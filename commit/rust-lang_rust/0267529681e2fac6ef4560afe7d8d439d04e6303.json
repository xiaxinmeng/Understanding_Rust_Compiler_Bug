{"sha": "0267529681e2fac6ef4560afe7d8d439d04e6303", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNjc1Mjk2ODFlMmZhYzZlZjQ1NjBhZmU3ZDhkNDM5ZDA0ZTYzMDM=", "commit": {"author": {"name": "Micha\u0142 Krasnoborski", "email": "mkrdln@gmail.com", "date": "2017-02-03T16:48:07Z"}, "committer": {"name": "Micha\u0142 Krasnoborski", "email": "mkrdln@gmail.com", "date": "2017-02-03T16:48:07Z"}, "message": "Merge remote-tracking branch 'upstream/master' into format-with-capacity", "tree": {"sha": "00bac1c7b714a59f1e4f230a64cb5427de2b62eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00bac1c7b714a59f1e4f230a64cb5427de2b62eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0267529681e2fac6ef4560afe7d8d439d04e6303", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0267529681e2fac6ef4560afe7d8d439d04e6303", "html_url": "https://github.com/rust-lang/rust/commit/0267529681e2fac6ef4560afe7d8d439d04e6303", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0267529681e2fac6ef4560afe7d8d439d04e6303/comments", "author": {"login": "krdln", "id": 3074996, "node_id": "MDQ6VXNlcjMwNzQ5OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/3074996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/krdln", "html_url": "https://github.com/krdln", "followers_url": "https://api.github.com/users/krdln/followers", "following_url": "https://api.github.com/users/krdln/following{/other_user}", "gists_url": "https://api.github.com/users/krdln/gists{/gist_id}", "starred_url": "https://api.github.com/users/krdln/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/krdln/subscriptions", "organizations_url": "https://api.github.com/users/krdln/orgs", "repos_url": "https://api.github.com/users/krdln/repos", "events_url": "https://api.github.com/users/krdln/events{/privacy}", "received_events_url": "https://api.github.com/users/krdln/received_events", "type": "User", "site_admin": false}, "committer": {"login": "krdln", "id": 3074996, "node_id": "MDQ6VXNlcjMwNzQ5OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/3074996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/krdln", "html_url": "https://github.com/krdln", "followers_url": "https://api.github.com/users/krdln/followers", "following_url": "https://api.github.com/users/krdln/following{/other_user}", "gists_url": "https://api.github.com/users/krdln/gists{/gist_id}", "starred_url": "https://api.github.com/users/krdln/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/krdln/subscriptions", "organizations_url": "https://api.github.com/users/krdln/orgs", "repos_url": "https://api.github.com/users/krdln/repos", "events_url": "https://api.github.com/users/krdln/events{/privacy}", "received_events_url": "https://api.github.com/users/krdln/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecda7f314fa79bbfbf2125c99fd66288ca83c875", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecda7f314fa79bbfbf2125c99fd66288ca83c875", "html_url": "https://github.com/rust-lang/rust/commit/ecda7f314fa79bbfbf2125c99fd66288ca83c875"}, {"sha": "aed6410a7b0f15dc68536e0735787436526ba395", "url": "https://api.github.com/repos/rust-lang/rust/commits/aed6410a7b0f15dc68536e0735787436526ba395", "html_url": "https://github.com/rust-lang/rust/commit/aed6410a7b0f15dc68536e0735787436526ba395"}], "stats": {"total": 12063, "additions": 7168, "deletions": 4895}, "files": [{"sha": "1ae0aae2d01baeb9664f244ececb7a3815145716", "filename": ".mailmap", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -43,8 +43,8 @@ Brian Anderson <banderson@mozilla.com> <andersrb@gmail.com>\n Brian Dawn <brian.t.dawn@gmail.com>\n Brian Leibig <brian@brianleibig.com> Brian Leibig <brian.leibig@gmail.com>\n Carl-Anton Ingmarsson <mail@carlanton.se> <ca.ingmarsson@gmail.com>\n-Carol (Nichols || Goulding) <carol.nichols@gmail.com> Carol Nichols <carol.nichols@gmail.com>\n-Carol (Nichols || Goulding) <carol.nichols@gmail.com> Carol Nichols <cnichols@thinkthroughmath.com>\n+Carol (Nichols || Goulding) <carol.nichols@gmail.com>\n+Carol (Nichols || Goulding) <cnichols@thinkthroughmath.com>\n Carol Willing <carolcode@willingconsulting.com>\n Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccerami@gmail.com>\n Chris Pressey <cpressey@gmail.com>\n@@ -53,6 +53,7 @@ Clark Gaebel <cg.wowus.cg@gmail.com> <cgaebel@mozilla.com>\n Clinton Ryan <clint.ryan3@gmail.com>\n Corey Farwell <coreyf+rust@rwell.org> Corey Farwell <coreyf@rwell.org>\n Corey Richardson <corey@octayn.net> Elaine \"See More\" Nemo <corey@octayn.net>\n+Cyryl P\u0142otnicki <cyplo@cyplo.net>\n Damien Schoof <damien.schoof@gmail.com>\n Daniel Ramos <dan@daramos.com>\n David Klein <david.klein@baesystemsdetica.com>\n@@ -102,6 +103,7 @@ Jason Toffaletti <toffaletti@gmail.com> Jason Toffaletti <jason@topsy.com>\n Jauhien Piatlicki <jauhien@gentoo.org> Jauhien Piatlicki <jpiatlicki@zertisa.com>\n Jay True <glacjay@gmail.com>\n Jeremy Letang <letang.jeremy@gmail.com>\n+Jethro Beekman <github@jbeekman.nl>\n Jihyun Yu <j.yu@navercorp.com> <yjh0502@gmail.com>\n Jihyun Yu <j.yu@navercorp.com> jihyun <jihyun@nablecomm.com>\n Jihyun Yu <j.yu@navercorp.com> Jihyun Yu <jihyun@nclab.kaist.ac.kr>\n@@ -165,6 +167,7 @@ O\u017ebolt Menegatti <ozbolt.menegatti@gmail.com> gareins <ozbolt.menegatti@gmail.c\n Paul Faria <paul_faria@ultimatesoftware.com> Paul Faria <Nashenas88@gmail.com>\n Peer Aramillo Irizar <peer.aramillo.irizar@gmail.com> parir <peer.aramillo.irizar@gmail.com>\n Peter Elmers <peter.elmers@yahoo.com> <peter.elmers@rice.edu>\n+Peter Liniker <peter.liniker+github@gmail.com>\n Peter Zotov <whitequark@whitequark.org>\n Phil Dawes <phil@phildawes.net> Phil Dawes <pdawes@drw.com>\n Philipp Br\u00fcschweiler <blei42@gmail.com> <blei42@gmail.com>"}, {"sha": "ea405413e78f4278871844f38bd5c798de2c1c4c", "filename": ".travis.yml", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -35,6 +35,7 @@ matrix:\n     - env: IMAGE=x86_64-gnu-make\n     - env: IMAGE=x86_64-gnu-llvm-3.7 ALLOW_PR=1 RUST_BACKTRACE=1\n     - env: IMAGE=x86_64-gnu-distcheck\n+    - env: IMAGE=x86_64-gnu-incremental\n \n     # OSX builders\n     - env: >\n@@ -43,17 +44,9 @@ matrix:\n         SRC=.\n       os: osx\n       osx_image: xcode8.2\n-      before_script: &osx_before_script >\n-        ulimit -c unlimited\n       install: &osx_install_sccache >\n         curl -L https://api.pub.build.mozilla.org/tooltool/sha512/d0025b286468cc5ada83b23d3fafbc936b9f190eaa7d4a981715b18e8e3bf720a7bcee7bfe758cfdeb8268857f6098fd52dcdd8818232692a30ce91039936596 |\n           tar xJf - -C /usr/local/bin --strip-components=1\n-      after_failure: &osx_after_failure >\n-        echo 'bt all' > cmds;\n-        for file in $(ls /cores); do\n-          echo core file $file;\n-          lldb -c /cores/$file `which ld` -b -s cmds;\n-        done\n \n     - env: >\n         SCRIPT=\"./x.py test && ./x.py dist\"\n@@ -62,28 +55,22 @@ matrix:\n         DEPLOY=1\n       os: osx\n       osx_image: xcode8.2\n-      before_script: *osx_before_script\n       install: *osx_install_sccache\n-      after_failure: *osx_after_failure\n     - env: >\n         RUST_CHECK_TARGET=check\n         RUST_CONFIGURE_ARGS=--build=x86_64-apple-darwin --disable-rustbuild\n         SRC=.\n       os: osx\n       osx_image: xcode8.2\n-      before_script: *osx_before_script\n       install: *osx_install_sccache\n-      after_failure: *osx_after_failure\n     - env: >\n         RUST_CHECK_TARGET=dist\n         RUST_CONFIGURE_ARGS=\"--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-extended\"\n         SRC=.\n         DEPLOY=1\n       os: osx\n       osx_image: xcode8.2\n-      before_script: *osx_before_script\n       install: *osx_install_sccache\n-      after_failure: *osx_after_failure\n \n env:\n   global:\n@@ -124,9 +111,11 @@ before_deploy:\n   - mkdir -p deploy/$TRAVIS_COMMIT\n   - >\n       if [ \"$TRAVIS_OS_NAME\" == \"osx\" ]; then\n-          cp build/dist/*.tar.gz deploy/$TRAVIS_COMMIT;\n+          rm -rf build/dist/doc &&\n+          cp -r build/dist/* deploy/$TRAVIS_COMMIT;\n       else\n-          cp obj/build/dist/*.tar.gz deploy/$TRAVIS_COMMIT;\n+          rm -rf obj/build/dist/doc &&\n+          cp -r obj/build/dist/* deploy/$TRAVIS_COMMIT;\n       fi\n \n deploy:"}, {"sha": "c617ac8a4e342d061e97209403d25d582952f6aa", "filename": "appveyor.yml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -137,7 +137,8 @@ branches:\n before_deploy:\n   - ps: |\n         New-Item -Path deploy -ItemType directory\n-        Get-ChildItem -Path build\\dist -Filter '*.tar.gz' | Move-Item -Destination deploy\n+        Remove-Item -Recurse -Force build\\dist\\doc\n+        Get-ChildItem -Path build\\dist | Move-Item -Destination deploy\n         Get-ChildItem -Path deploy | Foreach-Object {\n           Push-AppveyorArtifact $_.FullName -FileName ${env:APPVEYOR_REPO_COMMIT}/$_\n         }\n@@ -151,7 +152,7 @@ deploy:\n     bucket: rust-lang-ci\n     set_public: true\n     region: us-east-1\n-    artifact: /.*\\.tar.gz/\n+    artifact: /.*/\n     folder: rustc-builds\n     on:\n       branch: auto"}, {"sha": "c058586410dac9d27a643dbdedef185fcd70a6d4", "filename": "src/Cargo.lock", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -50,9 +50,20 @@ dependencies = [\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"build-manifest\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"build_helper\"\n version = \"0.1.0\"\n+dependencies = [\n+ \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n \n [[package]]\n name = \"cargotest\"\n@@ -586,7 +597,7 @@ dependencies = [\n \n [[package]]\n name = \"std_shim\"\n-version = \"0.1.0\"\n+version = \"0.0.0\"\n dependencies = [\n  \"core 0.0.0\",\n  \"std 0.0.0\",\n@@ -645,7 +656,7 @@ dependencies = [\n \n [[package]]\n name = \"test_shim\"\n-version = \"0.1.0\"\n+version = \"0.0.0\"\n dependencies = [\n  \"test 0.0.0\",\n ]"}, {"sha": "0db26ea5ae021ae7219884994b9dbc0a025c8853", "filename": "src/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -10,6 +10,7 @@ members = [\n   \"tools/linkchecker\",\n   \"tools/rustbook\",\n   \"tools/tidy\",\n+  \"tools/build-manifest\",\n ]\n \n # Curiously, compiletest will segfault if compiled with opt-level=3 on 64-bit"}, {"sha": "19aac0f36bb27e59c2a035d7ccca2d9453c48dc9", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -383,7 +383,7 @@ pub fn krate(build: &Build,\n                 // helper crate, not tested. If it leaks through then it ends up\n                 // messing with various mtime calculations and such.\n                 if !name.contains(\"jemalloc\") && name != \"build_helper\" {\n-                    cargo.arg(\"-p\").arg(name);\n+                    cargo.arg(\"-p\").arg(&format!(\"{}:0.0.0\", name));\n                 }\n                 for dep in build.crates[name].deps.iter() {\n                     if visited.insert(dep) {"}, {"sha": "776b91028a1a3a5ea0fb780ca9e041e19c111a10", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -21,10 +21,10 @@ use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n-use build_helper::output;\n+use build_helper::{output, mtime};\n use filetime::FileTime;\n \n-use util::{exe, libdir, mtime, is_dylib, copy};\n+use util::{exe, libdir, is_dylib, copy};\n use {Build, Compiler, Mode};\n \n /// Build the standard library."}, {"sha": "6e077691b3a058fe7c91c0162dd738cfd516676a", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -78,6 +78,11 @@ pub struct Config {\n     pub cargo: Option<PathBuf>,\n     pub local_rebuild: bool,\n \n+    // dist misc\n+    pub dist_sign_folder: Option<PathBuf>,\n+    pub dist_upload_addr: Option<String>,\n+    pub dist_gpg_password_file: Option<PathBuf>,\n+\n     // libstd features\n     pub debug_jemalloc: bool,\n     pub use_jemalloc: bool,\n@@ -123,6 +128,7 @@ struct TomlConfig {\n     llvm: Option<Llvm>,\n     rust: Option<Rust>,\n     target: Option<HashMap<String, TomlTarget>>,\n+    dist: Option<Dist>,\n }\n \n /// TOML representation of various global build decisions.\n@@ -166,6 +172,13 @@ struct Llvm {\n     targets: Option<String>,\n }\n \n+#[derive(RustcDecodable, Default, Clone)]\n+struct Dist {\n+    sign_folder: Option<String>,\n+    gpg_password_file: Option<String>,\n+    upload_addr: Option<String>,\n+}\n+\n #[derive(RustcDecodable)]\n enum StringOrBool {\n     String(String),\n@@ -352,6 +365,12 @@ impl Config {\n             }\n         }\n \n+        if let Some(ref t) = toml.dist {\n+            config.dist_sign_folder = t.sign_folder.clone().map(PathBuf::from);\n+            config.dist_gpg_password_file = t.gpg_password_file.clone().map(PathBuf::from);\n+            config.dist_upload_addr = t.upload_addr.clone();\n+        }\n+\n         return config\n     }\n \n@@ -497,7 +516,7 @@ impl Config {\n                 \"CFG_JEMALLOC_ROOT\" if value.len() > 0 => {\n                     let target = self.target_config.entry(self.build.clone())\n                                      .or_insert(Target::default());\n-                    target.jemalloc = Some(parse_configure_path(value));\n+                    target.jemalloc = Some(parse_configure_path(value).join(\"libjemalloc_pic.a\"));\n                 }\n                 \"CFG_ARM_LINUX_ANDROIDEABI_NDK\" if value.len() > 0 => {\n                     let target = \"arm-linux-androideabi\".to_string();"}, {"sha": "a53419ad7fd780a28b41fcf6433a5081510187bc", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -242,3 +242,33 @@\n # that this option only makes sense for MUSL targets that produce statically\n # linked binaries\n #musl-root = \"...\"\n+\n+# =============================================================================\n+# Distribution options\n+#\n+# These options are related to distribution, mostly for the Rust project itself.\n+# You probably won't need to concern yourself with any of these options\n+# =============================================================================\n+[dist]\n+\n+# This is the folder of artifacts that the build system will sign. All files in\n+# this directory will be signed with the default gpg key using the system `gpg`\n+# binary. The `asc` and `sha256` files will all be output into the standard dist\n+# output folder (currently `build/dist`)\n+#\n+# This folder should be populated ahead of time before the build system is\n+# invoked.\n+#sign-folder = \"path/to/folder/to/sign\"\n+\n+# This is a file which contains the password of the default gpg key. This will\n+# be passed to `gpg` down the road when signing all files in `sign-folder`\n+# above. This should be stored in plaintext.\n+#gpg-password-file = \"path/to/gpg/password\"\n+\n+# The remote address that all artifacts will eventually be uploaded to. The\n+# build system generates manifests which will point to these urls, and for the\n+# manifests to be correct they'll have to have the right URLs encoded.\n+#\n+# Note that this address should not contain a trailing slash as file names will\n+# be appended to it.\n+#upload-addr = \"https://example.com/folder\""}, {"sha": "5fac142f777ff2b71893a93e3b8f8ce7fad95b81", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -22,7 +22,7 @@ use std::env;\n use std::fs::{self, File};\n use std::io::{Read, Write};\n use std::path::{PathBuf, Path};\n-use std::process::Command;\n+use std::process::{Command, Stdio};\n \n use build_helper::output;\n \n@@ -827,7 +827,7 @@ pub fn extended(build: &Build, stage: u32, target: &str) {\n         cmd.arg(\"-nologo\")\n            .arg(\"-ext\").arg(\"WixUIExtension\")\n            .arg(\"-ext\").arg(\"WixUtilExtension\")\n-           .arg(\"-out\").arg(distdir(build).join(filename))\n+           .arg(\"-out\").arg(exe.join(&filename))\n            .arg(\"rust.wixobj\")\n            .arg(\"ui.wixobj\")\n            .arg(\"rustwelcomedlg.wixobj\")\n@@ -844,6 +844,8 @@ pub fn extended(build: &Build, stage: u32, target: &str) {\n         cmd.arg(\"-sice:ICE57\");\n \n         build.run(&mut cmd);\n+\n+        t!(fs::rename(exe.join(&filename), distdir(build).join(&filename)));\n     }\n }\n \n@@ -876,3 +878,34 @@ fn add_env(build: &Build, cmd: &mut Command, target: &str) {\n        cmd.env(\"CFG_PLATFORM\", \"x86\");\n     }\n }\n+\n+pub fn hash_and_sign(build: &Build) {\n+    let compiler = Compiler::new(0, &build.config.build);\n+    let mut cmd = build.tool_cmd(&compiler, \"build-manifest\");\n+    let sign = build.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n+        panic!(\"\\n\\nfailed to specify `dist.sign-folder` in `config.toml`\\n\\n\")\n+    });\n+    let addr = build.config.dist_upload_addr.as_ref().unwrap_or_else(|| {\n+        panic!(\"\\n\\nfailed to specify `dist.upload-addr` in `config.toml`\\n\\n\")\n+    });\n+    let file = build.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n+        panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n+    });\n+    let mut pass = String::new();\n+    t!(t!(File::open(&file)).read_to_string(&mut pass));\n+\n+    let today = output(Command::new(\"date\").arg(\"+%Y-%m-%d\"));\n+\n+    cmd.arg(sign);\n+    cmd.arg(distdir(build));\n+    cmd.arg(today.trim());\n+    cmd.arg(package_vers(build));\n+    cmd.arg(addr);\n+\n+    t!(fs::create_dir_all(distdir(build)));\n+\n+    let mut child = t!(cmd.stdin(Stdio::piped()).spawn());\n+    t!(child.stdin.take().unwrap().write_all(pass.as_bytes()));\n+    let status = t!(child.wait());\n+    assert!(status.success());\n+}"}, {"sha": "3dc9b8375550c1b8021d4489183fea2109b8e9c6", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -22,7 +22,8 @@ use std::io::prelude::*;\n use std::process::Command;\n \n use {Build, Compiler, Mode};\n-use util::{up_to_date, cp_r};\n+use util::cp_r;\n+use build_helper::up_to_date;\n \n /// Invoke `rustbook` as compiled in `stage` for `target` for the doc book\n /// `name` into the `out` path."}, {"sha": "df1218752d1c9bb52a3263796b01fbd5878ef43e", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -66,6 +66,7 @@\n \n #![deny(warnings)]\n \n+#[macro_use]\n extern crate build_helper;\n extern crate cmake;\n extern crate filetime;\n@@ -83,24 +84,9 @@ use std::fs::{self, File};\n use std::path::{Component, PathBuf, Path};\n use std::process::Command;\n \n-use build_helper::{run_silent, output};\n+use build_helper::{run_silent, output, mtime};\n \n-use util::{exe, mtime, libdir, add_lib_path};\n-\n-/// A helper macro to `unwrap` a result except also print out details like:\n-///\n-/// * The file/line of the panic\n-/// * The expression that failed\n-/// * The error itself\n-///\n-/// This is currently used judiciously throughout the build system rather than\n-/// using a `Result` with `try!`, but this may change one day...\n-macro_rules! t {\n-    ($e:expr) => (match $e {\n-        Ok(e) => e,\n-        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n-    })\n-}\n+use util::{exe, libdir, add_lib_path};\n \n mod cc;\n mod channel;\n@@ -482,7 +468,8 @@ impl Build {\n         //\n         // These variables are primarily all read by\n         // src/bootstrap/bin/{rustc.rs,rustdoc.rs}\n-        cargo.env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n+        cargo.env(\"RUSTBUILD_NATIVE_DIR\", self.native_dir(target))\n+             .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n              .env(\"RUSTC_REAL\", self.compiler_path(compiler))\n              .env(\"RUSTC_STAGE\", stage.to_string())\n              .env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string())\n@@ -746,10 +733,15 @@ impl Build {\n         }\n     }\n \n+    /// Directory for libraries built from C/C++ code and shared between stages.\n+    fn native_dir(&self, target: &str) -> PathBuf {\n+        self.out.join(target).join(\"native\")\n+    }\n+\n     /// Root output directory for rust_test_helpers library compiled for\n     /// `target`\n     fn test_helpers_out(&self, target: &str) -> PathBuf {\n-        self.out.join(target).join(\"rust-test-helpers\")\n+        self.native_dir(target).join(\"rust-test-helpers\")\n     }\n \n     /// Adds the compiler's directory of dynamic libraries to `cmd`'s dynamic"}, {"sha": "21fc61cc81484da74ba0eafa9b76ed8ba2e14be8", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -28,7 +28,8 @@ use cmake;\n use gcc;\n \n use Build;\n-use util::{self, up_to_date};\n+use util;\n+use build_helper::up_to_date;\n \n /// Compile LLVM for `target`.\n pub fn llvm(build: &Build, target: &str) {"}, {"sha": "3932a7cf8c56376c32af9a2a6938abcf9a31cc75", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -513,6 +513,9 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     rules.build(\"tool-compiletest\", \"src/tools/compiletest\")\n          .dep(|s| s.name(\"libtest\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"compiletest\"));\n+    rules.build(\"tool-build-manifest\", \"src/tools/build-manifest\")\n+         .dep(|s| s.name(\"libstd\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"build-manifest\"));\n \n     // ========================================================================\n     // Documentation targets\n@@ -633,6 +636,13 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .dep(|d| d.name(\"dist-cargo\"))\n          .run(move |s| dist::extended(build, s.stage, s.target));\n \n+    rules.dist(\"dist-sign\", \"hash-and-sign\")\n+         .host(true)\n+         .only_build(true)\n+         .only_host_build(true)\n+         .dep(move |s| s.name(\"tool-build-manifest\").target(&build.config.build).stage(0))\n+         .run(move |_| dist::hash_and_sign(build));\n+\n     rules.verify();\n     return rules;\n }"}, {"sha": "520514f5fc95a77871ad6db413d9b30e5ad56fd8", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -20,8 +20,6 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::Instant;\n \n-use filetime::FileTime;\n-\n /// Returns the `name` as the filename of a static library for `target`.\n pub fn staticlib(name: &str, target: &str) -> String {\n     if target.contains(\"windows\") {\n@@ -31,13 +29,6 @@ pub fn staticlib(name: &str, target: &str) -> String {\n     }\n }\n \n-/// Returns the last-modified time for `path`, or zero if it doesn't exist.\n-pub fn mtime(path: &Path) -> FileTime {\n-    fs::metadata(path).map(|f| {\n-        FileTime::from_last_modification_time(&f)\n-    }).unwrap_or(FileTime::zero())\n-}\n-\n /// Copies a file from `src` to `dst`, attempting to use hard links and then\n /// falling back to an actually filesystem copy if necessary.\n pub fn copy(src: &Path, dst: &Path) {\n@@ -132,34 +123,6 @@ pub fn add_lib_path(path: Vec<PathBuf>, cmd: &mut Command) {\n     cmd.env(dylib_path_var(), t!(env::join_paths(list)));\n }\n \n-/// Returns whether `dst` is up to date given that the file or files in `src`\n-/// are used to generate it.\n-///\n-/// Uses last-modified time checks to verify this.\n-pub fn up_to_date(src: &Path, dst: &Path) -> bool {\n-    let threshold = mtime(dst);\n-    let meta = match fs::metadata(src) {\n-        Ok(meta) => meta,\n-        Err(e) => panic!(\"source {:?} failed to get metadata: {}\", src, e),\n-    };\n-    if meta.is_dir() {\n-        dir_up_to_date(src, &threshold)\n-    } else {\n-        FileTime::from_last_modification_time(&meta) <= threshold\n-    }\n-}\n-\n-fn dir_up_to_date(src: &Path, threshold: &FileTime) -> bool {\n-    t!(fs::read_dir(src)).map(|e| t!(e)).all(|e| {\n-        let meta = t!(e.metadata());\n-        if meta.is_dir() {\n-            dir_up_to_date(&e.path(), threshold)\n-        } else {\n-            FileTime::from_last_modification_time(&meta) < *threshold\n-        }\n-    })\n-}\n-\n /// Returns the environment variable which the dynamic library lookup path\n /// resides in for this platform.\n pub fn dylib_path_var() -> &'static str {"}, {"sha": "f8ade0616a577a44f7bb0c970d855a99f3b58937", "filename": "src/build_helper/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbuild_helper%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbuild_helper%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2FCargo.toml?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -6,3 +6,6 @@ authors = [\"The Rust Project Developers\"]\n [lib]\n name = \"build_helper\"\n path = \"lib.rs\"\n+\n+[dependencies]\n+filetime = \"0.1\""}, {"sha": "3dfd29380828669ec75eb22b563baf3b6c91f5e6", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -10,9 +10,30 @@\n \n #![deny(warnings)]\n \n+extern crate filetime;\n+\n+use std::fs;\n use std::process::{Command, Stdio};\n use std::path::{Path, PathBuf};\n \n+use filetime::FileTime;\n+\n+/// A helper macro to `unwrap` a result except also print out details like:\n+///\n+/// * The file/line of the panic\n+/// * The expression that failed\n+/// * The error itself\n+///\n+/// This is currently used judiciously throughout the build system rather than\n+/// using a `Result` with `try!`, but this may change one day...\n+#[macro_export]\n+macro_rules! t {\n+    ($e:expr) => (match $e {\n+        Ok(e) => e,\n+        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n+    })\n+}\n+\n pub fn run(cmd: &mut Command) {\n     println!(\"running: {:?}\", cmd);\n     run_silent(cmd);\n@@ -88,6 +109,56 @@ pub fn output(cmd: &mut Command) -> String {\n     String::from_utf8(output.stdout).unwrap()\n }\n \n+pub fn rerun_if_changed_anything_in_dir(dir: &Path) {\n+    let mut stack = dir.read_dir().unwrap()\n+                       .map(|e| e.unwrap())\n+                       .filter(|e| &*e.file_name() != \".git\")\n+                       .collect::<Vec<_>>();\n+    while let Some(entry) = stack.pop() {\n+        let path = entry.path();\n+        if entry.file_type().unwrap().is_dir() {\n+            stack.extend(path.read_dir().unwrap().map(|e| e.unwrap()));\n+        } else {\n+            println!(\"cargo:rerun-if-changed={}\", path.display());\n+        }\n+    }\n+}\n+\n+/// Returns the last-modified time for `path`, or zero if it doesn't exist.\n+pub fn mtime(path: &Path) -> FileTime {\n+    fs::metadata(path).map(|f| {\n+        FileTime::from_last_modification_time(&f)\n+    }).unwrap_or(FileTime::zero())\n+}\n+\n+/// Returns whether `dst` is up to date given that the file or files in `src`\n+/// are used to generate it.\n+///\n+/// Uses last-modified time checks to verify this.\n+pub fn up_to_date(src: &Path, dst: &Path) -> bool {\n+    let threshold = mtime(dst);\n+    let meta = match fs::metadata(src) {\n+        Ok(meta) => meta,\n+        Err(e) => panic!(\"source {:?} failed to get metadata: {}\", src, e),\n+    };\n+    if meta.is_dir() {\n+        dir_up_to_date(src, &threshold)\n+    } else {\n+        FileTime::from_last_modification_time(&meta) <= threshold\n+    }\n+}\n+\n+fn dir_up_to_date(src: &Path, threshold: &FileTime) -> bool {\n+    t!(fs::read_dir(src)).map(|e| t!(e)).all(|e| {\n+        let meta = t!(e.metadata());\n+        if meta.is_dir() {\n+            dir_up_to_date(&e.path(), threshold)\n+        } else {\n+            FileTime::from_last_modification_time(&meta) < *threshold\n+        }\n+    })\n+}\n+\n fn fail(s: &str) -> ! {\n     println!(\"\\n\\n{}\\n\\n\", s);\n     std::process::exit(1);"}, {"sha": "52f74ba90de6ef0787b96170d128cb1f56c515da", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -143,3 +143,58 @@ For targets: `aarch64-unknown-linux-gnu`\n - C-library > glibc version = 2.17 -- aarch64 support was introduced in this version\n - C compiler > gcc version = 5.2.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n+\n+## `powerpc-linux-gnu.config`\n+\n+For targets: `powerpc-unknown-linux-gnu`\n+\n+- Path and misc options > Prefix directory = /x-tools/${CT\\_TARGET}\n+- Path and misc options > Patches origin = Bundled, then local\n+- Path and misc options > Local patch directory = /tmp/patches\n+- Target options > Target Architecture = powerpc\n+- Target options > Emit assembly for CPU = power4 -- (+)\n+- Target options > Tune for CPU = power6 -- (+)\n+- Operating System > Target OS = linux\n+- Operating System > Linux kernel version = 2.6.32.68 -- ~RHEL6 kernel\n+- C-library > glibc version = 2.12.2 -- ~RHEL6 glibc\n+- C compiler > gcc version = 4.9.3\n+- C compiler > Core gcc extra config = --with-cpu-32=power4 --with-cpu=default32 -- (+)\n+- C compiler > gcc extra config = --with-cpu-32=power4 --with-cpu=default32 -- (+)\n+- C compiler > C++ = ENABLE -- to cross compile LLVM\n+\n+(+) These CPU options match the configuration of the toolchains in RHEL6.\n+\n+## `powerpc64-linux-gnu.config`\n+\n+For targets: `powerpc64-unknown-linux-gnu`\n+\n+- Path and misc options > Prefix directory = /x-tools/${CT\\_TARGET}\n+- Path and misc options > Patches origin = Bundled, then local\n+- Path and misc options > Local patch directory = /tmp/patches\n+- Target options > Target Architecture = powerpc\n+- Target options > Bitness = 64-bit\n+- Target options > Emit assembly for CPU = power4 -- (+)\n+- Target options > Tune for CPU = power6 -- (+)\n+- Operating System > Target OS = linux\n+- Operating System > Linux kernel version = 2.6.32.68 -- ~RHEL6 kernel\n+- C-library > glibc version = 2.12.2 -- ~RHEL6 glibc\n+- C compiler > gcc version = 4.9.3\n+- C compiler > C++ = ENABLE -- to cross compile LLVM\n+\n+(+) These CPU options match the configuration of the toolchains in RHEL6.\n+\n+## `s390x-linux-gnu.config`\n+\n+For targets: `s390x-unknown-linux-gnu`\n+\n+- Path and misc options > Prefix directory = /x-tools/${CT\\_TARGET}\n+- Path and misc options > Patches origin = Bundled, then local\n+- Path and misc options > Local patch directory = /build/patches\n+- Target options > Target Architecture = s390\n+- Target options > Bitness = 64-bit\n+- Operating System > Target OS = linux\n+- Operating System > Linux kernel version = 2.6.32.68 -- ~RHEL6 kernel\n+- C-library > glibc version = 2.12.2 -- ~RHEL6 glibc\n+- C compiler > gcc version = 4.9.3\n+- C compiler > gcc extra config = --with-arch=z10 -- LLVM's minimum support\n+- C compiler > C++ = ENABLE -- to cross compile LLVM"}, {"sha": "640bacc54eb30b1d8ba65233c45ec6a09535372b", "filename": "src/ci/docker/dist-powerpc-linux/Dockerfile", "status": "modified", "additions": 56, "deletions": 8, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -1,18 +1,29 @@\n FROM ubuntu:16.04\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  automake \\\n+  bison \\\n+  bzip2 \\\n+  ca-certificates \\\n+  cmake \\\n+  curl \\\n+  file \\\n+  flex \\\n   g++ \\\n+  gawk \\\n+  gdb \\\n+  git \\\n+  gperf \\\n+  help2man \\\n+  libncurses-dev \\\n+  libtool-bin \\\n   make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n+  patch \\\n   python2.7 \\\n-  git \\\n-  cmake \\\n   sudo \\\n-  gdb \\\n-  xz-utils \\\n-  g++-powerpc-linux-gnu\n+  texinfo \\\n+  wget \\\n+  xz-utils\n \n ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n@@ -23,6 +34,43 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n     rm dumb-init_*.deb\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n+# Ubuntu 16.04 (this contianer) ships with make 4, but something in the\n+# toolchains we build below chokes on that, so go back to make 3\n+RUN curl https://ftp.gnu.org/gnu/make/make-3.81.tar.gz | tar xzf - && \\\n+      cd make-3.81 && \\\n+      ./configure --prefix=/usr && \\\n+      make && \\\n+      make install && \\\n+      cd .. && \\\n+      rm -rf make-3.81\n+\n+RUN curl http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-1.22.0.tar.bz2 | \\\n+      tar xjf - && \\\n+      cd crosstool-ng && \\\n+      ./configure --prefix=/usr/local && \\\n+      make -j$(nproc) && \\\n+      make install && \\\n+      cd .. && \\\n+      rm -rf crosstool-ng\n+\n+RUN groupadd -r rustbuild && useradd -m -r -g rustbuild rustbuild\n+RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n+USER rustbuild\n+WORKDIR /tmp\n+\n+COPY patches/ /tmp/patches/\n+COPY powerpc-linux-gnu.config build-powerpc-toolchain.sh /tmp/\n+RUN ./build-powerpc-toolchain.sh\n+\n+USER root\n+\n+ENV PATH=$PATH:/x-tools/powerpc-unknown-linux-gnu/bin\n+\n+ENV \\\n+    CC_powerpc_unknown_linux_gnu=powerpc-unknown-linux-gnu-gcc \\\n+    AR_powerpc_unknown_linux_gnu=powerpc-unknown-linux-gnu-ar \\\n+    CXX_powerpc_unknown_linux_gnu=powerpc-unknown-linux-gnu-g++\n+\n ENV HOSTS=powerpc-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended"}, {"sha": "90a4df0c19583d9a878cd314bb153deebe4f1129", "filename": "src/ci/docker/dist-powerpc-linux/build-powerpc-toolchain.sh", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fbuild-powerpc-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fbuild-powerpc-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fbuild-powerpc-toolchain.sh?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,36 @@\n+#!/bin/bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+hide_output() {\n+  set +x\n+  on_err=\"\n+echo ERROR: An error was encountered with the build.\n+cat /tmp/build.log\n+exit 1\n+\"\n+  trap \"$on_err\" ERR\n+  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n+  PING_LOOP_PID=$!\n+  $@ &> /tmp/build.log\n+  rm /tmp/build.log\n+  trap - ERR\n+  kill $PING_LOOP_PID\n+  set -x\n+}\n+\n+mkdir build\n+cd build\n+cp ../powerpc-linux-gnu.config .config\n+hide_output ct-ng build\n+cd ..\n+rm -rf build"}, {"sha": "744eb180cd1f670cd52f3b47ccce8ce645e20a91", "filename": "src/ci/docker/dist-powerpc-linux/patches/glibc/2.12.2/001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,24 @@\n+From b3563932f85d60bb0d38b0a5f3b8f4abc133f890 Mon Sep 17 00:00:00 2001\n+From: Tulio Magno Quites Machado Filho <tuliom@linux.vnet.ibm.com>\n+Date: Thu, 1 Nov 2012 18:00:06 -0500\n+Subject: [PATCH] PowerPC: Remove unnecessary -mnew-mnemonics.\n+\n+---\n+ sysdeps/powerpc/Makefile | 4 ----\n+ 1 file changed, 4 deletions(-)\n+\n+diff --git a/sysdeps/powerpc/Makefile b/sysdeps/powerpc/Makefile\n+index 79dd6fa976d5..7442b6709ad1 100644\n+--- a/sysdeps/powerpc/Makefile\n++++ b/sysdeps/powerpc/Makefile\n+@@ -1,7 +1,3 @@\n+-# We always want to use the new mnemonic syntax even if we are on a RS6000\n+-# machine.\n+-+cflags += -mnew-mnemonics\n+-\n+ ifeq ($(subdir),gmon)\n+ sysdep_routines += ppc-mcount\n+ endif\n+-- \n+2.9.3\n+"}, {"sha": "26e2de863a0f97bf073c157de7539238df4551a2", "filename": "src/ci/docker/dist-powerpc-linux/powerpc-linux-gnu.config", "status": "added", "additions": 528, "deletions": 0, "changes": 528, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fpowerpc-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fpowerpc-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2Fpowerpc-linux-gnu.config?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,528 @@\n+#\n+# Automatically generated file; DO NOT EDIT.\n+# Crosstool-NG Configuration\n+#\n+CT_CONFIGURE_has_make381=y\n+CT_CONFIGURE_has_xz=y\n+CT_MODULES=y\n+\n+#\n+# Paths and misc options\n+#\n+\n+#\n+# crosstool-NG behavior\n+#\n+# CT_OBSOLETE is not set\n+# CT_EXPERIMENTAL is not set\n+# CT_DEBUG_CT is not set\n+\n+#\n+# Paths\n+#\n+CT_LOCAL_TARBALLS_DIR=\"\"\n+CT_WORK_DIR=\"${CT_TOP_DIR}/.build\"\n+CT_PREFIX_DIR=\"/x-tools/${CT_TARGET}\"\n+CT_INSTALL_DIR=\"${CT_PREFIX_DIR}\"\n+CT_RM_RF_PREFIX_DIR=y\n+CT_REMOVE_DOCS=y\n+CT_INSTALL_DIR_RO=y\n+CT_STRIP_HOST_TOOLCHAIN_EXECUTABLES=y\n+# CT_STRIP_TARGET_TOOLCHAIN_EXECUTABLES is not set\n+\n+#\n+# Downloading\n+#\n+# CT_FORBID_DOWNLOAD is not set\n+# CT_FORCE_DOWNLOAD is not set\n+CT_CONNECT_TIMEOUT=10\n+# CT_ONLY_DOWNLOAD is not set\n+# CT_USE_MIRROR is not set\n+\n+#\n+# Extracting\n+#\n+# CT_FORCE_EXTRACT is not set\n+CT_OVERIDE_CONFIG_GUESS_SUB=y\n+# CT_ONLY_EXTRACT is not set\n+# CT_PATCH_BUNDLED is not set\n+# CT_PATCH_LOCAL is not set\n+CT_PATCH_BUNDLED_LOCAL=y\n+# CT_PATCH_LOCAL_BUNDLED is not set\n+# CT_PATCH_BUNDLED_FALLBACK_LOCAL is not set\n+# CT_PATCH_LOCAL_FALLBACK_BUNDLED is not set\n+# CT_PATCH_NONE is not set\n+CT_PATCH_ORDER=\"bundled,local\"\n+CT_PATCH_USE_LOCAL=y\n+CT_LOCAL_PATCH_DIR=\"/tmp/patches\"\n+\n+#\n+# Build behavior\n+#\n+CT_PARALLEL_JOBS=0\n+CT_LOAD=\"\"\n+CT_USE_PIPES=y\n+CT_EXTRA_CFLAGS_FOR_BUILD=\"\"\n+CT_EXTRA_LDFLAGS_FOR_BUILD=\"\"\n+CT_EXTRA_CFLAGS_FOR_HOST=\"\"\n+CT_EXTRA_LDFLAGS_FOR_HOST=\"\"\n+# CT_CONFIG_SHELL_SH is not set\n+# CT_CONFIG_SHELL_ASH is not set\n+CT_CONFIG_SHELL_BASH=y\n+# CT_CONFIG_SHELL_CUSTOM is not set\n+CT_CONFIG_SHELL=\"${bash}\"\n+\n+#\n+# Logging\n+#\n+# CT_LOG_ERROR is not set\n+# CT_LOG_WARN is not set\n+CT_LOG_INFO=y\n+# CT_LOG_EXTRA is not set\n+# CT_LOG_ALL is not set\n+# CT_LOG_DEBUG is not set\n+CT_LOG_LEVEL_MAX=\"INFO\"\n+# CT_LOG_SEE_TOOLS_WARN is not set\n+CT_LOG_PROGRESS_BAR=y\n+CT_LOG_TO_FILE=y\n+CT_LOG_FILE_COMPRESS=y\n+\n+#\n+# Target options\n+#\n+CT_ARCH=\"powerpc\"\n+CT_ARCH_SUPPORTS_BOTH_ENDIAN=y\n+CT_ARCH_SUPPORTS_32=y\n+CT_ARCH_SUPPORTS_64=y\n+CT_ARCH_SUPPORTS_WITH_ABI=y\n+CT_ARCH_SUPPORTS_WITH_CPU=y\n+CT_ARCH_SUPPORTS_WITH_TUNE=y\n+CT_ARCH_SUPPORTS_WITH_FLOAT=y\n+CT_ARCH_DEFAULT_BE=y\n+CT_ARCH_DEFAULT_32=y\n+CT_ARCH_ABI=\"\"\n+CT_ARCH_CPU=\"power4\"\n+CT_ARCH_TUNE=\"power6\"\n+CT_ARCH_BE=y\n+# CT_ARCH_LE is not set\n+CT_ARCH_32=y\n+# CT_ARCH_64 is not set\n+CT_ARCH_BITNESS=32\n+# CT_ARCH_FLOAT_HW is not set\n+# CT_ARCH_FLOAT_SW is not set\n+CT_TARGET_CFLAGS=\"\"\n+CT_TARGET_LDFLAGS=\"\"\n+# CT_ARCH_alpha is not set\n+# CT_ARCH_arm is not set\n+# CT_ARCH_avr is not set\n+# CT_ARCH_m68k is not set\n+# CT_ARCH_mips is not set\n+# CT_ARCH_nios2 is not set\n+CT_ARCH_powerpc=y\n+# CT_ARCH_s390 is not set\n+# CT_ARCH_sh is not set\n+# CT_ARCH_sparc is not set\n+# CT_ARCH_x86 is not set\n+# CT_ARCH_xtensa is not set\n+CT_ARCH_alpha_AVAILABLE=y\n+CT_ARCH_arm_AVAILABLE=y\n+CT_ARCH_avr_AVAILABLE=y\n+CT_ARCH_m68k_AVAILABLE=y\n+CT_ARCH_microblaze_AVAILABLE=y\n+CT_ARCH_mips_AVAILABLE=y\n+CT_ARCH_nios2_AVAILABLE=y\n+CT_ARCH_powerpc_AVAILABLE=y\n+CT_ARCH_s390_AVAILABLE=y\n+CT_ARCH_sh_AVAILABLE=y\n+CT_ARCH_sparc_AVAILABLE=y\n+CT_ARCH_x86_AVAILABLE=y\n+CT_ARCH_xtensa_AVAILABLE=y\n+CT_ARCH_SUFFIX=\"\"\n+\n+#\n+# Generic target options\n+#\n+# CT_MULTILIB is not set\n+CT_ARCH_USE_MMU=y\n+CT_ARCH_ENDIAN=\"big\"\n+\n+#\n+# Target optimisations\n+#\n+CT_ARCH_FLOAT_AUTO=y\n+CT_ARCH_FLOAT=\"auto\"\n+\n+#\n+# powerpc other options\n+#\n+CT_ARCH_powerpc_ABI=\"\"\n+CT_ARCH_powerpc_ABI_DEFAULT=y\n+# CT_ARCH_powerpc_ABI_SPE is not set\n+\n+#\n+# Toolchain options\n+#\n+\n+#\n+# General toolchain options\n+#\n+CT_FORCE_SYSROOT=y\n+CT_USE_SYSROOT=y\n+CT_SYSROOT_NAME=\"sysroot\"\n+CT_SYSROOT_DIR_PREFIX=\"\"\n+CT_WANTS_STATIC_LINK=y\n+# CT_STATIC_TOOLCHAIN is not set\n+CT_TOOLCHAIN_PKGVERSION=\"\"\n+CT_TOOLCHAIN_BUGURL=\"\"\n+\n+#\n+# Tuple completion and aliasing\n+#\n+CT_TARGET_VENDOR=\"unknown\"\n+CT_TARGET_ALIAS_SED_EXPR=\"\"\n+CT_TARGET_ALIAS=\"\"\n+\n+#\n+# Toolchain type\n+#\n+CT_CROSS=y\n+# CT_CANADIAN is not set\n+CT_TOOLCHAIN_TYPE=\"cross\"\n+\n+#\n+# Build system\n+#\n+CT_BUILD=\"\"\n+CT_BUILD_PREFIX=\"\"\n+CT_BUILD_SUFFIX=\"\"\n+\n+#\n+# Misc options\n+#\n+# CT_TOOLCHAIN_ENABLE_NLS is not set\n+\n+#\n+# Operating System\n+#\n+CT_KERNEL_SUPPORTS_SHARED_LIBS=y\n+CT_KERNEL=\"linux\"\n+CT_KERNEL_VERSION=\"2.6.32.68\"\n+# CT_KERNEL_bare_metal is not set\n+CT_KERNEL_linux=y\n+CT_KERNEL_bare_metal_AVAILABLE=y\n+CT_KERNEL_linux_AVAILABLE=y\n+# CT_KERNEL_V_4_3 is not set\n+# CT_KERNEL_V_4_2 is not set\n+# CT_KERNEL_V_4_1 is not set\n+# CT_KERNEL_V_3_18 is not set\n+# CT_KERNEL_V_3_14 is not set\n+# CT_KERNEL_V_3_12 is not set\n+# CT_KERNEL_V_3_10 is not set\n+# CT_KERNEL_V_3_4 is not set\n+# CT_KERNEL_V_3_2 is not set\n+CT_KERNEL_V_2_6_32=y\n+# CT_KERNEL_LINUX_CUSTOM is not set\n+CT_KERNEL_windows_AVAILABLE=y\n+\n+#\n+# Common kernel options\n+#\n+CT_SHARED_LIBS=y\n+\n+#\n+# linux other options\n+#\n+CT_KERNEL_LINUX_VERBOSITY_0=y\n+# CT_KERNEL_LINUX_VERBOSITY_1 is not set\n+# CT_KERNEL_LINUX_VERBOSITY_2 is not set\n+CT_KERNEL_LINUX_VERBOSE_LEVEL=0\n+CT_KERNEL_LINUX_INSTALL_CHECK=y\n+\n+#\n+# Binary utilities\n+#\n+CT_ARCH_BINFMT_ELF=y\n+CT_BINUTILS=\"binutils\"\n+CT_BINUTILS_binutils=y\n+\n+#\n+# GNU binutils\n+#\n+# CT_CC_BINUTILS_SHOW_LINARO is not set\n+CT_BINUTILS_V_2_25_1=y\n+# CT_BINUTILS_V_2_25 is not set\n+# CT_BINUTILS_V_2_24 is not set\n+# CT_BINUTILS_V_2_23_2 is not set\n+# CT_BINUTILS_V_2_23_1 is not set\n+# CT_BINUTILS_V_2_22 is not set\n+# CT_BINUTILS_V_2_21_53 is not set\n+# CT_BINUTILS_V_2_21_1a is not set\n+# CT_BINUTILS_V_2_20_1a is not set\n+# CT_BINUTILS_V_2_19_1a is not set\n+# CT_BINUTILS_V_2_18a is not set\n+CT_BINUTILS_VERSION=\"2.25.1\"\n+CT_BINUTILS_2_25_1_or_later=y\n+CT_BINUTILS_2_25_or_later=y\n+CT_BINUTILS_2_24_or_later=y\n+CT_BINUTILS_2_23_or_later=y\n+CT_BINUTILS_2_22_or_later=y\n+CT_BINUTILS_2_21_or_later=y\n+CT_BINUTILS_2_20_or_later=y\n+CT_BINUTILS_2_19_or_later=y\n+CT_BINUTILS_2_18_or_later=y\n+CT_BINUTILS_HAS_HASH_STYLE=y\n+CT_BINUTILS_HAS_GOLD=y\n+CT_BINUTILS_HAS_PLUGINS=y\n+CT_BINUTILS_HAS_PKGVERSION_BUGURL=y\n+CT_BINUTILS_FORCE_LD_BFD=y\n+CT_BINUTILS_LINKER_LD=y\n+CT_BINUTILS_LINKERS_LIST=\"ld\"\n+CT_BINUTILS_LINKER_DEFAULT=\"bfd\"\n+# CT_BINUTILS_PLUGINS is not set\n+CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n+# CT_BINUTILS_FOR_TARGET is not set\n+\n+#\n+# binutils other options\n+#\n+\n+#\n+# C-library\n+#\n+CT_LIBC=\"glibc\"\n+CT_LIBC_VERSION=\"2.12.2\"\n+CT_LIBC_glibc=y\n+# CT_LIBC_musl is not set\n+# CT_LIBC_uClibc is not set\n+CT_LIBC_avr_libc_AVAILABLE=y\n+CT_LIBC_glibc_AVAILABLE=y\n+CT_THREADS=\"nptl\"\n+# CT_CC_GLIBC_SHOW_LINARO is not set\n+# CT_LIBC_GLIBC_V_2_22 is not set\n+# CT_LIBC_GLIBC_V_2_21 is not set\n+# CT_LIBC_GLIBC_V_2_20 is not set\n+# CT_LIBC_GLIBC_V_2_19 is not set\n+# CT_LIBC_GLIBC_V_2_18 is not set\n+# CT_LIBC_GLIBC_V_2_17 is not set\n+# CT_LIBC_GLIBC_V_2_16_0 is not set\n+# CT_LIBC_GLIBC_V_2_15 is not set\n+# CT_LIBC_GLIBC_V_2_14_1 is not set\n+# CT_LIBC_GLIBC_V_2_14 is not set\n+# CT_LIBC_GLIBC_V_2_13 is not set\n+CT_LIBC_GLIBC_V_2_12_2=y\n+# CT_LIBC_GLIBC_V_2_12_1 is not set\n+# CT_LIBC_GLIBC_V_2_11_1 is not set\n+# CT_LIBC_GLIBC_V_2_11 is not set\n+# CT_LIBC_GLIBC_V_2_10_1 is not set\n+# CT_LIBC_GLIBC_V_2_9 is not set\n+# CT_LIBC_GLIBC_V_2_8 is not set\n+CT_LIBC_mingw_AVAILABLE=y\n+CT_LIBC_musl_AVAILABLE=y\n+CT_LIBC_newlib_AVAILABLE=y\n+CT_LIBC_none_AVAILABLE=y\n+CT_LIBC_uClibc_AVAILABLE=y\n+CT_LIBC_SUPPORT_THREADS_ANY=y\n+CT_LIBC_SUPPORT_THREADS_NATIVE=y\n+\n+#\n+# Common C library options\n+#\n+CT_THREADS_NATIVE=y\n+CT_LIBC_XLDD=y\n+\n+#\n+# glibc other options\n+#\n+CT_LIBC_GLIBC_PORTS_EXTERNAL=y\n+CT_LIBC_glibc_familly=y\n+CT_LIBC_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_LIBC_GLIBC_CONFIGPARMS=\"\"\n+CT_LIBC_GLIBC_EXTRA_CFLAGS=\"\"\n+CT_LIBC_EXTRA_CC_ARGS=\"\"\n+# CT_LIBC_DISABLE_VERSIONING is not set\n+CT_LIBC_OLDEST_ABI=\"\"\n+CT_LIBC_GLIBC_FORCE_UNWIND=y\n+# CT_LIBC_GLIBC_USE_PORTS is not set\n+CT_LIBC_ADDONS_LIST=\"\"\n+# CT_LIBC_LOCALES is not set\n+# CT_LIBC_GLIBC_KERNEL_VERSION_NONE is not set\n+CT_LIBC_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n+# CT_LIBC_GLIBC_KERNEL_VERSION_CHOSEN is not set\n+CT_LIBC_GLIBC_MIN_KERNEL=\"2.6.32.68\"\n+\n+#\n+# C compiler\n+#\n+CT_CC=\"gcc\"\n+CT_CC_CORE_PASSES_NEEDED=y\n+CT_CC_CORE_PASS_1_NEEDED=y\n+CT_CC_CORE_PASS_2_NEEDED=y\n+CT_CC_gcc=y\n+# CT_CC_GCC_SHOW_LINARO is not set\n+# CT_CC_GCC_V_5_2_0 is not set\n+CT_CC_GCC_V_4_9_3=y\n+# CT_CC_GCC_V_4_8_5 is not set\n+# CT_CC_GCC_V_4_7_4 is not set\n+# CT_CC_GCC_V_4_6_4 is not set\n+# CT_CC_GCC_V_4_5_4 is not set\n+# CT_CC_GCC_V_4_4_7 is not set\n+# CT_CC_GCC_V_4_3_6 is not set\n+# CT_CC_GCC_V_4_2_4 is not set\n+CT_CC_GCC_4_2_or_later=y\n+CT_CC_GCC_4_3_or_later=y\n+CT_CC_GCC_4_4_or_later=y\n+CT_CC_GCC_4_5_or_later=y\n+CT_CC_GCC_4_6_or_later=y\n+CT_CC_GCC_4_7_or_later=y\n+CT_CC_GCC_4_8_or_later=y\n+CT_CC_GCC_4_9=y\n+CT_CC_GCC_4_9_or_later=y\n+CT_CC_GCC_HAS_GRAPHITE=y\n+CT_CC_GCC_USE_GRAPHITE=y\n+CT_CC_GCC_HAS_LTO=y\n+CT_CC_GCC_USE_LTO=y\n+CT_CC_GCC_HAS_PKGVERSION_BUGURL=y\n+CT_CC_GCC_HAS_BUILD_ID=y\n+CT_CC_GCC_HAS_LNK_HASH_STYLE=y\n+CT_CC_GCC_USE_GMP_MPFR=y\n+CT_CC_GCC_USE_MPC=y\n+CT_CC_GCC_HAS_LIBQUADMATH=y\n+CT_CC_GCC_HAS_LIBSANITIZER=y\n+CT_CC_GCC_VERSION=\"4.9.3\"\n+# CT_CC_LANG_FORTRAN is not set\n+CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n+CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"--with-cpu-32=power4 --with-cpu=default32\"\n+CT_CC_GCC_EXTRA_CONFIG_ARRAY=\"--with-cpu-32=power4 --with-cpu=default32\"\n+CT_CC_GCC_EXTRA_ENV_ARRAY=\"\"\n+CT_CC_GCC_STATIC_LIBSTDCXX=y\n+# CT_CC_GCC_SYSTEM_ZLIB is not set\n+\n+#\n+# Optimisation features\n+#\n+\n+#\n+# Settings for libraries running on target\n+#\n+CT_CC_GCC_ENABLE_TARGET_OPTSPACE=y\n+# CT_CC_GCC_LIBMUDFLAP is not set\n+# CT_CC_GCC_LIBGOMP is not set\n+# CT_CC_GCC_LIBSSP is not set\n+# CT_CC_GCC_LIBQUADMATH is not set\n+# CT_CC_GCC_LIBSANITIZER is not set\n+\n+#\n+# Misc. obscure options.\n+#\n+CT_CC_CXA_ATEXIT=y\n+# CT_CC_GCC_DISABLE_PCH is not set\n+CT_CC_GCC_SJLJ_EXCEPTIONS=m\n+CT_CC_GCC_LDBL_128=m\n+# CT_CC_GCC_BUILD_ID is not set\n+CT_CC_GCC_LNK_HASH_STYLE_DEFAULT=y\n+# CT_CC_GCC_LNK_HASH_STYLE_SYSV is not set\n+# CT_CC_GCC_LNK_HASH_STYLE_GNU is not set\n+# CT_CC_GCC_LNK_HASH_STYLE_BOTH is not set\n+CT_CC_GCC_LNK_HASH_STYLE=\"\"\n+CT_CC_GCC_DEC_FLOAT_AUTO=y\n+# CT_CC_GCC_DEC_FLOAT_BID is not set\n+# CT_CC_GCC_DEC_FLOAT_DPD is not set\n+# CT_CC_GCC_DEC_FLOATS_NO is not set\n+CT_CC_SUPPORT_CXX=y\n+CT_CC_SUPPORT_FORTRAN=y\n+CT_CC_SUPPORT_JAVA=y\n+CT_CC_SUPPORT_ADA=y\n+CT_CC_SUPPORT_OBJC=y\n+CT_CC_SUPPORT_OBJCXX=y\n+CT_CC_SUPPORT_GOLANG=y\n+\n+#\n+# Additional supported languages:\n+#\n+CT_CC_LANG_CXX=y\n+# CT_CC_LANG_JAVA is not set\n+\n+#\n+# Debug facilities\n+#\n+# CT_DEBUG_dmalloc is not set\n+# CT_DEBUG_duma is not set\n+# CT_DEBUG_gdb is not set\n+# CT_DEBUG_ltrace is not set\n+# CT_DEBUG_strace is not set\n+\n+#\n+# Companion libraries\n+#\n+CT_COMPLIBS_NEEDED=y\n+CT_LIBICONV_NEEDED=y\n+CT_GETTEXT_NEEDED=y\n+CT_GMP_NEEDED=y\n+CT_MPFR_NEEDED=y\n+CT_ISL_NEEDED=y\n+CT_CLOOG_NEEDED=y\n+CT_MPC_NEEDED=y\n+CT_COMPLIBS=y\n+CT_LIBICONV=y\n+CT_GETTEXT=y\n+CT_GMP=y\n+CT_MPFR=y\n+CT_ISL=y\n+CT_CLOOG=y\n+CT_MPC=y\n+CT_LIBICONV_V_1_14=y\n+CT_LIBICONV_VERSION=\"1.14\"\n+CT_GETTEXT_V_0_19_6=y\n+CT_GETTEXT_VERSION=\"0.19.6\"\n+CT_GMP_V_6_0_0=y\n+# CT_GMP_V_5_1_3 is not set\n+# CT_GMP_V_5_1_1 is not set\n+# CT_GMP_V_5_0_2 is not set\n+# CT_GMP_V_5_0_1 is not set\n+# CT_GMP_V_4_3_2 is not set\n+# CT_GMP_V_4_3_1 is not set\n+# CT_GMP_V_4_3_0 is not set\n+CT_GMP_5_0_2_or_later=y\n+CT_GMP_VERSION=\"6.0.0a\"\n+CT_MPFR_V_3_1_3=y\n+# CT_MPFR_V_3_1_2 is not set\n+# CT_MPFR_V_3_1_0 is not set\n+# CT_MPFR_V_3_0_1 is not set\n+# CT_MPFR_V_3_0_0 is not set\n+# CT_MPFR_V_2_4_2 is not set\n+# CT_MPFR_V_2_4_1 is not set\n+# CT_MPFR_V_2_4_0 is not set\n+CT_MPFR_VERSION=\"3.1.3\"\n+CT_ISL_V_0_14=y\n+CT_ISL_V_0_14_or_later=y\n+CT_ISL_V_0_12_or_later=y\n+CT_ISL_VERSION=\"0.14\"\n+CT_CLOOG_V_0_18_4=y\n+# CT_CLOOG_V_0_18_1 is not set\n+# CT_CLOOG_V_0_18_0 is not set\n+CT_CLOOG_VERSION=\"0.18.4\"\n+CT_CLOOG_0_18_4_or_later=y\n+CT_CLOOG_0_18_or_later=y\n+CT_MPC_V_1_0_3=y\n+# CT_MPC_V_1_0_2 is not set\n+# CT_MPC_V_1_0_1 is not set\n+# CT_MPC_V_1_0 is not set\n+# CT_MPC_V_0_9 is not set\n+# CT_MPC_V_0_8_2 is not set\n+# CT_MPC_V_0_8_1 is not set\n+# CT_MPC_V_0_7 is not set\n+CT_MPC_VERSION=\"1.0.3\"\n+\n+#\n+# Companion libraries common options\n+#\n+# CT_COMPLIBS_CHECK is not set\n+\n+#\n+# Companion tools\n+#\n+\n+#\n+# READ HELP before you say 'Y' below !!!\n+#\n+# CT_COMP_TOOLS is not set"}, {"sha": "624763ef5de6708a3b64dbb1126cab144a7dde39", "filename": "src/ci/docker/dist-powerpc64-linux/Dockerfile", "status": "modified", "additions": 61, "deletions": 12, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -1,19 +1,29 @@\n FROM ubuntu:16.04\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  automake \\\n+  bison \\\n+  bzip2 \\\n+  ca-certificates \\\n+  cmake \\\n+  curl \\\n+  file \\\n+  flex \\\n   g++ \\\n+  gawk \\\n+  gdb \\\n+  git \\\n+  gperf \\\n+  help2man \\\n+  libncurses-dev \\\n+  libtool-bin \\\n   make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n+  patch \\\n   python2.7 \\\n-  git \\\n-  cmake \\\n   sudo \\\n-  gdb \\\n-  xz-utils \\\n-  g++-powerpc64-linux-gnu \\\n-  g++-powerpc64le-linux-gnu\n+  texinfo \\\n+  wget \\\n+  xz-utils\n \n ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n@@ -24,10 +34,49 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n     rm dumb-init_*.deb\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n+# Ubuntu 16.04 (this contianer) ships with make 4, but something in the\n+# toolchains we build below chokes on that, so go back to make 3\n+RUN curl https://ftp.gnu.org/gnu/make/make-3.81.tar.gz | tar xzf - && \\\n+      cd make-3.81 && \\\n+      ./configure --prefix=/usr && \\\n+      make && \\\n+      make install && \\\n+      cd .. && \\\n+      rm -rf make-3.81\n+\n+RUN curl http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-1.22.0.tar.bz2 | \\\n+      tar xjf - && \\\n+      cd crosstool-ng && \\\n+      ./configure --prefix=/usr/local && \\\n+      make -j$(nproc) && \\\n+      make install && \\\n+      cd .. && \\\n+      rm -rf crosstool-ng\n+\n+RUN groupadd -r rustbuild && useradd -m -r -g rustbuild rustbuild\n+RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n+USER rustbuild\n+WORKDIR /tmp\n+\n+COPY patches/ /tmp/patches/\n+COPY powerpc64-linux-gnu.config build-powerpc64-toolchain.sh /tmp/\n+RUN ./build-powerpc64-toolchain.sh\n+\n+USER root\n+\n+RUN apt-get install -y --no-install-recommends rpm2cpio cpio\n+COPY build-powerpc64le-toolchain.sh /tmp/\n+RUN ./build-powerpc64le-toolchain.sh\n+\n+ENV PATH=$PATH:/x-tools/powerpc64-unknown-linux-gnu/bin\n+\n ENV \\\n-    AR_powerpc64_unknown_linux_gnu=powerpc64-linux-gnu-ar \\\n-    CC_powerpc64_unknown_linux_gnu=powerpc64-linux-gnu-gcc \\\n-    CXX_powerpc64_unknown_linux_gnu=powerpc64-linux-gnu-g++\n+    AR_powerpc64_unknown_linux_gnu=powerpc64-unknown-linux-gnu-ar \\\n+    CC_powerpc64_unknown_linux_gnu=powerpc64-unknown-linux-gnu-gcc \\\n+    CXX_powerpc64_unknown_linux_gnu=powerpc64-unknown-linux-gnu-g++ \\\n+    AR_powerpc64le_unknown_linux_gnu=powerpc64le-linux-gnu-ar \\\n+    CC_powerpc64le_unknown_linux_gnu=powerpc64le-linux-gnu-gcc \\\n+    CXX_powerpc64le_unknown_linux_gnu=powerpc64le-linux-gnu-g++\n \n ENV HOSTS=powerpc64-unknown-linux-gnu\n ENV HOSTS=$HOSTS,powerpc64le-unknown-linux-gnu"}, {"sha": "d70947d2dd9d61be7d90025ac333339764612298", "filename": "src/ci/docker/dist-powerpc64-linux/build-powerpc64-toolchain.sh", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fbuild-powerpc64-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fbuild-powerpc64-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fbuild-powerpc64-toolchain.sh?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,36 @@\n+#!/bin/bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+hide_output() {\n+  set +x\n+  on_err=\"\n+echo ERROR: An error was encountered with the build.\n+cat /tmp/build.log\n+exit 1\n+\"\n+  trap \"$on_err\" ERR\n+  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n+  PING_LOOP_PID=$!\n+  $@ &> /tmp/build.log\n+  rm /tmp/build.log\n+  trap - ERR\n+  kill $PING_LOOP_PID\n+  set -x\n+}\n+\n+mkdir build\n+cd build\n+cp ../powerpc64-linux-gnu.config .config\n+hide_output ct-ng build\n+cd ..\n+rm -rf build"}, {"sha": "8b924ca34c47c48ae86e7951ae360759b4cb2f3c", "filename": "src/ci/docker/dist-powerpc64-linux/build-powerpc64le-toolchain.sh", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fbuild-powerpc64le-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fbuild-powerpc64le-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fbuild-powerpc64le-toolchain.sh?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,79 @@\n+#!/bin/bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+BINUTILS=2.25.1\n+GCC=5.3.0\n+TARGET=powerpc64le-linux-gnu\n+SYSROOT=/usr/local/$TARGET/sysroot\n+\n+# First, download the CentOS7 glibc.ppc64le and relevant header files.\n+# (upstream ppc64le support wasn't added until 2.19, which el7 backported.)\n+mkdir -p $SYSROOT\n+pushd $SYSROOT\n+\n+centos_base=http://mirror.centos.org/altarch/7.3.1611/os/ppc64le/Packages\n+glibc_v=2.17-157.el7\n+kernel_v=3.10.0-514.el7\n+for package in glibc{,-devel,-headers}-$glibc_v kernel-headers-$kernel_v; do\n+  curl $centos_base/$package.ppc64le.rpm | \\\n+    rpm2cpio - | cpio -idm\n+done\n+\n+ln -sT lib64 lib\n+ln -sT lib64 usr/lib\n+\n+popd\n+\n+# Next, download and build binutils.\n+mkdir binutils-$TARGET\n+pushd binutils-$TARGET\n+curl https://ftp.gnu.org/gnu/binutils/binutils-$BINUTILS.tar.bz2 | tar xjf -\n+mkdir binutils-build\n+cd binutils-build\n+../binutils-$BINUTILS/configure --target=$TARGET --with-sysroot=$SYSROOT\n+make -j10\n+make install\n+popd\n+rm -rf binutils-$TARGET\n+\n+# Finally, download and build gcc.\n+mkdir gcc-$TARGET\n+pushd gcc-$TARGET\n+curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n+cd gcc-$GCC\n+./contrib/download_prerequisites\n+\n+mkdir ../gcc-build\n+cd ../gcc-build\n+../gcc-$GCC/configure                            \\\n+  --enable-languages=c,c++                       \\\n+  --target=$TARGET                               \\\n+  --with-cpu=power8                              \\\n+  --with-sysroot=$SYSROOT                        \\\n+  --disable-libcilkrts                           \\\n+  --disable-multilib                             \\\n+  --disable-nls                                  \\\n+  --disable-libgomp                              \\\n+  --disable-libquadmath                          \\\n+  --disable-libssp                               \\\n+  --disable-libvtv                               \\\n+  --disable-libcilkrt                            \\\n+  --disable-libada                               \\\n+  --disable-libsanitizer                         \\\n+  --disable-libquadmath-support                  \\\n+  --disable-lto\n+make -j10\n+make install\n+\n+popd\n+rm -rf gcc-$TARGET"}, {"sha": "744eb180cd1f670cd52f3b47ccce8ce645e20a91", "filename": "src/ci/docker/dist-powerpc64-linux/patches/glibc/2.12.2/001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,24 @@\n+From b3563932f85d60bb0d38b0a5f3b8f4abc133f890 Mon Sep 17 00:00:00 2001\n+From: Tulio Magno Quites Machado Filho <tuliom@linux.vnet.ibm.com>\n+Date: Thu, 1 Nov 2012 18:00:06 -0500\n+Subject: [PATCH] PowerPC: Remove unnecessary -mnew-mnemonics.\n+\n+---\n+ sysdeps/powerpc/Makefile | 4 ----\n+ 1 file changed, 4 deletions(-)\n+\n+diff --git a/sysdeps/powerpc/Makefile b/sysdeps/powerpc/Makefile\n+index 79dd6fa976d5..7442b6709ad1 100644\n+--- a/sysdeps/powerpc/Makefile\n++++ b/sysdeps/powerpc/Makefile\n+@@ -1,7 +1,3 @@\n+-# We always want to use the new mnemonic syntax even if we are on a RS6000\n+-# machine.\n+-+cflags += -mnew-mnemonics\n+-\n+ ifeq ($(subdir),gmon)\n+ sysdep_routines += ppc-mcount\n+ endif\n+-- \n+2.9.3\n+"}, {"sha": "47cc8b28d225a11d496593d510e43f6bc7fa2e7b", "filename": "src/ci/docker/dist-powerpc64-linux/patches/glibc/2.12.2/002-Prevent-inlining-in-PPC64-initfini.s.patch", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-Prevent-inlining-in-PPC64-initfini.s.patch", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-Prevent-inlining-in-PPC64-initfini.s.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.12.2%2F002-Prevent-inlining-in-PPC64-initfini.s.patch?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,26 @@\n+From a4f388e111ce05e2ab7912cff3c9070334bb74ae Mon Sep 17 00:00:00 2001\n+From: Josh Stone <jistone@redhat.com>\n+Date: Fri, 20 Jan 2017 15:41:56 -0800\n+Subject: [PATCH] Prevent inlining in PPC64 initfini.s\n+\n+Ref: https://sourceware.org/ml/libc-alpha/2012-01/msg00195.html\n+---\n+ sysdeps/powerpc/powerpc64/Makefile | 2 +-\n+ 1 file changed, 1 insertion(+), 1 deletion(-)\n+\n+diff --git a/sysdeps/powerpc/powerpc64/Makefile b/sysdeps/powerpc/powerpc64/Makefile\n+index 78d4f07e575f..fe96aae4d43e 100644\n+--- a/sysdeps/powerpc/powerpc64/Makefile\n++++ b/sysdeps/powerpc/powerpc64/Makefile\n+@@ -28,7 +28,7 @@ elide-routines.os += hp-timing\n+ ifneq ($(elf),no)\n+ # The initfini generation code doesn't work in the presence of -fPIC, so\n+ # we use -fpic instead which is much better.\n+-CFLAGS-initfini.s += -fpic -O1\n++CFLAGS-initfini.s += -fpic -O1 -fno-inline\n+ endif\n+ endif\n+ \n+-- \n+2.9.3\n+"}, {"sha": "c2d02ee85cf25cb4e43c89c60895d5cb22757cbf", "filename": "src/ci/docker/dist-powerpc64-linux/powerpc64-linux-gnu.config", "status": "added", "additions": 528, "deletions": 0, "changes": 528, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fpowerpc64-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fpowerpc64-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fpowerpc64-linux-gnu.config?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,528 @@\n+#\n+# Automatically generated file; DO NOT EDIT.\n+# Crosstool-NG Configuration\n+#\n+CT_CONFIGURE_has_make381=y\n+CT_CONFIGURE_has_xz=y\n+CT_MODULES=y\n+\n+#\n+# Paths and misc options\n+#\n+\n+#\n+# crosstool-NG behavior\n+#\n+# CT_OBSOLETE is not set\n+# CT_EXPERIMENTAL is not set\n+# CT_DEBUG_CT is not set\n+\n+#\n+# Paths\n+#\n+CT_LOCAL_TARBALLS_DIR=\"\"\n+CT_WORK_DIR=\"${CT_TOP_DIR}/.build\"\n+CT_PREFIX_DIR=\"/x-tools/${CT_TARGET}\"\n+CT_INSTALL_DIR=\"${CT_PREFIX_DIR}\"\n+CT_RM_RF_PREFIX_DIR=y\n+CT_REMOVE_DOCS=y\n+CT_INSTALL_DIR_RO=y\n+CT_STRIP_HOST_TOOLCHAIN_EXECUTABLES=y\n+# CT_STRIP_TARGET_TOOLCHAIN_EXECUTABLES is not set\n+\n+#\n+# Downloading\n+#\n+# CT_FORBID_DOWNLOAD is not set\n+# CT_FORCE_DOWNLOAD is not set\n+CT_CONNECT_TIMEOUT=10\n+# CT_ONLY_DOWNLOAD is not set\n+# CT_USE_MIRROR is not set\n+\n+#\n+# Extracting\n+#\n+# CT_FORCE_EXTRACT is not set\n+CT_OVERIDE_CONFIG_GUESS_SUB=y\n+# CT_ONLY_EXTRACT is not set\n+# CT_PATCH_BUNDLED is not set\n+# CT_PATCH_LOCAL is not set\n+CT_PATCH_BUNDLED_LOCAL=y\n+# CT_PATCH_LOCAL_BUNDLED is not set\n+# CT_PATCH_BUNDLED_FALLBACK_LOCAL is not set\n+# CT_PATCH_LOCAL_FALLBACK_BUNDLED is not set\n+# CT_PATCH_NONE is not set\n+CT_PATCH_ORDER=\"bundled,local\"\n+CT_PATCH_USE_LOCAL=y\n+CT_LOCAL_PATCH_DIR=\"/tmp/patches\"\n+\n+#\n+# Build behavior\n+#\n+CT_PARALLEL_JOBS=0\n+CT_LOAD=\"\"\n+CT_USE_PIPES=y\n+CT_EXTRA_CFLAGS_FOR_BUILD=\"\"\n+CT_EXTRA_LDFLAGS_FOR_BUILD=\"\"\n+CT_EXTRA_CFLAGS_FOR_HOST=\"\"\n+CT_EXTRA_LDFLAGS_FOR_HOST=\"\"\n+# CT_CONFIG_SHELL_SH is not set\n+# CT_CONFIG_SHELL_ASH is not set\n+CT_CONFIG_SHELL_BASH=y\n+# CT_CONFIG_SHELL_CUSTOM is not set\n+CT_CONFIG_SHELL=\"${bash}\"\n+\n+#\n+# Logging\n+#\n+# CT_LOG_ERROR is not set\n+# CT_LOG_WARN is not set\n+CT_LOG_INFO=y\n+# CT_LOG_EXTRA is not set\n+# CT_LOG_ALL is not set\n+# CT_LOG_DEBUG is not set\n+CT_LOG_LEVEL_MAX=\"INFO\"\n+# CT_LOG_SEE_TOOLS_WARN is not set\n+CT_LOG_PROGRESS_BAR=y\n+CT_LOG_TO_FILE=y\n+CT_LOG_FILE_COMPRESS=y\n+\n+#\n+# Target options\n+#\n+CT_ARCH=\"powerpc\"\n+CT_ARCH_SUPPORTS_BOTH_ENDIAN=y\n+CT_ARCH_SUPPORTS_32=y\n+CT_ARCH_SUPPORTS_64=y\n+CT_ARCH_SUPPORTS_WITH_ABI=y\n+CT_ARCH_SUPPORTS_WITH_CPU=y\n+CT_ARCH_SUPPORTS_WITH_TUNE=y\n+CT_ARCH_SUPPORTS_WITH_FLOAT=y\n+CT_ARCH_DEFAULT_BE=y\n+CT_ARCH_DEFAULT_32=y\n+CT_ARCH_ABI=\"\"\n+CT_ARCH_CPU=\"power4\"\n+CT_ARCH_TUNE=\"power6\"\n+CT_ARCH_BE=y\n+# CT_ARCH_LE is not set\n+# CT_ARCH_32 is not set\n+CT_ARCH_64=y\n+CT_ARCH_BITNESS=64\n+# CT_ARCH_FLOAT_HW is not set\n+# CT_ARCH_FLOAT_SW is not set\n+CT_TARGET_CFLAGS=\"\"\n+CT_TARGET_LDFLAGS=\"\"\n+# CT_ARCH_alpha is not set\n+# CT_ARCH_arm is not set\n+# CT_ARCH_avr is not set\n+# CT_ARCH_m68k is not set\n+# CT_ARCH_mips is not set\n+# CT_ARCH_nios2 is not set\n+CT_ARCH_powerpc=y\n+# CT_ARCH_s390 is not set\n+# CT_ARCH_sh is not set\n+# CT_ARCH_sparc is not set\n+# CT_ARCH_x86 is not set\n+# CT_ARCH_xtensa is not set\n+CT_ARCH_alpha_AVAILABLE=y\n+CT_ARCH_arm_AVAILABLE=y\n+CT_ARCH_avr_AVAILABLE=y\n+CT_ARCH_m68k_AVAILABLE=y\n+CT_ARCH_microblaze_AVAILABLE=y\n+CT_ARCH_mips_AVAILABLE=y\n+CT_ARCH_nios2_AVAILABLE=y\n+CT_ARCH_powerpc_AVAILABLE=y\n+CT_ARCH_s390_AVAILABLE=y\n+CT_ARCH_sh_AVAILABLE=y\n+CT_ARCH_sparc_AVAILABLE=y\n+CT_ARCH_x86_AVAILABLE=y\n+CT_ARCH_xtensa_AVAILABLE=y\n+CT_ARCH_SUFFIX=\"\"\n+\n+#\n+# Generic target options\n+#\n+# CT_MULTILIB is not set\n+CT_ARCH_USE_MMU=y\n+CT_ARCH_ENDIAN=\"big\"\n+\n+#\n+# Target optimisations\n+#\n+CT_ARCH_FLOAT_AUTO=y\n+CT_ARCH_FLOAT=\"auto\"\n+\n+#\n+# powerpc other options\n+#\n+CT_ARCH_powerpc_ABI=\"\"\n+CT_ARCH_powerpc_ABI_DEFAULT=y\n+# CT_ARCH_powerpc_ABI_SPE is not set\n+\n+#\n+# Toolchain options\n+#\n+\n+#\n+# General toolchain options\n+#\n+CT_FORCE_SYSROOT=y\n+CT_USE_SYSROOT=y\n+CT_SYSROOT_NAME=\"sysroot\"\n+CT_SYSROOT_DIR_PREFIX=\"\"\n+CT_WANTS_STATIC_LINK=y\n+# CT_STATIC_TOOLCHAIN is not set\n+CT_TOOLCHAIN_PKGVERSION=\"\"\n+CT_TOOLCHAIN_BUGURL=\"\"\n+\n+#\n+# Tuple completion and aliasing\n+#\n+CT_TARGET_VENDOR=\"unknown\"\n+CT_TARGET_ALIAS_SED_EXPR=\"\"\n+CT_TARGET_ALIAS=\"\"\n+\n+#\n+# Toolchain type\n+#\n+CT_CROSS=y\n+# CT_CANADIAN is not set\n+CT_TOOLCHAIN_TYPE=\"cross\"\n+\n+#\n+# Build system\n+#\n+CT_BUILD=\"\"\n+CT_BUILD_PREFIX=\"\"\n+CT_BUILD_SUFFIX=\"\"\n+\n+#\n+# Misc options\n+#\n+# CT_TOOLCHAIN_ENABLE_NLS is not set\n+\n+#\n+# Operating System\n+#\n+CT_KERNEL_SUPPORTS_SHARED_LIBS=y\n+CT_KERNEL=\"linux\"\n+CT_KERNEL_VERSION=\"2.6.32.68\"\n+# CT_KERNEL_bare_metal is not set\n+CT_KERNEL_linux=y\n+CT_KERNEL_bare_metal_AVAILABLE=y\n+CT_KERNEL_linux_AVAILABLE=y\n+# CT_KERNEL_V_4_3 is not set\n+# CT_KERNEL_V_4_2 is not set\n+# CT_KERNEL_V_4_1 is not set\n+# CT_KERNEL_V_3_18 is not set\n+# CT_KERNEL_V_3_14 is not set\n+# CT_KERNEL_V_3_12 is not set\n+# CT_KERNEL_V_3_10 is not set\n+# CT_KERNEL_V_3_4 is not set\n+# CT_KERNEL_V_3_2 is not set\n+CT_KERNEL_V_2_6_32=y\n+# CT_KERNEL_LINUX_CUSTOM is not set\n+CT_KERNEL_windows_AVAILABLE=y\n+\n+#\n+# Common kernel options\n+#\n+CT_SHARED_LIBS=y\n+\n+#\n+# linux other options\n+#\n+CT_KERNEL_LINUX_VERBOSITY_0=y\n+# CT_KERNEL_LINUX_VERBOSITY_1 is not set\n+# CT_KERNEL_LINUX_VERBOSITY_2 is not set\n+CT_KERNEL_LINUX_VERBOSE_LEVEL=0\n+CT_KERNEL_LINUX_INSTALL_CHECK=y\n+\n+#\n+# Binary utilities\n+#\n+CT_ARCH_BINFMT_ELF=y\n+CT_BINUTILS=\"binutils\"\n+CT_BINUTILS_binutils=y\n+\n+#\n+# GNU binutils\n+#\n+# CT_CC_BINUTILS_SHOW_LINARO is not set\n+CT_BINUTILS_V_2_25_1=y\n+# CT_BINUTILS_V_2_25 is not set\n+# CT_BINUTILS_V_2_24 is not set\n+# CT_BINUTILS_V_2_23_2 is not set\n+# CT_BINUTILS_V_2_23_1 is not set\n+# CT_BINUTILS_V_2_22 is not set\n+# CT_BINUTILS_V_2_21_53 is not set\n+# CT_BINUTILS_V_2_21_1a is not set\n+# CT_BINUTILS_V_2_20_1a is not set\n+# CT_BINUTILS_V_2_19_1a is not set\n+# CT_BINUTILS_V_2_18a is not set\n+CT_BINUTILS_VERSION=\"2.25.1\"\n+CT_BINUTILS_2_25_1_or_later=y\n+CT_BINUTILS_2_25_or_later=y\n+CT_BINUTILS_2_24_or_later=y\n+CT_BINUTILS_2_23_or_later=y\n+CT_BINUTILS_2_22_or_later=y\n+CT_BINUTILS_2_21_or_later=y\n+CT_BINUTILS_2_20_or_later=y\n+CT_BINUTILS_2_19_or_later=y\n+CT_BINUTILS_2_18_or_later=y\n+CT_BINUTILS_HAS_HASH_STYLE=y\n+CT_BINUTILS_HAS_GOLD=y\n+CT_BINUTILS_HAS_PLUGINS=y\n+CT_BINUTILS_HAS_PKGVERSION_BUGURL=y\n+CT_BINUTILS_FORCE_LD_BFD=y\n+CT_BINUTILS_LINKER_LD=y\n+CT_BINUTILS_LINKERS_LIST=\"ld\"\n+CT_BINUTILS_LINKER_DEFAULT=\"bfd\"\n+# CT_BINUTILS_PLUGINS is not set\n+CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n+# CT_BINUTILS_FOR_TARGET is not set\n+\n+#\n+# binutils other options\n+#\n+\n+#\n+# C-library\n+#\n+CT_LIBC=\"glibc\"\n+CT_LIBC_VERSION=\"2.12.2\"\n+CT_LIBC_glibc=y\n+# CT_LIBC_musl is not set\n+# CT_LIBC_uClibc is not set\n+CT_LIBC_avr_libc_AVAILABLE=y\n+CT_LIBC_glibc_AVAILABLE=y\n+CT_THREADS=\"nptl\"\n+# CT_CC_GLIBC_SHOW_LINARO is not set\n+# CT_LIBC_GLIBC_V_2_22 is not set\n+# CT_LIBC_GLIBC_V_2_21 is not set\n+# CT_LIBC_GLIBC_V_2_20 is not set\n+# CT_LIBC_GLIBC_V_2_19 is not set\n+# CT_LIBC_GLIBC_V_2_18 is not set\n+# CT_LIBC_GLIBC_V_2_17 is not set\n+# CT_LIBC_GLIBC_V_2_16_0 is not set\n+# CT_LIBC_GLIBC_V_2_15 is not set\n+# CT_LIBC_GLIBC_V_2_14_1 is not set\n+# CT_LIBC_GLIBC_V_2_14 is not set\n+# CT_LIBC_GLIBC_V_2_13 is not set\n+CT_LIBC_GLIBC_V_2_12_2=y\n+# CT_LIBC_GLIBC_V_2_12_1 is not set\n+# CT_LIBC_GLIBC_V_2_11_1 is not set\n+# CT_LIBC_GLIBC_V_2_11 is not set\n+# CT_LIBC_GLIBC_V_2_10_1 is not set\n+# CT_LIBC_GLIBC_V_2_9 is not set\n+# CT_LIBC_GLIBC_V_2_8 is not set\n+CT_LIBC_mingw_AVAILABLE=y\n+CT_LIBC_musl_AVAILABLE=y\n+CT_LIBC_newlib_AVAILABLE=y\n+CT_LIBC_none_AVAILABLE=y\n+CT_LIBC_uClibc_AVAILABLE=y\n+CT_LIBC_SUPPORT_THREADS_ANY=y\n+CT_LIBC_SUPPORT_THREADS_NATIVE=y\n+\n+#\n+# Common C library options\n+#\n+CT_THREADS_NATIVE=y\n+CT_LIBC_XLDD=y\n+\n+#\n+# glibc other options\n+#\n+CT_LIBC_GLIBC_PORTS_EXTERNAL=y\n+CT_LIBC_glibc_familly=y\n+CT_LIBC_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_LIBC_GLIBC_CONFIGPARMS=\"\"\n+CT_LIBC_GLIBC_EXTRA_CFLAGS=\"\"\n+CT_LIBC_EXTRA_CC_ARGS=\"\"\n+# CT_LIBC_DISABLE_VERSIONING is not set\n+CT_LIBC_OLDEST_ABI=\"\"\n+CT_LIBC_GLIBC_FORCE_UNWIND=y\n+# CT_LIBC_GLIBC_USE_PORTS is not set\n+CT_LIBC_ADDONS_LIST=\"\"\n+# CT_LIBC_LOCALES is not set\n+# CT_LIBC_GLIBC_KERNEL_VERSION_NONE is not set\n+CT_LIBC_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n+# CT_LIBC_GLIBC_KERNEL_VERSION_CHOSEN is not set\n+CT_LIBC_GLIBC_MIN_KERNEL=\"2.6.32.68\"\n+\n+#\n+# C compiler\n+#\n+CT_CC=\"gcc\"\n+CT_CC_CORE_PASSES_NEEDED=y\n+CT_CC_CORE_PASS_1_NEEDED=y\n+CT_CC_CORE_PASS_2_NEEDED=y\n+CT_CC_gcc=y\n+# CT_CC_GCC_SHOW_LINARO is not set\n+# CT_CC_GCC_V_5_2_0 is not set\n+CT_CC_GCC_V_4_9_3=y\n+# CT_CC_GCC_V_4_8_5 is not set\n+# CT_CC_GCC_V_4_7_4 is not set\n+# CT_CC_GCC_V_4_6_4 is not set\n+# CT_CC_GCC_V_4_5_4 is not set\n+# CT_CC_GCC_V_4_4_7 is not set\n+# CT_CC_GCC_V_4_3_6 is not set\n+# CT_CC_GCC_V_4_2_4 is not set\n+CT_CC_GCC_4_2_or_later=y\n+CT_CC_GCC_4_3_or_later=y\n+CT_CC_GCC_4_4_or_later=y\n+CT_CC_GCC_4_5_or_later=y\n+CT_CC_GCC_4_6_or_later=y\n+CT_CC_GCC_4_7_or_later=y\n+CT_CC_GCC_4_8_or_later=y\n+CT_CC_GCC_4_9=y\n+CT_CC_GCC_4_9_or_later=y\n+CT_CC_GCC_HAS_GRAPHITE=y\n+CT_CC_GCC_USE_GRAPHITE=y\n+CT_CC_GCC_HAS_LTO=y\n+CT_CC_GCC_USE_LTO=y\n+CT_CC_GCC_HAS_PKGVERSION_BUGURL=y\n+CT_CC_GCC_HAS_BUILD_ID=y\n+CT_CC_GCC_HAS_LNK_HASH_STYLE=y\n+CT_CC_GCC_USE_GMP_MPFR=y\n+CT_CC_GCC_USE_MPC=y\n+CT_CC_GCC_HAS_LIBQUADMATH=y\n+CT_CC_GCC_HAS_LIBSANITIZER=y\n+CT_CC_GCC_VERSION=\"4.9.3\"\n+# CT_CC_LANG_FORTRAN is not set\n+CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n+CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n+CT_CC_GCC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_CC_GCC_EXTRA_ENV_ARRAY=\"\"\n+CT_CC_GCC_STATIC_LIBSTDCXX=y\n+# CT_CC_GCC_SYSTEM_ZLIB is not set\n+\n+#\n+# Optimisation features\n+#\n+\n+#\n+# Settings for libraries running on target\n+#\n+CT_CC_GCC_ENABLE_TARGET_OPTSPACE=y\n+# CT_CC_GCC_LIBMUDFLAP is not set\n+# CT_CC_GCC_LIBGOMP is not set\n+# CT_CC_GCC_LIBSSP is not set\n+# CT_CC_GCC_LIBQUADMATH is not set\n+# CT_CC_GCC_LIBSANITIZER is not set\n+\n+#\n+# Misc. obscure options.\n+#\n+CT_CC_CXA_ATEXIT=y\n+# CT_CC_GCC_DISABLE_PCH is not set\n+CT_CC_GCC_SJLJ_EXCEPTIONS=m\n+CT_CC_GCC_LDBL_128=m\n+# CT_CC_GCC_BUILD_ID is not set\n+CT_CC_GCC_LNK_HASH_STYLE_DEFAULT=y\n+# CT_CC_GCC_LNK_HASH_STYLE_SYSV is not set\n+# CT_CC_GCC_LNK_HASH_STYLE_GNU is not set\n+# CT_CC_GCC_LNK_HASH_STYLE_BOTH is not set\n+CT_CC_GCC_LNK_HASH_STYLE=\"\"\n+CT_CC_GCC_DEC_FLOAT_AUTO=y\n+# CT_CC_GCC_DEC_FLOAT_BID is not set\n+# CT_CC_GCC_DEC_FLOAT_DPD is not set\n+# CT_CC_GCC_DEC_FLOATS_NO is not set\n+CT_CC_SUPPORT_CXX=y\n+CT_CC_SUPPORT_FORTRAN=y\n+CT_CC_SUPPORT_JAVA=y\n+CT_CC_SUPPORT_ADA=y\n+CT_CC_SUPPORT_OBJC=y\n+CT_CC_SUPPORT_OBJCXX=y\n+CT_CC_SUPPORT_GOLANG=y\n+\n+#\n+# Additional supported languages:\n+#\n+CT_CC_LANG_CXX=y\n+# CT_CC_LANG_JAVA is not set\n+\n+#\n+# Debug facilities\n+#\n+# CT_DEBUG_dmalloc is not set\n+# CT_DEBUG_duma is not set\n+# CT_DEBUG_gdb is not set\n+# CT_DEBUG_ltrace is not set\n+# CT_DEBUG_strace is not set\n+\n+#\n+# Companion libraries\n+#\n+CT_COMPLIBS_NEEDED=y\n+CT_LIBICONV_NEEDED=y\n+CT_GETTEXT_NEEDED=y\n+CT_GMP_NEEDED=y\n+CT_MPFR_NEEDED=y\n+CT_ISL_NEEDED=y\n+CT_CLOOG_NEEDED=y\n+CT_MPC_NEEDED=y\n+CT_COMPLIBS=y\n+CT_LIBICONV=y\n+CT_GETTEXT=y\n+CT_GMP=y\n+CT_MPFR=y\n+CT_ISL=y\n+CT_CLOOG=y\n+CT_MPC=y\n+CT_LIBICONV_V_1_14=y\n+CT_LIBICONV_VERSION=\"1.14\"\n+CT_GETTEXT_V_0_19_6=y\n+CT_GETTEXT_VERSION=\"0.19.6\"\n+CT_GMP_V_6_0_0=y\n+# CT_GMP_V_5_1_3 is not set\n+# CT_GMP_V_5_1_1 is not set\n+# CT_GMP_V_5_0_2 is not set\n+# CT_GMP_V_5_0_1 is not set\n+# CT_GMP_V_4_3_2 is not set\n+# CT_GMP_V_4_3_1 is not set\n+# CT_GMP_V_4_3_0 is not set\n+CT_GMP_5_0_2_or_later=y\n+CT_GMP_VERSION=\"6.0.0a\"\n+CT_MPFR_V_3_1_3=y\n+# CT_MPFR_V_3_1_2 is not set\n+# CT_MPFR_V_3_1_0 is not set\n+# CT_MPFR_V_3_0_1 is not set\n+# CT_MPFR_V_3_0_0 is not set\n+# CT_MPFR_V_2_4_2 is not set\n+# CT_MPFR_V_2_4_1 is not set\n+# CT_MPFR_V_2_4_0 is not set\n+CT_MPFR_VERSION=\"3.1.3\"\n+CT_ISL_V_0_14=y\n+CT_ISL_V_0_14_or_later=y\n+CT_ISL_V_0_12_or_later=y\n+CT_ISL_VERSION=\"0.14\"\n+CT_CLOOG_V_0_18_4=y\n+# CT_CLOOG_V_0_18_1 is not set\n+# CT_CLOOG_V_0_18_0 is not set\n+CT_CLOOG_VERSION=\"0.18.4\"\n+CT_CLOOG_0_18_4_or_later=y\n+CT_CLOOG_0_18_or_later=y\n+CT_MPC_V_1_0_3=y\n+# CT_MPC_V_1_0_2 is not set\n+# CT_MPC_V_1_0_1 is not set\n+# CT_MPC_V_1_0 is not set\n+# CT_MPC_V_0_9 is not set\n+# CT_MPC_V_0_8_2 is not set\n+# CT_MPC_V_0_8_1 is not set\n+# CT_MPC_V_0_7 is not set\n+CT_MPC_VERSION=\"1.0.3\"\n+\n+#\n+# Companion libraries common options\n+#\n+# CT_COMPLIBS_CHECK is not set\n+\n+#\n+# Companion tools\n+#\n+\n+#\n+# READ HELP before you say 'Y' below !!!\n+#\n+# CT_COMP_TOOLS is not set"}, {"sha": "589b5fd530fc7cce13bd5bf4fd9a791ed52aa91f", "filename": "src/ci/docker/dist-s390x-linux-netbsd/Dockerfile", "status": "modified", "additions": 59, "deletions": 15, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-s390x-linux-netbsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-s390x-linux-netbsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux-netbsd%2FDockerfile?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -1,37 +1,81 @@\n FROM ubuntu:16.04\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  automake \\\n+  bison \\\n+  bzip2 \\\n+  ca-certificates \\\n+  cmake \\\n+  curl \\\n+  file \\\n+  flex \\\n   g++ \\\n+  gawk \\\n+  gdb \\\n+  git \\\n+  gperf \\\n+  help2man \\\n+  libncurses-dev \\\n+  libtool-bin \\\n   make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n+  patch \\\n   python2.7 \\\n-  git \\\n-  cmake \\\n   sudo \\\n-  bzip2 \\\n-  xz-utils \\\n+  texinfo \\\n   wget \\\n-  patch \\\n-  g++-s390x-linux-gnu\n+  xz-utils\n \n-COPY build-toolchain.sh /tmp/\n-RUN sh /tmp/build-toolchain.sh\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n     dpkg -i dumb-init_*.deb && \\\n     rm dumb-init_*.deb\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n-ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n-RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n-      tar xJf - -C /usr/local/bin --strip-components=1\n+# Ubuntu 16.04 (this contianer) ships with make 4, but something in the\n+# toolchains we build below chokes on that, so go back to make 3\n+RUN curl https://ftp.gnu.org/gnu/make/make-3.81.tar.gz | tar xzf - && \\\n+      cd make-3.81 && \\\n+      ./configure --prefix=/usr && \\\n+      make && \\\n+      make install && \\\n+      cd .. && \\\n+      rm -rf make-3.81\n+\n+RUN curl http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-1.22.0.tar.bz2 | \\\n+      tar xjf - && \\\n+      cd crosstool-ng && \\\n+      ./configure --prefix=/usr/local && \\\n+      make -j$(nproc) && \\\n+      make install && \\\n+      cd .. && \\\n+      rm -rf crosstool-ng\n+\n+RUN groupadd -r rustbuild && useradd -m -r -g rustbuild rustbuild\n+RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n+USER rustbuild\n+WORKDIR /tmp\n+\n+COPY patches/ /tmp/patches/\n+COPY s390x-linux-gnu.config build-s390x-toolchain.sh /tmp/\n+RUN ./build-s390x-toolchain.sh\n+\n+USER root\n+\n+COPY build-netbsd-toolchain.sh /tmp/\n+RUN ./build-netbsd-toolchain.sh\n+\n+ENV PATH=$PATH:/x-tools/s390x-ibm-linux-gnu/bin\n \n ENV \\\n     AR_x86_64_unknown_netbsd=x86_64-unknown-netbsd-ar \\\n     CC_x86_64_unknown_netbsd=x86_64-unknown-netbsd-gcc \\\n-    CXX_x86_64_unknown_netbsd=x86_64-unknown-netbsd-g++\n+    CXX_x86_64_unknown_netbsd=x86_64-unknown-netbsd-g++ \\\n+    CC_s390x_unknown_linux_gnu=s390x-ibm-linux-gnu-gcc \\\n+    AR_s390x_unknown_linux_gnu=s390x-ibm-linux-gnu-ar \\\n+    CXX_s390x_unknown_linux_gnu=s390x-ibm-linux-gnu-g++\n \n ENV HOSTS=x86_64-unknown-netbsd\n ENV HOSTS=$HOSTS,s390x-unknown-linux-gnu"}, {"sha": "654b458ea409e01335ebe1816ab6b40a58991761", "filename": "src/ci/docker/dist-s390x-linux-netbsd/build-netbsd-toolchain.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-s390x-linux-netbsd%2Fbuild-netbsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-s390x-linux-netbsd%2Fbuild-netbsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux-netbsd%2Fbuild-netbsd-toolchain.sh?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "previous_filename": "src/ci/docker/dist-s390x-linux-netbsd/build-toolchain.sh"}, {"sha": "b4995e20dc69b1058bc1577ea3e5aa535d790dd8", "filename": "src/ci/docker/dist-s390x-linux-netbsd/build-s390x-toolchain.sh", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-s390x-linux-netbsd%2Fbuild-s390x-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-s390x-linux-netbsd%2Fbuild-s390x-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux-netbsd%2Fbuild-s390x-toolchain.sh?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,36 @@\n+#!/bin/bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+hide_output() {\n+  set +x\n+  on_err=\"\n+echo ERROR: An error was encountered with the build.\n+cat /tmp/build.log\n+exit 1\n+\"\n+  trap \"$on_err\" ERR\n+  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n+  PING_LOOP_PID=$!\n+  $@ &> /tmp/build.log\n+  rm /tmp/build.log\n+  trap - ERR\n+  kill $PING_LOOP_PID\n+  set -x\n+}\n+\n+mkdir build\n+cd build\n+cp ../s390x-linux-gnu.config .config\n+hide_output ct-ng build\n+cd ..\n+rm -rf build"}, {"sha": "cba416ed2f70bc12990229442e23feb47a0fdd3c", "filename": "src/ci/docker/dist-s390x-linux-netbsd/patches/glibc/2.12.2/001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-s390x-linux-netbsd%2Fpatches%2Fglibc%2F2.12.2%2F001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-s390x-linux-netbsd%2Fpatches%2Fglibc%2F2.12.2%2F001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux-netbsd%2Fpatches%2Fglibc%2F2.12.2%2F001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,63 @@\n+From 2739047682590b1df473401b4febf424f857fccf Mon Sep 17 00:00:00 2001\n+From: Andreas Krebbel <Andreas.Krebbel@de.ibm.com>\n+Date: Sun, 17 Apr 2011 20:43:59 -0400\n+Subject: [PATCH] Use .machine to prevent AS from complaining about z9-109\n+ instructions in iconv modules\n+\n+---\n+ sysdeps/s390/s390-64/utf16-utf32-z9.c | 5 ++++-\n+ sysdeps/s390/s390-64/utf8-utf16-z9.c  | 5 ++++-\n+ sysdeps/s390/s390-64/utf8-utf32-z9.c  | 5 ++++-\n+ 3 files changed, 12 insertions(+), 3 deletions(-)\n+\n+diff --git a/sysdeps/s390/s390-64/utf16-utf32-z9.c b/sysdeps/s390/s390-64/utf16-utf32-z9.c\n+index 14daf2118fe5..5bcaaaedec9c 100644\n+--- a/sysdeps/s390/s390-64/utf16-utf32-z9.c\n++++ b/sysdeps/s390/s390-64/utf16-utf32-z9.c\n+@@ -169,7 +169,10 @@ gconv_end (struct __gconv_step *data)\n+     register unsigned long long outlen asm(\"11\") = outend - outptr;\t\\\n+     uint64_t cc = 0;\t\t\t\t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\\\n+-    asm volatile (\"0: \" INSTRUCTION \"  \\n\\t\"\t\t\t\t\\\n++    asm volatile (\".machine push       \\n\\t\"\t\t\t\t\\\n++                  \".machine \\\"z9-109\\\" \\n\\t\"\t\t\t\t\\\n++\t\t  \"0: \" INSTRUCTION \"  \\n\\t\"\t\t\t\t\\\n++                  \".machine pop        \\n\\t\"\t\t\t\t\\\n+                   \"   jo     0b        \\n\\t\"\t\t\t\t\\\n+ \t\t  \"   ipm    %2        \\n\"\t\t\t        \\\n+ \t\t  : \"+a\" (pOutput), \"+a\" (pInput), \"+d\" (cc),\t\t\\\n+diff --git a/sysdeps/s390/s390-64/utf8-utf16-z9.c b/sysdeps/s390/s390-64/utf8-utf16-z9.c\n+index 5f73f3c59e21..812a42fae44c 100644\n+--- a/sysdeps/s390/s390-64/utf8-utf16-z9.c\n++++ b/sysdeps/s390/s390-64/utf8-utf16-z9.c\n+@@ -151,7 +151,10 @@ gconv_end (struct __gconv_step *data)\n+     register unsigned long long outlen asm(\"11\") = outend - outptr;\t\\\n+     uint64_t cc = 0;\t\t\t\t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\\\n+-    asm volatile (\"0: \" INSTRUCTION \"  \\n\\t\"\t\t\t\t\\\n++    asm volatile (\".machine push       \\n\\t\"\t\t\t\t\\\n++                  \".machine \\\"z9-109\\\" \\n\\t\"\t\t\t\t\\\n++\t\t  \"0: \" INSTRUCTION \"  \\n\\t\"\t\t\t\t\\\n++                  \".machine pop        \\n\\t\"\t\t\t\t\\\n+                   \"   jo     0b        \\n\\t\"\t\t\t\t\\\n+ \t\t  \"   ipm    %2        \\n\"\t\t\t        \\\n+ \t\t  : \"+a\" (pOutput), \"+a\" (pInput), \"+d\" (cc),\t\t\\\n+diff --git a/sysdeps/s390/s390-64/utf8-utf32-z9.c b/sysdeps/s390/s390-64/utf8-utf32-z9.c\n+index 17ef8bc890c3..0ffd848c8124 100644\n+--- a/sysdeps/s390/s390-64/utf8-utf32-z9.c\n++++ b/sysdeps/s390/s390-64/utf8-utf32-z9.c\n+@@ -155,7 +155,10 @@ gconv_end (struct __gconv_step *data)\n+     register unsigned long long outlen asm(\"11\") = outend - outptr;\t\\\n+     uint64_t cc = 0;\t\t\t\t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\\\n+-    asm volatile (\"0: \" INSTRUCTION \"  \\n\\t\"\t\t\t\t\\\n++    asm volatile (\".machine push       \\n\\t\"\t\t\t\t\\\n++                  \".machine \\\"z9-109\\\" \\n\\t\"\t\t\t\t\\\n++\t\t  \"0: \" INSTRUCTION \"  \\n\\t\"\t\t\t\t\\\n++                  \".machine pop        \\n\\t\"\t\t\t\t\\\n+                   \"   jo     0b        \\n\\t\"\t\t\t\t\\\n+ \t\t  \"   ipm    %2        \\n\"\t\t\t\t\\\n+ \t\t  : \"+a\" (pOutput), \"+a\" (pInput), \"+d\" (cc),\t\t\\\n+-- \n+2.9.3\n+"}, {"sha": "fa5e4510987f1ca682a642234f52353481e77e1f", "filename": "src/ci/docker/dist-s390x-linux-netbsd/s390x-linux-gnu.config", "status": "added", "additions": 508, "deletions": 0, "changes": 508, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-s390x-linux-netbsd%2Fs390x-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fdist-s390x-linux-netbsd%2Fs390x-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux-netbsd%2Fs390x-linux-gnu.config?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,508 @@\n+#\n+# Automatically generated file; DO NOT EDIT.\n+# Crosstool-NG Configuration\n+#\n+CT_CONFIGURE_has_make381=y\n+CT_CONFIGURE_has_xz=y\n+CT_MODULES=y\n+\n+#\n+# Paths and misc options\n+#\n+\n+#\n+# crosstool-NG behavior\n+#\n+# CT_OBSOLETE is not set\n+# CT_EXPERIMENTAL is not set\n+# CT_DEBUG_CT is not set\n+\n+#\n+# Paths\n+#\n+CT_LOCAL_TARBALLS_DIR=\"\"\n+CT_WORK_DIR=\"${CT_TOP_DIR}/.build\"\n+CT_PREFIX_DIR=\"/x-tools/${CT_TARGET}\"\n+CT_INSTALL_DIR=\"${CT_PREFIX_DIR}\"\n+CT_RM_RF_PREFIX_DIR=y\n+CT_REMOVE_DOCS=y\n+CT_INSTALL_DIR_RO=y\n+CT_STRIP_HOST_TOOLCHAIN_EXECUTABLES=y\n+# CT_STRIP_TARGET_TOOLCHAIN_EXECUTABLES is not set\n+\n+#\n+# Downloading\n+#\n+# CT_FORBID_DOWNLOAD is not set\n+# CT_FORCE_DOWNLOAD is not set\n+CT_CONNECT_TIMEOUT=10\n+# CT_ONLY_DOWNLOAD is not set\n+# CT_USE_MIRROR is not set\n+\n+#\n+# Extracting\n+#\n+# CT_FORCE_EXTRACT is not set\n+CT_OVERIDE_CONFIG_GUESS_SUB=y\n+# CT_ONLY_EXTRACT is not set\n+# CT_PATCH_BUNDLED is not set\n+# CT_PATCH_LOCAL is not set\n+CT_PATCH_BUNDLED_LOCAL=y\n+# CT_PATCH_LOCAL_BUNDLED is not set\n+# CT_PATCH_BUNDLED_FALLBACK_LOCAL is not set\n+# CT_PATCH_LOCAL_FALLBACK_BUNDLED is not set\n+# CT_PATCH_NONE is not set\n+CT_PATCH_ORDER=\"bundled,local\"\n+CT_PATCH_USE_LOCAL=y\n+CT_LOCAL_PATCH_DIR=\"/tmp/patches\"\n+\n+#\n+# Build behavior\n+#\n+CT_PARALLEL_JOBS=0\n+CT_LOAD=\"\"\n+CT_USE_PIPES=y\n+CT_EXTRA_CFLAGS_FOR_BUILD=\"\"\n+CT_EXTRA_LDFLAGS_FOR_BUILD=\"\"\n+CT_EXTRA_CFLAGS_FOR_HOST=\"\"\n+CT_EXTRA_LDFLAGS_FOR_HOST=\"\"\n+# CT_CONFIG_SHELL_SH is not set\n+# CT_CONFIG_SHELL_ASH is not set\n+CT_CONFIG_SHELL_BASH=y\n+# CT_CONFIG_SHELL_CUSTOM is not set\n+CT_CONFIG_SHELL=\"${bash}\"\n+\n+#\n+# Logging\n+#\n+# CT_LOG_ERROR is not set\n+# CT_LOG_WARN is not set\n+CT_LOG_INFO=y\n+# CT_LOG_EXTRA is not set\n+# CT_LOG_ALL is not set\n+# CT_LOG_DEBUG is not set\n+CT_LOG_LEVEL_MAX=\"INFO\"\n+# CT_LOG_SEE_TOOLS_WARN is not set\n+CT_LOG_PROGRESS_BAR=y\n+CT_LOG_TO_FILE=y\n+CT_LOG_FILE_COMPRESS=y\n+\n+#\n+# Target options\n+#\n+CT_ARCH=\"s390\"\n+CT_ARCH_SUPPORTS_32=y\n+CT_ARCH_SUPPORTS_64=y\n+CT_ARCH_SUPPORTS_WITH_FPU=y\n+CT_ARCH_DEFAULT_32=y\n+CT_ARCH_FPU=\"\"\n+# CT_ARCH_32 is not set\n+CT_ARCH_64=y\n+CT_ARCH_BITNESS=64\n+CT_TARGET_CFLAGS=\"\"\n+CT_TARGET_LDFLAGS=\"\"\n+# CT_ARCH_alpha is not set\n+# CT_ARCH_arm is not set\n+# CT_ARCH_avr is not set\n+# CT_ARCH_m68k is not set\n+# CT_ARCH_mips is not set\n+# CT_ARCH_nios2 is not set\n+# CT_ARCH_powerpc is not set\n+CT_ARCH_s390=y\n+# CT_ARCH_sh is not set\n+# CT_ARCH_sparc is not set\n+# CT_ARCH_x86 is not set\n+# CT_ARCH_xtensa is not set\n+CT_ARCH_alpha_AVAILABLE=y\n+CT_ARCH_arm_AVAILABLE=y\n+CT_ARCH_avr_AVAILABLE=y\n+CT_ARCH_m68k_AVAILABLE=y\n+CT_ARCH_microblaze_AVAILABLE=y\n+CT_ARCH_mips_AVAILABLE=y\n+CT_ARCH_nios2_AVAILABLE=y\n+CT_ARCH_powerpc_AVAILABLE=y\n+CT_ARCH_s390_AVAILABLE=y\n+CT_ARCH_sh_AVAILABLE=y\n+CT_ARCH_sparc_AVAILABLE=y\n+CT_ARCH_x86_AVAILABLE=y\n+CT_ARCH_xtensa_AVAILABLE=y\n+CT_ARCH_SUFFIX=\"\"\n+\n+#\n+# Generic target options\n+#\n+# CT_MULTILIB is not set\n+CT_ARCH_USE_MMU=y\n+\n+#\n+# Target optimisations\n+#\n+CT_ARCH_FLOAT=\"\"\n+\n+#\n+# Toolchain options\n+#\n+\n+#\n+# General toolchain options\n+#\n+CT_FORCE_SYSROOT=y\n+CT_USE_SYSROOT=y\n+CT_SYSROOT_NAME=\"sysroot\"\n+CT_SYSROOT_DIR_PREFIX=\"\"\n+CT_WANTS_STATIC_LINK=y\n+# CT_STATIC_TOOLCHAIN is not set\n+CT_TOOLCHAIN_PKGVERSION=\"\"\n+CT_TOOLCHAIN_BUGURL=\"\"\n+\n+#\n+# Tuple completion and aliasing\n+#\n+CT_TARGET_VENDOR=\"unknown\"\n+CT_TARGET_ALIAS_SED_EXPR=\"\"\n+CT_TARGET_ALIAS=\"\"\n+\n+#\n+# Toolchain type\n+#\n+CT_CROSS=y\n+# CT_CANADIAN is not set\n+CT_TOOLCHAIN_TYPE=\"cross\"\n+\n+#\n+# Build system\n+#\n+CT_BUILD=\"\"\n+CT_BUILD_PREFIX=\"\"\n+CT_BUILD_SUFFIX=\"\"\n+\n+#\n+# Misc options\n+#\n+# CT_TOOLCHAIN_ENABLE_NLS is not set\n+\n+#\n+# Operating System\n+#\n+CT_KERNEL_SUPPORTS_SHARED_LIBS=y\n+CT_KERNEL=\"linux\"\n+CT_KERNEL_VERSION=\"2.6.32.68\"\n+# CT_KERNEL_bare_metal is not set\n+CT_KERNEL_linux=y\n+CT_KERNEL_bare_metal_AVAILABLE=y\n+CT_KERNEL_linux_AVAILABLE=y\n+# CT_KERNEL_V_4_3 is not set\n+# CT_KERNEL_V_4_2 is not set\n+# CT_KERNEL_V_4_1 is not set\n+# CT_KERNEL_V_3_18 is not set\n+# CT_KERNEL_V_3_14 is not set\n+# CT_KERNEL_V_3_12 is not set\n+# CT_KERNEL_V_3_10 is not set\n+# CT_KERNEL_V_3_4 is not set\n+# CT_KERNEL_V_3_2 is not set\n+CT_KERNEL_V_2_6_32=y\n+# CT_KERNEL_LINUX_CUSTOM is not set\n+CT_KERNEL_windows_AVAILABLE=y\n+\n+#\n+# Common kernel options\n+#\n+CT_SHARED_LIBS=y\n+\n+#\n+# linux other options\n+#\n+CT_KERNEL_LINUX_VERBOSITY_0=y\n+# CT_KERNEL_LINUX_VERBOSITY_1 is not set\n+# CT_KERNEL_LINUX_VERBOSITY_2 is not set\n+CT_KERNEL_LINUX_VERBOSE_LEVEL=0\n+CT_KERNEL_LINUX_INSTALL_CHECK=y\n+\n+#\n+# Binary utilities\n+#\n+CT_ARCH_BINFMT_ELF=y\n+CT_BINUTILS=\"binutils\"\n+CT_BINUTILS_binutils=y\n+\n+#\n+# GNU binutils\n+#\n+# CT_CC_BINUTILS_SHOW_LINARO is not set\n+CT_BINUTILS_V_2_25_1=y\n+# CT_BINUTILS_V_2_25 is not set\n+# CT_BINUTILS_V_2_24 is not set\n+# CT_BINUTILS_V_2_23_2 is not set\n+# CT_BINUTILS_V_2_23_1 is not set\n+# CT_BINUTILS_V_2_22 is not set\n+# CT_BINUTILS_V_2_21_53 is not set\n+# CT_BINUTILS_V_2_21_1a is not set\n+# CT_BINUTILS_V_2_20_1a is not set\n+# CT_BINUTILS_V_2_19_1a is not set\n+# CT_BINUTILS_V_2_18a is not set\n+CT_BINUTILS_VERSION=\"2.25.1\"\n+CT_BINUTILS_2_25_1_or_later=y\n+CT_BINUTILS_2_25_or_later=y\n+CT_BINUTILS_2_24_or_later=y\n+CT_BINUTILS_2_23_or_later=y\n+CT_BINUTILS_2_22_or_later=y\n+CT_BINUTILS_2_21_or_later=y\n+CT_BINUTILS_2_20_or_later=y\n+CT_BINUTILS_2_19_or_later=y\n+CT_BINUTILS_2_18_or_later=y\n+CT_BINUTILS_HAS_HASH_STYLE=y\n+CT_BINUTILS_HAS_GOLD=y\n+CT_BINUTILS_HAS_PLUGINS=y\n+CT_BINUTILS_HAS_PKGVERSION_BUGURL=y\n+CT_BINUTILS_FORCE_LD_BFD=y\n+CT_BINUTILS_LINKER_LD=y\n+CT_BINUTILS_LINKERS_LIST=\"ld\"\n+CT_BINUTILS_LINKER_DEFAULT=\"bfd\"\n+# CT_BINUTILS_PLUGINS is not set\n+CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n+# CT_BINUTILS_FOR_TARGET is not set\n+\n+#\n+# binutils other options\n+#\n+\n+#\n+# C-library\n+#\n+CT_LIBC=\"glibc\"\n+CT_LIBC_VERSION=\"2.12.2\"\n+CT_LIBC_glibc=y\n+# CT_LIBC_musl is not set\n+# CT_LIBC_uClibc is not set\n+CT_LIBC_avr_libc_AVAILABLE=y\n+CT_LIBC_glibc_AVAILABLE=y\n+CT_THREADS=\"nptl\"\n+# CT_CC_GLIBC_SHOW_LINARO is not set\n+# CT_LIBC_GLIBC_V_2_22 is not set\n+# CT_LIBC_GLIBC_V_2_21 is not set\n+# CT_LIBC_GLIBC_V_2_20 is not set\n+# CT_LIBC_GLIBC_V_2_19 is not set\n+# CT_LIBC_GLIBC_V_2_18 is not set\n+# CT_LIBC_GLIBC_V_2_17 is not set\n+# CT_LIBC_GLIBC_V_2_16_0 is not set\n+# CT_LIBC_GLIBC_V_2_15 is not set\n+# CT_LIBC_GLIBC_V_2_14_1 is not set\n+# CT_LIBC_GLIBC_V_2_14 is not set\n+# CT_LIBC_GLIBC_V_2_13 is not set\n+CT_LIBC_GLIBC_V_2_12_2=y\n+# CT_LIBC_GLIBC_V_2_12_1 is not set\n+# CT_LIBC_GLIBC_V_2_11_1 is not set\n+# CT_LIBC_GLIBC_V_2_11 is not set\n+# CT_LIBC_GLIBC_V_2_10_1 is not set\n+# CT_LIBC_GLIBC_V_2_9 is not set\n+# CT_LIBC_GLIBC_V_2_8 is not set\n+CT_LIBC_mingw_AVAILABLE=y\n+CT_LIBC_musl_AVAILABLE=y\n+CT_LIBC_newlib_AVAILABLE=y\n+CT_LIBC_none_AVAILABLE=y\n+CT_LIBC_uClibc_AVAILABLE=y\n+CT_LIBC_SUPPORT_THREADS_ANY=y\n+CT_LIBC_SUPPORT_THREADS_NATIVE=y\n+\n+#\n+# Common C library options\n+#\n+CT_THREADS_NATIVE=y\n+CT_LIBC_XLDD=y\n+\n+#\n+# glibc other options\n+#\n+CT_LIBC_GLIBC_PORTS_EXTERNAL=y\n+CT_LIBC_glibc_familly=y\n+CT_LIBC_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_LIBC_GLIBC_CONFIGPARMS=\"\"\n+CT_LIBC_GLIBC_EXTRA_CFLAGS=\"\"\n+CT_LIBC_EXTRA_CC_ARGS=\"\"\n+# CT_LIBC_DISABLE_VERSIONING is not set\n+CT_LIBC_OLDEST_ABI=\"\"\n+CT_LIBC_GLIBC_FORCE_UNWIND=y\n+# CT_LIBC_GLIBC_USE_PORTS is not set\n+CT_LIBC_ADDONS_LIST=\"\"\n+# CT_LIBC_LOCALES is not set\n+# CT_LIBC_GLIBC_KERNEL_VERSION_NONE is not set\n+CT_LIBC_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n+# CT_LIBC_GLIBC_KERNEL_VERSION_CHOSEN is not set\n+CT_LIBC_GLIBC_MIN_KERNEL=\"2.6.32.68\"\n+\n+#\n+# C compiler\n+#\n+CT_CC=\"gcc\"\n+CT_CC_CORE_PASSES_NEEDED=y\n+CT_CC_CORE_PASS_1_NEEDED=y\n+CT_CC_CORE_PASS_2_NEEDED=y\n+CT_CC_gcc=y\n+# CT_CC_GCC_SHOW_LINARO is not set\n+# CT_CC_GCC_V_5_2_0 is not set\n+CT_CC_GCC_V_4_9_3=y\n+# CT_CC_GCC_V_4_8_5 is not set\n+# CT_CC_GCC_V_4_7_4 is not set\n+# CT_CC_GCC_V_4_6_4 is not set\n+# CT_CC_GCC_V_4_5_4 is not set\n+# CT_CC_GCC_V_4_4_7 is not set\n+# CT_CC_GCC_V_4_3_6 is not set\n+# CT_CC_GCC_V_4_2_4 is not set\n+CT_CC_GCC_4_2_or_later=y\n+CT_CC_GCC_4_3_or_later=y\n+CT_CC_GCC_4_4_or_later=y\n+CT_CC_GCC_4_5_or_later=y\n+CT_CC_GCC_4_6_or_later=y\n+CT_CC_GCC_4_7_or_later=y\n+CT_CC_GCC_4_8_or_later=y\n+CT_CC_GCC_4_9=y\n+CT_CC_GCC_4_9_or_later=y\n+CT_CC_GCC_HAS_GRAPHITE=y\n+CT_CC_GCC_USE_GRAPHITE=y\n+CT_CC_GCC_HAS_LTO=y\n+CT_CC_GCC_USE_LTO=y\n+CT_CC_GCC_HAS_PKGVERSION_BUGURL=y\n+CT_CC_GCC_HAS_BUILD_ID=y\n+CT_CC_GCC_HAS_LNK_HASH_STYLE=y\n+CT_CC_GCC_USE_GMP_MPFR=y\n+CT_CC_GCC_USE_MPC=y\n+CT_CC_GCC_HAS_LIBQUADMATH=y\n+CT_CC_GCC_HAS_LIBSANITIZER=y\n+CT_CC_GCC_VERSION=\"4.9.3\"\n+# CT_CC_LANG_FORTRAN is not set\n+CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n+CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n+CT_CC_GCC_EXTRA_CONFIG_ARRAY=\"--with-arch=z10\"\n+CT_CC_GCC_EXTRA_ENV_ARRAY=\"\"\n+CT_CC_GCC_STATIC_LIBSTDCXX=y\n+# CT_CC_GCC_SYSTEM_ZLIB is not set\n+\n+#\n+# Optimisation features\n+#\n+\n+#\n+# Settings for libraries running on target\n+#\n+CT_CC_GCC_ENABLE_TARGET_OPTSPACE=y\n+# CT_CC_GCC_LIBMUDFLAP is not set\n+# CT_CC_GCC_LIBGOMP is not set\n+# CT_CC_GCC_LIBSSP is not set\n+# CT_CC_GCC_LIBQUADMATH is not set\n+# CT_CC_GCC_LIBSANITIZER is not set\n+\n+#\n+# Misc. obscure options.\n+#\n+CT_CC_CXA_ATEXIT=y\n+# CT_CC_GCC_DISABLE_PCH is not set\n+CT_CC_GCC_SJLJ_EXCEPTIONS=m\n+CT_CC_GCC_LDBL_128=m\n+# CT_CC_GCC_BUILD_ID is not set\n+CT_CC_GCC_LNK_HASH_STYLE_DEFAULT=y\n+# CT_CC_GCC_LNK_HASH_STYLE_SYSV is not set\n+# CT_CC_GCC_LNK_HASH_STYLE_GNU is not set\n+# CT_CC_GCC_LNK_HASH_STYLE_BOTH is not set\n+CT_CC_GCC_LNK_HASH_STYLE=\"\"\n+CT_CC_GCC_DEC_FLOAT_AUTO=y\n+# CT_CC_GCC_DEC_FLOAT_BID is not set\n+# CT_CC_GCC_DEC_FLOAT_DPD is not set\n+# CT_CC_GCC_DEC_FLOATS_NO is not set\n+CT_CC_SUPPORT_CXX=y\n+CT_CC_SUPPORT_FORTRAN=y\n+CT_CC_SUPPORT_JAVA=y\n+CT_CC_SUPPORT_ADA=y\n+CT_CC_SUPPORT_OBJC=y\n+CT_CC_SUPPORT_OBJCXX=y\n+CT_CC_SUPPORT_GOLANG=y\n+\n+#\n+# Additional supported languages:\n+#\n+CT_CC_LANG_CXX=y\n+# CT_CC_LANG_JAVA is not set\n+\n+#\n+# Debug facilities\n+#\n+# CT_DEBUG_dmalloc is not set\n+# CT_DEBUG_duma is not set\n+# CT_DEBUG_gdb is not set\n+# CT_DEBUG_ltrace is not set\n+# CT_DEBUG_strace is not set\n+\n+#\n+# Companion libraries\n+#\n+CT_COMPLIBS_NEEDED=y\n+CT_LIBICONV_NEEDED=y\n+CT_GETTEXT_NEEDED=y\n+CT_GMP_NEEDED=y\n+CT_MPFR_NEEDED=y\n+CT_ISL_NEEDED=y\n+CT_CLOOG_NEEDED=y\n+CT_MPC_NEEDED=y\n+CT_COMPLIBS=y\n+CT_LIBICONV=y\n+CT_GETTEXT=y\n+CT_GMP=y\n+CT_MPFR=y\n+CT_ISL=y\n+CT_CLOOG=y\n+CT_MPC=y\n+CT_LIBICONV_V_1_14=y\n+CT_LIBICONV_VERSION=\"1.14\"\n+CT_GETTEXT_V_0_19_6=y\n+CT_GETTEXT_VERSION=\"0.19.6\"\n+CT_GMP_V_6_0_0=y\n+# CT_GMP_V_5_1_3 is not set\n+# CT_GMP_V_5_1_1 is not set\n+# CT_GMP_V_5_0_2 is not set\n+# CT_GMP_V_5_0_1 is not set\n+# CT_GMP_V_4_3_2 is not set\n+# CT_GMP_V_4_3_1 is not set\n+# CT_GMP_V_4_3_0 is not set\n+CT_GMP_5_0_2_or_later=y\n+CT_GMP_VERSION=\"6.0.0a\"\n+CT_MPFR_V_3_1_3=y\n+# CT_MPFR_V_3_1_2 is not set\n+# CT_MPFR_V_3_1_0 is not set\n+# CT_MPFR_V_3_0_1 is not set\n+# CT_MPFR_V_3_0_0 is not set\n+# CT_MPFR_V_2_4_2 is not set\n+# CT_MPFR_V_2_4_1 is not set\n+# CT_MPFR_V_2_4_0 is not set\n+CT_MPFR_VERSION=\"3.1.3\"\n+CT_ISL_V_0_14=y\n+CT_ISL_V_0_14_or_later=y\n+CT_ISL_V_0_12_or_later=y\n+CT_ISL_VERSION=\"0.14\"\n+CT_CLOOG_V_0_18_4=y\n+# CT_CLOOG_V_0_18_1 is not set\n+# CT_CLOOG_V_0_18_0 is not set\n+CT_CLOOG_VERSION=\"0.18.4\"\n+CT_CLOOG_0_18_4_or_later=y\n+CT_CLOOG_0_18_or_later=y\n+CT_MPC_V_1_0_3=y\n+# CT_MPC_V_1_0_2 is not set\n+# CT_MPC_V_1_0_1 is not set\n+# CT_MPC_V_1_0 is not set\n+# CT_MPC_V_0_9 is not set\n+# CT_MPC_V_0_8_2 is not set\n+# CT_MPC_V_0_8_1 is not set\n+# CT_MPC_V_0_7 is not set\n+CT_MPC_VERSION=\"1.0.3\"\n+\n+#\n+# Companion libraries common options\n+#\n+# CT_COMPLIBS_CHECK is not set\n+\n+#\n+# Companion tools\n+#\n+\n+#\n+# READ HELP before you say 'Y' below !!!\n+#\n+# CT_COMP_TOOLS is not set"}, {"sha": "3e084f4a3c30289384b4affe22c0e84e8385713f", "filename": "src/ci/docker/x86_64-gnu-incremental/Dockerfile", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,27 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n+ENV RUSTFLAGS -Zincremental=/tmp/rust-incr-cache\n+ENV RUST_CHECK_TARGET check"}, {"sha": "17741cac10b78c88fd3cdabc30ef24b6fd9429b8", "filename": "src/doc/book/choosing-your-guarantees.md", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -118,7 +118,8 @@ These types are _generally_ found in struct fields, but they may be found elsewh\n \n ## `Cell<T>`\n \n-[`Cell<T>`][cell] is a type that provides zero-cost interior mutability, but only for `Copy` types.\n+[`Cell<T>`][cell] is a type that provides zero-cost interior mutability by moving data in and\n+out of the cell.\n Since the compiler knows that all the data owned by the contained value is on the stack, there's\n no worry of leaking any data behind references (or worse!) by simply replacing the data.\n \n@@ -160,24 +161,25 @@ This relaxes the &ldquo;no aliasing with mutability&rdquo; restriction in places\n unnecessary. However, this also relaxes the guarantees that the restriction provides; so if your\n invariants depend on data stored within `Cell`, you should be careful.\n \n-This is useful for mutating primitives and other `Copy` types when there is no easy way of\n+This is useful for mutating primitives and other types when there is no easy way of\n doing it in line with the static rules of `&` and `&mut`.\n \n `Cell` does not let you obtain interior references to the data, which makes it safe to freely\n mutate.\n \n #### Cost\n \n-There is no runtime cost to using `Cell<T>`, however if you are using it to wrap larger (`Copy`)\n+There is no runtime cost to using `Cell<T>`, however if you are using it to wrap larger\n structs, it might be worthwhile to instead wrap individual fields in `Cell<T>` since each write is\n otherwise a full copy of the struct.\n \n \n ## `RefCell<T>`\n \n-[`RefCell<T>`][refcell] also provides interior mutability, but isn't restricted to `Copy` types.\n+[`RefCell<T>`][refcell] also provides interior mutability, but doesn't move data in and out of the\n+cell.\n \n-Instead, it has a runtime cost. `RefCell<T>` enforces the read-write lock pattern at runtime (it's\n+However, it has a runtime cost. `RefCell<T>` enforces the read-write lock pattern at runtime (it's\n like a single-threaded mutex), unlike `&T`/`&mut T` which do so at compile time. This is done by the\n `borrow()` and `borrow_mut()` functions, which modify an internal reference count and return smart\n pointers which can be dereferenced immutably and mutably respectively. The refcount is restored when"}, {"sha": "8d29f11aa051971956c5ffbfac8ca748d1272765", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -56,9 +56,9 @@ almost any function that takes a pointer argument isn't valid for all possible\n inputs since the pointer could be dangling, and raw pointers fall outside of\n Rust's safe memory model.\n \n-When declaring the argument types to a foreign function, the Rust compiler can\n-not check if the declaration is correct, so specifying it correctly is part of\n-keeping the binding correct at runtime.\n+When declaring the argument types to a foreign function, the Rust compiler\n+cannot check if the declaration is correct, so specifying it correctly is part\n+of keeping the binding correct at runtime.\n \n The `extern` block can be extended to cover the entire snappy API:\n \n@@ -710,7 +710,7 @@ Please note that [`catch_unwind()`] will only catch unwinding panics, not\n those who abort the process. See the documentation of [`catch_unwind()`]\n for more information.\n \n-[`catch_unwind()`]: https://doc.rust-lang.org/std/panic/fn.catch_unwind.html\n+[`catch_unwind()`]: ../std/panic/fn.catch_unwind.html\n \n # Representing opaque structs\n "}, {"sha": "ef19c0dc7cc5e16a1fbc85a2577783dc6c1447cf", "filename": "src/doc/book/testing.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fdoc%2Fbook%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fdoc%2Fbook%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftesting.md?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -499,6 +499,10 @@ be imported in every test with `mod common;`\n That's all there is to the `tests` directory. The `tests` module isn't needed\n here, since the whole thing is focused on tests.\n \n+Note, when building integration tests, cargo will not pass the `test` attribute\n+to the compiler. It means that all parts in `cfg(test)` won't be included in\n+the build used in your integration tests.\n+\n Let's finally check out that third section: documentation tests.\n \n # Documentation tests"}, {"sha": "be4730cf8bce627fdb6e81c9993dd26dc05da3bf", "filename": "src/doc/nomicon/destructors.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fdoc%2Fnomicon%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fdoc%2Fnomicon%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdestructors.md?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -26,7 +26,7 @@ this is totally fine.\n For instance, a custom implementation of `Box` might write `Drop` like this:\n \n ```rust\n-#![feature(alloc, heap_api, drop_in_place, unique)]\n+#![feature(alloc, heap_api, unique)]\n \n extern crate alloc;\n \n@@ -57,7 +57,7 @@ use-after-free the `ptr` because when drop exits, it becomes inaccessible.\n However this wouldn't work:\n \n ```rust\n-#![feature(alloc, heap_api, drop_in_place, unique)]\n+#![feature(alloc, heap_api, unique)]\n \n extern crate alloc;\n \n@@ -135,7 +135,7 @@ The classic safe solution to overriding recursive drop and allowing moving out\n of Self during `drop` is to use an Option:\n \n ```rust\n-#![feature(alloc, heap_api, drop_in_place, unique)]\n+#![feature(alloc, heap_api, unique)]\n \n extern crate alloc;\n "}, {"sha": "6114006cbb341c068fd9936244616cb71fadfffd", "filename": "src/doc/nomicon/dropck.md", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fdoc%2Fnomicon%2Fdropck.md", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fdoc%2Fnomicon%2Fdropck.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdropck.md?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -199,24 +199,42 @@ assert (unsafely) that a generic type's destructor is *guaranteed* to\n not access any expired data, even if its type gives it the capability\n to do so.\n \n-That attribute is called `unsafe_destructor_blind_to_params`.\n+That attribute is called `may_dangle` and was introduced in [RFC 1327]\n+(https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md).\n To deploy it on the Inspector example from above, we would write:\n \n ```rust,ignore\n struct Inspector<'a>(&'a u8, &'static str);\n \n-impl<'a> Drop for Inspector<'a> {\n-    #[unsafe_destructor_blind_to_params]\n+unsafe impl<#[may_dangle] 'a> Drop for Inspector<'a> {\n     fn drop(&mut self) {\n         println!(\"Inspector(_, {}) knows when *not* to inspect.\", self.1);\n     }\n }\n ```\n \n-This attribute has the word `unsafe` in it because the compiler is not\n-checking the implicit assertion that no potentially expired data\n+Use of this attribute requires the `Drop` impl to be marked `unsafe` because the\n+compiler is not checking the implicit assertion that no potentially expired data\n (e.g. `self.0` above) is accessed.\n \n+The attribute can be applied to any number of lifetime and type parameters. In\n+the following example, we assert that we access no data behind a reference of\n+lifetime `'b` and that the only uses of `T` will be moves or drops, but omit\n+the attribute from `'a` and `U`, because we do access data with that lifetime\n+and that type:\n+\n+```rust,ignore\n+use std::fmt::Display;\n+\n+struct Inspector<'a, 'b, T, U: Display>(&'a u8, &'b u8, T, U);\n+\n+unsafe impl<'a, #[may_dangle] 'b, #[may_dangle] T, U: Display> Drop for Inspector<'a, 'b, T, U> {\n+    fn drop(&mut self) {\n+        println!(\"Inspector({}, _, _, {})\", self.0, self.3);\n+    }\n+}\n+```\n+\n It is sometimes obvious that no such access can occur, like the case above.\n However, when dealing with a generic type parameter, such access can\n occur indirectly. Examples of such indirect access are:\n@@ -263,7 +281,7 @@ some other method invoked by the destructor, rather than being written\n directly within it.\n \n In all of the above cases where the `&'a u8` is accessed in the\n-destructor, adding the `#[unsafe_destructor_blind_to_params]`\n+destructor, adding the `#[may_dangle]`\n attribute makes the type vulnerable to misuse that the borrower\n checker will not catch, inviting havoc. It is better to avoid adding\n the attribute."}, {"sha": "38d843263ffda09c7c1609e684a42da31a9763df", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -59,7 +59,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// as long as `T` implements [`Send`] and [`Sync`][sync]. The disadvantage is\n /// that atomic operations are more expensive than ordinary memory accesses.\n /// If you are not sharing reference-counted values between threads, consider\n-/// using [`rc::Rc`] for lower overhead. [`Rc`] is a safe default, because\n+/// using [`rc::Rc`][`Rc`] for lower overhead. [`Rc`] is a safe default, because\n /// the compiler will catch any attempt to send an [`Rc`] between threads.\n /// However, a library might choose `Arc` in order to give library consumers\n /// more flexibility."}, {"sha": "b6f490e09cddf645b9daaa00864b87e6b63e1bf9", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -103,6 +103,7 @@ pub struct ExchangeHeapSingleton {\n ///\n /// See the [module-level documentation](../../std/boxed/index.html) for more.\n #[lang = \"owned_box\"]\n+#[fundamental]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Box<T: ?Sized>(Unique<T>);\n \n@@ -292,6 +293,14 @@ impl<T: ?Sized> Box<T> {\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<#[may_dangle] T: ?Sized> Drop for Box<T> {\n+    fn drop(&mut self) {\n+        // FIXME: Do nothing, drop is currently performed by compiler.\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Box<T> {\n     /// Creates a `Box<T>`, with the `Default` value for T."}, {"sha": "0c01eabd593ff9743bc9fe206c32f5b8819b2498", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -47,7 +47,7 @@\n //! that the contained type `T` is shareable. Additionally, `Arc<T>` is itself\n //! sendable while `Rc<T>` is not.\n //!\n-//! This types allows for shared access to the contained data, and is often\n+//! This type allows for shared access to the contained data, and is often\n //! paired with synchronization primitives such as mutexes to allow mutation of\n //! shared resources.\n //!"}, {"sha": "6108a06634bb88cfaefafda0e88a76f80aa12e2d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -17,9 +17,11 @@\n //! pointer to the same value in the heap. When the last [`Rc`] pointer to a\n //! given value is destroyed, the pointed-to value is also destroyed.\n //!\n-//! Shared references in Rust disallow mutation by default, and `Rc` is no\n-//! exception. If you need to mutate through an [`Rc`], use [`Cell`] or\n-//! [`RefCell`].\n+//! Shared references in Rust disallow mutation by default, and [`Rc`]\n+//! is no exception: you cannot obtain a mutable reference to\n+//! something inside an [`Rc`]. If you need mutability, put a [`Cell`]\n+//! or [`RefCell`] inside the [`Rc`]; see [an example of mutability\n+//! inside an Rc][mutability].\n //!\n //! [`Rc`] uses non-atomic reference counting. This means that overhead is very\n //! low, but an [`Rc`] cannot be sent between threads, and consequently [`Rc`]\n@@ -214,6 +216,7 @@\n //! [upgrade]: struct.Weak.html#method.upgrade\n //! [`None`]: ../../std/option/enum.Option.html#variant.None\n //! [assoc]: ../../book/method-syntax.html#associated-functions\n+//! [mutability]: ../../std/cell/index.html#introducing-mutability-inside-of-something-immutable\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "7e616c0ff27cfb961e3feca8f629ef8f150be366", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -10,23 +10,20 @@\n \n #![deny(warnings)]\n \n+#[macro_use]\n extern crate build_helper;\n extern crate gcc;\n \n use std::env;\n-use std::path::PathBuf;\n+use std::fs::{self, File};\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n-use build_helper::run;\n+use build_helper::{run, rerun_if_changed_anything_in_dir, up_to_date};\n \n fn main() {\n     println!(\"cargo:rustc-cfg=cargobuild\");\n     println!(\"cargo:rerun-if-changed=build.rs\");\n \n-    let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n-    let host = env::var(\"HOST\").expect(\"HOST was not set\");\n-    let build_dir = PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n-    let src_dir = env::current_dir().unwrap();\n-\n     // FIXME: This is a hack to support building targets that don't\n     // support jemalloc alongside hosts that do. The jemalloc build is\n     // controlled by a feature of the std crate, and if that feature\n@@ -35,6 +32,8 @@ fn main() {\n     // that the feature set used by std is the same across all\n     // targets, which means we have to build the alloc_jemalloc crate\n     // for targets like emscripten, even if we don't use it.\n+    let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n+    let host = env::var(\"HOST\").expect(\"HOST was not set\");\n     if target.contains(\"rumprun\") || target.contains(\"bitrig\") || target.contains(\"openbsd\") ||\n        target.contains(\"msvc\") || target.contains(\"emscripten\") || target.contains(\"fuchsia\") ||\n        target.contains(\"redox\") {\n@@ -57,6 +56,28 @@ fn main() {\n         return;\n     }\n \n+    let build_dir = env::var_os(\"RUSTBUILD_NATIVE_DIR\").unwrap_or(env::var_os(\"OUT_DIR\").unwrap());\n+    let build_dir = PathBuf::from(build_dir).join(\"jemalloc\");\n+    let _ = fs::create_dir_all(&build_dir);\n+\n+    if target.contains(\"windows\") {\n+        println!(\"cargo:rustc-link-lib=static=jemalloc\");\n+    } else {\n+        println!(\"cargo:rustc-link-lib=static=jemalloc_pic\");\n+    }\n+    println!(\"cargo:rustc-link-search=native={}/lib\", build_dir.display());\n+    if target.contains(\"android\") {\n+        println!(\"cargo:rustc-link-lib=gcc\");\n+    } else if !target.contains(\"windows\") && !target.contains(\"musl\") {\n+        println!(\"cargo:rustc-link-lib=pthread\");\n+    }\n+    let src_dir = env::current_dir().unwrap().join(\"../jemalloc\");\n+    rerun_if_changed_anything_in_dir(&src_dir);\n+    let timestamp = build_dir.join(\"rustbuild.timestamp\");\n+    if up_to_date(&Path::new(\"build.rs\"), &timestamp) && up_to_date(&src_dir, &timestamp) {\n+        return\n+    }\n+\n     let compiler = gcc::Config::new().get_compiler();\n     // only msvc returns None for ar so unwrap is okay\n     let ar = build_helper::cc2ar(compiler.path(), &target).unwrap();\n@@ -66,23 +87,8 @@ fn main() {\n         .collect::<Vec<_>>()\n         .join(\" \");\n \n-    let mut stack = src_dir.join(\"../jemalloc\")\n-        .read_dir()\n-        .unwrap()\n-        .map(|e| e.unwrap())\n-        .filter(|e| &*e.file_name() != \".git\")\n-        .collect::<Vec<_>>();\n-    while let Some(entry) = stack.pop() {\n-        let path = entry.path();\n-        if entry.file_type().unwrap().is_dir() {\n-            stack.extend(path.read_dir().unwrap().map(|e| e.unwrap()));\n-        } else {\n-            println!(\"cargo:rerun-if-changed={}\", path.display());\n-        }\n-    }\n-\n     let mut cmd = Command::new(\"sh\");\n-    cmd.arg(src_dir.join(\"../jemalloc/configure\")\n+    cmd.arg(src_dir.join(\"configure\")\n                    .to_str()\n                    .unwrap()\n                    .replace(\"C:\\\\\", \"/c/\")\n@@ -158,6 +164,7 @@ fn main() {\n     }\n \n     run(&mut cmd);\n+\n     let mut make = Command::new(build_helper::make(&host));\n     make.current_dir(&build_dir)\n         .arg(\"build_lib_static\");\n@@ -170,15 +177,16 @@ fn main() {\n \n     run(&mut make);\n \n-    if target.contains(\"windows\") {\n-        println!(\"cargo:rustc-link-lib=static=jemalloc\");\n-    } else {\n-        println!(\"cargo:rustc-link-lib=static=jemalloc_pic\");\n-    }\n-    println!(\"cargo:rustc-link-search=native={}/lib\", build_dir.display());\n-    if target.contains(\"android\") {\n-        println!(\"cargo:rustc-link-lib=gcc\");\n-    } else if !target.contains(\"windows\") && !target.contains(\"musl\") {\n-        println!(\"cargo:rustc-link-lib=pthread\");\n+    // The pthread_atfork symbols is used by jemalloc on android but the really\n+    // old android we're building on doesn't have them defined, so just make\n+    // sure the symbols are available.\n+    if target.contains(\"androideabi\") {\n+        println!(\"cargo:rerun-if-changed=pthread_atfork_dummy.c\");\n+        gcc::Config::new()\n+            .flag(\"-fvisibility=hidden\")\n+            .file(\"pthread_atfork_dummy.c\")\n+            .compile(\"libpthread_atfork_dummy.a\");\n     }\n+\n+    t!(File::create(&timestamp));\n }"}, {"sha": "fc8a5455d1d07406a8e4557fd260534f441c3859", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -143,7 +143,7 @@ mod imp {\n     // we're building on doesn't have them defined, so just make sure the symbols\n     // are available.\n     #[no_mangle]\n-    #[cfg(target_os = \"android\")]\n+    #[cfg(all(target_os = \"android\", not(cargobuild)))]\n     pub extern \"C\" fn pthread_atfork(_prefork: *mut u8,\n                                      _postfork_parent: *mut u8,\n                                      _postfork_child: *mut u8)"}, {"sha": "4e3df0ab26c373340bd3c020ec0288b0b17addca", "filename": "src/liballoc_jemalloc/pthread_atfork_dummy.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fliballoc_jemalloc%2Fpthread_atfork_dummy.c", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Fliballoc_jemalloc%2Fpthread_atfork_dummy.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fpthread_atfork_dummy.c?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// See comments in build.rs for why this exists\n+int pthread_atfork(void* prefork,\n+                   void* postfork_parent,\n+                   void* postfork_child) {\n+  return 0;\n+}"}, {"sha": "78b610797778190f398d75eafbadcb0f4b4a25a5", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -17,6 +17,8 @@\n             reason = \"matches collection reform specification, \\\n                       waiting for dust to settle\",\n             issue = \"37966\")]\n+#![rustc_deprecated(since = \"1.16.0\", reason = \"long since replaced\")]\n+#![allow(deprecated)]\n \n use core::marker;\n use core::fmt;"}, {"sha": "39de87c08407f5bcea0f9050c2557758e403e28d", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -79,6 +79,7 @@ pub use btree_set::BTreeSet;\n #[doc(no_inline)]\n pub use linked_list::LinkedList;\n #[doc(no_inline)]\n+#[allow(deprecated)]\n pub use enum_set::EnumSet;\n #[doc(no_inline)]\n pub use vec_deque::VecDeque;"}, {"sha": "11f513ed798e07edbb7509eddf14f96cab145d6d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -509,7 +509,7 @@ impl<T> [T] {\n         core_slice::SliceExt::swap(self, a, b)\n     }\n \n-    /// Reverse the order of elements in a slice, in place.\n+    /// Reverses the order of elements in a slice, in place.\n     ///\n     /// # Example\n     ///\n@@ -1062,7 +1062,7 @@ impl<T> [T] {\n         core_slice::SliceExt::binary_search_by_key(self, b, f)\n     }\n \n-    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n+    /// Sorts the slice.\n     ///\n     /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n     ///"}, {"sha": "458d5114829f459b404ddcb8e34debd5b553fd5b", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -1607,7 +1607,6 @@ impl str {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// # #![feature(str_replacen)]\n     /// let s = \"foo foo 123 foo\";\n     /// assert_eq!(\"new new 123 foo\", s.replacen(\"foo\", \"new\", 2));\n     /// assert_eq!(\"faa fao 123 foo\", s.replacen('o', \"a\", 3));\n@@ -1617,13 +1616,10 @@ impl str {\n     /// When the pattern doesn't match:\n     ///\n     /// ```\n-    /// # #![feature(str_replacen)]\n     /// let s = \"this is old\";\n     /// assert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n     /// ```\n-    #[unstable(feature = \"str_replacen\",\n-               issue = \"36436\",\n-               reason = \"only need to replace first N matches\")]\n+    #[stable(feature = \"str_replacen\", since = \"1.16.0\")]\n     pub fn replacen<'a, P: Pattern<'a>>(&'a self, pat: P, to: &str, count: usize) -> String {\n         // Hope to reduce the times of re-allocation\n         let mut result = String::with_capacity(32);\n@@ -1795,11 +1791,9 @@ impl str {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(repeat_str)]\n-    ///\n     /// assert_eq!(\"abc\".repeat(4), String::from(\"abcabcabcabc\"));\n     /// ```\n-    #[unstable(feature = \"repeat_str\", issue = \"37079\")]\n+    #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n     pub fn repeat(&self, n: usize) -> String {\n         let mut s = String::with_capacity(self.len() * n);\n         s.extend((0..n).map(|_| self));"}, {"sha": "b184a8603e6bd1be5fa4568e3a68ab46174d9e64", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -1166,18 +1166,14 @@ impl String {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(insert_str)]\n-    ///\n     /// let mut s = String::from(\"bar\");\n     ///\n     /// s.insert_str(0, \"foo\");\n     ///\n     /// assert_eq!(\"foobar\", s);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"insert_str\",\n-               reason = \"recent addition\",\n-               issue = \"35553\")]\n+    #[stable(feature = \"insert_str\", since = \"1.16.0\")]\n     pub fn insert_str(&mut self, idx: usize, string: &str) {\n         assert!(self.is_char_boundary(idx));\n \n@@ -1270,7 +1266,6 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(string_split_off)]\n     /// # fn main() {\n     /// let mut hello = String::from(\"Hello, World!\");\n     /// let world = hello.split_off(7);\n@@ -1279,7 +1274,7 @@ impl String {\n     /// # }\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"string_split_off\", issue = \"38080\")]\n+    #[stable(feature = \"string_split_off\", since = \"1.16.0\")]\n     pub fn split_off(&mut self, mid: usize) -> String {\n         assert!(self.is_char_boundary(mid));\n         let other = self.vec.split_off(mid);"}, {"sha": "c45518438bd83e1317802a3ba01082b34c4648a6", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -820,15 +820,13 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(dedup_by)]\n-    ///\n     /// let mut vec = vec![10, 20, 21, 30, 20];\n     ///\n     /// vec.dedup_by_key(|i| *i / 10);\n     ///\n     /// assert_eq!(vec, [10, 20, 30, 20]);\n     /// ```\n-    #[unstable(feature = \"dedup_by\", reason = \"recently added\", issue = \"37087\")]\n+    #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n     #[inline]\n     pub fn dedup_by_key<F, K>(&mut self, mut key: F) where F: FnMut(&mut T) -> K, K: PartialEq {\n         self.dedup_by(|a, b| key(a) == key(b))\n@@ -841,7 +839,6 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(dedup_by)]\n     /// use std::ascii::AsciiExt;\n     ///\n     /// let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n@@ -850,7 +847,7 @@ impl<T> Vec<T> {\n     ///\n     /// assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n     /// ```\n-    #[unstable(feature = \"dedup_by\", reason = \"recently added\", issue = \"37087\")]\n+    #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n     pub fn dedup_by<F>(&mut self, mut same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool {\n         unsafe {\n             // Although we have a mutable reference to `self`, we cannot make\n@@ -1961,7 +1958,7 @@ impl<T> IntoIter<T> {\n     /// assert_eq!(into_iter.next().unwrap(), 'z');\n     /// ```\n     #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n-    pub fn as_mut_slice(&self) -> &mut [T] {\n+    pub fn as_mut_slice(&mut self) -> &mut [T] {\n         unsafe {\n             slice::from_raw_parts_mut(self.ptr as *mut T, self.len())\n         }"}, {"sha": "5e1adb3d808ce1bb71cd0d38d7fdf618a9d5f589", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 76, "deletions": 46, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -469,9 +469,9 @@ impl<T> VecDeque<T> {\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n+    /// assert_eq!(buf, [3, 4, 5]);\n     /// buf.swap(0, 2);\n-    /// assert_eq!(buf[0], 5);\n-    /// assert_eq!(buf[2], 3);\n+    /// assert_eq!(buf, [5, 4, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap(&mut self, i: usize, j: usize) {\n@@ -643,21 +643,17 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(deque_extras)]\n-    ///\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(10);\n     /// buf.push_back(15);\n+    /// assert_eq!(buf, [5, 10, 15]);\n     /// buf.truncate(1);\n-    /// assert_eq!(buf.len(), 1);\n-    /// assert_eq!(Some(&5), buf.get(0));\n+    /// assert_eq!(buf, [5]);\n     /// ```\n-    #[unstable(feature = \"deque_extras\",\n-               reason = \"matches collection reform specification; waiting on panic semantics\",\n-               issue = \"27788\")]\n+    #[stable(feature = \"deque_extras\", since = \"1.16.0\")]\n     pub fn truncate(&mut self, len: usize) {\n         for _ in len..self.len() {\n             self.pop_back();\n@@ -830,8 +826,9 @@ impl<T> VecDeque<T> {\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut v: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n-    /// assert_eq!(vec![3].into_iter().collect::<VecDeque<_>>(), v.drain(2..).collect());\n-    /// assert_eq!(vec![1, 2].into_iter().collect::<VecDeque<_>>(), v);\n+    /// let drained = v.drain(2..).collect::<VecDeque<_>>();\n+    /// assert_eq!(drained, [3]);\n+    /// assert_eq!(v, [1, 2]);\n     ///\n     /// // A full range clears all contents\n     /// v.drain(..);\n@@ -1183,11 +1180,10 @@ impl<T> VecDeque<T> {\n     /// buf.push_back(1);\n     /// buf.push_back(2);\n     /// buf.push_back(3);\n+    /// assert_eq!(buf, [1, 2, 3]);\n     ///\n     /// assert_eq!(buf.swap_remove_back(0), Some(1));\n-    /// assert_eq!(buf.len(), 2);\n-    /// assert_eq!(buf[0], 3);\n-    /// assert_eq!(buf[1], 2);\n+    /// assert_eq!(buf, [3, 2]);\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {\n@@ -1219,11 +1215,10 @@ impl<T> VecDeque<T> {\n     /// buf.push_back(1);\n     /// buf.push_back(2);\n     /// buf.push_back(3);\n+    /// assert_eq!(buf, [1, 2, 3]);\n     ///\n     /// assert_eq!(buf.swap_remove_front(2), Some(3));\n-    /// assert_eq!(buf.len(), 2);\n-    /// assert_eq!(buf[0], 2);\n-    /// assert_eq!(buf[1], 1);\n+    /// assert_eq!(buf, [2, 1]);\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {\n@@ -1254,11 +1249,10 @@ impl<T> VecDeque<T> {\n     /// vec_deque.push_back('a');\n     /// vec_deque.push_back('b');\n     /// vec_deque.push_back('c');\n+    /// assert_eq!(vec_deque, &['a', 'b', 'c']);\n     ///\n     /// vec_deque.insert(1, 'd');\n-    ///\n-    /// let vec = vec_deque.into_iter().collect::<Vec<_>>();\n-    /// assert_eq!(vec, ['a', 'd', 'b', 'c']);\n+    /// assert_eq!(vec_deque, &['a', 'd', 'b', 'c']);\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn insert(&mut self, index: usize, value: T) {\n@@ -1482,9 +1476,10 @@ impl<T> VecDeque<T> {\n     /// buf.push_back(1);\n     /// buf.push_back(2);\n     /// buf.push_back(3);\n+    /// assert_eq!(buf, [1, 2, 3]);\n     ///\n     /// assert_eq!(buf.remove(1), Some(2));\n-    /// assert_eq!(buf.get(1), Some(&3));\n+    /// assert_eq!(buf, [1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, index: usize) -> Option<T> {\n@@ -1663,9 +1658,8 @@ impl<T> VecDeque<T> {\n     ///\n     /// let mut buf: VecDeque<_> = vec![1,2,3].into_iter().collect();\n     /// let buf2 = buf.split_off(1);\n-    /// // buf = [1], buf2 = [2, 3]\n-    /// assert_eq!(buf.len(), 1);\n-    /// assert_eq!(buf2.len(), 2);\n+    /// assert_eq!(buf, [1]);\n+    /// assert_eq!(buf2, [2, 3]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"split_off\", since = \"1.4.0\")]\n@@ -1722,11 +1716,11 @@ impl<T> VecDeque<T> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let mut buf2: VecDeque<_> = vec![4, 5, 6].into_iter().collect();\n+    /// let mut buf: VecDeque<_> = vec![1, 2].into_iter().collect();\n+    /// let mut buf2: VecDeque<_> = vec![3, 4].into_iter().collect();\n     /// buf.append(&mut buf2);\n-    /// assert_eq!(buf.len(), 6);\n-    /// assert_eq!(buf2.len(), 0);\n+    /// assert_eq!(buf, [1, 2, 3, 4]);\n+    /// assert_eq!(buf2, []);\n     /// ```\n     #[inline]\n     #[stable(feature = \"append\", since = \"1.4.0\")]\n@@ -1749,9 +1743,7 @@ impl<T> VecDeque<T> {\n     /// let mut buf = VecDeque::new();\n     /// buf.extend(1..5);\n     /// buf.retain(|&x| x%2 == 0);\n-    ///\n-    /// let v: Vec<_> = buf.into_iter().collect();\n-    /// assert_eq!(&v[..], &[2, 4]);\n+    /// assert_eq!(buf, [2, 4]);\n     /// ```\n     #[stable(feature = \"vec_deque_retain\", since = \"1.4.0\")]\n     pub fn retain<F>(&mut self, mut f: F)\n@@ -1779,23 +1771,21 @@ impl<T: Clone> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(deque_extras)]\n-    ///\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(10);\n     /// buf.push_back(15);\n+    /// assert_eq!(buf, [5, 10, 15]);\n+    ///\n     /// buf.resize(2, 0);\n-    /// buf.resize(6, 20);\n-    /// for (a, b) in [5, 10, 20, 20, 20, 20].iter().zip(&buf) {\n-    ///     assert_eq!(a, b);\n-    /// }\n+    /// assert_eq!(buf, [5, 10]);\n+    ///\n+    /// buf.resize(5, 20);\n+    /// assert_eq!(buf, [5, 10, 20, 20, 20]);\n     /// ```\n-    #[unstable(feature = \"deque_extras\",\n-               reason = \"matches collection reform specification; waiting on panic semantics\",\n-               issue = \"27788\")]\n+    #[stable(feature = \"deque_extras\", since = \"1.16.0\")]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n \n@@ -2170,6 +2160,46 @@ impl<A: PartialEq> PartialEq for VecDeque<A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Eq> Eq for VecDeque<A> {}\n \n+macro_rules! __impl_slice_eq1 {\n+    ($Lhs: ty, $Rhs: ty) => {\n+        __impl_slice_eq1! { $Lhs, $Rhs, Sized }\n+    };\n+    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n+        #[stable(feature = \"vec-deque-partial-eq-slice\", since = \"1.16.0\")]\n+        impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n+            fn eq(&self, other: &$Rhs) -> bool {\n+                if self.len() != other.len() {\n+                    return false;\n+                }\n+                let (sa, sb) = self.as_slices();\n+                let (oa, ob) = other[..].split_at(sa.len());\n+                sa == oa && sb == ob\n+            }\n+        }\n+    }\n+}\n+\n+__impl_slice_eq1! { VecDeque<A>, Vec<B> }\n+__impl_slice_eq1! { VecDeque<A>, &'b [B] }\n+__impl_slice_eq1! { VecDeque<A>, &'b mut [B] }\n+\n+macro_rules! array_impls {\n+    ($($N: expr)+) => {\n+        $(\n+            __impl_slice_eq1! { VecDeque<A>, [B; $N] }\n+            __impl_slice_eq1! { VecDeque<A>, &'b [B; $N] }\n+            __impl_slice_eq1! { VecDeque<A>, &'b mut [B; $N] }\n+        )+\n+    }\n+}\n+\n+array_impls! {\n+     0  1  2  3  4  5  6  7  8  9\n+    10 11 12 13 14 15 16 17 18 19\n+    20 21 22 23 24 25 26 27 28 29\n+    30 31 32\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialOrd> PartialOrd for VecDeque<A> {\n     fn partial_cmp(&self, other: &VecDeque<A>) -> Option<Ordering> {\n@@ -2442,7 +2472,7 @@ mod tests {\n             let final_len = usable_cap / 2;\n \n             for len in 0..final_len {\n-                let expected = if back {\n+                let expected: VecDeque<_> = if back {\n                     (0..len).collect()\n                 } else {\n                     (0..len).rev().collect()\n@@ -2491,7 +2521,7 @@ mod tests {\n         // len is the length *after* insertion\n         for len in 1..cap {\n             // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect();\n+            let expected = (0..).take(len).collect::<VecDeque<_>>();\n             for tail_pos in 0..cap {\n                 for to_insert in 0..len {\n                     tester.tail = tail_pos;\n@@ -2524,7 +2554,7 @@ mod tests {\n         // len is the length *after* removal\n         for len in 0..cap - 1 {\n             // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect();\n+            let expected = (0..).take(len).collect::<VecDeque<_>>();\n             for tail_pos in 0..cap {\n                 for to_remove in 0..len + 1 {\n                     tester.tail = tail_pos;\n@@ -2599,7 +2629,7 @@ mod tests {\n \n         for len in 0..cap + 1 {\n             // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect();\n+            let expected = (0..).take(len).collect::<VecDeque<_>>();\n             for tail_pos in 0..max_cap + 1 {\n                 tester.tail = tail_pos;\n                 tester.head = tail_pos;\n@@ -2632,9 +2662,9 @@ mod tests {\n             // index to split at\n             for at in 0..len + 1 {\n                 // 0, 1, 2, .., at - 1 (may be empty)\n-                let expected_self = (0..).take(at).collect();\n+                let expected_self = (0..).take(at).collect::<VecDeque<_>>();\n                 // at, at + 1, .., len - 1 (may be empty)\n-                let expected_other = (at..).take(len - at).collect();\n+                let expected_other = (at..).take(len - at).collect::<VecDeque<_>>();\n \n                 for tail_pos in 0..cap {\n                     tester.tail = tail_pos;"}, {"sha": "972361326d7bb33af99e99d0a34b49ff8a4ccc70", "filename": "src/libcollectionstest/enum_set.rs", "status": "removed", "additions": 0, "deletions": 268, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/ecda7f314fa79bbfbf2125c99fd66288ca83c875/src%2Flibcollectionstest%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecda7f314fa79bbfbf2125c99fd66288ca83c875/src%2Flibcollectionstest%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fenum_set.rs?ref=ecda7f314fa79bbfbf2125c99fd66288ca83c875", "patch": "@@ -1,268 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::mem;\n-\n-use collections::enum_set::{CLike, EnumSet};\n-\n-use self::Foo::*;\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-#[repr(usize)]\n-enum Foo {\n-    A,\n-    B,\n-    C,\n-}\n-\n-impl CLike for Foo {\n-    fn to_usize(&self) -> usize {\n-        *self as usize\n-    }\n-\n-    fn from_usize(v: usize) -> Foo {\n-        unsafe { mem::transmute(v) }\n-    }\n-}\n-\n-#[test]\n-fn test_new() {\n-    let e: EnumSet<Foo> = EnumSet::new();\n-    assert!(e.is_empty());\n-}\n-\n-#[test]\n-fn test_show() {\n-    let mut e = EnumSet::new();\n-    assert!(format!(\"{:?}\", e) == \"{}\");\n-    e.insert(A);\n-    assert!(format!(\"{:?}\", e) == \"{A}\");\n-    e.insert(C);\n-    assert!(format!(\"{:?}\", e) == \"{A, C}\");\n-}\n-\n-#[test]\n-fn test_len() {\n-    let mut e = EnumSet::new();\n-    assert_eq!(e.len(), 0);\n-    e.insert(A);\n-    e.insert(B);\n-    e.insert(C);\n-    assert_eq!(e.len(), 3);\n-    e.remove(&A);\n-    assert_eq!(e.len(), 2);\n-    e.clear();\n-    assert_eq!(e.len(), 0);\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// intersect\n-\n-#[test]\n-fn test_two_empties_do_not_intersect() {\n-    let e1: EnumSet<Foo> = EnumSet::new();\n-    let e2: EnumSet<Foo> = EnumSet::new();\n-    assert!(e1.is_disjoint(&e2));\n-}\n-\n-#[test]\n-fn test_empty_does_not_intersect_with_full() {\n-    let e1: EnumSet<Foo> = EnumSet::new();\n-\n-    let mut e2: EnumSet<Foo> = EnumSet::new();\n-    e2.insert(A);\n-    e2.insert(B);\n-    e2.insert(C);\n-\n-    assert!(e1.is_disjoint(&e2));\n-}\n-\n-#[test]\n-fn test_disjoint_intersects() {\n-    let mut e1: EnumSet<Foo> = EnumSet::new();\n-    e1.insert(A);\n-\n-    let mut e2: EnumSet<Foo> = EnumSet::new();\n-    e2.insert(B);\n-\n-    assert!(e1.is_disjoint(&e2));\n-}\n-\n-#[test]\n-fn test_overlapping_intersects() {\n-    let mut e1: EnumSet<Foo> = EnumSet::new();\n-    e1.insert(A);\n-\n-    let mut e2: EnumSet<Foo> = EnumSet::new();\n-    e2.insert(A);\n-    e2.insert(B);\n-\n-    assert!(!e1.is_disjoint(&e2));\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// contains and contains_elem\n-\n-#[test]\n-fn test_superset() {\n-    let mut e1: EnumSet<Foo> = EnumSet::new();\n-    e1.insert(A);\n-\n-    let mut e2: EnumSet<Foo> = EnumSet::new();\n-    e2.insert(A);\n-    e2.insert(B);\n-\n-    let mut e3: EnumSet<Foo> = EnumSet::new();\n-    e3.insert(C);\n-\n-    assert!(e1.is_subset(&e2));\n-    assert!(e2.is_superset(&e1));\n-    assert!(!e3.is_superset(&e2));\n-    assert!(!e2.is_superset(&e3))\n-}\n-\n-#[test]\n-fn test_contains() {\n-    let mut e1: EnumSet<Foo> = EnumSet::new();\n-    e1.insert(A);\n-    assert!(e1.contains(&A));\n-    assert!(!e1.contains(&B));\n-    assert!(!e1.contains(&C));\n-\n-    e1.insert(A);\n-    e1.insert(B);\n-    assert!(e1.contains(&A));\n-    assert!(e1.contains(&B));\n-    assert!(!e1.contains(&C));\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// iter\n-\n-#[test]\n-fn test_iterator() {\n-    let mut e1: EnumSet<Foo> = EnumSet::new();\n-\n-    let elems: Vec<Foo> = e1.iter().collect();\n-    assert!(elems.is_empty());\n-\n-    e1.insert(A);\n-    let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!(elems, [A]);\n-\n-    e1.insert(C);\n-    let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!(elems, [A, C]);\n-\n-    e1.insert(C);\n-    let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!(elems, [A, C]);\n-\n-    e1.insert(B);\n-    let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!(elems, [A, B, C]);\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// operators\n-\n-#[test]\n-fn test_operators() {\n-    let mut e1: EnumSet<Foo> = EnumSet::new();\n-    e1.insert(A);\n-    e1.insert(C);\n-\n-    let mut e2: EnumSet<Foo> = EnumSet::new();\n-    e2.insert(B);\n-    e2.insert(C);\n-\n-    let e_union = e1 | e2;\n-    let elems: Vec<_> = e_union.iter().collect();\n-    assert_eq!(elems, [A, B, C]);\n-\n-    let e_intersection = e1 & e2;\n-    let elems: Vec<_> = e_intersection.iter().collect();\n-    assert_eq!(elems, [C]);\n-\n-    // Another way to express intersection\n-    let e_intersection = e1 - (e1 - e2);\n-    let elems: Vec<_> = e_intersection.iter().collect();\n-    assert_eq!(elems, [C]);\n-\n-    let e_subtract = e1 - e2;\n-    let elems: Vec<_> = e_subtract.iter().collect();\n-    assert_eq!(elems, [A]);\n-\n-    // Bitwise XOR of two sets, aka symmetric difference\n-    let e_symmetric_diff = e1 ^ e2;\n-    let elems: Vec<_> = e_symmetric_diff.iter().collect();\n-    assert_eq!(elems, [A, B]);\n-\n-    // Another way to express symmetric difference\n-    let e_symmetric_diff = (e1 - e2) | (e2 - e1);\n-    let elems: Vec<_> = e_symmetric_diff.iter().collect();\n-    assert_eq!(elems, [A, B]);\n-\n-    // Yet another way to express symmetric difference\n-    let e_symmetric_diff = (e1 | e2) - (e1 & e2);\n-    let elems: Vec<_> = e_symmetric_diff.iter().collect();\n-    assert_eq!(elems, [A, B]);\n-}\n-\n-#[test]\n-#[should_panic]\n-fn test_overflow() {\n-    #[allow(dead_code)]\n-    #[derive(Copy, Clone)]\n-    #[repr(usize)]\n-    enum Bar {\n-        V00, V01, V02, V03, V04, V05, V06, V07, V08, V09,\n-        V10, V11, V12, V13, V14, V15, V16, V17, V18, V19,\n-        V20, V21, V22, V23, V24, V25, V26, V27, V28, V29,\n-        V30, V31, V32, V33, V34, V35, V36, V37, V38, V39,\n-        V40, V41, V42, V43, V44, V45, V46, V47, V48, V49,\n-        V50, V51, V52, V53, V54, V55, V56, V57, V58, V59,\n-        V60, V61, V62, V63, V64, V65, V66, V67, V68, V69,\n-    }\n-\n-    impl CLike for Bar {\n-        fn to_usize(&self) -> usize {\n-            *self as usize\n-        }\n-\n-        fn from_usize(v: usize) -> Bar {\n-            unsafe { mem::transmute(v) }\n-        }\n-    }\n-    let mut set = EnumSet::new();\n-    set.insert(Bar::V64);\n-}\n-\n-#[test]\n-fn test_extend_ref() {\n-    let mut a = EnumSet::new();\n-    a.insert(A);\n-\n-    a.extend(&[A, C]);\n-\n-    assert_eq!(a.len(), 2);\n-    assert!(a.contains(&A));\n-    assert!(a.contains(&C));\n-\n-    let mut b = EnumSet::new();\n-    b.insert(B);\n-\n-    a.extend(&b);\n-\n-    assert_eq!(a.len(), 3);\n-    assert!(a.contains(&A));\n-    assert!(a.contains(&B));\n-    assert!(a.contains(&C));\n-}"}, {"sha": "b146672893f8dcf60ce09202a95581696ff34e8f", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -18,17 +18,12 @@\n #![feature(collections)]\n #![feature(collections_bound)]\n #![feature(const_fn)]\n-#![feature(dedup_by)]\n-#![feature(enumset)]\n #![feature(exact_size_is_empty)]\n #![feature(pattern)]\n #![feature(placement_in_syntax)]\n #![feature(rand)]\n-#![feature(repeat_str)]\n #![feature(step_by)]\n #![feature(str_escape)]\n-#![feature(str_replacen)]\n-#![feature(string_split_off)]\n #![feature(test)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n@@ -47,7 +42,6 @@ mod bench;\n mod binary_heap;\n mod btree;\n mod cow_str;\n-mod enum_set;\n mod fmt;\n mod linked_list;\n mod slice;"}, {"sha": "bb60f888f8be6e80521610fc89fa3fb290d8c809", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -603,6 +603,25 @@ fn test_eq() {\n     assert!(e == VecDeque::new());\n }\n \n+#[test]\n+fn test_partial_eq_array() {\n+    let d = VecDeque::<char>::new();\n+    assert!(d == []);\n+\n+    let mut d = VecDeque::new();\n+    d.push_front('a');\n+    assert!(d == ['a']);\n+\n+    let mut d = VecDeque::new();\n+    d.push_back('a');\n+    assert!(d == ['a']);\n+\n+    let mut d = VecDeque::new();\n+    d.push_back('a');\n+    d.push_back('b');\n+    assert!(d == ['a', 'b']);\n+}\n+\n #[test]\n fn test_hash() {\n     let mut x = VecDeque::new();"}, {"sha": "ab44342ebf02fda0daf228f3f1abc524c9106c54", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 108, "deletions": 41, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -15,10 +15,18 @@\n //! references. We say that `Cell<T>` and `RefCell<T>` provide 'interior mutability', in contrast\n //! with typical Rust types that exhibit 'inherited mutability'.\n //!\n-//! Cell types come in two flavors: `Cell<T>` and `RefCell<T>`. `Cell<T>` provides `get` and `set`\n-//! methods that change the interior value with a single method call. `Cell<T>` though is only\n-//! compatible with types that implement `Copy`. For other types, one must use the `RefCell<T>`\n-//! type, acquiring a write lock before mutating.\n+//! Cell types come in two flavors: `Cell<T>` and `RefCell<T>`. `Cell<T>` implements interior\n+//! mutability by moving values in and out of the `Cell<T>`. To use references instead of values,\n+//! one must use the `RefCell<T>` type, acquiring a write lock before mutating. `Cell<T>` provides\n+//! methods to retrieve and change the current interior value:\n+//!\n+//!  - For types that implement `Copy`, the `get` method retrieves the current interior value.\n+//!  - For types that implement `Default`, the `take` method replaces the current interior value\n+//!    with `Default::default()` and returns the replaced value.\n+//!  - For all types, the `replace` method replaces the current interior value and returns the\n+//!    replaced value and the `into_inner` method consumes the `Cell<T>` and returns the interior\n+//!    value. Additionally, the `set` method replaces the interior value, dropping the replaced\n+//!    value.\n //!\n //! `RefCell<T>` uses Rust's lifetimes to implement 'dynamic borrowing', a process whereby one can\n //! claim temporary, exclusive, mutable access to the inner value. Borrows for `RefCell<T>`s are\n@@ -176,9 +184,10 @@\n use cmp::Ordering;\n use fmt::{self, Debug, Display};\n use marker::Unsize;\n+use mem;\n use ops::{Deref, DerefMut, CoerceUnsized};\n \n-/// A mutable memory location that admits only `Copy` data.\n+/// A mutable memory location.\n ///\n /// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -187,23 +196,6 @@ pub struct Cell<T> {\n }\n \n impl<T:Copy> Cell<T> {\n-    /// Creates a new `Cell` containing the given value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::cell::Cell;\n-    ///\n-    /// let c = Cell::new(5);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub const fn new(value: T) -> Cell<T> {\n-        Cell {\n-            value: UnsafeCell::new(value),\n-        }\n-    }\n-\n     /// Returns a copy of the contained value.\n     ///\n     /// # Examples\n@@ -221,25 +213,6 @@ impl<T:Copy> Cell<T> {\n         unsafe{ *self.value.get() }\n     }\n \n-    /// Sets the contained value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::cell::Cell;\n-    ///\n-    /// let c = Cell::new(5);\n-    ///\n-    /// c.set(10);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn set(&self, value: T) {\n-        unsafe {\n-            *self.value.get() = value;\n-        }\n-    }\n-\n     /// Returns a reference to the underlying `UnsafeCell`.\n     ///\n     /// # Examples\n@@ -378,6 +351,100 @@ impl<T: Copy> From<T> for Cell<T> {\n     }\n }\n \n+impl<T> Cell<T> {\n+    /// Creates a new `Cell` containing the given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub const fn new(value: T) -> Cell<T> {\n+        Cell {\n+            value: UnsafeCell::new(value),\n+        }\n+    }\n+\n+    /// Sets the contained value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    ///\n+    /// c.set(10);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn set(&self, val: T) {\n+        let old = self.replace(val);\n+        drop(old);\n+    }\n+\n+    /// Replaces the contained value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(move_cell)]\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    /// let old = c.replace(10);\n+    ///\n+    /// assert_eq!(5, old);\n+    /// ```\n+    #[unstable(feature = \"move_cell\", issue = \"39264\")]\n+    pub fn replace(&self, val: T) -> T {\n+        mem::replace(unsafe { &mut *self.value.get() }, val)\n+    }\n+\n+    /// Unwraps the value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(move_cell)]\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    /// let five = c.into_inner();\n+    ///\n+    /// assert_eq!(five, 5);\n+    /// ```\n+    #[unstable(feature = \"move_cell\", issue = \"39264\")]\n+    pub fn into_inner(self) -> T {\n+        unsafe { self.value.into_inner() }\n+    }\n+}\n+\n+impl<T: Default> Cell<T> {\n+    /// Takes the value of the cell, leaving `Default::default()` in its place.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(move_cell)]\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    /// let five = c.take();\n+    ///\n+    /// assert_eq!(five, 5);\n+    /// assert_eq!(c.into_inner(), 0);\n+    /// ```\n+    #[unstable(feature = \"move_cell\", issue = \"39264\")]\n+    pub fn take(&self) -> T {\n+        self.replace(Default::default())\n+    }\n+}\n+\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: CoerceUnsized<U>, U> CoerceUnsized<Cell<U>> for Cell<T> {}\n "}, {"sha": "abd686b15e22b5f90a4603991b771a26d7007992", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -18,25 +18,33 @@\n //! support arguments of multiple types.\n //!\n //! - Impl the `As*` traits for reference-to-reference conversions\n-//! - Impl the `Into` trait when you want to consume the value in the conversion\n-//! - The `From` trait is the most flexible, useful for value _and_ reference conversions\n-//! - The `TryFrom` and `TryInto` traits behave like `From` and `Into`, but allow for the\n+//! - Impl the [`Into`] trait when you want to consume the value in the conversion\n+//! - The [`From`] trait is the most flexible, useful for value _and_ reference conversions\n+//! - The [`TryFrom`] and [`TryInto`] traits behave like [`From`] and [`Into`], but allow for the\n //!   conversion to fail\n //!\n-//! As a library author, you should prefer implementing `From<T>` or `TryFrom<T>` rather than\n-//! `Into<U>` or `TryInto<U>`, as `From` and `TryFrom` provide greater flexibility and offer\n-//! equivalent `Into` or `TryInto` implementations for free, thanks to a blanket implementation\n+//! As a library author, you should prefer implementing [`From<T>`][`From`] or\n+//! [`TryFrom<T>`][`TryFrom`] rather than [`Into<U>`][`Into`] or [`TryInto<U>`][`TryInto`],\n+//! as [`From`] and [`TryFrom`] provide greater flexibility and offer\n+//! equivalent [`Into`] or [`TryInto`] implementations for free, thanks to a blanket implementation\n //! in the standard library.\n //!\n //! # Generic impl\n //!\n-//! - `AsRef` and `AsMut` auto-dereference if the inner type is a reference\n-//! - `From<U> for T` implies `Into<T> for U`\n-//! - `TryFrom<U> for T` implies `TryInto<T> for U`\n-//! - `From` and `Into` are reflexive, which means that all types can `into()`\n+//! - [`AsRef`] and [`AsMut`] auto-dereference if the inner type is a reference\n+//! - [`From`]`<U> for T` implies [`Into`]`<T> for U`\n+//! - [`TryFrom`]`<U> for T` implies [`TryInto`]`<T> for U`\n+//! - [`From`] and [`Into`] are reflexive, which means that all types can `into()`\n //!   themselves and `from()` themselves\n //!\n //! See each trait for usage examples.\n+//!\n+//! [`Into`]: trait.Into.html\n+//! [`From`]: trait.From.html\n+//! [`TryFrom`]: trait.TryFrom.html\n+//! [`TryInto`]: trait.TryInto.html\n+//! [`AsRef`]: trait.AsRef.html\n+//! [`AsMut`]: trait.AsMut.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "dd6edc7d39af0ca0afca1f2be4418cd9430099df", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -307,6 +307,7 @@ pub trait BuildHasher {\n /// [`BuildHasher`]: trait.BuildHasher.html\n /// [`Default`]: ../default/trait.Default.html\n /// [`Hasher`]: trait.Hasher.html\n+/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n pub struct BuildHasherDefault<H>(marker::PhantomData<H>);\n "}, {"sha": "3b406873d4b191b63fc2d5a71cc416fd884d4606", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -1108,9 +1108,9 @@ pub trait Iterator {\n     ///\n     /// One of the keys to `collect()`'s power is that many things you might\n     /// not think of as 'collections' actually are. For example, a [`String`]\n-    /// is a collection of [`char`]s. And a collection of [`Result<T, E>`] can\n-    /// be thought of as single [`Result`]`<Collection<T>, E>`. See the examples\n-    /// below for more.\n+    /// is a collection of [`char`]s. And a collection of\n+    /// [`Result<T, E>`][`Result`] can be thought of as single\n+    /// [`Result`]`<Collection<T>, E>`. See the examples below for more.\n     ///\n     /// Because `collect()` is so general, it can cause problems with type\n     /// inference. As such, `collect()` is one of the few times you'll see"}, {"sha": "c4d7b2dcf96fb258f38a88754387d2e4cda4ba9c", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -60,7 +60,7 @@\n //! the optional owned box, [`Option`]`<`[`Box<T>`]`>`.\n //!\n //! The following example uses [`Option`] to create an optional box of\n-//! [`i32`]. Notice that in order to use the inner [`i32`] value first the\n+//! [`i32`]. Notice that in order to use the inner [`i32`] value first, the\n //! `check_optional` function needs to use pattern matching to\n //! determine whether the box has a value (i.e. it is [`Some(...)`][`Some`]) or\n //! not ([`None`]).\n@@ -74,8 +74,8 @@\n //!\n //! fn check_optional(optional: &Option<Box<i32>>) {\n //!     match *optional {\n-//!         Some(ref p) => println!(\"have value {}\", p),\n-//!         None => println!(\"have no value\"),\n+//!         Some(ref p) => println!(\"has value {}\", p),\n+//!         None => println!(\"has no value\"),\n //!     }\n //! }\n //! ```"}, {"sha": "02851c224e2e35b019c8cd6a0a06446156916716", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -448,7 +448,6 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(ptr_wrapping_offset)]\n     /// // Iterate using a raw pointer in increments of two elements\n     /// let data = [1u8, 2, 3, 4, 5];\n     /// let mut ptr: *const u8 = data.as_ptr();\n@@ -463,7 +462,7 @@ impl<T: ?Sized> *const T {\n     ///     ptr = ptr.wrapping_offset(step);\n     /// }\n     /// ```\n-    #[unstable(feature = \"ptr_wrapping_offset\", issue = \"37570\")]\n+    #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n     #[inline]\n     pub fn wrapping_offset(self, count: isize) -> *const T where T: Sized {\n         unsafe {\n@@ -572,7 +571,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(ptr_wrapping_offset)]\n     /// // Iterate using a raw pointer in increments of two elements\n     /// let mut data = [1u8, 2, 3, 4, 5];\n     /// let mut ptr: *mut u8 = data.as_mut_ptr();\n@@ -587,7 +585,7 @@ impl<T: ?Sized> *mut T {\n     /// }\n     /// assert_eq!(&data, &[0, 2, 0, 4, 0]);\n     /// ```\n-    #[unstable(feature = \"ptr_wrapping_offset\", issue = \"37570\")]\n+    #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n     #[inline]\n     pub fn wrapping_offset(self, count: isize) -> *mut T where T: Sized {\n         unsafe {"}, {"sha": "0a2e363965347830468dd2283c34e967e7a68df6", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -840,8 +840,6 @@ impl<T: Default, E> Result<T, E> {\n     /// `Err` on error.\n     ///\n     /// ```\n-    /// #![feature(result_unwrap_or_default)]\n-    ///\n     /// let good_year_from_input = \"1909\";\n     /// let bad_year_from_input = \"190blarg\";\n     /// let good_year = good_year_from_input.parse().unwrap_or_default();\n@@ -854,7 +852,7 @@ impl<T: Default, E> Result<T, E> {\n     /// [`FromStr`]: ../../std/str/trait.FromStr.html\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"result_unwrap_or_default\", issue = \"37516\")]\n+    #[stable(feature = \"result_unwrap_or_default\", since = \"1.16.0\")]\n     pub fn unwrap_or_default(self) -> T {\n         match self {\n             Ok(x) => x,"}, {"sha": "743e3c41170a34d0c99ef3575cd234811eb3deb2", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -24,7 +24,7 @@\n //! same as [LLVM atomic orderings][1]. For more information see the [nomicon][2].\n //!\n //! [1]: http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\n-//! [2]: https://doc.rust-lang.org/nomicon/atomics.html\n+//! [2]: ../../../nomicon/atomics.html\n //!\n //! Atomic variables are safe to share between threads (they implement `Sync`)\n //! but they do not themselves provide the mechanism for sharing and follow the\n@@ -144,7 +144,7 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n /// LLVM's](http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations).\n ///\n /// For more information see the [nomicon][1].\n-/// [1]: https://doc.rust-lang.org/nomicon/atomics.html\n+/// [1]: ../../../nomicon/atomics.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone, Debug)]\n pub enum Ordering {"}, {"sha": "8585f2f08711332a3e5af0fa53145df9e1b657ec", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -209,6 +209,37 @@ fn cell_default() {\n     assert_eq!(0, cell.get());\n }\n \n+#[test]\n+fn cell_set() {\n+    let cell = Cell::new(10);\n+    cell.set(20);\n+    assert_eq!(20, cell.get());\n+\n+    let cell = Cell::new(\"Hello\".to_owned());\n+    cell.set(\"World\".to_owned());\n+    assert_eq!(\"World\".to_owned(), cell.into_inner());\n+}\n+\n+#[test]\n+fn cell_replace() {\n+    let cell = Cell::new(10);\n+    assert_eq!(10, cell.replace(20));\n+    assert_eq!(20, cell.get());\n+\n+    let cell = Cell::new(\"Hello\".to_owned());\n+    assert_eq!(\"Hello\".to_owned(), cell.replace(\"World\".to_owned()));\n+    assert_eq!(\"World\".to_owned(), cell.into_inner());\n+}\n+\n+#[test]\n+fn cell_into_inner() {\n+    let cell = Cell::new(10);\n+    assert_eq!(10, cell.into_inner());\n+\n+    let cell = Cell::new(\"Hello world\".to_owned());\n+    assert_eq!(\"Hello world\".to_owned(), cell.into_inner());\n+}\n+\n #[test]\n fn refcell_default() {\n     let cell: RefCell<u64> = Default::default();"}, {"sha": "53ac17c052f6af89a27831ba50f2f7d1686bb4ba", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -66,7 +66,6 @@ fn test_writer_hasher() {\n     assert_eq!(hash(& s), 97 + 0xFF);\n     let cs: &[u8] = &[1, 2, 3];\n     assert_eq!(hash(& cs), 9);\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let cs: Box<[u8]> = Box::new([1, 2, 3]);\n     assert_eq!(hash(& cs), 9);\n "}, {"sha": "6d02f76c33d162ed628f2c9a93488f2b1790c1eb", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -700,7 +700,6 @@ fn test_collect() {\n \n #[test]\n fn test_all() {\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let v: Box<[isize]> = Box::new([1, 2, 3, 4, 5]);\n     assert!(v.iter().all(|&x| x < 10));\n     assert!(!v.iter().all(|&x| x % 2 == 0));\n@@ -710,7 +709,6 @@ fn test_all() {\n \n #[test]\n fn test_any() {\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let v: Box<[isize]> = Box::new([1, 2, 3, 4, 5]);\n     assert!(v.iter().any(|&x| x < 10));\n     assert!(v.iter().any(|&x| x % 2 == 0));"}, {"sha": "e06b757691e5ac29462159f04ce7e57831676893", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -32,8 +32,8 @@\n #![feature(unicode)]\n #![feature(unique)]\n #![feature(ordering_chaining)]\n-#![feature(result_unwrap_or_default)]\n #![feature(ptr_unaligned)]\n+#![feature(move_cell)]\n #![feature(fmt_internals)]\n \n extern crate core;"}, {"sha": "b51a7d4104ab92865a5f76d3ba2c3f542a32f690", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -327,6 +327,69 @@ struct ListNode {\n This works because `Box` is a pointer, so its size is well-known.\n \"##,\n \n+E0106: r##\"\n+This error indicates that a lifetime is missing from a type. If it is an error\n+inside a function signature, the problem may be with failing to adhere to the\n+lifetime elision rules (see below).\n+\n+Here are some simple examples of where you'll run into this error:\n+\n+```compile_fail,E0106\n+struct Foo { x: &bool }        // error\n+struct Foo<'a> { x: &'a bool } // correct\n+\n+enum Bar { A(u8), B(&bool), }        // error\n+enum Bar<'a> { A(u8), B(&'a bool), } // correct\n+\n+type MyStr = &str;        // error\n+type MyStr<'a> = &'a str; // correct\n+```\n+\n+Lifetime elision is a special, limited kind of inference for lifetimes in\n+function signatures which allows you to leave out lifetimes in certain cases.\n+For more background on lifetime elision see [the book][book-le].\n+\n+The lifetime elision rules require that any function signature with an elided\n+output lifetime must either have\n+\n+ - exactly one input lifetime\n+ - or, multiple input lifetimes, but the function must also be a method with a\n+   `&self` or `&mut self` receiver\n+\n+In the first case, the output lifetime is inferred to be the same as the unique\n+input lifetime. In the second case, the lifetime is instead inferred to be the\n+same as the lifetime on `&self` or `&mut self`.\n+\n+Here are some examples of elision errors:\n+\n+```compile_fail,E0106\n+// error, no input lifetimes\n+fn foo() -> &str { }\n+\n+// error, `x` and `y` have distinct lifetimes inferred\n+fn bar(x: &str, y: &str) -> &str { }\n+\n+// error, `y`'s lifetime is inferred to be distinct from `x`'s\n+fn baz<'a>(x: &'a str, y: &str) -> &str { }\n+```\n+\n+Here's an example that is currently an error, but may work in a future version\n+of Rust:\n+\n+```compile_fail,E0106\n+struct Foo<'a>(&'a str);\n+\n+trait Quux { }\n+impl Quux for Foo { }\n+```\n+\n+Lifetime elision in implementation headers was part of the lifetime elision\n+RFC. It is, however, [currently unimplemented][iss15872].\n+\n+[book-le]: https://doc.rust-lang.org/nightly/book/lifetimes.html#lifetime-elision\n+[iss15872]: https://github.com/rust-lang/rust/issues/15872\n+\"##,\n+\n E0109: r##\"\n You tried to give a type parameter to a type which doesn't need it. Erroneous\n code example:"}, {"sha": "4b3e0d29101e4c33c42f57adee5a5fa339a50412", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -301,7 +301,7 @@ pub trait Visitor<'v> : Sized {\n     fn visit_ty_param_bound(&mut self, bounds: &'v TyParamBound) {\n         walk_ty_param_bound(self, bounds)\n     }\n-    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: &'v TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: TraitBoundModifier) {\n         walk_poly_trait_ref(self, t, m)\n     }\n     fn visit_variant_data(&mut self,\n@@ -421,7 +421,7 @@ pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V, lifetime_def: &'v\n \n pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                   trait_ref: &'v PolyTraitRef,\n-                                  _modifier: &'v TraitBoundModifier)\n+                                  _modifier: TraitBoundModifier)\n     where V: Visitor<'v>\n {\n     walk_list!(visitor, visit_lifetime_def, &trait_ref.bound_lifetimes);\n@@ -547,8 +547,8 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyPtr(ref mutable_type) => {\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyRptr(ref opt_lifetime, ref mutable_type) => {\n-            walk_list!(visitor, visit_lifetime, opt_lifetime);\n+        TyRptr(ref lifetime, ref mutable_type) => {\n+            visitor.visit_lifetime(lifetime);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n         TyNever => {},\n@@ -566,8 +566,11 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_ty(ty);\n             visitor.visit_nested_body(length)\n         }\n-        TyTraitObject(ref bounds) => {\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n+        TyTraitObject(ref bounds, ref lifetime) => {\n+            for bound in bounds {\n+                visitor.visit_poly_trait_ref(bound, TraitBoundModifier::None);\n+            }\n+            visitor.visit_lifetime(lifetime);\n         }\n         TyImplTrait(ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n@@ -695,7 +698,7 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v\n \n pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v TyParamBound) {\n     match *bound {\n-        TraitTyParamBound(ref typ, ref modifier) => {\n+        TraitTyParamBound(ref typ, modifier) => {\n             visitor.visit_poly_trait_ref(typ, modifier);\n         }\n         RegionTyParamBound(ref lifetime) => {"}, {"sha": "8a4acb3d03880b57acd47ec2c2885892f71afe89", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 169, "deletions": 38, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -41,12 +41,12 @@\n // in the HIR, especially for multiple identifiers.\n \n use hir;\n-use hir::map::Definitions;\n+use hir::map::{Definitions, DefKey};\n use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId};\n use hir::def::{Def, PathResolution};\n use session::Session;\n-use util::nodemap::{NodeMap, FxHashMap};\n+use util::nodemap::{DefIdMap, NodeMap, FxHashMap};\n \n use std::collections::BTreeMap;\n use std::iter;\n@@ -78,6 +78,8 @@ pub struct LoweringContext<'a> {\n     trait_items: BTreeMap<hir::TraitItemId, hir::TraitItem>,\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n     bodies: FxHashMap<hir::BodyId, hir::Body>,\n+\n+    type_def_lifetime_params: DefIdMap<usize>,\n }\n \n pub trait Resolver {\n@@ -110,6 +112,7 @@ pub fn lower_crate(sess: &Session,\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n         bodies: FxHashMap(),\n+        type_def_lifetime_params: DefIdMap(),\n     }.lower_crate(krate)\n }\n \n@@ -123,24 +126,33 @@ enum ParamMode {\n \n impl<'a> LoweringContext<'a> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n-        self.lower_items(c);\n-        let module = self.lower_mod(&c.module);\n-        let attrs = self.lower_attrs(&c.attrs);\n-        let exported_macros = c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect();\n+        /// Full-crate AST visitor that inserts into a fresh\n+        /// `LoweringContext` any information that may be\n+        /// needed from arbitrary locations in the crate.\n+        /// E.g. The number of lifetime generic parameters\n+        /// declared for every type and trait definition.\n+        struct MiscCollector<'lcx, 'interner: 'lcx> {\n+            lctx: &'lcx mut LoweringContext<'interner>,\n+        }\n \n-        hir::Crate {\n-            module: module,\n-            attrs: attrs,\n-            span: c.span,\n-            exported_macros: exported_macros,\n-            items: self.items,\n-            trait_items: self.trait_items,\n-            impl_items: self.impl_items,\n-            bodies: self.bodies,\n+        impl<'lcx, 'interner> Visitor<'lcx> for MiscCollector<'lcx, 'interner> {\n+            fn visit_item(&mut self, item: &'lcx Item) {\n+                match item.node {\n+                    ItemKind::Struct(_, ref generics) |\n+                    ItemKind::Union(_, ref generics) |\n+                    ItemKind::Enum(_, ref generics) |\n+                    ItemKind::Ty(_, ref generics) |\n+                    ItemKind::Trait(_, ref generics, ..) => {\n+                        let def_id = self.lctx.resolver.definitions().local_def_id(item.id);\n+                        let count = generics.lifetimes.len();\n+                        self.lctx.type_def_lifetime_params.insert(def_id, count);\n+                    }\n+                    _ => {}\n+                }\n+                visit::walk_item(self, item);\n+            }\n         }\n-    }\n \n-    fn lower_items(&mut self, c: &Crate) {\n         struct ItemLowerer<'lcx, 'interner: 'lcx> {\n             lctx: &'lcx mut LoweringContext<'interner>,\n         }\n@@ -167,8 +179,23 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n-        let mut item_lowerer = ItemLowerer { lctx: self };\n-        visit::walk_crate(&mut item_lowerer, c);\n+        visit::walk_crate(&mut MiscCollector { lctx: &mut self }, c);\n+        visit::walk_crate(&mut ItemLowerer { lctx: &mut self }, c);\n+\n+        let module = self.lower_mod(&c.module);\n+        let attrs = self.lower_attrs(&c.attrs);\n+        let exported_macros = c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect();\n+\n+        hir::Crate {\n+            module: module,\n+            attrs: attrs,\n+            span: c.span,\n+            exported_macros: exported_macros,\n+            items: self.items,\n+            trait_items: self.trait_items,\n+            impl_items: self.impl_items,\n+            bodies: self.bodies,\n+        }\n     }\n \n     fn record_body(&mut self, value: hir::Expr, decl: Option<&FnDecl>)\n@@ -232,6 +259,14 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n+    fn def_key(&mut self, id: DefId) -> DefKey {\n+        if id.is_local() {\n+            self.resolver.definitions().def_key(id.index)\n+        } else {\n+            self.sess.cstore.def_key(id)\n+        }\n+    }\n+\n     fn lower_opt_sp_ident(&mut self, o_id: Option<Spanned<Ident>>) -> Option<Spanned<Name>> {\n         o_id.map(|sp_ident| respan(sp_ident.span, sp_ident.node.name))\n     }\n@@ -279,7 +314,12 @@ impl<'a> LoweringContext<'a> {\n                 TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty)),\n                 TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt)),\n                 TyKind::Rptr(ref region, ref mt) => {\n-                    hir::TyRptr(self.lower_opt_lifetime(region), self.lower_mt(mt))\n+                    let span = Span { hi: t.span.lo, ..t.span };\n+                    let lifetime = match *region {\n+                        Some(ref lt) => self.lower_lifetime(lt),\n+                        None => self.elided_lifetime(span)\n+                    };\n+                    hir::TyRptr(lifetime, self.lower_mt(mt))\n                 }\n                 TyKind::BareFn(ref f) => {\n                     hir::TyBareFn(P(hir::BareFnTy {\n@@ -297,7 +337,8 @@ impl<'a> LoweringContext<'a> {\n                     return self.lower_ty(ty);\n                 }\n                 TyKind::Path(ref qself, ref path) => {\n-                    hir::TyPath(self.lower_qpath(t.id, qself, path, ParamMode::Explicit))\n+                    let qpath = self.lower_qpath(t.id, qself, path, ParamMode::Explicit);\n+                    return self.ty_path(t.id, t.span, qpath);\n                 }\n                 TyKind::ImplicitSelf => {\n                     hir::TyPath(hir::QPath::Resolved(None, P(hir::Path {\n@@ -319,7 +360,23 @@ impl<'a> LoweringContext<'a> {\n                     hir::TyTypeof(self.record_body(expr, None))\n                 }\n                 TyKind::TraitObject(ref bounds) => {\n-                    hir::TyTraitObject(self.lower_bounds(bounds))\n+                    let mut lifetime_bound = None;\n+                    let bounds = bounds.iter().filter_map(|bound| {\n+                        match *bound {\n+                            TraitTyParamBound(ref ty, TraitBoundModifier::None) => {\n+                                Some(self.lower_poly_trait_ref(ty))\n+                            }\n+                            TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n+                            RegionTyParamBound(ref lifetime) => {\n+                                lifetime_bound = Some(self.lower_lifetime(lifetime));\n+                                None\n+                            }\n+                        }\n+                    }).collect();\n+                    let lifetime_bound = lifetime_bound.unwrap_or_else(|| {\n+                        self.elided_lifetime(t.span)\n+                    });\n+                    hir::TyTraitObject(bounds, lifetime_bound)\n                 }\n                 TyKind::ImplTrait(ref bounds) => {\n                     hir::TyImplTrait(self.lower_bounds(bounds))\n@@ -377,7 +434,40 @@ impl<'a> LoweringContext<'a> {\n                     }\n                     _ => param_mode\n                 };\n-                self.lower_path_segment(segment, param_mode)\n+\n+                // Figure out if this is a type/trait segment,\n+                // which may need lifetime elision performed.\n+                let parent_def_id = |this: &mut Self, def_id: DefId| {\n+                    DefId {\n+                        krate: def_id.krate,\n+                        index: this.def_key(def_id).parent.expect(\"missing parent\")\n+                    }\n+                };\n+                let type_def_id = match resolution.base_def {\n+                    Def::AssociatedTy(def_id) if i + 2 == proj_start => {\n+                        Some(parent_def_id(self, def_id))\n+                    }\n+                    Def::Variant(def_id) if i + 1 == proj_start => {\n+                        Some(parent_def_id(self, def_id))\n+                    }\n+                    Def::Struct(def_id) |\n+                    Def::Union(def_id) |\n+                    Def::Enum(def_id) |\n+                    Def::TyAlias(def_id) |\n+                    Def::Trait(def_id) if i + 1 == proj_start => Some(def_id),\n+                    _ => None\n+                };\n+\n+                let num_lifetimes = type_def_id.map_or(0, |def_id| {\n+                    if let Some(&n) = self.type_def_lifetime_params.get(&def_id) {\n+                        return n;\n+                    }\n+                    assert!(!def_id.is_local());\n+                    let (n, _) = self.sess.cstore.item_generics_own_param_counts(def_id);\n+                    self.type_def_lifetime_params.insert(def_id, n);\n+                    n\n+                });\n+                self.lower_path_segment(p.span, segment, param_mode, num_lifetimes)\n             }).collect(),\n             span: p.span,\n         });\n@@ -397,7 +487,8 @@ impl<'a> LoweringContext<'a> {\n             // Otherwise, the base path is an implicit `Self` type path,\n             // e.g. `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n             // `<I as Iterator>::Item::default`.\n-            self.ty(p.span, hir::TyPath(hir::QPath::Resolved(qself, path)))\n+            let new_id = self.next_id();\n+            self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path))\n         };\n \n         // Anything after the base path are associated \"extensions\",\n@@ -411,7 +502,7 @@ impl<'a> LoweringContext<'a> {\n         //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n         // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n         for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n-            let segment = P(self.lower_path_segment(segment, param_mode));\n+            let segment = P(self.lower_path_segment(p.span, segment, param_mode, 0));\n             let qpath = hir::QPath::TypeRelative(ty, segment);\n \n             // It's finished, return the extension of the right node type.\n@@ -420,7 +511,8 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             // Wrap the associated extension in another type node.\n-            ty = self.ty(p.span, hir::TyPath(qpath));\n+            let new_id = self.next_id();\n+            ty = self.ty_path(new_id, p.span, qpath);\n         }\n \n         // Should've returned in the for loop above.\n@@ -443,7 +535,7 @@ impl<'a> LoweringContext<'a> {\n         hir::Path {\n             def: self.expect_full_def(id),\n             segments: segments.map(|segment| {\n-                self.lower_path_segment(segment, param_mode)\n+                self.lower_path_segment(p.span, segment, param_mode, 0)\n             }).chain(name.map(|name| {\n                 hir::PathSegment {\n                     name: name,\n@@ -464,10 +556,12 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_path_segment(&mut self,\n+                          path_span: Span,\n                           segment: &PathSegment,\n-                          param_mode: ParamMode)\n+                          param_mode: ParamMode,\n+                          expected_lifetimes: usize)\n                           -> hir::PathSegment {\n-        let parameters = if let Some(ref parameters) = segment.parameters {\n+        let mut parameters = if let Some(ref parameters) = segment.parameters {\n             match **parameters {\n                 PathParameters::AngleBracketed(ref data) => {\n                     let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n@@ -482,6 +576,14 @@ impl<'a> LoweringContext<'a> {\n             hir::AngleBracketedParameters(data)\n         };\n \n+        if let hir::AngleBracketedParameters(ref mut data) = parameters {\n+            if data.lifetimes.is_empty() {\n+                data.lifetimes = (0..expected_lifetimes).map(|_| {\n+                    self.elided_lifetime(path_span)\n+                }).collect();\n+            }\n+        }\n+\n         hir::PathSegment {\n             name: segment.identifier.name,\n             parameters: parameters,\n@@ -628,10 +730,6 @@ impl<'a> LoweringContext<'a> {\n         lts.iter().map(|l| self.lower_lifetime_def(l)).collect()\n     }\n \n-    fn lower_opt_lifetime(&mut self, o_lt: &Option<Lifetime>) -> Option<hir::Lifetime> {\n-        o_lt.as_ref().map(|lt| self.lower_lifetime(lt))\n-    }\n-\n     fn lower_generics(&mut self, g: &Generics) -> hir::Generics {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n         let mut add_bounds = NodeMap();\n@@ -751,8 +849,12 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_trait_ref(&mut self, p: &TraitRef) -> hir::TraitRef {\n+        let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit) {\n+            hir::QPath::Resolved(None, path) => path.and_then(|path| path),\n+            qpath => bug!(\"lower_trait_ref: unexpected QPath `{:?}`\", qpath)\n+        };\n         hir::TraitRef {\n-            path: self.lower_path(p.ref_id, &p.path, ParamMode::Explicit, false),\n+            path: path,\n             ref_id: p.ref_id,\n         }\n     }\n@@ -2269,11 +2371,40 @@ impl<'a> LoweringContext<'a> {\n         self.expr_block(block, attrs)\n     }\n \n-    fn ty(&mut self, span: Span, node: hir::Ty_) -> P<hir::Ty> {\n-        P(hir::Ty {\n+    fn ty_path(&mut self, id: NodeId, span: Span, qpath: hir::QPath) -> P<hir::Ty> {\n+        let mut id = id;\n+        let node = match qpath {\n+            hir::QPath::Resolved(None, path) => {\n+                // Turn trait object paths into `TyTraitObject` instead.\n+                if let Def::Trait(_) = path.def {\n+                    let principal = hir::PolyTraitRef {\n+                        bound_lifetimes: hir_vec![],\n+                        trait_ref: hir::TraitRef {\n+                            path: path.and_then(|path| path),\n+                            ref_id: id,\n+                        },\n+                        span,\n+                    };\n+\n+                    // The original ID is taken by the `PolyTraitRef`,\n+                    // so the `Ty` itself needs a different one.\n+                    id = self.next_id();\n+\n+                    hir::TyTraitObject(hir_vec![principal], self.elided_lifetime(span))\n+                } else {\n+                    hir::TyPath(hir::QPath::Resolved(None, path))\n+                }\n+            }\n+            _ => hir::TyPath(qpath)\n+        };\n+        P(hir::Ty { id, node, span })\n+    }\n+\n+    fn elided_lifetime(&mut self, span: Span) -> hir::Lifetime {\n+        hir::Lifetime {\n             id: self.next_id(),\n-            node: node,\n             span: span,\n-        })\n+            name: keywords::Invalid.name()\n+        }\n     }\n }"}, {"sha": "ff2f1dc1ba28a85f83f67d795c56ed2f50cfeaa5", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -38,7 +38,7 @@ use syntax_pos::Span;\n ///   - The default implementation for a trait method.\n ///\n /// To construct one, use the `Code::from_node` function.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub struct FnLikeNode<'a> { node: map::Node<'a> }\n \n /// MaybeFnLike wraps a method that indicates if an object"}, {"sha": "4ebe416e1bfe67c12300b0b9b7d6a62cf3b55019", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 15, "deletions": 32, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -77,6 +77,13 @@ pub mod svh;\n pub struct Lifetime {\n     pub id: NodeId,\n     pub span: Span,\n+\n+    /// Either \"'a\", referring to a named lifetime definition,\n+    /// or \"\" (aka keywords::Invalid), for elision placeholders.\n+    ///\n+    /// HIR lowering inserts these placeholders in type paths that\n+    /// refer to type definitions needing lifetime parameters,\n+    /// `&T` and `&mut T`, and trait objects without `... + 'a`.\n     pub name: Name,\n }\n \n@@ -89,6 +96,12 @@ impl fmt::Debug for Lifetime {\n     }\n }\n \n+impl Lifetime {\n+    pub fn is_elided(&self) -> bool {\n+        self.name == keywords::Invalid.name()\n+    }\n+}\n+\n /// A lifetime definition, eg `'a: 'b+'c+'d`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct LifetimeDef {\n@@ -165,30 +178,6 @@ impl PathParameters {\n         })\n     }\n \n-    pub fn is_empty(&self) -> bool {\n-        match *self {\n-            AngleBracketedParameters(ref data) => data.is_empty(),\n-\n-            // Even if the user supplied no types, something like\n-            // `X()` is equivalent to `X<(),()>`.\n-            ParenthesizedParameters(..) => false,\n-        }\n-    }\n-\n-    pub fn has_lifetimes(&self) -> bool {\n-        match *self {\n-            AngleBracketedParameters(ref data) => !data.lifetimes.is_empty(),\n-            ParenthesizedParameters(_) => false,\n-        }\n-    }\n-\n-    pub fn has_types(&self) -> bool {\n-        match *self {\n-            AngleBracketedParameters(ref data) => !data.types.is_empty(),\n-            ParenthesizedParameters(..) => true,\n-        }\n-    }\n-\n     /// Returns the types that the user wrote. Note that these do not necessarily map to the type\n     /// parameters in the parenthesized case.\n     pub fn types(&self) -> HirVec<&P<Ty>> {\n@@ -245,12 +234,6 @@ pub struct AngleBracketedParameterData {\n     pub bindings: HirVec<TypeBinding>,\n }\n \n-impl AngleBracketedParameterData {\n-    fn is_empty(&self) -> bool {\n-        self.lifetimes.is_empty() && self.types.is_empty() && self.bindings.is_empty()\n-    }\n-}\n-\n /// A path like `Foo(A,B) -> C`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ParenthesizedParameterData {\n@@ -1208,7 +1191,7 @@ pub enum Ty_ {\n     /// A raw pointer (`*const T` or `*mut T`)\n     TyPtr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`)\n-    TyRptr(Option<Lifetime>, MutTy),\n+    TyRptr(Lifetime, MutTy),\n     /// A bare function (e.g. `fn(usize) -> bool`)\n     TyBareFn(P<BareFnTy>),\n     /// The never type (`!`)\n@@ -1222,7 +1205,7 @@ pub enum Ty_ {\n     TyPath(QPath),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n-    TyTraitObject(TyParamBounds),\n+    TyTraitObject(HirVec<PolyTraitRef>, Lifetime),\n     /// An `impl Bound1 + Bound2 + Bound3` type\n     /// where `Bound` is a trait or a lifetime.\n     TyImplTrait(TyParamBounds),"}, {"sha": "e058c48c59149b2995a5d8393e0887423d504e35", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 39, "deletions": 41, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -26,6 +26,7 @@ use syntax_pos::{self, BytePos};\n use hir;\n use hir::{PatKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier, RangeEnd};\n \n+use std::cell::Cell;\n use std::io::{self, Write, Read};\n \n pub enum AnnNode<'a> {\n@@ -359,9 +360,9 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_opt_lifetime(&mut self, lifetime: &Option<hir::Lifetime>) -> io::Result<()> {\n-        if let Some(l) = *lifetime {\n-            self.print_lifetime(&l)?;\n+    pub fn print_opt_lifetime(&mut self, lifetime: &hir::Lifetime) -> io::Result<()> {\n+        if !lifetime.is_elided() {\n+            self.print_lifetime(lifetime)?;\n             self.nbsp()?;\n         }\n         Ok(())\n@@ -415,8 +416,21 @@ impl<'a> State<'a> {\n             hir::TyPath(ref qpath) => {\n                 self.print_qpath(qpath, false)?\n             }\n-            hir::TyTraitObject(ref bounds) => {\n-                self.print_bounds(\"\", &bounds[..])?;\n+            hir::TyTraitObject(ref bounds, ref lifetime) => {\n+                let mut first = true;\n+                for bound in bounds {\n+                    self.nbsp()?;\n+                    if first {\n+                        first = false;\n+                    } else {\n+                        self.word_space(\"+\")?;\n+                    }\n+                    self.print_poly_trait_ref(bound)?;\n+                }\n+                if !lifetime.is_elided() {\n+                    self.word_space(\"+\")?;\n+                    self.print_lifetime(lifetime)?;\n+                }\n             }\n             hir::TyImplTrait(ref bounds) => {\n                 self.print_bounds(\"impl \", &bounds[..])?;\n@@ -1553,65 +1567,49 @@ impl<'a> State<'a> {\n                              parameters: &hir::PathParameters,\n                              colons_before_params: bool)\n                              -> io::Result<()> {\n-        if parameters.is_empty() {\n-            let infer_types = match *parameters {\n-                hir::AngleBracketedParameters(ref data) => data.infer_types,\n-                hir::ParenthesizedParameters(_) => false\n-            };\n-\n-            // FIXME(eddyb) See the comment below about infer_types.\n-            if !(infer_types && false) {\n-                return Ok(());\n-            }\n-        }\n-\n-        if colons_before_params {\n-            word(&mut self.s, \"::\")?\n-        }\n-\n         match *parameters {\n             hir::AngleBracketedParameters(ref data) => {\n-                word(&mut self.s, \"<\")?;\n+                let start = if colons_before_params { \"::<\" } else { \"<\" };\n+                let empty = Cell::new(true);\n+                let start_or_comma = |this: &mut Self| {\n+                    if empty.get() {\n+                        empty.set(false);\n+                        word(&mut this.s, start)\n+                    } else {\n+                        this.word_space(\",\")\n+                    }\n+                };\n \n-                let mut comma = false;\n-                for lifetime in &data.lifetimes {\n-                    if comma {\n-                        self.word_space(\",\")?\n+                if !data.lifetimes.iter().all(|lt| lt.is_elided()) {\n+                    for lifetime in &data.lifetimes {\n+                        start_or_comma(self)?;\n+                        self.print_lifetime(lifetime)?;\n                     }\n-                    self.print_lifetime(lifetime)?;\n-                    comma = true;\n                 }\n \n                 if !data.types.is_empty() {\n-                    if comma {\n-                        self.word_space(\",\")?\n-                    }\n+                    start_or_comma(self)?;\n                     self.commasep(Inconsistent, &data.types, |s, ty| s.print_type(&ty))?;\n-                    comma = true;\n                 }\n \n                 // FIXME(eddyb) This would leak into error messages, e.g.:\n                 // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n                 if data.infer_types && false {\n-                    if comma {\n-                        self.word_space(\",\")?\n-                    }\n+                    start_or_comma(self)?;\n                     word(&mut self.s, \"..\")?;\n-                    comma = true;\n                 }\n \n                 for binding in data.bindings.iter() {\n-                    if comma {\n-                        self.word_space(\",\")?\n-                    }\n+                    start_or_comma(self)?;\n                     self.print_name(binding.name)?;\n                     space(&mut self.s)?;\n                     self.word_space(\"=\")?;\n                     self.print_type(&binding.ty)?;\n-                    comma = true;\n                 }\n \n-                word(&mut self.s, \">\")?\n+                if !empty.get() {\n+                    word(&mut self.s, \">\")?\n+                }\n             }\n \n             hir::ParenthesizedParameters(ref data) => {"}, {"sha": "2489a6a6c7a6304e46d552a86112f2ce68d15a22", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 714, "changes": 718, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -55,8 +55,6 @@\n //! ported to this system, and which relies on string concatenation at the\n //! time of error detection.\n \n-use self::FreshOrKept::*;\n-\n use super::InferCtxt;\n use super::TypeTrace;\n use super::SubregionOrigin;\n@@ -71,13 +69,10 @@ use super::region_inference::ProcessedErrors;\n use super::region_inference::ProcessedErrorOrigin;\n use super::region_inference::SameRegions;\n \n-use std::collections::HashSet;\n-\n use hir::map as hir_map;\n use hir;\n \n use lint;\n-use hir::def::Def;\n use hir::def_id::DefId;\n use infer;\n use middle::region;\n@@ -86,13 +81,9 @@ use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, ReFree};\n use ty::error::TypeError;\n \n-use std::cell::{Cell, RefCell};\n-use std::char::from_u32;\n use std::fmt;\n use syntax::ast;\n-use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n-use syntax_pos::{self, Pos, Span};\n+use syntax_pos::{Pos, Span};\n use errors::DiagnosticBuilder;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -292,7 +283,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ProcessedErrors(ref origins,\n                                 ref same_regions) => {\n                     if !same_regions.is_empty() {\n-                        self.report_processed_errors(origins, same_regions);\n+                        self.report_processed_errors(origins);\n                     }\n                 }\n             }\n@@ -1050,88 +1041,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn report_processed_errors(&self,\n-                               origins: &[ProcessedErrorOrigin<'tcx>],\n-                               same_regions: &[SameRegions]) {\n-        for (i, origin) in origins.iter().enumerate() {\n+                               origins: &[ProcessedErrorOrigin<'tcx>]) {\n+        for origin in origins.iter() {\n             let mut err = match *origin {\n                 ProcessedErrorOrigin::VariableFailure(ref var_origin) =>\n                     self.report_inference_failure(var_origin.clone()),\n                 ProcessedErrorOrigin::ConcreteFailure(ref sr_origin, sub, sup) =>\n                     self.report_concrete_failure(sr_origin.clone(), sub, sup),\n             };\n \n-            // attach the suggestion to the last such error\n-            if i == origins.len() - 1 {\n-                self.give_suggestion(&mut err, same_regions);\n-            }\n-\n             err.emit();\n         }\n     }\n \n-    fn give_suggestion(&self, err: &mut DiagnosticBuilder, same_regions: &[SameRegions]) {\n-        let scope_id = same_regions[0].scope_id;\n-        let parent = self.tcx.hir.get_parent(scope_id);\n-        let parent_node = self.tcx.hir.find(parent);\n-        let taken = lifetimes_in_scope(self.tcx, scope_id);\n-        let life_giver = LifeGiver::with_taken(&taken[..]);\n-        let node_inner = match parent_node {\n-            Some(ref node) => match *node {\n-                hir_map::NodeItem(ref item) => {\n-                    match item.node {\n-                        hir::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, body) => {\n-                            Some((fn_decl, gen, unsafety, constness, item.name, item.span, body))\n-                        }\n-                        _ => None,\n-                    }\n-                }\n-                hir_map::NodeImplItem(item) => {\n-                    let id = self.tcx.hir.get_parent(item.id);\n-                    if let Some(hir_map::NodeItem(parent_scope)) = self.tcx.hir.find(id) {\n-                        if let hir::ItemImpl(_, _, _, None, _, _) = parent_scope.node {\n-                            // this impl scope implements a trait, do not recomend\n-                            // using explicit lifetimes (#37363)\n-                            return;\n-                        }\n-                    }\n-                    if let hir::ImplItemKind::Method(ref sig, body) = item.node {\n-                        Some((&sig.decl,\n-                              &sig.generics,\n-                              sig.unsafety,\n-                              sig.constness,\n-                              item.name,\n-                              item.span,\n-                              body))\n-                    } else {\n-                        None\n-                    }\n-                },\n-                hir_map::NodeTraitItem(item) => {\n-                    match item.node {\n-                        hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n-                            Some((&sig.decl,\n-                                  &sig.generics,\n-                                  sig.unsafety,\n-                                  sig.constness,\n-                                  item.name,\n-                                  item.span,\n-                                  body))\n-                        }\n-                        _ => None,\n-                    }\n-                }\n-                _ => None,\n-            },\n-            None => None,\n-        };\n-        let (fn_decl, generics, unsafety, constness, name, span, body)\n-                                    = node_inner.expect(\"expect item fn\");\n-        let rebuilder = Rebuilder::new(self.tcx, fn_decl, generics, same_regions, &life_giver);\n-        let (fn_decl, generics) = rebuilder.rebuild();\n-        self.give_expl_lifetime_param(\n-            err, &fn_decl, unsafety, constness, name, &generics, span, body);\n-    }\n-\n     pub fn issue_32330_warnings(&self, span: Span, issue32330s: &[ty::Issue32330]) {\n         for issue32330 in issue32330s {\n             match *issue32330 {\n@@ -1154,530 +1076,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-struct RebuildPathInfo<'a> {\n-    path: &'a hir::Path,\n-    // indexes to insert lifetime on path.lifetimes\n-    indexes: Vec<u32>,\n-    // number of lifetimes we expect to see on the type referred by `path`\n-    // (e.g., expected=1 for struct Foo<'a>)\n-    expected: u32,\n-    anon_nums: &'a HashSet<u32>,\n-    region_names: &'a HashSet<ast::Name>\n-}\n-\n-struct Rebuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    fn_decl: &'a hir::FnDecl,\n-    generics: &'a hir::Generics,\n-    same_regions: &'a [SameRegions],\n-    life_giver: &'a LifeGiver,\n-    cur_anon: Cell<u32>,\n-    inserted_anons: RefCell<HashSet<u32>>,\n-}\n-\n-enum FreshOrKept {\n-    Fresh,\n-    Kept\n-}\n-\n-impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-           fn_decl: &'a hir::FnDecl,\n-           generics: &'a hir::Generics,\n-           same_regions: &'a [SameRegions],\n-           life_giver: &'a LifeGiver)\n-           -> Rebuilder<'a, 'gcx, 'tcx> {\n-        Rebuilder {\n-            tcx: tcx,\n-            fn_decl: fn_decl,\n-            generics: generics,\n-            same_regions: same_regions,\n-            life_giver: life_giver,\n-            cur_anon: Cell::new(0),\n-            inserted_anons: RefCell::new(HashSet::new()),\n-        }\n-    }\n-\n-    fn rebuild(&self) -> (hir::FnDecl, hir::Generics) {\n-        let mut inputs = self.fn_decl.inputs.clone();\n-        let mut output = self.fn_decl.output.clone();\n-        let mut ty_params = self.generics.ty_params.clone();\n-        let where_clause = self.generics.where_clause.clone();\n-        let mut kept_lifetimes = HashSet::new();\n-        for sr in self.same_regions {\n-            self.cur_anon.set(0);\n-            self.offset_cur_anon();\n-            let (anon_nums, region_names) =\n-                                self.extract_anon_nums_and_names(sr);\n-            let (lifetime, fresh_or_kept) = self.pick_lifetime(&region_names);\n-            match fresh_or_kept {\n-                Kept => { kept_lifetimes.insert(lifetime.name); }\n-                _ => ()\n-            }\n-            inputs = self.rebuild_args_ty(&inputs[..], lifetime,\n-                                          &anon_nums, &region_names);\n-            output = self.rebuild_output(&output, lifetime, &anon_nums, &region_names);\n-            ty_params = self.rebuild_ty_params(ty_params, lifetime,\n-                                               &region_names);\n-        }\n-        let fresh_lifetimes = self.life_giver.get_generated_lifetimes();\n-        let all_region_names = self.extract_all_region_names();\n-        let generics = self.rebuild_generics(self.generics,\n-                                             &fresh_lifetimes,\n-                                             &kept_lifetimes,\n-                                             &all_region_names,\n-                                             ty_params,\n-                                             where_clause);\n-        let new_fn_decl = hir::FnDecl {\n-            inputs: inputs,\n-            output: output,\n-            variadic: self.fn_decl.variadic\n-        };\n-        (new_fn_decl, generics)\n-    }\n-\n-    fn pick_lifetime(&self,\n-                     region_names: &HashSet<ast::Name>)\n-                     -> (hir::Lifetime, FreshOrKept) {\n-        if !region_names.is_empty() {\n-            // It's not necessary to convert the set of region names to a\n-            // vector of string and then sort them. However, it makes the\n-            // choice of lifetime name deterministic and thus easier to test.\n-            let mut names = Vec::new();\n-            for rn in region_names {\n-                let lt_name = rn.to_string();\n-                names.push(lt_name);\n-            }\n-            names.sort();\n-            let name = Symbol::intern(&names[0]);\n-            return (name_to_dummy_lifetime(name), Kept);\n-        }\n-        return (self.life_giver.give_lifetime(), Fresh);\n-    }\n-\n-    fn extract_anon_nums_and_names(&self, same_regions: &SameRegions)\n-                                   -> (HashSet<u32>, HashSet<ast::Name>) {\n-        let mut anon_nums = HashSet::new();\n-        let mut region_names = HashSet::new();\n-        for br in &same_regions.regions {\n-            match *br {\n-                ty::BrAnon(i) => {\n-                    anon_nums.insert(i);\n-                }\n-                ty::BrNamed(_, name, _) => {\n-                    region_names.insert(name);\n-                }\n-                _ => ()\n-            }\n-        }\n-        (anon_nums, region_names)\n-    }\n-\n-    fn extract_all_region_names(&self) -> HashSet<ast::Name> {\n-        let mut all_region_names = HashSet::new();\n-        for sr in self.same_regions {\n-            for br in &sr.regions {\n-                match *br {\n-                    ty::BrNamed(_, name, _) => {\n-                        all_region_names.insert(name);\n-                    }\n-                    _ => ()\n-                }\n-            }\n-        }\n-        all_region_names\n-    }\n-\n-    fn inc_cur_anon(&self, n: u32) {\n-        let anon = self.cur_anon.get();\n-        self.cur_anon.set(anon+n);\n-    }\n-\n-    fn offset_cur_anon(&self) {\n-        let mut anon = self.cur_anon.get();\n-        while self.inserted_anons.borrow().contains(&anon) {\n-            anon += 1;\n-        }\n-        self.cur_anon.set(anon);\n-    }\n-\n-    fn inc_and_offset_cur_anon(&self, n: u32) {\n-        self.inc_cur_anon(n);\n-        self.offset_cur_anon();\n-    }\n-\n-    fn track_anon(&self, anon: u32) {\n-        self.inserted_anons.borrow_mut().insert(anon);\n-    }\n-\n-    fn rebuild_ty_params(&self,\n-                         ty_params: hir::HirVec<hir::TyParam>,\n-                         lifetime: hir::Lifetime,\n-                         region_names: &HashSet<ast::Name>)\n-                         -> hir::HirVec<hir::TyParam> {\n-        ty_params.into_iter().map(|ty_param| {\n-            let bounds = self.rebuild_ty_param_bounds(ty_param.bounds,\n-                                                      lifetime,\n-                                                      region_names);\n-            hir::TyParam {\n-                name: ty_param.name,\n-                id: ty_param.id,\n-                bounds: bounds,\n-                default: ty_param.default,\n-                span: ty_param.span,\n-                pure_wrt_drop: ty_param.pure_wrt_drop,\n-            }\n-        }).collect()\n-    }\n-\n-    fn rebuild_ty_param_bounds(&self,\n-                               ty_param_bounds: hir::TyParamBounds,\n-                               lifetime: hir::Lifetime,\n-                               region_names: &HashSet<ast::Name>)\n-                               -> hir::TyParamBounds {\n-        ty_param_bounds.iter().map(|tpb| {\n-            match tpb {\n-                &hir::RegionTyParamBound(lt) => {\n-                    // FIXME -- it's unclear whether I'm supposed to\n-                    // substitute lifetime here. I suspect we need to\n-                    // be passing down a map.\n-                    hir::RegionTyParamBound(lt)\n-                }\n-                &hir::TraitTyParamBound(ref poly_tr, modifier) => {\n-                    let tr = &poly_tr.trait_ref;\n-                    let last_seg = tr.path.segments.last().unwrap();\n-                    let mut insert = Vec::new();\n-                    let lifetimes = last_seg.parameters.lifetimes();\n-                    for (i, lt) in lifetimes.iter().enumerate() {\n-                        if region_names.contains(&lt.name) {\n-                            insert.push(i as u32);\n-                        }\n-                    }\n-                    let rebuild_info = RebuildPathInfo {\n-                        path: &tr.path,\n-                        indexes: insert,\n-                        expected: lifetimes.len() as u32,\n-                        anon_nums: &HashSet::new(),\n-                        region_names: region_names\n-                    };\n-                    let new_path = self.rebuild_path(rebuild_info, lifetime);\n-                    hir::TraitTyParamBound(hir::PolyTraitRef {\n-                        bound_lifetimes: poly_tr.bound_lifetimes.clone(),\n-                        trait_ref: hir::TraitRef {\n-                            path: new_path,\n-                            ref_id: tr.ref_id,\n-                        },\n-                        span: poly_tr.span,\n-                    }, modifier)\n-                }\n-            }\n-        }).collect()\n-    }\n-\n-    fn rebuild_generics(&self,\n-                        generics: &hir::Generics,\n-                        add: &Vec<hir::Lifetime>,\n-                        keep: &HashSet<ast::Name>,\n-                        remove: &HashSet<ast::Name>,\n-                        ty_params: hir::HirVec<hir::TyParam>,\n-                        where_clause: hir::WhereClause)\n-                        -> hir::Generics {\n-        let mut lifetimes = Vec::new();\n-        for lt in add {\n-            lifetimes.push(hir::LifetimeDef {\n-                lifetime: *lt,\n-                bounds: hir::HirVec::new(),\n-                pure_wrt_drop: false,\n-            });\n-        }\n-        for lt in &generics.lifetimes {\n-            if keep.contains(&lt.lifetime.name) ||\n-                !remove.contains(&lt.lifetime.name) {\n-                lifetimes.push((*lt).clone());\n-            }\n-        }\n-        hir::Generics {\n-            lifetimes: lifetimes.into(),\n-            ty_params: ty_params,\n-            where_clause: where_clause,\n-            span: generics.span,\n-        }\n-    }\n-\n-    fn rebuild_args_ty(&self,\n-                       inputs: &[P<hir::Ty>],\n-                       lifetime: hir::Lifetime,\n-                       anon_nums: &HashSet<u32>,\n-                       region_names: &HashSet<ast::Name>)\n-                       -> hir::HirVec<P<hir::Ty>> {\n-        inputs.iter().map(|arg_ty| {\n-            self.rebuild_arg_ty_or_output(arg_ty, lifetime, anon_nums, region_names)\n-        }).collect()\n-    }\n-\n-    fn rebuild_output(&self, ty: &hir::FunctionRetTy,\n-                      lifetime: hir::Lifetime,\n-                      anon_nums: &HashSet<u32>,\n-                      region_names: &HashSet<ast::Name>) -> hir::FunctionRetTy {\n-        match *ty {\n-            hir::Return(ref ret_ty) => hir::Return(\n-                self.rebuild_arg_ty_or_output(&ret_ty, lifetime, anon_nums, region_names)\n-            ),\n-            hir::DefaultReturn(span) => hir::DefaultReturn(span),\n-        }\n-    }\n-\n-    fn rebuild_arg_ty_or_output(&self,\n-                                ty: &hir::Ty,\n-                                lifetime: hir::Lifetime,\n-                                anon_nums: &HashSet<u32>,\n-                                region_names: &HashSet<ast::Name>)\n-                                -> P<hir::Ty> {\n-        let mut new_ty = P(ty.clone());\n-        let mut ty_queue = vec![ty];\n-        while !ty_queue.is_empty() {\n-            let cur_ty = ty_queue.remove(0);\n-            match cur_ty.node {\n-                hir::TyRptr(lt_opt, ref mut_ty) => {\n-                    let rebuild = match lt_opt {\n-                        Some(lt) => region_names.contains(&lt.name),\n-                        None => {\n-                            let anon = self.cur_anon.get();\n-                            let rebuild = anon_nums.contains(&anon);\n-                            if rebuild {\n-                                self.track_anon(anon);\n-                            }\n-                            self.inc_and_offset_cur_anon(1);\n-                            rebuild\n-                        }\n-                    };\n-                    if rebuild {\n-                        let to = hir::Ty {\n-                            id: cur_ty.id,\n-                            node: hir::TyRptr(Some(lifetime), mut_ty.clone()),\n-                            span: cur_ty.span\n-                        };\n-                        new_ty = self.rebuild_ty(new_ty, P(to));\n-                    }\n-                    ty_queue.push(&mut_ty.ty);\n-                }\n-                hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n-                    match path.def {\n-                        Def::Enum(did) | Def::TyAlias(did) |\n-                        Def::Struct(did) | Def::Union(did) => {\n-                            let generics = self.tcx.item_generics(did);\n-\n-                            let expected =\n-                                generics.regions.len() as u32;\n-                            let lifetimes =\n-                                path.segments.last().unwrap().parameters.lifetimes();\n-                            let mut insert = Vec::new();\n-                            if lifetimes.is_empty() {\n-                                let anon = self.cur_anon.get();\n-                                for (i, a) in (anon..anon+expected).enumerate() {\n-                                    if anon_nums.contains(&a) {\n-                                        insert.push(i as u32);\n-                                    }\n-                                    self.track_anon(a);\n-                                }\n-                                self.inc_and_offset_cur_anon(expected);\n-                            } else {\n-                                for (i, lt) in lifetimes.iter().enumerate() {\n-                                    if region_names.contains(&lt.name) {\n-                                        insert.push(i as u32);\n-                                    }\n-                                }\n-                            }\n-                            let rebuild_info = RebuildPathInfo {\n-                                path: path,\n-                                indexes: insert,\n-                                expected: expected,\n-                                anon_nums: anon_nums,\n-                                region_names: region_names\n-                            };\n-                            let new_path = self.rebuild_path(rebuild_info, lifetime);\n-                            let qself = maybe_qself.as_ref().map(|qself| {\n-                                self.rebuild_arg_ty_or_output(qself, lifetime,\n-                                                              anon_nums, region_names)\n-                            });\n-                            let to = hir::Ty {\n-                                id: cur_ty.id,\n-                                node: hir::TyPath(hir::QPath::Resolved(qself, P(new_path))),\n-                                span: cur_ty.span\n-                            };\n-                            new_ty = self.rebuild_ty(new_ty, P(to));\n-                        }\n-                        _ => ()\n-                    }\n-                }\n-\n-                hir::TyPtr(ref mut_ty) => {\n-                    ty_queue.push(&mut_ty.ty);\n-                }\n-                hir::TySlice(ref ty) |\n-                hir::TyArray(ref ty, _) => {\n-                    ty_queue.push(&ty);\n-                }\n-                hir::TyTup(ref tys) => ty_queue.extend(tys.iter().map(|ty| &**ty)),\n-                _ => {}\n-            }\n-        }\n-        new_ty\n-    }\n-\n-    fn rebuild_ty(&self,\n-                  from: P<hir::Ty>,\n-                  to: P<hir::Ty>)\n-                  -> P<hir::Ty> {\n-\n-        fn build_to(from: P<hir::Ty>,\n-                    to: &mut Option<P<hir::Ty>>)\n-                    -> P<hir::Ty> {\n-            if Some(from.id) == to.as_ref().map(|ty| ty.id) {\n-                return to.take().expect(\"`to` type found more than once during rebuild\");\n-            }\n-            from.map(|hir::Ty {id, node, span}| {\n-                let new_node = match node {\n-                    hir::TyRptr(lifetime, mut_ty) => {\n-                        hir::TyRptr(lifetime, hir::MutTy {\n-                            mutbl: mut_ty.mutbl,\n-                            ty: build_to(mut_ty.ty, to),\n-                        })\n-                    }\n-                    hir::TyPtr(mut_ty) => {\n-                        hir::TyPtr(hir::MutTy {\n-                            mutbl: mut_ty.mutbl,\n-                            ty: build_to(mut_ty.ty, to),\n-                        })\n-                    }\n-                    hir::TySlice(ty) => hir::TySlice(build_to(ty, to)),\n-                    hir::TyArray(ty, e) => {\n-                        hir::TyArray(build_to(ty, to), e)\n-                    }\n-                    hir::TyTup(tys) => {\n-                        hir::TyTup(tys.into_iter().map(|ty| build_to(ty, to)).collect())\n-                    }\n-                    other => other\n-                };\n-                hir::Ty { id: id, node: new_node, span: span }\n-            })\n-        }\n-\n-        build_to(from, &mut Some(to))\n-    }\n-\n-    fn rebuild_path(&self,\n-                    rebuild_info: RebuildPathInfo,\n-                    lifetime: hir::Lifetime)\n-                    -> hir::Path\n-    {\n-        let RebuildPathInfo {\n-            path,\n-            indexes,\n-            expected,\n-            anon_nums,\n-            region_names,\n-        } = rebuild_info;\n-\n-        let last_seg = path.segments.last().unwrap();\n-        let new_parameters = match last_seg.parameters {\n-            hir::ParenthesizedParameters(..) => {\n-                last_seg.parameters.clone()\n-            }\n-\n-            hir::AngleBracketedParameters(ref data) => {\n-                let mut new_lts = Vec::new();\n-                if data.lifetimes.is_empty() {\n-                    // traverse once to see if there's a need to insert lifetime\n-                    let need_insert = (0..expected).any(|i| {\n-                        indexes.contains(&i)\n-                    });\n-                    if need_insert {\n-                        for i in 0..expected {\n-                            if indexes.contains(&i) {\n-                                new_lts.push(lifetime);\n-                            } else {\n-                                new_lts.push(self.life_giver.give_lifetime());\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    for (i, lt) in data.lifetimes.iter().enumerate() {\n-                        if indexes.contains(&(i as u32)) {\n-                            new_lts.push(lifetime);\n-                        } else {\n-                            new_lts.push(*lt);\n-                        }\n-                    }\n-                }\n-                let new_types = data.types.iter().map(|t| {\n-                    self.rebuild_arg_ty_or_output(&t, lifetime, anon_nums, region_names)\n-                }).collect();\n-                let new_bindings = data.bindings.iter().map(|b| {\n-                    hir::TypeBinding {\n-                        id: b.id,\n-                        name: b.name,\n-                        ty: self.rebuild_arg_ty_or_output(&b.ty,\n-                                                          lifetime,\n-                                                          anon_nums,\n-                                                          region_names),\n-                        span: b.span\n-                    }\n-                }).collect();\n-                hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n-                    lifetimes: new_lts.into(),\n-                    types: new_types,\n-                    infer_types: data.infer_types,\n-                    bindings: new_bindings,\n-               })\n-            }\n-        };\n-        let new_seg = hir::PathSegment {\n-            name: last_seg.name,\n-            parameters: new_parameters\n-        };\n-        let mut new_segs = Vec::new();\n-        new_segs.extend_from_slice(path.segments.split_last().unwrap().1);\n-        new_segs.push(new_seg);\n-        hir::Path {\n-            span: path.span,\n-            def: path.def,\n-            segments: new_segs.into()\n-        }\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    fn give_expl_lifetime_param(&self,\n-                                err: &mut DiagnosticBuilder,\n-                                decl: &hir::FnDecl,\n-                                unsafety: hir::Unsafety,\n-                                constness: hir::Constness,\n-                                name: ast::Name,\n-                                generics: &hir::Generics,\n-                                span: Span,\n-                                body: hir::BodyId) {\n-        let s = hir::print::to_string(&self.tcx.hir, |s| {\n-            use syntax::abi::Abi;\n-            use syntax::print::pprust::PrintState;\n-\n-            s.head(\"\")?;\n-            s.print_fn(decl,\n-                       unsafety,\n-                       constness,\n-                       Abi::Rust,\n-                       Some(name),\n-                       generics,\n-                       &hir::Inherited,\n-                       &[],\n-                       Some(body))?;\n-            s.end()?; // Close the head box\n-            s.end()   // Close the outer box\n-        });\n-        let msg = format!(\"consider using an explicit lifetime parameter as shown: {}\", s);\n-        err.span_help(span, &msg[..]);\n-    }\n-\n     fn report_inference_failure(&self,\n                                 var_origin: RegionVariableOrigin)\n                                 -> DiagnosticBuilder<'tcx> {\n@@ -1890,114 +1289,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn lifetimes_in_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                      scope_id: ast::NodeId)\n-                                      -> Vec<hir::LifetimeDef> {\n-    let mut taken = Vec::new();\n-    let parent = tcx.hir.get_parent(scope_id);\n-    let method_id_opt = match tcx.hir.find(parent) {\n-        Some(node) => match node {\n-            hir_map::NodeItem(item) => match item.node {\n-                hir::ItemFn(.., ref gen, _) => {\n-                    taken.extend_from_slice(&gen.lifetimes);\n-                    None\n-                },\n-                _ => None\n-            },\n-            hir_map::NodeImplItem(ii) => {\n-                match ii.node {\n-                    hir::ImplItemKind::Method(ref sig, _) => {\n-                        taken.extend_from_slice(&sig.generics.lifetimes);\n-                        Some(ii.id)\n-                    }\n-                    _ => None,\n-                }\n-            }\n-            _ => None\n-        },\n-        None => None\n-    };\n-    if let Some(method_id) = method_id_opt {\n-        let parent = tcx.hir.get_parent(method_id);\n-        if let Some(node) = tcx.hir.find(parent) {\n-            match node {\n-                hir_map::NodeItem(item) => match item.node {\n-                    hir::ItemImpl(_, _, ref gen, ..) => {\n-                        taken.extend_from_slice(&gen.lifetimes);\n-                    }\n-                    _ => ()\n-                },\n-                _ => ()\n-            }\n-        }\n-    }\n-    return taken;\n-}\n-\n-// LifeGiver is responsible for generating fresh lifetime names\n-struct LifeGiver {\n-    taken: HashSet<String>,\n-    counter: Cell<usize>,\n-    generated: RefCell<Vec<hir::Lifetime>>,\n-}\n-\n-impl LifeGiver {\n-    fn with_taken(taken: &[hir::LifetimeDef]) -> LifeGiver {\n-        let mut taken_ = HashSet::new();\n-        for lt in taken {\n-            let lt_name = lt.lifetime.name.to_string();\n-            taken_.insert(lt_name);\n-        }\n-        LifeGiver {\n-            taken: taken_,\n-            counter: Cell::new(0),\n-            generated: RefCell::new(Vec::new()),\n-        }\n-    }\n-\n-    fn inc_counter(&self) {\n-        let c = self.counter.get();\n-        self.counter.set(c+1);\n-    }\n-\n-    fn give_lifetime(&self) -> hir::Lifetime {\n-        let lifetime;\n-        loop {\n-            let mut s = String::from(\"'\");\n-            s.push_str(&num_to_string(self.counter.get()));\n-            if !self.taken.contains(&s) {\n-                lifetime = name_to_dummy_lifetime(Symbol::intern(&s));\n-                self.generated.borrow_mut().push(lifetime);\n-                break;\n-            }\n-            self.inc_counter();\n-        }\n-        self.inc_counter();\n-        return lifetime;\n-\n-        // 0 .. 25 generates a .. z, 26 .. 51 generates aa .. zz, and so on\n-        fn num_to_string(counter: usize) -> String {\n-            let mut s = String::new();\n-            let (n, r) = (counter/26 + 1, counter % 26);\n-            let letter: char = from_u32((r+97) as u32).unwrap();\n-            for _ in 0..n {\n-                s.push(letter);\n-            }\n-            s\n-        }\n-    }\n-\n-    fn get_generated_lifetimes(&self) -> Vec<hir::Lifetime> {\n-        self.generated.borrow().clone()\n-    }\n-}\n-\n-fn name_to_dummy_lifetime(name: ast::Name) -> hir::Lifetime {\n-    hir::Lifetime { id: ast::DUMMY_NODE_ID,\n-                    span: syntax_pos::DUMMY_SP,\n-                    name: name }\n-}\n-\n impl<'tcx> ObligationCause<'tcx> {\n     fn as_failure_str(&self) -> &'static str {\n         use traits::ObligationCauseCode::*;\n@@ -2038,4 +1329,3 @@ impl<'tcx> ObligationCause<'tcx> {\n         }\n     }\n }\n-"}, {"sha": "697a1ecadc456afe92b6702999aa1d8851aa3cd9", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -156,7 +156,6 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyUint(..) |\n             ty::TyFloat(..) |\n             ty::TyAdt(..) |\n-            ty::TyBox(..) |\n             ty::TyStr |\n             ty::TyError |\n             ty::TyArray(..) |"}, {"sha": "855f4a8197e35558a9e384a0a6072dcb1890bfae", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -29,7 +29,9 @@\n #![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n+#![feature(field_init_shorthand)]\n #![feature(libc)]\n+#![feature(loop_break_value)]\n #![feature(nonzero)]\n #![feature(pub_restricted)]\n #![feature(quote)]\n@@ -107,7 +109,6 @@ pub mod util {\n     pub mod common;\n     pub mod ppaux;\n     pub mod nodemap;\n-    pub mod num;\n     pub mod fs;\n }\n "}, {"sha": "e1605959922c0530e64e1a2b1ab299282afc6639", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -223,6 +223,12 @@ declare_lint! {\n     \"detects names that resolve to ambiguous glob imports with RFC 1560\"\n }\n \n+declare_lint! {\n+    pub LEGACY_CONSTRUCTOR_VISIBILITY,\n+    Deny,\n+    \"detects use of struct constructors that would be invisible with new visibility rules\"\n+}\n+\n declare_lint! {\n     pub DEPRECATED,\n     Warn,\n@@ -271,6 +277,7 @@ impl LintPass for HardwiredLints {\n             EXTRA_REQUIREMENT_IN_IMPL,\n             LEGACY_DIRECTORY_OWNERSHIP,\n             LEGACY_IMPORTS,\n+            LEGACY_CONSTRUCTOR_VISIBILITY,\n             DEPRECATED\n         )\n     }"}, {"sha": "d11e6e3fc72bd415c31910243845b9a6bccae566", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -28,6 +28,7 @@ use hir::map as hir_map;\n use hir::map::definitions::{Definitions, DefKey, DisambiguatedDefPathData};\n use hir::svh::Svh;\n use middle::lang_items;\n+use middle::resolve_lifetime::ObjectLifetimeDefault;\n use ty::{self, Ty, TyCtxt};\n use mir::Mir;\n use session::Session;\n@@ -182,6 +183,9 @@ pub trait CrateStore<'tcx> {\n                                  -> ty::GenericPredicates<'tcx>;\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                          -> ty::Generics<'tcx>;\n+    fn item_generics_own_param_counts(&self, def: DefId) -> (usize, usize);\n+    fn item_generics_object_lifetime_defaults(&self, def: DefId)\n+                                              -> Vec<ObjectLifetimeDefault>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef;\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef;\n@@ -331,6 +335,11 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                                  -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                          -> ty::Generics<'tcx> { bug!(\"item_generics\") }\n+    fn item_generics_own_param_counts(&self, def: DefId) -> (usize, usize)\n+        { bug!(\"item_generics_own_param_counts\") }\n+    fn item_generics_object_lifetime_defaults(&self, def: DefId)\n+                                              -> Vec<ObjectLifetimeDefault>\n+        { bug!(\"item_generics_object_lifetime_defaults\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef\n         { bug!(\"trait_def\") }"}, {"sha": "0e8e1921de700fc1f7a77161bbb9162d1c051c5f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -194,6 +194,63 @@ pub struct cmt_<'tcx> {\n \n pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n+impl<'tcx> cmt_<'tcx> {\n+    pub fn get_field(&self, name: ast::Name) -> Option<DefId> {\n+        match self.cat {\n+            Categorization::Deref(ref cmt, ..) |\n+            Categorization::Interior(ref cmt, _) |\n+            Categorization::Downcast(ref cmt, _) => {\n+                if let Categorization::Local(_) = cmt.cat {\n+                    if let ty::TyAdt(def, _) = self.ty.sty {\n+                        return def.struct_variant().find_field_named(name).map(|x| x.did);\n+                    }\n+                    None\n+                } else {\n+                    cmt.get_field(name)\n+                }\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    pub fn get_field_name(&self) -> Option<ast::Name> {\n+        match self.cat {\n+            Categorization::Interior(_, ref ik) => {\n+                if let InteriorKind::InteriorField(FieldName::NamedField(name)) = *ik {\n+                    Some(name)\n+                } else {\n+                    None\n+                }\n+            }\n+            Categorization::Deref(ref cmt, ..) |\n+            Categorization::Downcast(ref cmt, _) => {\n+                cmt.get_field_name()\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn get_arg_if_immutable(&self, map: &hir_map::Map) -> Option<ast::NodeId> {\n+        match self.cat {\n+            Categorization::Deref(ref cmt, ..) |\n+            Categorization::Interior(ref cmt, _) |\n+            Categorization::Downcast(ref cmt, _) => {\n+                if let Categorization::Local(nid) = cmt.cat {\n+                    if let ty::TyAdt(_, _) = self.ty.sty {\n+                        if let ty::TyRef(_, ty::TypeAndMut{mutbl: MutImmutable, ..}) = cmt.ty.sty {\n+                            return Some(nid);\n+                        }\n+                    }\n+                    None\n+                } else {\n+                    cmt.get_arg_if_immutable(map)\n+                }\n+            }\n+            _ => None\n+        }\n+    }\n+}\n+\n pub trait ast_node {\n     fn id(&self) -> ast::NodeId;\n     fn span(&self) -> Span;\n@@ -904,7 +961,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                     -> cmt<'tcx>\n     {\n         let ptr = match base_cmt.ty.sty {\n-            ty::TyBox(..) => Unique,\n+            ty::TyAdt(def, ..) if def.is_box() => Unique,\n             ty::TyRawPtr(ref mt) => UnsafePtr(mt.mutbl),\n             ty::TyRef(r, mt) => {\n                 let bk = ty::BorrowKind::from_mutbl(mt.mutbl);"}, {"sha": "88ef2c69a04dce975ab907a9ee7b1a1e97bee033", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1011, "deletions": 316, "changes": 1327, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -15,55 +15,156 @@\n //! used between functions, and they operate in a purely top-down\n //! way. Therefore we break lifetime name resolution into a separate pass.\n \n-pub use self::DefRegion::*;\n-use self::ScopeChain::*;\n-\n use dep_graph::DepNode;\n use hir::map::Map;\n use session::Session;\n use hir::def::Def;\n use hir::def_id::DefId;\n use middle::region;\n use ty;\n+\n+use std::cell::Cell;\n use std::mem::replace;\n use syntax::ast;\n+use syntax::attr;\n+use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n-use util::nodemap::NodeMap;\n+use errors::DiagnosticBuilder;\n+use util::nodemap::{NodeMap, FxHashSet, FxHashMap, DefIdMap};\n+use rustc_back::slice;\n \n-use rustc_data_structures::fx::FxHashSet;\n use hir;\n-use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n-pub enum DefRegion {\n-    DefStaticRegion,\n-    DefEarlyBoundRegion(/* index */ u32,\n-                        /* lifetime decl */ ast::NodeId),\n-    DefLateBoundRegion(ty::DebruijnIndex,\n-                       /* lifetime decl */ ast::NodeId),\n-    DefFreeRegion(region::CallSiteScopeData,\n-                  /* lifetime decl */ ast::NodeId),\n+pub enum Region {\n+    Static,\n+    EarlyBound(/* index */ u32, /* lifetime decl */ ast::NodeId),\n+    LateBound(ty::DebruijnIndex, /* lifetime decl */ ast::NodeId),\n+    LateBoundAnon(ty::DebruijnIndex, /* anon index */ u32),\n+    Free(region::CallSiteScopeData, /* lifetime decl */ ast::NodeId),\n }\n \n+impl Region {\n+    fn early(index: &mut u32, def: &hir::LifetimeDef) -> (ast::Name, Region) {\n+        let i = *index;\n+        *index += 1;\n+        (def.lifetime.name, Region::EarlyBound(i, def.lifetime.id))\n+    }\n+\n+    fn late(def: &hir::LifetimeDef) -> (ast::Name, Region) {\n+        let depth = ty::DebruijnIndex::new(1);\n+        (def.lifetime.name, Region::LateBound(depth, def.lifetime.id))\n+    }\n+\n+    fn late_anon(index: &Cell<u32>) -> Region {\n+        let i = index.get();\n+        index.set(i + 1);\n+        let depth = ty::DebruijnIndex::new(1);\n+        Region::LateBoundAnon(depth, i)\n+    }\n+\n+    fn id(&self) -> Option<ast::NodeId> {\n+        match *self {\n+            Region::Static |\n+            Region::LateBoundAnon(..) => None,\n+\n+            Region::EarlyBound(_, id) |\n+            Region::LateBound(_, id) |\n+            Region::Free(_, id) => Some(id)\n+        }\n+    }\n+\n+    fn shifted(self, amount: u32) -> Region {\n+        match self {\n+            Region::LateBound(depth, id) => {\n+                Region::LateBound(depth.shifted(amount), id)\n+            }\n+            Region::LateBoundAnon(depth, index) => {\n+                Region::LateBoundAnon(depth.shifted(amount), index)\n+            }\n+            _ => self\n+        }\n+    }\n+\n+    fn from_depth(self, depth: u32) -> Region {\n+        match self {\n+            Region::LateBound(debruijn, id) => {\n+                Region::LateBound(ty::DebruijnIndex {\n+                    depth: debruijn.depth - (depth - 1)\n+                }, id)\n+            }\n+            Region::LateBoundAnon(debruijn, index) => {\n+                Region::LateBoundAnon(ty::DebruijnIndex {\n+                    depth: debruijn.depth - (depth - 1)\n+                }, index)\n+            }\n+            _ => self\n+        }\n+    }\n+\n+    fn subst(self, params: &[hir::Lifetime], map: &NamedRegionMap)\n+             -> Option<Region> {\n+        if let Region::EarlyBound(index, _) = self {\n+            params.get(index as usize).and_then(|lifetime| {\n+                map.defs.get(&lifetime.id).cloned()\n+            })\n+        } else {\n+            Some(self)\n+        }\n+    }\n+}\n+\n+/// A set containing, at most, one known element.\n+/// If two distinct values are inserted into a set, then it\n+/// becomes `Many`, which can be used to detect ambiguities.\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+pub enum Set1<T> {\n+    Empty,\n+    One(T),\n+    Many\n+}\n+\n+impl<T: PartialEq> Set1<T> {\n+    pub fn insert(&mut self, value: T) {\n+        if let Set1::Empty = *self {\n+            *self = Set1::One(value);\n+            return;\n+        }\n+        if let Set1::One(ref old) = *self {\n+            if *old == value {\n+                return;\n+            }\n+        }\n+        *self = Set1::Many;\n+    }\n+}\n+\n+pub type ObjectLifetimeDefault = Set1<Region>;\n+\n // Maps the id of each lifetime reference to the lifetime decl\n // that it corresponds to.\n pub struct NamedRegionMap {\n     // maps from every use of a named (not anonymous) lifetime to a\n-    // `DefRegion` describing how that region is bound\n-    pub defs: NodeMap<DefRegion>,\n+    // `Region` describing how that region is bound\n+    pub defs: NodeMap<Region>,\n \n     // the set of lifetime def ids that are late-bound; late-bound ids\n     // are named regions appearing in fn arguments that do not appear\n     // in where-clauses\n     pub late_bound: NodeMap<ty::Issue32330>,\n+\n+    // For each type and trait definition, maps type parameters\n+    // to the trait object lifetime defaults computed from them.\n+    pub object_lifetime_defaults: NodeMap<Vec<ObjectLifetimeDefault>>,\n }\n \n struct LifetimeContext<'a, 'tcx: 'a> {\n     sess: &'a Session,\n     hir_map: &'a Map<'tcx>,\n     map: &'a mut NamedRegionMap,\n-    scope: Scope<'a>,\n+    scope: ScopeRef<'a>,\n     // Deep breath. Our representation for poly trait refs contains a single\n     // binder and thus we only allow a single level of quantification. However,\n     // the syntax of Rust permits quantification in two places, e.g., `T: for <'a> Foo<'a>`\n@@ -83,28 +184,75 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n \n     // List of labels in the function/method currently under analysis.\n     labels_in_fn: Vec<(ast::Name, Span)>,\n+\n+    // Cache for cross-crate per-definition object lifetime defaults.\n+    xcrate_object_lifetime_defaults: DefIdMap<Vec<ObjectLifetimeDefault>>,\n+}\n+\n+#[derive(Debug)]\n+enum Scope<'a> {\n+    /// Declares lifetimes, and each can be early-bound or late-bound.\n+    /// The `DebruijnIndex` of late-bound lifetimes starts at `1` and\n+    /// it should be shifted by the number of `Binder`s in between the\n+    /// declaration `Binder` and the location it's referenced from.\n+    Binder {\n+        lifetimes: FxHashMap<ast::Name, Region>,\n+        s: ScopeRef<'a>\n+    },\n+\n+    /// Lifetimes introduced by a fn are scoped to the call-site for that fn,\n+    /// if this is a fn body, otherwise the original definitions are used.\n+    /// Unspecified lifetimes are inferred, unless an elision scope is nested,\n+    /// e.g. `(&T, fn(&T) -> &T);` becomes `(&'_ T, for<'a> fn(&'a T) -> &'a T)`.\n+    Body {\n+        id: hir::BodyId,\n+        s: ScopeRef<'a>\n+    },\n+\n+    /// A scope which either determines unspecified lifetimes or errors\n+    /// on them (e.g. due to ambiguity). For more details, see `Elide`.\n+    Elision {\n+        elide: Elide,\n+        s: ScopeRef<'a>\n+    },\n+\n+    /// Use a specific lifetime (if `Some`) or leave it unset (to be\n+    /// inferred in a function body or potentially error outside one),\n+    /// for the default choice of lifetime in a trait object type.\n+    ObjectLifetimeDefault {\n+        lifetime: Option<Region>,\n+        s: ScopeRef<'a>\n+    },\n+\n+    Root\n+}\n+\n+#[derive(Clone, Debug)]\n+enum Elide {\n+    /// Use a fresh anonymous late-bound lifetime each time, by\n+    /// incrementing the counter to generate sequential indices.\n+    FreshLateAnon(Cell<u32>),\n+    /// Always use this one lifetime.\n+    Exact(Region),\n+    /// Like `Exact(Static)` but requires `#![feature(static_in_const)]`.\n+    Static,\n+    /// Less or more than one lifetime were found, error on unspecified.\n+    Error(Vec<ElisionFailureInfo>)\n }\n \n-#[derive(PartialEq, Debug)]\n-enum ScopeChain<'a> {\n-    /// EarlyScope(['a, 'b, ...], start, s) extends s with early-bound\n-    /// lifetimes, with consecutive parameter indices from `start`.\n-    /// That is, 'a has index `start`, 'b has index `start + 1`, etc.\n-    /// Indices before `start` correspond to other generic parameters\n-    /// of a parent item (trait/impl of a method), or `Self` in traits.\n-    EarlyScope(&'a [hir::LifetimeDef], u32, Scope<'a>),\n-    /// LateScope(['a, 'b, ...], s) extends s with late-bound\n-    /// lifetimes introduced by the declaration binder_id.\n-    LateScope(&'a [hir::LifetimeDef], Scope<'a>),\n-\n-    /// lifetimes introduced by a fn are scoped to the call-site for that fn.\n-    FnScope { fn_id: ast::NodeId, body_id: ast::NodeId, s: Scope<'a> },\n-    RootScope\n+#[derive(Clone, Debug)]\n+struct ElisionFailureInfo {\n+    /// Where we can find the argument pattern.\n+    parent: Option<hir::BodyId>,\n+    /// The index of the argument in the original definition.\n+    index: usize,\n+    lifetime_count: usize,\n+    have_bound_regions: bool\n }\n \n-type Scope<'a> = &'a ScopeChain<'a>;\n+type ScopeRef<'a> = &'a Scope<'a>;\n \n-static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n+const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n \n pub fn krate(sess: &Session,\n              hir_map: &Map)\n@@ -114,178 +262,197 @@ pub fn krate(sess: &Session,\n     let mut map = NamedRegionMap {\n         defs: NodeMap(),\n         late_bound: NodeMap(),\n+        object_lifetime_defaults: compute_object_lifetime_defaults(sess, hir_map),\n     };\n     sess.track_errors(|| {\n-        intravisit::walk_crate(&mut LifetimeContext {\n+        let mut visitor = LifetimeContext {\n             sess: sess,\n             hir_map: hir_map,\n             map: &mut map,\n-            scope: &ROOT_SCOPE,\n+            scope: ROOT_SCOPE,\n             trait_ref_hack: false,\n             labels_in_fn: vec![],\n-        }, krate);\n+            xcrate_object_lifetime_defaults: DefIdMap(),\n+        };\n+        for (_, item) in &krate.items {\n+            visitor.visit_item(item);\n+        }\n     })?;\n     Ok(map)\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n-    // Override the nested functions -- lifetimes follow lexical scope,\n-    // so it's convenient to walk the tree in lexical order.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.hir_map)\n+        NestedVisitorMap::All(self.hir_map)\n+    }\n+\n+    // We want to nest trait/impl items in their parent, but nothing else.\n+    fn visit_nested_item(&mut self, _: hir::ItemId) {}\n+\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        // Each body has their own set of labels, save labels.\n+        let saved = replace(&mut self.labels_in_fn, vec![]);\n+        let body = self.hir_map.body(body);\n+        extract_labels(self, body);\n+        self.with(Scope::Body { id: body.id(), s: self.scope }, |_, this| {\n+            this.visit_body(body);\n+        });\n+        replace(&mut self.labels_in_fn, saved);\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        // Save labels for nested items.\n-        let saved_labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n-\n-        // Items always introduce a new root scope\n-        self.with(RootScope, |_, this| {\n-            match item.node {\n-                hir::ItemFn(..) => {\n-                    // Fn lifetimes get added in visit_fn below:\n+        match item.node {\n+            hir::ItemFn(ref decl, _, _, _, ref generics, _) => {\n+                self.visit_early_late(item.id, None, decl, generics, |this| {\n                     intravisit::walk_item(this, item);\n-                }\n-                hir::ItemExternCrate(_) |\n-                hir::ItemUse(..) |\n-                hir::ItemMod(..) |\n-                hir::ItemDefaultImpl(..) |\n-                hir::ItemForeignMod(..) |\n-                hir::ItemStatic(..) |\n-                hir::ItemConst(..) => {\n-                    // These sorts of items have no lifetime parameters at all.\n+                });\n+            }\n+            hir::ItemExternCrate(_) |\n+            hir::ItemUse(..) |\n+            hir::ItemMod(..) |\n+            hir::ItemDefaultImpl(..) |\n+            hir::ItemForeignMod(..) => {\n+                // These sorts of items have no lifetime parameters at all.\n+                intravisit::walk_item(self, item);\n+            }\n+            hir::ItemStatic(..) |\n+            hir::ItemConst(..) => {\n+                // No lifetime parameters, but implied 'static.\n+                let scope = Scope::Elision {\n+                    elide: Elide::Static,\n+                    s: ROOT_SCOPE\n+                };\n+                self.with(scope, |_, this| intravisit::walk_item(this, item));\n+            }\n+            hir::ItemTy(_, ref generics) |\n+            hir::ItemEnum(_, ref generics) |\n+            hir::ItemStruct(_, ref generics) |\n+            hir::ItemUnion(_, ref generics) |\n+            hir::ItemTrait(_, ref generics, ..) |\n+            hir::ItemImpl(_, _, ref generics, ..) => {\n+                // These kinds of items have only early bound lifetime parameters.\n+                let mut index = if let hir::ItemTrait(..) = item.node {\n+                    1 // Self comes before lifetimes\n+                } else {\n+                    0\n+                };\n+                let lifetimes = generics.lifetimes.iter().map(|def| {\n+                    Region::early(&mut index, def)\n+                }).collect();\n+                let scope = Scope::Binder {\n+                    lifetimes: lifetimes,\n+                    s: ROOT_SCOPE\n+                };\n+                self.with(scope, |old_scope, this| {\n+                    this.check_lifetime_defs(old_scope, &generics.lifetimes);\n                     intravisit::walk_item(this, item);\n-                }\n-                hir::ItemTy(_, ref generics) |\n-                hir::ItemEnum(_, ref generics) |\n-                hir::ItemStruct(_, ref generics) |\n-                hir::ItemUnion(_, ref generics) |\n-                hir::ItemTrait(_, ref generics, ..) |\n-                hir::ItemImpl(_, _, ref generics, ..) => {\n-                    // These kinds of items have only early bound lifetime parameters.\n-                    let lifetimes = &generics.lifetimes;\n-                    let start = if let hir::ItemTrait(..) = item.node {\n-                        1 // Self comes before lifetimes\n-                    } else {\n-                        0\n-                    };\n-                    this.with(EarlyScope(lifetimes, start, &ROOT_SCOPE), |old_scope, this| {\n-                        this.check_lifetime_defs(old_scope, lifetimes);\n-                        intravisit::walk_item(this, item);\n-                    });\n-                }\n+                });\n             }\n-        });\n-\n-        // Done traversing the item; remove any labels it created\n-        self.labels_in_fn = saved_labels_in_fn;\n+        }\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n-        // Items save/restore the set of labels. This way inner items\n-        // can freely reuse names, be they loop labels or lifetimes.\n-        let saved = replace(&mut self.labels_in_fn, vec![]);\n-\n-        // Items always introduce a new root scope\n-        self.with(RootScope, |_, this| {\n-            match item.node {\n-                hir::ForeignItemFn(ref decl, _, ref generics) => {\n-                    this.visit_early_late(item.id, decl, generics, |this| {\n-                        intravisit::walk_foreign_item(this, item);\n-                    })\n-                }\n-                hir::ForeignItemStatic(..) => {\n+        match item.node {\n+            hir::ForeignItemFn(ref decl, _, ref generics) => {\n+                self.visit_early_late(item.id, None, decl, generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n-                }\n-            }\n-        });\n-\n-        // Done traversing the item; restore saved set of labels.\n-        replace(&mut self.labels_in_fn, saved);\n-    }\n-\n-    fn visit_fn(&mut self, fk: FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n-                b: hir::BodyId, s: Span, fn_id: ast::NodeId) {\n-        match fk {\n-            FnKind::ItemFn(_, generics, ..) => {\n-                self.visit_early_late(fn_id,decl, generics, |this| {\n-                    this.add_scope_and_walk_fn(fk, decl, b, s, fn_id)\n                 })\n             }\n-            FnKind::Method(_, sig, ..) => {\n-                self.visit_early_late(\n-                    fn_id,\n-                    decl,\n-                    &sig.generics,\n-                    |this| this.add_scope_and_walk_fn(fk, decl, b, s, fn_id));\n-            }\n-            FnKind::Closure(_) => {\n-                // Closures have their own set of labels, save labels just\n-                // like for foreign items above.\n-                let saved = replace(&mut self.labels_in_fn, vec![]);\n-                let result = self.add_scope_and_walk_fn(fk, decl, b, s, fn_id);\n-                replace(&mut self.labels_in_fn, saved);\n-                result\n+            hir::ForeignItemStatic(..) => {\n+                intravisit::walk_foreign_item(self, item);\n             }\n         }\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         match ty.node {\n             hir::TyBareFn(ref c) => {\n-                self.with(LateScope(&c.lifetimes, self.scope), |old_scope, this| {\n+                let scope = Scope::Binder {\n+                    lifetimes: c.lifetimes.iter().map(Region::late).collect(),\n+                    s: self.scope\n+                };\n+                self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n                     // contained within is scoped within its binder.\n                     this.check_lifetime_defs(old_scope, &c.lifetimes);\n                     intravisit::walk_ty(this, ty);\n                 });\n             }\n-            hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n-                // if this path references a trait, then this will resolve to\n-                // a trait ref, which introduces a binding scope.\n-                match path.def {\n-                    Def::Trait(..) => {\n-                        self.with(LateScope(&[], self.scope), |_, this| {\n-                            this.visit_path(path, ty.id);\n-                        });\n-                    }\n-                    _ => {\n-                        intravisit::walk_ty(self, ty);\n-                    }\n+            hir::TyTraitObject(ref bounds, ref lifetime) => {\n+                for bound in bounds {\n+                    self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n+                }\n+                if lifetime.is_elided() {\n+                    self.resolve_object_lifetime_default(lifetime)\n+                } else {\n+                    self.visit_lifetime(lifetime);\n                 }\n             }\n+            hir::TyRptr(ref lifetime_ref, ref mt) => {\n+                self.visit_lifetime(lifetime_ref);\n+                let scope = Scope::ObjectLifetimeDefault {\n+                    lifetime: self.map.defs.get(&lifetime_ref.id).cloned(),\n+                    s: self.scope\n+                };\n+                self.with(scope, |_, this| this.visit_ty(&mt.ty));\n+            }\n             _ => {\n                 intravisit::walk_ty(self, ty)\n             }\n         }\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        // We reset the labels on every trait item, so that different\n-        // methods in an impl can reuse label names.\n-        let saved = replace(&mut self.labels_in_fn, vec![]);\n-\n-        if let hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(_)) =\n-                trait_item.node {\n+        if let hir::TraitItemKind::Method(ref sig, _) = trait_item.node {\n             self.visit_early_late(\n                 trait_item.id,\n+                Some(self.hir_map.get_parent(trait_item.id)),\n                 &sig.decl, &sig.generics,\n                 |this| intravisit::walk_trait_item(this, trait_item))\n         } else {\n             intravisit::walk_trait_item(self, trait_item);\n         }\n+    }\n \n-        replace(&mut self.labels_in_fn, saved);\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n+            self.visit_early_late(\n+                impl_item.id,\n+                Some(self.hir_map.get_parent(impl_item.id)),\n+                &sig.decl, &sig.generics,\n+                |this| intravisit::walk_impl_item(this, impl_item))\n+        } else {\n+            intravisit::walk_impl_item(self, impl_item);\n+        }\n     }\n \n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n+        if lifetime_ref.is_elided() {\n+            self.resolve_elided_lifetimes(slice::ref_slice(lifetime_ref));\n+            return;\n+        }\n         if lifetime_ref.name == keywords::StaticLifetime.name() {\n-            self.insert_lifetime(lifetime_ref, DefStaticRegion);\n+            self.insert_lifetime(lifetime_ref, Region::Static);\n             return;\n         }\n         self.resolve_lifetime_ref(lifetime_ref);\n     }\n \n+    fn visit_path(&mut self, path: &'tcx hir::Path, _: ast::NodeId) {\n+        for (i, segment) in path.segments.iter().enumerate() {\n+            let depth = path.segments.len() - i - 1;\n+            self.visit_segment_parameters(path.def, depth, &segment.parameters);\n+        }\n+    }\n+\n+    fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl) {\n+        let output = match fd.output {\n+            hir::DefaultReturn(_) => None,\n+            hir::Return(ref ty) => Some(ty)\n+        };\n+        self.visit_fn_like_elision(&fd.inputs, output);\n+    }\n+\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         for ty_param in generics.ty_params.iter() {\n             walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n@@ -301,8 +468,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                                                                .. }) => {\n                     if !bound_lifetimes.is_empty() {\n                         self.trait_ref_hack = true;\n-                        let result = self.with(LateScope(bound_lifetimes, self.scope),\n-                                               |old_scope, this| {\n+                        let scope = Scope::Binder {\n+                            lifetimes: bound_lifetimes.iter().map(Region::late).collect(),\n+                            s: self.scope\n+                        };\n+                        let result = self.with(scope, |old_scope, this| {\n                             this.check_lifetime_defs(old_scope, bound_lifetimes);\n                             this.visit_ty(&bounded_ty);\n                             walk_list!(this, visit_ty_param_bound, bounds);\n@@ -335,20 +505,24 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_poly_trait_ref(&mut self,\n                             trait_ref: &'tcx hir::PolyTraitRef,\n-                            _modifier: &'tcx hir::TraitBoundModifier) {\n+                            _modifier: hir::TraitBoundModifier) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n         if !self.trait_ref_hack || !trait_ref.bound_lifetimes.is_empty() {\n             if self.trait_ref_hack {\n                 span_err!(self.sess, trait_ref.span, E0316,\n                           \"nested quantification of lifetimes\");\n             }\n-            self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |old_scope, this| {\n+            let scope = Scope::Binder {\n+                lifetimes: trait_ref.bound_lifetimes.iter().map(Region::late).collect(),\n+                s: self.scope\n+            };\n+            self.with(scope, |old_scope, this| {\n                 this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n                 for lifetime in &trait_ref.bound_lifetimes {\n                     this.visit_lifetime_def(lifetime);\n                 }\n-                intravisit::walk_path(this, &trait_ref.trait_ref.path)\n+                this.visit_trait_ref(&trait_ref.trait_ref)\n             })\n         } else {\n             self.visit_trait_ref(&trait_ref.trait_ref)\n@@ -367,8 +541,8 @@ fn original_label(span: Span) -> Original {\n fn shadower_label(span: Span) -> Shadower {\n     Shadower { kind: ShadowKind::Label, span: span }\n }\n-fn original_lifetime(l: &hir::Lifetime) -> Original {\n-    Original { kind: ShadowKind::Lifetime, span: l.span }\n+fn original_lifetime(span: Span) -> Original {\n+    Original { kind: ShadowKind::Lifetime, span: span }\n }\n fn shadower_lifetime(l: &hir::Lifetime) -> Shadower {\n     Shadower { kind: ShadowKind::Lifetime, span: l.span }\n@@ -406,33 +580,28 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n-    struct GatherLabels<'a> {\n+fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n+    struct GatherLabels<'a, 'tcx: 'a> {\n         sess: &'a Session,\n-        scope: Scope<'a>,\n+        hir_map: &'a Map<'tcx>,\n+        scope: ScopeRef<'a>,\n         labels_in_fn: &'a mut Vec<(ast::Name, Span)>,\n     }\n \n     let mut gather = GatherLabels {\n         sess: ctxt.sess,\n+        hir_map: ctxt.hir_map,\n         scope: ctxt.scope,\n         labels_in_fn: &mut ctxt.labels_in_fn,\n     };\n-    gather.visit_body(ctxt.hir_map.body(b));\n-    return;\n+    gather.visit_body(body);\n \n-    impl<'v, 'a> Visitor<'v> for GatherLabels<'a> {\n+    impl<'v, 'a, 'tcx> Visitor<'v> for GatherLabels<'a, 'tcx> {\n         fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n             NestedVisitorMap::None\n         }\n \n-        fn visit_expr(&mut self, ex: &'v hir::Expr) {\n-            // do not recurse into closures defined in the block\n-            // since they are treated as separate fns from the POV of\n-            // labels_in_fn\n-            if let hir::ExprClosure(..) = ex.node {\n-                return\n-            }\n+        fn visit_expr(&mut self, ex: &hir::Expr) {\n             if let Some((label, label_span)) = expression_label(ex) {\n                 for &(prior, prior_span) in &self.labels_in_fn[..] {\n                     // FIXME (#24278): non-hygienic comparison\n@@ -445,6 +614,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n                 }\n \n                 check_if_label_shadows_lifetime(self.sess,\n+                                                self.hir_map,\n                                                 self.scope,\n                                                 label,\n                                                 label_span);\n@@ -453,10 +623,6 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n             }\n             intravisit::walk_expr(self, ex)\n         }\n-\n-        fn visit_item(&mut self, _: &hir::Item) {\n-            // do not recurse into items defined in the block\n-        }\n     }\n \n     fn expression_label(ex: &hir::Expr) -> Option<(ast::Name, Span)> {\n@@ -468,26 +634,27 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n     }\n \n     fn check_if_label_shadows_lifetime<'a>(sess: &'a Session,\n-                                           mut scope: Scope<'a>,\n+                                           hir_map: &Map,\n+                                           mut scope: ScopeRef<'a>,\n                                            label: ast::Name,\n                                            label_span: Span) {\n         loop {\n             match *scope {\n-                FnScope { s, .. } => { scope = s; }\n-                RootScope => { return; }\n-\n-                EarlyScope(lifetimes, _, s) |\n-                LateScope(lifetimes, s) => {\n-                    for lifetime_def in lifetimes {\n-                        // FIXME (#24278): non-hygienic comparison\n-                        if label == lifetime_def.lifetime.name {\n-                            signal_shadowing_problem(\n-                                sess,\n-                                label,\n-                                original_lifetime(&lifetime_def.lifetime),\n-                                shadower_label(label_span));\n-                            return;\n-                        }\n+                Scope::Body { s, .. } |\n+                Scope::Elision { s, .. } |\n+                Scope::ObjectLifetimeDefault { s, .. } => { scope = s; }\n+\n+                Scope::Root => { return; }\n+\n+                Scope::Binder { ref lifetimes, s } => {\n+                    // FIXME (#24278): non-hygienic comparison\n+                    if let Some(def) = lifetimes.get(&label) {\n+                        signal_shadowing_problem(\n+                            sess,\n+                            label,\n+                            original_lifetime(hir_map.span(def.id().unwrap())),\n+                            shadower_label(label_span));\n+                        return;\n                     }\n                     scope = s;\n                 }\n@@ -496,57 +663,132 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n     }\n }\n \n-impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n-    fn add_scope_and_walk_fn(&mut self,\n-                             fk: FnKind<'tcx>,\n-                             fd: &'tcx hir::FnDecl,\n-                             fb: hir::BodyId,\n-                             _span: Span,\n-                             fn_id: ast::NodeId) {\n-        match fk {\n-            FnKind::ItemFn(_, generics, ..) => {\n-                intravisit::walk_fn_decl(self, fd);\n-                self.visit_generics(generics);\n-            }\n-            FnKind::Method(_, sig, ..) => {\n-                intravisit::walk_fn_decl(self, fd);\n-                self.visit_generics(&sig.generics);\n+fn compute_object_lifetime_defaults(sess: &Session, hir_map: &Map)\n+                                    -> NodeMap<Vec<ObjectLifetimeDefault>> {\n+    let mut map = NodeMap();\n+    for item in hir_map.krate().items.values() {\n+        match item.node {\n+            hir::ItemStruct(_, ref generics) |\n+            hir::ItemUnion(_, ref generics) |\n+            hir::ItemEnum(_, ref generics) |\n+            hir::ItemTy(_, ref generics) |\n+            hir::ItemTrait(_, ref generics, ..) => {\n+                let result = object_lifetime_defaults_for_item(hir_map, generics);\n+\n+                // Debugging aid.\n+                if attr::contains_name(&item.attrs, \"rustc_object_lifetime_default\") {\n+                    let object_lifetime_default_reprs: String =\n+                        result.iter().map(|set| {\n+                            match *set {\n+                                Set1::Empty => \"BaseDefault\".to_string(),\n+                                Set1::One(Region::Static) => \"'static\".to_string(),\n+                                Set1::One(Region::EarlyBound(i, _)) => {\n+                                    generics.lifetimes[i as usize].lifetime.name.to_string()\n+                                }\n+                                Set1::One(_) => bug!(),\n+                                Set1::Many => \"Ambiguous\".to_string(),\n+                            }\n+                        }).collect::<Vec<String>>().join(\",\");\n+                    sess.span_err(item.span, &object_lifetime_default_reprs);\n+                }\n+\n+                map.insert(item.id, result);\n             }\n-            FnKind::Closure(_) => {\n-                intravisit::walk_fn_decl(self, fd);\n+            _ => {}\n+        }\n+    }\n+    map\n+}\n+\n+/// Scan the bounds and where-clauses on parameters to extract bounds\n+/// of the form `T:'a` so as to determine the `ObjectLifetimeDefault`\n+/// for each type parameter.\n+fn object_lifetime_defaults_for_item(hir_map: &Map, generics: &hir::Generics)\n+                                     -> Vec<ObjectLifetimeDefault> {\n+    fn add_bounds(set: &mut Set1<ast::Name>, bounds: &[hir::TyParamBound]) {\n+        for bound in bounds {\n+            if let hir::RegionTyParamBound(ref lifetime) = *bound {\n+                set.insert(lifetime.name);\n             }\n         }\n+    }\n \n-        // After inpsecting the decl, add all labels from the body to\n-        // `self.labels_in_fn`.\n-        extract_labels(self, fb);\n+    generics.ty_params.iter().map(|param| {\n+        let mut set = Set1::Empty;\n \n-        self.with(FnScope { fn_id: fn_id, body_id: fb.node_id, s: self.scope },\n-                  |_old_scope, this| this.visit_nested_body(fb))\n-    }\n+        add_bounds(&mut set, &param.bounds);\n+\n+        let param_def_id = hir_map.local_def_id(param.id);\n+        for predicate in &generics.where_clause.predicates {\n+            // Look for `type: ...` where clauses.\n+            let data = match *predicate {\n+                hir::WherePredicate::BoundPredicate(ref data) => data,\n+                _ => continue\n+            };\n+\n+            // Ignore `for<'a> type: ...` as they can change what\n+            // lifetimes mean (although we could \"just\" handle it).\n+            if !data.bound_lifetimes.is_empty() {\n+                continue;\n+            }\n+\n+            let def = match data.bounded_ty.node {\n+                hir::TyPath(hir::QPath::Resolved(None, ref path)) => path.def,\n+                _ => continue\n+            };\n \n+            if def == Def::TyParam(param_def_id) {\n+                add_bounds(&mut set, &data.bounds);\n+            }\n+        }\n+\n+        match set {\n+            Set1::Empty => Set1::Empty,\n+            Set1::One(name) => {\n+                if name == keywords::StaticLifetime.name() {\n+                    Set1::One(Region::Static)\n+                } else {\n+                    generics.lifetimes.iter().enumerate().find(|&(_, def)| {\n+                        def.lifetime.name == name\n+                    }).map_or(Set1::Many, |(i, def)| {\n+                        Set1::One(Region::EarlyBound(i as u32, def.lifetime.id))\n+                    })\n+                }\n+            }\n+            Set1::Many => Set1::Many\n+        }\n+    }).collect()\n+}\n+\n+impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     // FIXME(#37666) this works around a limitation in the region inferencer\n     fn hack<F>(&mut self, f: F) where\n         F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n     {\n         f(self)\n     }\n \n-    fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n-        F: for<'b> FnOnce(Scope, &mut LifetimeContext<'b, 'tcx>),\n+    fn with<F>(&mut self, wrap_scope: Scope, f: F) where\n+        F: for<'b> FnOnce(ScopeRef, &mut LifetimeContext<'b, 'tcx>),\n     {\n         let LifetimeContext {sess, hir_map, ref mut map, ..} = *self;\n+        let labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n+        let xcrate_object_lifetime_defaults =\n+            replace(&mut self.xcrate_object_lifetime_defaults, DefIdMap());\n         let mut this = LifetimeContext {\n             sess: sess,\n             hir_map: hir_map,\n             map: *map,\n             scope: &wrap_scope,\n             trait_ref_hack: self.trait_ref_hack,\n-            labels_in_fn: self.labels_in_fn.clone(),\n+            labels_in_fn: labels_in_fn,\n+            xcrate_object_lifetime_defaults: xcrate_object_lifetime_defaults,\n         };\n         debug!(\"entering scope {:?}\", this.scope);\n         f(self.scope, &mut this);\n         debug!(\"exiting scope {:?}\", this.scope);\n+        self.labels_in_fn = this.labels_in_fn;\n+        self.xcrate_object_lifetime_defaults = this.xcrate_object_lifetime_defaults;\n     }\n \n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n@@ -569,6 +811,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ordering is not important there.\n     fn visit_early_late<F>(&mut self,\n                            fn_id: ast::NodeId,\n+                           parent_id: Option<ast::NodeId>,\n                            decl: &'tcx hir::FnDecl,\n                            generics: &'tcx hir::Generics,\n                            walk: F) where\n@@ -580,156 +823,618 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                     decl,\n                                     generics);\n \n-        let (late, early): (Vec<_>, _) =\n-            generics.lifetimes\n-                    .iter()\n-                    .cloned()\n-                    .partition(|l| self.map.late_bound.contains_key(&l.lifetime.id));\n-\n         // Find the start of nested early scopes, e.g. in methods.\n-        let mut start = 0;\n-        if let EarlyScope(..) = *self.scope {\n-            let parent = self.hir_map.expect_item(self.hir_map.get_parent(fn_id));\n+        let mut index = 0;\n+        if let Some(parent_id) = parent_id {\n+            let parent = self.hir_map.expect_item(parent_id);\n             if let hir::ItemTrait(..) = parent.node {\n-                start += 1; // Self comes first.\n+                index += 1; // Self comes first.\n             }\n             match parent.node {\n                 hir::ItemTrait(_, ref generics, ..) |\n                 hir::ItemImpl(_, _, ref generics, ..) => {\n-                    start += generics.lifetimes.len() + generics.ty_params.len();\n+                    index += (generics.lifetimes.len() + generics.ty_params.len()) as u32;\n                 }\n                 _ => {}\n             }\n         }\n \n-        self.with(EarlyScope(&early, start as u32, self.scope), move |old_scope, this| {\n-            this.with(LateScope(&late, this.scope), move |_, this| {\n-                this.check_lifetime_defs(old_scope, &generics.lifetimes);\n-                this.hack(walk); // FIXME(#37666) workaround in place of `walk(this)`\n-            });\n+        let lifetimes = generics.lifetimes.iter().map(|def| {\n+            if self.map.late_bound.contains_key(&def.lifetime.id) {\n+                Region::late(def)\n+            } else {\n+                Region::early(&mut index, def)\n+            }\n+        }).collect();\n+\n+        let scope = Scope::Binder {\n+            lifetimes: lifetimes,\n+            s: self.scope\n+        };\n+        self.with(scope, move |old_scope, this| {\n+            this.check_lifetime_defs(old_scope, &generics.lifetimes);\n+            this.hack(walk); // FIXME(#37666) workaround in place of `walk(this)`\n         });\n     }\n \n     fn resolve_lifetime_ref(&mut self, lifetime_ref: &hir::Lifetime) {\n         // Walk up the scope chain, tracking the number of fn scopes\n         // that we pass through, until we find a lifetime with the\n-        // given name or we run out of scopes. If we encounter a code\n-        // block, then the lifetime is not bound but free, so switch\n-        // over to `resolve_free_lifetime_ref()` to complete the\n+        // given name or we run out of scopes.\n         // search.\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n-        loop {\n+        let mut outermost_body = None;\n+        let result = loop {\n             match *scope {\n-                FnScope {fn_id, body_id, s } => {\n-                    return self.resolve_free_lifetime_ref(\n-                        region::CallSiteScopeData { fn_id: fn_id, body_id: body_id },\n-                        lifetime_ref,\n-                        s);\n+                Scope::Body { id, s } => {\n+                    outermost_body = Some(id);\n+                    scope = s;\n                 }\n \n-                RootScope => {\n-                    break;\n+                Scope::Root => {\n+                    break None;\n                 }\n \n-                EarlyScope(lifetimes, start, s) => {\n-                    match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((index, lifetime_def)) => {\n-                            let decl_id = lifetime_def.id;\n-                            let def = DefEarlyBoundRegion(start + index, decl_id);\n-                            self.insert_lifetime(lifetime_ref, def);\n-                            return;\n-                        }\n-                        None => {\n+                Scope::Binder { ref lifetimes, s } => {\n+                    if let Some(&def) = lifetimes.get(&lifetime_ref.name) {\n+                        break Some(def.shifted(late_depth));\n+                    } else {\n+                        late_depth += 1;\n+                        scope = s;\n+                    }\n+                }\n+\n+                Scope::Elision { s, .. } |\n+                Scope::ObjectLifetimeDefault { s, .. } => {\n+                    scope = s;\n+                }\n+            }\n+        };\n+\n+        if let Some(mut def) = result {\n+            if let Some(body_id) = outermost_body {\n+                let fn_id = self.hir_map.body_owner(body_id);\n+                let scope_data = region::CallSiteScopeData {\n+                    fn_id: fn_id, body_id: body_id.node_id\n+                };\n+                match self.hir_map.get(fn_id) {\n+                    hir::map::NodeItem(&hir::Item {\n+                        node: hir::ItemFn(..), ..\n+                    }) |\n+                    hir::map::NodeTraitItem(&hir::TraitItem {\n+                        node: hir::TraitItemKind::Method(..), ..\n+                    }) |\n+                    hir::map::NodeImplItem(&hir::ImplItem {\n+                        node: hir::ImplItemKind::Method(..), ..\n+                    }) => {\n+                        def = Region::Free(scope_data, def.id().unwrap());\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            self.insert_lifetime(lifetime_ref, def);\n+        } else {\n+            struct_span_err!(self.sess, lifetime_ref.span, E0261,\n+                \"use of undeclared lifetime name `{}`\", lifetime_ref.name)\n+                .span_label(lifetime_ref.span, &format!(\"undeclared lifetime\"))\n+                .emit();\n+        }\n+    }\n+\n+    fn visit_segment_parameters(&mut self,\n+                                def: Def,\n+                                depth: usize,\n+                                params: &'tcx hir::PathParameters) {\n+        let data = match *params {\n+            hir::ParenthesizedParameters(ref data) => {\n+                self.visit_fn_like_elision(&data.inputs, data.output.as_ref());\n+                return;\n+            }\n+            hir::AngleBracketedParameters(ref data) => data\n+        };\n+\n+        if data.lifetimes.iter().all(|l| l.is_elided()) {\n+            self.resolve_elided_lifetimes(&data.lifetimes);\n+        } else {\n+            for l in &data.lifetimes { self.visit_lifetime(l); }\n+        }\n+\n+        // Figure out if this is a type/trait segment,\n+        // which requires object lifetime defaults.\n+        let parent_def_id = |this: &mut Self, def_id: DefId| {\n+            let def_key = if def_id.is_local() {\n+                this.hir_map.def_key(def_id)\n+            } else {\n+                this.sess.cstore.def_key(def_id)\n+            };\n+            DefId {\n+                krate: def_id.krate,\n+                index: def_key.parent.expect(\"missing parent\")\n+            }\n+        };\n+        let type_def_id = match def {\n+            Def::AssociatedTy(def_id) if depth == 1 => {\n+                Some(parent_def_id(self, def_id))\n+            }\n+            Def::Variant(def_id) if depth == 0 => {\n+                Some(parent_def_id(self, def_id))\n+            }\n+            Def::Struct(def_id) |\n+            Def::Union(def_id) |\n+            Def::Enum(def_id) |\n+            Def::TyAlias(def_id) |\n+            Def::Trait(def_id) if depth == 0 => Some(def_id),\n+            _ => None\n+        };\n+\n+        let object_lifetime_defaults = type_def_id.map_or(vec![], |def_id| {\n+            let in_body = {\n+                let mut scope = self.scope;\n+                loop {\n+                    match *scope {\n+                        Scope::Root => break false,\n+\n+                        Scope::Body { .. } => break true,\n+\n+                        Scope::Binder { s, .. } |\n+                        Scope::Elision { s, .. } |\n+                        Scope::ObjectLifetimeDefault { s, .. } => {\n                             scope = s;\n                         }\n                     }\n                 }\n+            };\n+\n+            let map = &self.map;\n+            let unsubst = if let Some(id) = self.hir_map.as_local_node_id(def_id) {\n+                &map.object_lifetime_defaults[&id]\n+            } else {\n+                let cstore = &self.sess.cstore;\n+                self.xcrate_object_lifetime_defaults.entry(def_id).or_insert_with(|| {\n+                    cstore.item_generics_object_lifetime_defaults(def_id)\n+                })\n+            };\n+            unsubst.iter().map(|set| {\n+                match *set {\n+                    Set1::Empty => {\n+                        if in_body {\n+                            None\n+                        } else {\n+                            Some(Region::Static)\n+                        }\n+                    }\n+                    Set1::One(r) => r.subst(&data.lifetimes, map),\n+                    Set1::Many => None\n+                }\n+            }).collect()\n+        });\n+\n+        for (i, ty) in data.types.iter().enumerate() {\n+            if let Some(&lt) = object_lifetime_defaults.get(i) {\n+                let scope = Scope::ObjectLifetimeDefault {\n+                    lifetime: lt,\n+                    s: self.scope\n+                };\n+                self.with(scope, |_, this| this.visit_ty(ty));\n+            } else {\n+                self.visit_ty(ty);\n+            }\n+        }\n+\n+        for b in &data.bindings { self.visit_assoc_type_binding(b); }\n+    }\n+\n+    fn visit_fn_like_elision(&mut self, inputs: &'tcx [P<hir::Ty>],\n+                             output: Option<&'tcx P<hir::Ty>>) {\n+        let mut arg_elide = Elide::FreshLateAnon(Cell::new(0));\n+        let arg_scope = Scope::Elision {\n+            elide: arg_elide.clone(),\n+            s: self.scope\n+        };\n+        self.with(arg_scope, |_, this| {\n+            for input in inputs {\n+                this.visit_ty(input);\n+            }\n+            match *this.scope {\n+                Scope::Elision { ref elide, .. } => {\n+                    arg_elide = elide.clone();\n+                }\n+                _ => bug!()\n+            }\n+        });\n+\n+        let output = match output {\n+            Some(ty) => ty,\n+            None => return\n+        };\n+\n+        // Figure out if there's a body we can get argument names from,\n+        // and whether there's a `self` argument (treated specially).\n+        let mut assoc_item_kind = None;\n+        let mut impl_self = None;\n+        let parent = self.hir_map.get_parent_node(output.id);\n+        let body = match self.hir_map.get(parent) {\n+            // `fn` definitions and methods.\n+            hir::map::NodeItem(&hir::Item {\n+                node: hir::ItemFn(.., body), ..\n+            })  => Some(body),\n+\n+            hir::map::NodeTraitItem(&hir::TraitItem {\n+                node: hir::TraitItemKind::Method(_, ref m), ..\n+            }) => {\n+                match self.hir_map.expect_item(self.hir_map.get_parent(parent)).node {\n+                    hir::ItemTrait(.., ref trait_items) => {\n+                        assoc_item_kind = trait_items.iter().find(|ti| ti.id.node_id == parent)\n+                                                            .map(|ti| ti.kind);\n+                    }\n+                    _ => {}\n+                }\n+                match *m {\n+                    hir::TraitMethod::Required(_) => None,\n+                    hir::TraitMethod::Provided(body) => Some(body),\n+                }\n+            }\n+\n+            hir::map::NodeImplItem(&hir::ImplItem {\n+                node: hir::ImplItemKind::Method(_, body), ..\n+            }) => {\n+                match self.hir_map.expect_item(self.hir_map.get_parent(parent)).node {\n+                    hir::ItemImpl(.., ref self_ty, ref impl_items) => {\n+                        impl_self = Some(self_ty);\n+                        assoc_item_kind = impl_items.iter().find(|ii| ii.id.node_id == parent)\n+                                                           .map(|ii| ii.kind);\n+                    }\n+                    _ => {}\n+                }\n+                Some(body)\n+            }\n+\n+            // `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n+            hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) => None,\n+\n+            // Foreign `fn` decls are terrible because we messed up,\n+            // and their return types get argument type elision.\n+            // And now too much code out there is abusing this rule.\n+            hir::map::NodeForeignItem(_) => {\n+                let arg_scope = Scope::Elision {\n+                    elide: arg_elide,\n+                    s: self.scope\n+                };\n+                self.with(arg_scope, |_, this| this.visit_ty(output));\n+                return;\n+            }\n+\n+            // Everything else (only closures?) doesn't\n+            // actually enjoy elision in return types.\n+            _ => {\n+                self.visit_ty(output);\n+                return;\n+            }\n+        };\n+\n+        let has_self = match assoc_item_kind {\n+            Some(hir::AssociatedItemKind::Method { has_self }) => has_self,\n+            _ => false\n+        };\n+\n+        // In accordance with the rules for lifetime elision, we can determine\n+        // what region to use for elision in the output type in two ways.\n+        // First (determined here), if `self` is by-reference, then the\n+        // implied output region is the region of the self parameter.\n+        if has_self {\n+            // Look for `self: &'a Self` - also desugared from `&'a self`,\n+            // and if that matches, use it for elision and return early.\n+            let is_self_ty = |def: Def| {\n+                if let Def::SelfTy(..) = def {\n+                    return true;\n+                }\n+\n+                // Can't always rely on literal (or implied) `Self` due\n+                // to the way elision rules were originally specified.\n+                let impl_self = impl_self.map(|ty| &ty.node);\n+                if let Some(&hir::TyPath(hir::QPath::Resolved(None, ref path))) = impl_self {\n+                    match path.def {\n+                        // Whitelist the types that unambiguously always\n+                        // result in the same type constructor being used\n+                        // (it can't differ between `Self` and `self`).\n+                        Def::Struct(_) |\n+                        Def::Union(_) |\n+                        Def::Enum(_) |\n+                        Def::PrimTy(_) => return def == path.def,\n+                        _ => {}\n+                    }\n+                }\n \n-                LateScope(lifetimes, s) => {\n-                    match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((_index, lifetime_def)) => {\n-                            let decl_id = lifetime_def.id;\n-                            let debruijn = ty::DebruijnIndex::new(late_depth + 1);\n-                            let def = DefLateBoundRegion(debruijn, decl_id);\n-                            self.insert_lifetime(lifetime_ref, def);\n+                false\n+            };\n+\n+            if let hir::TyRptr(lifetime_ref, ref mt) = inputs[0].node {\n+                if let hir::TyPath(hir::QPath::Resolved(None, ref path)) = mt.ty.node {\n+                    if is_self_ty(path.def) {\n+                        if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n+                            let scope = Scope::Elision {\n+                                elide: Elide::Exact(lifetime),\n+                                s: self.scope\n+                            };\n+                            self.with(scope, |_, this| this.visit_ty(output));\n                             return;\n                         }\n+                    }\n+                }\n+            }\n+        }\n \n-                        None => {\n-                            late_depth += 1;\n-                            scope = s;\n+        // Second, if there was exactly one lifetime (either a substitution or a\n+        // reference) in the arguments, then any anonymous regions in the output\n+        // have that lifetime.\n+        let mut possible_implied_output_region = None;\n+        let mut lifetime_count = 0;\n+        let arg_lifetimes = inputs.iter().enumerate().skip(has_self as usize).map(|(i, input)| {\n+            let mut gather = GatherLifetimes {\n+                map: self.map,\n+                binder_depth: 1,\n+                have_bound_regions: false,\n+                lifetimes: FxHashSet()\n+            };\n+            gather.visit_ty(input);\n+\n+            lifetime_count += gather.lifetimes.len();\n+\n+            if lifetime_count == 1 && gather.lifetimes.len() == 1 {\n+                // there's a chance that the unique lifetime of this\n+                // iteration will be the appropriate lifetime for output\n+                // parameters, so lets store it.\n+                possible_implied_output_region = gather.lifetimes.iter().cloned().next();\n+            }\n+\n+            ElisionFailureInfo {\n+                parent: body,\n+                index: i,\n+                lifetime_count: gather.lifetimes.len(),\n+                have_bound_regions: gather.have_bound_regions\n+            }\n+        }).collect();\n+\n+        let elide = if lifetime_count == 1 {\n+            Elide::Exact(possible_implied_output_region.unwrap())\n+        } else {\n+            Elide::Error(arg_lifetimes)\n+        };\n+\n+        let scope = Scope::Elision {\n+            elide: elide,\n+            s: self.scope\n+        };\n+        self.with(scope, |_, this| this.visit_ty(output));\n+\n+        struct GatherLifetimes<'a> {\n+            map: &'a NamedRegionMap,\n+            binder_depth: u32,\n+            have_bound_regions: bool,\n+            lifetimes: FxHashSet<Region>,\n+        }\n+\n+        impl<'v, 'a> Visitor<'v> for GatherLifetimes<'a> {\n+            fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+                NestedVisitorMap::None\n+            }\n+\n+            fn visit_ty(&mut self, ty: &hir::Ty) {\n+                if let hir::TyBareFn(_) = ty.node {\n+                    self.binder_depth += 1;\n+                }\n+                if let hir::TyTraitObject(ref bounds, ref lifetime) = ty.node {\n+                    for bound in bounds {\n+                        self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n+                    }\n+\n+                    // Stay on the safe side and don't include the object\n+                    // lifetime default (which may not end up being used).\n+                    if !lifetime.is_elided() {\n+                        self.visit_lifetime(lifetime);\n+                    }\n+                } else {\n+                    intravisit::walk_ty(self, ty);\n+                }\n+                if let hir::TyBareFn(_) = ty.node {\n+                    self.binder_depth -= 1;\n+                }\n+            }\n+\n+            fn visit_poly_trait_ref(&mut self,\n+                                    trait_ref: &hir::PolyTraitRef,\n+                                    modifier: hir::TraitBoundModifier) {\n+                self.binder_depth += 1;\n+                intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n+                self.binder_depth -= 1;\n+            }\n+\n+            fn visit_lifetime_def(&mut self, lifetime_def: &hir::LifetimeDef) {\n+                for l in &lifetime_def.bounds { self.visit_lifetime(l); }\n+            }\n+\n+            fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n+                if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n+                    match lifetime {\n+                        Region::LateBound(debruijn, _) |\n+                        Region::LateBoundAnon(debruijn, _)\n+                                if debruijn.depth < self.binder_depth => {\n+                            self.have_bound_regions = true;\n+                        }\n+                        _ => {\n+                            self.lifetimes.insert(lifetime.from_depth(self.binder_depth));\n                         }\n                     }\n                 }\n             }\n         }\n \n-        self.unresolved_lifetime_ref(lifetime_ref);\n     }\n \n-    fn resolve_free_lifetime_ref(&mut self,\n-                                 scope_data: region::CallSiteScopeData,\n-                                 lifetime_ref: &hir::Lifetime,\n-                                 scope: Scope) {\n-        debug!(\"resolve_free_lifetime_ref \\\n-                scope_data: {:?} lifetime_ref: {:?} scope: {:?}\",\n-               scope_data, lifetime_ref, scope);\n+    fn resolve_elided_lifetimes(&mut self, lifetime_refs: &[hir::Lifetime]) {\n+        if lifetime_refs.is_empty() {\n+            return;\n+        }\n \n-        // Walk up the scope chain, tracking the outermost free scope,\n-        // until we encounter a scope that contains the named lifetime\n-        // or we run out of scopes.\n-        let mut scope_data = scope_data;\n-        let mut scope = scope;\n-        let mut search_result = None;\n-        loop {\n-            debug!(\"resolve_free_lifetime_ref \\\n-                    scope_data: {:?} scope: {:?} search_result: {:?}\",\n-                   scope_data, scope, search_result);\n+        let span = lifetime_refs[0].span;\n+        let mut late_depth = 0;\n+        let mut scope = self.scope;\n+        let error = loop {\n             match *scope {\n-                FnScope { fn_id, body_id, s } => {\n-                    scope_data = region::CallSiteScopeData {\n-                        fn_id: fn_id, body_id: body_id\n-                    };\n+                // Do not assign any resolution, it will be inferred.\n+                Scope::Body { .. } => return,\n+\n+                Scope::Root => break None,\n+\n+                Scope::Binder { s, .. } => {\n+                    late_depth += 1;\n                     scope = s;\n                 }\n \n-                RootScope => {\n-                    break;\n+                Scope::Elision { ref elide, .. } => {\n+                    let lifetime = match *elide {\n+                        Elide::FreshLateAnon(ref counter) => {\n+                            for lifetime_ref in lifetime_refs {\n+                                let lifetime = Region::late_anon(counter).shifted(late_depth);\n+                                self.insert_lifetime(lifetime_ref, lifetime);\n+                            }\n+                            return;\n+                        }\n+                        Elide::Exact(l) => l.shifted(late_depth),\n+                        Elide::Static => {\n+                            if !self.sess.features.borrow().static_in_const {\n+                                self.sess\n+                                    .struct_span_err(span,\n+                                                     \"this needs a `'static` lifetime or the \\\n+                                                      `static_in_const` feature, see #35897\")\n+                                    .emit();\n+                            }\n+                            Region::Static\n+                        }\n+                        Elide::Error(ref e) => break Some(e)\n+                    };\n+                    for lifetime_ref in lifetime_refs {\n+                        self.insert_lifetime(lifetime_ref, lifetime);\n+                    }\n+                    return;\n                 }\n \n-                EarlyScope(lifetimes, _, s) |\n-                LateScope(lifetimes, s) => {\n-                    search_result = search_lifetimes(lifetimes, lifetime_ref);\n-                    if search_result.is_some() {\n-                        break;\n-                    }\n+                Scope::ObjectLifetimeDefault { s, .. } => {\n                     scope = s;\n                 }\n             }\n-        }\n+        };\n \n-        match search_result {\n-            Some((_depth, lifetime)) => {\n-                let def = DefFreeRegion(scope_data, lifetime.id);\n-                self.insert_lifetime(lifetime_ref, def);\n+        let mut err = struct_span_err!(self.sess, span, E0106,\n+            \"missing lifetime specifier{}\",\n+            if lifetime_refs.len() > 1 { \"s\" } else { \"\" });\n+        let msg = if lifetime_refs.len() > 1 {\n+            format!(\"expected {} lifetime parameters\", lifetime_refs.len())\n+        } else {\n+            format!(\"expected lifetime parameter\")\n+        };\n+        err.span_label(span, &msg);\n+\n+        if let Some(params) = error {\n+            if lifetime_refs.len() == 1 {\n+                self.report_elision_failure(&mut err, params);\n             }\n+        }\n+        err.emit();\n+    }\n \n-            None => {\n-                self.unresolved_lifetime_ref(lifetime_ref);\n+    fn report_elision_failure(&mut self,\n+                              db: &mut DiagnosticBuilder,\n+                              params: &[ElisionFailureInfo]) {\n+        let mut m = String::new();\n+        let len = params.len();\n+\n+        let elided_params: Vec<_> = params.iter().cloned()\n+                                          .filter(|info| info.lifetime_count > 0)\n+                                          .collect();\n+\n+        let elided_len = elided_params.len();\n+\n+        for (i, info) in elided_params.into_iter().enumerate() {\n+            let ElisionFailureInfo {\n+                parent, index, lifetime_count: n, have_bound_regions\n+            } = info;\n+\n+            let help_name = if let Some(body) = parent {\n+                let arg = &self.hir_map.body(body).arguments[index];\n+                format!(\"`{}`\", self.hir_map.node_to_pretty_string(arg.pat.id))\n+            } else {\n+                format!(\"argument {}\", index + 1)\n+            };\n+\n+            m.push_str(&(if n == 1 {\n+                help_name\n+            } else {\n+                format!(\"one of {}'s {} elided {}lifetimes\", help_name, n,\n+                        if have_bound_regions { \"free \" } else { \"\" } )\n+            })[..]);\n+\n+            if elided_len == 2 && i == 0 {\n+                m.push_str(\" or \");\n+            } else if i + 2 == elided_len {\n+                m.push_str(\", or \");\n+            } else if i != elided_len - 1 {\n+                m.push_str(\", \");\n             }\n+\n         }\n \n+        if len == 0 {\n+            help!(db,\n+                  \"this function's return type contains a borrowed value, but \\\n+                   there is no value for it to be borrowed from\");\n+            help!(db,\n+                  \"consider giving it a 'static lifetime\");\n+        } else if elided_len == 0 {\n+            help!(db,\n+                  \"this function's return type contains a borrowed value with \\\n+                   an elided lifetime, but the lifetime cannot be derived from \\\n+                   the arguments\");\n+            help!(db,\n+                  \"consider giving it an explicit bounded or 'static \\\n+                   lifetime\");\n+        } else if elided_len == 1 {\n+            help!(db,\n+                  \"this function's return type contains a borrowed value, but \\\n+                   the signature does not say which {} it is borrowed from\",\n+                  m);\n+        } else {\n+            help!(db,\n+                  \"this function's return type contains a borrowed value, but \\\n+                   the signature does not say whether it is borrowed from {}\",\n+                  m);\n+        }\n     }\n \n-    fn unresolved_lifetime_ref(&self, lifetime_ref: &hir::Lifetime) {\n-        struct_span_err!(self.sess, lifetime_ref.span, E0261,\n-            \"use of undeclared lifetime name `{}`\", lifetime_ref.name)\n-            .span_label(lifetime_ref.span, &format!(\"undeclared lifetime\"))\n-            .emit();\n+    fn resolve_object_lifetime_default(&mut self, lifetime_ref: &hir::Lifetime) {\n+        let mut late_depth = 0;\n+        let mut scope = self.scope;\n+        let lifetime = loop {\n+            match *scope {\n+                Scope::Binder { s, .. } => {\n+                    late_depth += 1;\n+                    scope = s;\n+                }\n+\n+                Scope::Root |\n+                Scope::Elision { .. } => break Region::Static,\n+\n+                Scope::Body { .. } |\n+                Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n+\n+                Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l\n+            }\n+        };\n+        self.insert_lifetime(lifetime_ref, lifetime.shifted(late_depth));\n     }\n \n-    fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &[hir::LifetimeDef]) {\n+    fn check_lifetime_defs(&mut self, old_scope: ScopeRef, lifetimes: &[hir::LifetimeDef]) {\n         for i in 0..lifetimes.len() {\n             let lifetime_i = &lifetimes[i];\n \n@@ -770,7 +1475,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn check_lifetime_def_for_shadowing(&self,\n-                                        mut old_scope: Scope,\n+                                        mut old_scope: ScopeRef,\n                                         lifetime: &hir::Lifetime)\n     {\n         for &(label, label_span) in &self.labels_in_fn {\n@@ -786,21 +1491,22 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         loop {\n             match *old_scope {\n-                FnScope { s, .. } => {\n+                Scope::Body { s, .. } |\n+                Scope::Elision { s, .. } |\n+                Scope::ObjectLifetimeDefault { s, .. } => {\n                     old_scope = s;\n                 }\n \n-                RootScope => {\n+                Scope::Root => {\n                     return;\n                 }\n \n-                EarlyScope(lifetimes, _, s) |\n-                LateScope(lifetimes, s) => {\n-                    if let Some((_, lifetime_def)) = search_lifetimes(lifetimes, lifetime) {\n+                Scope::Binder { ref lifetimes, s } => {\n+                    if let Some(&def) = lifetimes.get(&lifetime.name) {\n                         signal_shadowing_problem(\n                             self.sess,\n                             lifetime.name,\n-                            original_lifetime(&lifetime_def),\n+                            original_lifetime(self.hir_map.span(def.id().unwrap())),\n                             shadower_lifetime(&lifetime));\n                         return;\n                     }\n@@ -813,7 +1519,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n     fn insert_lifetime(&mut self,\n                        lifetime_ref: &hir::Lifetime,\n-                       def: DefRegion) {\n+                       def: Region) {\n         if lifetime_ref.id == ast::DUMMY_NODE_ID {\n             span_bug!(lifetime_ref.span,\n                       \"lifetime reference not renumbered, \\\n@@ -828,17 +1534,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n }\n \n-fn search_lifetimes<'a>(lifetimes: &'a [hir::LifetimeDef],\n-                    lifetime_ref: &hir::Lifetime)\n-                    -> Option<(u32, &'a hir::Lifetime)> {\n-    for (i, lifetime_decl) in lifetimes.iter().enumerate() {\n-        if lifetime_decl.lifetime.name == lifetime_ref.name {\n-            return Some((i as u32, &lifetime_decl.lifetime));\n-        }\n-    }\n-    return None;\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n \n /// Detects late-bound lifetimes and inserts them into"}, {"sha": "7419d74287b97a9d3e4c0adabc88063b2a823f45", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -899,6 +899,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"attempt to recover from parse errors (experimental)\"),\n     incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"enable incremental compilation (experimental)\"),\n+    incremental_cc: bool = (false, parse_bool, [UNTRACKED],\n+          \"enable cross-crate incremental compilation (even more experimental)\"),\n     incremental_info: bool = (false, parse_bool, [UNTRACKED],\n         \"print high-level information about incremental reuse (or the lack thereof)\"),\n     incremental_dump_hash: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "383fab3fcd766cc1d40cd774c0f44f249b3cf792", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -199,7 +199,7 @@ fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n \n fn uncovered_tys<'tcx>(tcx: TyCtxt, ty: Ty<'tcx>, infer_is_local: InferIsLocal)\n                        -> Vec<Ty<'tcx>> {\n-    if ty_is_local_constructor(tcx, ty, infer_is_local) {\n+    if ty_is_local_constructor(ty, infer_is_local) {\n         vec![]\n     } else if fundamental_ty(tcx, ty) {\n         ty.walk_shallow()\n@@ -219,13 +219,13 @@ fn is_type_parameter(ty: Ty) -> bool {\n }\n \n fn ty_is_local(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal) -> bool {\n-    ty_is_local_constructor(tcx, ty, infer_is_local) ||\n+    ty_is_local_constructor(ty, infer_is_local) ||\n         fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, infer_is_local))\n }\n \n fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n     match ty.sty {\n-        ty::TyBox(..) | ty::TyRef(..) => true,\n+        ty::TyRef(..) => true,\n         ty::TyAdt(def, _) => def.is_fundamental(),\n         ty::TyDynamic(ref data, ..) => {\n             data.principal().map_or(false, |p| tcx.has_attr(p.def_id(), \"fundamental\"))\n@@ -234,7 +234,7 @@ fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n     }\n }\n \n-fn ty_is_local_constructor(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal)-> bool {\n+fn ty_is_local_constructor(ty: Ty, infer_is_local: InferIsLocal)-> bool {\n     debug!(\"ty_is_local_constructor({:?})\", ty);\n \n     match ty.sty {\n@@ -265,11 +265,6 @@ fn ty_is_local_constructor(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal)->\n             def.did.is_local()\n         }\n \n-        ty::TyBox(_) => { // Box<T>\n-            let krate = tcx.lang_items.owned_box().map(|d| d.krate);\n-            krate == Some(LOCAL_CRATE)\n-        }\n-\n         ty::TyDynamic(ref tt, ..) => {\n             tt.principal().map_or(false, |p| p.def_id().is_local())\n         }"}, {"sha": "661d47199df13991861ca3023eeb302a4a9d6931", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -154,7 +154,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyStr => Some(2),\n                 ty::TyInt(..) | ty::TyUint(..) | ty::TyInfer(ty::IntVar(..)) => Some(3),\n                 ty::TyFloat(..) | ty::TyInfer(ty::FloatVar(..)) => Some(4),\n-                ty::TyBox(..) | ty::TyRef(..) | ty::TyRawPtr(..) => Some(5),\n+                ty::TyRef(..) | ty::TyRawPtr(..) => Some(5),\n                 ty::TyArray(..) | ty::TySlice(..) => Some(6),\n                 ty::TyFnDef(..) | ty::TyFnPtr(..) => Some(7),\n                 ty::TyDynamic(..) => Some(8),"}, {"sha": "d51332f833d77cfdbefddc812c1092da8d7177c6", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -1735,7 +1735,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n             ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n             ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyRawPtr(..) |\n-            ty::TyChar | ty::TyBox(_) | ty::TyRef(..) |\n+            ty::TyChar | ty::TyRef(..) |\n             ty::TyArray(..) | ty::TyClosure(..) | ty::TyNever |\n             ty::TyError => {\n                 // safe for everything\n@@ -1788,7 +1788,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(Vec::new()))\n             }\n \n-            ty::TyBox(_) | ty::TyDynamic(..) | ty::TyStr | ty::TySlice(..) |\n+            ty::TyDynamic(..) | ty::TyStr | ty::TySlice(..) |\n             ty::TyClosure(..) |\n             ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n                 Never\n@@ -1865,10 +1865,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                      t);\n             }\n \n-            ty::TyBox(referent_ty) => {  // Box<T>\n-                vec![referent_ty]\n-            }\n-\n             ty::TyRawPtr(ty::TypeAndMut { ty: element_ty, ..}) |\n             ty::TyRef(_, ty::TypeAndMut { ty: element_ty, ..}) => {\n                 vec![element_ty]"}, {"sha": "00c6dca21b1ef4f5f2a031973b1008498785b420", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -56,12 +56,8 @@ def_type_content_sets! {\n         // InteriorAll                         = 0b00000000__00000000__1111,\n \n         // Things that are owned by the value (second and third nibbles):\n-        OwnsOwned                           = 0b0000_0000__0000_0001__0000,\n         OwnsDtor                            = 0b0000_0000__0000_0010__0000,\n-        OwnsAll                             = 0b0000_0000__1111_1111__0000,\n-\n-        // Things that mean drop glue is necessary\n-        NeedsDrop                           = 0b0000_0000__0000_0111__0000,\n+        // OwnsAll                             = 0b0000_0000__1111_1111__0000,\n \n         // All bits\n         All                                 = 0b1111_1111__1111_1111__1111\n@@ -77,10 +73,6 @@ impl TypeContents {\n         (self.bits & tc.bits) != 0\n     }\n \n-    pub fn owns_owned(&self) -> bool {\n-        self.intersects(TC::OwnsOwned)\n-    }\n-\n     pub fn interior_param(&self) -> bool {\n         self.intersects(TC::InteriorParam)\n     }\n@@ -90,12 +82,7 @@ impl TypeContents {\n     }\n \n     pub fn needs_drop(&self, _: TyCtxt) -> bool {\n-        self.intersects(TC::NeedsDrop)\n-    }\n-\n-    /// Includes only those bits that still apply when indirected through a `Box` pointer\n-    pub fn owned_pointer(&self) -> TypeContents {\n-        TC::OwnsOwned | (*self & TC::OwnsAll)\n+        self.intersects(TC::OwnsDtor)\n     }\n \n     pub fn union<I, T, F>(v: I, mut f: F) -> TypeContents where\n@@ -104,10 +91,6 @@ impl TypeContents {\n     {\n         v.into_iter().fold(TC::None, |tc, ty| tc | f(ty))\n     }\n-\n-    pub fn has_dtor(&self) -> bool {\n-        self.intersects(TC::OwnsDtor)\n-    }\n }\n \n impl ops::BitOr for TypeContents {\n@@ -191,10 +174,6 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                     TC::None\n                 }\n \n-                ty::TyBox(typ) => {\n-                    tc_ty(tcx, typ, cache).owned_pointer()\n-                }\n-\n                 ty::TyDynamic(..) => {\n                     TC::All - TC::InteriorParam\n                 }\n@@ -237,7 +216,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n                     if def.is_union() {\n                         // unions don't have destructors regardless of the child types\n-                        res = res - TC::NeedsDrop;\n+                        res = res - TC::OwnsDtor;\n                     }\n \n                     if def.has_dtor() {"}, {"sha": "ce4a6a3182635d5aad030d99e5ef25474822d4f7", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -19,6 +19,7 @@ use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as hir_map;\n use hir::map::DisambiguatedDefPathData;\n use middle::free_region::FreeRegionMap;\n+use middle::lang_items;\n use middle::region::RegionMaps;\n use middle::resolve_lifetime;\n use middle::stability;\n@@ -231,7 +232,11 @@ pub struct TypeckTables<'tcx> {\n     /// of the struct - this is needed because it is non-trivial to\n     /// normalize while preserving regions. This table is used only in\n     /// MIR construction and hence is not serialized to metadata.\n-    pub fru_field_types: NodeMap<Vec<Ty<'tcx>>>\n+    pub fru_field_types: NodeMap<Vec<Ty<'tcx>>>,\n+\n+    /// Maps a cast expression to its kind. This is keyed on the\n+    /// *from* expression of the cast, not the cast itself.\n+    pub cast_kinds: NodeMap<ty::cast::CastKind>,\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n@@ -246,7 +251,8 @@ impl<'tcx> TypeckTables<'tcx> {\n             closure_tys: NodeMap(),\n             closure_kinds: NodeMap(),\n             liberated_fn_sigs: NodeMap(),\n-            fru_field_types: NodeMap()\n+            fru_field_types: NodeMap(),\n+            cast_kinds: NodeMap(),\n         }\n     }\n \n@@ -533,10 +539,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// expression defining the closure.\n     pub closure_kinds: RefCell<DepTrackingMap<maps::ClosureKinds<'tcx>>>,\n \n-    /// Maps a cast expression to its kind. This is keyed on the\n-    /// *from* expression of the cast, not the cast itself.\n-    pub cast_kinds: RefCell<NodeMap<ty::cast::CastKind>>,\n-\n     /// Maps Fn items to a collection of fragment infos.\n     ///\n     /// The main goal is to identify data (each of which may be moved\n@@ -792,7 +794,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n             closure_tys: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             closure_kinds: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            cast_kinds: RefCell::new(NodeMap()),\n             fragment_infos: RefCell::new(DefIdMap()),\n             crate_name: Symbol::intern(crate_name),\n             data_layout: data_layout,\n@@ -1088,7 +1089,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n-            TyAdt, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n+            TyAdt, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n             TyDynamic, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n@@ -1336,7 +1337,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyBox(ty))\n+        let def_id = self.require_lang_item(lang_items::OwnedBoxLangItem);\n+        let adt_def = self.lookup_adt_def(def_id);\n+        let substs = self.mk_substs(iter::once(Kind::from(ty)));\n+        self.mk_ty(TyAdt(adt_def, substs))\n     }\n \n     pub fn mk_ptr(self, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {"}, {"sha": "29d855a7fcb78ebf9cc3362bc7e100060243b610", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -181,7 +181,6 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyTuple(ref tys) if tys.is_empty() => self.to_string(),\n \n             ty::TyAdt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)),\n-            ty::TyBox(_) => \"box\".to_string(),\n             ty::TyArray(_, n) => format!(\"array of {} elements\", n),\n             ty::TySlice(_) => \"slice\".to_string(),\n             ty::TyRawPtr(_) => \"*-ptr\".to_string(),"}, {"sha": "94b9abc72025faed7f33357bdcd25610416ed7d8", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -11,7 +11,6 @@\n use hir::def_id::DefId;\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n-use middle::lang_items::OwnedBoxLangItem;\n \n use self::SimplifiedType::*;\n \n@@ -69,10 +68,6 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             // view of possibly unifying\n             simplify_type(tcx, mt.ty, can_simplify_params)\n         }\n-        ty::TyBox(_) => {\n-            // treat like we would treat `Box`\n-            Some(AdtSimplifiedType(tcx.require_lang_item(OwnedBoxLangItem)))\n-        }\n         ty::TyClosure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))\n         }"}, {"sha": "0de77526b5a46a2e934c36ee239a200f441ab05f", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -138,7 +138,7 @@ impl FlagComputation {\n                 self.add_region(r);\n             }\n \n-            &ty::TyBox(tt) | &ty::TyArray(tt, _) | &ty::TySlice(tt) => {\n+            &ty::TyArray(tt, _) | &ty::TySlice(tt) => {\n                 self.add_ty(tt)\n             }\n "}, {"sha": "6c49493a655597abb1b95ec23aeba408ea0bcffa", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -191,11 +191,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 }\n             }\n             TyRef(_, ref tm) => {\n-                if tcx.sess.features.borrow().never_type {\n-                    tm.ty.uninhabited_from(visited, tcx)\n-                } else {\n-                    DefIdForest::empty()\n-                }\n+                tm.ty.uninhabited_from(visited, tcx)\n             }\n \n             _ => DefIdForest::empty(),"}, {"sha": "b719911d18cf8706113805f6ccba94fe49f00b21", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -314,8 +314,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n         ty::TyDynamic(data, ..) => data.principal().map(|p| p.def_id()),\n \n         ty::TyArray(subty, _) |\n-        ty::TySlice(subty) |\n-        ty::TyBox(subty) => characteristic_def_id_of_type(subty),\n+        ty::TySlice(subty) => characteristic_def_id_of_type(subty),\n \n         ty::TyRawPtr(mt) |\n         ty::TyRef(_, mt) => characteristic_def_id_of_type(mt.ty),"}, {"sha": "78364abdaecba9ee2a160cf811b53846687211d1", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -1053,6 +1053,23 @@ impl<'a, 'gcx, 'tcx> Layout {\n         let dl = &tcx.data_layout;\n         assert!(!ty.has_infer_types());\n \n+        let ptr_layout = |pointee: Ty<'gcx>| {\n+            let non_zero = !ty.is_unsafe_ptr();\n+            let pointee = normalize_associated_type(infcx, pointee);\n+            if pointee.is_sized(tcx, &infcx.parameter_environment, DUMMY_SP) {\n+                Ok(Scalar { value: Pointer, non_zero: non_zero })\n+            } else {\n+                let unsized_part = tcx.struct_tail(pointee);\n+                let meta = match unsized_part.sty {\n+                    ty::TySlice(_) | ty::TyStr => {\n+                        Int(dl.ptr_sized_integer())\n+                    }\n+                    ty::TyDynamic(..) => Pointer,\n+                    _ => return Err(LayoutError::Unknown(unsized_part))\n+                };\n+                Ok(FatPointer { metadata: meta, non_zero: non_zero })\n+            }\n+        };\n \n         let layout = match ty.sty {\n             // Basic scalars.\n@@ -1082,24 +1099,12 @@ impl<'a, 'gcx, 'tcx> Layout {\n             },\n \n             // Potentially-fat pointers.\n-            ty::TyBox(pointee) |\n             ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n-                let non_zero = !ty.is_unsafe_ptr();\n-                let pointee = normalize_associated_type(infcx, pointee);\n-                if pointee.is_sized(tcx, &infcx.parameter_environment, DUMMY_SP) {\n-                    Scalar { value: Pointer, non_zero: non_zero }\n-                } else {\n-                    let unsized_part = tcx.struct_tail(pointee);\n-                    let meta = match unsized_part.sty {\n-                        ty::TySlice(_) | ty::TyStr => {\n-                            Int(dl.ptr_sized_integer())\n-                        }\n-                        ty::TyDynamic(..) => Pointer,\n-                        _ => return Err(LayoutError::Unknown(unsized_part))\n-                    };\n-                    FatPointer { metadata: meta, non_zero: non_zero }\n-                }\n+                ptr_layout(pointee)?\n+            }\n+            ty::TyAdt(def, _) if def.is_box() => {\n+                ptr_layout(ty.boxed_ty())?\n             }\n \n             // Arrays and slices.\n@@ -1560,26 +1565,32 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n             Err(err) => err\n         };\n \n+        let ptr_skeleton = |pointee: Ty<'gcx>| {\n+            let non_zero = !ty.is_unsafe_ptr();\n+            let tail = tcx.struct_tail(pointee);\n+            match tail.sty {\n+                ty::TyParam(_) | ty::TyProjection(_) => {\n+                    assert!(tail.has_param_types() || tail.has_self_ty());\n+                    Ok(SizeSkeleton::Pointer {\n+                        non_zero: non_zero,\n+                        tail: tcx.erase_regions(&tail)\n+                    })\n+                }\n+                _ => {\n+                    bug!(\"SizeSkeleton::compute({}): layout errored ({}), yet \\\n+                            tail `{}` is not a type parameter or a projection\",\n+                            ty, err, tail)\n+                }\n+            }\n+        };\n+\n         match ty.sty {\n-            ty::TyBox(pointee) |\n             ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n-                let non_zero = !ty.is_unsafe_ptr();\n-                let tail = tcx.struct_tail(pointee);\n-                match tail.sty {\n-                    ty::TyParam(_) | ty::TyProjection(_) => {\n-                        assert!(tail.has_param_types() || tail.has_self_ty());\n-                        Ok(SizeSkeleton::Pointer {\n-                            non_zero: non_zero,\n-                            tail: tcx.erase_regions(&tail)\n-                        })\n-                    }\n-                    _ => {\n-                        bug!(\"SizeSkeleton::compute({}): layout errored ({}), yet \\\n-                              tail `{}` is not a type parameter or a projection\",\n-                             ty, err, tail)\n-                    }\n-                }\n+                ptr_skeleton(pointee)\n+            }\n+            ty::TyAdt(def, _) if def.is_box() => {\n+                ptr_skeleton(ty.boxed_ty())\n             }\n \n             ty::TyAdt(def, substs) => {"}, {"sha": "5ab45e746e7f25e67763af997ff915812cf60631", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 20, "deletions": 51, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n pub use self::Variance::*;\n-pub use self::DtorKind::*;\n pub use self::AssociatedItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n@@ -120,21 +119,6 @@ pub struct Resolutions {\n     pub maybe_unused_trait_imports: NodeSet,\n }\n \n-#[derive(Copy, Clone)]\n-pub enum DtorKind {\n-    NoDtor,\n-    TraitDtor\n-}\n-\n-impl DtorKind {\n-    pub fn is_present(&self) -> bool {\n-        match *self {\n-            TraitDtor => true,\n-            _ => false\n-        }\n-    }\n-}\n-\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum AssociatedItemContainer {\n     TraitContainer(DefId),\n@@ -514,7 +498,7 @@ pub enum BorrowKind {\n \n     /// Data must be immutable but not aliasable.  This kind of borrow\n     /// cannot currently be expressed by the user and is used only in\n-    /// implicit closure bindings. It is needed when you the closure\n+    /// implicit closure bindings. It is needed when the closure\n     /// is borrowing or mutating a mutable referent, e.g.:\n     ///\n     ///    let x: &mut isize = ...;\n@@ -592,53 +576,33 @@ pub enum IntVarValue {\n     UintType(ast::UintTy),\n }\n \n-/// Default region to use for the bound of objects that are\n-/// supplied as the value for this type parameter. This is derived\n-/// from `T:'a` annotations appearing in the type definition.  If\n-/// this is `None`, then the default is inherited from the\n-/// surrounding context. See RFC #599 for details.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub enum ObjectLifetimeDefault<'tcx> {\n-    /// Require an explicit annotation. Occurs when multiple\n-    /// `T:'a` constraints are found.\n-    Ambiguous,\n-\n-    /// Use the base default, typically 'static, but in a fn body it is a fresh variable\n-    BaseDefault,\n-\n-    /// Use the given region as the default.\n-    Specific(&'tcx Region),\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct TypeParameterDef<'tcx> {\n     pub name: Name,\n     pub def_id: DefId,\n     pub index: u32,\n     pub default_def_id: DefId, // for use in error reporing about defaults\n     pub default: Option<Ty<'tcx>>,\n-    pub object_lifetime_default: ObjectLifetimeDefault<'tcx>,\n \n     /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n     /// on generic parameter `T`, asserts data behind the parameter\n     /// `T` won't be accessed during the parent type's `Drop` impl.\n     pub pure_wrt_drop: bool,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub struct RegionParameterDef<'tcx> {\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+pub struct RegionParameterDef {\n     pub name: Name,\n     pub def_id: DefId,\n     pub index: u32,\n-    pub bounds: Vec<&'tcx ty::Region>,\n \n     /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n     /// on generic parameter `'a`, asserts data of lifetime `'a`\n     /// won't be accessed during the parent type's `Drop` impl.\n     pub pure_wrt_drop: bool,\n }\n \n-impl<'tcx> RegionParameterDef<'tcx> {\n+impl RegionParameterDef {\n     pub fn to_early_bound_region_data(&self) -> ty::EarlyBoundRegion {\n         ty::EarlyBoundRegion {\n             index: self.index,\n@@ -659,7 +623,7 @@ pub struct Generics<'tcx> {\n     pub parent: Option<DefId>,\n     pub parent_regions: u32,\n     pub parent_types: u32,\n-    pub regions: Vec<RegionParameterDef<'tcx>>,\n+    pub regions: Vec<RegionParameterDef>,\n     pub types: Vec<TypeParameterDef<'tcx>>,\n     pub has_self: bool,\n }\n@@ -677,7 +641,7 @@ impl<'tcx> Generics<'tcx> {\n         self.parent_count() + self.own_count()\n     }\n \n-    pub fn region_param(&self, param: &EarlyBoundRegion) -> &RegionParameterDef<'tcx> {\n+    pub fn region_param(&self, param: &EarlyBoundRegion) -> &RegionParameterDef {\n         &self.regions[param.index as usize - self.has_self as usize]\n     }\n \n@@ -1322,9 +1286,11 @@ bitflags! {\n         const IS_SIMD             = 1 << 4,\n         const IS_FUNDAMENTAL      = 1 << 5,\n         const IS_UNION            = 1 << 6,\n+        const IS_BOX              = 1 << 7,\n     }\n }\n \n+#[derive(Debug)]\n pub struct VariantDef {\n     /// The variant's DefId. If this is a tuple-like struct,\n     /// this is the DefId of the struct's ctor.\n@@ -1335,6 +1301,7 @@ pub struct VariantDef {\n     pub ctor_kind: CtorKind,\n }\n \n+#[derive(Debug)]\n pub struct FieldDef {\n     pub did: DefId,\n     pub name: Name,\n@@ -1394,6 +1361,9 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         if Some(did) == tcx.lang_items.phantom_data() {\n             flags = flags | AdtFlags::IS_PHANTOM_DATA;\n         }\n+        if Some(did) == tcx.lang_items.owned_box() {\n+            flags = flags | AdtFlags::IS_BOX;\n+        }\n         match kind {\n             AdtKind::Enum => flags = flags | AdtFlags::IS_ENUM,\n             AdtKind::Union => flags = flags | AdtFlags::IS_UNION,\n@@ -1486,9 +1456,15 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.get().intersects(AdtFlags::IS_PHANTOM_DATA)\n     }\n \n+    /// Returns true if this is Box<T>.\n+    #[inline]\n+    pub fn is_box(&self) -> bool {\n+        self.flags.get().intersects(AdtFlags::IS_BOX)\n+    }\n+\n     /// Returns whether this type has a destructor.\n     pub fn has_dtor(&self) -> bool {\n-        self.dtor_kind().is_present()\n+        self.destructor.get().is_some()\n     }\n \n     /// Asserts this is a struct and returns the struct's unique\n@@ -1551,13 +1527,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.destructor.set(Some(dtor));\n     }\n \n-    pub fn dtor_kind(&self) -> DtorKind {\n-        match self.destructor.get() {\n-            Some(_) => TraitDtor,\n-            None => NoDtor,\n-        }\n-    }\n-\n     /// Returns a simpler type such that `Self: Sized` if and only\n     /// if that type is Sized, or `TyErr` if this type is recursive.\n     ///\n@@ -1659,7 +1628,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                                -> Vec<Ty<'tcx>> {\n         let result = match ty.sty {\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n-            TyBox(..) | TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n+            TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n             TyArray(..) | TyClosure(..) | TyNever => {\n                 vec![]\n             }"}, {"sha": "bc30f1fb71722b31f3df73be54f2885e9dede316", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -167,7 +167,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::TyFloat(..) |       // OutlivesScalar\n             ty::TyNever |           // ...\n             ty::TyAdt(..) |         // OutlivesNominalType\n-            ty::TyBox(..) |         // OutlivesNominalType (ish)\n             ty::TyAnon(..) |        // OutlivesNominalType (ish)\n             ty::TyStr |             // OutlivesScalar (ish)\n             ty::TyArray(..) |       // ..."}, {"sha": "89514085e1c78601d1efd4582387df06ef1b4fff", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -418,12 +418,6 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_closure_from_closure_substs(a_id, substs))\n         }\n \n-        (&ty::TyBox(a_inner), &ty::TyBox(b_inner)) =>\n-        {\n-            let typ = relation.relate(&a_inner, &b_inner)?;\n-            Ok(tcx.mk_box(typ))\n-        }\n-\n         (&ty::TyRawPtr(ref a_mt), &ty::TyRawPtr(ref b_mt)) =>\n         {\n             let mt = relation.relate(a_mt, b_mt)?;"}, {"sha": "05f4abad469213f41347de0013a71ae28d3423ff", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 44, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -353,7 +353,7 @@ macro_rules! CopyImpls {\n     }\n }\n \n-CopyImpls! { (), hir::Unsafety, abi::Abi }\n+CopyImpls! { (), hir::Unsafety, abi::Abi, ty::RegionParameterDef }\n \n impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> (T, U) {\n@@ -468,7 +468,6 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<Ty<'tcx>> {\n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let sty = match self.sty {\n-            ty::TyBox(typ) => ty::TyBox(typ.fold_with(folder)),\n             ty::TyRawPtr(tm) => ty::TyRawPtr(tm.fold_with(folder)),\n             ty::TyArray(typ, sz) => ty::TyArray(typ.fold_with(folder), sz),\n             ty::TySlice(typ) => ty::TySlice(typ.fold_with(folder)),\n@@ -506,7 +505,6 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match self.sty {\n-            ty::TyBox(typ) => typ.visit_with(visitor),\n             ty::TyRawPtr(ref tm) => tm.visit_with(visitor),\n             ty::TyArray(typ, _sz) => typ.visit_with(visitor),\n             ty::TySlice(typ) => typ.visit_with(visitor),\n@@ -726,52 +724,12 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n             index: self.index,\n             default: self.default.fold_with(folder),\n             default_def_id: self.default_def_id,\n-            object_lifetime_default: self.object_lifetime_default.fold_with(folder),\n             pure_wrt_drop: self.pure_wrt_drop,\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.default.visit_with(visitor) ||\n-            self.object_lifetime_default.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            ty::ObjectLifetimeDefault::Ambiguous =>\n-                ty::ObjectLifetimeDefault::Ambiguous,\n-\n-            ty::ObjectLifetimeDefault::BaseDefault =>\n-                ty::ObjectLifetimeDefault::BaseDefault,\n-\n-            ty::ObjectLifetimeDefault::Specific(r) =>\n-                ty::ObjectLifetimeDefault::Specific(r.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            ty::ObjectLifetimeDefault::Specific(r) => r.visit_with(visitor),\n-            _ => false,\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::RegionParameterDef {\n-            name: self.name,\n-            def_id: self.def_id,\n-            index: self.index,\n-            bounds: self.bounds.fold_with(folder),\n-            pure_wrt_drop: self.pure_wrt_drop,\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.bounds.visit_with(visitor)\n+        self.default.visit_with(visitor)\n     }\n }\n "}, {"sha": "113534e4529cdc6c87c8855cbd11c366b392bd76", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -115,12 +115,6 @@ pub enum TypeVariants<'tcx> {\n     /// definition and not a concrete use of it.\n     TyAdt(&'tcx AdtDef, &'tcx Substs<'tcx>),\n \n-    /// `Box<T>`; this is nominally a struct in the documentation, but is\n-    /// special-cased internally. For example, it is possible to implicitly\n-    /// move the contents of a box out of that box, and methods of any type\n-    /// can have type `Box<Self>`.\n-    TyBox(Ty<'tcx>),\n-\n     /// The pointee of a string slice. Written as `str`.\n     TyStr,\n \n@@ -134,7 +128,7 @@ pub enum TypeVariants<'tcx> {\n     TyRawPtr(TypeAndMut<'tcx>),\n \n     /// A reference; a pointer with an associated lifetime. Written as\n-    /// `&a mut T` or `&'a T`.\n+    /// `&'a mut T` or `&'a T`.\n     TyRef(&'tcx Region, TypeAndMut<'tcx>),\n \n     /// The anonymous type of a function declaration/definition. Each\n@@ -1139,10 +1133,17 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn is_unique(&self) -> bool {\n+    pub fn is_box(&self) -> bool {\n         match self.sty {\n-            TyBox(_) => true,\n-            _ => false\n+            TyAdt(def, _) => def.is_box(),\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn boxed_ty(&self) -> Ty<'tcx> {\n+        match self.sty {\n+            TyAdt(def, substs) if def.is_box() => substs.type_at(0),\n+            _ => bug!(\"`boxed_ty` is called on non-box type {:?}\", self),\n         }\n     }\n \n@@ -1247,9 +1248,9 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         -> Option<TypeAndMut<'tcx>>\n     {\n         match self.sty {\n-            TyBox(ty) => {\n+            TyAdt(def, _) if def.is_box() => {\n                 Some(TypeAndMut {\n-                    ty: ty,\n+                    ty: self.boxed_ty(),\n                     mutbl: if pref == ty::PreferMutLvalue {\n                         hir::MutMutable\n                     } else {\n@@ -1349,7 +1350,6 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             TyInt(_) |\n             TyUint(_) |\n             TyFloat(_) |\n-            TyBox(_) |\n             TyStr |\n             TyArray(..) |\n             TySlice(_) |"}, {"sha": "ba49aa1ef4866b97c8ffc5c211130ae5775a99a2", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -481,7 +481,6 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n             TyBool |\n             TyChar |\n             TyStr |\n-            TyBox(_) |\n             TySlice(_) => {}\n \n             TyError |\n@@ -563,7 +562,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 mutbl: hir::MutImmutable, ..\n             }) => Some(false),\n \n-            TyStr | TyBox(..) | TyRef(_, TypeAndMut {\n+            TyStr | TyRef(_, TypeAndMut {\n                 mutbl: hir::MutMutable, ..\n             }) => Some(true),\n \n@@ -606,7 +605,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         // Fast-path for primitive types\n         let result = match self.sty {\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n-            TyBox(..) | TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n+            TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n             TyArray(..) | TyTuple(..) | TyClosure(..) | TyNever => Some(true),\n \n             TyStr | TyDynamic(..) | TySlice(_) => Some(false),"}, {"sha": "0d1dc2e4d7c218c8ed3dabc3dcafca6d176eef87", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -83,7 +83,7 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n         ty::TyStr | ty::TyInfer(_) | ty::TyParam(_) | ty::TyNever | ty::TyError => {\n         }\n-        ty::TyBox(ty) | ty::TyArray(ty, _) | ty::TySlice(ty) => {\n+        ty::TyArray(ty, _) | ty::TySlice(ty) => {\n             stack.push(ty);\n         }\n         ty::TyRawPtr(ref mt) | ty::TyRef(_, ref mt) => {"}, {"sha": "33b70b09dcb7b6d742ae1932e77079384fe574ae", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -323,7 +323,6 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                ty::TyBox(_) |\n                 ty::TyRawPtr(_) => {\n                     // simple cases that are WF if their type args are WF\n                 }"}, {"sha": "da04976a96a37234b4f1cfaf05af3b622ce865ab", "filename": "src/librustc/util/num.rs", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ecda7f314fa79bbfbf2125c99fd66288ca83c875/src%2Flibrustc%2Futil%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecda7f314fa79bbfbf2125c99fd66288ca83c875/src%2Flibrustc%2Futil%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnum.rs?ref=ecda7f314fa79bbfbf2125c99fd66288ca83c875", "patch": "@@ -1,98 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub trait ToPrimitive {\n-    fn to_i8(&self) -> Option<i8>;\n-    fn to_i16(&self) -> Option<i16>;\n-    fn to_i32(&self) -> Option<i32>;\n-    fn to_i64(&self) -> Option<i64>;\n-    fn to_u8(&self) -> Option<u8>;\n-    fn to_u16(&self) -> Option<u16>;\n-    fn to_u32(&self) -> Option<u32>;\n-    fn to_u64(&self) -> Option<u64>;\n-}\n-\n-impl ToPrimitive for i64 {\n-    fn to_i8(&self) -> Option<i8> {\n-        if *self < i8::min_value() as i64 || *self > i8::max_value() as i64 {\n-            None\n-        } else {\n-            Some(*self as i8)\n-        }\n-    }\n-    fn to_i16(&self) -> Option<i16> {\n-        if *self < i16::min_value() as i64 || *self > i16::max_value() as i64 {\n-            None\n-        } else {\n-            Some(*self as i16)\n-        }\n-    }\n-    fn to_i32(&self) -> Option<i32> {\n-        if *self < i32::min_value() as i64 || *self > i32::max_value() as i64 {\n-            None\n-        } else {\n-            Some(*self as i32)\n-        }\n-    }\n-    fn to_i64(&self) -> Option<i64> {\n-        Some(*self)\n-    }\n-    fn to_u8(&self) -> Option<u8> {\n-        if *self < 0 || *self > u8::max_value() as i64 {\n-            None\n-        } else {\n-            Some(*self as u8)\n-        }\n-    }\n-    fn to_u16(&self) -> Option<u16> {\n-        if *self < 0 || *self > u16::max_value() as i64 {\n-            None\n-        } else {\n-            Some(*self as u16)\n-        }\n-    }\n-    fn to_u32(&self) -> Option<u32> {\n-        if *self < 0 || *self > u32::max_value() as i64 {\n-            None\n-        } else {\n-            Some(*self as u32)\n-        }\n-    }\n-    fn to_u64(&self) -> Option<u64> {\n-        if *self < 0 {None} else {Some(*self as u64)}\n-    }\n-}\n-\n-impl ToPrimitive for u64 {\n-    fn to_i8(&self) -> Option<i8> {\n-        if *self > i8::max_value() as u64 {None} else {Some(*self as i8)}\n-    }\n-    fn to_i16(&self) -> Option<i16> {\n-        if *self > i16::max_value() as u64 {None} else {Some(*self as i16)}\n-    }\n-    fn to_i32(&self) -> Option<i32> {\n-        if *self > i32::max_value() as u64 {None} else {Some(*self as i32)}\n-    }\n-    fn to_i64(&self) -> Option<i64> {\n-        if *self > i64::max_value() as u64 {None} else {Some(*self as i64)}\n-    }\n-    fn to_u8(&self) -> Option<u8> {\n-        if *self > u8::max_value() as u64 {None} else {Some(*self as u8)}\n-    }\n-    fn to_u16(&self) -> Option<u16> {\n-        if *self > u16::max_value() as u64 {None} else {Some(*self as u16)}\n-    }\n-    fn to_u32(&self) -> Option<u32> {\n-        if *self > u32::max_value() as u64 {None} else {Some(*self as u32)}\n-    }\n-    fn to_u64(&self) -> Option<u64> {\n-        Some(*self)\n-    }\n-}"}, {"sha": "aa2eb2955debe69cbd278e39cb3b7319de362c7e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -16,7 +16,7 @@ use ty::{TyBool, TyChar, TyAdt};\n use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n use ty::{TyClosure, TyProjection, TyAnon};\n-use ty::{TyBox, TyDynamic, TyInt, TyUint, TyInfer};\n+use ty::{TyDynamic, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use std::cell::Cell;\n@@ -336,13 +336,12 @@ impl<'tcx> fmt::Debug for ty::TypeParameterDef<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::RegionParameterDef<'tcx> {\n+impl fmt::Debug for ty::RegionParameterDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionParameterDef({}, {:?}, {}, {:?})\",\n+        write!(f, \"RegionParameterDef({}, {:?}, {})\",\n                self.name,\n                self.def_id,\n-               self.index,\n-               self.bounds)\n+               self.index)\n     }\n }\n \n@@ -523,16 +522,6 @@ impl<'tcx> fmt::Debug for ty::ParameterEnvironment<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ObjectLifetimeDefault<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::ObjectLifetimeDefault::Ambiguous => write!(f, \"Ambiguous\"),\n-            ty::ObjectLifetimeDefault::BaseDefault => write!(f, \"BaseDefault\"),\n-            ty::ObjectLifetimeDefault::Specific(ref r) => write!(f, \"{:?}\", r),\n-        }\n-    }\n-}\n-\n impl fmt::Display for ty::Region {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {\n@@ -719,7 +708,6 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyInt(t) => write!(f, \"{}\", t.ty_to_string()),\n             TyUint(t) => write!(f, \"{}\", t.ty_to_string()),\n             TyFloat(t) => write!(f, \"{}\", t.ty_to_string()),\n-            TyBox(typ) => write!(f, \"Box<{}>\",  typ),\n             TyRawPtr(ref tm) => {\n                 write!(f, \"*{} {}\", match tm.mutbl {\n                     hir::MutMutable => \"mut\","}, {"sha": "29477261392079332e3e03ed3ba4b13c3fa3c992", "filename": "src/librustc_back/target/i686_pc_windows_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -14,6 +14,7 @@ pub fn target() -> TargetResult {\n     let mut base = super::windows_base::opts();\n     base.cpu = \"pentium4\".to_string();\n     base.max_atomic_width = Some(64);\n+    base.eliminate_frame_pointer = false; // Required for backtraces\n \n     // Mark all dynamic libraries and executables as compatible with the larger 4GiB address\n     // space available to x86 Windows binaries on x86_64."}, {"sha": "1783ca74a25923fdf4fcad56f6b5a29c75e93788", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -195,15 +195,17 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             bccx.report_aliasability_violation(\n                         borrow_span,\n                         loan_cause,\n-                        mc::AliasableReason::UnaliasableImmutable);\n+                        mc::AliasableReason::UnaliasableImmutable,\n+                        cmt);\n             Err(())\n         }\n         (mc::Aliasability::FreelyAliasable(alias_cause), ty::UniqueImmBorrow) |\n         (mc::Aliasability::FreelyAliasable(alias_cause), ty::MutBorrow) => {\n             bccx.report_aliasability_violation(\n                         borrow_span,\n                         loan_cause,\n-                        alias_cause);\n+                        alias_cause,\n+                        cmt);\n             Err(())\n         }\n         (..) => {"}, {"sha": "9e89a3689c7acd23c7894a16270052336813d430", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -709,18 +709,18 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn open_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n         let ty = c.lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n         match ty.sty {\n-            ty::TyAdt(def, substs) => {\n-                self.open_drop_for_adt(c, def, substs)\n-            }\n             ty::TyClosure(def_id, substs) => {\n                 let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx).collect();\n                 self.open_drop_for_tuple(c, &tys)\n             }\n             ty::TyTuple(tys) => {\n                 self.open_drop_for_tuple(c, tys)\n             }\n-            ty::TyBox(ty) => {\n-                self.open_drop_for_box(c, ty)\n+            ty::TyAdt(def, _) if def.is_box() => {\n+                self.open_drop_for_box(c, ty.boxed_ty())\n+            }\n+            ty::TyAdt(def, substs) => {\n+                self.open_drop_for_adt(c, def, substs)\n             }\n             _ => bug!(\"open drop from non-ADT `{:?}`\", ty)\n         }\n@@ -895,7 +895,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n         match ty.sty {\n             ty::TyAdt(def, _) => {\n-                if def.has_dtor() {\n+                if def.has_dtor() && !def.is_box() {\n                     self.tcx.sess.span_warn(\n                         c.source_info.span,\n                         &format!(\"dataflow bug??? moving out of type with dtor {:?}\","}, {"sha": "7cf6ab2999c05df88e809b115ae301d691dcb0c1", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -289,7 +289,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             // error: can't move out of borrowed content\n             ty::TyRef(..) | ty::TyRawPtr(..) => return Err(MovePathError::IllegalMove),\n             // error: can't move out of struct with destructor\n-            ty::TyAdt(adt, _) if adt.has_dtor() =>\n+            ty::TyAdt(adt, _) if adt.has_dtor() && !adt.is_box() =>\n                 return Err(MovePathError::IllegalMove),\n             // move out of union - always move the entire union\n             ty::TyAdt(adt, _) if adt.is_union() =>"}, {"sha": "a0c36139ddcd2ec8c8eac363f737b58e0577ac9f", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -248,7 +248,7 @@ fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                    lv, ty);\n             true\n         }\n-        ty::TyAdt(def, _) if def.has_dtor() || def.is_union() => {\n+        ty::TyAdt(def, _) if (def.has_dtor() && !def.is_box()) || def.is_union() => {\n             debug!(\"lvalue_contents_drop_state_cannot_differ lv: {:?} ty: {:?} Drop => true\",\n                    lv, ty);\n             true"}, {"sha": "46179b31d5cb45bc2c212baad7a898355109e9e0", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 92, "deletions": 48, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -540,7 +540,7 @@ pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n // Errors\n \n // Errors that can occur\n-#[derive(PartialEq)]\n+#[derive(Debug, PartialEq)]\n pub enum bckerr_code<'tcx> {\n     err_mutbl,\n     /// superscope, subscope, loan cause\n@@ -550,7 +550,7 @@ pub enum bckerr_code<'tcx> {\n \n // Combination of an error code and the categorization of the expression\n // that caused it\n-#[derive(PartialEq)]\n+#[derive(Debug, PartialEq)]\n pub struct BckError<'tcx> {\n     span: Span,\n     cause: AliasableViolationKind,\n@@ -601,12 +601,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             _ => { }\n         }\n \n-        // General fallback.\n-        let span = err.span.clone();\n-        let mut db = self.struct_span_err(\n-            err.span,\n-            &self.bckerr_to_string(&err));\n-        self.note_and_explain_bckerr(&mut db, err, span);\n+        let mut db = self.bckerr_to_diag(&err);\n+        self.note_and_explain_bckerr(&mut db, err);\n         db.emit();\n     }\n \n@@ -771,8 +767,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err_with_code(s, msg, code);\n     }\n \n-    pub fn bckerr_to_string(&self, err: &BckError<'tcx>) -> String {\n-        match err.code {\n+    pub fn bckerr_to_diag(&self, err: &BckError<'tcx>) -> DiagnosticBuilder<'a> {\n+        let span = err.span.clone();\n+        let mut immutable_field = None;\n+\n+        let msg = &match err.code {\n             err_mutbl => {\n                 let descr = match err.cmt.note {\n                     mc::NoteClosureEnv(_) | mc::NoteUpvarRef(_) => {\n@@ -783,6 +782,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             format!(\"{} {}\",\n                                     err.cmt.mutbl.to_user_str(),\n                                     self.cmt_to_string(&err.cmt))\n+\n                         }\n                         Some(lp) => {\n                             format!(\"{} {} `{}`\",\n@@ -807,6 +807,19 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     BorrowViolation(euv::AutoUnsafe) |\n                     BorrowViolation(euv::ForLoop) |\n                     BorrowViolation(euv::MatchDiscriminant) => {\n+                        // Check for this field's definition to see if it is an immutable reference\n+                        // and suggest making it mutable if that is the case.\n+                        immutable_field = err.cmt.get_field_name()\n+                            .and_then(|name| err.cmt.get_field(name))\n+                            .and_then(|did| self.tcx.hir.as_local_node_id(did))\n+                            .and_then(|nid| {\n+                                if let hir_map::Node::NodeField(ref field) = self.tcx.hir.get(nid) {\n+                                    return self.suggest_mut_for_immutable(&field.ty)\n+                                        .map(|msg| (self.tcx.hir.span(nid), msg));\n+                                }\n+                                None\n+                            });\n+\n                         format!(\"cannot borrow {} as mutable\", descr)\n                     }\n                     BorrowViolation(euv::ClosureInvocation) => {\n@@ -830,13 +843,20 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                          its contents can be safely reborrowed\",\n                         descr)\n             }\n+        };\n+\n+        let mut db = self.struct_span_err(span, msg);\n+        if let Some((span, msg)) = immutable_field {\n+            db.span_label(span, &msg);\n         }\n+        db\n     }\n \n     pub fn report_aliasability_violation(&self,\n                                          span: Span,\n                                          kind: AliasableViolationKind,\n-                                         cause: mc::AliasableReason) {\n+                                         cause: mc::AliasableReason,\n+                                         cmt: mc::cmt<'tcx>) {\n         let mut is_closure = false;\n         let prefix = match kind {\n             MutabilityViolation => {\n@@ -903,6 +923,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     self.tcx.sess, span, E0389,\n                     \"{} in a `&` reference\", prefix);\n                 e.span_label(span, &\"assignment into an immutable reference\");\n+                if let Some(nid) = cmt.get_arg_if_immutable(&self.tcx.hir) {\n+                    self.immutable_argument_should_be_mut(nid, &mut e);\n+                }\n                 e\n             }\n         };\n@@ -913,6 +936,55 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n+    /// Given a type, if it is an immutable reference, return a suggestion to make it mutable\n+    fn suggest_mut_for_immutable(&self, pty: &hir::Ty) -> Option<String> {\n+        // Check wether the argument is an immutable reference\n+        if let hir::TyRptr(lifetime, hir::MutTy {\n+            mutbl: hir::Mutability::MutImmutable,\n+            ref ty\n+        }) = pty.node {\n+            // Account for existing lifetimes when generating the message\n+            if !lifetime.is_elided() {\n+                if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(ty.span) {\n+                    if let Ok(lifetime_snippet) = self.tcx.sess.codemap()\n+                        .span_to_snippet(lifetime.span) {\n+                            return Some(format!(\"use `&{} mut {}` here to make mutable\",\n+                                                lifetime_snippet,\n+                                                snippet));\n+                    }\n+                }\n+            } else if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(pty.span) {\n+                if snippet.starts_with(\"&\") {\n+                    return Some(format!(\"use `{}` here to make mutable\",\n+                                        snippet.replace(\"&\", \"&mut \")));\n+                }\n+            } else {\n+                bug!(\"couldn't find a snippet for span: {:?}\", pty.span);\n+            }\n+        }\n+        None\n+    }\n+\n+    fn immutable_argument_should_be_mut(&self, nid: ast::NodeId, db: &mut DiagnosticBuilder) {\n+        let parent = self.tcx.hir.get_parent_node(nid);\n+        let parent_node = self.tcx.hir.get(parent);\n+\n+        // The parent node is like a fn\n+        if let Some(fn_like) = FnLikeNode::from_node(parent_node) {\n+            // `nid`'s parent's `Body`\n+            let fn_body = self.tcx.hir.body(fn_like.body());\n+            // Get the position of `nid` in the arguments list\n+            let arg_pos = fn_body.arguments.iter().position(|arg| arg.pat.id == nid);\n+            if let Some(i) = arg_pos {\n+                // The argument's `Ty`\n+                let arg_ty = &fn_like.decl().inputs[i];\n+                if let Some(msg) = self.suggest_mut_for_immutable(&arg_ty) {\n+                    db.span_label(arg_ty.span, &msg);\n+                }\n+            }\n+        }\n+    }\n+\n     fn report_out_of_scope_escaping_closure_capture(&self,\n                                                     err: &BckError<'tcx>,\n                                                     capture_span: Span)\n@@ -961,8 +1033,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn note_and_explain_bckerr(&self, db: &mut DiagnosticBuilder, err: BckError<'tcx>,\n-        error_span: Span) {\n+    pub fn note_and_explain_bckerr(&self, db: &mut DiagnosticBuilder, err: BckError<'tcx>) {\n+        let error_span = err.span.clone();\n         match err.code {\n             err_mutbl => self.note_and_explain_mutbl_error(db, &err, &error_span),\n             err_out_of_scope(super_scope, sub_scope, cause) => {\n@@ -1114,41 +1186,13 @@ before rustc 1.16, this temporary lived longer - see issue #39283 \\\n                 }\n             }\n             _ => {\n-                if let Categorization::Deref(ref inner_cmt, ..) = err.cmt.cat {\n-                    if let Categorization::Local(local_id) = inner_cmt.cat {\n-                        let parent = self.tcx.hir.get_parent_node(local_id);\n-\n-                        if let Some(fn_like) = FnLikeNode::from_node(self.tcx.hir.get(parent)) {\n-                            if let Some(i) = self.tcx.hir.body(fn_like.body()).arguments.iter()\n-                                                     .position(|arg| arg.pat.id == local_id) {\n-                                let arg_ty = &fn_like.decl().inputs[i];\n-                                if let hir::TyRptr(\n-                                    opt_lifetime,\n-                                    hir::MutTy{mutbl: hir::Mutability::MutImmutable, ref ty}) =\n-                                    arg_ty.node {\n-                                    if let Some(lifetime) = opt_lifetime {\n-                                        if let Ok(snippet) = self.tcx.sess.codemap()\n-                                            .span_to_snippet(ty.span) {\n-                                            if let Ok(lifetime_snippet) = self.tcx.sess.codemap()\n-                                                .span_to_snippet(lifetime.span) {\n-                                                    db.span_label(arg_ty.span,\n-                                                                  &format!(\"use `&{} mut {}` \\\n-                                                                            here to make mutable\",\n-                                                                            lifetime_snippet,\n-                                                                            snippet));\n-                                            }\n-                                        }\n-                                    }\n-                                    else if let Ok(snippet) = self.tcx.sess.codemap()\n-                                        .span_to_snippet(arg_ty.span) {\n-                                        if snippet.starts_with(\"&\") {\n-                                            db.span_label(arg_ty.span,\n-                                                          &format!(\"use `{}` here to make mutable\",\n-                                                                   snippet.replace(\"&\", \"&mut \")));\n-                                        }\n-                                    }\n-                                }\n-                            }\n+                if let Categorization::Deref(..) = err.cmt.cat {\n+                    db.span_label(*error_span, &\"cannot borrow as mutable\");\n+                    if let Some(local_id) = err.cmt.get_arg_if_immutable(&self.tcx.hir) {\n+                        self.immutable_argument_should_be_mut(local_id, db);\n+                    } else if let Categorization::Deref(ref inner_cmt, ..) = err.cmt.cat {\n+                        if let Categorization::Local(local_id) = inner_cmt.cat {\n+                            self.immutable_argument_should_be_mut(local_id, db);\n                         }\n                     }\n                 } else if let Categorization::Local(local_id) = err.cmt.cat {"}, {"sha": "94b2ba58c9aa539c776df5978597f95658365b93", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -379,19 +379,24 @@ impl<'tcx> Witness<'tcx> {\n fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                   pcx: PatternContext<'tcx>) -> Vec<Constructor>\n {\n+    let check_inhabited = cx.tcx.sess.features.borrow().never_type;\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     match pcx.ty.sty {\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n         ty::TySlice(ref sub_ty) => {\n-            if sub_ty.is_uninhabited_from(cx.module, cx.tcx) {\n+            if sub_ty.is_uninhabited_from(cx.module, cx.tcx)\n+                && check_inhabited\n+            {\n                 vec![Slice(0)]\n             } else {\n                 (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n             }\n         }\n         ty::TyArray(ref sub_ty, length) => {\n-            if length == 0 || !sub_ty.is_uninhabited_from(cx.module, cx.tcx) {\n+            if length == 0 || !(sub_ty.is_uninhabited_from(cx.module, cx.tcx)\n+                                && check_inhabited)\n+            {\n                 vec![Slice(length)]\n             } else {\n                 vec![]\n@@ -403,15 +408,19 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 let forest = v.uninhabited_from(&mut visited,\n                                                 cx.tcx, substs,\n                                                 AdtKind::Enum);\n-                if forest.contains(cx.tcx, cx.module) {\n+                if forest.contains(cx.tcx, cx.module)\n+                    && check_inhabited\n+                {\n                     None\n                 } else {\n                     Some(Variant(v.did))\n                 }\n             }).collect()\n         }\n         _ => {\n-            if pcx.ty.is_uninhabited_from(cx.module, cx.tcx) {\n+            if pcx.ty.is_uninhabited_from(cx.module, cx.tcx)\n+                    && check_inhabited\n+            {\n                 vec![]\n             } else {\n                 vec![Single]\n@@ -713,7 +722,6 @@ fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize\n     debug!(\"constructor_arity({:?}, {:?})\", ctor, ty);\n     match ty.sty {\n         ty::TyTuple(ref fs) => fs.len(),\n-        ty::TyBox(_) => 1,\n         ty::TySlice(..) | ty::TyArray(..) => match *ctor {\n             Slice(length) => length,\n             ConstantValue(_) => 0,\n@@ -738,7 +746,6 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     debug!(\"constructor_sub_pattern_tys({:?}, {:?})\", ctor, ty);\n     match ty.sty {\n         ty::TyTuple(ref fs) => fs.into_iter().map(|t| *t).collect(),\n-        ty::TyBox(ty) => vec![ty],\n         ty::TySlice(ty) | ty::TyArray(ty, _) => match *ctor {\n             Slice(length) => repeat(ty).take(length).collect(),\n             ConstantValue(_) => vec![],"}, {"sha": "47a98155fc4b026a425a37fd0a1f9805140b83a7", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//#![allow(non_camel_case_types)]\n-\n use rustc::middle::const_val::ConstVal::*;\n use rustc::middle::const_val::ConstVal;\n use self::ErrKind::*;"}, {"sha": "c6272613f4d09fd3695222e4523e40dde99e6f37", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -215,7 +215,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n             }\n             PatternKind::Deref { ref subpattern } => {\n                 match self.ty.sty {\n-                    ty::TyBox(_) => write!(f, \"box \")?,\n+                    ty::TyAdt(def, _) if def.is_box() => write!(f, \"box \")?,\n                     ty::TyRef(_, mt) => {\n                         write!(f, \"&\")?;\n                         if mt.mutbl == hir::MutMutable {"}, {"sha": "d4bd9e707fdcb9780a618a6ba30151061b479109", "filename": "src/librustc_data_structures/accumulate_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Faccumulate_vec.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -25,7 +25,7 @@ use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n \n use array_vec::{self, Array, ArrayVec};\n \n-#[derive(PartialEq, Eq, Hash, Debug)]\n+#[derive(Hash, Debug)]\n pub enum AccumulateVec<A: Array> {\n     Array(ArrayVec<A>),\n     Heap(Vec<A::Element>)"}, {"sha": "51e6e09ab5003fc212ddcee8189576bf8296b777", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -52,14 +52,6 @@ impl<A> Hash for ArrayVec<A>\n     }\n }\n \n-impl<A: Array> PartialEq for ArrayVec<A> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self == other\n-    }\n-}\n-\n-impl<A: Array> Eq for ArrayVec<A> {}\n-\n impl<A> Clone for ArrayVec<A>\n     where A: Array,\n           A::Element: Clone {"}, {"sha": "a04a5b106b8f1e3546549ffbff5890ad2a9f669e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -741,15 +741,15 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n          \"checking for inline asm in case the target doesn't support it\",\n          || no_asm::check_crate(sess, &krate));\n \n-    time(sess.time_passes(),\n+    time(time_passes,\n          \"early lint checks\",\n          || lint::check_ast_crate(sess, &krate));\n \n-    time(sess.time_passes(),\n+    time(time_passes,\n          \"AST validation\",\n          || ast_validation::check_crate(sess, &krate));\n \n-    time(sess.time_passes(), \"name resolution\", || -> CompileResult {\n+    time(time_passes, \"name resolution\", || -> CompileResult {\n         // Since import resolution will eventually happen in expansion,\n         // don't perform `after_expand` until after import resolution.\n         after_expand(&krate)?;\n@@ -770,7 +770,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n     })?;\n \n     // Lower ast -> hir.\n-    let hir_forest = time(sess.time_passes(), \"lowering ast -> hir\", || {\n+    let hir_forest = time(time_passes, \"lowering ast -> hir\", || {\n         let hir_crate = lower_crate(sess, &krate, &mut resolver);\n \n         if sess.opts.debugging_opts.hir_stats {\n@@ -780,7 +780,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         hir_map::Forest::new(hir_crate, &sess.dep_graph)\n     });\n \n-    // Discard hygiene data, which isn't required past lowering to HIR.\n+    // Discard hygiene data, which isn't required after lowering to HIR.\n     if !keep_hygiene_data(sess) {\n         syntax::ext::hygiene::reset_hygiene_data();\n     }"}, {"sha": "1086d75f02cb4055c030b85c0077eb55fb349804", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -805,10 +805,9 @@ fn walk_ty() {\n         let uint_ty = tcx.types.usize;\n         let tup1_ty = tcx.intern_tup(&[int_ty, uint_ty, int_ty, uint_ty]);\n         let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, uint_ty]);\n-        let uniq_ty = tcx.mk_box(tup2_ty);\n-        let walked: Vec<_> = uniq_ty.walk().collect();\n+        let walked: Vec<_> = tup2_ty.walk().collect();\n         assert_eq!(walked,\n-                   [uniq_ty, tup2_ty, tup1_ty, int_ty, uint_ty, int_ty, uint_ty, tup1_ty, int_ty,\n+                   [tup2_ty, tup1_ty, int_ty, uint_ty, int_ty, uint_ty, tup1_ty, int_ty,\n                     uint_ty, int_ty, uint_ty, uint_ty]);\n     })\n }\n@@ -821,12 +820,10 @@ fn walk_ty_skip_subtree() {\n         let uint_ty = tcx.types.usize;\n         let tup1_ty = tcx.intern_tup(&[int_ty, uint_ty, int_ty, uint_ty]);\n         let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, uint_ty]);\n-        let uniq_ty = tcx.mk_box(tup2_ty);\n \n         // types we expect to see (in order), plus a boolean saying\n         // whether to skip the subtree.\n-        let mut expected = vec![(uniq_ty, false),\n-                                (tup2_ty, false),\n+        let mut expected = vec![(tup2_ty, false),\n                                 (tup1_ty, false),\n                                 (int_ty, false),\n                                 (uint_ty, false),\n@@ -836,7 +833,7 @@ fn walk_ty_skip_subtree() {\n                                 (uint_ty, false)];\n         expected.reverse();\n \n-        let mut walker = uniq_ty.walk();\n+        let mut walker = tup2_ty.walk();\n         while let Some(t) = walker.next() {\n             debug!(\"walked to {:?}\", t);\n             let (expected_ty, skip) = expected.pop().unwrap();"}, {"sha": "c7512f2971b33990269ddf68a317f637b6b45eb4", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -828,7 +828,7 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         visit::walk_ty_param_bound(self, bounds)\n     }\n \n-    fn visit_poly_trait_ref(&mut self, t: &'tcx PolyTraitRef, m: &'tcx TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, t: &'tcx PolyTraitRef, m: TraitBoundModifier) {\n         debug!(\"visit_poly_trait_ref: st={:?}\", self.st);\n         SawPolyTraitRef.hash(self.st);\n         m.hash(self.st);"}, {"sha": "3daeacfe87d8211ffc709546ee67ad80329e0337", "filename": "src/librustc_incremental/persist/preds.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -33,8 +33,12 @@ pub struct Predecessors<'query> {\n \n impl<'q> Predecessors<'q> {\n     pub fn new(query: &'q DepGraphQuery<DefId>, hcx: &mut HashContext) -> Self {\n-        // Find nodes for which we want to know the full set of preds\n         let tcx = hcx.tcx;\n+\n+        let collect_for_metadata = tcx.sess.opts.debugging_opts.incremental_cc ||\n+                                   tcx.sess.opts.debugging_opts.query_dep_graph;\n+\n+        // Find nodes for which we want to know the full set of preds\n         let node_count = query.graph.len_nodes();\n \n         // Set up some data structures the cache predecessor search needs:\n@@ -52,7 +56,7 @@ impl<'q> Predecessors<'q> {\n             .enumerate()\n             .filter(|&(_, node)| match node.data {\n                 DepNode::WorkProduct(_) => true,\n-                DepNode::MetaData(ref def_id) => def_id.is_local(),\n+                DepNode::MetaData(ref def_id) => collect_for_metadata && def_id.is_local(),\n \n                 // if -Z query-dep-graph is passed, save more extended data\n                 // to enable better unit testing"}, {"sha": "f626905f27d4a1d5ff2f9333e04a126861dedbb5", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -55,17 +55,21 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let preds = Predecessors::new(&query, &mut hcx);\n     let mut current_metadata_hashes = FxHashMap();\n \n-    // IMPORTANT: We are saving the metadata hashes *before* the dep-graph,\n-    //            since metadata-encoding might add new entries to the\n-    //            DefIdDirectory (which is saved in the dep-graph file).\n-    save_in(sess,\n-            metadata_hash_export_path(sess),\n-            |e| encode_metadata_hashes(tcx,\n-                                       svh,\n-                                       &preds,\n-                                       &mut builder,\n-                                       &mut current_metadata_hashes,\n-                                       e));\n+    if sess.opts.debugging_opts.incremental_cc ||\n+       sess.opts.debugging_opts.query_dep_graph {\n+        // IMPORTANT: We are saving the metadata hashes *before* the dep-graph,\n+        //            since metadata-encoding might add new entries to the\n+        //            DefIdDirectory (which is saved in the dep-graph file).\n+        save_in(sess,\n+                metadata_hash_export_path(sess),\n+                |e| encode_metadata_hashes(tcx,\n+                                           svh,\n+                                           &preds,\n+                                           &mut builder,\n+                                           &mut current_metadata_hashes,\n+                                           e));\n+    }\n+\n     save_in(sess,\n             dep_graph_path(sess),\n             |e| encode_dep_graph(&preds, &mut builder, e));"}, {"sha": "05ba262ef90c08eae406ba8ebe6f3b6642cb3afc", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -377,8 +377,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.node {\n-            if path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n-                if let Def::Const(..) = path.def {\n+            if let Def::Const(..) = path.def {\n+                if path.segments.len() == 1 {\n                     NonUpperCaseGlobals::check_upper_case(cx,\n                                                           \"constant in pattern\",\n                                                           path.segments[0].name,"}, {"sha": "1592d178176413622851fd0ce664e4863fde72e7", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -95,7 +95,7 @@ pub struct BoxPointers;\n impl BoxPointers {\n     fn check_heap_type<'a, 'tcx>(&self, cx: &LateContext, span: Span, ty: Ty) {\n         for leaf_ty in ty.walk() {\n-            if let ty::TyBox(_) = leaf_ty.sty {\n+            if leaf_ty.is_box() {\n                 let m = format!(\"type uses owned (Box type) pointers: {}\", ty);\n                 cx.span_lint(BOX_POINTERS, span, &m);\n             }"}, {"sha": "18067cb86739b51cd0787c63973d8455cc183d92", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -240,6 +240,10 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(LEGACY_IMPORTS),\n             reference: \"issue #38260 <https://github.com/rust-lang/rust/issues/38260>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(LEGACY_CONSTRUCTOR_VISIBILITY),\n+            reference: \"issue #39207 <https://github.com/rust-lang/rust/issues/39207>\",\n+        },\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "9669efa2d86b3954250d944ad213dadfb30ce37e", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -519,11 +519,6 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             // Primitive types with a stable representation.\n             ty::TyBool | ty::TyInt(..) | ty::TyUint(..) | ty::TyFloat(..) | ty::TyNever => FfiSafe,\n \n-            ty::TyBox(..) => {\n-                FfiUnsafe(\"found Rust type Box<_> in foreign module, \\\n-                           consider using a raw pointer instead\")\n-            }\n-\n             ty::TySlice(_) => {\n                 FfiUnsafe(\"found Rust slice type in foreign module, \\\n                            consider using a raw pointer instead\")"}, {"sha": "58b2017ceb66e8a7dd562e7369ca72578f63feba", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -804,7 +804,7 @@ extern \"C\" {\n                                     Name: *const c_char)\n                                     -> ValueRef;\n     pub fn LLVMRustAddHandler(CatchSwitch: ValueRef, Handler: BasicBlockRef);\n-    pub fn LLVMRustSetPersonalityFn(B: BuilderRef, Pers: ValueRef);\n+    pub fn LLVMSetPersonalityFn(Func: ValueRef, Pers: ValueRef);\n \n     // Add a case to the switch instruction\n     pub fn LLVMAddCase(Switch: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef);"}, {"sha": "39581a46960887069faecd871888335f49a89c95", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -17,6 +17,7 @@ use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind, ExternC\n use rustc::middle::cstore::{NativeLibrary, LinkMeta, LinkagePreference, LoadedMacro};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n+use rustc::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -110,6 +111,17 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).get_generics(def.index, tcx)\n     }\n \n+    fn item_generics_own_param_counts(&self, def: DefId) -> (usize, usize) {\n+        self.dep_graph.read(DepNode::MetaData(def));\n+        self.get_crate_data(def.krate).generics_own_param_counts(def.index)\n+    }\n+\n+    fn item_generics_object_lifetime_defaults(&self, def: DefId)\n+                                              -> Vec<ObjectLifetimeDefault> {\n+        self.dep_graph.read(DepNode::MetaData(def));\n+        self.get_crate_data(def.krate).generics_object_lifetime_defaults(def.index)\n+    }\n+\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>\n     {\n         self.dep_graph.read(DepNode::MetaData(def_id));"}, {"sha": "dd44ef202dc2733bcf7185dae4a2dd968c7f4dd2", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -20,6 +20,7 @@ use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::middle::lang_items;\n+use rustc::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n@@ -598,7 +599,26 @@ impl<'a, 'tcx> CrateMetadata {\n                         item_id: DefIndex,\n                         tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                         -> ty::Generics<'tcx> {\n-        self.entry(item_id).generics.unwrap().decode((self, tcx))\n+        let g = self.entry(item_id).generics.unwrap().decode(self);\n+        ty::Generics {\n+            parent: g.parent,\n+            parent_regions: g.parent_regions,\n+            parent_types: g.parent_types,\n+            regions: g.regions.decode((self, tcx)).collect(),\n+            types: g.types.decode((self, tcx)).collect(),\n+            has_self: g.has_self,\n+        }\n+    }\n+\n+    pub fn generics_own_param_counts(&self, item_id: DefIndex) -> (usize, usize) {\n+        let g = self.entry(item_id).generics.unwrap().decode(self);\n+        (g.regions.len, g.types.len)\n+    }\n+\n+    pub fn generics_object_lifetime_defaults(&self, item_id: DefIndex)\n+                                             -> Vec<ObjectLifetimeDefault> {\n+        self.entry(item_id).generics.unwrap().decode(self)\n+                           .object_lifetime_defaults.decode(self).collect()\n     }\n \n     pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {"}, {"sha": "b9c2f0622b6988e70ff1fc5bd0c121948bd3352d", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -396,10 +396,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let struct_id = tcx.hir.as_local_node_id(adt_def_id).unwrap();\n         let struct_vis = &tcx.hir.expect_item(struct_id).vis;\n+        let mut ctor_vis = ty::Visibility::from_hir(struct_vis, struct_id, tcx);\n+        for field in &variant.fields {\n+            if ctor_vis.is_at_least(field.vis, tcx) {\n+                ctor_vis = field.vis;\n+            }\n+        }\n \n         Entry {\n             kind: EntryKind::Struct(self.lazy(&data)),\n-            visibility: self.lazy(&ty::Visibility::from_hir(struct_vis, struct_id, tcx)),\n+            visibility: self.lazy(&ctor_vis),\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: LazySeq::empty(),\n             children: LazySeq::empty(),\n@@ -417,9 +423,26 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics<'tcx>> {\n+    fn encode_generics(&mut self, def_id: DefId) -> Lazy<Generics<'tcx>> {\n         let tcx = self.tcx;\n-        self.lazy(tcx.item_generics(def_id))\n+        let g = tcx.item_generics(def_id);\n+        let regions = self.lazy_seq_ref(&g.regions);\n+        let types = self.lazy_seq_ref(&g.types);\n+        let mut object_lifetime_defaults = LazySeq::empty();\n+        if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n+            if let Some(o) = tcx.named_region_map.object_lifetime_defaults.get(&id) {\n+                object_lifetime_defaults = self.lazy_seq_ref(o);\n+            }\n+        }\n+        self.lazy(&Generics {\n+            parent: g.parent,\n+            parent_regions: g.parent_regions,\n+            parent_types: g.parent_types,\n+            regions: regions,\n+            types: types,\n+            has_self: g.has_self,\n+            object_lifetime_defaults: object_lifetime_defaults,\n+        })\n     }\n \n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {"}, {"sha": "d9c639f2bc573dbc4d853e32b62d8c27fb165730", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -16,6 +16,7 @@ use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId};\n use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n use rustc::middle::lang_items;\n+use rustc::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc_back::PanicStrategy;\n@@ -213,7 +214,7 @@ pub struct Entry<'tcx> {\n     pub ty: Option<Lazy<Ty<'tcx>>>,\n     pub inherent_impls: LazySeq<DefIndex>,\n     pub variances: LazySeq<ty::Variance>,\n-    pub generics: Option<Lazy<ty::Generics<'tcx>>>,\n+    pub generics: Option<Lazy<Generics<'tcx>>>,\n     pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n \n     pub ast: Option<Lazy<astencode::Ast<'tcx>>>,\n@@ -247,6 +248,20 @@ pub enum EntryKind<'tcx> {\n     AssociatedConst(AssociatedContainer),\n }\n \n+/// A copy of `ty::Generics` which allows lazy decoding of\n+/// `regions` and `types` (e.g. knowing the number of type\n+/// and lifetime parameters before `TyCtxt` is created).\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct Generics<'tcx> {\n+    pub parent: Option<DefId>,\n+    pub parent_regions: u32,\n+    pub parent_types: u32,\n+    pub regions: LazySeq<ty::RegionParameterDef>,\n+    pub types: LazySeq<ty::TypeParameterDef<'tcx>>,\n+    pub has_self: bool,\n+    pub object_lifetime_defaults: LazySeq<ObjectLifetimeDefault>,\n+}\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ModData {\n     pub reexports: LazySeq<def::Export>,"}, {"sha": "121d592da0316881621fc53468fffc0da11eca32", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -16,8 +16,6 @@ use rustc::hir;\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn ast_block(&mut self,\n                      destination: &Lvalue<'tcx>,\n-                     // FIXME(#32959): temporary measure for the issue\n-                     dest_is_unit: bool,\n                      mut block: BasicBlock,\n                      ast_block: &'tcx hir::Block)\n                      -> BlockAnd<()> {\n@@ -83,8 +81,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // of the block.\n             if let Some(expr) = expr {\n                 unpack!(block = this.into(destination, block, expr));\n-            } else if dest_is_unit {\n-                // FIXME(#31472)\n+            } else {\n                 let source_info = this.source_info(span);\n                 this.cfg.push_assign_unit(block, source_info, destination);\n             }"}, {"sha": "3d4af259ec9f72550ed8ce17f51692872bc00392", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -40,7 +40,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 this.in_scope(extent, block, |this| this.into(destination, block, value))\n             }\n             ExprKind::Block { body: ast_block } => {\n-                this.ast_block(destination, expr.ty.is_nil(), block, ast_block)\n+                this.ast_block(destination, block, ast_block)\n             }\n             ExprKind::Match { discriminant, arms } => {\n                 this.match_expr(destination, expr_span, block, discriminant, arms)"}, {"sha": "e94d35195c21336cc162a8f777ca2e7a303eecb5", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -99,20 +99,24 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             PatternKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n-                let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n-                    i == variant_index || {\n-                        let mut visited = FxHashSet::default();\n-                        let node_set = v.uninhabited_from(&mut visited,\n-                                                          self.hir.tcx(),\n-                                                          substs,\n-                                                          adt_def.adt_kind());\n-                        !node_set.is_empty()\n+                if self.hir.tcx().sess.features.borrow().never_type {\n+                    let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n+                        i == variant_index || {\n+                            let mut visited = FxHashSet::default();\n+                            let node_set = v.uninhabited_from(&mut visited,\n+                                                              self.hir.tcx(),\n+                                                              substs,\n+                                                              adt_def.adt_kind());\n+                            !node_set.is_empty()\n+                        }\n+                    });\n+                    if irrefutable {\n+                        let lvalue = match_pair.lvalue.downcast(adt_def, variant_index);\n+                        candidate.match_pairs.extend(self.field_match_pairs(lvalue, subpatterns));\n+                        Ok(())\n+                    } else {\n+                        Err(match_pair)\n                     }\n-                });\n-                if irrefutable {\n-                    let lvalue = match_pair.lvalue.downcast(adt_def, variant_index);\n-                    candidate.match_pairs.extend(self.field_match_pairs(lvalue, subpatterns));\n-                    Ok(())\n                 } else {\n                     Err(match_pair)\n                 }"}, {"sha": "7eaf1fe13986518e85fd8ccd4c44759cb6b6bd7a", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -663,7 +663,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprCast(ref source, _) => {\n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op).\n-            if let Some(&TyCastKind::CoercionCast) = cx.tcx.cast_kinds.borrow().get(&source.id) {\n+            if let Some(&TyCastKind::CoercionCast) = cx.tables().cast_kinds.get(&source.id) {\n                 // Convert the lexpr to a vexpr.\n                 ExprKind::Use { source: source.to_ref() }\n             } else {"}, {"sha": "35734dcce2beb631c2dd58cc319dffd7c7a7a816", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -92,7 +92,7 @@ pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n     where I: Iterator<Item=DefId>, 'tcx: 'a\n {\n     let mut first = true;\n-    for def_id in iter {\n+    for def_id in iter.filter(DefId::is_local) {\n         let mir = &tcx.item_mir(def_id);\n \n         if first {"}, {"sha": "9c1107344f241f077800f03deb48aab657d51dcf", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -350,7 +350,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 base: Lvalue::Local(index),\n                 elem: ProjectionElem::Deref\n             }) if self.mir.local_kind(index) == LocalKind::Temp\n-               && self.mir.local_decls[index].ty.is_unique()\n+               && self.mir.local_decls[index].ty.is_box()\n                && self.temp_qualif[index].map_or(false, |qualif| {\n                     qualif.intersects(Qualif::NOT_CONST)\n                }) => {"}, {"sha": "c9195f29f1784481e0774d8b23ccfaba7d61a523", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -580,9 +580,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             return;\n         }\n \n-        let arg_ty = match args[0].ty(mir, self.tcx()).sty {\n+        let ty = args[0].ty(mir, self.tcx());\n+        let arg_ty = match ty.sty {\n             ty::TyRawPtr(mt) => mt.ty,\n-            ty::TyBox(ty) => ty,\n+            ty::TyAdt(def, _) if def.is_box() => ty.boxed_ty(),\n             _ => {\n                 span_mirbug!(self, term, \"box_free called with bad arg ty\");\n                 return;"}, {"sha": "0933fdfd357cd7e82cccce429b23f57b39a2a7a4", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -144,8 +144,25 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 });\n             }\n             TyKind::TraitObject(ref bounds) => {\n+                let mut any_lifetime_bounds = false;\n+                for bound in bounds {\n+                    if let RegionTyParamBound(ref lifetime) = *bound {\n+                        if any_lifetime_bounds {\n+                            span_err!(self.session, lifetime.span, E0226,\n+                                      \"only a single explicit lifetime bound is permitted\");\n+                            break;\n+                        }\n+                        any_lifetime_bounds = true;\n+                    }\n+                }\n                 self.no_questions_in_bounds(bounds, \"trait object types\", false);\n             }\n+            TyKind::ImplTrait(ref bounds) => {\n+                if !bounds.iter()\n+                          .any(|b| if let TraitTyParamBound(..) = *b { true } else { false }) {\n+                    self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n+                }\n+            }\n             _ => {}\n         }\n \n@@ -284,6 +301,26 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n         visit::walk_vis(self, vis)\n     }\n+\n+    fn visit_generics(&mut self, g: &'a Generics) {\n+        let mut seen_default = None;\n+        for ty_param in &g.ty_params {\n+            if ty_param.default.is_some() {\n+                seen_default = Some(ty_param.span);\n+            } else if let Some(span) = seen_default {\n+                self.err_handler()\n+                    .span_err(span, \"type parameters with a default must be trailing\");\n+                break\n+            }\n+        }\n+        for predicate in &g.where_clause.predicates {\n+            if let WherePredicate::EqPredicate(ref predicate) = *predicate {\n+                self.err_handler().span_err(predicate.span, \"equality constraints are not yet \\\n+                                                             supported in where clauses (#20041)\");\n+            }\n+        }\n+        visit::walk_generics(self, g)\n+    }\n }\n \n pub fn check_crate(session: &Session, krate: &Crate) {"}, {"sha": "0b55513f8318c3c45cd8228fb8f3823a0f15db35", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -314,7 +314,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         }\n         hir::ExprCast(ref from, _) => {\n             debug!(\"Checking const cast(id={})\", from.id);\n-            match v.tcx.cast_kinds.borrow().get(&from.id) {\n+            match v.tables.cast_kinds.get(&from.id) {\n                 None => span_bug!(e.span, \"no kind for cast\"),\n                 Some(&CastKind::PtrAddrCast) | Some(&CastKind::FnPtrAddrCast) => {\n                     v.promotable = false;"}, {"sha": "ef871959176af088e534eda9b70c54b451c30392", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -244,6 +244,7 @@ match 5u32 {\n }\n \n register_diagnostics! {\n+    E0226, // only a single explicit lifetime bound is permitted\n     E0472, // asm! is unsupported on this target\n     E0561, // patterns aren't allowed in function pointer types\n     E0571, // `break` with a value in a non-`loop`-loop"}, {"sha": "49f2ccb7c57f59865c723449bcc968c7b2e9e61c", "filename": "src/librustc_privacy/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 39, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_privacy%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_privacy%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Fdiagnostics.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -115,45 +115,6 @@ pub enum Foo {\n ```\n \"##,\n \n-E0450: r##\"\n-A tuple constructor was invoked while some of its fields are private. Erroneous\n-code example:\n-\n-```compile_fail,E0450\n-mod Bar {\n-    pub struct Foo(isize);\n-}\n-\n-let f = Bar::Foo(0); // error: cannot invoke tuple struct constructor with\n-                     //        private fields\n-```\n-\n-To solve this issue, please ensure that all of the fields of the tuple struct\n-are public. Alternatively, provide a `new()` method to the tuple struct to\n-construct it from a given inner value. Example:\n-\n-```\n-mod Bar {\n-    pub struct Foo(pub isize); // we set its field to public\n-}\n-\n-let f = Bar::Foo(0); // ok!\n-\n-// or:\n-mod bar {\n-    pub struct Foo(isize);\n-\n-    impl Foo {\n-        pub fn new(x: isize) -> Foo {\n-            Foo(x)\n-        }\n-    }\n-}\n-\n-let f = bar::Foo::new(1);\n-```\n-\"##,\n-\n E0451: r##\"\n A struct constructor with private fields was invoked. Erroneous code example:\n \n@@ -204,3 +165,7 @@ let f = Bar::Foo::new(); // ok!\n \"##,\n \n }\n+\n+register_diagnostics! {\n+//  E0450, moved into resolve\n+}"}, {"sha": "9dc94745cff7b72fc64b4c8f142605e058502e40", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -27,7 +27,7 @@ extern crate syntax_pos;\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::{self, PatKind};\n-use rustc::hir::def::{self, Def, CtorKind};\n+use rustc::hir::def::{self, Def};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::DeepVisitor;\n@@ -478,33 +478,6 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n-                if let Def::StructCtor(_, CtorKind::Fn) = path.def {\n-                    let adt_def = self.tcx.expect_variant_def(path.def);\n-                    let private_indexes = adt_def.fields.iter().enumerate().filter(|&(_, field)| {\n-                        !field.vis.is_accessible_from(self.curitem, self.tcx)\n-                    }).map(|(i, _)| i).collect::<Vec<_>>();\n-\n-                    if !private_indexes.is_empty() {\n-                        let mut error = struct_span_err!(self.tcx.sess, expr.span, E0450,\n-                                                         \"cannot invoke tuple struct constructor \\\n-                                                          with private fields\");\n-                        error.span_label(expr.span,\n-                                         &format!(\"cannot construct with a private field\"));\n-\n-                        if let Some(node_id) = self.tcx.hir.as_local_node_id(adt_def.did) {\n-                            let node = self.tcx.hir.find(node_id);\n-                            if let Some(hir::map::NodeStructCtor(vdata)) = node {\n-                                for i in private_indexes {\n-                                    error.span_label(vdata.fields()[i].span,\n-                                                     &format!(\"private field declared here\"));\n-                                }\n-                            }\n-                        }\n-                        error.emit();\n-                    }\n-                }\n-            }\n             _ => {}\n         }\n "}, {"sha": "eb6c7f4bed5deaddb2cdeec5528afc97a4f3d2b0", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -327,21 +327,26 @@ impl<'a> Resolver<'a> {\n                 let def = Def::Struct(self.definitions.local_def_id(item.id));\n                 self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n \n-                // If this is a tuple or unit struct, define a name\n-                // in the value namespace as well.\n-                if !struct_def.is_struct() {\n-                    let ctor_def = Def::StructCtor(self.definitions.local_def_id(struct_def.id()),\n-                                                   CtorKind::from_ast(struct_def));\n-                    self.define(parent, ident, ValueNS, (ctor_def, vis, sp, expansion));\n-                }\n-\n                 // Record field names for error reporting.\n+                let mut ctor_vis = vis;\n                 let field_names = struct_def.fields().iter().filter_map(|field| {\n-                    self.resolve_visibility(&field.vis);\n+                    let field_vis = self.resolve_visibility(&field.vis);\n+                    if ctor_vis.is_at_least(field_vis, &*self) {\n+                        ctor_vis = field_vis;\n+                    }\n                     field.ident.map(|ident| ident.name)\n                 }).collect();\n                 let item_def_id = self.definitions.local_def_id(item.id);\n                 self.insert_field_names(item_def_id, field_names);\n+\n+                // If this is a tuple or unit struct, define a name\n+                // in the value namespace as well.\n+                if !struct_def.is_struct() {\n+                    let ctor_def = Def::StructCtor(self.definitions.local_def_id(struct_def.id()),\n+                                                   CtorKind::from_ast(struct_def));\n+                    self.define(parent, ident, ValueNS, (ctor_def, ctor_vis, sp, expansion));\n+                    self.struct_constructors.insert(def.def_id(), (ctor_def, ctor_vis));\n+                }\n             }\n \n             ItemKind::Union(ref vdata, _) => {\n@@ -434,9 +439,17 @@ impl<'a> Resolver<'a> {\n             Def::Variant(..) | Def::TyAlias(..) => {\n                 self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n-            Def::Fn(..) | Def::Static(..) | Def::Const(..) |\n-            Def::VariantCtor(..) | Def::StructCtor(..) => {\n+            Def::Fn(..) | Def::Static(..) | Def::Const(..) | Def::VariantCtor(..) => {\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+            }\n+            Def::StructCtor(..) => {\n                 self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+\n+                if let Some(struct_def_id) =\n+                        self.session.cstore.def_key(def_id).parent\n+                            .map(|index| DefId { krate: def_id.krate, index: index }) {\n+                    self.struct_constructors.insert(struct_def_id, (def, vis));\n+                }\n             }\n             Def::Trait(..) => {\n                 let module_kind = ModuleKind::Def(def, ident.name);"}, {"sha": "676ff98e602d6714fe1204b2f625583f874a594d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -45,7 +45,7 @@ use rustc::hir::def::*;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n-use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet};\n+use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, SpannedIdent, FloatTy, IntTy, UintTy};\n@@ -1131,6 +1131,10 @@ pub struct Resolver<'a> {\n     warned_proc_macros: FxHashSet<Name>,\n \n     potentially_unused_imports: Vec<&'a ImportDirective<'a>>,\n+\n+    // This table maps struct IDs into struct constructor IDs,\n+    // it's not used during normal resolution, only for better error reporting.\n+    struct_constructors: DefIdMap<(Def, ty::Visibility)>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1310,6 +1314,7 @@ impl<'a> Resolver<'a> {\n             proc_macro_enabled: features.proc_macro,\n             warned_proc_macros: FxHashSet(),\n             potentially_unused_imports: Vec::new(),\n+            struct_constructors: DefIdMap(),\n         }\n     }\n \n@@ -2205,6 +2210,15 @@ impl<'a> Resolver<'a> {\n                         _ => {}\n                     },\n                     _ if ns == ValueNS && is_struct_like(def) => {\n+                        if let Def::Struct(def_id) = def {\n+                            if let Some((ctor_def, ctor_vis))\n+                                    = this.struct_constructors.get(&def_id).cloned() {\n+                                if is_expected(ctor_def) && !this.is_accessible(ctor_vis) {\n+                                    err.span_label(span, &format!(\"constructor is not visible \\\n+                                                                   here due to private fields\"));\n+                                }\n+                            }\n+                        }\n                         err.span_label(span, &format!(\"did you mean `{} {{ /* fields */ }}`?\",\n                                                        path_str));\n                         return err;\n@@ -2235,7 +2249,23 @@ impl<'a> Resolver<'a> {\n                 if is_expected(resolution.base_def) || resolution.base_def == Def::Err {\n                     resolution\n                 } else {\n-                    report_errors(self, Some(resolution.base_def))\n+                    // Add a temporary hack to smooth the transition to new struct ctor\n+                    // visibility rules. See #38932 for more details.\n+                    let mut res = None;\n+                    if let Def::Struct(def_id) = resolution.base_def {\n+                        if let Some((ctor_def, ctor_vis))\n+                                = self.struct_constructors.get(&def_id).cloned() {\n+                            if is_expected(ctor_def) && self.is_accessible(ctor_vis) {\n+                                let lint = lint::builtin::LEGACY_CONSTRUCTOR_VISIBILITY;\n+                                self.session.add_lint(lint, id, span,\n+                                    \"private struct constructors are not usable through \\\n+                                     reexports in outer modules\".to_string());\n+                                res = Some(PathResolution::new(ctor_def));\n+                            }\n+                        }\n+                    }\n+\n+                    res.unwrap_or_else(|| report_errors(self, Some(resolution.base_def)))\n                 }\n             }\n             Some(resolution) if source.defer_to_typeck() => {"}, {"sha": "f128167bbf621b50e074a27a3d34bd2227ddaf70", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -111,11 +111,16 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     fn nest_tables<F>(&mut self, item_id: NodeId, f: F)\n         where F: FnOnce(&mut DumpVisitor<'l, 'tcx, 'll, D>)\n     {\n-        let old_tables = self.save_ctxt.tables;\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n-        self.save_ctxt.tables = self.tcx.item_tables(item_def_id);\n-        f(self);\n-        self.save_ctxt.tables = old_tables;\n+        match self.tcx.tables.borrow().get(&item_def_id) {\n+            Some(tables) => {\n+                let old_tables = self.save_ctxt.tables;\n+                self.save_ctxt.tables = tables;\n+                f(self);\n+                self.save_ctxt.tables = old_tables;\n+            }\n+            None => f(self),\n+        }\n     }\n \n     pub fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {"}, {"sha": "d392ebaa33d422dfb045ee80a01f67155bdbd96f", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -429,7 +429,7 @@ impl FnType {\n         if !type_is_fat_ptr(ccx, ret_ty) {\n             // The `noalias` attribute on the return value is useful to a\n             // function ptr caller.\n-            if let ty::TyBox(_) = ret_ty.sty {\n+            if ret_ty.is_box() {\n                 // `Box` pointer return values never alias because ownership\n                 // is transferred\n                 ret.attrs.set(ArgAttribute::NoAlias);\n@@ -438,12 +438,16 @@ impl FnType {\n             // We can also mark the return value as `dereferenceable` in certain cases\n             match ret_ty.sty {\n                 // These are not really pointers but pairs, (pointer, len)\n-                ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n-                ty::TyBox(ty) => {\n+                ty::TyRef(_, ty::TypeAndMut { ty, .. }) => {\n                     let llty = type_of::sizing_type_of(ccx, ty);\n                     let llsz = llsize_of_alloc(ccx, llty);\n                     ret.attrs.set_dereferenceable(llsz);\n                 }\n+                ty::TyAdt(def, _) if def.is_box() => {\n+                    let llty = type_of::sizing_type_of(ccx, ret_ty.boxed_ty());\n+                    let llsz = llsize_of_alloc(ccx, llty);\n+                    ret.attrs.set_dereferenceable(llsz);\n+                }\n                 _ => {}\n             }\n         }\n@@ -453,9 +457,9 @@ impl FnType {\n         // Handle safe Rust thin and fat pointers.\n         let rust_ptr_attrs = |ty: Ty<'tcx>, arg: &mut ArgType| match ty.sty {\n             // `Box` pointer parameters never alias because ownership is transferred\n-            ty::TyBox(inner) => {\n+            ty::TyAdt(def, _) if def.is_box() => {\n                 arg.attrs.set(ArgAttribute::NoAlias);\n-                Some(inner)\n+                Some(ty.boxed_ty())\n             }\n \n             ty::TyRef(b, mt) => {"}, {"sha": "bea3ca8df70e0babf243b0c40c210ddbe75bc4ae", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -81,19 +81,50 @@ impl ExportedSymbols {\n         for cnum in scx.sess().cstore.crates() {\n             debug_assert!(cnum != LOCAL_CRATE);\n \n+            // If this crate is a plugin and/or a custom derive crate, then\n+            // we're not even going to link those in so we skip those crates.\n             if scx.sess().cstore.plugin_registrar_fn(cnum).is_some() ||\n                scx.sess().cstore.derive_registrar_fn(cnum).is_some() {\n                 continue;\n             }\n \n+            // Check to see if this crate is a \"special runtime crate\". These\n+            // crates, implementation details of the standard library, typically\n+            // have a bunch of `pub extern` and `#[no_mangle]` functions as the\n+            // ABI between them. We don't want their symbols to have a `C`\n+            // export level, however, as they're just implementation details.\n+            // Down below we'll hardwire all of the symbols to the `Rust` export\n+            // level instead.\n+            let special_runtime_crate =\n+                scx.sess().cstore.is_allocator(cnum) ||\n+                scx.sess().cstore.is_panic_runtime(cnum) ||\n+                scx.sess().cstore.is_compiler_builtins(cnum);\n+\n             let crate_exports = scx\n                 .sess()\n                 .cstore\n                 .exported_symbols(cnum)\n                 .iter()\n                 .map(|&def_id| {\n                     let name = Instance::mono(scx, def_id).symbol_name(scx);\n-                    let export_level = export_level(scx, def_id);\n+                    let export_level = if special_runtime_crate {\n+                        // We can probably do better here by just ensuring that\n+                        // it has hidden visibility rather than public\n+                        // visibility, as this is primarily here to ensure it's\n+                        // not stripped during LTO.\n+                        //\n+                        // In general though we won't link right if these\n+                        // symbols are stripped, and LTO currently strips them.\n+                        if name == \"rust_eh_personality\" ||\n+                           name == \"rust_eh_register_frames\" ||\n+                           name == \"rust_eh_unregister_frames\" {\n+                            SymbolExportLevel::C\n+                        } else {\n+                            SymbolExportLevel::Rust\n+                        }\n+                    } else {\n+                        export_level(scx, def_id)\n+                    };\n                     debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\", name, export_level);\n                     (name, export_level)\n                 })"}, {"sha": "9bd19d5bbb3e47f050d7ffcbd19495e55cdaa6fb", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -227,7 +227,6 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n ) -> (ValueRef, ValueRef) {\n     debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n     match (&src_ty.sty, &dst_ty.sty) {\n-        (&ty::TyBox(a), &ty::TyBox(b)) |\n         (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRef(_, ty::TypeAndMut { ty: b, .. })) |\n         (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n@@ -238,6 +237,12 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n             let ptr_ty = type_of::in_memory_type_of(bcx.ccx, b).ptr_to();\n             (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n         }\n+        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n+            let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n+            assert!(bcx.ccx.shared().type_is_sized(a));\n+            let ptr_ty = type_of::in_memory_type_of(bcx.ccx, b).ptr_to();\n+            (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n+        }\n         _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n     }\n }\n@@ -249,25 +254,30 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                      src_ty: Ty<'tcx>,\n                                      dst: ValueRef,\n                                      dst_ty: Ty<'tcx>) {\n+    let coerce_ptr = || {\n+        let (base, info) = if common::type_is_fat_ptr(bcx.ccx, src_ty) {\n+            // fat-ptr to fat-ptr unsize preserves the vtable\n+            // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n+            // So we need to pointercast the base to ensure\n+            // the types match up.\n+            let (base, info) = load_fat_ptr(bcx, src, src_ty);\n+            let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, dst_ty);\n+            let base = bcx.pointercast(base, llcast_ty);\n+            (base, info)\n+        } else {\n+            let base = load_ty(bcx, src, src_ty);\n+            unsize_thin_ptr(bcx, base, src_ty, dst_ty)\n+        };\n+        store_fat_ptr(bcx, base, info, dst, dst_ty);\n+    };\n     match (&src_ty.sty, &dst_ty.sty) {\n-        (&ty::TyBox(..), &ty::TyBox(..)) |\n         (&ty::TyRef(..), &ty::TyRef(..)) |\n         (&ty::TyRef(..), &ty::TyRawPtr(..)) |\n         (&ty::TyRawPtr(..), &ty::TyRawPtr(..)) => {\n-            let (base, info) = if common::type_is_fat_ptr(bcx.ccx, src_ty) {\n-                // fat-ptr to fat-ptr unsize preserves the vtable\n-                // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n-                // So we need to pointercast the base to ensure\n-                // the types match up.\n-                let (base, info) = load_fat_ptr(bcx, src, src_ty);\n-                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, dst_ty);\n-                let base = bcx.pointercast(base, llcast_ty);\n-                (base, info)\n-            } else {\n-                let base = load_ty(bcx, src, src_ty);\n-                unsize_thin_ptr(bcx, base, src_ty, dst_ty)\n-            };\n-            store_fat_ptr(bcx, base, info, dst, dst_ty);\n+            coerce_ptr()\n+        }\n+        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n+            coerce_ptr()\n         }\n \n         (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) => {\n@@ -414,7 +424,7 @@ pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> V\n         // a char is a Unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n         b.load_range_assert(ptr, 0, 0x10FFFF + 1, llvm::False)\n-    } else if (t.is_region_ptr() || t.is_unique()) && !common::type_is_fat_ptr(ccx, t) {\n+    } else if (t.is_region_ptr() || t.is_box()) && !common::type_is_fat_ptr(ccx, t) {\n         b.load_nonnull(ptr)\n     } else {\n         b.load(ptr)\n@@ -449,7 +459,7 @@ pub fn load_fat_ptr<'a, 'tcx>(\n     b: &Builder<'a, 'tcx>, src: ValueRef, t: Ty<'tcx>\n ) -> (ValueRef, ValueRef) {\n     let ptr = get_dataptr(b, src);\n-    let ptr = if t.is_region_ptr() || t.is_unique() {\n+    let ptr = if t.is_region_ptr() || t.is_box() {\n         b.load_nonnull(ptr)\n     } else {\n         b.load(ptr)"}, {"sha": "c113716ca5c74295339868d95bda27492dbcc0d3", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -1107,7 +1107,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     pub fn set_personality_fn(&self, personality: ValueRef) {\n         unsafe {\n-            llvm::LLVMRustSetPersonalityFn(self.llbuilder, personality);\n+            llvm::LLVMSetPersonalityFn(self.llfn(), personality);\n         }\n     }\n "}, {"sha": "392c270c130a857b09886bc64e51ad349a910fb2", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -52,7 +52,7 @@\n //!   the LLVM artifact produced for A references the LLVM artifact produced\n //!   for B.\n //!\n-//! - Translation items and the references between them for a directed graph,\n+//! - Translation items and the references between them form a directed graph,\n //!   where the translation items are the nodes and references form the edges.\n //!   Let's call this graph the \"translation item graph\".\n //!\n@@ -721,14 +721,13 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     debug!(\"find_drop_glue_neighbors: {}\", type_to_string(scx.tcx(), ty));\n \n     // Make sure the BoxFreeFn lang-item gets translated if there is a boxed value.\n-    if let ty::TyBox(content_type) = ty.sty {\n+    if ty.is_box() {\n         let def_id = scx.tcx().require_lang_item(BoxFreeFnLangItem);\n-\n         if should_trans_locally(scx.tcx(), def_id) {\n             let box_free_fn_trans_item =\n                 create_fn_trans_item(scx,\n                                      def_id,\n-                                     scx.tcx().mk_substs(iter::once(Kind::from(content_type))),\n+                                     scx.tcx().mk_substs(iter::once(Kind::from(ty.boxed_ty()))),\n                                      scx.tcx().intern_substs(&[]));\n             output.push(box_free_fn_trans_item);\n         }\n@@ -741,7 +740,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         _ => None\n     };\n \n-    if let Some(destructor_did) = destructor_did {\n+    if let (Some(destructor_did), false) = (destructor_did, ty.is_box()) {\n         use rustc::ty::ToPolyTraitRef;\n \n         let drop_trait_def_id = scx.tcx()\n@@ -790,8 +789,14 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         ty::TyDynamic(..)  => {\n             /* nothing to do */\n         }\n-        ty::TyAdt(adt_def, substs) => {\n-            for field in adt_def.all_fields() {\n+        ty::TyAdt(def, _) if def.is_box() => {\n+            let inner_type = glue::get_drop_glue_type(scx, ty.boxed_ty());\n+            if scx.type_needs_drop(inner_type) {\n+                output.push(TransItem::DropGlue(DropGlueKind::Ty(inner_type)));\n+            }\n+        }\n+        ty::TyAdt(def, substs) => {\n+            for field in def.all_fields() {\n                 let field_type = scx.tcx().item_type(field.did);\n                 let field_type = monomorphize::apply_param_substs(scx,\n                                                                   substs,\n@@ -811,7 +816,6 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        ty::TyBox(inner_type)      |\n         ty::TySlice(inner_type)    |\n         ty::TyArray(inner_type, _) => {\n             let inner_type = glue::get_drop_glue_type(scx, inner_type);\n@@ -1008,21 +1012,24 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                             source_ty: ty::Ty<'tcx>,\n                                             target_ty: ty::Ty<'tcx>)\n                                             -> (ty::Ty<'tcx>, ty::Ty<'tcx>) {\n+    let ptr_vtable = |inner_source: ty::Ty<'tcx>, inner_target: ty::Ty<'tcx>| {\n+        if !scx.type_is_sized(inner_source) {\n+            (inner_source, inner_target)\n+        } else {\n+            scx.tcx().struct_lockstep_tails(inner_source, inner_target)\n+        }\n+    };\n     match (&source_ty.sty, &target_ty.sty) {\n-        (&ty::TyBox(a), &ty::TyBox(b)) |\n         (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRef(_, ty::TypeAndMut { ty: b, .. })) |\n         (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) |\n         (&ty::TyRawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            let (inner_source, inner_target) = (a, b);\n-\n-            if !scx.type_is_sized(inner_source) {\n-                (inner_source, inner_target)\n-            } else {\n-                scx.tcx().struct_lockstep_tails(inner_source, inner_target)\n-            }\n+            ptr_vtable(a, b)\n+        }\n+        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n+            ptr_vtable(source_ty.boxed_ty(), target_ty.boxed_ty())\n         }\n \n         (&ty::TyAdt(source_adt_def, source_substs),"}, {"sha": "0ba94fdfe635cf5aca3968f15e836fa18597e319", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -234,7 +234,8 @@ pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n pub fn C_big_integral(t: Type, u: u128, sign_extend: bool) -> ValueRef {\n     if ::std::mem::size_of::<u128>() == 16 {\n         unsafe {\n-            llvm::LLVMConstIntOfArbitraryPrecision(t.to_ref(), 2, &u as *const u128 as *const u64)\n+            let words = [u as u64, u.wrapping_shr(64) as u64];\n+            llvm::LLVMConstIntOfArbitraryPrecision(t.to_ref(), 2, words.as_ptr())\n         }\n     } else {\n         // SNAP: remove after snapshot"}, {"sha": "b7e319f2de43431cf9ef8190611dc227b9aab659", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -490,6 +490,35 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     debug!(\"type_metadata: {:?}\", t);\n \n     let sty = &t.sty;\n+    let ptr_metadata = |ty: Ty<'tcx>| {\n+        match ty.sty {\n+            ty::TySlice(typ) => {\n+                Ok(vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span))\n+            }\n+            ty::TyStr => {\n+                Ok(vec_slice_metadata(cx, t, cx.tcx().types.u8, unique_type_id, usage_site_span))\n+            }\n+            ty::TyDynamic(..) => {\n+                Ok(MetadataCreationResult::new(\n+                    trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n+                    false))\n+            }\n+            _ => {\n+                let pointee_metadata = type_metadata(cx, ty, usage_site_span);\n+\n+                match debug_context(cx).type_map\n+                                        .borrow()\n+                                        .find_metadata_for_unique_id(unique_type_id) {\n+                    Some(metadata) => return Err(metadata),\n+                    None => { /* proceed normally */ }\n+                };\n+\n+                Ok(MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata),\n+                   false))\n+            }\n+        }\n+    };\n+\n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n         ty::TyNever    |\n         ty::TyBool     |\n@@ -516,34 +545,17 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         trait_pointer_metadata(cx, t, None, unique_type_id),\n             false)\n         }\n-        ty::TyBox(ty) |\n         ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n         ty::TyRef(_, ty::TypeAndMut{ty, ..}) => {\n-            match ty.sty {\n-                ty::TySlice(typ) => {\n-                    vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span)\n-                }\n-                ty::TyStr => {\n-                    vec_slice_metadata(cx, t, cx.tcx().types.u8, unique_type_id, usage_site_span)\n-                }\n-                ty::TyDynamic(..) => {\n-                    MetadataCreationResult::new(\n-                        trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n-                        false)\n-                }\n-                _ => {\n-                    let pointee_metadata = type_metadata(cx, ty, usage_site_span);\n-\n-                    match debug_context(cx).type_map\n-                                           .borrow()\n-                                           .find_metadata_for_unique_id(unique_type_id) {\n-                        Some(metadata) => return metadata,\n-                        None => { /* proceed normally */ }\n-                    };\n-\n-                    MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata),\n-                                                false)\n-                }\n+            match ptr_metadata(ty) {\n+                Ok(res) => res,\n+                Err(metadata) => return metadata,\n+            }\n+        }\n+        ty::TyAdt(def, _) if def.is_box() => {\n+            match ptr_metadata(t.boxed_ty()) {\n+                Ok(res) => res,\n+                Err(metadata) => return metadata,\n             }\n         }\n         ty::TyFnDef(.., ref barefnty) | ty::TyFnPtr(ref barefnty) => {"}, {"sha": "e9468e56637d22cf1859fe79ebc91a72c666bb08", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -400,7 +400,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // Only \"class\" methods are generally understood by LLVM,\n                 // so avoid methods on other types (e.g. `<*mut T>::null`).\n                 match impl_self_ty.sty {\n-                    ty::TyAdt(..) => {\n+                    ty::TyAdt(def, ..) if !def.is_box() => {\n                         Some(type_metadata(cx, impl_self_ty, syntax_pos::DUMMY_SP))\n                     }\n                     _ => None"}, {"sha": "8e11bf6b8976a8c3c822c18cec94de6966458fbc", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -60,11 +60,6 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n             output.push(')');\n         },\n-        ty::TyBox(inner_type) => {\n-            output.push_str(\"Box<\");\n-            push_debuginfo_type_name(cx, inner_type, true, output);\n-            output.push('>');\n-        },\n         ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n             output.push('*');\n             match mutbl {"}, {"sha": "8d634c0e292ad7f35e5cfab404c75c89c88ecfc1", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -60,8 +60,7 @@ pub fn bytes_to_bits(bytes: u64) -> u64 {\n #[inline]\n pub fn debug_context<'a, 'tcx>(cx: &'a CrateContext<'a, 'tcx>)\n                            -> &'a CrateDebugContext<'tcx> {\n-    let debug_context: &'a CrateDebugContext<'tcx> = cx.dbg_cx().as_ref().unwrap();\n-    debug_context\n+    cx.dbg_cx().as_ref().unwrap()\n }\n \n #[inline]"}, {"sha": "1415ca6029f530f885a8f469243db2aaf4dc6dac", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -79,16 +79,21 @@ pub fn get_drop_glue_type<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'t\n         return scx.tcx().types.i8;\n     }\n     match t.sty {\n-        ty::TyBox(typ) if !scx.type_needs_drop(typ) && scx.type_is_sized(typ) => {\n-            scx.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n-                let layout = t.layout(&infcx).unwrap();\n-                if layout.size(&scx.tcx().data_layout).bytes() == 0 {\n-                    // `Box<ZeroSizeType>` does not allocate.\n-                    scx.tcx().types.i8\n-                } else {\n-                    t\n-                }\n-            })\n+        ty::TyAdt(def, _) if def.is_box() => {\n+            let typ = t.boxed_ty();\n+            if !scx.type_needs_drop(typ) && scx.type_is_sized(typ) {\n+                scx.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n+                    let layout = t.layout(&infcx).unwrap();\n+                    if layout.size(&scx.tcx().data_layout).bytes() == 0 {\n+                        // `Box<ZeroSizeType>` does not allocate.\n+                        scx.tcx().types.i8\n+                    } else {\n+                        t\n+                    }\n+                })\n+            } else {\n+                t\n+            }\n         }\n         _ => t\n     }\n@@ -205,11 +210,11 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n     };\n \n     let bcx = match t.sty {\n-        ty::TyBox(content_ty) => {\n-            // Support for TyBox is built-in and its drop glue is\n-            // special. It may move to library and have Drop impl. As\n-            // a safe-guard, assert TyBox not used with TyContents.\n+        ty::TyAdt(def, _) if def.is_box() => {\n+            // Support for Box is built-in as yet and its drop glue is special\n+            // despite having a dummy Drop impl in the library.\n             assert!(!skip_dtor);\n+            let content_ty = t.boxed_ty();\n             let ptr = if !bcx.ccx.shared().type_is_sized(content_ty) {\n                 let llbox = bcx.load(get_dataptr(&bcx, ptr.llval));\n                 let info = bcx.load(get_meta(&bcx, ptr.llval));\n@@ -230,7 +235,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             bcx.call(dtor, &[ptr.llval], None);\n             bcx\n         }\n-        ty::TyAdt(def, ..) if def.dtor_kind().is_present() && !skip_dtor => {\n+        ty::TyAdt(def, ..) if def.has_dtor() && !skip_dtor => {\n             let shallow_drop = def.is_union();\n             let tcx = bcx.tcx();\n "}, {"sha": "2a1ab10d74e16dbc4b944a163b264a63ef8a1e71", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -30,7 +30,7 @@ pub fn lvalue_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n         let ty = mircx.monomorphize(&ty);\n         debug!(\"local {} has type {:?}\", index, ty);\n         if ty.is_scalar() ||\n-            ty.is_unique() ||\n+            ty.is_box() ||\n             ty.is_region_ptr() ||\n             ty.is_simd() ||\n             common::type_is_zero_size(mircx.ccx, ty)"}, {"sha": "30c138310da9c501d158ba856ecd2b6890540a82", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -319,7 +319,9 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     mircx.cleanup_kinds.iter_enumerated().map(|(bb, cleanup_kind)| {\n         if let CleanupKind::Funclet = *cleanup_kind {\n             let bcx = mircx.get_builder(bb);\n-            bcx.set_personality_fn(mircx.ccx.eh_personality());\n+            unsafe {\n+                llvm::LLVMSetPersonalityFn(mircx.llfn, mircx.ccx.eh_personality());\n+            }\n             if base::wants_msvc_seh(ccx.sess()) {\n                 return Some(Funclet::new(bcx.cleanup_pad(None, &[])));\n             }"}, {"sha": "d58a93e3cb71c47d4ee758e7887b8648dc10ac28", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -421,11 +421,6 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                 }\n                 output.push(')');\n             },\n-            ty::TyBox(inner_type) => {\n-                output.push_str(\"Box<\");\n-                self.push_type_name(inner_type, output);\n-                output.push('>');\n-            },\n             ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n                 output.push('*');\n                 match mutbl {"}, {"sha": "4df0e989ada9975040bbe9eea3e350838f1f92af", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -38,6 +38,13 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     debug!(\"sizing_type_of {:?}\", t);\n     let _recursion_lock = cx.enter_type_of(t);\n \n+    let ptr_sizing_ty = |ty: Ty<'tcx>| {\n+        if cx.shared().type_is_sized(ty) {\n+            Type::i8p(cx)\n+        } else {\n+            Type::struct_(cx, &[Type::i8p(cx), unsized_info_ty(cx, ty)], false)\n+        }\n+    };\n     let llsizingty = match t.sty {\n         _ if !cx.shared().type_is_sized(t) => {\n             Type::struct_(cx, &[Type::i8p(cx), unsized_info_ty(cx, t)], false)\n@@ -50,14 +57,12 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         ty::TyFloat(t) => Type::float_from_ty(cx, t),\n         ty::TyNever => Type::nil(cx),\n \n-        ty::TyBox(ty) |\n         ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n         ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => {\n-            if cx.shared().type_is_sized(ty) {\n-                Type::i8p(cx)\n-            } else {\n-                Type::struct_(cx, &[Type::i8p(cx), unsized_info_ty(cx, ty)], false)\n-            }\n+            ptr_sizing_ty(ty)\n+        }\n+        ty::TyAdt(def, _) if def.is_box() => {\n+            ptr_sizing_ty(t.boxed_ty())\n         }\n \n         ty::TyFnDef(..) => Type::nil(cx),\n@@ -131,11 +136,13 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n \n pub fn fat_ptr_base_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n     match ty.sty {\n-        ty::TyBox(t) |\n         ty::TyRef(_, ty::TypeAndMut { ty: t, .. }) |\n         ty::TyRawPtr(ty::TypeAndMut { ty: t, .. }) if !ccx.shared().type_is_sized(t) => {\n             in_memory_type_of(ccx, t).ptr_to()\n         }\n+        ty::TyAdt(def, _) if def.is_box() => {\n+            in_memory_type_of(ccx, ty.boxed_ty()).ptr_to()\n+        }\n         _ => bug!(\"expected fat ptr ty but got {:?}\", ty)\n     }\n }\n@@ -214,6 +221,22 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n         return llty;\n     }\n \n+    let ptr_ty = |ty: Ty<'tcx>| {\n+        if !cx.shared().type_is_sized(ty) {\n+            if let ty::TyStr = ty.sty {\n+                // This means we get a nicer name in the output (str is always\n+                // unsized).\n+                cx.str_slice_type()\n+            } else {\n+                let ptr_ty = in_memory_type_of(cx, ty).ptr_to();\n+                let info_ty = unsized_info_ty(cx, ty);\n+                Type::struct_(cx, &[ptr_ty, info_ty], false)\n+            }\n+        } else {\n+            in_memory_type_of(cx, ty).ptr_to()\n+        }\n+    };\n+\n     let mut llty = match t.sty {\n       ty::TyBool => Type::bool(cx),\n       ty::TyChar => Type::char(cx),\n@@ -227,22 +250,12 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           adt::incomplete_type_of(cx, t, \"closure\")\n       }\n \n-      ty::TyBox(ty) |\n       ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n       ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => {\n-          if !cx.shared().type_is_sized(ty) {\n-              if let ty::TyStr = ty.sty {\n-                  // This means we get a nicer name in the output (str is always\n-                  // unsized).\n-                  cx.str_slice_type()\n-              } else {\n-                  let ptr_ty = in_memory_type_of(cx, ty).ptr_to();\n-                  let info_ty = unsized_info_ty(cx, ty);\n-                  Type::struct_(cx, &[ptr_ty, info_ty], false)\n-              }\n-          } else {\n-              in_memory_type_of(cx, ty).ptr_to()\n-          }\n+          ptr_ty(ty)\n+      }\n+      ty::TyAdt(def, _) if def.is_box() => {\n+          ptr_ty(t.boxed_ty())\n       }\n \n       ty::TyArray(ty, size) => {\n@@ -300,7 +313,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n     // If this was an enum or struct, fill in the type now.\n     match t.sty {\n-        ty::TyAdt(..) | ty::TyClosure(..) if !t.is_simd() => {\n+        ty::TyAdt(..) | ty::TyClosure(..) if !t.is_simd() && !t.is_box() => {\n             adt::finish_type_of(cx, t, &mut llty);\n         }\n         _ => ()"}, {"sha": "bb9a487802e7b686c207cdff0ed41be19a7ac154", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 196, "deletions": 615, "changes": 811, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -10,7 +10,7 @@\n \n //! Conversion from AST representation of types to the ty.rs\n //! representation.  The main routine here is `ast_ty_to_ty()`: each use\n-//! is parameterized by an instance of `AstConv` and a `RegionScope`.\n+//! is parameterized by an instance of `AstConv`.\n //!\n //! The parameterization of `ast_ty_to_ty()` is because it behaves\n //! somewhat differently during the collect and check phases,\n@@ -22,31 +22,6 @@\n //! an error).  In the check phase, when the FnCtxt is used as the\n //! `AstConv`, `get_item_type()` just looks up the item type in\n //! `tcx.types` (using `TyCtxt::item_type`).\n-//!\n-//! The `RegionScope` trait controls what happens when the user does\n-//! not specify a region in some location where a region is required\n-//! (e.g., if the user writes `&Foo` as a type rather than `&'a Foo`).\n-//! See the `rscope` module for more details.\n-//!\n-//! Unlike the `AstConv` trait, the region scope can change as we descend\n-//! the type.  This is to accommodate the fact that (a) fn types are binding\n-//! scopes and (b) the default region may change.  To understand case (a),\n-//! consider something like:\n-//!\n-//!   type foo = { x: &a.int, y: |&a.int| }\n-//!\n-//! The type of `x` is an error because there is no region `a` in scope.\n-//! In the type of `y`, however, region `a` is considered a bound region\n-//! as it does not already appear in scope.\n-//!\n-//! Case (b) says that if you have a type:\n-//!   type foo<'a> = ...;\n-//!   type bar = fn(&foo, &a.foo)\n-//! The fully expanded version of type bar is:\n-//!   type bar = fn(&'foo &, &a.foo<'a>)\n-//! Note that the self region for the `foo` defaulted to `&` in the first\n-//! case but `&a` in the second.  Basically, defaults that appear inside\n-//! an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \n use rustc_const_eval::eval_length;\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -61,10 +36,6 @@ use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n use rustc_back::slice;\n use require_c_abi_if_variadic;\n-use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n-             ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope,\n-             ElisionFailureInfo, ElidedLifetime};\n-use rscope::{AnonTypeScope, MaybeWithAnonTypes};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::{NodeMap, FxHashSet};\n \n@@ -74,7 +45,6 @@ use syntax::{abi, ast};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n-use errors::DiagnosticBuilder;\n \n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n@@ -111,6 +81,10 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// See ParameterEnvironment::free_substs for more information.\n     fn get_free_substs(&self) -> Option<&Substs<'tcx>>;\n \n+    /// What lifetime should we use when a lifetime is omitted (and not elided)?\n+    fn re_infer(&self, span: Span, _def: Option<&ty::RegionParameterDef>)\n+                -> Option<&'tcx ty::Region>;\n+\n     /// What type should we use when a type is omitted?\n     fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n \n@@ -161,171 +135,71 @@ struct ConvertedBinding<'tcx> {\n /// This type must not appear anywhere in other converted types.\n const TRAIT_OBJECT_DUMMY_SELF: ty::TypeVariants<'static> = ty::TyInfer(ty::FreshTy(0));\n \n-pub fn ast_region_to_region<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                            lifetime: &hir::Lifetime)\n-                                            -> &'tcx ty::Region {\n-    let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n-        None => {\n-            // should have been recorded by the `resolve_lifetime` pass\n-            span_bug!(lifetime.span, \"unresolved lifetime\");\n-        }\n+impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n+    pub fn ast_region_to_region(&self,\n+        lifetime: &hir::Lifetime,\n+        def: Option<&ty::RegionParameterDef>)\n+        -> &'tcx ty::Region\n+    {\n+        let tcx = self.tcx();\n+        let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n+            Some(&rl::Region::Static) => {\n+                tcx.mk_region(ty::ReStatic)\n+            }\n \n-        Some(&rl::DefStaticRegion) => {\n-            ty::ReStatic\n-        }\n+            Some(&rl::Region::LateBound(debruijn, id)) => {\n+                // If this region is declared on a function, it will have\n+                // an entry in `late_bound`, but if it comes from\n+                // `for<'a>` in some type or something, it won't\n+                // necessarily have one. In that case though, we won't be\n+                // changed from late to early bound, so we can just\n+                // substitute false.\n+                let issue_32330 = tcx.named_region_map\n+                                     .late_bound\n+                                     .get(&id)\n+                                     .cloned()\n+                                     .unwrap_or(ty::Issue32330::WontChange);\n+                let name = tcx.hir.name(id);\n+                tcx.mk_region(ty::ReLateBound(debruijn,\n+                    ty::BrNamed(tcx.hir.local_def_id(id), name, issue_32330)))\n+            }\n \n-        Some(&rl::DefLateBoundRegion(debruijn, id)) => {\n-            // If this region is declared on a function, it will have\n-            // an entry in `late_bound`, but if it comes from\n-            // `for<'a>` in some type or something, it won't\n-            // necessarily have one. In that case though, we won't be\n-            // changed from late to early bound, so we can just\n-            // substitute false.\n-            let issue_32330 = tcx.named_region_map\n-                                 .late_bound\n-                                 .get(&id)\n-                                 .cloned()\n-                                 .unwrap_or(ty::Issue32330::WontChange);\n-            ty::ReLateBound(debruijn, ty::BrNamed(tcx.hir.local_def_id(id),\n-                                                  lifetime.name,\n-                                                  issue_32330))\n-        }\n+            Some(&rl::Region::LateBoundAnon(debruijn, index)) => {\n+                tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(index)))\n+            }\n \n-        Some(&rl::DefEarlyBoundRegion(index, _)) => {\n-            ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                index: index,\n-                name: lifetime.name\n-            })\n-        }\n+            Some(&rl::Region::EarlyBound(index, id)) => {\n+                let name = tcx.hir.name(id);\n+                tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                    index: index,\n+                    name: name\n+                }))\n+            }\n \n-        Some(&rl::DefFreeRegion(scope, id)) => {\n-            // As in DefLateBoundRegion above, could be missing for some late-bound\n-            // regions, but also for early-bound regions.\n-            let issue_32330 = tcx.named_region_map\n-                                 .late_bound\n-                                 .get(&id)\n-                                 .cloned()\n-                                 .unwrap_or(ty::Issue32330::WontChange);\n-            ty::ReFree(ty::FreeRegion {\n+            Some(&rl::Region::Free(scope, id)) => {\n+                // As in Region::LateBound above, could be missing for some late-bound\n+                // regions, but also for early-bound regions.\n+                let issue_32330 = tcx.named_region_map\n+                                     .late_bound\n+                                     .get(&id)\n+                                     .cloned()\n+                                     .unwrap_or(ty::Issue32330::WontChange);\n+                let name = tcx.hir.name(id);\n+                tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                     scope: scope.to_code_extent(&tcx.region_maps),\n-                    bound_region: ty::BrNamed(tcx.hir.local_def_id(id),\n-                                              lifetime.name,\n-                                              issue_32330)\n-            })\n-\n-                // (*) -- not late-bound, won't change\n-        }\n-    };\n-\n-    debug!(\"ast_region_to_region(lifetime={:?} id={}) yields {:?}\",\n-           lifetime,\n-           lifetime.id,\n-           r);\n+                    bound_region: ty::BrNamed(tcx.hir.local_def_id(id), name, issue_32330)\n+                }))\n \n-    tcx.mk_region(r)\n-}\n-\n-fn report_elision_failure(\n-    tcx: TyCtxt,\n-    db: &mut DiagnosticBuilder,\n-    params: Vec<ElisionFailureInfo>)\n-{\n-    let mut m = String::new();\n-    let len = params.len();\n-\n-    let elided_params: Vec<_> = params.into_iter()\n-                                       .filter(|info| info.lifetime_count > 0)\n-                                       .collect();\n-\n-    let elided_len = elided_params.len();\n-\n-    for (i, info) in elided_params.into_iter().enumerate() {\n-        let ElisionFailureInfo {\n-            parent, index, lifetime_count: n, have_bound_regions\n-        } = info;\n-\n-        let help_name = if let Some(body) = parent {\n-            let arg = &tcx.hir.body(body).arguments[index];\n-            format!(\"`{}`\", tcx.hir.node_to_pretty_string(arg.pat.id))\n-        } else {\n-            format!(\"argument {}\", index + 1)\n-        };\n-\n-        m.push_str(&(if n == 1 {\n-            help_name\n-        } else {\n-            format!(\"one of {}'s {} elided {}lifetimes\", help_name, n,\n-                    if have_bound_regions { \"free \" } else { \"\" } )\n-        })[..]);\n-\n-        if elided_len == 2 && i == 0 {\n-            m.push_str(\" or \");\n-        } else if i + 2 == elided_len {\n-            m.push_str(\", or \");\n-        } else if i != elided_len - 1 {\n-            m.push_str(\", \");\n-        }\n-\n-    }\n-\n-    if len == 0 {\n-        help!(db,\n-                   \"this function's return type contains a borrowed value, but \\\n-                    there is no value for it to be borrowed from\");\n-        help!(db,\n-                   \"consider giving it a 'static lifetime\");\n-    } else if elided_len == 0 {\n-        help!(db,\n-                   \"this function's return type contains a borrowed value with \\\n-                    an elided lifetime, but the lifetime cannot be derived from \\\n-                    the arguments\");\n-        help!(db,\n-                   \"consider giving it an explicit bounded or 'static \\\n-                    lifetime\");\n-    } else if elided_len == 1 {\n-        help!(db,\n-                   \"this function's return type contains a borrowed value, but \\\n-                    the signature does not say which {} it is borrowed from\",\n-                   m);\n-    } else {\n-        help!(db,\n-                   \"this function's return type contains a borrowed value, but \\\n-                    the signature does not say whether it is borrowed from {}\",\n-                   m);\n-    }\n-}\n-\n-impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n-    pub fn opt_ast_region_to_region(&self,\n-        rscope: &RegionScope,\n-        default_span: Span,\n-        opt_lifetime: &Option<hir::Lifetime>) -> &'tcx ty::Region\n-    {\n-        let r = match *opt_lifetime {\n-            Some(ref lifetime) => {\n-                ast_region_to_region(self.tcx(), lifetime)\n+                    // (*) -- not late-bound, won't change\n             }\n \n-            None => self.tcx().mk_region(match rscope.anon_regions(default_span, 1) {\n-                Ok(rs) => rs[0],\n-                Err(params) => {\n-                    let ampersand_span = Span { hi: default_span.lo, ..default_span};\n-\n-                    let mut err = struct_span_err!(self.tcx().sess, ampersand_span, E0106,\n-                                                 \"missing lifetime specifier\");\n-                    err.span_label(ampersand_span, &format!(\"expected lifetime parameter\"));\n-\n-                    if let Some(params) = params {\n-                        report_elision_failure(self.tcx(), &mut err, params);\n-                    }\n-                    err.emit();\n-                    ty::ReStatic\n-                }\n-            })\n+            None => {\n+                self.re_infer(lifetime.span, def).expect(\"unelided lifetime in signature\")\n+            }\n         };\n \n-        debug!(\"opt_ast_region_to_region(opt_lifetime={:?}) yields {:?}\",\n-                opt_lifetime,\n+        debug!(\"ast_region_to_region(lifetime={:?}) yields {:?}\",\n+                lifetime,\n                 r);\n \n         r\n@@ -334,7 +208,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     /// Given a path `path` that refers to an item `I` with the declared generics `decl_generics`,\n     /// returns an appropriate set of substitutions for this particular reference to `I`.\n     pub fn ast_path_substs_for_ty(&self,\n-        rscope: &RegionScope,\n         span: Span,\n         def_id: DefId,\n         item_segment: &hir::PathSegment)\n@@ -359,8 +232,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n \n         let (substs, assoc_bindings) =\n-            self.create_substs_for_ast_path(rscope,\n-                                            span,\n+            self.create_substs_for_ast_path(span,\n                                             def_id,\n                                             &item_segment.parameters,\n                                             None);\n@@ -376,7 +248,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     ///\n     /// Note that the type listing given here is *exactly* what the user provided.\n     fn create_substs_for_ast_path(&self,\n-        rscope: &RegionScope,\n         span: Span,\n         def_id: DefId,\n         parameters: &hir::PathParameters,\n@@ -409,23 +280,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n         let expected_num_region_params = decl_generics.regions.len();\n         let supplied_num_region_params = lifetimes.len();\n-        let regions = if expected_num_region_params == supplied_num_region_params {\n-            lifetimes.iter().map(|l| *ast_region_to_region(tcx, l)).collect()\n-        } else {\n-            let anon_regions =\n-                rscope.anon_regions(span, expected_num_region_params);\n-\n-            if supplied_num_region_params != 0 || anon_regions.is_err() {\n-                report_lifetime_number_error(tcx, span,\n-                                             supplied_num_region_params,\n-                                             expected_num_region_params);\n-            }\n-\n-            match anon_regions {\n-                Ok(anon_regions) => anon_regions,\n-                Err(_) => (0..expected_num_region_params).map(|_| ty::ReStatic).collect()\n-            }\n-        };\n+        if expected_num_region_params != supplied_num_region_params {\n+            report_lifetime_number_error(tcx, span,\n+                                         supplied_num_region_params,\n+                                         expected_num_region_params);\n+        }\n \n         // If a self-type was declared, one should be provided.\n         assert_eq!(decl_generics.has_self, self_ty.is_some());\n@@ -452,7 +311,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let mut output_assoc_binding = None;\n         let substs = Substs::for_item(tcx, def_id, |def, _| {\n             let i = def.index as usize - self_ty.is_some() as usize;\n-            tcx.mk_region(regions[i])\n+            if let Some(lifetime) = lifetimes.get(i) {\n+                self.ast_region_to_region(lifetime, Some(def))\n+            } else {\n+                tcx.mk_region(ty::ReStatic)\n+            }\n         }, |def, substs| {\n             let i = def.index as usize;\n \n@@ -466,12 +329,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // A provided type parameter.\n                 match *parameters {\n                     hir::AngleBracketedParameters(ref data) => {\n-                        self.ast_ty_arg_to_ty(rscope, Some(def), substs, &data.types[i])\n+                        self.ast_ty_to_ty(&data.types[i])\n                     }\n                     hir::ParenthesizedParameters(ref data) => {\n                         assert_eq!(i, 0);\n-                        let (ty, assoc) =\n-                            self.convert_parenthesized_parameters(rscope, substs, data);\n+                        let (ty, assoc) = self.convert_parenthesized_parameters(data);\n                         output_assoc_binding = Some(assoc);\n                         ty\n                     }\n@@ -516,7 +378,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 data.bindings.iter().map(|b| {\n                     ConvertedBinding {\n                         item_name: b.name,\n-                        ty: self.ast_ty_to_ty(rscope, &b.ty),\n+                        ty: self.ast_ty_to_ty(&b.ty),\n                         span: b.span\n                     }\n                 }).collect()\n@@ -525,7 +387,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 vec![output_assoc_binding.unwrap_or_else(|| {\n                     // This is an error condition, but we should\n                     // get the associated type binding anyway.\n-                    self.convert_parenthesized_parameters(rscope, substs, data).1\n+                    self.convert_parenthesized_parameters(data).1\n                 })]\n             }\n         };\n@@ -536,92 +398,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         (substs, assoc_bindings)\n     }\n \n-    /// Returns the appropriate lifetime to use for any output lifetimes\n-    /// (if one exists) and a vector of the (pattern, number of lifetimes)\n-    /// corresponding to each input type/pattern.\n-    fn find_implied_output_region<I>(&self,\n-                                     input_tys: &[Ty<'tcx>],\n-                                     parent: Option<hir::BodyId>,\n-                                     input_indices: I) -> ElidedLifetime\n-        where I: Iterator<Item=usize>\n-    {\n-        let tcx = self.tcx();\n-        let mut lifetimes_for_params = Vec::with_capacity(input_tys.len());\n-        let mut possible_implied_output_region = None;\n-        let mut lifetimes = 0;\n-\n-        for (input_type, index) in input_tys.iter().zip(input_indices) {\n-            let mut regions = FxHashSet();\n-            let have_bound_regions = tcx.collect_regions(input_type, &mut regions);\n-\n-            debug!(\"find_implied_output_regions: collected {:?} from {:?} \\\n-                    have_bound_regions={:?}\", &regions, input_type, have_bound_regions);\n-\n-            lifetimes += regions.len();\n-\n-            if lifetimes == 1 && regions.len() == 1 {\n-                // there's a chance that the unique lifetime of this\n-                // iteration will be the appropriate lifetime for output\n-                // parameters, so lets store it.\n-                possible_implied_output_region = regions.iter().cloned().next();\n-            }\n-\n-            lifetimes_for_params.push(ElisionFailureInfo {\n-                parent: parent,\n-                index: index,\n-                lifetime_count: regions.len(),\n-                have_bound_regions: have_bound_regions\n-            });\n-        }\n-\n-        if lifetimes == 1 {\n-            Ok(*possible_implied_output_region.unwrap())\n-        } else {\n-            Err(Some(lifetimes_for_params))\n-        }\n-    }\n-\n-    fn convert_ty_with_lifetime_elision(&self,\n-                                        elided_lifetime: ElidedLifetime,\n-                                        ty: &hir::Ty,\n-                                        anon_scope: Option<AnonTypeScope>)\n-                                        -> Ty<'tcx>\n-    {\n-        match elided_lifetime {\n-            Ok(implied_output_region) => {\n-                let rb = ElidableRscope::new(implied_output_region);\n-                self.ast_ty_to_ty(&MaybeWithAnonTypes::new(rb, anon_scope), ty)\n-            }\n-            Err(param_lifetimes) => {\n-                // All regions must be explicitly specified in the output\n-                // if the lifetime elision rules do not apply. This saves\n-                // the user from potentially-confusing errors.\n-                let rb = UnelidableRscope::new(param_lifetimes);\n-                self.ast_ty_to_ty(&MaybeWithAnonTypes::new(rb, anon_scope), ty)\n-            }\n-        }\n-    }\n-\n     fn convert_parenthesized_parameters(&self,\n-                                        rscope: &RegionScope,\n-                                        region_substs: &[Kind<'tcx>],\n                                         data: &hir::ParenthesizedParameterData)\n                                         -> (Ty<'tcx>, ConvertedBinding<'tcx>)\n     {\n-        let anon_scope = rscope.anon_type_scope();\n-        let binding_rscope = MaybeWithAnonTypes::new(BindingRscope::new(), anon_scope);\n         let inputs = self.tcx().mk_type_list(data.inputs.iter().map(|a_t| {\n-            self.ast_ty_arg_to_ty(&binding_rscope, None, region_substs, a_t)\n+            self.ast_ty_to_ty(a_t)\n         }));\n-        let input_params = 0..inputs.len();\n-        let implied_output_region = self.find_implied_output_region(&inputs, None, input_params);\n \n         let (output, output_span) = match data.output {\n             Some(ref output_ty) => {\n-                (self.convert_ty_with_lifetime_elision(implied_output_region,\n-                                                       &output_ty,\n-                                                       anon_scope),\n-                 output_ty.span)\n+                (self.ast_ty_to_ty(output_ty), output_ty.span)\n             }\n             None => {\n                 (self.tcx().mk_nil(), data.span)\n@@ -637,39 +424,19 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         (self.tcx().mk_ty(ty::TyTuple(inputs)), output_binding)\n     }\n \n-    pub fn instantiate_poly_trait_ref(&self,\n-        rscope: &RegionScope,\n-        ast_trait_ref: &hir::PolyTraitRef,\n-        self_ty: Ty<'tcx>,\n-        poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n-        -> ty::PolyTraitRef<'tcx>\n-    {\n-        let trait_ref = &ast_trait_ref.trait_ref;\n-        let trait_def_id = self.trait_def_id(trait_ref);\n-        self.ast_path_to_poly_trait_ref(rscope,\n-                                        trait_ref.path.span,\n-                                        trait_def_id,\n-                                        self_ty,\n-                                        trait_ref.ref_id,\n-                                        trait_ref.path.segments.last().unwrap(),\n-                                        poly_projections)\n-    }\n-\n     /// Instantiates the path for the given trait reference, assuming that it's\n     /// bound to a valid trait type. Returns the def_id for the defining trait.\n     /// Fails if the type is a type other than a trait type.\n     ///\n     /// If the `projections` argument is `None`, then assoc type bindings like `Foo<T=X>`\n     /// are disallowed. Otherwise, they are pushed onto the vector given.\n     pub fn instantiate_mono_trait_ref(&self,\n-        rscope: &RegionScope,\n         trait_ref: &hir::TraitRef,\n         self_ty: Ty<'tcx>)\n         -> ty::TraitRef<'tcx>\n     {\n         let trait_def_id = self.trait_def_id(trait_ref);\n-        self.ast_path_to_mono_trait_ref(rscope,\n-                                        trait_ref.path.span,\n+        self.ast_path_to_mono_trait_ref(trait_ref.path.span,\n                                         trait_def_id,\n                                         self_ty,\n                                         trait_ref.path.segments.last().unwrap())\n@@ -689,57 +456,47 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    fn ast_path_to_poly_trait_ref(&self,\n-        rscope: &RegionScope,\n-        span: Span,\n-        trait_def_id: DefId,\n+    pub fn instantiate_poly_trait_ref(&self,\n+        ast_trait_ref: &hir::PolyTraitRef,\n         self_ty: Ty<'tcx>,\n-        path_id: ast::NodeId,\n-        trait_segment: &hir::PathSegment,\n         poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n         -> ty::PolyTraitRef<'tcx>\n     {\n-        debug!(\"ast_path_to_poly_trait_ref(trait_segment={:?})\", trait_segment);\n-        // The trait reference introduces a binding level here, so\n-        // we need to shift the `rscope`. It'd be nice if we could\n-        // do away with this rscope stuff and work this knowledge\n-        // into resolve_lifetimes, as we do with non-omitted\n-        // lifetimes. Oh well, not there yet.\n-        let shifted_rscope = &ShiftedRscope::new(rscope);\n+        let trait_ref = &ast_trait_ref.trait_ref;\n+        let trait_def_id = self.trait_def_id(trait_ref);\n+\n+        debug!(\"ast_path_to_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n \n         let (substs, assoc_bindings) =\n-            self.create_substs_for_ast_trait_ref(shifted_rscope,\n-                                                 span,\n+            self.create_substs_for_ast_trait_ref(trait_ref.path.span,\n                                                  trait_def_id,\n                                                  self_ty,\n-                                                 trait_segment);\n+                                                 trait_ref.path.segments.last().unwrap());\n         let poly_trait_ref = ty::Binder(ty::TraitRef::new(trait_def_id, substs));\n \n         poly_projections.extend(assoc_bindings.iter().filter_map(|binding| {\n             // specify type to assert that error was already reported in Err case:\n             let predicate: Result<_, ErrorReported> =\n-                self.ast_type_binding_to_poly_projection_predicate(path_id,\n+                self.ast_type_binding_to_poly_projection_predicate(trait_ref.ref_id,\n                                                                    poly_trait_ref,\n                                                                    binding);\n             predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n         }));\n \n-        debug!(\"ast_path_to_poly_trait_ref(trait_segment={:?}, projections={:?}) -> {:?}\",\n-               trait_segment, poly_projections, poly_trait_ref);\n+        debug!(\"ast_path_to_poly_trait_ref({:?}, projections={:?}) -> {:?}\",\n+               trait_ref, poly_projections, poly_trait_ref);\n         poly_trait_ref\n     }\n \n     fn ast_path_to_mono_trait_ref(&self,\n-                                  rscope: &RegionScope,\n                                   span: Span,\n                                   trait_def_id: DefId,\n                                   self_ty: Ty<'tcx>,\n                                   trait_segment: &hir::PathSegment)\n                                   -> ty::TraitRef<'tcx>\n     {\n         let (substs, assoc_bindings) =\n-            self.create_substs_for_ast_trait_ref(rscope,\n-                                                 span,\n+            self.create_substs_for_ast_trait_ref(span,\n                                                  trait_def_id,\n                                                  self_ty,\n                                                  trait_segment);\n@@ -748,7 +505,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     fn create_substs_for_ast_trait_ref(&self,\n-                                       rscope: &RegionScope,\n                                        span: Span,\n                                        trait_def_id: DefId,\n                                        self_ty: Ty<'tcx>,\n@@ -792,8 +548,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         }\n \n-        self.create_substs_for_ast_path(rscope,\n-                                        span,\n+        self.create_substs_for_ast_path(span,\n                                         trait_def_id,\n                                         &trait_segment.parameters,\n                                         Some(self_ty))\n@@ -902,7 +657,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     fn ast_path_to_ty(&self,\n-        rscope: &RegionScope,\n         span: Span,\n         did: DefId,\n         item_segment: &hir::PathSegment)\n@@ -916,17 +670,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         };\n \n-        let substs = self.ast_path_substs_for_ty(rscope,\n-                                                 span,\n-                                                 did,\n-                                                 item_segment);\n-\n-        // FIXME(#12938): This is a hack until we have full support for DST.\n-        if Some(did) == self.tcx().lang_items.owned_box() {\n-            assert_eq!(substs.types().count(), 1);\n-            return self.tcx().mk_box(substs.type_at(0));\n-        }\n-\n+        let substs = self.ast_path_substs_for_ty(span, did, item_segment);\n         decl_ty.subst(self.tcx(), substs)\n     }\n \n@@ -938,32 +682,27 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         ty::ExistentialTraitRef::erase_self_ty(self.tcx(), trait_ref)\n     }\n \n-    fn trait_path_to_object_type(&self,\n-                                 rscope: &RegionScope,\n-                                 path_span: Span,\n-                                 trait_def_id: DefId,\n-                                 trait_path_ref_id: ast::NodeId,\n-                                 trait_segment: &hir::PathSegment,\n-                                 span: Span,\n-                                 partitioned_bounds: PartitionedBounds)\n-                                 -> Ty<'tcx> {\n+    fn conv_object_ty_poly_trait_ref(&self,\n+        span: Span,\n+        trait_bounds: &[hir::PolyTraitRef],\n+        lifetime: &hir::Lifetime)\n+        -> Ty<'tcx>\n+    {\n         let tcx = self.tcx();\n \n+        if trait_bounds.is_empty() {\n+            span_err!(tcx.sess, span, E0224,\n+                      \"at least one non-builtin trait is required for an object type\");\n+            return tcx.types.err;\n+        }\n+\n         let mut projection_bounds = vec![];\n         let dummy_self = tcx.mk_ty(TRAIT_OBJECT_DUMMY_SELF);\n-        let principal = self.ast_path_to_poly_trait_ref(rscope,\n-                                                        path_span,\n-                                                        trait_def_id,\n+        let principal = self.instantiate_poly_trait_ref(&trait_bounds[0],\n                                                         dummy_self,\n-                                                        trait_path_ref_id,\n-                                                        trait_segment,\n                                                         &mut projection_bounds);\n \n-        let PartitionedBounds { trait_bounds,\n-                                region_bounds } =\n-            partitioned_bounds;\n-\n-        let (auto_traits, trait_bounds) = split_auto_traits(tcx, trait_bounds);\n+        let (auto_traits, trait_bounds) = split_auto_traits(tcx, &trait_bounds[1..]);\n \n         if !trait_bounds.is_empty() {\n             let b = &trait_bounds[0];\n@@ -1038,23 +777,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         v.sort_by(|a, b| a.cmp(tcx, b));\n         let existential_predicates = ty::Binder(tcx.mk_existential_predicates(v.into_iter()));\n \n-        let region_bound = self.compute_object_lifetime_bound(span,\n-                                                              &region_bounds,\n-                                                              existential_predicates);\n \n-        let region_bound = match region_bound {\n-            Some(r) => r,\n-            None => {\n-                tcx.mk_region(match rscope.object_lifetime_default(span) {\n-                    Some(r) => r,\n-                    None => {\n-                        span_err!(self.tcx().sess, span, E0228,\n+        // Explicitly specified region bound. Use that.\n+        let region_bound = if !lifetime.is_elided() {\n+            self.ast_region_to_region(lifetime, None)\n+        } else {\n+            self.compute_object_lifetime_bound(span, existential_predicates).unwrap_or_else(|| {\n+                if tcx.named_region_map.defs.contains_key(&lifetime.id) {\n+                    self.ast_region_to_region(lifetime, None)\n+                } else {\n+                    self.re_infer(span, None).unwrap_or_else(|| {\n+                        span_err!(tcx.sess, span, E0228,\n                                   \"the lifetime bound for this object type cannot be deduced \\\n                                    from context; please supply an explicit bound\");\n-                        ty::ReStatic\n-                    }\n-                })\n-            }\n+                        tcx.mk_region(ty::ReStatic)\n+                    })\n+                }\n+            })\n         };\n \n         debug!(\"region_bound: {:?}\", region_bound);\n@@ -1265,7 +1004,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     fn qpath_to_ty(&self,\n-                   rscope: &RegionScope,\n                    span: Span,\n                    opt_self_ty: Option<Ty<'tcx>>,\n                    trait_def_id: DefId,\n@@ -1290,8 +1028,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"qpath_to_ty: self_type={:?}\", self_ty);\n \n-        let trait_ref = self.ast_path_to_mono_trait_ref(rscope,\n-                                                        span,\n+        let trait_ref = self.ast_path_to_mono_trait_ref(span,\n                                                         trait_def_id,\n                                                         self_ty,\n                                                         trait_segment);\n@@ -1301,41 +1038,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         self.projected_ty(span, trait_ref, item_segment.name)\n     }\n \n-    /// Convert a type supplied as value for a type argument from AST into our\n-    /// our internal representation. This is the same as `ast_ty_to_ty` but that\n-    /// it applies the object lifetime default.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// * `this`, `rscope`: the surrounding context\n-    /// * `def`: the type parameter being instantiated (if available)\n-    /// * `region_substs`: a partial substitution consisting of\n-    ///   only the region type parameters being supplied to this type.\n-    /// * `ast_ty`: the ast representation of the type being supplied\n-    fn ast_ty_arg_to_ty(&self,\n-                        rscope: &RegionScope,\n-                        def: Option<&ty::TypeParameterDef<'tcx>>,\n-                        region_substs: &[Kind<'tcx>],\n-                        ast_ty: &hir::Ty)\n-                        -> Ty<'tcx>\n-    {\n-        let tcx = self.tcx();\n-\n-        if let Some(def) = def {\n-            let object_lifetime_default = def.object_lifetime_default.subst(tcx, region_substs);\n-            let rscope1 = &ObjectLifetimeDefaultRscope::new(rscope, object_lifetime_default);\n-            self.ast_ty_to_ty(rscope1, ast_ty)\n-        } else {\n-            self.ast_ty_to_ty(rscope, ast_ty)\n-        }\n-    }\n-\n     // Check a type Path and convert it to a Ty.\n     pub fn def_to_ty(&self,\n-                     rscope: &RegionScope,\n                      opt_self_ty: Option<Ty<'tcx>>,\n                      path: &hir::Path,\n-                     path_id: ast::NodeId,\n                      permit_variants: bool)\n                      -> Ty<'tcx> {\n         let tcx = self.tcx();\n@@ -1345,33 +1051,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let span = path.span;\n         match path.def {\n-            Def::Trait(trait_def_id) => {\n-                // N.B. this case overlaps somewhat with\n-                // TyTraitObject, see that fn for details\n-\n-                assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n-\n-                self.trait_path_to_object_type(rscope,\n-                                               span,\n-                                               trait_def_id,\n-                                               path_id,\n-                                               path.segments.last().unwrap(),\n-                                               span,\n-                                               partition_bounds(&[]))\n-            }\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) | Def::Union(did) => {\n                 assert_eq!(opt_self_ty, None);\n                 tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n-                self.ast_path_to_ty(rscope, span, did, path.segments.last().unwrap())\n+                self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n             Def::Variant(did) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n                 // The resulting `Ty` is type of the variant's enum for now.\n                 assert_eq!(opt_self_ty, None);\n                 tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n-                self.ast_path_to_ty(rscope,\n-                                    span,\n+                self.ast_path_to_ty(span,\n                                     tcx.parent_def_id(did).unwrap(),\n                                     path.segments.last().unwrap())\n             }\n@@ -1429,8 +1119,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Def::AssociatedTy(def_id) => {\n                 tcx.prohibit_type_params(&path.segments[..path.segments.len()-2]);\n                 let trait_did = tcx.parent_def_id(def_id).unwrap();\n-                self.qpath_to_ty(rscope,\n-                                 span,\n+                self.qpath_to_ty(span,\n                                  opt_self_ty,\n                                  trait_did,\n                                  &path.segments[path.segments.len()-2],\n@@ -1450,7 +1139,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     /// Parses the programmer's textual representation of a type into our\n     /// internal notion of a type.\n-    pub fn ast_ty_to_ty(&self, rscope: &RegionScope, ast_ty: &hir::Ty) -> Ty<'tcx> {\n+    pub fn ast_ty_to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n         debug!(\"ast_ty_to_ty(id={:?}, ast_ty={:?})\",\n                ast_ty.id, ast_ty);\n \n@@ -1463,40 +1152,29 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let result_ty = match ast_ty.node {\n             hir::TySlice(ref ty) => {\n-                tcx.mk_slice(self.ast_ty_to_ty(rscope, &ty))\n+                tcx.mk_slice(self.ast_ty_to_ty(&ty))\n             }\n             hir::TyPtr(ref mt) => {\n                 tcx.mk_ptr(ty::TypeAndMut {\n-                    ty: self.ast_ty_to_ty(rscope, &mt.ty),\n+                    ty: self.ast_ty_to_ty(&mt.ty),\n                     mutbl: mt.mutbl\n                 })\n             }\n             hir::TyRptr(ref region, ref mt) => {\n-                let r = self.opt_ast_region_to_region(rscope, ast_ty.span, region);\n+                let r = self.ast_region_to_region(region, None);\n                 debug!(\"TyRef r={:?}\", r);\n-                let rscope1 =\n-                    &ObjectLifetimeDefaultRscope::new(\n-                        rscope,\n-                        ty::ObjectLifetimeDefault::Specific(r));\n-                let t = self.ast_ty_to_ty(rscope1, &mt.ty);\n+                let t = self.ast_ty_to_ty(&mt.ty);\n                 tcx.mk_ref(r, ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n             }\n             hir::TyNever => {\n                 tcx.types.never\n             },\n             hir::TyTup(ref fields) => {\n-                tcx.mk_tup(fields.iter().map(|t| self.ast_ty_to_ty(rscope, &t)))\n+                tcx.mk_tup(fields.iter().map(|t| self.ast_ty_to_ty(&t)))\n             }\n             hir::TyBareFn(ref bf) => {\n                 require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n-                let anon_scope = rscope.anon_type_scope();\n-                let bare_fn_ty = self.ty_of_method_or_bare_fn(bf.unsafety,\n-                                                              bf.abi,\n-                                                              None,\n-                                                              &bf.decl,\n-                                                              None,\n-                                                              anon_scope,\n-                                                              anon_scope);\n+                let bare_fn_ty = self.ty_of_fn(bf.unsafety, bf.abi, &bf.decl);\n \n                 // Find any late-bound regions declared in return type that do\n                 // not appear in the arguments. These are not wellformed.\n@@ -1537,22 +1215,60 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 }\n                 tcx.mk_fn_ptr(bare_fn_ty)\n             }\n-            hir::TyTraitObject(ref bounds) => {\n-                self.conv_object_ty_poly_trait_ref(rscope, ast_ty.span, bounds)\n+            hir::TyTraitObject(ref bounds, ref lifetime) => {\n+                self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n             }\n             hir::TyImplTrait(ref bounds) => {\n                 use collect::{compute_bounds, SizedByDefault};\n \n+                // Figure out if we can allow an `impl Trait` here, by walking up\n+                // to a `fn` or inherent `impl` method, going only through `Ty`\n+                // or `TraitRef` nodes (as nothing else should be in types) and\n+                // ensuring that we reach the `fn`/method signature's return type.\n+                let mut node_id = ast_ty.id;\n+                let fn_decl = loop {\n+                    let parent = tcx.hir.get_parent_node(node_id);\n+                    match tcx.hir.get(parent) {\n+                        hir::map::NodeItem(&hir::Item {\n+                            node: hir::ItemFn(ref fn_decl, ..), ..\n+                        }) => break Some(fn_decl),\n+\n+                        hir::map::NodeImplItem(&hir::ImplItem {\n+                            node: hir::ImplItemKind::Method(ref sig, _), ..\n+                        }) => {\n+                            match tcx.hir.expect_item(tcx.hir.get_parent(parent)).node {\n+                                hir::ItemImpl(.., None, _, _) => {\n+                                    break Some(&sig.decl)\n+                                }\n+                                _ => break None\n+                            }\n+                        }\n+\n+                        hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) => {}\n+\n+                        _ => break None\n+                    }\n+                    node_id = parent;\n+                };\n+                let allow = fn_decl.map_or(false, |fd| {\n+                    match fd.output {\n+                        hir::DefaultReturn(_) => false,\n+                        hir::Return(ref ty) => ty.id == node_id\n+                    }\n+                });\n+\n                 // Create the anonymized type.\n-                let def_id = tcx.hir.local_def_id(ast_ty.id);\n-                if let Some(anon_scope) = rscope.anon_type_scope() {\n-                    let substs = anon_scope.fresh_substs(self, ast_ty.span);\n+                if allow {\n+                    let def_id = tcx.hir.local_def_id(ast_ty.id);\n+                    if let Err(ErrorReported) = self.get_generics(ast_ty.span, def_id) {\n+                        return tcx.types.err;\n+                    }\n+                    let substs = Substs::identity_for_item(tcx, def_id);\n                     let ty = tcx.mk_anon(tcx.hir.local_def_id(ast_ty.id), substs);\n \n                     // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n                     let bounds = compute_bounds(self, ty, bounds,\n                                                 SizedByDefault::Yes,\n-                                                Some(anon_scope),\n                                                 ast_ty.span);\n                     let predicates = bounds.predicates(tcx, ty);\n                     let predicates = tcx.lift_to_global(&predicates).unwrap();\n@@ -1572,13 +1288,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n-                    self.ast_ty_to_ty(rscope, qself)\n+                    self.ast_ty_to_ty(qself)\n                 });\n-                self.def_to_ty(rscope, opt_self_ty, path, ast_ty.id, false)\n+                self.def_to_ty(opt_self_ty, path, false)\n             }\n             hir::TyPath(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n-                let ty = self.ast_ty_to_ty(rscope, qself);\n+                let ty = self.ast_ty_to_ty(qself);\n \n                 let def = if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = qself.node {\n                     path.def\n@@ -1589,7 +1305,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             hir::TyArray(ref ty, length) => {\n                 if let Ok(length) = eval_length(tcx.global_tcx(), length, \"array length\") {\n-                    tcx.mk_array(self.ast_ty_to_ty(rscope, &ty), length)\n+                    tcx.mk_array(self.ast_ty_to_ty(&ty), length)\n                 } else {\n                     self.tcx().types.err\n                 }\n@@ -1617,95 +1333,33 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     pub fn ty_of_arg(&self,\n-                     rscope: &RegionScope,\n                      ty: &hir::Ty,\n                      expected_ty: Option<Ty<'tcx>>)\n                      -> Ty<'tcx>\n     {\n         match ty.node {\n             hir::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n             hir::TyInfer => self.ty_infer(ty.span),\n-            _ => self.ast_ty_to_ty(rscope, ty),\n+            _ => self.ast_ty_to_ty(ty),\n         }\n     }\n \n-    pub fn ty_of_method(&self,\n-                        sig: &hir::MethodSig,\n-                        opt_self_value_ty: Option<Ty<'tcx>>,\n-                        body: Option<hir::BodyId>,\n-                        anon_scope: Option<AnonTypeScope>)\n-                        -> &'tcx ty::BareFnTy<'tcx> {\n-        self.ty_of_method_or_bare_fn(sig.unsafety,\n-                                     sig.abi,\n-                                     opt_self_value_ty,\n-                                     &sig.decl,\n-                                     body,\n-                                     None,\n-                                     anon_scope)\n-    }\n-\n-    pub fn ty_of_bare_fn(&self,\n-                         unsafety: hir::Unsafety,\n-                         abi: abi::Abi,\n-                         decl: &hir::FnDecl,\n-                         body: hir::BodyId,\n-                         anon_scope: Option<AnonTypeScope>)\n-                         -> &'tcx ty::BareFnTy<'tcx> {\n-        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl, Some(body), None, anon_scope)\n-    }\n-\n-    fn ty_of_method_or_bare_fn(&self,\n-                               unsafety: hir::Unsafety,\n-                               abi: abi::Abi,\n-                               opt_self_value_ty: Option<Ty<'tcx>>,\n-                               decl: &hir::FnDecl,\n-                               body: Option<hir::BodyId>,\n-                               arg_anon_scope: Option<AnonTypeScope>,\n-                               ret_anon_scope: Option<AnonTypeScope>)\n-                               -> &'tcx ty::BareFnTy<'tcx>\n-    {\n-        debug!(\"ty_of_method_or_bare_fn\");\n-\n-        // New region names that appear inside of the arguments of the function\n-        // declaration are bound to that function type.\n-        let rb = MaybeWithAnonTypes::new(BindingRscope::new(), arg_anon_scope);\n+    pub fn ty_of_fn(&self,\n+                    unsafety: hir::Unsafety,\n+                    abi: abi::Abi,\n+                    decl: &hir::FnDecl)\n+                    -> &'tcx ty::BareFnTy<'tcx> {\n+        debug!(\"ty_of_fn\");\n \n         let input_tys: Vec<Ty> =\n-            decl.inputs.iter().map(|a| self.ty_of_arg(&rb, a, None)).collect();\n-\n-        let has_self = opt_self_value_ty.is_some();\n-        let explicit_self = opt_self_value_ty.map(|self_value_ty| {\n-            ExplicitSelf::determine(self_value_ty, input_tys[0])\n-        });\n-\n-        let implied_output_region = match explicit_self {\n-            // `implied_output_region` is the region that will be assumed for any\n-            // region parameters in the return type. In accordance with the rules for\n-            // lifetime elision, we can determine it in two ways. First (determined\n-            // here), if self is by-reference, then the implied output region is the\n-            // region of the self parameter.\n-            Some(ExplicitSelf::ByReference(region, _)) => Ok(*region),\n-\n-            // Second, if there was exactly one lifetime (either a substitution or a\n-            // reference) in the arguments, then any anonymous regions in the output\n-            // have that lifetime.\n-            _ => {\n-                let arg_tys = &input_tys[has_self as usize..];\n-                let arg_params = has_self as usize..input_tys.len();\n-                self.find_implied_output_region(arg_tys, body, arg_params)\n-\n-            }\n-        };\n+            decl.inputs.iter().map(|a| self.ty_of_arg(a, None)).collect();\n \n         let output_ty = match decl.output {\n-            hir::Return(ref output) =>\n-                self.convert_ty_with_lifetime_elision(implied_output_region,\n-                                                      &output,\n-                                                      ret_anon_scope),\n+            hir::Return(ref output) => self.ast_ty_to_ty(output),\n             hir::DefaultReturn(..) => self.tcx().mk_nil(),\n         };\n \n-        debug!(\"ty_of_method_or_bare_fn: output_ty={:?}\", output_ty);\n+        debug!(\"ty_of_fn: output_ty={:?}\", output_ty);\n \n         self.tcx().mk_bare_fn(ty::BareFnTy {\n             unsafety: unsafety,\n@@ -1728,10 +1382,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         debug!(\"ty_of_closure(expected_sig={:?})\",\n                expected_sig);\n \n-        // new region names that appear inside of the fn decl are bound to\n-        // that function type\n-        let rb = rscope::BindingRscope::new();\n-\n         let input_tys = decl.inputs.iter().enumerate().map(|(i, a)| {\n             let expected_arg_ty = expected_sig.as_ref().and_then(|e| {\n                 // no guarantee that the correct number of expected args\n@@ -1742,7 +1392,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     None\n                 }\n             });\n-            self.ty_of_arg(&rb, a, expected_arg_ty)\n+            self.ty_of_arg(a, expected_arg_ty)\n         });\n \n         let expected_ret_ty = expected_sig.as_ref().map(|e| e.output());\n@@ -1758,7 +1408,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 expected_ret_ty.unwrap(),\n             _ if is_infer => self.ty_infer(decl.output.span()),\n             hir::Return(ref output) =>\n-                self.ast_ty_to_ty(&rb, &output),\n+                self.ast_ty_to_ty(&output),\n             hir::DefaultReturn(..) => bug!(),\n         };\n \n@@ -1771,61 +1421,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    fn conv_object_ty_poly_trait_ref(&self,\n-        rscope: &RegionScope,\n-        span: Span,\n-        ast_bounds: &[hir::TyParamBound])\n-        -> Ty<'tcx>\n-    {\n-        let mut partitioned_bounds = partition_bounds(ast_bounds);\n-\n-        let trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n-            partitioned_bounds.trait_bounds.remove(0)\n-        } else {\n-            span_err!(self.tcx().sess, span, E0224,\n-                      \"at least one non-builtin trait is required for an object type\");\n-            return self.tcx().types.err;\n-        };\n-\n-        let trait_ref = &trait_bound.trait_ref;\n-        let trait_def_id = self.trait_def_id(trait_ref);\n-        self.trait_path_to_object_type(rscope,\n-                                       trait_ref.path.span,\n-                                       trait_def_id,\n-                                       trait_ref.ref_id,\n-                                       trait_ref.path.segments.last().unwrap(),\n-                                       span,\n-                                       partitioned_bounds)\n-    }\n-\n     /// Given the bounds on an object, determines what single region bound (if any) we can\n     /// use to summarize this type. The basic idea is that we will use the bound the user\n     /// provided, if they provided one, and otherwise search the supertypes of trait bounds\n     /// for region bounds. It may be that we can derive no bound at all, in which case\n     /// we return `None`.\n     fn compute_object_lifetime_bound(&self,\n         span: Span,\n-        explicit_region_bounds: &[&hir::Lifetime],\n         existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n         -> Option<&'tcx ty::Region> // if None, use the default\n     {\n         let tcx = self.tcx();\n \n-        debug!(\"compute_opt_region_bound(explicit_region_bounds={:?}, \\\n-               existential_predicates={:?})\",\n-               explicit_region_bounds,\n+        debug!(\"compute_opt_region_bound(existential_predicates={:?})\",\n                existential_predicates);\n \n-        if explicit_region_bounds.len() > 1 {\n-            span_err!(tcx.sess, explicit_region_bounds[1].span, E0226,\n-                \"only a single explicit lifetime bound is permitted\");\n-        }\n-\n-        if let Some(&r) = explicit_region_bounds.get(0) {\n-            // Explicitly specified region bound. Use that.\n-            return Some(ast_region_to_region(tcx, r));\n-        }\n-\n         if let Some(principal) = existential_predicates.principal() {\n             if let Err(ErrorReported) = self.ensure_super_predicates(span, principal.def_id()) {\n                 return Some(tcx.mk_region(ty::ReStatic));\n@@ -1861,18 +1471,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n }\n \n-pub struct PartitionedBounds<'a> {\n-    pub trait_bounds: Vec<&'a hir::PolyTraitRef>,\n-    pub region_bounds: Vec<&'a hir::Lifetime>,\n-}\n-\n /// Divides a list of general trait bounds into two groups: builtin bounds (Sync/Send) and the\n /// remaining general trait bounds.\n fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                         trait_bounds: Vec<&'b hir::PolyTraitRef>)\n+                                         trait_bounds: &'b [hir::PolyTraitRef])\n     -> (Vec<DefId>, Vec<&'b hir::PolyTraitRef>)\n {\n-    let (auto_traits, trait_bounds): (Vec<_>, _) = trait_bounds.into_iter().partition(|bound| {\n+    let (auto_traits, trait_bounds): (Vec<_>, _) = trait_bounds.iter().partition(|bound| {\n         match bound.trait_ref.path.def {\n             Def::Trait(trait_did) => {\n                 // Checks whether `trait_did` refers to one of the builtin\n@@ -1909,30 +1514,6 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     (auto_traits, trait_bounds)\n }\n \n-/// Divides a list of bounds from the AST into two groups: general trait bounds and region bounds\n-pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(ast_bounds: &'b [hir::TyParamBound])\n-    -> PartitionedBounds<'b>\n-{\n-    let mut region_bounds = Vec::new();\n-    let mut trait_bounds = Vec::new();\n-    for ast_bound in ast_bounds {\n-        match *ast_bound {\n-            hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n-                trait_bounds.push(b);\n-            }\n-            hir::TraitTyParamBound(_, hir::TraitBoundModifier::Maybe) => {}\n-            hir::RegionTyParamBound(ref l) => {\n-                region_bounds.push(l);\n-            }\n-        }\n-    }\n-\n-    PartitionedBounds {\n-        trait_bounds: trait_bounds,\n-        region_bounds: region_bounds,\n-    }\n-}\n-\n fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n                              ty_param_defs: &[ty::TypeParameterDef]) {\n     let accepted = ty_param_defs.len();\n@@ -2084,7 +1665,7 @@ impl<'tcx> ExplicitSelf<'tcx> {\n         fn count_modifiers(ty: Ty) -> usize {\n             match ty.sty {\n                 ty::TyRef(_, mt) => count_modifiers(mt.ty) + 1,\n-                ty::TyBox(t) => count_modifiers(t) + 1,\n+                ty::TyAdt(def, _) if def.is_box() => count_modifiers(ty.boxed_ty()) + 1,\n                 _ => 0,\n             }\n         }\n@@ -2097,7 +1678,7 @@ impl<'tcx> ExplicitSelf<'tcx> {\n         } else {\n             match self_arg_ty.sty {\n                 ty::TyRef(r, mt) => ExplicitSelf::ByReference(r, mt.mutbl),\n-                ty::TyBox(_) => ExplicitSelf::ByBox,\n+                ty::TyAdt(def, _) if def.is_box() => ExplicitSelf::ByBox,\n                 _ => ExplicitSelf::ByValue,\n             }\n         }"}, {"sha": "6215b4498dc684ee3a63454b1c8bf1d242abfc9f", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -288,7 +288,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                                tstr);\n                 }\n             }\n-            ty::TyBox(..) => {\n+            ty::TyAdt(def, ..) if def.is_box() => {\n                 match fcx.tcx.sess.codemap().span_to_snippet(self.cast_span) {\n                     Ok(s) => {\n                         err.span_suggestion(self.cast_span,\n@@ -348,12 +348,12 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         } else if self.try_coercion_cast(fcx) {\n             self.trivial_cast_lint(fcx);\n             debug!(\" -> CoercionCast\");\n-            fcx.tcx.cast_kinds.borrow_mut().insert(self.expr.id, CastKind::CoercionCast);\n+            fcx.tables.borrow_mut().cast_kinds.insert(self.expr.id, CastKind::CoercionCast);\n         } else {\n             match self.do_check(fcx) {\n                 Ok(k) => {\n                     debug!(\" -> {:?}\", k);\n-                    fcx.tcx.cast_kinds.borrow_mut().insert(self.expr.id, k);\n+                    fcx.tables.borrow_mut().cast_kinds.insert(self.expr.id, k);\n                 }\n                 Err(e) => self.report_cast_error(fcx, e),\n             };"}, {"sha": "34aa4eda772ada2b1904be85f40ca05612a29648", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -448,7 +448,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n             Ok(())\n         }\n \n-        ty::TyBox(ity) | ty::TyArray(ity, _) | ty::TySlice(ity) => {\n+        ty::TyArray(ity, _) | ty::TySlice(ity) => {\n             // single-element containers, behave like their element\n             iterate_over_potentially_unsafe_regions_in_type(\n                 cx, context, ity, depth+1)"}, {"sha": "300caca30fec8c12927dc4f405e30a2fdab8b627", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -391,11 +391,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             ty::TyAdt(def, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(def.did);\n             }\n-            ty::TyBox(_) => {\n-                if let Some(box_did) = self.tcx.lang_items.owned_box() {\n-                    self.assemble_inherent_impl_candidates_for_type(box_did);\n-                }\n-            }\n             ty::TyParam(p) => {\n                 self.assemble_inherent_candidates_from_param(self_ty, p);\n             }"}, {"sha": "c435f9341253e92920ff621ecc13e8fa26486eb2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 42, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -80,7 +80,7 @@ pub use self::Expectation::*;\n pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::TupleArgumentsFlag::*;\n \n-use astconv::{AstConv, ast_region_to_region};\n+use astconv::AstConv;\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n use hir::def::{Def, CtorKind};\n@@ -97,7 +97,6 @@ use rustc::ty::adjustment;\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n use rustc::ty::util::{Representability, IntTypeExt};\n use require_c_abi_if_variadic;\n-use rscope::{ElisionFailureInfo, RegionScope};\n use session::{Session, CompileResult};\n use CrateCtxt;\n use TypeAndSubsts;\n@@ -1410,6 +1409,15 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         Ok(r)\n     }\n \n+    fn re_infer(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n+                -> Option<&'tcx ty::Region> {\n+        let v = match def {\n+            Some(def) => infer::EarlyBoundRegion(span, def.name),\n+            None => infer::MiscVariable(span)\n+        };\n+        Some(self.next_region_var(v))\n+    }\n+\n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         self.next_ty_var(TypeVariableOrigin::TypeInference(span))\n     }\n@@ -1450,30 +1458,6 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> RegionScope for FnCtxt<'a, 'gcx, 'tcx> {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n-        // RFC #599 specifies that object lifetime defaults take\n-        // precedence over other defaults. But within a fn body we\n-        // don't have a *default* region, rather we use inference to\n-        // find the *correct* region, which is strictly more general\n-        // (and anyway, within a fn body the right region may not even\n-        // be something the user can write explicitly, since it might\n-        // be some expression).\n-        *self.next_region_var(infer::MiscVariable(span))\n-    }\n-\n-    fn anon_regions(&self, span: Span, count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n-        Ok((0..count).map(|_| {\n-            *self.next_region_var(infer::MiscVariable(span))\n-        }).collect())\n-    }\n-}\n-\n /// Controls whether the arguments are tupled. This is used for the call\n /// operator.\n ///\n@@ -1830,7 +1814,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn to_ty(&self, ast_t: &hir::Ty) -> Ty<'tcx> {\n-        let t = AstConv::ast_ty_to_ty(self, self, ast_t);\n+        let t = AstConv::ast_ty_to_ty(self, ast_t);\n         self.register_wf_obligation(t, ast_t.span, traits::MiscObligation);\n         t\n     }\n@@ -3306,16 +3290,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             Def::Struct(..) | Def::Union(..) | Def::TyAlias(..) |\n             Def::AssociatedTy(..) | Def::SelfTy(..) => {\n-                match def {\n-                    Def::AssociatedTy(..) | Def::SelfTy(..)\n-                            if !self.tcx.sess.features.borrow().more_struct_aliases => {\n-                        emit_feature_err(&self.tcx.sess.parse_sess,\n-                                         \"more_struct_aliases\", path_span, GateIssue::Language,\n-                                         \"`Self` and associated types in struct \\\n-                                          expressions and patterns are unstable\");\n-                    }\n-                    _ => {}\n-                }\n                 match ty.sty {\n                     ty::TyAdt(adt, substs) if !adt.is_enum() => {\n                         Some((adt.struct_variant(), adt.did, substs))\n@@ -3464,7 +3438,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprBox(ref subexpr) => {\n             let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n                 match ty.sty {\n-                    ty::TyBox(ty) => Expectation::rvalue_hint(self, ty),\n+                    ty::TyAdt(def, _) if def.is_box()\n+                        => Expectation::rvalue_hint(self, ty.boxed_ty()),\n                     _ => NoExpectation\n                 }\n             });\n@@ -3984,7 +3959,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match *qpath {\n             hir::QPath::Resolved(ref maybe_qself, ref path) => {\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n-                let ty = AstConv::def_to_ty(self, self, opt_self_ty, path, node_id, true);\n+                let ty = AstConv::def_to_ty(self, opt_self_ty, path, true);\n                 (path.def, ty)\n             }\n             hir::QPath::TypeRelative(ref qself, ref segment) => {\n@@ -4416,10 +4391,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 None => &[]\n             };\n \n-            if let Some(ast_lifetime) = lifetimes.get(i) {\n-                ast_region_to_region(self.tcx, ast_lifetime)\n+            if let Some(lifetime) = lifetimes.get(i) {\n+                AstConv::ast_region_to_region(self, lifetime, Some(def))\n             } else {\n-                self.region_var_for_def(span, def)\n+                self.re_infer(span, Some(def)).unwrap()\n             }\n         }, |def, substs| {\n             let mut i = def.index as usize;"}, {"sha": "0dcdab07e6fc8a259727e571ae5f37f87a30f11c", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 71, "deletions": 4, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -12,8 +12,10 @@\n \n use super::FnCtxt;\n use hir::def_id::DefId;\n-use rustc::ty::{Ty, TypeFoldable, PreferMutLvalue};\n+use rustc::ty::{Ty, TypeFoldable, PreferMutLvalue, TypeVariants};\n+use rustc::ty::TypeVariants::{TyStr, TyRef};\n use rustc::infer::type_variable::TypeVariableOrigin;\n+use errors;\n use syntax::ast;\n use syntax::symbol::Symbol;\n use rustc::hir;\n@@ -204,6 +206,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             \"binary operation `{}` cannot be applied to type `{}`\",\n                             op.node.as_str(),\n                             lhs_ty);\n+\n+                        if let TypeVariants::TyRef(_, ref ty_mut) = lhs_ty.sty {\n+                            if !self.infcx.type_moves_by_default(ty_mut.ty, lhs_expr.span) &&\n+                                self.lookup_op_method(expr, ty_mut.ty, vec![rhs_ty_var],\n+                                    Symbol::intern(name), trait_def_id,\n+                                    lhs_expr).is_ok() {\n+                                err.span_note(\n+                                    lhs_expr.span,\n+                                    &format!(\n+                                        \"this is a reference of type that `{}` can be applied to, \\\n+                                        you need to dereference this variable once for this \\\n+                                        operation to work\",\n+                                    op.node.as_str()));\n+                            }\n+                        }\n+\n                         let missing_trait = match op.node {\n                             hir::BiAdd    => Some(\"std::ops::Add\"),\n                             hir::BiSub    => Some(\"std::ops::Sub\"),\n@@ -221,9 +239,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         };\n \n                         if let Some(missing_trait) = missing_trait {\n-                            span_note!(&mut err, lhs_expr.span,\n-                                       \"an implementation of `{}` might be missing for `{}`\",\n-                                        missing_trait, lhs_ty);\n+                            if missing_trait == \"std::ops::Add\" &&\n+                                self.check_str_addition(expr, lhs_expr, lhs_ty,\n+                                                         rhs_expr, rhs_ty_var, &mut err) {\n+                                // This has nothing here because it means we did string\n+                                // concatenation (e.g. \"Hello \" + \"World!\"). This means\n+                                // we don't want the span in the else clause to be emmitted\n+                            } else {\n+                                span_note!(&mut err, lhs_expr.span,\n+                                            \"an implementation of `{}` might be missing for `{}`\",\n+                                            missing_trait, lhs_ty);\n+                            }\n                         }\n                         err.emit();\n                     }\n@@ -238,6 +264,47 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         (rhs_ty_var, return_ty)\n     }\n \n+    fn check_str_addition(&self,\n+                          expr: &'gcx hir::Expr,\n+                          lhs_expr: &'gcx hir::Expr,\n+                          lhs_ty: Ty<'tcx>,\n+                          rhs_expr: &'gcx hir::Expr,\n+                          rhs_ty_var: Ty<'tcx>,\n+                          mut err: &mut errors::DiagnosticBuilder) -> bool {\n+        // If this function returns false it means we use it to make sure we print\n+        // out the an \"implementation of span_note!\" above where this function is\n+        // called and if true we don't.\n+        let mut is_string_addition = false;\n+        let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n+        if let TyRef(_, l_ty) = lhs_ty.sty {\n+            if let TyRef(_, r_ty) = rhs_ty.sty {\n+                if l_ty.ty.sty == TyStr && r_ty.ty.sty == TyStr {\n+                    span_note!(&mut err, lhs_expr.span,\n+                            \"`+` can't be used to concatenate two `&str` strings\");\n+                    let codemap = self.tcx.sess.codemap();\n+                    let suggestion =\n+                        match (codemap.span_to_snippet(lhs_expr.span),\n+                                codemap.span_to_snippet(rhs_expr.span)) {\n+                            (Ok(lstring), Ok(rstring)) =>\n+                                format!(\"{}.to_owned() + {}\", lstring, rstring),\n+                            _ => format!(\"<expression>\")\n+                        };\n+                    err.span_suggestion(expr.span,\n+                        &format!(\"to_owned() can be used to create an owned `String` \\\n+                                  from a string reference. String concatenation \\\n+                                  appends the string on the right to the string \\\n+                                  on the left and may require reallocation. This \\\n+                                  requires ownership of the string on the left.\"), suggestion);\n+                    is_string_addition = true;\n+                }\n+\n+            }\n+\n+        }\n+\n+        is_string_addition\n+    }\n+\n     pub fn check_user_unop(&self,\n                            op_str: &str,\n                            mname: &str,"}, {"sha": "d84e9d3fd3731d642efee92e57d2565ef30badc2", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -815,9 +815,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 self.type_must_outlive(infer::RelateObjectBound(cast_expr.span), from_ty, r);\n             }\n \n-            /*From:*/ (&ty::TyBox(from_referent_ty),\n-            /*To:  */  &ty::TyBox(to_referent_ty)) => {\n-                self.walk_cast(cast_expr, from_referent_ty, to_referent_ty);\n+            /*From:*/ (&ty::TyAdt(from_def, _),\n+            /*To:  */  &ty::TyAdt(to_def, _)) if from_def.is_box() && to_def.is_box() => {\n+                self.walk_cast(cast_expr, from_ty.boxed_ty(), to_ty.boxed_ty());\n             }\n \n             _ => { }"}, {"sha": "7f82d7829ce52d7e700ff06bce99f8552f6bb2c2", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -51,6 +51,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_anon_types();\n         wbcx.visit_deferred_obligations(item_id);\n         wbcx.visit_type_nodes();\n+        wbcx.visit_cast_types();\n \n         let tables = self.tcx.alloc_tables(wbcx.tables);\n         self.tcx.tables.borrow_mut().insert(item_def_id, tables);\n@@ -291,6 +292,15 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn visit_cast_types(&mut self) {\n+        if self.fcx.writeback_errors.get() {\n+            return\n+        }\n+\n+        self.tables.cast_kinds.extend(\n+            self.fcx.tables.borrow().cast_kinds.iter().map(|(&key, &value)| (key, value)));\n+    }\n+\n     fn visit_anon_types(&self) {\n         if self.fcx.writeback_errors.get() {\n             return"}, {"sha": "96875fce468d2e34473ddc0c2a7b25c37e3755de", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -220,8 +220,6 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             (mt_a.ty, mt_b.ty, unsize_trait, None)\n         };\n         let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n-            (&ty::TyBox(a), &ty::TyBox(b)) => (a, b, unsize_trait, None),\n-\n             (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n                 infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n                 check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))"}, {"sha": "e9c710d2fec4c38ca1173e2e302cb620f52102f5", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -21,7 +21,7 @@ use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n use rustc::ty::{TyRef, TyAdt, TyDynamic, TyNever, TyTuple};\n use rustc::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n-use rustc::ty::{TyUint, TyClosure, TyBox, TyFnDef, TyFnPtr};\n+use rustc::ty::{TyUint, TyClosure, TyFnDef, TyFnPtr};\n use rustc::ty::{TyProjection, TyAnon};\n use CrateCtxt;\n use syntax_pos::Span;\n@@ -61,8 +61,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n             TyDynamic(ref t, ..) => t.principal().map(|p| p.def_id()),\n \n-            TyBox(_) => self.tcx.lang_items.owned_box(),\n-\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) | TyStr | TyArray(..) |\n             TySlice(..) | TyFnDef(..) | TyFnPtr(_) | TyTuple(..) | TyParam(..) | TyError |\n             TyNever | TyRawPtr(_) | TyRef(..) | TyProjection(..) => None,"}, {"sha": "9ef231499df5145c1fc0036624c60f769e9c4f4a", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -91,12 +91,6 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                     ty::TyDynamic(ref data, ..) if data.principal().is_some() => {\n                         self.check_def_id(item, data.principal().unwrap().def_id());\n                     }\n-                    ty::TyBox(..) => {\n-                        match self.tcx.lang_items.require_owned_box() {\n-                            Ok(trait_id) => self.check_def_id(item, trait_id),\n-                            Err(msg) => self.tcx.sess.span_fatal(item.span, &msg),\n-                        }\n-                    }\n                     ty::TyChar => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.char_impl(),\n@@ -263,6 +257,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                             .span_label(item.span, &format!(\"impl doesn't use types inside crate\"))\n                             .note(&format!(\"the impl does not reference any types defined in \\\n                                             this crate\"))\n+                            .note(\"define and implement a trait or new type instead\")\n                             .emit();\n                         return;\n                     }\n@@ -320,7 +315,6 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                     let self_ty = trait_ref.self_ty();\n                     let opt_self_def_id = match self_ty.sty {\n                         ty::TyAdt(self_def, _) => Some(self_def.did),\n-                        ty::TyBox(..) => self.tcx.lang_items.owned_box(),\n                         _ => None,\n                     };\n "}, {"sha": "bbd0c8058151f2b6669efce9a17beb374c52330a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 60, "deletions": 192, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -57,7 +57,7 @@ There are some shortcomings in this design:\n \n */\n \n-use astconv::{AstConv, ast_region_to_region, Bounds, PartitionedBounds, partition_bounds};\n+use astconv::{AstConv, Bounds};\n use lint;\n use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n@@ -68,10 +68,9 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n-use rscope::*;\n use rustc::dep_graph::DepNode;\n use util::common::{ErrorReported, MemoizationMap};\n-use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n+use util::nodemap::{NodeMap, FxHashMap};\n use CrateCtxt;\n \n use rustc_const_math::ConstInt;\n@@ -373,8 +372,8 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n }\n \n impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &hir::Ty) -> Ty<'tcx> {\n-        AstConv::ast_ty_to_ty(self, rs, ast_ty)\n+    fn to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n+        AstConv::ast_ty_to_ty(self, ast_ty)\n     }\n }\n \n@@ -437,6 +436,11 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         None\n     }\n \n+    fn re_infer(&self, _span: Span, _def: Option<&ty::RegionParameterDef>)\n+                -> Option<&'tcx ty::Region> {\n+        None\n+    }\n+\n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         struct_span_err!(\n             self.tcx().sess,\n@@ -626,7 +630,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            field: &hir::StructField,\n                            ty_f: &'tcx ty::FieldDef)\n {\n-    let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &field.ty);\n+    let tt = ccx.icx(struct_predicates).to_ty(&field.ty);\n     ccx.tcx.item_types.borrow_mut().insert(ty_f.did, tt);\n \n     let def_id = ccx.tcx.hir.local_def_id(field.id);\n@@ -636,30 +640,17 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                            container: AssociatedItemContainer,\n                             id: ast::NodeId,\n                             sig: &hir::MethodSig,\n-                            untransformed_rcvr_ty: Ty<'tcx>,\n-                            body: Option<hir::BodyId>,\n                             rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,) {\n     let def_id = ccx.tcx.hir.local_def_id(id);\n     let ty_generics = generics_of_def_id(ccx, def_id);\n \n     let ty_generic_predicates =\n         ty_generic_predicates(ccx, &sig.generics, ty_generics.parent, vec![], false);\n \n-    let anon_scope = match container {\n-        ImplContainer(_) => Some(AnonTypeScope::new(def_id)),\n-        TraitContainer(_) => None\n-    };\n-    let assoc_item = ccx.tcx.associated_item(def_id);\n-    let self_value_ty = if assoc_item.method_has_self_argument {\n-        Some(untransformed_rcvr_ty)\n-    } else {\n-        None\n-    };\n-    let fty = AstConv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                                    sig, self_value_ty, body, anon_scope);\n+    let fty = AstConv::ty_of_fn(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n+                                sig.unsafety, sig.abi, &sig.decl);\n \n     let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                                 ccx.tcx.hir.span(id), def_id);\n@@ -765,7 +756,6 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         hir::ItemDefaultImpl(_, ref ast_trait_ref) => {\n             let trait_ref =\n                 AstConv::instantiate_mono_trait_ref(&ccx.icx(&()),\n-                                                    &ExplicitRscope,\n                                                     ast_trait_ref,\n                                                     tcx.mk_self_type());\n \n@@ -787,12 +777,11 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n-            let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &selfty);\n+            let selfty = ccx.icx(&ty_predicates).to_ty(&selfty);\n             tcx.item_types.borrow_mut().insert(def_id, selfty);\n \n             let trait_ref = opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 AstConv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n-                                                    &ExplicitRscope,\n                                                     ast_trait_ref,\n                                                     selfty)\n             });\n@@ -858,8 +847,7 @@ fn convert_trait_item(ccx: &CrateCtxt, trait_item: &hir::TraitItem) {\n         hir::TraitItemKind::Const(ref ty, _) => {\n             let const_def_id = ccx.tcx.hir.local_def_id(trait_item.id);\n             generics_of_def_id(ccx, const_def_id);\n-            let ty = ccx.icx(&trait_predicates)\n-                        .to_ty(&ExplicitRscope, &ty);\n+            let ty = ccx.icx(&trait_predicates).to_ty(&ty);\n             tcx.item_types.borrow_mut().insert(const_def_id, ty);\n             convert_associated_const(ccx, TraitContainer(trait_def_id),\n                                      trait_item.id, ty);\n@@ -870,20 +858,14 @@ fn convert_trait_item(ccx: &CrateCtxt, trait_item: &hir::TraitItem) {\n             generics_of_def_id(ccx, type_def_id);\n \n             let typ = opt_ty.as_ref().map({\n-                |ty| ccx.icx(&trait_predicates).to_ty(&ExplicitRscope, &ty)\n+                |ty| ccx.icx(&trait_predicates).to_ty(&ty)\n             });\n \n             convert_associated_type(ccx, TraitContainer(trait_def_id), trait_item.id, typ);\n         }\n \n-        hir::TraitItemKind::Method(ref sig, ref method) => {\n-            let body = match *method {\n-                hir::TraitMethod::Required(_) => None,\n-                hir::TraitMethod::Provided(body) => Some(body)\n-            };\n-            convert_method(ccx, TraitContainer(trait_def_id),\n-                           trait_item.id, sig, tcx.mk_self_type(),\n-                           body, &trait_predicates);\n+        hir::TraitItemKind::Method(ref sig, _) => {\n+            convert_method(ccx, trait_item.id, sig, &trait_predicates);\n         }\n     }\n }\n@@ -896,14 +878,12 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n     let impl_def_id = tcx.hir.get_parent_did(impl_item.id);\n     let impl_predicates = tcx.item_predicates(impl_def_id);\n     let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n-    let impl_self_ty = tcx.item_type(impl_def_id);\n \n     match impl_item.node {\n         hir::ImplItemKind::Const(ref ty, _) => {\n             let const_def_id = ccx.tcx.hir.local_def_id(impl_item.id);\n             generics_of_def_id(ccx, const_def_id);\n-            let ty = ccx.icx(&impl_predicates)\n-                        .to_ty(&ExplicitRscope, &ty);\n+            let ty = ccx.icx(&impl_predicates).to_ty(&ty);\n             tcx.item_types.borrow_mut().insert(const_def_id, ty);\n             convert_associated_const(ccx, ImplContainer(impl_def_id),\n                                      impl_item.id, ty);\n@@ -918,15 +898,13 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n                           \"associated types are not allowed in inherent impls\");\n             }\n \n-            let typ = ccx.icx(&impl_predicates).to_ty(&ExplicitRscope, ty);\n+            let typ = ccx.icx(&impl_predicates).to_ty(ty);\n \n             convert_associated_type(ccx, ImplContainer(impl_def_id), impl_item.id, Some(typ));\n         }\n \n-        hir::ImplItemKind::Method(ref sig, body) => {\n-            convert_method(ccx, ImplContainer(impl_def_id),\n-                           impl_item.id, sig, impl_self_ty,\n-                           Some(body), &impl_predicates);\n+        hir::ImplItemKind::Method(ref sig, _) => {\n+            convert_method(ccx, impl_item.id, sig, &impl_predicates);\n         }\n     }\n }\n@@ -1197,7 +1175,6 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n                                           self_param_ty,\n                                           bounds,\n                                           SizedByDefault::No,\n-                                          None,\n                                           item.span);\n \n         let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n@@ -1334,7 +1311,6 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n                                         assoc_ty,\n                                         bounds,\n                                         SizedByDefault::Yes,\n-                                        None,\n                                         trait_item.span);\n \n             bounds.predicates(ccx.tcx, assoc_ty).into_iter()\n@@ -1429,7 +1405,6 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             def_id: tcx.hir.local_def_id(param_id),\n                             default_def_id: tcx.hir.local_def_id(parent),\n                             default: None,\n-                            object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n                             pure_wrt_drop: false,\n                         };\n                         tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n@@ -1471,9 +1446,6 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 name: l.lifetime.name,\n                 index: own_start + i as u32,\n                 def_id: tcx.hir.local_def_id(l.lifetime.id),\n-                bounds: l.bounds.iter().map(|l| {\n-                    ast_region_to_region(tcx, l)\n-                }).collect(),\n                 pure_wrt_drop: l.pure_wrt_drop,\n             }\n         }).collect::<Vec<_>>();\n@@ -1482,7 +1454,7 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let type_start = own_start + regions.len() as u32;\n         let types = ast_generics.ty_params.iter().enumerate().map(|(i, p)| {\n             let i = type_start + i as u32;\n-            get_or_create_type_parameter_def(ccx, ast_generics, i, p, allow_defaults)\n+            get_or_create_type_parameter_def(ccx, i, p, allow_defaults)\n         });\n         let mut types: Vec<_> = opt_self.into_iter().chain(types).collect();\n \n@@ -1497,24 +1469,11 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     def_id: def_id,\n                     default_def_id: parent_def_id.unwrap(),\n                     default: None,\n-                    object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n                     pure_wrt_drop: false,\n                }));\n             });\n         }\n \n-        // Debugging aid.\n-        if tcx.has_attr(def_id, \"rustc_object_lifetime_default\") {\n-            let object_lifetime_default_reprs: String =\n-                types.iter().map(|t| {\n-                    match t.object_lifetime_default {\n-                        ty::ObjectLifetimeDefault::Specific(r) => r.to_string(),\n-                        d => format!(\"{:?}\", d),\n-                    }\n-                }).collect::<Vec<String>>().join(\",\");\n-            tcx.sess.span_err(tcx.hir.span(node_id), &object_lifetime_default_reprs);\n-        }\n-\n         tcx.alloc_generics(ty::Generics {\n             parent: parent_def_id,\n             parent_regions: parent_regions,\n@@ -1545,16 +1504,15 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             NodeItem(item) => {\n                 match item.node {\n                     ItemStatic(ref t, ..) | ItemConst(ref t, _) => {\n-                        ccx.icx(&()).to_ty(&StaticRscope::new(&ccx.tcx), &t)\n+                        ccx.icx(&()).to_ty(&t)\n                     }\n-                    ItemFn(ref decl, unsafety, _, abi, ref generics, body) => {\n-                        let tofd = AstConv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl,\n-                                                          body, Some(AnonTypeScope::new(def_id)));\n+                    ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n+                        let tofd = AstConv::ty_of_fn(&ccx.icx(generics), unsafety, abi, &decl);\n                         let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n                         ccx.tcx.mk_fn_def(def_id, substs, tofd)\n                     }\n                     ItemTy(ref t, ref generics) => {\n-                        ccx.icx(generics).to_ty(&ExplicitRscope, &t)\n+                        ccx.icx(generics).to_ty(&t)\n                     }\n                     ItemEnum(ref ei, ref generics) => {\n                         let def = convert_enum_def(ccx, item, ei);\n@@ -1595,7 +1553,7 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             fn_decl, generics, abi)\n                     }\n                     ForeignItemStatic(ref t, _) => {\n-                        ccx.icx(&()).to_ty(&ExplicitRscope, t)\n+                        ccx.icx(&()).to_ty(t)\n                     }\n                 }\n             }\n@@ -1765,7 +1723,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             name: param.lifetime.name\n         }));\n         for bound in &param.bounds {\n-            let bound_region = ast_region_to_region(ccx.tcx, bound);\n+            let bound_region = AstConv::ast_region_to_region(&ccx.icx(&()), bound, None);\n             let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n             predicates.push(outlives.to_predicate());\n         }\n@@ -1781,7 +1739,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                     param_ty,\n                                     &param.bounds,\n                                     SizedByDefault::Yes,\n-                                    None,\n                                     param.span);\n         predicates.extend(bounds.predicates(ccx.tcx, param_ty));\n     }\n@@ -1792,7 +1749,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         match predicate {\n             &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n                 let ty = AstConv::ast_ty_to_ty(&ccx.icx(&(base_predicates, ast_generics)),\n-                                               &ExplicitRscope,\n                                                &bound_pred.bounded_ty);\n \n                 for bound in bound_pred.bounds.iter() {\n@@ -1803,7 +1759,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                             let trait_ref =\n                                 AstConv::instantiate_poly_trait_ref(&ccx.icx(&(base_predicates,\n                                                                                ast_generics)),\n-                                                                    &ExplicitRscope,\n                                                                     poly_trait_ref,\n                                                                     ty,\n                                                                     &mut projections);\n@@ -1816,7 +1771,9 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                         }\n \n                         &hir::TyParamBound::RegionTyParamBound(ref lifetime) => {\n-                            let region = ast_region_to_region(tcx, lifetime);\n+                            let region = AstConv::ast_region_to_region(&ccx.icx(&()),\n+                                                                       lifetime,\n+                                                                       None);\n                             let pred = ty::Binder(ty::OutlivesPredicate(ty, region));\n                             predicates.push(ty::Predicate::TypeOutlives(pred))\n                         }\n@@ -1825,19 +1782,16 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             }\n \n             &hir::WherePredicate::RegionPredicate(ref region_pred) => {\n-                let r1 = ast_region_to_region(tcx, &region_pred.lifetime);\n+                let r1 = AstConv::ast_region_to_region(&ccx.icx(&()), &region_pred.lifetime, None);\n                 for bound in &region_pred.bounds {\n-                    let r2 = ast_region_to_region(tcx, bound);\n+                    let r2 = AstConv::ast_region_to_region(&ccx.icx(&()), bound, None);\n                     let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n                     predicates.push(ty::Predicate::RegionOutlives(pred))\n                 }\n             }\n \n-            &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n+            &hir::WherePredicate::EqPredicate(..) => {\n                 // FIXME(#20041)\n-                span_bug!(eq_pred.span,\n-                         \"Equality constraints are not yet \\\n-                          implemented (#20041)\")\n             }\n         }\n     }\n@@ -1849,7 +1803,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n }\n \n fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                             ast_generics: &hir::Generics,\n                                              index: u32,\n                                              param: &hir::TyParam,\n                                              allow_defaults: bool)\n@@ -1862,11 +1815,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n \n     let default =\n-        param.default.as_ref().map(|def| ccx.icx(&()).to_ty(&ExplicitRscope, def));\n-\n-    let object_lifetime_default =\n-        compute_object_lifetime_default(ccx, param.id,\n-                                        &param.bounds, &ast_generics.where_clause);\n+        param.default.as_ref().map(|def| ccx.icx(&()).to_ty(def));\n \n     let parent = tcx.hir.get_parent(param.id);\n \n@@ -1887,7 +1836,6 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         def_id: ccx.tcx.hir.local_def_id(param.id),\n         default_def_id: ccx.tcx.hir.local_def_id(parent),\n         default: default,\n-        object_lifetime_default: object_lifetime_default,\n         pure_wrt_drop: param.pure_wrt_drop,\n     };\n \n@@ -1902,75 +1850,6 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     def\n }\n \n-/// Scan the bounds and where-clauses on a parameter to extract bounds\n-/// of the form `T:'a` so as to determine the `ObjectLifetimeDefault`.\n-/// This runs as part of computing the minimal type scheme, so we\n-/// intentionally avoid just asking astconv to convert all the where\n-/// clauses into a `ty::Predicate`. This is because that could induce\n-/// artificial cycles.\n-fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                            param_id: ast::NodeId,\n-                                            param_bounds: &[hir::TyParamBound],\n-                                            where_clause: &hir::WhereClause)\n-                                            -> ty::ObjectLifetimeDefault<'tcx>\n-{\n-    let inline_bounds = from_bounds(ccx, param_bounds);\n-    let where_bounds = from_predicates(ccx, param_id, &where_clause.predicates);\n-    let all_bounds: FxHashSet<_> = inline_bounds.into_iter()\n-                                                .chain(where_bounds)\n-                                                .collect();\n-    return if all_bounds.len() > 1 {\n-        ty::ObjectLifetimeDefault::Ambiguous\n-    } else if all_bounds.len() == 0 {\n-        ty::ObjectLifetimeDefault::BaseDefault\n-    } else {\n-        ty::ObjectLifetimeDefault::Specific(\n-            all_bounds.into_iter().next().unwrap())\n-    };\n-\n-    fn from_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                            bounds: &[hir::TyParamBound])\n-                            -> Vec<&'tcx ty::Region>\n-    {\n-        bounds.iter()\n-              .filter_map(|bound| {\n-                  match *bound {\n-                      hir::TraitTyParamBound(..) =>\n-                          None,\n-                      hir::RegionTyParamBound(ref lifetime) =>\n-                          Some(ast_region_to_region(ccx.tcx, lifetime)),\n-                  }\n-              })\n-              .collect()\n-    }\n-\n-    fn from_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                param_id: ast::NodeId,\n-                                predicates: &[hir::WherePredicate])\n-                                -> Vec<&'tcx ty::Region>\n-    {\n-        predicates.iter()\n-                  .flat_map(|predicate| {\n-                      match *predicate {\n-                          hir::WherePredicate::BoundPredicate(ref data) => {\n-                              if data.bound_lifetimes.is_empty() &&\n-                                  is_param(ccx.tcx, &data.bounded_ty, param_id)\n-                              {\n-                                  from_bounds(ccx, &data.bounds).into_iter()\n-                              } else {\n-                                  Vec::new().into_iter()\n-                              }\n-                          }\n-                          hir::WherePredicate::RegionPredicate(..) |\n-                          hir::WherePredicate::EqPredicate(..) => {\n-                              Vec::new().into_iter()\n-                          }\n-                      }\n-                  })\n-                  .collect()\n-    }\n-}\n-\n pub enum SizedByDefault { Yes, No, }\n \n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n@@ -1980,28 +1859,33 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                                         param_ty: ty::Ty<'tcx>,\n                                         ast_bounds: &[hir::TyParamBound],\n                                         sized_by_default: SizedByDefault,\n-                                        anon_scope: Option<AnonTypeScope>,\n                                         span: Span)\n                                         -> Bounds<'tcx>\n {\n-    let tcx = astconv.tcx();\n-    let PartitionedBounds {\n-        trait_bounds,\n-        region_bounds\n-    } = partition_bounds(&ast_bounds);\n+    let mut region_bounds = vec![];\n+    let mut trait_bounds = vec![];\n+    for ast_bound in ast_bounds {\n+        match *ast_bound {\n+            hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n+                trait_bounds.push(b);\n+            }\n+            hir::TraitTyParamBound(_, hir::TraitBoundModifier::Maybe) => {}\n+            hir::RegionTyParamBound(ref l) => {\n+                region_bounds.push(l);\n+            }\n+        }\n+    }\n \n     let mut projection_bounds = vec![];\n \n-    let rscope = MaybeWithAnonTypes::new(ExplicitRscope, anon_scope);\n     let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n-        astconv.instantiate_poly_trait_ref(&rscope,\n-                                           bound,\n+        astconv.instantiate_poly_trait_ref(bound,\n                                            param_ty,\n                                            &mut projection_bounds)\n     }).collect();\n \n     let region_bounds = region_bounds.into_iter().map(|r| {\n-        ast_region_to_region(tcx, r)\n+        astconv.ast_region_to_region(r, None)\n     }).collect();\n \n     trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n@@ -2033,8 +1917,7 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n     match *bound {\n         hir::TraitTyParamBound(ref tr, hir::TraitBoundModifier::None) => {\n             let mut projections = Vec::new();\n-            let pred = astconv.instantiate_poly_trait_ref(&ExplicitRscope,\n-                                                          tr,\n+            let pred = astconv.instantiate_poly_trait_ref(tr,\n                                                           param_ty,\n                                                           &mut projections);\n             projections.into_iter()\n@@ -2043,7 +1926,7 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                        .collect()\n         }\n         hir::RegionTyParamBound(ref lifetime) => {\n-            let region = ast_region_to_region(astconv.tcx(), lifetime);\n+            let region = astconv.ast_region_to_region(lifetime, None);\n             let pred = ty::Binder(ty::OutlivesPredicate(param_ty, region));\n             vec![ty::Predicate::TypeOutlives(pred)]\n         }\n@@ -2061,18 +1944,7 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n     abi: abi::Abi)\n     -> Ty<'tcx>\n {\n-    let rb = BindingRscope::new();\n-    let input_tys = decl.inputs\n-                        .iter()\n-                        .map(|a| AstConv::ty_of_arg(&ccx.icx(ast_generics), &rb, a, None))\n-                        .collect::<Vec<_>>();\n-\n-    let output = match decl.output {\n-        hir::Return(ref ty) =>\n-            AstConv::ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &ty),\n-        hir::DefaultReturn(..) =>\n-            ccx.tcx.mk_nil(),\n-    };\n+    let fty = AstConv::ty_of_fn(&ccx.icx(ast_generics), hir::Unsafety::Unsafe, abi, decl);\n \n     // feature gate SIMD types in FFI, since I (huonw) am not sure the\n     // ABIs are handled at all correctly.\n@@ -2088,27 +1960,23 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n                     .emit();\n             }\n         };\n-        for (input, ty) in decl.inputs.iter().zip(&input_tys) {\n+        for (input, ty) in decl.inputs.iter().zip(*fty.sig.inputs().skip_binder()) {\n             check(&input, ty)\n         }\n         if let hir::Return(ref ty) = decl.output {\n-            check(&ty, output)\n+            check(&ty, *fty.sig.output().skip_binder())\n         }\n     }\n \n     let id = ccx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let substs = mk_item_substs(&ccx.icx(ast_generics), ccx.tcx.hir.span(id), def_id);\n-    ccx.tcx.mk_fn_def(def_id, substs, ccx.tcx.mk_bare_fn(ty::BareFnTy {\n-        abi: abi,\n-        unsafety: hir::Unsafety::Unsafe,\n-        sig: ty::Binder(ccx.tcx.mk_fn_sig(input_tys.into_iter(), output, decl.variadic)),\n-    }))\n+    ccx.tcx.mk_fn_def(def_id, substs, fty)\n }\n \n-pub fn mk_item_substs<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n-                                        span: Span,\n-                                        def_id: DefId)\n-                                        -> &'tcx Substs<'tcx> {\n+fn mk_item_substs<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n+                        span: Span,\n+                        def_id: DefId)\n+                        -> &'tcx Substs<'tcx> {\n     let tcx = astconv.tcx();\n     // FIXME(eddyb) Do this request from Substs::for_item in librustc.\n     if let Err(ErrorReported) = astconv.get_generics(span, def_id) {"}, {"sha": "c41d40b41e42ab53c8a9ca53a780e1766a8bfc82", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 70, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -1412,85 +1412,19 @@ fn main() {\n ```\n \"##,\n \n-E0106: r##\"\n-This error indicates that a lifetime is missing from a type. If it is an error\n-inside a function signature, the problem may be with failing to adhere to the\n-lifetime elision rules (see below).\n-\n-Here are some simple examples of where you'll run into this error:\n-\n-```compile_fail,E0106\n-struct Foo { x: &bool }        // error\n-struct Foo<'a> { x: &'a bool } // correct\n-\n-enum Bar { A(u8), B(&bool), }        // error\n-enum Bar<'a> { A(u8), B(&'a bool), } // correct\n-\n-type MyStr = &str;        // error\n-type MyStr<'a> = &'a str; // correct\n-```\n-\n-Lifetime elision is a special, limited kind of inference for lifetimes in\n-function signatures which allows you to leave out lifetimes in certain cases.\n-For more background on lifetime elision see [the book][book-le].\n-\n-The lifetime elision rules require that any function signature with an elided\n-output lifetime must either have\n-\n- - exactly one input lifetime\n- - or, multiple input lifetimes, but the function must also be a method with a\n-   `&self` or `&mut self` receiver\n-\n-In the first case, the output lifetime is inferred to be the same as the unique\n-input lifetime. In the second case, the lifetime is instead inferred to be the\n-same as the lifetime on `&self` or `&mut self`.\n-\n-Here are some examples of elision errors:\n-\n-```compile_fail,E0106\n-// error, no input lifetimes\n-fn foo() -> &str { }\n-\n-// error, `x` and `y` have distinct lifetimes inferred\n-fn bar(x: &str, y: &str) -> &str { }\n-\n-// error, `y`'s lifetime is inferred to be distinct from `x`'s\n-fn baz<'a>(x: &'a str, y: &str) -> &str { }\n-```\n-\n-[book-le]: https://doc.rust-lang.org/nightly/book/lifetimes.html#lifetime-elision\n-\"##,\n-\n E0107: r##\"\n This error means that an incorrect number of lifetime parameters were provided\n-for a type (like a struct or enum) or trait.\n-\n-Some basic examples include:\n+for a type (like a struct or enum) or trait:\n \n ```compile_fail,E0107\n-struct Foo<'a>(&'a str);\n+struct Foo<'a, 'b>(&'a str, &'b str);\n enum Bar { A, B, C }\n \n struct Baz<'a> {\n-    foo: Foo,     // error: expected 1, found 0\n+    foo: Foo<'a>, // error: expected 2, found 1\n     bar: Bar<'a>, // error: expected 0, found 1\n }\n ```\n-\n-Here's an example that is currently an error, but may work in a future version\n-of Rust:\n-\n-```compile_fail,E0107\n-struct Foo<'a>(&'a str);\n-\n-trait Quux { }\n-impl Quux for Foo { } // error: expected 1, found 0\n-```\n-\n-Lifetime elision in implementation headers was part of the lifetime elision\n-RFC. It is, however, [currently unimplemented][iss15872].\n-\n-[iss15872]: https://github.com/rust-lang/rust/issues/15872\n \"##,\n \n E0116: r##\"\n@@ -4162,7 +4096,6 @@ register_diagnostics! {\n //  E0222, // Error code E0045 (variadic function must have C calling\n            // convention) duplicate\n     E0224, // at least one non-builtin train is required for an object type\n-    E0226, // only a single explicit lifetime bound is permitted\n     E0227, // ambiguous lifetime bound, explicit lifetime bound required\n     E0228, // explicit lifetime bound required\n     E0231, // only named substitution parameters are allowed"}, {"sha": "4ed116b88f6d942622476e27fc0cbbf66c51cba1", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -77,6 +77,7 @@ This API is completely unstable and subject to change.\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(conservative_impl_trait)]\n+#![feature(loop_break_value)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -126,7 +127,6 @@ pub mod diagnostics;\n \n pub mod check;\n pub mod check_unused;\n-mod rscope;\n mod astconv;\n pub mod collect;\n mod constrained_type_params;"}, {"sha": "3f5e443a20a6854b575a7a57fdf197102483da43", "filename": "src/librustc_typeck/rscope.rs", "status": "removed", "additions": 0, "deletions": 393, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/ecda7f314fa79bbfbf2125c99fd66288ca83c875/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecda7f314fa79bbfbf2125c99fd66288ca83c875/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=ecda7f314fa79bbfbf2125c99fd66288ca83c875", "patch": "@@ -1,393 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::hir;\n-use rustc::hir::def_id::DefId;\n-use rustc::ty;\n-use rustc::ty::subst::Substs;\n-\n-use astconv::AstConv;\n-\n-use std::cell::Cell;\n-use syntax_pos::Span;\n-\n-#[derive(Clone)]\n-pub struct ElisionFailureInfo {\n-    /// Where we can find the argument pattern.\n-    pub parent: Option<hir::BodyId>,\n-    /// The index of the argument in the original definition.\n-    pub index: usize,\n-    pub lifetime_count: usize,\n-    pub have_bound_regions: bool\n-}\n-\n-pub type ElidedLifetime = Result<ty::Region, Option<Vec<ElisionFailureInfo>>>;\n-\n-/// Defines strategies for handling regions that are omitted.  For\n-/// example, if one writes the type `&Foo`, then the lifetime of\n-/// this reference has been omitted. When converting this\n-/// type, the generic functions in astconv will invoke `anon_regions`\n-/// on the provided region-scope to decide how to translate this\n-/// omitted region.\n-///\n-/// It is not always legal to omit regions, therefore `anon_regions`\n-/// can return `Err(())` to indicate that this is not a scope in which\n-/// regions can legally be omitted.\n-pub trait RegionScope {\n-    fn anon_regions(&self,\n-                    span: Span,\n-                    count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>;\n-\n-    /// If an object omits any explicit lifetime bound, and none can\n-    /// be derived from the object traits, what should we use? If\n-    /// `None` is returned, an explicit annotation is required.\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region>;\n-\n-    /// The \"base\" default is the initial default for a scope. This is\n-    /// 'static except for in fn bodies, where it is a fresh inference\n-    /// variable. You shouldn't call this except for as part of\n-    /// computing `object_lifetime_default` (in particular, in legacy\n-    /// modes, it may not be relevant).\n-    fn base_object_lifetime_default(&self, span: Span) -> ty::Region;\n-\n-    /// If this scope allows anonymized types, return the generics in\n-    /// scope, that anonymized types will close over. For example,\n-    /// if you have a function like:\n-    ///\n-    ///     fn foo<'a, T>() -> impl Trait { ... }\n-    ///\n-    /// then, for the rscope that is used when handling the return type,\n-    /// `anon_type_scope()` would return a `Some(AnonTypeScope {...})`,\n-    /// on which `.fresh_substs(...)` can be used to obtain identity\n-    /// Substs for `'a` and `T`, to track them in `TyAnon`. This property\n-    /// is controlled by the region scope because it's fine-grained enough\n-    /// to allow restriction of anonymized types to the syntactical extent\n-    /// of a function's return type.\n-    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n-        None\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct AnonTypeScope {\n-    enclosing_item: DefId\n-}\n-\n-impl<'gcx: 'tcx, 'tcx> AnonTypeScope {\n-    pub fn new(enclosing_item: DefId) -> AnonTypeScope {\n-        AnonTypeScope {\n-            enclosing_item: enclosing_item\n-        }\n-    }\n-\n-    pub fn fresh_substs(&self, astconv: &AstConv<'gcx, 'tcx>, span: Span)\n-                        -> &'tcx Substs<'tcx> {\n-        use collect::mk_item_substs;\n-\n-        mk_item_substs(astconv, span, self.enclosing_item)\n-    }\n-}\n-\n-/// A scope wrapper which optionally allows anonymized types.\n-#[derive(Copy, Clone)]\n-pub struct MaybeWithAnonTypes<R> {\n-    base_scope: R,\n-    anon_scope: Option<AnonTypeScope>\n-}\n-\n-impl<R: RegionScope> MaybeWithAnonTypes<R>  {\n-    pub fn new(base_scope: R, anon_scope: Option<AnonTypeScope>) -> Self {\n-        MaybeWithAnonTypes {\n-            base_scope: base_scope,\n-            anon_scope: anon_scope\n-        }\n-    }\n-}\n-\n-impl<R: RegionScope> RegionScope for MaybeWithAnonTypes<R> {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        self.base_scope.object_lifetime_default(span)\n-    }\n-\n-    fn anon_regions(&self,\n-                    span: Span,\n-                    count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n-        self.base_scope.anon_regions(span, count)\n-    }\n-\n-    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n-        self.base_scope.base_object_lifetime_default(span)\n-    }\n-\n-    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n-        self.anon_scope\n-    }\n-}\n-\n-// A scope in which all regions must be explicitly named. This is used\n-// for types that appear in structs and so on.\n-#[derive(Copy, Clone)]\n-pub struct ExplicitRscope;\n-\n-impl RegionScope for ExplicitRscope {\n-    fn anon_regions(&self,\n-                    _span: Span,\n-                    _count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n-        Err(None)\n-    }\n-\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n-        ty::ReStatic\n-    }\n-}\n-\n-// Same as `ExplicitRscope`, but provides some extra information for diagnostics\n-pub struct UnelidableRscope(Option<Vec<ElisionFailureInfo>>);\n-\n-impl UnelidableRscope {\n-    pub fn new(v: Option<Vec<ElisionFailureInfo>>) -> UnelidableRscope {\n-        UnelidableRscope(v)\n-    }\n-}\n-\n-impl RegionScope for UnelidableRscope {\n-    fn anon_regions(&self,\n-                    _span: Span,\n-                    _count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n-        let UnelidableRscope(ref v) = *self;\n-        Err(v.clone())\n-    }\n-\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n-        ty::ReStatic\n-    }\n-}\n-\n-// A scope in which omitted anonymous region defaults to\n-// `default`. This is used after the `->` in function signatures. The\n-// latter use may go away. Note that object-lifetime defaults work a\n-// bit differently, as specified in RFC #599.\n-pub struct ElidableRscope {\n-    default: ty::Region,\n-}\n-\n-impl ElidableRscope {\n-    pub fn new(r: ty::Region) -> ElidableRscope {\n-        ElidableRscope { default: r }\n-    }\n-}\n-\n-impl RegionScope for ElidableRscope {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        // Per RFC #599, object-lifetimes default to 'static unless\n-        // overridden by context, and this takes precedence over\n-        // lifetime elision.\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n-        ty::ReStatic\n-    }\n-\n-    fn anon_regions(&self,\n-                    _span: Span,\n-                    count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n-    {\n-        Ok(vec![self.default; count])\n-    }\n-}\n-\n-/// A scope that behaves as an ElidabeRscope with a `'static` default region\n-/// that should also warn if the `static_in_const` feature is unset.\n-#[derive(Copy, Clone)]\n-pub struct StaticRscope<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: &'a ty::TyCtxt<'a, 'gcx, 'tcx>,\n-}\n-\n-impl<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> StaticRscope<'a, 'gcx, 'tcx> {\n-    /// create a new StaticRscope from a reference to the `TyCtxt`\n-    pub fn new(tcx: &'a ty::TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        StaticRscope { tcx: tcx }\n-    }\n-}\n-\n-impl<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> RegionScope for StaticRscope<'a, 'gcx, 'tcx> {\n-    fn anon_regions(&self,\n-                    span: Span,\n-                    count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n-        if !self.tcx.sess.features.borrow().static_in_const {\n-            self.tcx\n-                .sess\n-                .struct_span_err(span,\n-                                 \"this needs a `'static` lifetime or the \\\n-                                 `static_in_const` feature, see #35897\")\n-                .emit();\n-        }\n-        Ok(vec![ty::ReStatic; count])\n-    }\n-\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n-        ty::ReStatic\n-    }\n-}\n-\n-/// A scope in which we generate anonymous, late-bound regions for\n-/// omitted regions. This occurs in function signatures.\n-pub struct BindingRscope {\n-    anon_bindings: Cell<u32>,\n-}\n-\n-impl BindingRscope {\n-    pub fn new() -> BindingRscope {\n-        BindingRscope {\n-            anon_bindings: Cell::new(0),\n-        }\n-    }\n-\n-    fn next_region(&self) -> ty::Region {\n-        let idx = self.anon_bindings.get();\n-        self.anon_bindings.set(idx + 1);\n-        ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(idx))\n-    }\n-}\n-\n-impl RegionScope for BindingRscope {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        // Per RFC #599, object-lifetimes default to 'static unless\n-        // overridden by context, and this takes precedence over the\n-        // binding defaults in a fn signature.\n-        Some(self.base_object_lifetime_default(span))\n-    }\n-\n-    fn base_object_lifetime_default(&self, _span: Span) -> ty::Region {\n-        ty::ReStatic\n-    }\n-\n-    fn anon_regions(&self,\n-                    _: Span,\n-                    count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n-    {\n-        Ok((0..count).map(|_| self.next_region()).collect())\n-    }\n-}\n-\n-/// A scope which overrides the default object lifetime but has no other effect.\n-pub struct ObjectLifetimeDefaultRscope<'r> {\n-    base_scope: &'r (RegionScope+'r),\n-    default: ty::ObjectLifetimeDefault<'r>,\n-}\n-\n-impl<'r> ObjectLifetimeDefaultRscope<'r> {\n-    pub fn new(base_scope: &'r (RegionScope+'r),\n-               default: ty::ObjectLifetimeDefault<'r>)\n-               -> ObjectLifetimeDefaultRscope<'r>\n-    {\n-        ObjectLifetimeDefaultRscope {\n-            base_scope: base_scope,\n-            default: default,\n-        }\n-    }\n-}\n-\n-impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        match self.default {\n-            ty::ObjectLifetimeDefault::Ambiguous =>\n-                None,\n-\n-            ty::ObjectLifetimeDefault::BaseDefault =>\n-                // NB: This behavior changed in Rust 1.3.\n-                Some(self.base_object_lifetime_default(span)),\n-\n-            ty::ObjectLifetimeDefault::Specific(r) =>\n-                Some(*r),\n-        }\n-    }\n-\n-    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n-        self.base_scope.base_object_lifetime_default(span)\n-    }\n-\n-    fn anon_regions(&self,\n-                    span: Span,\n-                    count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n-    {\n-        self.base_scope.anon_regions(span, count)\n-    }\n-\n-    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n-        self.base_scope.anon_type_scope()\n-    }\n-}\n-\n-/// A scope which simply shifts the Debruijn index of other scopes\n-/// to account for binding levels.\n-pub struct ShiftedRscope<'r> {\n-    base_scope: &'r (RegionScope+'r)\n-}\n-\n-impl<'r> ShiftedRscope<'r> {\n-    pub fn new(base_scope: &'r (RegionScope+'r)) -> ShiftedRscope<'r> {\n-        ShiftedRscope { base_scope: base_scope }\n-    }\n-}\n-\n-impl<'r> RegionScope for ShiftedRscope<'r> {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        self.base_scope.object_lifetime_default(span)\n-            .map(|r| ty::fold::shift_region(r, 1))\n-    }\n-\n-    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n-        ty::fold::shift_region(self.base_scope.base_object_lifetime_default(span), 1)\n-    }\n-\n-    fn anon_regions(&self,\n-                    span: Span,\n-                    count: usize)\n-                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>>\n-    {\n-        match self.base_scope.anon_regions(span, count) {\n-            Ok(mut v) => {\n-                for r in &mut v {\n-                    *r = ty::fold::shift_region(*r, 1);\n-                }\n-                Ok(v)\n-            }\n-            Err(errs) => {\n-                Err(errs)\n-            }\n-        }\n-    }\n-\n-    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n-        self.base_scope.anon_type_scope()\n-    }\n-}"}, {"sha": "40e82959336de4e654ecc7a95f0ee075a5232f0e", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -154,7 +154,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         let tcx = self.terms_cx.tcx;\n         assert!(is_lifetime(&tcx.hir, param_id));\n         match tcx.named_region_map.defs.get(&param_id) {\n-            Some(&rl::DefEarlyBoundRegion(_, lifetime_decl_id)) => lifetime_decl_id,\n+            Some(&rl::Region::EarlyBound(_, lifetime_decl_id)) => lifetime_decl_id,\n             Some(_) => bug!(\"should not encounter non early-bound cases\"),\n \n             // The lookup should only fail when `param_id` is\n@@ -329,7 +329,6 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_mt(generics, mt, variance);\n             }\n \n-            ty::TyBox(typ) |\n             ty::TyArray(typ, _) |\n             ty::TySlice(typ) => {\n                 self.add_constraints_from_ty(generics, typ, variance);"}, {"sha": "cdb24a56367fc39749f20d213cf0faadd62ebbe4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 42, "deletions": 63, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -28,7 +28,7 @@ use syntax::symbol::keywords;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n use rustc::middle::privacy::AccessLevels;\n-use rustc::middle::resolve_lifetime::DefRegion::*;\n+use rustc::middle::resolve_lifetime as rl;\n use rustc::middle::lang_items;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -765,9 +765,9 @@ impl Clean<Lifetime> for hir::Lifetime {\n     fn clean(&self, cx: &DocContext) -> Lifetime {\n         let def = cx.tcx.named_region_map.defs.get(&self.id).cloned();\n         match def {\n-            Some(DefEarlyBoundRegion(_, node_id)) |\n-            Some(DefLateBoundRegion(_, node_id)) |\n-            Some(DefFreeRegion(_, node_id)) => {\n+            Some(rl::Region::EarlyBound(_, node_id)) |\n+            Some(rl::Region::LateBound(_, node_id)) |\n+            Some(rl::Region::Free(_, node_id)) => {\n                 if let Some(lt) = cx.lt_substs.borrow().get(&node_id).cloned() {\n                     return lt;\n                 }\n@@ -794,7 +794,7 @@ impl Clean<Lifetime> for hir::LifetimeDef {\n     }\n }\n \n-impl<'tcx> Clean<Lifetime> for ty::RegionParameterDef<'tcx> {\n+impl Clean<Lifetime> for ty::RegionParameterDef {\n     fn clean(&self, _: &DocContext) -> Lifetime {\n         Lifetime(self.name.to_string())\n     }\n@@ -842,8 +842,11 @@ impl Clean<WherePredicate> for hir::WherePredicate {\n                 }\n             }\n \n-            hir::WherePredicate::EqPredicate(_) => {\n-                unimplemented!() // FIXME(#20041)\n+            hir::WherePredicate::EqPredicate(ref wrp) => {\n+                WherePredicate::EqPredicate {\n+                    lhs: wrp.lhs_ty.clean(cx),\n+                    rhs: wrp.rhs_ty.clean(cx)\n+                }\n             }\n         }\n     }\n@@ -967,11 +970,6 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n                 Some(tp.clean(cx))\n             }\n         }).collect::<Vec<_>>();\n-        let stripped_lifetimes = gens.regions.iter().map(|rp| {\n-            let mut srp = rp.clone();\n-            srp.bounds = Vec::new();\n-            srp.clean(cx)\n-        }).collect::<Vec<_>>();\n \n         let mut where_predicates = preds.predicates.to_vec().clean(cx);\n \n@@ -1014,7 +1012,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n \n         Generics {\n             type_params: simplify::ty_params(stripped_typarams),\n-            lifetimes: stripped_lifetimes,\n+            lifetimes: gens.regions.clean(cx),\n             where_predicates: simplify::where_clauses(cx, where_predicates),\n         }\n     }\n@@ -1685,9 +1683,15 @@ impl Clean<Type> for hir::Ty {\n         match self.node {\n             TyNever => Never,\n             TyPtr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n-            TyRptr(ref l, ref m) =>\n-                BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n-                             type_: box m.ty.clean(cx)},\n+            TyRptr(ref l, ref m) => {\n+                let lifetime = if l.is_elided() {\n+                    None\n+                } else {\n+                    Some(l.clean(cx))\n+                };\n+                BorrowedRef {lifetime: lifetime, mutability: m.mutbl.clean(cx),\n+                             type_: box m.ty.clean(cx)}\n+            }\n             TySlice(ref ty) => Vector(box ty.clean(cx)),\n             TyArray(ref ty, length) => {\n                 use rustc_const_eval::eval_length;\n@@ -1726,7 +1730,9 @@ impl Clean<Type> for hir::Ty {\n                     for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n                         if let Some(lt) = provided_params.lifetimes().get(i).cloned()\n                                                                             .cloned() {\n-                            lt_substs.insert(lt_param.lifetime.id, lt.clean(cx));\n+                            if !lt.is_elided() {\n+                                lt_substs.insert(lt_param.lifetime.id, lt.clean(cx));\n+                            }\n                         }\n                     }\n                     return cx.enter_alias(ty_substs, lt_substs, || ty.clean(cx));\n@@ -1765,20 +1771,20 @@ impl Clean<Type> for hir::Ty {\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n             }\n-            TyTraitObject(ref bounds) => {\n-                let lhs_ty = bounds[0].clean(cx);\n-                match lhs_ty {\n-                    TraitBound(poly_trait, ..) => {\n-                        match poly_trait.trait_ {\n-                            ResolvedPath { path, typarams: None, did, is_generic } => {\n-                                ResolvedPath {\n-                                    path: path,\n-                                    typarams: Some(bounds[1..].clean(cx)),\n-                                    did: did,\n-                                    is_generic: is_generic,\n-                                }\n-                            }\n-                            _ => Infer // shouldn't happen\n+            TyTraitObject(ref bounds, ref lifetime) => {\n+                match bounds[0].clean(cx).trait_ {\n+                    ResolvedPath { path, typarams: None, did, is_generic } => {\n+                        let mut bounds: Vec<_> = bounds[1..].iter().map(|bound| {\n+                            TraitBound(bound.clean(cx), hir::TraitBoundModifier::None)\n+                        }).collect();\n+                        if !lifetime.is_elided() {\n+                            bounds.push(RegionBound(lifetime.clean(cx)));\n+                        }\n+                        ResolvedPath {\n+                            path: path,\n+                            typarams: Some(bounds),\n+                            did: did,\n+                            is_generic: is_generic,\n                         }\n                     }\n                     _ => Infer // shouldn't happen\n@@ -1802,10 +1808,6 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::TyUint(uint_ty) => Primitive(uint_ty.into()),\n             ty::TyFloat(float_ty) => Primitive(float_ty.into()),\n             ty::TyStr => Primitive(PrimitiveType::Str),\n-            ty::TyBox(t) => {\n-                let box_did = cx.tcx.lang_items.owned_box();\n-                lang_struct(cx, box_did, t, \"Box\", Unique)\n-            }\n             ty::TySlice(ty) => Vector(box ty.clean(cx)),\n             ty::TyArray(ty, i) => FixedVector(box ty.clean(cx),\n                                               format!(\"{}\", i)),\n@@ -2239,7 +2241,11 @@ impl Clean<PathParameters> for hir::PathParameters {\n         match *self {\n             hir::AngleBracketedParameters(ref data) => {\n                 PathParameters::AngleBracketed {\n-                    lifetimes: data.lifetimes.clean(cx),\n+                    lifetimes: if data.lifetimes.iter().all(|lt| lt.is_elided()) {\n+                        vec![]\n+                    } else {\n+                        data.lifetimes.clean(cx)\n+                    },\n                     types: data.types.clean(cx),\n                     bindings: data.bindings.clean(cx)\n                 }\n@@ -2878,33 +2884,6 @@ impl Clean<Deprecation> for attr::Deprecation {\n     }\n }\n \n-fn lang_struct(cx: &DocContext, did: Option<DefId>,\n-               t: ty::Ty, name: &str,\n-               fallback: fn(Box<Type>) -> Type) -> Type {\n-    let did = match did {\n-        Some(did) => did,\n-        None => return fallback(box t.clean(cx)),\n-    };\n-    inline::record_extern_fqn(cx, did, TypeKind::Struct);\n-    ResolvedPath {\n-        typarams: None,\n-        did: did,\n-        path: Path {\n-            global: false,\n-            def: Def::Err,\n-            segments: vec![PathSegment {\n-                name: name.to_string(),\n-                params: PathParameters::AngleBracketed {\n-                    lifetimes: vec![],\n-                    types: vec![t.clean(cx)],\n-                    bindings: vec![]\n-                }\n-            }],\n-        },\n-        is_generic: false,\n-    }\n-}\n-\n /// An equality constraint on an associated type, e.g. `A=Bar` in `Foo<A=Bar>`\n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Debug)]\n pub struct TypeBinding {"}, {"sha": "442a2f4074215a4f519ea4ec2c792520ca8ebf75", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -237,8 +237,9 @@ pub fn render(w: &mut fmt::Formatter,\n             let my_opaque: &MyOpaque = &*((*opaque).opaque as *const MyOpaque);\n             let text = (*orig_text).as_bytes();\n             let origtext = str::from_utf8(text).unwrap();\n+            let origtext = origtext.trim_left();\n             debug!(\"docblock: ==============\\n{:?}\\n=======\", text);\n-            let rendered = if lang.is_null() {\n+            let rendered = if lang.is_null() || origtext.is_empty() {\n                 false\n             } else {\n                 let rlang = (*lang).as_bytes();\n@@ -659,8 +660,6 @@ mod tests {\n         t(\"no_run\",                false,        true,   false,  true,  false, false, Vec::new());\n         t(\"test_harness\",          false,        false,  false,  true,  true,  false, Vec::new());\n         t(\"compile_fail\",          false,        true,   false,  true,  false, true,  Vec::new());\n-        t(\"E0450\",                 false,        false,  false,  true,  false, false,\n-                                   vec![\"E0450\".to_owned()]);\n         t(\"{.no_run .example}\",    false,        true,   false,  true,  false, false, Vec::new());\n         t(\"{.sh .should_panic}\",   true,         false,  false,  true,  false, false, Vec::new());\n         t(\"{.example .rust}\",      false,        false,  false,  true,  false, false, Vec::new());"}, {"sha": "40eb7e5ab78c3df024e83346641c41979913fc76", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -1806,12 +1806,13 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                     String::new()\n                 };\n \n-                let mut unsafety_flag = \"\";\n-                if let clean::FunctionItem(ref func) = myitem.inner {\n-                    if func.unsafety == hir::Unsafety::Unsafe {\n-                        unsafety_flag = \"<a title='unsafe function' href='#'><sup>\u26a0</sup></a>\";\n+                let unsafety_flag = match myitem.inner {\n+                    clean::FunctionItem(ref func) | clean::ForeignFunctionItem(ref func)\n+                    if func.unsafety == hir::Unsafety::Unsafe => {\n+                        \"<a title='unsafe function' href='#'><sup>\u26a0</sup></a>\"\n                     }\n-                }\n+                    _ => \"\",\n+                };\n \n                 let doc_value = myitem.doc_value().unwrap_or(\"\");\n                 write!(w, \""}, {"sha": "ab0ac02fd88f1fc6cdeaa97835e24b6090f63719", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -429,8 +429,12 @@ impl Collector {\n                 should_panic: testing::ShouldPanic::No,\n             },\n             testfn: testing::DynTestFn(box move |()| {\n+                let panic = io::set_panic(None);\n+                let print = io::set_print(None);\n                 match {\n                     rustc_driver::in_rustc_thread(move || {\n+                        io::set_panic(panic);\n+                        io::set_print(print);\n                         runtest(&test,\n                                 &cratename,\n                                 cfgs,"}, {"sha": "05cfb6352fbb800e49a8b8210ff7d3814963b709", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -11,11 +11,9 @@\n //! Implementations of serialization for structures found in libcollections\n \n use std::hash::{Hash, BuildHasher};\n-use std::mem;\n \n use {Decodable, Encodable, Decoder, Encoder};\n use std::collections::{LinkedList, VecDeque, BTreeMap, BTreeSet, HashMap, HashSet};\n-use collections::enum_set::{EnumSet, CLike};\n \n impl<\n     T: Encodable\n@@ -128,33 +126,6 @@ impl<\n     }\n }\n \n-impl<\n-    T: Encodable + CLike\n-> Encodable for EnumSet<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        let mut bits = 0;\n-        for item in self {\n-            bits |= 1 << item.to_usize();\n-        }\n-        s.emit_usize(bits)\n-    }\n-}\n-\n-impl<\n-    T: Decodable + CLike\n-> Decodable for EnumSet<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<EnumSet<T>, D::Error> {\n-        let bits = d.read_usize()?;\n-        let mut set = EnumSet::new();\n-        for bit in 0..(mem::size_of::<usize>()*8) {\n-            if bits & (1 << bit) != 0 {\n-                set.insert(CLike::from_usize(bit));\n-            }\n-        }\n-        Ok(set)\n-    }\n-}\n-\n impl<K, V, S> Encodable for HashMap<K, V, S>\n     where K: Encodable + Hash + Eq,\n           V: Encodable,"}, {"sha": "1cb83fa33da068ecca77c6aaedc1111d8f0c55fe", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -30,7 +30,6 @@ Core encoding and decoding interfaces.\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core_intrinsics)]\n-#![feature(enumset)]\n #![feature(specialization)]\n #![feature(staged_api)]\n #![cfg_attr(test, feature(test))]"}, {"sha": "a0844821709378f4cefb96ac46936af458330867", "filename": "src/libstd/build.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -10,14 +10,15 @@\n \n #![deny(warnings)]\n \n-extern crate gcc;\n+#[macro_use]\n extern crate build_helper;\n+extern crate gcc;\n \n use std::env;\n-use std::path::PathBuf;\n+use std::fs::{self, File};\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n-\n-use build_helper::run;\n+use build_helper::{run, rerun_if_changed_anything_in_dir, up_to_date};\n \n fn main() {\n     println!(\"cargo:rustc-cfg=cargobuild\");\n@@ -66,29 +67,25 @@ fn main() {\n }\n \n fn build_libbacktrace(host: &str, target: &str) {\n-    let src_dir = env::current_dir().unwrap().join(\"../libbacktrace\");\n-    let build_dir = PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n+    let build_dir = env::var_os(\"RUSTBUILD_NATIVE_DIR\").unwrap_or(env::var_os(\"OUT_DIR\").unwrap());\n+    let build_dir = PathBuf::from(build_dir).join(\"libbacktrace\");\n+    let _ = fs::create_dir_all(&build_dir);\n \n     println!(\"cargo:rustc-link-lib=static=backtrace\");\n     println!(\"cargo:rustc-link-search=native={}/.libs\", build_dir.display());\n-\n-    let mut stack = src_dir.read_dir().unwrap()\n-                           .map(|e| e.unwrap())\n-                           .collect::<Vec<_>>();\n-    while let Some(entry) = stack.pop() {\n-        let path = entry.path();\n-        if entry.file_type().unwrap().is_dir() {\n-            stack.extend(path.read_dir().unwrap().map(|e| e.unwrap()));\n-        } else {\n-            println!(\"cargo:rerun-if-changed={}\", path.display());\n-        }\n+    let src_dir = env::current_dir().unwrap().join(\"../libbacktrace\");\n+    rerun_if_changed_anything_in_dir(&src_dir);\n+    let timestamp = build_dir.join(\"rustbuild.timestamp\");\n+    if up_to_date(&Path::new(\"build.rs\"), &timestamp) && up_to_date(&src_dir, &timestamp) {\n+        return\n     }\n \n     let compiler = gcc::Config::new().get_compiler();\n     // only msvc returns None for ar so unwrap is okay\n     let ar = build_helper::cc2ar(compiler.path(), target).unwrap();\n-    let cflags = compiler.args().iter().map(|s| s.to_str().unwrap())\n-                         .collect::<Vec<_>>().join(\" \");\n+    let mut cflags = compiler.args().iter().map(|s| s.to_str().unwrap())\n+                             .collect::<Vec<_>>().join(\" \");\n+    cflags.push_str(\" -fvisibility=hidden\");\n     run(Command::new(\"sh\")\n                 .current_dir(&build_dir)\n                 .arg(src_dir.join(\"configure\").to_str().unwrap()\n@@ -104,8 +101,11 @@ fn build_libbacktrace(host: &str, target: &str) {\n                 .env(\"AR\", &ar)\n                 .env(\"RANLIB\", format!(\"{} s\", ar.display()))\n                 .env(\"CFLAGS\", cflags));\n+\n     run(Command::new(build_helper::make(host))\n                 .current_dir(&build_dir)\n                 .arg(format!(\"INCDIR={}\", src_dir.display()))\n                 .arg(\"-j\").arg(env::var(\"NUM_JOBS\").expect(\"NUM_JOBS was not set\")));\n+\n+    t!(File::create(&timestamp));\n }"}, {"sha": "c3a6b2433ed8815acb1460ba3800a2a13857738b", "filename": "src/libstd/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -222,7 +222,7 @@ fn _var_os(key: &OsStr) -> Option<OsString> {\n \n /// Possible errors from the [`env::var`] function.\n ///\n-/// [env::var]: fn.var.html\n+/// [`env::var`]: fn.var.html\n #[derive(Debug, PartialEq, Eq, Clone)]\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub enum VarError {"}, {"sha": "249627c430cb7d49299b5cda6a3c4b1d9da91384", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -404,7 +404,6 @@ impl File {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(set_permissions_atomic)]\n     /// # fn foo() -> std::io::Result<()> {\n     /// use std::fs::File;\n     ///\n@@ -415,7 +414,7 @@ impl File {\n     /// # Ok(())\n     /// # }\n     /// ```\n-    #[unstable(feature = \"set_permissions_atomic\", issue=\"37916\")]\n+    #[stable(feature = \"set_permissions_atomic\", since = \"1.16.0\")]\n     pub fn set_permissions(&self, perm: Permissions) -> io::Result<()> {\n         self.inner.set_permissions(perm.0)\n     }"}, {"sha": "751878c687c0150c21d53932b03d39e96c8250df", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -148,8 +148,6 @@ impl SocketAddr {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(sockaddr_checker)]\n-    ///\n     /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n     ///\n     /// fn main() {\n@@ -158,7 +156,7 @@ impl SocketAddr {\n     ///     assert_eq!(socket.is_ipv6(), false);\n     /// }\n     /// ```\n-    #[unstable(feature = \"sockaddr_checker\", issue = \"36949\")]\n+    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv4(&self) -> bool {\n         match *self {\n             SocketAddr::V4(_) => true,\n@@ -172,8 +170,6 @@ impl SocketAddr {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(sockaddr_checker)]\n-    ///\n     /// use std::net::{IpAddr, Ipv6Addr, SocketAddr};\n     ///\n     /// fn main() {\n@@ -183,7 +179,7 @@ impl SocketAddr {\n     ///     assert_eq!(socket.is_ipv6(), true);\n     /// }\n     /// ```\n-    #[unstable(feature = \"sockaddr_checker\", issue = \"36949\")]\n+    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv6(&self) -> bool {\n         match *self {\n             SocketAddr::V4(_) => false,"}, {"sha": "7803cf728f2e98777855e0fa32e7f09e4985769b", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -196,8 +196,6 @@ impl IpAddr {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(ipaddr_checker)]\n-    ///\n     /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n     ///\n     /// fn main() {\n@@ -206,7 +204,7 @@ impl IpAddr {\n     ///                false);\n     /// }\n     /// ```\n-    #[unstable(feature = \"ipaddr_checker\", issue = \"36949\")]\n+    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv4(&self) -> bool {\n         match *self {\n             IpAddr::V4(_) => true,\n@@ -219,8 +217,6 @@ impl IpAddr {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(ipaddr_checker)]\n-    ///\n     /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n     ///\n     /// fn main() {\n@@ -229,7 +225,7 @@ impl IpAddr {\n     ///                true);\n     /// }\n     /// ```\n-    #[unstable(feature = \"ipaddr_checker\", issue = \"36949\")]\n+    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n     pub fn is_ipv6(&self) -> bool {\n         match *self {\n             IpAddr::V4(_) => false,"}, {"sha": "fc81cc737d9f0e3937fe64a504d9bb8bee587719", "filename": "src/libstd/sys/redox/ext/fs.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -160,6 +160,10 @@ impl OpenOptionsExt for OpenOptions {\n // casts and rely on manual lowering to `stat` if the raw type is desired.\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn dev(&self) -> u64;\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn ino(&self) -> u64;\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n     fn mode(&self) -> u32;\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n@@ -184,6 +188,12 @@ pub trait MetadataExt {\n \n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n impl MetadataExt for fs::Metadata {\n+    fn dev(&self) -> u64 {\n+        self.as_inner().as_inner().st_dev as u64\n+    }\n+    fn ino(&self) -> u64 {\n+        self.as_inner().as_inner().st_ino as u64\n+    }\n     fn mode(&self) -> u32 {\n         self.as_inner().as_inner().st_mode as u32\n     }"}, {"sha": "1eef89bf66f74af2eac1eedd7dc06e9db508a023", "filename": "src/libstd/sys/unix/backtrace/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -89,3 +89,14 @@ pub use self::tracing::write;\n mod tracing;\n // symbol resolvers:\n mod printing;\n+\n+#[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"emscripten\")))]\n+pub mod gnu {\n+    use io;\n+    use fs;\n+    use libc::c_char;\n+\n+    pub fn get_executable_filename() -> io::Result<(Vec<c_char>, fs::File)> {\n+        Err(io::Error::new(io::ErrorKind::Other, \"Not implemented\"))\n+    }\n+}"}, {"sha": "51e00fc1ab96abe8456cfb7280fc367af249dbef", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -13,7 +13,7 @@ use io;\n use libc::{self, c_int};\n use mem;\n use ptr;\n-use sys::cvt_r;\n+use sys::{cvt, cvt_r};\n use sys::fd::FileDesc;\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -29,34 +29,29 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n     // CLOEXEC flag is to use the `pipe2` syscall on Linux. This was added in\n     // 2.6.27, however, and because we support 2.6.18 we must detect this\n     // support dynamically.\n-    if cfg!(target_os = \"linux\") {\n+    if cfg!(any(target_os = \"dragonfly\",\n+                target_os = \"freebsd\",\n+                target_os = \"linux\",\n+                target_os = \"netbsd\",\n+                target_os = \"openbsd\"))\n+    {\n         weak! { fn pipe2(*mut c_int, c_int) -> c_int }\n         if let Some(pipe) = pipe2.get() {\n-            match cvt_r(|| unsafe { pipe(fds.as_mut_ptr(), libc::O_CLOEXEC) }) {\n-                Ok(_) => {\n-                    return Ok((AnonPipe(FileDesc::new(fds[0])),\n-                               AnonPipe(FileDesc::new(fds[1]))))\n-                }\n-                Err(ref e) if e.raw_os_error() == Some(libc::ENOSYS) => {}\n-                Err(e) => return Err(e),\n-            }\n+            cvt(unsafe { pipe(fds.as_mut_ptr(), libc::O_CLOEXEC) })?;\n+            return Ok((AnonPipe(FileDesc::new(fds[0])),\n+                       AnonPipe(FileDesc::new(fds[1]))));\n         }\n     }\n-    if unsafe { libc::pipe(fds.as_mut_ptr()) == 0 } {\n-        let fd0 = FileDesc::new(fds[0]);\n-        let fd1 = FileDesc::new(fds[1]);\n-        Ok((AnonPipe::from_fd(fd0)?, AnonPipe::from_fd(fd1)?))\n-    } else {\n-        Err(io::Error::last_os_error())\n-    }\n+    cvt(unsafe { libc::pipe(fds.as_mut_ptr()) })?;\n+\n+    let fd0 = FileDesc::new(fds[0]);\n+    let fd1 = FileDesc::new(fds[1]);\n+    fd0.set_cloexec()?;\n+    fd1.set_cloexec()?;\n+    Ok((AnonPipe(fd0), AnonPipe(fd1)))\n }\n \n impl AnonPipe {\n-    pub fn from_fd(fd: FileDesc) -> io::Result<AnonPipe> {\n-        fd.set_cloexec()?;\n-        Ok(AnonPipe(fd))\n-    }\n-\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.0.read(buf)\n     }"}, {"sha": "94aaf439f3d576bdb7fa53cc23752da69c34d65a", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -51,6 +51,10 @@ mod printing;\n #[path = \"printing/gnu.rs\"]\n mod printing;\n \n+#[cfg(target_env = \"gnu\")]\n+#[path = \"backtrace_gnu.rs\"]\n+pub mod gnu;\n+\n type SymInitializeFn =\n     unsafe extern \"system\" fn(c::HANDLE, *mut c_void,\n                               c::BOOL) -> c::BOOL;"}, {"sha": "f0d29dd4178d125acff38545459c05752030a757", "filename": "src/libstd/sys/windows/backtrace_gnu.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace_gnu.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::c;\n+use libc::c_char;\n+use path::PathBuf;\n+use fs::{OpenOptions, File};\n+use sys::ext::fs::OpenOptionsExt;\n+use sys::handle::Handle;\n+use super::super::{fill_utf16_buf, os2path, to_u16s, wide_char_to_multi_byte};\n+\n+fn query_full_process_image_name() -> io::Result<PathBuf> {\n+    unsafe {\n+        let process_handle = Handle::new(c::OpenProcess(c::PROCESS_QUERY_INFORMATION,\n+                                                        c::FALSE,\n+                                                        c::GetCurrentProcessId()));\n+        fill_utf16_buf(|buf, mut sz| {\n+            if c::QueryFullProcessImageNameW(process_handle.raw(), 0, buf, &mut sz) == 0 {\n+                0\n+            } else {\n+                sz\n+            }\n+        }, os2path)\n+    }\n+}\n+\n+fn lock_and_get_executable_filename() -> io::Result<(PathBuf, File)> {\n+    // We query the current image name, open the file without FILE_SHARE_DELETE so it\n+    // can't be moved and then get the current image name again. If the names are the\n+    // same than we have successfully locked the file\n+    let image_name1 = query_full_process_image_name()?;\n+    let file = OpenOptions::new()\n+                .read(true)\n+                .share_mode(c::FILE_SHARE_READ | c::FILE_SHARE_WRITE)\n+                .open(&image_name1)?;\n+    let image_name2 = query_full_process_image_name()?;\n+\n+    if image_name1 != image_name2 {\n+        return Err(io::Error::new(io::ErrorKind::Other,\n+                                  \"executable moved while trying to lock it\"));\n+    }\n+\n+    Ok((image_name1, file))\n+}\n+\n+// Get the executable filename for libbacktrace\n+// This returns the path in the ANSI code page and a File which should remain open\n+// for as long as the path should remain valid\n+pub fn get_executable_filename() -> io::Result<(Vec<c_char>, File)> {\n+    let (executable, file) = lock_and_get_executable_filename()?;\n+    let u16_executable = to_u16s(executable.into_os_string())?;\n+    Ok((wide_char_to_multi_byte(c::CP_ACP, c::WC_NO_BEST_FIT_CHARS,\n+                                &u16_executable, true)?, file))\n+}"}, {"sha": "1b29bf73c7aec09794eff3830c87df9842c2c53c", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -69,6 +69,7 @@ pub type LPWCH = *mut WCHAR;\n pub type LPWIN32_FIND_DATAW = *mut WIN32_FIND_DATAW;\n pub type LPWSADATA = *mut WSADATA;\n pub type LPWSAPROTOCOL_INFO = *mut WSAPROTOCOL_INFO;\n+pub type LPSTR = *mut CHAR;\n pub type LPWSTR = *mut WCHAR;\n pub type LPFILETIME = *mut FILETIME;\n \n@@ -973,6 +974,14 @@ extern \"system\" {\n     pub fn DeleteFileW(lpPathName: LPCWSTR) -> BOOL;\n     pub fn GetCurrentDirectoryW(nBufferLength: DWORD, lpBuffer: LPWSTR) -> DWORD;\n     pub fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n+    pub fn WideCharToMultiByte(CodePage: UINT,\n+                               dwFlags: DWORD,\n+                               lpWideCharStr: LPCWSTR,\n+                               cchWideChar: c_int,\n+                               lpMultiByteStr: LPSTR,\n+                               cbMultiByte: c_int,\n+                               lpDefaultChar: LPCSTR,\n+                               lpUsedDefaultChar: LPBOOL) -> c_int;\n \n     pub fn closesocket(socket: SOCKET) -> c_int;\n     pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int,\n@@ -1178,3 +1187,34 @@ compat_fn! {\n         panic!(\"rwlocks not available\")\n     }\n }\n+\n+#[cfg(target_env = \"gnu\")]\n+mod gnu {\n+    use super::*;\n+\n+    pub const PROCESS_QUERY_INFORMATION: DWORD = 0x0400;\n+\n+    pub const CP_ACP: UINT = 0;\n+\n+    pub const WC_NO_BEST_FIT_CHARS: DWORD = 0x00000400;\n+\n+    extern \"system\" {\n+        pub fn OpenProcess(dwDesiredAccess: DWORD,\n+                           bInheritHandle: BOOL,\n+                           dwProcessId: DWORD) -> HANDLE;\n+    }\n+\n+    compat_fn! {\n+        kernel32:\n+\n+        pub fn QueryFullProcessImageNameW(_hProcess: HANDLE,\n+                                          _dwFlags: DWORD,\n+                                          _lpExeName: LPWSTR,\n+                                          _lpdwSize: LPDWORD) -> BOOL {\n+            SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n+        }\n+    }\n+}\n+\n+#[cfg(target_env = \"gnu\")]\n+pub use self::gnu::*;"}, {"sha": "1419a4af4273831d81dc3017db2cfbde008e1b82", "filename": "src/libstd/sys/windows/ext/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -99,17 +99,17 @@ impl ExitStatusExt for process::ExitStatus {\n }\n \n /// Windows-specific extensions to the `std::process::Command` builder\n-#[unstable(feature = \"windows_process_extensions\", issue = \"37827\")]\n+#[stable(feature = \"windows_process_extensions\", since = \"1.16.0\")]\n pub trait CommandExt {\n     /// Sets the [process creation flags][1] to be passed to `CreateProcess`.\n     ///\n     /// These will always be ORed with `CREATE_UNICODE_ENVIRONMENT`.\n     /// [1]: https://msdn.microsoft.com/en-us/library/windows/desktop/ms684863(v=vs.85).aspx\n-    #[unstable(feature = \"windows_process_extensions\", issue = \"37827\")]\n+    #[stable(feature = \"windows_process_extensions\", since = \"1.16.0\")]\n     fn creation_flags(&mut self, flags: u32) -> &mut process::Command;\n }\n \n-#[unstable(feature = \"windows_process_extensions\", issue = \"37827\")]\n+#[stable(feature = \"windows_process_extensions\", since = \"1.16.0\")]\n impl CommandExt for process::Command {\n     fn creation_flags(&mut self, flags: u32) -> &mut process::Command {\n         self.as_inner_mut().creation_flags(flags);"}, {"sha": "4424c6c6136c5ff94521be912b206bdb0ed482c0", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -10,6 +10,7 @@\n \n #![allow(missing_docs, bad_style)]\n \n+use ptr;\n use ffi::{OsStr, OsString};\n use io::{self, ErrorKind};\n use os::windows::ffi::{OsStrExt, OsStringExt};\n@@ -171,6 +172,52 @@ fn os2path(s: &[u16]) -> PathBuf {\n     PathBuf::from(OsString::from_wide(s))\n }\n \n+#[allow(dead_code)] // Only used in backtrace::gnu::get_executable_filename()\n+fn wide_char_to_multi_byte(code_page: u32,\n+                           flags: u32,\n+                           s: &[u16],\n+                           no_default_char: bool)\n+                           -> io::Result<Vec<i8>> {\n+    unsafe {\n+        let mut size = c::WideCharToMultiByte(code_page,\n+                                              flags,\n+                                              s.as_ptr(),\n+                                              s.len() as i32,\n+                                              ptr::null_mut(),\n+                                              0,\n+                                              ptr::null(),\n+                                              ptr::null_mut());\n+        if size == 0 {\n+            return Err(io::Error::last_os_error());\n+        }\n+\n+        let mut buf = Vec::with_capacity(size as usize);\n+        buf.set_len(size as usize);\n+\n+        let mut used_default_char = c::FALSE;\n+        size = c::WideCharToMultiByte(code_page,\n+                                      flags,\n+                                      s.as_ptr(),\n+                                      s.len() as i32,\n+                                      buf.as_mut_ptr(),\n+                                      buf.len() as i32,\n+                                      ptr::null(),\n+                                      if no_default_char { &mut used_default_char }\n+                                      else { ptr::null_mut() });\n+        if size == 0 {\n+            return Err(io::Error::last_os_error());\n+        }\n+        if no_default_char && used_default_char == c::TRUE {\n+            return Err(io::Error::new(io::ErrorKind::InvalidData,\n+                                      \"string cannot be converted to requested code page\"));\n+        }\n+\n+        buf.set_len(size as usize);\n+\n+        Ok(buf)\n+    }\n+}\n+\n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     match v.iter().position(|c| *c == 0) {\n         // don't include the 0"}, {"sha": "d464a13ad1d3f67484d986c6976af6099347bcea", "filename": "src/libstd/sys_common/gnu/libbacktrace.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fgnu%2Flibbacktrace.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -16,6 +16,7 @@ use sys_common::backtrace::{output, output_fileline};\n pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n              symaddr: *mut libc::c_void) -> io::Result<()> {\n     use ffi::CStr;\n+    use mem;\n     use ptr;\n \n     ////////////////////////////////////////////////////////////////////////\n@@ -124,7 +125,21 @@ pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n     unsafe fn init_state() -> *mut backtrace_state {\n         static mut STATE: *mut backtrace_state = ptr::null_mut();\n         if !STATE.is_null() { return STATE }\n-        STATE = backtrace_create_state(ptr::null(), 0, error_cb,\n+\n+        let filename = match ::sys::backtrace::gnu::get_executable_filename() {\n+            Ok((filename, file)) => {\n+                // filename is purposely leaked here since libbacktrace requires\n+                // it to stay allocated permanently, file is also leaked so that\n+                // the file stays locked\n+                let filename_ptr = filename.as_ptr();\n+                mem::forget(filename);\n+                mem::forget(file);\n+                filename_ptr\n+            },\n+            Err(_) => ptr::null(),\n+        };\n+\n+        STATE = backtrace_create_state(filename, 0, error_cb,\n                                        ptr::null_mut());\n         STATE\n     }"}, {"sha": "8789006436c0c7baa2cfe93a0960b3ea1b4faa57", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -391,7 +391,7 @@ impl Builder {\n /// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n /// [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-/// [`panic!`]: ../../std/macro.panic.html\n+/// [`panic`]: ../../std/macro.panic.html\n /// [`Builder::spawn`]: ../../std/thread/struct.Builder.html#method.spawn\n ///\n /// # Examples\n@@ -974,7 +974,7 @@ impl<T> JoinHandle<T> {\n     /// to [`panic`].\n     ///\n     /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    /// [`panic!`]: ../../std/macro.panic.html\n+    /// [`panic`]: ../../std/macro.panic.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "af7eaeb3106b2e73151cbd08a108fd44f3e5b8a7", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -154,14 +154,12 @@ impl Duration {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(duration_checked_ops)]\n-    ///\n     /// use std::time::Duration;\n     ///\n     /// assert_eq!(Duration::new(0, 0).checked_add(Duration::new(0, 1)), Some(Duration::new(0, 1)));\n     /// assert_eq!(Duration::new(1, 0).checked_add(Duration::new(std::u64::MAX, 0)), None);\n     /// ```\n-    #[unstable(feature = \"duration_checked_ops\", issue = \"35774\")]\n+    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n     #[inline]\n     pub fn checked_add(self, rhs: Duration) -> Option<Duration> {\n         if let Some(mut secs) = self.secs.checked_add(rhs.secs) {\n@@ -194,14 +192,12 @@ impl Duration {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(duration_checked_ops)]\n-    ///\n     /// use std::time::Duration;\n     ///\n     /// assert_eq!(Duration::new(0, 1).checked_sub(Duration::new(0, 0)), Some(Duration::new(0, 1)));\n     /// assert_eq!(Duration::new(0, 0).checked_sub(Duration::new(0, 1)), None);\n     /// ```\n-    #[unstable(feature = \"duration_checked_ops\", issue = \"35774\")]\n+    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n     #[inline]\n     pub fn checked_sub(self, rhs: Duration) -> Option<Duration> {\n         if let Some(mut secs) = self.secs.checked_sub(rhs.secs) {\n@@ -232,14 +228,12 @@ impl Duration {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(duration_checked_ops)]\n-    ///\n     /// use std::time::Duration;\n     ///\n     /// assert_eq!(Duration::new(0, 500_000_001).checked_mul(2), Some(Duration::new(1, 2)));\n     /// assert_eq!(Duration::new(std::u64::MAX - 1, 0).checked_mul(2), None);\n     /// ```\n-    #[unstable(feature = \"duration_checked_ops\", issue = \"35774\")]\n+    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n     #[inline]\n     pub fn checked_mul(self, rhs: u32) -> Option<Duration> {\n         // Multiply nanoseconds as u64, because it cannot overflow that way.\n@@ -269,15 +263,13 @@ impl Duration {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(duration_checked_ops)]\n-    ///\n     /// use std::time::Duration;\n     ///\n     /// assert_eq!(Duration::new(2, 0).checked_div(2), Some(Duration::new(1, 0)));\n     /// assert_eq!(Duration::new(1, 0).checked_div(2), Some(Duration::new(0, 500_000_000)));\n     /// assert_eq!(Duration::new(2, 0).checked_div(0), None);\n     /// ```\n-    #[unstable(feature = \"duration_checked_ops\", issue = \"35774\")]\n+    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n     #[inline]\n     pub fn checked_div(self, rhs: u32) -> Option<Duration> {\n         if rhs != 0 {"}, {"sha": "112211851ec0505600528aea7bc457059a486b63", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -297,10 +297,6 @@ declare_features! (\n     // The #![windows_subsystem] attribute\n     (active, windows_subsystem, \"1.14.0\", Some(37499)),\n \n-    // Allows using `Self` and associated types in struct expressions and patterns.\n-    (active, more_struct_aliases, \"1.14.0\", Some(37544)),\n-\n-\n     // Allows #[link(..., cfg(..))]\n     (active, link_cfg, \"1.14.0\", Some(37406)),\n \n@@ -381,6 +377,8 @@ declare_features! (\n     // Allows `..` in tuple (struct) patterns\n     (accepted, dotdot_in_tuple_patterns, \"1.14.0\", Some(33627)),\n     (accepted, item_like_imports, \"1.14.0\", Some(35120)),\n+    // Allows using `Self` and associated types in struct expressions and patterns.\n+    (accepted, more_struct_aliases, \"1.14.0\", Some(37544)),\n );\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n "}, {"sha": "2532a1def7ddaf65a23d14bf377b6acf2cf6e79c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 300, "deletions": 437, "changes": 737, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -22,7 +22,7 @@ use ast::{Expr, ExprKind, RangeLimits};\n use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n use ast::{Ident, ImplItem, Item, ItemKind};\n-use ast::{Lit, LitKind, UintTy};\n+use ast::{Lifetime, LifetimeDef, Lit, LitKind, UintTy};\n use ast::Local;\n use ast::MacStmtStyle;\n use ast::Mac_;\n@@ -193,14 +193,22 @@ pub enum TokenType {\n     Token(token::Token),\n     Keyword(keywords::Keyword),\n     Operator,\n+    Lifetime,\n+    Ident,\n+    Path,\n+    Type,\n }\n \n impl TokenType {\n     fn to_string(&self) -> String {\n         match *self {\n             TokenType::Token(ref t) => format!(\"`{}`\", Parser::token_to_string(t)),\n-            TokenType::Operator => \"an operator\".to_string(),\n             TokenType::Keyword(kw) => format!(\"`{}`\", kw.name()),\n+            TokenType::Operator => \"an operator\".to_string(),\n+            TokenType::Lifetime => \"lifetime\".to_string(),\n+            TokenType::Ident => \"identifier\".to_string(),\n+            TokenType::Path => \"path\".to_string(),\n+            TokenType::Type => \"type\".to_string(),\n         }\n     }\n }\n@@ -553,6 +561,33 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn check_ident(&mut self) -> bool {\n+        if self.token.is_ident() {\n+            true\n+        } else {\n+            self.expected_tokens.push(TokenType::Ident);\n+            false\n+        }\n+    }\n+\n+    fn check_path(&mut self) -> bool {\n+        if self.token.is_path_start() {\n+            true\n+        } else {\n+            self.expected_tokens.push(TokenType::Path);\n+            false\n+        }\n+    }\n+\n+    fn check_type(&mut self) -> bool {\n+        if self.token.can_begin_type() {\n+            true\n+        } else {\n+            self.expected_tokens.push(TokenType::Type);\n+            false\n+        }\n+    }\n+\n     /// Expect and consume an `&`. If `&&` is seen, replace it with a single\n     /// `&` and continue. If an `&` is not seen, signal an error.\n     fn expect_and(&mut self) -> PResult<'a, ()> {\n@@ -639,13 +674,7 @@ impl<'a> Parser<'a> {\n                 let lo = span.lo + BytePos(1);\n                 Ok(self.bump_with(token::Eq, lo, span.hi))\n             }\n-            _ => {\n-                let gt_str = Parser::token_to_string(&token::Gt);\n-                let this_token_str = self.this_token_to_string();\n-                Err(self.fatal(&format!(\"expected `{}`, found `{}`\",\n-                                        gt_str,\n-                                        this_token_str)))\n-            }\n+            _ => self.unexpected()\n         }\n     }\n \n@@ -972,20 +1001,11 @@ impl<'a> Parser<'a> {\n         Parses whatever can come after a `for` keyword in a type.\n         The `for` hasn't been consumed.\n \n-        Deprecated:\n-\n-        - for <'lt> |S| -> T\n-\n-        Eventually:\n-\n         - for <'lt> [unsafe] [extern \"ABI\"] fn (S) -> T\n-        - for <'lt> path::foo(a, b)\n-\n+        - for <'lt> path::foo(a, b) + Trait + 'a\n         */\n \n-        // parse <'lt>\n         let lo = self.span.lo;\n-\n         let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n \n         // examine next token to decide to do\n@@ -994,9 +1014,9 @@ impl<'a> Parser<'a> {\n         } else {\n             let hi = self.span.hi;\n             let trait_ref = self.parse_trait_ref()?;\n-            let poly_trait_ref = ast::PolyTraitRef { bound_lifetimes: lifetime_defs,\n-                                                     trait_ref: trait_ref,\n-                                                     span: mk_sp(lo, hi)};\n+            let poly_trait_ref = PolyTraitRef { bound_lifetimes: lifetime_defs,\n+                                                trait_ref: trait_ref,\n+                                                span: mk_sp(lo, hi)};\n             let other_bounds = if self.eat(&token::BinOp(token::Plus)) {\n                 self.parse_ty_param_bounds()?\n             } else {\n@@ -1011,26 +1031,17 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_impl_trait_type(&mut self) -> PResult<'a, TyKind> {\n-        /*\n-        Parses whatever can come after a `impl` keyword in a type.\n-        The `impl` has already been consumed.\n-        */\n-\n-        let bounds = self.parse_ty_param_bounds()?;\n-\n-        if !bounds.iter().any(|b| if let TraitTyParamBound(..) = *b { true } else { false }) {\n-            self.span_err(self.prev_span, \"at least one trait must be specified\");\n-        }\n-\n-        Ok(ast::TyKind::ImplTrait(bounds))\n+        // Parses whatever can come after a `impl` keyword in a type.\n+        // The `impl` has already been consumed.\n+        Ok(ast::TyKind::ImplTrait(self.parse_ty_param_bounds()?))\n     }\n \n     pub fn parse_ty_path(&mut self) -> PResult<'a, TyKind> {\n         Ok(TyKind::Path(None, self.parse_path(PathStyle::Type)?))\n     }\n \n     /// parse a TyKind::BareFn type:\n-    pub fn parse_ty_bare_fn(&mut self, lifetime_defs: Vec<ast::LifetimeDef>)\n+    pub fn parse_ty_bare_fn(&mut self, lifetime_defs: Vec<LifetimeDef>)\n                             -> PResult<'a, TyKind> {\n         /*\n \n@@ -1202,13 +1213,6 @@ impl<'a> Parser<'a> {\n             })\n     }\n \n-    /// Parse a possibly mutable type\n-    pub fn parse_mt(&mut self) -> PResult<'a, MutTy> {\n-        let mutbl = self.parse_mutability()?;\n-        let t = self.parse_ty_no_plus()?;\n-        Ok(MutTy { ty: t, mutbl: mutbl })\n-    }\n-\n     /// Parse optional return type [ -> TY ] in function decl\n     pub fn parse_ret_ty(&mut self) -> PResult<'a, FunctionRetTy> {\n         if self.eat(&token::RArrow) {\n@@ -1260,8 +1264,8 @@ impl<'a> Parser<'a> {\n                                             pprust::ty_to_string(&lhs));\n             err.span_label(lhs.span, &format!(\"expected a path\"));\n             let hi = bounds.iter().map(|x| match *x {\n-                ast::TraitTyParamBound(ref tr, _) => tr.span.hi,\n-                ast::RegionTyParamBound(ref r) => r.span.hi,\n+                TraitTyParamBound(ref tr, _) => tr.span.hi,\n+                RegionTyParamBound(ref r) => r.span.hi,\n             }).max_by_key(|x| x.to_usize());\n             let full_span = hi.map(|hi| Span {\n                 lo: lhs.span.lo,\n@@ -1309,19 +1313,16 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n \n-        let t = if self.check(&token::OpenDelim(token::Paren)) {\n-            self.bump();\n-\n+        let t = if self.eat(&token::OpenDelim(token::Paren)) {\n             // (t) is a parenthesized ty\n             // (t,) is the type of a tuple with only one field,\n             // of type t\n             let mut ts = vec![];\n             let mut last_comma = false;\n             while self.token != token::CloseDelim(token::Paren) {\n                 ts.push(self.parse_ty()?);\n-                if self.check(&token::Comma) {\n+                if self.eat(&token::Comma) {\n                     last_comma = true;\n-                    self.bump();\n                 } else {\n                     last_comma = false;\n                     break;\n@@ -1336,13 +1337,11 @@ impl<'a> Parser<'a> {\n             }\n         } else if self.eat(&token::Not) {\n             TyKind::Never\n-        } else if self.check(&token::BinOp(token::Star)) {\n+        } else if self.eat(&token::BinOp(token::Star)) {\n             // STAR POINTER (bare pointer?)\n-            self.bump();\n             TyKind::Ptr(self.parse_ptr()?)\n-        } else if self.check(&token::OpenDelim(token::Bracket)) {\n+        } else if self.eat(&token::OpenDelim(token::Bracket)) {\n             // VECTOR\n-            self.expect(&token::OpenDelim(token::Bracket))?;\n             let t = self.parse_ty()?;\n \n             // Parse the `; e` in `[ i32; e ]`\n@@ -1354,13 +1353,15 @@ impl<'a> Parser<'a> {\n             self.expect(&token::CloseDelim(token::Bracket))?;\n             t\n         } else if self.check(&token::BinOp(token::And)) ||\n-                  self.token == token::AndAnd {\n+                  self.check(&token::AndAnd) {\n             // BORROWED POINTER\n             self.expect_and()?;\n             self.parse_borrowed_pointee()?\n         } else if self.check_keyword(keywords::For) {\n+            // FIXME `+` has incorrect priority in trait object types starting with `for` (#39317).\n             self.parse_for_in_type()?\n         } else if self.eat_keyword(keywords::Impl) {\n+            // FIXME figure out priority of `+` in `impl Trait1 + Trait2` (#34511).\n             self.parse_impl_trait_type()?\n         } else if self.token_is_bare_fn_keyword() {\n             // BARE FUNCTION\n@@ -1373,10 +1374,7 @@ impl<'a> Parser<'a> {\n             self.expect(&token::CloseDelim(token::Paren))?;\n             TyKind::Typeof(e)\n         } else if self.eat_lt() {\n-\n-            let (qself, path) =\n-                 self.parse_qualified_path(PathStyle::Type)?;\n-\n+            let (qself, path) = self.parse_qualified_path(PathStyle::Type)?;\n             TyKind::Path(Some(qself), path)\n         } else if self.token.is_path_start() {\n             let path = self.parse_path(PathStyle::Type)?;\n@@ -1406,10 +1404,10 @@ impl<'a> Parser<'a> {\n \n     pub fn parse_borrowed_pointee(&mut self) -> PResult<'a, TyKind> {\n         // look for `&'lt` or `&'foo ` and interpret `foo` as the region name:\n-        let opt_lifetime = self.parse_opt_lifetime()?;\n-\n-        let mt = self.parse_mt()?;\n-        return Ok(TyKind::Rptr(opt_lifetime, mt));\n+        let opt_lifetime = self.eat_lifetime();\n+        let mutbl = self.parse_mutability()?;\n+        let ty = self.parse_ty_no_plus()?;\n+        return Ok(TyKind::Rptr(opt_lifetime, MutTy { ty: ty, mutbl: mutbl }));\n     }\n \n     pub fn parse_ptr(&mut self) -> PResult<'a, MutTy> {\n@@ -1505,8 +1503,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn maybe_parse_fixed_length_of_vec(&mut self) -> PResult<'a, Option<P<ast::Expr>>> {\n-        if self.check(&token::Semi) {\n-            self.bump();\n+        if self.eat(&token::Semi) {\n             Ok(Some(self.parse_expr()?))\n         } else {\n             Ok(None)\n@@ -1728,7 +1725,8 @@ impl<'a> Parser<'a> {\n \n             // Parse types, optionally.\n             let parameters = if self.eat_lt() {\n-                let (lifetimes, types, bindings) = self.parse_generic_values_after_lt()?;\n+                let (lifetimes, types, bindings) = self.parse_generic_args()?;\n+                self.expect_gt()?;\n                 ast::AngleBracketedParameterData {\n                     lifetimes: lifetimes,\n                     types: types,\n@@ -1786,7 +1784,8 @@ impl<'a> Parser<'a> {\n             // Check for a type segment.\n             if self.eat_lt() {\n                 // Consumed `a::b::<`, go look for types\n-                let (lifetimes, types, bindings) = self.parse_generic_values_after_lt()?;\n+                let (lifetimes, types, bindings) = self.parse_generic_args()?;\n+                self.expect_gt()?;\n                 segments.push(ast::PathSegment {\n                     identifier: identifier,\n                     parameters: ast::AngleBracketedParameterData {\n@@ -1828,121 +1827,21 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// parses 0 or 1 lifetime\n-    pub fn parse_opt_lifetime(&mut self) -> PResult<'a, Option<ast::Lifetime>> {\n-        match self.token {\n-            token::Lifetime(..) => {\n-                Ok(Some(self.parse_lifetime()?))\n-            }\n-            _ => {\n-                Ok(None)\n-            }\n-        }\n-    }\n-\n-    /// Parses a single lifetime\n-    /// Matches lifetime = LIFETIME\n-    pub fn parse_lifetime(&mut self) -> PResult<'a, ast::Lifetime> {\n+    /// Parse single lifetime 'a or nothing.\n+    pub fn eat_lifetime(&mut self) -> Option<Lifetime> {\n         match self.token {\n-            token::Lifetime(i) => {\n-                let span = self.span;\n+            token::Lifetime(ident) => {\n                 self.bump();\n-                return Ok(ast::Lifetime {\n+                Some(Lifetime {\n                     id: ast::DUMMY_NODE_ID,\n-                    span: span,\n-                    name: i.name\n-                });\n+                    span: self.prev_span,\n+                    name: ident.name\n+                })\n             }\n             _ => {\n-                return Err(self.fatal(\"expected a lifetime name\"));\n-            }\n-        }\n-    }\n-\n-    /// Parses `lifetime_defs = [ lifetime_defs { ',' lifetime_defs } ]` where `lifetime_def  =\n-    /// lifetime [':' lifetimes]`\n-    ///\n-    /// If `followed_by_ty_params` is None, then we are in a context\n-    /// where only lifetime parameters are allowed, and thus we should\n-    /// error if we encounter attributes after the bound lifetimes.\n-    ///\n-    /// If `followed_by_ty_params` is Some(r), then there may be type\n-    /// parameter bindings after the lifetimes, so we should pass\n-    /// along the parsed attributes to be attached to the first such\n-    /// type parmeter.\n-    pub fn parse_lifetime_defs(&mut self,\n-                               followed_by_ty_params: Option<&mut Vec<ast::Attribute>>)\n-                               -> PResult<'a, Vec<ast::LifetimeDef>>\n-    {\n-        let mut res = Vec::new();\n-        loop {\n-            let attrs = self.parse_outer_attributes()?;\n-            match self.token {\n-                token::Lifetime(_) => {\n-                    let lifetime = self.parse_lifetime()?;\n-                    let bounds =\n-                        if self.eat(&token::Colon) {\n-                            self.parse_lifetimes(token::BinOp(token::Plus))?\n-                        } else {\n-                            Vec::new()\n-                        };\n-                    res.push(ast::LifetimeDef { attrs: attrs.into(),\n-                                                lifetime: lifetime,\n-                                                bounds: bounds });\n-                }\n-\n-                _ => {\n-                    if let Some(recv) = followed_by_ty_params {\n-                        assert!(recv.is_empty());\n-                        *recv = attrs;\n-                        debug!(\"parse_lifetime_defs ret {:?}\", res);\n-                        return Ok(res);\n-                    } else if !attrs.is_empty() {\n-                        let msg = \"trailing attribute after lifetime parameters\";\n-                        return Err(self.fatal(msg));\n-                    }\n-                }\n-            }\n-\n-            match self.token {\n-                token::Comma => { self.bump();}\n-                token::Gt => { return Ok(res); }\n-                token::BinOp(token::Shr) => { return Ok(res); }\n-                _ => {\n-                    let this_token_str = self.this_token_to_string();\n-                    let msg = format!(\"expected `,` or `>` after lifetime \\\n-                                      name, found `{}`\",\n-                                      this_token_str);\n-                    return Err(self.fatal(&msg[..]));\n-                }\n-            }\n-        }\n-    }\n-\n-    /// matches lifetimes = ( lifetime ) | ( lifetime , lifetimes ) actually, it matches the empty\n-    /// one too, but putting that in there messes up the grammar....\n-    ///\n-    /// Parses zero or more comma separated lifetimes. Expects each lifetime to be followed by\n-    /// either a comma or `>`.  Used when parsing type parameter lists, where we expect something\n-    /// like `<'a, 'b, T>`.\n-    pub fn parse_lifetimes(&mut self, sep: token::Token) -> PResult<'a, Vec<ast::Lifetime>> {\n-\n-        let mut res = Vec::new();\n-        loop {\n-            match self.token {\n-                token::Lifetime(_) => {\n-                    res.push(self.parse_lifetime()?);\n-                }\n-                _ => {\n-                    return Ok(res);\n-                }\n-            }\n-\n-            if self.token != sep {\n-                return Ok(res);\n+                self.expected_tokens.push(TokenType::Lifetime);\n+                None\n             }\n-\n-            self.bump();\n         }\n     }\n \n@@ -2459,7 +2358,9 @@ impl<'a> Parser<'a> {\n                         -> PResult<'a, P<Expr>> {\n         let (_, tys, bindings) = if self.eat(&token::ModSep) {\n             self.expect_lt()?;\n-            self.parse_generic_values_after_lt()?\n+            let args = self.parse_generic_args()?;\n+            self.expect_gt()?;\n+            args\n         } else {\n             (Vec::new(), Vec::new(), Vec::new())\n         };\n@@ -2555,9 +2456,21 @@ impl<'a> Parser<'a> {\n                             Some(f) => f,\n                             None => continue,\n                         };\n-                        err.help(&format!(\"try parenthesizing the first index; e.g., `(foo.{}){}`\",\n-                                 float.trunc() as usize,\n-                                 format!(\".{}\", fstr.splitn(2, \".\").last().unwrap())));\n+                        let sugg = pprust::to_string(|s| {\n+                            use print::pprust::PrintState;\n+                            use print::pp::word;\n+                            s.popen()?;\n+                            s.print_expr(&e)?;\n+                            word(&mut s.s, \".\")?;\n+                            s.print_usize(float.trunc() as usize)?;\n+                            s.pclose()?;\n+                            word(&mut s.s, \".\")?;\n+                            word(&mut s.s, fstr.splitn(2, \".\").last().unwrap())\n+                        });\n+                        err.span_suggestion(\n+                            prev_span,\n+                            \"try parenthesizing the first index\",\n+                            sugg);\n                     }\n                     return Err(err);\n \n@@ -3999,7 +3912,14 @@ impl<'a> Parser<'a> {\n                     if self.eat(&token::Semi) {\n                         stmt_span.hi = self.prev_span.hi;\n                     }\n-                    e.span_help(stmt_span, \"try placing this code inside a block\");\n+                    let sugg = pprust::to_string(|s| {\n+                        use print::pprust::{PrintState, INDENT_UNIT};\n+                        s.ibox(INDENT_UNIT)?;\n+                        s.bopen()?;\n+                        s.print_stmt(&stmt)?;\n+                        s.bclose_maybe_open(stmt.span, INDENT_UNIT, false)\n+                    });\n+                    e.span_suggestion(stmt_span, \"try placing this code inside a block\", sugg);\n                 }\n                 Err(mut e) => {\n                     self.recover_stmt_(SemiColonMode::Break);\n@@ -4094,69 +4014,68 @@ impl<'a> Parser<'a> {\n         }).emit();\n     }\n \n-    // Parses a sequence of bounds if a `:` is found,\n-    // otherwise returns empty list.\n-    fn parse_colon_then_ty_param_bounds(&mut self) -> PResult<'a, TyParamBounds>\n-    {\n-        if !self.eat(&token::Colon) {\n-            Ok(Vec::new())\n-        } else {\n-            self.parse_ty_param_bounds()\n-        }\n-    }\n-\n-    // matches bounds    = ( boundseq )?\n-    // where   boundseq  = ( polybound + boundseq ) | polybound\n-    // and     polybound = ( 'for' '<' 'region '>' )? bound\n-    // and     bound     = 'region | trait_ref\n+    // Parse bounds of a type parameter `BOUND + BOUND + BOUND` without trailing `+`.\n+    // BOUND = TY_BOUND | LT_BOUND\n+    // LT_BOUND = LIFETIME (e.g. `'a`)\n+    // TY_BOUND = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g. `?for<'a: 'b> m::Trait<'a>`)\n     fn parse_ty_param_bounds(&mut self) -> PResult<'a, TyParamBounds>\n     {\n-        let mut result = vec![];\n+        let mut bounds = Vec::new();\n         loop {\n-            let question_span = self.span;\n-            let ate_question = self.eat(&token::Question);\n-            match self.token {\n-                token::Lifetime(lifetime) => {\n-                    if ate_question {\n-                        self.span_err(question_span,\n-                                      \"`?` may only modify trait bounds, not lifetime bounds\");\n-                    }\n-                    result.push(RegionTyParamBound(ast::Lifetime {\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: self.span,\n-                        name: lifetime.name\n-                    }));\n-                    self.bump();\n+            let question = if self.eat(&token::Question) { Some(self.prev_span) } else { None };\n+            if let Some(lifetime) = self.eat_lifetime() {\n+                if let Some(question_span) = question {\n+                    self.span_err(question_span,\n+                                  \"`?` may only modify trait bounds, not lifetime bounds\");\n                 }\n-                _ if self.token.is_path_start() || self.token.is_keyword(keywords::For) => {\n-                    let poly_trait_ref = self.parse_poly_trait_ref()?;\n-                    let modifier = if ate_question {\n-                        TraitBoundModifier::Maybe\n-                    } else {\n-                        TraitBoundModifier::None\n-                    };\n-                    result.push(TraitTyParamBound(poly_trait_ref, modifier))\n-                }\n-                _ => break,\n-            }\n+                bounds.push(RegionTyParamBound(lifetime));\n+            } else {if self.check_keyword(keywords::For) || self.check_path() {\n+                let poly_trait_ref = self.parse_poly_trait_ref()?;\n+                let modifier = if question.is_some() {\n+                    TraitBoundModifier::Maybe\n+                } else {\n+                    TraitBoundModifier::None\n+                };\n+                bounds.push(TraitTyParamBound(poly_trait_ref, modifier));\n+            } else {\n+                break\n+            }}\n \n             if !self.eat(&token::BinOp(token::Plus)) {\n-                break;\n+                break\n             }\n         }\n \n-        return Ok(result);\n+        return Ok(bounds);\n+    }\n+\n+    // Parse bounds of a type parameter `BOUND + BOUND + BOUND` without trailing `+`.\n+    // BOUND = LT_BOUND (e.g. `'a`)\n+    fn parse_lt_param_bounds(&mut self) -> Vec<Lifetime> {\n+        let mut lifetimes = Vec::new();\n+        while let Some(lifetime) = self.eat_lifetime() {\n+            lifetimes.push(lifetime);\n+\n+            if !self.eat(&token::BinOp(token::Plus)) {\n+                break\n+            }\n+        }\n+        lifetimes\n     }\n \n     /// Matches typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?\n-    fn parse_ty_param(&mut self, preceding_attrs: Vec<ast::Attribute>) -> PResult<'a, TyParam> {\n+    fn parse_ty_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, TyParam> {\n         let span = self.span;\n         let ident = self.parse_ident()?;\n \n-        let bounds = self.parse_colon_then_ty_param_bounds()?;\n+        // Parse optional colon and param bounds.\n+        let bounds = if self.eat(&token::Colon) {\n+            self.parse_ty_param_bounds()?\n+        } else {\n+            Vec::new()\n+        };\n \n-        let default = if self.check(&token::Eq) {\n-            self.bump();\n+        let default = if self.eat(&token::Eq) {\n             Some(self.parse_ty()?)\n         } else {\n             None\n@@ -4172,6 +4091,51 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    /// Parses (possibly empty) list of lifetime and type parameters, possibly including\n+    /// trailing comma and erroneous trailing attributes.\n+    pub fn parse_generic_params(&mut self) -> PResult<'a, (Vec<LifetimeDef>, Vec<TyParam>)> {\n+        let mut lifetime_defs = Vec::new();\n+        let mut ty_params = Vec::new();\n+        let mut seen_ty_param = false;\n+        loop {\n+            let attrs = self.parse_outer_attributes()?;\n+            if let Some(lifetime) = self.eat_lifetime() {\n+                // Parse lifetime parameter.\n+                let bounds = if self.eat(&token::Colon) {\n+                    self.parse_lt_param_bounds()\n+                } else {\n+                    Vec::new()\n+                };\n+                lifetime_defs.push(LifetimeDef {\n+                    attrs: attrs.into(),\n+                    lifetime: lifetime,\n+                    bounds: bounds,\n+                });\n+                if seen_ty_param {\n+                    self.span_err(self.prev_span,\n+                        \"lifetime parameters must be declared prior to type parameters\");\n+                }\n+            } else {if self.check_ident() {\n+                // Parse type parameter.\n+                ty_params.push(self.parse_ty_param(attrs)?);\n+                seen_ty_param = true;\n+            } else {\n+                // Check for trailing attributes and stop parsing.\n+                if !attrs.is_empty() {\n+                    let param_kind = if seen_ty_param { \"type\" } else { \"lifetime\" };\n+                    self.span_err(attrs[0].span,\n+                        &format!(\"trailing attribute after {} parameters\", param_kind));\n+                }\n+                break\n+            }}\n+\n+            if !self.eat(&token::Comma) {\n+                break\n+            }\n+        }\n+        Ok((lifetime_defs, ty_params))\n+    }\n+\n     /// Parse a set of optional generic type parameter declarations. Where\n     /// clauses are not parsed here, and must be added later via\n     /// `parse_where_clause()`.\n@@ -4181,45 +4145,11 @@ impl<'a> Parser<'a> {\n     /// where   typaramseq = ( typaram ) | ( typaram , typaramseq )\n     pub fn parse_generics(&mut self) -> PResult<'a, ast::Generics> {\n         maybe_whole!(self, NtGenerics, |x| x);\n-        let span_lo = self.span.lo;\n \n-        if self.eat(&token::Lt) {\n-            // Upon encountering attribute in generics list, we do not\n-            // know if it is attached to lifetime or to type param.\n-            //\n-            // Solution: 1. eagerly parse attributes in tandem with\n-            // lifetime defs, 2. store last set of parsed (and unused)\n-            // attributes in `attrs`, and 3. pass in those attributes\n-            // when parsing formal type param after lifetime defs.\n-            let mut attrs = vec![];\n-            let lifetime_defs = self.parse_lifetime_defs(Some(&mut attrs))?;\n-            let mut seen_default = false;\n-            let mut post_lifetime_attrs = Some(attrs);\n-            let ty_params = self.parse_seq_to_gt(Some(token::Comma), |p| {\n-                p.forbid_lifetime()?;\n-                // Move out of `post_lifetime_attrs` if present. O/w\n-                // not first type param: parse attributes anew.\n-                let attrs = match post_lifetime_attrs.as_mut() {\n-                    None => p.parse_outer_attributes()?,\n-                    Some(attrs) => mem::replace(attrs, vec![]),\n-                };\n-                post_lifetime_attrs = None;\n-                let ty_param = p.parse_ty_param(attrs)?;\n-                if ty_param.default.is_some() {\n-                    seen_default = true;\n-                } else if seen_default {\n-                    let prev_span = p.prev_span;\n-                    p.span_err(prev_span,\n-                               \"type parameters with a default must be trailing\");\n-                }\n-                Ok(ty_param)\n-            })?;\n-            if let Some(attrs) = post_lifetime_attrs {\n-                if !attrs.is_empty() {\n-                    self.span_err(attrs[0].span,\n-                                  \"trailing attribute after lifetime parameters\");\n-                }\n-            }\n+        let span_lo = self.span.lo;\n+        if self.eat_lt() {\n+            let (lifetime_defs, ty_params) = self.parse_generic_params()?;\n+            self.expect_gt()?;\n             Ok(ast::Generics {\n                 lifetimes: lifetime_defs,\n                 ty_params: ty_params,\n@@ -4234,93 +4164,60 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_generic_values_after_lt(&mut self) -> PResult<'a, (Vec<ast::Lifetime>,\n-                                                            Vec<P<Ty>>,\n-                                                            Vec<TypeBinding>)> {\n-        let span_lo = self.span.lo;\n-        let lifetimes = self.parse_lifetimes(token::Comma)?;\n-\n-        let missing_comma = !lifetimes.is_empty() &&\n-                            !self.token.is_like_gt() &&\n-                            self.prev_token_kind != PrevTokenKind::Comma;\n-\n-        if missing_comma {\n-\n-            let msg = format!(\"expected `,` or `>` after lifetime \\\n-                              name, found `{}`\",\n-                              self.this_token_to_string());\n-            let mut err = self.diagnostic().struct_span_err(self.span, &msg);\n-\n-            let span_hi = self.span.hi;\n-            let span_hi = match self.parse_ty_no_plus() {\n-                Ok(..) => self.span.hi,\n-                Err(ref mut err) => {\n-                    self.cancel(err);\n-                    span_hi\n-                }\n-            };\n-\n-            let msg = format!(\"did you mean a single argument type &'a Type, \\\n-                              or did you mean the comma-separated arguments \\\n-                              'a, Type?\");\n-            err.span_note(mk_sp(span_lo, span_hi), &msg);\n-            return Err(err);\n-        }\n-\n-        // First parse types.\n-        let (types, returned) = self.parse_seq_to_gt_or_return(\n-            Some(token::Comma),\n-            |p| {\n-                p.forbid_lifetime()?;\n-                if p.look_ahead(1, |t| t == &token::Eq) {\n-                    Ok(None)\n-                } else {\n-                    Ok(Some(p.parse_ty()?))\n+    /// Parses (possibly empty) list of lifetime and type arguments and associated type bindings,\n+    /// possibly including trailing comma.\n+    fn parse_generic_args(&mut self) -> PResult<'a, (Vec<Lifetime>, Vec<P<Ty>>, Vec<TypeBinding>)> {\n+        let mut lifetimes = Vec::new();\n+        let mut types = Vec::new();\n+        let mut bindings = Vec::new();\n+        let mut seen_type = false;\n+        let mut seen_binding = false;\n+        loop {\n+            if let Some(lifetime) = self.eat_lifetime() {\n+                // Parse lifetime argument.\n+                lifetimes.push(lifetime);\n+                if seen_type || seen_binding {\n+                    self.span_err(self.prev_span,\n+                        \"lifetime parameters must be declared prior to type parameters\");\n                 }\n-            }\n-        )?;\n-\n-        // If we found the `>`, don't continue.\n-        if !returned {\n-            return Ok((lifetimes, types, Vec::new()));\n-        }\n-\n-        // Then parse type bindings.\n-        let bindings = self.parse_seq_to_gt(\n-            Some(token::Comma),\n-            |p| {\n-                p.forbid_lifetime()?;\n-                let lo = p.span.lo;\n-                let ident = p.parse_ident()?;\n-                p.expect(&token::Eq)?;\n-                let ty = p.parse_ty_no_plus()?;\n-                let hi = ty.span.hi;\n-                let span = mk_sp(lo, hi);\n-                return Ok(TypeBinding{id: ast::DUMMY_NODE_ID,\n+            } else {if self.check_ident() && self.look_ahead(1, |t| t == &token::Eq) {\n+                // Parse associated type binding.\n+                let lo = self.span.lo;\n+                let ident = self.parse_ident()?;\n+                self.bump();\n+                let ty = self.parse_ty()?;\n+                bindings.push(TypeBinding {\n+                    id: ast::DUMMY_NODE_ID,\n                     ident: ident,\n                     ty: ty,\n-                    span: span,\n+                    span: mk_sp(lo, self.prev_span.hi),\n                 });\n-            }\n-        )?;\n-        Ok((lifetimes, types, bindings))\n-    }\n+                seen_binding = true;\n+            } else if self.check_type() {\n+                // Parse type argument.\n+                types.push(self.parse_ty()?);\n+                if seen_binding {\n+                    self.span_err(types[types.len() - 1].span,\n+                        \"type parameters must be declared prior to associated type bindings\");\n+                }\n+                seen_type = true;\n+            } else {\n+                break\n+            }}\n \n-    fn forbid_lifetime(&mut self) -> PResult<'a, ()> {\n-        if self.token.is_lifetime() {\n-            let span = self.span;\n-            return Err(self.diagnostic().struct_span_err(span, \"lifetime parameters must be \\\n-                                                                declared prior to type parameters\"))\n+            if !self.eat(&token::Comma) {\n+                break\n+            }\n         }\n-        Ok(())\n+        Ok((lifetimes, types, bindings))\n     }\n \n     /// Parses an optional `where` clause and places it in `generics`.\n     ///\n     /// ```ignore\n     /// where T : Trait<U, V> + 'b, 'a : 'b\n     /// ```\n-    pub fn parse_where_clause(&mut self) -> PResult<'a, ast::WhereClause> {\n+    pub fn parse_where_clause(&mut self) -> PResult<'a, WhereClause> {\n         maybe_whole!(self, NtWhereClause, |x| x);\n \n         let mut where_clause = WhereClause {\n@@ -4332,7 +4229,7 @@ impl<'a> Parser<'a> {\n             return Ok(where_clause);\n         }\n \n-        // This is a temporary hack.\n+        // This is a temporary future proofing.\n         //\n         // We are considering adding generics to the `where` keyword as an alternative higher-rank\n         // parameter syntax (as in `where<'a>` or `where<T>`. To avoid that being a breaking\n@@ -4349,106 +4246,64 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let mut parsed_something = false;\n         loop {\n             let lo = self.span.lo;\n-            match self.token {\n-                token::OpenDelim(token::Brace) => {\n-                    break\n-                }\n-\n-                token::Lifetime(..) => {\n-                    let bounded_lifetime =\n-                        self.parse_lifetime()?;\n-\n-                    self.expect(&token::Colon)?;\n-\n-                    let bounds =\n-                        self.parse_lifetimes(token::BinOp(token::Plus))?;\n-\n-                    let hi = self.prev_span.hi;\n-                    let span = mk_sp(lo, hi);\n-\n-                    where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n-                        ast::WhereRegionPredicate {\n-                            span: span,\n-                            lifetime: bounded_lifetime,\n-                            bounds: bounds\n+            if let Some(lifetime) = self.eat_lifetime() {\n+                // Bounds starting with a colon are mandatory, but possibly empty.\n+                self.expect(&token::Colon)?;\n+                let bounds = self.parse_lt_param_bounds();\n+                where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n+                    ast::WhereRegionPredicate {\n+                        span: mk_sp(lo, self.prev_span.hi),\n+                        lifetime: lifetime,\n+                        bounds: bounds,\n+                    }\n+                ));\n+            } else {if self.check_type() {\n+                // Parse optional `for<'a, 'b>`.\n+                // This `for` is parsed greedily and applies to the whole predicate,\n+                // the bounded type can have its own `for` applying only to it.\n+                // Example 1: for<'a> Trait1<'a>: Trait2<'a /*ok*/>\n+                // Example 2: (for<'a> Trait1<'a>): Trait2<'a /*not ok*/>\n+                // Example 3: for<'a> for<'b> Trait1<'a, 'b>: Trait2<'a /*ok*/, 'b /*not ok*/>\n+                let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+\n+                // Parse type with mandatory colon and (possibly empty) bounds,\n+                // or with mandatory equality sign and the second type.\n+                let ty = self.parse_ty()?;\n+                if self.eat(&token::Colon) {\n+                    let bounds = self.parse_ty_param_bounds()?;\n+                    where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n+                        ast::WhereBoundPredicate {\n+                            span: mk_sp(lo, self.prev_span.hi),\n+                            bound_lifetimes: lifetime_defs,\n+                            bounded_ty: ty,\n+                            bounds: bounds,\n                         }\n                     ));\n-\n-                    parsed_something = true;\n-                }\n-\n-                _ => {\n-                    let bound_lifetimes = if self.eat_keyword(keywords::For) {\n-                        // Higher ranked constraint.\n-                        self.expect(&token::Lt)?;\n-                        let lifetime_defs = self.parse_lifetime_defs(None)?;\n-                        self.expect_gt()?;\n-                        lifetime_defs\n-                    } else {\n-                        vec![]\n-                    };\n-\n-                    let bounded_ty = self.parse_ty_no_plus()?;\n-\n-                    if self.eat(&token::Colon) {\n-                        let bounds = self.parse_ty_param_bounds()?;\n-                        let hi = self.prev_span.hi;\n-                        let span = mk_sp(lo, hi);\n-\n-                        if bounds.is_empty() {\n-                            self.span_err(span,\n-                                          \"each predicate in a `where` clause must have \\\n-                                           at least one bound in it\");\n+                // FIXME: Decide what should be used here, `=` or `==`.\n+                } else if self.eat(&token::Eq) || self.eat(&token::EqEq) {\n+                    let rhs_ty = self.parse_ty()?;\n+                    where_clause.predicates.push(ast::WherePredicate::EqPredicate(\n+                        ast::WhereEqPredicate {\n+                            span: mk_sp(lo, self.prev_span.hi),\n+                            lhs_ty: ty,\n+                            rhs_ty: rhs_ty,\n+                            id: ast::DUMMY_NODE_ID,\n                         }\n-\n-                        where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n-                                ast::WhereBoundPredicate {\n-                                    span: span,\n-                                    bound_lifetimes: bound_lifetimes,\n-                                    bounded_ty: bounded_ty,\n-                                    bounds: bounds,\n-                        }));\n-\n-                        parsed_something = true;\n-                    } else if self.eat(&token::Eq) {\n-                        // let ty = try!(self.parse_ty_no_plus());\n-                        let hi = self.prev_span.hi;\n-                        let span = mk_sp(lo, hi);\n-                        // where_clause.predicates.push(\n-                        //     ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n-                        //         id: ast::DUMMY_NODE_ID,\n-                        //         span: span,\n-                        //         path: panic!(\"NYI\"), //bounded_ty,\n-                        //         ty: ty,\n-                        // }));\n-                        // parsed_something = true;\n-                        // // FIXME(#18433)\n-                        self.span_err(span,\n-                                     \"equality constraints are not yet supported \\\n-                                     in where clauses (#20041)\");\n-                    } else {\n-                        let prev_span = self.prev_span;\n-                        self.span_err(prev_span,\n-                              \"unexpected token in `where` clause\");\n-                    }\n+                    ));\n+                } else {\n+                    return self.unexpected();\n                 }\n-            };\n+            } else {\n+                break\n+            }}\n \n             if !self.eat(&token::Comma) {\n                 break\n             }\n         }\n \n-        if !parsed_something {\n-            let prev_span = self.prev_span;\n-            self.span_err(prev_span,\n-                          \"a `where` clause must have at least one predicate \\\n-                           in it\");\n-        }\n-\n         Ok(where_clause)\n     }\n \n@@ -4547,13 +4402,13 @@ impl<'a> Parser<'a> {\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n                           isolated_self(self, 2) {\n                     self.bump();\n-                    let lt = self.parse_lifetime()?;\n+                    let lt = self.eat_lifetime().expect(\"not a lifetime\");\n                     (SelfKind::Region(Some(lt), Mutability::Immutable), expect_ident(self))\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n                           self.look_ahead(2, |t| t.is_keyword(keywords::Mut)) &&\n                           isolated_self(self, 3) {\n                     self.bump();\n-                    let lt = self.parse_lifetime()?;\n+                    let lt = self.eat_lifetime().expect(\"not a lifetime\");\n                     self.bump();\n                     (SelfKind::Region(Some(lt), Mutability::Mutable), expect_ident(self))\n                 } else {\n@@ -4855,8 +4710,12 @@ impl<'a> Parser<'a> {\n         let ident = self.parse_ident()?;\n         let mut tps = self.parse_generics()?;\n \n-        // Parse supertrait bounds.\n-        let bounds = self.parse_colon_then_ty_param_bounds()?;\n+        // Parse optional colon and supertrait bounds.\n+        let bounds = if self.eat(&token::Colon) {\n+            self.parse_ty_param_bounds()?\n+        } else {\n+            Vec::new()\n+        };\n \n         tps.where_clause = self.parse_where_clause()?;\n \n@@ -4947,17 +4806,21 @@ impl<'a> Parser<'a> {\n \n     /// Parse a::B<String,i32>\n     fn parse_trait_ref(&mut self) -> PResult<'a, TraitRef> {\n-        Ok(ast::TraitRef {\n+        Ok(TraitRef {\n             path: self.parse_path(PathStyle::Type)?,\n             ref_id: ast::DUMMY_NODE_ID,\n         })\n     }\n \n-    fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<ast::LifetimeDef>> {\n+    fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<LifetimeDef>> {\n         if self.eat_keyword(keywords::For) {\n-            self.expect(&token::Lt)?;\n-            let lifetime_defs = self.parse_lifetime_defs(None)?;\n+            self.expect_lt()?;\n+            let (lifetime_defs, ty_params) = self.parse_generic_params()?;\n             self.expect_gt()?;\n+            if !ty_params.is_empty() {\n+                self.span_err(ty_params[0].span,\n+                              \"only lifetime parameters can be used in this context\");\n+            }\n             Ok(lifetime_defs)\n         } else {\n             Ok(Vec::new())\n@@ -4969,7 +4832,7 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n \n-        Ok(ast::PolyTraitRef {\n+        Ok(PolyTraitRef {\n             bound_lifetimes: lifetime_defs,\n             trait_ref: self.parse_trait_ref()?,\n             span: mk_sp(lo, self.prev_span.hi),"}, {"sha": "0f0c6d0ca83f5f01a333de4f542a9755f7966786", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -80,6 +80,28 @@ impl Lit {\n     }\n }\n \n+fn ident_can_begin_expr(ident: ast::Ident) -> bool {\n+    let ident_token: Token = Ident(ident);\n+\n+    !ident_token.is_any_keyword() ||\n+    ident_token.is_path_segment_keyword() ||\n+    [\n+        keywords::Box.name(),\n+        keywords::Break.name(),\n+        keywords::Continue.name(),\n+        keywords::False.name(),\n+        keywords::For.name(),\n+        keywords::If.name(),\n+        keywords::Loop.name(),\n+        keywords::Match.name(),\n+        keywords::Move.name(),\n+        keywords::Return.name(),\n+        keywords::True.name(),\n+        keywords::Unsafe.name(),\n+        keywords::While.name(),\n+    ].contains(&ident.name)\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug)]\n pub enum Token {\n     /* Expression-operator symbols. */\n@@ -163,7 +185,7 @@ impl Token {\n     pub fn can_begin_expr(&self) -> bool {\n         match *self {\n             OpenDelim(..)               => true,\n-            Ident(..)                   => true,\n+            Ident(ident)                => ident_can_begin_expr(ident),\n             Literal(..)                 => true,\n             Not                         => true,\n             BinOp(Minus)                => true,\n@@ -187,6 +209,29 @@ impl Token {\n         }\n     }\n \n+    /// Returns `true` if the token can appear at the start of a type.\n+    pub fn can_begin_type(&self) -> bool {\n+        match *self {\n+            OpenDelim(Paren)            => true, // tuple\n+            OpenDelim(Bracket)          => true, // array\n+            Ident(..)                   => true, // type name or keyword\n+            Underscore                  => true, // placeholder\n+            Not                         => true, // never\n+            BinOp(Star)                 => true, // raw pointer\n+            BinOp(And)                  => true, // reference\n+            AndAnd                      => true, // double reference\n+            Lt | BinOp(Shl)             => true, // associated path\n+            ModSep                      => true, // global path\n+            Interpolated(ref nt) => match **nt {\n+                NtTy(..) => true,\n+                NtIdent(..) => true,\n+                NtPath(..) => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        }\n+    }\n+\n     /// Returns `true` if the token is any literal\n     pub fn is_lit(&self) -> bool {\n         match *self {"}, {"sha": "c278171aa109a81120433777fafd9a4504dedb53", "filename": "src/libsyntax/symbol.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibsyntax%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibsyntax%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsymbol.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -140,7 +140,7 @@ macro_rules! declare_keywords {(\n         $(\n             #[allow(non_upper_case_globals)]\n             pub const $konst: Keyword = Keyword {\n-                ident: ast::Ident::with_empty_ctxt(ast::Name($index))\n+                ident: ast::Ident::with_empty_ctxt(super::Symbol($index))\n             };\n         )*\n     }\n@@ -282,25 +282,24 @@ impl Encodable for InternedString {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use ast::Name;\n \n     #[test]\n     fn interner_tests() {\n         let mut i: Interner = Interner::new();\n         // first one is zero:\n-        assert_eq!(i.intern(\"dog\"), Name(0));\n+        assert_eq!(i.intern(\"dog\"), Symbol(0));\n         // re-use gets the same entry:\n-        assert_eq!(i.intern (\"dog\"), Name(0));\n+        assert_eq!(i.intern (\"dog\"), Symbol(0));\n         // different string gets a different #:\n-        assert_eq!(i.intern(\"cat\"), Name(1));\n-        assert_eq!(i.intern(\"cat\"), Name(1));\n+        assert_eq!(i.intern(\"cat\"), Symbol(1));\n+        assert_eq!(i.intern(\"cat\"), Symbol(1));\n         // dog is still at zero\n-        assert_eq!(i.intern(\"dog\"), Name(0));\n+        assert_eq!(i.intern(\"dog\"), Symbol(0));\n         // gensym gets 3\n-        assert_eq!(i.gensym(\"zebra\"), Name(2));\n+        assert_eq!(i.gensym(\"zebra\"), Symbol(2));\n         // gensym of same string gets new number :\n-        assert_eq!(i.gensym(\"zebra\"), Name(3));\n+        assert_eq!(i.gensym(\"zebra\"), Symbol(3));\n         // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(\"dog\"), Name(4));\n+        assert_eq!(i.gensym(\"dog\"), Symbol(4));\n     }\n }"}, {"sha": "86b0fcebeb21ecf0d37548bf007e12ea3d4c378b", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -17,7 +17,7 @@\n //! expansion).\n //!\n //! ## Ownership\n-//! TokenStreams are persistant data structures construced as ropes with reference\n+//! TokenStreams are persistent data structures constructed as ropes with reference\n //! counted-children. In general, this means that calling an operation on a TokenStream\n //! (such as `slice`) produces an entirely new TokenStream from the borrowed reference to\n //! the original. This essentially coerces TokenStreams into 'views' of their subparts,"}, {"sha": "2a14b3da7b7d01ecc43cb056f5bbca9fc7fe9ecf", "filename": "src/rt/rust_test_helpers.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Frt%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Frt%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.c?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -269,7 +269,7 @@ LARGE_INTEGER increment_all_parts(LARGE_INTEGER li) {\n     return li;\n }\n \n-#if !(defined(WIN32) || defined(_WIN32) || defined(__WIN32)) && defined(__amd64__)\n+#if __SIZEOF_INT128__ == 16\n \n unsigned __int128 identity(unsigned __int128 a) {\n     return a;"}, {"sha": "14c9c5544b188561d41302d3a22ac5a6dcbc32ee", "filename": "src/rustc/std_shim/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Frustc%2Fstd_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Frustc%2Fstd_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fstd_shim%2FCargo.toml?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -21,7 +21,7 @@\n \n [package]\n name = \"std_shim\"\n-version = \"0.1.0\"\n+version = \"0.0.0\"\n authors = [\"The Rust Project Developers\"]\n \n [lib]"}, {"sha": "6ef613eee06281060bed344fae9cbc7448a5c215", "filename": "src/rustc/test_shim/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Frustc%2Ftest_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Frustc%2Ftest_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ftest_shim%2FCargo.toml?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -5,7 +5,7 @@\n \n [package]\n name = \"test_shim\"\n-version = \"0.1.0\"\n+version = \"0.0.0\"\n authors = [\"The Rust Project Developers\"]\n \n [lib]"}, {"sha": "34ee7d552f346f7ad1b578a75c905971917b5cb3", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -1082,14 +1082,6 @@ extern \"C\" void LLVMRustAddHandler(LLVMValueRef CatchSwitchRef,\n #endif\n }\n \n-extern \"C\" void LLVMRustSetPersonalityFn(LLVMBuilderRef B,\n-                                         LLVMValueRef Personality) {\n-#if LLVM_VERSION_GE(3, 8)\n-  unwrap(B)->GetInsertBlock()->getParent()->setPersonalityFn(\n-      cast<Function>(unwrap(Personality)));\n-#endif\n-}\n-\n #if LLVM_VERSION_GE(3, 8)\n extern \"C\" OperandBundleDef *LLVMRustBuildOperandBundleDef(const char *Name,\n                                                            LLVMValueRef *Inputs,"}, {"sha": "61b1a0a0b4d25a702fe28a2b9fbc19696fd51935", "filename": "src/test/compile-fail-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -36,11 +36,9 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_macro(\"identity\", expand_identity);\n     reg.register_syntax_extension(\n         Symbol::intern(\"into_multi_foo\"),\n-        // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiModifier(Box::new(expand_into_foo_multi)));\n     reg.register_syntax_extension(\n         Symbol::intern(\"duplicate\"),\n-        // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiDecorator(Box::new(expand_duplicate)));\n }\n "}, {"sha": "b9839edea2dc4e5b4e39e6423e53525341c60b61", "filename": "src/test/compile-fail-fulldeps/explore-issue-38412.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail-fulldeps%2Fexplore-issue-38412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail-fulldeps%2Fexplore-issue-38412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fexplore-issue-38412.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -25,21 +25,14 @@ use pub_and_stability::{Record, Trait, Tuple};\n fn main() {\n     // Okay\n     let Record { .. } = Record::new();\n-    // Okay (for now; see RFC Issue #902)\n-    let Tuple(..) = Tuple::new();\n \n     // Okay\n     let Record { a_stable_pub: _, a_unstable_declared_pub: _, .. } = Record::new();\n-    // Okay (for now; see RFC Issue #902)\n-    let Tuple(_, _, ..) = Tuple::new(); // analogous to above\n \n     let Record { a_stable_pub: _, a_unstable_declared_pub: _, a_unstable_undeclared_pub: _, .. } =\n         Record::new();\n     //~^^ ERROR use of unstable library feature 'unstable_undeclared'\n \n-    let Tuple(_, _, _, ..) = Tuple::new(); // analogous to previous\n-    //~^ ERROR use of unstable library feature 'unstable_undeclared'\n-\n     let r = Record::new();\n     let t = Tuple::new();\n "}, {"sha": "22c92623e1c1944b9168b0ba2d7747eab2a00583", "filename": "src/test/compile-fail-fulldeps/gated-macro-reexports.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-macro-reexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-macro-reexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-macro-reexports.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -11,6 +11,7 @@\n // Test that macro reexports item are gated by `macro_reexport` feature gate.\n \n // aux-build:macro_reexport_1.rs\n+// gate-test-macro_reexport\n \n #![crate_type = \"dylib\"]\n "}, {"sha": "51a9a87744a2058062afcdd7318d868ff2e21bef", "filename": "src/test/compile-fail-fulldeps/gated-quote.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-quote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-quote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-quote.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -15,6 +15,8 @@\n \n // FIXME the error message that is current emitted seems pretty bad.\n \n+// gate-test-quote\n+\n #![feature(rustc_private)]\n #![allow(dead_code, unused_imports, unused_variables)]\n "}, {"sha": "d5644ab0608877a2fd5ad62d4f2fb768abcdaa03", "filename": "src/test/compile-fail/E0106.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2FE0106.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2FE0106.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0106.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -23,5 +23,17 @@ type MyStr = &str;\n         //~^ ERROR E0106\n         //~| NOTE expected lifetime parameter\n \n+struct Baz<'a>(&'a str);\n+struct Buzz<'a, 'b>(&'a str, &'b str);\n+\n+struct Quux {\n+    baz: Baz,\n+    //~^ ERROR E0106\n+    //~| expected lifetime parameter\n+    buzz: Buzz,\n+    //~^ ERROR E0106\n+    //~| expected 2 lifetime parameters\n+}\n+\n fn main() {\n }"}, {"sha": "16ebd3e9ca5f2abfa3d3b4f92a0a28a2e058479d", "filename": "src/test/compile-fail/E0107.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2FE0107.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2FE0107.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0107.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -18,9 +18,6 @@ enum Bar {\n }\n \n struct Baz<'a, 'b, 'c> {\n-    foo: Foo,\n-    //~^ ERROR E0107\n-    //~| expected 1 lifetime parameter\n     buzz: Buzz<'a>,\n     //~^ ERROR E0107\n     //~| expected 2 lifetime parameters"}, {"sha": "4ba9c3382f35d4792219ac0f5b54f559eefcaf6d", "filename": "src/test/compile-fail/E0117.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2FE0117.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2FE0117.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0117.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -11,6 +11,7 @@\n impl Drop for u32 {} //~ ERROR E0117\n //~^ NOTE impl doesn't use types inside crate\n //~| NOTE the impl does not reference any types defined in this crate\n+//~| NOTE define and implement a trait or new type instead\n \n fn main() {\n }"}, {"sha": "1131e8e1b01cae69a1c19043442f149ce935e3c7", "filename": "src/test/compile-fail/E0206.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2FE0206.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2FE0206.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0206.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -16,6 +16,7 @@ impl Copy for Foo { }\n //~| ERROR only traits defined in the current crate can be implemented for arbitrary types\n //~| NOTE impl doesn't use types inside crate\n //~| NOTE the impl does not reference any types defined in this crate\n+//~| NOTE define and implement a trait or new type instead\n \n #[derive(Copy, Clone)]\n struct Bar;"}, {"sha": "ace96c9983e66612097228f6a949778e797cf0f0", "filename": "src/test/compile-fail/E0451.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2FE0451.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2FE0451.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0451.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -25,11 +25,6 @@ fn pat_match(foo: Bar::Foo) {\n                                   //~^ NOTE field `b` is private\n }\n \n-fn pat_match_tuple(foo: Bar::FooTuple) {\n-    let Bar::FooTuple(a,b) = foo; //~ ERROR E0451\n-                                  //~^ NOTE field `1` is private\n-}\n-\n fn main() {\n     let f = Bar::Foo{ a: 0, b: 0 }; //~ ERROR E0451\n                                     //~^ NOTE field `b` is private"}, {"sha": "e6251a0d318a35321da6f640bada3adb1528adeb", "filename": "src/test/compile-fail/associated-types-project-from-hrtb-in-struct.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-project-from-hrtb-in-struct.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -22,10 +22,11 @@ struct SomeStruct<I : for<'x> Foo<&'x isize>> {\n     //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n }\n \n-struct AnotherStruct<I : for<'x> Foo<&'x isize>> {\n-    field: <I as Foo<&isize>>::A\n-    //~^ ERROR missing lifetime specifier\n-}\n+// FIXME(eddyb) This one doesn't even compile because of the unsupported syntax.\n+\n+// struct AnotherStruct<I : for<'x> Foo<&'x isize>> {\n+//     field: <I as for<'y> Foo<&'y isize>>::A\n+// }\n \n struct YetAnotherStruct<'a, I : for<'x> Foo<&'x isize>> {\n     field: <I as Foo<&'a isize>>::A"}, {"sha": "5e09473ab77da9ee2987123bc7c740a158247908", "filename": "src/test/compile-fail/attrs-with-no-formal-in-generics-2.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fattrs-with-no-formal-in-generics-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fattrs-with-no-formal-in-generics-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattrs-with-no-formal-in-generics-2.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -17,10 +17,7 @@\n \n struct RefAny<'a, T>(&'a T);\n \n-impl<#[rustc_1] 'a, #[rustc_2] T, #[oops]> RefAny<'a, T> {\n-    //~^ ERROR expected identifier, found `>`\n-}\n+impl<#[rustc_1] 'a, #[rustc_2] T, #[oops]> RefAny<'a, T> {}\n+//~^ ERROR trailing attribute after type parameters\n \n-fn main() {\n-\n-}\n+fn main() {}"}, {"sha": "c152fdd9296828b590e80b32e0d3116cba94a02c", "filename": "src/test/compile-fail/autoderef-full-lval.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -22,13 +22,14 @@ struct fish {\n fn main() {\n     let a: clam = clam{x: box 1, y: box 2};\n     let b: clam = clam{x: box 10, y: box 20};\n-    let z: isize = a.x + b.y; //~ ERROR binary operation `+` cannot be applied to type `Box<isize>`\n+    let z: isize = a.x + b.y;\n+    //~^ ERROR binary operation `+` cannot be applied to type `std::boxed::Box<isize>`\n     println!(\"{}\", z);\n     assert_eq!(z, 21);\n     let forty: fish = fish{a: box 40};\n     let two: fish = fish{a: box 2};\n     let answer: isize = forty.a + two.a;\n-    //~^ ERROR binary operation `+` cannot be applied to type `Box<isize>`\n+    //~^ ERROR binary operation `+` cannot be applied to type `std::boxed::Box<isize>`\n     println!(\"{}\", answer);\n     assert_eq!(answer, 42);\n }"}, {"sha": "a49cfaa17606dfcad53844dd0f3351440a9dd77f", "filename": "src/test/compile-fail/binary-op-on-double-ref.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fbinary-op-on-double-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fbinary-op-on-double-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinary-op-on-double-ref.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let vr = v.iter().filter(|x| {\n+        x % 2 == 0\n+        //~^ ERROR binary operation `%` cannot be applied to type `&&{integer}`\n+        //~| NOTE this is a reference of type that `%` can be applied to\n+        //~| NOTE an implementation of `std::ops::Rem` might be missing for `&&{integer}`\n+    });\n+    println!(\"{:?}\", vr);\n+}"}, {"sha": "f58eca7c8ae39229b8d75910cebcb205e37119ec", "filename": "src/test/compile-fail/borrowck/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -17,7 +17,6 @@ use std::collections::HashMap;\n fn main() {\n     let tmp: Box<_>;\n     let mut buggy_map: HashMap<usize, &usize> = HashMap::new();\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     buggy_map.insert(42, &*Box::new(1)); //~ ERROR borrowed value does not live long enough\n \n     // but it is ok if we use a temporary"}, {"sha": "d09cb73d6702a5536863185b88da86dced16ac73", "filename": "src/test/compile-fail/borrowck/borrowck-box-insensitivity.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-box-insensitivity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-box-insensitivity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-box-insensitivity.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -35,7 +35,7 @@ fn copy_after_move() {\n     let _x = a.x;\n     //~^ value moved here\n     let _y = a.y; //~ ERROR use of moved\n-    //~^ move occurs because `a.x` has type `Box<isize>`\n+    //~^ move occurs because `a.x` has type `std::boxed::Box<isize>`\n     //~| value used here after move\n }\n \n@@ -44,7 +44,7 @@ fn move_after_move() {\n     let _x = a.x;\n     //~^ value moved here\n     let _y = a.y; //~ ERROR use of moved\n-    //~^ move occurs because `a.x` has type `Box<isize>`\n+    //~^ move occurs because `a.x` has type `std::boxed::Box<isize>`\n     //~| value used here after move\n }\n \n@@ -53,7 +53,7 @@ fn borrow_after_move() {\n     let _x = a.x;\n     //~^ value moved here\n     let _y = &a.y; //~ ERROR use of moved\n-    //~^ move occurs because `a.x` has type `Box<isize>`\n+    //~^ move occurs because `a.x` has type `std::boxed::Box<isize>`\n     //~| value used here after move\n }\n \n@@ -106,7 +106,7 @@ fn copy_after_move_nested() {\n     let _x = a.x.x;\n     //~^ value moved here\n     let _y = a.y; //~ ERROR use of collaterally moved\n-    //~^ NOTE move occurs because `a.x.x` has type `Box<isize>`\n+    //~^ NOTE move occurs because `a.x.x` has type `std::boxed::Box<isize>`\n     //~| value used here after move\n }\n \n@@ -115,7 +115,7 @@ fn move_after_move_nested() {\n     let _x = a.x.x;\n     //~^ value moved here\n     let _y = a.y; //~ ERROR use of collaterally moved\n-    //~^ NOTE move occurs because `a.x.x` has type `Box<isize>`\n+    //~^ NOTE move occurs because `a.x.x` has type `std::boxed::Box<isize>`\n     //~| value used here after move\n }\n \n@@ -124,7 +124,7 @@ fn borrow_after_move_nested() {\n     let _x = a.x.x;\n     //~^ value moved here\n     let _y = &a.y; //~ ERROR use of collaterally moved\n-    //~^ NOTE move occurs because `a.x.x` has type `Box<isize>`\n+    //~^ NOTE move occurs because `a.x.x` has type `std::boxed::Box<isize>`\n     //~| value used here after move\n }\n "}, {"sha": "68f219c6ed9935830b40f714c3a1a4be42dcc544", "filename": "src/test/compile-fail/can-begin-expr-check.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fcan-begin-expr-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fcan-begin-expr-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcan-begin-expr-check.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+\n+    return;\n+    return ();\n+    return as ();\n+    return return as ();\n+    return return return;\n+\n+    return if true {\n+        ()\n+    } else {\n+        ()\n+    };\n+\n+    loop {\n+        return break as ();\n+    }\n+\n+    return enum; //~ ERROR expected one of `.`, `;`, `?`, `}`, or an operator, found `enum`\n+}"}, {"sha": "fe121a3bc48ffbaac5a6f07e5b7eedbed60f4bb3", "filename": "src/test/compile-fail/coherence-impls-copy.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -37,6 +37,7 @@ impl Copy for (MyType, MyType) {}\n //~| ERROR only traits defined in the current crate can be implemented for arbitrary types\n //~| NOTE impl doesn't use types inside crate\n //~| NOTE the impl does not reference any types defined in this crate\n+//~| NOTE define and implement a trait or new type instead\n \n impl Copy for &'static NotSync {}\n //~^ ERROR the trait `Copy` may not be implemented for this type\n@@ -46,15 +47,17 @@ impl Copy for [MyType] {}\n //~^ ERROR the trait `Copy` may not be implemented for this type\n //~| NOTE type is not a structure or enumeration\n //~| ERROR only traits defined in the current crate can be implemented for arbitrary types\n-//~| NOTE impl doesn't use types inside crate\n //~| NOTE the impl does not reference any types defined in this crate\n+//~| NOTE define and implement a trait or new type instead\n+//~| NOTE impl doesn't use types inside crate\n \n impl Copy for &'static [NotSync] {}\n //~^ ERROR the trait `Copy` may not be implemented for this type\n //~| NOTE type is not a structure or enumeration\n //~| ERROR only traits defined in the current crate can be implemented for arbitrary types\n //~| NOTE impl doesn't use types inside crate\n //~| NOTE the impl does not reference any types defined in this crate\n+//~| NOTE define and implement a trait or new type instead\n \n fn main() {\n }"}, {"sha": "e5afccb9cf3943080ae12feb22ce6675f4ccced6", "filename": "src/test/compile-fail/cross-borrow-trait.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-borrow-trait.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -16,10 +16,8 @@ trait Trait { fn foo(&self) {} }\n impl Trait for Foo {}\n \n pub fn main() {\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let x: Box<Trait> = Box::new(Foo);\n     let _y: &Trait = x; //~  ERROR mismatched types\n                         //~| expected type `&Trait`\n-                        //~| found type `Box<Trait>`\n-                        //~| expected &Trait, found box\n+                        //~| found type `std::boxed::Box<Trait>`\n }"}, {"sha": "835ec8e4a5e7e2060328e2a32e36eb948a056d2c", "filename": "src/test/compile-fail/destructure-trait-ref.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -51,6 +51,5 @@ fn main() {\n     let box box x = box 1isize as Box<T>;\n     //~^ ERROR mismatched types\n     //~| expected type `T`\n-    //~| found type `Box<_>`\n-    //~| expected trait T, found box\n+    //~| found type `std::boxed::Box<_>`\n }"}, {"sha": "10c8f1eed00b0dfe89e26e241c48f738d69db49d", "filename": "src/test/compile-fail/dst-bad-assign-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -41,7 +41,6 @@ impl ToBar for Bar1 {\n pub fn main() {\n     // Assignment.\n     let f5: &mut Fat<ToBar> = &mut Fat { f1: 5, f2: \"some str\", ptr: Bar1 {f :42} };\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let z: Box<ToBar> = Box::new(Bar1 {f: 36});\n     f5.ptr = *z;\n     //~^ ERROR `ToBar: std::marker::Sized` is not satisfied"}, {"sha": "4f7d07600ad154e68712ea96b736c627d8161d0c", "filename": "src/test/compile-fail/dst-bad-assign.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -41,7 +41,6 @@ impl ToBar for Bar1 {\n pub fn main() {\n     // Assignment.\n     let f5: &mut Fat<ToBar> = &mut Fat { f1: 5, f2: \"some str\", ptr: Bar1 {f :42} };\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let z: Box<ToBar> = Box::new(Bar1 {f: 36});\n     f5.ptr = Bar1 {f: 36};\n     //~^ ERROR mismatched types"}, {"sha": "6377550d3d22f9ed5297d366a7f5130a320ef4c6", "filename": "src/test/compile-fail/fn-trait-formatting.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -16,18 +16,15 @@ fn main() {\n     let _: () = (box |_: isize| {}) as Box<FnOnce(isize)>;\n     //~^ ERROR mismatched types\n     //~| expected type `()`\n-    //~| found type `Box<std::ops::FnOnce(isize)>`\n-    //~| expected (), found box\n+    //~| found type `std::boxed::Box<std::ops::FnOnce(isize)>`\n     let _: () = (box |_: isize, isize| {}) as Box<Fn(isize, isize)>;\n     //~^ ERROR mismatched types\n     //~| expected type `()`\n-    //~| found type `Box<std::ops::Fn(isize, isize)>`\n-    //~| expected (), found box\n+    //~| found type `std::boxed::Box<std::ops::Fn(isize, isize)>`\n     let _: () = (box || -> isize { unimplemented!() }) as Box<FnMut() -> isize>;\n     //~^ ERROR mismatched types\n     //~| expected type `()`\n-    //~| found type `Box<std::ops::FnMut() -> isize>`\n-    //~| expected (), found box\n+    //~| found type `std::boxed::Box<std::ops::FnMut() -> isize>`\n \n     needs_fn(1);\n     //~^ ERROR : std::ops::Fn<(isize,)>`"}, {"sha": "77e5520326379e21193ee7d5ff1320aa8fc9ba7b", "filename": "src/test/compile-fail/generic-non-trailing-defaults.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fgeneric-non-trailing-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fgeneric-non-trailing-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgeneric-non-trailing-defaults.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Heap;\n+\n+struct Vec<A = Heap, T>;\n+//~^ ERROR type parameters with a default must be trailing\n+\n+struct Foo<A, B = Vec<C>, C>;\n+//~^ ERROR type parameters with a default must be trailing\n+//~| ERROR type parameters with a default cannot use forward declared identifiers\n+\n+fn main() {}"}, {"sha": "0467c49b0311def45249af4a813e3eb2a18493f1", "filename": "src/test/compile-fail/impl-trait/disallowed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -26,9 +26,9 @@ trait LazyToString {\n     //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n }\n \n-// Note that the following impl doesn't error, because the trait is invalid.\n impl LazyToString for String {\n     fn lazy_to_string<'a>(&'a self) -> impl Fn() -> String {\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n         || self.clone()\n     }\n }"}, {"sha": "ce61c5bf63d830340818ede696f175033a2d37c2", "filename": "src/test/compile-fail/impl-trait/no-trait.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fno-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fno-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fno-trait.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+\n+fn f() -> impl 'static {} //~ ERROR at least one trait must be specified\n+\n+fn main() {}"}, {"sha": "d4e7dc7e9a35dfc705e0e5bdf36ee8159bcd12e4", "filename": "src/test/compile-fail/issue-10291.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n fn test<'x>(x: &'x isize) {\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     drop::<Box<for<'z> FnMut(&'z isize) -> &'z isize>>(Box::new(|z| {\n         x //~ ERROR E0312\n     }));"}, {"sha": "7afb8314ea689ffeba0615e449e18a503b16f2f1", "filename": "src/test/compile-fail/issue-11515.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-11515.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-11515.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11515.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -15,7 +15,6 @@ struct Test {\n }\n \n fn main() {\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let closure: Box<Fn()+'static> = Box::new(|| ());\n     let test = box Test { func: closure }; //~ ERROR mismatched types\n }"}, {"sha": "408c6d411de9030efb4b80371f4ee13cd1e5a2de", "filename": "src/test/compile-fail/issue-13058.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -20,7 +20,6 @@ impl<'r> Itble<'r, usize, Range<usize>> for (usize, usize) {\n }\n \n fn check<'r, I: Iterator<Item=usize>, T: Itble<'r, usize, I>>(cont: &T) -> bool\n-//~^ HELP as shown: fn check<'r, I: Iterator<Item = usize>, T: Itble<'r, usize, I>>(cont: &'r T)\n {\n     let cont_iter = cont.iter();\n //~^ ERROR cannot infer an appropriate lifetime for autoref due to conflicting requirements"}, {"sha": "810d6656a8f6216bbcbff41f7080332219a6673e", "filename": "src/test/compile-fail/issue-14915.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -13,5 +13,6 @@\n fn main() {\n     let x: Box<isize> = box 0;\n \n-    println!(\"{}\", x + 1); //~ ERROR binary operation `+` cannot be applied to type `Box<isize>`\n+    println!(\"{}\", x + 1);\n+    //~^ ERROR binary operation `+` cannot be applied to type `std::boxed::Box<isize>`\n }"}, {"sha": "bddc9c13815e741ef8d9b2b00928acc90236e1d9", "filename": "src/test/compile-fail/issue-17441.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-17441.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-17441.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17441.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -13,9 +13,8 @@ fn main() {\n     //~^ ERROR cast to unsized type: `&[usize; 2]` as `[usize]`\n     //~^^ HELP consider using an implicit coercion to `&[usize]` instead\n \n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let _bar = Box::new(1_usize) as std::fmt::Debug;\n-    //~^ ERROR cast to unsized type: `Box<usize>` as `std::fmt::Debug`\n+    //~^ ERROR cast to unsized type: `std::boxed::Box<usize>` as `std::fmt::Debug`\n     //~^^ HELP try casting to a `Box` instead\n \n     let _baz = 1_usize as std::fmt::Debug;"}, {"sha": "4996da057dd8ebc7be04358282479c5810b8a486", "filename": "src/test/compile-fail/issue-17651.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-17651.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-17651.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17651.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -12,7 +12,6 @@\n // and rejected.\n \n fn main() {\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     (|| Box::new(*(&[0][..])))();\n     //~^ ERROR `[{integer}]: std::marker::Sized` is not satisfied\n }"}, {"sha": "9a7b3781f1e24873ab6a627eb857695caa671176", "filename": "src/test/compile-fail/issue-18783.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-18783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-18783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18783.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -10,8 +10,6 @@\n \n use std::cell::RefCell;\n \n-// FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-\n fn main() {\n     let mut y = 1;\n     let c = RefCell::new(vec![]);"}, {"sha": "a1949df661a34a699e9708864f1ad069d16c3867", "filename": "src/test/compile-fail/issue-20616-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-1.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -16,7 +16,7 @@\n type Type_1_<'a, T> = &'a T;\n \n \n-type Type_1<'a T> = &'a T; //~ error: expected `,` or `>` after lifetime name, found `T`\n+type Type_1<'a T> = &'a T; //~ error: expected one of `,`, `:`, or `>`, found `T`\n \n \n //type Type_2 = Type_1_<'static ()>; // error: expected `,` or `>` after lifetime name, found `(`"}, {"sha": "87b836d68727480b74e09e10d68b37a26056daba", "filename": "src/test/compile-fail/issue-20616-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-2.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -19,7 +19,7 @@ type Type_1_<'a, T> = &'a T;\n //type Type_1<'a T> = &'a T; // error: expected `,` or `>` after lifetime name, found `T`\n \n \n-type Type_2 = Type_1_<'static ()>; //~ error: expected `,` or `>` after lifetime name, found `(`\n+type Type_2 = Type_1_<'static ()>; //~ error: expected one of `,` or `>`, found `(`\n \n \n //type Type_3<T> = Box<T,,>; // error: expected type, found `,`"}, {"sha": "e5ed46d2cb3b01c575be7f351eae779f0ce94d6d", "filename": "src/test/compile-fail/issue-20616-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-3.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -22,7 +22,7 @@ type Type_1_<'a, T> = &'a T;\n //type Type_2 = Type_1_<'static ()>; // error: expected `,` or `>` after lifetime name, found `(`\n \n \n-type Type_3<T> = Box<T,,>; //~ error: expected type, found `,`\n+type Type_3<T> = Box<T,,>; //~ error: expected one of `>`, identifier, lifetime, or type, found `,`\n \n \n //type Type_4<T> = Type_1_<'static,, T>; // error: expected type, found `,`"}, {"sha": "9b731289e138bd17aa845f7977fda72cbf40f508", "filename": "src/test/compile-fail/issue-20616-4.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-4.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -25,7 +25,8 @@ type Type_1_<'a, T> = &'a T;\n //type Type_3<T> = Box<T,,>; // error: expected type, found `,`\n \n \n-type Type_4<T> = Type_1_<'static,, T>; //~ error: expected type, found `,`\n+type Type_4<T> = Type_1_<'static,, T>;\n+//~^ error: expected one of `>`, identifier, lifetime, or type, found `,`\n \n \n type Type_5_<'a> = Type_1_<'a, ()>;"}, {"sha": "5e3b024da9a075c86f4726cd3e9cecff732857e8", "filename": "src/test/compile-fail/issue-20616-5.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-5.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -31,7 +31,8 @@ type Type_1_<'a, T> = &'a T;\n type Type_5_<'a> = Type_1_<'a, ()>;\n \n \n-type Type_5<'a> = Type_1_<'a, (),,>; //~ error: expected type, found `,`\n+type Type_5<'a> = Type_1_<'a, (),,>;\n+//~^ error: expected one of `>`, identifier, lifetime, or type, found `,`\n \n \n //type Type_6 = Type_5_<'a,,>; // error: expected type, found `,`"}, {"sha": "b6ee26f9f62b88a87be7445a4f779c1f10af3b99", "filename": "src/test/compile-fail/issue-20616-6.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-6.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -34,7 +34,8 @@ type Type_5_<'a> = Type_1_<'a, ()>;\n //type Type_5<'a> = Type_1_<'a, (),,>; // error: expected type, found `,`\n \n \n-type Type_6 = Type_5_<'a,,>; //~ error: expected type, found `,`\n+type Type_6 = Type_5_<'a,,>;\n+//~^ error: expected one of `>`, identifier, lifetime, or type, found `,`\n \n \n //type Type_7 = Box<(),,>; // error: expected type, found `,`"}, {"sha": "fef3dd4e31d5ad787e6beb68815ccc307055e1bf", "filename": "src/test/compile-fail/issue-20616-7.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-7.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -37,7 +37,7 @@ type Type_5_<'a> = Type_1_<'a, ()>;\n //type Type_6 = Type_5_<'a,,>; // error: expected type, found `,`\n \n \n-type Type_7 = Box<(),,>; //~ error: expected type, found `,`\n+type Type_7 = Box<(),,>; //~ error: expected one of `>`, identifier, lifetime, or type, found `,`\n \n \n //type Type_8<'a,,> = &'a (); // error: expected ident, found `,`"}, {"sha": "b7bef47c4f4425bed0f00262cb6b6bf602036ef2", "filename": "src/test/compile-fail/issue-20616-8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-8.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -40,7 +40,7 @@ type Type_5_<'a> = Type_1_<'a, ()>;\n //type Type_7 = Box<(),,>; // error: expected type, found `,`\n \n \n-type Type_8<'a,,> = &'a (); //~ error: expected identifier, found `,`\n+type Type_8<'a,,> = &'a (); //~ error: expected one of `>`, identifier, or lifetime, found `,`\n \n \n //type Type_9<T,,> = Box<T>; // error: expected identifier, found `,`"}, {"sha": "5c16d24cef854e1ac2a458a313a85916f0e44ba9", "filename": "src/test/compile-fail/issue-20616-9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-20616-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20616-9.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -43,4 +43,4 @@ type Type_5_<'a> = Type_1_<'a, ()>;\n //type Type_8<'a,,> = &'a (); // error: expected identifier, found `,`\n \n \n-type Type_9<T,,> = Box<T>; //~ error: expected identifier, found `,`\n+type Type_9<T,,> = Box<T>; //~ error: expected one of `>`, identifier, or lifetime, found `,`"}, {"sha": "851f5dfeabe8ac31fa90ce61c8d6f96093ff6f84", "filename": "src/test/compile-fail/issue-3763.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-3763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-3763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3763.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -25,13 +25,11 @@ fn main() {\n     let _woohoo = (&my_struct).priv_field;\n     //~^ ERROR field `priv_field` of struct `my_mod::MyStruct` is private\n \n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let _woohoo = (Box::new(my_struct)).priv_field;\n     //~^ ERROR field `priv_field` of struct `my_mod::MyStruct` is private\n \n     (&my_struct).happyfun();               //~ ERROR method `happyfun` is private\n \n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     (Box::new(my_struct)).happyfun();          //~ ERROR method `happyfun` is private\n     let nope = my_struct.priv_field;\n     //~^ ERROR field `priv_field` of struct `my_mod::MyStruct` is private"}, {"sha": "3b62aaf2ab8e9450789eca11ffa54610af1bc333", "filename": "src/test/compile-fail/issue-38412.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-38412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-38412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-38412.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -10,7 +10,8 @@\n \n fn main() {\n     let Box(a) = loop { };\n-    //~^ ERROR field `0` of struct `std::boxed::Box` is private\n+    //~^ ERROR expected tuple struct/variant, found struct `Box`\n+    //~| ERROR expected tuple struct/variant, found struct `Box`\n \n     // (The below is a trick to allow compiler to infer a type for\n     // variable `a` without attempting to ascribe a type to the"}, {"sha": "c5aae894c3ecbc44c60b6de14a7dae510442b6c6", "filename": "src/test/compile-fail/issue-4335.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -13,7 +13,6 @@\n fn id<T>(t: T) -> T { t }\n \n fn f<'r, T>(v: &'r T) -> Box<FnMut() -> T + 'r> {\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     id(Box::new(|| *v))\n         //~^ ERROR E0373\n         //~| NOTE `v` is borrowed here"}, {"sha": "9ef780aac8e274bdac62fe6c40651292c7fea658", "filename": "src/test/compile-fail/issue-5100.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -43,8 +43,7 @@ fn main() {\n         box (true, false) => ()\n //~^ ERROR mismatched types\n //~| expected type `(bool, bool)`\n-//~| found type `Box<_>`\n-//~| expected tuple, found box\n+//~| found type `std::boxed::Box<_>`\n     }\n \n     match (true, false) {"}, {"sha": "b99f5b707ee2d0afbe5df1401acb17827fff7129", "filename": "src/test/compile-fail/issue-7061.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-7061.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fissue-7061.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7061.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -13,9 +13,8 @@ struct BarStruct;\n impl<'a> BarStruct {\n     fn foo(&'a mut self) -> Box<BarStruct> { self }\n     //~^ ERROR mismatched types\n-    //~| expected type `Box<BarStruct>`\n+    //~| expected type `std::boxed::Box<BarStruct>`\n     //~| found type `&'a mut BarStruct`\n-    //~| expected box, found mutable reference\n }\n \n fn main() {}"}, {"sha": "21aefc4f9c1bc1b1e7a8098584d401114c00a570", "filename": "src/test/compile-fail/kindck-impl-type-params-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params-2.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -21,5 +21,5 @@ fn take_param<T:Foo>(foo: &T) { }\n fn main() {\n     let x: Box<_> = box 3;\n     take_param(&x);\n-    //~^ ERROR `Box<{integer}>: std::marker::Copy` is not satisfied\n+    //~^ ERROR `std::boxed::Box<{integer}>: std::marker::Copy` is not satisfied\n }"}, {"sha": "43371eb6340f434d89aa8b903fe5cf4e463586ef", "filename": "src/test/compile-fail/lifetime-elision-return-type-requires-explicit-lifetime.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -38,4 +38,28 @@ fn i(_x: isize) -> &isize { //~ ERROR missing lifetime specifier\n     panic!()\n }\n \n+// Cases which used to work but now don't.\n+\n+type StaticStr = &'static str; // hides 'static\n+trait WithLifetime<'a> {\n+    type Output; // can hide 'a\n+}\n+\n+// This worked because the type of the first argument contains\n+// 'static, although StaticStr doesn't even have parameters.\n+fn j(_x: StaticStr) -> &isize { //~ ERROR missing lifetime specifier\n+//~^ HELP this function's return type contains a borrowed value\n+//~| HELP consider giving it an explicit bounded or 'static lifetime\n+    panic!()\n+}\n+\n+// This worked because the compiler resolved the argument type\n+// to <T as WithLifetime<'a>>::Output which has the hidden 'a.\n+fn k<'a, T: WithLifetime<'a>>(_x: T::Output) -> &isize {\n+//~^ ERROR missing lifetime specifier\n+//~| HELP this function's return type contains a borrowed value\n+//~| HELP consider giving it an explicit bounded or 'static lifetime\n+    panic!()\n+}\n+\n fn main() {}"}, {"sha": "d2d0dbf3e981fe3fa32a24d7eb7d9bd32b8cbac4", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param-2.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ecda7f314fa79bbfbf2125c99fd66288ca83c875/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecda7f314fa79bbfbf2125c99fd66288ca83c875/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs?ref=ecda7f314fa79bbfbf2125c99fd66288ca83c875", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-\n-use std::ops::Range;\n-\n-trait Itble<'r, T, I: Iterator<Item=T>> { fn iter(&'r self) -> I; }\n-\n-impl<'r> Itble<'r, usize, Range<usize>> for (usize, usize) {\n-    fn iter(&'r self) -> Range<usize> {\n-        let &(min, max) = self;\n-        min..max\n-    }\n-}\n-\n-fn check<'r, I: Iterator<Item=usize>, T: Itble<'r, usize, I>>(cont: &T) -> bool {\n-//~^ HELP: consider using an explicit lifetime parameter as shown: fn check<'r, I: Iterator<Item = usize>, T: Itble<'r, usize, I>>(cont: &'r T)\n-    let cont_iter = cont.iter(); //~ ERROR: cannot infer\n-    let result = cont_iter.fold(Some(0), |state, val| {\n-        state.map_or(None, |mask| {\n-            let bit = 1 << val;\n-            if mask & bit == 0 {Some(mask|bit)} else {None}\n-        })\n-    });\n-    result.is_some()\n-}\n-\n-fn main() {}"}, {"sha": "6b22d434804ffecafc2b56e71c8140e1ae6e5428", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param-3.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ecda7f314fa79bbfbf2125c99fd66288ca83c875/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecda7f314fa79bbfbf2125c99fd66288ca83c875/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs?ref=ecda7f314fa79bbfbf2125c99fd66288ca83c875", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-\n-use std::marker::PhantomData;\n-\n-struct Bar<'x, 'y, 'z> { bar: &'y i32, baz: i32, marker: PhantomData<(&'x(),&'y(),&'z())> }\n-fn bar1<'a>(x: &Bar) -> (&'a i32, &'a i32, &'a i32) {\n-    //~^ HELP consider using an explicit lifetime parameter as shown: fn bar1<'b, 'c, 'a>(x: &'a Bar<'b, 'a, 'c>) -> (&'a i32, &'a i32, &'a i32)\n-    (x.bar, &x.baz, &x.baz)\n-    //~^ ERROR E0312\n-    //~| ERROR cannot infer\n-    //~| ERROR cannot infer\n-}\n-\n-fn bar2<'a, 'b, 'c>(x: &Bar<'a, 'b, 'c>) -> (&'a i32, &'a i32, &'a i32) {\n-    //~^ HELP: consider using an explicit lifetime parameter as shown: fn bar2<'a, 'c>(x: &'a Bar<'a, 'a, 'c>) -> (&'a i32, &'a i32, &'a i32)\n-    (x.bar, &x.baz, &x.baz)\n-    //~^ ERROR E0312\n-    //~| ERROR cannot infer\n-    //~| ERROR cannot infer\n-}\n-\n-fn main() { }"}, {"sha": "4323929e2e37a7cc07827fa3cccbde3cb06d72dd", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param.rs", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ecda7f314fa79bbfbf2125c99fd66288ca83c875/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecda7f314fa79bbfbf2125c99fd66288ca83c875/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs?ref=ecda7f314fa79bbfbf2125c99fd66288ca83c875", "patch": "@@ -1,57 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-\n-use std::marker::PhantomData;\n-\n-struct Foo<'x> { bar: isize, marker: PhantomData<&'x ()> }\n-fn foo1<'a>(x: &Foo) -> &'a isize {\n-//~^ HELP: consider using an explicit lifetime parameter as shown: fn foo1<'a>(x: &'a Foo) -> &'a isize\n-    &x.bar //~ ERROR: cannot infer\n-}\n-\n-fn foo2<'a, 'b>(x: &'a Foo) -> &'b isize {\n-//~^ HELP: consider using an explicit lifetime parameter as shown: fn foo2<'a>(x: &'a Foo) -> &'a isize\n-    &x.bar //~ ERROR: cannot infer\n-}\n-\n-fn foo3<'a>(x: &Foo) -> (&'a isize, &'a isize) {\n-//~^ HELP: consider using an explicit lifetime parameter as shown: fn foo3<'a>(x: &'a Foo) -> (&'a isize, &'a isize)\n-    (&x.bar, &x.bar) //~ ERROR: cannot infer\n-    //~^ ERROR: cannot infer\n-}\n-\n-fn foo4<'a, 'b>(x: &'a Foo) -> (&'b isize, &'a isize, &'b isize) {\n-//~^ HELP: consider using an explicit lifetime parameter as shown: fn foo4<'a>(x: &'a Foo) -> (&'a isize, &'a isize, &'a isize)\n-    (&x.bar, &x.bar, &x.bar) //~ ERROR: cannot infer\n-    //~^ ERROR: cannot infer\n-}\n-\n-struct Cat<'x, T> { cat: &'x isize, t: T }\n-struct Dog<'y> { dog: &'y isize }\n-\n-fn cat2<'x, 'y>(x: Cat<'x, Dog<'y>>) -> &'x isize {\n-    //~^ HELP consider using an explicit lifetime parameter as shown: fn cat2<'x>(x: Cat<'x, Dog<'x>>) -> &'x isize\n-    x.t.dog //~ ERROR E0312\n-}\n-\n-struct Baz<'x> {\n-    bar: &'x isize\n-}\n-\n-impl<'a> Baz<'a> {\n-    fn baz2<'b>(&self, x: &isize) -> (&'b isize, &'b isize) {\n-        (self.bar, x) //~ ERROR E0312\n-        //~^ ERROR E0312\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "ccc25b58228bd66941036a5555072f2865cae0b1", "filename": "src/test/compile-fail/lint-ctypes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -34,15 +34,15 @@ extern {\n     pub fn ptr_type2(size: *const Foo); //~ ERROR: found struct without\n     pub fn slice_type(p: &[u32]); //~ ERROR: found Rust slice type\n     pub fn str_type(p: &str); //~ ERROR: found Rust type\n-    pub fn box_type(p: Box<u32>); //~ ERROR found Rust type\n+    pub fn box_type(p: Box<u32>); //~ ERROR found struct without\n     pub fn char_type(p: char); //~ ERROR found Rust type\n     pub fn trait_type(p: &Clone); //~ ERROR found Rust trait type\n     pub fn tuple_type(p: (i32, i32)); //~ ERROR found Rust tuple type\n     pub fn tuple_type2(p: I32Pair); //~ ERROR found Rust tuple type\n     pub fn zero_size(p: ZeroSize); //~ ERROR found zero-size struct\n     pub fn fn_type(p: RustFn); //~ ERROR found function pointer with Rust\n     pub fn fn_type2(p: fn()); //~ ERROR found function pointer with Rust\n-    pub fn fn_contained(p: RustBadRet); //~ ERROR: found Rust type\n+    pub fn fn_contained(p: RustBadRet); //~ ERROR: found struct without\n \n     pub fn good1(size: *const libc::c_int);\n     pub fn good2(size: *const libc::c_uint);"}, {"sha": "9dcf902a69f916c7f343ebcd3de73f1853519ff9", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -24,7 +24,6 @@ impl<K, V> Map<K, V> for HashMap<K, V> {}\n fn main() {\n     let x: Box<HashMap<isize, isize>> = box HashMap::new();\n     let x: Box<Map<isize, isize>> = x;\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let y: Box<Map<usize, isize>> = Box::new(x);\n-    //~^ ERROR `Box<Map<isize, isize>>: Map<usize, isize>` is not satisfied\n+    //~^ ERROR `std::boxed::Box<Map<isize, isize>>: Map<usize, isize>` is not satisfied\n }"}, {"sha": "6a140e6f21c1948220cd005b7a66f7b6198f65d1", "filename": "src/test/compile-fail/missing-block-hint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fmissing-block-hint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fmissing-block-hint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-block-hint.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -15,6 +15,7 @@ fn main() {\n     {\n         if (foo)\n             bar; //~ ERROR expected `{`, found `bar`\n-                 //^ HELP try placing this code inside a block\n+                 //~^ HELP try placing this code inside a block\n+                 //~| SUGGESTION { bar; }\n     }\n }"}, {"sha": "d52960659999421e78f3c93c2eb359369a6c0195", "filename": "src/test/compile-fail/moves-based-on-type-no-recursive-stack-closure.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -38,7 +38,6 @@ fn innocent_looking_victim() {\n }\n \n fn conspirator<F>(mut f: F) where F: FnMut(&mut R, bool) {\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let mut r = R {c: Box::new(f)};\n     f(&mut r, false) //~ ERROR use of moved value\n }"}, {"sha": "8babc734c84cc13afdf33ec6fcaf74f757461362", "filename": "src/test/compile-fail/object-does-not-impl-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -14,5 +14,5 @@\n trait Foo {}\n fn take_foo<F:Foo>(f: F) {}\n fn take_object(f: Box<Foo>) { take_foo(f); }\n-//~^ ERROR `Box<Foo>: Foo` is not satisfied\n+//~^ ERROR `std::boxed::Box<Foo>: Foo` is not satisfied\n fn main() {}"}, {"sha": "a276af83dee25c13d74d77b8019a6be578846afb", "filename": "src/test/compile-fail/occurs-check-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check-2.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -17,6 +17,6 @@ fn main() {\n     f = box g;\n     //~^  ERROR mismatched types\n     //~| expected type `_`\n-    //~| found type `Box<_>`\n+    //~| found type `std::boxed::Box<_>`\n     //~| cyclic type of infinite size\n }"}, {"sha": "5b6a11e58c27c8059e0ff0b231e7588d1a395abd", "filename": "src/test/compile-fail/occurs-check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foccurs-check.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -15,6 +15,6 @@ fn main() {\n     f = box f;\n     //~^ ERROR mismatched types\n     //~| expected type `_`\n-    //~| found type `Box<_>`\n+    //~| found type `std::boxed::Box<_>`\n     //~| cyclic type of infinite size\n }"}, {"sha": "fb65af230ace5cf05eaeb02574a83c06bd81b748", "filename": "src/test/compile-fail/privacy/legacy-ctor-visibility.rs", "status": "renamed", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fprivacy%2Flegacy-ctor-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fprivacy%2Flegacy-ctor-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Flegacy-ctor-visibility.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,23 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// gate-test-more_struct_aliases\n+#![allow(unused)]\n \n-struct S;\n+use m::S;\n \n-trait Tr {\n-    type A;\n-}\n-\n-fn f<T: Tr<A = S>>() {\n-    let _ = T::A {};\n-    //~^ ERROR `Self` and associated types in struct expressions and patterns are unstable\n-}\n+mod m {\n+    pub struct S(u8);\n \n-impl S {\n-    fn f() {\n-        let _ = Self {};\n-        //~^ ERROR `Self` and associated types in struct expressions and patterns are unstable\n+    mod n {\n+        use S;\n+        fn f() {\n+            S(10);\n+            //~^ ERROR private struct constructors are not usable through reexports in outer modules\n+            //~| WARN this was previously accepted\n+        }\n     }\n }\n ", "previous_filename": "src/test/compile-fail/struct-path-self-feature-gate.rs"}, {"sha": "599c1f871604406bd3f6f99470b3078d073c2603", "filename": "src/test/compile-fail/privacy5.rs", "status": "modified", "additions": 52, "deletions": 55, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fprivacy5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fprivacy5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy5.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -58,83 +58,80 @@ mod a {\n }\n \n fn this_crate() {\n-    let a = a::A(()); //~ ERROR: cannot invoke tuple struct constructor\n-    let b = a::B(2); //~ ERROR: cannot invoke tuple struct constructor\n-    let c = a::C(2, 3); //~ ERROR: cannot invoke tuple struct constructor\n+    let a = a::A(()); //~ ERROR tuple struct `A` is private\n+    let b = a::B(2); //~ ERROR tuple struct `B` is private\n+    let c = a::C(2, 3); //~ ERROR tuple struct `C` is private\n     let d = a::D(4);\n \n-    let a::A(()) = a; //~ ERROR: field `0` of struct `a::A` is private\n-    let a::A(_) = a;\n-    match a { a::A(()) => {} } //~ ERROR: field `0` of struct `a::A` is private\n-    match a { a::A(_) => {} }\n-\n-    let a::B(_) = b;\n-    let a::B(_b) = b; //~ ERROR: field `0` of struct `a::B` is private\n-    match b { a::B(_) => {} }\n-    match b { a::B(_b) => {} } //~ ERROR: field `0` of struct `a::B` is private\n-    match b { a::B(1) => {} a::B(_) => {} } //~ ERROR: field `0` of struct `a::B` is private\n-\n-    let a::C(_, _) = c;\n-    let a::C(_a, _) = c;\n-    let a::C(_, _b) = c; //~ ERROR: field `1` of struct `a::C` is private\n-    let a::C(_a, _b) = c; //~ ERROR: field `1` of struct `a::C` is private\n-    match c { a::C(_, _) => {} }\n-    match c { a::C(_a, _) => {} }\n-    match c { a::C(_, _b) => {} } //~ ERROR: field `1` of struct `a::C` is private\n-    match c { a::C(_a, _b) => {} } //~ ERROR: field `1` of struct `a::C` is private\n+    let a::A(()) = a; //~ ERROR tuple struct `A` is private\n+    let a::A(_) = a; //~ ERROR tuple struct `A` is private\n+    match a { a::A(()) => {} } //~ ERROR tuple struct `A` is private\n+    match a { a::A(_) => {} } //~ ERROR tuple struct `A` is private\n+\n+    let a::B(_) = b; //~ ERROR tuple struct `B` is private\n+    let a::B(_b) = b; //~ ERROR tuple struct `B` is private\n+    match b { a::B(_) => {} } //~ ERROR tuple struct `B` is private\n+    match b { a::B(_b) => {} } //~ ERROR tuple struct `B` is private\n+    match b { a::B(1) => {} a::B(_) => {} } //~ ERROR tuple struct `B` is private\n+                                            //~^ ERROR tuple struct `B` is private\n+\n+    let a::C(_, _) = c; //~ ERROR tuple struct `C` is private\n+    let a::C(_a, _) = c; //~ ERROR tuple struct `C` is private\n+    let a::C(_, _b) = c; //~ ERROR tuple struct `C` is private\n+    let a::C(_a, _b) = c; //~ ERROR tuple struct `C` is private\n+    match c { a::C(_, _) => {} } //~ ERROR tuple struct `C` is private\n+    match c { a::C(_a, _) => {} } //~ ERROR tuple struct `C` is private\n+    match c { a::C(_, _b) => {} } //~ ERROR tuple struct `C` is private\n+    match c { a::C(_a, _b) => {} } //~ ERROR tuple struct `C` is private\n \n     let a::D(_) = d;\n     let a::D(_d) = d;\n     match d { a::D(_) => {} }\n     match d { a::D(_d) => {} }\n     match d { a::D(1) => {} a::D(_) => {} }\n \n-    let a2 = a::A; //~ ERROR: cannot invoke tuple struct constructor\n-    let b2 = a::B; //~ ERROR: cannot invoke tuple struct constructor\n-    let c2 = a::C; //~ ERROR: cannot invoke tuple struct constructor\n+    let a2 = a::A; //~ ERROR tuple struct `A` is private\n+    let b2 = a::B; //~ ERROR tuple struct `B` is private\n+    let c2 = a::C; //~ ERROR tuple struct `C` is private\n     let d2 = a::D;\n }\n \n fn xcrate() {\n-    let a = other::A(()); //~ ERROR: cannot invoke tuple struct constructor\n-    let b = other::B(2); //~ ERROR: cannot invoke tuple struct constructor\n-    let c = other::C(2, 3); //~ ERROR: cannot invoke tuple struct constructor\n+    let a = other::A(()); //~ ERROR tuple struct `A` is private\n+    let b = other::B(2); //~ ERROR tuple struct `B` is private\n+    let c = other::C(2, 3); //~ ERROR tuple struct `C` is private\n     let d = other::D(4);\n \n-    let other::A(()) = a; //~ ERROR: field `0` of struct `other::A` is private\n-    let other::A(_) = a;\n-    match a { other::A(()) => {} }\n-    //~^ ERROR: field `0` of struct `other::A` is private\n-    match a { other::A(_) => {} }\n-\n-    let other::B(_) = b;\n-    let other::B(_b) = b; //~ ERROR: field `0` of struct `other::B` is private\n-    match b { other::B(_) => {} }\n-    match b { other::B(_b) => {} }\n-    //~^ ERROR: field `0` of struct `other::B` is private\n-    match b { other::B(1) => {} other::B(_) => {} }\n-    //~^ ERROR: field `0` of struct `other::B` is private\n-\n-    let other::C(_, _) = c;\n-    let other::C(_a, _) = c;\n-    let other::C(_, _b) = c; //~ ERROR: field `1` of struct `other::C` is private\n-    let other::C(_a, _b) = c; //~ ERROR: field `1` of struct `other::C` is private\n-    match c { other::C(_, _) => {} }\n-    match c { other::C(_a, _) => {} }\n-    match c { other::C(_, _b) => {} }\n-    //~^ ERROR: field `1` of struct `other::C` is private\n-    match c { other::C(_a, _b) => {} }\n-    //~^ ERROR: field `1` of struct `other::C` is private\n+    let other::A(()) = a; //~ ERROR tuple struct `A` is private\n+    let other::A(_) = a; //~ ERROR tuple struct `A` is private\n+    match a { other::A(()) => {} } //~ ERROR tuple struct `A` is private\n+    match a { other::A(_) => {} } //~ ERROR tuple struct `A` is private\n+\n+    let other::B(_) = b; //~ ERROR tuple struct `B` is private\n+    let other::B(_b) = b; //~ ERROR tuple struct `B` is private\n+    match b { other::B(_) => {} } //~ ERROR tuple struct `B` is private\n+    match b { other::B(_b) => {} } //~ ERROR tuple struct `B` is private\n+    match b { other::B(1) => {} other::B(_) => {} } //~ ERROR tuple struct `B` is private\n+                                                    //~^ ERROR tuple struct `B` is private\n+\n+    let other::C(_, _) = c; //~ ERROR tuple struct `C` is private\n+    let other::C(_a, _) = c; //~ ERROR tuple struct `C` is private\n+    let other::C(_, _b) = c; //~ ERROR tuple struct `C` is private\n+    let other::C(_a, _b) = c; //~ ERROR tuple struct `C` is private\n+    match c { other::C(_, _) => {} } //~ ERROR tuple struct `C` is private\n+    match c { other::C(_a, _) => {} } //~ ERROR tuple struct `C` is private\n+    match c { other::C(_, _b) => {} } //~ ERROR tuple struct `C` is private\n+    match c { other::C(_a, _b) => {} } //~ ERROR tuple struct `C` is private\n \n     let other::D(_) = d;\n     let other::D(_d) = d;\n     match d { other::D(_) => {} }\n     match d { other::D(_d) => {} }\n     match d { other::D(1) => {} other::D(_) => {} }\n \n-    let a2 = other::A; //~ ERROR: cannot invoke tuple struct constructor\n-    let b2 = other::B; //~ ERROR: cannot invoke tuple struct constructor\n-    let c2 = other::C; //~ ERROR: cannot invoke tuple struct constructor\n+    let a2 = other::A; //~ ERROR tuple struct `A` is private\n+    let b2 = other::B; //~ ERROR tuple struct `B` is private\n+    let c2 = other::C; //~ ERROR tuple struct `C` is private\n     let d2 = other::D;\n }\n "}, {"sha": "503b577b1f1b4f3530392c3a714a14d800d69a31", "filename": "src/test/compile-fail/region-bounds-on-objects-and-type-parameters.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -18,7 +18,7 @@ trait SomeTrait { }\n \n // Bounds on object types:\n \n-struct Foo<'a,'b,'c> {\n+struct Foo<'a,'b,'c> { //~ ERROR parameter `'b` is never used\n     // All of these are ok, because we can derive exactly one bound:\n     a: Box<IsStatic>,\n     b: Box<Is<'static>>,\n@@ -28,7 +28,9 @@ struct Foo<'a,'b,'c> {\n     f: Box<SomeTrait>,   // OK, defaults to 'static due to RFC 599.\n     g: Box<SomeTrait+'a>,\n \n-    z: Box<Is<'a>+'b+'c>, //~ ERROR only a single explicit lifetime bound is permitted\n+    z: Box<Is<'a>+'b+'c>,\n+    //~^ ERROR only a single explicit lifetime bound is permitted\n+    //~| ERROR lifetime bound not satisfied\n }\n \n fn test<"}, {"sha": "687b2c344a3b755d42f6baa392b31ddc18b1741a", "filename": "src/test/compile-fail/region-object-lifetime-in-coercion.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-object-lifetime-in-coercion.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -14,8 +14,6 @@\n trait Foo {}\n impl<'a> Foo for &'a [u8] {}\n \n-// FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-\n fn a(v: &[u8]) -> Box<Foo + 'static> {\n     let x: Box<Foo + 'static> = Box::new(v);\n     //~^ ERROR cannot infer an appropriate lifetime due to conflicting"}, {"sha": "6b88abfca6c914f8ae611bbb8af82ffbf5491c58", "filename": "src/test/compile-fail/regions-close-associated-type-into-object.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-associated-type-into-object.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -10,8 +10,6 @@\n \n #![feature(box_syntax)]\n \n-// FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-\n trait X {}\n \n trait Iter {"}, {"sha": "c9063405bd7e203ea6e449e214bf078df37131f5", "filename": "src/test/compile-fail/regions-close-param-into-object.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregions-close-param-into-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregions-close-param-into-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-param-into-object.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-\n trait X { fn foo(&self) {} }\n \n fn p1<T>(v: T) -> Box<X+'static>"}, {"sha": "c559992c865316849674474a32a8e73be36804bd", "filename": "src/test/compile-fail/regions-infer-paramd-indirect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -32,8 +32,8 @@ impl<'a> set_f<'a> for c<'a> {\n     fn set_f_bad(&mut self, b: Box<b>) {\n         self.f = b;\n         //~^ ERROR mismatched types\n-        //~| expected type `Box<Box<&'a isize>>`\n-        //~| found type `Box<Box<&isize>>`\n+        //~| expected type `std::boxed::Box<std::boxed::Box<&'a isize>>`\n+        //~| found type `std::boxed::Box<std::boxed::Box<&isize>>`\n         //~| lifetime mismatch\n     }\n }"}, {"sha": "010b7d17688125542558d0f2db720d50c91def7d", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-\n fn ignore<T>(t: T) {}\n \n fn nested<'x>(x: &'x isize) {"}, {"sha": "fb726e31af586a5ba81e434d086ccf8d3f7af9d1", "filename": "src/test/compile-fail/regions-proc-bound-capture.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-\n fn borrowed_proc<'a>(x: &'a isize) -> Box<FnMut()->(isize) + 'a> {\n     // This is legal, because the region bound on `proc`\n     // states that it captures `x`."}, {"sha": "7ca63b9896fe0064035144f28cffdba4f118f45e", "filename": "src/test/compile-fail/regions-steal-closure.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -21,7 +21,6 @@ fn box_it<'r>(x: Box<FnMut() + 'r>) -> closure_box<'r> {\n fn main() {\n     let mut cl_box = {\n         let mut i = 3;\n-        // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         box_it(Box::new(|| i += 1)) //~ ERROR `i` does not live long enough\n     };\n     cl_box.cl.call_mut(());"}, {"sha": "93635e7fddea781c7b9f065c598abe20ee416f33", "filename": "src/test/compile-fail/rfc1623.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Frfc1623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Frfc1623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1623.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -15,8 +15,10 @@ fn non_elidable<'a, 'b>(a: &'a u8, b: &'b u8) -> &'a u8 {\n }\n \n // the boundaries of elision\n-static NON_ELIDABLE_FN: &fn(&u8, &u8) -> &u8 = &(non_elidable as fn(&u8, &u8) -> &u8);\n+static NON_ELIDABLE_FN: &fn(&u8, &u8) -> &u8 =\n //~^ ERROR missing lifetime specifier [E0106]\n+    &(non_elidable as fn(&u8, &u8) -> &u8);\n+    //~^ ERROR missing lifetime specifier [E0106]\n \n struct SomeStruct<'x, 'y, 'z: 'x> {\n     foo: &'x Foo<'z>,"}, {"sha": "f85422f76d40ee0d492fe6f219b2e62d9c7ed848", "filename": "src/test/compile-fail/str-concat-on-double-ref.rs", "status": "renamed", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fstr-concat-on-double-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fstr-concat-on-double-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstr-concat-on-double-ref.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,14 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-mod Bar {\n-    pub struct Foo( bool, pub i32, f32, bool);\n-    //~^ NOTE private field declared here\n-    //~| NOTE private field declared here\n-    //~| NOTE private field declared here\n-}\n-\n fn main() {\n-    let f = Bar::Foo(false,1,0.1, true); //~ ERROR E0450\n-                         //~^ NOTE cannot construct with a private field\n+    let a: &String = &\"1\".to_owned();\n+    let b: &str = &\"2\";\n+    let c = a + b;\n+    //~^ ERROR binary operation `+` cannot be applied to type `&std::string::String`\n+    //~| NOTE an implementation of `std::ops::Add` might be missing for `&std::string::String`\n+    println!(\"{:?}\", c);\n }", "previous_filename": "src/test/compile-fail/E0450.rs"}, {"sha": "660ac44ce0b53c07130fa71b89f73afac155d9d7", "filename": "src/test/compile-fail/struct-path-associated-type.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fstruct-path-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fstruct-path-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-path-associated-type.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(more_struct_aliases)]\n-\n struct S;\n \n trait Tr {"}, {"sha": "f694e7d277c7fec094e70b30b191f17605845340", "filename": "src/test/compile-fail/struct-path-self-type-mismatch.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fstruct-path-self-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fstruct-path-self-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-path-self-type-mismatch.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(more_struct_aliases)]\n-\n struct Foo<A> { inner: A }\n \n trait Bar { fn bar(); }"}, {"sha": "067d6ac22dc6fb35a3a7e06fdb98c6be84487de7", "filename": "src/test/compile-fail/struct-path-self.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fstruct-path-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fstruct-path-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-path-self.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(more_struct_aliases)]\n-\n struct S;\n \n trait Tr {"}, {"sha": "fd92a26d0fcecb90ede0ee48a07942a702ff9501", "filename": "src/test/compile-fail/terr-sorts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fterr-sorts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fterr-sorts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fterr-sorts.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -20,8 +20,7 @@ fn want_foo(f: foo) {}\n fn have_bar(b: bar) {\n     want_foo(b); //~  ERROR mismatched types\n                  //~| expected type `foo`\n-                 //~| found type `Box<foo>`\n-                 //~| expected struct `foo`, found box\n+                 //~| found type `std::boxed::Box<foo>`\n }\n \n fn main() {}"}, {"sha": "3839e90ed9fe769263f0ab6faac96b5a34b32c75", "filename": "src/test/compile-fail/trait-coercion-generic-bad.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -23,7 +23,6 @@ impl Trait<&'static str> for Struct {\n }\n \n fn main() {\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let s: Box<Trait<isize>> = Box::new(Struct { person: \"Fred\" });\n     //~^ ERROR `Struct: Trait<isize>` is not satisfied\n     s.f(1);"}, {"sha": "18d3ded77f8f3d61bb57ccc07f78b3eae0fb8256", "filename": "src/test/compile-fail/trait-coercion-generic-regions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -25,6 +25,5 @@ impl Trait<&'static str> for Struct {\n fn main() {\n     let person = \"Fred\".to_string();\n     let person: &str = &person;  //~ ERROR `person` does not live long enough\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let s: Box<Trait<&'static str>> = Box::new(Struct { person: person });\n }"}, {"sha": "aabf0d26d5ba7db921d144fd43df73d2ab35edb5", "filename": "src/test/compile-fail/trivial_casts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Ftrivial_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Ftrivial_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrivial_casts.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -52,7 +52,8 @@ pub fn main() {\n     let _: *mut [u32] = x;\n \n     let x: Box<[u32; 3]> = Box::new([42, 43, 44]);\n-    let _ = x as Box<[u32]>; //~ERROR trivial cast: `Box<[u32; 3]>` as `Box<[u32]>`\n+    let _ = x as Box<[u32]>;\n+    //~^ ERROR trivial cast: `std::boxed::Box<[u32; 3]>` as `std::boxed::Box<[u32]>`\n     let x: Box<[u32; 3]> = Box::new([42, 43, 44]);\n     let _: Box<[u32]> = x;\n \n@@ -70,7 +71,7 @@ pub fn main() {\n     let _: *mut Foo = x;\n \n     let x: Box<Bar> = Box::new(Bar);\n-    let _ = x as Box<Foo>; //~ERROR trivial cast: `Box<Bar>` as `Box<Foo>`\n+    let _ = x as Box<Foo>; //~ERROR trivial cast: `std::boxed::Box<Bar>` as `std::boxed::Box<Foo>`\n     let x: Box<Bar> = Box::new(Bar);\n     let _: Box<Foo> = x;\n "}, {"sha": "4295d08a4709c701eaa8e63336ff5fac086e9e4d", "filename": "src/test/compile-fail/type-mismatch-same-crate-name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-same-crate-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-same-crate-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-mismatch-same-crate-name.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -33,7 +33,7 @@ fn main() {\n         //~^ ERROR mismatched types\n         //~| Perhaps two different versions of crate `crate_a1`\n         //~| expected trait `main::a::Bar`\n-        //~| expected type `Box<main::a::Bar + 'static>`\n-        //~| found type `Box<main::a::Bar>`\n+        //~| expected type `std::boxed::Box<main::a::Bar + 'static>`\n+        //~| found type `std::boxed::Box<main::a::Bar>`\n     }\n }"}, {"sha": "427be5607600db9abbc86a80e7598358116a13ad", "filename": "src/test/compile-fail/unboxed-closure-illegal-move.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -18,8 +18,6 @@ fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n \n-// FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-\n fn main() {\n     // By-ref cases\n     {"}, {"sha": "18a1185d695f70ca0de33391fc4fadbc9843bbc5", "filename": "src/test/compile-fail/unboxed-closure-sugar-region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -38,9 +38,9 @@ fn test<'a,'b>() {\n }\n \n fn test2(x: &Foo<(isize,),Output=()>, y: &Foo(isize)) {\n+//~^ ERROR wrong number of lifetime parameters: expected 1, found 0\n     // Here, the omitted lifetimes are expanded to distinct things.\n-    same_type(x, y) //~ ERROR cannot infer\n-                    //~^ ERROR cannot infer\n+    same_type(x, y)\n }\n \n fn main() { }"}, {"sha": "0f8b0a6c238d08f03c4d2ae88554f4c3775313e5", "filename": "src/test/compile-fail/uninhabited-matches-feature-gated.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Funinhabited-matches-feature-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Funinhabited-matches-feature-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinhabited-matches-feature-gated.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(slice_patterns)]\n+\n+enum Void {}\n+\n+fn main() {\n+    let x: Result<u32, &'static Void> = Ok(23);\n+    let _ = match x {   //~ ERROR non-exhaustive\n+        Ok(n) => n,\n+    };\n+\n+    let x: &Void = unsafe { std::mem::uninitialized() };\n+    let _ = match x {};\n+    //~^ ERROR non-exhaustive\n+\n+    let x: (Void,) = unsafe { std::mem::uninitialized() };\n+    let _ = match x {};\n+    //~^ ERROR non-exhaustive\n+\n+    let x: [Void; 1] = unsafe { std::mem::uninitialized() };\n+    let _ = match x {};\n+    //~^ ERROR non-exhaustive\n+\n+    let x: &[Void] = unsafe { std::mem::uninitialized() };\n+    let _ = match x {   //~ ERROR non-exhaustive\n+        &[] => (),\n+    };\n+\n+    let x: Void = unsafe { std::mem::uninitialized() };\n+    let _ = match x {}; // okay\n+\n+    let x: Result<u32, Void> = Ok(23);\n+    let _ = match x {   //~ ERROR non-exhaustive\n+        Ok(x) => x,\n+    };\n+\n+    let x: Result<u32, Void> = Ok(23);\n+    let Ok(x) = x;\n+    //~^ ERROR refutable\n+}\n+"}, {"sha": "c09feec1d4af25b1b713ce74fe4875153404905c", "filename": "src/test/compile-fail/unique-pinned-nocopy.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -18,7 +18,6 @@ impl Drop for r {\n }\n \n fn main() {\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let i = Box::new(r { b: true });\n     let _j = i.clone(); //~ ERROR no method named `clone` found\n     println!(\"{:?}\", i);"}, {"sha": "e449a736c753a9360827d0a7e51563686af0dc7b", "filename": "src/test/compile-fail/where-equality-constraints.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fwhere-equality-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fwhere-equality-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-equality-constraints.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f() where u8 = u16 {}\n+//~^ ERROR equality constraints are not yet supported in where clauses\n+fn g() where for<'a> &'static (u8,) == u16, {}\n+//~^ ERROR equality constraints are not yet supported in where clauses\n+\n+fn main() {}"}, {"sha": "f4c6842206db17443e3a8e4ab090e4c5a914bd68", "filename": "src/test/compile-fail/where-lifetime-resolution.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fwhere-lifetime-resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fcompile-fail%2Fwhere-lifetime-resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-lifetime-resolution.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Trait1 {}\n+trait Trait2 {}\n+\n+fn f() where\n+    for<'a> Trait1<'a>: Trait1<'a>, // OK\n+    (for<'a> Trait1<'a>): Trait1<'a>,\n+    //~^ ERROR use of undeclared lifetime name `'a`\n+    for<'a> for<'b> Trait2<'a, 'b>: Trait2<'a, 'b>,\n+    //~^ ERROR use of undeclared lifetime name `'b`\n+    //~| ERROR nested quantification of lifetimes\n+{}\n+\n+fn main() {}"}, {"sha": "57d40cccf2d808f1cbb19d5c1bdd18182c305055", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -70,12 +70,12 @@\n \n // BOX\n // gdb-command:whatis box1\n-// gdbg-check:type = struct (Box<f32>, i32)\n-// gdbr-check:type = (Box<f32>, i32)\n+// gdbg-check:type = struct (alloc::boxed::Box<f32>, i32)\n+// gdbr-check:type = (alloc::boxed::Box<f32>, i32)\n \n // gdb-command:whatis box2\n-// gdbg-check:type = struct (Box<type_names::mod1::mod2::Enum3<f32>>, i32)\n-// gdbr-check:type = (Box<type_names::mod1::mod2::Enum3<f32>>, i32)\n+// gdbg-check:type = struct (alloc::boxed::Box<type_names::mod1::mod2::Enum3<f32>>, i32)\n+// gdbr-check:type = (alloc::boxed::Box<type_names::mod1::mod2::Enum3<f32>>, i32)\n \n \n // REFERENCES\n@@ -196,8 +196,8 @@\n // gdbr-check:type = (unsafe fn(type_names::GenericStruct<u16, u8>) -> type_names::mod1::Struct2, usize)\n \n // gdb-command:whatis extern_stdcall_fn_with_return_value\n-// gdbg-check:type = struct (extern \"stdcall\" fn(Box<isize>) -> usize, usize)\n-// gdbr-check:type = (extern \"stdcall\" fn(Box<isize>) -> usize, usize)\n+// gdbg-check:type = struct (extern \"stdcall\" fn(alloc::boxed::Box<isize>) -> usize, usize)\n+// gdbr-check:type = (extern \"stdcall\" fn(alloc::boxed::Box<isize>) -> usize, usize)\n \n // gdb-command:whatis generic_function_int\n // gdbg-check:type = struct (fn(isize) -> isize, usize)"}, {"sha": "1064c97b744a4e51a899957ed90ac8f6cf35b341", "filename": "src/test/incremental/add_private_fn_at_krate_root_cc/auxiliary/point.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fauxiliary%2Fpoint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fauxiliary%2Fpoint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fauxiliary%2Fpoint.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z incremental-cc\n+\n pub struct Point {\n     pub x: f32,\n     pub y: f32,"}, {"sha": "a02b71a753cc3bdff1f9b05b4a1e71ba4f3c6676", "filename": "src/test/incremental/callee_caller_cross_crate/auxiliary/a.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fauxiliary%2Fa.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z incremental-cc\n+\n #![crate_type=\"rlib\"]\n \n #[cfg(rpass1)]"}, {"sha": "08eef2a73f68f21d2bdb9f72083689fb8f762b17", "filename": "src/test/incremental/change_private_fn_cc/auxiliary/point.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fauxiliary%2Fpoint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fauxiliary%2Fpoint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fauxiliary%2Fpoint.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z incremental-cc\n+\n pub struct Point {\n     pub x: f32,\n     pub y: f32,"}, {"sha": "e69dc51119e920e8bbdd7455c0a5356f8d538c8f", "filename": "src/test/incremental/change_private_impl_method_cc/auxiliary/point.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fauxiliary%2Fpoint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fauxiliary%2Fpoint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fauxiliary%2Fpoint.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z incremental-cc\n+\n pub struct Point {\n     pub x: f32,\n     pub y: f32,"}, {"sha": "39547fb7359f56e1ba64e78cd466b260481b71bc", "filename": "src/test/incremental/remove-private-item-cross-crate/auxiliary/a.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fauxiliary%2Fa.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z incremental-cc\n+\n #![allow(warnings)]\n #![crate_name = \"a\"]\n #![crate_type = \"rlib\"]"}, {"sha": "3ecd9aff3f8cdc348d5f55bb415bdf7301b36f77", "filename": "src/test/incremental/rlib_cross_crate/auxiliary/a.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fauxiliary%2Fa.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z incremental-cc\n // no-prefer-dynamic\n \n #![crate_type=\"rlib\"]"}, {"sha": "d14ebf78d8222b452975d9d7d985f665efac1027", "filename": "src/test/incremental/struct_change_field_type_cross_crate/auxiliary/a.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fauxiliary%2Fa.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z incremental-cc\n+\n #![crate_type=\"rlib\"]\n \n  #[cfg(rpass1)]"}, {"sha": "0393bcda991565f874e0cba700d01da027f2cca4", "filename": "src/test/incremental/type_alias_cross_crate/auxiliary/a.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fauxiliary%2Fa.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z incremental-cc\n+\n #![crate_type=\"rlib\"]\n \n #[cfg(rpass1)]"}, {"sha": "824d243d5f846d2547e931f5359514c3580e586d", "filename": "src/test/parse-fail/bounds-lifetime-1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fparse-fail%2Fbounds-lifetime-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fparse-fail%2Fbounds-lifetime-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fbounds-lifetime-1.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+type A = for<'a 'b> fn(); //~ ERROR expected one of `,`, `:`, or `>`, found `'b`\n+\n+fn main() {}"}, {"sha": "3c67dda70f5628edbc42847896a3de972bdf261c", "filename": "src/test/parse-fail/bounds-lifetime-2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fparse-fail%2Fbounds-lifetime-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0267529681e2fac6ef4560afe7d8d439d04e6303/src%2Ftest%2Fparse-fail%2Fbounds-lifetime-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fbounds-lifetime-2.rs?ref=0267529681e2fac6ef4560afe7d8d439d04e6303", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+type A = for<'a + 'b> fn(); //~ ERROR expected one of `,`, `:`, or `>`, found `+`\n+\n+fn main() {}"}]}