{"sha": "83fe6e4392b2b89005f3056cf56a382887c939d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZmU2ZTQzOTJiMmI4OTAwNWYzMDU2Y2Y1NmEzODI4ODdjOTM5ZDU=", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2018-12-11T18:55:02Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2018-12-11T20:06:18Z"}, "message": "Use iterators instead of raw offsets in Windows argument parser", "tree": {"sha": "9a52996873269a3631137bc4421591420398dff0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a52996873269a3631137bc4421591420398dff0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83fe6e4392b2b89005f3056cf56a382887c939d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83fe6e4392b2b89005f3056cf56a382887c939d5", "html_url": "https://github.com/rust-lang/rust/commit/83fe6e4392b2b89005f3056cf56a382887c939d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83fe6e4392b2b89005f3056cf56a382887c939d5/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55420f0f42460e5dc1d724be68496f9ef8557e72", "url": "https://api.github.com/repos/rust-lang/rust/commits/55420f0f42460e5dc1d724be68496f9ef8557e72", "html_url": "https://github.com/rust-lang/rust/commit/55420f0f42460e5dc1d724be68496f9ef8557e72"}], "stats": {"total": 94, "additions": 45, "deletions": 49}, "files": [{"sha": "9e9198e05ee0ed73bc90f03035063e02fd2858d0", "filename": "src/libstd/sys/windows/args.rs", "status": "modified", "additions": 45, "deletions": 49, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/83fe6e4392b2b89005f3056cf56a382887c939d5/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83fe6e4392b2b89005f3056cf56a382887c939d5/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs?ref=83fe6e4392b2b89005f3056cf56a382887c939d5", "patch": "@@ -55,38 +55,35 @@ unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_na\n     const QUOTE: u16 = '\"' as u16;\n     const TAB: u16 = '\\t' as u16;\n     const SPACE: u16 = ' ' as u16;\n-    let mut in_quotes = false;\n-    let mut was_in_quotes = false;\n-    let mut backslash_count: usize = 0;\n     let mut ret_val = Vec::new();\n-    let mut cur = Vec::new();\n     if lp_cmd_line.is_null() || *lp_cmd_line == 0 {\n         ret_val.push(exe_name());\n         return ret_val;\n     }\n-    let mut i = 0;\n+    let mut cmd_line = {\n+        let mut end = 0;\n+        while *lp_cmd_line.offset(end) != 0 {\n+            end += 1;\n+        }\n+        slice::from_raw_parts(lp_cmd_line, end as usize)\n+    };\n     // The executable name at the beginning is special.\n-    match *lp_cmd_line {\n+    cmd_line = match cmd_line[0] {\n         // The executable name ends at the next quote mark,\n         // no matter what.\n         QUOTE => {\n-            loop {\n-                i += 1;\n-                let c = *lp_cmd_line.offset(i);\n-                if c == 0 {\n-                    ret_val.push(OsString::from_wide(\n-                        slice::from_raw_parts(lp_cmd_line.offset(1), i as usize - 1)\n-                    ));\n-                    return ret_val;\n-                }\n-                if c == QUOTE {\n-                    break;\n+            let args = {\n+                let mut cut = cmd_line[1..].splitn(2, |&c| c == QUOTE);\n+                if let Some(exe) = cut.next() {\n+                    ret_val.push(OsString::from_wide(exe));\n                 }\n+                cut.next()\n+            };\n+            if let Some(args) = args {\n+                args\n+            } else {\n+                return ret_val;\n             }\n-            ret_val.push(OsString::from_wide(\n-                slice::from_raw_parts(lp_cmd_line.offset(1), i as usize - 1)\n-            ));\n-            i += 1;\n         }\n         // Implement quirk: when they say whitespace here,\n         // they include the entire ASCII control plane:\n@@ -95,32 +92,30 @@ unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_na\n         // end of lpCmdLine is ignored.\"\n         0...SPACE => {\n             ret_val.push(OsString::new());\n-            i += 1;\n+            &cmd_line[1..]\n         },\n         // The executable name ends at the next whitespace,\n         // no matter what.\n         _ => {\n-            loop {\n-                i += 1;\n-                let c = *lp_cmd_line.offset(i);\n-                if c == 0 {\n-                    ret_val.push(OsString::from_wide(\n-                        slice::from_raw_parts(lp_cmd_line, i as usize)\n-                    ));\n-                    return ret_val;\n-                }\n-                if c > 0 && c <= SPACE {\n-                    break;\n+            let args = {\n+                let mut cut = cmd_line.splitn(2, |&c| c > 0 && c <= SPACE);\n+                if let Some(exe) = cut.next() {\n+                    ret_val.push(OsString::from_wide(exe));\n                 }\n+                cut.next()\n+            };\n+            if let Some(args) = args {\n+                args\n+            } else {\n+                return ret_val;\n             }\n-            ret_val.push(OsString::from_wide(\n-                slice::from_raw_parts(lp_cmd_line, i as usize)\n-            ));\n-            i += 1;\n         }\n-    }\n-    loop {\n-        let c = *lp_cmd_line.offset(i);\n+    };\n+    let mut cur = Vec::new();\n+    let mut in_quotes = false;\n+    let mut was_in_quotes = false;\n+    let mut backslash_count: usize = 0;\n+    for &c in cmd_line {\n         match c {\n             // backslash\n             BACKSLASH => {\n@@ -153,22 +148,18 @@ unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_na\n                 backslash_count = 0;\n                 was_in_quotes = false;\n             }\n-            0x00 => {\n-                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n-                // include empty quoted strings at the end of the arguments list\n-                if !cur.is_empty() || was_in_quotes || in_quotes {\n-                    ret_val.push(OsString::from_wide(&cur[..]));\n-                }\n-                break;\n-            }\n             _ => {\n                 cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n                 backslash_count = 0;\n                 was_in_quotes = false;\n                 cur.push(c);\n             }\n         }\n-        i += 1;\n+    }\n+    cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n+    // include empty quoted strings at the end of the arguments list\n+    if !cur.is_empty() || was_in_quotes || in_quotes {\n+        ret_val.push(OsString::from_wide(&cur[..]));\n     }\n     ret_val\n }\n@@ -267,5 +258,10 @@ mod tests {\n         );\n         chk(r#\"EXE \"a\"\"\"#, &[\"EXE\", \"a\\\"\"]);\n         chk(r#\"EXE \"a\"\" a\"#, &[\"EXE\", \"a\\\"\", \"a\"]);\n+        // quotes cannot be escaped in command names\n+        chk(r#\"\"EXE\" check\"#, &[\"EXE\", \"check\"]);\n+        chk(r#\"\"EXE check\"\"#, &[\"EXE check\"]);\n+        chk(r#\"\"EXE \"\"\"for\"\"\" check\"#, &[\"EXE \", r#\"for\"\"#, \"check\"]);\n+        chk(r#\"\"EXE \\\"for\\\" check\"#, &[r#\"EXE \\\"#, r#\"for\"\"#,  \"check\"]);\n     }\n }"}]}