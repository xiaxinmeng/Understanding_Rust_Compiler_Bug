{"sha": "192e336148babf0dc9d83399955e94544305296a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MmUzMzYxNDhiYWJmMGRjOWQ4MzM5OTk1NWU5NDU0NDMwNTI5NmE=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2016-05-08T17:57:12Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2016-05-08T17:57:12Z"}, "message": "Merge pull request #1 from nrc/save-ids-fix\n\nSave ids fix", "tree": {"sha": "bd3af615cded9806e673f1efb03ad52027a36073", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd3af615cded9806e673f1efb03ad52027a36073"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/192e336148babf0dc9d83399955e94544305296a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/192e336148babf0dc9d83399955e94544305296a", "html_url": "https://github.com/rust-lang/rust/commit/192e336148babf0dc9d83399955e94544305296a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/192e336148babf0dc9d83399955e94544305296a/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dca29d7b0832a5d75db18be96833a8885ef2c2a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/dca29d7b0832a5d75db18be96833a8885ef2c2a6", "html_url": "https://github.com/rust-lang/rust/commit/dca29d7b0832a5d75db18be96833a8885ef2c2a6"}, {"sha": "01be25b1f98e75de46a6a4ee1ae6901d736de070", "url": "https://api.github.com/repos/rust-lang/rust/commits/01be25b1f98e75de46a6a4ee1ae6901d736de070", "html_url": "https://github.com/rust-lang/rust/commit/01be25b1f98e75de46a6a4ee1ae6901d736de070"}], "stats": {"total": 902, "additions": 609, "deletions": 293}, "files": [{"sha": "90a7888af09c77d433de6f900b926a00eba71a45", "filename": "mk/tests.mk", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -636,11 +636,11 @@ CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3) := \\\n         --host-rustcflags \"$(RUSTC_FLAGS_$(3)) $$(CTEST_RUSTC_FLAGS) -L $$(RT_OUTPUT_DIR_$(3))\" \\\n         --lldb-python-dir=$(CFG_LLDB_PYTHON_DIR) \\\n         --target-rustcflags \"$(RUSTC_FLAGS_$(2)) $$(CTEST_RUSTC_FLAGS) -L $$(RT_OUTPUT_DIR_$(2))\" \\\n-\t--cc '$$(CC_$(3))' \\\n-\t--cxx '$$(CXX_$(3))' \\\n-\t--cflags \"$$(CFG_GCCISH_CFLAGS_$(3))\" \\\n-\t--llvm-components \"$$(LLVM_ALL_COMPONENTS_$(3))\" \\\n-\t--llvm-cxxflags \"$$(LLVM_CXXFLAGS_$(3))\" \\\n+\t--cc '$$(CC_$(2))' \\\n+\t--cxx '$$(CXX_$(2))' \\\n+\t--cflags \"$$(CFG_GCCISH_CFLAGS_$(2))\" \\\n+\t--llvm-components \"$$(LLVM_ALL_COMPONENTS_$(2))\" \\\n+\t--llvm-cxxflags \"$$(LLVM_CXXFLAGS_$(2))\" \\\n         $$(CTEST_TESTARGS)\n \n ifdef CFG_VALGRIND_RPASS"}, {"sha": "e61a76a2c37a91dc4fc5efb0a5f7c583eaf05f1b", "filename": "src/doc/book/getting-started.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Fdoc%2Fbook%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Fdoc%2Fbook%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgetting-started.md?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -8,7 +8,7 @@ we\u2019ll talk about Cargo, Rust\u2019s build system and package manager.\n \n The first step to using Rust is to install it. Generally speaking, you\u2019ll need\n an Internet connection to run the commands in this section, as we\u2019ll be\n-downloading Rust from the internet.\n+downloading Rust from the Internet.\n \n We\u2019ll be showing off a number of commands using a terminal, and those lines all\n start with `$`. We don't need to type in the `$`s, they are there to indicate\n@@ -399,13 +399,13 @@ Let\u2019s convert the Hello World program to Cargo. To Cargo-fy a project, you nee\n to do three things:\n \n 1. Put your source file in the right directory.\n-2. Get rid of the old executable (`main.exe` on Windows, `main` everywhere else)\n-   and make a new one.\n+2. Get rid of the old executable (`main.exe` on Windows, `main` everywhere\n+   else).\n 3. Make a Cargo configuration file.\n \n Let's get started!\n \n-### Creating a new Executable and Source Directory\n+### Creating a Source Directory and Removing the Old Executable\n \n First, go back to your terminal, move to your *hello_world* directory, and\n enter the following commands:"}, {"sha": "d58c26a72136b29d415af3695ac97ad088c2981c", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -333,7 +333,7 @@\n //! precision := count | '*'\n //! type := identifier | ''\n //! count := parameter | integer\n-//! parameter := integer '$'\n+//! parameter := argument '$'\n //! ```\n //!\n //! # Formatting Parameters\n@@ -403,11 +403,12 @@\n //! println!(\"Hello {:5}!\", \"x\");\n //! println!(\"Hello {:1$}!\", \"x\", 5);\n //! println!(\"Hello {1:0$}!\", 5, \"x\");\n+//! println!(\"Hello {:width$}!\", \"x\", width = 5);\n //! ```\n //!\n //! Referring to an argument with the dollar syntax does not affect the \"next\n-//! argument\" counter, so it's usually a good idea to refer to all arguments by\n-//! their position explicitly.\n+//! argument\" counter, so it's usually a good idea to refer to arguments by\n+//! position, or use named arguments.\n //!\n //! ## Precision\n //!\n@@ -426,7 +427,7 @@\n //!\n //!    the integer `N` itself is the precision.\n //!\n-//! 2. An integer followed by dollar sign `.N$`:\n+//! 2. An integer or name followed by dollar sign `.N$`:\n //!\n //!    use format *argument* `N` (which must be a `usize`) as the precision.\n //!\n@@ -456,6 +457,10 @@\n //! // Hello {next arg (x)} is {arg 2 (0.01) with precision\n //! //                          specified in its predecessor (5)}\n //! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (x)} is {arg \"number\" (0.01) with precision specified\n+//! //                          in arg \"prec\" (5)}\n+//! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n //! ```\n //!\n //! All print the same thing:"}, {"sha": "a0f2a2adcb62cb8cf2587af3170fa96eea412f51", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -110,6 +110,7 @@ pub use intrinsics::transmute;\n ///     }\n /// }\n /// ```\n+#[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn forget<T>(t: T) {\n     unsafe { intrinsics::forget(t) }"}, {"sha": "04e8bc4913bdc96cc5ce66f7a371f475c2dddbf0", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -275,6 +275,15 @@ macro_rules! wrapping_impl {\n                 *self = *self & other;\n             }\n         }\n+\n+        #[stable(feature = \"wrapping_neg\", since = \"1.10.0\")]\n+        impl Neg for Wrapping<$t> {\n+            type Output = Self;\n+            #[inline(always)]\n+            fn neg(self) -> Self {\n+                Wrapping(0) - self\n+            }\n+        }\n     )*)\n }\n "}, {"sha": "e838921a831784f224b9d4c51653e391fee48ec9", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -314,6 +314,82 @@ let c = &i; // still ok!\n ```\n \"##,\n \n+E0501: r##\"\n+This error indicates that a mutable variable is being used while it is still\n+captured by a closure. Because the closure has borrowed the variable, it is not\n+available for use until the closure goes out of scope.\n+\n+Note that a capture will either move or borrow a variable, but in this\n+situation, the closure is borrowing the variable. Take a look at\n+http://rustbyexample.com/fn/closures/capture.html for more information about\n+capturing.\n+\n+Example of erroneous code:\n+\n+```compile_fail\n+fn inside_closure(x: &mut i32) {\n+    // Actions which require unique access\n+}\n+\n+fn outside_closure(x: &mut i32) {\n+    // Actions which require unique access\n+}\n+\n+fn foo(a: &mut i32) {\n+    let bar = || {\n+        inside_closure(a)\n+    };\n+    outside_closure(a); // error: cannot borrow `*a` as mutable because previous\n+                        //        closure requires unique access.\n+}\n+```\n+\n+To fix this error, you can place the closure in its own scope:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    {\n+        let bar = || {\n+            inside_closure(a)\n+        };\n+    } // borrow on `a` ends.\n+    outside_closure(a); // ok!\n+}\n+```\n+\n+Or you can pass the variable as a parameter to the closure:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    let bar = |s: &mut i32| {\n+        inside_closure(s)\n+    };\n+    outside_closure(a);\n+    bar(a);\n+}\n+```\n+\n+It may be possible to define the closure later:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    outside_closure(a);\n+    let bar = || {\n+        inside_closure(a)\n+    };\n+}\n+```\n+\"##,\n+\n E0507: r##\"\n You tried to move out of a value which was borrowed. Erroneous code example:\n \n@@ -436,7 +512,6 @@ register_diagnostics! {\n     E0388, // {} in a static location\n     E0389, // {} in a `&` reference\n     E0500, // closure requires unique access to `..` but .. is already borrowed\n-    E0501, // cannot borrow `..`.. as .. because previous closure requires unique access\n     E0502, // cannot borrow `..`.. as .. because .. is also borrowed as ...\n     E0503, // cannot use `..` because it was mutably borrowed\n     E0504, // cannot move `..` into closure because it is borrowed"}, {"sha": "06be29b90497657dd97fe307595605d7fdfade12", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 37, "deletions": 48, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -377,13 +377,6 @@ pub enum ErrKind {\n     NotOn(ConstVal),\n     CallOn(ConstVal),\n \n-    NegateWithOverflow(i64),\n-    AddiWithOverflow(i64, i64),\n-    SubiWithOverflow(i64, i64),\n-    MuliWithOverflow(i64, i64),\n-    AdduWithOverflow(u64, u64),\n-    SubuWithOverflow(u64, u64),\n-    MuluWithOverflow(u64, u64),\n     DivideByZero,\n     DivideWithOverflow,\n     ModuloByZero,\n@@ -415,6 +408,7 @@ pub enum ErrKind {\n     TypeMismatch(String, ConstInt),\n     BadType(ConstVal),\n     ErroneousReferencedConstant(Box<ConstEvalErr>),\n+    CharCast(ConstInt),\n }\n \n impl From<ConstMathErr> for ErrKind {\n@@ -439,13 +433,6 @@ impl ConstEvalErr {\n             NotOn(ref const_val) => format!(\"not on {}\", const_val.description()).into_cow(),\n             CallOn(ref const_val) => format!(\"call on {}\", const_val.description()).into_cow(),\n \n-            NegateWithOverflow(..) => \"attempted to negate with overflow\".into_cow(),\n-            AddiWithOverflow(..) => \"attempted to add with overflow\".into_cow(),\n-            SubiWithOverflow(..) => \"attempted to sub with overflow\".into_cow(),\n-            MuliWithOverflow(..) => \"attempted to mul with overflow\".into_cow(),\n-            AdduWithOverflow(..) => \"attempted to add with overflow\".into_cow(),\n-            SubuWithOverflow(..) => \"attempted to sub with overflow\".into_cow(),\n-            MuluWithOverflow(..) => \"attempted to mul with overflow\".into_cow(),\n             DivideByZero         => \"attempted to divide by zero\".into_cow(),\n             DivideWithOverflow   => \"attempted to divide with overflow\".into_cow(),\n             ModuloByZero         => \"attempted remainder with a divisor of zero\".into_cow(),\n@@ -482,6 +469,9 @@ impl ConstEvalErr {\n             },\n             BadType(ref i) => format!(\"value of wrong type: {:?}\", i).into_cow(),\n             ErroneousReferencedConstant(_) => \"could not evaluate referenced constant\".into_cow(),\n+            CharCast(ref got) => {\n+                format!(\"only `u8` can be cast as `char`, not `{}`\", got.description()).into_cow()\n+            },\n         }\n     }\n }\n@@ -824,7 +814,10 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n           debug!(\"const call({:?})\", call_args);\n           eval_const_expr_partial(tcx, &result, ty_hint, Some(&call_args))?\n       },\n-      hir::ExprLit(ref lit) => lit_to_const(&lit.node, tcx, ety, lit.span)?,\n+      hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety, lit.span) {\n+          Ok(val) => val,\n+          Err(err) => signal!(e, err),\n+      },\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => eval_const_expr_partial(tcx, &expr, ty_hint, fn_args)?,\n@@ -930,7 +923,10 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n     };\n \n     match (ety.map(|t| &t.sty), result) {\n-        (Some(ref ty_hint), Integral(i)) => Ok(Integral(infer(i, tcx, ty_hint, e.span)?)),\n+        (Some(ref ty_hint), Integral(i)) => match infer(i, tcx, ty_hint) {\n+            Ok(inferred) => Ok(Integral(inferred)),\n+            Err(err) => signal!(e, err),\n+        },\n         (_, result) => Ok(result),\n     }\n }\n@@ -939,15 +935,9 @@ fn infer<'tcx>(\n     i: ConstInt,\n     tcx: &TyCtxt<'tcx>,\n     ty_hint: &ty::TypeVariants<'tcx>,\n-    span: Span\n-) -> Result<ConstInt, ConstEvalErr> {\n+) -> Result<ConstInt, ErrKind> {\n     use syntax::ast::*;\n \n-    let err = |e| ConstEvalErr {\n-        span: span,\n-        kind: e,\n-    };\n-\n     match (ty_hint, i) {\n         (&ty::TyInt(IntTy::I8), result @ I8(_)) => Ok(result),\n         (&ty::TyInt(IntTy::I16), result @ I16(_)) => Ok(result),\n@@ -993,17 +983,17 @@ fn infer<'tcx>(\n                 Err(_) => Ok(Usize(ConstUsize::Us32(i as u32))),\n             }\n         },\n-        (&ty::TyUint(_), InferSigned(_)) => Err(err(IntermediateUnsignedNegative)),\n+        (&ty::TyUint(_), InferSigned(_)) => Err(IntermediateUnsignedNegative),\n \n-        (&ty::TyInt(ity), i) => Err(err(TypeMismatch(ity.to_string(), i))),\n-        (&ty::TyUint(ity), i) => Err(err(TypeMismatch(ity.to_string(), i))),\n+        (&ty::TyInt(ity), i) => Err(TypeMismatch(ity.to_string(), i)),\n+        (&ty::TyUint(ity), i) => Err(TypeMismatch(ity.to_string(), i)),\n \n         (&ty::TyEnum(ref adt, _), i) => {\n             let hints = tcx.lookup_repr_hints(adt.did);\n             let int_ty = tcx.enum_repr_type(hints.iter().next());\n-            infer(i, tcx, &int_ty.to_ty(tcx).sty, span)\n+            infer(i, tcx, &int_ty.to_ty(tcx).sty)\n         },\n-        (_, i) => Err(err(BadType(ConstVal::Integral(i)))),\n+        (_, i) => Err(BadType(ConstVal::Integral(i))),\n     }\n }\n \n@@ -1089,23 +1079,22 @@ fn cast_const_int<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstInt, ty: ty::Ty) -> CastRe\n                 Err(_) => Ok(Integral(Usize(ConstUsize::Us32(v as u32)))),\n             }\n         },\n-        ty::TyFloat(ast::FloatTy::F64) if val.is_negative() => {\n-            // FIXME: this could probably be prettier\n-            // there's no easy way to turn an `Infer` into a f64\n-            let val = (-val).map_err(Math)?;\n-            let val = val.to_u64().unwrap() as f64;\n-            let val = -val;\n-            Ok(Float(val))\n+        ty::TyFloat(ast::FloatTy::F64) => match val.erase_type() {\n+            Infer(u) => Ok(Float(u as f64)),\n+            InferSigned(i) => Ok(Float(i as f64)),\n+            _ => bug!(\"ConstInt::erase_type returned something other than Infer/InferSigned\"),\n         },\n-        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(val.to_u64().unwrap() as f64)),\n-        ty::TyFloat(ast::FloatTy::F32) if val.is_negative() => {\n-            let val = (-val).map_err(Math)?;\n-            let val = val.to_u64().unwrap() as f32;\n-            let val = -val;\n-            Ok(Float(val as f64))\n+        ty::TyFloat(ast::FloatTy::F32) => match val.erase_type() {\n+            Infer(u) => Ok(Float(u as f32 as f64)),\n+            InferSigned(i) => Ok(Float(i as f32 as f64)),\n+            _ => bug!(\"ConstInt::erase_type returned something other than Infer/InferSigned\"),\n         },\n-        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(val.to_u64().unwrap() as f32 as f64)),\n         ty::TyRawPtr(_) => Err(ErrKind::UnimplementedConstVal(\"casting an address to a raw ptr\")),\n+        ty::TyChar => match infer(val, tcx, &ty::TyUint(ast::UintTy::U8)) {\n+            Ok(U8(u)) => Ok(Char(u as char)),\n+            // can only occur before typeck, typeck blocks `T as char` for `T` != `u8`\n+            _ => Err(CharCast(val)),\n+        },\n         _ => Err(CannotCast),\n     }\n }\n@@ -1136,36 +1125,36 @@ fn lit_to_const<'tcx>(lit: &ast::LitKind,\n                       tcx: &TyCtxt<'tcx>,\n                       ty_hint: Option<Ty<'tcx>>,\n                       span: Span,\n-                      ) -> Result<ConstVal, ConstEvalErr> {\n+                      ) -> Result<ConstVal, ErrKind> {\n     use syntax::ast::*;\n     use syntax::ast::LitIntType::*;\n     match *lit {\n         LitKind::Str(ref s, _) => Ok(Str((*s).clone())),\n         LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n         LitKind::Byte(n) => Ok(Integral(U8(n))),\n         LitKind::Int(n, Signed(ity)) => {\n-            infer(InferSigned(n as i64), tcx, &ty::TyInt(ity), span).map(Integral)\n+            infer(InferSigned(n as i64), tcx, &ty::TyInt(ity)).map(Integral)\n         },\n \n         LitKind::Int(n, Unsuffixed) => {\n             match ty_hint.map(|t| &t.sty) {\n                 Some(&ty::TyInt(ity)) => {\n-                    infer(InferSigned(n as i64), tcx, &ty::TyInt(ity), span).map(Integral)\n+                    infer(InferSigned(n as i64), tcx, &ty::TyInt(ity)).map(Integral)\n                 },\n                 Some(&ty::TyUint(uty)) => {\n-                    infer(Infer(n), tcx, &ty::TyUint(uty), span).map(Integral)\n+                    infer(Infer(n), tcx, &ty::TyUint(uty)).map(Integral)\n                 },\n                 None => Ok(Integral(Infer(n))),\n                 Some(&ty::TyEnum(ref adt, _)) => {\n                     let hints = tcx.lookup_repr_hints(adt.did);\n                     let int_ty = tcx.enum_repr_type(hints.iter().next());\n-                    infer(Infer(n), tcx, &int_ty.to_ty(tcx).sty, span).map(Integral)\n+                    infer(Infer(n), tcx, &int_ty.to_ty(tcx).sty).map(Integral)\n                 },\n                 Some(ty_hint) => bug!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),\n             }\n         },\n         LitKind::Int(n, Unsigned(ity)) => {\n-            infer(Infer(n), tcx, &ty::TyUint(ity), span).map(Integral)\n+            infer(Infer(n), tcx, &ty::TyUint(ity)).map(Integral)\n         },\n \n         LitKind::Float(ref n, _) |"}, {"sha": "b590cc91c5918d0e440dcb6c9f0bbde26d969b52", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -147,7 +147,7 @@ enum ResolutionError<'a> {\n     /// error E0416: identifier is bound more than once in the same pattern\n     IdentifierBoundMoreThanOnceInSamePattern(&'a str),\n     /// error E0417: static variables cannot be referenced in a pattern\n-    StaticVariableReference,\n+    StaticVariableReference(DefId, Option<Name>),\n     /// error E0418: is not an enum variant, struct or const\n     NotAnEnumVariantStructOrConst(&'a str),\n     /// error E0419: unresolved enum variant, struct or const\n@@ -352,12 +352,24 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                              \"identifier `{}` is bound more than once in the same pattern\",\n                              identifier)\n         }\n-        ResolutionError::StaticVariableReference => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0417,\n-                             \"static variables cannot be referenced in a pattern, use a \\\n-                              `const` instead\")\n+        ResolutionError::StaticVariableReference(did, name) => {\n+            let mut err = struct_span_err!(resolver.session,\n+                                           span,\n+                                           E0417,\n+                                           \"static variables cannot be referenced in a \\\n+                                            pattern, use a `const` instead\");\n+            if let Some(sp) = resolver.ast_map.span_if_local(did) {\n+                err.span_note(sp, \"static variable defined here\");\n+            }\n+            if let Some(name) = name {\n+                if let Some(binding) = resolver.current_module\n+                                               .resolve_name_in_lexical_scope(name, ValueNS) {\n+                    if binding.is_import() {\n+                        err.span_note(binding.span, \"static variable imported here\");\n+                    }\n+                }\n+            }\n+            err\n         }\n         ResolutionError::NotAnEnumVariantStructOrConst(name) => {\n             struct_span_err!(resolver.session,\n@@ -2313,10 +2325,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             Def::Variant(..) | Def::Const(..) => {\n                                 self.record_def(pattern.id, path_res);\n                             }\n-                            Def::Static(..) => {\n+                            Def::Static(did, _) => {\n                                 resolve_error(&self,\n                                               path.span,\n-                                              ResolutionError::StaticVariableReference);\n+                                              ResolutionError::StaticVariableReference(\n+                                                  did, None));\n                                 self.record_def(pattern.id, err_path_resolution());\n                             }\n                             _ => {\n@@ -2456,8 +2469,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some(def @ Def::Const(..)) | Some(def @ Def::AssociatedConst(..)) => {\n                 FoundConst(def, ident.unhygienic_name)\n             }\n-            Some(Def::Static(..)) => {\n-                resolve_error(self, span, ResolutionError::StaticVariableReference);\n+            Some(Def::Static(did, _)) => {\n+                resolve_error(self, span, ResolutionError::StaticVariableReference(\n+                    did, Some(ident.unhygienic_name)));\n                 BareIdentifierPatternUnresolved\n             }\n             _ => BareIdentifierPatternUnresolved,"}, {"sha": "ac658af4006b1fe089bd8de4d5f701af12a81214", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "modified", "additions": 100, "deletions": 56, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -60,8 +60,8 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn enum_data(&mut self, data: EnumData) {\n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"qualname\", &data.qualname),\n@@ -73,9 +73,9 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn extern_crate(&mut self, data: ExternCrateData) {\n-        let id = data.id.to_string();\n+        let id = data.id.index.as_u32().to_string();\n         let crate_num = data.crate_num.to_string();\n-        let scope = data.scope.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"name\", &data.name),\n@@ -88,50 +88,68 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn impl_data(&mut self, data: ImplData) {\n-        let id = data.id.to_string();\n-        let ref_id = data.self_ref.unwrap_or(Id::null()).to_string();\n-        let trait_id = data.trait_ref.unwrap_or(Id::null()).to_string();\n-        let scope = data.scope.to_string();\n+        let self_ref = data.self_ref.unwrap_or(null_def_id());\n+        let trait_ref = data.trait_ref.unwrap_or(null_def_id());\n+\n+        let id = data.id.index.as_u32().to_string();\n+        let ref_id = self_ref.index.as_usize().to_string();\n+        let ref_id_crate = self_ref.krate.to_string();\n+        let trait_id = trait_ref.index.as_usize().to_string();\n+        let trait_id_crate = trait_ref.krate.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"refid\", &ref_id),\n+            (\"refidcrate\", &ref_id_crate),\n             (\"traitid\", &trait_id),\n+            (\"traitidcrate\", &trait_id_crate),\n             (\"scopeid\", &scope)\n         ]);\n \n         self.record(\"impl\", data.span, values);\n     }\n \n     fn inheritance(&mut self, data: InheritanceData) {\n-        let base_id = data.base_id.to_string();\n-        let deriv_id = data.deriv_id.to_string();\n-        let values = make_values_str(&[\n-            (\"base\", &base_id),\n-            (\"derived\", &deriv_id),\n-        ]);\n+       let base_id = data.base_id.index.as_usize().to_string();\n+       let base_crate = data.base_id.krate.to_string();\n+       let deriv_id = data.deriv_id.index.as_u32().to_string();\n+       let deriv_crate = data.deriv_id.krate.to_string();\n+       let values = make_values_str(&[\n+           (\"base\", &base_id),\n+           (\"basecrate\", &base_crate),\n+           (\"derived\", &deriv_id),\n+           (\"derivedcrate\", &deriv_crate)\n+       ]);\n \n        self.record(\"inheritance\", data.span, values);\n     }\n \n     fn function(&mut self, data: FunctionData) {\n-        let id = data.id.to_string();\n-        let decl_id = data.declaration.unwrap_or(Id::null()).to_string();\n-        let scope = data.scope.to_string();\n+        let (decl_id, decl_crate) = match data.declaration {\n+            Some(id) => (id.index.as_usize().to_string(), id.krate.to_string()),\n+            None => (String::new(), String::new())\n+        };\n+\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"qualname\", &data.qualname),\n             (\"declid\", &decl_id),\n+            (\"declidcrate\", &decl_crate),\n             (\"scopeid\", &scope)\n         ]);\n \n         self.record(\"function\", data.span, values);\n     }\n \n     fn function_ref(&mut self, data: FunctionRefData) {\n-        let ref_id = data.ref_id.to_string();\n-        let scope = data.scope.to_string();\n+        let ref_id = data.ref_id.index.as_usize().to_string();\n+        let ref_crate = data.ref_id.krate.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"refid\", &ref_id),\n+            (\"refidcrate\", &ref_crate),\n             (\"qualname\", \"\"),\n             (\"scopeid\", &scope)\n         ]);\n@@ -140,11 +158,13 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn function_call(&mut self, data: FunctionCallData) {\n-        let ref_id = data.ref_id.to_string();\n+        let ref_id = data.ref_id.index.as_usize().to_string();\n+        let ref_crate = data.ref_id.krate.to_string();\n         let qualname = String::new();\n-        let scope = data.scope.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"refid\", &ref_id),\n+            (\"refidcrate\", &ref_crate),\n             (\"qualname\", &qualname),\n             (\"scopeid\", &scope)\n         ]);\n@@ -153,8 +173,8 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn method(&mut self, data: MethodData) {\n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"qualname\", &data.qualname),\n@@ -165,12 +185,21 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn method_call(&mut self, data: MethodCallData) {\n-        let decl_id = data.decl_id.unwrap_or(Id::null()).to_string();\n-        let ref_id = data.ref_id.unwrap_or(Id::null()).to_string();\n-        let scope = data.scope.to_string();\n+        let (dcn, dck) = match data.decl_id {\n+            Some(declid) => (declid.index.as_usize().to_string(), declid.krate.to_string()),\n+            None => (String::new(), String::new()),\n+        };\n+\n+        let ref_id = data.ref_id.unwrap_or(null_def_id());\n+\n+        let def_id = ref_id.index.as_usize().to_string();\n+        let def_crate = ref_id.krate.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n-            (\"refid\", &ref_id),\n-            (\"declid\", &decl_id),\n+            (\"refid\", &def_id),\n+            (\"refidcrate\", &def_crate),\n+            (\"declid\", &dcn),\n+            (\"declidcrate\", &dck),\n             (\"scopeid\", &scope)\n         ]);\n \n@@ -187,7 +216,7 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn macro_use(&mut self, data: MacroUseData) {\n-        let scope = data.scope.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"callee_name\", &data.name),\n             (\"qualname\", &data.qualname),\n@@ -198,8 +227,8 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn mod_data(&mut self, data: ModData) {\n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"qualname\", &data.qualname),\n@@ -211,11 +240,15 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn mod_ref(&mut self, data: ModRefData) {\n-        let ref_id = data.ref_id.unwrap_or(Id::null()).to_string();\n+        let (ref_id, ref_crate) = match data.ref_id {\n+            Some(rid) => (rid.index.as_usize().to_string(), rid.krate.to_string()),\n+            None => (0.to_string(), 0.to_string())\n+        };\n \n-        let scope = data.scope.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"refid\", &ref_id),\n+            (\"refidcrate\", &ref_crate),\n             (\"qualname\", &data.qualname),\n             (\"scopeid\", &scope)\n         ]);\n@@ -224,9 +257,9 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn struct_data(&mut self, data: StructData) {\n-        let id = data.id.to_string();\n-        let ctor_id = data.ctor_id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let ctor_id = data.ctor_id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"ctor_id\", &ctor_id),\n@@ -239,8 +272,8 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn struct_variant(&mut self, data: StructVariantData) {\n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"ctor_id\", &id),\n@@ -254,8 +287,8 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn trait_data(&mut self, data: TraitData) {\n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"qualname\", &data.qualname),\n@@ -267,8 +300,8 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn tuple_variant(&mut self, data: TupleVariantData) {\n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"name\", &data.name),\n@@ -282,10 +315,15 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn type_ref(&mut self, data: TypeRefData) {\n-        let ref_id = data.ref_id.unwrap_or(Id::null()).to_string();\n-        let scope = data.scope.to_string();\n+        let (ref_id, ref_crate) = match data.ref_id {\n+            Some(id) => (id.index.as_usize().to_string(), id.krate.to_string()),\n+            None => (0.to_string(), 0.to_string())\n+        };\n+\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"refid\", &ref_id),\n+            (\"refidcrate\", &ref_crate),\n             (\"qualname\", &data.qualname),\n             (\"scopeid\", &scope)\n         ]);\n@@ -294,7 +332,7 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn typedef(&mut self, data: TypedefData) {\n-        let id = data.id.to_string();\n+        let id = data.id.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"qualname\", &data.qualname),\n@@ -305,12 +343,16 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn use_data(&mut self, data: UseData) {\n-        let id = data.id.to_string();\n-        let mod_id = data.mod_id.unwrap_or(Id::null()).to_string();\n-        let scope = data.scope.to_string();\n+        let mod_id = data.mod_id.unwrap_or(null_def_id());\n+\n+        let id = data.id.index.as_u32().to_string();\n+        let ref_id = mod_id.index.as_usize().to_string();\n+        let ref_crate = mod_id.krate.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n-            (\"mod_id\", &mod_id),\n+            (\"refid\", &ref_id),\n+            (\"refidcrate\", &ref_crate),\n             (\"name\", &data.name),\n             (\"scopeid\", &scope)\n         ]);\n@@ -321,8 +363,8 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     fn use_glob(&mut self, data: UseGlobData) {\n         let names = data.names.join(\", \");\n \n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"value\", &names),\n@@ -333,8 +375,8 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn variable(&mut self, data: VariableData) {\n-        let id = data.id.to_string();\n-        let scope = data.scope.to_string();\n+        let id = data.id.index.as_u32().to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n             (\"id\", &id),\n             (\"name\", &data.name),\n@@ -348,10 +390,12 @@ impl<'b, W: Write + 'b> Dump for CsvDumper<'b, W> {\n     }\n \n     fn variable_ref(&mut self, data: VariableRefData) {\n-        let id = data.ref_id.to_string();\n-        let scope = data.scope.to_string();\n+        let ref_id = data.ref_id.index.as_usize().to_string();\n+        let ref_crate = data.ref_id.krate.to_string();\n+        let scope = data.scope.index.as_u32().to_string();\n         let values = make_values_str(&[\n-            (\"id\", &id),\n+            (\"refid\", &ref_id),\n+            (\"refidcrate\", &ref_crate),\n             (\"qualname\", \"\"),\n             (\"scopeid\", &scope)\n         ]);"}, {"sha": "db4bd1d6d730821623532854f454183f60b70a33", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 101, "deletions": 123, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt::{self, Display, Formatter};\n-\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::map::Map;\n use rustc::ty::TyCtxt;\n use syntax::ast::{CrateNum, NodeId};\n@@ -24,32 +22,12 @@ pub trait Lower {\n     fn lower(self, tcx: &TyCtxt) -> Self::Target;\n }\n \n-// We use a newtype to enforce conversion of all NodeIds (which are u32s as well)\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable)]\n-pub struct Id(u32);\n-\n-impl Id {\n-    pub fn from_def_id(id: DefId) -> Id {\n-        Id(id.index.as_u32())\n-    }\n-\n-    // FIXME: this function is called with non-local NodeIds. This means that they\n-    // cannot be mapped to a DefId. We should remove those calls. In the meantime,\n-    // we return a \"null Id\" when the NodeId is invalid.\n-    pub fn from_node_id(id: NodeId, map: &Map) -> Id {\n-        map.opt_local_def_id(id).map(|id| Id(id.index.as_u32()))\n-                                .unwrap_or(Id::null())\n-    }\n-\n-    pub fn null() -> Id {\n-        Id(u32::max_value())\n-    }\n+fn make_def_id(id: NodeId, map: &Map) -> DefId {\n+    map.opt_local_def_id(id).unwrap_or(null_def_id())\n }\n \n-impl Display for Id {\n-    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n-        self.0.fmt(f)\n-    }\n+pub fn null_def_id() -> DefId {\n+    DefId { krate: u32::max_value(), index: DefIndex::from_u32(u32::max_value()) }\n }\n \n #[derive(Clone, Debug, RustcEncodable)]\n@@ -106,49 +84,49 @@ impl Lower for data::CratePreludeData {\n /// Data for enum declarations.\n #[derive(Clone, Debug, RustcEncodable)]\n pub struct EnumData {\n-    pub id: Id,\n+    pub id: DefId,\n     pub value: String,\n     pub qualname: String,\n     pub span: SpanData,\n-    pub scope: Id,\n+    pub scope: DefId,\n }\n \n impl Lower for data::EnumData {\n     type Target = EnumData;\n \n     fn lower(self, tcx: &TyCtxt) -> EnumData {\n         EnumData {\n-            id: Id::from_node_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.map),\n             value: self.value,\n             qualname: self.qualname,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.map),\n         }\n     }\n }\n \n /// Data for extern crates.\n #[derive(Debug, RustcEncodable)]\n pub struct ExternCrateData {\n-    pub id: Id,\n+    pub id: DefId,\n     pub name: String,\n     pub crate_num: CrateNum,\n     pub location: String,\n     pub span: SpanData,\n-    pub scope: Id,\n+    pub scope: DefId,\n }\n \n impl Lower for data::ExternCrateData {\n     type Target = ExternCrateData;\n \n     fn lower(self, tcx: &TyCtxt) -> ExternCrateData {\n         ExternCrateData {\n-            id: Id::from_node_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.map),\n             name: self.name,\n             crate_num: self.crate_num,\n             location: self.location,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.map),\n         }\n     }\n }\n@@ -157,8 +135,8 @@ impl Lower for data::ExternCrateData {\n #[derive(Debug, RustcEncodable)]\n pub struct FunctionCallData {\n     pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Id,\n+    pub scope: DefId,\n+    pub ref_id: DefId,\n }\n \n impl Lower for data::FunctionCallData {\n@@ -167,34 +145,34 @@ impl Lower for data::FunctionCallData {\n     fn lower(self, tcx: &TyCtxt) -> FunctionCallData {\n         FunctionCallData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n-            ref_id: Id::from_def_id(self.ref_id),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            ref_id: self.ref_id,\n         }\n     }\n }\n \n /// Data for all kinds of functions and methods.\n #[derive(Clone, Debug, RustcEncodable)]\n pub struct FunctionData {\n-    pub id: Id,\n+    pub id: DefId,\n     pub name: String,\n     pub qualname: String,\n-    pub declaration: Option<Id>,\n+    pub declaration: Option<DefId>,\n     pub span: SpanData,\n-    pub scope: Id,\n+    pub scope: DefId,\n }\n \n impl Lower for data::FunctionData {\n     type Target = FunctionData;\n \n     fn lower(self, tcx: &TyCtxt) -> FunctionData {\n         FunctionData {\n-            id: Id::from_node_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.map),\n             name: self.name,\n             qualname: self.qualname,\n-            declaration: self.declaration.map(Id::from_def_id),\n+            declaration: self.declaration,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.map),\n         }\n     }\n }\n@@ -203,8 +181,8 @@ impl Lower for data::FunctionData {\n #[derive(Debug, RustcEncodable)]\n pub struct FunctionRefData {\n     pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Id,\n+    pub scope: DefId,\n+    pub ref_id: DefId,\n }\n \n impl Lower for data::FunctionRefData {\n@@ -213,39 +191,39 @@ impl Lower for data::FunctionRefData {\n     fn lower(self, tcx: &TyCtxt) -> FunctionRefData {\n         FunctionRefData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n-            ref_id: Id::from_def_id(self.ref_id),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            ref_id: self.ref_id,\n         }\n     }\n }\n #[derive(Debug, RustcEncodable)]\n pub struct ImplData {\n-    pub id: Id,\n+    pub id: DefId,\n     pub span: SpanData,\n-    pub scope: Id,\n-    pub trait_ref: Option<Id>,\n-    pub self_ref: Option<Id>,\n+    pub scope: DefId,\n+    pub trait_ref: Option<DefId>,\n+    pub self_ref: Option<DefId>,\n }\n \n impl Lower for data::ImplData {\n     type Target = ImplData;\n \n     fn lower(self, tcx: &TyCtxt) -> ImplData {\n         ImplData {\n-            id: Id::from_node_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.map),\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n-            trait_ref: self.trait_ref.map(Id::from_def_id),\n-            self_ref: self.self_ref.map(Id::from_def_id),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            trait_ref: self.trait_ref,\n+            self_ref: self.self_ref,\n         }\n     }\n }\n \n #[derive(Debug, RustcEncodable)]\n pub struct InheritanceData {\n     pub span: SpanData,\n-    pub base_id: Id,\n-    pub deriv_id: Id\n+    pub base_id: DefId,\n+    pub deriv_id: DefId\n }\n \n impl Lower for data::InheritanceData {\n@@ -254,8 +232,8 @@ impl Lower for data::InheritanceData {\n     fn lower(self, tcx: &TyCtxt) -> InheritanceData {\n         InheritanceData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            base_id: Id::from_def_id(self.base_id),\n-            deriv_id: Id::from_node_id(self.deriv_id, &tcx.map)\n+            base_id: self.base_id,\n+            deriv_id: make_def_id(self.deriv_id, &tcx.map)\n         }\n     }\n }\n@@ -289,7 +267,7 @@ pub struct MacroUseData {\n     // Because macro expansion happens before ref-ids are determined,\n     // we use the callee span to reference the associated macro definition.\n     pub callee_span: SpanData,\n-    pub scope: Id,\n+    pub scope: DefId,\n     pub imported: bool,\n }\n \n@@ -302,7 +280,7 @@ impl Lower for data::MacroUseData {\n             name: self.name,\n             qualname: self.qualname,\n             callee_span: SpanData::from_span(self.callee_span, tcx.sess.codemap()),\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.map),\n             imported: self.imported,\n         }\n     }\n@@ -312,9 +290,9 @@ impl Lower for data::MacroUseData {\n #[derive(Debug, RustcEncodable)]\n pub struct MethodCallData {\n     pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Option<Id>,\n-    pub decl_id: Option<Id>,\n+    pub scope: DefId,\n+    pub ref_id: Option<DefId>,\n+    pub decl_id: Option<DefId>,\n }\n \n impl Lower for data::MethodCallData {\n@@ -323,20 +301,20 @@ impl Lower for data::MethodCallData {\n     fn lower(self, tcx: &TyCtxt) -> MethodCallData {\n         MethodCallData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n-            ref_id: self.ref_id.map(Id::from_def_id),\n-            decl_id: self.decl_id.map(Id::from_def_id),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            ref_id: self.ref_id,\n+            decl_id: self.decl_id,\n         }\n     }\n }\n \n /// Data for method declarations (methods with a body are treated as functions).\n #[derive(Clone, Debug, RustcEncodable)]\n pub struct MethodData {\n-    pub id: Id,\n+    pub id: DefId,\n     pub qualname: String,\n     pub span: SpanData,\n-    pub scope: Id,\n+    pub scope: DefId,\n }\n \n impl Lower for data::MethodData {\n@@ -345,8 +323,8 @@ impl Lower for data::MethodData {\n     fn lower(self, tcx: &TyCtxt) -> MethodData {\n         MethodData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n-            id: Id::from_node_id(self.id, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            id: make_def_id(self.id, &tcx.map),\n             qualname: self.qualname,\n         }\n     }\n@@ -355,11 +333,11 @@ impl Lower for data::MethodData {\n /// Data for modules.\n #[derive(Debug, RustcEncodable)]\n pub struct ModData {\n-    pub id: Id,\n+    pub id: DefId,\n     pub name: String,\n     pub qualname: String,\n     pub span: SpanData,\n-    pub scope: Id,\n+    pub scope: DefId,\n     pub filename: String,\n }\n \n@@ -368,11 +346,11 @@ impl Lower for data::ModData {\n \n     fn lower(self, tcx: &TyCtxt) -> ModData {\n         ModData {\n-            id: Id::from_node_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.map),\n             name: self.name,\n             qualname: self.qualname,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.map),\n             filename: self.filename,\n         }\n     }\n@@ -382,8 +360,8 @@ impl Lower for data::ModData {\n #[derive(Debug, RustcEncodable)]\n pub struct ModRefData {\n     pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Option<Id>,\n+    pub scope: DefId,\n+    pub ref_id: Option<DefId>,\n     pub qualname: String\n }\n \n@@ -393,8 +371,8 @@ impl Lower for data::ModRefData {\n     fn lower(self, tcx: &TyCtxt) -> ModRefData {\n         ModRefData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n-            ref_id: self.ref_id.map(Id::from_def_id),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            ref_id: self.ref_id,\n             qualname: self.qualname,\n         }\n     }\n@@ -403,10 +381,10 @@ impl Lower for data::ModRefData {\n #[derive(Debug, RustcEncodable)]\n pub struct StructData {\n     pub span: SpanData,\n-    pub id: Id,\n-    pub ctor_id: Id,\n+    pub id: DefId,\n+    pub ctor_id: DefId,\n     pub qualname: String,\n-    pub scope: Id,\n+    pub scope: DefId,\n     pub value: String\n }\n \n@@ -416,10 +394,10 @@ impl Lower for data::StructData {\n     fn lower(self, tcx: &TyCtxt) -> StructData {\n         StructData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            id: Id::from_node_id(self.id, &tcx.map),\n-            ctor_id: Id::from_node_id(self.ctor_id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.map),\n+            ctor_id: make_def_id(self.ctor_id, &tcx.map),\n             qualname: self.qualname,\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.map),\n             value: self.value\n         }\n     }\n@@ -428,11 +406,11 @@ impl Lower for data::StructData {\n #[derive(Debug, RustcEncodable)]\n pub struct StructVariantData {\n     pub span: SpanData,\n-    pub id: Id,\n+    pub id: DefId,\n     pub qualname: String,\n     pub type_value: String,\n     pub value: String,\n-    pub scope: Id\n+    pub scope: DefId\n }\n \n impl Lower for data::StructVariantData {\n@@ -441,21 +419,21 @@ impl Lower for data::StructVariantData {\n     fn lower(self, tcx: &TyCtxt) -> StructVariantData {\n         StructVariantData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            id: Id::from_node_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.map),\n             qualname: self.qualname,\n             type_value: self.type_value,\n             value: self.value,\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.map),\n         }\n     }\n }\n \n #[derive(Debug, RustcEncodable)]\n pub struct TraitData {\n     pub span: SpanData,\n-    pub id: Id,\n+    pub id: DefId,\n     pub qualname: String,\n-    pub scope: Id,\n+    pub scope: DefId,\n     pub value: String\n }\n \n@@ -465,9 +443,9 @@ impl Lower for data::TraitData {\n     fn lower(self, tcx: &TyCtxt) -> TraitData {\n         TraitData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            id: Id::from_node_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.map),\n             qualname: self.qualname,\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.map),\n             value: self.value,\n         }\n     }\n@@ -476,12 +454,12 @@ impl Lower for data::TraitData {\n #[derive(Debug, RustcEncodable)]\n pub struct TupleVariantData {\n     pub span: SpanData,\n-    pub id: Id,\n+    pub id: DefId,\n     pub name: String,\n     pub qualname: String,\n     pub type_value: String,\n     pub value: String,\n-    pub scope: Id,\n+    pub scope: DefId,\n }\n \n impl Lower for data::TupleVariantData {\n@@ -490,20 +468,20 @@ impl Lower for data::TupleVariantData {\n     fn lower(self, tcx: &TyCtxt) -> TupleVariantData {\n         TupleVariantData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            id: Id::from_node_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.map),\n             name: self.name,\n             qualname: self.qualname,\n             type_value: self.type_value,\n             value: self.value,\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.map),\n         }\n     }\n }\n \n /// Data for a typedef.\n #[derive(Debug, RustcEncodable)]\n pub struct TypedefData {\n-    pub id: Id,\n+    pub id: DefId,\n     pub span: SpanData,\n     pub qualname: String,\n     pub value: String,\n@@ -514,7 +492,7 @@ impl Lower for data::TypedefData {\n \n     fn lower(self, tcx: &TyCtxt) -> TypedefData {\n         TypedefData {\n-            id: Id::from_node_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.map),\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             qualname: self.qualname,\n             value: self.value,\n@@ -526,8 +504,8 @@ impl Lower for data::TypedefData {\n #[derive(Clone, Debug, RustcEncodable)]\n pub struct TypeRefData {\n     pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Option<Id>,\n+    pub scope: DefId,\n+    pub ref_id: Option<DefId>,\n     pub qualname: String,\n }\n \n@@ -537,65 +515,65 @@ impl Lower for data::TypeRefData {\n     fn lower(self, tcx: &TyCtxt) -> TypeRefData {\n         TypeRefData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n-            ref_id: self.ref_id.map(Id::from_def_id),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            ref_id: self.ref_id,\n             qualname: self.qualname,\n         }\n     }\n }\n \n #[derive(Debug, RustcEncodable)]\n pub struct UseData {\n-    pub id: Id,\n+    pub id: DefId,\n     pub span: SpanData,\n     pub name: String,\n-    pub mod_id: Option<Id>,\n-    pub scope: Id\n+    pub mod_id: Option<DefId>,\n+    pub scope: DefId\n }\n \n impl Lower for data::UseData {\n     type Target = UseData;\n \n     fn lower(self, tcx: &TyCtxt) -> UseData {\n         UseData {\n-            id: Id::from_node_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.map),\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n-            mod_id: self.mod_id.map(Id::from_def_id),\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n+            mod_id: self.mod_id,\n+            scope: make_def_id(self.scope, &tcx.map),\n         }\n     }\n }\n \n #[derive(Debug, RustcEncodable)]\n pub struct UseGlobData {\n-    pub id: Id,\n+    pub id: DefId,\n     pub span: SpanData,\n     pub names: Vec<String>,\n-    pub scope: Id\n+    pub scope: DefId\n }\n \n impl Lower for data::UseGlobData {\n     type Target = UseGlobData;\n \n     fn lower(self, tcx: &TyCtxt) -> UseGlobData {\n         UseGlobData {\n-            id: Id::from_node_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.map),\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             names: self.names,\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.map),\n         }\n     }\n }\n \n /// Data for local and global variables (consts and statics).\n #[derive(Debug, RustcEncodable)]\n pub struct VariableData {\n-    pub id: Id,\n+    pub id: DefId,\n     pub name: String,\n     pub qualname: String,\n     pub span: SpanData,\n-    pub scope: Id,\n+    pub scope: DefId,\n     pub value: String,\n     pub type_value: String,\n }\n@@ -605,11 +583,11 @@ impl Lower for data::VariableData {\n \n     fn lower(self, tcx: &TyCtxt) -> VariableData {\n         VariableData {\n-            id: Id::from_node_id(self.id, &tcx.map),\n+            id: make_def_id(self.id, &tcx.map),\n             name: self.name,\n             qualname: self.qualname,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n+            scope: make_def_id(self.scope, &tcx.map),\n             value: self.value,\n             type_value: self.type_value,\n         }\n@@ -622,8 +600,8 @@ impl Lower for data::VariableData {\n pub struct VariableRefData {\n     pub name: String,\n     pub span: SpanData,\n-    pub scope: Id,\n-    pub ref_id: Id,\n+    pub scope: DefId,\n+    pub ref_id: DefId,\n }\n \n impl Lower for data::VariableRefData {\n@@ -633,8 +611,8 @@ impl Lower for data::VariableRefData {\n         VariableRefData {\n             name: self.name,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n-            scope: Id::from_node_id(self.scope, &tcx.map),\n-            ref_id: Id::from_def_id(self.ref_id),\n+            scope: make_def_id(self.scope, &tcx.map),\n+            ref_id: self.ref_id,\n         }\n     }\n }"}, {"sha": "fab3bb60e0b2a5252589f0dee06082559bded409", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -233,7 +233,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             match *source {\n                 CandidateSource::ImplSource(impl_did) => {\n                     // Provide the best span we can. Use the item, if local to crate, else\n-                    // the impl, if local to crate (item may be defaulted), else the call site.\n+                    // the impl, if local to crate (item may be defaulted), else nothing.\n                     let item = impl_item(fcx.tcx(), impl_did, item_name)\n                         .or_else(|| {\n                             trait_item(\n@@ -242,8 +242,9 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                 item_name\n                             )\n                         }).unwrap();\n-                    let impl_span = fcx.tcx().map.def_id_span(impl_did, span);\n-                    let item_span = fcx.tcx().map.def_id_span(item.def_id(), impl_span);\n+                    let note_span = fcx.tcx().map.span_if_local(item.def_id()).or_else(|| {\n+                        fcx.tcx().map.span_if_local(impl_did)\n+                    });\n \n                     let impl_ty = check::impl_self_ty(fcx, span, impl_did).ty;\n \n@@ -255,11 +256,17 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         }\n                     };\n \n-                    span_note!(err, item_span,\n-                               \"candidate #{} is defined in an impl{} for the type `{}`\",\n-                               idx + 1,\n-                               insertion,\n-                               impl_ty);\n+                    let note_str = format!(\"candidate #{} is defined in an impl{} \\\n+                                            for the type `{}`\",\n+                                           idx + 1,\n+                                           insertion,\n+                                           impl_ty);\n+                    if let Some(note_span) = note_span {\n+                        // We have a span pointing to the method. Show note with snippet.\n+                        err.span_note(note_span, &note_str);\n+                    } else {\n+                        err.note(&note_str);\n+                    }\n                 }\n                 CandidateSource::TraitSource(trait_did) => {\n                     let item = trait_item(fcx.tcx(), trait_did, item_name).unwrap();"}, {"sha": "36eb1a1301c9ded4db01f9b8bccaac9546987330", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -20,6 +20,7 @@ use rustc::hir;\n use rustc::middle::cstore::{self, CrateStore};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n+use rustc::hir::print as pprust;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::subst;\n use rustc::middle::stability;\n@@ -30,7 +31,7 @@ use core::{DocContext, DocAccessLevels};\n use doctree;\n use clean::{self, GetDefId};\n \n-use super::{Clean, ToSource};\n+use super::Clean;\n \n /// Attempt to inline the definition of a local node id into this AST.\n ///\n@@ -333,8 +334,8 @@ pub fn build_impl(cx: &DocContext,\n                 let did = assoc_const.def_id;\n                 let type_scheme = tcx.lookup_item_type(did);\n                 let default = if assoc_const.has_value {\n-                    Some(lookup_const_by_id(tcx, did, None)\n-                         .unwrap().0.span.to_src(cx))\n+                    Some(pprust::expr_to_string(\n+                        lookup_const_by_id(tcx, did, None).unwrap().0))\n                 } else {\n                     None\n                 };\n@@ -479,8 +480,6 @@ fn build_module(cx: &DocContext, tcx: &TyCtxt,\n \n fn build_const(cx: &DocContext, tcx: &TyCtxt,\n                did: DefId) -> clean::Constant {\n-    use rustc::hir::print as pprust;\n-\n     let (expr, ty) = lookup_const_by_id(tcx, did, None).unwrap_or_else(|| {\n         panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n     });"}, {"sha": "0a606e1425c4552579b597d27a02d0c1ca733a3e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -39,6 +39,7 @@ use rustc::middle::cstore::{self, CrateStore};\n use rustc::middle::privacy::AccessLevels;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc::hir::print as pprust;\n use rustc::ty::subst::{self, ParamSpace, VecPerParamSpace};\n use rustc::ty;\n use rustc::middle::stability;\n@@ -1285,8 +1286,7 @@ impl Clean<Item> for hir::TraitItem {\n         let inner = match self.node {\n             hir::ConstTraitItem(ref ty, ref default) => {\n                 AssociatedConstItem(ty.clean(cx),\n-                                    default.as_ref().map(|expr|\n-                                                         expr.span.to_src(cx)))\n+                                    default.as_ref().map(|e| pprust::expr_to_string(&e)))\n             }\n             hir::MethodTraitItem(ref sig, Some(_)) => {\n                 MethodItem(sig.clean(cx))\n@@ -1316,7 +1316,7 @@ impl Clean<Item> for hir::ImplItem {\n         let inner = match self.node {\n             hir::ImplItemKind::Const(ref ty, ref expr) => {\n                 AssociatedConstItem(ty.clean(cx),\n-                                    Some(expr.span.to_src(cx)))\n+                                    Some(pprust::expr_to_string(expr)))\n             }\n             hir::ImplItemKind::Method(ref sig, _) => {\n                 MethodItem(sig.clean(cx))\n@@ -1635,8 +1635,8 @@ impl Clean<Type> for hir::Ty {\n                 BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n                              type_: box m.ty.clean(cx)},\n             TyVec(ref ty) => Vector(box ty.clean(cx)),\n-            TyFixedLengthVec(ref ty, ref e) => FixedVector(box ty.clean(cx),\n-                                                           e.span.to_src(cx)),\n+            TyFixedLengthVec(ref ty, ref e) =>\n+                FixedVector(box ty.clean(cx), pprust::expr_to_string(e)),\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(None, ref p) => {\n                 resolve_type(cx, p.clean(cx), self.id)\n@@ -2185,7 +2185,7 @@ impl Clean<Item> for doctree::Static {\n             inner: StaticItem(Static {\n                 type_: self.type_.clean(cx),\n                 mutability: self.mutability.clean(cx),\n-                expr: self.expr.span.to_src(cx),\n+                expr: pprust::expr_to_string(&self.expr),\n             }),\n         }\n     }\n@@ -2209,7 +2209,7 @@ impl Clean<Item> for doctree::Constant {\n             deprecation: self.depr.clean(cx),\n             inner: ConstantItem(Constant {\n                 type_: self.type_.clean(cx),\n-                expr: self.expr.span.to_src(cx),\n+                expr: pprust::expr_to_string(&self.expr),\n             }),\n         }\n     }"}, {"sha": "7af5322e7bdf16ea73449e4e5b94e775a1602db5", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -26,6 +26,7 @@ use rustc::hir;\n use clean;\n use core::DocAccessLevels;\n use html::item_type::ItemType;\n+use html::escape::Escape;\n use html::render;\n use html::render::{cache, CURRENT_LOCATION_KEY};\n \n@@ -496,7 +497,7 @@ impl fmt::Display for clean::Type {\n                 primitive_link(f, clean::PrimitiveType::Array, \"[\")?;\n                 write!(f, \"{}\", t)?;\n                 primitive_link(f, clean::PrimitiveType::Array,\n-                               &format!(\"; {}]\", *s))\n+                               &format!(\"; {}]\", Escape(s)))\n             }\n             clean::Bottom => f.write_str(\"!\"),\n             clean::RawPointer(m, ref t) => {"}, {"sha": "36da95279fb24f7190666dd683ddb210eab207bd", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -1866,7 +1866,7 @@ impl<'a> fmt::Display for Initializer<'a> {\n         let Initializer(s) = *self;\n         if s.is_empty() { return Ok(()); }\n         write!(f, \"<code> = </code>\")?;\n-        write!(f, \"<code>{}</code>\", s)\n+        write!(f, \"<code>{}</code>\", Escape(s))\n     }\n }\n \n@@ -2106,7 +2106,7 @@ fn assoc_const(w: &mut fmt::Formatter,\n \n     write!(w, \": {}\", ty)?;\n     if let Some(default) = default {\n-        write!(w, \" = {}\", default)?;\n+        write!(w, \" = {}\", Escape(default))?;\n     }\n     Ok(())\n }"}, {"sha": "fbc8886ce8f8cd98589f2cd52dcf33421dc68d3c", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -326,6 +326,22 @@ impl fmt::Debug for CStr {\n     }\n }\n \n+#[stable(feature = \"cstr_default\", since = \"1.10.0\")]\n+impl<'a> Default for &'a CStr {\n+    fn default() -> &'a CStr {\n+        static SLICE: &'static [c_char] = &[0];\n+        unsafe { CStr::from_ptr(SLICE.as_ptr()) }\n+    }\n+}\n+\n+#[stable(feature = \"cstr_default\", since = \"1.10.0\")]\n+impl Default for CString {\n+    fn default() -> CString {\n+        let a: &CStr = Default::default();\n+        a.to_owned()\n+    }\n+}\n+\n #[stable(feature = \"cstr_borrow\", since = \"1.3.0\")]\n impl Borrow<CStr> for CString {\n     fn borrow(&self) -> &CStr { self }"}, {"sha": "d337c78bee8b5d1207658c06a41dc094f2d8823e", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 53, "deletions": 6, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -16,6 +16,22 @@ use errors::DiagnosticBuilder;\n use super::StringReader;\n \n const UNICODE_ARRAY: &'static [(char, &'static str, char)] = &[\n+    ('\u00a0', \"No-Break Space\", ' '),\n+    ('\u1680', \"Ogham Space Mark\", ' '),\n+    ('\u2000', \"En Quad\", ' '),\n+    ('\u2001', \"Em Quad\", ' '),\n+    ('\u2002', \"En Space\", ' '),\n+    ('\u2003', \"Em Space\", ' '),\n+    ('\u2004', \"Three-Per-Em Space\", ' '),\n+    ('\u2005', \"Four-Per-Em Space\", ' '),\n+    ('\u2006', \"Six-Per-Em Space\", ' '),\n+    ('\u2007', \"Figure Space\", ' '),\n+    ('\u2008', \"Punctuation Space\", ' '),\n+    ('\u2009', \"Thin Space\", ' '),\n+    ('\u200a', \"Hair Space\", ' '),\n+    ('\u202f', \"Narrow No-Break Space\", ' '),\n+    ('\u205f', \"Medium Mathematical Space\", ' '),\n+    ('\u3000', \"Ideographic Space\", ' '),\n     ('\u07fa', \"Nko Lajanyalan\", '_'),\n     ('\ufe4d', \"Dashed Low Line\", '_'),\n     ('\ufe4e', \"Centreline Low Line\", '_'),\n@@ -24,14 +40,18 @@ const UNICODE_ARRAY: &'static [(char, &'static str, char)] = &[\n     ('\u2011', \"Non-Breaking Hyphen\", '-'),\n     ('\u2012', \"Figure Dash\", '-'),\n     ('\u2013', \"En Dash\", '-'),\n+    ('\u2014', \"Em Dash\", '-'),\n     ('\ufe58', \"Small Em Dash\", '-'),\n     ('\u2043', \"Hyphen Bullet\", '-'),\n     ('\u02d7', \"Modifier Letter Minus Sign\", '-'),\n     ('\u2212', \"Minus Sign\", '-'),\n+    ('\u30fc', \"Katakana-Hiragana Prolonged Sound Mark\", '-'),\n     ('\u066b', \"Arabic Decimal Separator\", ','),\n     ('\u201a', \"Single Low-9 Quotation Mark\", ','),\n     ('\ua4f9', \"Lisu Letter Tone Na Po\", ','),\n+    ('\uff0c', \"Fullwidth Comma\", ','),\n     ('\u037e', \"Greek Question Mark\", ';'),\n+    ('\uff1b', \"Fullwidth Semicolon\", ';'),\n     ('\u0903', \"Devanagari Sign Visarga\", ':'),\n     ('\u0a83', \"Gujarati Sign Visarga\", ':'),\n     ('\uff1a', \"Fullwidth Colon\", ':'),\n@@ -53,16 +73,20 @@ const UNICODE_ARRAY: &'static [(char, &'static str, char)] = &[\n     ('\u0294', \"Latin Letter Glottal Stop\", '?'),\n     ('\u097d', \"Devanagari Letter Glottal Stop\", '?'),\n     ('\u13ae', \"Cherokee Letter He\", '?'),\n+    ('\uff1f', \"Fullwidth Question Mark\", '?'),\n     ('\ud834\udd6d', \"Musical Symbol Combining Augmentation Dot\", '.'),\n     ('\u2024', \"One Dot Leader\", '.'),\n     ('\u06d4', \"Arabic Full Stop\", '.'),\n     ('\u0701', \"Syriac Supralinear Full Stop\", '.'),\n     ('\u0702', \"Syriac Sublinear Full Stop\", '.'),\n     ('\ua60e', \"Vai Full Stop\", '.'),\n     ('\ud802\ude50', \"Kharoshthi Punctuation Dot\", '.'),\n+    ('\u00b7', \"Middle Dot\", '.'),\n     ('\u0660', \"Arabic-Indic Digit Zero\", '.'),\n     ('\u06f0', \"Extended Arabic-Indic Digit Zero\", '.'),\n     ('\ua4f8', \"Lisu Letter Tone Mya Ti\", '.'),\n+    ('\u3002', \"Ideographic Full Stop\", '.'),\n+    ('\u30fb', \"Katakana Middle Dot\", '.'),\n     ('\u055d', \"Armenian Comma\", '\\''),\n     ('\uff07', \"Fullwidth Apostrophe\", '\\''),\n     ('\u2018', \"Left Single Quotation Mark\", '\\''),\n@@ -108,16 +132,30 @@ const UNICODE_ARRAY: &'static [(char, &'static str, char)] = &[\n     ('\u05f2', \"Hebrew Ligature Yiddish Double Yod\", '\"'),\n     ('\u275e', \"Heavy Double Comma Quotation Mark Ornament\", '\"'),\n     ('\u275d', \"Heavy Double Turned Comma Quotation Mark Ornament\", '\"'),\n-    ('\uff3b', \"Fullwidth Left Square Bracket\", '('),\n     ('\u2768', \"Medium Left Parenthesis Ornament\", '('),\n-    ('\u2772', \"Light Left Tortoise Shell Bracket Ornament\", '('),\n-    ('\u3014', \"Left Tortoise Shell Bracket\", '('),\n     ('\ufd3e', \"Ornate Left Parenthesis\", '('),\n-    ('\uff3d', \"Fullwidth Right Square Bracket\", ')'),\n+    ('\uff08', \"Fullwidth Left Parenthesis\", '('),\n     ('\u2769', \"Medium Right Parenthesis Ornament\", ')'),\n-    ('\u2773', \"Light Right Tortoise Shell Bracket Ornament\", ')'),\n-    ('\u3015', \"Right Tortoise Shell Bracket\", ')'),\n     ('\ufd3f', \"Ornate Right Parenthesis\", ')'),\n+    ('\uff09', \"Fullwidth Right Parenthesis\", ')'),\n+    ('\uff3b', \"Fullwidth Left Square Bracket\", '['),\n+    ('\u2772', \"Light Left Tortoise Shell Bracket Ornament\", '['),\n+    ('\u300c', \"Left Corner Bracket\", '['),\n+    ('\u300e', \"Left White Corner Bracket\", '['),\n+    ('\u3010', \"Left Black Lenticular Bracket\", '['),\n+    ('\u3014', \"Left Tortoise Shell Bracket\", '['),\n+    ('\u3016', \"Left White Lenticular Bracket\", '['),\n+    ('\u3018', \"Left White Tortoise Shell Bracket\", '['),\n+    ('\u301a', \"Left White Square Bracket\", '['),\n+    ('\uff3d', \"Fullwidth Right Square Bracket\", ']'),\n+    ('\u2773', \"Light Right Tortoise Shell Bracket Ornament\", ']'),\n+    ('\u300d', \"Right Corner Bracket\", ']'),\n+    ('\u300f', \"Right White Corner Bracket\", ']'),\n+    ('\u3011', \"Right Black Lenticular Bracket\", ']'),\n+    ('\u3015', \"Right Tortoise Shell Bracket\", ']'),\n+    ('\u3017', \"Right White Lenticular Bracket\", ']'),\n+    ('\u3019', \"Right White Tortoise Shell Bracket\", ']'),\n+    ('\u301b', \"Right White Square Bracket\", ']'),\n     ('\u2774', \"Medium Left Curly Bracket Ornament\", '{'),\n     ('\u2775', \"Medium Right Curly Bracket Ornament\", '}'),\n     ('\u204e', \"Low Asterisk\", '*'),\n@@ -140,6 +178,8 @@ const UNICODE_ARRAY: &'static [(char, &'static str, char)] = &[\n     ('\u27cd', \"Mathematical Falling Diagonal\", '\\\\'),\n     ('\u29f5', \"Reverse Solidus Operator\", '\\\\'),\n     ('\u29f9', \"Big Reverse Solidus\", '\\\\'),\n+    ('\u3001', \"Ideographic Comma\", '\\\\'),\n+    ('\u30fd', \"Katakana Iteration Mark\", '\\\\'),\n     ('\u31d4', \"Cjk Stroke D\", '\\\\'),\n     ('\u4e36', \"Cjk Unified Ideograph-4E36\", '\\\\'),\n     ('\u2f02', \"Kangxi Radical Dot\", '\\\\'),\n@@ -148,15 +188,20 @@ const UNICODE_ARRAY: &'static [(char, &'static str, char)] = &[\n     ('\u2039', \"Single Left-Pointing Angle Quotation Mark\", '<'),\n     ('\u276e', \"Heavy Left-Pointing Angle Quotation Mark Ornament\", '<'),\n     ('\u02c2', \"Modifier Letter Left Arrowhead\", '<'),\n+    ('\u3008', \"Left Angle Bracket\", '<'),\n+    ('\u300a', \"Left Double Angle Bracket\", '<'),\n     ('\ua4ff', \"Lisu Punctuation Full Stop\", '='),\n     ('\u203a', \"Single Right-Pointing Angle Quotation Mark\", '>'),\n     ('\u276f', \"Heavy Right-Pointing Angle Quotation Mark Ornament\", '>'),\n     ('\u02c3', \"Modifier Letter Right Arrowhead\", '>'),\n+    ('\u3009', \"Right Angle Bracket\", '>'),\n+    ('\u300b', \"Right Double Angle Bracket\", '>'),\n     ('\u2cba', \"Coptic Capital Letter Dialect-P Ni\", '-'),\n     ('\u0241', \"Latin Capital Letter Glottal Stop\", '?'),\n     ('\u2cc6', \"Coptic Capital Letter Old Coptic Esh\", '/'), ];\n \n const ASCII_ARRAY: &'static [(char, &'static str)] = &[\n+    (' ', \"Space\"),\n     ('_', \"Underscore\"),\n     ('-', \"Minus/Hyphen\"),\n     (',', \"Comma\"),\n@@ -169,6 +214,8 @@ const ASCII_ARRAY: &'static [(char, &'static str)] = &[\n     ('\"', \"Quotation Mark\"),\n     ('(', \"Left Parenthesis\"),\n     (')', \"Right Parenthesis\"),\n+    ('[', \"Left Square Bracket\"),\n+    (']', \"Right Square Bracket\"),\n     ('{', \"Left Curly Brace\"),\n     ('}', \"Right Curly Brace\"),\n     ('*', \"Asterisk\"),"}, {"sha": "9cd2e6ef7d695960b97e2a1ce00caa821e646923", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -4419,11 +4419,7 @@ impl<'a> Parser<'a> {\n                 p.forbid_lifetime()?;\n                 let lo = p.span.lo;\n                 let ident = p.parse_ident()?;\n-                let found_eq = p.eat(&token::Eq);\n-                if !found_eq {\n-                    let span = p.span;\n-                    p.span_warn(span, \"whoops, no =?\");\n-                }\n+                p.expect(&token::Eq)?;\n                 let ty = p.parse_ty()?;\n                 let hi = ty.span.hi;\n                 let span = mk_sp(lo, hi);"}, {"sha": "31e1a72967f4dcf4860574ce6f563503a3d2637d", "filename": "src/test/compile-fail/const-eval-overflow-4b.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -15,7 +15,6 @@\n \n #![allow(unused_imports)]\n \n-use std::fmt;\n use std::{i8, i16, i32, i64, isize};\n use std::{u8, u16, u32, u64, usize};\n \n@@ -26,10 +25,15 @@ const A_I8_T\n     //~| found `u8` [E0250]\n     = [0; (i8::MAX as usize) + 1];\n \n-fn main() {\n-    foo(&A_I8_T[..]);\n-}\n \n-fn foo<T:fmt::Debug>(x: T) {\n-    println!(\"{:?}\", x);\n-}\n+const A_CHAR_USIZE\n+    : [u32; 5u8 as char as usize]\n+    = [0; 5];\n+\n+\n+const A_BAD_CHAR_USIZE\n+    : [u32; 5i8 as char as usize]\n+    //~^ ERROR only `u8` can be cast as `char`, not `i8`\n+    = [0; 5];\n+\n+fn main() {}"}, {"sha": "c54f901199b460c0e62d1dce4881819440e2bf0a", "filename": "src/test/compile-fail/issue-23716.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static foo: i32 = 0;\n+//~^ NOTE static variable defined here\n+\n+fn bar(foo: i32) {}\n+//~^ ERROR static variables cannot be referenced in a pattern, use a `const` instead\n+\n+mod submod {\n+    pub static answer: i32 = 42;\n+    //~^ NOTE static variable defined here\n+}\n+\n+use self::submod::answer;\n+//~^ NOTE static variable imported here\n+\n+fn question(answer: i32) {}\n+//~^ ERROR static variables cannot be referenced in a pattern, use a `const` instead\n+\n+fn main() {\n+}"}, {"sha": "3ba59c8ee946bfc792442a2a94a9f79aa43ab160", "filename": "src/test/parse-fail/issue-32214.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Ftest%2Fparse-fail%2Fissue-32214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Ftest%2Fparse-fail%2Fissue-32214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-32214.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n+\n+pub fn test<W, I: Iterator<Item=(), W> >() {\n+    //~^ ERROR expected `=`, found `>`\n+}\n+\n+fn main() { }"}, {"sha": "30641c1cb87b198e7ec30008843cc6a9720fa66e", "filename": "src/test/run-pass/const-err.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Ftest%2Frun-pass%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Ftest%2Frun-pass%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-err.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check for const_err regressions\n+\n+#![deny(const_err)]\n+\n+\n+fn main() {\n+    let _ = ((-1 as i8) << 8 - 1) as f32;\n+    let _ = 0u8 as char;\n+}"}, {"sha": "7f9a2bf175a5f96c7a23daf497665244f16b055e", "filename": "src/test/rustdoc/escape-rust-expr.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Ftest%2Frustdoc%2Fescape-rust-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Ftest%2Frustdoc%2Fescape-rust-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fescape-rust-expr.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we HTML-escape Rust expressions, where HTML special chars\n+// can occur, and we know it's definitely not markup.\n+\n+// @has escape_rust_expr/constant.CONST_S.html '//pre[@class=\"rust const\"]' '\"<script>\"'\n+pub const CONST_S: &'static str = \"<script>\";"}, {"sha": "b9188e8a4e9bacbb82a7507f72ee12a03a3f9cbf", "filename": "src/test/rustdoc/issue-33302.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Ftest%2Frustdoc%2Fissue-33302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Ftest%2Frustdoc%2Fissue-33302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-33302.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure constant and array length values are not taken from source\n+// code, which wreaks havoc with macros.\n+\n+#![feature(associated_consts)]\n+\n+macro_rules! make {\n+    ($n:expr) => {\n+        pub struct S;\n+\n+        // @has issue_33302/constant.CST.html \\\n+        //        '//pre[@class=\"rust const\"]' 'pub const CST: i32 = 4 * 4'\n+        pub const CST: i32 = ($n * $n);\n+        // @has issue_33302/static.ST.html \\\n+        //        '//pre[@class=\"rust static\"]' 'pub static ST: i32 = 4 * 4'\n+        pub static ST: i32 = ($n * $n);\n+\n+        pub trait T<X> {\n+            fn ignore(_: &X) {}\n+            const C: X;\n+            // @has issue_33302/trait.T.html \\\n+            //        '//*[@class=\"rust trait\"]' 'const D: i32 = 4 * 4;'\n+            // @has - '//*[@id=\"associatedconstant.D\"]' 'const D: i32 = 4 * 4'\n+            const D: i32 = ($n * $n);\n+        }\n+\n+        // @has issue_33302/struct.S.html \\\n+        //        '//h3[@class=\"impl\"]' 'impl T<[i32; 4 * 4]> for S'\n+        // @has - '//*[@id=\"associatedconstant.C\"]' 'const C: [i32; 4 * 4] = [0; 4 * 4]'\n+        // @has - '//*[@id=\"associatedconstant.D\"]' 'const D: i32 = 4 * 4'\n+        impl T<[i32; ($n * $n)]> for S {\n+            const C: [i32; ($n * $n)] = [0; ($n * $n)];\n+        }\n+    }\n+}\n+\n+make!(4);"}, {"sha": "acaec0b5199d13860a1bf2783224ba16221be46d", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/192e336148babf0dc9d83399955e94544305296a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/192e336148babf0dc9d83399955e94544305296a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=192e336148babf0dc9d83399955e94544305296a", "patch": "@@ -2063,6 +2063,11 @@ fn run_incremental_test(config: &Config, props: &TestProps, testpaths: &TestPath\n }\n \n fn run_rmake_test(config: &Config, _props: &TestProps, testpaths: &TestPaths) {\n+    // FIXME(#11094): we should fix these tests\n+    if config.host != config.target {\n+        return\n+    }\n+\n     let cwd = env::current_dir().unwrap();\n     let src_root = config.src_base.parent().unwrap().parent().unwrap()\n                                   .parent().unwrap();"}]}