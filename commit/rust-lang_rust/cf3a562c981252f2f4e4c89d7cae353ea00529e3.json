{"sha": "cf3a562c981252f2f4e4c89d7cae353ea00529e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmM2E1NjJjOTgxMjUyZjJmNGU0Yzg5ZDdjYWUzNTNlYTAwNTI5ZTM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-17T04:19:44Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-17T05:32:29Z"}, "message": "Remove `NodeIndex`.\n\nThe size of the indices doesn't matter much here, and having a\n`newtype_index!` index type without also using `IndexVec` requires lots\nof conversions. So this commit removes `NodeIndex` in favour of uniform\nuse of `usize` as the index type. As well as making the code slightly\nmore concise, it also slightly speeds things up.", "tree": {"sha": "a4e5874edca54d2b3c26cb6e0da36a6c4341cbb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4e5874edca54d2b3c26cb6e0da36a6c4341cbb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf3a562c981252f2f4e4c89d7cae353ea00529e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf3a562c981252f2f4e4c89d7cae353ea00529e3", "html_url": "https://github.com/rust-lang/rust/commit/cf3a562c981252f2f4e4c89d7cae353ea00529e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf3a562c981252f2f4e4c89d7cae353ea00529e3/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "476e75ded71ad6f573daabe2ca7a1be9fe3ce3cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/476e75ded71ad6f573daabe2ca7a1be9fe3ce3cb", "html_url": "https://github.com/rust-lang/rust/commit/476e75ded71ad6f573daabe2ca7a1be9fe3ce3cb"}], "stats": {"total": 63, "additions": 27, "deletions": 36}, "files": [{"sha": "ddf89d99621cabccc5be65cef79e1d048888bd70", "filename": "src/librustc_data_structures/obligation_forest/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf3a562c981252f2f4e4c89d7cae353ea00529e3/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3a562c981252f2f4e4c89d7cae353ea00529e3/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs?ref=cf3a562c981252f2f4e4c89d7cae353ea00529e3", "patch": "@@ -74,7 +74,7 @@ impl<'a, O: ForestObligation + 'a> dot::GraphWalk<'a> for &'a ObligationForest<O\n             .flat_map(|i| {\n                 let node = &self.nodes[i];\n \n-                node.dependents.iter().map(move |p| (p.index(), i))\n+                node.dependents.iter().map(move |&d| (d, i))\n             })\n             .collect()\n     }"}, {"sha": "afec7a24b1785a289be0cce9e99d764fd75d73e4", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cf3a562c981252f2f4e4c89d7cae353ea00529e3/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf3a562c981252f2f4e4c89d7cae353ea00529e3/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=cf3a562c981252f2f4e4c89d7cae353ea00529e3", "patch": "@@ -73,8 +73,6 @@\n //! aren't needed anymore.\n \n use crate::fx::{FxHashMap, FxHashSet};\n-use crate::indexed_vec::Idx;\n-use crate::newtype_index;\n \n use std::cell::{Cell, RefCell};\n use std::collections::hash_map::Entry;\n@@ -87,10 +85,6 @@ mod graphviz;\n #[cfg(test)]\n mod tests;\n \n-newtype_index! {\n-    pub struct NodeIndex { .. }\n-}\n-\n pub trait ForestObligation : Clone + Debug {\n     type Predicate : Clone + hash::Hash + Eq + Debug;\n \n@@ -143,9 +137,10 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// At the end of processing, those nodes will be removed by a\n     /// call to `compress`.\n     ///\n-    /// Ideally, this would be an `IndexVec<NodeIndex, Node<O>>`. But that is\n-    /// slower, because this vector is accessed so often that the\n-    /// `u32`-to-`usize` conversions required for accesses are significant.\n+    /// `usize` indices are used here and throughout this module, rather than\n+    /// `newtype_index!` indices, because this code is hot enough that the\n+    /// `u32`-to-`usize` conversions that would be required are significant,\n+    /// and space considerations are not important.\n     nodes: Vec<Node<O>>,\n \n     /// A cache of predicates that have been successfully completed.\n@@ -154,7 +149,7 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// A cache of the nodes in `nodes`, indexed by predicate. Unfortunately,\n     /// its contents are not guaranteed to match those of `nodes`. See the\n     /// comments in `process_obligation` for details.\n-    waiting_cache: FxHashMap<O::Predicate, NodeIndex>,\n+    waiting_cache: FxHashMap<O::Predicate, usize>,\n \n     /// A scratch vector reused in various operations, to avoid allocating new\n     /// vectors.\n@@ -179,12 +174,12 @@ struct Node<O> {\n \n     /// Obligations that depend on this obligation for their completion. They\n     /// must all be in a non-pending state.\n-    dependents: Vec<NodeIndex>,\n+    dependents: Vec<usize>,\n \n     /// If true, dependents[0] points to a \"parent\" node, which requires\n     /// special treatment upon error but is otherwise treated the same.\n     /// (It would be more idiomatic to store the parent node in a separate\n-    /// `Option<NodeIndex>` field, but that slows down the common case of\n+    /// `Option<usize>` field, but that slows down the common case of\n     /// iterating over the parent and other descendants together.)\n     has_parent: bool,\n \n@@ -194,7 +189,7 @@ struct Node<O> {\n \n impl<O> Node<O> {\n     fn new(\n-        parent: Option<NodeIndex>,\n+        parent: Option<usize>,\n         obligation: O,\n         obligation_tree_id: ObligationTreeId\n     ) -> Node<O> {\n@@ -303,9 +298,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n     }\n \n     // Returns Err(()) if we already know this obligation failed.\n-    fn register_obligation_at(&mut self, obligation: O, parent: Option<NodeIndex>)\n-                              -> Result<(), ()>\n-    {\n+    fn register_obligation_at(&mut self, obligation: O, parent: Option<usize>) -> Result<(), ()> {\n         if self.done_cache.contains(obligation.as_predicate()) {\n             return Ok(());\n         }\n@@ -314,7 +307,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             Entry::Occupied(o) => {\n                 debug!(\"register_obligation_at({:?}, {:?}) - duplicate of {:?}!\",\n                        obligation, parent, o.get());\n-                let node = &mut self.nodes[o.get().index()];\n+                let node = &mut self.nodes[*o.get()];\n                 if let Some(parent_index) = parent {\n                     // If the node is already in `waiting_cache`, it has\n                     // already had its chance to be marked with a parent. So if\n@@ -335,10 +328,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n                        obligation, parent, self.nodes.len());\n \n                 let obligation_tree_id = match parent {\n-                    Some(parent_index) => {\n-                        self.nodes[parent_index.index()].obligation_tree_id\n-                    }\n-                    None => self.obligation_tree_id_generator.next().unwrap()\n+                    Some(parent_index) => self.nodes[parent_index].obligation_tree_id,\n+                    None => self.obligation_tree_id_generator.next().unwrap(),\n                 };\n \n                 let already_failed =\n@@ -351,7 +342,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 if already_failed {\n                     Err(())\n                 } else {\n-                    v.insert(NodeIndex::new(self.nodes.len()));\n+                    v.insert(self.nodes.len());\n                     self.nodes.push(Node::new(parent, obligation, obligation_tree_id));\n                     Ok(())\n                 }\n@@ -437,7 +428,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     for child in children {\n                         let st = self.register_obligation_at(\n                             child,\n-                            Some(NodeIndex::new(i))\n+                            Some(i)\n                         );\n                         if let Err(()) = st {\n                             // Error already reported - propagate it\n@@ -522,8 +513,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n             NodeState::Success => {\n                 node.state.set(NodeState::OnDfsStack);\n                 stack.push(i);\n-                for index in node.dependents.iter() {\n-                    self.find_cycles_from_node(stack, processor, index.index());\n+                for &index in node.dependents.iter() {\n+                    self.find_cycles_from_node(stack, processor, index);\n                 }\n                 stack.pop();\n                 node.state.set(NodeState::Done);\n@@ -551,11 +542,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n             if node.has_parent {\n                 // The first dependent is the parent, which is treated\n                 // specially.\n-                error_stack.extend(node.dependents.iter().skip(1).map(|index| index.index()));\n-                i = node.dependents[0].index();\n+                error_stack.extend(node.dependents.iter().skip(1));\n+                i = node.dependents[0];\n             } else {\n                 // No parent; treat all dependents non-specially.\n-                error_stack.extend(node.dependents.iter().map(|index| index.index()));\n+                error_stack.extend(node.dependents.iter());\n                 break;\n             }\n         }\n@@ -567,7 +558,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 _ => node.state.set(NodeState::Error),\n             }\n \n-            error_stack.extend(node.dependents.iter().map(|index| index.index()));\n+            error_stack.extend(node.dependents.iter());\n         }\n \n         self.scratch.replace(error_stack);\n@@ -577,8 +568,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n     // This always-inlined function is for the hot call site.\n     #[inline(always)]\n     fn inlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n-        for dependent in node.dependents.iter() {\n-            self.mark_as_waiting_from(&self.nodes[dependent.index()]);\n+        for &dependent in node.dependents.iter() {\n+            self.mark_as_waiting_from(&self.nodes[dependent]);\n         }\n     }\n \n@@ -708,15 +699,15 @@ impl<O: ForestObligation> ObligationForest<O> {\n         for node in &mut self.nodes {\n             let mut i = 0;\n             while i < node.dependents.len() {\n-                let new_i = node_rewrites[node.dependents[i].index()];\n+                let new_i = node_rewrites[node.dependents[i]];\n                 if new_i >= nodes_len {\n                     node.dependents.swap_remove(i);\n                     if i == 0 && node.has_parent {\n                         // We just removed the parent.\n                         node.has_parent = false;\n                     }\n                 } else {\n-                    node.dependents[i] = NodeIndex::new(new_i);\n+                    node.dependents[i] = new_i;\n                     i += 1;\n                 }\n             }\n@@ -725,11 +716,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n         // This updating of `self.waiting_cache` is necessary because the\n         // removal of nodes within `compress` can fail. See above.\n         self.waiting_cache.retain(|_predicate, index| {\n-            let new_i = node_rewrites[index.index()];\n+            let new_i = node_rewrites[*index];\n             if new_i >= nodes_len {\n                 false\n             } else {\n-                *index = NodeIndex::new(new_i);\n+                *index = new_i;\n                 true\n             }\n         });"}]}