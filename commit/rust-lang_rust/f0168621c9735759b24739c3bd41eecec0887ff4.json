{"sha": "f0168621c9735759b24739c3bd41eecec0887ff4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMTY4NjIxYzk3MzU3NTliMjQ3MzljM2JkNDFlZWNlYzA4ODdmZjQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-12-20T10:07:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-12-20T10:07:31Z"}, "message": "Merge pull request #2281 from detrumi/match-as-ref\n\nLint for matching option as ref", "tree": {"sha": "16ba940ccd6cfe92d332b241a234cd06dbf002be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16ba940ccd6cfe92d332b241a234cd06dbf002be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0168621c9735759b24739c3bd41eecec0887ff4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaOjZjCRBK7hj4Ov3rIwAAdHIIAD1N56uwbBNCas6Rdgjv4H5m\nM2r2KcRO4x7ICXlgKbzQeWRtirA6eqbSLWCSnUcfJUwWZg5uPdK/ntXs3/vkoR4W\n9a5A41KKu00N7p9WLa8jOCYai21LKEfAJHdDroMMCQmK3cbAas5V35mWNwQj9uHv\nLlGCdakMug9RwdNk4SSw/0cAHjmrTGKIpOMS5AdtUX87pykcZ9p2NSB+2Fg3S2he\nbqCznp01wn8XWCUPHfbZR67Hq+XM341DpU9GKZpjZzhfpI3woKp6t383qZDqxoN5\nD4qhDJDJXj8XOhQO7IR72HTiZOyhfwe56sQzypdu5zvwF4NzsKPeHWT8OQbHVaY=\n=xTs8\n-----END PGP SIGNATURE-----\n", "payload": "tree 16ba940ccd6cfe92d332b241a234cd06dbf002be\nparent cf58e1c6729b969507c0027d6107e2a6e157932f\nparent a6ccc6fe3d67f4802d58a9a76a4f1d308a8a96f3\nauthor Oliver Schneider <oli-obk@users.noreply.github.com> 1513764451 +0100\ncommitter GitHub <noreply@github.com> 1513764451 +0100\n\nMerge pull request #2281 from detrumi/match-as-ref\n\nLint for matching option as ref"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0168621c9735759b24739c3bd41eecec0887ff4", "html_url": "https://github.com/rust-lang/rust/commit/f0168621c9735759b24739c3bd41eecec0887ff4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0168621c9735759b24739c3bd41eecec0887ff4/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf58e1c6729b969507c0027d6107e2a6e157932f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf58e1c6729b969507c0027d6107e2a6e157932f", "html_url": "https://github.com/rust-lang/rust/commit/cf58e1c6729b969507c0027d6107e2a6e157932f"}, {"sha": "a6ccc6fe3d67f4802d58a9a76a4f1d308a8a96f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6ccc6fe3d67f4802d58a9a76a4f1d308a8a96f3", "html_url": "https://github.com/rust-lang/rust/commit/a6ccc6fe3d67f4802d58a9a76a4f1d308a8a96f3"}], "stats": {"total": 120, "additions": 117, "deletions": 3}, "files": [{"sha": "9b598df4fa62dd78acfbbb4a1e15fd6f36006534", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0168621c9735759b24739c3bd41eecec0887ff4/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0168621c9735759b24739c3bd41eecec0887ff4/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f0168621c9735759b24739c3bd41eecec0887ff4", "patch": "@@ -499,6 +499,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         loops::WHILE_LET_LOOP,\n         loops::WHILE_LET_ON_ITERATOR,\n         map_clone::MAP_CLONE,\n+        matches::MATCH_AS_REF,\n         matches::MATCH_BOOL,\n         matches::MATCH_OVERLAPPING_ARM,\n         matches::MATCH_REF_PATS,"}, {"sha": "2183c6e4fa675e701bacbd9d9fabe5bc705bb013", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 79, "deletions": 3, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f0168621c9735759b24739c3bd41eecec0887ff4/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0168621c9735759b24739c3bd41eecec0887ff4/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=f0168621c9735759b24739c3bd41eecec0887ff4", "patch": "@@ -11,8 +11,8 @@ use syntax::ast::LitKind;\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use utils::paths;\n-use utils::{expr_block, in_external_macro, is_allowed, is_expn_of, match_type, remove_blocks, snippet,\n-            span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty};\n+use utils::{expr_block, in_external_macro, is_allowed, is_expn_of, match_qpath, match_type, remove_blocks,\n+            snippet, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty};\n use utils::sugg::Sugg;\n \n /// **What it does:** Checks for matches with a single arm where an `if let`\n@@ -145,6 +145,27 @@ declare_lint! {\n     \"a match with `Err(_)` arm and take drastic actions\"\n }\n \n+/// **What it does:** Checks for match which is used to add a reference to an\n+/// `Option` value.\n+///\n+/// **Why is this bad?** Using `as_ref()` or `as_mut()` instead is shorter.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// let x: Option<()> = None;\n+/// let r: Option<&()> = match x {\n+///   None => None,\n+///   Some(ref v) => Some(v),\n+/// };\n+/// ```\n+declare_lint! {\n+    pub MATCH_AS_REF,\n+    Warn,\n+    \"a match on an Option value instead of using `as_ref()` or `as_mut`\"\n+}\n+\n #[allow(missing_copy_implementations)]\n pub struct MatchPass;\n \n@@ -156,7 +177,8 @@ impl LintPass for MatchPass {\n             MATCH_BOOL,\n             SINGLE_MATCH_ELSE,\n             MATCH_OVERLAPPING_ARM,\n-            MATCH_WILD_ERR_ARM\n+            MATCH_WILD_ERR_ARM,\n+            MATCH_AS_REF\n         )\n     }\n }\n@@ -171,6 +193,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MatchPass {\n             check_match_bool(cx, ex, arms, expr);\n             check_overlapping_arms(cx, ex, arms);\n             check_wild_err_arm(cx, ex, arms);\n+            check_match_as_ref(cx, ex, arms, expr);\n         }\n         if let ExprMatch(ref ex, ref arms, source) = expr.node {\n             check_match_ref_pats(cx, ex, arms, source, expr);\n@@ -411,6 +434,31 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: Match\n     }\n }\n \n+fn check_match_as_ref(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+    if arms.len() == 2 &&\n+        arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+        arms[1].pats.len() == 1 && arms[1].guard.is_none() {\n+        let arm_ref: Option<BindingAnnotation> = if is_none_arm(&arms[0]) {\n+            is_ref_some_arm(&arms[1])\n+        } else if is_none_arm(&arms[1]) {\n+            is_ref_some_arm(&arms[0])\n+        } else {\n+            None\n+        };\n+        if let Some(rb) = arm_ref {\n+            let suggestion = if rb == BindingAnnotation::Ref { \"as_ref\" } else { \"as_mut\" };\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_AS_REF,\n+                expr.span,\n+                &format!(\"use {}() instead\", suggestion),\n+                \"try this\",\n+                format!(\"{}.{}()\", snippet(cx, ex.span, \"_\"), suggestion)\n+            )\n+        }\n+    }\n+}\n+\n /// Get all arms that are unbounded `PatRange`s.\n fn all_ranges<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n@@ -524,6 +572,34 @@ fn is_unit_expr(expr: &Expr) -> bool {\n     }\n }\n \n+// Checks if arm has the form `None => None`\n+fn is_none_arm(arm: &Arm) -> bool {\n+    match arm.pats[0].node {\n+        PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => true,\n+        _ => false,\n+    }\n+}\n+\n+// Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n+fn is_ref_some_arm(arm: &Arm) -> Option<BindingAnnotation> {\n+    if_chain! {\n+        if let PatKind::TupleStruct(ref path, ref pats, _) = arm.pats[0].node;\n+        if pats.len() == 1 && match_qpath(path, &paths::OPTION_SOME);\n+        if let PatKind::Binding(rb, _, ref ident, _) = pats[0].node;\n+        if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n+        if let ExprCall(ref e, ref args) = remove_blocks(&arm.body).node;\n+        if let ExprPath(ref some_path) = e.node;\n+        if match_qpath(some_path, &paths::OPTION_SOME) && args.len() == 1;\n+        if let ExprPath(ref qpath) = args[0].node;\n+        if let &QPath::Resolved(_, ref path2) = qpath;\n+        if path2.segments.len() == 1 && ident.node == path2.segments[0].name;\n+        then {\n+            return Some(rb)\n+        }\n+    }\n+    None\n+}\n+\n fn has_only_ref_pats(arms: &[Arm]) -> bool {\n     let mapped = arms.iter()\n         .flat_map(|a| &a.pats)"}, {"sha": "67a901f65b28ddce6ee6bd42f0145975981f7db6", "filename": "tests/ui/matches.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f0168621c9735759b24739c3bd41eecec0887ff4/tests%2Fui%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0168621c9735759b24739c3bd41eecec0887ff4/tests%2Fui%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatches.rs?ref=f0168621c9735759b24739c3bd41eecec0887ff4", "patch": "@@ -315,5 +315,20 @@ fn match_wild_err_arm() {\n     }\n }\n \n+fn match_as_ref() {\n+    let owned: Option<()> = None;\n+    let borrowed: Option<&()> = match owned {\n+        None => None,\n+        Some(ref v) => Some(v),\n+    };\n+\n+    let mut mut_owned: Option<()> = None;\n+    let borrow_mut: Option<&mut ()> = match mut_owned {\n+        None => None,\n+        Some(ref mut v) => Some(v),\n+    };\n+\n+}\n+\n fn main() {\n }"}, {"sha": "62c77c778bebef1749c701febd67d9fe55822525", "filename": "tests/ui/matches.stderr", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f0168621c9735759b24739c3bd41eecec0887ff4/tests%2Fui%2Fmatches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0168621c9735759b24739c3bd41eecec0887ff4/tests%2Fui%2Fmatches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatches.stderr?ref=f0168621c9735759b24739c3bd41eecec0887ff4", "patch": "@@ -426,3 +426,25 @@ note: consider refactoring into `Ok(3) | Ok(_)`\n     |                  ^^^^^^^^^^^^^^\n     = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n+error: use as_ref() instead\n+   --> $DIR/matches.rs:320:33\n+    |\n+320 |       let borrowed: Option<&()> = match owned {\n+    |  _________________________________^\n+321 | |         None => None,\n+322 | |         Some(ref v) => Some(v),\n+323 | |     };\n+    | |_____^ help: try this: `owned.as_ref()`\n+    |\n+    = note: `-D match-as-ref` implied by `-D warnings`\n+\n+error: use as_mut() instead\n+   --> $DIR/matches.rs:326:39\n+    |\n+326 |       let borrow_mut: Option<&mut ()> = match mut_owned {\n+    |  _______________________________________^\n+327 | |         None => None,\n+328 | |         Some(ref mut v) => Some(v),\n+329 | |     };\n+    | |_____^ help: try this: `mut_owned.as_mut()`\n+"}]}