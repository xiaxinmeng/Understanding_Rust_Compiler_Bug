{"sha": "389333a21c6a0ed51952c6d5d0b339e7d274ef2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4OTMzM2EyMWM2YTBlZDUxOTUyYzZkNWQwYjMzOWU3ZDI3NGVmMmU=", "commit": {"author": {"name": "Julian Frimmel", "email": "julian.frimmel@gmail.com", "date": "2021-03-27T10:44:39Z"}, "committer": {"name": "Julian Frimmel", "email": "julian.frimmel@gmail.com", "date": "2021-05-03T21:14:17Z"}, "message": "Update `ptr` docs with regards to `ptr::addr_of!`\n\nThis updates the documentation since `ptr::addr_of!` and\n`ptr::addr_of_mut!` are now stable. One might remove the distinction\nbetween the sections `# On packed structs` and `# Examples`, as the old\nsection on packed structs was primarily to prevent users of doing unde-\nfined behavior, which is not necessary anymore.\nThere is also a new section in \"how to obtain a pointer\", which referen-\nces the `ptr::addr_of!` macros.\n\nThis commit contains squashed commits from code review.\n\nCo-authored-by: Joshua Nelson <joshua@yottadb.com>\nCo-authored-by: Mara Bos <m-ou.se@m-ou.se>\nCo-authored-by: Soveu <marx.tomasz@gmail.com>\nCo-authored-by: Ralf Jung <post@ralfj.de>", "tree": {"sha": "e96871296ffb9db43ad5e93d9776ae824e5e3c4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e96871296ffb9db43ad5e93d9776ae824e5e3c4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/389333a21c6a0ed51952c6d5d0b339e7d274ef2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/389333a21c6a0ed51952c6d5d0b339e7d274ef2e", "html_url": "https://github.com/rust-lang/rust/commit/389333a21c6a0ed51952c6d5d0b339e7d274ef2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/389333a21c6a0ed51952c6d5d0b339e7d274ef2e/comments", "author": {"login": "jfrimmel", "id": 31166235, "node_id": "MDQ6VXNlcjMxMTY2MjM1", "avatar_url": "https://avatars.githubusercontent.com/u/31166235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jfrimmel", "html_url": "https://github.com/jfrimmel", "followers_url": "https://api.github.com/users/jfrimmel/followers", "following_url": "https://api.github.com/users/jfrimmel/following{/other_user}", "gists_url": "https://api.github.com/users/jfrimmel/gists{/gist_id}", "starred_url": "https://api.github.com/users/jfrimmel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jfrimmel/subscriptions", "organizations_url": "https://api.github.com/users/jfrimmel/orgs", "repos_url": "https://api.github.com/users/jfrimmel/repos", "events_url": "https://api.github.com/users/jfrimmel/events{/privacy}", "received_events_url": "https://api.github.com/users/jfrimmel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jfrimmel", "id": 31166235, "node_id": "MDQ6VXNlcjMxMTY2MjM1", "avatar_url": "https://avatars.githubusercontent.com/u/31166235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jfrimmel", "html_url": "https://github.com/jfrimmel", "followers_url": "https://api.github.com/users/jfrimmel/followers", "following_url": "https://api.github.com/users/jfrimmel/following{/other_user}", "gists_url": "https://api.github.com/users/jfrimmel/gists{/gist_id}", "starred_url": "https://api.github.com/users/jfrimmel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jfrimmel/subscriptions", "organizations_url": "https://api.github.com/users/jfrimmel/orgs", "repos_url": "https://api.github.com/users/jfrimmel/repos", "events_url": "https://api.github.com/users/jfrimmel/events{/privacy}", "received_events_url": "https://api.github.com/users/jfrimmel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5208f63ba8ec70a2a7a074d7ecd59a94693286fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/5208f63ba8ec70a2a7a074d7ecd59a94693286fc", "html_url": "https://github.com/rust-lang/rust/commit/5208f63ba8ec70a2a7a074d7ecd59a94693286fc"}], "stats": {"total": 83, "additions": 44, "deletions": 39}, "files": [{"sha": "66d3626fe5d748afc8a028a57d7db9cc110bb707", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 23, "deletions": 38, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/389333a21c6a0ed51952c6d5d0b339e7d274ef2e/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/389333a21c6a0ed51952c6d5d0b339e7d274ef2e/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=389333a21c6a0ed51952c6d5d0b339e7d274ef2e", "patch": "@@ -742,9 +742,6 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n ///\n /// ## On `packed` structs\n ///\n-/// It is currently impossible to create raw pointers to unaligned fields\n-/// of a packed struct.\n-///\n /// Attempting to create a raw pointer to an `unaligned` struct field with\n /// an expression such as `&packed.unaligned as *const FieldType` creates an\n /// intermediate unaligned reference before converting that to a raw pointer.\n@@ -753,9 +750,13 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n /// As a result, using `&packed.unaligned as *const FieldType` causes immediate\n /// *undefined behavior* in your program.\n ///\n+/// Instead you must use the [`ptr::addr_of!`](addr_of) macro to\n+/// create the pointer. You may use that returned pointer together with this\n+/// function.\n+///\n /// An example of what not to do and how this relates to `read_unaligned` is:\n ///\n-/// ```no_run\n+/// ```\n /// #[repr(packed, C)]\n /// struct Packed {\n ///     _padding: u8,\n@@ -767,24 +768,15 @@ pub const unsafe fn read<T>(src: *const T) -> T {\n ///     unaligned: 0x01020304,\n /// };\n ///\n-/// #[allow(unaligned_references)]\n-/// let v = unsafe {\n-///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n-///     let unaligned =\n-///         // A temporary unaligned reference is created here which results in\n-///         // undefined behavior regardless of whether the reference is used or not.\n-///         &packed.unaligned\n-///         // Casting to a raw pointer doesn't help; the mistake already happened.\n-///         as *const u32;\n+/// // Take the address of a 32-bit integer which is not aligned.\n+/// // In contrast to `&packed.unaligned as *const _`, this has no undefined behavior.\n+/// let unaligned = std::ptr::addr_of!(packed.unaligned);\n ///\n-///     let v = std::ptr::read_unaligned(unaligned);\n-///\n-///     v\n-/// };\n+/// let v = unsafe { std::ptr::read_unaligned(unaligned) };\n+/// assert_eq!(v, 0x01020304);\n /// ```\n ///\n /// Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however.\n-// FIXME: Update docs based on outcome of RFC #2582 and friends.\n ///\n /// # Examples\n ///\n@@ -938,9 +930,6 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n ///\n /// ## On `packed` structs\n ///\n-/// It is currently impossible to create raw pointers to unaligned fields\n-/// of a packed struct.\n-///\n /// Attempting to create a raw pointer to an `unaligned` struct field with\n /// an expression such as `&packed.unaligned as *const FieldType` creates an\n /// intermediate unaligned reference before converting that to a raw pointer.\n@@ -949,36 +938,32 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n /// As a result, using `&packed.unaligned as *const FieldType` causes immediate\n /// *undefined behavior* in your program.\n ///\n-/// An example of what not to do and how this relates to `write_unaligned` is:\n+/// Instead you must use the [`ptr::addr_of_mut!`](addr_of_mut)\n+/// macro to create the pointer. You may use that returned pointer together with\n+/// this function.\n+///\n+/// An example of how to do it and how this relates to `write_unaligned` is:\n ///\n-/// ```no_run\n+/// ```\n /// #[repr(packed, C)]\n /// struct Packed {\n ///     _padding: u8,\n ///     unaligned: u32,\n /// }\n ///\n-/// let v = 0x01020304;\n /// let mut packed: Packed = unsafe { std::mem::zeroed() };\n ///\n-/// #[allow(unaligned_references)]\n-/// let v = unsafe {\n-///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n-///     let unaligned =\n-///         // A temporary unaligned reference is created here which results in\n-///         // undefined behavior regardless of whether the reference is used or not.\n-///         &mut packed.unaligned\n-///         // Casting to a raw pointer doesn't help; the mistake already happened.\n-///         as *mut u32;\n+/// // Take the address of a 32-bit integer which is not aligned.\n+/// // In contrast to `&packed.unaligned as *mut _`, this has no undefined behavior.\n+/// let unaligned = std::ptr::addr_of_mut!(packed.unaligned);\n ///\n-///     std::ptr::write_unaligned(unaligned, v);\n+/// unsafe { std::ptr::write_unaligned(unaligned, 42) };\n ///\n-///     v\n-/// };\n+/// assert_eq!({packed.unaligned}, 42); // `{...}` forces copying the field instead of creating a reference.\n /// ```\n ///\n-/// Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however.\n-// FIXME: Update docs based on outcome of RFC #2582 and friends.\n+/// Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however\n+/// (as can be seen in the `assert_eq!` above).\n ///\n /// # Examples\n ///"}, {"sha": "a37c92e92fe4260bc0455d426c44354ee3316ab7", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/389333a21c6a0ed51952c6d5d0b339e7d274ef2e/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/389333a21c6a0ed51952c6d5d0b339e7d274ef2e/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=389333a21c6a0ed51952c6d5d0b339e7d274ef2e", "patch": "@@ -445,7 +445,27 @@ mod prim_unit {}\n /// Note that here the call to [`drop`] is for clarity - it indicates\n /// that we are done with the given value and it should be destroyed.\n ///\n-/// ## 3. Get it from C.\n+/// ## 3. Create it using `ptr::addr_of!`\n+///\n+/// Instead of coercing a reference to a raw pointer, you can use the macros\n+/// [`ptr::addr_of!`] (for `*const T`) and [`ptr::addr_of_mut!`] (for `*mut T`).\n+/// These macros allow you to create raw pointers to fields to which you cannot\n+/// create a reference (without causing undefined behaviour), such as an\n+/// unaligned field. This might be necessary if packed structs or uninitialized\n+/// memory is involved.\n+///\n+/// ```\n+/// #[derive(Debug, Default, Copy, Clone)]\n+/// #[repr(C, packed)]\n+/// struct S {\n+///     aligned: u8,\n+///     unaligned: u32,\n+/// }\n+/// let s = S::default();\n+/// let p = std::ptr::addr_of!(s.unaligned); // not allowed with coercion\n+/// ```\n+///\n+/// ## 4. Get it from C.\n ///\n /// ```\n /// # #![feature(rustc_private)]"}]}