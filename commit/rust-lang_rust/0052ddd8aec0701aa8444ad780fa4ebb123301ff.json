{"sha": "0052ddd8aec0701aa8444ad780fa4ebb123301ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNTJkZGQ4YWVjMDcwMWFhODQ0NGFkNzgwZmE0ZWJiMTIzMzAxZmY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-02T14:40:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-12T04:38:40Z"}, "message": "introduce a generic SCC computation", "tree": {"sha": "7e3b6d838c62b274c32b952afe5d9e6ac847b5d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e3b6d838c62b274c32b952afe5d9e6ac847b5d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0052ddd8aec0701aa8444ad780fa4ebb123301ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0052ddd8aec0701aa8444ad780fa4ebb123301ff", "html_url": "https://github.com/rust-lang/rust/commit/0052ddd8aec0701aa8444ad780fa4ebb123301ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0052ddd8aec0701aa8444ad780fa4ebb123301ff/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dab206f8b57bba507436e23e0e80a6d1ed80bfc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/dab206f8b57bba507436e23e0e80a6d1ed80bfc4", "html_url": "https://github.com/rust-lang/rust/commit/dab206f8b57bba507436e23e0e80a6d1ed80bfc4"}], "stats": {"total": 534, "additions": 531, "deletions": 3}, "files": [{"sha": "3814827b5df6edbdec8892723eb5aa57a36d143e", "filename": "src/librustc_data_structures/graph/implementation/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0052ddd8aec0701aa8444ad780fa4ebb123301ff/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0052ddd8aec0701aa8444ad780fa4ebb123301ff/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Ftests.rs?ref=0052ddd8aec0701aa8444ad780fa4ebb123301ff", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use graph::*;\n+use graph::implementation::*;\n use std::fmt::Debug;\n \n type TestGraph = Graph<&'static str, &'static str>;"}, {"sha": "7265e4e8c7c66090ebb1600577c965355d1866cc", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0052ddd8aec0701aa8444ad780fa4ebb123301ff/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0052ddd8aec0701aa8444ad780fa4ebb123301ff/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=0052ddd8aec0701aa8444ad780fa4ebb123301ff", "patch": "@@ -14,6 +14,7 @@ pub mod dominators;\n pub mod implementation;\n pub mod iterate;\n mod reference;\n+pub mod scc;\n \n #[cfg(test)]\n mod test;"}, {"sha": "b0f098b3d204fd4ac90058dab8c320e41e25e838", "filename": "src/librustc_data_structures/graph/scc/mod.rs", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/0052ddd8aec0701aa8444ad780fa4ebb123301ff/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0052ddd8aec0701aa8444ad780fa4ebb123301ff/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs?ref=0052ddd8aec0701aa8444ad780fa4ebb123301ff", "patch": "@@ -0,0 +1,341 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Routine to compute the strongly connected components (SCCs) of a\n+//! graph, as well as the resulting DAG if each SCC is replaced with a\n+//! node in the graph. This uses Tarjan's algorithm that completes in\n+//! O(n) time.\n+\n+use fx::FxHashSet;\n+use graph::{DirectedGraph, WithNumNodes, WithSuccessors};\n+use indexed_vec::{Idx, IndexVec};\n+use std::ops::Range;\n+\n+mod test;\n+\n+/// Strongly connected components (SCC) of a graph. The type `N` is\n+/// the index type for the graph nodes and `S` is the index type for\n+/// the SCCs. We can map from each node to the SCC that it\n+/// participates in, and we also have the successors of each SCC.\n+pub struct Sccs<N: Idx, S: Idx> {\n+    /// For each node, what is the SCC index of the SCC to which it\n+    /// belongs.\n+    scc_indices: IndexVec<N, S>,\n+\n+    /// Data about each SCC.\n+    scc_data: SccData<S>,\n+}\n+\n+struct SccData<S: Idx> {\n+    /// For each SCC, the range of `all_successors` where its\n+    /// successors can be found.\n+    ranges: IndexVec<S, Range<usize>>,\n+\n+    /// Contains the succcessors for all the Sccs, concatenated. The\n+    /// range of indices corresponding to a given SCC is found in its\n+    /// SccData.\n+    all_successors: Vec<S>,\n+}\n+\n+impl<N: Idx, S: Idx> Sccs<N, S> {\n+    pub fn new(graph: &(impl DirectedGraph<Node = N> + WithNumNodes + WithSuccessors)) -> Self {\n+        SccsConstruction::construct(graph)\n+    }\n+\n+    /// Returns the number of SCCs in the graph.\n+    pub fn num_sccs(&self) -> usize {\n+        self.scc_data.len()\n+    }\n+\n+    /// Returns the SCC to which a node `r` belongs.\n+    pub fn scc(&self, r: N) -> S {\n+        self.scc_indices[r]\n+    }\n+\n+    /// Returns the successor of the given SCC.\n+    pub fn successors(&self, scc: S) -> &[S] {\n+        self.scc_data.successors(scc)\n+    }\n+}\n+\n+impl<S: Idx> SccData<S> {\n+    /// Number of SCCs,\n+    fn len(&self) -> usize {\n+        self.ranges.len()\n+    }\n+\n+    /// Returns the successor of the given SCC.\n+    fn successors(&self, scc: S) -> &[S] {\n+        // Annoyingly, `range` does not implement `Copy`, so we have\n+        // to do `range.start..range.end`:\n+        let range = &self.ranges[scc];\n+        &self.all_successors[range.start..range.end]\n+    }\n+\n+    /// Creates a new SCC with `successors` as its successors and\n+    /// returns the resulting index.\n+    fn create_scc(&mut self, successors: impl IntoIterator<Item = S>) -> S {\n+        // Store the successors on `scc_successors_vec`, remembering\n+        // the range of indices.\n+        let all_successors_start = self.all_successors.len();\n+        self.all_successors.extend(successors);\n+        let all_successors_end = self.all_successors.len();\n+\n+        debug!(\n+            \"create_scc({:?}) successors={:?}\",\n+            self.ranges.len(),\n+            &self.all_successors[all_successors_start..all_successors_end],\n+        );\n+\n+        self.ranges.push(all_successors_start..all_successors_end)\n+    }\n+}\n+\n+struct SccsConstruction<'c, G: DirectedGraph + WithNumNodes + WithSuccessors + 'c, S: Idx> {\n+    graph: &'c G,\n+\n+    /// The state of each node; used during walk to record the stack\n+    /// and after walk to record what cycle each node ended up being\n+    /// in.\n+    node_states: IndexVec<G::Node, NodeState<G::Node, S>>,\n+\n+    /// The stack of nodes that we are visiting as part of the DFS.\n+    node_stack: Vec<G::Node>,\n+\n+    /// The stack of successors: as we visit a node, we mark our\n+    /// position in this stack, and when we encounter a successor SCC,\n+    /// we push it on the stack. When we complete an SCC, we can pop\n+    /// everything off the stack that was found along the way.\n+    successors_stack: Vec<S>,\n+\n+    /// A set used to strip duplicates. As we accumulate successors\n+    /// into the successors_stack, we sometimes get duplicate entries.\n+    /// We use this set to remove those -- we keep it around between\n+    /// successors to amortize memory allocation costs.\n+    duplicate_set: FxHashSet<S>,\n+\n+    scc_data: SccData<S>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum NodeState<N, S> {\n+    /// This node has not yet been visited as part of the DFS.\n+    ///\n+    /// After SCC construction is complete, this state ought to be\n+    /// impossible.\n+    NotVisited,\n+\n+    /// This node is currently being walk as part of our DFS. It is on\n+    /// the stack at the depth `depth`.\n+    ///\n+    /// After SCC construction is complete, this state ought to be\n+    /// impossible.\n+    BeingVisited { depth: usize },\n+\n+    /// Indicates that this node is a member of the given cycle.\n+    InCycle { scc_index: S },\n+\n+    /// Indicates that this node is a member of whatever cycle\n+    /// `parent` is a member of. This state is transient: whenever we\n+    /// see it, we try to overwrite it with the current state of\n+    /// `parent` (this is the \"path compression\" step of a union-find\n+    /// algorithm).\n+    InCycleWith { parent: N },\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum WalkReturn<S> {\n+    Cycle { min_depth: usize },\n+    Complete { scc_index: S },\n+}\n+\n+impl<'c, G, S> SccsConstruction<'c, G, S>\n+where\n+    G: DirectedGraph + WithNumNodes + WithSuccessors,\n+    S: Idx,\n+{\n+    /// Identifies SCCs in the graph `G` and computes the resulting\n+    /// DAG. This uses a variant of [Tarjan's\n+    /// algorithm][wikipedia]. The high-level summary of the algorithm\n+    /// is that we do a depth-first search. Along the way, we keep a\n+    /// stack of each node whose successors are being visited. We\n+    /// track the depth of each node on this stack (there is no depth\n+    /// if the node is not on the stack). When we find that some node\n+    /// N with depth D can reach some other node N' with lower depth\n+    /// D' (i.e., D' < D), we know that N, N', and all nodes in\n+    /// between them on the stack are part of an SCC.\n+    ///\n+    /// For each node, we track the lowest depth of any successor we\n+    /// have found, along with that\n+    ///\n+    /// [wikipedia]: https://bit.ly/2EZIx84\n+    fn construct(graph: &'c G) -> Sccs<G::Node, S> {\n+        let num_nodes = graph.num_nodes();\n+\n+        let mut this = Self {\n+            graph,\n+            node_states: IndexVec::from_elem_n(NodeState::NotVisited, num_nodes),\n+            node_stack: Vec::with_capacity(num_nodes),\n+            successors_stack: Vec::new(),\n+            scc_data: SccData {\n+                ranges: IndexVec::new(),\n+                all_successors: Vec::new(),\n+            },\n+            duplicate_set: FxHashSet::default(),\n+        };\n+\n+        let scc_indices = (0..num_nodes)\n+            .map(G::Node::new)\n+            .map(|node| match this.walk_node(0, node) {\n+                WalkReturn::Complete { scc_index } => scc_index,\n+                WalkReturn::Cycle { min_depth } => panic!(\n+                    \"`walk_node(0, {:?})` returned cycle with depth {:?}\",\n+                    node, min_depth\n+                ),\n+            })\n+            .collect();\n+\n+        Sccs {\n+            scc_indices,\n+            scc_data: this.scc_data,\n+        }\n+    }\n+\n+    fn walk_node(&mut self, depth: usize, node: G::Node) -> WalkReturn<S> {\n+        debug!(\"walk_node(depth = {:?}, node = {:?})\", depth, node);\n+        match self.find_state(node) {\n+            NodeState::InCycle { scc_index } => WalkReturn::Complete { scc_index },\n+\n+            NodeState::BeingVisited { depth: min_depth } => WalkReturn::Cycle { min_depth },\n+\n+            NodeState::NotVisited => self.walk_unvisited_node(depth, node),\n+\n+            NodeState::InCycleWith { parent } => panic!(\n+                \"`find_state` returned `InCycleWith({:?})`, which ought to be impossible\",\n+                parent\n+            ),\n+        }\n+    }\n+\n+    /// Fetches the state of the node `r`. If `r` is recorded as being\n+    /// in a cycle with some other node `r2`, then fetches the state\n+    /// of `r2` (and updates `r` to reflect current result). This is\n+    /// basically the \"find\" part of a standard union-find algorithm\n+    /// (with path compression).\n+    fn find_state(&mut self, r: G::Node) -> NodeState<G::Node, S> {\n+        debug!(\"find_state(r = {:?} in state {:?})\", r, self.node_states[r]);\n+        match self.node_states[r] {\n+            NodeState::InCycle { scc_index } => NodeState::InCycle { scc_index },\n+            NodeState::BeingVisited { depth } => NodeState::BeingVisited { depth },\n+            NodeState::NotVisited => NodeState::NotVisited,\n+            NodeState::InCycleWith { parent } => {\n+                let parent_state = self.find_state(parent);\n+                debug!(\"find_state: parent_state = {:?}\", parent_state);\n+                match parent_state {\n+                    NodeState::InCycle { .. } => {\n+                        self.node_states[r] = parent_state;\n+                        parent_state\n+                    }\n+\n+                    NodeState::BeingVisited { depth } => {\n+                        self.node_states[r] = NodeState::InCycleWith {\n+                            parent: self.node_stack[depth],\n+                        };\n+                        parent_state\n+                    }\n+\n+                    NodeState::NotVisited | NodeState::InCycleWith { .. } => {\n+                        panic!(\"invalid parent state: {:?}\", parent_state)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Walks a node that has never been visited before.\n+    fn walk_unvisited_node(&mut self, depth: usize, node: G::Node) -> WalkReturn<S> {\n+        debug!(\n+            \"walk_unvisited_node(depth = {:?}, node = {:?})\",\n+            depth, node\n+        );\n+\n+        debug_assert!(match self.node_states[node] {\n+            NodeState::NotVisited => true,\n+            _ => false,\n+        });\n+\n+        self.node_states[node] = NodeState::BeingVisited { depth };\n+        self.node_stack.push(node);\n+\n+        // Walk each successor of the node, looking to see if any of\n+        // them can reach a node that is presently on the stack. If\n+        // so, that means they can also reach us.\n+        let mut min_depth = depth;\n+        let mut min_cycle_root = node;\n+        let successors_len = self.successors_stack.len();\n+        for successor_node in self.graph.successors(node) {\n+            debug!(\n+                \"walk_unvisited_node: node = {:?} successor_ode = {:?}\",\n+                node, successor_node\n+            );\n+            match self.walk_node(depth + 1, successor_node) {\n+                WalkReturn::Cycle {\n+                    min_depth: successor_min_depth,\n+                } => {\n+                    assert!(successor_min_depth <= depth);\n+                    if successor_min_depth < min_depth {\n+                        debug!(\n+                            \"walk_unvisited_node: node = {:?} successor_min_depth = {:?}\",\n+                            node, successor_min_depth\n+                        );\n+                        min_depth = successor_min_depth;\n+                        min_cycle_root = successor_node;\n+                    }\n+                }\n+\n+                WalkReturn::Complete {\n+                    scc_index: successor_scc_index,\n+                } => {\n+                    debug!(\n+                        \"walk_unvisited_node: node = {:?} successor_scc_index = {:?}\",\n+                        node, successor_scc_index\n+                    );\n+                    self.successors_stack.push(successor_scc_index);\n+                }\n+            }\n+        }\n+\n+        let r = self.node_stack.pop();\n+        debug_assert_eq!(r, Some(node));\n+\n+        if min_depth == depth {\n+            // Note that successor stack may have duplicates, so we\n+            // want to remove those:\n+            let deduplicated_successors = {\n+                let duplicate_set = &mut self.duplicate_set;\n+                duplicate_set.clear();\n+                self.successors_stack\n+                    .drain(successors_len..)\n+                    .filter(move |&i| duplicate_set.insert(i))\n+            };\n+            let scc_index = self.scc_data.create_scc(deduplicated_successors);\n+            self.node_states[node] = NodeState::InCycle { scc_index };\n+            WalkReturn::Complete { scc_index }\n+        } else {\n+            // We are not the head of the cycle. Return back to our\n+            // caller.  They will take ownership of the\n+            // `self.successors` data that we pushed.\n+            self.node_states[node] = NodeState::InCycleWith {\n+                parent: min_cycle_root,\n+            };\n+            WalkReturn::Cycle { min_depth }\n+        }\n+    }\n+}"}, {"sha": "a273d64a40c410340fa3a37b86004dea123ae393", "filename": "src/librustc_data_structures/graph/scc/test.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/0052ddd8aec0701aa8444ad780fa4ebb123301ff/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0052ddd8aec0701aa8444ad780fa4ebb123301ff/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Ftest.rs?ref=0052ddd8aec0701aa8444ad780fa4ebb123301ff", "patch": "@@ -0,0 +1,178 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg(test)]\n+\n+use graph::test::TestGraph;\n+use super::*;\n+\n+#[test]\n+fn diamond() {\n+    let graph = TestGraph::new(0, &[(0, 1), (0, 2), (1, 3), (2, 3)]);\n+    let sccs: Sccs<_, usize> = Sccs::new(&graph);\n+    assert_eq!(sccs.num_sccs(), 4);\n+    assert_eq!(sccs.num_sccs(), 4);\n+}\n+\n+#[test]\n+fn test_big_scc() {\n+    // The order in which things will be visited is important to this\n+    // test.\n+    //\n+    // We will visit:\n+    //\n+    // 0 -> 1 -> 2 -> 0\n+    //\n+    // and at this point detect a cycle. 2 will return back to 1 which\n+    // will visit 3. 3 will visit 2 before the cycle is complete, and\n+    // hence it too will return a cycle.\n+\n+    /*\n++-> 0\n+|   |\n+|   v\n+|   1 -> 3\n+|   |    |\n+|   v    |\n++-- 2 <--+\n+     */\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (1, 2),\n+        (1, 3),\n+        (2, 0),\n+        (3, 2),\n+    ]);\n+    let sccs: Sccs<_, usize> = Sccs::new(&graph);\n+    assert_eq!(sccs.num_sccs(), 1);\n+}\n+\n+#[test]\n+fn test_three_sccs() {\n+    /*\n+    0\n+    |\n+    v\n++-> 1    3\n+|   |    |\n+|   v    |\n++-- 2 <--+\n+     */\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (1, 2),\n+        (2, 1),\n+        (3, 2),\n+    ]);\n+    let sccs: Sccs<_, usize> = Sccs::new(&graph);\n+    assert_eq!(sccs.num_sccs(), 3);\n+    assert_eq!(sccs.scc(0), 1);\n+    assert_eq!(sccs.scc(1), 0);\n+    assert_eq!(sccs.scc(2), 0);\n+    assert_eq!(sccs.scc(3), 2);\n+    assert_eq!(sccs.successors(0), &[]);\n+    assert_eq!(sccs.successors(1), &[0]);\n+    assert_eq!(sccs.successors(2), &[0]);\n+}\n+\n+#[test]\n+fn test_find_state_2() {\n+    // The order in which things will be visited is important to this\n+    // test. It tests part of the `find_state` behavior.\n+    //\n+    // We will start in our DFS by visiting:\n+    //\n+    // 0 -> 1 -> 2 -> 1\n+    //\n+    // and at this point detect a cycle. The state of 2 will thus be\n+    // `InCycleWith { 1 }`.  We will then visit the 1 -> 3 edge, which\n+    // will attempt to visit 0 as well, thus going to the state\n+    // `InCycleWith { 0 }`. Finally, node 1 will complete; the lowest\n+    // depth of any successor was 3 which had depth 0, and thus it\n+    // will be in the state `InCycleWith { 3 }`.\n+    //\n+    // When we finally traverse the `0 -> 4` edge and then visit node 2,\n+    // the states of the nodes are:\n+    //\n+    // 0 BeingVisited { 0 }\n+    // 1 InCycleWith { 3 }\n+    // 2 InCycleWith { 1 }\n+    // 3 InCycleWith { 0 }\n+    //\n+    // and hence 4 will traverse the links, finding an ultimate depth of 0.\n+    // If will also collapse the states to the following:\n+    //\n+    // 0 BeingVisited { 0 }\n+    // 1 InCycleWith { 3 }\n+    // 2 InCycleWith { 1 }\n+    // 3 InCycleWith { 0 }\n+\n+    /*\n+      /----+\n+    0 <--+ |\n+    |    | |\n+    v    | |\n++-> 1 -> 3 4\n+|   |      |\n+|   v      |\n++-- 2 <----+\n+     */\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (0, 4),\n+        (1, 2),\n+        (1, 3),\n+        (2, 1),\n+        (3, 0),\n+        (4, 2),\n+    ]);\n+    let sccs: Sccs<_, usize> = Sccs::new(&graph);\n+    assert_eq!(sccs.num_sccs(), 1);\n+    assert_eq!(sccs.scc(0), 0);\n+    assert_eq!(sccs.scc(1), 0);\n+    assert_eq!(sccs.scc(2), 0);\n+    assert_eq!(sccs.scc(3), 0);\n+    assert_eq!(sccs.scc(4), 0);\n+    assert_eq!(sccs.successors(0), &[]);\n+}\n+\n+#[test]\n+fn test_find_state_3() {\n+    /*\n+      /----+\n+    0 <--+ |\n+    |    | |\n+    v    | |\n++-> 1 -> 3 4 5\n+|   |      | |\n+|   v      | |\n++-- 2 <----+-+\n+     */\n+    let graph = TestGraph::new(0, &[\n+        (0, 1),\n+        (0, 4),\n+        (1, 2),\n+        (1, 3),\n+        (2, 1),\n+        (3, 0),\n+        (4, 2),\n+        (5, 2),\n+    ]);\n+    let sccs: Sccs<_, usize> = Sccs::new(&graph);\n+    assert_eq!(sccs.num_sccs(), 2);\n+    assert_eq!(sccs.scc(0), 0);\n+    assert_eq!(sccs.scc(1), 0);\n+    assert_eq!(sccs.scc(2), 0);\n+    assert_eq!(sccs.scc(3), 0);\n+    assert_eq!(sccs.scc(4), 0);\n+    assert_eq!(sccs.scc(5), 1);\n+    assert_eq!(sccs.successors(0), &[]);\n+    assert_eq!(sccs.successors(1), &[0]);\n+}"}, {"sha": "48b654726b8f262e2a27d67f4f8b04e36dfd6958", "filename": "src/librustc_data_structures/graph/test.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0052ddd8aec0701aa8444ad780fa4ebb123301ff/src%2Flibrustc_data_structures%2Fgraph%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0052ddd8aec0701aa8444ad780fa4ebb123301ff/src%2Flibrustc_data_structures%2Fgraph%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftest.rs?ref=0052ddd8aec0701aa8444ad780fa4ebb123301ff", "patch": "@@ -13,7 +13,7 @@ use std::cmp::max;\n use std::slice;\n use std::iter;\n \n-use super::{ControlFlowGraph, GraphPredecessors, GraphSuccessors};\n+use super::*;\n \n pub struct TestGraph {\n     num_nodes: usize,\n@@ -44,23 +44,31 @@ impl TestGraph {\n     }\n }\n \n-impl ControlFlowGraph for TestGraph {\n+impl DirectedGraph for TestGraph {\n     type Node = usize;\n+}\n \n+impl WithStartNode for TestGraph {\n     fn start_node(&self) -> usize {\n         self.start_node\n     }\n+}\n \n+impl WithNumNodes for TestGraph {\n     fn num_nodes(&self) -> usize {\n         self.num_nodes\n     }\n+}\n \n+impl WithPredecessors for TestGraph {\n     fn predecessors<'graph>(&'graph self,\n                             node: usize)\n                             -> <Self as GraphPredecessors<'graph>>::Iter {\n         self.predecessors[&node].iter().cloned()\n     }\n+}\n \n+impl WithSuccessors for TestGraph {\n     fn successors<'graph>(&'graph self, node: usize) -> <Self as GraphSuccessors<'graph>>::Iter {\n         self.successors[&node].iter().cloned()\n     }"}]}