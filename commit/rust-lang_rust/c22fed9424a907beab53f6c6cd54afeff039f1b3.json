{"sha": "c22fed9424a907beab53f6c6cd54afeff039f1b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMmZlZDk0MjRhOTA3YmVhYjUzZjZjNmNkNTRhZmVmZjAzOWYxYjM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-29T03:44:52Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-01T04:15:03Z"}, "message": "Convert relevant static mutexes to Once", "tree": {"sha": "36917eae31e165819adbdff2d9aea95b3c3073a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36917eae31e165819adbdff2d9aea95b3c3073a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c22fed9424a907beab53f6c6cd54afeff039f1b3", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c22fed9424a907beab53f6c6cd54afeff039f1b3", "html_url": "https://github.com/rust-lang/rust/commit/c22fed9424a907beab53f6c6cd54afeff039f1b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c22fed9424a907beab53f6c6cd54afeff039f1b3/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3370295b738c8b4c80fa8fc8449c0c3545b1b35", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3370295b738c8b4c80fa8fc8449c0c3545b1b35", "html_url": "https://github.com/rust-lang/rust/commit/f3370295b738c8b4c80fa8fc8449c0c3545b1b35"}], "stats": {"total": 106, "additions": 41, "deletions": 65}, "files": [{"sha": "9f307fcebb0421e507bb7e8d6c7e08d97d2c3d94", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c22fed9424a907beab53f6c6cd54afeff039f1b3/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22fed9424a907beab53f6c6cd54afeff039f1b3/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=c22fed9424a907beab53f6c6cd54afeff039f1b3", "patch": "@@ -164,19 +164,14 @@ pub fn init() {\n     }\n \n     unsafe {\n-        use std::unstable::mutex::{Mutex, MUTEX_INIT};\n-        static mut LOCK: Mutex = MUTEX_INIT;\n-        static mut INITIALIZED: bool = false;\n-        if INITIALIZED { return }\n-        LOCK.lock();\n-        if !INITIALIZED {\n+        use std::unstable::mutex::{Once, ONCE_INIT};\n+        static mut INIT: Once = ONCE_INIT;\n+        INIT.doit(|| {\n             let mut data: WSADATA = intrinsics::init();\n             let ret = WSAStartup(0x202,      // version 2.2\n                                  &mut data);\n             assert_eq!(ret, 0);\n-            INITIALIZED = true;\n-        }\n-        LOCK.unlock();\n+        });\n     }\n }\n "}, {"sha": "75edf6c80e66cb7a721dd882e6cf2a3ad67d1cb8", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c22fed9424a907beab53f6c6cd54afeff039f1b3/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22fed9424a907beab53f6c6cd54afeff039f1b3/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=c22fed9424a907beab53f6c6cd54afeff039f1b3", "patch": "@@ -310,9 +310,8 @@ pub mod write {\n     }\n \n     unsafe fn configure_llvm(sess: Session) {\n-        use std::unstable::mutex::{MUTEX_INIT, Mutex};\n-        static mut LOCK: Mutex = MUTEX_INIT;\n-        static mut CONFIGURED: bool = false;\n+        use std::unstable::mutex::{Once, ONCE_INIT};\n+        static mut INIT: Once = ONCE_INIT;\n \n         // Copy what clan does by turning on loop vectorization at O2 and\n         // slp vectorization at O3\n@@ -341,8 +340,7 @@ pub mod write {\n             add(*arg);\n         }\n \n-        LOCK.lock();\n-        if !CONFIGURED {\n+        INIT.doit(|| {\n             llvm::LLVMInitializePasses();\n \n             // Only initialize the platforms supported by Rust here, because\n@@ -369,9 +367,7 @@ pub mod write {\n \n             llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n                                          llvm_args.as_ptr());\n-            CONFIGURED = true;\n-        }\n-        LOCK.unlock();\n+        });\n     }\n \n     unsafe fn populate_llvm_passes(fpm: lib::llvm::PassManagerRef,"}, {"sha": "46bc79e3e3d88cb0e10071282cf7e229e68d706a", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c22fed9424a907beab53f6c6cd54afeff039f1b3/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22fed9424a907beab53f6c6cd54afeff039f1b3/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=c22fed9424a907beab53f6c6cd54afeff039f1b3", "patch": "@@ -1455,15 +1455,16 @@ pub mod llvm {\n                                                          BufferName: *c_char)\n             -> MemoryBufferRef;\n \n+        pub fn LLVMIsMultithreaded() -> Bool;\n+        pub fn LLVMStartMultithreaded() -> Bool;\n+\n         /** Returns a string describing the last error caused by an LLVMRust*\n             call. */\n         pub fn LLVMRustGetLastError() -> *c_char;\n \n         /// Print the pass timings since static dtors aren't picking them up.\n         pub fn LLVMRustPrintPassTimings();\n \n-        pub fn LLVMRustStartMultithreading() -> bool;\n-\n         pub fn LLVMStructCreateNamed(C: ContextRef, Name: *c_char) -> TypeRef;\n \n         pub fn LLVMStructSetBody(StructTy: TypeRef,"}, {"sha": "f308b8a02915e7e2b0fcddc17a15041f58d39b0b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c22fed9424a907beab53f6c6cd54afeff039f1b3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22fed9424a907beab53f6c6cd54afeff039f1b3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c22fed9424a907beab53f6c6cd54afeff039f1b3", "patch": "@@ -3189,8 +3189,21 @@ pub fn trans_crate(sess: session::Session,\n                    analysis: &CrateAnalysis,\n                    output: &Path) -> CrateTranslation {\n     // Before we touch LLVM, make sure that multithreading is enabled.\n-    if unsafe { !llvm::LLVMRustStartMultithreading() } {\n-        sess.bug(\"couldn't enable multi-threaded LLVM\");\n+    unsafe {\n+        use std::unstable::mutex::{Once, ONCE_INIT};\n+        static mut INIT: Once = ONCE_INIT;\n+        static mut POISONED: bool = false;\n+        INIT.doit(|| {\n+            if llvm::LLVMStartMultithreaded() != 1 {\n+                // use an extra bool to make sure that all future usage of LLVM\n+                // cannot proceed despite the Once not running more than once.\n+                POISONED = true;\n+            }\n+        });\n+\n+        if POISONED {\n+            sess.bug(\"couldn't enable multi-threaded LLVM\");\n+        }\n     }\n \n     let mut symbol_hasher = Sha256::new();"}, {"sha": "f13691a7bfe99542cb2b87196648762b3018f8e6", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c22fed9424a907beab53f6c6cd54afeff039f1b3/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22fed9424a907beab53f6c6cd54afeff039f1b3/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=c22fed9424a907beab53f6c6cd54afeff039f1b3", "patch": "@@ -160,30 +160,20 @@ pub mod native {\n     use option::{Option, Some, None};\n     use ptr;\n     use tls = rt::thread_local_storage;\n-    use unstable::mutex::{Mutex, MUTEX_INIT};\n \n-    static mut LOCK: Mutex = MUTEX_INIT;\n-    static mut INITIALIZED: bool = false;\n     static mut RT_TLS_KEY: tls::Key = -1;\n \n     /// Initialize the TLS key. Other ops will fail if this isn't executed\n     /// first.\n     pub fn init() {\n         unsafe {\n-            LOCK.lock();\n-            if !INITIALIZED {\n-                tls::create(&mut RT_TLS_KEY);\n-                INITIALIZED = true;\n-            }\n-            LOCK.unlock();\n+            tls::create(&mut RT_TLS_KEY);\n         }\n     }\n \n     pub unsafe fn cleanup() {\n-        rtassert!(INITIALIZED);\n+        rtassert!(RT_TLS_KEY != -1);\n         tls::destroy(RT_TLS_KEY);\n-        LOCK.destroy();\n-        INITIALIZED = false;\n     }\n \n     /// Give a pointer to thread-local storage."}, {"sha": "6dbac90ef664abf9fe09b38ff30431556c80b4e9", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c22fed9424a907beab53f6c6cd54afeff039f1b3/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c22fed9424a907beab53f6c6cd54afeff039f1b3/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=c22fed9424a907beab53f6c6cd54afeff039f1b3", "patch": "@@ -47,6 +47,7 @@\n \n #[allow(non_camel_case_types)];\n \n+use int;\n use libc::c_void;\n use sync::atomics;\n \n@@ -339,15 +340,15 @@ mod imp {\n /// ```\n pub struct Once {\n     priv mutex: Mutex,\n-    priv cnt: AtomicInt,\n-    priv lock_cnt: AtomicInt,\n+    priv cnt: atomics::AtomicInt,\n+    priv lock_cnt: atomics::AtomicInt,\n }\n \n /// Initialization value for static `Once` values.\n pub static ONCE_INIT: Once = Once {\n     mutex: MUTEX_INIT,\n-    cnt: INIT_ATOMIC_INT,\n-    lock_cnt: INIT_ATOMIC_INT,\n+    cnt: atomics::INIT_ATOMIC_INT,\n+    lock_cnt: atomics::INIT_ATOMIC_INT,\n };\n \n impl Once {\n@@ -388,34 +389,36 @@ impl Once {\n         // calling `doit` will return immediately before the initialization has\n         // completed.\n \n-        let prev = self.cnt.fetch_add(1, SeqCst);\n+        let prev = self.cnt.fetch_add(1, atomics::SeqCst);\n         if prev < 0 {\n             // Make sure we never overflow, we'll never have int::min_value\n             // simultaneous calls to `doit` to make this value go back to 0\n-            self.cnt.store(int::min_value, SeqCst);\n+            self.cnt.store(int::min_value, atomics::SeqCst);\n             return\n         }\n \n         // If the count is negative, then someone else finished the job,\n         // otherwise we run the job and record how many people will try to grab\n         // this lock\n         unsafe { self.mutex.lock() }\n-        if self.cnt.load(SeqCst) > 0 {\n+        if self.cnt.load(atomics::SeqCst) > 0 {\n             f();\n-            let prev = self.cnt.swap(int::min_value, SeqCst);\n-            self.lock_cnt.store(prev, SeqCst);\n+            let prev = self.cnt.swap(int::min_value, atomics::SeqCst);\n+            self.lock_cnt.store(prev, atomics::SeqCst);\n         }\n         unsafe { self.mutex.unlock() }\n \n         // Last one out cleans up after everyone else, no leaks!\n-        if self.lock_cnt.fetch_add(-1, SeqCst) == 1 {\n+        if self.lock_cnt.fetch_add(-1, atomics::SeqCst) == 1 {\n             unsafe { self.mutex.destroy() }\n         }\n     }\n }\n \n #[cfg(test)]\n mod test {\n+    use prelude::*;\n+\n     use rt::thread::Thread;\n     use super::{ONCE_INIT, Once, Mutex, MUTEX_INIT};\n     use task;"}, {"sha": "335c7b2c65b7fc552a6810467db7a3f2c430c375", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c22fed9424a907beab53f6c6cd54afeff039f1b3/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c22fed9424a907beab53f6c6cd54afeff039f1b3/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=c22fed9424a907beab53f6c6cd54afeff039f1b3", "patch": "@@ -149,28 +149,6 @@ extern \"C\" LLVMValueRef LLVMInlineAsm(LLVMTypeRef Ty,\n                                IsAlignStack, (InlineAsm::AsmDialect) Dialect));\n }\n \n-/**\n- * This function is intended to be a threadsafe interface into enabling a\n- * multithreaded LLVM. This is invoked at the start of the translation phase of\n- * compilation to ensure that LLVM is ready.\n- *\n- * All of trans properly isolates LLVM with the use of a different\n- * LLVMContextRef per task, thus allowing parallel compilation of different\n- * crates in the same process. At the time of this writing, the use case for\n- * this is unit tests for rusti, but there are possible other applications.\n- */\n-extern \"C\" bool LLVMRustStartMultithreading() {\n-    static Mutex lock;\n-    bool ret = true;\n-    assert(lock.acquire());\n-    if (!LLVMIsMultithreaded()) {\n-        ret = LLVMStartMultithreaded();\n-    }\n-    assert(lock.release());\n-    return ret;\n-}\n-\n-\n typedef DIBuilder* DIBuilderRef;\n \n template<typename DIT>"}]}