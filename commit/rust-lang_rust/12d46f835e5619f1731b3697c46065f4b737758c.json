{"sha": "12d46f835e5619f1731b3697c46065f4b737758c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZDQ2ZjgzNWU1NjE5ZjE3MzFiMzY5N2M0NjA2NWY0YjczNzc1OGM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-27T01:22:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-27T01:22:28Z"}, "message": "Merge #9018\n\n9018: Collapse more CompletionContext booleans into enums r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "e8750a920f92bbbd4fe3cb23be585eed7ad92b24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8750a920f92bbbd4fe3cb23be585eed7ad92b24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12d46f835e5619f1731b3697c46065f4b737758c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgrvRUCRBK7hj4Ov3rIwAAJJ8IAEXf794tCSP2RoBMKdGeMTiQ\n98P7w+rl+BNaS/ELzrXFh4+JrahaPVuANr+UJvqHW8mJqVvkB/hyazfrjLqyXuuU\nlu4CjfsuRnze6OPWO9JzmZrew3zD2bXvw+WokQ0U/842a/VmwBZgDd2xnxpxmCYm\nqzimfwotJVRwCHS8hhwQxsqfmJAj9A1r6bF2fQ+OhY1yIVsflJiePNXFSuCGIENN\nKrfcCnJAHHkGFzqeoQlbHJPVYUo6DVee0dS2VZuE3iE3e0D2mX4mud5Dpv6GdUuf\nwcqE3JiLOD+aDe2D3kHHdzVz1vZ9diQAWiV2cutlJ8VQl9l1tFdiHRMd28k3ibQ=\n=QQpT\n-----END PGP SIGNATURE-----\n", "payload": "tree e8750a920f92bbbd4fe3cb23be585eed7ad92b24\nparent d6ed315806e23d9ebda96ecfbe13da2154a2289c\nparent 6ec4ea8d9eb9ad6ad8b91968bde09121b5b791a0\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1622078548 +0000\ncommitter GitHub <noreply@github.com> 1622078548 +0000\n\nMerge #9018\n\n9018: Collapse more CompletionContext booleans into enums r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12d46f835e5619f1731b3697c46065f4b737758c", "html_url": "https://github.com/rust-lang/rust/commit/12d46f835e5619f1731b3697c46065f4b737758c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12d46f835e5619f1731b3697c46065f4b737758c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6ed315806e23d9ebda96ecfbe13da2154a2289c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ed315806e23d9ebda96ecfbe13da2154a2289c", "html_url": "https://github.com/rust-lang/rust/commit/d6ed315806e23d9ebda96ecfbe13da2154a2289c"}, {"sha": "6ec4ea8d9eb9ad6ad8b91968bde09121b5b791a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ec4ea8d9eb9ad6ad8b91968bde09121b5b791a0", "html_url": "https://github.com/rust-lang/rust/commit/6ec4ea8d9eb9ad6ad8b91968bde09121b5b791a0"}], "stats": {"total": 253, "additions": 140, "deletions": 113}, "files": [{"sha": "b7d3ee8ce7bb05a780e7967460b5eb89004dfefb", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/12d46f835e5619f1731b3697c46065f4b737758c/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d46f835e5619f1731b3697c46065f4b737758c/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=12d46f835e5619f1731b3697c46065f4b737758c", "patch": "@@ -114,8 +114,7 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n         || ctx.attribute_under_caret.is_some()\n         || ctx.mod_declaration_under_caret.is_some()\n         || ctx.record_lit_syntax.is_some()\n-        || ctx.has_trait_parent\n-        || ctx.has_impl_parent\n+        || ctx.has_impl_or_trait_parent()\n     {\n         return None;\n     }"}, {"sha": "58e35bad9b24ae687c49caede155845e48803410", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/12d46f835e5619f1731b3697c46065f4b737758c/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d46f835e5619f1731b3697c46065f4b737758c/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=12d46f835e5619f1731b3697c46065f4b737758c", "patch": "@@ -49,34 +49,35 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         return;\n     }\n \n-    let has_trait_or_impl_parent = ctx.has_impl_parent || ctx.has_trait_parent;\n-    if ctx.trait_as_prev_sibling || ctx.impl_as_prev_sibling {\n+    let has_trait_or_impl_parent = ctx.has_impl_or_trait_parent();\n+    let has_block_expr_parent = ctx.has_block_expr_parent();\n+    let has_item_list_parent = ctx.has_item_list_parent();\n+    if ctx.has_impl_or_trait_prev_sibling() {\n         add_keyword(ctx, acc, \"where\", \"where \");\n         return;\n     }\n     if ctx.previous_token_is(T![unsafe]) {\n-        if ctx.has_item_list_or_source_file_parent || ctx.block_expr_parent {\n+        if has_item_list_parent || has_block_expr_parent {\n             add_keyword(ctx, acc, \"fn\", \"fn $1($2) {\\n    $0\\n}\")\n         }\n \n-        if (ctx.has_item_list_or_source_file_parent) || ctx.block_expr_parent {\n+        if has_item_list_parent || has_block_expr_parent {\n             add_keyword(ctx, acc, \"trait\", \"trait $1 {\\n    $0\\n}\");\n             add_keyword(ctx, acc, \"impl\", \"impl $1 {\\n    $0\\n}\");\n         }\n \n         return;\n     }\n-    if ctx.has_item_list_or_source_file_parent || has_trait_or_impl_parent || ctx.block_expr_parent\n-    {\n+    if has_item_list_parent || has_trait_or_impl_parent || has_block_expr_parent {\n         add_keyword(ctx, acc, \"fn\", \"fn $1($2) {\\n    $0\\n}\");\n     }\n-    if (ctx.has_item_list_or_source_file_parent) || ctx.block_expr_parent {\n+    if has_item_list_parent || has_block_expr_parent {\n         add_keyword(ctx, acc, \"use\", \"use \");\n         add_keyword(ctx, acc, \"impl\", \"impl $1 {\\n    $0\\n}\");\n         add_keyword(ctx, acc, \"trait\", \"trait $1 {\\n    $0\\n}\");\n     }\n \n-    if ctx.has_item_list_or_source_file_parent {\n+    if has_item_list_parent {\n         add_keyword(ctx, acc, \"enum\", \"enum $1 {\\n    $0\\n}\");\n         add_keyword(ctx, acc, \"struct\", \"struct $0\");\n         add_keyword(ctx, acc, \"union\", \"union $1 {\\n    $0\\n}\");\n@@ -92,35 +93,31 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         add_keyword(ctx, acc, \"for\", \"for $1 in $2 {\\n    $0\\n}\");\n     }\n \n-    if ctx.previous_token_is(T![if]) || ctx.previous_token_is(T![while]) || ctx.block_expr_parent {\n+    if ctx.previous_token_is(T![if]) || ctx.previous_token_is(T![while]) || has_block_expr_parent {\n         add_keyword(ctx, acc, \"let\", \"let \");\n     }\n \n     if ctx.after_if {\n         add_keyword(ctx, acc, \"else\", \"else {\\n    $0\\n}\");\n         add_keyword(ctx, acc, \"else if\", \"else if $1 {\\n    $0\\n}\");\n     }\n-    if (ctx.has_item_list_or_source_file_parent) || ctx.block_expr_parent {\n+    if has_item_list_parent || has_block_expr_parent {\n         add_keyword(ctx, acc, \"mod\", \"mod $0\");\n     }\n-    if ctx.bind_pat_parent || ctx.ref_pat_parent {\n+    if ctx.has_ident_or_ref_pat_parent() {\n         add_keyword(ctx, acc, \"mut\", \"mut \");\n     }\n-    if ctx.has_item_list_or_source_file_parent || has_trait_or_impl_parent || ctx.block_expr_parent\n-    {\n+    if has_item_list_parent || has_trait_or_impl_parent || has_block_expr_parent {\n         add_keyword(ctx, acc, \"const\", \"const \");\n         add_keyword(ctx, acc, \"type\", \"type \");\n     }\n-    if (ctx.has_item_list_or_source_file_parent) || ctx.block_expr_parent {\n+    if has_item_list_parent || has_block_expr_parent {\n         add_keyword(ctx, acc, \"static\", \"static \");\n     };\n-    if (ctx.has_item_list_or_source_file_parent) || ctx.block_expr_parent {\n+    if has_item_list_parent || has_block_expr_parent {\n         add_keyword(ctx, acc, \"extern\", \"extern \");\n     }\n-    if ctx.has_item_list_or_source_file_parent\n-        || has_trait_or_impl_parent\n-        || ctx.block_expr_parent\n-        || ctx.is_match_arm\n+    if has_item_list_parent || has_trait_or_impl_parent || has_block_expr_parent || ctx.is_match_arm\n     {\n         add_keyword(ctx, acc, \"unsafe\", \"unsafe \");\n     }\n@@ -133,15 +130,15 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n             add_keyword(ctx, acc, \"break\", \"break\");\n         }\n     }\n-    if ctx.has_item_list_or_source_file_parent || ctx.has_impl_parent | ctx.has_field_list_parent {\n+    if has_item_list_parent || ctx.has_impl_parent() || ctx.has_field_list_parent() {\n         add_keyword(ctx, acc, \"pub(crate)\", \"pub(crate) \");\n         add_keyword(ctx, acc, \"pub\", \"pub \");\n     }\n \n     if !ctx.is_trivial_path {\n         return;\n     }\n-    let fn_def = match &ctx.function_syntax {\n+    let fn_def = match &ctx.function_def {\n         Some(it) => it,\n         None => return,\n     };"}, {"sha": "defc25b00892b039407a650f832efac72ca9e901", "filename": "crates/ide_completion/src/completions/snippet.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12d46f835e5619f1731b3697c46065f4b737758c/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d46f835e5619f1731b3697c46065f4b737758c/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=12d46f835e5619f1731b3697c46065f4b737758c", "patch": "@@ -14,7 +14,7 @@ fn snippet(ctx: &CompletionContext, cap: SnippetCap, label: &str, snippet: &str)\n }\n \n pub(crate) fn complete_expr_snippet(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !(ctx.is_trivial_path && ctx.function_syntax.is_some()) {\n+    if !(ctx.is_trivial_path && ctx.function_def.is_some()) {\n         return;\n     }\n     let cap = match ctx.config.snippet_cap {"}, {"sha": "7496d26c4db89b709c6e118863d39b3d9214a388", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/12d46f835e5619f1731b3697c46065f4b737758c/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d46f835e5619f1731b3697c46065f4b737758c/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=12d46f835e5619f1731b3697c46065f4b737758c", "patch": "@@ -13,8 +13,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         || ctx.record_pat_syntax.is_some()\n         || ctx.attribute_under_caret.is_some()\n         || ctx.mod_declaration_under_caret.is_some()\n-        || ctx.has_impl_parent\n-        || ctx.has_trait_parent\n+        || ctx.has_impl_or_trait_parent()\n     {\n         return;\n     }"}, {"sha": "5d15fde2fdfade267081d4a52d15ab33f0e9a9ad", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 96, "deletions": 52, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/12d46f835e5619f1731b3697c46065f4b737758c/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d46f835e5619f1731b3697c46065f4b737758c/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=12d46f835e5619f1731b3697c46065f4b737758c", "patch": "@@ -18,9 +18,8 @@ use text_edit::Indel;\n use crate::{\n     patterns::{\n         for_is_prev2, has_bind_pat_parent, has_block_expr_parent, has_field_list_parent,\n-        has_impl_as_prev_sibling, has_impl_parent, has_item_list_or_source_file_parent,\n-        has_ref_parent, has_trait_as_prev_sibling, has_trait_parent, inside_impl_trait_block,\n-        is_in_loop_body, is_match_arm, previous_token,\n+        has_impl_parent, has_item_list_or_source_file_parent, has_prev_sibling, has_ref_parent,\n+        has_trait_parent, inside_impl_trait_block, is_in_loop_body, is_match_arm, previous_token,\n     },\n     CompletionConfig,\n };\n@@ -31,6 +30,24 @@ pub(crate) enum PatternRefutability {\n     Irrefutable,\n }\n \n+/// Direct parent container of the cursor position\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum ImmediateLocation {\n+    Impl,\n+    Trait,\n+    RecordFieldList,\n+    RefPatOrExpr,\n+    IdentPat,\n+    BlockExpr,\n+    ItemList,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum PrevSibling {\n+    Trait,\n+    Impl,\n+}\n+\n /// `CompletionContext` is created early during completion to figure out, where\n /// exactly is the cursor, syntax-wise.\n #[derive(Debug)]\n@@ -48,14 +65,19 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) expected_name: Option<NameOrNameRef>,\n     pub(super) expected_type: Option<Type>,\n     pub(super) name_ref_syntax: Option<ast::NameRef>,\n-    pub(super) function_syntax: Option<ast::Fn>,\n+\n     pub(super) use_item_syntax: Option<ast::Use>,\n-    pub(super) record_lit_syntax: Option<ast::RecordExpr>,\n-    pub(super) record_pat_syntax: Option<ast::RecordPat>,\n-    pub(super) record_field_syntax: Option<ast::RecordExprField>,\n+\n+    /// The parent function of the cursor position if it exists.\n+    pub(super) function_def: Option<ast::Fn>,\n     /// The parent impl of the cursor position if it exists.\n     pub(super) impl_def: Option<ast::Impl>,\n \n+    /// RecordExpr the token is a field of\n+    pub(super) record_lit_syntax: Option<ast::RecordExpr>,\n+    /// RecordPat the token is a field of\n+    pub(super) record_pat_syntax: Option<ast::RecordPat>,\n+\n     // potentially set if we are completing a lifetime\n     pub(super) lifetime_syntax: Option<ast::Lifetime>,\n     pub(super) lifetime_param_syntax: Option<ast::LifetimeParam>,\n@@ -66,6 +88,8 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_pat_or_const: Option<PatternRefutability>,\n     pub(super) is_param: bool,\n \n+    pub(super) completion_location: Option<ImmediateLocation>,\n+\n     /// FIXME: `ActiveParameter` is string-based, which is very very wrong\n     pub(super) active_parameter: Option<ActiveParameter>,\n     /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n@@ -94,20 +118,12 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) locals: Vec<(String, Local)>,\n \n     pub(super) mod_declaration_under_caret: Option<ast::Module>,\n-    pub(super) has_trait_parent: bool,\n-    pub(super) has_impl_parent: bool,\n \n     // keyword patterns\n     pub(super) previous_token: Option<SyntaxToken>,\n-    pub(super) block_expr_parent: bool,\n-    pub(super) bind_pat_parent: bool,\n-    pub(super) ref_pat_parent: bool,\n     pub(super) in_loop_body: bool,\n-    pub(super) has_field_list_parent: bool,\n-    pub(super) trait_as_prev_sibling: bool,\n-    pub(super) impl_as_prev_sibling: bool,\n+    pub(super) prev_sibling: Option<PrevSibling>,\n     pub(super) is_match_arm: bool,\n-    pub(super) has_item_list_or_source_file_parent: bool,\n     pub(super) incomplete_let: bool,\n \n     no_completion_required: bool,\n@@ -159,11 +175,10 @@ impl<'a> CompletionContext<'a> {\n             name_ref_syntax: None,\n             lifetime_syntax: None,\n             lifetime_param_syntax: None,\n-            function_syntax: None,\n+            function_def: None,\n             use_item_syntax: None,\n             record_lit_syntax: None,\n             record_pat_syntax: None,\n-            record_field_syntax: None,\n             impl_def: None,\n             active_parameter: ActiveParameter::at(db, position),\n             is_label_ref: false,\n@@ -185,17 +200,10 @@ impl<'a> CompletionContext<'a> {\n             attribute_under_caret: None,\n             mod_declaration_under_caret: None,\n             previous_token: None,\n-            block_expr_parent: false,\n-            bind_pat_parent: false,\n-            ref_pat_parent: false,\n             in_loop_body: false,\n-            has_trait_parent: false,\n-            has_impl_parent: false,\n-            has_field_list_parent: false,\n-            trait_as_prev_sibling: false,\n-            impl_as_prev_sibling: false,\n+            completion_location: None,\n+            prev_sibling: None,\n             is_match_arm: false,\n-            has_item_list_or_source_file_parent: false,\n             no_completion_required: false,\n             incomplete_let: false,\n             locals,\n@@ -274,23 +282,68 @@ impl<'a> CompletionContext<'a> {\n         self.previous_token.as_ref().map_or(false, |tok| tok.kind() == kind)\n     }\n \n+    pub(crate) fn has_impl_or_trait_parent(&self) -> bool {\n+        matches!(\n+            self.completion_location,\n+            Some(ImmediateLocation::Trait) | Some(ImmediateLocation::Impl)\n+        )\n+    }\n+\n+    pub(crate) fn has_block_expr_parent(&self) -> bool {\n+        matches!(self.completion_location, Some(ImmediateLocation::BlockExpr))\n+    }\n+\n+    pub(crate) fn has_item_list_parent(&self) -> bool {\n+        matches!(self.completion_location, Some(ImmediateLocation::ItemList))\n+    }\n+\n+    pub(crate) fn has_ident_or_ref_pat_parent(&self) -> bool {\n+        matches!(\n+            self.completion_location,\n+            Some(ImmediateLocation::IdentPat) | Some(ImmediateLocation::RefPatOrExpr)\n+        )\n+    }\n+\n+    pub(crate) fn has_impl_parent(&self) -> bool {\n+        matches!(self.completion_location, Some(ImmediateLocation::Impl))\n+    }\n+\n+    pub(crate) fn has_field_list_parent(&self) -> bool {\n+        matches!(self.completion_location, Some(ImmediateLocation::RecordFieldList))\n+    }\n+\n+    pub(crate) fn has_impl_or_trait_prev_sibling(&self) -> bool {\n+        self.prev_sibling.is_some()\n+    }\n+\n     fn fill_keyword_patterns(&mut self, file_with_fake_ident: &SyntaxNode, offset: TextSize) {\n         let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n         let syntax_element = NodeOrToken::Token(fake_ident_token);\n         self.previous_token = previous_token(syntax_element.clone());\n-        self.block_expr_parent = has_block_expr_parent(syntax_element.clone());\n-        self.bind_pat_parent = has_bind_pat_parent(syntax_element.clone());\n-        self.ref_pat_parent = has_ref_parent(syntax_element.clone());\n         self.in_loop_body = is_in_loop_body(syntax_element.clone());\n-        self.has_trait_parent = has_trait_parent(syntax_element.clone());\n-        self.has_impl_parent = has_impl_parent(syntax_element.clone());\n-        self.has_field_list_parent = has_field_list_parent(syntax_element.clone());\n-        self.impl_as_prev_sibling = has_impl_as_prev_sibling(syntax_element.clone());\n-        self.trait_as_prev_sibling = has_trait_as_prev_sibling(syntax_element.clone());\n         self.is_match_arm = is_match_arm(syntax_element.clone());\n+        if has_prev_sibling(syntax_element.clone(), IMPL) {\n+            self.prev_sibling = Some(PrevSibling::Impl)\n+        } else if has_prev_sibling(syntax_element.clone(), TRAIT) {\n+            self.prev_sibling = Some(PrevSibling::Trait)\n+        }\n+\n+        if has_block_expr_parent(syntax_element.clone()) {\n+            self.completion_location = Some(ImmediateLocation::BlockExpr);\n+        } else if has_bind_pat_parent(syntax_element.clone()) {\n+            self.completion_location = Some(ImmediateLocation::IdentPat);\n+        } else if has_ref_parent(syntax_element.clone()) {\n+            self.completion_location = Some(ImmediateLocation::RefPatOrExpr);\n+        } else if has_impl_parent(syntax_element.clone()) {\n+            self.completion_location = Some(ImmediateLocation::Impl);\n+        } else if has_field_list_parent(syntax_element.clone()) {\n+            self.completion_location = Some(ImmediateLocation::RecordFieldList);\n+        } else if has_trait_parent(syntax_element.clone()) {\n+            self.completion_location = Some(ImmediateLocation::Trait);\n+        } else if has_item_list_or_source_file_parent(syntax_element.clone()) {\n+            self.completion_location = Some(ImmediateLocation::ItemList);\n+        }\n \n-        self.has_item_list_or_source_file_parent =\n-            has_item_list_or_source_file_parent(syntax_element.clone());\n         self.mod_declaration_under_caret =\n             find_node_at_offset::<ast::Module>(&file_with_fake_ident, offset)\n                 .filter(|module| module.item_list().is_none());\n@@ -542,31 +595,20 @@ impl<'a> CompletionContext<'a> {\n             .last()\n             .unwrap();\n \n-        match top_node.parent().map(|it| it.kind()) {\n-            Some(SOURCE_FILE) | Some(ITEM_LIST) => {\n-                self.is_new_item = true;\n-                return;\n-            }\n-            _ => (),\n+        if matches!(top_node.parent().map(|it| it.kind()), Some(SOURCE_FILE) | Some(ITEM_LIST)) {\n+            self.is_new_item = true;\n+            return;\n         }\n \n         self.use_item_syntax =\n             self.sema.token_ancestors_with_macros(self.token.clone()).find_map(ast::Use::cast);\n \n-        self.function_syntax = self\n+        self.function_def = self\n             .sema\n             .token_ancestors_with_macros(self.token.clone())\n             .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n             .find_map(ast::Fn::cast);\n \n-        self.record_field_syntax = self\n-            .sema\n-            .token_ancestors_with_macros(self.token.clone())\n-            .take_while(|it| {\n-                it.kind() != SOURCE_FILE && it.kind() != MODULE && it.kind() != CALL_EXPR\n-            })\n-            .find_map(ast::RecordExprField::cast);\n-\n         let parent = match name_ref.syntax().parent() {\n             Some(it) => it,\n             None => return,\n@@ -639,6 +681,7 @@ impl<'a> CompletionContext<'a> {\n                 }\n             }\n         }\n+\n         if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n             // The receiver comes before the point of insertion of the fake\n             // ident, so it should have the same range in the non-modified file\n@@ -656,6 +699,7 @@ impl<'a> CompletionContext<'a> {\n                     false\n                 };\n         }\n+\n         if let Some(method_call_expr) = ast::MethodCallExpr::cast(parent) {\n             // As above\n             self.dot_receiver = method_call_expr"}, {"sha": "04f2c532b119d077ffc6f49dd5b02942c904825f", "filename": "crates/ide_completion/src/patterns.rs", "status": "modified", "additions": 23, "deletions": 35, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/12d46f835e5619f1731b3697c46065f4b737758c/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d46f835e5619f1731b3697c46065f4b737758c/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fpatterns.rs?ref=12d46f835e5619f1731b3697c46065f4b737758c", "patch": "@@ -4,7 +4,7 @@ use syntax::{\n     algo::non_trivia_sibling,\n     ast::{self, LoopBodyOwner},\n     match_ast, AstNode, Direction, NodeOrToken, SyntaxElement,\n-    SyntaxKind::*,\n+    SyntaxKind::{self, *},\n     SyntaxNode, SyntaxToken, T,\n };\n \n@@ -73,6 +73,7 @@ fn test_has_block_expr_parent() {\n pub(crate) fn has_bind_pat_parent(element: SyntaxElement) -> bool {\n     element.ancestors().any(|it| it.kind() == IDENT_PAT)\n }\n+\n #[test]\n fn test_has_bind_pat_parent() {\n     check_pattern_is_applicable(r\"fn my_fn(m$0) {}\", has_bind_pat_parent);\n@@ -91,11 +92,10 @@ fn test_has_ref_parent() {\n }\n \n pub(crate) fn has_item_list_or_source_file_parent(element: SyntaxElement) -> bool {\n-    let ancestor = not_same_range_ancestor(element);\n-    if !ancestor.is_some() {\n-        return true;\n+    match not_same_range_ancestor(element) {\n+        Some(it) => it.kind() == SOURCE_FILE || it.kind() == ITEM_LIST,\n+        None => true,\n     }\n-    ancestor.filter(|it| it.kind() == SOURCE_FILE || it.kind() == ITEM_LIST).is_some()\n }\n #[test]\n fn test_has_item_list_or_source_file_parent() {\n@@ -134,42 +134,30 @@ fn test_for_is_prev2() {\n     check_pattern_is_applicable(r\"for i i$0\", for_is_prev2);\n }\n \n-pub(crate) fn has_trait_as_prev_sibling(element: SyntaxElement) -> bool {\n-    previous_sibling_or_ancestor_sibling(element).filter(|it| it.kind() == TRAIT).is_some()\n-}\n-#[test]\n-fn test_has_trait_as_prev_sibling() {\n-    check_pattern_is_applicable(r\"trait A w$0 {}\", has_trait_as_prev_sibling);\n-}\n-\n-pub(crate) fn has_impl_as_prev_sibling(element: SyntaxElement) -> bool {\n-    previous_sibling_or_ancestor_sibling(element).filter(|it| it.kind() == IMPL).is_some()\n+pub(crate) fn has_prev_sibling(element: SyntaxElement, kind: SyntaxKind) -> bool {\n+    previous_sibling_or_ancestor_sibling(element).filter(|it| it.kind() == kind).is_some()\n }\n #[test]\n fn test_has_impl_as_prev_sibling() {\n-    check_pattern_is_applicable(r\"impl A w$0 {}\", has_impl_as_prev_sibling);\n+    check_pattern_is_applicable(r\"impl A w$0 {}\", |it| has_prev_sibling(it, IMPL));\n }\n \n pub(crate) fn is_in_loop_body(element: SyntaxElement) -> bool {\n-    for node in element.ancestors() {\n-        if node.kind() == FN || node.kind() == CLOSURE_EXPR {\n-            break;\n-        }\n-        let loop_body = match_ast! {\n-            match node {\n-                ast::ForExpr(it) => it.loop_body(),\n-                ast::WhileExpr(it) => it.loop_body(),\n-                ast::LoopExpr(it) => it.loop_body(),\n-                _ => None,\n-            }\n-        };\n-        if let Some(body) = loop_body {\n-            if body.syntax().text_range().contains_range(element.text_range()) {\n-                return true;\n-            }\n-        }\n-    }\n-    false\n+    element\n+        .ancestors()\n+        .take_while(|it| it.kind() != FN && it.kind() != CLOSURE_EXPR)\n+        .find_map(|it| {\n+            let loop_body = match_ast! {\n+                match it {\n+                    ast::ForExpr(it) => it.loop_body(),\n+                    ast::WhileExpr(it) => it.loop_body(),\n+                    ast::LoopExpr(it) => it.loop_body(),\n+                    _ => None,\n+                }\n+            };\n+            loop_body.filter(|it| it.syntax().text_range().contains_range(element.text_range()))\n+        })\n+        .is_some()\n }\n \n fn not_same_range_ancestor(element: SyntaxElement) -> Option<SyntaxNode> {"}]}