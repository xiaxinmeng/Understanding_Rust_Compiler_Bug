{"sha": "0689fdb650b43c7a5dc3bb27655b2df6879d8387", "node_id": "C_kwDOAAsO6NoAKDA2ODlmZGI2NTBiNDNjN2E1ZGMzYmIyNzY1NWIyZGY2ODc5ZDgzODc", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-03-20T18:20:16Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-03-21T15:46:01Z"}, "message": "Add \"add missing Ok/Some\" fix", "tree": {"sha": "dc2054f07e6b9a5be0e6b1a64a8bbc3d33d7f510", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc2054f07e6b9a5be0e6b1a64a8bbc3d33d7f510"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0689fdb650b43c7a5dc3bb27655b2df6879d8387", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0689fdb650b43c7a5dc3bb27655b2df6879d8387", "html_url": "https://github.com/rust-lang/rust/commit/0689fdb650b43c7a5dc3bb27655b2df6879d8387", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0689fdb650b43c7a5dc3bb27655b2df6879d8387/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab3313b1cb5e9ff79ecef0fb188873c892c193f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab3313b1cb5e9ff79ecef0fb188873c892c193f1", "html_url": "https://github.com/rust-lang/rust/commit/ab3313b1cb5e9ff79ecef0fb188873c892c193f1"}], "stats": {"total": 479, "additions": 252, "deletions": 227}, "files": [{"sha": "3af56b743f338e69b8218983dcb7d1529e564a64", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0689fdb650b43c7a5dc3bb27655b2df6879d8387/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0689fdb650b43c7a5dc3bb27655b2df6879d8387/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=0689fdb650b43c7a5dc3bb27655b2df6879d8387", "patch": "@@ -1004,6 +1004,26 @@ impl Adt {\n         Type::from_def(db, id.module(db.upcast()).krate(), id)\n     }\n \n+    /// Turns this ADT into a type with the given type parameters. This isn't\n+    /// the greatest API, FIXME find a better one.\n+    pub fn ty_with_args(self, db: &dyn HirDatabase, args: &[Type]) -> Type {\n+        let id = AdtId::from(self);\n+        let mut it = args.iter().map(|t| t.ty.clone());\n+        let ty = TyBuilder::def_ty(db, id.into())\n+            .fill(|x| {\n+                let r = it.next().unwrap_or_else(|| TyKind::Error.intern(Interner));\n+                match x {\n+                    ParamKind::Type => GenericArgData::Ty(r).intern(Interner),\n+                    ParamKind::Const(ty) => {\n+                        unknown_const_as_generic(ty.clone())\n+                    }\n+                }\n+            })\n+            .build();\n+        let krate = id.module(db.upcast()).krate();\n+        Type::new(db, krate, id, ty)\n+    }\n+\n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n         match self {\n             Adt::Struct(s) => s.module(db),\n@@ -1019,6 +1039,14 @@ impl Adt {\n             Adt::Enum(e) => e.name(db),\n         }\n     }\n+\n+    pub fn as_enum(&self) -> Option<Enum> {\n+        if let Self::Enum(v) = self {\n+            Some(*v)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n impl HasVisibility for Adt {"}, {"sha": "d5635ba8baf355d93a85f0767873c7cf4235d4f3", "filename": "crates/ide_diagnostics/src/handlers/missing_ok_or_some_in_tail_expr.rs", "status": "removed", "additions": 0, "deletions": 223, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_ok_or_some_in_tail_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab3313b1cb5e9ff79ecef0fb188873c892c193f1/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_ok_or_some_in_tail_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_ok_or_some_in_tail_expr.rs?ref=ab3313b1cb5e9ff79ecef0fb188873c892c193f1", "patch": "@@ -1,223 +0,0 @@\n-use hir::{db::AstDatabase, TypeInfo};\n-use ide_db::{\n-    assists::Assist, source_change::SourceChange, syntax_helpers::node_ext::for_each_tail_expr,\n-};\n-use syntax::AstNode;\n-use text_edit::TextEdit;\n-\n-use crate::{fix, Diagnostic, DiagnosticsContext};\n-\n-// Diagnostic: missing-ok-or-some-in-tail-expr\n-//\n-// This diagnostic is triggered if a block that should return `Result` returns a value not wrapped in `Ok`,\n-// or if a block that should return `Option` returns a value not wrapped in `Some`.\n-//\n-// Example:\n-//\n-// ```rust\n-// fn foo() -> Result<u8, ()> {\n-//     10\n-// }\n-// ```\n-pub(crate) fn missing_ok_or_some_in_tail_expr(\n-    ctx: &DiagnosticsContext<'_>,\n-    d: &hir::MissingOkOrSomeInTailExpr,\n-) -> Diagnostic {\n-    Diagnostic::new(\n-        \"missing-ok-or-some-in-tail-expr\",\n-        format!(\"wrap return expression in {}\", d.required),\n-        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n-    )\n-    .with_fixes(fixes(ctx, d))\n-}\n-\n-fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingOkOrSomeInTailExpr) -> Option<Vec<Assist>> {\n-    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n-    let tail_expr = d.expr.value.to_node(&root);\n-    let tail_expr_range = tail_expr.syntax().text_range();\n-    let mut builder = TextEdit::builder();\n-    for_each_tail_expr(&tail_expr, &mut |expr| {\n-        if ctx.sema.type_of_expr(expr).map(TypeInfo::original).as_ref() != Some(&d.expected) {\n-            builder.insert(expr.syntax().text_range().start(), format!(\"{}(\", d.required));\n-            builder.insert(expr.syntax().text_range().end(), \")\".to_string());\n-        }\n-    });\n-    let source_change =\n-        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), builder.finish());\n-    let name = if d.required == \"Ok\" { \"Wrap with Ok\" } else { \"Wrap with Some\" };\n-    Some(vec![fix(\"wrap_tail_expr\", name, source_change, tail_expr_range)])\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::tests::{check_diagnostics, check_fix};\n-\n-    #[test]\n-    fn test_wrap_return_type_option() {\n-        check_fix(\n-            r#\"\n-//- minicore: option, result\n-fn div(x: i32, y: i32) -> Option<i32> {\n-    if y == 0 {\n-        return None;\n-    }\n-    x / y$0\n-}\n-\"#,\n-            r#\"\n-fn div(x: i32, y: i32) -> Option<i32> {\n-    if y == 0 {\n-        return None;\n-    }\n-    Some(x / y)\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type_option_tails() {\n-        check_fix(\n-            r#\"\n-//- minicore: option, result\n-fn div(x: i32, y: i32) -> Option<i32> {\n-    if y == 0 {\n-        0\n-    } else if true {\n-        100\n-    } else {\n-        None\n-    }$0\n-}\n-\"#,\n-            r#\"\n-fn div(x: i32, y: i32) -> Option<i32> {\n-    if y == 0 {\n-        Some(0)\n-    } else if true {\n-        Some(100)\n-    } else {\n-        None\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type() {\n-        check_fix(\n-            r#\"\n-//- minicore: option, result\n-fn div(x: i32, y: i32) -> Result<i32, ()> {\n-    if y == 0 {\n-        return Err(());\n-    }\n-    x / y$0\n-}\n-\"#,\n-            r#\"\n-fn div(x: i32, y: i32) -> Result<i32, ()> {\n-    if y == 0 {\n-        return Err(());\n-    }\n-    Ok(x / y)\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type_handles_generic_functions() {\n-        check_fix(\n-            r#\"\n-//- minicore: option, result\n-fn div<T>(x: T) -> Result<T, i32> {\n-    if x == 0 {\n-        return Err(7);\n-    }\n-    $0x\n-}\n-\"#,\n-            r#\"\n-fn div<T>(x: T) -> Result<T, i32> {\n-    if x == 0 {\n-        return Err(7);\n-    }\n-    Ok(x)\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type_handles_type_aliases() {\n-        check_fix(\n-            r#\"\n-//- minicore: option, result\n-type MyResult<T> = Result<T, ()>;\n-\n-fn div(x: i32, y: i32) -> MyResult<i32> {\n-    if y == 0 {\n-        return Err(());\n-    }\n-    x $0/ y\n-}\n-\"#,\n-            r#\"\n-type MyResult<T> = Result<T, ()>;\n-\n-fn div(x: i32, y: i32) -> MyResult<i32> {\n-    if y == 0 {\n-        return Err(());\n-    }\n-    Ok(x / y)\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_in_const_and_static() {\n-        check_fix(\n-            r#\"\n-//- minicore: option, result\n-static A: Option<()> = {($0)};\n-            \"#,\n-            r#\"\n-static A: Option<()> = {Some(())};\n-            \"#,\n-        );\n-        check_fix(\n-            r#\"\n-//- minicore: option, result\n-const _: Option<()> = {($0)};\n-            \"#,\n-            r#\"\n-const _: Option<()> = {Some(())};\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type_not_applicable_when_expr_type_does_not_match_ok_type() {\n-        check_diagnostics(\n-            r#\"\n-//- minicore: option, result\n-fn foo() -> Result<(), i32> { 0 }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type_not_applicable_when_return_type_is_not_result_or_option() {\n-        check_diagnostics(\n-            r#\"\n-//- minicore: option, result\n-enum SomeOtherEnum { Ok(i32), Err(String) }\n-\n-fn foo() -> SomeOtherEnum { 0 }\n-\"#,\n-        );\n-    }\n-}"}, {"sha": "571605ef26637e33d7a108367947f846429b9755", "filename": "crates/ide_diagnostics/src/handlers/type_mismatch.rs", "status": "modified", "additions": 224, "deletions": 4, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/0689fdb650b43c7a5dc3bb27655b2df6879d8387/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0689fdb650b43c7a5dc3bb27655b2df6879d8387/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs?ref=0689fdb650b43c7a5dc3bb27655b2df6879d8387", "patch": "@@ -1,5 +1,8 @@\n-use hir::{db::AstDatabase, HirDisplay, Type};\n-use ide_db::source_change::SourceChange;\n+use hir::{db::AstDatabase, HirDisplay, Type, TypeInfo};\n+use ide_db::{\n+    famous_defs::FamousDefs, source_change::SourceChange,\n+    syntax_helpers::node_ext::for_each_tail_expr,\n+};\n use syntax::{AstNode, TextRange};\n use text_edit::TextEdit;\n \n@@ -30,6 +33,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch) -> Option<Vec<Assi\n     let mut fixes = Vec::new();\n \n     add_reference(ctx, d, &mut fixes);\n+    add_missing_ok_or_some(ctx, d, &mut fixes);\n \n     if fixes.is_empty() {\n         None\n@@ -38,7 +42,11 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch) -> Option<Vec<Assi\n     }\n }\n \n-fn add_reference(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch, acc: &mut Vec<Assist>) -> Option<()> {\n+fn add_reference(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::TypeMismatch,\n+    acc: &mut Vec<Assist>,\n+) -> Option<()> {\n     let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n     let expr_node = d.expr.value.to_node(&root);\n \n@@ -59,9 +67,52 @@ fn add_reference(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch, acc: &mut\n     Some(())\n }\n \n+fn add_missing_ok_or_some(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::TypeMismatch,\n+    acc: &mut Vec<Assist>,\n+) -> Option<()> {\n+    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n+    let tail_expr = d.expr.value.to_node(&root);\n+    let tail_expr_range = tail_expr.syntax().text_range();\n+    let scope = ctx.sema.scope(tail_expr.syntax());\n+\n+    let expected_adt = d.expected.as_adt()?;\n+    let expected_enum = expected_adt.as_enum()?;\n+\n+    let famous_defs = FamousDefs(&ctx.sema, scope.krate());\n+    let core_result = famous_defs.core_result_Result();\n+    let core_option = famous_defs.core_option_Option();\n+\n+    if Some(expected_enum) != core_result && Some(expected_enum) != core_option {\n+        return None;\n+    }\n+\n+    let variant_name = if Some(expected_enum) == core_result { \"Ok\" } else { \"Some\" };\n+\n+    let wrapped_actual_ty = expected_adt.ty_with_args(ctx.sema.db, &[d.actual.clone()]);\n+\n+    if !d.expected.could_unify_with(ctx.sema.db, &wrapped_actual_ty) {\n+        return None;\n+    }\n+\n+    let mut builder = TextEdit::builder();\n+    for_each_tail_expr(&tail_expr, &mut |expr| {\n+        if ctx.sema.type_of_expr(expr).map(TypeInfo::adjusted).as_ref() != Some(&d.expected) {\n+            builder.insert(expr.syntax().text_range().start(), format!(\"{}(\", variant_name));\n+            builder.insert(expr.syntax().text_range().end(), \")\".to_string());\n+        }\n+    });\n+    let source_change =\n+        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), builder.finish());\n+    let name = format!(\"Wrap in {}\", variant_name);\n+    acc.push(fix(\"wrap_tail_expr\", &name, source_change, tail_expr_range));\n+    Some(())\n+}\n+\n #[cfg(test)]\n mod tests {\n-    use crate::tests::{check_diagnostics, check_fix};\n+    use crate::tests::{check_diagnostics, check_fix, check_no_fix};\n \n     #[test]\n     fn missing_reference() {\n@@ -217,4 +268,173 @@ fn main() {\n             \"#,\n         );\n     }\n+\n+    #[test]\n+    fn test_wrap_return_type_option() {\n+        check_fix(\n+            r#\"\n+//- minicore: option, result\n+fn div(x: i32, y: i32) -> Option<i32> {\n+    if y == 0 {\n+        return None;\n+    }\n+    x / y$0\n+}\n+\"#,\n+            r#\"\n+fn div(x: i32, y: i32) -> Option<i32> {\n+    if y == 0 {\n+        return None;\n+    }\n+    Some(x / y)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_option_tails() {\n+        check_fix(\n+            r#\"\n+//- minicore: option, result\n+fn div(x: i32, y: i32) -> Option<i32> {\n+    if y == 0 {\n+        0\n+    } else if true {\n+        100\n+    } else {\n+        None\n+    }$0\n+}\n+\"#,\n+            r#\"\n+fn div(x: i32, y: i32) -> Option<i32> {\n+    if y == 0 {\n+        Some(0)\n+    } else if true {\n+        Some(100)\n+    } else {\n+        None\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type() {\n+        check_fix(\n+            r#\"\n+//- minicore: option, result\n+fn div(x: i32, y: i32) -> Result<i32, ()> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    x / y$0\n+}\n+\"#,\n+            r#\"\n+fn div(x: i32, y: i32) -> Result<i32, ()> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    Ok(x / y)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_handles_generic_functions() {\n+        check_fix(\n+            r#\"\n+//- minicore: option, result\n+fn div<T>(x: T) -> Result<T, i32> {\n+    if x == 0 {\n+        return Err(7);\n+    }\n+    $0x\n+}\n+\"#,\n+            r#\"\n+fn div<T>(x: T) -> Result<T, i32> {\n+    if x == 0 {\n+        return Err(7);\n+    }\n+    Ok(x)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_handles_type_aliases() {\n+        check_fix(\n+            r#\"\n+//- minicore: option, result\n+type MyResult<T> = Result<T, ()>;\n+\n+fn div(x: i32, y: i32) -> MyResult<i32> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    x $0/ y\n+}\n+\"#,\n+            r#\"\n+type MyResult<T> = Result<T, ()>;\n+\n+fn div(x: i32, y: i32) -> MyResult<i32> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    Ok(x / y)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_in_const_and_static() {\n+        check_fix(\n+            r#\"\n+//- minicore: option, result\n+static A: Option<()> = {($0)};\n+            \"#,\n+            r#\"\n+static A: Option<()> = {Some(())};\n+            \"#,\n+        );\n+        check_fix(\n+            r#\"\n+//- minicore: option, result\n+const _: Option<()> = {($0)};\n+            \"#,\n+            r#\"\n+const _: Option<()> = {Some(())};\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_not_applicable_when_expr_type_does_not_match_ok_type() {\n+        check_no_fix(\n+            r#\"\n+//- minicore: option, result\n+fn foo() -> Result<(), i32> { 0$0 }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_not_applicable_when_return_type_is_not_result_or_option() {\n+        check_no_fix(\n+            r#\"\n+//- minicore: option, result\n+enum SomeOtherEnum { Ok(i32), Err(String) }\n+\n+fn foo() -> SomeOtherEnum { 0$0 }\n+\"#,\n+        );\n+    }\n }"}]}