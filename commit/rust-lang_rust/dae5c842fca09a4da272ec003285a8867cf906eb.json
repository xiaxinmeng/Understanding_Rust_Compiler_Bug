{"sha": "dae5c842fca09a4da272ec003285a8867cf906eb", "node_id": "C_kwDOAAsO6NoAKGRhZTVjODQyZmNhMDlhNGRhMjcyZWMwMDMyODVhODg2N2NmOTA2ZWI", "commit": {"author": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-03-24T22:25:03Z"}, "committer": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-04-11T19:18:53Z"}, "message": "Improve documentation of `Place` and `Operand`", "tree": {"sha": "02b15a1c681c0b06d8c3d17d603a445fb148e1f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02b15a1c681c0b06d8c3d17d603a445fb148e1f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dae5c842fca09a4da272ec003285a8867cf906eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dae5c842fca09a4da272ec003285a8867cf906eb", "html_url": "https://github.com/rust-lang/rust/commit/dae5c842fca09a4da272ec003285a8867cf906eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dae5c842fca09a4da272ec003285a8867cf906eb/comments", "author": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "625e4dd13a3abd0cc59807af66c3c4cd63440852", "url": "https://api.github.com/repos/rust-lang/rust/commits/625e4dd13a3abd0cc59807af66c3c4cd63440852", "html_url": "https://github.com/rust-lang/rust/commit/625e4dd13a3abd0cc59807af66c3c4cd63440852"}], "stats": {"total": 134, "additions": 121, "deletions": 13}, "files": [{"sha": "394bc12f015c1fc3eed66b005c2105e78f3f68f4", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 121, "deletions": 13, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/dae5c842fca09a4da272ec003285a8867cf906eb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae5c842fca09a4da272ec003285a8867cf906eb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=dae5c842fca09a4da272ec003285a8867cf906eb", "patch": "@@ -1785,8 +1785,98 @@ pub struct CopyNonOverlapping<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Places\n \n-/// A path to a value; something that can be evaluated without\n-/// changing or disturbing program state.\n+/// Places roughly correspond to a \"location in memory.\" Places in MIR are the same mathematical\n+/// object as places in Rust. This of course means that what exactly they are is undecided and part\n+/// of the Rust memory model. However, they will likely contain at least the following three pieces\n+/// of information in some form:\n+///\n+///  1. The part of memory that is referred to (see discussion below for details).\n+///  2. The type of the place and an optional variant index. See [`PlaceTy`][tcx::PlaceTy]\n+///  3. The provenance with which the place is being accessed.\n+///\n+/// We'll give a description below of how the first two of these three properties are computed for a\n+/// place. We cannot give a description of the provenance, because that is part of the undecided\n+/// aliasing model - we only include it here at all to acknowledge its existence.\n+///\n+/// For a place that has no projections, ie `Place { local, projection: [] }`, the part of memory is\n+/// the local's full allocation and the type is the type of the local. For any other place, we\n+/// define the values as a function of the parent place, that is the place with its last\n+/// [`ProjectionElem`] stripped. The way this is computed of course depends on the kind of that last\n+/// projection element:\n+///\n+///  - [`Downcast`](ProjectionElem::Downcast): This projection sets the place's variant index to the\n+///    given one, and makes no other changes. A `Downcast` projection on a place with its variant\n+///    index already set is not well-formed.\n+///  - [`Field`](ProjectionElem::Field): `Field` projections take their parent place and create a\n+///    place referring to one of the fields of the type. The referred to place in memory is where\n+///    the layout places the field. The type becomes the type of the field.\n+///\n+///    These projections are only legal for tuples, ADTs, closures, and generators. If the ADT or\n+///    generator has more than one variant, the parent place's variant index must be set, indicating\n+///    which variant is being used. If it has just one variant, the variant index may or may not be\n+///    included - the single possible variant is inferred if it is not included.\n+///  - [`ConstantIndex`](ProjectionElem::ConstantIndex): Computes an offset in units of `T` into the\n+///    place as described in the documentation for the `ProjectionElem`. The resulting part of\n+///    memory is the location of that element of the array/slice, and the type is `T`. This is only\n+///    legal if the parent place has type `[T;  N]` or `[T]` (*not* `&[T]`).\n+///  - [`Subslice`](ProjectionElem::Subslice): Much like `ConstantIndex`. It is also only legal on\n+///    `[T; N]` and `[T]`. However, this yields a `Place` of type `[T]`, and may refer to more than\n+///    one element in the parent place.\n+///  - [`Index`](ProjectionElem::Index): Like `ConstantIndex`, only legal on `[T; N]` or `[T]`.\n+///    However, `Index` additionally takes a local from which the value of the index is computed at\n+///    runtime. Computing the value of the index involves interpreting the `Local` as a\n+///    `Place { local, projection: [] }`, and then computing its value as if done via\n+///    [`Operand::Copy`]. The array/slice is then indexed with the resulting value. The local must\n+///    have type `usize`.\n+///  - [`Deref`](ProjectionElem::Deref): Derefs are the last type of projection, and the most\n+///    complicated. They are only legal on parent places that are references, pointers, or `Box`. A\n+///    `Deref` projection begins by creating a value from the parent place, as if by\n+///    [`Operand::Copy`]. It then dereferences the resulting pointer, creating a place of the\n+///    pointed to type.\n+///\n+/// **Needs clarification**: What about metadata resulting from dereferencing wide pointers (and\n+/// possibly from accessing unsized locals - not sure how those work)? That probably deserves to go\n+/// on the list above and be discussed too. It is also probably necessary for making the indexing\n+/// stuff lass hand-wavey.\n+///\n+/// **Needs clarification**: When it says \"part of memory\" what does that mean precisely, and how\n+/// does it interact with the metadata?\n+///\n+/// One possible model that I believe makes sense is that \"part of memory\" is actually just the\n+/// address of the beginning of the referred to range of bytes. For sized types, the size of the\n+/// range is then stored in the type, and for unsized types it's stored (possibly indirectly,\n+/// through a vtable) in the metadata.\n+///\n+/// Alternatively, the \"part of memory\" could be a whole range of bytes. Initially seemed more\n+/// natural to me, but seems like it falls apart after a little bit.\n+///\n+/// More likely though, we should call this detail a part of the Rust memory model and let that deal\n+/// with the precise definition of this part of a place. If we feel strongly, I don't think we *have\n+/// to* though. MIR places are more flexible than Rust places, and we might be able to make a\n+/// decision on the flexible parts without semi-stabilizing the source language. (end NC)\n+///\n+/// Computing a place may be UB - this is certainly the case with dereferencing, which requires\n+/// sufficient provenance, but it may additionally be the case for some of the other field\n+/// projections.\n+///\n+/// It is undecided when this UB kicks in. As best I can tell that is the question being discussed\n+/// in [UCG#319]. Summarizing from that thread, I believe the options are:\n+///\n+/// [UCG#319]: https://github.com/rust-lang/unsafe-code-guidelines/issues/319\n+///\n+///  1. Each intermediate place must have provenance for the whole part of memory it refers to. This\n+///     is the status quo.\n+///  2. Only for intermediate place where the last projection was *not* a deref. This corresponds to\n+///     \"Check inbounds on place projection\".\n+///  3. Only on place to value conversions, assignments, and referencing operation. This corresponds\n+///     to \"remove the restrictions from `*` entirely.\"\n+///  4. On each intermediate place if the place is used for a place to value conversion as part of\n+///     an assignment assignment or it is used for a referencing operation. For a raw pointer\n+///     computation, never. This corresponds to \"magic?\".\n+///\n+/// Hopefully I am not misrepresenting anyone's opinions - please let me know if I am. Currently,\n+/// Rust chooses option 1. This is checked by MIRI and taken advantage of by codegen (via `gep\n+/// inbounds`). That is possibly subject to change.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, HashStable)]\n pub struct Place<'tcx> {\n     pub local: Local,\n@@ -2155,24 +2245,42 @@ pub struct SourceScopeLocalData {\n ///////////////////////////////////////////////////////////////////////////\n // Operands\n \n-/// These are values that can appear inside an rvalue. They are intentionally\n-/// limited to prevent rvalues from being nested in one another.\n+/// An operand in MIR represents a \"value\" in Rust, the definition of which is undecided and part of\n+/// the memory model. One proposal for a definition of values can be found [on UCG][value-def].\n+///\n+/// [value-def]: https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\n+///\n+/// The most common way to create values is via a place to value conversion. A place to value\n+/// conversion is an operation which reads the memory of the place and converts it to a value. This\n+/// is a fundamentally *typed* operation. Different types will do different things. These are some\n+/// possible examples of what Rust may - but will not necessarily - decide to do on place to value\n+/// conversions:\n+///\n+///  1. Types with validity constraints cause UB if the validity constraint is not met\n+///  2. References/pointers may have their provenance change or cause other provenance related\n+///     side-effects.\n+///\n+/// A place to value conversion on a place that has its variant index set is not well-formed.\n+/// However, note that this rule only applies to places appearing in MIR bodies. Many functions,\n+/// such as [`Place::ty`], still accept such a place. If you write a function for which it might be\n+/// ambiguous whether such a thing is accepted, make sure to document your choice clearly.\n #[derive(Clone, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n pub enum Operand<'tcx> {\n-    /// Copy: The value must be available for use afterwards.\n-    ///\n-    /// This implies that the type of the place must be `Copy`; this is true\n-    /// by construction during build, but also checked by the MIR type checker.\n+    /// Creates a value by performing a place to value conversion at the given place. The type of\n+    /// the place must be `Copy`\n     Copy(Place<'tcx>),\n \n-    /// Move: The value (including old borrows of it) will not be used again.\n+    /// Creates a value by performing a place to value conversion for the place, just like the\n+    /// `Copy` operand.\n+    ///\n+    /// This *may* additionally overwrite the place with `uninit` bytes, depending on how we decide\n+    /// in [UCG#188]. You should not emit MIR that may attempt a subsequent second place to value\n+    /// conversion on this place without first re-initializing it.\n     ///\n-    /// Safe for values of all types (modulo future developments towards `?Move`).\n-    /// Correct usage patterns are enforced by the borrow checker for safe code.\n-    /// `Copy` may be converted to `Move` to enable \"last-use\" optimizations.\n+    /// [UCG#188]: https://github.com/rust-lang/unsafe-code-guidelines/issues/188\n     Move(Place<'tcx>),\n \n-    /// Synthesizes a constant value.\n+    /// Constants are already semantically values, and remain unchanged.\n     Constant(Box<Constant<'tcx>>),\n }\n "}]}