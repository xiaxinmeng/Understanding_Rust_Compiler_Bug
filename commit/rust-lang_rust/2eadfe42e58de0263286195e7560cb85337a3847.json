{"sha": "2eadfe42e58de0263286195e7560cb85337a3847", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYWRmZTQyZTU4ZGUwMjYzMjg2MTk1ZTc1NjBjYjg1MzM3YTM4NDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-15T04:16:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-15T04:16:20Z"}, "message": "auto merge of #15511 : brson/rust/extract-rustc-back, r=alexcrichton\n\nThis was my weekend project, to start breaking up rustc. It first pulls out LLVM into `rustc_llvm`, then parts of `rustc::back` and `rustc::util` to `rustc_back`. The immediate intent is just to reduce the size of rustc, to reduce memory pressure when building rustc, but this is also a good starting point for further refactoring.\r\n\r\nThe `rustc_back` crate is definitely misnamed (`rustc::back` was never a very cohesive module anyway) - it's mostly just somewhere to stuff parts of rustc that don't have many deps. Right now it's main dep is `syntax`; it has no dep on `rustc_llvm`.\r\n\r\nSome next steps might be to split `rustc_back` into `rustc_util` (with no `syntax` dep), and `rustc_syntax_util` (with a syntax dep); move the rest of `rustc::util` into `rustc_syntax_util`; move all of `rustc::front` to a new crate, `rustc_front`. At that point the refactoring necessary to keep extracting crates will get harder.", "tree": {"sha": "fad27715d3341c18b4707d83942143a71720bbf7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fad27715d3341c18b4707d83942143a71720bbf7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2eadfe42e58de0263286195e7560cb85337a3847", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2eadfe42e58de0263286195e7560cb85337a3847", "html_url": "https://github.com/rust-lang/rust/commit/2eadfe42e58de0263286195e7560cb85337a3847", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2eadfe42e58de0263286195e7560cb85337a3847/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1ae09e52a712f34de7823de55aaa6ef142c6fe9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ae09e52a712f34de7823de55aaa6ef142c6fe9", "html_url": "https://github.com/rust-lang/rust/commit/b1ae09e52a712f34de7823de55aaa6ef142c6fe9"}, {"sha": "a008fc84aaf429a1966c422297302cf809df796d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a008fc84aaf429a1966c422297302cf809df796d", "html_url": "https://github.com/rust-lang/rust/commit/a008fc84aaf429a1966c422297302cf809df796d"}], "stats": {"total": 5177, "additions": 2718, "deletions": 2459}, "files": [{"sha": "bc34fc2dcdfbb5cc771b32dae4351fbb7d59857d", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -86,5 +86,5 @@ src/etc/dl\n .settings/\n /build\n i686-pc-mingw32/\n-src/librustc/lib/llvmdeps.rs\n+src/librustc_llvm/llvmdeps.rs\n *.pot"}, {"sha": "c95576f6252aa3feca7b16ef2c458ec7de17f04e", "filename": "mk/crates.mk", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -53,7 +53,8 @@ TARGET_CRATES := libc std green rustuv native flate arena glob term semver \\\n                  uuid serialize sync getopts collections num test time rand \\\n                  url log regex graphviz core rlibc alloc debug rustrt \\\n                  unicode\n-HOST_CRATES := syntax rustc rustdoc fourcc hexfloat regex_macros fmt_macros\n+HOST_CRATES := syntax rustc rustdoc fourcc hexfloat regex_macros fmt_macros \\\n+\t       rustc_llvm rustc_back\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n \n@@ -70,8 +71,10 @@ DEPS_green := std native:context_switch\n DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std\n DEPS_syntax := std term serialize log fmt_macros debug\n-DEPS_rustc := syntax native:rustllvm flate arena serialize getopts \\\n-              time log graphviz debug\n+DEPS_rustc := syntax flate arena serialize getopts \\\n+              time log graphviz debug rustc_llvm rustc_back\n+DEPS_rustc_llvm := native:rustllvm libc std\n+DEPS_rustc_back := std syntax rustc_llvm flate log libc\n DEPS_rustdoc := rustc native:hoedown serialize getopts \\\n                 test time debug\n DEPS_flate := std native:miniz"}, {"sha": "177e4de310324dd6f2d3c1e35f0e50d5b80d8119", "filename": "mk/llvm.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/mk%2Fllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/mk%2Fllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fllvm.mk?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -57,7 +57,7 @@ $(foreach host,$(CFG_HOST), \\\n $(foreach host,$(CFG_HOST), \\\n  $(eval LLVM_CONFIGS := $(LLVM_CONFIGS) $(LLVM_CONFIG_$(host))))\n \n-$(S)src/librustc/lib/llvmdeps.rs: \\\n+$(S)src/librustc_llvm/llvmdeps.rs: \\\n \t\t    $(LLVM_CONFIGS) \\\n \t\t    $(S)src/etc/mklldeps.py \\\n \t\t    $(MKFILE_DEPS)"}, {"sha": "7da11a21a7cb7fe4927f397d75390870c32d766c", "filename": "mk/target.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -134,7 +134,7 @@ SNAPSHOT_RUSTC_POST_CLEANUP=$(HBIN0_H_$(CFG_BUILD))/rustc$(X_$(CFG_BUILD))\n \n define TARGET_HOST_RULES\n \n-$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.rustc: $(S)src/librustc/lib/llvmdeps.rs\n+$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.rustc_llvm: $(S)src/librustc_llvm/llvmdeps.rs\n \n $$(TBIN$(1)_T_$(2)_H_$(3))/:\n \tmkdir -p $$@"}, {"sha": "cad164c9e2019d0c271c5c7c00b3b2988cedffaf", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 84, "deletions": 40, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -8,16 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::archive::{Archive, METADATA_FILENAME};\n-use back::rpath;\n-use back::svh::Svh;\n+use super::archive::{Archive, ArchiveConfig, METADATA_FILENAME};\n+use super::rpath;\n+use super::rpath::RPathConfig;\n+use super::svh::Svh;\n use driver::driver::{CrateTranslation, OutputFilenames, Input, FileInput};\n use driver::config::NoDebugInfo;\n use driver::session::Session;\n use driver::config;\n-use lib::llvm::llvm;\n-use lib::llvm::ModuleRef;\n-use lib;\n+use llvm;\n+use llvm::ModuleRef;\n use metadata::common::LinkMeta;\n use metadata::{encoder, cstore, filesearch, csearch, loader, creader};\n use middle::trans::context::CrateContext;\n@@ -29,6 +29,7 @@ use util::sha2::{Digest, Sha256};\n \n use std::c_str::{ToCStr, CString};\n use std::char;\n+use std::collections::HashSet;\n use std::io::{fs, TempDir, Command};\n use std::io;\n use std::ptr;\n@@ -70,11 +71,11 @@ pub fn llvm_err(sess: &Session, msg: String) -> ! {\n \n pub fn write_output_file(\n         sess: &Session,\n-        target: lib::llvm::TargetMachineRef,\n-        pm: lib::llvm::PassManagerRef,\n+        target: llvm::TargetMachineRef,\n+        pm: llvm::PassManagerRef,\n         m: ModuleRef,\n         output: &Path,\n-        file_type: lib::llvm::FileType) {\n+        file_type: llvm::FileType) {\n     unsafe {\n         output.with_c_str(|output| {\n             let result = llvm::LLVMRustWriteOutputFile(\n@@ -88,18 +89,17 @@ pub fn write_output_file(\n \n pub mod write {\n \n-    use back::lto;\n-    use back::link::{write_output_file, OutputType};\n-    use back::link::{OutputTypeAssembly, OutputTypeBitcode};\n-    use back::link::{OutputTypeExe, OutputTypeLlvmAssembly};\n-    use back::link::{OutputTypeObject};\n+    use super::super::lto;\n+    use super::{write_output_file, OutputType};\n+    use super::{OutputTypeAssembly, OutputTypeBitcode};\n+    use super::{OutputTypeExe, OutputTypeLlvmAssembly};\n+    use super::{OutputTypeObject};\n     use driver::driver::{CrateTranslation, OutputFilenames};\n     use driver::config::NoDebugInfo;\n     use driver::session::Session;\n     use driver::config;\n-    use lib::llvm::llvm;\n-    use lib::llvm::{ModuleRef, TargetMachineRef, PassManagerRef};\n-    use lib;\n+    use llvm;\n+    use llvm::{ModuleRef, TargetMachineRef, PassManagerRef};\n     use util::common::time;\n     use syntax::abi;\n \n@@ -152,10 +152,10 @@ pub mod write {\n             }\n \n             let opt_level = match sess.opts.optimize {\n-              config::No => lib::llvm::CodeGenLevelNone,\n-              config::Less => lib::llvm::CodeGenLevelLess,\n-              config::Default => lib::llvm::CodeGenLevelDefault,\n-              config::Aggressive => lib::llvm::CodeGenLevelAggressive,\n+              config::No => llvm::CodeGenLevelNone,\n+              config::Less => llvm::CodeGenLevelLess,\n+              config::Default => llvm::CodeGenLevelDefault,\n+              config::Aggressive => llvm::CodeGenLevelAggressive,\n             };\n             let use_softfp = sess.opts.cg.soft_float;\n \n@@ -172,10 +172,10 @@ pub mod write {\n             let fdata_sections = ffunction_sections;\n \n             let reloc_model = match sess.opts.cg.relocation_model.as_slice() {\n-                \"pic\" => lib::llvm::RelocPIC,\n-                \"static\" => lib::llvm::RelocStatic,\n-                \"default\" => lib::llvm::RelocDefault,\n-                \"dynamic-no-pic\" => lib::llvm::RelocDynamicNoPic,\n+                \"pic\" => llvm::RelocPIC,\n+                \"static\" => llvm::RelocStatic,\n+                \"default\" => llvm::RelocDefault,\n+                \"dynamic-no-pic\" => llvm::RelocDynamicNoPic,\n                 _ => {\n                     sess.err(format!(\"{} is not a valid relocation mode\",\n                                      sess.opts\n@@ -195,7 +195,7 @@ pub mod write {\n                     target_feature(sess).with_c_str(|features| {\n                         llvm::LLVMRustCreateTargetMachine(\n                             t, cpu, features,\n-                            lib::llvm::CodeModelDefault,\n+                            llvm::CodeModelDefault,\n                             reloc_model,\n                             opt_level,\n                             true /* EnableSegstk */,\n@@ -320,7 +320,7 @@ pub mod write {\n                         };\n                         with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n                             write_output_file(sess, tm, cpm, llmod, &path,\n-                                            lib::llvm::AssemblyFile);\n+                                            llvm::AssemblyFile);\n                         });\n                     }\n                     OutputTypeObject => {\n@@ -338,7 +338,7 @@ pub mod write {\n                     Some(ref path) => {\n                         with_codegen(tm, llmod, trans.no_builtins, |cpm| {\n                             write_output_file(sess, tm, cpm, llmod, path,\n-                                            lib::llvm::ObjectFile);\n+                                            llvm::ObjectFile);\n                         });\n                     }\n                     None => {}\n@@ -350,7 +350,7 @@ pub mod write {\n                                         .with_extension(\"metadata.o\");\n                         write_output_file(sess, tm, cpm,\n                                         trans.metadata_module, &out,\n-                                        lib::llvm::ObjectFile);\n+                                        llvm::ObjectFile);\n                     })\n                 }\n             });\n@@ -455,29 +455,29 @@ pub mod write {\n         });\n     }\n \n-    unsafe fn populate_llvm_passes(fpm: lib::llvm::PassManagerRef,\n-                                   mpm: lib::llvm::PassManagerRef,\n+    unsafe fn populate_llvm_passes(fpm: llvm::PassManagerRef,\n+                                   mpm: llvm::PassManagerRef,\n                                    llmod: ModuleRef,\n-                                   opt: lib::llvm::CodeGenOptLevel,\n+                                   opt: llvm::CodeGenOptLevel,\n                                    no_builtins: bool) {\n         // Create the PassManagerBuilder for LLVM. We configure it with\n         // reasonable defaults and prepare it to actually populate the pass\n         // manager.\n         let builder = llvm::LLVMPassManagerBuilderCreate();\n         match opt {\n-            lib::llvm::CodeGenLevelNone => {\n+            llvm::CodeGenLevelNone => {\n                 // Don't add lifetime intrinsics at O0\n                 llvm::LLVMRustAddAlwaysInlinePass(builder, false);\n             }\n-            lib::llvm::CodeGenLevelLess => {\n+            llvm::CodeGenLevelLess => {\n                 llvm::LLVMRustAddAlwaysInlinePass(builder, true);\n             }\n             // numeric values copied from clang\n-            lib::llvm::CodeGenLevelDefault => {\n+            llvm::CodeGenLevelDefault => {\n                 llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n                                                                     225);\n             }\n-            lib::llvm::CodeGenLevelAggressive => {\n+            llvm::CodeGenLevelAggressive => {\n                 llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n                                                                     275);\n             }\n@@ -611,7 +611,7 @@ pub fn build_link_meta(sess: &Session, krate: &ast::Crate,\n                        name: String) -> LinkMeta {\n     let r = LinkMeta {\n         crate_name: name,\n-        crate_hash: Svh::calculate(sess, krate),\n+        crate_hash: Svh::calculate(&sess.opts.cg.metadata, krate),\n     };\n     info!(\"{}\", r);\n     return r;\n@@ -963,6 +963,17 @@ fn link_binary_output(sess: &Session,\n     out_filename\n }\n \n+fn archive_search_paths(sess: &Session) -> Vec<Path> {\n+    let mut rustpath = filesearch::rust_path();\n+    rustpath.push(sess.target_filesearch().get_lib_path());\n+    // FIXME: Addl lib search paths are an unordered HashSet?\n+    // Shouldn't this search be done in some order?\n+    let addl_lib_paths: HashSet<Path> = sess.opts.addl_lib_search_paths.borrow().clone();\n+    let mut search: Vec<Path> = addl_lib_paths.move_iter().collect();\n+    search.push_all(rustpath.as_slice());\n+    return search;\n+}\n+\n // Create an 'rlib'\n //\n // An rlib in its current incarnation is essentially a renamed .a file. The\n@@ -973,7 +984,15 @@ fn link_rlib<'a>(sess: &'a Session,\n                  trans: Option<&CrateTranslation>, // None == no metadata/bytecode\n                  obj_filename: &Path,\n                  out_filename: &Path) -> Archive<'a> {\n-    let mut a = Archive::create(sess, out_filename, obj_filename);\n+    let handler = &sess.diagnostic().handler;\n+    let config = ArchiveConfig {\n+        handler: handler,\n+        dst: out_filename.clone(),\n+        lib_search_paths: archive_search_paths(sess),\n+        os: sess.targ_cfg.os,\n+        maybe_ar_prog: sess.opts.cg.ar.clone()\n+    };\n+    let mut a = Archive::create(config, obj_filename);\n \n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {\n@@ -1387,7 +1406,24 @@ fn link_args(cmd: &mut Command,\n     // where extern libraries might live, based on the\n     // addl_lib_search_paths\n     if sess.opts.cg.rpath {\n-        cmd.args(rpath::get_rpath_flags(sess, out_filename).as_slice());\n+        let sysroot = sess.sysroot();\n+        let target_triple = sess.opts.target_triple.as_slice();\n+        let get_install_prefix_lib_path = || {\n+            let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n+            let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n+            let mut path = Path::new(install_prefix);\n+            path.push(&tlib);\n+\n+            path\n+        };\n+        let rpath_config = RPathConfig {\n+            os: sess.targ_cfg.os,\n+            used_crates: sess.cstore.get_used_crates(cstore::RequireDynamic),\n+            out_filename: out_filename.clone(),\n+            get_install_prefix_lib_path: get_install_prefix_lib_path,\n+            realpath: ::util::fs::realpath\n+        };\n+        cmd.args(rpath::get_rpath_flags(rpath_config).as_slice());\n     }\n \n     // compiler-rt contains implementations of low-level LLVM helpers. This is\n@@ -1545,7 +1581,15 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                         sess.abort_if_errors();\n                     }\n                 }\n-                let mut archive = Archive::open(sess, dst.clone());\n+                let handler = &sess.diagnostic().handler;\n+                let config = ArchiveConfig {\n+                    handler: handler,\n+                    dst: dst.clone(),\n+                    lib_search_paths: archive_search_paths(sess),\n+                    os: sess.targ_cfg.os,\n+                    maybe_ar_prog: sess.opts.cg.ar.clone()\n+                };\n+                let mut archive = Archive::open(config);\n                 archive.remove_file(format!(\"{}.o\", name).as_slice());\n                 let files = archive.files();\n                 if files.iter().any(|s| s.as_slice().ends_with(\".o\")) {"}, {"sha": "6184ea4591f084ae5041f04c56372e6cd516d8f5", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::archive::ArchiveRO;\n-use back::link;\n+use super::link;\n use driver::session;\n use driver::config;\n-use lib::llvm::{ModuleRef, TargetMachineRef, llvm, True, False};\n+use llvm;\n+use llvm::archive_ro::ArchiveRO;\n+use llvm::{ModuleRef, TargetMachineRef, True, False};\n use metadata::cstore;\n use util::common::time;\n "}, {"sha": "232a1252f596cf40e501225dc86c1eaac5ccd748", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -33,10 +33,10 @@ use syntax::parse::token::InternedString;\n use std::collections::{HashSet, HashMap};\n use getopts::{optopt, optmulti, optflag, optflagopt};\n use getopts;\n-use lib::llvm::llvm;\n use std::cell::{RefCell};\n use std::fmt;\n \n+use llvm;\n \n pub struct Config {\n     pub os: abi::Os,"}, {"sha": "2149504a67ae72219803a7c2a7e9f9bb2100e8f6", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -15,8 +15,8 @@ use driver::{config, PpMode};\n use driver::{PpmFlowGraph, PpmExpanded, PpmExpandedIdentified, PpmTyped};\n use driver::{PpmIdentified};\n use front;\n-use lib::llvm::{ContextRef, ModuleRef};\n use lint;\n+use llvm::{ContextRef, ModuleRef};\n use metadata::common::LinkMeta;\n use metadata::creader;\n use middle::cfg;"}, {"sha": "e850b71dda8cca9266632398d1234a1069977dd2", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -292,7 +292,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     }\n \n     if cg_flags.contains(&\"passes=list\".to_string()) {\n-        unsafe { ::lib::llvm::llvm::LLVMRustPrintPasses(); }\n+        unsafe { ::llvm::LLVMRustPrintPasses(); }\n         return None;\n     }\n "}, {"sha": "92d1c176a1b92c8b28d8ef2faf7b2b56d6a6c811", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -41,13 +41,32 @@ extern crate flate;\n extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n+extern crate llvm = \"rustc_llvm\";\n+extern crate rustc_back = \"rustc_back\";\n extern crate serialize;\n extern crate time;\n #[phase(plugin, link)] extern crate log;\n #[phase(plugin, link)] extern crate syntax;\n \n mod diagnostics;\n \n+pub mod back {\n+    pub use rustc_back::abi;\n+    pub use rustc_back::archive;\n+    pub use rustc_back::arm;\n+    pub use rustc_back::mips;\n+    pub use rustc_back::mipsel;\n+    pub use rustc_back::rpath;\n+    pub use rustc_back::svh;\n+    pub use rustc_back::target_strs;\n+    pub use rustc_back::x86;\n+    pub use rustc_back::x86_64;\n+\n+    pub mod link;\n+    pub mod lto;\n+\n+}\n+\n pub mod middle {\n     pub mod def;\n     pub mod trans;\n@@ -96,21 +115,6 @@ pub mod front {\n     pub mod show_span;\n }\n \n-pub mod back {\n-    pub mod abi;\n-    pub mod archive;\n-    pub mod arm;\n-    pub mod link;\n-    pub mod lto;\n-    pub mod mips;\n-    pub mod mipsel;\n-    pub mod rpath;\n-    pub mod svh;\n-    pub mod target_strs;\n-    pub mod x86;\n-    pub mod x86_64;\n-}\n-\n pub mod metadata;\n \n pub mod driver;\n@@ -120,16 +124,16 @@ pub mod plugin;\n pub mod lint;\n \n pub mod util {\n+    pub use rustc_back::fs;\n+    pub use rustc_back::sha2;\n+\n     pub mod common;\n     pub mod ppaux;\n-    pub mod sha2;\n     pub mod nodemap;\n-    pub mod fs;\n }\n \n pub mod lib {\n-    pub mod llvm;\n-    pub mod llvmdeps;\n+    pub use llvm;\n }\n \n __build_diagnostic_array!(DIAGNOSTICS)"}, {"sha": "a4425183cde64ad79f46fa646d43ab8aca5b3e3c", "filename": "src/librustc/lib/llvm.rs", "status": "removed", "additions": 0, "deletions": 1983, "changes": 1983, "blob_url": "https://github.com/rust-lang/rust/blob/b1ae09e52a712f34de7823de55aaa6ef142c6fe9/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ae09e52a712f34de7823de55aaa6ef142c6fe9/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=b1ae09e52a712f34de7823de55aaa6ef142c6fe9", "patch": "@@ -1,1983 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(non_uppercase_pattern_statics)]\n-#![allow(non_camel_case_types)]\n-#![allow(non_snake_case_functions)]\n-#![allow(dead_code)]\n-\n-use std::c_str::ToCStr;\n-use std::cell::RefCell;\n-use std::collections::HashMap;\n-use libc::{c_uint, c_ushort, c_void, free, uint64_t};\n-use std::str::raw::from_c_str;\n-\n-use middle::trans::type_::Type;\n-\n-pub type Opcode = u32;\n-pub type Bool = c_uint;\n-\n-pub static True: Bool = 1 as Bool;\n-pub static False: Bool = 0 as Bool;\n-\n-// Consts for the LLVM CallConv type, pre-cast to uint.\n-\n-#[deriving(PartialEq)]\n-pub enum CallConv {\n-    CCallConv = 0,\n-    FastCallConv = 8,\n-    ColdCallConv = 9,\n-    X86StdcallCallConv = 64,\n-    X86FastcallCallConv = 65,\n-    X86_64_Win64 = 79,\n-}\n-\n-pub enum Visibility {\n-    LLVMDefaultVisibility = 0,\n-    HiddenVisibility = 1,\n-    ProtectedVisibility = 2,\n-}\n-\n-// This enum omits the obsolete (and no-op) linkage types DLLImportLinkage,\n-// DLLExportLinkage, GhostLinkage and LinkOnceODRAutoHideLinkage.\n-// LinkerPrivateLinkage and LinkerPrivateWeakLinkage are not included either;\n-// they've been removed in upstream LLVM commit r203866.\n-pub enum Linkage {\n-    ExternalLinkage = 0,\n-    AvailableExternallyLinkage = 1,\n-    LinkOnceAnyLinkage = 2,\n-    LinkOnceODRLinkage = 3,\n-    WeakAnyLinkage = 5,\n-    WeakODRLinkage = 6,\n-    AppendingLinkage = 7,\n-    InternalLinkage = 8,\n-    PrivateLinkage = 9,\n-    ExternalWeakLinkage = 12,\n-    CommonLinkage = 14,\n-}\n-\n-#[deriving(Clone)]\n-pub enum Attribute {\n-    ZExtAttribute = 1 << 0,\n-    SExtAttribute = 1 << 1,\n-    NoReturnAttribute = 1 << 2,\n-    InRegAttribute = 1 << 3,\n-    StructRetAttribute = 1 << 4,\n-    NoUnwindAttribute = 1 << 5,\n-    NoAliasAttribute = 1 << 6,\n-    ByValAttribute = 1 << 7,\n-    NestAttribute = 1 << 8,\n-    ReadNoneAttribute = 1 << 9,\n-    ReadOnlyAttribute = 1 << 10,\n-    NoInlineAttribute = 1 << 11,\n-    AlwaysInlineAttribute = 1 << 12,\n-    OptimizeForSizeAttribute = 1 << 13,\n-    StackProtectAttribute = 1 << 14,\n-    StackProtectReqAttribute = 1 << 15,\n-    AlignmentAttribute = 31 << 16,\n-    NoCaptureAttribute = 1 << 21,\n-    NoRedZoneAttribute = 1 << 22,\n-    NoImplicitFloatAttribute = 1 << 23,\n-    NakedAttribute = 1 << 24,\n-    InlineHintAttribute = 1 << 25,\n-    StackAttribute = 7 << 26,\n-    ReturnsTwiceAttribute = 1 << 29,\n-    UWTableAttribute = 1 << 30,\n-    NonLazyBindAttribute = 1 << 31,\n-}\n-\n-#[repr(u64)]\n-pub enum OtherAttribute {\n-    // The following are not really exposed in\n-    // the LLVM c api so instead to add these\n-    // we call a wrapper function in RustWrapper\n-    // that uses the C++ api.\n-    SanitizeAddressAttribute = 1 << 32,\n-    MinSizeAttribute = 1 << 33,\n-    NoDuplicateAttribute = 1 << 34,\n-    StackProtectStrongAttribute = 1 << 35,\n-    SanitizeThreadAttribute = 1 << 36,\n-    SanitizeMemoryAttribute = 1 << 37,\n-    NoBuiltinAttribute = 1 << 38,\n-    ReturnedAttribute = 1 << 39,\n-    ColdAttribute = 1 << 40,\n-    BuiltinAttribute = 1 << 41,\n-    OptimizeNoneAttribute = 1 << 42,\n-    InAllocaAttribute = 1 << 43,\n-    NonNullAttribute = 1 << 44,\n-}\n-\n-#[repr(C)]\n-pub enum AttributeSet {\n-    ReturnIndex = 0,\n-    FunctionIndex = !0\n-}\n-\n-// enum for the LLVM IntPredicate type\n-pub enum IntPredicate {\n-    IntEQ = 32,\n-    IntNE = 33,\n-    IntUGT = 34,\n-    IntUGE = 35,\n-    IntULT = 36,\n-    IntULE = 37,\n-    IntSGT = 38,\n-    IntSGE = 39,\n-    IntSLT = 40,\n-    IntSLE = 41,\n-}\n-\n-// enum for the LLVM RealPredicate type\n-pub enum RealPredicate {\n-    RealPredicateFalse = 0,\n-    RealOEQ = 1,\n-    RealOGT = 2,\n-    RealOGE = 3,\n-    RealOLT = 4,\n-    RealOLE = 5,\n-    RealONE = 6,\n-    RealORD = 7,\n-    RealUNO = 8,\n-    RealUEQ = 9,\n-    RealUGT = 10,\n-    RealUGE = 11,\n-    RealULT = 12,\n-    RealULE = 13,\n-    RealUNE = 14,\n-    RealPredicateTrue = 15,\n-}\n-\n-// The LLVM TypeKind type - must stay in sync with the def of\n-// LLVMTypeKind in llvm/include/llvm-c/Core.h\n-#[deriving(PartialEq)]\n-#[repr(C)]\n-pub enum TypeKind {\n-    Void      = 0,\n-    Half      = 1,\n-    Float     = 2,\n-    Double    = 3,\n-    X86_FP80  = 4,\n-    FP128     = 5,\n-    PPC_FP128 = 6,\n-    Label     = 7,\n-    Integer   = 8,\n-    Function  = 9,\n-    Struct    = 10,\n-    Array     = 11,\n-    Pointer   = 12,\n-    Vector    = 13,\n-    Metadata  = 14,\n-    X86_MMX   = 15,\n-}\n-\n-#[repr(C)]\n-pub enum AtomicBinOp {\n-    Xchg = 0,\n-    Add  = 1,\n-    Sub  = 2,\n-    And  = 3,\n-    Nand = 4,\n-    Or   = 5,\n-    Xor  = 6,\n-    Max  = 7,\n-    Min  = 8,\n-    UMax = 9,\n-    UMin = 10,\n-}\n-\n-#[repr(C)]\n-pub enum AtomicOrdering {\n-    NotAtomic = 0,\n-    Unordered = 1,\n-    Monotonic = 2,\n-    // Consume = 3,  // Not specified yet.\n-    Acquire = 4,\n-    Release = 5,\n-    AcquireRelease = 6,\n-    SequentiallyConsistent = 7\n-}\n-\n-// Consts for the LLVMCodeGenFileType type (in include/llvm/c/TargetMachine.h)\n-#[repr(C)]\n-pub enum FileType {\n-    AssemblyFile = 0,\n-    ObjectFile = 1\n-}\n-\n-pub enum Metadata {\n-    MD_dbg = 0,\n-    MD_tbaa = 1,\n-    MD_prof = 2,\n-    MD_fpmath = 3,\n-    MD_range = 4,\n-    MD_tbaa_struct = 5\n-}\n-\n-// Inline Asm Dialect\n-pub enum AsmDialect {\n-    AD_ATT   = 0,\n-    AD_Intel = 1\n-}\n-\n-#[deriving(PartialEq)]\n-#[repr(C)]\n-pub enum CodeGenOptLevel {\n-    CodeGenLevelNone = 0,\n-    CodeGenLevelLess = 1,\n-    CodeGenLevelDefault = 2,\n-    CodeGenLevelAggressive = 3,\n-}\n-\n-#[repr(C)]\n-pub enum RelocMode {\n-    RelocDefault = 0,\n-    RelocStatic = 1,\n-    RelocPIC = 2,\n-    RelocDynamicNoPic = 3,\n-}\n-\n-#[repr(C)]\n-pub enum CodeGenModel {\n-    CodeModelDefault = 0,\n-    CodeModelJITDefault = 1,\n-    CodeModelSmall = 2,\n-    CodeModelKernel = 3,\n-    CodeModelMedium = 4,\n-    CodeModelLarge = 5,\n-}\n-\n-// Opaque pointer types\n-pub enum Module_opaque {}\n-pub type ModuleRef = *mut Module_opaque;\n-pub enum Context_opaque {}\n-pub type ContextRef = *mut Context_opaque;\n-pub enum Type_opaque {}\n-pub type TypeRef = *mut Type_opaque;\n-pub enum Value_opaque {}\n-pub type ValueRef = *mut Value_opaque;\n-pub enum BasicBlock_opaque {}\n-pub type BasicBlockRef = *mut BasicBlock_opaque;\n-pub enum Builder_opaque {}\n-pub type BuilderRef = *mut Builder_opaque;\n-pub enum ExecutionEngine_opaque {}\n-pub type ExecutionEngineRef = *mut ExecutionEngine_opaque;\n-pub enum MemoryBuffer_opaque {}\n-pub type MemoryBufferRef = *mut MemoryBuffer_opaque;\n-pub enum PassManager_opaque {}\n-pub type PassManagerRef = *mut PassManager_opaque;\n-pub enum PassManagerBuilder_opaque {}\n-pub type PassManagerBuilderRef = *mut PassManagerBuilder_opaque;\n-pub enum Use_opaque {}\n-pub type UseRef = *mut Use_opaque;\n-pub enum TargetData_opaque {}\n-pub type TargetDataRef = *mut TargetData_opaque;\n-pub enum ObjectFile_opaque {}\n-pub type ObjectFileRef = *mut ObjectFile_opaque;\n-pub enum SectionIterator_opaque {}\n-pub type SectionIteratorRef = *mut SectionIterator_opaque;\n-pub enum Pass_opaque {}\n-pub type PassRef = *mut Pass_opaque;\n-pub enum TargetMachine_opaque {}\n-pub type TargetMachineRef = *mut TargetMachine_opaque;\n-pub enum Archive_opaque {}\n-pub type ArchiveRef = *mut Archive_opaque;\n-\n-pub mod debuginfo {\n-    use super::{ValueRef};\n-\n-    pub enum DIBuilder_opaque {}\n-    pub type DIBuilderRef = *mut DIBuilder_opaque;\n-\n-    pub type DIDescriptor = ValueRef;\n-    pub type DIScope = DIDescriptor;\n-    pub type DILocation = DIDescriptor;\n-    pub type DIFile = DIScope;\n-    pub type DILexicalBlock = DIScope;\n-    pub type DISubprogram = DIScope;\n-    pub type DIType = DIDescriptor;\n-    pub type DIBasicType = DIType;\n-    pub type DIDerivedType = DIType;\n-    pub type DICompositeType = DIDerivedType;\n-    pub type DIVariable = DIDescriptor;\n-    pub type DIGlobalVariable = DIDescriptor;\n-    pub type DIArray = DIDescriptor;\n-    pub type DISubrange = DIDescriptor;\n-\n-    pub enum DIDescriptorFlags {\n-      FlagPrivate            = 1 << 0,\n-      FlagProtected          = 1 << 1,\n-      FlagFwdDecl            = 1 << 2,\n-      FlagAppleBlock         = 1 << 3,\n-      FlagBlockByrefStruct   = 1 << 4,\n-      FlagVirtual            = 1 << 5,\n-      FlagArtificial         = 1 << 6,\n-      FlagExplicit           = 1 << 7,\n-      FlagPrototyped         = 1 << 8,\n-      FlagObjcClassComplete  = 1 << 9,\n-      FlagObjectPointer      = 1 << 10,\n-      FlagVector             = 1 << 11,\n-      FlagStaticMember       = 1 << 12\n-    }\n-}\n-\n-pub mod llvm {\n-    use super::{AtomicBinOp, AtomicOrdering, BasicBlockRef, ExecutionEngineRef};\n-    use super::{Bool, BuilderRef, ContextRef, MemoryBufferRef, ModuleRef};\n-    use super::{ObjectFileRef, Opcode, PassManagerRef, PassManagerBuilderRef};\n-    use super::{SectionIteratorRef, TargetDataRef, TypeKind, TypeRef, UseRef};\n-    use super::{ValueRef, TargetMachineRef, FileType, ArchiveRef};\n-    use super::{CodeGenModel, RelocMode, CodeGenOptLevel};\n-    use super::debuginfo::*;\n-    use libc::{c_char, c_int, c_longlong, c_ushort, c_uint, c_ulonglong,\n-               size_t, uint64_t};\n-\n-    // Link to our native llvm bindings (things that we need to use the C++ api\n-    // for) and because llvm is written in C++ we need to link against libstdc++\n-    //\n-    // You'll probably notice that there is an omission of all LLVM libraries\n-    // from this location. This is because the set of LLVM libraries that we\n-    // link to is mostly defined by LLVM, and the `llvm-config` tool is used to\n-    // figure out the exact set of libraries. To do this, the build system\n-    // generates an llvmdeps.rs file next to this one which will be\n-    // automatically updated whenever LLVM is updated to include an up-to-date\n-    // set of the libraries we need to link to LLVM for.\n-    #[link(name = \"rustllvm\", kind = \"static\")]\n-    extern {\n-        /* Create and destroy contexts. */\n-        pub fn LLVMContextCreate() -> ContextRef;\n-        pub fn LLVMContextDispose(C: ContextRef);\n-        pub fn LLVMGetMDKindIDInContext(C: ContextRef,\n-                                        Name: *const c_char,\n-                                        SLen: c_uint)\n-                                        -> c_uint;\n-\n-        /* Create and destroy modules. */\n-        pub fn LLVMModuleCreateWithNameInContext(ModuleID: *const c_char,\n-                                                 C: ContextRef)\n-                                                 -> ModuleRef;\n-        pub fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n-        pub fn LLVMDisposeModule(M: ModuleRef);\n-\n-        /** Data layout. See Module::getDataLayout. */\n-        pub fn LLVMGetDataLayout(M: ModuleRef) -> *const c_char;\n-        pub fn LLVMSetDataLayout(M: ModuleRef, Triple: *const c_char);\n-\n-        /** Target triple. See Module::getTargetTriple. */\n-        pub fn LLVMGetTarget(M: ModuleRef) -> *const c_char;\n-        pub fn LLVMSetTarget(M: ModuleRef, Triple: *const c_char);\n-\n-        /** See Module::dump. */\n-        pub fn LLVMDumpModule(M: ModuleRef);\n-\n-        /** See Module::setModuleInlineAsm. */\n-        pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n-\n-        /** See llvm::LLVMTypeKind::getTypeID. */\n-        pub fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n-\n-        /** See llvm::LLVMType::getContext. */\n-        pub fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n-\n-        /* Operations on integer types */\n-        pub fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n-        pub fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n-        pub fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n-        pub fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n-        pub fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n-        pub fn LLVMIntTypeInContext(C: ContextRef, NumBits: c_uint)\n-                                    -> TypeRef;\n-\n-        pub fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n-\n-        /* Operations on real types */\n-        pub fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n-        pub fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n-        pub fn LLVMX86FP80TypeInContext(C: ContextRef) -> TypeRef;\n-        pub fn LLVMFP128TypeInContext(C: ContextRef) -> TypeRef;\n-        pub fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n-\n-        /* Operations on function types */\n-        pub fn LLVMFunctionType(ReturnType: TypeRef,\n-                                ParamTypes: *const TypeRef,\n-                                ParamCount: c_uint,\n-                                IsVarArg: Bool)\n-                                -> TypeRef;\n-        pub fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n-        pub fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n-        pub fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n-        pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *const TypeRef);\n-\n-        /* Operations on struct types */\n-        pub fn LLVMStructTypeInContext(C: ContextRef,\n-                                       ElementTypes: *const TypeRef,\n-                                       ElementCount: c_uint,\n-                                       Packed: Bool)\n-                                       -> TypeRef;\n-        pub fn LLVMCountStructElementTypes(StructTy: TypeRef) -> c_uint;\n-        pub fn LLVMGetStructElementTypes(StructTy: TypeRef,\n-                                         Dest: *mut TypeRef);\n-        pub fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n-\n-        /* Operations on array, pointer, and vector types (sequence types) */\n-        pub fn LLVMRustArrayType(ElementType: TypeRef, ElementCount: u64) -> TypeRef;\n-        pub fn LLVMPointerType(ElementType: TypeRef, AddressSpace: c_uint)\n-                               -> TypeRef;\n-        pub fn LLVMVectorType(ElementType: TypeRef, ElementCount: c_uint)\n-                              -> TypeRef;\n-\n-        pub fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n-        pub fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n-        pub fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n-        pub fn LLVMGetPointerToGlobal(EE: ExecutionEngineRef, V: ValueRef)\n-                                      -> *const ();\n-        pub fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n-\n-        /* Operations on other types */\n-        pub fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n-        pub fn LLVMLabelTypeInContext(C: ContextRef) -> TypeRef;\n-        pub fn LLVMMetadataTypeInContext(C: ContextRef) -> TypeRef;\n-\n-        /* Operations on all values */\n-        pub fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n-        pub fn LLVMGetValueName(Val: ValueRef) -> *const c_char;\n-        pub fn LLVMSetValueName(Val: ValueRef, Name: *const c_char);\n-        pub fn LLVMDumpValue(Val: ValueRef);\n-        pub fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n-        pub fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n-        pub fn LLVMGetMetadata(Val: ValueRef, KindID: c_uint) -> ValueRef;\n-        pub fn LLVMSetMetadata(Val: ValueRef, KindID: c_uint, Node: ValueRef);\n-\n-        /* Operations on Uses */\n-        pub fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n-        pub fn LLVMGetNextUse(U: UseRef) -> UseRef;\n-        pub fn LLVMGetUser(U: UseRef) -> ValueRef;\n-        pub fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n-\n-        /* Operations on Users */\n-        pub fn LLVMGetNumOperands(Val: ValueRef) -> c_int;\n-        pub fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n-        pub fn LLVMSetOperand(Val: ValueRef, Index: c_uint, Op: ValueRef);\n-\n-        /* Operations on constants of any type */\n-        pub fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n-        /* all zeroes */\n-        pub fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n-        pub fn LLVMConstICmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n-                             -> ValueRef;\n-        pub fn LLVMConstFCmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n-                             -> ValueRef;\n-        /* only for int/vector */\n-        pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n-        pub fn LLVMIsConstant(Val: ValueRef) -> Bool;\n-        pub fn LLVMIsNull(Val: ValueRef) -> Bool;\n-        pub fn LLVMIsUndef(Val: ValueRef) -> Bool;\n-        pub fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n-\n-        /* Operations on metadata */\n-        pub fn LLVMMDStringInContext(C: ContextRef,\n-                                     Str: *const c_char,\n-                                     SLen: c_uint)\n-                                     -> ValueRef;\n-        pub fn LLVMMDNodeInContext(C: ContextRef,\n-                                   Vals: *const ValueRef,\n-                                   Count: c_uint)\n-                                   -> ValueRef;\n-        pub fn LLVMAddNamedMetadataOperand(M: ModuleRef,\n-                                           Str: *const c_char,\n-                                           Val: ValueRef);\n-\n-        /* Operations on scalar constants */\n-        pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool)\n-                            -> ValueRef;\n-        pub fn LLVMConstIntOfString(IntTy: TypeRef, Text: *const c_char, Radix: u8)\n-                                    -> ValueRef;\n-        pub fn LLVMConstIntOfStringAndSize(IntTy: TypeRef,\n-                                           Text: *const c_char,\n-                                           SLen: c_uint,\n-                                           Radix: u8)\n-                                           -> ValueRef;\n-        pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n-        pub fn LLVMConstRealOfString(RealTy: TypeRef, Text: *const c_char)\n-                                     -> ValueRef;\n-        pub fn LLVMConstRealOfStringAndSize(RealTy: TypeRef,\n-                                            Text: *const c_char,\n-                                            SLen: c_uint)\n-                                            -> ValueRef;\n-        pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n-        pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n-\n-\n-        /* Operations on composite constants */\n-        pub fn LLVMConstStringInContext(C: ContextRef,\n-                                        Str: *const c_char,\n-                                        Length: c_uint,\n-                                        DontNullTerminate: Bool)\n-                                        -> ValueRef;\n-        pub fn LLVMConstStructInContext(C: ContextRef,\n-                                        ConstantVals: *const ValueRef,\n-                                        Count: c_uint,\n-                                        Packed: Bool)\n-                                        -> ValueRef;\n-\n-        pub fn LLVMConstArray(ElementTy: TypeRef,\n-                              ConstantVals: *const ValueRef,\n-                              Length: c_uint)\n-                              -> ValueRef;\n-        pub fn LLVMConstVector(ScalarConstantVals: *const ValueRef, Size: c_uint)\n-                               -> ValueRef;\n-\n-        /* Constant expressions */\n-        pub fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n-        pub fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n-        pub fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n-        pub fn LLVMConstNSWNeg(ConstantVal: ValueRef) -> ValueRef;\n-        pub fn LLVMConstNUWNeg(ConstantVal: ValueRef) -> ValueRef;\n-        pub fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n-        pub fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n-        pub fn LLVMConstAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                            -> ValueRef;\n-        pub fn LLVMConstNSWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                               -> ValueRef;\n-        pub fn LLVMConstNUWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                               -> ValueRef;\n-        pub fn LLVMConstFAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                             -> ValueRef;\n-        pub fn LLVMConstSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                            -> ValueRef;\n-        pub fn LLVMConstNSWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                               -> ValueRef;\n-        pub fn LLVMConstNUWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                               -> ValueRef;\n-        pub fn LLVMConstFSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                             -> ValueRef;\n-        pub fn LLVMConstMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                            -> ValueRef;\n-        pub fn LLVMConstNSWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                               -> ValueRef;\n-        pub fn LLVMConstNUWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                               -> ValueRef;\n-        pub fn LLVMConstFMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                             -> ValueRef;\n-        pub fn LLVMConstUDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                             -> ValueRef;\n-        pub fn LLVMConstSDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                             -> ValueRef;\n-        pub fn LLVMConstExactSDiv(LHSConstant: ValueRef,\n-                                  RHSConstant: ValueRef)\n-                                  -> ValueRef;\n-        pub fn LLVMConstFDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                             -> ValueRef;\n-        pub fn LLVMConstURem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                             -> ValueRef;\n-        pub fn LLVMConstSRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                             -> ValueRef;\n-        pub fn LLVMConstFRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                             -> ValueRef;\n-        pub fn LLVMConstAnd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                            -> ValueRef;\n-        pub fn LLVMConstOr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                           -> ValueRef;\n-        pub fn LLVMConstXor(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                            -> ValueRef;\n-        pub fn LLVMConstShl(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                            -> ValueRef;\n-        pub fn LLVMConstLShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                             -> ValueRef;\n-        pub fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n-                             -> ValueRef;\n-        pub fn LLVMConstGEP(ConstantVal: ValueRef,\n-                            ConstantIndices: *const ValueRef,\n-                            NumIndices: c_uint)\n-                            -> ValueRef;\n-        pub fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n-                                    ConstantIndices: *const ValueRef,\n-                                    NumIndices: c_uint)\n-                                    -> ValueRef;\n-        pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n-                              -> ValueRef;\n-        pub fn LLVMConstSExt(ConstantVal: ValueRef, ToType: TypeRef)\n-                             -> ValueRef;\n-        pub fn LLVMConstZExt(ConstantVal: ValueRef, ToType: TypeRef)\n-                             -> ValueRef;\n-        pub fn LLVMConstFPTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n-                                -> ValueRef;\n-        pub fn LLVMConstFPExt(ConstantVal: ValueRef, ToType: TypeRef)\n-                              -> ValueRef;\n-        pub fn LLVMConstUIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n-                               -> ValueRef;\n-        pub fn LLVMConstSIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n-                               -> ValueRef;\n-        pub fn LLVMConstFPToUI(ConstantVal: ValueRef, ToType: TypeRef)\n-                               -> ValueRef;\n-        pub fn LLVMConstFPToSI(ConstantVal: ValueRef, ToType: TypeRef)\n-                               -> ValueRef;\n-        pub fn LLVMConstPtrToInt(ConstantVal: ValueRef, ToType: TypeRef)\n-                                 -> ValueRef;\n-        pub fn LLVMConstIntToPtr(ConstantVal: ValueRef, ToType: TypeRef)\n-                                 -> ValueRef;\n-        pub fn LLVMConstBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                -> ValueRef;\n-        pub fn LLVMConstZExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                      -> ValueRef;\n-        pub fn LLVMConstSExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                      -> ValueRef;\n-        pub fn LLVMConstTruncOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                       -> ValueRef;\n-        pub fn LLVMConstPointerCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                                    -> ValueRef;\n-        pub fn LLVMConstIntCast(ConstantVal: ValueRef,\n-                                ToType: TypeRef,\n-                                isSigned: Bool)\n-                                -> ValueRef;\n-        pub fn LLVMConstFPCast(ConstantVal: ValueRef, ToType: TypeRef)\n-                               -> ValueRef;\n-        pub fn LLVMConstSelect(ConstantCondition: ValueRef,\n-                               ConstantIfTrue: ValueRef,\n-                               ConstantIfFalse: ValueRef)\n-                               -> ValueRef;\n-        pub fn LLVMConstExtractElement(VectorConstant: ValueRef,\n-                                       IndexConstant: ValueRef)\n-                                       -> ValueRef;\n-        pub fn LLVMConstInsertElement(VectorConstant: ValueRef,\n-                                      ElementValueConstant: ValueRef,\n-                                      IndexConstant: ValueRef)\n-                                      -> ValueRef;\n-        pub fn LLVMConstShuffleVector(VectorAConstant: ValueRef,\n-                                      VectorBConstant: ValueRef,\n-                                      MaskConstant: ValueRef)\n-                                      -> ValueRef;\n-        pub fn LLVMConstExtractValue(AggConstant: ValueRef,\n-                                     IdxList: *const c_uint,\n-                                     NumIdx: c_uint)\n-                                     -> ValueRef;\n-        pub fn LLVMConstInsertValue(AggConstant: ValueRef,\n-                                    ElementValueConstant: ValueRef,\n-                                    IdxList: *const c_uint,\n-                                    NumIdx: c_uint)\n-                                    -> ValueRef;\n-        pub fn LLVMConstInlineAsm(Ty: TypeRef,\n-                                  AsmString: *const c_char,\n-                                  Constraints: *const c_char,\n-                                  HasSideEffects: Bool,\n-                                  IsAlignStack: Bool)\n-                                  -> ValueRef;\n-        pub fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef) -> ValueRef;\n-\n-\n-\n-        /* Operations on global variables, functions, and aliases (globals) */\n-        pub fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n-        pub fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n-        pub fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n-        pub fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n-        pub fn LLVMGetSection(Global: ValueRef) -> *const c_char;\n-        pub fn LLVMSetSection(Global: ValueRef, Section: *const c_char);\n-        pub fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n-        pub fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n-        pub fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n-        pub fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n-\n-\n-        /* Operations on global variables */\n-        pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMAddGlobalInAddressSpace(M: ModuleRef,\n-                                           Ty: TypeRef,\n-                                           Name: *const c_char,\n-                                           AddressSpace: c_uint)\n-                                           -> ValueRef;\n-        pub fn LLVMGetNamedGlobal(M: ModuleRef, Name: *const c_char) -> ValueRef;\n-        pub fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n-        pub fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n-        pub fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n-        pub fn LLVMGetPreviousGlobal(GlobalVar: ValueRef) -> ValueRef;\n-        pub fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n-        pub fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n-        pub fn LLVMSetInitializer(GlobalVar: ValueRef,\n-                                         ConstantVal: ValueRef);\n-        pub fn LLVMIsThreadLocal(GlobalVar: ValueRef) -> Bool;\n-        pub fn LLVMSetThreadLocal(GlobalVar: ValueRef, IsThreadLocal: Bool);\n-        pub fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n-        pub fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n-\n-        /* Operations on aliases */\n-        pub fn LLVMAddAlias(M: ModuleRef,\n-                            Ty: TypeRef,\n-                            Aliasee: ValueRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-\n-        /* Operations on functions */\n-        pub fn LLVMAddFunction(M: ModuleRef,\n-                               Name: *const c_char,\n-                               FunctionTy: TypeRef)\n-                               -> ValueRef;\n-        pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;\n-        pub fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n-        pub fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n-        pub fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n-        pub fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n-        pub fn LLVMDeleteFunction(Fn: ValueRef);\n-        pub fn LLVMGetOrInsertFunction(M: ModuleRef,\n-                                       Name: *const c_char,\n-                                       FunctionTy: TypeRef)\n-                                       -> ValueRef;\n-        pub fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n-        pub fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n-        pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n-        pub fn LLVMGetGC(Fn: ValueRef) -> *const c_char;\n-        pub fn LLVMSetGC(Fn: ValueRef, Name: *const c_char);\n-        pub fn LLVMAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: uint64_t);\n-        pub fn LLVMAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n-        pub fn LLVMRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n-        pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_ulonglong;\n-\n-        /* Operations on parameters */\n-        pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n-        pub fn LLVMGetParams(Fn: ValueRef, Params: *const ValueRef);\n-        pub fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n-        pub fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n-        pub fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n-        pub fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n-        pub fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n-        pub fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n-        pub fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n-        pub fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n-        pub fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n-        pub fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n-\n-        /* Operations on basic blocks */\n-        pub fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n-        pub fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n-        pub fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n-        pub fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n-        pub fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n-        pub fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *const ValueRef);\n-        pub fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-        pub fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-        pub fn LLVMGetNextBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n-        pub fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n-        pub fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n-\n-        pub fn LLVMAppendBasicBlockInContext(C: ContextRef,\n-                                             Fn: ValueRef,\n-                                             Name: *const c_char)\n-                                             -> BasicBlockRef;\n-        pub fn LLVMInsertBasicBlockInContext(C: ContextRef,\n-                                             BB: BasicBlockRef,\n-                                             Name: *const c_char)\n-                                             -> BasicBlockRef;\n-        pub fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n-\n-        pub fn LLVMMoveBasicBlockAfter(BB: BasicBlockRef,\n-                                       MoveAfter: BasicBlockRef);\n-\n-        pub fn LLVMMoveBasicBlockBefore(BB: BasicBlockRef,\n-                                        MoveBefore: BasicBlockRef);\n-\n-        /* Operations on instructions */\n-        pub fn LLVMGetInstructionParent(Inst: ValueRef) -> BasicBlockRef;\n-        pub fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n-        pub fn LLVMGetLastInstruction(BB: BasicBlockRef) -> ValueRef;\n-        pub fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n-        pub fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n-        pub fn LLVMInstructionEraseFromParent(Inst: ValueRef);\n-\n-        /* Operations on call sites */\n-        pub fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n-        pub fn LLVMGetInstructionCallConv(Instr: ValueRef) -> c_uint;\n-        pub fn LLVMAddInstrAttribute(Instr: ValueRef,\n-                                     index: c_uint,\n-                                     IA: c_uint);\n-        pub fn LLVMRemoveInstrAttribute(Instr: ValueRef,\n-                                        index: c_uint,\n-                                        IA: c_uint);\n-        pub fn LLVMSetInstrParamAlignment(Instr: ValueRef,\n-                                          index: c_uint,\n-                                          align: c_uint);\n-        pub fn LLVMAddCallSiteAttribute(Instr: ValueRef,\n-                                        index: c_uint,\n-                                        Val: uint64_t);\n-\n-        /* Operations on call instructions (only) */\n-        pub fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n-        pub fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n-\n-        /* Operations on load/store instructions (only) */\n-        pub fn LLVMGetVolatile(MemoryAccessInst: ValueRef) -> Bool;\n-        pub fn LLVMSetVolatile(MemoryAccessInst: ValueRef, volatile: Bool);\n-\n-        /* Operations on phi nodes */\n-        pub fn LLVMAddIncoming(PhiNode: ValueRef,\n-                               IncomingValues: *const ValueRef,\n-                               IncomingBlocks: *const BasicBlockRef,\n-                               Count: c_uint);\n-        pub fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n-        pub fn LLVMGetIncomingValue(PhiNode: ValueRef, Index: c_uint)\n-                                    -> ValueRef;\n-        pub fn LLVMGetIncomingBlock(PhiNode: ValueRef, Index: c_uint)\n-                                    -> BasicBlockRef;\n-\n-        /* Instruction builders */\n-        pub fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n-        pub fn LLVMPositionBuilder(Builder: BuilderRef,\n-                                   Block: BasicBlockRef,\n-                                   Instr: ValueRef);\n-        pub fn LLVMPositionBuilderBefore(Builder: BuilderRef,\n-                                         Instr: ValueRef);\n-        pub fn LLVMPositionBuilderAtEnd(Builder: BuilderRef,\n-                                        Block: BasicBlockRef);\n-        pub fn LLVMGetInsertBlock(Builder: BuilderRef) -> BasicBlockRef;\n-        pub fn LLVMClearInsertionPosition(Builder: BuilderRef);\n-        pub fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n-        pub fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef,\n-                                             Instr: ValueRef,\n-                                             Name: *const c_char);\n-        pub fn LLVMDisposeBuilder(Builder: BuilderRef);\n-        pub fn LLVMDisposeExecutionEngine(EE: ExecutionEngineRef);\n-\n-        /* Metadata */\n-        pub fn LLVMSetCurrentDebugLocation(Builder: BuilderRef, L: ValueRef);\n-        pub fn LLVMGetCurrentDebugLocation(Builder: BuilderRef) -> ValueRef;\n-        pub fn LLVMSetInstDebugLocation(Builder: BuilderRef, Inst: ValueRef);\n-\n-        /* Terminators */\n-        pub fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n-        pub fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n-        pub fn LLVMBuildAggregateRet(B: BuilderRef,\n-                                     RetVals: *const ValueRef,\n-                                     N: c_uint)\n-                                     -> ValueRef;\n-        pub fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n-        pub fn LLVMBuildCondBr(B: BuilderRef,\n-                               If: ValueRef,\n-                               Then: BasicBlockRef,\n-                               Else: BasicBlockRef)\n-                               -> ValueRef;\n-        pub fn LLVMBuildSwitch(B: BuilderRef,\n-                               V: ValueRef,\n-                               Else: BasicBlockRef,\n-                               NumCases: c_uint)\n-                               -> ValueRef;\n-        pub fn LLVMBuildIndirectBr(B: BuilderRef,\n-                                   Addr: ValueRef,\n-                                   NumDests: c_uint)\n-                                   -> ValueRef;\n-        pub fn LLVMBuildInvoke(B: BuilderRef,\n-                               Fn: ValueRef,\n-                               Args: *const ValueRef,\n-                               NumArgs: c_uint,\n-                               Then: BasicBlockRef,\n-                               Catch: BasicBlockRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildLandingPad(B: BuilderRef,\n-                                   Ty: TypeRef,\n-                                   PersFn: ValueRef,\n-                                   NumClauses: c_uint,\n-                                   Name: *const c_char)\n-                                   -> ValueRef;\n-        pub fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n-        pub fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n-\n-        /* Add a case to the switch instruction */\n-        pub fn LLVMAddCase(Switch: ValueRef,\n-                           OnVal: ValueRef,\n-                           Dest: BasicBlockRef);\n-\n-        /* Add a destination to the indirectbr instruction */\n-        pub fn LLVMAddDestination(IndirectBr: ValueRef, Dest: BasicBlockRef);\n-\n-        /* Add a clause to the landing pad instruction */\n-        pub fn LLVMAddClause(LandingPad: ValueRef, ClauseVal: ValueRef);\n-\n-        /* Set the cleanup on a landing pad instruction */\n-        pub fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n-\n-        /* Arithmetic */\n-        pub fn LLVMBuildAdd(B: BuilderRef,\n-                            LHS: ValueRef,\n-                            RHS: ValueRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-        pub fn LLVMBuildNSWAdd(B: BuilderRef,\n-                               LHS: ValueRef,\n-                               RHS: ValueRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildNUWAdd(B: BuilderRef,\n-                               LHS: ValueRef,\n-                               RHS: ValueRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildFAdd(B: BuilderRef,\n-                             LHS: ValueRef,\n-                             RHS: ValueRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildSub(B: BuilderRef,\n-                            LHS: ValueRef,\n-                            RHS: ValueRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-        pub fn LLVMBuildNSWSub(B: BuilderRef,\n-                               LHS: ValueRef,\n-                               RHS: ValueRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildNUWSub(B: BuilderRef,\n-                               LHS: ValueRef,\n-                               RHS: ValueRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildFSub(B: BuilderRef,\n-                             LHS: ValueRef,\n-                             RHS: ValueRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildMul(B: BuilderRef,\n-                            LHS: ValueRef,\n-                            RHS: ValueRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-        pub fn LLVMBuildNSWMul(B: BuilderRef,\n-                               LHS: ValueRef,\n-                               RHS: ValueRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildNUWMul(B: BuilderRef,\n-                               LHS: ValueRef,\n-                               RHS: ValueRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildFMul(B: BuilderRef,\n-                             LHS: ValueRef,\n-                             RHS: ValueRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildUDiv(B: BuilderRef,\n-                             LHS: ValueRef,\n-                             RHS: ValueRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildSDiv(B: BuilderRef,\n-                             LHS: ValueRef,\n-                             RHS: ValueRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildExactSDiv(B: BuilderRef,\n-                                  LHS: ValueRef,\n-                                  RHS: ValueRef,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-        pub fn LLVMBuildFDiv(B: BuilderRef,\n-                             LHS: ValueRef,\n-                             RHS: ValueRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildURem(B: BuilderRef,\n-                             LHS: ValueRef,\n-                             RHS: ValueRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildSRem(B: BuilderRef,\n-                             LHS: ValueRef,\n-                             RHS: ValueRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildFRem(B: BuilderRef,\n-                             LHS: ValueRef,\n-                             RHS: ValueRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildShl(B: BuilderRef,\n-                            LHS: ValueRef,\n-                            RHS: ValueRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-        pub fn LLVMBuildLShr(B: BuilderRef,\n-                             LHS: ValueRef,\n-                             RHS: ValueRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildAShr(B: BuilderRef,\n-                             LHS: ValueRef,\n-                             RHS: ValueRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildAnd(B: BuilderRef,\n-                            LHS: ValueRef,\n-                            RHS: ValueRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-        pub fn LLVMBuildOr(B: BuilderRef,\n-                           LHS: ValueRef,\n-                           RHS: ValueRef,\n-                           Name: *const c_char)\n-                           -> ValueRef;\n-        pub fn LLVMBuildXor(B: BuilderRef,\n-                            LHS: ValueRef,\n-                            RHS: ValueRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-        pub fn LLVMBuildBinOp(B: BuilderRef,\n-                              Op: Opcode,\n-                              LHS: ValueRef,\n-                              RHS: ValueRef,\n-                              Name: *const c_char)\n-                              -> ValueRef;\n-        pub fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                            -> ValueRef;\n-        pub fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *const c_char)\n-                            -> ValueRef;\n-\n-        /* Memory */\n-        pub fn LLVMBuildMalloc(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildArrayMalloc(B: BuilderRef,\n-                                    Ty: TypeRef,\n-                                    Val: ValueRef,\n-                                    Name: *const c_char)\n-                                    -> ValueRef;\n-        pub fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildArrayAlloca(B: BuilderRef,\n-                                    Ty: TypeRef,\n-                                    Val: ValueRef,\n-                                    Name: *const c_char)\n-                                    -> ValueRef;\n-        pub fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n-        pub fn LLVMBuildLoad(B: BuilderRef,\n-                             PointerVal: ValueRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-\n-        pub fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef)\n-                              -> ValueRef;\n-\n-        pub fn LLVMBuildGEP(B: BuilderRef,\n-                            Pointer: ValueRef,\n-                            Indices: *const ValueRef,\n-                            NumIndices: c_uint,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n-        pub fn LLVMBuildInBoundsGEP(B: BuilderRef,\n-                                    Pointer: ValueRef,\n-                                    Indices: *const ValueRef,\n-                                    NumIndices: c_uint,\n-                                    Name: *const c_char)\n-                                    -> ValueRef;\n-        pub fn LLVMBuildStructGEP(B: BuilderRef,\n-                                  Pointer: ValueRef,\n-                                  Idx: c_uint,\n-                                  Name: *const c_char)\n-                                  -> ValueRef;\n-        pub fn LLVMBuildGlobalString(B: BuilderRef,\n-                                     Str: *const c_char,\n-                                     Name: *const c_char)\n-                                     -> ValueRef;\n-        pub fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n-                                        Str: *const c_char,\n-                                        Name: *const c_char)\n-                                        -> ValueRef;\n-\n-        /* Casts */\n-        pub fn LLVMBuildTrunc(B: BuilderRef,\n-                              Val: ValueRef,\n-                              DestTy: TypeRef,\n-                              Name: *const c_char)\n-                              -> ValueRef;\n-        pub fn LLVMBuildZExt(B: BuilderRef,\n-                             Val: ValueRef,\n-                             DestTy: TypeRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildSExt(B: BuilderRef,\n-                             Val: ValueRef,\n-                             DestTy: TypeRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildFPToUI(B: BuilderRef,\n-                               Val: ValueRef,\n-                               DestTy: TypeRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildFPToSI(B: BuilderRef,\n-                               Val: ValueRef,\n-                               DestTy: TypeRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildUIToFP(B: BuilderRef,\n-                               Val: ValueRef,\n-                               DestTy: TypeRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildSIToFP(B: BuilderRef,\n-                               Val: ValueRef,\n-                               DestTy: TypeRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildFPTrunc(B: BuilderRef,\n-                                Val: ValueRef,\n-                                DestTy: TypeRef,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-        pub fn LLVMBuildFPExt(B: BuilderRef,\n-                              Val: ValueRef,\n-                              DestTy: TypeRef,\n-                              Name: *const c_char)\n-                              -> ValueRef;\n-        pub fn LLVMBuildPtrToInt(B: BuilderRef,\n-                                 Val: ValueRef,\n-                                 DestTy: TypeRef,\n-                                 Name: *const c_char)\n-                                 -> ValueRef;\n-        pub fn LLVMBuildIntToPtr(B: BuilderRef,\n-                                 Val: ValueRef,\n-                                 DestTy: TypeRef,\n-                                 Name: *const c_char)\n-                                 -> ValueRef;\n-        pub fn LLVMBuildBitCast(B: BuilderRef,\n-                                Val: ValueRef,\n-                                DestTy: TypeRef,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-        pub fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n-                                      Val: ValueRef,\n-                                      DestTy: TypeRef,\n-                                      Name: *const c_char)\n-                                      -> ValueRef;\n-        pub fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n-                                      Val: ValueRef,\n-                                      DestTy: TypeRef,\n-                                      Name: *const c_char)\n-                                      -> ValueRef;\n-        pub fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n-                                       Val: ValueRef,\n-                                       DestTy: TypeRef,\n-                                       Name: *const c_char)\n-                                       -> ValueRef;\n-        pub fn LLVMBuildCast(B: BuilderRef,\n-                             Op: Opcode,\n-                             Val: ValueRef,\n-                             DestTy: TypeRef,\n-                             Name: *const c_char) -> ValueRef;\n-        pub fn LLVMBuildPointerCast(B: BuilderRef,\n-                                    Val: ValueRef,\n-                                    DestTy: TypeRef,\n-                                    Name: *const c_char)\n-                                    -> ValueRef;\n-        pub fn LLVMBuildIntCast(B: BuilderRef,\n-                                Val: ValueRef,\n-                                DestTy: TypeRef,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-        pub fn LLVMBuildFPCast(B: BuilderRef,\n-                               Val: ValueRef,\n-                               DestTy: TypeRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-\n-        /* Comparisons */\n-        pub fn LLVMBuildICmp(B: BuilderRef,\n-                             Op: c_uint,\n-                             LHS: ValueRef,\n-                             RHS: ValueRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildFCmp(B: BuilderRef,\n-                             Op: c_uint,\n-                             LHS: ValueRef,\n-                             RHS: ValueRef,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-\n-        /* Miscellaneous instructions */\n-        pub fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n-                            -> ValueRef;\n-        pub fn LLVMBuildCall(B: BuilderRef,\n-                             Fn: ValueRef,\n-                             Args: *const ValueRef,\n-                             NumArgs: c_uint,\n-                             Name: *const c_char)\n-                             -> ValueRef;\n-        pub fn LLVMBuildSelect(B: BuilderRef,\n-                               If: ValueRef,\n-                               Then: ValueRef,\n-                               Else: ValueRef,\n-                               Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildVAArg(B: BuilderRef,\n-                              list: ValueRef,\n-                              Ty: TypeRef,\n-                              Name: *const c_char)\n-                              -> ValueRef;\n-        pub fn LLVMBuildExtractElement(B: BuilderRef,\n-                                       VecVal: ValueRef,\n-                                       Index: ValueRef,\n-                                       Name: *const c_char)\n-                                       -> ValueRef;\n-        pub fn LLVMBuildInsertElement(B: BuilderRef,\n-                                      VecVal: ValueRef,\n-                                      EltVal: ValueRef,\n-                                      Index: ValueRef,\n-                                      Name: *const c_char)\n-                                      -> ValueRef;\n-        pub fn LLVMBuildShuffleVector(B: BuilderRef,\n-                                      V1: ValueRef,\n-                                      V2: ValueRef,\n-                                      Mask: ValueRef,\n-                                      Name: *const c_char)\n-                                      -> ValueRef;\n-        pub fn LLVMBuildExtractValue(B: BuilderRef,\n-                                     AggVal: ValueRef,\n-                                     Index: c_uint,\n-                                     Name: *const c_char)\n-                                     -> ValueRef;\n-        pub fn LLVMBuildInsertValue(B: BuilderRef,\n-                                    AggVal: ValueRef,\n-                                    EltVal: ValueRef,\n-                                    Index: c_uint,\n-                                    Name: *const c_char)\n-                                    -> ValueRef;\n-\n-        pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n-                               -> ValueRef;\n-        pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n-                                  -> ValueRef;\n-        pub fn LLVMBuildPtrDiff(B: BuilderRef,\n-                                LHS: ValueRef,\n-                                RHS: ValueRef,\n-                                Name: *const c_char)\n-                                -> ValueRef;\n-\n-        /* Atomic Operations */\n-        pub fn LLVMBuildAtomicLoad(B: BuilderRef,\n-                                   PointerVal: ValueRef,\n-                                   Name: *const c_char,\n-                                   Order: AtomicOrdering,\n-                                   Alignment: c_uint)\n-                                   -> ValueRef;\n-\n-        pub fn LLVMBuildAtomicStore(B: BuilderRef,\n-                                    Val: ValueRef,\n-                                    Ptr: ValueRef,\n-                                    Order: AtomicOrdering,\n-                                    Alignment: c_uint)\n-                                    -> ValueRef;\n-\n-        pub fn LLVMBuildAtomicCmpXchg(B: BuilderRef,\n-                                      LHS: ValueRef,\n-                                      CMP: ValueRef,\n-                                      RHS: ValueRef,\n-                                      Order: AtomicOrdering,\n-                                      FailureOrder: AtomicOrdering)\n-                                      -> ValueRef;\n-        pub fn LLVMBuildAtomicRMW(B: BuilderRef,\n-                                  Op: AtomicBinOp,\n-                                  LHS: ValueRef,\n-                                  RHS: ValueRef,\n-                                  Order: AtomicOrdering,\n-                                  SingleThreaded: Bool)\n-                                  -> ValueRef;\n-\n-        pub fn LLVMBuildAtomicFence(B: BuilderRef, Order: AtomicOrdering);\n-\n-\n-        /* Selected entries from the downcasts. */\n-        pub fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n-        pub fn LLVMIsAStoreInst(Inst: ValueRef) -> ValueRef;\n-\n-        /** Writes a module to the specified path. Returns 0 on success. */\n-        pub fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *const c_char) -> c_int;\n-\n-        /** Creates target data from a target layout string. */\n-        pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n-        /// Adds the target data to the given pass manager. The pass manager\n-        /// references the target data only weakly.\n-        pub fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n-        /** Number of bytes clobbered when doing a Store to *T. */\n-        pub fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef)\n-                                   -> c_ulonglong;\n-\n-        /** Number of bytes clobbered when doing a Store to *T. */\n-        pub fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef)\n-                                    -> c_ulonglong;\n-\n-        /** Distance between successive elements in an array of T.\n-        Includes ABI padding. */\n-        pub fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_uint;\n-\n-        /** Returns the preferred alignment of a type. */\n-        pub fn LLVMPreferredAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n-                                            -> c_uint;\n-        /** Returns the minimum alignment of a type. */\n-        pub fn LLVMABIAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n-                                      -> c_uint;\n-\n-        /// Computes the byte offset of the indexed struct element for a\n-        /// target.\n-        pub fn LLVMOffsetOfElement(TD: TargetDataRef,\n-                                   StructTy: TypeRef,\n-                                   Element: c_uint)\n-                                   -> c_ulonglong;\n-\n-        /**\n-         * Returns the minimum alignment of a type when part of a call frame.\n-         */\n-        pub fn LLVMCallFrameAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n-                                            -> c_uint;\n-\n-        /** Disposes target data. */\n-        pub fn LLVMDisposeTargetData(TD: TargetDataRef);\n-\n-        /** Creates a pass manager. */\n-        pub fn LLVMCreatePassManager() -> PassManagerRef;\n-\n-        /** Creates a function-by-function pass manager */\n-        pub fn LLVMCreateFunctionPassManagerForModule(M: ModuleRef)\n-                                                      -> PassManagerRef;\n-\n-        /** Disposes a pass manager. */\n-        pub fn LLVMDisposePassManager(PM: PassManagerRef);\n-\n-        /** Runs a pass manager on a module. */\n-        pub fn LLVMRunPassManager(PM: PassManagerRef, M: ModuleRef) -> Bool;\n-\n-        /** Runs the function passes on the provided function. */\n-        pub fn LLVMRunFunctionPassManager(FPM: PassManagerRef, F: ValueRef)\n-                                          -> Bool;\n-\n-        /** Initializes all the function passes scheduled in the manager */\n-        pub fn LLVMInitializeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n-\n-        /** Finalizes all the function passes scheduled in the manager */\n-        pub fn LLVMFinalizeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n-\n-        pub fn LLVMInitializePasses();\n-\n-        /** Adds a verification pass. */\n-        pub fn LLVMAddVerifierPass(PM: PassManagerRef);\n-\n-        pub fn LLVMAddGlobalOptimizerPass(PM: PassManagerRef);\n-        pub fn LLVMAddIPSCCPPass(PM: PassManagerRef);\n-        pub fn LLVMAddDeadArgEliminationPass(PM: PassManagerRef);\n-        pub fn LLVMAddInstructionCombiningPass(PM: PassManagerRef);\n-        pub fn LLVMAddCFGSimplificationPass(PM: PassManagerRef);\n-        pub fn LLVMAddFunctionInliningPass(PM: PassManagerRef);\n-        pub fn LLVMAddFunctionAttrsPass(PM: PassManagerRef);\n-        pub fn LLVMAddScalarReplAggregatesPass(PM: PassManagerRef);\n-        pub fn LLVMAddScalarReplAggregatesPassSSA(PM: PassManagerRef);\n-        pub fn LLVMAddJumpThreadingPass(PM: PassManagerRef);\n-        pub fn LLVMAddConstantPropagationPass(PM: PassManagerRef);\n-        pub fn LLVMAddReassociatePass(PM: PassManagerRef);\n-        pub fn LLVMAddLoopRotatePass(PM: PassManagerRef);\n-        pub fn LLVMAddLICMPass(PM: PassManagerRef);\n-        pub fn LLVMAddLoopUnswitchPass(PM: PassManagerRef);\n-        pub fn LLVMAddLoopDeletionPass(PM: PassManagerRef);\n-        pub fn LLVMAddLoopUnrollPass(PM: PassManagerRef);\n-        pub fn LLVMAddGVNPass(PM: PassManagerRef);\n-        pub fn LLVMAddMemCpyOptPass(PM: PassManagerRef);\n-        pub fn LLVMAddSCCPPass(PM: PassManagerRef);\n-        pub fn LLVMAddDeadStoreEliminationPass(PM: PassManagerRef);\n-        pub fn LLVMAddStripDeadPrototypesPass(PM: PassManagerRef);\n-        pub fn LLVMAddConstantMergePass(PM: PassManagerRef);\n-        pub fn LLVMAddArgumentPromotionPass(PM: PassManagerRef);\n-        pub fn LLVMAddTailCallEliminationPass(PM: PassManagerRef);\n-        pub fn LLVMAddIndVarSimplifyPass(PM: PassManagerRef);\n-        pub fn LLVMAddAggressiveDCEPass(PM: PassManagerRef);\n-        pub fn LLVMAddGlobalDCEPass(PM: PassManagerRef);\n-        pub fn LLVMAddCorrelatedValuePropagationPass(PM: PassManagerRef);\n-        pub fn LLVMAddPruneEHPass(PM: PassManagerRef);\n-        pub fn LLVMAddSimplifyLibCallsPass(PM: PassManagerRef);\n-        pub fn LLVMAddLoopIdiomPass(PM: PassManagerRef);\n-        pub fn LLVMAddEarlyCSEPass(PM: PassManagerRef);\n-        pub fn LLVMAddTypeBasedAliasAnalysisPass(PM: PassManagerRef);\n-        pub fn LLVMAddBasicAliasAnalysisPass(PM: PassManagerRef);\n-\n-        pub fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n-        pub fn LLVMPassManagerBuilderDispose(PMB: PassManagerBuilderRef);\n-        pub fn LLVMPassManagerBuilderSetOptLevel(PMB: PassManagerBuilderRef,\n-                                                 OptimizationLevel: c_uint);\n-        pub fn LLVMPassManagerBuilderSetSizeLevel(PMB: PassManagerBuilderRef,\n-                                                  Value: Bool);\n-        pub fn LLVMPassManagerBuilderSetDisableUnitAtATime(\n-            PMB: PassManagerBuilderRef,\n-            Value: Bool);\n-        pub fn LLVMPassManagerBuilderSetDisableUnrollLoops(\n-            PMB: PassManagerBuilderRef,\n-            Value: Bool);\n-        pub fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls(\n-            PMB: PassManagerBuilderRef,\n-            Value: Bool);\n-        pub fn LLVMPassManagerBuilderUseInlinerWithThreshold(\n-            PMB: PassManagerBuilderRef,\n-            threshold: c_uint);\n-        pub fn LLVMPassManagerBuilderPopulateModulePassManager(\n-            PMB: PassManagerBuilderRef,\n-            PM: PassManagerRef);\n-\n-        pub fn LLVMPassManagerBuilderPopulateFunctionPassManager(\n-            PMB: PassManagerBuilderRef,\n-            PM: PassManagerRef);\n-        pub fn LLVMPassManagerBuilderPopulateLTOPassManager(\n-            PMB: PassManagerBuilderRef,\n-            PM: PassManagerRef,\n-            Internalize: Bool,\n-            RunInliner: Bool);\n-\n-        /** Destroys a memory buffer. */\n-        pub fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n-\n-\n-        /* Stuff that's in rustllvm/ because it's not upstream yet. */\n-\n-        /** Opens an object file. */\n-        pub fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef) -> ObjectFileRef;\n-        /** Closes an object file. */\n-        pub fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n-\n-        /** Enumerates the sections in an object file. */\n-        pub fn LLVMGetSections(ObjFile: ObjectFileRef) -> SectionIteratorRef;\n-        /** Destroys a section iterator. */\n-        pub fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n-        /** Returns true if the section iterator is at the end of the section\n-            list: */\n-        pub fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n-                                          SI: SectionIteratorRef)\n-                                          -> Bool;\n-        /** Moves the section iterator to point to the next section. */\n-        pub fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n-        /** Returns the current section size. */\n-        pub fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n-        /** Returns the current section contents as a string buffer. */\n-        pub fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *const c_char;\n-\n-        /** Reads the given file and returns it as a memory buffer. Use\n-            LLVMDisposeMemoryBuffer() to get rid of it. */\n-        pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *const c_char)\n-            -> MemoryBufferRef;\n-        /** Borrows the contents of the memory buffer (doesn't copy it) */\n-        pub fn LLVMCreateMemoryBufferWithMemoryRange(InputData: *const c_char,\n-                                                     InputDataLength: size_t,\n-                                                     BufferName: *const c_char,\n-                                                     RequiresNull: Bool)\n-            -> MemoryBufferRef;\n-        pub fn LLVMCreateMemoryBufferWithMemoryRangeCopy(InputData: *const c_char,\n-                                                         InputDataLength: size_t,\n-                                                         BufferName: *const c_char)\n-            -> MemoryBufferRef;\n-\n-        pub fn LLVMIsMultithreaded() -> Bool;\n-        pub fn LLVMStartMultithreaded() -> Bool;\n-\n-        /** Returns a string describing the last error caused by an LLVMRust*\n-            call. */\n-        pub fn LLVMRustGetLastError() -> *const c_char;\n-\n-        /// Print the pass timings since static dtors aren't picking them up.\n-        pub fn LLVMRustPrintPassTimings();\n-\n-        pub fn LLVMStructCreateNamed(C: ContextRef, Name: *const c_char) -> TypeRef;\n-\n-        pub fn LLVMStructSetBody(StructTy: TypeRef,\n-                                 ElementTypes: *const TypeRef,\n-                                 ElementCount: c_uint,\n-                                 Packed: Bool);\n-\n-        pub fn LLVMConstNamedStruct(S: TypeRef,\n-                                    ConstantVals: *const ValueRef,\n-                                    Count: c_uint)\n-                                    -> ValueRef;\n-\n-        /** Enables LLVM debug output. */\n-        pub fn LLVMSetDebug(Enabled: c_int);\n-\n-        /** Prepares inline assembly. */\n-        pub fn LLVMInlineAsm(Ty: TypeRef,\n-                             AsmString: *const c_char,\n-                             Constraints: *const c_char,\n-                             SideEffects: Bool,\n-                             AlignStack: Bool,\n-                             Dialect: c_uint)\n-                             -> ValueRef;\n-\n-        pub static LLVMRustDebugMetadataVersion: u32;\n-\n-        pub fn LLVMRustAddModuleFlag(M: ModuleRef,\n-                                     name: *const c_char,\n-                                     value: u32);\n-\n-        pub fn LLVMDIBuilderCreate(M: ModuleRef) -> DIBuilderRef;\n-\n-        pub fn LLVMDIBuilderDispose(Builder: DIBuilderRef);\n-\n-        pub fn LLVMDIBuilderFinalize(Builder: DIBuilderRef);\n-\n-        pub fn LLVMDIBuilderCreateCompileUnit(Builder: DIBuilderRef,\n-                                              Lang: c_uint,\n-                                              File: *const c_char,\n-                                              Dir: *const c_char,\n-                                              Producer: *const c_char,\n-                                              isOptimized: bool,\n-                                              Flags: *const c_char,\n-                                              RuntimeVer: c_uint,\n-                                              SplitName: *const c_char);\n-\n-        pub fn LLVMDIBuilderCreateFile(Builder: DIBuilderRef,\n-                                       Filename: *const c_char,\n-                                       Directory: *const c_char)\n-                                       -> DIFile;\n-\n-        pub fn LLVMDIBuilderCreateSubroutineType(Builder: DIBuilderRef,\n-                                                 File: DIFile,\n-                                                 ParameterTypes: DIArray)\n-                                                 -> DICompositeType;\n-\n-        pub fn LLVMDIBuilderCreateFunction(Builder: DIBuilderRef,\n-                                           Scope: DIDescriptor,\n-                                           Name: *const c_char,\n-                                           LinkageName: *const c_char,\n-                                           File: DIFile,\n-                                           LineNo: c_uint,\n-                                           Ty: DIType,\n-                                           isLocalToUnit: bool,\n-                                           isDefinition: bool,\n-                                           ScopeLine: c_uint,\n-                                           Flags: c_uint,\n-                                           isOptimized: bool,\n-                                           Fn: ValueRef,\n-                                           TParam: ValueRef,\n-                                           Decl: ValueRef)\n-                                           -> DISubprogram;\n-\n-        pub fn LLVMDIBuilderCreateBasicType(Builder: DIBuilderRef,\n-                                            Name: *const c_char,\n-                                            SizeInBits: c_ulonglong,\n-                                            AlignInBits: c_ulonglong,\n-                                            Encoding: c_uint)\n-                                            -> DIBasicType;\n-\n-        pub fn LLVMDIBuilderCreatePointerType(Builder: DIBuilderRef,\n-                                              PointeeTy: DIType,\n-                                              SizeInBits: c_ulonglong,\n-                                              AlignInBits: c_ulonglong,\n-                                              Name: *const c_char)\n-                                              -> DIDerivedType;\n-\n-        pub fn LLVMDIBuilderCreateStructType(Builder: DIBuilderRef,\n-                                             Scope: DIDescriptor,\n-                                             Name: *const c_char,\n-                                             File: DIFile,\n-                                             LineNumber: c_uint,\n-                                             SizeInBits: c_ulonglong,\n-                                             AlignInBits: c_ulonglong,\n-                                             Flags: c_uint,\n-                                             DerivedFrom: DIType,\n-                                             Elements: DIArray,\n-                                             RunTimeLang: c_uint,\n-                                             VTableHolder: ValueRef,\n-                                             UniqueId: *const c_char)\n-                                             -> DICompositeType;\n-\n-        pub fn LLVMDIBuilderCreateMemberType(Builder: DIBuilderRef,\n-                                             Scope: DIDescriptor,\n-                                             Name: *const c_char,\n-                                             File: DIFile,\n-                                             LineNo: c_uint,\n-                                             SizeInBits: c_ulonglong,\n-                                             AlignInBits: c_ulonglong,\n-                                             OffsetInBits: c_ulonglong,\n-                                             Flags: c_uint,\n-                                             Ty: DIType)\n-                                             -> DIDerivedType;\n-\n-        pub fn LLVMDIBuilderCreateLexicalBlock(Builder: DIBuilderRef,\n-                                               Scope: DIDescriptor,\n-                                               File: DIFile,\n-                                               Line: c_uint,\n-                                               Col: c_uint,\n-                                               Discriminator: c_uint)\n-                                               -> DILexicalBlock;\n-\n-        pub fn LLVMDIBuilderCreateStaticVariable(Builder: DIBuilderRef,\n-                                                 Context: DIDescriptor,\n-                                                 Name: *const c_char,\n-                                                 LinkageName: *const c_char,\n-                                                 File: DIFile,\n-                                                 LineNo: c_uint,\n-                                                 Ty: DIType,\n-                                                 isLocalToUnit: bool,\n-                                                 Val: ValueRef,\n-                                                 Decl: ValueRef)\n-                                                 -> DIGlobalVariable;\n-\n-        pub fn LLVMDIBuilderCreateLocalVariable(Builder: DIBuilderRef,\n-                                                Tag: c_uint,\n-                                                Scope: DIDescriptor,\n-                                                Name: *const c_char,\n-                                                File: DIFile,\n-                                                LineNo: c_uint,\n-                                                Ty: DIType,\n-                                                AlwaysPreserve: bool,\n-                                                Flags: c_uint,\n-                                                ArgNo: c_uint)\n-                                                -> DIVariable;\n-\n-        pub fn LLVMDIBuilderCreateArrayType(Builder: DIBuilderRef,\n-                                            Size: c_ulonglong,\n-                                            AlignInBits: c_ulonglong,\n-                                            Ty: DIType,\n-                                            Subscripts: DIArray)\n-                                            -> DIType;\n-\n-        pub fn LLVMDIBuilderCreateVectorType(Builder: DIBuilderRef,\n-                                             Size: c_ulonglong,\n-                                             AlignInBits: c_ulonglong,\n-                                             Ty: DIType,\n-                                             Subscripts: DIArray)\n-                                             -> DIType;\n-\n-        pub fn LLVMDIBuilderGetOrCreateSubrange(Builder: DIBuilderRef,\n-                                                Lo: c_longlong,\n-                                                Count: c_longlong)\n-                                                -> DISubrange;\n-\n-        pub fn LLVMDIBuilderGetOrCreateArray(Builder: DIBuilderRef,\n-                                             Ptr: *const DIDescriptor,\n-                                             Count: c_uint)\n-                                             -> DIArray;\n-\n-        pub fn LLVMDIBuilderInsertDeclareAtEnd(Builder: DIBuilderRef,\n-                                               Val: ValueRef,\n-                                               VarInfo: DIVariable,\n-                                               InsertAtEnd: BasicBlockRef)\n-                                               -> ValueRef;\n-\n-        pub fn LLVMDIBuilderInsertDeclareBefore(Builder: DIBuilderRef,\n-                                                Val: ValueRef,\n-                                                VarInfo: DIVariable,\n-                                                InsertBefore: ValueRef)\n-                                                -> ValueRef;\n-\n-        pub fn LLVMDIBuilderCreateEnumerator(Builder: DIBuilderRef,\n-                                             Name: *const c_char,\n-                                             Val: c_ulonglong)\n-                                             -> ValueRef;\n-\n-        pub fn LLVMDIBuilderCreateEnumerationType(Builder: DIBuilderRef,\n-                                                  Scope: ValueRef,\n-                                                  Name: *const c_char,\n-                                                  File: ValueRef,\n-                                                  LineNumber: c_uint,\n-                                                  SizeInBits: c_ulonglong,\n-                                                  AlignInBits: c_ulonglong,\n-                                                  Elements: ValueRef,\n-                                                  ClassType: ValueRef)\n-                                                  -> ValueRef;\n-\n-        pub fn LLVMDIBuilderCreateUnionType(Builder: DIBuilderRef,\n-                                            Scope: ValueRef,\n-                                            Name: *const c_char,\n-                                            File: ValueRef,\n-                                            LineNumber: c_uint,\n-                                            SizeInBits: c_ulonglong,\n-                                            AlignInBits: c_ulonglong,\n-                                            Flags: c_uint,\n-                                            Elements: ValueRef,\n-                                            RunTimeLang: c_uint,\n-                                            UniqueId: *const c_char)\n-                                            -> ValueRef;\n-\n-        pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);\n-\n-        pub fn LLVMDIBuilderCreateTemplateTypeParameter(Builder: DIBuilderRef,\n-                                                        Scope: ValueRef,\n-                                                        Name: *const c_char,\n-                                                        Ty: ValueRef,\n-                                                        File: ValueRef,\n-                                                        LineNo: c_uint,\n-                                                        ColumnNo: c_uint)\n-                                                        -> ValueRef;\n-\n-        pub fn LLVMDIBuilderCreateOpDeref(IntType: TypeRef) -> ValueRef;\n-\n-        pub fn LLVMDIBuilderCreateOpPlus(IntType: TypeRef) -> ValueRef;\n-\n-        pub fn LLVMDIBuilderCreateComplexVariable(Builder: DIBuilderRef,\n-            Tag: c_uint,\n-            Scope: ValueRef,\n-            Name: *const c_char,\n-            File: ValueRef,\n-            LineNo: c_uint,\n-            Ty: ValueRef,\n-            AddrOps: *const ValueRef,\n-            AddrOpsCount: c_uint,\n-            ArgNo: c_uint)\n-            -> ValueRef;\n-\n-        pub fn LLVMDIBuilderCreateNameSpace(Builder: DIBuilderRef,\n-                                            Scope: ValueRef,\n-                                            Name: *const c_char,\n-                                            File: ValueRef,\n-                                            LineNo: c_uint)\n-                                            -> ValueRef;\n-\n-        pub fn LLVMDICompositeTypeSetTypeArray(CompositeType: ValueRef, TypeArray: ValueRef);\n-        pub fn LLVMTypeToString(Type: TypeRef) -> *const c_char;\n-        pub fn LLVMValueToString(value_ref: ValueRef) -> *const c_char;\n-\n-        pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n-\n-        pub fn LLVMIsAAllocaInst(value_ref: ValueRef) -> ValueRef;\n-\n-        pub fn LLVMInitializeX86TargetInfo();\n-        pub fn LLVMInitializeX86Target();\n-        pub fn LLVMInitializeX86TargetMC();\n-        pub fn LLVMInitializeX86AsmPrinter();\n-        pub fn LLVMInitializeX86AsmParser();\n-        pub fn LLVMInitializeARMTargetInfo();\n-        pub fn LLVMInitializeARMTarget();\n-        pub fn LLVMInitializeARMTargetMC();\n-        pub fn LLVMInitializeARMAsmPrinter();\n-        pub fn LLVMInitializeARMAsmParser();\n-        pub fn LLVMInitializeMipsTargetInfo();\n-        pub fn LLVMInitializeMipsTarget();\n-        pub fn LLVMInitializeMipsTargetMC();\n-        pub fn LLVMInitializeMipsAsmPrinter();\n-        pub fn LLVMInitializeMipsAsmParser();\n-\n-        pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: *const c_char) -> bool;\n-        pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n-                                           CPU: *const c_char,\n-                                           Features: *const c_char,\n-                                           Model: CodeGenModel,\n-                                           Reloc: RelocMode,\n-                                           Level: CodeGenOptLevel,\n-                                           EnableSegstk: bool,\n-                                           UseSoftFP: bool,\n-                                           NoFramePointerElim: bool,\n-                                           FunctionSections: bool,\n-                                           DataSections: bool) -> TargetMachineRef;\n-        pub fn LLVMRustDisposeTargetMachine(T: TargetMachineRef);\n-        pub fn LLVMRustAddAnalysisPasses(T: TargetMachineRef,\n-                                         PM: PassManagerRef,\n-                                         M: ModuleRef);\n-        pub fn LLVMRustAddBuilderLibraryInfo(PMB: PassManagerBuilderRef,\n-                                             M: ModuleRef,\n-                                             DisableSimplifyLibCalls: bool);\n-        pub fn LLVMRustAddLibraryInfo(PM: PassManagerRef, M: ModuleRef,\n-                                      DisableSimplifyLibCalls: bool);\n-        pub fn LLVMRustRunFunctionPassManager(PM: PassManagerRef, M: ModuleRef);\n-        pub fn LLVMRustWriteOutputFile(T: TargetMachineRef,\n-                                       PM: PassManagerRef,\n-                                       M: ModuleRef,\n-                                       Output: *const c_char,\n-                                       FileType: FileType) -> bool;\n-        pub fn LLVMRustPrintModule(PM: PassManagerRef,\n-                                   M: ModuleRef,\n-                                   Output: *const c_char);\n-        pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n-        pub fn LLVMRustPrintPasses();\n-        pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n-        pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef,\n-                                           AddLifetimes: bool);\n-        pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef,\n-                                             bc: *const c_char,\n-                                             len: size_t) -> bool;\n-        pub fn LLVMRustRunRestrictionPass(M: ModuleRef,\n-                                          syms: *const *const c_char,\n-                                          len: size_t);\n-        pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n-\n-        pub fn LLVMRustOpenArchive(path: *const c_char) -> ArchiveRef;\n-        pub fn LLVMRustArchiveReadSection(AR: ArchiveRef, name: *const c_char,\n-                                          out_len: *mut size_t) -> *const c_char;\n-        pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n-\n-        pub fn LLVMRustSetDLLExportStorageClass(V: ValueRef);\n-        pub fn LLVMVersionMajor() -> c_int;\n-        pub fn LLVMVersionMinor() -> c_int;\n-\n-        pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n-                                      data: *mut *const c_char) -> c_int;\n-    }\n-}\n-\n-pub fn SetInstructionCallConv(instr: ValueRef, cc: CallConv) {\n-    unsafe {\n-        llvm::LLVMSetInstructionCallConv(instr, cc as c_uint);\n-    }\n-}\n-pub fn SetFunctionCallConv(fn_: ValueRef, cc: CallConv) {\n-    unsafe {\n-        llvm::LLVMSetFunctionCallConv(fn_, cc as c_uint);\n-    }\n-}\n-pub fn SetLinkage(global: ValueRef, link: Linkage) {\n-    unsafe {\n-        llvm::LLVMSetLinkage(global, link as c_uint);\n-    }\n-}\n-\n-pub fn SetUnnamedAddr(global: ValueRef, unnamed: bool) {\n-    unsafe {\n-        llvm::LLVMSetUnnamedAddr(global, unnamed as Bool);\n-    }\n-}\n-\n-pub fn set_thread_local(global: ValueRef, is_thread_local: bool) {\n-    unsafe {\n-        llvm::LLVMSetThreadLocal(global, is_thread_local as Bool);\n-    }\n-}\n-\n-pub fn ConstICmp(pred: IntPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMConstICmp(pred as c_ushort, v1, v2)\n-    }\n-}\n-pub fn ConstFCmp(pred: RealPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMConstFCmp(pred as c_ushort, v1, v2)\n-    }\n-}\n-\n-pub fn SetFunctionAttribute(fn_: ValueRef, attr: Attribute) {\n-    unsafe {\n-        llvm::LLVMAddFunctionAttribute(fn_, FunctionIndex as c_uint, attr as uint64_t)\n-    }\n-}\n-/* Memory-managed object interface to type handles. */\n-\n-pub struct TypeNames {\n-    named_types: RefCell<HashMap<String, TypeRef>>,\n-}\n-\n-impl TypeNames {\n-    pub fn new() -> TypeNames {\n-        TypeNames {\n-            named_types: RefCell::new(HashMap::new())\n-        }\n-    }\n-\n-    pub fn associate_type(&self, s: &str, t: &Type) {\n-        assert!(self.named_types.borrow_mut().insert(s.to_string(),\n-                                                     t.to_ref()));\n-    }\n-\n-    pub fn find_type(&self, s: &str) -> Option<Type> {\n-        self.named_types.borrow().find_equiv(&s).map(|x| Type::from_ref(*x))\n-    }\n-\n-    pub fn type_to_string(&self, ty: Type) -> String {\n-        unsafe {\n-            let s = llvm::LLVMTypeToString(ty.to_ref());\n-            let ret = from_c_str(s);\n-            free(s as *mut c_void);\n-            ret.to_string()\n-        }\n-    }\n-\n-    pub fn types_to_str(&self, tys: &[Type]) -> String {\n-        let strs: Vec<String> = tys.iter().map(|t| self.type_to_string(*t)).collect();\n-        format!(\"[{}]\", strs.connect(\",\"))\n-    }\n-\n-    pub fn val_to_string(&self, val: ValueRef) -> String {\n-        unsafe {\n-            let s = llvm::LLVMValueToString(val);\n-            let ret = from_c_str(s);\n-            free(s as *mut c_void);\n-            ret.to_string()\n-        }\n-    }\n-}\n-\n-/* Memory-managed interface to target data. */\n-\n-pub struct TargetData {\n-    pub lltd: TargetDataRef\n-}\n-\n-impl Drop for TargetData {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMDisposeTargetData(self.lltd);\n-        }\n-    }\n-}\n-\n-pub fn mk_target_data(string_rep: &str) -> TargetData {\n-    TargetData {\n-        lltd: string_rep.with_c_str(|buf| {\n-            unsafe { llvm::LLVMCreateTargetData(buf) }\n-        })\n-    }\n-}\n-\n-/* Memory-managed interface to object files. */\n-\n-pub struct ObjectFile {\n-    pub llof: ObjectFileRef,\n-}\n-\n-impl ObjectFile {\n-    // This will take ownership of llmb\n-    pub fn new(llmb: MemoryBufferRef) -> Option<ObjectFile> {\n-        unsafe {\n-            let llof = llvm::LLVMCreateObjectFile(llmb);\n-            if llof as int == 0 {\n-                // LLVMCreateObjectFile took ownership of llmb\n-                return None\n-            }\n-\n-            Some(ObjectFile {\n-                llof: llof,\n-            })\n-        }\n-    }\n-}\n-\n-impl Drop for ObjectFile {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMDisposeObjectFile(self.llof);\n-        }\n-    }\n-}\n-\n-/* Memory-managed interface to section iterators. */\n-\n-pub struct SectionIter {\n-    pub llsi: SectionIteratorRef\n-}\n-\n-impl Drop for SectionIter {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMDisposeSectionIterator(self.llsi);\n-        }\n-    }\n-}\n-\n-pub fn mk_section_iter(llof: ObjectFileRef) -> SectionIter {\n-    unsafe {\n-        SectionIter {\n-            llsi: llvm::LLVMGetSections(llof)\n-        }\n-    }\n-}"}, {"sha": "05e5e585a63aba0305792e23421a41f78daf50e5", "filename": "src/librustc/lib/llvmdeps.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Flib%2Fllvmdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Flib%2Fllvmdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvmdeps.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// WARNING: THIS IS A GENERATED FILE, DO NOT MODIFY\n+//          take a look at src/etc/mklldeps.py if you're interested\n+\n+#[cfg(target_arch = \"x86_64\", target_os = \"linux\")]\n+#[link(name = \"LLVMInstrumentation\", kind = \"static\")]\n+#[link(name = \"LLVMInterpreter\", kind = \"static\")]\n+#[link(name = \"LLVMMCJIT\", kind = \"static\")]\n+#[link(name = \"LLVMRuntimeDyld\", kind = \"static\")]\n+#[link(name = \"LLVMJIT\", kind = \"static\")]\n+#[link(name = \"LLVMExecutionEngine\", kind = \"static\")]\n+#[link(name = \"LLVMAsmParser\", kind = \"static\")]\n+#[link(name = \"LLVMLinker\", kind = \"static\")]\n+#[link(name = \"LLVMBitWriter\", kind = \"static\")]\n+#[link(name = \"LLVMipo\", kind = \"static\")]\n+#[link(name = \"LLVMVectorize\", kind = \"static\")]\n+#[link(name = \"LLVMMipsDisassembler\", kind = \"static\")]\n+#[link(name = \"LLVMMipsCodeGen\", kind = \"static\")]\n+#[link(name = \"LLVMMipsAsmParser\", kind = \"static\")]\n+#[link(name = \"LLVMMipsDesc\", kind = \"static\")]\n+#[link(name = \"LLVMMipsInfo\", kind = \"static\")]\n+#[link(name = \"LLVMMipsAsmPrinter\", kind = \"static\")]\n+#[link(name = \"LLVMARMDisassembler\", kind = \"static\")]\n+#[link(name = \"LLVMARMCodeGen\", kind = \"static\")]\n+#[link(name = \"LLVMARMAsmParser\", kind = \"static\")]\n+#[link(name = \"LLVMARMDesc\", kind = \"static\")]\n+#[link(name = \"LLVMARMInfo\", kind = \"static\")]\n+#[link(name = \"LLVMARMAsmPrinter\", kind = \"static\")]\n+#[link(name = \"LLVMX86Disassembler\", kind = \"static\")]\n+#[link(name = \"LLVMX86AsmParser\", kind = \"static\")]\n+#[link(name = \"LLVMX86CodeGen\", kind = \"static\")]\n+#[link(name = \"LLVMSelectionDAG\", kind = \"static\")]\n+#[link(name = \"LLVMAsmPrinter\", kind = \"static\")]\n+#[link(name = \"LLVMMCParser\", kind = \"static\")]\n+#[link(name = \"LLVMCodeGen\", kind = \"static\")]\n+#[link(name = \"LLVMScalarOpts\", kind = \"static\")]\n+#[link(name = \"LLVMInstCombine\", kind = \"static\")]\n+#[link(name = \"LLVMTransformUtils\", kind = \"static\")]\n+#[link(name = \"LLVMipa\", kind = \"static\")]\n+#[link(name = \"LLVMAnalysis\", kind = \"static\")]\n+#[link(name = \"LLVMTarget\", kind = \"static\")]\n+#[link(name = \"LLVMX86Desc\", kind = \"static\")]\n+#[link(name = \"LLVMX86Info\", kind = \"static\")]\n+#[link(name = \"LLVMX86AsmPrinter\", kind = \"static\")]\n+#[link(name = \"LLVMMC\", kind = \"static\")]\n+#[link(name = \"LLVMObject\", kind = \"static\")]\n+#[link(name = \"LLVMBitReader\", kind = \"static\")]\n+#[link(name = \"LLVMCore\", kind = \"static\")]\n+#[link(name = \"LLVMX86Utils\", kind = \"static\")]\n+#[link(name = \"LLVMSupport\", kind = \"static\")]\n+#[link(name = \"pthread\")]\n+#[link(name = \"dl\")]\n+#[link(name = \"m\")]\n+#[link(name = \"stdc++\")]\n+extern {}"}, {"sha": "e7d52ef3b3d6cb1b54cb124e8207bfe39ba47802", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -212,10 +212,12 @@\n //! no means all of the necessary details. Take a look at the rest of\n //! metadata::loader or metadata::creader for all the juicy details!\n \n-use back::archive::{ArchiveRO, METADATA_FILENAME};\n+use back::archive::{METADATA_FILENAME};\n use back::svh::Svh;\n use driver::session::Session;\n-use lib::llvm::{False, llvm, ObjectFile, mk_section_iter};\n+use llvm;\n+use llvm::{False, ObjectFile, mk_section_iter};\n+use llvm::archive_ro::ArchiveRO;\n use metadata::cstore::{MetadataBlob, MetadataVec, MetadataArchive};\n use metadata::decoder;\n use metadata::encoder;"}, {"sha": "958d2cd3774315fa4da1a53a44b2e2e7c00a6e86", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -190,7 +190,8 @@\n \n use back::abi;\n use driver::config::FullDebugInfo;\n-use lib::llvm::{llvm, ValueRef, BasicBlockRef};\n+use llvm;\n+use llvm::{ValueRef, BasicBlockRef};\n use middle::const_eval;\n use middle::def;\n use middle::check_match;"}, {"sha": "3ee61b1d6759668beaf3423c0fb3edfe1abc59df", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -48,7 +48,7 @@\n use libc::c_ulonglong;\n use std::rc::Rc;\n \n-use lib::llvm::{ValueRef, True, IntEQ, IntNE};\n+use llvm::{ValueRef, True, IntEQ, IntNE};\n use middle::subst;\n use middle::subst::Subst;\n use middle::trans::_match;"}, {"sha": "9760ef07a40e463aa4bb7b5d1aabee8a92a4c1ff", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -12,7 +12,7 @@\n # Translation of inline assembly.\n */\n \n-use lib;\n+use llvm;\n use middle::trans::build::*;\n use middle::trans::callee;\n use middle::trans::common::*;\n@@ -99,8 +99,8 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n     };\n \n     let dialect = match ia.dialect {\n-        ast::AsmAtt   => lib::llvm::AD_ATT,\n-        ast::AsmIntel => lib::llvm::AD_Intel\n+        ast::AsmAtt   => llvm::AD_ATT,\n+        ast::AsmIntel => llvm::AD_Intel\n     };\n \n     let r = ia.asm.get().with_c_str(|a| {"}, {"sha": "6bcc9b9b745b7f5e438842de8b7bbcb9774c4a6e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -31,9 +31,9 @@ use driver::config;\n use driver::config::{NoDebugInfo, FullDebugInfo};\n use driver::session::Session;\n use driver::driver::{CrateAnalysis, CrateTranslation};\n-use lib::llvm::{ModuleRef, ValueRef, BasicBlockRef};\n-use lib::llvm::{llvm, Vector};\n-use lib;\n+use llvm;\n+use llvm::{ModuleRef, ValueRef, BasicBlockRef};\n+use llvm::{Vector};\n use metadata::{csearch, encoder, loader};\n use lint;\n use middle::astencode;\n@@ -172,7 +172,7 @@ impl<'a> Drop for StatRecorder<'a> {\n }\n \n // only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n-fn decl_fn(ccx: &CrateContext, name: &str, cc: lib::llvm::CallConv,\n+fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n            ty: Type, output: ty::t) -> ValueRef {\n \n     let llfn: ValueRef = name.with_c_str(|buf| {\n@@ -186,16 +186,16 @@ fn decl_fn(ccx: &CrateContext, name: &str, cc: lib::llvm::CallConv,\n         ty::ty_bot => {\n             unsafe {\n                 llvm::LLVMAddFunctionAttribute(llfn,\n-                                               lib::llvm::FunctionIndex as c_uint,\n-                                               lib::llvm::NoReturnAttribute as uint64_t)\n+                                               llvm::FunctionIndex as c_uint,\n+                                               llvm::NoReturnAttribute as uint64_t)\n             }\n         }\n         _ => {}\n     }\n \n-    lib::llvm::SetFunctionCallConv(llfn, cc);\n+    llvm::SetFunctionCallConv(llfn, cc);\n     // Function addresses in Rust are never significant, allowing functions to be merged.\n-    lib::llvm::SetUnnamedAddr(llfn, true);\n+    llvm::SetUnnamedAddr(llfn, true);\n \n     if ccx.is_split_stack_supported() {\n         set_split_stack(llfn);\n@@ -209,14 +209,14 @@ pub fn decl_cdecl_fn(ccx: &CrateContext,\n                      name: &str,\n                      ty: Type,\n                      output: ty::t) -> ValueRef {\n-    decl_fn(ccx, name, lib::llvm::CCallConv, ty, output)\n+    decl_fn(ccx, name, llvm::CCallConv, ty, output)\n }\n \n // only use this for foreign function ABIs and glue, use `get_extern_rust_fn` for Rust functions\n pub fn get_extern_fn(ccx: &CrateContext,\n                      externs: &mut ExternMap,\n                      name: &str,\n-                     cc: lib::llvm::CallConv,\n+                     cc: llvm::CallConv,\n                      ty: Type,\n                      output: ty::t)\n                      -> ValueRef {\n@@ -253,7 +253,7 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n     };\n \n     let llfty = type_of_rust_fn(ccx, has_env, inputs.as_slice(), output);\n-    let llfn = decl_fn(ccx, name, lib::llvm::CCallConv, llfty, output);\n+    let llfn = decl_fn(ccx, name, llvm::CCallConv, llfty, output);\n     let attrs = get_fn_llvm_attributes(ccx, fn_ty);\n     for &(idx, attr) in attrs.iter() {\n         unsafe {\n@@ -266,7 +266,7 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n \n pub fn decl_internal_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n     let llfn = decl_rust_fn(ccx, fn_ty, name);\n-    lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n+    llvm::SetLinkage(llfn, llvm::InternalLinkage);\n     llfn\n }\n \n@@ -375,26 +375,26 @@ pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> Rc<tydesc_info> {\n \n #[allow(dead_code)] // useful\n pub fn set_optimize_for_size(f: ValueRef) {\n-    lib::llvm::SetFunctionAttribute(f, lib::llvm::OptimizeForSizeAttribute)\n+    llvm::SetFunctionAttribute(f, llvm::OptimizeForSizeAttribute)\n }\n \n pub fn set_no_inline(f: ValueRef) {\n-    lib::llvm::SetFunctionAttribute(f, lib::llvm::NoInlineAttribute)\n+    llvm::SetFunctionAttribute(f, llvm::NoInlineAttribute)\n }\n \n #[allow(dead_code)] // useful\n pub fn set_no_unwind(f: ValueRef) {\n-    lib::llvm::SetFunctionAttribute(f, lib::llvm::NoUnwindAttribute)\n+    llvm::SetFunctionAttribute(f, llvm::NoUnwindAttribute)\n }\n \n // Tell LLVM to emit the information necessary to unwind the stack for the\n // function f.\n pub fn set_uwtable(f: ValueRef) {\n-    lib::llvm::SetFunctionAttribute(f, lib::llvm::UWTableAttribute)\n+    llvm::SetFunctionAttribute(f, llvm::UWTableAttribute)\n }\n \n pub fn set_inline_hint(f: ValueRef) {\n-    lib::llvm::SetFunctionAttribute(f, lib::llvm::InlineHintAttribute)\n+    llvm::SetFunctionAttribute(f, llvm::InlineHintAttribute)\n }\n \n pub fn set_llvm_fn_attrs(attrs: &[ast::Attribute], llfn: ValueRef) {\n@@ -415,25 +415,25 @@ pub fn set_llvm_fn_attrs(attrs: &[ast::Attribute], llfn: ValueRef) {\n     if contains_name(attrs, \"cold\") {\n         unsafe {\n             llvm::LLVMAddFunctionAttribute(llfn,\n-                                           lib::llvm::FunctionIndex as c_uint,\n-                                           lib::llvm::ColdAttribute as uint64_t)\n+                                           llvm::FunctionIndex as c_uint,\n+                                           llvm::ColdAttribute as uint64_t)\n         }\n     }\n }\n \n pub fn set_always_inline(f: ValueRef) {\n-    lib::llvm::SetFunctionAttribute(f, lib::llvm::AlwaysInlineAttribute)\n+    llvm::SetFunctionAttribute(f, llvm::AlwaysInlineAttribute)\n }\n \n pub fn set_split_stack(f: ValueRef) {\n     \"split-stack\".with_c_str(|buf| {\n-        unsafe { llvm::LLVMAddFunctionAttrString(f, lib::llvm::FunctionIndex as c_uint, buf); }\n+        unsafe { llvm::LLVMAddFunctionAttrString(f, llvm::FunctionIndex as c_uint, buf); }\n     })\n }\n \n pub fn unset_split_stack(f: ValueRef) {\n     \"split-stack\".with_c_str(|buf| {\n-        unsafe { llvm::LLVMRemoveFunctionAttrString(f, lib::llvm::FunctionIndex as c_uint, buf); }\n+        unsafe { llvm::LLVMRemoveFunctionAttrString(f, llvm::FunctionIndex as c_uint, buf); }\n     })\n }\n \n@@ -479,7 +479,7 @@ pub fn get_res_dtor(ccx: &CrateContext,\n         get_extern_fn(ccx,\n                       &mut *ccx.externs.borrow_mut(),\n                       name.as_slice(),\n-                      lib::llvm::CCallConv,\n+                      llvm::CCallConv,\n                       llty,\n                       dtor_ty)\n     }\n@@ -546,36 +546,36 @@ pub fn compare_scalar_values<'a>(\n       }\n       floating_point => {\n         let cmp = match op {\n-          ast::BiEq => lib::llvm::RealOEQ,\n-          ast::BiNe => lib::llvm::RealUNE,\n-          ast::BiLt => lib::llvm::RealOLT,\n-          ast::BiLe => lib::llvm::RealOLE,\n-          ast::BiGt => lib::llvm::RealOGT,\n-          ast::BiGe => lib::llvm::RealOGE,\n+          ast::BiEq => llvm::RealOEQ,\n+          ast::BiNe => llvm::RealUNE,\n+          ast::BiLt => llvm::RealOLT,\n+          ast::BiLe => llvm::RealOLE,\n+          ast::BiGt => llvm::RealOGT,\n+          ast::BiGe => llvm::RealOGE,\n           _ => die(cx)\n         };\n         return FCmp(cx, cmp, lhs, rhs);\n       }\n       signed_int => {\n         let cmp = match op {\n-          ast::BiEq => lib::llvm::IntEQ,\n-          ast::BiNe => lib::llvm::IntNE,\n-          ast::BiLt => lib::llvm::IntSLT,\n-          ast::BiLe => lib::llvm::IntSLE,\n-          ast::BiGt => lib::llvm::IntSGT,\n-          ast::BiGe => lib::llvm::IntSGE,\n+          ast::BiEq => llvm::IntEQ,\n+          ast::BiNe => llvm::IntNE,\n+          ast::BiLt => llvm::IntSLT,\n+          ast::BiLe => llvm::IntSLE,\n+          ast::BiGt => llvm::IntSGT,\n+          ast::BiGe => llvm::IntSGE,\n           _ => die(cx)\n         };\n         return ICmp(cx, cmp, lhs, rhs);\n       }\n       unsigned_int => {\n         let cmp = match op {\n-          ast::BiEq => lib::llvm::IntEQ,\n-          ast::BiNe => lib::llvm::IntNE,\n-          ast::BiLt => lib::llvm::IntULT,\n-          ast::BiLe => lib::llvm::IntULE,\n-          ast::BiGt => lib::llvm::IntUGT,\n-          ast::BiGe => lib::llvm::IntUGE,\n+          ast::BiEq => llvm::IntEQ,\n+          ast::BiNe => llvm::IntNE,\n+          ast::BiLt => llvm::IntULT,\n+          ast::BiLe => llvm::IntULE,\n+          ast::BiGt => llvm::IntUGT,\n+          ast::BiGe => llvm::IntUGE,\n           _ => die(cx)\n         };\n         return ICmp(cx, cmp, lhs, rhs);\n@@ -602,12 +602,12 @@ pub fn compare_simd_types(\n         },\n         ty::ty_uint(_) | ty::ty_int(_) => {\n             let cmp = match op {\n-                ast::BiEq => lib::llvm::IntEQ,\n-                ast::BiNe => lib::llvm::IntNE,\n-                ast::BiLt => lib::llvm::IntSLT,\n-                ast::BiLe => lib::llvm::IntSLE,\n-                ast::BiGt => lib::llvm::IntSGT,\n-                ast::BiGe => lib::llvm::IntSGE,\n+                ast::BiEq => llvm::IntEQ,\n+                ast::BiNe => llvm::IntNE,\n+                ast::BiLt => llvm::IntSLT,\n+                ast::BiLe => llvm::IntSLE,\n+                ast::BiGt => llvm::IntSGT,\n+                ast::BiGe => llvm::IntSGE,\n                 _ => cx.sess().bug(\"compare_simd_types: must be a comparison operator\"),\n             };\n             let return_ty = Type::vector(&type_of(cx.ccx(), t), size as u64);\n@@ -801,11 +801,11 @@ pub fn fail_if_zero_or_overflows<'a>(\n     let (is_zero, is_signed) = match ty::get(rhs_t).sty {\n         ty::ty_int(t) => {\n             let zero = C_integral(Type::int_from_ty(cx.ccx(), t), 0u64, false);\n-            (ICmp(cx, lib::llvm::IntEQ, rhs, zero), true)\n+            (ICmp(cx, llvm::IntEQ, rhs, zero), true)\n         }\n         ty::ty_uint(t) => {\n             let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0u64, false);\n-            (ICmp(cx, lib::llvm::IntEQ, rhs, zero), false)\n+            (ICmp(cx, llvm::IntEQ, rhs, zero), false)\n         }\n         _ => {\n             cx.sess().bug(format!(\"fail-if-zero on unexpected type: {}\",\n@@ -841,10 +841,10 @@ pub fn fail_if_zero_or_overflows<'a>(\n             }\n             _ => unreachable!(),\n         };\n-        let minus_one = ICmp(bcx, lib::llvm::IntEQ, rhs,\n+        let minus_one = ICmp(bcx, llvm::IntEQ, rhs,\n                              C_integral(llty, -1, false));\n         with_cond(bcx, minus_one, |bcx| {\n-            let is_min = ICmp(bcx, lib::llvm::IntEQ, lhs,\n+            let is_min = ICmp(bcx, llvm::IntEQ, lhs,\n                               C_integral(llty, min, true));\n             with_cond(bcx, is_min, |bcx| {\n                 controlflow::trans_fail(bcx, span,\n@@ -975,11 +975,11 @@ pub fn load_ty(cx: &Block, ptr: ValueRef, t: ty::t) -> ValueRef {\n     if type_is_zero_size(cx.ccx(), t) {\n         C_undef(type_of::type_of(cx.ccx(), t))\n     } else if ty::type_is_bool(t) {\n-        Trunc(cx, LoadRangeAssert(cx, ptr, 0, 2, lib::llvm::False), Type::i1(cx.ccx()))\n+        Trunc(cx, LoadRangeAssert(cx, ptr, 0, 2, llvm::False), Type::i1(cx.ccx()))\n     } else if ty::type_is_char(t) {\n         // a char is a unicode codepoint, and so takes values from 0\n         // to 0x10FFFF inclusive only.\n-        LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, lib::llvm::False)\n+        LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, llvm::False)\n     } else {\n         Load(cx, ptr)\n     }\n@@ -1755,7 +1755,7 @@ fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: String, node_id: ast::N\n     ccx.item_symbols.borrow_mut().insert(node_id, sym);\n \n     if !ccx.reachable.contains(&node_id) {\n-        lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n+        llvm::SetLinkage(llfn, llvm::InternalLinkage);\n     }\n \n     // The stack exhaustion lang item shouldn't have a split stack because\n@@ -1764,10 +1764,10 @@ fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: String, node_id: ast::N\n     let def = ast_util::local_def(node_id);\n     if ccx.tcx.lang_items.stack_exhausted() == Some(def) {\n         unset_split_stack(llfn);\n-        lib::llvm::SetLinkage(llfn, lib::llvm::ExternalLinkage);\n+        llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n     }\n     if ccx.tcx.lang_items.eh_personality() == Some(def) {\n-        lib::llvm::SetLinkage(llfn, lib::llvm::ExternalLinkage);\n+        llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n     }\n \n \n@@ -1814,13 +1814,13 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t) -> Vec<(uint, u6\n     // implications directly to the call instruction. Right now,\n     // the only attribute we need to worry about is `sret`.\n     if type_of::return_uses_outptr(ccx, ret_ty) {\n-        attrs.push((1, lib::llvm::StructRetAttribute as u64));\n+        attrs.push((1, llvm::StructRetAttribute as u64));\n \n         // The outptr can be noalias and nocapture because it's entirely\n         // invisible to the program. We can also mark it as nonnull\n-        attrs.push((1, lib::llvm::NoAliasAttribute as u64));\n-        attrs.push((1, lib::llvm::NoCaptureAttribute as u64));\n-        attrs.push((1, lib::llvm::NonNullAttribute as u64));\n+        attrs.push((1, llvm::NoAliasAttribute as u64));\n+        attrs.push((1, llvm::NoCaptureAttribute as u64));\n+        attrs.push((1, llvm::NonNullAttribute as u64));\n \n         // Add one more since there's an outptr\n         first_arg_offset += 1;\n@@ -1834,7 +1834,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t) -> Vec<(uint, u6\n                 ty::ty_str | ty::ty_vec(..) | ty::ty_trait(..) => true, _ => false\n             } => {}\n             ty::ty_uniq(_) => {\n-                attrs.push((lib::llvm::ReturnIndex as uint, lib::llvm::NoAliasAttribute as u64));\n+                attrs.push((llvm::ReturnIndex as uint, llvm::NoAliasAttribute as u64));\n             }\n             _ => {}\n         }\n@@ -1847,14 +1847,14 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t) -> Vec<(uint, u6\n                 ty::ty_str | ty::ty_vec(..) | ty::ty_trait(..) => true, _ => false\n             } => {}\n             ty::ty_uniq(_) | ty::ty_rptr(_, _) => {\n-                attrs.push((lib::llvm::ReturnIndex as uint, lib::llvm::NonNullAttribute as u64));\n+                attrs.push((llvm::ReturnIndex as uint, llvm::NonNullAttribute as u64));\n             }\n             _ => {}\n         }\n \n         match ty::get(ret_ty).sty {\n             ty::ty_bool => {\n-                attrs.push((lib::llvm::ReturnIndex as uint, lib::llvm::ZExtAttribute as u64));\n+                attrs.push((llvm::ReturnIndex as uint, llvm::ZExtAttribute as u64));\n             }\n             _ => {}\n         }\n@@ -1867,38 +1867,38 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t) -> Vec<(uint, u6\n                 // For non-immediate arguments the callee gets its own copy of\n                 // the value on the stack, so there are no aliases. It's also\n                 // program-invisible so can't possibly capture\n-                attrs.push((idx, lib::llvm::NoAliasAttribute as u64));\n-                attrs.push((idx, lib::llvm::NoCaptureAttribute as u64));\n-                attrs.push((idx, lib::llvm::NonNullAttribute as u64));\n+                attrs.push((idx, llvm::NoAliasAttribute as u64));\n+                attrs.push((idx, llvm::NoCaptureAttribute as u64));\n+                attrs.push((idx, llvm::NonNullAttribute as u64));\n             }\n             ty::ty_bool => {\n-                attrs.push((idx, lib::llvm::ZExtAttribute as u64));\n+                attrs.push((idx, llvm::ZExtAttribute as u64));\n             }\n             // `~` pointer parameters never alias because ownership is transferred\n             ty::ty_uniq(_) => {\n-                attrs.push((idx, lib::llvm::NoAliasAttribute as u64));\n-                attrs.push((idx, lib::llvm::NonNullAttribute as u64));\n+                attrs.push((idx, llvm::NoAliasAttribute as u64));\n+                attrs.push((idx, llvm::NonNullAttribute as u64));\n             }\n             // `&mut` pointer parameters never alias other parameters, or mutable global data\n             ty::ty_rptr(b, mt) if mt.mutbl == ast::MutMutable => {\n-                attrs.push((idx, lib::llvm::NoAliasAttribute as u64));\n-                attrs.push((idx, lib::llvm::NonNullAttribute as u64));\n+                attrs.push((idx, llvm::NoAliasAttribute as u64));\n+                attrs.push((idx, llvm::NonNullAttribute as u64));\n                 match b {\n                     ReLateBound(_, BrAnon(_)) => {\n-                        attrs.push((idx, lib::llvm::NoCaptureAttribute as u64));\n+                        attrs.push((idx, llvm::NoCaptureAttribute as u64));\n                     }\n                     _ => {}\n                 }\n             }\n             // When a reference in an argument has no named lifetime, it's impossible for that\n             // reference to escape this function (returned or stored beyond the call by a closure).\n             ty::ty_rptr(ReLateBound(_, BrAnon(_)), _) => {\n-                attrs.push((idx, lib::llvm::NoCaptureAttribute as u64));\n-                attrs.push((idx, lib::llvm::NonNullAttribute as u64));\n+                attrs.push((idx, llvm::NoCaptureAttribute as u64));\n+                attrs.push((idx, llvm::NonNullAttribute as u64));\n             }\n             // & pointer parameters are never null\n             ty::ty_rptr(_, _) => {\n-                attrs.push((idx, lib::llvm::NonNullAttribute as u64));\n+                attrs.push((idx, llvm::NonNullAttribute as u64));\n             }\n             _ => ()\n         }\n@@ -1912,7 +1912,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n                           sp: Span,\n                           sym: String,\n                           node_id: ast::NodeId,\n-                          cc: lib::llvm::CallConv,\n+                          cc: llvm::CallConv,\n                           llfty: Type) -> ValueRef {\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n@@ -2073,15 +2073,15 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         });\n \n                         if !ccx.reachable.contains(&id) {\n-                            lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n+                            llvm::SetLinkage(g, llvm::InternalLinkage);\n                         }\n \n                         // Apply the `unnamed_addr` attribute if\n                         // requested\n                         if !ast_util::static_has_significant_address(\n                                 mutbl,\n                                 i.attrs.as_slice()) {\n-                            lib::llvm::SetUnnamedAddr(g, true);\n+                            llvm::SetUnnamedAddr(g, true);\n \n                             // This is a curious case where we must make\n                             // all of these statics inlineable. If a\n@@ -2103,7 +2103,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n                         if attr::contains_name(i.attrs.as_slice(),\n                                                \"thread_local\") {\n-                            lib::llvm::set_thread_local(g, true);\n+                            llvm::set_thread_local(g, true);\n                         }\n \n                         if !inlineable {\n@@ -2241,7 +2241,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     // linkage b/c that doesn't quite make sense. Otherwise items can\n     // have internal linkage if they're not reachable.\n     if !foreign && !ccx.reachable.contains(&id) {\n-        lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n+        llvm::SetLinkage(val, llvm::InternalLinkage);\n     }\n \n     ccx.item_vals.borrow_mut().insert(id, val);"}, {"sha": "13b8ed4df6b82a9b4b933a8ce2f5c6ce11803314", "filename": "src/librustc/middle/trans/basic_block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use lib::llvm::{llvm, BasicBlockRef};\n+use llvm;\n+use llvm::{BasicBlockRef};\n use middle::trans::value::{Users, Value};\n use std::iter::{Filter, Map};\n "}, {"sha": "995ad16b59f5b303c159b15af5f34329f1d4773c", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -11,11 +11,10 @@\n #![allow(dead_code)] // FFI wrappers\n #![allow(non_snake_case_functions)]\n \n-use lib::llvm::llvm;\n-use lib::llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};\n-use lib::llvm::{Opcode, IntPredicate, RealPredicate};\n-use lib::llvm::{ValueRef, BasicBlockRef};\n-use lib;\n+use llvm;\n+use llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};\n+use llvm::{Opcode, IntPredicate, RealPredicate};\n+use llvm::{ValueRef, BasicBlockRef};\n use middle::trans::common::*;\n use syntax::codemap::Span;\n \n@@ -97,7 +96,7 @@ pub fn Switch(cx: &Block, v: ValueRef, else_: BasicBlockRef, num_cases: uint)\n \n pub fn AddCase(s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n     unsafe {\n-        if llvm::LLVMIsUndef(s) == lib::llvm::True { return; }\n+        if llvm::LLVMIsUndef(s) == llvm::True { return; }\n         llvm::LLVMAddCase(s, on_val, dest);\n     }\n }\n@@ -350,7 +349,7 @@ pub fn Load(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable.get() {\n             let ty = val_ty(pointer_val);\n-            let eltty = if ty.kind() == lib::llvm::Array {\n+            let eltty = if ty.kind() == llvm::Array {\n                 ty.element_type()\n             } else {\n                 ccx.int_type\n@@ -382,11 +381,11 @@ pub fn AtomicLoad(cx: &Block, pointer_val: ValueRef, order: AtomicOrdering) -> V\n \n \n pub fn LoadRangeAssert(cx: &Block, pointer_val: ValueRef, lo: c_ulonglong,\n-                       hi: c_ulonglong, signed: lib::llvm::Bool) -> ValueRef {\n+                       hi: c_ulonglong, signed: llvm::Bool) -> ValueRef {\n     if cx.unreachable.get() {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(pointer_val);\n-        let eltty = if ty.kind() == lib::llvm::Array {\n+        let eltty = if ty.kind() == llvm::Array {\n             ty.element_type()\n         } else {\n             ccx.int_type\n@@ -647,7 +646,7 @@ pub fn Phi(cx: &Block, ty: Type, vals: &[ValueRef],\n \n pub fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     unsafe {\n-        if llvm::LLVMIsUndef(phi) == lib::llvm::True { return; }\n+        if llvm::LLVMIsUndef(phi) == llvm::True { return; }\n         llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n     }\n }\n@@ -656,7 +655,7 @@ pub fn _UndefReturn(cx: &Block, fn_: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(fn_);\n-        let retty = if ty.kind() == lib::llvm::Integer {\n+        let retty = if ty.kind() == llvm::Integer {\n             ty.return_type()\n         } else {\n             ccx.int_type"}, {"sha": "32e91c337f0862ff8f7be65f8995a82f24ca9e6a", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -10,11 +10,10 @@\n \n #![allow(dead_code)] // FFI wrappers\n \n-use lib;\n-use lib::llvm::llvm;\n-use lib::llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};\n-use lib::llvm::{Opcode, IntPredicate, RealPredicate, False};\n-use lib::llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n+use llvm;\n+use llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};\n+use llvm::{Opcode, IntPredicate, RealPredicate, False};\n+use llvm::{ValueRef, BasicBlockRef, BuilderRef, ModuleRef};\n use middle::trans::base;\n use middle::trans::common::*;\n use middle::trans::machine::llalign_of_pref;\n@@ -460,7 +459,7 @@ impl<'a> Builder<'a> {\n         self.count_insn(\"load.volatile\");\n         unsafe {\n             let insn = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n-            llvm::LLVMSetVolatile(insn, lib::llvm::True);\n+            llvm::LLVMSetVolatile(insn, llvm::True);\n             insn\n         }\n     }\n@@ -477,7 +476,7 @@ impl<'a> Builder<'a> {\n \n \n     pub fn load_range_assert(&self, ptr: ValueRef, lo: c_ulonglong,\n-                           hi: c_ulonglong, signed: lib::llvm::Bool) -> ValueRef {\n+                           hi: c_ulonglong, signed: llvm::Bool) -> ValueRef {\n         let value = self.load(ptr);\n \n         unsafe {\n@@ -487,7 +486,7 @@ impl<'a> Builder<'a> {\n \n             let v = [min, max];\n \n-            llvm::LLVMSetMetadata(value, lib::llvm::MD_range as c_uint,\n+            llvm::LLVMSetMetadata(value, llvm::MD_range as c_uint,\n                                   llvm::LLVMMDNodeInContext(self.ccx.llcx,\n                                                             v.as_ptr(), v.len() as c_uint));\n         }\n@@ -514,7 +513,7 @@ impl<'a> Builder<'a> {\n         self.count_insn(\"store.volatile\");\n         unsafe {\n             let insn = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n-            llvm::LLVMSetVolatile(insn, lib::llvm::True);\n+            llvm::LLVMSetVolatile(insn, llvm::True);\n         }\n     }\n \n@@ -788,10 +787,10 @@ impl<'a> Builder<'a> {\n                          dia: AsmDialect) -> ValueRef {\n         self.count_insn(\"inlineasm\");\n \n-        let volatile = if volatile { lib::llvm::True }\n-                       else        { lib::llvm::False };\n-        let alignstack = if alignstack { lib::llvm::True }\n-                         else          { lib::llvm::False };\n+        let volatile = if volatile { llvm::True }\n+                       else        { llvm::False };\n+        let alignstack = if alignstack { llvm::True }\n+                         else          { llvm::False };\n \n         let argtys = inputs.iter().map(|v| {\n             debug!(\"Asm Input Type: {:?}\", self.ccx.tn.val_to_string(*v));\n@@ -832,7 +831,7 @@ impl<'a> Builder<'a> {\n                           conv: CallConv, attributes: &[(uint, u64)]) -> ValueRef {\n         self.count_insn(\"callwithconv\");\n         let v = self.call(llfn, args, attributes);\n-        lib::llvm::SetInstructionCallConv(v, conv);\n+        llvm::SetInstructionCallConv(v, conv);\n         v\n     }\n \n@@ -945,7 +944,7 @@ impl<'a> Builder<'a> {\n     pub fn set_cleanup(&self, landing_pad: ValueRef) {\n         self.count_insn(\"setcleanup\");\n         unsafe {\n-            llvm::LLVMSetCleanup(landing_pad, lib::llvm::True);\n+            llvm::LLVMSetCleanup(landing_pad, llvm::True);\n         }\n     }\n "}, {"sha": "0a10fb8b1720830e9ac54b9efd52e151075fc236", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use lib::llvm::Attribute;\n+use llvm::Attribute;\n use std::option;\n use middle::trans::context::CrateContext;\n use middle::trans::cabi_x86;"}, {"sha": "0e2bf2104fd55923bb61f002e59b03e855261489", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -10,8 +10,9 @@\n \n #![allow(non_uppercase_pattern_statics)]\n \n-use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n-use lib::llvm::{StructRetAttribute, ZExtAttribute};\n+use llvm;\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array};\n+use llvm::{StructRetAttribute, ZExtAttribute};\n use middle::trans::cabi::{FnType, ArgType};\n use middle::trans::context::CrateContext;\n use middle::trans::type_::Type;"}, {"sha": "d07090686874f9e8151d33d5fe2ac83f37b203e4", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -12,8 +12,9 @@\n \n use libc::c_uint;\n use std::cmp;\n-use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n-use lib::llvm::{StructRetAttribute, ZExtAttribute};\n+use llvm;\n+use llvm::{Integer, Pointer, Float, Double, Struct, Array};\n+use llvm::{StructRetAttribute, ZExtAttribute};\n use middle::trans::context::CrateContext;\n use middle::trans::cabi::*;\n use middle::trans::type_::Type;"}, {"sha": "6bb3d992f50c627a4745666c2072b4b729ff4694", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -10,7 +10,7 @@\n \n \n use syntax::abi::{OsWin32, OsMacos, OsiOS};\n-use lib::llvm::*;\n+use llvm::*;\n use super::cabi::*;\n use super::common::*;\n use super::machine::*;"}, {"sha": "493aca0ddf0c415e9d8e45a4738bd859b513ed4c", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -13,9 +13,10 @@\n \n #![allow(non_uppercase_pattern_statics)]\n \n-use lib::llvm::{llvm, Integer, Pointer, Float, Double};\n-use lib::llvm::{Struct, Array, Attribute};\n-use lib::llvm::{StructRetAttribute, ByValAttribute, ZExtAttribute};\n+use llvm;\n+use llvm::{Integer, Pointer, Float, Double};\n+use llvm::{Struct, Array, Attribute};\n+use llvm::{StructRetAttribute, ByValAttribute, ZExtAttribute};\n use middle::trans::cabi::*;\n use middle::trans::context::CrateContext;\n use middle::trans::type_::Type;"}, {"sha": "db2d17c85db5f64b834d0dde519ec48def0be54d", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -19,8 +19,8 @@\n use arena::TypedArena;\n use back::abi;\n use back::link;\n-use lib::llvm::ValueRef;\n-use lib::llvm::llvm;\n+use llvm;\n+use llvm::ValueRef;\n use metadata::csearch;\n use middle::def;\n use middle::subst;"}, {"sha": "6e40445d8f9038b0a7096f685cb21f9d485a2620", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -13,7 +13,7 @@\n  * drop glue. See discussion in `doc.rs` for a high-level summary.\n  */\n \n-use lib::llvm::{BasicBlockRef, ValueRef};\n+use llvm::{BasicBlockRef, ValueRef};\n use middle::trans::base;\n use middle::trans::build;\n use middle::trans::callee;"}, {"sha": "f2400f6bfefe35c6e7470151cb91d29e035a54fe", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -12,7 +12,7 @@\n use back::abi;\n use back::link::mangle_internal_name_by_path_and_seq;\n use driver::config::FullDebugInfo;\n-use lib::llvm::ValueRef;\n+use llvm::ValueRef;\n use middle::def;\n use middle::freevars;\n use middle::lang_items::ClosureExchangeMallocFnLangItem;"}, {"sha": "945185f59534208593556a85b663f67dd119ab6d", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -13,10 +13,9 @@\n //! Code that is useful in various trans modules.\n \n use driver::session::Session;\n-use lib::llvm::{ValueRef, BasicBlockRef, BuilderRef};\n-use lib::llvm::{True, False, Bool};\n-use lib::llvm::llvm;\n-use lib;\n+use llvm;\n+use llvm::{ValueRef, BasicBlockRef, BuilderRef};\n+use llvm::{True, False, Bool};\n use middle::def;\n use middle::lang_items::LangItem;\n use middle::subst;\n@@ -570,7 +569,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n         });\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n-        lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n+        llvm::SetLinkage(g, llvm::InternalLinkage);\n \n         cx.const_cstr_cache.borrow_mut().insert(s, g);\n         g\n@@ -599,7 +598,7 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n         });\n         llvm::LLVMSetInitializer(g, lldata);\n         llvm::LLVMSetGlobalConstant(g, True);\n-        lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n+        llvm::SetLinkage(g, llvm::InternalLinkage);\n \n         let cs = llvm::LLVMConstPointerCast(g, Type::i8p(cx).to_ref());\n         C_struct(cx, [cs, C_uint(cx, len)], false)"}, {"sha": "2fd468d8fda8fbe248c90b694fa146dc60fe4244", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -10,9 +10,10 @@\n \n \n use back::abi;\n-use lib::llvm::{llvm, ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, Bool, True,\n+use llvm;\n+use llvm::{ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, Bool, True,\n     False};\n-use lib::llvm::{IntEQ, IntNE, IntUGT, IntUGE, IntULT, IntULE, IntSGT, IntSGE, IntSLT, IntSLE,\n+use llvm::{IntEQ, IntNE, IntUGT, IntUGE, IntULT, IntULE, IntSGT, IntSGE, IntSLT, IntSLE,\n     RealOEQ, RealOGT, RealOGE, RealOLT, RealOLE, RealONE};\n \n use metadata::csearch;"}, {"sha": "8c55f33a0d46dd19b9c912c6f84010263704c6c1", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -10,9 +10,10 @@\n \n use driver::config::NoDebugInfo;\n use driver::session::Session;\n-use lib::llvm::{ContextRef, ModuleRef, ValueRef};\n-use lib::llvm::{llvm, TargetData, TypeNames};\n-use lib::llvm::mk_target_data;\n+use llvm;\n+use llvm::{ContextRef, ModuleRef, ValueRef};\n+use llvm::{TargetData};\n+use llvm::mk_target_data;\n use metadata::common::LinkMeta;\n use middle::resolve;\n use middle::trans::adt;\n@@ -21,7 +22,7 @@ use middle::trans::builder::Builder;\n use middle::trans::common::{ExternMap,tydesc_info,BuilderRef_res};\n use middle::trans::debuginfo;\n use middle::trans::monomorphize::MonoId;\n-use middle::trans::type_::Type;\n+use middle::trans::type_::{Type, TypeNames};\n use middle::ty;\n use util::sha2::Sha256;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap};"}, {"sha": "845684bb037a935f55f7d2abbf0bfe119621431f", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use lib::llvm::*;\n+use llvm::*;\n use driver::config::FullDebugInfo;\n use middle::def;\n use middle::lang_items::{FailFnLangItem, FailBoundsCheckFnLangItem};"}, {"sha": "d4b2b04745b58903689f66b2ae8a83000ff6e6fd", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -13,7 +13,7 @@\n  * Datums are and how they are intended to be used.\n  */\n \n-use lib::llvm::ValueRef;\n+use llvm::ValueRef;\n use middle::trans::base::*;\n use middle::trans::common::*;\n use middle::trans::cleanup;"}, {"sha": "6e81c10c4a0a91a80e5a871b742c36f1e7adcb25", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -180,9 +180,9 @@ seen before (which is most of the time). */\n \n use driver::config;\n use driver::config::{FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n-use lib::llvm::llvm;\n-use lib::llvm::{ModuleRef, ContextRef, ValueRef};\n-use lib::llvm::debuginfo::*;\n+use llvm;\n+use llvm::{ModuleRef, ContextRef, ValueRef};\n+use llvm::debuginfo::*;\n use metadata::csearch;\n use middle::subst;\n use middle::trans::adt;"}, {"sha": "60bf80191cb1057386a73b7d84f7b87a189ee877", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -34,8 +34,8 @@\n #![allow(non_camel_case_types)]\n \n use back::abi;\n-use lib::llvm::{ValueRef, llvm};\n-use lib;\n+use llvm;\n+use llvm::{ValueRef};\n use metadata::csearch;\n use middle::def;\n use middle::lang_items::MallocFnLangItem;\n@@ -548,7 +548,7 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n             debug!(\"trans_index: base {}\", bcx.val_to_string(base));\n             debug!(\"trans_index: len {}\", bcx.val_to_string(len));\n \n-            let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, len);\n+            let bounds_check = ICmp(bcx, llvm::IntUGE, ix_val, len);\n             let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n             let expected = Call(bcx,\n                                 expect,"}, {"sha": "56fbccefede5ea05f2c81ff4c73f69383193ab4c", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -10,9 +10,8 @@\n \n \n use back::{link};\n-use lib::llvm::llvm;\n-use lib::llvm::{ValueRef, CallConv, Linkage};\n-use lib;\n+use llvm;\n+use llvm::{ValueRef, CallConv, Linkage};\n use middle::weak_lang_items;\n use middle::trans::base::push_ctxt;\n use middle::trans::base;\n@@ -88,14 +87,14 @@ pub fn llvm_calling_convention(ccx: &CrateContext,\n             // It's the ABI's job to select this, not us.\n             System => ccx.sess().bug(\"system abi should be selected elsewhere\"),\n \n-            Stdcall => lib::llvm::X86StdcallCallConv,\n-            Fastcall => lib::llvm::X86FastcallCallConv,\n-            C => lib::llvm::CCallConv,\n-            Win64 => lib::llvm::X86_64_Win64,\n+            Stdcall => llvm::X86StdcallCallConv,\n+            Fastcall => llvm::X86FastcallCallConv,\n+            C => llvm::CCallConv,\n+            Win64 => llvm::X86_64_Win64,\n \n             // These API constants ought to be more specific...\n-            Cdecl => lib::llvm::CCallConv,\n-            Aapcs => lib::llvm::CCallConv,\n+            Cdecl => llvm::CCallConv,\n+            Aapcs => llvm::CCallConv,\n         }\n     })\n }\n@@ -110,17 +109,17 @@ pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n     // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n     // and don't have to be, LLVM treats them as no-ops.\n     match name {\n-        \"appending\" => Some(lib::llvm::AppendingLinkage),\n-        \"available_externally\" => Some(lib::llvm::AvailableExternallyLinkage),\n-        \"common\" => Some(lib::llvm::CommonLinkage),\n-        \"extern_weak\" => Some(lib::llvm::ExternalWeakLinkage),\n-        \"external\" => Some(lib::llvm::ExternalLinkage),\n-        \"internal\" => Some(lib::llvm::InternalLinkage),\n-        \"linkonce\" => Some(lib::llvm::LinkOnceAnyLinkage),\n-        \"linkonce_odr\" => Some(lib::llvm::LinkOnceODRLinkage),\n-        \"private\" => Some(lib::llvm::PrivateLinkage),\n-        \"weak\" => Some(lib::llvm::WeakAnyLinkage),\n-        \"weak_odr\" => Some(lib::llvm::WeakODRLinkage),\n+        \"appending\" => Some(llvm::AppendingLinkage),\n+        \"available_externally\" => Some(llvm::AvailableExternallyLinkage),\n+        \"common\" => Some(llvm::CommonLinkage),\n+        \"extern_weak\" => Some(llvm::ExternalWeakLinkage),\n+        \"external\" => Some(llvm::ExternalLinkage),\n+        \"internal\" => Some(llvm::InternalLinkage),\n+        \"linkonce\" => Some(llvm::LinkOnceAnyLinkage),\n+        \"linkonce_odr\" => Some(llvm::LinkOnceODRLinkage),\n+        \"private\" => Some(llvm::PrivateLinkage),\n+        \"weak\" => Some(llvm::WeakAnyLinkage),\n+        \"weak_odr\" => Some(llvm::WeakODRLinkage),\n         _ => None,\n     }\n }\n@@ -157,14 +156,14 @@ pub fn register_static(ccx: &CrateContext,\n                 let g1 = ident.get().with_c_str(|buf| {\n                     llvm::LLVMAddGlobal(ccx.llmod, llty2.to_ref(), buf)\n                 });\n-                lib::llvm::SetLinkage(g1, linkage);\n+                llvm::SetLinkage(g1, linkage);\n \n                 let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n                 real_name.push_str(ident.get());\n                 let g2 = real_name.with_c_str(|buf| {\n                     llvm::LLVMAddGlobal(ccx.llmod, llty.to_ref(), buf)\n                 });\n-                lib::llvm::SetLinkage(g2, lib::llvm::InternalLinkage);\n+                llvm::SetLinkage(g2, llvm::InternalLinkage);\n                 llvm::LLVMSetInitializer(g2, g1);\n                 g2\n             }\n@@ -217,7 +216,7 @@ pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi, fty: ty::t,\n     // Make sure the calling convention is right for variadic functions\n     // (should've been caught if not in typeck)\n     if tys.fn_sig.variadic {\n-        assert!(cc == lib::llvm::CCallConv);\n+        assert!(cc == llvm::CCallConv);\n     }\n \n     // Create the LLVM value for the C extern fn\n@@ -347,7 +346,7 @@ pub fn trans_native_call<'a>(\n             llarg_rust\n         } else {\n             if ty::type_is_bool(*passed_arg_tys.get(i)) {\n-                let val = LoadRangeAssert(bcx, llarg_rust, 0, 2, lib::llvm::False);\n+                let val = LoadRangeAssert(bcx, llarg_rust, 0, 2, llvm::False);\n                 Trunc(bcx, val, Type::i1(bcx.ccx()))\n             } else {\n                 Load(bcx, llarg_rust)\n@@ -384,9 +383,9 @@ pub fn trans_native_call<'a>(\n     if fn_type.ret_ty.is_indirect() {\n         // The outptr can be noalias and nocapture because it's entirely\n         // invisible to the program. We can also mark it as nonnull\n-        attrs.push((1, lib::llvm::NoAliasAttribute as u64));\n-        attrs.push((1, lib::llvm::NoCaptureAttribute as u64));\n-        attrs.push((1, lib::llvm::NonNullAttribute as u64));\n+        attrs.push((1, llvm::NoAliasAttribute as u64));\n+        attrs.push((1, llvm::NoCaptureAttribute as u64));\n+        attrs.push((1, llvm::NonNullAttribute as u64));\n     };\n \n     // Add attributes that depend on the concrete foreign ABI\n@@ -531,7 +530,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let cconv = match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             let c = llvm_calling_convention(ccx, fn_ty.abi);\n-            c.unwrap_or(lib::llvm::CCallConv)\n+            c.unwrap_or(llvm::CCallConv)\n         }\n         _ => fail!(\"expected bare fn in register_rust_fn_with_foreign_abi\")\n     };\n@@ -743,7 +742,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n                 llforeign_arg\n             } else {\n                 if ty::type_is_bool(rust_ty) {\n-                    let tmp = builder.load_range_assert(llforeign_arg, 0, 2, lib::llvm::False);\n+                    let tmp = builder.load_range_assert(llforeign_arg, 0, 2, llvm::False);\n                     builder.trunc(tmp, Type::i1(ccx))\n                 } else {\n                     builder.load(llforeign_arg)"}, {"sha": "40065d0bc5053f327562956d7f3bbb003d1804ae", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -15,8 +15,8 @@\n \n use back::abi;\n use back::link::*;\n-use lib::llvm::{llvm, ValueRef, True};\n-use lib;\n+use llvm;\n+use llvm::{ValueRef, True};\n use middle::lang_items::{FreeFnLangItem, ExchangeFreeFnLangItem};\n use middle::subst;\n use middle::trans::adt;\n@@ -492,7 +492,7 @@ fn make_generic_glue(ccx: &CrateContext,\n \n     let bcx = init_function(&fcx, false, ty::mk_nil());\n \n-    lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n+    llvm::SetLinkage(llfn, llvm::InternalLinkage);\n     ccx.stats.n_glues_created.set(ccx.stats.n_glues_created.get() + 1u);\n     // All glue functions take values passed *by alias*; this is a\n     // requirement since in many contexts glue is invoked indirectly and\n@@ -550,7 +550,7 @@ pub fn emit_tydescs(ccx: &CrateContext) {\n             let gvar = ti.tydesc;\n             llvm::LLVMSetInitializer(gvar, tydesc);\n             llvm::LLVMSetGlobalConstant(gvar, True);\n-            lib::llvm::SetLinkage(gvar, lib::llvm::InternalLinkage);\n+            llvm::SetLinkage(gvar, llvm::InternalLinkage);\n         }\n     };\n }"}, {"sha": "d64eeb727e733bdc6820a4c77c8336911a47d9eb", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use lib::llvm::{AvailableExternallyLinkage, SetLinkage};\n+use llvm::{AvailableExternallyLinkage, SetLinkage};\n use metadata::csearch;\n use middle::astencode;\n use middle::trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};"}, {"sha": "bb33a5e4f8d2fa5a1b392a47d6212ae85d617f11", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -10,8 +10,8 @@\n \n #![allow(non_uppercase_pattern_statics)]\n \n-use lib::llvm::{SequentiallyConsistent, Acquire, Release, Xchg, ValueRef};\n-use lib;\n+use llvm;\n+use llvm::{SequentiallyConsistent, Acquire, Release, Xchg, ValueRef};\n use middle::subst;\n use middle::subst::FnSpace;\n use middle::trans::base::*;\n@@ -426,13 +426,13 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n             assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n \n             let order = if split.len() == 2 {\n-                lib::llvm::SequentiallyConsistent\n+                llvm::SequentiallyConsistent\n             } else {\n                 match *split.get(2) {\n-                    \"relaxed\" => lib::llvm::Monotonic,\n-                    \"acq\"     => lib::llvm::Acquire,\n-                    \"rel\"     => lib::llvm::Release,\n-                    \"acqrel\"  => lib::llvm::AcquireRelease,\n+                    \"relaxed\" => llvm::Monotonic,\n+                    \"acq\"     => llvm::Acquire,\n+                    \"rel\"     => llvm::Release,\n+                    \"acqrel\"  => llvm::AcquireRelease,\n                     _ => ccx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n                 }\n             };\n@@ -443,23 +443,23 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n                     // of this, I assume that it's good enough for us to use for\n                     // now.\n                     let strongest_failure_ordering = match order {\n-                        lib::llvm::NotAtomic | lib::llvm::Unordered =>\n+                        llvm::NotAtomic | llvm::Unordered =>\n                             ccx.sess().fatal(\"cmpxchg must be atomic\"),\n \n-                        lib::llvm::Monotonic | lib::llvm::Release =>\n-                            lib::llvm::Monotonic,\n+                        llvm::Monotonic | llvm::Release =>\n+                            llvm::Monotonic,\n \n-                        lib::llvm::Acquire | lib::llvm::AcquireRelease =>\n-                            lib::llvm::Acquire,\n+                        llvm::Acquire | llvm::AcquireRelease =>\n+                            llvm::Acquire,\n \n-                        lib::llvm::SequentiallyConsistent =>\n-                            lib::llvm::SequentiallyConsistent\n+                        llvm::SequentiallyConsistent =>\n+                            llvm::SequentiallyConsistent\n                     };\n \n                     let res = AtomicCmpXchg(bcx, *llargs.get(0), *llargs.get(1),\n                                             *llargs.get(2), order,\n                                             strongest_failure_ordering);\n-                    if unsafe { lib::llvm::llvm::LLVMVersionMinor() >= 5 } {\n+                    if unsafe { llvm::LLVMVersionMinor() >= 5 } {\n                         ExtractValue(bcx, res, 0)\n                     } else {\n                         res\n@@ -482,17 +482,17 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n                 // These are all AtomicRMW ops\n                 op => {\n                     let atom_op = match op {\n-                        \"xchg\"  => lib::llvm::Xchg,\n-                        \"xadd\"  => lib::llvm::Add,\n-                        \"xsub\"  => lib::llvm::Sub,\n-                        \"and\"   => lib::llvm::And,\n-                        \"nand\"  => lib::llvm::Nand,\n-                        \"or\"    => lib::llvm::Or,\n-                        \"xor\"   => lib::llvm::Xor,\n-                        \"max\"   => lib::llvm::Max,\n-                        \"min\"   => lib::llvm::Min,\n-                        \"umax\"  => lib::llvm::UMax,\n-                        \"umin\"  => lib::llvm::UMin,\n+                        \"xchg\"  => llvm::Xchg,\n+                        \"xadd\"  => llvm::Add,\n+                        \"xsub\"  => llvm::Sub,\n+                        \"and\"   => llvm::And,\n+                        \"nand\"  => llvm::Nand,\n+                        \"or\"    => llvm::Or,\n+                        \"xor\"   => llvm::Xor,\n+                        \"max\"   => llvm::Max,\n+                        \"min\"   => llvm::Min,\n+                        \"umax\"  => llvm::UMax,\n+                        \"umin\"  => llvm::UMin,\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n "}, {"sha": "2740e5695be107b76b92a4c2f99671e6a7d1db7a", "filename": "src/librustc/middle/trans/llrepr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -10,7 +10,7 @@\n \n use middle::trans::context::CrateContext;\n use middle::trans::type_::Type;\n-use lib::llvm::ValueRef;\n+use llvm::ValueRef;\n \n pub trait LlvmRepr {\n     fn llrepr(&self, ccx: &CrateContext) -> String;"}, {"sha": "15bbc5ae845898390644965b38ea10c53076e574", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -10,9 +10,9 @@\n \n // Information concerning the machine representation of various types.\n \n-use lib::llvm::{ValueRef};\n-use lib::llvm::False;\n-use lib::llvm::llvm;\n+use llvm;\n+use llvm::{ValueRef};\n+use llvm::False;\n use middle::trans::common::*;\n \n use middle::trans::type_::Type;"}, {"sha": "092a524e48a1898476d7c283cbfa92cb20735415", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -10,9 +10,8 @@\n \n \n use back::abi;\n-use lib::llvm::llvm;\n-use lib::llvm::ValueRef;\n-use lib;\n+use llvm;\n+use llvm::ValueRef;\n use metadata::csearch;\n use middle::subst;\n use middle::trans::base::*;\n@@ -460,8 +459,8 @@ pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl).to_ref(), buf)\n         });\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n-        llvm::LLVMSetGlobalConstant(vt_gvar, lib::llvm::True);\n-        lib::llvm::SetLinkage(vt_gvar, lib::llvm::InternalLinkage);\n+        llvm::LLVMSetGlobalConstant(vt_gvar, llvm::True);\n+        llvm::SetLinkage(vt_gvar, llvm::InternalLinkage);\n         vt_gvar\n     }\n }"}, {"sha": "7687e82654a9201e3e891927116951e53d08745e", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -10,7 +10,7 @@\n \n use back::link::exported_name;\n use driver::session;\n-use lib::llvm::ValueRef;\n+use llvm::ValueRef;\n use middle::subst;\n use middle::subst::Subst;\n use middle::trans::base::{set_llvm_fn_attrs, set_inline_hint};"}, {"sha": "bc156fc37917cc8ec1c9601b3f0cad308f70d044", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n use back::link::mangle_internal_name_by_path_and_seq;\n-use lib::llvm::{ValueRef, llvm};\n+use llvm;\n+use llvm::{ValueRef};\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;"}, {"sha": "07571b2f4c4a509d036263308e2787ed2c4085eb", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -11,8 +11,8 @@\n #![allow(non_camel_case_types)]\n \n use back::abi;\n-use lib;\n-use lib::llvm::{llvm, ValueRef};\n+use llvm;\n+use llvm::{ValueRef};\n use middle::lang_items::StrDupUniqFnLangItem;\n use middle::trans::base::*;\n use middle::trans::base;\n@@ -543,7 +543,7 @@ pub fn iter_vec_loop<'r,\n     { // i < count\n         let lhs = Load(cond_bcx, loop_counter);\n         let rhs = count;\n-        let cond_val = ICmp(cond_bcx, lib::llvm::IntULT, lhs, rhs);\n+        let cond_val = ICmp(cond_bcx, llvm::IntULT, lhs, rhs);\n \n         CondBr(cond_bcx, cond_val, body_bcx.llbb, next_bcx.llbb);\n     }\n@@ -599,7 +599,7 @@ pub fn iter_vec_raw<'r,\n         let data_ptr =\n             Phi(header_bcx, val_ty(data_ptr), [data_ptr], [bcx.llbb]);\n         let not_yet_at_end =\n-            ICmp(header_bcx, lib::llvm::IntULT, data_ptr, data_end_ptr);\n+            ICmp(header_bcx, llvm::IntULT, data_ptr, data_end_ptr);\n         let body_bcx = fcx.new_temp_block(\"iter_vec_loop_body\");\n         let next_bcx = fcx.new_temp_block(\"iter_vec_next\");\n         CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb);"}, {"sha": "573965108ad9468671343b120ebb9b513209b7a9", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -10,8 +10,9 @@\n \n #![allow(non_uppercase_pattern_statics)]\n \n-use lib::llvm::{llvm, TypeRef, Bool, False, True, TypeKind};\n-use lib::llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n+use llvm;\n+use llvm::{TypeRef, Bool, False, True, TypeKind, ValueRef};\n+use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use middle::trans::context::CrateContext;\n \n@@ -20,8 +21,11 @@ use syntax::abi::{X86, X86_64, Arm, Mips, Mipsel};\n \n use std::c_str::ToCStr;\n use std::mem;\n+use std::cell::RefCell;\n+use std::collections::HashMap;\n+use std::str::raw::from_c_str;\n \n-use libc::{c_uint};\n+use libc::{c_uint, c_void, free};\n \n #[deriving(Clone, PartialEq, Show)]\n pub struct Type {\n@@ -303,3 +307,50 @@ impl Type {\n         }\n     }\n }\n+\n+\n+/* Memory-managed object interface to type handles. */\n+\n+pub struct TypeNames {\n+    named_types: RefCell<HashMap<String, TypeRef>>,\n+}\n+\n+impl TypeNames {\n+    pub fn new() -> TypeNames {\n+        TypeNames {\n+            named_types: RefCell::new(HashMap::new())\n+        }\n+    }\n+\n+    pub fn associate_type(&self, s: &str, t: &Type) {\n+        assert!(self.named_types.borrow_mut().insert(s.to_string(),\n+                                                     t.to_ref()));\n+    }\n+\n+    pub fn find_type(&self, s: &str) -> Option<Type> {\n+        self.named_types.borrow().find_equiv(&s).map(|x| Type::from_ref(*x))\n+    }\n+\n+    pub fn type_to_string(&self, ty: Type) -> String {\n+        unsafe {\n+            let s = llvm::LLVMTypeToString(ty.to_ref());\n+            let ret = from_c_str(s);\n+            free(s as *mut c_void);\n+            ret.to_string()\n+        }\n+    }\n+\n+    pub fn types_to_str(&self, tys: &[Type]) -> String {\n+        let strs: Vec<String> = tys.iter().map(|t| self.type_to_string(*t)).collect();\n+        format!(\"[{}]\", strs.connect(\",\"))\n+    }\n+\n+    pub fn val_to_string(&self, val: ValueRef) -> String {\n+        unsafe {\n+            let s = llvm::LLVMValueToString(val);\n+            let ret = from_c_str(s);\n+            free(s as *mut c_void);\n+            ret.to_string()\n+        }\n+    }\n+}"}, {"sha": "2db6a87a9dc53a99b8fcb216421fe9489ddda57e", "filename": "src/librustc/middle/trans/value.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use lib::llvm::{llvm, UseRef, ValueRef};\n+use llvm;\n+use llvm::{UseRef, ValueRef};\n use middle::trans::basic_block::BasicBlock;\n use middle::trans::common::Block;\n use libc::c_uint;"}, {"sha": "c722beb43ae955c9e7ebdc487638dad5cf422cf2", "filename": "src/librustc_back/abi.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fabi.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "previous_filename": "src/librustc/back/abi.rs"}, {"sha": "c4a9d9c80ef1284ccf197a8723cace79e52ba43b", "filename": "src/librustc_back/archive.rs", "status": "renamed", "additions": 54, "deletions": 86, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -10,36 +10,40 @@\n \n //! A helper class for dealing with static archives\n \n-use back::link::{get_ar_prog};\n-use driver::session::Session;\n-use metadata::filesearch;\n-use lib::llvm::{ArchiveRef, llvm};\n-\n-use libc;\n use std::io::process::{Command, ProcessOutput};\n use std::io::{fs, TempDir};\n use std::io;\n-use std::mem;\n use std::os;\n-use std::raw;\n use std::str;\n use syntax::abi;\n+use ErrorHandler = syntax::diagnostic::Handler;\n \n pub static METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n \n-pub struct Archive<'a> {\n-    sess: &'a Session,\n-    dst: Path,\n+pub struct ArchiveConfig<'a> {\n+    pub handler: &'a ErrorHandler,\n+    pub dst: Path,\n+    pub lib_search_paths: Vec<Path>,\n+    pub os: abi::Os,\n+    pub maybe_ar_prog: Option<String>\n }\n \n-pub struct ArchiveRO {\n-    ptr: ArchiveRef,\n+pub struct Archive<'a> {\n+    handler: &'a ErrorHandler,\n+    dst: Path,\n+    lib_search_paths: Vec<Path>,\n+    os: abi::Os,\n+    maybe_ar_prog: Option<String>\n }\n \n-fn run_ar(sess: &Session, args: &str, cwd: Option<&Path>,\n+fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n+          args: &str, cwd: Option<&Path>,\n           paths: &[&Path]) -> ProcessOutput {\n-    let ar = get_ar_prog(sess);\n-    let mut cmd = Command::new(ar.as_slice());\n+    let ar = match *maybe_ar_prog {\n+        Some(ref ar) => ar.as_slice(),\n+        None => \"ar\"\n+    };\n+    let mut cmd = Command::new(ar);\n \n     cmd.arg(args).args(paths);\n     debug!(\"{}\", cmd);\n@@ -56,42 +60,55 @@ fn run_ar(sess: &Session, args: &str, cwd: Option<&Path>,\n         Ok(prog) => {\n             let o = prog.wait_with_output().unwrap();\n             if !o.status.success() {\n-                sess.err(format!(\"{} failed with: {}\",\n+                handler.err(format!(\"{} failed with: {}\",\n                                  cmd,\n                                  o.status).as_slice());\n-                sess.note(format!(\"stdout ---\\n{}\",\n+                handler.note(format!(\"stdout ---\\n{}\",\n                                   str::from_utf8(o.output\n                                                   .as_slice()).unwrap())\n                           .as_slice());\n-                sess.note(format!(\"stderr ---\\n{}\",\n+                handler.note(format!(\"stderr ---\\n{}\",\n                                   str::from_utf8(o.error\n                                                   .as_slice()).unwrap())\n                           .as_slice());\n-                sess.abort_if_errors();\n+                handler.abort_if_errors();\n             }\n             o\n         },\n         Err(e) => {\n-            sess.err(format!(\"could not exec `{}`: {}\", ar.as_slice(),\n+            handler.err(format!(\"could not exec `{}`: {}\", ar.as_slice(),\n                              e).as_slice());\n-            sess.abort_if_errors();\n+            handler.abort_if_errors();\n             fail!(\"rustc::back::archive::run_ar() should not reach this point\");\n         }\n     }\n }\n \n impl<'a> Archive<'a> {\n     /// Initializes a new static archive with the given object file\n-    pub fn create<'b>(sess: &'a Session, dst: &'b Path,\n-                      initial_object: &'b Path) -> Archive<'a> {\n-        run_ar(sess, \"crus\", None, [dst, initial_object]);\n-        Archive { sess: sess, dst: dst.clone() }\n+    pub fn create<'b>(config: ArchiveConfig<'a>, initial_object: &'b Path) -> Archive<'a> {\n+        let ArchiveConfig { handler, dst, lib_search_paths, os, maybe_ar_prog } = config;\n+        run_ar(handler, &maybe_ar_prog, \"crus\", None, [&dst, initial_object]);\n+        Archive {\n+            handler: handler,\n+            dst: dst,\n+            lib_search_paths: lib_search_paths,\n+            os: os,\n+            maybe_ar_prog: maybe_ar_prog\n+        }\n     }\n \n     /// Opens an existing static archive\n-    pub fn open(sess: &'a Session, dst: Path) -> Archive<'a> {\n+    pub fn open(config: ArchiveConfig<'a>) -> Archive<'a> {\n+        let ArchiveConfig { handler, dst, lib_search_paths, os, maybe_ar_prog } = config;\n         assert!(dst.exists());\n-        Archive { sess: sess, dst: dst }\n+        Archive {\n+            handler: handler,\n+            dst: dst,\n+            lib_search_paths: lib_search_paths,\n+            os: os,\n+            maybe_ar_prog: maybe_ar_prog\n+        }\n     }\n \n     /// Adds all of the contents of a native library to this archive. This will\n@@ -120,22 +137,22 @@ impl<'a> Archive<'a> {\n     /// Adds an arbitrary file to this archive\n     pub fn add_file(&mut self, file: &Path, has_symbols: bool) {\n         let cmd = if has_symbols {\"r\"} else {\"rS\"};\n-        run_ar(self.sess, cmd, None, [&self.dst, file]);\n+        run_ar(self.handler, &self.maybe_ar_prog, cmd, None, [&self.dst, file]);\n     }\n \n     /// Removes a file from this archive\n     pub fn remove_file(&mut self, file: &str) {\n-        run_ar(self.sess, \"d\", None, [&self.dst, &Path::new(file)]);\n+        run_ar(self.handler, &self.maybe_ar_prog, \"d\", None, [&self.dst, &Path::new(file)]);\n     }\n \n     /// Updates all symbols in the archive (runs 'ar s' over it)\n     pub fn update_symbols(&mut self) {\n-        run_ar(self.sess, \"s\", None, [&self.dst]);\n+        run_ar(self.handler, &self.maybe_ar_prog, \"s\", None, [&self.dst]);\n     }\n \n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<String> {\n-        let output = run_ar(self.sess, \"t\", None, [&self.dst]);\n+        let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, [&self.dst]);\n         let output = str::from_utf8(output.output.as_slice()).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n@@ -148,7 +165,7 @@ impl<'a> Archive<'a> {\n \n         // First, extract the contents of the archive to a temporary directory\n         let archive = os::make_absolute(archive);\n-        run_ar(self.sess, \"x\", Some(loc.path()), [&archive]);\n+        run_ar(self.handler, &self.maybe_ar_prog, \"x\", Some(loc.path()), [&archive]);\n \n         // Next, we must rename all of the inputs to \"guaranteed unique names\".\n         // The reason for this is that archives are keyed off the name of the\n@@ -184,23 +201,20 @@ impl<'a> Archive<'a> {\n         // Finally, add all the renamed files to this archive\n         let mut args = vec!(&self.dst);\n         args.extend(inputs.iter());\n-        run_ar(self.sess, \"r\", None, args.as_slice());\n+        run_ar(self.handler, &self.maybe_ar_prog, \"r\", None, args.as_slice());\n         Ok(())\n     }\n \n     fn find_library(&self, name: &str) -> Path {\n-        let (osprefix, osext) = match self.sess.targ_cfg.os {\n+        let (osprefix, osext) = match self.os {\n             abi::OsWin32 => (\"\", \"lib\"), _ => (\"lib\", \"a\"),\n         };\n         // On Windows, static libraries sometimes show up as libfoo.a and other\n         // times show up as foo.lib\n         let oslibname = format!(\"{}{}.{}\", osprefix, name, osext);\n         let unixlibname = format!(\"lib{}.a\", name);\n \n-        let mut rustpath = filesearch::rust_path();\n-        rustpath.push(self.sess.target_filesearch().get_lib_path());\n-        let search = self.sess.opts.addl_lib_search_paths.borrow();\n-        for path in search.iter().chain(rustpath.iter()) {\n+        for path in self.lib_search_paths.iter() {\n             debug!(\"looking for {} inside {}\", name, path.display());\n             let test = path.join(oslibname.as_slice());\n             if test.exists() { return test }\n@@ -209,55 +223,9 @@ impl<'a> Archive<'a> {\n                 if test.exists() { return test }\n             }\n         }\n-        self.sess.fatal(format!(\"could not find native static library `{}`, \\\n+        self.handler.fatal(format!(\"could not find native static library `{}`, \\\n                                  perhaps an -L flag is missing?\",\n                                 name).as_slice());\n     }\n }\n \n-impl ArchiveRO {\n-    /// Opens a static archive for read-only purposes. This is more optimized\n-    /// than the `open` method because it uses LLVM's internal `Archive` class\n-    /// rather than shelling out to `ar` for everything.\n-    ///\n-    /// If this archive is used with a mutable method, then an error will be\n-    /// raised.\n-    pub fn open(dst: &Path) -> Option<ArchiveRO> {\n-        unsafe {\n-            let ar = dst.with_c_str(|dst| {\n-                llvm::LLVMRustOpenArchive(dst)\n-            });\n-            if ar.is_null() {\n-                None\n-            } else {\n-                Some(ArchiveRO { ptr: ar })\n-            }\n-        }\n-    }\n-\n-    /// Reads a file in the archive\n-    pub fn read<'a>(&'a self, file: &str) -> Option<&'a [u8]> {\n-        unsafe {\n-            let mut size = 0 as libc::size_t;\n-            let ptr = file.with_c_str(|file| {\n-                llvm::LLVMRustArchiveReadSection(self.ptr, file, &mut size)\n-            });\n-            if ptr.is_null() {\n-                None\n-            } else {\n-                Some(mem::transmute(raw::Slice {\n-                    data: ptr,\n-                    len: size as uint,\n-                }))\n-            }\n-        }\n-    }\n-}\n-\n-impl Drop for ArchiveRO {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMRustDestroyArchive(self.ptr);\n-        }\n-    }\n-}", "previous_filename": "src/librustc/back/archive.rs"}, {"sha": "a0730360ec7298c6aa9b41a16eeb6e454f9ef90c", "filename": "src/librustc_back/arm.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farm.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::target_strs;\n+use target_strs;\n use syntax::abi;\n \n pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs::t {", "previous_filename": "src/librustc/back/arm.rs"}, {"sha": "c051b8e60cd80ef0cbdf46f83b0b620ab6350e21", "filename": "src/librustc_back/fs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "previous_filename": "src/librustc/util/fs.rs"}, {"sha": "8ec74f4d6efcc4076141306acd806ae915f0ef2a", "filename": "src/librustc_back/lib.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Some stuff used by rustc that doesn't have many dependencies\n+//!\n+//! Originally extracted from rustc::back, which was nominally the\n+//! compiler 'backend', though LLVM is rustc's backend, so rustc_back\n+//! is really just odds-and-ends relating to code gen and linking.\n+//! This crate mostly exists to make rustc smaller, so we might put\n+//! more 'stuff' here in the future.  It does not have a dependency on\n+//! rustc_llvm.\n+//!\n+//! FIXME: Split this into two crates: one that has deps on syntax, and\n+//! one that doesn't; the one that doesn't might get decent parallel\n+//! build speedups.\n+\n+#![crate_id = \"rustc_back#0.11.0-pre\"]\n+#![crate_name = \"rustc_back\"]\n+#![experimental]\n+#![comment = \"The Rust compiler minimal-dependency dumping-ground\"]\n+#![license = \"MIT/ASL2\"]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+      html_root_url = \"http://doc.rust-lang.org/\")]\n+\n+#![feature(globs, phase, macro_rules)]\n+#![allow(unused_attribute)] // NOTE: remove after stage0\n+\n+#[phase(plugin, link)]\n+extern crate log;\n+extern crate syntax;\n+extern crate libc;\n+extern crate flate;\n+extern crate serialize;\n+\n+pub mod abi;\n+pub mod archive;\n+pub mod arm;\n+pub mod fs;\n+pub mod mips;\n+pub mod mipsel;\n+pub mod rpath;\n+pub mod sha2;\n+pub mod svh;\n+pub mod target_strs;\n+pub mod x86;\n+pub mod x86_64;"}, {"sha": "4176d0e9a6f57a5ac3fddbd4c6f320cb9b6d9909", "filename": "src/librustc_back/mips.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fmips.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::target_strs;\n+use target_strs;\n use syntax::abi;\n \n pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs::t {", "previous_filename": "src/librustc/back/mips.rs"}, {"sha": "d3ea9d3aa7237e2facabd94138bc3863bb3a2a17", "filename": "src/librustc_back/mipsel.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Fmipsel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Fmipsel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fmipsel.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::target_strs;\n+use target_strs;\n use syntax::abi;\n \n pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs::t {", "previous_filename": "src/librustc/back/mipsel.rs"}, {"sha": "e298e1dbfe94acba5f456f649dadfd6d8fce0434", "filename": "src/librustc_back/rpath.rs", "status": "renamed", "additions": 58, "deletions": 84, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -9,81 +9,70 @@\n // except according to those terms.\n \n \n-use driver::session::Session;\n-use metadata::cstore;\n-use metadata::filesearch;\n-use util::fs;\n-\n use std::collections::HashSet;\n use std::os;\n+use std::io::IoError;\n use syntax::abi;\n-\n-fn not_win32(os: abi::Os) -> bool {\n-  os != abi::OsWin32\n+use syntax::ast;\n+\n+pub struct RPathConfig<'a> {\n+    pub os: abi::Os,\n+    pub used_crates: Vec<(ast::CrateNum, Option<Path>)>,\n+    pub out_filename: Path,\n+    pub get_install_prefix_lib_path: ||:'a -> Path,\n+    pub realpath: |&Path|:'a -> Result<Path, IoError>\n }\n \n-pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<String> {\n-    let os = sess.targ_cfg.os;\n+pub fn get_rpath_flags(config: RPathConfig) -> Vec<String> {\n \n     // No rpath on windows\n-    if os == abi::OsWin32 {\n+    if config.os == abi::OsWin32 {\n         return Vec::new();\n     }\n \n     let mut flags = Vec::new();\n \n-    if sess.targ_cfg.os == abi::OsFreebsd {\n+    if config.os == abi::OsFreebsd {\n         flags.push_all([\"-Wl,-rpath,/usr/local/lib/gcc46\".to_string(),\n                         \"-Wl,-rpath,/usr/local/lib/gcc44\".to_string(),\n                         \"-Wl,-z,origin\".to_string()]);\n     }\n \n     debug!(\"preparing the RPATH!\");\n \n-    let sysroot = sess.sysroot();\n-    let output = out_filename;\n-    let libs = sess.cstore.get_used_crates(cstore::RequireDynamic);\n+    let libs = config.used_crates.clone();\n     let libs = libs.move_iter().filter_map(|(_, l)| {\n         l.map(|p| p.clone())\n     }).collect::<Vec<_>>();\n \n-    let rpaths = get_rpaths(os,\n-                            sysroot,\n-                            output,\n-                            libs.as_slice(),\n-                            sess.opts.target_triple.as_slice());\n+    let rpaths = get_rpaths(config, libs.as_slice());\n     flags.push_all(rpaths_to_flags(rpaths.as_slice()).as_slice());\n     flags\n }\n \n-pub fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n+fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     let mut ret = Vec::new();\n     for rpath in rpaths.iter() {\n         ret.push(format!(\"-Wl,-rpath,{}\", (*rpath).as_slice()));\n     }\n     return ret;\n }\n \n-fn get_rpaths(os: abi::Os,\n-              sysroot: &Path,\n-              output: &Path,\n-              libs: &[Path],\n-              target_triple: &str) -> Vec<String> {\n-    debug!(\"sysroot: {}\", sysroot.display());\n-    debug!(\"output: {}\", output.display());\n+fn get_rpaths(mut config: RPathConfig,\n+              libs: &[Path]) -> Vec<String> {\n+    debug!(\"output: {}\", config.out_filename.display());\n     debug!(\"libs:\");\n     for libpath in libs.iter() {\n         debug!(\"    {}\", libpath.display());\n     }\n-    debug!(\"target_triple: {}\", target_triple);\n \n     // Use relative paths to the libraries. Binaries can be moved\n     // as long as they maintain the relative relationship to the\n     // crates they depend on.\n-    let rel_rpaths = get_rpaths_relative_to_output(os, output, libs);\n+    let rel_rpaths = get_rpaths_relative_to_output(&mut config, libs);\n \n     // And a final backup rpath to the global library location.\n-    let fallback_rpaths = vec!(get_install_prefix_rpath(sysroot, target_triple));\n+    let fallback_rpaths = vec!(get_install_prefix_rpath(config));\n \n     fn log_rpaths(desc: &str, rpaths: &[String]) {\n         debug!(\"{} rpaths:\", desc);\n@@ -103,31 +92,28 @@ fn get_rpaths(os: abi::Os,\n     return rpaths;\n }\n \n-fn get_rpaths_relative_to_output(os: abi::Os,\n-                                 output: &Path,\n+fn get_rpaths_relative_to_output(config: &mut RPathConfig,\n                                  libs: &[Path]) -> Vec<String> {\n-    libs.iter().map(|a| get_rpath_relative_to_output(os, output, a)).collect()\n+    libs.iter().map(|a| get_rpath_relative_to_output(config, a)).collect()\n }\n \n-pub fn get_rpath_relative_to_output(os: abi::Os,\n-                                    output: &Path,\n-                                    lib: &Path)\n-                                 -> String {\n+fn get_rpath_relative_to_output(config: &mut RPathConfig,\n+                                lib: &Path) -> String {\n     use std::os;\n \n-    assert!(not_win32(os));\n+    assert!(config.os != abi::OsWin32);\n \n     // Mac doesn't appear to support $ORIGIN\n-    let prefix = match os {\n+    let prefix = match config.os {\n         abi::OsAndroid | abi::OsLinux | abi::OsFreebsd\n                           => \"$ORIGIN\",\n         abi::OsMacos => \"@loader_path\",\n         abi::OsWin32 | abi::OsiOS => unreachable!()\n     };\n \n-    let mut lib = fs::realpath(&os::make_absolute(lib)).unwrap();\n+    let mut lib = (config.realpath)(&os::make_absolute(lib)).unwrap();\n     lib.pop();\n-    let mut output = fs::realpath(&os::make_absolute(output)).unwrap();\n+    let mut output = (config.realpath)(&os::make_absolute(&config.out_filename)).unwrap();\n     output.pop();\n     let relative = lib.path_relative_from(&output);\n     let relative = relative.expect(\"could not create rpath relative to output\");\n@@ -137,18 +123,14 @@ pub fn get_rpath_relative_to_output(os: abi::Os,\n             relative.as_str().expect(\"non-utf8 component in path\"))\n }\n \n-pub fn get_install_prefix_rpath(sysroot: &Path, target_triple: &str) -> String {\n-    let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n-\n-    let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n-    let mut path = Path::new(install_prefix);\n-    path.push(&tlib);\n+fn get_install_prefix_rpath(config: RPathConfig) -> String {\n+    let path = (config.get_install_prefix_lib_path)();\n     let path = os::make_absolute(&path);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     path.as_str().expect(\"non-utf8 component in rpath\").to_string()\n }\n \n-pub fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n+fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n     let mut set = HashSet::new();\n     let mut minimized = Vec::new();\n     for rpath in rpaths.iter() {\n@@ -161,10 +143,9 @@ pub fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n \n #[cfg(unix, test)]\n mod test {\n-    use back::rpath::get_install_prefix_rpath;\n-    use back::rpath::{minimize_rpaths, rpaths_to_flags, get_rpath_relative_to_output};\n+    use super::{RPathConfig};\n+    use super::{minimize_rpaths, rpaths_to_flags, get_rpath_relative_to_output};\n     use syntax::abi;\n-    use metadata::filesearch;\n \n     #[test]\n     fn test_rpaths_to_flags() {\n@@ -177,27 +158,6 @@ mod test {\n                         \"-Wl,-rpath,path2\".to_string()));\n     }\n \n-    #[test]\n-    fn test_prefix_rpath() {\n-        let sysroot = filesearch::get_or_default_sysroot();\n-        let res = get_install_prefix_rpath(&sysroot, \"triple\");\n-        let mut d = Path::new((option_env!(\"CFG_PREFIX\")).expect(\"CFG_PREFIX\"));\n-        d.push(\"lib\");\n-        d.push(filesearch::rustlibdir());\n-        d.push(\"triple/lib\");\n-        debug!(\"test_prefix_path: {} vs. {}\",\n-               res,\n-               d.display());\n-        assert!(res.as_bytes().ends_with(d.as_vec()));\n-    }\n-\n-    #[test]\n-    fn test_prefix_rpath_abs() {\n-        let sysroot = filesearch::get_or_default_sysroot();\n-        let res = get_install_prefix_rpath(&sysroot, \"triple\");\n-        assert!(Path::new(res).is_absolute());\n-    }\n-\n     #[test]\n     fn test_minimize1() {\n         let res = minimize_rpaths([\n@@ -237,28 +197,42 @@ mod test {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     fn test_rpath_relative() {\n-      let o = abi::OsLinux;\n-      let res = get_rpath_relative_to_output(o,\n-            &Path::new(\"bin/rustc\"), &Path::new(\"lib/libstd.so\"));\n-      assert_eq!(res.as_slice(), \"$ORIGIN/../lib\");\n+        let config = &mut RPathConfig {\n+            os: abi::OsLinux,\n+            used_crates: Vec::new(),\n+            out_filename: Path::new(\"bin/rustc\"),\n+            get_install_prefix_lib_path: || fail!(),\n+            realpath: |p| Ok(p.clone())\n+        };\n+        let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n+        assert_eq!(res.as_slice(), \"$ORIGIN/../lib\");\n     }\n \n     #[test]\n     #[cfg(target_os = \"freebsd\")]\n     fn test_rpath_relative() {\n-        let o = abi::OsFreebsd;\n-        let res = get_rpath_relative_to_output(o,\n-            &Path::new(\"bin/rustc\"), &Path::new(\"lib/libstd.so\"));\n+        let config = &mut RPathConfig {\n+            os: abi::OsFreebsd,\n+            used_crates: Vec::new(),\n+            out_filename: Path::new(\"bin/rustc\"),\n+            get_install_prefix_lib_path: || fail!(),\n+            realpath: |p| Ok(p.clone())\n+        };\n+        let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n         assert_eq!(res.as_slice(), \"$ORIGIN/../lib\");\n     }\n \n     #[test]\n     #[cfg(target_os = \"macos\")]\n     fn test_rpath_relative() {\n-        let o = abi::OsMacos;\n-        let res = get_rpath_relative_to_output(o,\n-                                               &Path::new(\"bin/rustc\"),\n-                                               &Path::new(\"lib/libstd.so\"));\n+        let config = &mut RPathConfig {\n+            os: abi::OsMacos,\n+            used_crates: Vec::new(),\n+            out_filename: Path::new(\"bin/rustc\"),\n+            get_install_prefix_lib_path: || fail!(),\n+            realpath: |p| Ok(p.clone())\n+        };\n+        let res = get_rpath_relative_to_output(config, &Path::new(\"lib/libstd.so\"));\n         assert_eq!(res.as_slice(), \"@loader_path/../lib\");\n     }\n }", "previous_filename": "src/librustc/back/rpath.rs"}, {"sha": "681de6a6626be14b36d9fa5961eeceb78f4e60c6", "filename": "src/librustc_back/sha2.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -12,6 +12,8 @@\n //! use. This implementation is not intended for external use or for any use where security is\n //! important.\n \n+#![allow(deprecated)] // to_be32\n+\n use std::iter::range_step;\n use std::num::Zero;\n use std::slice::bytes::{MutableByteVector, copy_memory};", "previous_filename": "src/librustc/util/sha2.rs"}, {"sha": "66bc8c740c47fb092225d360b835b027bfe599b9", "filename": "src/librustc_back/svh.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -53,8 +53,6 @@ use std::iter::range_step;\n use syntax::ast;\n use syntax::visit;\n \n-use driver::session::Session;\n-\n #[deriving(Clone, PartialEq)]\n pub struct Svh {\n     hash: String,\n@@ -70,7 +68,7 @@ impl Svh {\n         self.hash.as_slice()\n     }\n \n-    pub fn calculate(sess: &Session, krate: &ast::Crate) -> Svh {\n+    pub fn calculate(metadata: &Vec<String>, krate: &ast::Crate) -> Svh {\n         // FIXME (#14132): This is better than it used to be, but it still not\n         // ideal. We now attempt to hash only the relevant portions of the\n         // Crate AST as well as the top-level crate attributes. (However,\n@@ -82,7 +80,7 @@ impl Svh {\n         //        avoid collisions.\n         let mut state = SipState::new();\n \n-        for data in sess.opts.cg.metadata.iter() {\n+        for data in metadata.iter() {\n             data.hash(&mut state);\n         }\n ", "previous_filename": "src/librustc/back/svh.rs"}, {"sha": "7928f3d8db098167d7571824ea1b7d5666835a21", "filename": "src/librustc_back/target_strs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Ftarget_strs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Ftarget_strs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget_strs.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "previous_filename": "src/librustc/back/target_strs.rs"}, {"sha": "b4d67bc98d2e3b14c3a315f43d2814a927965679", "filename": "src/librustc_back/x86.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fx86.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use back::target_strs;\n+use target_strs;\n use syntax::abi;\n \n pub fn get_target_strs(target_triple: String, target_os: abi::Os)", "previous_filename": "src/librustc/back/x86.rs"}, {"sha": "70807edc9960e3c9ec05a623d5235102fd528a71", "filename": "src/librustc_back/x86_64.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_back%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fx86_64.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use back::target_strs;\n+use target_strs;\n use syntax::abi;\n \n pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs::t {", "previous_filename": "src/librustc/back/x86_64.rs"}, {"sha": "6c3778787e2e24e5fd3cc2a663fdacce258d56d5", "filename": "src/librustc_llvm/archive_ro.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A wrapper around LLVM's archive (.a) code\n+\n+use libc;\n+use ArchiveRef;\n+\n+use std::raw;\n+use std::mem;\n+\n+pub struct ArchiveRO {\n+    ptr: ArchiveRef,\n+}\n+\n+impl ArchiveRO {\n+    /// Opens a static archive for read-only purposes. This is more optimized\n+    /// than the `open` method because it uses LLVM's internal `Archive` class\n+    /// rather than shelling out to `ar` for everything.\n+    ///\n+    /// If this archive is used with a mutable method, then an error will be\n+    /// raised.\n+    pub fn open(dst: &Path) -> Option<ArchiveRO> {\n+        unsafe {\n+            let ar = dst.with_c_str(|dst| {\n+                ::LLVMRustOpenArchive(dst)\n+            });\n+            if ar.is_null() {\n+                None\n+            } else {\n+                Some(ArchiveRO { ptr: ar })\n+            }\n+        }\n+    }\n+\n+    /// Reads a file in the archive\n+    pub fn read<'a>(&'a self, file: &str) -> Option<&'a [u8]> {\n+        unsafe {\n+            let mut size = 0 as libc::size_t;\n+            let ptr = file.with_c_str(|file| {\n+                ::LLVMRustArchiveReadSection(self.ptr, file, &mut size)\n+            });\n+            if ptr.is_null() {\n+                None\n+            } else {\n+                Some(mem::transmute(raw::Slice {\n+                    data: ptr,\n+                    len: size as uint,\n+                }))\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for ArchiveRO {\n+    fn drop(&mut self) {\n+        unsafe {\n+            ::LLVMRustDestroyArchive(self.ptr);\n+        }\n+    }\n+}"}, {"sha": "9ee8fa98c7499ca98654052dbf93557222c2e362", "filename": "src/librustc_llvm/lib.rs", "status": "added", "additions": 2003, "deletions": 0, "changes": 2003, "blob_url": "https://github.com/rust-lang/rust/blob/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eadfe42e58de0263286195e7560cb85337a3847/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=2eadfe42e58de0263286195e7560cb85337a3847", "patch": "@@ -0,0 +1,2003 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_uppercase_pattern_statics)]\n+#![allow(non_camel_case_types)]\n+#![allow(non_snake_case_functions)]\n+#![allow(dead_code)]\n+\n+#![crate_id = \"rustc_llvm#0.11.0\"]\n+#![crate_name = \"rustc_llvm\"]\n+#![experimental]\n+#![license = \"MIT/ASL2\"]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+       html_root_url = \"http://doc.rust-lang.org/\")]\n+\n+#![feature(globs)]\n+#![feature(link_args)]\n+#![allow(unused_attribute)] // NOTE: remove after stage0\n+\n+extern crate libc;\n+\n+use std::c_str::ToCStr;\n+use libc::{c_uint, c_ushort, uint64_t, c_int, size_t, c_char};\n+use libc::{c_longlong, c_ulonglong};\n+use debuginfo::{DIBuilderRef, DIDescriptor,\n+                DIFile, DILexicalBlock, DISubprogram, DIType,\n+                DIBasicType, DIDerivedType, DICompositeType,\n+                DIVariable, DIGlobalVariable, DIArray, DISubrange};\n+\n+pub mod archive_ro;\n+\n+pub type Opcode = u32;\n+pub type Bool = c_uint;\n+\n+pub static True: Bool = 1 as Bool;\n+pub static False: Bool = 0 as Bool;\n+\n+// Consts for the LLVM CallConv type, pre-cast to uint.\n+\n+#[deriving(PartialEq)]\n+pub enum CallConv {\n+    CCallConv = 0,\n+    FastCallConv = 8,\n+    ColdCallConv = 9,\n+    X86StdcallCallConv = 64,\n+    X86FastcallCallConv = 65,\n+    X86_64_Win64 = 79,\n+}\n+\n+pub enum Visibility {\n+    LLVMDefaultVisibility = 0,\n+    HiddenVisibility = 1,\n+    ProtectedVisibility = 2,\n+}\n+\n+// This enum omits the obsolete (and no-op) linkage types DLLImportLinkage,\n+// DLLExportLinkage, GhostLinkage and LinkOnceODRAutoHideLinkage.\n+// LinkerPrivateLinkage and LinkerPrivateWeakLinkage are not included either;\n+// they've been removed in upstream LLVM commit r203866.\n+pub enum Linkage {\n+    ExternalLinkage = 0,\n+    AvailableExternallyLinkage = 1,\n+    LinkOnceAnyLinkage = 2,\n+    LinkOnceODRLinkage = 3,\n+    WeakAnyLinkage = 5,\n+    WeakODRLinkage = 6,\n+    AppendingLinkage = 7,\n+    InternalLinkage = 8,\n+    PrivateLinkage = 9,\n+    ExternalWeakLinkage = 12,\n+    CommonLinkage = 14,\n+}\n+\n+#[deriving(Clone)]\n+pub enum Attribute {\n+    ZExtAttribute = 1 << 0,\n+    SExtAttribute = 1 << 1,\n+    NoReturnAttribute = 1 << 2,\n+    InRegAttribute = 1 << 3,\n+    StructRetAttribute = 1 << 4,\n+    NoUnwindAttribute = 1 << 5,\n+    NoAliasAttribute = 1 << 6,\n+    ByValAttribute = 1 << 7,\n+    NestAttribute = 1 << 8,\n+    ReadNoneAttribute = 1 << 9,\n+    ReadOnlyAttribute = 1 << 10,\n+    NoInlineAttribute = 1 << 11,\n+    AlwaysInlineAttribute = 1 << 12,\n+    OptimizeForSizeAttribute = 1 << 13,\n+    StackProtectAttribute = 1 << 14,\n+    StackProtectReqAttribute = 1 << 15,\n+    AlignmentAttribute = 31 << 16,\n+    NoCaptureAttribute = 1 << 21,\n+    NoRedZoneAttribute = 1 << 22,\n+    NoImplicitFloatAttribute = 1 << 23,\n+    NakedAttribute = 1 << 24,\n+    InlineHintAttribute = 1 << 25,\n+    StackAttribute = 7 << 26,\n+    ReturnsTwiceAttribute = 1 << 29,\n+    UWTableAttribute = 1 << 30,\n+    NonLazyBindAttribute = 1 << 31,\n+}\n+\n+#[repr(u64)]\n+pub enum OtherAttribute {\n+    // The following are not really exposed in\n+    // the LLVM c api so instead to add these\n+    // we call a wrapper function in RustWrapper\n+    // that uses the C++ api.\n+    SanitizeAddressAttribute = 1 << 32,\n+    MinSizeAttribute = 1 << 33,\n+    NoDuplicateAttribute = 1 << 34,\n+    StackProtectStrongAttribute = 1 << 35,\n+    SanitizeThreadAttribute = 1 << 36,\n+    SanitizeMemoryAttribute = 1 << 37,\n+    NoBuiltinAttribute = 1 << 38,\n+    ReturnedAttribute = 1 << 39,\n+    ColdAttribute = 1 << 40,\n+    BuiltinAttribute = 1 << 41,\n+    OptimizeNoneAttribute = 1 << 42,\n+    InAllocaAttribute = 1 << 43,\n+    NonNullAttribute = 1 << 44,\n+}\n+\n+#[repr(C)]\n+pub enum AttributeSet {\n+    ReturnIndex = 0,\n+    FunctionIndex = !0\n+}\n+\n+// enum for the LLVM IntPredicate type\n+pub enum IntPredicate {\n+    IntEQ = 32,\n+    IntNE = 33,\n+    IntUGT = 34,\n+    IntUGE = 35,\n+    IntULT = 36,\n+    IntULE = 37,\n+    IntSGT = 38,\n+    IntSGE = 39,\n+    IntSLT = 40,\n+    IntSLE = 41,\n+}\n+\n+// enum for the LLVM RealPredicate type\n+pub enum RealPredicate {\n+    RealPredicateFalse = 0,\n+    RealOEQ = 1,\n+    RealOGT = 2,\n+    RealOGE = 3,\n+    RealOLT = 4,\n+    RealOLE = 5,\n+    RealONE = 6,\n+    RealORD = 7,\n+    RealUNO = 8,\n+    RealUEQ = 9,\n+    RealUGT = 10,\n+    RealUGE = 11,\n+    RealULT = 12,\n+    RealULE = 13,\n+    RealUNE = 14,\n+    RealPredicateTrue = 15,\n+}\n+\n+// The LLVM TypeKind type - must stay in sync with the def of\n+// LLVMTypeKind in llvm/include/llvm-c/Core.h\n+#[deriving(PartialEq)]\n+#[repr(C)]\n+pub enum TypeKind {\n+    Void      = 0,\n+    Half      = 1,\n+    Float     = 2,\n+    Double    = 3,\n+    X86_FP80  = 4,\n+    FP128     = 5,\n+    PPC_FP128 = 6,\n+    Label     = 7,\n+    Integer   = 8,\n+    Function  = 9,\n+    Struct    = 10,\n+    Array     = 11,\n+    Pointer   = 12,\n+    Vector    = 13,\n+    Metadata  = 14,\n+    X86_MMX   = 15,\n+}\n+\n+#[repr(C)]\n+pub enum AtomicBinOp {\n+    Xchg = 0,\n+    Add  = 1,\n+    Sub  = 2,\n+    And  = 3,\n+    Nand = 4,\n+    Or   = 5,\n+    Xor  = 6,\n+    Max  = 7,\n+    Min  = 8,\n+    UMax = 9,\n+    UMin = 10,\n+}\n+\n+#[repr(C)]\n+pub enum AtomicOrdering {\n+    NotAtomic = 0,\n+    Unordered = 1,\n+    Monotonic = 2,\n+    // Consume = 3,  // Not specified yet.\n+    Acquire = 4,\n+    Release = 5,\n+    AcquireRelease = 6,\n+    SequentiallyConsistent = 7\n+}\n+\n+// Consts for the LLVMCodeGenFileType type (in include/llvm/c/TargetMachine.h)\n+#[repr(C)]\n+pub enum FileType {\n+    AssemblyFile = 0,\n+    ObjectFile = 1\n+}\n+\n+pub enum Metadata {\n+    MD_dbg = 0,\n+    MD_tbaa = 1,\n+    MD_prof = 2,\n+    MD_fpmath = 3,\n+    MD_range = 4,\n+    MD_tbaa_struct = 5\n+}\n+\n+// Inline Asm Dialect\n+pub enum AsmDialect {\n+    AD_ATT   = 0,\n+    AD_Intel = 1\n+}\n+\n+#[deriving(PartialEq)]\n+#[repr(C)]\n+pub enum CodeGenOptLevel {\n+    CodeGenLevelNone = 0,\n+    CodeGenLevelLess = 1,\n+    CodeGenLevelDefault = 2,\n+    CodeGenLevelAggressive = 3,\n+}\n+\n+#[repr(C)]\n+pub enum RelocMode {\n+    RelocDefault = 0,\n+    RelocStatic = 1,\n+    RelocPIC = 2,\n+    RelocDynamicNoPic = 3,\n+}\n+\n+#[repr(C)]\n+pub enum CodeGenModel {\n+    CodeModelDefault = 0,\n+    CodeModelJITDefault = 1,\n+    CodeModelSmall = 2,\n+    CodeModelKernel = 3,\n+    CodeModelMedium = 4,\n+    CodeModelLarge = 5,\n+}\n+\n+// Opaque pointer types\n+pub enum Module_opaque {}\n+pub type ModuleRef = *mut Module_opaque;\n+pub enum Context_opaque {}\n+pub type ContextRef = *mut Context_opaque;\n+pub enum Type_opaque {}\n+pub type TypeRef = *mut Type_opaque;\n+pub enum Value_opaque {}\n+pub type ValueRef = *mut Value_opaque;\n+pub enum BasicBlock_opaque {}\n+pub type BasicBlockRef = *mut BasicBlock_opaque;\n+pub enum Builder_opaque {}\n+pub type BuilderRef = *mut Builder_opaque;\n+pub enum ExecutionEngine_opaque {}\n+pub type ExecutionEngineRef = *mut ExecutionEngine_opaque;\n+pub enum MemoryBuffer_opaque {}\n+pub type MemoryBufferRef = *mut MemoryBuffer_opaque;\n+pub enum PassManager_opaque {}\n+pub type PassManagerRef = *mut PassManager_opaque;\n+pub enum PassManagerBuilder_opaque {}\n+pub type PassManagerBuilderRef = *mut PassManagerBuilder_opaque;\n+pub enum Use_opaque {}\n+pub type UseRef = *mut Use_opaque;\n+pub enum TargetData_opaque {}\n+pub type TargetDataRef = *mut TargetData_opaque;\n+pub enum ObjectFile_opaque {}\n+pub type ObjectFileRef = *mut ObjectFile_opaque;\n+pub enum SectionIterator_opaque {}\n+pub type SectionIteratorRef = *mut SectionIterator_opaque;\n+pub enum Pass_opaque {}\n+pub type PassRef = *mut Pass_opaque;\n+pub enum TargetMachine_opaque {}\n+pub type TargetMachineRef = *mut TargetMachine_opaque;\n+pub enum Archive_opaque {}\n+pub type ArchiveRef = *mut Archive_opaque;\n+\n+pub mod debuginfo {\n+    use super::{ValueRef};\n+\n+    pub enum DIBuilder_opaque {}\n+    pub type DIBuilderRef = *mut DIBuilder_opaque;\n+\n+    pub type DIDescriptor = ValueRef;\n+    pub type DIScope = DIDescriptor;\n+    pub type DILocation = DIDescriptor;\n+    pub type DIFile = DIScope;\n+    pub type DILexicalBlock = DIScope;\n+    pub type DISubprogram = DIScope;\n+    pub type DIType = DIDescriptor;\n+    pub type DIBasicType = DIType;\n+    pub type DIDerivedType = DIType;\n+    pub type DICompositeType = DIDerivedType;\n+    pub type DIVariable = DIDescriptor;\n+    pub type DIGlobalVariable = DIDescriptor;\n+    pub type DIArray = DIDescriptor;\n+    pub type DISubrange = DIDescriptor;\n+\n+    pub enum DIDescriptorFlags {\n+      FlagPrivate            = 1 << 0,\n+      FlagProtected          = 1 << 1,\n+      FlagFwdDecl            = 1 << 2,\n+      FlagAppleBlock         = 1 << 3,\n+      FlagBlockByrefStruct   = 1 << 4,\n+      FlagVirtual            = 1 << 5,\n+      FlagArtificial         = 1 << 6,\n+      FlagExplicit           = 1 << 7,\n+      FlagPrototyped         = 1 << 8,\n+      FlagObjcClassComplete  = 1 << 9,\n+      FlagObjectPointer      = 1 << 10,\n+      FlagVector             = 1 << 11,\n+      FlagStaticMember       = 1 << 12\n+    }\n+}\n+\n+\n+// Link to our native llvm bindings (things that we need to use the C++ api\n+// for) and because llvm is written in C++ we need to link against libstdc++\n+//\n+// You'll probably notice that there is an omission of all LLVM libraries\n+// from this location. This is because the set of LLVM libraries that we\n+// link to is mostly defined by LLVM, and the `llvm-config` tool is used to\n+// figure out the exact set of libraries. To do this, the build system\n+// generates an llvmdeps.rs file next to this one which will be\n+// automatically updated whenever LLVM is updated to include an up-to-date\n+// set of the libraries we need to link to LLVM for.\n+#[link(name = \"rustllvm\", kind = \"static\")]\n+extern {\n+    /* Create and destroy contexts. */\n+    pub fn LLVMContextCreate() -> ContextRef;\n+    pub fn LLVMContextDispose(C: ContextRef);\n+    pub fn LLVMGetMDKindIDInContext(C: ContextRef,\n+                                    Name: *const c_char,\n+                                    SLen: c_uint)\n+                                    -> c_uint;\n+\n+    /* Create and destroy modules. */\n+    pub fn LLVMModuleCreateWithNameInContext(ModuleID: *const c_char,\n+                                             C: ContextRef)\n+                                             -> ModuleRef;\n+    pub fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n+    pub fn LLVMDisposeModule(M: ModuleRef);\n+\n+    /** Data layout. See Module::getDataLayout. */\n+    pub fn LLVMGetDataLayout(M: ModuleRef) -> *const c_char;\n+    pub fn LLVMSetDataLayout(M: ModuleRef, Triple: *const c_char);\n+\n+    /** Target triple. See Module::getTargetTriple. */\n+    pub fn LLVMGetTarget(M: ModuleRef) -> *const c_char;\n+    pub fn LLVMSetTarget(M: ModuleRef, Triple: *const c_char);\n+\n+    /** See Module::dump. */\n+    pub fn LLVMDumpModule(M: ModuleRef);\n+\n+    /** See Module::setModuleInlineAsm. */\n+    pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n+\n+    /** See llvm::LLVMTypeKind::getTypeID. */\n+    pub fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n+\n+    /** See llvm::LLVMType::getContext. */\n+    pub fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n+\n+    /* Operations on integer types */\n+    pub fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMIntTypeInContext(C: ContextRef, NumBits: c_uint)\n+                                -> TypeRef;\n+\n+    pub fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n+\n+    /* Operations on real types */\n+    pub fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMX86FP80TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMFP128TypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n+\n+    /* Operations on function types */\n+    pub fn LLVMFunctionType(ReturnType: TypeRef,\n+                            ParamTypes: *const TypeRef,\n+                            ParamCount: c_uint,\n+                            IsVarArg: Bool)\n+                            -> TypeRef;\n+    pub fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n+    pub fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n+    pub fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *const TypeRef);\n+\n+    /* Operations on struct types */\n+    pub fn LLVMStructTypeInContext(C: ContextRef,\n+                                   ElementTypes: *const TypeRef,\n+                                   ElementCount: c_uint,\n+                                   Packed: Bool)\n+                                   -> TypeRef;\n+    pub fn LLVMCountStructElementTypes(StructTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetStructElementTypes(StructTy: TypeRef,\n+                                     Dest: *mut TypeRef);\n+    pub fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n+\n+    /* Operations on array, pointer, and vector types (sequence types) */\n+    pub fn LLVMRustArrayType(ElementType: TypeRef, ElementCount: u64) -> TypeRef;\n+    pub fn LLVMPointerType(ElementType: TypeRef, AddressSpace: c_uint)\n+                           -> TypeRef;\n+    pub fn LLVMVectorType(ElementType: TypeRef, ElementCount: c_uint)\n+                          -> TypeRef;\n+\n+    pub fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n+    pub fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n+    pub fn LLVMGetPointerToGlobal(EE: ExecutionEngineRef, V: ValueRef)\n+                                  -> *const ();\n+    pub fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n+\n+    /* Operations on other types */\n+    pub fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMLabelTypeInContext(C: ContextRef) -> TypeRef;\n+    pub fn LLVMMetadataTypeInContext(C: ContextRef) -> TypeRef;\n+\n+    /* Operations on all values */\n+    pub fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n+    pub fn LLVMGetValueName(Val: ValueRef) -> *const c_char;\n+    pub fn LLVMSetValueName(Val: ValueRef, Name: *const c_char);\n+    pub fn LLVMDumpValue(Val: ValueRef);\n+    pub fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n+    pub fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n+    pub fn LLVMGetMetadata(Val: ValueRef, KindID: c_uint) -> ValueRef;\n+    pub fn LLVMSetMetadata(Val: ValueRef, KindID: c_uint, Node: ValueRef);\n+\n+    /* Operations on Uses */\n+    pub fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n+    pub fn LLVMGetNextUse(U: UseRef) -> UseRef;\n+    pub fn LLVMGetUser(U: UseRef) -> ValueRef;\n+    pub fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n+\n+    /* Operations on Users */\n+    pub fn LLVMGetNumOperands(Val: ValueRef) -> c_int;\n+    pub fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n+    pub fn LLVMSetOperand(Val: ValueRef, Index: c_uint, Op: ValueRef);\n+\n+    /* Operations on constants of any type */\n+    pub fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n+    /* all zeroes */\n+    pub fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMConstICmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstFCmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n+                         -> ValueRef;\n+    /* only for int/vector */\n+    pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMIsConstant(Val: ValueRef) -> Bool;\n+    pub fn LLVMIsNull(Val: ValueRef) -> Bool;\n+    pub fn LLVMIsUndef(Val: ValueRef) -> Bool;\n+    pub fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n+\n+    /* Operations on metadata */\n+    pub fn LLVMMDStringInContext(C: ContextRef,\n+                                 Str: *const c_char,\n+                                 SLen: c_uint)\n+                                 -> ValueRef;\n+    pub fn LLVMMDNodeInContext(C: ContextRef,\n+                               Vals: *const ValueRef,\n+                               Count: c_uint)\n+                               -> ValueRef;\n+    pub fn LLVMAddNamedMetadataOperand(M: ModuleRef,\n+                                       Str: *const c_char,\n+                                       Val: ValueRef);\n+\n+    /* Operations on scalar constants */\n+    pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool)\n+                        -> ValueRef;\n+    pub fn LLVMConstIntOfString(IntTy: TypeRef, Text: *const c_char, Radix: u8)\n+                                -> ValueRef;\n+    pub fn LLVMConstIntOfStringAndSize(IntTy: TypeRef,\n+                                       Text: *const c_char,\n+                                       SLen: c_uint,\n+                                       Radix: u8)\n+                                       -> ValueRef;\n+    pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n+    pub fn LLVMConstRealOfString(RealTy: TypeRef, Text: *const c_char)\n+                                 -> ValueRef;\n+    pub fn LLVMConstRealOfStringAndSize(RealTy: TypeRef,\n+                                        Text: *const c_char,\n+                                        SLen: c_uint)\n+                                        -> ValueRef;\n+    pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n+    pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n+\n+\n+    /* Operations on composite constants */\n+    pub fn LLVMConstStringInContext(C: ContextRef,\n+                                    Str: *const c_char,\n+                                    Length: c_uint,\n+                                    DontNullTerminate: Bool)\n+                                    -> ValueRef;\n+    pub fn LLVMConstStructInContext(C: ContextRef,\n+                                    ConstantVals: *const ValueRef,\n+                                    Count: c_uint,\n+                                    Packed: Bool)\n+                                    -> ValueRef;\n+\n+    pub fn LLVMConstArray(ElementTy: TypeRef,\n+                          ConstantVals: *const ValueRef,\n+                          Length: c_uint)\n+                          -> ValueRef;\n+    pub fn LLVMConstVector(ScalarConstantVals: *const ValueRef, Size: c_uint)\n+                           -> ValueRef;\n+\n+    /* Constant expressions */\n+    pub fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n+    pub fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstNSWNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstNUWNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n+    pub fn LLVMConstAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstNSWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstNUWAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFAdd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstNSWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstNUWSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFSub(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstNSWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstNUWMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFMul(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstUDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstSDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstExactSDiv(LHSConstant: ValueRef,\n+                              RHSConstant: ValueRef)\n+                              -> ValueRef;\n+    pub fn LLVMConstFDiv(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstURem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstSRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstFRem(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstAnd(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstOr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                       -> ValueRef;\n+    pub fn LLVMConstXor(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstShl(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                        -> ValueRef;\n+    pub fn LLVMConstLShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstGEP(ConstantVal: ValueRef,\n+                        ConstantIndices: *const ValueRef,\n+                        NumIndices: c_uint)\n+                        -> ValueRef;\n+    pub fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n+                                ConstantIndices: *const ValueRef,\n+                                NumIndices: c_uint)\n+                                -> ValueRef;\n+    pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n+                          -> ValueRef;\n+    pub fn LLVMConstSExt(ConstantVal: ValueRef, ToType: TypeRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstZExt(ConstantVal: ValueRef, ToType: TypeRef)\n+                         -> ValueRef;\n+    pub fn LLVMConstFPTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n+                            -> ValueRef;\n+    pub fn LLVMConstFPExt(ConstantVal: ValueRef, ToType: TypeRef)\n+                          -> ValueRef;\n+    pub fn LLVMConstUIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstSIToFP(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFPToUI(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstFPToSI(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstPtrToInt(ConstantVal: ValueRef, ToType: TypeRef)\n+                             -> ValueRef;\n+    pub fn LLVMConstIntToPtr(ConstantVal: ValueRef, ToType: TypeRef)\n+                             -> ValueRef;\n+    pub fn LLVMConstBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                            -> ValueRef;\n+    pub fn LLVMConstZExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstSExtOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstTruncOrBitCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                   -> ValueRef;\n+    pub fn LLVMConstPointerCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                                -> ValueRef;\n+    pub fn LLVMConstIntCast(ConstantVal: ValueRef,\n+                            ToType: TypeRef,\n+                            isSigned: Bool)\n+                            -> ValueRef;\n+    pub fn LLVMConstFPCast(ConstantVal: ValueRef, ToType: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstSelect(ConstantCondition: ValueRef,\n+                           ConstantIfTrue: ValueRef,\n+                           ConstantIfFalse: ValueRef)\n+                           -> ValueRef;\n+    pub fn LLVMConstExtractElement(VectorConstant: ValueRef,\n+                                   IndexConstant: ValueRef)\n+                                   -> ValueRef;\n+    pub fn LLVMConstInsertElement(VectorConstant: ValueRef,\n+                                  ElementValueConstant: ValueRef,\n+                                  IndexConstant: ValueRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstShuffleVector(VectorAConstant: ValueRef,\n+                                  VectorBConstant: ValueRef,\n+                                  MaskConstant: ValueRef)\n+                                  -> ValueRef;\n+    pub fn LLVMConstExtractValue(AggConstant: ValueRef,\n+                                 IdxList: *const c_uint,\n+                                 NumIdx: c_uint)\n+                                 -> ValueRef;\n+    pub fn LLVMConstInsertValue(AggConstant: ValueRef,\n+                                ElementValueConstant: ValueRef,\n+                                IdxList: *const c_uint,\n+                                NumIdx: c_uint)\n+                                -> ValueRef;\n+    pub fn LLVMConstInlineAsm(Ty: TypeRef,\n+                              AsmString: *const c_char,\n+                              Constraints: *const c_char,\n+                              HasSideEffects: Bool,\n+                              IsAlignStack: Bool)\n+                              -> ValueRef;\n+    pub fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef) -> ValueRef;\n+\n+\n+\n+    /* Operations on global variables, functions, and aliases (globals) */\n+    pub fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n+    pub fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n+    pub fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n+    pub fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n+    pub fn LLVMGetSection(Global: ValueRef) -> *const c_char;\n+    pub fn LLVMSetSection(Global: ValueRef, Section: *const c_char);\n+    pub fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n+    pub fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n+    pub fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n+    pub fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n+\n+\n+    /* Operations on global variables */\n+    pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMAddGlobalInAddressSpace(M: ModuleRef,\n+                                       Ty: TypeRef,\n+                                       Name: *const c_char,\n+                                       AddressSpace: c_uint)\n+                                       -> ValueRef;\n+    pub fn LLVMGetNamedGlobal(M: ModuleRef, Name: *const c_char) -> ValueRef;\n+    pub fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousGlobal(GlobalVar: ValueRef) -> ValueRef;\n+    pub fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n+    pub fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n+    pub fn LLVMSetInitializer(GlobalVar: ValueRef,\n+                              ConstantVal: ValueRef);\n+    pub fn LLVMIsThreadLocal(GlobalVar: ValueRef) -> Bool;\n+    pub fn LLVMSetThreadLocal(GlobalVar: ValueRef, IsThreadLocal: Bool);\n+    pub fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n+    pub fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n+\n+    /* Operations on aliases */\n+    pub fn LLVMAddAlias(M: ModuleRef,\n+                        Ty: TypeRef,\n+                        Aliasee: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+\n+    /* Operations on functions */\n+    pub fn LLVMAddFunction(M: ModuleRef,\n+                           Name: *const c_char,\n+                           FunctionTy: TypeRef)\n+                           -> ValueRef;\n+    pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;\n+    pub fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n+    pub fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMDeleteFunction(Fn: ValueRef);\n+    pub fn LLVMGetOrInsertFunction(M: ModuleRef,\n+                                   Name: *const c_char,\n+                                   FunctionTy: TypeRef)\n+                                   -> ValueRef;\n+    pub fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n+    pub fn LLVMGetGC(Fn: ValueRef) -> *const c_char;\n+    pub fn LLVMSetGC(Fn: ValueRef, Name: *const c_char);\n+    pub fn LLVMAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: uint64_t);\n+    pub fn LLVMAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n+    pub fn LLVMRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n+    pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_ulonglong;\n+\n+    /* Operations on parameters */\n+    pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMGetParams(Fn: ValueRef, Params: *const ValueRef);\n+    pub fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n+    pub fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n+    pub fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n+    pub fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n+    pub fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n+    pub fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n+    pub fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n+\n+    /* Operations on basic blocks */\n+    pub fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n+    pub fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n+    pub fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *const ValueRef);\n+    pub fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetNextBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n+    pub fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n+    pub fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+\n+    pub fn LLVMAppendBasicBlockInContext(C: ContextRef,\n+                                         Fn: ValueRef,\n+                                         Name: *const c_char)\n+                                         -> BasicBlockRef;\n+    pub fn LLVMInsertBasicBlockInContext(C: ContextRef,\n+                                         BB: BasicBlockRef,\n+                                         Name: *const c_char)\n+                                         -> BasicBlockRef;\n+    pub fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n+\n+    pub fn LLVMMoveBasicBlockAfter(BB: BasicBlockRef,\n+                                   MoveAfter: BasicBlockRef);\n+\n+    pub fn LLVMMoveBasicBlockBefore(BB: BasicBlockRef,\n+                                    MoveBefore: BasicBlockRef);\n+\n+    /* Operations on instructions */\n+    pub fn LLVMGetInstructionParent(Inst: ValueRef) -> BasicBlockRef;\n+    pub fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMGetLastInstruction(BB: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMInstructionEraseFromParent(Inst: ValueRef);\n+\n+    /* Operations on call sites */\n+    pub fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n+    pub fn LLVMGetInstructionCallConv(Instr: ValueRef) -> c_uint;\n+    pub fn LLVMAddInstrAttribute(Instr: ValueRef,\n+                                 index: c_uint,\n+                                 IA: c_uint);\n+    pub fn LLVMRemoveInstrAttribute(Instr: ValueRef,\n+                                    index: c_uint,\n+                                    IA: c_uint);\n+    pub fn LLVMSetInstrParamAlignment(Instr: ValueRef,\n+                                      index: c_uint,\n+                                      align: c_uint);\n+    pub fn LLVMAddCallSiteAttribute(Instr: ValueRef,\n+                                    index: c_uint,\n+                                    Val: uint64_t);\n+\n+    /* Operations on call instructions (only) */\n+    pub fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n+    pub fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n+\n+    /* Operations on load/store instructions (only) */\n+    pub fn LLVMGetVolatile(MemoryAccessInst: ValueRef) -> Bool;\n+    pub fn LLVMSetVolatile(MemoryAccessInst: ValueRef, volatile: Bool);\n+\n+    /* Operations on phi nodes */\n+    pub fn LLVMAddIncoming(PhiNode: ValueRef,\n+                           IncomingValues: *const ValueRef,\n+                           IncomingBlocks: *const BasicBlockRef,\n+                           Count: c_uint);\n+    pub fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n+    pub fn LLVMGetIncomingValue(PhiNode: ValueRef, Index: c_uint)\n+                                -> ValueRef;\n+    pub fn LLVMGetIncomingBlock(PhiNode: ValueRef, Index: c_uint)\n+                                -> BasicBlockRef;\n+\n+    /* Instruction builders */\n+    pub fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n+    pub fn LLVMPositionBuilder(Builder: BuilderRef,\n+                               Block: BasicBlockRef,\n+                               Instr: ValueRef);\n+    pub fn LLVMPositionBuilderBefore(Builder: BuilderRef,\n+                                     Instr: ValueRef);\n+    pub fn LLVMPositionBuilderAtEnd(Builder: BuilderRef,\n+                                    Block: BasicBlockRef);\n+    pub fn LLVMGetInsertBlock(Builder: BuilderRef) -> BasicBlockRef;\n+    pub fn LLVMClearInsertionPosition(Builder: BuilderRef);\n+    pub fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n+    pub fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef,\n+                                         Instr: ValueRef,\n+                                         Name: *const c_char);\n+    pub fn LLVMDisposeBuilder(Builder: BuilderRef);\n+    pub fn LLVMDisposeExecutionEngine(EE: ExecutionEngineRef);\n+\n+    /* Metadata */\n+    pub fn LLVMSetCurrentDebugLocation(Builder: BuilderRef, L: ValueRef);\n+    pub fn LLVMGetCurrentDebugLocation(Builder: BuilderRef) -> ValueRef;\n+    pub fn LLVMSetInstDebugLocation(Builder: BuilderRef, Inst: ValueRef);\n+\n+    /* Terminators */\n+    pub fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n+    pub fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n+    pub fn LLVMBuildAggregateRet(B: BuilderRef,\n+                                 RetVals: *const ValueRef,\n+                                 N: c_uint)\n+                                 -> ValueRef;\n+    pub fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n+    pub fn LLVMBuildCondBr(B: BuilderRef,\n+                           If: ValueRef,\n+                           Then: BasicBlockRef,\n+                           Else: BasicBlockRef)\n+                           -> ValueRef;\n+    pub fn LLVMBuildSwitch(B: BuilderRef,\n+                           V: ValueRef,\n+                           Else: BasicBlockRef,\n+                           NumCases: c_uint)\n+                           -> ValueRef;\n+    pub fn LLVMBuildIndirectBr(B: BuilderRef,\n+                               Addr: ValueRef,\n+                               NumDests: c_uint)\n+                               -> ValueRef;\n+    pub fn LLVMBuildInvoke(B: BuilderRef,\n+                           Fn: ValueRef,\n+                           Args: *const ValueRef,\n+                           NumArgs: c_uint,\n+                           Then: BasicBlockRef,\n+                           Catch: BasicBlockRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildLandingPad(B: BuilderRef,\n+                               Ty: TypeRef,\n+                               PersFn: ValueRef,\n+                               NumClauses: c_uint,\n+                               Name: *const c_char)\n+                               -> ValueRef;\n+    pub fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n+    pub fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n+\n+    /* Add a case to the switch instruction */\n+    pub fn LLVMAddCase(Switch: ValueRef,\n+                       OnVal: ValueRef,\n+                       Dest: BasicBlockRef);\n+\n+    /* Add a destination to the indirectbr instruction */\n+    pub fn LLVMAddDestination(IndirectBr: ValueRef, Dest: BasicBlockRef);\n+\n+    /* Add a clause to the landing pad instruction */\n+    pub fn LLVMAddClause(LandingPad: ValueRef, ClauseVal: ValueRef);\n+\n+    /* Set the cleanup on a landing pad instruction */\n+    pub fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n+\n+    /* Arithmetic */\n+    pub fn LLVMBuildAdd(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWAdd(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWAdd(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFAdd(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSub(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWSub(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWSub(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFSub(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildMul(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWMul(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWMul(B: BuilderRef,\n+                           LHS: ValueRef,\n+                           RHS: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFMul(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildUDiv(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSDiv(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildExactSDiv(B: BuilderRef,\n+                              LHS: ValueRef,\n+                              RHS: ValueRef,\n+                              Name: *const c_char)\n+                              -> ValueRef;\n+    pub fn LLVMBuildFDiv(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildURem(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSRem(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildFRem(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildShl(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildLShr(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildAShr(B: BuilderRef,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildAnd(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildOr(B: BuilderRef,\n+                       LHS: ValueRef,\n+                       RHS: ValueRef,\n+                       Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildXor(B: BuilderRef,\n+                        LHS: ValueRef,\n+                        RHS: ValueRef,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildBinOp(B: BuilderRef,\n+                          Op: Opcode,\n+                          LHS: ValueRef,\n+                          RHS: ValueRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *const c_char)\n+                        -> ValueRef;\n+\n+    /* Memory */\n+    pub fn LLVMBuildMalloc(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildArrayMalloc(B: BuilderRef,\n+                                Ty: TypeRef,\n+                                Val: ValueRef,\n+                                Name: *const c_char)\n+                                -> ValueRef;\n+    pub fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildArrayAlloca(B: BuilderRef,\n+                                Ty: TypeRef,\n+                                Val: ValueRef,\n+                                Name: *const c_char)\n+                                -> ValueRef;\n+    pub fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n+    pub fn LLVMBuildLoad(B: BuilderRef,\n+                         PointerVal: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+\n+    pub fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef)\n+                          -> ValueRef;\n+\n+    pub fn LLVMBuildGEP(B: BuilderRef,\n+                        Pointer: ValueRef,\n+                        Indices: *const ValueRef,\n+                        NumIndices: c_uint,\n+                        Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildInBoundsGEP(B: BuilderRef,\n+                                Pointer: ValueRef,\n+                                Indices: *const ValueRef,\n+                                NumIndices: c_uint,\n+                                Name: *const c_char)\n+                                -> ValueRef;\n+    pub fn LLVMBuildStructGEP(B: BuilderRef,\n+                              Pointer: ValueRef,\n+                              Idx: c_uint,\n+                              Name: *const c_char)\n+                              -> ValueRef;\n+    pub fn LLVMBuildGlobalString(B: BuilderRef,\n+                                 Str: *const c_char,\n+                                 Name: *const c_char)\n+                                 -> ValueRef;\n+    pub fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n+                                    Str: *const c_char,\n+                                    Name: *const c_char)\n+                                    -> ValueRef;\n+\n+    /* Casts */\n+    pub fn LLVMBuildTrunc(B: BuilderRef,\n+                          Val: ValueRef,\n+                          DestTy: TypeRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildZExt(B: BuilderRef,\n+                         Val: ValueRef,\n+                         DestTy: TypeRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSExt(B: BuilderRef,\n+                         Val: ValueRef,\n+                         DestTy: TypeRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildFPToUI(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFPToSI(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildUIToFP(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildSIToFP(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildFPTrunc(B: BuilderRef,\n+                            Val: ValueRef,\n+                            DestTy: TypeRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+    pub fn LLVMBuildFPExt(B: BuilderRef,\n+                          Val: ValueRef,\n+                          DestTy: TypeRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildPtrToInt(B: BuilderRef,\n+                             Val: ValueRef,\n+                             DestTy: TypeRef,\n+                             Name: *const c_char)\n+                             -> ValueRef;\n+    pub fn LLVMBuildIntToPtr(B: BuilderRef,\n+                             Val: ValueRef,\n+                             DestTy: TypeRef,\n+                             Name: *const c_char)\n+                             -> ValueRef;\n+    pub fn LLVMBuildBitCast(B: BuilderRef,\n+                            Val: ValueRef,\n+                            DestTy: TypeRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+    pub fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n+                                  Val: ValueRef,\n+                                  DestTy: TypeRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n+                                  Val: ValueRef,\n+                                  DestTy: TypeRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n+                                   Val: ValueRef,\n+                                   DestTy: TypeRef,\n+                                   Name: *const c_char)\n+                                   -> ValueRef;\n+    pub fn LLVMBuildCast(B: BuilderRef,\n+                         Op: Opcode,\n+                         Val: ValueRef,\n+                         DestTy: TypeRef,\n+                         Name: *const c_char) -> ValueRef;\n+    pub fn LLVMBuildPointerCast(B: BuilderRef,\n+                                Val: ValueRef,\n+                                DestTy: TypeRef,\n+                                Name: *const c_char)\n+                                -> ValueRef;\n+    pub fn LLVMBuildIntCast(B: BuilderRef,\n+                            Val: ValueRef,\n+                            DestTy: TypeRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+    pub fn LLVMBuildFPCast(B: BuilderRef,\n+                           Val: ValueRef,\n+                           DestTy: TypeRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+\n+    /* Comparisons */\n+    pub fn LLVMBuildICmp(B: BuilderRef,\n+                         Op: c_uint,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildFCmp(B: BuilderRef,\n+                         Op: c_uint,\n+                         LHS: ValueRef,\n+                         RHS: ValueRef,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+\n+    /* Miscellaneous instructions */\n+    pub fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n+                        -> ValueRef;\n+    pub fn LLVMBuildCall(B: BuilderRef,\n+                         Fn: ValueRef,\n+                         Args: *const ValueRef,\n+                         NumArgs: c_uint,\n+                         Name: *const c_char)\n+                         -> ValueRef;\n+    pub fn LLVMBuildSelect(B: BuilderRef,\n+                           If: ValueRef,\n+                           Then: ValueRef,\n+                           Else: ValueRef,\n+                           Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildVAArg(B: BuilderRef,\n+                          list: ValueRef,\n+                          Ty: TypeRef,\n+                          Name: *const c_char)\n+                          -> ValueRef;\n+    pub fn LLVMBuildExtractElement(B: BuilderRef,\n+                                   VecVal: ValueRef,\n+                                   Index: ValueRef,\n+                                   Name: *const c_char)\n+                                   -> ValueRef;\n+    pub fn LLVMBuildInsertElement(B: BuilderRef,\n+                                  VecVal: ValueRef,\n+                                  EltVal: ValueRef,\n+                                  Index: ValueRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildShuffleVector(B: BuilderRef,\n+                                  V1: ValueRef,\n+                                  V2: ValueRef,\n+                                  Mask: ValueRef,\n+                                  Name: *const c_char)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildExtractValue(B: BuilderRef,\n+                                 AggVal: ValueRef,\n+                                 Index: c_uint,\n+                                 Name: *const c_char)\n+                                 -> ValueRef;\n+    pub fn LLVMBuildInsertValue(B: BuilderRef,\n+                                AggVal: ValueRef,\n+                                EltVal: ValueRef,\n+                                Index: c_uint,\n+                                Name: *const c_char)\n+                                -> ValueRef;\n+\n+    pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n+                           -> ValueRef;\n+    pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n+                              -> ValueRef;\n+    pub fn LLVMBuildPtrDiff(B: BuilderRef,\n+                            LHS: ValueRef,\n+                            RHS: ValueRef,\n+                            Name: *const c_char)\n+                            -> ValueRef;\n+\n+    /* Atomic Operations */\n+    pub fn LLVMBuildAtomicLoad(B: BuilderRef,\n+                               PointerVal: ValueRef,\n+                               Name: *const c_char,\n+                               Order: AtomicOrdering,\n+                               Alignment: c_uint)\n+                               -> ValueRef;\n+\n+    pub fn LLVMBuildAtomicStore(B: BuilderRef,\n+                                Val: ValueRef,\n+                                Ptr: ValueRef,\n+                                Order: AtomicOrdering,\n+                                Alignment: c_uint)\n+                                -> ValueRef;\n+\n+    pub fn LLVMBuildAtomicCmpXchg(B: BuilderRef,\n+                                  LHS: ValueRef,\n+                                  CMP: ValueRef,\n+                                  RHS: ValueRef,\n+                                  Order: AtomicOrdering,\n+                                  FailureOrder: AtomicOrdering)\n+                                  -> ValueRef;\n+    pub fn LLVMBuildAtomicRMW(B: BuilderRef,\n+                              Op: AtomicBinOp,\n+                              LHS: ValueRef,\n+                              RHS: ValueRef,\n+                              Order: AtomicOrdering,\n+                              SingleThreaded: Bool)\n+                              -> ValueRef;\n+\n+    pub fn LLVMBuildAtomicFence(B: BuilderRef, Order: AtomicOrdering);\n+\n+\n+    /* Selected entries from the downcasts. */\n+    pub fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n+    pub fn LLVMIsAStoreInst(Inst: ValueRef) -> ValueRef;\n+\n+    /** Writes a module to the specified path. Returns 0 on success. */\n+    pub fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *const c_char) -> c_int;\n+\n+    /** Creates target data from a target layout string. */\n+    pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n+    /// Adds the target data to the given pass manager. The pass manager\n+    /// references the target data only weakly.\n+    pub fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n+    /** Number of bytes clobbered when doing a Store to *T. */\n+    pub fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef)\n+                               -> c_ulonglong;\n+\n+    /** Number of bytes clobbered when doing a Store to *T. */\n+    pub fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef)\n+                                -> c_ulonglong;\n+\n+    /** Distance between successive elements in an array of T.\n+    Includes ABI padding. */\n+    pub fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef) -> c_uint;\n+\n+    /** Returns the preferred alignment of a type. */\n+    pub fn LLVMPreferredAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n+                                        -> c_uint;\n+    /** Returns the minimum alignment of a type. */\n+    pub fn LLVMABIAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n+                                  -> c_uint;\n+\n+    /// Computes the byte offset of the indexed struct element for a\n+    /// target.\n+    pub fn LLVMOffsetOfElement(TD: TargetDataRef,\n+                               StructTy: TypeRef,\n+                               Element: c_uint)\n+                               -> c_ulonglong;\n+\n+    /**\n+     * Returns the minimum alignment of a type when part of a call frame.\n+     */\n+    pub fn LLVMCallFrameAlignmentOfType(TD: TargetDataRef, Ty: TypeRef)\n+                                        -> c_uint;\n+\n+    /** Disposes target data. */\n+    pub fn LLVMDisposeTargetData(TD: TargetDataRef);\n+\n+    /** Creates a pass manager. */\n+    pub fn LLVMCreatePassManager() -> PassManagerRef;\n+\n+    /** Creates a function-by-function pass manager */\n+    pub fn LLVMCreateFunctionPassManagerForModule(M: ModuleRef)\n+                                                  -> PassManagerRef;\n+\n+    /** Disposes a pass manager. */\n+    pub fn LLVMDisposePassManager(PM: PassManagerRef);\n+\n+    /** Runs a pass manager on a module. */\n+    pub fn LLVMRunPassManager(PM: PassManagerRef, M: ModuleRef) -> Bool;\n+\n+    /** Runs the function passes on the provided function. */\n+    pub fn LLVMRunFunctionPassManager(FPM: PassManagerRef, F: ValueRef)\n+                                      -> Bool;\n+\n+    /** Initializes all the function passes scheduled in the manager */\n+    pub fn LLVMInitializeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n+\n+    /** Finalizes all the function passes scheduled in the manager */\n+    pub fn LLVMFinalizeFunctionPassManager(FPM: PassManagerRef) -> Bool;\n+\n+    pub fn LLVMInitializePasses();\n+\n+    /** Adds a verification pass. */\n+    pub fn LLVMAddVerifierPass(PM: PassManagerRef);\n+\n+    pub fn LLVMAddGlobalOptimizerPass(PM: PassManagerRef);\n+    pub fn LLVMAddIPSCCPPass(PM: PassManagerRef);\n+    pub fn LLVMAddDeadArgEliminationPass(PM: PassManagerRef);\n+    pub fn LLVMAddInstructionCombiningPass(PM: PassManagerRef);\n+    pub fn LLVMAddCFGSimplificationPass(PM: PassManagerRef);\n+    pub fn LLVMAddFunctionInliningPass(PM: PassManagerRef);\n+    pub fn LLVMAddFunctionAttrsPass(PM: PassManagerRef);\n+    pub fn LLVMAddScalarReplAggregatesPass(PM: PassManagerRef);\n+    pub fn LLVMAddScalarReplAggregatesPassSSA(PM: PassManagerRef);\n+    pub fn LLVMAddJumpThreadingPass(PM: PassManagerRef);\n+    pub fn LLVMAddConstantPropagationPass(PM: PassManagerRef);\n+    pub fn LLVMAddReassociatePass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopRotatePass(PM: PassManagerRef);\n+    pub fn LLVMAddLICMPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopUnswitchPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopDeletionPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopUnrollPass(PM: PassManagerRef);\n+    pub fn LLVMAddGVNPass(PM: PassManagerRef);\n+    pub fn LLVMAddMemCpyOptPass(PM: PassManagerRef);\n+    pub fn LLVMAddSCCPPass(PM: PassManagerRef);\n+    pub fn LLVMAddDeadStoreEliminationPass(PM: PassManagerRef);\n+    pub fn LLVMAddStripDeadPrototypesPass(PM: PassManagerRef);\n+    pub fn LLVMAddConstantMergePass(PM: PassManagerRef);\n+    pub fn LLVMAddArgumentPromotionPass(PM: PassManagerRef);\n+    pub fn LLVMAddTailCallEliminationPass(PM: PassManagerRef);\n+    pub fn LLVMAddIndVarSimplifyPass(PM: PassManagerRef);\n+    pub fn LLVMAddAggressiveDCEPass(PM: PassManagerRef);\n+    pub fn LLVMAddGlobalDCEPass(PM: PassManagerRef);\n+    pub fn LLVMAddCorrelatedValuePropagationPass(PM: PassManagerRef);\n+    pub fn LLVMAddPruneEHPass(PM: PassManagerRef);\n+    pub fn LLVMAddSimplifyLibCallsPass(PM: PassManagerRef);\n+    pub fn LLVMAddLoopIdiomPass(PM: PassManagerRef);\n+    pub fn LLVMAddEarlyCSEPass(PM: PassManagerRef);\n+    pub fn LLVMAddTypeBasedAliasAnalysisPass(PM: PassManagerRef);\n+    pub fn LLVMAddBasicAliasAnalysisPass(PM: PassManagerRef);\n+\n+    pub fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n+    pub fn LLVMPassManagerBuilderDispose(PMB: PassManagerBuilderRef);\n+    pub fn LLVMPassManagerBuilderSetOptLevel(PMB: PassManagerBuilderRef,\n+                                             OptimizationLevel: c_uint);\n+    pub fn LLVMPassManagerBuilderSetSizeLevel(PMB: PassManagerBuilderRef,\n+                                              Value: Bool);\n+    pub fn LLVMPassManagerBuilderSetDisableUnitAtATime(\n+        PMB: PassManagerBuilderRef,\n+        Value: Bool);\n+    pub fn LLVMPassManagerBuilderSetDisableUnrollLoops(\n+        PMB: PassManagerBuilderRef,\n+        Value: Bool);\n+    pub fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls(\n+        PMB: PassManagerBuilderRef,\n+        Value: Bool);\n+    pub fn LLVMPassManagerBuilderUseInlinerWithThreshold(\n+        PMB: PassManagerBuilderRef,\n+        threshold: c_uint);\n+    pub fn LLVMPassManagerBuilderPopulateModulePassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef);\n+\n+    pub fn LLVMPassManagerBuilderPopulateFunctionPassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef);\n+    pub fn LLVMPassManagerBuilderPopulateLTOPassManager(\n+        PMB: PassManagerBuilderRef,\n+        PM: PassManagerRef,\n+        Internalize: Bool,\n+        RunInliner: Bool);\n+\n+    /** Destroys a memory buffer. */\n+    pub fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n+\n+\n+    /* Stuff that's in rustllvm/ because it's not upstream yet. */\n+\n+    /** Opens an object file. */\n+    pub fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef) -> ObjectFileRef;\n+    /** Closes an object file. */\n+    pub fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n+\n+    /** Enumerates the sections in an object file. */\n+    pub fn LLVMGetSections(ObjFile: ObjectFileRef) -> SectionIteratorRef;\n+    /** Destroys a section iterator. */\n+    pub fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n+    /** Returns true if the section iterator is at the end of the section\n+    list: */\n+    pub fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n+                                      SI: SectionIteratorRef)\n+                                      -> Bool;\n+    /** Moves the section iterator to point to the next section. */\n+    pub fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n+    /** Returns the current section size. */\n+    pub fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n+    /** Returns the current section contents as a string buffer. */\n+    pub fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *const c_char;\n+\n+    /** Reads the given file and returns it as a memory buffer. Use\n+    LLVMDisposeMemoryBuffer() to get rid of it. */\n+    pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *const c_char)\n+                                                        -> MemoryBufferRef;\n+    /** Borrows the contents of the memory buffer (doesn't copy it) */\n+    pub fn LLVMCreateMemoryBufferWithMemoryRange(InputData: *const c_char,\n+                                                 InputDataLength: size_t,\n+                                                 BufferName: *const c_char,\n+                                                 RequiresNull: Bool)\n+                                                 -> MemoryBufferRef;\n+    pub fn LLVMCreateMemoryBufferWithMemoryRangeCopy(InputData: *const c_char,\n+                                                     InputDataLength: size_t,\n+                                                     BufferName: *const c_char)\n+                                                     -> MemoryBufferRef;\n+\n+    pub fn LLVMIsMultithreaded() -> Bool;\n+    pub fn LLVMStartMultithreaded() -> Bool;\n+\n+    /** Returns a string describing the last error caused by an LLVMRust*\n+    call. */\n+    pub fn LLVMRustGetLastError() -> *const c_char;\n+\n+    /// Print the pass timings since static dtors aren't picking them up.\n+    pub fn LLVMRustPrintPassTimings();\n+\n+    pub fn LLVMStructCreateNamed(C: ContextRef, Name: *const c_char) -> TypeRef;\n+\n+    pub fn LLVMStructSetBody(StructTy: TypeRef,\n+                             ElementTypes: *const TypeRef,\n+                             ElementCount: c_uint,\n+                             Packed: Bool);\n+\n+    pub fn LLVMConstNamedStruct(S: TypeRef,\n+                                ConstantVals: *const ValueRef,\n+                                Count: c_uint)\n+                                -> ValueRef;\n+\n+    /** Enables LLVM debug output. */\n+    pub fn LLVMSetDebug(Enabled: c_int);\n+\n+    /** Prepares inline assembly. */\n+    pub fn LLVMInlineAsm(Ty: TypeRef,\n+                         AsmString: *const c_char,\n+                         Constraints: *const c_char,\n+                         SideEffects: Bool,\n+                         AlignStack: Bool,\n+                         Dialect: c_uint)\n+                         -> ValueRef;\n+\n+    pub static LLVMRustDebugMetadataVersion: u32;\n+\n+    pub fn LLVMRustAddModuleFlag(M: ModuleRef,\n+                                 name: *const c_char,\n+                                 value: u32);\n+\n+    pub fn LLVMDIBuilderCreate(M: ModuleRef) -> DIBuilderRef;\n+\n+    pub fn LLVMDIBuilderDispose(Builder: DIBuilderRef);\n+\n+    pub fn LLVMDIBuilderFinalize(Builder: DIBuilderRef);\n+\n+    pub fn LLVMDIBuilderCreateCompileUnit(Builder: DIBuilderRef,\n+                                          Lang: c_uint,\n+                                          File: *const c_char,\n+                                          Dir: *const c_char,\n+                                          Producer: *const c_char,\n+                                          isOptimized: bool,\n+                                          Flags: *const c_char,\n+                                          RuntimeVer: c_uint,\n+                                          SplitName: *const c_char);\n+\n+    pub fn LLVMDIBuilderCreateFile(Builder: DIBuilderRef,\n+                                   Filename: *const c_char,\n+                                   Directory: *const c_char)\n+                                   -> DIFile;\n+\n+    pub fn LLVMDIBuilderCreateSubroutineType(Builder: DIBuilderRef,\n+                                             File: DIFile,\n+                                             ParameterTypes: DIArray)\n+                                             -> DICompositeType;\n+\n+    pub fn LLVMDIBuilderCreateFunction(Builder: DIBuilderRef,\n+                                       Scope: DIDescriptor,\n+                                       Name: *const c_char,\n+                                       LinkageName: *const c_char,\n+                                       File: DIFile,\n+                                       LineNo: c_uint,\n+                                       Ty: DIType,\n+                                       isLocalToUnit: bool,\n+                                       isDefinition: bool,\n+                                       ScopeLine: c_uint,\n+                                       Flags: c_uint,\n+                                       isOptimized: bool,\n+                                       Fn: ValueRef,\n+                                       TParam: ValueRef,\n+                                       Decl: ValueRef)\n+                                       -> DISubprogram;\n+\n+    pub fn LLVMDIBuilderCreateBasicType(Builder: DIBuilderRef,\n+                                        Name: *const c_char,\n+                                        SizeInBits: c_ulonglong,\n+                                        AlignInBits: c_ulonglong,\n+                                        Encoding: c_uint)\n+                                        -> DIBasicType;\n+\n+    pub fn LLVMDIBuilderCreatePointerType(Builder: DIBuilderRef,\n+                                          PointeeTy: DIType,\n+                                          SizeInBits: c_ulonglong,\n+                                          AlignInBits: c_ulonglong,\n+                                          Name: *const c_char)\n+                                          -> DIDerivedType;\n+\n+    pub fn LLVMDIBuilderCreateStructType(Builder: DIBuilderRef,\n+                                         Scope: DIDescriptor,\n+                                         Name: *const c_char,\n+                                         File: DIFile,\n+                                         LineNumber: c_uint,\n+                                         SizeInBits: c_ulonglong,\n+                                         AlignInBits: c_ulonglong,\n+                                         Flags: c_uint,\n+                                         DerivedFrom: DIType,\n+                                         Elements: DIArray,\n+                                         RunTimeLang: c_uint,\n+                                         VTableHolder: ValueRef,\n+                                         UniqueId: *const c_char)\n+                                         -> DICompositeType;\n+\n+    pub fn LLVMDIBuilderCreateMemberType(Builder: DIBuilderRef,\n+                                         Scope: DIDescriptor,\n+                                         Name: *const c_char,\n+                                         File: DIFile,\n+                                         LineNo: c_uint,\n+                                         SizeInBits: c_ulonglong,\n+                                         AlignInBits: c_ulonglong,\n+                                         OffsetInBits: c_ulonglong,\n+                                         Flags: c_uint,\n+                                         Ty: DIType)\n+                                         -> DIDerivedType;\n+\n+    pub fn LLVMDIBuilderCreateLexicalBlock(Builder: DIBuilderRef,\n+                                           Scope: DIDescriptor,\n+                                           File: DIFile,\n+                                           Line: c_uint,\n+                                           Col: c_uint,\n+                                           Discriminator: c_uint)\n+                                           -> DILexicalBlock;\n+\n+    pub fn LLVMDIBuilderCreateStaticVariable(Builder: DIBuilderRef,\n+                                             Context: DIDescriptor,\n+                                             Name: *const c_char,\n+                                             LinkageName: *const c_char,\n+                                             File: DIFile,\n+                                             LineNo: c_uint,\n+                                             Ty: DIType,\n+                                             isLocalToUnit: bool,\n+                                             Val: ValueRef,\n+                                             Decl: ValueRef)\n+                                             -> DIGlobalVariable;\n+\n+    pub fn LLVMDIBuilderCreateLocalVariable(Builder: DIBuilderRef,\n+                                            Tag: c_uint,\n+                                            Scope: DIDescriptor,\n+                                            Name: *const c_char,\n+                                            File: DIFile,\n+                                            LineNo: c_uint,\n+                                            Ty: DIType,\n+                                            AlwaysPreserve: bool,\n+                                            Flags: c_uint,\n+                                            ArgNo: c_uint)\n+                                            -> DIVariable;\n+\n+    pub fn LLVMDIBuilderCreateArrayType(Builder: DIBuilderRef,\n+                                        Size: c_ulonglong,\n+                                        AlignInBits: c_ulonglong,\n+                                        Ty: DIType,\n+                                        Subscripts: DIArray)\n+                                        -> DIType;\n+\n+    pub fn LLVMDIBuilderCreateVectorType(Builder: DIBuilderRef,\n+                                         Size: c_ulonglong,\n+                                         AlignInBits: c_ulonglong,\n+                                         Ty: DIType,\n+                                         Subscripts: DIArray)\n+                                         -> DIType;\n+\n+    pub fn LLVMDIBuilderGetOrCreateSubrange(Builder: DIBuilderRef,\n+                                            Lo: c_longlong,\n+                                            Count: c_longlong)\n+                                            -> DISubrange;\n+\n+    pub fn LLVMDIBuilderGetOrCreateArray(Builder: DIBuilderRef,\n+                                         Ptr: *const DIDescriptor,\n+                                         Count: c_uint)\n+                                         -> DIArray;\n+\n+    pub fn LLVMDIBuilderInsertDeclareAtEnd(Builder: DIBuilderRef,\n+                                           Val: ValueRef,\n+                                           VarInfo: DIVariable,\n+                                           InsertAtEnd: BasicBlockRef)\n+                                           -> ValueRef;\n+\n+    pub fn LLVMDIBuilderInsertDeclareBefore(Builder: DIBuilderRef,\n+                                            Val: ValueRef,\n+                                            VarInfo: DIVariable,\n+                                            InsertBefore: ValueRef)\n+                                            -> ValueRef;\n+\n+    pub fn LLVMDIBuilderCreateEnumerator(Builder: DIBuilderRef,\n+                                         Name: *const c_char,\n+                                         Val: c_ulonglong)\n+                                         -> ValueRef;\n+\n+    pub fn LLVMDIBuilderCreateEnumerationType(Builder: DIBuilderRef,\n+                                              Scope: ValueRef,\n+                                              Name: *const c_char,\n+                                              File: ValueRef,\n+                                              LineNumber: c_uint,\n+                                              SizeInBits: c_ulonglong,\n+                                              AlignInBits: c_ulonglong,\n+                                              Elements: ValueRef,\n+                                              ClassType: ValueRef)\n+                                              -> ValueRef;\n+\n+    pub fn LLVMDIBuilderCreateUnionType(Builder: DIBuilderRef,\n+                                        Scope: ValueRef,\n+                                        Name: *const c_char,\n+                                        File: ValueRef,\n+                                        LineNumber: c_uint,\n+                                        SizeInBits: c_ulonglong,\n+                                        AlignInBits: c_ulonglong,\n+                                        Flags: c_uint,\n+                                        Elements: ValueRef,\n+                                        RunTimeLang: c_uint,\n+                                        UniqueId: *const c_char)\n+                                        -> ValueRef;\n+\n+    pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);\n+\n+    pub fn LLVMDIBuilderCreateTemplateTypeParameter(Builder: DIBuilderRef,\n+                                                    Scope: ValueRef,\n+                                                    Name: *const c_char,\n+                                                    Ty: ValueRef,\n+                                                    File: ValueRef,\n+                                                    LineNo: c_uint,\n+                                                    ColumnNo: c_uint)\n+                                                    -> ValueRef;\n+\n+    pub fn LLVMDIBuilderCreateOpDeref(IntType: TypeRef) -> ValueRef;\n+\n+    pub fn LLVMDIBuilderCreateOpPlus(IntType: TypeRef) -> ValueRef;\n+\n+    pub fn LLVMDIBuilderCreateComplexVariable(Builder: DIBuilderRef,\n+                                              Tag: c_uint,\n+                                              Scope: ValueRef,\n+                                              Name: *const c_char,\n+                                              File: ValueRef,\n+                                              LineNo: c_uint,\n+                                              Ty: ValueRef,\n+                                              AddrOps: *const ValueRef,\n+                                              AddrOpsCount: c_uint,\n+                                              ArgNo: c_uint)\n+                                              -> ValueRef;\n+\n+    pub fn LLVMDIBuilderCreateNameSpace(Builder: DIBuilderRef,\n+                                        Scope: ValueRef,\n+                                        Name: *const c_char,\n+                                        File: ValueRef,\n+                                        LineNo: c_uint)\n+                                        -> ValueRef;\n+\n+    pub fn LLVMDICompositeTypeSetTypeArray(CompositeType: ValueRef, TypeArray: ValueRef);\n+    pub fn LLVMTypeToString(Type: TypeRef) -> *const c_char;\n+    pub fn LLVMValueToString(value_ref: ValueRef) -> *const c_char;\n+\n+    pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n+\n+    pub fn LLVMIsAAllocaInst(value_ref: ValueRef) -> ValueRef;\n+\n+    pub fn LLVMInitializeX86TargetInfo();\n+    pub fn LLVMInitializeX86Target();\n+    pub fn LLVMInitializeX86TargetMC();\n+    pub fn LLVMInitializeX86AsmPrinter();\n+    pub fn LLVMInitializeX86AsmParser();\n+    pub fn LLVMInitializeARMTargetInfo();\n+    pub fn LLVMInitializeARMTarget();\n+    pub fn LLVMInitializeARMTargetMC();\n+    pub fn LLVMInitializeARMAsmPrinter();\n+    pub fn LLVMInitializeARMAsmParser();\n+    pub fn LLVMInitializeMipsTargetInfo();\n+    pub fn LLVMInitializeMipsTarget();\n+    pub fn LLVMInitializeMipsTargetMC();\n+    pub fn LLVMInitializeMipsAsmPrinter();\n+    pub fn LLVMInitializeMipsAsmParser();\n+\n+    pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: *const c_char) -> bool;\n+    pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n+                                       CPU: *const c_char,\n+                                       Features: *const c_char,\n+                                       Model: CodeGenModel,\n+                                       Reloc: RelocMode,\n+                                       Level: CodeGenOptLevel,\n+                                       EnableSegstk: bool,\n+                                       UseSoftFP: bool,\n+                                       NoFramePointerElim: bool,\n+                                       FunctionSections: bool,\n+                                       DataSections: bool) -> TargetMachineRef;\n+    pub fn LLVMRustDisposeTargetMachine(T: TargetMachineRef);\n+    pub fn LLVMRustAddAnalysisPasses(T: TargetMachineRef,\n+                                     PM: PassManagerRef,\n+                                     M: ModuleRef);\n+    pub fn LLVMRustAddBuilderLibraryInfo(PMB: PassManagerBuilderRef,\n+                                         M: ModuleRef,\n+                                         DisableSimplifyLibCalls: bool);\n+    pub fn LLVMRustAddLibraryInfo(PM: PassManagerRef, M: ModuleRef,\n+                                  DisableSimplifyLibCalls: bool);\n+    pub fn LLVMRustRunFunctionPassManager(PM: PassManagerRef, M: ModuleRef);\n+    pub fn LLVMRustWriteOutputFile(T: TargetMachineRef,\n+                                   PM: PassManagerRef,\n+                                   M: ModuleRef,\n+                                   Output: *const c_char,\n+                                   FileType: FileType) -> bool;\n+    pub fn LLVMRustPrintModule(PM: PassManagerRef,\n+                               M: ModuleRef,\n+                               Output: *const c_char);\n+    pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n+    pub fn LLVMRustPrintPasses();\n+    pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n+    pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef,\n+                                       AddLifetimes: bool);\n+    pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef,\n+                                         bc: *const c_char,\n+                                         len: size_t) -> bool;\n+    pub fn LLVMRustRunRestrictionPass(M: ModuleRef,\n+                                      syms: *const *const c_char,\n+                                      len: size_t);\n+    pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n+\n+    pub fn LLVMRustOpenArchive(path: *const c_char) -> ArchiveRef;\n+    pub fn LLVMRustArchiveReadSection(AR: ArchiveRef, name: *const c_char,\n+                                      out_len: *mut size_t) -> *const c_char;\n+    pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n+\n+    pub fn LLVMRustSetDLLExportStorageClass(V: ValueRef);\n+    pub fn LLVMVersionMajor() -> c_int;\n+    pub fn LLVMVersionMinor() -> c_int;\n+\n+    pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n+                                  data: *mut *const c_char) -> c_int;\n+}\n+\n+pub fn SetInstructionCallConv(instr: ValueRef, cc: CallConv) {\n+    unsafe {\n+        LLVMSetInstructionCallConv(instr, cc as c_uint);\n+    }\n+}\n+pub fn SetFunctionCallConv(fn_: ValueRef, cc: CallConv) {\n+    unsafe {\n+        LLVMSetFunctionCallConv(fn_, cc as c_uint);\n+    }\n+}\n+pub fn SetLinkage(global: ValueRef, link: Linkage) {\n+    unsafe {\n+        LLVMSetLinkage(global, link as c_uint);\n+    }\n+}\n+\n+pub fn SetUnnamedAddr(global: ValueRef, unnamed: bool) {\n+    unsafe {\n+        LLVMSetUnnamedAddr(global, unnamed as Bool);\n+    }\n+}\n+\n+pub fn set_thread_local(global: ValueRef, is_thread_local: bool) {\n+    unsafe {\n+        LLVMSetThreadLocal(global, is_thread_local as Bool);\n+    }\n+}\n+\n+pub fn ConstICmp(pred: IntPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n+    unsafe {\n+        LLVMConstICmp(pred as c_ushort, v1, v2)\n+    }\n+}\n+pub fn ConstFCmp(pred: RealPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n+    unsafe {\n+        LLVMConstFCmp(pred as c_ushort, v1, v2)\n+    }\n+}\n+\n+pub fn SetFunctionAttribute(fn_: ValueRef, attr: Attribute) {\n+    unsafe {\n+        LLVMAddFunctionAttribute(fn_, FunctionIndex as c_uint, attr as uint64_t)\n+    }\n+}\n+\n+/* Memory-managed interface to target data. */\n+\n+pub struct TargetData {\n+    pub lltd: TargetDataRef\n+}\n+\n+impl Drop for TargetData {\n+    fn drop(&mut self) {\n+        unsafe {\n+            LLVMDisposeTargetData(self.lltd);\n+        }\n+    }\n+}\n+\n+pub fn mk_target_data(string_rep: &str) -> TargetData {\n+    TargetData {\n+        lltd: string_rep.with_c_str(|buf| {\n+            unsafe { LLVMCreateTargetData(buf) }\n+        })\n+    }\n+}\n+\n+/* Memory-managed interface to object files. */\n+\n+pub struct ObjectFile {\n+    pub llof: ObjectFileRef,\n+}\n+\n+impl ObjectFile {\n+    // This will take ownership of llmb\n+    pub fn new(llmb: MemoryBufferRef) -> Option<ObjectFile> {\n+        unsafe {\n+            let llof = LLVMCreateObjectFile(llmb);\n+            if llof as int == 0 {\n+                // LLVMCreateObjectFile took ownership of llmb\n+                return None\n+            }\n+\n+            Some(ObjectFile {\n+                llof: llof,\n+            })\n+        }\n+    }\n+}\n+\n+impl Drop for ObjectFile {\n+    fn drop(&mut self) {\n+        unsafe {\n+            LLVMDisposeObjectFile(self.llof);\n+        }\n+    }\n+}\n+\n+/* Memory-managed interface to section iterators. */\n+\n+pub struct SectionIter {\n+    pub llsi: SectionIteratorRef\n+}\n+\n+impl Drop for SectionIter {\n+    fn drop(&mut self) {\n+        unsafe {\n+            LLVMDisposeSectionIterator(self.llsi);\n+        }\n+    }\n+}\n+\n+pub fn mk_section_iter(llof: ObjectFileRef) -> SectionIter {\n+    unsafe {\n+        SectionIter {\n+            llsi: LLVMGetSections(llof)\n+        }\n+    }\n+}\n+\n+// FIXME #15460 - create a public function that actually calls our\n+// static LLVM symbols. Otherwise the linker will just throw llvm\n+// away.  We're just calling lots of stuff until we transitively get\n+// all of LLVM. This is worse than anything.\n+pub unsafe fn static_link_hack_this_sucks() {\n+    LLVMInitializePasses();\n+\n+    LLVMInitializeX86TargetInfo();\n+    LLVMInitializeX86Target();\n+    LLVMInitializeX86TargetMC();\n+    LLVMInitializeX86AsmPrinter();\n+    LLVMInitializeX86AsmParser();\n+\n+    LLVMInitializeARMTargetInfo();\n+    LLVMInitializeARMTarget();\n+    LLVMInitializeARMTargetMC();\n+    LLVMInitializeARMAsmPrinter();\n+    LLVMInitializeARMAsmParser();\n+\n+    LLVMInitializeMipsTargetInfo();\n+    LLVMInitializeMipsTarget();\n+    LLVMInitializeMipsTargetMC();\n+    LLVMInitializeMipsAsmPrinter();\n+    LLVMInitializeMipsAsmParser();\n+\n+    LLVMRustSetLLVMOptions(0 as c_int,\n+                                       0 as *const _);\n+\n+    LLVMPassManagerBuilderPopulateModulePassManager(0 as *mut _, 0 as *mut _);\n+    LLVMPassManagerBuilderPopulateLTOPassManager(0 as *mut _, 0 as *mut _, False, False);\n+    LLVMPassManagerBuilderPopulateFunctionPassManager(0 as *mut _, 0 as *mut _);\n+    LLVMPassManagerBuilderSetOptLevel(0 as *mut _, 0 as c_uint);\n+    LLVMPassManagerBuilderUseInlinerWithThreshold(0 as *mut _, 0 as c_uint);\n+    LLVMWriteBitcodeToFile(0 as *mut _, 0 as *const _);\n+    LLVMPassManagerBuilderCreate();\n+    LLVMPassManagerBuilderDispose(0 as *mut _);\n+\n+    LLVMRustLinkInExternalBitcode(0 as *mut _, 0 as *const _, 0 as size_t);\n+\n+    LLVMLinkInJIT();\n+    LLVMLinkInMCJIT();\n+    LLVMLinkInInterpreter();\n+\n+    extern {\n+        fn LLVMLinkInJIT();\n+        fn LLVMLinkInMCJIT();\n+        fn LLVMLinkInInterpreter();\n+    }\n+}\n+\n+// The module containing the native LLVM dependencies, generated by the build system\n+// Note that this must come after the rustllvm extern declaration so that\n+// parts of LLVM that rustllvm depends on aren't thrown away by the linker.\n+// Works to the above fix for #15460 to ensure LLVM dependencies that\n+// are only used by rustllvm don't get stripped by the linker.\n+mod llvmdeps;\n+"}]}