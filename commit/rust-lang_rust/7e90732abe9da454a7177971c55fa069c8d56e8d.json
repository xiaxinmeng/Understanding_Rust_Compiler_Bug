{"sha": "7e90732abe9da454a7177971c55fa069c8d56e8d", "node_id": "C_kwDOAAsO6NoAKDdlOTA3MzJhYmU5ZGE0NTRhNzE3Nzk3MWM1NWZhMDY5YzhkNTZlOGQ", "commit": {"author": {"name": "nils", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-03-28T10:51:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-28T10:51:13Z"}, "message": "Rollup merge of #109470 - compiler-errors:gat-normalize-bound, r=jackh726\n\nCorrectly substitute GAT's type used in `normalize_param_env` in `check_type_bounds`\n\nGiven:\n\n```rust\ntrait Foo {\n    type Assoc<T>: PartialEq<Self::Assoc<i32>>;\n}\n\nimpl Foo for () {\n    type Assoc<T> = Wrapper<T>;\n}\n\nstruct Wrapper<T>(T);\n\nimpl<T> PartialEq<Wrapper<i32>> for Wrapper<T> { }\n```\n\nWe add an additional predicate in the `normalize_param_env` in `check_type_bounds` that is used to normalize the GAT's bounds to check them in the impl. Problematically, though, that predicate is constructed to be `for<^0> <() as Foo>::Assoc<^0> => Wrapper<T>`, instead of `for<^0> <() as Foo>::Assoc<^0> => Wrapper<^0>`.\n\nThat means `Self::Assoc<i32>` in the bounds that we're checking normalizes to `Wrapper<T>`, instead of `Wrapper<i32>`, and so the bound `Self::Assoc<T>: PartialEq<Self::Assoc<i32>>` normalizes to `Wrapper<T>: PartialEq<Wrapper<T>>`, which does not hold.\n\nFixes this by properly substituting the RHS of that normalizes predicate that we add to the `normalize_param_env`. That means the bound is properly normalized to `Wrapper<T>: PartialEq<Wrapper<i32>>`, which *does* hold.\n\n---\n\nThe second commit in this PR just cleans up some substs stuff and some naming.\n\nr? `@jackh726` cc #87900", "tree": {"sha": "ca189cdc2109dc2e275ff4f897ce9e9870d50d07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca189cdc2109dc2e275ff4f897ce9e9870d50d07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e90732abe9da454a7177971c55fa069c8d56e8d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkIsahCRBK7hj4Ov3rIwAAoTkIACdVEEhjADc/dQ8T5JMjAbfw\nnHA7IKQGVTpNKjRVOPx13AN1BXc6dR79pdtBuI1pcRLsFSu/n8B9XMmXLD0TFeha\nkjYBqRPofkwfy38JG3vJjaYqKatko7cxvEqoE8XBpEYq6kgnwLHXqdzcJuzyjX4b\nQGEUWs6UwhkHe9VsXcrhROzJk0c3w2t1wVMbJ7yI1RDzGvT45bdqrrL64KCHIPNP\nHQyok2uPxazFcjU/v+8bG3Tar75oTKX8C8TsYXZUEA9ZS3HyTNku/4S6Cj7uMd/r\nHfMF2ZdakGKx1f6f6uMR35c9uOkDx8db/4ol+UtjXBFlUD03Z8u8GkUH4y1euzM=\n=ipAy\n-----END PGP SIGNATURE-----\n", "payload": "tree ca189cdc2109dc2e275ff4f897ce9e9870d50d07\nparent 64710790d6ce6fce7aa33a07932fb46bdf54d7b3\nparent 5456eecab0eb17bd34d3368db3bc6002ba619a64\nauthor nils <48135649+Nilstrieb@users.noreply.github.com> 1680000673 +0200\ncommitter GitHub <noreply@github.com> 1680000673 +0200\n\nRollup merge of #109470 - compiler-errors:gat-normalize-bound, r=jackh726\n\nCorrectly substitute GAT's type used in `normalize_param_env` in `check_type_bounds`\n\nGiven:\n\n```rust\ntrait Foo {\n    type Assoc<T>: PartialEq<Self::Assoc<i32>>;\n}\n\nimpl Foo for () {\n    type Assoc<T> = Wrapper<T>;\n}\n\nstruct Wrapper<T>(T);\n\nimpl<T> PartialEq<Wrapper<i32>> for Wrapper<T> { }\n```\n\nWe add an additional predicate in the `normalize_param_env` in `check_type_bounds` that is used to normalize the GAT's bounds to check them in the impl. Problematically, though, that predicate is constructed to be `for<^0> <() as Foo>::Assoc<^0> => Wrapper<T>`, instead of `for<^0> <() as Foo>::Assoc<^0> => Wrapper<^0>`.\n\nThat means `Self::Assoc<i32>` in the bounds that we're checking normalizes to `Wrapper<T>`, instead of `Wrapper<i32>`, and so the bound `Self::Assoc<T>: PartialEq<Self::Assoc<i32>>` normalizes to `Wrapper<T>: PartialEq<Wrapper<T>>`, which does not hold.\n\nFixes this by properly substituting the RHS of that normalizes predicate that we add to the `normalize_param_env`. That means the bound is properly normalized to `Wrapper<T>: PartialEq<Wrapper<i32>>`, which *does* hold.\n\n---\n\nThe second commit in this PR just cleans up some substs stuff and some naming.\n\nr? `@jackh726` cc #87900\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e90732abe9da454a7177971c55fa069c8d56e8d", "html_url": "https://github.com/rust-lang/rust/commit/7e90732abe9da454a7177971c55fa069c8d56e8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e90732abe9da454a7177971c55fa069c8d56e8d/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64710790d6ce6fce7aa33a07932fb46bdf54d7b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/64710790d6ce6fce7aa33a07932fb46bdf54d7b3", "html_url": "https://github.com/rust-lang/rust/commit/64710790d6ce6fce7aa33a07932fb46bdf54d7b3"}, {"sha": "5456eecab0eb17bd34d3368db3bc6002ba619a64", "url": "https://api.github.com/repos/rust-lang/rust/commits/5456eecab0eb17bd34d3368db3bc6002ba619a64", "html_url": "https://github.com/rust-lang/rust/commit/5456eecab0eb17bd34d3368db3bc6002ba619a64"}], "stats": {"total": 120, "additions": 67, "deletions": 53}, "files": [{"sha": "17abb6ef75a6fbbe8857bb0d6fad8531929da86b", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 50, "deletions": 53, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/7e90732abe9da454a7177971c55fa069c8d56e8d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e90732abe9da454a7177971c55fa069c8d56e8d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=7e90732abe9da454a7177971c55fa069c8d56e8d", "patch": "@@ -1876,14 +1876,17 @@ pub(super) fn check_type_bounds<'tcx>(\n     impl_ty: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n+    let param_env = tcx.param_env(impl_ty.def_id);\n+    let container_id = impl_ty.container_id(tcx);\n     // Given\n     //\n     // impl<A, B> Foo<u32> for (A, B) {\n-    //     type Bar<C> =...\n+    //     type Bar<C> = Wrapper<A, B, C>\n     // }\n     //\n     // - `impl_trait_ref` would be `<(A, B) as Foo<u32>>`\n-    // - `impl_ty_substs` would be `[A, B, ^0.0]` (`^0.0` here is the bound var with db 0 and index 0)\n+    // - `normalize_impl_ty_substs` would be `[A, B, ^0.0]` (`^0.0` here is the bound var with db 0 and index 0)\n+    // - `normalize_impl_ty` would be `Wrapper<A, B, ^0.0>`\n     // - `rebased_substs` would be `[(A, B), u32, ^0.0]`, combining the substs from\n     //    the *trait* with the generic associated type parameters (as bound vars).\n     //\n@@ -1912,56 +1915,46 @@ pub(super) fn check_type_bounds<'tcx>(\n     // Member<C: Eq> = .... That type would fail a well-formedness check that we ought to be doing\n     // elsewhere, which would check that any <T as Family>::Member<X> meets the bounds declared in\n     // the trait (notably, that X: Eq and T: Family).\n-    let defs: &ty::Generics = tcx.generics_of(impl_ty.def_id);\n-    let mut substs = smallvec::SmallVec::with_capacity(defs.count());\n-    if let Some(def_id) = defs.parent {\n-        let parent_defs = tcx.generics_of(def_id);\n-        InternalSubsts::fill_item(&mut substs, tcx, parent_defs, &mut |param, _| {\n-            tcx.mk_param_from_def(param)\n-        });\n-    }\n     let mut bound_vars: smallvec::SmallVec<[ty::BoundVariableKind; 8]> =\n-        smallvec::SmallVec::with_capacity(defs.count());\n-    InternalSubsts::fill_single(&mut substs, defs, &mut |param, _| match param.kind {\n-        GenericParamDefKind::Type { .. } => {\n-            let kind = ty::BoundTyKind::Param(param.def_id, param.name);\n-            let bound_var = ty::BoundVariableKind::Ty(kind);\n-            bound_vars.push(bound_var);\n-            tcx.mk_bound(\n-                ty::INNERMOST,\n-                ty::BoundTy { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind },\n-            )\n-            .into()\n-        }\n-        GenericParamDefKind::Lifetime => {\n-            let kind = ty::BoundRegionKind::BrNamed(param.def_id, param.name);\n-            let bound_var = ty::BoundVariableKind::Region(kind);\n-            bound_vars.push(bound_var);\n-            tcx.mk_re_late_bound(\n-                ty::INNERMOST,\n-                ty::BoundRegion { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind },\n-            )\n-            .into()\n-        }\n-        GenericParamDefKind::Const { .. } => {\n-            let bound_var = ty::BoundVariableKind::Const;\n-            bound_vars.push(bound_var);\n-            tcx.mk_const(\n-                ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(bound_vars.len() - 1)),\n-                tcx.type_of(param.def_id).subst_identity(),\n-            )\n-            .into()\n-        }\n-    });\n-    let bound_vars = tcx.mk_bound_variable_kinds(&bound_vars);\n-    let impl_ty_substs = tcx.mk_substs(&substs);\n-    let container_id = impl_ty.container_id(tcx);\n-\n-    let rebased_substs = impl_ty_substs.rebase_onto(tcx, container_id, impl_trait_ref.substs);\n-    let impl_ty_value = tcx.type_of(impl_ty.def_id).subst_identity();\n-\n-    let param_env = tcx.param_env(impl_ty.def_id);\n-\n+        smallvec::SmallVec::with_capacity(tcx.generics_of(impl_ty.def_id).params.len());\n+    // Extend the impl's identity substs with late-bound GAT vars\n+    let normalize_impl_ty_substs = ty::InternalSubsts::identity_for_item(tcx, container_id)\n+        .extend_to(tcx, impl_ty.def_id, |param, _| match param.kind {\n+            GenericParamDefKind::Type { .. } => {\n+                let kind = ty::BoundTyKind::Param(param.def_id, param.name);\n+                let bound_var = ty::BoundVariableKind::Ty(kind);\n+                bound_vars.push(bound_var);\n+                tcx.mk_bound(\n+                    ty::INNERMOST,\n+                    ty::BoundTy { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind },\n+                )\n+                .into()\n+            }\n+            GenericParamDefKind::Lifetime => {\n+                let kind = ty::BoundRegionKind::BrNamed(param.def_id, param.name);\n+                let bound_var = ty::BoundVariableKind::Region(kind);\n+                bound_vars.push(bound_var);\n+                tcx.mk_re_late_bound(\n+                    ty::INNERMOST,\n+                    ty::BoundRegion { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind },\n+                )\n+                .into()\n+            }\n+            GenericParamDefKind::Const { .. } => {\n+                let bound_var = ty::BoundVariableKind::Const;\n+                bound_vars.push(bound_var);\n+                tcx.mk_const(\n+                    ty::ConstKind::Bound(\n+                        ty::INNERMOST,\n+                        ty::BoundVar::from_usize(bound_vars.len() - 1),\n+                    ),\n+                    tcx.type_of(param.def_id)\n+                        .no_bound_vars()\n+                        .expect(\"const parameter types cannot be generic\"),\n+                )\n+                .into()\n+            }\n+        });\n     // When checking something like\n     //\n     // trait X { type Y: PartialEq<<Self as X>::Y> }\n@@ -1971,9 +1964,13 @@ pub(super) fn check_type_bounds<'tcx>(\n     // we want <T as X>::Y to normalize to S. This is valid because we are\n     // checking the default value specifically here. Add this equality to the\n     // ParamEnv for normalization specifically.\n+    let normalize_impl_ty = tcx.type_of(impl_ty.def_id).subst(tcx, normalize_impl_ty_substs);\n+    let rebased_substs =\n+        normalize_impl_ty_substs.rebase_onto(tcx, container_id, impl_trait_ref.substs);\n+    let bound_vars = tcx.mk_bound_variable_kinds(&bound_vars);\n     let normalize_param_env = {\n         let mut predicates = param_env.caller_bounds().iter().collect::<Vec<_>>();\n-        match impl_ty_value.kind() {\n+        match normalize_impl_ty.kind() {\n             ty::Alias(ty::Projection, proj)\n                 if proj.def_id == trait_ty.def_id && proj.substs == rebased_substs =>\n             {\n@@ -1987,7 +1984,7 @@ pub(super) fn check_type_bounds<'tcx>(\n                 ty::Binder::bind_with_vars(\n                     ty::ProjectionPredicate {\n                         projection_ty: tcx.mk_alias_ty(trait_ty.def_id, rebased_substs),\n-                        term: impl_ty_value.into(),\n+                        term: normalize_impl_ty.into(),\n                     },\n                     bound_vars,\n                 )"}, {"sha": "b43f982283b8b1f84fcd52800e22951a8e69c44b", "filename": "tests/ui/generic-associated-types/gat-bounds-normalize-pred.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7e90732abe9da454a7177971c55fa069c8d56e8d/tests%2Fui%2Fgeneric-associated-types%2Fgat-bounds-normalize-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e90732abe9da454a7177971c55fa069c8d56e8d/tests%2Fui%2Fgeneric-associated-types%2Fgat-bounds-normalize-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fgat-bounds-normalize-pred.rs?ref=7e90732abe9da454a7177971c55fa069c8d56e8d", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+\n+trait Foo {\n+    type Assoc<T>: PartialEq<Self::Assoc<i32>>;\n+}\n+\n+impl Foo for () {\n+    type Assoc<T> = Wrapper<T>;\n+}\n+\n+struct Wrapper<T>(T);\n+\n+impl<T> PartialEq<Wrapper<i32>> for Wrapper<T> {\n+    fn eq(&self, _other: &Wrapper<i32>) -> bool { true }\n+}\n+\n+fn main() {}"}]}