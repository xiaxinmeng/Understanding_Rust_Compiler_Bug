{"sha": "6b34ba242d7372b779bf50682b9401b61183828e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMzRiYTI0MmQ3MzcyYjc3OWJmNTA2ODJiOTQwMWI2MTE4MzgyOGU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-01T22:37:15Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-05T17:15:54Z"}, "message": "Update LLVM and jettison jit support\n\nLLVM's JIT has been updated numerous times, and we haven't been tracking it at\nall. The existing LLVM glue code no longer compiles, and the JIT isn't used for\nanything currently.\n\nThis also rebases out the FixedStackSegment support which we have added to LLVM.\nNone of this is still in use by the compiler, and there's no need to keep this\nfunctionality around inside of LLVM.\n\nThis is needed to unblock #10708 (where we're tripping an LLVM assertion).", "tree": {"sha": "628ee4c8058d4517b568cc5cccbe45380b0cb83a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/628ee4c8058d4517b568cc5cccbe45380b0cb83a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b34ba242d7372b779bf50682b9401b61183828e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b34ba242d7372b779bf50682b9401b61183828e", "html_url": "https://github.com/rust-lang/rust/commit/6b34ba242d7372b779bf50682b9401b61183828e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b34ba242d7372b779bf50682b9401b61183828e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48", "html_url": "https://github.com/rust-lang/rust/commit/b5bab85c1a41bcd7758fb8090a3cf3ba20e33b48"}], "stats": {"total": 506, "additions": 43, "deletions": 463}, "files": [{"sha": "2bebadc2ef2bc69bdb2f46297eec5e7e4ed3190e", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 28, "deletions": 141, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/6b34ba242d7372b779bf50682b9401b61183828e/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b34ba242d7372b779bf50682b9401b61183828e/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=6b34ba242d7372b779bf50682b9401b61183828e", "patch": "@@ -82,111 +82,8 @@ pub fn WriteOutputFile(\n     }\n }\n \n-pub mod jit {\n-\n-    use back::link::llvm_err;\n-    use driver::session::Session;\n-    use lib::llvm::llvm;\n-    use lib::llvm::{ModuleRef, ContextRef, ExecutionEngineRef};\n-\n-    use std::c_str::ToCStr;\n-    use std::cast;\n-    use std::local_data;\n-    use std::unstable::intrinsics;\n-\n-    struct LLVMJITData {\n-        ee: ExecutionEngineRef,\n-        llcx: ContextRef\n-    }\n-\n-    pub trait Engine {}\n-    impl Engine for LLVMJITData {}\n-\n-    impl Drop for LLVMJITData {\n-        fn drop(&mut self) {\n-            unsafe {\n-                llvm::LLVMDisposeExecutionEngine(self.ee);\n-                llvm::LLVMContextDispose(self.llcx);\n-            }\n-        }\n-    }\n-\n-    pub fn exec(sess: Session,\n-                c: ContextRef,\n-                m: ModuleRef,\n-                stacks: bool) {\n-        unsafe {\n-            let manager = llvm::LLVMRustPrepareJIT(intrinsics::morestack_addr());\n-\n-            // We need to tell JIT where to resolve all linked\n-            // symbols from. The equivalent of -lstd, -lcore, etc.\n-            // By default the JIT will resolve symbols from the extra and\n-            // core linked into rustc. We don't want that,\n-            // incase the user wants to use an older extra library.\n-\n-            // We custom-build a JIT execution engine via some rust wrappers\n-            // first. This wrappers takes ownership of the module passed in.\n-            let ee = llvm::LLVMRustBuildJIT(manager, m, stacks);\n-            if ee.is_null() {\n-                llvm::LLVMContextDispose(c);\n-                llvm_err(sess, ~\"Could not create the JIT\");\n-            }\n-\n-            // Next, we need to get a handle on the _rust_main function by\n-            // looking up it's corresponding ValueRef and then requesting that\n-            // the execution engine compiles the function.\n-            let fun = \"_rust_main\".with_c_str(|entry| {\n-                llvm::LLVMGetNamedFunction(m, entry)\n-            });\n-            if fun.is_null() {\n-                llvm::LLVMDisposeExecutionEngine(ee);\n-                llvm::LLVMContextDispose(c);\n-                llvm_err(sess, ~\"Could not find _rust_main in the JIT\");\n-            }\n-\n-            // Finally, once we have the pointer to the code, we can do some\n-            // closure magic here to turn it straight into a callable rust\n-            // closure\n-            let code = llvm::LLVMGetPointerToGlobal(ee, fun);\n-            assert!(!code.is_null());\n-            let func: extern \"Rust\" fn() = cast::transmute(code);\n-            func();\n-\n-            // Currently there is no method of re-using the executing engine\n-            // from LLVM in another call to the JIT. While this kinda defeats\n-            // the purpose of having a JIT in the first place, there isn't\n-            // actually much code currently which would re-use data between\n-            // different invocations of this. Additionally, the compilation\n-            // model currently isn't designed to support this scenario.\n-            //\n-            // We can't destroy the engine/context immediately here, however,\n-            // because of annihilation. The JIT code contains drop glue for any\n-            // types defined in the crate we just ran, and if any of those boxes\n-            // are going to be dropped during annihilation, the drop glue must\n-            // be run. Hence, we need to transfer ownership of this jit engine\n-            // to the caller of this function. To be convenient for now, we\n-            // shove it into TLS and have someone else remove it later on.\n-            let data = ~LLVMJITData { ee: ee, llcx: c };\n-            set_engine(data as ~Engine);\n-        }\n-    }\n-\n-    // The stage1 compiler won't work, but that doesn't really matter. TLS\n-    // changed only very recently to allow storage of owned values.\n-    local_data_key!(engine_key: ~Engine)\n-\n-    fn set_engine(engine: ~Engine) {\n-        local_data::set(engine_key, engine)\n-    }\n-\n-    pub fn consume_engine() -> Option<~Engine> {\n-        local_data::pop(engine_key)\n-    }\n-}\n-\n pub mod write {\n \n-    use back::link::jit;\n     use back::link::{WriteOutputFile, output_type};\n     use back::link::{output_type_assembly, output_type_bitcode};\n     use back::link::{output_type_exe, output_type_llvm_assembly};\n@@ -307,48 +204,38 @@ pub mod write {\n                 })\n             }\n \n-            if sess.opts.jit {\n-                // If we are using JIT, go ahead and create and execute the\n-                // engine now. JIT execution takes ownership of the module and\n-                // context, so don't dispose\n-                jit::exec(sess, llcx, llmod, true);\n-            } else {\n-                // Create a codegen-specific pass manager to emit the actual\n-                // assembly or object files. This may not end up getting used,\n-                // but we make it anyway for good measure.\n-                let cpm = llvm::LLVMCreatePassManager();\n-                llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n-                llvm::LLVMRustAddLibraryInfo(cpm, llmod);\n-\n-                match output_type {\n-                    output_type_none => {}\n-                    output_type_bitcode => {\n-                        output.with_c_str(|buf| {\n-                            llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                        })\n-                    }\n-                    output_type_llvm_assembly => {\n-                        output.with_c_str(|output| {\n-                            llvm::LLVMRustPrintModule(cpm, llmod, output)\n-                        })\n-                    }\n-                    output_type_assembly => {\n-                        WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::AssemblyFile);\n-                    }\n-                    output_type_exe | output_type_object => {\n-                        WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::ObjectFile);\n-                    }\n+            // Create a codegen-specific pass manager to emit the actual\n+            // assembly or object files. This may not end up getting used,\n+            // but we make it anyway for good measure.\n+            let cpm = llvm::LLVMCreatePassManager();\n+            llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n+            llvm::LLVMRustAddLibraryInfo(cpm, llmod);\n+\n+            match output_type {\n+                output_type_none => {}\n+                output_type_bitcode => {\n+                    output.with_c_str(|buf| {\n+                        llvm::LLVMWriteBitcodeToFile(llmod, buf);\n+                    })\n+                }\n+                output_type_llvm_assembly => {\n+                    output.with_c_str(|output| {\n+                        llvm::LLVMRustPrintModule(cpm, llmod, output)\n+                    })\n+                }\n+                output_type_assembly => {\n+                    WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::AssemblyFile);\n+                }\n+                output_type_exe | output_type_object => {\n+                    WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::ObjectFile);\n                 }\n-\n-                llvm::LLVMDisposePassManager(cpm);\n             }\n \n+            llvm::LLVMDisposePassManager(cpm);\n+\n             llvm::LLVMRustDisposeTargetMachine(tm);\n-            // the jit takes ownership of these two items\n-            if !sess.opts.jit {\n-                llvm::LLVMDisposeModule(llmod);\n-                llvm::LLVMContextDispose(llcx);\n-            }\n+            llvm::LLVMDisposeModule(llmod);\n+            llvm::LLVMContextDispose(llcx);\n             if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n         }\n     }"}, {"sha": "63d6c60d2698d07fae13ef37818960d58c6e668c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6b34ba242d7372b779bf50682b9401b61183828e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b34ba242d7372b779bf50682b9401b61183828e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=6b34ba242d7372b779bf50682b9401b61183828e", "patch": "@@ -419,11 +419,6 @@ pub fn stop_after_phase_5(sess: Session) -> bool {\n         debug!(\"not building executable, returning early from compile_input\");\n         return true;\n     }\n-\n-    if sess.opts.jit {\n-        debug!(\"running JIT, returning early from compile_input\");\n-        return true;\n-    }\n     return false;\n }\n \n@@ -751,7 +746,6 @@ pub fn build_session_options(binary: @str,\n         } else { No }\n     };\n     let gc = debugging_opts & session::gc != 0;\n-    let jit = debugging_opts & session::jit != 0;\n     let extra_debuginfo = debugging_opts & session::extra_debug_info != 0;\n     let debuginfo = debugging_opts & session::debug_info != 0 ||\n         extra_debuginfo;\n@@ -802,7 +796,6 @@ pub fn build_session_options(binary: @str,\n         extra_debuginfo: extra_debuginfo,\n         lint_opts: lint_opts,\n         save_temps: save_temps,\n-        jit: jit,\n         output_type: output_type,\n         addl_lib_search_paths: @mut addl_lib_search_paths,\n         ar: ar,"}, {"sha": "2c41cf00e6b8292f94135055eaedaabee1405330", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6b34ba242d7372b779bf50682b9401b61183828e/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b34ba242d7372b779bf50682b9401b61183828e/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=6b34ba242d7372b779bf50682b9401b61183828e", "patch": "@@ -55,19 +55,18 @@ pub static count_type_sizes:        uint = 1 << 14;\n pub static meta_stats:              uint = 1 << 15;\n pub static no_opt:                  uint = 1 << 16;\n pub static gc:                      uint = 1 << 17;\n-pub static jit:                     uint = 1 << 18;\n-pub static debug_info:              uint = 1 << 19;\n-pub static extra_debug_info:        uint = 1 << 20;\n-pub static print_link_args:         uint = 1 << 21;\n-pub static no_debug_borrows:        uint = 1 << 22;\n-pub static lint_llvm:               uint = 1 << 23;\n-pub static print_llvm_passes:       uint = 1 << 24;\n-pub static no_vectorize_loops:      uint = 1 << 25;\n-pub static no_vectorize_slp:        uint = 1 << 26;\n-pub static no_prepopulate_passes:   uint = 1 << 27;\n-pub static use_softfp:              uint = 1 << 28;\n-pub static gen_crate_map:           uint = 1 << 29;\n-pub static prefer_dynamic:          uint = 1 << 30;\n+pub static debug_info:              uint = 1 << 18;\n+pub static extra_debug_info:        uint = 1 << 19;\n+pub static print_link_args:         uint = 1 << 20;\n+pub static no_debug_borrows:        uint = 1 << 21;\n+pub static lint_llvm:               uint = 1 << 22;\n+pub static print_llvm_passes:       uint = 1 << 23;\n+pub static no_vectorize_loops:      uint = 1 << 24;\n+pub static no_vectorize_slp:        uint = 1 << 25;\n+pub static no_prepopulate_passes:   uint = 1 << 26;\n+pub static use_softfp:              uint = 1 << 27;\n+pub static gen_crate_map:           uint = 1 << 28;\n+pub static prefer_dynamic:          uint = 1 << 29;\n \n pub fn debugging_opts_map() -> ~[(&'static str, &'static str, uint)] {\n     ~[(\"verbose\", \"in general, enable more debug printouts\", verbose),\n@@ -95,7 +94,6 @@ pub fn debugging_opts_map() -> ~[(&'static str, &'static str, uint)] {\n      (\"no-opt\", \"do not optimize, even if -O is passed\", no_opt),\n      (\"print-link-args\", \"Print the arguments passed to the linker\", print_link_args),\n      (\"gc\", \"Garbage collect shared data (experimental)\", gc),\n-     (\"jit\", \"Execute using JIT (experimental)\", jit),\n      (\"extra-debug-info\", \"Extra debugging info (experimental)\",\n       extra_debug_info),\n      (\"debug-info\", \"Produce debug info (experimental)\", debug_info),\n@@ -146,7 +144,6 @@ pub struct options {\n     extra_debuginfo: bool,\n     lint_opts: ~[(lint::lint, lint::level)],\n     save_temps: bool,\n-    jit: bool,\n     output_type: back::link::output_type,\n     addl_lib_search_paths: @mut HashSet<Path>, // This is mutable for rustpkg, which\n                                                // updates search paths based on the\n@@ -370,7 +367,6 @@ pub fn basic_options() -> @options {\n         extra_debuginfo: false,\n         lint_opts: ~[],\n         save_temps: false,\n-        jit: false,\n         output_type: link::output_type_exe,\n         addl_lib_search_paths: @mut HashSet::new(),\n         ar: None,"}, {"sha": "166e1414f6ea24b69f07b6102f9594e4bcff3a3b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b34ba242d7372b779bf50682b9401b61183828e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b34ba242d7372b779bf50682b9401b61183828e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=6b34ba242d7372b779bf50682b9401b61183828e", "patch": "@@ -363,10 +363,6 @@ pub fn monitor(f: proc(@diagnostic::Emitter)) {\n         let _finally = finally { ch: ch };\n \n         f(demitter);\n-\n-        // Due reasons explain in #7732, if there was a jit execution context it\n-        // must be consumed and passed along to our parent task.\n-        back::link::jit::consume_engine()\n     }) {\n         result::Ok(_) => { /* fallthrough */ }\n         result::Err(_) => {"}, {"sha": "1e1444babf232007e70edca6cf6b3dd950ba1960", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b34ba242d7372b779bf50682b9401b61183828e/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b34ba242d7372b779bf50682b9401b61183828e/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=6b34ba242d7372b779bf50682b9401b61183828e", "patch": "@@ -1441,18 +1441,6 @@ pub mod llvm {\n             call. */\n         pub fn LLVMRustGetLastError() -> *c_char;\n \n-        /** Prepare the JIT. Returns a memory manager that can load crates. */\n-        pub fn LLVMRustPrepareJIT(__morestack: *()) -> *();\n-\n-        /** Load a crate into the memory manager. */\n-        pub fn LLVMRustLoadCrate(MM: *(), Filename: *c_char) -> bool;\n-\n-        /** Execute the JIT engine. */\n-        pub fn LLVMRustBuildJIT(MM: *(),\n-                                M: ModuleRef,\n-                                EnableSegmentedStacks: bool)\n-                                -> ExecutionEngineRef;\n-\n         /// Print the pass timings since static dtors aren't picking them up.\n         pub fn LLVMRustPrintPassTimings();\n "}, {"sha": "9e85884132d277efeb507d0aeaa160ba201d054f", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=6b34ba242d7372b779bf50682b9401b61183828e", "patch": "@@ -1 +1 @@\n-Subproject commit c9ffab392a39eb85f2f15ffc8d41e8c4f4397b8e\n+Subproject commit 9e85884132d277efeb507d0aeaa160ba201d054f"}, {"sha": "0ae8991b2e7402091a781939fbebf9e60d390b6a", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b34ba242d7372b779bf50682b9401b61183828e/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6b34ba242d7372b779bf50682b9401b61183828e/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=6b34ba242d7372b779bf50682b9401b61183828e", "patch": "@@ -81,7 +81,6 @@ LLVMRustCreateTargetMachine(const char *triple,\n     TargetOptions Options;\n     Options.NoFramePointerElim = true;\n     Options.EnableSegmentedStacks = EnableSegmentedStacks;\n-    Options.FixedStackSegmentSize = 2 * 1024 * 1024; // XXX: This is too big.\n     Options.FloatABIType =\n          (Trip.getEnvironment() == Triple::GNUEABIHF) ? FloatABI::Hard :\n                                                         FloatABI::Default;"}, {"sha": "484cded314710ce6caba992349b805ff6f94b4f2", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 1, "deletions": 277, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/6b34ba242d7372b779bf50682b9401b61183828e/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6b34ba242d7372b779bf50682b9401b61183828e/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=6b34ba242d7372b779bf50682b9401b61183828e", "patch": "@@ -34,282 +34,6 @@ extern \"C\" const char *LLVMRustGetLastError(void) {\n   return LLVMRustError;\n }\n \n-// Custom memory manager for MCJITting. It needs special features\n-// that the generic JIT memory manager doesn't entail. Based on\n-// code from LLI, change where needed for Rust.\n-class RustMCJITMemoryManager : public JITMemoryManager {\n-public:\n-  SmallVector<sys::MemoryBlock, 16> AllocatedDataMem;\n-  SmallVector<sys::MemoryBlock, 16> AllocatedCodeMem;\n-  SmallVector<sys::MemoryBlock, 16> FreeCodeMem;\n-  void* __morestack;\n-  DenseSet<DynamicLibrary*> crates;\n-\n-  RustMCJITMemoryManager(void* sym) : __morestack(sym) { }\n-  ~RustMCJITMemoryManager();\n-\n-  bool loadCrate(const char*, std::string*);\n-\n-  virtual uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,\n-                                       unsigned SectionID);\n-\n-  virtual uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,\n-                                       unsigned SectionID, bool isReadOnly);\n-  bool finalizeMemory(std::string *ErrMsg) { return false; }\n-\n-  virtual bool applyPermissions(std::string *Str);\n-\n-  virtual void *getPointerToNamedFunction(const std::string &Name,\n-                                          bool AbortOnFailure = true);\n-\n-  // Invalidate instruction cache for code sections. Some platforms with\n-  // separate data cache and instruction cache require explicit cache flush,\n-  // otherwise JIT code manipulations (like resolved relocations) will get to\n-  // the data cache but not to the instruction cache.\n-  virtual void invalidateInstructionCache();\n-\n-  // The MCJITMemoryManager doesn't use the following functions, so we don't\n-  // need implement them.\n-  virtual void setMemoryWritable() {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-  virtual void setMemoryExecutable() {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-  virtual void setPoisonMemory(bool poison) {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-  virtual void AllocateGOT() {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-  virtual uint8_t *getGOTBase() const {\n-    llvm_unreachable(\"Unimplemented call\");\n-    return 0;\n-  }\n-  virtual uint8_t *startFunctionBody(const Function *F,\n-                                     uintptr_t &ActualSize){\n-    llvm_unreachable(\"Unimplemented call\");\n-    return 0;\n-  }\n-  virtual uint8_t *allocateStub(const GlobalValue* F, unsigned StubSize,\n-                                unsigned Alignment) {\n-    llvm_unreachable(\"Unimplemented call\");\n-    return 0;\n-  }\n-  virtual void endFunctionBody(const Function *F, uint8_t *FunctionStart,\n-                               uint8_t *FunctionEnd) {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-  virtual uint8_t *allocateSpace(intptr_t Size, unsigned Alignment) {\n-    llvm_unreachable(\"Unimplemented call\");\n-    return 0;\n-  }\n-  virtual uint8_t *allocateGlobal(uintptr_t Size, unsigned Alignment) {\n-    llvm_unreachable(\"Unimplemented call\");\n-    return 0;\n-  }\n-  virtual void deallocateFunctionBody(void *Body) {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-  virtual uint8_t* startExceptionTable(const Function* F,\n-                                       uintptr_t &ActualSize) {\n-    llvm_unreachable(\"Unimplemented call\");\n-    return 0;\n-  }\n-  virtual void endExceptionTable(const Function *F, uint8_t *TableStart,\n-                                 uint8_t *TableEnd, uint8_t* FrameRegister) {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-  virtual void deallocateExceptionTable(void *ET) {\n-    llvm_unreachable(\"Unimplemented call\");\n-  }\n-};\n-\n-bool RustMCJITMemoryManager::loadCrate(const char* file, std::string* err) {\n-  DynamicLibrary crate = DynamicLibrary::getPermanentLibrary(file,\n-                                                             err);\n-\n-  if(crate.isValid()) {\n-    crates.insert(&crate);\n-\n-    return true;\n-  }\n-\n-  return false;\n-}\n-\n-uint8_t *RustMCJITMemoryManager::allocateDataSection(uintptr_t Size,\n-                                                     unsigned Alignment,\n-                                                     unsigned SectionID,\n-                                                     bool isReadOnly) {\n-  if (!Alignment)\n-    Alignment = 16;\n-  uint8_t *Addr = (uint8_t*)calloc((Size + Alignment - 1)/Alignment, Alignment);\n-  AllocatedDataMem.push_back(sys::MemoryBlock(Addr, Size));\n-  return Addr;\n-}\n-\n-bool RustMCJITMemoryManager::applyPermissions(std::string *Str) {\n-    // Empty.\n-    return true;\n-}\n-\n-uint8_t *RustMCJITMemoryManager::allocateCodeSection(uintptr_t Size,\n-                                                     unsigned Alignment,\n-                                                     unsigned SectionID) {\n-  if (!Alignment)\n-    Alignment = 16;\n-  unsigned NeedAllocate = Alignment * ((Size + Alignment - 1)/Alignment + 1);\n-  uintptr_t Addr = 0;\n-  // Look in the list of free code memory regions and use a block there if one\n-  // is available.\n-  for (int i = 0, e = FreeCodeMem.size(); i != e; ++i) {\n-    sys::MemoryBlock &MB = FreeCodeMem[i];\n-    if (MB.size() >= NeedAllocate) {\n-      Addr = (uintptr_t)MB.base();\n-      uintptr_t EndOfBlock = Addr + MB.size();\n-      // Align the address.\n-      Addr = (Addr + Alignment - 1) & ~(uintptr_t)(Alignment - 1);\n-      // Store cutted free memory block.\n-      FreeCodeMem[i] = sys::MemoryBlock((void*)(Addr + Size),\n-                                        EndOfBlock - Addr - Size);\n-      return (uint8_t*)Addr;\n-    }\n-  }\n-\n-  // No pre-allocated free block was large enough. Allocate a new memory region.\n-  sys::MemoryBlock MB = sys::Memory::AllocateRWX(NeedAllocate, 0, 0);\n-\n-  AllocatedCodeMem.push_back(MB);\n-  Addr = (uintptr_t)MB.base();\n-  uintptr_t EndOfBlock = Addr + MB.size();\n-  // Align the address.\n-  Addr = (Addr + Alignment - 1) & ~(uintptr_t)(Alignment - 1);\n-  // The AllocateRWX may allocate much more memory than we need. In this case,\n-  // we store the unused memory as a free memory block.\n-  unsigned FreeSize = EndOfBlock-Addr-Size;\n-  if (FreeSize > 16)\n-    FreeCodeMem.push_back(sys::MemoryBlock((void*)(Addr + Size), FreeSize));\n-\n-  // Return aligned address\n-  return (uint8_t*)Addr;\n-}\n-\n-void RustMCJITMemoryManager::invalidateInstructionCache() {\n-  for (int i = 0, e = AllocatedCodeMem.size(); i != e; ++i)\n-    sys::Memory::InvalidateInstructionCache(AllocatedCodeMem[i].base(),\n-                                            AllocatedCodeMem[i].size());\n-}\n-\n-void *RustMCJITMemoryManager::getPointerToNamedFunction(const std::string &Name,\n-                                                       bool AbortOnFailure) {\n-#ifdef __linux__\n-  // Force the following functions to be linked in to anything that uses the\n-  // JIT. This is a hack designed to work around the all-too-clever Glibc\n-  // strategy of making these functions work differently when inlined vs. when\n-  // not inlined, and hiding their real definitions in a separate archive file\n-  // that the dynamic linker can't see. For more info, search for\n-  // 'libc_nonshared.a' on Google, or read http://llvm.org/PR274.\n-  if (Name == \"stat\") return (void*)(intptr_t)&stat;\n-  if (Name == \"fstat\") return (void*)(intptr_t)&fstat;\n-  if (Name == \"lstat\") return (void*)(intptr_t)&lstat;\n-  if (Name == \"stat64\") return (void*)(intptr_t)&stat64;\n-  if (Name == \"fstat64\") return (void*)(intptr_t)&fstat64;\n-  if (Name == \"lstat64\") return (void*)(intptr_t)&lstat64;\n-  if (Name == \"atexit\") return (void*)(intptr_t)&atexit;\n-  if (Name == \"mknod\") return (void*)(intptr_t)&mknod;\n-#endif\n-\n-  if (Name == \"__morestack\" || Name == \"___morestack\") return &__morestack;\n-\n-  const char *NameStr = Name.c_str();\n-\n-  // Look through loaded crates and main for symbols.\n-\n-  void *Ptr = sys::DynamicLibrary::SearchForAddressOfSymbol(NameStr);\n-  if (Ptr) return Ptr;\n-\n-  // If it wasn't found and if it starts with an underscore ('_') character,\n-  // try again without the underscore.\n-  if (NameStr[0] == '_') {\n-    Ptr = sys::DynamicLibrary::SearchForAddressOfSymbol(NameStr+1);\n-    if (Ptr) return Ptr;\n-  }\n-\n-  if (AbortOnFailure)\n-    report_fatal_error(\"Program used external function '\" + Name +\n-                      \"' which could not be resolved!\");\n-  return 0;\n-}\n-\n-RustMCJITMemoryManager::~RustMCJITMemoryManager() {\n-  for (unsigned i = 0, e = AllocatedCodeMem.size(); i != e; ++i)\n-    sys::Memory::ReleaseRWX(AllocatedCodeMem[i]);\n-  for (unsigned i = 0, e = AllocatedDataMem.size(); i != e; ++i)\n-    free(AllocatedDataMem[i].base());\n-}\n-\n-extern \"C\" void*\n-LLVMRustPrepareJIT(void* __morestack) {\n-  // An execution engine will take ownership of this later\n-  // and clean it up for us.\n-\n-  return (void*) new RustMCJITMemoryManager(__morestack);\n-}\n-\n-extern \"C\" bool\n-LLVMRustLoadCrate(void* mem, const char* crate) {\n-  RustMCJITMemoryManager* manager = (RustMCJITMemoryManager*) mem;\n-  std::string Err;\n-\n-  assert(manager);\n-\n-  if(!manager->loadCrate(crate, &Err)) {\n-    LLVMRustError = Err.c_str();\n-    return false;\n-  }\n-\n-  return true;\n-}\n-\n-extern \"C\" LLVMExecutionEngineRef\n-LLVMRustBuildJIT(void* mem,\n-                 LLVMModuleRef M,\n-                 bool EnableSegmentedStacks) {\n-\n-  InitializeNativeTarget();\n-  InitializeNativeTargetAsmPrinter();\n-  InitializeNativeTargetAsmParser();\n-\n-  std::string Err;\n-  TargetOptions Options;\n-  Options.JITEmitDebugInfo = true;\n-  Options.NoFramePointerElim = true;\n-  Options.EnableSegmentedStacks = EnableSegmentedStacks;\n-  RustMCJITMemoryManager* MM = (RustMCJITMemoryManager*) mem;\n-  assert(MM);\n-\n-  ExecutionEngine* EE = EngineBuilder(unwrap(M))\n-    .setErrorStr(&Err)\n-    .setTargetOptions(Options)\n-    .setJITMemoryManager(MM)\n-    .setUseMCJIT(true)\n-    .setAllocateGVsWithCode(false)\n-    .create();\n-\n-  if(!EE || Err != \"\") {\n-    LLVMRustError = Err.c_str();\n-    // The EngineBuilder only takes ownership of these two structures if the\n-    // create() call is successful, but here it wasn't successful.\n-    LLVMDisposeModule(M);\n-    delete MM;\n-    return NULL;\n-  }\n-\n-  MM->invalidateInstructionCache();\n-  return wrap(EE);\n-}\n-\n extern \"C\" void\n LLVMRustSetNormalizedTarget(LLVMModuleRef M, const char *triple) {\n     unwrap(M)->setTargetTriple(Triple::normalize(triple));\n@@ -566,7 +290,7 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateStructType(\n         unwrapDI<DIType>(DerivedFrom),\n         unwrapDI<DIArray>(Elements),\n         RunTimeLang,\n-        unwrapDI<MDNode*>(VTableHolder),\n+        unwrapDI<DIType>(VTableHolder),\n         UniqueId));\n }\n "}, {"sha": "a72e585355480df7b8e221876478231bd8c8463b", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b34ba242d7372b779bf50682b9401b61183828e/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/6b34ba242d7372b779bf50682b9401b61183828e/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=6b34ba242d7372b779bf50682b9401b61183828e", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2013-09-23\n+2013-11-19"}, {"sha": "d8ec1c868408d0738b2a9dfbd4301e75d6a67afd", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b34ba242d7372b779bf50682b9401b61183828e/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/6b34ba242d7372b779bf50682b9401b61183828e/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=6b34ba242d7372b779bf50682b9401b61183828e", "patch": "@@ -3,9 +3,6 @@ LLVMRustWriteOutputFile\n LLVMRustGetLastError\n LLVMRustConstSmallInt\n LLVMRustConstInt\n-LLVMRustLoadCrate\n-LLVMRustPrepareJIT\n-LLVMRustBuildJIT\n LLVMRustPrintPassTimings\n LLVMRustStartMultithreading\n LLVMCreateObjectFile"}]}