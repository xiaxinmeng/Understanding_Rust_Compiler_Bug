{"sha": "ace2c92a96eb4ac46913305854235592aa9207ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjZTJjOTJhOTZlYjRhYzQ2OTEzMzA1ODU0MjM1NTkyYWE5MjA3YWU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-28T21:42:01Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-28T21:42:01Z"}, "message": "rustc: Populate the item types table with types of items from external crates; remove the redundant typeck.ty_and_params type on the way", "tree": {"sha": "06bb55116d3934e60b5bb71a4610de54473b5808", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06bb55116d3934e60b5bb71a4610de54473b5808"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ace2c92a96eb4ac46913305854235592aa9207ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ace2c92a96eb4ac46913305854235592aa9207ae", "html_url": "https://github.com/rust-lang/rust/commit/ace2c92a96eb4ac46913305854235592aa9207ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ace2c92a96eb4ac46913305854235592aa9207ae/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "621ab344101b3733566a1367f6fa87ab50385d2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/621ab344101b3733566a1367f6fa87ab50385d2e", "html_url": "https://github.com/rust-lang/rust/commit/621ab344101b3733566a1367f6fa87ab50385d2e"}], "stats": {"total": 55, "additions": 43, "deletions": 12}, "files": [{"sha": "7dac336798208dfd8841e5e24d3643c76aab2703", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ace2c92a96eb4ac46913305854235592aa9207ae/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ace2c92a96eb4ac46913305854235592aa9207ae/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=ace2c92a96eb4ac46913305854235592aa9207ae", "patch": "@@ -9,7 +9,6 @@ import lib.llvm.mk_section_iter;\n import middle.fold;\n import middle.metadata;\n import middle.ty;\n-import middle.typeck;\n import back.x86;\n import util.common;\n import util.common.span;\n@@ -522,7 +521,7 @@ fn lookup_def(session.session sess, &span sp, int cnum, vec[ast.ident] path)\n     fail;\n }\n \n-fn get_type(session.session sess, ast.def_id def) -> typeck.ty_and_params {\n+fn get_type(session.session sess, ast.def_id def) -> ty.ty_params_and_ty {\n     // FIXME: fill in.\n     fail;\n }"}, {"sha": "2fd89401c0e04201b13de07495630742a8cbc0e4", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ace2c92a96eb4ac46913305854235592aa9207ae/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ace2c92a96eb4ac46913305854235592aa9207ae/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=ace2c92a96eb4ac46913305854235592aa9207ae", "patch": "@@ -53,8 +53,7 @@ type fn_ctxt = rec(@ty.t ret_ty,\n                    @crate_ctxt ccx);\n \n // Used for ast_ty_to_ty() below.\n-type ty_and_params = rec(vec[ast.ty_param] params, @ty.t ty);\n-type ty_getter = fn(ast.def_id) -> ty_and_params;\n+type ty_getter = fn(ast.def_id) -> ty.ty_params_and_ty;\n \n // Replaces parameter types inside a type with type variables.\n fn generalize_ty(@crate_ctxt cx, @ty.t t) -> @ty.t {\n@@ -128,6 +127,23 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n     ret ty.fold_ty(substituter, typ);\n }\n \n+\n+// Looks up the type of the given item in an external crate.\n+fn lookup_item_type_if_necessary(@crate_ctxt ccx, ast.def_id did) {\n+    if (did._0 == ccx.sess.get_targ_crate_num()) {\n+        ret;    // Nothing to do; it should already be in the tables.\n+    }\n+\n+    if (ccx.item_types.contains_key(did)) {\n+        ret;    // Nothing to do; we already looked up this item's type.\n+    }\n+\n+    auto tyt = creader.get_type(ccx.sess, did);\n+    ccx.item_types.insert(did, tyt._1);\n+    ccx.item_ty_params.insert(did, tyt._0);\n+}\n+\n+\n type ty_params_opt_and_ty = tup(option.t[vec[ast.def_id]], @ty.t);\n \n // Returns the type parameters and the type for the given definition.\n@@ -151,20 +167,25 @@ fn ty_params_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n             ret tup(none[vec[ast.def_id]], fcx.locals.get(id));\n         }\n         case (ast.def_fn(?id)) {\n+            lookup_item_type_if_necessary(fcx.ccx, id);\n             check (fcx.ccx.item_types.contains_key(id));\n             ret tup(some(fcx.ccx.item_ty_params.get(id)),\n                     fcx.ccx.item_types.get(id));\n         }\n         case (ast.def_native_fn(?id)) {\n+            lookup_item_type_if_necessary(fcx.ccx, id);\n             check (fcx.ccx.item_types.contains_key(id));\n             ret tup(some(fcx.ccx.item_ty_params.get(id)),\n                     fcx.ccx.item_types.get(id));\n         }\n         case (ast.def_const(?id)) {\n+            lookup_item_type_if_necessary(fcx.ccx, id);\n             check (fcx.ccx.item_types.contains_key(id));\n             ret tup(none[vec[ast.def_id]], fcx.ccx.item_types.get(id));\n         }\n         case (ast.def_variant(?tag_id, ?variant_id)) {\n+            lookup_item_type_if_necessary(fcx.ccx, tag_id);\n+            lookup_item_type_if_necessary(fcx.ccx, variant_id);\n             check (fcx.ccx.item_types.contains_key(variant_id));\n             ret tup(some(fcx.ccx.item_ty_params.get(tag_id)),\n                     fcx.ccx.item_types.get(variant_id));\n@@ -174,6 +195,7 @@ fn ty_params_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n             ret tup(none[vec[ast.def_id]], fcx.locals.get(id));\n         }\n         case (ast.def_obj(?id)) {\n+            lookup_item_type_if_necessary(fcx.ccx, id);\n             check (fcx.ccx.item_types.contains_key(id));\n             ret tup(some(fcx.ccx.item_ty_params.get(id)),\n                     fcx.ccx.item_types.get(id));\n@@ -291,17 +313,17 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n         // TODO: maybe record cname chains so we can do\n         // \"foo = int\" like OCaml?\n         auto ty_and_params = getter(id);\n-        auto params = ty_and_params.params;\n+        auto params = ty_and_params._0;\n         auto num_type_args = _vec.len[@ast.ty](args);\n-        check(num_type_args == _vec.len[ast.ty_param](params));\n+        check(num_type_args == _vec.len[ast.def_id](params));\n \n         auto param_map = common.new_def_hash[@ty.t]();\n         for each (uint i in _uint.range(0u, num_type_args)) {\n             auto arg = args.(i);\n             auto param = params.(i);\n-            param_map.insert(param.id, ast_ty_to_ty(getter, arg));\n+            param_map.insert(param, ast_ty_to_ty(getter, arg));\n         }\n-        ret ty.replace_type_params(ty_and_params.ty, param_map);\n+        ret ty.replace_type_params(ty_and_params._1, param_map);\n     }\n \n     auto mut = ast.imm;\n@@ -404,7 +426,7 @@ fn actual_type(@ty.t t, @ast.item item) -> @ty.t {\n // A convenience function to use a crate_ctxt to resolve names for\n // ast_ty_to_ty.\n fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> @ty.t {\n-    fn getter(@crate_ctxt ccx, ast.def_id id) -> ty_and_params {\n+    fn getter(@crate_ctxt ccx, ast.def_id id) -> ty.ty_params_and_ty {\n \n         if (id._0 != ccx.sess.get_targ_crate_num()) {\n             // This is a type we need to load in from the crate reader.\n@@ -426,7 +448,12 @@ fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> @ty.t {\n            }\n         }\n \n-        ret rec(params = params, ty = ty);\n+        let vec[ast.def_id] param_ids = vec();\n+        for (ast.ty_param tp in params) {\n+            param_ids += vec(tp.id);\n+        }\n+\n+        ret tup(param_ids, ty);\n     }\n     auto f = bind getter(ccx, _);\n     ret ast_ty_to_ty(f, ast_ty);\n@@ -510,7 +537,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n     fn getter(session.session sess,\n               @ty_item_table id_to_ty_item,\n               @ty_table item_to_ty,\n-              ast.def_id id) -> ty_and_params {\n+              ast.def_id id) -> ty.ty_params_and_ty {\n \n         if (id._0 != sess.get_targ_crate_num()) {\n             // This is a type we need to load in from the crate reader.\n@@ -535,7 +562,12 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n             }\n         }\n \n-        ret rec(params = params, ty = ty);\n+        let vec[ast.def_id] param_ids = vec();\n+        for (ast.ty_param tp in params) {\n+            param_ids += vec(tp.id);\n+        }\n+\n+        ret tup(param_ids, ty);\n     }\n \n     fn ty_of_arg(session.session sess,"}]}