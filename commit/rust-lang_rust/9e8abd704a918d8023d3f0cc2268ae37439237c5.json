{"sha": "9e8abd704a918d8023d3f0cc2268ae37439237c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllOGFiZDcwNGE5MThkODAyM2QzZjBjYzIyNjhhZTM3NDM5MjM3YzU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-04T21:56:27Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-15T21:50:30Z"}, "message": "apply rustfmt to `type_check`", "tree": {"sha": "054e2939935384cb4bb991253e6bf4081e3dafee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/054e2939935384cb4bb991253e6bf4081e3dafee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e8abd704a918d8023d3f0cc2268ae37439237c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e8abd704a918d8023d3f0cc2268ae37439237c5", "html_url": "https://github.com/rust-lang/rust/commit/9e8abd704a918d8023d3f0cc2268ae37439237c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e8abd704a918d8023d3f0cc2268ae37439237c5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d672961fbb0f5b69d39003757bddef1d1d4469a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d672961fbb0f5b69d39003757bddef1d1d4469a", "html_url": "https://github.com/rust-lang/rust/commit/6d672961fbb0f5b69d39003757bddef1d1d4469a"}], "stats": {"total": 620, "additions": 364, "deletions": 256}, "files": [{"sha": "2adb36434d8a9cc05ca4a2d2b0688e62691be82c", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 364, "deletions": 256, "changes": 620, "blob_url": "https://github.com/rust-lang/rust/blob/9e8abd704a918d8023d3f0cc2268ae37439237c5/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e8abd704a918d8023d3f0cc2268ae37439237c5/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=9e8abd704a918d8023d3f0cc2268ae37439237c5", "patch": "@@ -51,20 +51,20 @@ macro_rules! span_mirbug_and_err {\n }\n \n enum FieldAccessError {\n-    OutOfRange { field_count: usize }\n+    OutOfRange { field_count: usize },\n }\n \n /// Verifies that MIR types are sane to not crash further checks.\n ///\n /// The sanitize_XYZ methods here take an MIR object and compute its\n /// type, calling `span_mirbug` and returning an error type if there\n /// is a problem.\n-struct TypeVerifier<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n+struct TypeVerifier<'a, 'b: 'a, 'gcx: 'b + 'tcx, 'tcx: 'b> {\n     cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     last_span: Span,\n     body_id: ast::NodeId,\n-    errors_reported: bool\n+    errors_reported: bool,\n }\n \n impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n@@ -74,10 +74,12 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_lvalue(&mut self,\n-                    lvalue: &Lvalue<'tcx>,\n-                    _context: visit::LvalueContext,\n-                    location: Location) {\n+    fn visit_lvalue(\n+        &mut self,\n+        lvalue: &Lvalue<'tcx>,\n+        _context: visit::LvalueContext,\n+        location: Location,\n+    ) {\n         self.sanitize_lvalue(lvalue, location);\n     }\n \n@@ -116,7 +118,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             body_id: cx.body_id,\n             cx,\n             last_span: mir.span,\n-            errors_reported: false\n+            errors_reported: false,\n         }\n     }\n \n@@ -135,38 +137,47 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn sanitize_lvalue(&mut self, lvalue: &Lvalue<'tcx>, location: Location) -> LvalueTy<'tcx> {\n         debug!(\"sanitize_lvalue: {:?}\", lvalue);\n         match *lvalue {\n-            Lvalue::Local(index) => LvalueTy::Ty { ty: self.mir.local_decls[index].ty },\n+            Lvalue::Local(index) => LvalueTy::Ty {\n+                ty: self.mir.local_decls[index].ty,\n+            },\n             Lvalue::Static(box Static { def_id, ty: sty }) => {\n                 let sty = self.sanitize_type(lvalue, sty);\n                 let ty = self.tcx().type_of(def_id);\n                 let ty = self.cx.normalize(&ty, location);\n                 if let Err(terr) = self.cx.eq_types(self.last_span, ty, sty, location) {\n                     span_mirbug!(\n-                        self, lvalue, \"bad static type ({:?}: {:?}): {:?}\",\n-                        ty, sty, terr);\n+                        self,\n+                        lvalue,\n+                        \"bad static type ({:?}: {:?}): {:?}\",\n+                        ty,\n+                        sty,\n+                        terr\n+                    );\n                 }\n                 LvalueTy::Ty { ty: sty }\n-\n-            },\n+            }\n             Lvalue::Projection(ref proj) => {\n                 let base_ty = self.sanitize_lvalue(&proj.base, location);\n                 if let LvalueTy::Ty { ty } = base_ty {\n                     if ty.references_error() {\n                         assert!(self.errors_reported);\n-                        return LvalueTy::Ty { ty: self.tcx().types.err };\n+                        return LvalueTy::Ty {\n+                            ty: self.tcx().types.err,\n+                        };\n                     }\n                 }\n                 self.sanitize_projection(base_ty, &proj.elem, lvalue, location)\n             }\n         }\n     }\n \n-    fn sanitize_projection(&mut self,\n-                           base: LvalueTy<'tcx>,\n-                           pi: &LvalueElem<'tcx>,\n-                           lvalue: &Lvalue<'tcx>,\n-                           location: Location)\n-                           -> LvalueTy<'tcx> {\n+    fn sanitize_projection(\n+        &mut self,\n+        base: LvalueTy<'tcx>,\n+        pi: &LvalueElem<'tcx>,\n+        lvalue: &Lvalue<'tcx>,\n+        location: Location,\n+    ) -> LvalueTy<'tcx> {\n         debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, lvalue);\n         let tcx = self.tcx();\n         let base_ty = base.to_ty(tcx);\n@@ -176,97 +187,102 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 let deref_ty = base_ty.builtin_deref(true, ty::LvaluePreference::NoPreference);\n                 LvalueTy::Ty {\n                     ty: deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n-                        span_mirbug_and_err!(\n-                            self, lvalue, \"deref of non-pointer {:?}\", base_ty)\n-                    })\n+                        span_mirbug_and_err!(self, lvalue, \"deref of non-pointer {:?}\", base_ty)\n+                    }),\n                 }\n             }\n             ProjectionElem::Index(i) => {\n                 let index_ty = Lvalue::Local(i).ty(self.mir, tcx).to_ty(tcx);\n                 if index_ty != tcx.types.usize {\n                     LvalueTy::Ty {\n-                        ty: span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i)\n+                        ty: span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i),\n                     }\n                 } else {\n                     LvalueTy::Ty {\n                         ty: base_ty.builtin_index().unwrap_or_else(|| {\n-                            span_mirbug_and_err!(\n-                                self, lvalue, \"index of non-array {:?}\", base_ty)\n-                        })\n+                            span_mirbug_and_err!(self, lvalue, \"index of non-array {:?}\", base_ty)\n+                        }),\n                     }\n                 }\n             }\n             ProjectionElem::ConstantIndex { .. } => {\n                 // consider verifying in-bounds\n                 LvalueTy::Ty {\n                     ty: base_ty.builtin_index().unwrap_or_else(|| {\n-                        span_mirbug_and_err!(\n-                            self, lvalue, \"index of non-array {:?}\", base_ty)\n-                    })\n+                        span_mirbug_and_err!(self, lvalue, \"index of non-array {:?}\", base_ty)\n+                    }),\n                 }\n             }\n-            ProjectionElem::Subslice { from, to } => {\n-                LvalueTy::Ty {\n-                    ty: match base_ty.sty {\n-                        ty::TyArray(inner, size) => {\n-                            let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n-                            let min_size = (from as u64) + (to as u64);\n-                            if let Some(rest_size) = size.checked_sub(min_size) {\n-                                tcx.mk_array(inner, rest_size)\n-                            } else {\n-                                span_mirbug_and_err!(\n-                                    self, lvalue, \"taking too-small slice of {:?}\", base_ty)\n-                            }\n-                        }\n-                        ty::TySlice(..) => base_ty,\n-                        _ => {\n+            ProjectionElem::Subslice { from, to } => LvalueTy::Ty {\n+                ty: match base_ty.sty {\n+                    ty::TyArray(inner, size) => {\n+                        let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n+                        let min_size = (from as u64) + (to as u64);\n+                        if let Some(rest_size) = size.checked_sub(min_size) {\n+                            tcx.mk_array(inner, rest_size)\n+                        } else {\n                             span_mirbug_and_err!(\n-                                self, lvalue, \"slice of non-array {:?}\", base_ty)\n+                                self,\n+                                lvalue,\n+                                \"taking too-small slice of {:?}\",\n+                                base_ty\n+                            )\n                         }\n                     }\n-                }\n-            }\n-            ProjectionElem::Downcast(adt_def1, index) =>\n-                match base_ty.sty {\n-                    ty::TyAdt(adt_def, substs) if adt_def.is_enum() && adt_def == adt_def1 => {\n-                        if index >= adt_def.variants.len() {\n-                            LvalueTy::Ty {\n-                                ty: span_mirbug_and_err!(\n-                                    self,\n-                                    lvalue,\n-                                    \"cast to variant #{:?} but enum only has {:?}\",\n-                                    index,\n-                                    adt_def.variants.len())\n-                            }\n-                        } else {\n-                            LvalueTy::Downcast {\n-                                adt_def,\n-                                substs,\n-                                variant_index: index\n-                            }\n+                    ty::TySlice(..) => base_ty,\n+                    _ => span_mirbug_and_err!(self, lvalue, \"slice of non-array {:?}\", base_ty),\n+                },\n+            },\n+            ProjectionElem::Downcast(adt_def1, index) => match base_ty.sty {\n+                ty::TyAdt(adt_def, substs) if adt_def.is_enum() && adt_def == adt_def1 => {\n+                    if index >= adt_def.variants.len() {\n+                        LvalueTy::Ty {\n+                            ty: span_mirbug_and_err!(\n+                                self,\n+                                lvalue,\n+                                \"cast to variant #{:?} but enum only has {:?}\",\n+                                index,\n+                                adt_def.variants.len()\n+                            ),\n+                        }\n+                    } else {\n+                        LvalueTy::Downcast {\n+                            adt_def,\n+                            substs,\n+                            variant_index: index,\n                         }\n                     }\n-                    _ => LvalueTy::Ty {\n-                        ty: span_mirbug_and_err!(\n-                            self, lvalue, \"can't downcast {:?} as {:?}\",\n-                            base_ty, adt_def1)\n-                    }\n+                }\n+                _ => LvalueTy::Ty {\n+                    ty: span_mirbug_and_err!(\n+                        self,\n+                        lvalue,\n+                        \"can't downcast {:?} as {:?}\",\n+                        base_ty,\n+                        adt_def1\n+                    ),\n                 },\n+            },\n             ProjectionElem::Field(field, fty) => {\n                 let fty = self.sanitize_type(lvalue, fty);\n                 match self.field_ty(lvalue, base, field, location) {\n-                    Ok(ty) => {\n-                        if let Err(terr) = self.cx.eq_types(span, ty, fty, location) {\n-                            span_mirbug!(\n-                                self, lvalue, \"bad field access ({:?}: {:?}): {:?}\",\n-                                ty, fty, terr);\n-                        }\n-                    }\n-                    Err(FieldAccessError::OutOfRange { field_count }) => {\n+                    Ok(ty) => if let Err(terr) = self.cx.eq_types(span, ty, fty, location) {\n                         span_mirbug!(\n-                            self, lvalue, \"accessed field #{} but variant only has {}\",\n-                            field.index(), field_count)\n-                    }\n+                            self,\n+                            lvalue,\n+                            \"bad field access ({:?}: {:?}): {:?}\",\n+                            ty,\n+                            fty,\n+                            terr\n+                        );\n+                    },\n+                    Err(FieldAccessError::OutOfRange { field_count }) => span_mirbug!(\n+                        self,\n+                        lvalue,\n+                        \"accessed field #{} but variant only has {}\",\n+                        field.index(),\n+                        field_count\n+                    ),\n                 }\n                 LvalueTy::Ty { ty: fty }\n             }\n@@ -278,29 +294,31 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         self.tcx().types.err\n     }\n \n-    fn field_ty(&mut self,\n-                parent: &fmt::Debug,\n-                base_ty: LvalueTy<'tcx>,\n-                field: Field,\n-                location: Location)\n-                -> Result<Ty<'tcx>, FieldAccessError>\n-    {\n+    fn field_ty(\n+        &mut self,\n+        parent: &fmt::Debug,\n+        base_ty: LvalueTy<'tcx>,\n+        field: Field,\n+        location: Location,\n+    ) -> Result<Ty<'tcx>, FieldAccessError> {\n         let tcx = self.tcx();\n \n         let (variant, substs) = match base_ty {\n-            LvalueTy::Downcast { adt_def, substs, variant_index } => {\n-                (&adt_def.variants[variant_index], substs)\n-            }\n+            LvalueTy::Downcast {\n+                adt_def,\n+                substs,\n+                variant_index,\n+            } => (&adt_def.variants[variant_index], substs),\n             LvalueTy::Ty { ty } => match ty.sty {\n                 ty::TyAdt(adt_def, substs) if adt_def.is_univariant() => {\n-                        (&adt_def.variants[0], substs)\n-                    }\n+                    (&adt_def.variants[0], substs)\n+                }\n                 ty::TyClosure(def_id, substs) => {\n                     return match substs.upvar_tys(def_id, tcx).nth(field.index()) {\n                         Some(ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n-                            field_count: substs.upvar_tys(def_id, tcx).count()\n-                        })\n+                            field_count: substs.upvar_tys(def_id, tcx).count(),\n+                        }),\n                     }\n                 }\n                 ty::TyGenerator(def_id, substs, _) => {\n@@ -312,32 +330,40 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     return match substs.field_tys(def_id, tcx).nth(field.index()) {\n                         Some(ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n-                            field_count: substs.field_tys(def_id, tcx).count() + 1\n-                        })\n-                    }\n+                            field_count: substs.field_tys(def_id, tcx).count() + 1,\n+                        }),\n+                    };\n                 }\n                 ty::TyTuple(tys, _) => {\n                     return match tys.get(field.index()) {\n                         Some(&ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n-                            field_count: tys.len()\n-                        })\n+                            field_count: tys.len(),\n+                        }),\n                     }\n                 }\n-                _ => return Ok(span_mirbug_and_err!(\n-                    self, parent, \"can't project out of {:?}\", base_ty))\n-            }\n+                _ => {\n+                    return Ok(span_mirbug_and_err!(\n+                        self,\n+                        parent,\n+                        \"can't project out of {:?}\",\n+                        base_ty\n+                    ))\n+                }\n+            },\n         };\n \n         if let Some(field) = variant.fields.get(field.index()) {\n             Ok(self.cx.normalize(&field.ty(tcx, substs), location))\n         } else {\n-            Err(FieldAccessError::OutOfRange { field_count: variant.fields.len() })\n+            Err(FieldAccessError::OutOfRange {\n+                field_count: variant.fields.len(),\n+            })\n         }\n     }\n }\n \n-pub struct TypeChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n     fulfillment_cx: traits::FulfillmentContext<'tcx>,\n@@ -347,10 +373,11 @@ pub struct TypeChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-           body_id: ast::NodeId,\n-           param_env: ty::ParamEnv<'gcx>)\n-           -> Self {\n+    fn new(\n+        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+        body_id: ast::NodeId,\n+        param_env: ty::ParamEnv<'gcx>,\n+    ) -> Self {\n         TypeChecker {\n             infcx,\n             fulfillment_cx: traits::FulfillmentContext::new(),\n@@ -367,62 +394,82 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     pub fn register_infer_ok_obligations<T>(&mut self, infer_ok: InferOk<'tcx, T>) -> T {\n         for obligation in infer_ok.obligations {\n-            self.fulfillment_cx.register_predicate_obligation(self.infcx, obligation);\n+            self.fulfillment_cx\n+                .register_predicate_obligation(self.infcx, obligation);\n         }\n         infer_ok.value\n     }\n \n-    fn sub_types(&mut self, sub: Ty<'tcx>, sup: Ty<'tcx>, _at_location: Location)\n-                 -> infer::UnitResult<'tcx>\n-    {\n-        self.infcx.at(&self.misc(self.last_span), self.param_env)\n-                  .sup(sup, sub)\n-                  .map(|ok| self.register_infer_ok_obligations(ok))\n+    fn sub_types(\n+        &mut self,\n+        sub: Ty<'tcx>,\n+        sup: Ty<'tcx>,\n+        _at_location: Location,\n+    ) -> infer::UnitResult<'tcx> {\n+        self.infcx\n+            .at(&self.misc(self.last_span), self.param_env)\n+            .sup(sup, sub)\n+            .map(|ok| self.register_infer_ok_obligations(ok))\n     }\n \n-    fn eq_types(&mut self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>, _at_location: Location)\n-                -> infer::UnitResult<'tcx>\n-    {\n-        self.infcx.at(&self.misc(span), self.param_env)\n-                  .eq(b, a)\n-                  .map(|ok| self.register_infer_ok_obligations(ok))\n+    fn eq_types(\n+        &mut self,\n+        span: Span,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        _at_location: Location,\n+    ) -> infer::UnitResult<'tcx> {\n+        self.infcx\n+            .at(&self.misc(span), self.param_env)\n+            .eq(b, a)\n+            .map(|ok| self.register_infer_ok_obligations(ok))\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn check_stmt(&mut self,\n-                  mir: &Mir<'tcx>,\n-                  stmt: &Statement<'tcx>,\n-                  location: Location) {\n+    fn check_stmt(&mut self, mir: &Mir<'tcx>, stmt: &Statement<'tcx>, location: Location) {\n         debug!(\"check_stmt: {:?}\", stmt);\n         let tcx = self.tcx();\n         match stmt.kind {\n             StatementKind::Assign(ref lv, ref rv) => {\n                 let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n                 if let Err(terr) = self.sub_types(rv_ty, lv_ty, location.successor_within_block()) {\n-                    span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n-                                 lv_ty, rv_ty, terr);\n-                }\n-            }\n-            StatementKind::SetDiscriminant{ ref lvalue, variant_index } => {\n+                    span_mirbug!(\n+                        self,\n+                        stmt,\n+                        \"bad assignment ({:?} = {:?}): {:?}\",\n+                        lv_ty,\n+                        rv_ty,\n+                        terr\n+                    );\n+                }\n+            }\n+            StatementKind::SetDiscriminant {\n+                ref lvalue,\n+                variant_index,\n+            } => {\n                 let lvalue_type = lvalue.ty(mir, tcx).to_ty(tcx);\n                 let adt = match lvalue_type.sty {\n                     TypeVariants::TyAdt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n-                        span_bug!(stmt.source_info.span,\n-                                  \"bad set discriminant ({:?} = {:?}): lhs is not an enum\",\n-                                  lvalue,\n-                                  variant_index);\n+                        span_bug!(\n+                            stmt.source_info.span,\n+                            \"bad set discriminant ({:?} = {:?}): lhs is not an enum\",\n+                            lvalue,\n+                            variant_index\n+                        );\n                     }\n                 };\n                 if variant_index >= adt.variants.len() {\n-                     span_bug!(stmt.source_info.span,\n-                               \"bad set discriminant ({:?} = {:?}): value of of range\",\n-                               lvalue,\n-                               variant_index);\n+                    span_bug!(\n+                        stmt.source_info.span,\n+                        \"bad set discriminant ({:?} = {:?}): value of of range\",\n+                        lvalue,\n+                        variant_index\n+                    );\n                 };\n             }\n             StatementKind::StorageLive(_) |\n@@ -434,10 +481,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_terminator(&mut self,\n-                        mir: &Mir<'tcx>,\n-                        term: &Terminator<'tcx>,\n-                        location: Location) {\n+    fn check_terminator(&mut self, mir: &Mir<'tcx>, term: &Terminator<'tcx>, location: Location) {\n         debug!(\"check_terminator: {:?}\", term);\n         let tcx = self.tcx();\n         match term.kind {\n@@ -451,7 +495,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // no checks needed for these\n             }\n \n-\n             TerminatorKind::DropAndReplace {\n                 ref location,\n                 ref value,\n@@ -462,34 +505,59 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let rv_ty = value.ty(mir, tcx);\n \n                 if let Err(terr) = self.sub_types(rv_ty, lv_ty, target.start_location()) {\n-                    span_mirbug!(self, term, \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n-                                 lv_ty, rv_ty, terr);\n+                    span_mirbug!(\n+                        self,\n+                        term,\n+                        \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n+                        lv_ty,\n+                        rv_ty,\n+                        terr\n+                    );\n                 }\n \n                 // Subtle: this assignment occurs at the start of\n                 // *both* blocks, so we need to ensure that it holds\n                 // at both locations.\n                 if let Some(unwind) = unwind {\n                     if let Err(terr) = self.sub_types(rv_ty, lv_ty, unwind.start_location()) {\n-                        span_mirbug!(self, term, \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n-                                     lv_ty, rv_ty, terr);\n+                        span_mirbug!(\n+                            self,\n+                            term,\n+                            \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n+                            lv_ty,\n+                            rv_ty,\n+                            terr\n+                        );\n                     }\n                 }\n             }\n-            TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n+            TerminatorKind::SwitchInt {\n+                ref discr,\n+                switch_ty,\n+                ..\n+            } => {\n                 let discr_ty = discr.ty(mir, tcx);\n                 if let Err(terr) = self.sub_types(discr_ty, switch_ty, location) {\n-                    span_mirbug!(self, term, \"bad SwitchInt ({:?} on {:?}): {:?}\",\n-                                 switch_ty, discr_ty, terr);\n+                    span_mirbug!(\n+                        self,\n+                        term,\n+                        \"bad SwitchInt ({:?} on {:?}): {:?}\",\n+                        switch_ty,\n+                        discr_ty,\n+                        terr\n+                    );\n                 }\n-                if !switch_ty.is_integral() && !switch_ty.is_char() &&\n-                    !switch_ty.is_bool()\n-                {\n-                    span_mirbug!(self, term, \"bad SwitchInt discr ty {:?}\",switch_ty);\n+                if !switch_ty.is_integral() && !switch_ty.is_char() && !switch_ty.is_bool() {\n+                    span_mirbug!(self, term, \"bad SwitchInt discr ty {:?}\", switch_ty);\n                 }\n                 // FIXME: check the values\n             }\n-            TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n+            TerminatorKind::Call {\n+                ref func,\n+                ref args,\n+                ref destination,\n+                ..\n+            } => {\n                 let func_ty = func.ty(mir, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n                 let sig = match func_ty.sty {\n@@ -509,7 +577,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     self.check_call_inputs(mir, term, &sig, args, location);\n                 }\n             }\n-            TerminatorKind::Assert { ref cond, ref msg, .. } => {\n+            TerminatorKind::Assert {\n+                ref cond, ref msg, ..\n+            } => {\n                 let cond_ty = cond.ty(mir, tcx);\n                 if cond_ty != tcx.types.bool {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n@@ -528,88 +598,108 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let value_ty = value.ty(mir, tcx);\n                 match mir.yield_ty {\n                     None => span_mirbug!(self, term, \"yield in non-generator\"),\n-                    Some(ty) => {\n-                        if let Err(terr) = self.sub_types(value_ty, ty, location) {\n-                            span_mirbug!(self,\n-                                term,\n-                                \"type of yield value is {:?}, but the yield type is {:?}: {:?}\",\n-                                value_ty,\n-                                ty,\n-                                terr);\n-                        }\n-                    }\n+                    Some(ty) => if let Err(terr) = self.sub_types(value_ty, ty, location) {\n+                        span_mirbug!(\n+                            self,\n+                            term,\n+                            \"type of yield value is {:?}, but the yield type is {:?}: {:?}\",\n+                            value_ty,\n+                            ty,\n+                            terr\n+                        );\n+                    },\n                 }\n             }\n         }\n     }\n \n-    fn check_call_dest(&mut self,\n-                       mir: &Mir<'tcx>,\n-                       term: &Terminator<'tcx>,\n-                       sig: &ty::FnSig<'tcx>,\n-                       destination: &Option<(Lvalue<'tcx>, BasicBlock)>) {\n+    fn check_call_dest(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        term: &Terminator<'tcx>,\n+        sig: &ty::FnSig<'tcx>,\n+        destination: &Option<(Lvalue<'tcx>, BasicBlock)>,\n+    ) {\n         let tcx = self.tcx();\n         match *destination {\n             Some((ref dest, target_block)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                if let Err(terr) = self.sub_types(sig.output(),\n-                                                  dest_ty,\n-                                                  target_block.start_location()) {\n-                    span_mirbug!(self, term,\n-                                 \"call dest mismatch ({:?} <- {:?}): {:?}\",\n-                                 dest_ty, sig.output(), terr);\n+                if let Err(terr) =\n+                    self.sub_types(sig.output(), dest_ty, target_block.start_location())\n+                {\n+                    span_mirbug!(\n+                        self,\n+                        term,\n+                        \"call dest mismatch ({:?} <- {:?}): {:?}\",\n+                        dest_ty,\n+                        sig.output(),\n+                        terr\n+                    );\n                 }\n-            },\n+            }\n             None => {\n                 // FIXME(canndrew): This is_never should probably be an is_uninhabited\n                 if !sig.output().is_never() {\n                     span_mirbug!(self, term, \"call to converging function {:?} w/o dest\", sig);\n                 }\n-            },\n+            }\n         }\n     }\n \n-    fn check_call_inputs(&mut self,\n-                         mir: &Mir<'tcx>,\n-                         term: &Terminator<'tcx>,\n-                         sig: &ty::FnSig<'tcx>,\n-                         args: &[Operand<'tcx>],\n-                         location: Location)\n-    {\n+    fn check_call_inputs(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        term: &Terminator<'tcx>,\n+        sig: &ty::FnSig<'tcx>,\n+        args: &[Operand<'tcx>],\n+        location: Location,\n+    ) {\n         debug!(\"check_call_inputs({:?}, {:?})\", sig, args);\n-        if args.len() < sig.inputs().len() ||\n-           (args.len() > sig.inputs().len() && !sig.variadic) {\n+        if args.len() < sig.inputs().len() || (args.len() > sig.inputs().len() && !sig.variadic) {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n             let op_arg_ty = op_arg.ty(mir, self.tcx());\n             if let Err(terr) = self.sub_types(op_arg_ty, fn_arg, location) {\n-                span_mirbug!(self, term, \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n-                             n, fn_arg, op_arg_ty, terr);\n+                span_mirbug!(\n+                    self,\n+                    term,\n+                    \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n+                    n,\n+                    fn_arg,\n+                    op_arg_ty,\n+                    terr\n+                );\n             }\n         }\n     }\n \n     fn is_box_free(&self, operand: &Operand<'tcx>) -> bool {\n         match operand {\n             &Operand::Constant(box Constant {\n-                literal: Literal::Value {\n-                    value: &ty::Const { val: ConstVal::Function(def_id, _), .. }, ..\n-                }, ..\n-            }) => {\n-                Some(def_id) == self.tcx().lang_items().box_free_fn()\n-            }\n+                literal:\n+                    Literal::Value {\n+                        value:\n+                            &ty::Const {\n+                                val: ConstVal::Function(def_id, _),\n+                                ..\n+                            },\n+                        ..\n+                    },\n+                ..\n+            }) => Some(def_id) == self.tcx().lang_items().box_free_fn(),\n             _ => false,\n         }\n     }\n \n-    fn check_box_free_inputs(&mut self,\n-                             mir: &Mir<'tcx>,\n-                             term: &Terminator<'tcx>,\n-                             sig: &ty::FnSig<'tcx>,\n-                             args: &[Operand<'tcx>],\n-                             location: Location)\n-    {\n+    fn check_box_free_inputs(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        term: &Terminator<'tcx>,\n+        sig: &ty::FnSig<'tcx>,\n+        args: &[Operand<'tcx>],\n+        location: Location,\n+    ) {\n         debug!(\"check_box_free_inputs\");\n \n         // box_free takes a Box as a pointer. Allow for that.\n@@ -643,38 +733,36 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         };\n \n         if let Err(terr) = self.sub_types(arg_ty, pointee_ty, location) {\n-            span_mirbug!(self, term, \"bad box_free arg ({:?} <- {:?}): {:?}\",\n-                         pointee_ty, arg_ty, terr);\n+            span_mirbug!(\n+                self,\n+                term,\n+                \"bad box_free arg ({:?} <- {:?}): {:?}\",\n+                pointee_ty,\n+                arg_ty,\n+                terr\n+            );\n         }\n     }\n \n-    fn check_iscleanup(&mut self, mir: &Mir<'tcx>, block_data: &BasicBlockData<'tcx>)\n-    {\n+    fn check_iscleanup(&mut self, mir: &Mir<'tcx>, block_data: &BasicBlockData<'tcx>) {\n         let is_cleanup = block_data.is_cleanup;\n         self.last_span = block_data.terminator().source_info.span;\n         match block_data.terminator().kind {\n-            TerminatorKind::Goto { target } =>\n-                self.assert_iscleanup(mir, block_data, target, is_cleanup),\n-            TerminatorKind::SwitchInt { ref targets, .. } => {\n-                for target in targets {\n-                    self.assert_iscleanup(mir, block_data, *target, is_cleanup);\n-                }\n-            }\n-            TerminatorKind::Resume => {\n-                if !is_cleanup {\n-                    span_mirbug!(self, block_data, \"resume on non-cleanup block!\")\n-                }\n-            }\n-            TerminatorKind::Return => {\n-                if is_cleanup {\n-                    span_mirbug!(self, block_data, \"return on cleanup block\")\n-                }\n-            }\n-            TerminatorKind::GeneratorDrop { .. } => {\n-                if is_cleanup {\n-                    span_mirbug!(self, block_data, \"generator_drop in cleanup block\")\n-                }\n+            TerminatorKind::Goto { target } => {\n+                self.assert_iscleanup(mir, block_data, target, is_cleanup)\n             }\n+            TerminatorKind::SwitchInt { ref targets, .. } => for target in targets {\n+                self.assert_iscleanup(mir, block_data, *target, is_cleanup);\n+            },\n+            TerminatorKind::Resume => if !is_cleanup {\n+                span_mirbug!(self, block_data, \"resume on non-cleanup block!\")\n+            },\n+            TerminatorKind::Return => if is_cleanup {\n+                span_mirbug!(self, block_data, \"return on cleanup block\")\n+            },\n+            TerminatorKind::GeneratorDrop { .. } => if is_cleanup {\n+                span_mirbug!(self, block_data, \"generator_drop in cleanup block\")\n+            },\n             TerminatorKind::Yield { resume, drop, .. } => {\n                 if is_cleanup {\n                     span_mirbug!(self, block_data, \"yield in cleanup block\")\n@@ -687,7 +775,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             TerminatorKind::Unreachable => {}\n             TerminatorKind::Drop { target, unwind, .. } |\n             TerminatorKind::DropAndReplace { target, unwind, .. } |\n-            TerminatorKind::Assert { target, cleanup: unwind, .. } => {\n+            TerminatorKind::Assert {\n+                target,\n+                cleanup: unwind,\n+                ..\n+            } => {\n                 self.assert_iscleanup(mir, block_data, target, is_cleanup);\n                 if let Some(unwind) = unwind {\n                     if is_cleanup {\n@@ -696,7 +788,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     self.assert_iscleanup(mir, block_data, unwind, true);\n                 }\n             }\n-            TerminatorKind::Call { ref destination, cleanup, .. } => {\n+            TerminatorKind::Call {\n+                ref destination,\n+                cleanup,\n+                ..\n+            } => {\n                 if let &Some((_, target)) = destination {\n                     self.assert_iscleanup(mir, block_data, target, is_cleanup);\n                 }\n@@ -707,7 +803,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     self.assert_iscleanup(mir, block_data, cleanup, true);\n                 }\n             }\n-            TerminatorKind::FalseEdges { real_target, ref imaginary_targets } => {\n+            TerminatorKind::FalseEdges {\n+                real_target,\n+                ref imaginary_targets,\n+            } => {\n                 self.assert_iscleanup(mir, block, real_target, is_cleanup);\n                 for target in imaginary_targets {\n                     self.assert_iscleanup(mir, block, *target, is_cleanup);\n@@ -716,15 +815,21 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn assert_iscleanup(&mut self,\n-                        mir: &Mir<'tcx>,\n-                        ctxt: &fmt::Debug,\n-                        bb: BasicBlock,\n-                        iscleanuppad: bool)\n-    {\n+    fn assert_iscleanup(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        ctxt: &fmt::Debug,\n+        bb: BasicBlock,\n+        iscleanuppad: bool,\n+    ) {\n         if mir[bb].is_cleanup != iscleanuppad {\n-            span_mirbug!(self, ctxt, \"cleanuppad mismatch: {:?} should be {:?}\",\n-                         bb, iscleanuppad);\n+            span_mirbug!(\n+                self,\n+                ctxt,\n+                \"cleanuppad mismatch: {:?} should be {:?}\",\n+                bb,\n+                iscleanuppad\n+            );\n         }\n     }\n \n@@ -737,7 +842,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 //\n                 // Unbound parts of arguments were never required to be Sized\n                 // - maybe we should make that a warning.\n-                return\n+                return;\n             }\n             LocalKind::Var | LocalKind::Temp => {}\n         }\n@@ -750,9 +855,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             // slot or local, so to find all unsized rvalues it is enough\n             // to check all temps, return slots and locals.\n             if let None = self.reported_errors.replace((ty, span)) {\n-                span_err!(self.tcx().sess, span, E0161,\n-                          \"cannot move a value of type {0}: the size of {0} \\\n-                           cannot be statically determined\", ty);\n+                span_err!(\n+                    self.tcx().sess,\n+                    span,\n+                    E0161,\n+                    \"cannot move a value of type {0}: the size of {0} \\\n+                     cannot be statically determined\",\n+                    ty\n+                );\n             }\n         }\n     }\n@@ -766,7 +876,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n \n         for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n-            let mut location = Location { block, statement_index: 0 };\n+            let mut location = Location {\n+                block,\n+                statement_index: 0,\n+            };\n             for stmt in &block_data.statements {\n                 if stmt.source_info.span != DUMMY_SP {\n                     self.last_span = stmt.source_info.span;\n@@ -782,16 +895,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n \n     fn normalize<T>(&mut self, value: &T, _location: Location) -> T\n-        where T: fmt::Debug + TypeFoldable<'tcx>\n+    where\n+        T: fmt::Debug + TypeFoldable<'tcx>,\n     {\n         let mut selcx = traits::SelectionContext::new(self.infcx);\n         let cause = traits::ObligationCause::misc(self.last_span, ast::CRATE_NODE_ID);\n         let traits::Normalized { value, obligations } =\n             traits::normalize(&mut selcx, self.param_env, cause, value);\n \n-        debug!(\"normalize: value={:?} obligations={:?}\",\n-               value,\n-               obligations);\n+        debug!(\"normalize: value={:?} obligations={:?}\", value, obligations);\n \n         let fulfill_cx = &mut self.fulfillment_cx;\n         for obligation in obligations {\n@@ -804,19 +916,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn verify_obligations(&mut self, mir: &Mir<'tcx>) {\n         self.last_span = mir.span;\n         if let Err(e) = self.fulfillment_cx.select_all_or_error(self.infcx) {\n-            span_mirbug!(self, \"\", \"errors selecting obligation: {:?}\",\n-                         e);\n+            span_mirbug!(self, \"\", \"errors selecting obligation: {:?}\", e);\n         }\n     }\n }\n \n pub struct TypeckMir;\n \n impl MirPass for TypeckMir {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          src: MirSource,\n-                          mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n         let def_id = src.def_id;\n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n         debug!(\"run_pass: {:?}\", def_id);"}]}