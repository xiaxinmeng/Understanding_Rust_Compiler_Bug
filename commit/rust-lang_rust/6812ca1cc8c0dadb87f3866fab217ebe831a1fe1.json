{"sha": "6812ca1cc8c0dadb87f3866fab217ebe831a1fe1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MTJjYTFjYzhjMGRhZGI4N2YzODY2ZmFiMjE3ZWJlODMxYTFmZTE=", "commit": {"author": {"name": "Peter Elmers", "email": "peter.elmers@yahoo.com", "date": "2015-06-02T19:21:20Z"}, "committer": {"name": "Peter Elmers", "email": "peter.elmers@yahoo.com", "date": "2015-06-02T19:21:20Z"}, "message": "Move EnumData to the API.", "tree": {"sha": "4b36ff0af36af265447a5fa58d7ba0ec03492668", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b36ff0af36af265447a5fa58d7ba0ec03492668"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6812ca1cc8c0dadb87f3866fab217ebe831a1fe1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6812ca1cc8c0dadb87f3866fab217ebe831a1fe1", "html_url": "https://github.com/rust-lang/rust/commit/6812ca1cc8c0dadb87f3866fab217ebe831a1fe1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6812ca1cc8c0dadb87f3866fab217ebe831a1fe1/comments", "author": {"login": "pelmers", "id": 2406051, "node_id": "MDQ6VXNlcjI0MDYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2406051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pelmers", "html_url": "https://github.com/pelmers", "followers_url": "https://api.github.com/users/pelmers/followers", "following_url": "https://api.github.com/users/pelmers/following{/other_user}", "gists_url": "https://api.github.com/users/pelmers/gists{/gist_id}", "starred_url": "https://api.github.com/users/pelmers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pelmers/subscriptions", "organizations_url": "https://api.github.com/users/pelmers/orgs", "repos_url": "https://api.github.com/users/pelmers/repos", "events_url": "https://api.github.com/users/pelmers/events{/privacy}", "received_events_url": "https://api.github.com/users/pelmers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pelmers", "id": 2406051, "node_id": "MDQ6VXNlcjI0MDYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2406051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pelmers", "html_url": "https://github.com/pelmers", "followers_url": "https://api.github.com/users/pelmers/followers", "following_url": "https://api.github.com/users/pelmers/following{/other_user}", "gists_url": "https://api.github.com/users/pelmers/gists{/gist_id}", "starred_url": "https://api.github.com/users/pelmers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pelmers/subscriptions", "organizations_url": "https://api.github.com/users/pelmers/orgs", "repos_url": "https://api.github.com/users/pelmers/repos", "events_url": "https://api.github.com/users/pelmers/events{/privacy}", "received_events_url": "https://api.github.com/users/pelmers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48e9ef640480a5371759d011da7acbe2fa182511", "url": "https://api.github.com/repos/rust-lang/rust/commits/48e9ef640480a5371759d011da7acbe2fa182511", "html_url": "https://github.com/rust-lang/rust/commit/48e9ef640480a5371759d011da7acbe2fa182511"}], "stats": {"total": 127, "additions": 72, "deletions": 55}, "files": [{"sha": "d5fa93ac0f4426bcd7da67a0301d88dff4100ac2", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 49, "deletions": 54, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/6812ca1cc8c0dadb87f3866fab217ebe831a1fe1/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6812ca1cc8c0dadb87f3866fab217ebe831a1fe1/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=6812ca1cc8c0dadb87f3866fab217ebe831a1fe1", "patch": "@@ -604,65 +604,60 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     item: &ast::Item,\n                     enum_definition: &ast::EnumDef,\n                     ty_params: &ast::Generics) {\n-        let enum_name = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-        let val = self.span.snippet(item.span);\n-        match self.span.sub_span_after_keyword(item.span, keywords::Enum) {\n-            Some(sub_span) => self.fmt.enum_str(item.span,\n-                                                Some(sub_span),\n-                                                item.id,\n-                                                &enum_name[..],\n-                                                self.cur_scope,\n-                                                &val[..]),\n-            None => self.sess.span_bug(item.span,\n-                                       &format!(\"Could not find subspan for enum {}\",\n-                                               enum_name)),\n-        }\n-        for variant in &enum_definition.variants {\n-            let name = get_ident(variant.node.name);\n-            let name = &name;\n-            let mut qualname = enum_name.clone();\n-            qualname.push_str(\"::\");\n-            qualname.push_str(name);\n-            let val = self.span.snippet(variant.span);\n-            match variant.node.kind {\n-                ast::TupleVariantKind(ref args) => {\n-                    // first ident in span is the variant's name\n-                    self.fmt.tuple_variant_str(variant.span,\n-                                               self.span.span_for_first_ident(variant.span),\n-                                               variant.node.id,\n-                                               name,\n-                                               &qualname[..],\n-                                               &enum_name[..],\n-                                               &val[..],\n-                                               item.id);\n-                    for arg in args {\n-                        self.visit_ty(&*arg.ty);\n+        let enum_data = self.save_ctxt.get_item_data(item);\n+        if let super::Data::EnumData(enum_data) = enum_data {\n+            self.fmt.enum_str(item.span,\n+                              Some(enum_data.span),\n+                              enum_data.id,\n+                              &enum_data.qualname,\n+                              self.cur_scope,\n+                              &enum_data.value);\n+            for variant in &enum_definition.variants {\n+                let name = &get_ident(variant.node.name);\n+                let mut qualname = enum_data.qualname.clone();\n+                qualname.push_str(\"::\");\n+                qualname.push_str(name);\n+                let val = self.span.snippet(variant.span);\n+                match variant.node.kind {\n+                    ast::TupleVariantKind(ref args) => {\n+                        // first ident in span is the variant's name\n+                        self.fmt.tuple_variant_str(variant.span,\n+                                                   self.span.span_for_first_ident(variant.span),\n+                                                   variant.node.id,\n+                                                   name,\n+                                                   &qualname,\n+                                                   &enum_data.qualname,\n+                                                   &val,\n+                                                   item.id);\n+                        for arg in args {\n+                            self.visit_ty(&*arg.ty);\n+                        }\n                     }\n-                }\n-                ast::StructVariantKind(ref struct_def) => {\n-                    let ctor_id = match struct_def.ctor_id {\n-                        Some(node_id) => node_id,\n-                        None => -1,\n-                    };\n-                    self.fmt.struct_variant_str(\n-                        variant.span,\n-                        self.span.span_for_first_ident(variant.span),\n-                        variant.node.id,\n-                        ctor_id,\n-                        &qualname[..],\n-                        &enum_name[..],\n-                        &val[..],\n-                        item.id);\n-\n-                    for field in &struct_def.fields {\n-                        self.process_struct_field_def(field, &qualname, variant.node.id);\n-                        self.visit_ty(&*field.node.ty);\n+                    ast::StructVariantKind(ref struct_def) => {\n+                        let ctor_id = match struct_def.ctor_id {\n+                            Some(node_id) => node_id,\n+                            None => -1,\n+                        };\n+                        self.fmt.struct_variant_str(variant.span,\n+                                                    self.span.span_for_first_ident(variant.span),\n+                                                    variant.node.id,\n+                                                    ctor_id,\n+                                                    &qualname,\n+                                                    &enum_data.qualname,\n+                                                    &val,\n+                                                    item.id);\n+\n+                        for field in &struct_def.fields {\n+                            self.process_struct_field_def(field, &qualname, variant.node.id);\n+                            self.visit_ty(&*field.node.ty);\n+                        }\n                     }\n                 }\n             }\n+            self.process_generic_params(ty_params, item.span, &enum_data.qualname, item.id);\n+        } else {\n+            self.sess.span_bug(item.span, \"expected EnumData\");\n         }\n-\n-        self.process_generic_params(ty_params, item.span, &enum_name[..], item.id);\n     }\n \n     fn process_impl(&mut self,"}, {"sha": "8e0f1d3a4288ae560081e2cf18c4bc50fc826b84", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6812ca1cc8c0dadb87f3866fab217ebe831a1fe1/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6812ca1cc8c0dadb87f3866fab217ebe831a1fe1/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=6812ca1cc8c0dadb87f3866fab217ebe831a1fe1", "patch": "@@ -51,6 +51,8 @@ pub enum Data {\n     VariableData(VariableData),\n     /// Data for modules.\n     ModData(ModData),\n+    /// Data for Enums.\n+    EnumData(EnumData),\n \n     /// Data for the use of some variable (e.g., the use of a local variable, which\n     /// will refere to that variables declaration).\n@@ -88,6 +90,14 @@ pub struct ModData {\n     pub filename: String,\n }\n \n+/// Data for enum declarations.\n+pub struct EnumData {\n+    pub id: NodeId,\n+    pub value: String,\n+    pub qualname: String,\n+    pub span: Span,\n+}\n+\n /// Data for the use of some item (e.g., the use of a local variable, which\n /// will refere to that variables declaration (by ref_id)).\n pub struct VariableRefData {\n@@ -188,7 +198,19 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     scope: self.analysis.ty_cx.map.get_parent(item.id),\n                     filename: filename,\n                 })\n-            }\n+            },\n+            ast::ItemEnum(..) => {\n+                let enum_name = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+                let val = self.span_utils.snippet(item.span);\n+                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Enum);\n+\n+                Data::EnumData(EnumData {\n+                    id: item.id,\n+                    value: val,\n+                    span: sub_span.unwrap(),\n+                    qualname: enum_name,\n+                })\n+            },\n             _ => {\n                 // FIXME\n                 unimplemented!();"}]}