{"sha": "ed589761e62735ebb803510e01bfd8b278527fb9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNTg5NzYxZTYyNzM1ZWJiODAzNTEwZTAxYmZkOGIyNzg1MjdmYjk=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-11-06T07:35:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-11-06T07:35:52Z"}, "message": "Merge pull request #2202 from topecongiro/format\n\nRun `cargo fmt`", "tree": {"sha": "34ce4c2b9390076536746f9323981bca96e2ddee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34ce4c2b9390076536746f9323981bca96e2ddee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed589761e62735ebb803510e01bfd8b278527fb9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaABDYCRBK7hj4Ov3rIwAAdHIIAFbPzqfdbuirIjdNPkTaB3dZ\nP0v+diNvJ8u5lkVLIE1UnlgFtjipntkHgZNDu/Ec2rAZ8A7Htl7+kO8C/BCeXQsK\nin1sNg6PtkIDzGRfYW9tqx5LZLKPQs8UOi5/YJRvFyMH4BHtBoLkwiihyoSOcbX8\nWDgn1ZzEOH04FvKYN+crfZcLggfl4iAHyy7I7ht2UnNRk48bo670JPt5V1iUb4q2\nAELzlLLIxM6CkxoaVeRGexhWIqSJltGGaPCcAs8zTAu6CsIFOY1pSQW+umxZIcsN\ncuyXk95UFS0WNioGiISYJUv/ySpAa7op7aOAX4/jr49i0wH3B8bsSH6ENnBKaM8=\n=5Lfp\n-----END PGP SIGNATURE-----\n", "payload": "tree 34ce4c2b9390076536746f9323981bca96e2ddee\nparent fdeaf8002e6def4083b5a120eb235868410d14f4\nparent a6c71e9c0ddceeb3711e1b147103e2ba0a68b551\nauthor Oliver Schneider <oli-obk@users.noreply.github.com> 1509953752 +0100\ncommitter GitHub <noreply@github.com> 1509953752 +0100\n\nMerge pull request #2202 from topecongiro/format\n\nRun `cargo fmt`"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed589761e62735ebb803510e01bfd8b278527fb9", "html_url": "https://github.com/rust-lang/rust/commit/ed589761e62735ebb803510e01bfd8b278527fb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed589761e62735ebb803510e01bfd8b278527fb9/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdeaf8002e6def4083b5a120eb235868410d14f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdeaf8002e6def4083b5a120eb235868410d14f4", "html_url": "https://github.com/rust-lang/rust/commit/fdeaf8002e6def4083b5a120eb235868410d14f4"}, {"sha": "a6c71e9c0ddceeb3711e1b147103e2ba0a68b551", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6c71e9c0ddceeb3711e1b147103e2ba0a68b551", "html_url": "https://github.com/rust-lang/rust/commit/a6c71e9c0ddceeb3711e1b147103e2ba0a68b551"}], "stats": {"total": 1417, "additions": 804, "deletions": 613}, "files": [{"sha": "8949e4cc3879693a2f7eda072ffad16fd9996470", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -120,13 +120,19 @@ fn to_const_range(\n     array_size: ConstInt,\n ) -> Option<(ConstInt, ConstInt)> {\n     let start = match *start {\n-        Some(Some(&ty::Const { val: ConstVal::Integral(x), .. })) => x,\n+        Some(Some(&ty::Const {\n+            val: ConstVal::Integral(x),\n+            ..\n+        })) => x,\n         Some(_) => return None,\n         None => ConstInt::U8(0),\n     };\n \n     let end = match *end {\n-        Some(Some(&ty::Const { val: ConstVal::Integral(x), .. })) => if limits == RangeLimits::Closed {\n+        Some(Some(&ty::Const {\n+            val: ConstVal::Integral(x),\n+            ..\n+        })) => if limits == RangeLimits::Closed {\n             match x {\n                 ConstInt::U8(_) => (x + ConstInt::U8(1)),\n                 ConstInt::U16(_) => (x + ConstInt::U16(1)),"}, {"sha": "790c2884273e9a71f2d07b3c7d6904231c33c27c", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -143,7 +143,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                         if_chain! {\n                                             if parent_impl != ast::CRATE_NODE_ID;\n                                             if let hir::map::Node::NodeItem(item) = cx.tcx.hir.get(parent_impl);\n-                                            if let hir::Item_::ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) = item.node;\n+                                            if let hir::Item_::ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) =\n+                                                item.node;\n                                             if trait_ref.path.def.def_id() == trait_id;\n                                             then { return; }\n                                         }"}, {"sha": "da7fff2ed93a999a05985bad7f29ce1cfce4079e", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::{self, TyCtxt};\n use semver::Version;\n use syntax::ast::{Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use syntax::codemap::Span;\n-use utils::{in_macro, match_def_path, paths, snippet_opt, span_lint, span_lint_and_then, opt_def_id};\n+use utils::{in_macro, match_def_path, opt_def_id, paths, snippet_opt, span_lint, span_lint_and_then};\n \n /// **What it does:** Checks for items annotated with `#[inline(always)]`,\n /// unless the annotated function is empty or simply panics."}, {"sha": "a89959d95068529dd2ac66311195402b8cc192fb", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n \n const BRACED_EXPR_MESSAGE: &str = \"omit braces around single expression condition\";\n const COMPLEX_BLOCK_MESSAGE: &str = \"in an 'if' condition, avoid complex blocks or closures with blocks; \\\n-                                             instead, move the block or closure higher and bind it with a 'let'\";\n+                                     instead, move the block or closure higher and bind it with a 'let'\";\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n@@ -92,9 +92,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n                                 BLOCK_IN_IF_CONDITION_EXPR,\n                                 check.span,\n                                 BRACED_EXPR_MESSAGE,\n-                                &format!(\"try\\nif {} {} ... \",\n-                                snippet_block(cx, ex.span, \"..\"),\n-                                snippet_block(cx, then.span, \"..\")),\n+                                &format!(\n+                                    \"try\\nif {} {} ... \",\n+                                    snippet_block(cx, ex.span, \"..\"),\n+                                    snippet_block(cx, then.span, \"..\")\n+                                ),\n                             );\n                         }\n                     } else {\n@@ -111,9 +113,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n                             BLOCK_IN_IF_CONDITION_STMT,\n                             check.span,\n                             COMPLEX_BLOCK_MESSAGE,\n-                            &format!(\"try\\nlet res = {};\\nif res {} ... \",\n-                            snippet_block(cx, block.span, \"..\"),\n-                            snippet_block(cx, then.span, \"..\")),\n+                            &format!(\n+                                \"try\\nlet res = {};\\nif res {} ... \",\n+                                snippet_block(cx, block.span, \"..\"),\n+                                snippet_block(cx, then.span, \"..\")\n+                            ),\n                         );\n                     }\n                 }"}, {"sha": "ca3fb4017dfa594491dce2eb1c83a88ff2522ae6", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -368,9 +368,9 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                     }\n                     // if the number of occurrences of a terminal decreases or any of the stats\n                     // decreases while none increases\n-                    improvement |= (stats.terminals[i] > simplified_stats.terminals[i]) ||\n-                        (stats.negations > simplified_stats.negations && stats.ops == simplified_stats.ops) ||\n-                        (stats.ops > simplified_stats.ops && stats.negations == simplified_stats.negations);\n+                    improvement |= (stats.terminals[i] > simplified_stats.terminals[i])\n+                        || (stats.negations > simplified_stats.negations && stats.ops == simplified_stats.ops)\n+                        || (stats.ops > simplified_stats.ops && stats.negations == simplified_stats.negations);\n                 }\n                 if improvement {\n                     improvements.push(suggestion);"}, {"sha": "886834e398109b762af288444642c55753c1be00", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -2,8 +2,8 @@ use rustc::hir::*;\n use rustc::lint::*;\n use rustc::ty;\n use syntax::ast::{Name, UintTy};\n-use utils::{contains_name, get_pat_name, match_type, paths, single_segment_path,\n-            snippet, span_lint_and_sugg, walk_ptrs_ty};\n+use utils::{contains_name, get_pat_name, match_type, paths, single_segment_path, snippet, span_lint_and_sugg,\n+            walk_ptrs_ty};\n \n /// **What it does:** Checks for naive byte counts\n ///"}, {"sha": "6ee4dad7db40cd505ea2c58cdd9f7e3d5a204e37", "filename": "clippy_lints/src/const_static_lifetime.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -1,6 +1,6 @@\n-use syntax::ast::{Item, ItemKind, TyKind, Ty};\n-use rustc::lint::{LintPass, EarlyLintPass, LintArray, EarlyContext};\n-use utils::{span_lint_and_then, in_macro};\n+use syntax::ast::{Item, ItemKind, Ty, TyKind};\n+use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n+use utils::{in_macro, span_lint_and_then};\n \n /// **What it does:** Checks for constants with an explicit `'static` lifetime.\n ///\n@@ -20,7 +20,7 @@ use utils::{span_lint_and_then, in_macro};\n /// ```\n \n declare_lint! {\n-    pub CONST_STATIC_LIFETIME, \n+    pub CONST_STATIC_LIFETIME,\n     Warn,\n     \"Using explicit `'static` lifetime for constants when elision rules would allow omitting them.\"\n }\n@@ -41,10 +41,8 @@ impl StaticConst {\n             TyKind::Array(ref ty, _) => {\n                 self.visit_type(&*ty, cx);\n             },\n-            TyKind::Tup(ref tup) => {\n-                for tup_ty in tup {\n-                    self.visit_type(&*tup_ty, cx);\n-                }\n+            TyKind::Tup(ref tup) => for tup_ty in tup {\n+                self.visit_type(&*tup_ty, cx);\n             },\n             // This is what we are looking for !\n             TyKind::Rptr(ref optional_lifetime, ref borrow_type) => {\n@@ -54,11 +52,15 @@ impl StaticConst {\n                         // Verify that the path is a str\n                         if lifetime.ident.name == \"'static\" {\n                             let mut sug: String = String::new();\n-                            span_lint_and_then(cx,\n-                                               CONST_STATIC_LIFETIME,\n-                                               lifetime.span,\n-                                               \"Constants have by default a `'static` lifetime\",\n-                                               |db| {db.span_suggestion(lifetime.span,\"consider removing `'static`\",sug);});\n+                            span_lint_and_then(\n+                                cx,\n+                                CONST_STATIC_LIFETIME,\n+                                lifetime.span,\n+                                \"Constants have by default a `'static` lifetime\",\n+                                |db| {\n+                                    db.span_suggestion(lifetime.span, \"consider removing `'static`\", sug);\n+                                },\n+                            );\n                         }\n                     }\n                 }"}, {"sha": "6ce67a9b05c662f8c2ca56d4709e41c6302586b8", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -98,13 +98,13 @@ fn check_hash_peq<'a, 'tcx>(\n             // Look for the PartialEq implementations for `ty`\n             cx.tcx.for_each_relevant_impl(peq_trait_def_id, ty, |impl_id| {\n                 let peq_is_automatically_derived = is_automatically_derived(&cx.tcx.get_attrs(impl_id));\n-    \n+\n                 if peq_is_automatically_derived == hash_is_automatically_derived {\n                     return;\n                 }\n-    \n+\n                 let trait_ref = cx.tcx.impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n-    \n+\n                 // Only care about `impl PartialEq<Foo> for Foo`\n                 // For `impl PartialEq<B> for A, input_types is [A, B]\n                 if trait_ref.substs.type_at(1) == ty {\n@@ -113,7 +113,7 @@ fn check_hash_peq<'a, 'tcx>(\n                     } else {\n                         \"you are deriving `Hash` but have implemented `PartialEq` explicitly\"\n                     };\n-    \n+\n                     span_lint_and_then(\n                         cx, DERIVE_HASH_XOR_EQ, span,\n                         mess,\n@@ -157,7 +157,9 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref\n             EXPL_IMPL_CLONE_ON_COPY,\n             item.span,\n             \"you are implementing `Clone` explicitly on a `Copy` type\",\n-            |db| { db.span_note(item.span, \"consider deriving `Clone` or removing `Copy`\"); },\n+            |db| {\n+                db.span_note(item.span, \"consider deriving `Clone` or removing `Copy`\");\n+            },\n         );\n     }\n }"}, {"sha": "b6542b2ebca6ab040b8a6eac6f5c8b89b24e1e8c", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -204,7 +204,7 @@ fn check_doc<'a, Events: Iterator<Item = (usize, pulldown_cmark::Event<'a>)>>(\n             End(CodeBlock(_)) | End(Code) => in_code = false,\n             Start(Link(link, _)) => in_link = Some(link),\n             End(Link(_, _)) => in_link = None,\n-            Start(_tag) | End(_tag) => (), // We don't care about other tags\n+            Start(_tag) | End(_tag) => (),         // We don't care about other tags\n             Html(_html) | InlineHtml(_html) => (), // HTML is weird, just ignore it\n             SoftBreak => (),\n             HardBreak => (),\n@@ -273,8 +273,8 @@ fn check_word(cx: &EarlyContext, word: &str, span: Span) {\n             s\n         };\n \n-        s.chars().all(char::is_alphanumeric) && s.chars().filter(|&c| c.is_uppercase()).take(2).count() > 1 &&\n-            s.chars().filter(|&c| c.is_lowercase()).take(1).count() > 0\n+        s.chars().all(char::is_alphanumeric) && s.chars().filter(|&c| c.is_uppercase()).take(2).count() > 1\n+            && s.chars().filter(|&c| c.is_lowercase()).take(1).count() > 0\n     }\n \n     fn has_underscore(s: &str) -> bool {\n@@ -284,10 +284,12 @@ fn check_word(cx: &EarlyContext, word: &str, span: Span) {\n     if let Ok(url) = Url::parse(word) {\n         // try to get around the fact that `foo::bar` parses as a valid URL\n         if !url.cannot_be_a_base() {\n-            span_lint(cx,\n-                      DOC_MARKDOWN,\n-                      span,\n-                      \"you should put bare URLs between `<`/`>` or make a proper Markdown link\");\n+            span_lint(\n+                cx,\n+                DOC_MARKDOWN,\n+                span,\n+                \"you should put bare URLs between `<`/`>` or make a proper Markdown link\",\n+            );\n \n             return;\n         }"}, {"sha": "c523c569a68d6dc58505a6123a3cfd44d9655c89", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use rustc::ty;\n use rustc::hir::*;\n-use utils::{is_copy, match_def_path, paths, span_note_and_lint, opt_def_id};\n+use utils::{is_copy, match_def_path, opt_def_id, paths, span_note_and_lint};\n \n /// **What it does:** Checks for calls to `std::mem::drop` with a reference\n /// instead of an owned value.\n@@ -125,7 +125,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 let msg;\n                 let arg = &args[0];\n                 let arg_ty = cx.tables.expr_ty(arg);\n-    \n+\n                 if let ty::TyRef(..) = arg_ty.sty {\n                     if match_def_path(cx.tcx, def_id, &paths::DROP) {\n                         lint = DROP_REF;"}, {"sha": "b86a4a43fb1e7cacf18f9115eb401c57f5973fc2", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -95,7 +95,7 @@ fn check_cond<'a, 'tcx, 'b>(\n         then {\n             let map = &params[0];\n             let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(map));\n-    \n+\n             return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n                 Some((\"BTreeMap\", map, key))\n             }\n@@ -136,14 +136,14 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n                                            snippet(self.cx, self.map.span, \"map\"),\n                                            snippet(self.cx, params[1].span, \"..\"),\n                                            snippet(self.cx, params[2].span, \"..\"));\n-    \n+\n                         db.span_suggestion(self.span, \"consider using\", help);\n                     }\n                     else {\n                         let help = format!(\"{}.entry({})\",\n                                            snippet(self.cx, self.map.span, \"map\"),\n                                            snippet(self.cx, params[1].span, \"..\"));\n-    \n+\n                         db.span_suggestion(self.span, \"consider using\", help);\n                     }\n                 });"}, {"sha": "c65cf92590a6fb32604907981d577ade122bf005", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -55,8 +55,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                         .at(expr.span)\n                         .const_eval(param_env.and((did, substs)))\n                     {\n-                        Ok(&ty::Const { val: ConstVal::Integral(Usize(Us64(i))), .. }) => u64::from(i as u32) != i,\n-                        Ok(&ty::Const { val: ConstVal::Integral(Isize(Is64(i))), .. }) => i64::from(i as i32) != i,\n+                        Ok(&ty::Const {\n+                            val: ConstVal::Integral(Usize(Us64(i))),\n+                            ..\n+                        }) => u64::from(i as u32) != i,\n+                        Ok(&ty::Const {\n+                            val: ConstVal::Integral(Isize(Is64(i))),\n+                            ..\n+                        }) => i64::from(i as i32) != i,\n                         _ => false,\n                     };\n                     if bad {"}, {"sha": "ea7a378de222c71253507f92ccc99058130effe1", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -159,8 +159,11 @@ fn check_variant(\n     }\n     for var in &def.variants {\n         let name = var2str(var);\n-        if partial_match(item_name, &name) == item_name_chars &&\n-           name.chars().nth(item_name_chars).map_or(false, |c| !c.is_lowercase()) {\n+        if partial_match(item_name, &name) == item_name_chars\n+            && name.chars()\n+                .nth(item_name_chars)\n+                .map_or(false, |c| !c.is_lowercase())\n+        {\n             span_lint(cx, lint, var.span, \"Variant name starts with the enum's name\");\n         }\n         if partial_rmatch(item_name, &name) == item_name_chars {"}, {"sha": "0c91d0cd97c92b104146b15a6c28f18414f88995", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc::hir;\n use rustc::ty;\n use syntax_pos::Span;\n-use utils::{method_chain_args, match_def_path, span_lint_and_then, walk_ptrs_ty};\n+use utils::{match_def_path, method_chain_args, span_lint_and_then, walk_ptrs_ty};\n use utils::paths::{BEGIN_PANIC, BEGIN_PANIC_FMT, FROM_TRAIT, OPTION, RESULT};\n \n /// **What it does:** Checks for impls of `From<..>` that contain `panic!()` or `unwrap()`\n@@ -74,9 +74,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n             // check for `unwrap`\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n                 let reciever_ty = walk_ptrs_ty(self.tables.expr_ty(&arglists[0][0]));\n-                if match_type(self.tcx, reciever_ty, &OPTION) ||\n-                    match_type(self.tcx, reciever_ty, &RESULT)\n-                {\n+                if match_type(self.tcx, reciever_ty, &OPTION) || match_type(self.tcx, reciever_ty, &RESULT) {\n                     self.result.push(expr.span);\n                 }\n             }\n@@ -105,7 +103,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n                     result: Vec::new(),\n                 };\n                 fpu.visit_expr(&body.value);\n-    \n+\n                 // if we've found one, lint\n                 if !fpu.result.is_empty() {\n                     span_lint_and_then("}, {"sha": "dcafbc50d0ca5e6880747eb311ca94d371c96ca3", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -3,7 +3,7 @@ use rustc::lint::*;\n use rustc::ty;\n use syntax::ast::LitKind;\n use utils::paths;\n-use utils::{is_expn_of, match_def_path, match_type, resolve_node, span_lint, walk_ptrs_ty, opt_def_id};\n+use utils::{is_expn_of, match_def_path, match_type, opt_def_id, resolve_node, span_lint, walk_ptrs_ty};\n \n /// **What it does:** Checks for the use of `format!(\"string literal with no\n /// argument\")` and `format!(\"{}\", foo)` where `foo` is a string.\n@@ -109,7 +109,7 @@ fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n         if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n         then {\n             let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n-    \n+\n             return ty.sty == ty::TyStr || match_type(cx, ty, &paths::STRING);\n         }\n     }"}, {"sha": "e016fa3d595a755814b2b807ccfab1ef8508b4cc", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -190,8 +190,8 @@ fn check_array(cx: &EarlyContext, expr: &ast::Expr) {\n \n /// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for consecutive ifs.\n fn check_consecutive_ifs(cx: &EarlyContext, first: &ast::Expr, second: &ast::Expr) {\n-    if !differing_macro_contexts(first.span, second.span) && !in_macro(first.span) && unsugar_if(first).is_some() &&\n-        unsugar_if(second).is_some()\n+    if !differing_macro_contexts(first.span, second.span) && !in_macro(first.span) && unsugar_if(first).is_some()\n+        && unsugar_if(second).is_some()\n     {\n         // where the else would be\n         let else_span = first.span.between(second.span);"}, {"sha": "e1d84a0743984ed9654b1c70a5d67fb2edf86bf4", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -70,7 +70,7 @@ fn all_ones(v: &ConstInt) -> bool {\n         ConstInt::U32(i) => i == !0,\n         ConstInt::U64(i) => i == !0,\n         ConstInt::U128(i) => i == !0,\n-        _ => false\n+        _ => false,\n     }\n }\n "}, {"sha": "d7d98351647c0e3232ef01e11a7a27f8f7433276", "filename": "clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_not_else.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -4,7 +4,7 @@\n use rustc::lint::*;\n use syntax::ast::*;\n \n-use utils::{span_help_and_lint, in_external_macro};\n+use utils::{in_external_macro, span_help_and_lint};\n \n /// **What it does:** Checks for usage of `!` or `!=` in an if condition with an\n /// else branch."}, {"sha": "6e74547b75f8346fe00d12008d1e653e6d9c539b", "filename": "clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 49, "deletions": 26, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fint_plus_one.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -3,7 +3,7 @@\n use rustc::lint::*;\n use syntax::ast::*;\n \n-use utils::{span_lint_and_then, snippet_opt};\n+use utils::{snippet_opt, span_lint_and_then};\n \n /// **What it does:** Checks for usage of `x >= y + 1` or `x - 1 >= y` (and `<=`) in a block\n ///\n@@ -55,7 +55,7 @@ impl IntPlusOne {\n     #[allow(cast_sign_loss)]\n     fn check_lit(&self, lit: &Lit, target_value: i128) -> bool {\n         if let LitKind::Int(value, ..) = lit.node {\n-            return value == (target_value as u128)\n+            return value == (target_value as u128);\n         }\n         false\n     }\n@@ -66,49 +66,76 @@ impl IntPlusOne {\n             (BinOpKind::Ge, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _) => {\n                 match (lhskind.node, &lhslhs.node, &lhsrhs.node) {\n                     // `-1 + x`\n-                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if self.check_lit(lit, -1) => self.generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS),\n+                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if self.check_lit(lit, -1) => {\n+                        self.generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS)\n+                    },\n                     // `x - 1`\n-                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => self.generate_recommendation(cx, binop, lhslhs, rhs, Side::LHS),\n-                    _ => None\n+                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => {\n+                        self.generate_recommendation(cx, binop, lhslhs, rhs, Side::LHS)\n+                    },\n+                    _ => None,\n                 }\n             },\n             // case where `... >= y + 1` or `... >= 1 + y`\n-            (BinOpKind::Ge, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs)) if rhskind.node == BinOpKind::Add => {\n+            (BinOpKind::Ge, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs))\n+                if rhskind.node == BinOpKind::Add =>\n+            {\n                 match (&rhslhs.node, &rhsrhs.node) {\n                     // `y + 1` and `1 + y`\n-                    (&ExprKind::Lit(ref lit), _) if self.check_lit(lit, 1) => self.generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS),\n-                    (_, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => self.generate_recommendation(cx, binop, rhslhs, lhs, Side::RHS),\n-                    _ => None\n+                    (&ExprKind::Lit(ref lit), _) if self.check_lit(lit, 1) => {\n+                        self.generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS)\n+                    },\n+                    (_, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => {\n+                        self.generate_recommendation(cx, binop, rhslhs, lhs, Side::RHS)\n+                    },\n+                    _ => None,\n                 }\n-            },\n+            }\n             // case where `x + 1 <= ...` or `1 + x <= ...`\n-            (BinOpKind::Le, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _) if lhskind.node == BinOpKind::Add => {\n+            (BinOpKind::Le, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _)\n+                if lhskind.node == BinOpKind::Add =>\n+            {\n                 match (&lhslhs.node, &lhsrhs.node) {\n                     // `1 + x` and `x + 1`\n-                    (&ExprKind::Lit(ref lit), _) if self.check_lit(lit, 1) => self.generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS),\n-                    (_, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => self.generate_recommendation(cx, binop, lhslhs, rhs, Side::LHS),\n-                    _ => None\n+                    (&ExprKind::Lit(ref lit), _) if self.check_lit(lit, 1) => {\n+                        self.generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS)\n+                    },\n+                    (_, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => {\n+                        self.generate_recommendation(cx, binop, lhslhs, rhs, Side::LHS)\n+                    },\n+                    _ => None,\n                 }\n-            },\n+            }\n             // case where `... >= y - 1` or `... >= -1 + y`\n             (BinOpKind::Le, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs)) => {\n                 match (rhskind.node, &rhslhs.node, &rhsrhs.node) {\n                     // `-1 + y`\n-                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if self.check_lit(lit, -1) => self.generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS),\n+                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if self.check_lit(lit, -1) => {\n+                        self.generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS)\n+                    },\n                     // `y - 1`\n-                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => self.generate_recommendation(cx, binop, rhslhs, lhs, Side::RHS),\n-                    _ => None\n+                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => {\n+                        self.generate_recommendation(cx, binop, rhslhs, lhs, Side::RHS)\n+                    },\n+                    _ => None,\n                 }\n             },\n-            _ => None\n+            _ => None,\n         }\n     }\n \n-    fn generate_recommendation(&self, cx: &EarlyContext, binop: BinOpKind, node: &Expr, other_side: &Expr, side: Side) -> Option<String> {\n+    fn generate_recommendation(\n+        &self,\n+        cx: &EarlyContext,\n+        binop: BinOpKind,\n+        node: &Expr,\n+        other_side: &Expr,\n+        side: Side,\n+    ) -> Option<String> {\n         let binop_string = match binop {\n             BinOpKind::Ge => \">\",\n             BinOpKind::Le => \"<\",\n-            _ => return None\n+            _ => return None,\n         };\n         if let Some(snippet) = snippet_opt(cx, node.span) {\n             if let Some(other_side_snippet) = snippet_opt(cx, other_side.span) {\n@@ -123,11 +150,7 @@ impl IntPlusOne {\n     }\n \n     fn emit_warning(&self, cx: &EarlyContext, block: &Expr, recommendation: String) {\n-        span_lint_and_then(cx,\n-                           INT_PLUS_ONE,\n-                           block.span,\n-                           \"Unnecessary `>= y + 1` or `x - 1 >=`\",\n-                           |db| {\n+        span_lint_and_then(cx, INT_PLUS_ONE, block.span, \"Unnecessary `>= y + 1` or `x - 1 >=`\", |db| {\n             db.span_suggestion(block.span, \"change `>= y + 1` to `> y` as shown\", recommendation);\n         });\n     }"}, {"sha": "90eb92b8ca453bc070d23392a8353bc7eee455e5", "filename": "clippy_lints/src/invalid_ref.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Finvalid_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Finvalid_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_ref.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -1,13 +1,13 @@\n use rustc::lint::*;\n use rustc::ty;\n use rustc::hir::*;\n-use utils::{match_def_path, paths, span_help_and_lint, opt_def_id};\n+use utils::{match_def_path, opt_def_id, paths, span_help_and_lint};\n \n /// **What it does:** Checks for creation of references to zeroed or uninitialized memory.\n ///\n /// **Why is this bad?** Creation of null references is undefined behavior.\n ///\n-/// **Known problems:** None. \n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n@@ -22,9 +22,10 @@ declare_lint! {\n \n const ZERO_REF_SUMMARY: &str = \"reference to zeroed memory\";\n const UNINIT_REF_SUMMARY: &str = \"reference to uninitialized memory\";\n-const HELP: &str = \"Creation of a null reference is undefined behavior; see https://doc.rust-lang.org/reference/behavior-considered-undefined.html\"; \n+const HELP: &str = \"Creation of a null reference is undefined behavior; \\\n+                    see https://doc.rust-lang.org/reference/behavior-considered-undefined.html\";\n \n-pub struct InvalidRef; \n+pub struct InvalidRef;\n \n impl LintPass for InvalidRef {\n     fn get_lints(&self) -> LintArray {\n@@ -38,19 +39,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidRef {\n             if let ExprCall(ref path, ref args) = expr.node;\n             if let ExprPath(ref qpath) = path.node;\n             if args.len() == 0;\n-            if let ty::TyRef(..) = cx.tables.expr_ty(expr).sty; \n+            if let ty::TyRef(..) = cx.tables.expr_ty(expr).sty;\n             if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n             then {\n-                let msg = if match_def_path(cx.tcx, def_id, &paths::MEM_ZEROED) | match_def_path(cx.tcx, def_id, &paths::INIT) {\n+                let msg = if match_def_path(cx.tcx, def_id, &paths::MEM_ZEROED) |\n+                             match_def_path(cx.tcx, def_id, &paths::INIT)\n+                {\n                     ZERO_REF_SUMMARY\n-                } else if match_def_path(cx.tcx, def_id, &paths::MEM_UNINIT) | match_def_path(cx.tcx, def_id, &paths::UNINIT) {\n+                } else if match_def_path(cx.tcx, def_id, &paths::MEM_UNINIT) |\n+                          match_def_path(cx.tcx, def_id, &paths::UNINIT)\n+                {\n                     UNINIT_REF_SUMMARY\n                 } else {\n                     return;\n                 };\n                 span_help_and_lint(cx, INVALID_REF, expr.span, msg, HELP);\n             }\n-        }        \n+        }\n         return;\n     }\n }"}, {"sha": "3f94178e524c929dfedde56565b9894d658c76d6", "filename": "clippy_lints/src/is_unit_expr.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fis_unit_expr.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -139,13 +139,9 @@ fn check_last_stmt_in_block(block: &Block) -> bool {\n     // like `panic!()`\n     match final_stmt.node {\n         StmtKind::Expr(_) => false,\n-        StmtKind::Semi(ref expr) => {\n-            match expr.node {\n-                ExprKind::Break(_, _) |\n-                ExprKind::Continue(_) |\n-                ExprKind::Ret(_) => false,\n-                _ => true,\n-            }\n+        StmtKind::Semi(ref expr) => match expr.node {\n+            ExprKind::Break(_, _) | ExprKind::Continue(_) | ExprKind::Ret(_) => false,\n+            _ => true,\n         },\n         _ => true,\n     }"}, {"sha": "4499f41fc1dc152c98db1c601d97a048b8ab72a1", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -119,8 +119,8 @@ fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[Trai\n             .iter()\n             .flat_map(|&i| cx.tcx.associated_items(i))\n             .any(|i| {\n-                i.kind == ty::AssociatedKind::Method && i.method_has_self_argument && i.name == \"is_empty\" &&\n-                    cx.tcx.fn_sig(i.def_id).inputs().skip_binder().len() == 1\n+                i.kind == ty::AssociatedKind::Method && i.method_has_self_argument && i.name == \"is_empty\"\n+                    && cx.tcx.fn_sig(i.def_id).inputs().skip_binder().len() == 1\n             });\n \n         if !is_empty_method_found {"}, {"sha": "34863208fde5b5ad0e3c8606e53c507857c86b4d", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -76,7 +76,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n                 if !used_in_expr(cx, canonical_id, value);\n                 then {\n                     let span = stmt.span.to(if_.span);\n-    \n+\n                     let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n                         if let hir::ExprBlock(ref else_) = else_.node {\n                             if let Some(default) = check_assign(cx, canonical_id, else_) {\n@@ -94,15 +94,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n                     } else {\n                         continue;\n                     };\n-    \n+\n                     let mutability = match mode {\n                         BindingAnnotation::RefMut | BindingAnnotation::Mutable => \"<mut> \",\n                         _ => \"\",\n                     };\n-    \n+\n                     // FIXME: this should not suggest `mut` if we can detect that the variable is not\n                     // use mutably after the `if`\n-    \n+\n                     let sug = format!(\n                         \"let {mut}{name} = if {cond} {{{then} {value} }} else {{{else} {default} }};\",\n                         mut=mutability,\n@@ -174,15 +174,15 @@ fn check_assign<'a, 'tcx>(\n                 id: decl,\n                 used: false,\n             };\n-    \n+\n             for s in block.stmts.iter().take(block.stmts.len()-1) {\n                 hir::intravisit::walk_stmt(&mut v, s);\n-    \n+\n                 if v.used {\n                     return None;\n                 }\n             }\n-    \n+\n             return Some(value);\n         }\n     }"}, {"sha": "0f8f461087184cf9172ef1de1479d07d231aa815", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -11,8 +11,7 @@\n #![feature(inclusive_range_syntax, range_contains)]\n #![feature(macro_vis_matcher)]\n #![allow(unknown_lints, indexing_slicing, shadow_reuse, missing_docs_in_private_items)]\n-\n-#![recursion_limit=\"256\"]\n+#![recursion_limit = \"256\"]\n \n #[macro_use]\n extern crate rustc;"}, {"sha": "011b5ec1d5e69358e39d254ad7e7301334e27c23", "filename": "clippy_lints/src/literal_digit_grouping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -270,7 +270,7 @@ impl LiteralDigitGrouping {\n                     .digits\n                     .split_terminator('.')\n                     .collect();\n-    \n+\n                 // Lint integral and fractional parts separately, and then check consistency of digit\n                 // groups if both pass.\n                 let _ = Self::do_lint(parts[0])"}, {"sha": "2d994d468c6dea23b6caf06b20224ca29e83e053", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 142, "deletions": 134, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -16,7 +16,7 @@ use rustc::ty::{self, Ty};\n use rustc::ty::subst::{Subst, Substs};\n use rustc_const_eval::ConstContext;\n use std::collections::{HashMap, HashSet};\n-use std::iter::{Iterator, once};\n+use std::iter::{once, Iterator};\n use syntax::ast;\n use syntax::codemap::Span;\n use utils::sugg;\n@@ -377,8 +377,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n         // check for never_loop\n         match expr.node {\n-            ExprWhile(_, ref block, _) |\n-            ExprLoop(ref block, _, _) => {\n+            ExprWhile(_, ref block, _) | ExprLoop(ref block, _, _) => {\n                 let mut state = NeverLoopState {\n                     breaks: HashSet::new(),\n                     continues: HashSet::new(),\n@@ -413,11 +412,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 if let ExprMatch(ref matchexpr, ref arms, ref source) = inner.node {\n                     // ensure \"if let\" compatible match structure\n                     match *source {\n-                        MatchSource::Normal |\n-                        MatchSource::IfLetDesugar { .. } => {\n-                            if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n-                                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n-                                is_simple_break_expr(&arms[1].body)\n+                        MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n+                            if arms.len() == 2 && arms[0].pats.len() == 1 && arms[0].guard.is_none()\n+                                && arms[1].pats.len() == 1 && arms[1].guard.is_none()\n+                                && is_simple_break_expr(&arms[1].body)\n                             {\n                                 if in_external_macro(cx, expr.span) {\n                                     return;\n@@ -449,15 +447,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n         if let ExprMatch(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n             let pat = &arms[0].pats[0].node;\n-            if let (&PatKind::TupleStruct(ref qpath, ref pat_args, _),\n-                    &ExprMethodCall(ref method_path, _, ref method_args)) = (pat, &match_expr.node)\n+            if let (\n+                &PatKind::TupleStruct(ref qpath, ref pat_args, _),\n+                &ExprMethodCall(ref method_path, _, ref method_args),\n+            ) = (pat, &match_expr.node)\n             {\n                 let iter_expr = &method_args[0];\n                 let lhs_constructor = last_path_segment(qpath);\n-                if method_path.name == \"next\" && match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n-                    lhs_constructor.name == \"Some\" && !is_refutable(cx, &pat_args[0]) &&\n-                    !is_iterator_used_after_while_let(cx, iter_expr) &&\n-                    !is_nested(cx, expr, &method_args[0])\n+                if method_path.name == \"next\" && match_trait_method(cx, match_expr, &paths::ITERATOR)\n+                    && lhs_constructor.name == \"Some\" && !is_refutable(cx, &pat_args[0])\n+                    && !is_iterator_used_after_while_let(cx, iter_expr)\n+                    && !is_nested(cx, expr, &method_args[0])\n                 {\n                     let iterator = snippet(cx, method_args[0].span, \"_\");\n                     let loop_var = snippet(cx, pat_args[0].span, \"_\");\n@@ -505,8 +505,7 @@ fn never_loop_block(block: &Block, state: &mut NeverLoopState) -> bool {\n \n fn stmt_to_expr(stmt: &Stmt) -> Option<&Expr> {\n     match stmt.node {\n-        StmtSemi(ref e, ..) |\n-        StmtExpr(ref e, ..) => Some(e),\n+        StmtSemi(ref e, ..) | StmtExpr(ref e, ..) => Some(e),\n         StmtDecl(ref d, ..) => decl_to_expr(d),\n     }\n }\n@@ -528,9 +527,9 @@ fn never_loop_expr(expr: &Expr, state: &mut NeverLoopState) -> bool {\n         ExprTupField(ref e, _) |\n         ExprAddrOf(_, ref e) |\n         ExprRepeat(ref e, _) => never_loop_expr(e, state),\n-        ExprArray(ref es) |\n-        ExprMethodCall(_, _, ref es) |\n-        ExprTup(ref es) => never_loop_expr_seq(&mut es.iter(), state),\n+        ExprArray(ref es) | ExprMethodCall(_, _, ref es) | ExprTup(ref es) => {\n+            never_loop_expr_seq(&mut es.iter(), state)\n+        },\n         ExprCall(ref e, ref es) => never_loop_expr_seq(&mut once(&**e).chain(es.iter()), state),\n         ExprBinary(_, ref e1, ref e2) |\n         ExprAssign(ref e1, ref e2) |\n@@ -567,12 +566,16 @@ fn never_loop_expr(expr: &Expr, state: &mut NeverLoopState) -> bool {\n         },\n         ExprBlock(ref b) => never_loop_block(b, state),\n         ExprAgain(d) => {\n-            let id = d.target_id.opt_id().expect(\"target id can only be missing in the presence of compilation errors\");\n+            let id = d.target_id\n+                .opt_id()\n+                .expect(\"target id can only be missing in the presence of compilation errors\");\n             state.continues.insert(id);\n             false\n         },\n         ExprBreak(d, _) => {\n-            let id = d.target_id.opt_id().expect(\"target id can only be missing in the presence of compilation errors\");\n+            let id = d.target_id\n+                .opt_id()\n+                .expect(\"target id can only be missing in the presence of compilation errors\");\n             state.breaks.insert(id);\n             false\n         },\n@@ -586,12 +589,14 @@ fn never_loop_expr(expr: &Expr, state: &mut NeverLoopState) -> bool {\n     }\n }\n \n-fn never_loop_expr_seq<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, state: &mut NeverLoopState) -> bool {\n-    es.map(|e| never_loop_expr(e, state)).fold(true, |a, b| a && b)\n+fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr>>(es: &mut T, state: &mut NeverLoopState) -> bool {\n+    es.map(|e| never_loop_expr(e, state))\n+        .fold(true, |a, b| a && b)\n }\n \n-fn never_loop_expr_branch<'a, T: Iterator<Item=&'a Expr>>(e: &mut T, state: &mut NeverLoopState) -> bool {\n-    e.map(|e| never_loop_expr(e, state)).fold(false, |a, b| a || b)\n+fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr>>(e: &mut T, state: &mut NeverLoopState) -> bool {\n+    e.map(|e| never_loop_expr(e, state))\n+        .fold(false, |a, b| a || b)\n }\n \n fn check_for_loop<'a, 'tcx>(\n@@ -665,11 +670,9 @@ fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty) -> bool {\n fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: ast::NodeId) -> Option<FixedOffsetVar> {\n     fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr, var: ast::NodeId) -> Option<String> {\n         match e.node {\n-            ExprLit(ref l) => {\n-                match l.node {\n-                    ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n-                    _ => None,\n-                }\n+            ExprLit(ref l) => match l.node {\n+                ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n+                _ => None,\n             },\n             ExprPath(..) if !same_var(cx, e, var) => Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into())),\n             _ => None,\n@@ -683,29 +686,25 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var:\n         }\n \n         let offset = match idx.node {\n-            ExprBinary(op, ref lhs, ref rhs) => {\n-                match op.node {\n-                    BinOp_::BiAdd => {\n-                        let offset_opt = if same_var(cx, lhs, var) {\n-                            extract_offset(cx, rhs, var)\n-                        } else if same_var(cx, rhs, var) {\n-                            extract_offset(cx, lhs, var)\n-                        } else {\n-                            None\n-                        };\n+            ExprBinary(op, ref lhs, ref rhs) => match op.node {\n+                BinOp_::BiAdd => {\n+                    let offset_opt = if same_var(cx, lhs, var) {\n+                        extract_offset(cx, rhs, var)\n+                    } else if same_var(cx, rhs, var) {\n+                        extract_offset(cx, lhs, var)\n+                    } else {\n+                        None\n+                    };\n \n-                        offset_opt.map(Offset::positive)\n-                    },\n-                    BinOp_::BiSub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n-                    _ => None,\n-                }\n+                    offset_opt.map(Offset::positive)\n+                },\n+                BinOp_::BiSub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n+                _ => None,\n             },\n-            ExprPath(..) => {\n-                if same_var(cx, idx, var) {\n-                    Some(Offset::positive(\"0\".into()))\n-                } else {\n-                    None\n-                }\n+            ExprPath(..) => if same_var(cx, idx, var) {\n+                Some(Offset::positive(\"0\".into()))\n+            } else {\n+                None\n             },\n             _ => None,\n         };\n@@ -777,12 +776,13 @@ fn get_indexed_assignments<'a, 'tcx>(\n             .iter()\n             .map(|stmt| match stmt.node {\n                 Stmt_::StmtDecl(..) => None,\n-                Stmt_::StmtExpr(ref e, _node_id) |\n-                Stmt_::StmtSemi(ref e, _node_id) => Some(get_assignment(cx, e, var)),\n+                Stmt_::StmtExpr(ref e, _node_id) | Stmt_::StmtSemi(ref e, _node_id) => Some(get_assignment(cx, e, var)),\n             })\n-            .chain(expr.as_ref().into_iter().map(|e| {\n-                Some(get_assignment(cx, &*e, var))\n-            }))\n+            .chain(\n+                expr.as_ref()\n+                    .into_iter()\n+                    .map(|e| Some(get_assignment(cx, &*e, var))),\n+            )\n             .filter_map(|op| op)\n             .collect::<Option<Vec<_>>>()\n             .unwrap_or_else(|| vec![])\n@@ -801,20 +801,18 @@ fn detect_manual_memcpy<'a, 'tcx>(\n     expr: &'tcx Expr,\n ) {\n     if let Some(higher::Range {\n-                    start: Some(start),\n-                    ref end,\n-                    limits,\n-                }) = higher::range(arg)\n+        start: Some(start),\n+        ref end,\n+        limits,\n+    }) = higher::range(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, _, _) = pat.node {\n             let print_sum = |arg1: &Offset, arg2: &Offset| -> String {\n                 match (&arg1.value[..], arg1.negate, &arg2.value[..], arg2.negate) {\n                     (\"0\", _, \"0\", _) => \"\".into(),\n-                    (\"0\", _, x, false) |\n-                    (x, false, \"0\", false) => x.into(),\n-                    (\"0\", _, x, true) |\n-                    (x, false, \"0\", true) => format!(\"-{}\", x),\n+                    (\"0\", _, x, false) | (x, false, \"0\", false) => x.into(),\n+                    (\"0\", _, x, true) | (x, false, \"0\", true) => format!(\"-{}\", x),\n                     (x, false, y, false) => format!(\"({} + {})\", x, y),\n                     (x, false, y, true) => format!(\"({} - {})\", x, y),\n                     (x, true, y, false) => format!(\"({} - {})\", y, x),\n@@ -897,10 +895,10 @@ fn check_for_loop_range<'a, 'tcx>(\n     expr: &'tcx Expr,\n ) {\n     if let Some(higher::Range {\n-                    start: Some(start),\n-                    ref end,\n-                    limits,\n-                }) = higher::range(arg)\n+        start: Some(start),\n+        ref end,\n+        limits,\n+    }) = higher::range(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, ref ident, _) = pat.node {\n@@ -917,9 +915,11 @@ fn check_for_loop_range<'a, 'tcx>(\n             // linting condition: we only indexed one variable, and indexed it directly\n             // (`indexed_directly` is subset of `indexed`)\n             if visitor.indexed.len() == 1 && visitor.indexed_directly.len() == 1 {\n-                let (indexed, indexed_extent) = visitor.indexed_directly.into_iter().next().expect(\n-                    \"already checked that we have exactly 1 element\",\n-                );\n+                let (indexed, indexed_extent) = visitor\n+                    .indexed_directly\n+                    .into_iter()\n+                    .next()\n+                    .expect(\"already checked that we have exactly 1 element\");\n \n                 // ensure that the indexed variable was declared before the loop, see #601\n                 if let Some(indexed_extent) = indexed_extent {\n@@ -1024,10 +1024,10 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx Expr, expr: &'tcx Expr) {\n     // if this for loop is iterating over a two-sided range...\n     if let Some(higher::Range {\n-                    start: Some(start),\n-                    end: Some(end),\n-                    limits,\n-                }) = higher::range(arg)\n+        start: Some(start),\n+        end: Some(end),\n+        limits,\n+    }) = higher::range(arg)\n     {\n         // ...and both sides are compile-time constant integers...\n         let parent_item = cx.tcx.hir.get_parent(arg.id);\n@@ -1041,10 +1041,16 @@ fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx\n                 // who think that this will iterate from the larger value to the\n                 // smaller value.\n                 let (sup, eq) = match (start_idx, end_idx) {\n-                    (&ty::Const { val: ConstVal::Integral(start_idx), .. },\n-                     &ty::Const { val: ConstVal::Integral(end_idx), .. }) => {\n-                        (start_idx > end_idx, start_idx == end_idx)\n-                    },\n+                    (\n+                        &ty::Const {\n+                            val: ConstVal::Integral(start_idx),\n+                            ..\n+                        },\n+                        &ty::Const {\n+                            val: ConstVal::Integral(end_idx),\n+                            ..\n+                        },\n+                    ) => (start_idx > end_idx, start_idx == end_idx),\n                     _ => (false, false),\n                 };\n \n@@ -1132,7 +1138,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                         // If the length is greater than 32 no traits are implemented for array and\n                         // therefore we cannot use `&`.\n                         ty::TypeVariants::TyArray(_, size) if const_to_u64(size) > 32 => (),\n-                        _ => lint_iter_method(cx, args, arg, method_name)\n+                        _ => lint_iter_method(cx, args, arg, method_name),\n                     };\n                 } else {\n                     let object = snippet(cx, args[0].span, \"_\");\n@@ -1219,14 +1225,14 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n     // For each candidate, check the parent block to see if\n     // it's initialized to zero at the start of the loop.\n     let map = &cx.tcx.hir;\n-    let parent_scope = map.get_enclosing_scope(expr.id).and_then(|id| {\n-        map.get_enclosing_scope(id)\n-    });\n+    let parent_scope = map.get_enclosing_scope(expr.id)\n+        .and_then(|id| map.get_enclosing_scope(id));\n     if let Some(parent_id) = parent_scope {\n         if let NodeBlock(block) = map.get(parent_id) {\n-            for (id, _) in visitor.states.iter().filter(\n-                |&(_, v)| *v == VarState::IncrOnce,\n-            )\n+            for (id, _) in visitor\n+                .states\n+                .iter()\n+                .filter(|&(_, v)| *v == VarState::IncrOnce)\n             {\n                 let mut visitor2 = InitializeVisitor {\n                     cx: cx,\n@@ -1273,12 +1279,10 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n         if pat.len() == 2 {\n             let arg_span = arg.span;\n             let (new_pat_span, kind, ty, mutbl) = match cx.tables.expr_ty(arg).sty {\n-                ty::TyRef(_, ref tam) => {\n-                    match (&pat[0].node, &pat[1].node) {\n-                        (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", tam.ty, tam.mutbl),\n-                        (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", tam.ty, MutImmutable),\n-                        _ => return,\n-                    }\n+                ty::TyRef(_, ref tam) => match (&pat[0].node, &pat[1].node) {\n+                    (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", tam.ty, tam.mutbl),\n+                    (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", tam.ty, MutImmutable),\n+                    _ => return,\n                 },\n                 _ => return,\n             };\n@@ -1322,14 +1326,11 @@ struct MutateDelegate {\n }\n \n impl<'tcx> Delegate<'tcx> for MutateDelegate {\n-    fn consume(&mut self, _: NodeId, _: Span, _: cmt<'tcx>, _: ConsumeMode) {\n-    }\n+    fn consume(&mut self, _: NodeId, _: Span, _: cmt<'tcx>, _: ConsumeMode) {}\n \n-    fn matched_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: MatchMode) {\n-    }\n+    fn matched_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: MatchMode) {}\n \n-    fn consume_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: ConsumeMode) {\n-    }\n+    fn consume_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: ConsumeMode) {}\n \n     fn borrow(&mut self, _: NodeId, sp: Span, cmt: cmt<'tcx>, _: ty::Region, bk: ty::BorrowKind, _: LoanCause) {\n         if let ty::BorrowKind::MutBorrow = bk {\n@@ -1355,8 +1356,7 @@ impl<'tcx> Delegate<'tcx> for MutateDelegate {\n         }\n     }\n \n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {\n-    }\n+    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n }\n \n impl<'tcx> MutateDelegate {\n@@ -1366,8 +1366,16 @@ impl<'tcx> MutateDelegate {\n }\n \n fn check_for_mut_range_bound(cx: &LateContext, arg: &Expr, body: &Expr) {\n-    if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(arg) {\n-        let mut_ids = vec![check_for_mutability(cx, start), check_for_mutability(cx, end)];\n+    if let Some(higher::Range {\n+        start: Some(start),\n+        end: Some(end),\n+        ..\n+    }) = higher::range(arg)\n+    {\n+        let mut_ids = vec![\n+            check_for_mutability(cx, start),\n+            check_for_mutability(cx, end),\n+        ];\n         if mut_ids[0].is_some() || mut_ids[1].is_some() {\n             let (span_low, span_high) = check_for_mutation(cx, body, &mut_ids);\n             mut_warn_with_span(cx, span_low);\n@@ -1378,7 +1386,12 @@ fn check_for_mut_range_bound(cx: &LateContext, arg: &Expr, body: &Expr) {\n \n fn mut_warn_with_span(cx: &LateContext, span: Option<Span>) {\n     if let Some(sp) = span {\n-        span_lint(cx, MUT_RANGE_BOUND, sp, \"attempt to mutate range bound within loop; note that the range of the loop is unchanged\");\n+        span_lint(\n+            cx,\n+            MUT_RANGE_BOUND,\n+            sp,\n+            \"attempt to mutate range bound within loop; note that the range of the loop is unchanged\",\n+        );\n     }\n }\n \n@@ -1405,7 +1418,12 @@ fn check_for_mutability(cx: &LateContext, bound: &Expr) -> Option<NodeId> {\n }\n \n fn check_for_mutation(cx: &LateContext, body: &Expr, bound_ids: &[Option<NodeId>]) -> (Option<Span>, Option<Span>) {\n-    let mut delegate = MutateDelegate { node_id_low: bound_ids[0], node_id_high: bound_ids[1], span_low: None, span_high: None };\n+    let mut delegate = MutateDelegate {\n+        node_id_low: bound_ids[0],\n+        node_id_high: bound_ids[1],\n+        span_low: None,\n+        span_high: None,\n+    };\n     let def_id = def_id::DefId::local(body.hir_id.owner);\n     let region_scope_tree = &cx.tcx.region_scope_tree(def_id);\n     ExprUseVisitor::new(&mut delegate, cx.tcx, cx.param_env, region_scope_tree, cx.tables, None).walk_expr(body);\n@@ -1430,7 +1448,7 @@ fn pat_is_wild<'tcx>(pat: &'tcx PatKind, body: &'tcx Expr) -> bool {\n \n struct UsedVisitor {\n     var: ast::Name, // var to look for\n-    used: bool, // has the var been used otherwise?\n+    used: bool,     // has the var been used otherwise?\n }\n \n impl<'tcx> Visitor<'tcx> for UsedVisitor {\n@@ -1652,12 +1670,9 @@ fn extract_expr_from_first_stmt(block: &Block) -> Option<&Expr> {\n fn extract_first_expr(block: &Block) -> Option<&Expr> {\n     match block.expr {\n         Some(ref expr) if block.stmts.is_empty() => Some(expr),\n-        None if !block.stmts.is_empty() => {\n-            match block.stmts[0].node {\n-                StmtExpr(ref expr, _) |\n-                StmtSemi(ref expr, _) => Some(expr),\n-                StmtDecl(..) => None,\n-            }\n+        None if !block.stmts.is_empty() => match block.stmts[0].node {\n+            StmtExpr(ref expr, _) | StmtSemi(ref expr, _) => Some(expr),\n+            StmtDecl(..) => None,\n         },\n         _ => None,\n     }\n@@ -1669,11 +1684,9 @@ fn extract_first_expr(block: &Block) -> Option<&Expr> {\n fn is_simple_break_expr(expr: &Expr) -> bool {\n     match expr.node {\n         ExprBreak(dest, ref passed_expr) if dest.ident.is_none() && passed_expr.is_none() => true,\n-        ExprBlock(ref b) => {\n-            match extract_first_expr(b) {\n-                Some(subexpr) => is_simple_break_expr(subexpr),\n-                None => false,\n-            }\n+        ExprBlock(ref b) => match extract_first_expr(b) {\n+            Some(subexpr) => is_simple_break_expr(subexpr),\n+            None => false,\n         },\n         _ => false,\n     }\n@@ -1684,7 +1697,7 @@ fn is_simple_break_expr(expr: &Expr) -> bool {\n // at the start of the loop.\n #[derive(PartialEq)]\n enum VarState {\n-    Initial, // Not examined yet\n+    Initial,  // Not examined yet\n     IncrOnce, // Incremented exactly once, may be a loop counter\n     Declared, // Declared but not (yet) initialized to zero\n     Warn,\n@@ -1693,9 +1706,9 @@ enum VarState {\n \n /// Scan a for loop for variables that are incremented exactly once.\n struct IncrementVisitor<'a, 'tcx: 'a> {\n-    cx: &'a LateContext<'a, 'tcx>, // context reference\n+    cx: &'a LateContext<'a, 'tcx>,     // context reference\n     states: HashMap<NodeId, VarState>, // incremented variables\n-    depth: u32, // depth of conditional expressions\n+    depth: u32,                        // depth of conditional expressions\n     done: bool,\n }\n \n@@ -1749,7 +1762,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n /// Check whether a variable is initialized to zero at the start of a loop.\n struct InitializeVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>, // context reference\n-    end_expr: &'tcx Expr, // the for loop. Stop scanning here.\n+    end_expr: &'tcx Expr,          // the for loop. Stop scanning here.\n     var_id: NodeId,\n     state: VarState,\n     name: Option<Name>,\n@@ -1881,13 +1894,11 @@ fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool\n             return false;\n         }\n         match cx.tcx.hir.find(parent) {\n-            Some(NodeExpr(expr)) => {\n-                match expr.node {\n-                    ExprLoop(..) | ExprWhile(..) => {\n-                        return true;\n-                    },\n-                    _ => (),\n-                }\n+            Some(NodeExpr(expr)) => match expr.node {\n+                ExprLoop(..) | ExprWhile(..) => {\n+                    return true;\n+                },\n+                _ => (),\n             },\n             Some(NodeBlock(block)) => {\n                 let mut block_visitor = LoopNestVisitor {\n@@ -1911,8 +1922,8 @@ fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool\n \n #[derive(PartialEq, Eq)]\n enum Nesting {\n-    Unknown, // no nesting detected yet\n-    RuledOut, // the iterator is initialized or assigned within scope\n+    Unknown,     // no nesting detected yet\n+    RuledOut,    // the iterator is initialized or assigned within scope\n     LookFurther, // no nesting detected, no further walk required\n }\n \n@@ -1942,11 +1953,8 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n             return;\n         }\n         match expr.node {\n-            ExprAssign(ref path, _) |\n-            ExprAssignOp(_, ref path, _) => {\n-                if match_var(path, self.iterator) {\n-                    self.nesting = RuledOut;\n-                }\n+            ExprAssign(ref path, _) | ExprAssignOp(_, ref path, _) => if match_var(path, self.iterator) {\n+                self.nesting = RuledOut;\n             },\n             _ => walk_expr(self, expr),\n         }"}, {"sha": "dd3b2f00b7d75dea2d2eb6e1fe95049d89df58db", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -412,7 +412,11 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: Match\n }\n \n /// Get all arms that are unbounded `PatRange`s.\n-fn all_ranges<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arms: &'tcx [Arm], id: NodeId) -> Vec<SpannedRange<&'tcx ty::Const<'tcx>>> {\n+fn all_ranges<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    arms: &'tcx [Arm],\n+    id: NodeId,\n+) -> Vec<SpannedRange<&'tcx ty::Const<'tcx>>> {\n     let parent_item = cx.tcx.hir.get_parent(id);\n     let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n     let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n@@ -471,15 +475,39 @@ fn type_ranges(ranges: &[SpannedRange<&ty::Const>]) -> TypedRanges {\n     ranges\n         .iter()\n         .filter_map(|range| match range.node {\n-            (&ty::Const { val: ConstVal::Integral(start), .. }, Bound::Included(&ty::Const { val: ConstVal::Integral(end), .. })) => Some(SpannedRange {\n+            (\n+                &ty::Const {\n+                    val: ConstVal::Integral(start),\n+                    ..\n+                },\n+                Bound::Included(&ty::Const {\n+                    val: ConstVal::Integral(end),\n+                    ..\n+                }),\n+            ) => Some(SpannedRange {\n                 span: range.span,\n                 node: (start, Bound::Included(end)),\n             }),\n-            (&ty::Const { val: ConstVal::Integral(start), .. }, Bound::Excluded(&ty::Const { val: ConstVal::Integral(end), .. })) => Some(SpannedRange {\n+            (\n+                &ty::Const {\n+                    val: ConstVal::Integral(start),\n+                    ..\n+                },\n+                Bound::Excluded(&ty::Const {\n+                    val: ConstVal::Integral(end),\n+                    ..\n+                }),\n+            ) => Some(SpannedRange {\n                 span: range.span,\n                 node: (start, Bound::Excluded(end)),\n             }),\n-            (&ty::Const { val: ConstVal::Integral(start), .. }, Bound::Unbounded) => Some(SpannedRange {\n+            (\n+                &ty::Const {\n+                    val: ConstVal::Integral(start),\n+                    ..\n+                },\n+                Bound::Unbounded,\n+            ) => Some(SpannedRange {\n                 span: range.span,\n                 node: (start, Bound::Unbounded),\n             }),"}, {"sha": "103dbb72229a1b61d04bc670acf2c77eeaa86979", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::{Expr, ExprCall, ExprPath};\n-use utils::{match_def_path, paths, span_lint, opt_def_id};\n+use utils::{match_def_path, opt_def_id, paths, span_lint};\n \n /// **What it does:** Checks for usage of `std::mem::forget(t)` where `t` is\n /// `Drop`."}, {"sha": "251c4ac3a1138ac2389094366ba0264e2d588285", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 103, "deletions": 68, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -652,7 +652,8 @@ impl LintPass for Pass {\n             GET_UNWRAP,\n             STRING_EXTEND_CHARS,\n             ITER_CLONED_COLLECT,\n-            USELESS_ASREF)\n+            USELESS_ASREF\n+        )\n     }\n }\n \n@@ -773,15 +774,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         }\n                     }\n                 }\n-    \n+\n                 // check conventions w.r.t. conversion method names and predicates\n                 let def_id = cx.tcx.hir.local_def_id(item.id);\n                 let ty = cx.tcx.type_of(def_id);\n                 let is_copy = is_copy(cx, ty);\n                 for &(ref conv, self_kinds) in &CONVENTIONS {\n                     if_chain! {\n                         if conv.check(&name.as_str());\n-                        if !self_kinds.iter().any(|k| k.matches(first_arg_ty, first_arg, self_ty, is_copy, &implitem.generics));\n+                        if !self_kinds\n+                            .iter()\n+                            .any(|k| k.matches(first_arg_ty, first_arg, self_ty, is_copy, &implitem.generics));\n                         then {\n                             let lint = if item.vis == hir::Visibility::Public {\n                                 WRONG_PUB_SELF_CONVENTION\n@@ -801,7 +804,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         }\n                     }\n                 }\n-    \n+\n                 let ret_ty = return_ty(cx, implitem.id);\n                 if name == \"new\" &&\n                    !ret_ty.walk().any(|t| same_tys(cx, t, ty)) {\n@@ -887,9 +890,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n         // don't lint for constant values\n         // FIXME: can we `expect` here instead of match?\n         let owner_def = cx.tcx.hir.get_parent_did(arg.id);\n-        let promotable = cx.tcx\n-            .rvalue_promotable_map(owner_def)\n-            [&arg.hir_id.local_id];\n+        let promotable = cx.tcx.rvalue_promotable_map(owner_def)[&arg.hir_id.local_id];\n         if promotable {\n             return;\n         }\n@@ -991,12 +992,8 @@ fn lint_clone_on_ref_ptr(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr) {\n         expr.span,\n         \"using '.clone()' on a ref-counted pointer\",\n         \"try this\",\n-        format!(\"{}::clone(&{})\",\n-            caller_type,\n-            snippet(cx, arg.span, \"_\")\n-        )\n+        format!(\"{}::clone(&{})\", caller_type, snippet(cx, arg.span, \"_\")),\n     );\n-\n }\n \n \n@@ -1044,19 +1041,22 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n         if let Def::Method(did) = cx.tables.qpath_def(path, fun.hir_id);\n         if match_def_path(cx.tcx, did, &paths::CSTRING_NEW);\n         then {\n-            span_lint_and_then(cx, TEMPORARY_CSTRING_AS_PTR, expr.span,\n-                               \"you are getting the inner pointer of a temporary `CString`\",\n-                               |db| {\n-                                   db.note(\"that pointer will be invalid outside this expression\");\n-                                   db.span_help(unwrap.span, \"assign the `CString` to a variable to extend its lifetime\");\n-                               });\n+            span_lint_and_then(\n+                cx,\n+                TEMPORARY_CSTRING_AS_PTR,\n+                expr.span,\n+                \"you are getting the inner pointer of a temporary `CString`\",\n+                |db| {\n+                    db.note(\"that pointer will be invalid outside this expression\");\n+                    db.span_help(unwrap.span, \"assign the `CString` to a variable to extend its lifetime\");\n+                });\n         }\n     }\n }\n \n fn lint_iter_cloned_collect(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr]) {\n-    if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC) &&\n-        derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some()\n+    if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC)\n+        && derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some()\n     {\n         span_lint(\n             cx,\n@@ -1231,8 +1231,16 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::Expr]\n         // lint message\n         // comparing the snippet from source to raw text (\"None\") below is safe\n         // because we already have checked the type.\n-        let arg = if unwrap_snippet == \"None\" { \"None\" } else { \"a\" };\n-        let suggest = if unwrap_snippet == \"None\" { \"and_then(f)\" } else { \"map_or(a, f)\" };\n+        let arg = if unwrap_snippet == \"None\" {\n+            \"None\"\n+        } else {\n+            \"a\"\n+        };\n+        let suggest = if unwrap_snippet == \"None\" {\n+            \"and_then(f)\"\n+        } else {\n+            \"map_or(a, f)\"\n+        };\n         let msg = &format!(\n             \"called `map(f).unwrap_or({})` on an Option value. \\\n              This can be done more directly by calling `{}` instead\",\n@@ -1276,10 +1284,10 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n         // lint message\n         let msg = if is_option {\n             \"called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling \\\n-            `map_or_else(g, f)` instead\"\n+             `map_or_else(g, f)` instead\"\n         } else {\n             \"called `map(f).unwrap_or_else(g)` on a Result value. This can be done more directly by calling \\\n-            `ok().map_or_else(g, f)` instead\"\n+             `ok().map_or_else(g, f)` instead\"\n         };\n         // get snippets for args to map() and unwrap_or_else()\n         let map_snippet = snippet(cx, map_args[1].span, \"..\");\n@@ -1323,7 +1331,6 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n \n /// lint use of `_.map_or(None, _)` for `Option`s\n fn lint_map_or_none<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_or_args: &'tcx [hir::Expr]) {\n-\n     if match_type(cx, cx.tables.expr_ty(&map_or_args[0]), &paths::OPTION) {\n         // check if the first non-self argument to map_or() is None\n         let map_or_arg_is_none = if let hir::Expr_::ExprPath(ref qpath) = map_or_args[1].node {\n@@ -1339,13 +1346,9 @@ fn lint_map_or_none<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n             let map_or_self_snippet = snippet(cx, map_or_args[0].span, \"..\");\n             let map_or_func_snippet = snippet(cx, map_or_args[2].span, \"..\");\n             let hint = format!(\"{0}.and_then({1})\", map_or_self_snippet, map_or_func_snippet);\n-            span_lint_and_then(\n-                cx,\n-                OPTION_MAP_OR_NONE,\n-                expr.span,\n-                msg,\n-                |db| { db.span_suggestion(expr.span, \"try using and_then instead\", hint); },\n-            );\n+            span_lint_and_then(cx, OPTION_MAP_OR_NONE, expr.span, msg, |db| {\n+                db.span_suggestion(expr.span, \"try using and_then instead\", hint);\n+            });\n         }\n     }\n }\n@@ -1374,7 +1377,12 @@ fn lint_filter_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n }\n \n /// lint use of `filter().map()` for `Iterators`\n-fn lint_filter_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, _filter_args: &'tcx [hir::Expr], _map_args: &'tcx [hir::Expr]) {\n+fn lint_filter_map<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx hir::Expr,\n+    _filter_args: &'tcx [hir::Expr],\n+    _map_args: &'tcx [hir::Expr],\n+) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).map(q)` on an `Iterator`. \\\n@@ -1384,7 +1392,12 @@ fn lint_filter_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n }\n \n /// lint use of `filter().map()` for `Iterators`\n-fn lint_filter_map_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, _filter_args: &'tcx [hir::Expr], _map_args: &'tcx [hir::Expr]) {\n+fn lint_filter_map_map<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx hir::Expr,\n+    _filter_args: &'tcx [hir::Expr],\n+    _map_args: &'tcx [hir::Expr],\n+) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter_map(p).map(q)` on an `Iterator`. \\\n@@ -1394,7 +1407,12 @@ fn lint_filter_map_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Ex\n }\n \n /// lint use of `filter().flat_map()` for `Iterators`\n-fn lint_filter_flat_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, _filter_args: &'tcx [hir::Expr], _map_args: &'tcx [hir::Expr]) {\n+fn lint_filter_flat_map<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx hir::Expr,\n+    _filter_args: &'tcx [hir::Expr],\n+    _map_args: &'tcx [hir::Expr],\n+) {\n     // lint if caller of `.filter().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).flat_map(q)` on an `Iterator`. \\\n@@ -1405,7 +1423,12 @@ fn lint_filter_flat_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::E\n }\n \n /// lint use of `filter_map().flat_map()` for `Iterators`\n-fn lint_filter_map_flat_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, _filter_args: &'tcx [hir::Expr], _map_args: &'tcx [hir::Expr]) {\n+fn lint_filter_map_flat_map<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx hir::Expr,\n+    _filter_args: &'tcx [hir::Expr],\n+    _map_args: &'tcx [hir::Expr],\n+) {\n     // lint if caller of `.filter_map().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter_map(p).flat_map(q)` on an `Iterator`. \\\n@@ -1476,7 +1499,13 @@ fn lint_binary_expr_with_method_call<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, i\n }\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_NEXT_CMP` lints.\n-fn lint_chars_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo, chain_methods: &[&str], lint: &'static Lint, suggest: &str) -> bool {\n+fn lint_chars_cmp<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    info: &BinaryExprInfo,\n+    chain_methods: &[&str],\n+    lint: &'static Lint,\n+    suggest: &str,\n+) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n         if let hir::ExprCall(ref fun, ref arg_char) = info.other.node;\n@@ -1486,11 +1515,11 @@ fn lint_chars_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo, c\n         if segment.name == \"Some\";\n         then {\n             let self_ty = walk_ptrs_ty(cx.tables.expr_ty_adjusted(&args[0][0]));\n-    \n+\n             if self_ty.sty != ty::TyStr {\n                 return false;\n             }\n-    \n+\n             span_lint_and_sugg(cx,\n                                lint,\n                                info.expr.span,\n@@ -1501,7 +1530,7 @@ fn lint_chars_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo, c\n                                        snippet(cx, args[0][0].span, \"_\"),\n                                        suggest,\n                                        snippet(cx, arg_char[0].span, \"_\")));\n-    \n+\n             return true;\n         }\n     }\n@@ -1524,7 +1553,13 @@ fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprIn\n }\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints with `unwrap()`.\n-fn lint_chars_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo, chain_methods: &[&str], lint: &'static Lint, suggest: &str) -> bool {\n+fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    info: &BinaryExprInfo,\n+    chain_methods: &[&str],\n+    lint: &'static Lint,\n+    suggest: &str,\n+) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n         if let hir::ExprLit(ref lit) = info.other.node;\n@@ -1542,7 +1577,7 @@ fn lint_chars_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &Binar\n                         suggest,\n                         c)\n             );\n-    \n+\n             return true;\n         }\n     }\n@@ -1569,15 +1604,21 @@ fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hi\n     let parent_item = cx.tcx.hir.get_parent(arg.id);\n     let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n     let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n-    if let Ok(&ty::Const { val: ConstVal::Str(r), .. }) = ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(arg) {\n+    if let Ok(&ty::Const {\n+        val: ConstVal::Str(r),\n+        ..\n+    }) = ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(arg)\n+    {\n         if r.len() == 1 {\n             let hint = snippet(cx, expr.span, \"..\").replace(&format!(\"\\\"{}\\\"\", r), &format!(\"'{}'\", r));\n             span_lint_and_then(\n                 cx,\n                 SINGLE_CHAR_PATTERN,\n                 arg.span,\n                 \"single-character string constant used as pattern\",\n-                |db| { db.span_suggestion(expr.span, \"try using a char instead\", hint); },\n+                |db| {\n+                    db.span_suggestion(expr.span, \"try using a char instead\", hint);\n+                },\n             );\n         }\n     }\n@@ -1772,31 +1813,25 @@ impl SelfKind {\n fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Generics, name: &[&str]) -> bool {\n     single_segment_ty(ty).map_or(false, |seg| {\n         generics.ty_params.iter().any(|param| {\n-            param.name == seg.name &&\n-                param\n-                    .bounds\n-                    .iter()\n-                    .any(|bound| if let hir::TyParamBound::TraitTyParamBound(ref ptr, ..) = *bound {\n-                        let path = &ptr.trait_ref.path;\n-                        match_path(path, name) &&\n-                            path.segments\n-                                .last()\n-                                .map_or(false, |s| {\n-                                    if let Some(ref params) = s.parameters {\n-                                        if params.parenthesized {\n-                                            false\n-                                        } else {\n-                                            params.types.len() == 1 &&\n-                                                (is_self_ty(&params.types[0])\n-                                                  || is_ty(&*params.types[0], self_ty))\n-                                        }\n-                                    } else {\n-                                        false\n-                                    }\n-                                })\n-                    } else {\n-                        false\n+            param.name == seg.name && param.bounds.iter().any(|bound| {\n+                if let hir::TyParamBound::TraitTyParamBound(ref ptr, ..) = *bound {\n+                    let path = &ptr.trait_ref.path;\n+                    match_path(path, name) && path.segments.last().map_or(false, |s| {\n+                        if let Some(ref params) = s.parameters {\n+                            if params.parenthesized {\n+                                false\n+                            } else {\n+                                params.types.len() == 1\n+                                    && (is_self_ty(&params.types[0]) || is_ty(&*params.types[0], self_ty))\n+                            }\n+                        } else {\n+                            false\n+                        }\n                     })\n+                } else {\n+                    false\n+                }\n+            })\n         })\n     })\n }"}, {"sha": "b5b844e199e9df979abf744c49ae1a1a6a05ed56", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -2,7 +2,7 @@ use consts::{constant_simple, Constant};\n use rustc::lint::*;\n use rustc::hir::*;\n use std::cmp::{Ordering, PartialOrd};\n-use utils::{match_def_path, paths, span_lint, opt_def_id};\n+use utils::{match_def_path, opt_def_id, paths, span_lint};\n \n /// **What it does:** Checks for expressions where `std::cmp::min` and `max` are\n /// used to clamp values, but switched so that the result is constant."}, {"sha": "e1d350a9ad2548cf75a23a4e33d250f462be5e47", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -328,8 +328,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     }\n                     if let Some(name) = get_item_name(cx, expr) {\n                         let name = name.as_str();\n-                        if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") ||\n-                            name.ends_with(\"_eq\")\n+                        if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\")\n+                            || name.ends_with(\"_eq\")\n                         {\n                             return;\n                         }\n@@ -410,13 +410,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n fn check_nan(cx: &LateContext, path: &Path, expr: &Expr) {\n     if !in_constant(cx, expr.id) {\n-        path.segments.last().map(|seg| if seg.name == \"NAN\" {\n-            span_lint(\n-                cx,\n-                CMP_NAN,\n-                expr.span,\n-                \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\",\n-            );\n+        path.segments.last().map(|seg| {\n+            if seg.name == \"NAN\" {\n+                span_lint(\n+                    cx,\n+                    CMP_NAN,\n+                    expr.span,\n+                    \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\",\n+                );\n+            }\n         });\n     }\n }\n@@ -426,7 +428,11 @@ fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n     let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n     let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n     let res = ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(expr);\n-    if let Ok(&ty::Const { val: ConstVal::Float(val), .. }) = res {\n+    if let Ok(&ty::Const {\n+        val: ConstVal::Float(val),\n+        ..\n+    }) = res\n+    {\n         use std::cmp::Ordering;\n         match val.ty {\n             FloatTy::F32 => {\n@@ -445,8 +451,8 @@ fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n                     bits: u128::from(::std::f32::NEG_INFINITY.to_bits()),\n                 };\n \n-                val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal) ||\n-                    val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n+                val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal)\n+                    || val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n             },\n             FloatTy::F64 => {\n                 let zero = ConstFloat {\n@@ -464,8 +470,8 @@ fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n                     bits: u128::from(::std::f64::NEG_INFINITY.to_bits()),\n                 };\n \n-                val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal) ||\n-                    val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n+                val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal)\n+                    || val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n             },\n         }\n     } else {\n@@ -576,9 +582,7 @@ fn in_attributes_expansion(expr: &Expr) -> bool {\n /// Test whether `def` is a variable defined outside a macro.\n fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n     match *def {\n-        def::Def::Local(id) | def::Def::Upvar(id, _, _) => {\n-            !in_macro(cx.tcx.hir.span(id))\n-        },\n+        def::Def::Local(id) | def::Def::Upvar(id, _, _) => !in_macro(cx.tcx.hir.span(id)),\n         _ => false,\n     }\n }"}, {"sha": "b1388864bdc1738d058232cc141dc2a5751ef24e", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n                                 if let Some(snippet) = snippet_opt(cx, inner.span) {\n                                     db.span_suggestion(e.span, \"change this to\", snippet);\n                                 }\n-                            }\n+                            },\n                         );\n                     }\n                 }"}, {"sha": "ccf9c62d93c9b8c6572b644daaab0e954f1ac7b1", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -255,13 +255,13 @@ struct LintData<'a> {\n const MSG_REDUNDANT_ELSE_BLOCK: &str = \"This else block is redundant.\\n\";\n \n const MSG_ELSE_BLOCK_NOT_NEEDED: &str = \"There is no need for an explicit `else` block for this `if` \\\n-                                                 expression\\n\";\n+                                         expression\\n\";\n \n const DROP_ELSE_BLOCK_AND_MERGE_MSG: &str = \"Consider dropping the else clause and merging the code that \\\n-                                                     follows (in the loop) with the if block, like so:\\n\";\n+                                             follows (in the loop) with the if block, like so:\\n\";\n \n const DROP_ELSE_BLOCK_MSG: &str = \"Consider dropping the else clause, and moving out the code in the else \\\n-                                           block, like so:\\n\";\n+                                   block, like so:\\n\";\n \n \n fn emit_warning<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str, typ: LintType) {\n@@ -332,22 +332,24 @@ fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext, data: &'a\n }\n \n fn check_and_warn<'a>(ctx: &EarlyContext, expr: &'a ast::Expr) {\n-    with_loop_block(expr, |loop_block| for (i, stmt) in loop_block.stmts.iter().enumerate() {\n-        with_if_expr(stmt, |if_expr, cond, then_block, else_expr| {\n-            let data = &LintData {\n-                stmt_idx: i,\n-                if_expr: if_expr,\n-                if_cond: cond,\n-                if_block: then_block,\n-                else_expr: else_expr,\n-                block_stmts: &loop_block.stmts,\n-            };\n-            if needless_continue_in_else(else_expr) {\n-                emit_warning(ctx, data, DROP_ELSE_BLOCK_AND_MERGE_MSG, LintType::ContinueInsideElseBlock);\n-            } else if is_first_block_stmt_continue(then_block) {\n-                emit_warning(ctx, data, DROP_ELSE_BLOCK_MSG, LintType::ContinueInsideThenBlock);\n-            }\n-        });\n+    with_loop_block(expr, |loop_block| {\n+        for (i, stmt) in loop_block.stmts.iter().enumerate() {\n+            with_if_expr(stmt, |if_expr, cond, then_block, else_expr| {\n+                let data = &LintData {\n+                    stmt_idx: i,\n+                    if_expr: if_expr,\n+                    if_cond: cond,\n+                    if_block: then_block,\n+                    else_expr: else_expr,\n+                    block_stmts: &loop_block.stmts,\n+                };\n+                if needless_continue_in_else(else_expr) {\n+                    emit_warning(ctx, data, DROP_ELSE_BLOCK_AND_MERGE_MSG, LintType::ContinueInsideElseBlock);\n+                } else if is_first_block_stmt_continue(then_block) {\n+                    emit_warning(ctx, data, DROP_ELSE_BLOCK_MSG, LintType::ContinueInsideThenBlock);\n+                }\n+            });\n+        }\n     });\n }\n "}, {"sha": "81edd58af57e320ab32521a5daea663f56378d55", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -106,13 +106,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n         let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds.to_vec())\n             .filter(|p| !p.is_global())\n-            .filter_map(|pred| if let ty::Predicate::Trait(poly_trait_ref) = pred {\n-                if poly_trait_ref.def_id() == sized_trait || poly_trait_ref.skip_binder().has_escaping_regions() {\n-                    return None;\n+            .filter_map(|pred| {\n+                if let ty::Predicate::Trait(poly_trait_ref) = pred {\n+                    if poly_trait_ref.def_id() == sized_trait || poly_trait_ref.skip_binder().has_escaping_regions() {\n+                        return None;\n+                    }\n+                    Some(poly_trait_ref)\n+                } else {\n+                    None\n                 }\n-                Some(poly_trait_ref)\n-            } else {\n-                None\n             })\n             .collect::<Vec<_>>();\n "}, {"sha": "d56833eb457468c2991b0fed98c69c5e70f90aa2", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -108,55 +108,66 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                 // can't be implemented by default\n                 return;\n             }\n-            if !cx.generics.expect(\"method must have generics\").ty_params.is_empty() {\n-               // when the result of `new()` depends on a type parameter we should not require\n-               // an\n-               // impl of `Default`\n-               return;\n+            if !cx.generics\n+                .expect(\"method must have generics\")\n+                .ty_params\n+                .is_empty()\n+            {\n+                // when the result of `new()` depends on a type parameter we should not require\n+                // an\n+                // impl of `Default`\n+                return;\n             }\n             if decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(id) {\n                 let self_ty = cx.tcx\n                     .type_of(cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id)));\n                 if_chain! {\n-                                    if same_tys(cx, self_ty, return_ty(cx, id));\n-                                    if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n-                                    if !implements_trait(cx, self_ty, default_trait_id, &[]);\n-                                    then {\n-                                        if let Some(sp) = can_derive_default(self_ty, cx, default_trait_id) {\n-                                            span_lint_and_then(cx,\n-                                                               NEW_WITHOUT_DEFAULT_DERIVE, span,\n-                                                               &format!(\"you should consider deriving a \\\n-                                                                         `Default` implementation for `{}`\",\n-                                                                        self_ty),\n-                                                               |db| {\n-                                                db.suggest_item_with_attr(cx, sp, \"try this\", \"#[derive(Default)]\");\n-                                            });\n-                                        } else {\n-                                            span_lint_and_then(cx,\n-                                                               NEW_WITHOUT_DEFAULT, span,\n-                                                               &format!(\"you should consider adding a \\\n-                                                                        `Default` implementation for `{}`\",\n-                                                                        self_ty),\n-                                                               |db| {\n-                                            db.suggest_prepend_item(cx,\n-                                                                      span,\n-                                                                      \"try this\",\n-                                                                      &format!(\n-\"impl Default for {} {{\n-    fn default() -> Self {{\n-        Self::new()\n-    }}\n-}}\",\n-                                                                               self_ty));\n-                                            });\n-                                        }\n-                                    }\n+                    if same_tys(cx, self_ty, return_ty(cx, id));\n+                    if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n+                    if !implements_trait(cx, self_ty, default_trait_id, &[]);\n+                    then {\n+                        if let Some(sp) = can_derive_default(self_ty, cx, default_trait_id) {\n+                            span_lint_and_then(\n+                                cx,\n+                                NEW_WITHOUT_DEFAULT_DERIVE,\n+                                span,\n+                                &format!(\"you should consider deriving a `Default` implementation for `{}`\", self_ty),\n+                                |db| {\n+                                    db.suggest_item_with_attr(cx, sp, \"try this\", \"#[derive(Default)]\");\n+                                });\n+                        } else {\n+                            span_lint_and_then(\n+                                cx,\n+                                NEW_WITHOUT_DEFAULT,\n+                                span,\n+                                &format!(\"you should consider adding a `Default` implementation for `{}`\", self_ty),\n+                                |db| {\n+                                    db.suggest_prepend_item(\n+                                        cx,\n+                                        span,\n+                                        \"try this\",\n+                                        &create_new_without_default_suggest_msg(self_ty),\n+                                    );\n+                                },\n+                            );\n+                        }\n+                    }\n                 }\n             }\n         }\n     }\n }\n \n+fn create_new_without_default_suggest_msg(ty: Ty) -> String {\n+    #[rustfmt_skip]\n+    format!(\n+\"impl Default for {} {{\n+    fn default() -> Self {{\n+        Self::new()\n+    }}\n+}}\", ty)\n+}\n+\n fn can_derive_default<'t, 'c>(ty: Ty<'t>, cx: &LateContext<'c, 't>, default_trait_id: DefId) -> Option<Span> {\n     match ty.sty {\n         ty::TyAdt(adt_def, substs) if adt_def.is_struct() => {"}, {"sha": "a1139ff746479bd32eb661cec821885ac7a37eb5", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::hir::def::Def;\n use rustc::hir::{BiAnd, BiOr, BlockCheckMode, Expr, Expr_, Stmt, StmtSemi, UnsafeSource};\n-use utils::{in_macro, snippet_opt, span_lint, span_lint_and_sugg, has_drop};\n+use utils::{has_drop, in_macro, snippet_opt, span_lint, span_lint_and_sugg};\n use std::ops::Deref;\n \n /// **What it does:** Checks for statements which have no effect.\n@@ -146,23 +146,24 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n         Expr_::ExprTupField(ref inner, _) |\n         Expr_::ExprAddrOf(_, ref inner) |\n         Expr_::ExprBox(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n-        Expr_::ExprStruct(_, ref fields, ref base) => {\n-            if has_drop(cx, expr) {\n-                None\n-            } else {\n-                Some(\n-                    fields\n-                        .iter()\n-                        .map(|f| &f.expr)\n-                        .chain(base)\n-                        .map(Deref::deref)\n-                        .collect())\n-            }\n+        Expr_::ExprStruct(_, ref fields, ref base) => if has_drop(cx, expr) {\n+            None\n+        } else {\n+            Some(\n+                fields\n+                    .iter()\n+                    .map(|f| &f.expr)\n+                    .chain(base)\n+                    .map(Deref::deref)\n+                    .collect(),\n+            )\n         },\n         Expr_::ExprCall(ref callee, ref args) => if let Expr_::ExprPath(ref qpath) = callee.node {\n             let def = cx.tables.qpath_def(qpath, callee.hir_id);\n             match def {\n-                Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..) if !has_drop(cx, expr) => {\n+                Def::Struct(..) | Def::Variant(..) | Def::StructCtor(..) | Def::VariantCtor(..)\n+                    if !has_drop(cx, expr) =>\n+                {\n                     Some(args.iter().collect())\n                 },\n                 _ => None,"}, {"sha": "d3b6aefe5f43985b40918ed5a86365ef4313464c", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -216,8 +216,8 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n                         let second_last_e = existing_chars\n                             .next_back()\n                             .expect(\"we know we have at least three chars\");\n-                        if !eq_or_numeric((second_last_i, second_last_e)) || second_last_i == '_' ||\n-                            !interned_chars.zip(existing_chars).all(eq_or_numeric)\n+                        if !eq_or_numeric((second_last_i, second_last_e)) || second_last_i == '_'\n+                            || !interned_chars.zip(existing_chars).all(eq_or_numeric)\n                         {\n                             // allowed similarity foo_x, foo_y\n                             // or too many chars differ (foo_x, boo_y) or (foox, booy)\n@@ -232,8 +232,8 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n                     let second_e = existing_chars\n                         .next()\n                         .expect(\"we know we have at least two chars\");\n-                    if !eq_or_numeric((second_i, second_e)) || second_i == '_' ||\n-                        !interned_chars.zip(existing_chars).all(eq_or_numeric)\n+                    if !eq_or_numeric((second_i, second_e)) || second_i == '_'\n+                        || !interned_chars.zip(existing_chars).all(eq_or_numeric)\n                     {\n                         // allowed similarity x_foo, y_foo\n                         // or too many chars differ (x_foo, y_boo) or (xfoo, yboo)"}, {"sha": "b79e90f910bdf75087b30f74530dfa2205b352eb", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -49,7 +49,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if let ExprMethodCall(_, _, ref result_types) = op.node; //check is expr.ok() has type Result<T,E>.ok()\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pats[0].node; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n-    \n+\n             then {\n                 let is_result_type = match_type(cx, cx.tables.expr_ty(&result_types[0]), &paths::RESULT);\n                 let some_expr_string = snippet(cx, y[0].span, \"\");"}, {"sha": "673f428eb07937430dc11f6b53ec4f35d4c753c2", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -81,8 +81,8 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n                         }\n                     } else {\n                         return; // The function is called with a literal\n-                        // which is not a boolean literal. This is theoretically\n-                        // possible, but not very likely.\n+                                // which is not a boolean literal. This is theoretically\n+                                // possible, but not very likely.\n                     }\n                 },\n                 _ => Argument::Unknown,"}, {"sha": "9430e59ac86485fddcc10bfca8630928dcbcc78d", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n use syntax::ast::LitKind;\n-use utils::{is_direct_expn_of, match_def_path, paths, resolve_node, span_lint, opt_def_id};\n+use utils::{is_direct_expn_of, match_def_path, opt_def_id, paths, resolve_node, span_lint};\n \n /// **What it does:** Checks for missing parameters in `panic!`.\n ///"}, {"sha": "61ed8d5ac2503c0e8725d10f1182758a68408ffb", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -6,7 +6,7 @@ use syntax::ast::LitKind;\n use syntax::symbol::InternedString;\n use syntax_pos::Span;\n use utils::{is_expn_of, match_def_path, match_path, resolve_node, span_lint};\n-use utils::{paths, opt_def_id};\n+use utils::{opt_def_id, paths};\n \n /// **What it does:** This lint warns when you using `println!(\"\")` to\n /// print a newline.\n@@ -94,7 +94,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if let ExprPath(ref qpath) = fun.node;\n             if let Some(fun_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n             then {\n-    \n+\n                 // Search for `std::io::_print(..)` which is unique in a\n                 // `print!` expansion.\n                 if match_def_path(cx.tcx, fun_id, &paths::IO_PRINT) {\n@@ -104,9 +104,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                             Some(span) => (span, \"println\"),\n                             None => (span, \"print\"),\n                         };\n-    \n+\n                         span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n-    \n+\n                         if_chain! {\n                             // ensure we're calling Arguments::new_v1\n                             if args.len() == 1;"}, {"sha": "a6a3690202fa56591c77ca7baaca7ca4729790d3", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -8,8 +8,7 @@ use rustc::ty;\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use syntax_pos::MultiSpan;\n-use utils::{match_qpath, match_type, paths, snippet_opt, span_lint, span_lint_and_then,\n-            walk_ptrs_hir_ty};\n+use utils::{match_qpath, match_type, paths, snippet_opt, span_lint, span_lint_and_then, walk_ptrs_hir_ty};\n use utils::ptr::get_spans;\n \n /// **What it does:** This lint checks for function arguments of type `&String`\n@@ -121,7 +120,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if let TraitItemKind::Method(ref sig, ref trait_method) = item.node {\n-            let body_id = if let TraitMethod::Provided(b) = *trait_method { Some(b) } else { None };\n+            let body_id = if let TraitMethod::Provided(b) = *trait_method {\n+                Some(b)\n+            } else {\n+                None\n+            };\n             check_fn(cx, &sig.decl, item.id, body_id);\n         }\n     }\n@@ -173,17 +176,19 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n                          with non-Vec-based slices.\",\n                         |db| {\n                             if let Some(ref snippet) = ty_snippet {\n-                                db.span_suggestion(arg.span,\n-                                                   \"change this to\",\n-                                                   format!(\"&[{}]\", snippet));\n+                                db.span_suggestion(arg.span, \"change this to\", format!(\"&[{}]\", snippet));\n                             }\n                             for (clonespan, suggestion) in spans {\n-                                db.span_suggestion(clonespan,\n-                                                   &snippet_opt(cx, clonespan).map_or(\"change the call to\".into(),\n-                                                        |x| Cow::Owned(format!(\"change `{}` to\", x))),\n-                                                   suggestion.into());\n+                                db.span_suggestion(\n+                                    clonespan,\n+                                    &snippet_opt(cx, clonespan).map_or(\n+                                        \"change the call to\".into(),\n+                                        |x| Cow::Owned(format!(\"change `{}` to\", x)),\n+                                    ),\n+                                    suggestion.into(),\n+                                );\n                             }\n-                        }\n+                        },\n                     );\n                 }\n             } else if match_type(cx, ty, &paths::STRING) {\n@@ -194,16 +199,18 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n                         arg.span,\n                         \"writing `&String` instead of `&str` involves a new object where a slice will do.\",\n                         |db| {\n-                            db.span_suggestion(arg.span,\n-                                               \"change this to\",\n-                                               \"&str\".into());\n+                            db.span_suggestion(arg.span, \"change this to\", \"&str\".into());\n                             for (clonespan, suggestion) in spans {\n-                                db.span_suggestion_short(clonespan,\n-                                                   &snippet_opt(cx, clonespan).map_or(\"change the call to\".into(),\n-                                                        |x| Cow::Owned(format!(\"change `{}` to\", x))),\n-                                                   suggestion.into());\n+                                db.span_suggestion_short(\n+                                    clonespan,\n+                                    &snippet_opt(cx, clonespan).map_or(\n+                                        \"change the call to\".into(),\n+                                        |x| Cow::Owned(format!(\"change `{}` to\", x)),\n+                                    ),\n+                                    suggestion.into(),\n+                                );\n                             }\n-                        }\n+                        },\n                     );\n                 }\n             }"}, {"sha": "39252ceed1c9644d23cd810f9c6e93946b998932", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -82,12 +82,7 @@ pub struct Pass;\n \n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(\n-            ITERATOR_STEP_BY_ZERO,\n-            RANGE_ZIP_WITH_LEN,\n-            RANGE_PLUS_ONE,\n-            RANGE_MINUS_ONE\n-        )\n+        lint_array!(ITERATOR_STEP_BY_ZERO, RANGE_ZIP_WITH_LEN, RANGE_PLUS_ONE, RANGE_MINUS_ONE)\n     }\n }\n \n@@ -192,14 +187,12 @@ fn has_step_by(cx: &LateContext, expr: &Expr) -> bool {\n \n fn y_plus_one(expr: &Expr) -> Option<&Expr> {\n     match expr.node {\n-        ExprBinary(Spanned { node: BiAdd, .. }, ref lhs, ref rhs) => {\n-            if is_integer_literal(lhs, 1) {\n-                Some(rhs)\n-            } else if is_integer_literal(rhs, 1) {\n-                Some(lhs)\n-            } else {\n-                None\n-            }\n+        ExprBinary(Spanned { node: BiAdd, .. }, ref lhs, ref rhs) => if is_integer_literal(lhs, 1) {\n+            Some(rhs)\n+        } else if is_integer_literal(rhs, 1) {\n+            Some(lhs)\n+        } else {\n+            None\n         },\n         _ => None,\n     }"}, {"sha": "beb24a3dbe4eca298a313f52e6aa1e2a9f18d991", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -10,7 +10,7 @@ use std::error::Error;\n use syntax::ast::{LitKind, NodeId};\n use syntax::codemap::{BytePos, Span};\n use syntax::symbol::InternedString;\n-use utils::{is_expn_of, match_def_path, match_type, paths, span_help_and_lint, span_lint, opt_def_id};\n+use utils::{is_expn_of, match_def_path, match_type, opt_def_id, paths, span_help_and_lint, span_lint};\n \n /// **What it does:** Checks [regex](https://crates.io/crates/regex) creation\n /// (with `Regex::new`,`RegexBuilder::new` or `RegexSet::new`) for correct\n@@ -151,7 +151,10 @@ fn const_str<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) -> Option<Inte\n     let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n     let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n     match ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(e) {\n-        Ok(&ty::Const { val: ConstVal::Str(r), .. }) => Some(r),\n+        Ok(&ty::Const {\n+            val: ConstVal::Str(r),\n+            ..\n+        }) => Some(r),\n         _ => None,\n     }\n }"}, {"sha": "92ac65b5abc66260dcfd96880c532101fc48227b", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -253,7 +253,9 @@ fn lint_shadow<'a, 'tcx: 'a>(\n                     snippet(cx, pattern_span, \"_\"),\n                     snippet(cx, expr.span, \"..\")\n                 ),\n-                |db| { db.span_note(prev_span, \"previous binding is here\"); },\n+                |db| {\n+                    db.span_note(prev_span, \"previous binding is here\");\n+                },\n             );\n         } else if contains_name(name, expr) {\n             span_lint_and_then(\n@@ -292,7 +294,9 @@ fn lint_shadow<'a, 'tcx: 'a>(\n             SHADOW_UNRELATED,\n             span,\n             &format!(\"`{}` shadows a previous declaration\", snippet(cx, pattern_span, \"_\")),\n-            |db| { db.span_note(prev_span, \"previous binding is here\"); },\n+            |db| {\n+                db.span_note(prev_span, \"previous binding is here\");\n+            },\n         );\n     }\n }\n@@ -361,8 +365,8 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n     match expr.node {\n         ExprBox(ref inner) | ExprAddrOf(_, ref inner) => is_self_shadow(name, inner),\n         ExprBlock(ref block) => {\n-            block.stmts.is_empty() &&\n-                block\n+            block.stmts.is_empty()\n+                && block\n                     .expr\n                     .as_ref()\n                     .map_or(false, |e| is_self_shadow(name, e))"}, {"sha": "17514d9d658d1323e4db7cd5b1748096049ad038", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -123,8 +123,8 @@ fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n         ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n         ExprBlock(ref block) => {\n-            block.stmts.is_empty() &&\n-                block\n+            block.stmts.is_empty()\n+                && block\n                     .expr\n                     .as_ref()\n                     .map_or(false, |expr| is_add(cx, expr, target))"}, {"sha": "25fc666d3e1e30b947f735b848278c95404f7483", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -89,7 +89,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n                         if let ExprIndex(ref lhs2, ref idx2) = lhs2.node {\n                             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n                                 let ty = walk_ptrs_ty(cx.tables.expr_ty(lhs1));\n-    \n+\n                                 if matches!(ty.sty, ty::TySlice(_)) ||\n                                     matches!(ty.sty, ty::TyArray(_, _)) ||\n                                     match_type(cx, ty, &paths::VEC) ||\n@@ -99,10 +99,10 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n                             }\n                         }\n                     }\n-    \n+\n                     None\n                 }\n-    \n+\n                 let (replace, what, sugg) = if let Some((slice, idx1, idx2)) = check_for_slice(cx, lhs1, lhs2) {\n                     if let Some(slice) = Sugg::hir_opt(cx, slice) {\n                         (false,\n@@ -120,17 +120,17 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n                 } else {\n                     (true, \"\".to_owned(), \"\".to_owned())\n                 };\n-    \n+\n                 let span = w[0].span.to(second.span);\n-    \n+\n                 span_lint_and_then(cx,\n                                    MANUAL_SWAP,\n                                    span,\n                                    &format!(\"this looks like you are swapping{} manually\", what),\n                                    |db| {\n                                        if !sugg.is_empty() {\n                                            db.span_suggestion(span, \"try\", sugg);\n-    \n+\n                                            if replace {\n                                                db.note(\"or maybe you should use `std::mem::replace`?\");\n                                            }\n@@ -156,13 +156,17 @@ fn check_suspicious_swap(cx: &LateContext, block: &Block) {\n                 let lhs0 = Sugg::hir_opt(cx, lhs0);\n                 let rhs0 = Sugg::hir_opt(cx, rhs0);\n                 let (what, lhs, rhs) = if let (Some(first), Some(second)) = (lhs0, rhs0) {\n-                    (format!(\" `{}` and `{}`\", first, second), first.mut_addr().to_string(), second.mut_addr().to_string())\n+                    (\n+                        format!(\" `{}` and `{}`\", first, second),\n+                        first.mut_addr().to_string(),\n+                        second.mut_addr().to_string(),\n+                    )\n                 } else {\n                     (\"\".to_owned(), \"\".to_owned(), \"\".to_owned())\n                 };\n-    \n+\n                 let span = first.span.to(second.span);\n-    \n+\n                 span_lint_and_then(cx,\n                                    ALMOST_SWAPPED,\n                                    span,"}, {"sha": "1028381e20a16136fdfc7808197b95dd6f3712d6", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 67, "deletions": 43, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -4,7 +4,7 @@ use rustc::hir::*;\n use std::borrow::Cow;\n use syntax::ast;\n use utils::{last_path_segment, match_def_path, paths, snippet, span_lint, span_lint_and_then};\n-use utils::{sugg, opt_def_id};\n+use utils::{opt_def_id, sugg};\n \n /// **What it does:** Checks for transmutes that can't ever be correct on any\n /// architecture.\n@@ -190,7 +190,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n         if let ExprCall(ref path_expr, ref args) = e.node {\n             if let ExprPath(ref qpath) = path_expr.node {\n                 if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path_expr.hir_id)) {\n-\n                     if match_def_path(cx.tcx, def_id, &paths::TRANSMUTE) {\n                         let from_ty = cx.tables.expr_ty(&args[0]);\n                         let to_ty = cx.tables.expr_ty(e);\n@@ -217,15 +216,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     db.span_suggestion(e.span, \"try\", sugg.to_string());\n                                 },\n                             ),\n-                            (&ty::TyInt(_), &ty::TyRawPtr(_)) | (&ty::TyUint(_), &ty::TyRawPtr(_)) => span_lint_and_then(\n-                                cx,\n-                                USELESS_TRANSMUTE,\n-                                e.span,\n-                                \"transmute from an integer to a pointer\",\n-                                |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                    db.span_suggestion(e.span, \"try\", arg.as_ty(&to_ty.to_string()).to_string());\n-                                },\n-                            ),\n+                            (&ty::TyInt(_), &ty::TyRawPtr(_)) | (&ty::TyUint(_), &ty::TyRawPtr(_)) => {\n+                                span_lint_and_then(\n+                                    cx,\n+                                    USELESS_TRANSMUTE,\n+                                    e.span,\n+                                    \"transmute from an integer to a pointer\",\n+                                    |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                                        db.span_suggestion(e.span, \"try\", arg.as_ty(&to_ty.to_string()).to_string());\n+                                    },\n+                                )\n+                            },\n                             (&ty::TyFloat(_), &ty::TyRef(..)) |\n                             (&ty::TyFloat(_), &ty::TyRawPtr(_)) |\n                             (&ty::TyChar, &ty::TyRef(..)) |\n@@ -249,15 +250,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                 cx,\n                                 CROSSPOINTER_TRANSMUTE,\n                                 e.span,\n-                                &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\", from_ty, to_ty),\n+                                &format!(\n+                                    \"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n+                                    from_ty,\n+                                    to_ty\n+                                ),\n                             ),\n                             (&ty::TyRawPtr(from_pty), &ty::TyRef(_, to_ref_ty)) => span_lint_and_then(\n                                 cx,\n                                 TRANSMUTE_PTR_TO_REF,\n                                 e.span,\n                                 &format!(\n                                     \"transmute from a pointer type (`{}`) to a reference type \\\n-                                    (`{}`)\",\n+                                     (`{}`)\",\n                                     from_ty,\n                                     to_ty\n                                 ),\n@@ -291,8 +296,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     } else {\n                                         arg\n                                     };\n-                                    db.span_suggestion(e.span, \"consider using\", format!(\"std::char::from_u32({}).unwrap()\", arg.to_string()));\n-                                }\n+                                    db.span_suggestion(\n+                                        e.span,\n+                                        \"consider using\",\n+                                        format!(\"std::char::from_u32({}).unwrap()\", arg.to_string()),\n+                                    );\n+                                },\n                             ),\n                             (&ty::TyRef(_, ref ref_from), &ty::TyRef(_, ref ref_to)) => {\n                                 if_chain! {\n@@ -326,34 +335,49 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                     }\n                                 }\n                             },\n-                            (&ty::TyInt(ast::IntTy::I8), &ty::TyBool) |\n-                            (&ty::TyUint(ast::UintTy::U8), &ty::TyBool) => span_lint_and_then(\n-                                cx,\n-                                TRANSMUTE_INT_TO_BOOL,\n-                                e.span,\n-                                &format!(\"transmute from a `{}` to a `bool`\", from_ty),\n-                                |db| {\n-                                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                    let zero = sugg::Sugg::NonParen(Cow::from(\"0\"));\n-                                    db.span_suggestion(e.span, \"consider using\", sugg::make_binop(ast::BinOpKind::Ne, &arg, &zero).to_string());\n-                                }\n-                            ),\n-                            (&ty::TyInt(_), &ty::TyFloat(_)) |\n-                            (&ty::TyUint(_), &ty::TyFloat(_)) => span_lint_and_then(\n-                                cx,\n-                                TRANSMUTE_INT_TO_FLOAT,\n-                                e.span,\n-                                &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n-                                |db| {\n-                                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                    let arg = if let ty::TyInt(int_ty) = from_ty.sty {\n-                                        arg.as_ty(format!(\"u{}\", int_ty.bit_width().map_or_else(|| \"size\".to_string(), |v| v.to_string())))\n-                                    } else {\n-                                        arg\n-                                    };\n-                                    db.span_suggestion(e.span, \"consider using\", format!(\"{}::from_bits({})\", to_ty, arg.to_string()));\n-                                }\n-                            ),\n+                            (&ty::TyInt(ast::IntTy::I8), &ty::TyBool) | (&ty::TyUint(ast::UintTy::U8), &ty::TyBool) => {\n+                                span_lint_and_then(\n+                                    cx,\n+                                    TRANSMUTE_INT_TO_BOOL,\n+                                    e.span,\n+                                    &format!(\"transmute from a `{}` to a `bool`\", from_ty),\n+                                    |db| {\n+                                        let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                                        let zero = sugg::Sugg::NonParen(Cow::from(\"0\"));\n+                                        db.span_suggestion(\n+                                            e.span,\n+                                            \"consider using\",\n+                                            sugg::make_binop(ast::BinOpKind::Ne, &arg, &zero).to_string(),\n+                                        );\n+                                    },\n+                                )\n+                            },\n+                            (&ty::TyInt(_), &ty::TyFloat(_)) | (&ty::TyUint(_), &ty::TyFloat(_)) => {\n+                                span_lint_and_then(\n+                                    cx,\n+                                    TRANSMUTE_INT_TO_FLOAT,\n+                                    e.span,\n+                                    &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n+                                    |db| {\n+                                        let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                                        let arg = if let ty::TyInt(int_ty) = from_ty.sty {\n+                                            arg.as_ty(format!(\n+                                                \"u{}\",\n+                                                int_ty\n+                                                    .bit_width()\n+                                                    .map_or_else(|| \"size\".to_string(), |v| v.to_string())\n+                                            ))\n+                                        } else {\n+                                            arg\n+                                        };\n+                                        db.span_suggestion(\n+                                            e.span,\n+                                            \"consider using\",\n+                                            format!(\"{}::from_bits({})\", to_ty, arg.to_string()),\n+                                        );\n+                                    },\n+                                )\n+                            },\n                             _ => return,\n                         };\n                     }"}, {"sha": "8d5dd3d19b4dc266c3f10188470a6362d3d501ae", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -166,11 +166,13 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n                         if let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, cx.tcx.hir.node_to_hir_id(vec.id)));\n                         if match_def_path(cx.tcx, did, &paths::VEC);\n                         then {\n-                            span_help_and_lint(cx,\n-                                               BOX_VEC,\n-                                               ast_ty.span,\n-                                               \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n-                                               \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n+                            span_help_and_lint(\n+                                cx,\n+                                BOX_VEC,\n+                                ast_ty.span,\n+                                \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n+                                \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\",\n+                            );\n                             return; // don't recurse into the type\n                         }\n                     }\n@@ -241,7 +243,7 @@ fn check_ty_rptr(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool, lt: &Lifeti\n                         // Ignore `Box<Any>` types, see #1884 for details.\n                         return;\n                     }\n-    \n+\n                     let ltopt = if lt.is_elided() {\n                         \"\".to_owned()\n                     } else {\n@@ -1730,7 +1732,7 @@ impl<'a, 'b, 'tcx: 'a + 'b> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'\n                 if !same_tys(self.cx, self.target.ty(), self.body.expr_ty(e)) {\n                     return;\n                 }\n-    \n+\n                 if match_path(ty_path, &paths::HASHMAP) {\n                     if method.name == \"new\" {\n                         self.suggestions"}, {"sha": "8203377e465f55d9634d733728c2dcb522e175ab", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n             then {\n                 let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).parameters;\n                 let should_check = if let Some(ref params) = *parameters {\n-                    !params.parenthesized && params.lifetimes.len() == 0 \n+                    !params.parenthesized && params.lifetimes.len() == 0\n                 } else {\n                     true\n                 };"}, {"sha": "eadc672e56b9f6ccd20a5d7b71d05156ec8c1d7a", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -245,7 +245,9 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     // FIXME: also check int type\n                     LitKind::Int(i, _) => println!(\"    if let LitKind::Int({}, _) = {}.node;\", i, lit_pat),\n                     LitKind::Float(..) => println!(\"    if let LitKind::Float(..) = {}.node;\", lit_pat),\n-                    LitKind::FloatUnsuffixed(_) => println!(\"    if let LitKind::FloatUnsuffixed(_) = {}.node;\", lit_pat),\n+                    LitKind::FloatUnsuffixed(_) => {\n+                        println!(\"    if let LitKind::FloatUnsuffixed(_) = {}.node;\", lit_pat)\n+                    },\n                     LitKind::ByteStr(ref vec) => {\n                         let vec_pat = self.next(\"vec\");\n                         println!(\"    if let LitKind::ByteStr(ref {}) = {}.node;\", vec_pat, lit_pat);"}, {"sha": "091261ffbec499c187e903aca0287e3eb9fb1777", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -6,7 +6,7 @@\n use rustc::hir;\n use rustc::lint::LateContext;\n use syntax::ast;\n-use utils::{is_expn_of, match_def_path, match_qpath, paths, resolve_node, opt_def_id};\n+use utils::{is_expn_of, match_def_path, match_qpath, opt_def_id, paths, resolve_node};\n \n /// Convert a hir binary operator to the corresponding `ast` type.\n pub fn binop(op: hir::BinOp_) -> ast::BinOpKind {\n@@ -48,10 +48,7 @@ pub fn range(expr: &hir::Expr) -> Option<Range> {\n     /// Find the field named `name` in the field. Always return `Some` for\n     /// convenience.\n     fn get_field<'a>(name: &str, fields: &'a [hir::Field]) -> Option<&'a hir::Expr> {\n-        let expr = &fields\n-            .iter()\n-            .find(|field| field.name.node == name)?\n-            .expr;\n+        let expr = &fields.iter().find(|field| field.name.node == name)?.expr;\n \n         Some(expr)\n     }\n@@ -72,8 +69,8 @@ pub fn range(expr: &hir::Expr) -> Option<Range> {\n                 None\n             }\n         },\n-        hir::ExprStruct(ref path, ref fields, None) => if match_qpath(path, &paths::RANGE_FROM_STD) ||\n-            match_qpath(path, &paths::RANGE_FROM)\n+        hir::ExprStruct(ref path, ref fields, None) => if match_qpath(path, &paths::RANGE_FROM_STD)\n+            || match_qpath(path, &paths::RANGE_FROM)\n         {\n             Some(Range {\n                 start: Some(get_field(\"start\", fields)?),\n@@ -198,7 +195,7 @@ pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e\n                         return Some(VecArgs::Vec(&*args));\n                     }\n                 }\n-    \n+\n                 None\n             }\n             else {"}, {"sha": "397b925a5663c9430c9e390eb98e580375425cf4", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -55,8 +55,8 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n     /// Check whether two blocks are the same.\n     pub fn eq_block(&self, left: &Block, right: &Block) -> bool {\n-        over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r)) &&\n-            both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n+        over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r))\n+            && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n     }\n \n     pub fn eq_expr(&self, left: &Expr, right: &Expr) -> bool {\n@@ -81,14 +81,14 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             },\n             (&ExprBlock(ref l), &ExprBlock(ref r)) => self.eq_block(l, r),\n             (&ExprBinary(l_op, ref ll, ref lr), &ExprBinary(r_op, ref rl, ref rr)) => {\n-                l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr) ||\n-                    swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n+                l_op.node == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                    || swap_binop(l_op.node, ll, lr).map_or(false, |(l_op, ll, lr)| {\n                         l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n                     })\n             },\n             (&ExprBreak(li, ref le), &ExprBreak(ri, ref re)) => {\n-                both(&li.ident, &ri.ident, |l, r| l.node.name.as_str() == r.node.name.as_str()) &&\n-                    both(le, re, |l, r| self.eq_expr(l, r))\n+                both(&li.ident, &ri.ident, |l, r| l.node.name.as_str() == r.node.name.as_str())\n+                    && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n             (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n             (&ExprCall(ref l_fun, ref l_args), &ExprCall(ref r_fun, ref r_args)) => {\n@@ -109,22 +109,22 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             },\n             (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n                 ls == rs && self.eq_expr(le, re) && over(la, ra, |l, r| {\n-                    self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n-                        over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n+                    self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r))\n+                        && over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n                 })\n             },\n             (&ExprMethodCall(ref l_path, _, ref l_args), &ExprMethodCall(ref r_path, _, ref r_args)) => {\n                 !self.ignore_fn && l_path == r_path && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprRepeat(ref le, ll_id), &ExprRepeat(ref re, rl_id)) => {\n-                self.eq_expr(le, re) &&\n-                    self.eq_expr(&self.cx.tcx.hir.body(ll_id).value, &self.cx.tcx.hir.body(rl_id).value)\n+                self.eq_expr(le, re)\n+                    && self.eq_expr(&self.cx.tcx.hir.body(ll_id).value, &self.cx.tcx.hir.body(rl_id).value)\n             },\n             (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n             (&ExprPath(ref l), &ExprPath(ref r)) => self.eq_qpath(l, r),\n             (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n-                self.eq_qpath(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n-                    over(lf, rf, |l, r| self.eq_field(l, r))\n+                self.eq_qpath(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r))\n+                    && over(lf, rf, |l, r| self.eq_field(l, r))\n             },\n             (&ExprTup(ref l_tup), &ExprTup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n             (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => li.node == ri.node && self.eq_expr(le, re),\n@@ -169,8 +169,8 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             },\n             (&PatKind::Ref(ref le, ref lm), &PatKind::Ref(ref re, ref rm)) => lm == rm && self.eq_pat(le, re),\n             (&PatKind::Slice(ref ls, ref li, ref le), &PatKind::Slice(ref rs, ref ri, ref re)) => {\n-                over(ls, rs, |l, r| self.eq_pat(l, r)) && over(le, re, |l, r| self.eq_pat(l, r)) &&\n-                    both(li, ri, |l, r| self.eq_pat(l, r))\n+                over(ls, rs, |l, r| self.eq_pat(l, r)) && over(le, re, |l, r| self.eq_pat(l, r))\n+                    && both(li, ri, |l, r| self.eq_pat(l, r))\n             },\n             (&PatKind::Wild, &PatKind::Wild) => true,\n             _ => false,\n@@ -190,18 +190,18 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     }\n \n     fn eq_path(&self, left: &Path, right: &Path) -> bool {\n-        left.is_global() == right.is_global() &&\n-            over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n+        left.is_global() == right.is_global()\n+            && over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n     }\n \n     fn eq_path_parameters(&self, left: &PathParameters, right: &PathParameters) -> bool {\n         if !(left.parenthesized || right.parenthesized) {\n-            over(&left.lifetimes, &right.lifetimes, |l, r| self.eq_lifetime(l, r)) &&\n-                over(&left.types, &right.types, |l, r| self.eq_ty(l, r)) &&\n-                over(&left.bindings, &right.bindings, |l, r| self.eq_type_binding(l, r))\n+            over(&left.lifetimes, &right.lifetimes, |l, r| self.eq_lifetime(l, r))\n+                && over(&left.types, &right.types, |l, r| self.eq_ty(l, r))\n+                && over(&left.bindings, &right.bindings, |l, r| self.eq_type_binding(l, r))\n         } else if left.parenthesized && right.parenthesized {\n-            over(left.inputs(), right.inputs(), |l, r| self.eq_ty(l, r)) &&\n-                both(\n+            over(left.inputs(), right.inputs(), |l, r| self.eq_ty(l, r))\n+                && both(\n                     &Some(&left.bindings[0].ty),\n                     &Some(&right.bindings[0].ty),\n                     |l, r| self.eq_ty(l, r),\n@@ -220,16 +220,16 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         match (&left.parameters, &right.parameters) {\n             (&None, &None) => true,\n             (&Some(ref l), &Some(ref r)) => self.eq_path_parameters(l, r),\n-            _ => false\n+            _ => false,\n         }\n     }\n \n     fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {\n         match (&left.node, &right.node) {\n             (&TySlice(ref l_vec), &TySlice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyArray(ref lt, ll_id), &TyArray(ref rt, rl_id)) => {\n-                self.eq_ty(lt, rt) &&\n-                    self.eq_expr(&self.cx.tcx.hir.body(ll_id).value, &self.cx.tcx.hir.body(rl_id).value)\n+                self.eq_ty(lt, rt)\n+                    && self.eq_expr(&self.cx.tcx.hir.body(ll_id).value, &self.cx.tcx.hir.body(rl_id).value)\n             },\n             (&TyPtr(ref l_mut), &TyPtr(ref r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty),\n             (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {"}, {"sha": "c557e856bf4b9469d454bbd3adc94d6ba7df4011", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -125,8 +125,8 @@ pub fn match_def_path(tcx: TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n \n     tcx.push_item_path(&mut apb, def_id);\n \n-    apb.names.len() == path.len() &&\n-        apb.names\n+    apb.names.len() == path.len()\n+        && apb.names\n             .into_iter()\n             .zip(path.iter())\n             .all(|(a, &b)| *a == *b)\n@@ -201,8 +201,8 @@ pub fn match_qpath(path: &QPath, segments: &[&str]) -> bool {\n         QPath::Resolved(_, ref path) => match_path(path, segments),\n         QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n             TyPath(ref inner_path) => {\n-                !segments.is_empty() && match_qpath(inner_path, &segments[..(segments.len() - 1)]) &&\n-                    segment.name == segments[segments.len() - 1]\n+                !segments.is_empty() && match_qpath(inner_path, &segments[..(segments.len() - 1)])\n+                    && segment.name == segments[segments.len() - 1]\n             },\n             _ => false,\n         },\n@@ -233,7 +233,6 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n \n /// Get the definition associated to a path.\n pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n-\n     let crates = cx.tcx.crates();\n     let krate = crates\n         .iter()\n@@ -269,7 +268,11 @@ pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n }\n \n pub fn const_to_u64(c: &ty::Const) -> u64 {\n-    c.val.to_const_int().expect(\"eddyb says this works\").to_u64().expect(\"see previous expect\")\n+    c.val\n+        .to_const_int()\n+        .expect(\"eddyb says this works\")\n+        .to_u64()\n+        .expect(\"see previous expect\")\n }\n \n /// Convenience function to get the `DefId` of a trait by path.\n@@ -473,10 +476,12 @@ fn trim_multiline_inner(s: Cow<str>, ignore_first: bool, ch: char) -> Cow<str> {\n         Cow::Owned(\n             s.lines()\n                 .enumerate()\n-                .map(|(i, l)| if (ignore_first && i == 0) || l.is_empty() {\n-                    l\n-                } else {\n-                    l.split_at(x).1\n+                .map(|(i, l)| {\n+                    if (ignore_first && i == 0) || l.is_empty() {\n+                        l\n+                    } else {\n+                        l.split_at(x).1\n+                    }\n                 })\n                 .collect::<Vec<_>>()\n                 .join(\"\\n\"),\n@@ -494,12 +499,13 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n     if node_id == parent_id {\n         return None;\n     }\n-    map.find(parent_id)\n-        .and_then(|node| if let Node::NodeExpr(parent) = node {\n+    map.find(parent_id).and_then(|node| {\n+        if let Node::NodeExpr(parent) = node {\n             Some(parent)\n         } else {\n             None\n-        })\n+        }\n+    })\n }\n \n pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeId) -> Option<&'tcx Block> {\n@@ -598,7 +604,9 @@ pub fn span_lint_and_sugg<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n     help: &str,\n     sugg: String,\n ) {\n-    span_lint_and_then(cx, lint, sp, msg, |db| { db.span_suggestion(sp, help, sugg); });\n+    span_lint_and_then(cx, lint, sp, msg, |db| {\n+        db.span_suggestion(sp, help, sugg);\n+    });\n }\n \n /// Create a suggestion made from several `span \u2192 replacement`.\n@@ -609,7 +617,7 @@ pub fn span_lint_and_sugg<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n /// the whole suggestion.\n pub fn multispan_sugg<I>(db: &mut DiagnosticBuilder, help_msg: String, sugg: I)\n where\n-    I: IntoIterator<Item=(Span, String)>,\n+    I: IntoIterator<Item = (Span, String)>,\n {\n     let sugg = rustc_errors::CodeSuggestion {\n         substitution_parts: sugg.into_iter()\n@@ -629,9 +637,8 @@ where\n /// Return the base type for HIR references and pointers.\n pub fn walk_ptrs_hir_ty(ty: &hir::Ty) -> &hir::Ty {\n     match ty.node {\n-        TyPtr(ref mut_ty) |\n-        TyRptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n-        _ => ty\n+        TyPtr(ref mut_ty) | TyRptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n+        _ => ty,\n     }\n }\n "}, {"sha": "c680e3eeb5b2b0e41f08002a40b1cf552c12a33b", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -267,11 +267,11 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n     /// in the direction\n     /// `dir`.\n     fn needs_paren(op: &AssocOp, other: &AssocOp, dir: Associativity) -> bool {\n-        other.precedence() < op.precedence() ||\n-            (other.precedence() == op.precedence() &&\n-                ((op != other && associativity(op) != dir) ||\n-                    (op == other && associativity(op) != Associativity::Both))) ||\n-            is_shift(op) && is_arith(other) || is_shift(other) && is_arith(op)\n+        other.precedence() < op.precedence()\n+            || (other.precedence() == op.precedence()\n+                && ((op != other && associativity(op) != dir)\n+                    || (op == other && associativity(op) != Associativity::Both)))\n+            || is_shift(op) && is_arith(other) || is_shift(other) && is_arith(op)\n     }\n \n     let lhs_paren = if let Sugg::BinOp(ref lop, _) = *lhs {\n@@ -472,11 +472,13 @@ impl<'a, 'b, 'c, T: LintContext<'c>> DiagnosticBuilderExt<'c, T> for rustc_error\n             let mut first = true;\n             let new_item = new_item\n                 .lines()\n-                .map(|l| if first {\n-                    first = false;\n-                    format!(\"{}\\n\", l)\n-                } else {\n-                    format!(\"{}{}\\n\", indent, l)\n+                .map(|l| {\n+                    if first {\n+                        first = false;\n+                        format!(\"{}\\n\", l)\n+                    } else {\n+                        format!(\"{}{}\\n\", indent, l)\n+                    }\n                 })\n                 .collect::<String>();\n "}, {"sha": "e1c226466f9522ff5d6eed7fa86c2e5fc160d1fd", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -52,7 +52,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if is_copy(cx, vec_type(cx.tables.expr_ty_adjusted(arg)));\n             then {\n                 // report the error around the `vec!` not inside `<std macros>:`\n-                let span = arg.span.ctxt().outer().expn_info().map(|info| info.call_site).expect(\"unable to get call_site\");\n+                let span = arg.span\n+                    .ctxt()\n+                    .outer()\n+                    .expn_info()\n+                    .map(|info| info.call_site)\n+                    .expect(\"unable to get call_site\");\n                 check_vec_macro(cx, &vec_args, span);\n             }\n         }"}, {"sha": "efe23bcdc47fbb37f2ee498c627ae9edf9528d2d", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -49,9 +49,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     | (_, FloatWidth::F64) => \"f64\",\n                     _ => \"f32\"\n                 };\n-                span_help_and_lint(cx, ZERO_DIVIDED_BY_ZERO, expr.span,\n+                span_help_and_lint(\n+                    cx,\n+                    ZERO_DIVIDED_BY_ZERO,\n+                    expr.span,\n                     \"constant division of 0.0 with 0.0 will always result in NaN\",\n-                    &format!(\"Consider using `std::{}::NAN` if you would like a constant representing NaN\", float_type));\n+                    &format!(\n+                        \"Consider using `std::{}::NAN` if you would like a constant representing NaN\",\n+                        float_type,\n+                    ),\n+                );\n             }\n         }\n     }"}, {"sha": "205b7d897d3d818b21d71693a2367235b4c28183", "filename": "rustfmt.toml", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -1,8 +1,6 @@\n max_width = 120\n-ideal_width = 100\n+comment_width = 100\n fn_call_width = 80\n match_block_trailing_comma = true\n-fn_args_layout = \"Block\"\n closure_block_indent_threshold = 0\n-fn_return_indent = \"WithWhereClause\"\n wrap_comments = true"}, {"sha": "8e88cc2e346c01f19966596f557cb1c797094f49", "filename": "src/driver.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -154,9 +154,7 @@ pub fn main() {\n                     .and_then(|out| String::from_utf8(out.stdout).ok())\n                     .map(|s| s.trim().to_owned())\n             })\n-            .expect(\n-                \"need to specify SYSROOT env var during clippy compilation, or use rustup or multirust\",\n-            )\n+            .expect(\"need to specify SYSROOT env var during clippy compilation, or use rustup or multirust\")\n     };\n \n     rustc_driver::in_rustc_thread(|| {\n@@ -176,7 +174,9 @@ pub fn main() {\n         let mut args: Vec<String> = if orig_args.iter().any(|s| s == \"--sysroot\") {\n             orig_args.clone()\n         } else {\n-            orig_args.clone().into_iter()\n+            orig_args\n+                .clone()\n+                .into_iter()\n                 .chain(Some(\"--sysroot\".to_owned()))\n                 .chain(Some(sys_root))\n                 .collect()\n@@ -185,8 +185,10 @@ pub fn main() {\n         // this check ensures that dependencies are built but not linted and the final\n         // crate is\n         // linted but not built\n-        let clippy_enabled = env::var(\"CLIPPY_TESTS\").ok().map_or(false, |val| val == \"true\") ||\n-            orig_args.iter().any(|s| s == \"--emit=metadata\");\n+        let clippy_enabled = env::var(\"CLIPPY_TESTS\")\n+            .ok()\n+            .map_or(false, |val| val == \"true\")\n+            || orig_args.iter().any(|s| s == \"--emit=metadata\");\n \n         if clippy_enabled {\n             args.extend_from_slice(&[\"--cfg\".to_owned(), r#\"feature=\"cargo-clippy\"\"#.to_owned()]);"}, {"sha": "10c0360a26704c65c453279af9ea139b10bec571", "filename": "src/main.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -69,8 +69,7 @@ pub fn main() {\n         .skip(2)\n         .find(|val| val.starts_with(\"--manifest-path=\"));\n \n-    let mut metadata = if let Ok(metadata) = cargo_metadata::metadata(manifest_path_arg.as_ref().map(AsRef::as_ref))\n-    {\n+    let mut metadata = if let Ok(metadata) = cargo_metadata::metadata(manifest_path_arg.as_ref().map(AsRef::as_ref)) {\n         metadata\n     } else {\n         let _ = io::stderr().write_fmt(format_args!(\"error: Could not obtain cargo metadata.\\n\"));"}, {"sha": "5ada775560e9376099edba70587e5ffa721aefc2", "filename": "tests/conf_whitelisted.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/tests%2Fconf_whitelisted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/tests%2Fconf_whitelisted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconf_whitelisted.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -1,3 +1,2 @@\n #![feature(plugin)]\n-#![plugin(clippy(conf_file=\"./tests/auxiliary/conf_whitelisted.toml\"))]\n-\n+#![plugin(clippy(conf_file = \"./tests/auxiliary/conf_whitelisted.toml\"))]"}, {"sha": "4870bd285b499b248f320538524fc5504c1e7175", "filename": "tests/dogfood.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -24,9 +24,7 @@ fn dogfood() {\n     let mut s = String::new();\n     s.push_str(\" -L target/debug/\");\n     s.push_str(\" -L target/debug/deps\");\n-    s.push_str(\n-        \" -Zextra-plugins=clippy -Ltarget_recur/debug -Dwarnings -Dclippy_pedantic -Dclippy -Dclippy_internal\",\n-    );\n+    s.push_str(\" -Zextra-plugins=clippy -Ltarget_recur/debug -Dwarnings -Dclippy_pedantic -Dclippy -Dclippy_internal\");\n     config.target_rustcflags = Some(s);\n     if let Ok(name) = var(\"TESTNAME\") {\n         config.filter = Some(name.to_owned())"}, {"sha": "f806c2c6fde244904974a43ef76472ee0ca01522", "filename": "tests/issue-825.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed589761e62735ebb803510e01bfd8b278527fb9/tests%2Fissue-825.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed589761e62735ebb803510e01bfd8b278527fb9/tests%2Fissue-825.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fissue-825.rs?ref=ed589761e62735ebb803510e01bfd8b278527fb9", "patch": "@@ -4,9 +4,9 @@\n \n // this should compile in a reasonable amount of time\n fn rust_type_id(name: &str) {\n-    if \"bool\" == &name[..] || \"uint\" == &name[..] || \"u8\" == &name[..] || \"u16\" == &name[..] || \"u32\" == &name[..] ||\n-        \"f32\" == &name[..] || \"f64\" == &name[..] || \"i8\" == &name[..] || \"i16\" == &name[..] ||\n-        \"i32\" == &name[..] || \"i64\" == &name[..] || \"Self\" == &name[..] || \"str\" == &name[..]\n+    if \"bool\" == &name[..] || \"uint\" == &name[..] || \"u8\" == &name[..] || \"u16\" == &name[..] || \"u32\" == &name[..]\n+        || \"f32\" == &name[..] || \"f64\" == &name[..] || \"i8\" == &name[..] || \"i16\" == &name[..]\n+        || \"i32\" == &name[..] || \"i64\" == &name[..] || \"Self\" == &name[..] || \"str\" == &name[..]\n     {\n         unreachable!();\n     }"}]}