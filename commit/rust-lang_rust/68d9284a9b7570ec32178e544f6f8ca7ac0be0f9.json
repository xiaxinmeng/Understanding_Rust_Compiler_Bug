{"sha": "68d9284a9b7570ec32178e544f6f8ca7ac0be0f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZDkyODRhOWI3NTcwZWMzMjE3OGU1NDRmNmY4Y2E3YWMwYmUwZjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-12T05:10:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-12T05:10:16Z"}, "message": "Auto merge of #34811 - DanielJCampbell:Expander, r=jseyfried\n\nExtended expand.rs to support alternate expansion behaviours (eg. stepwise expansion)\n\nr? nrc", "tree": {"sha": "5f544243a7c789bbefe9a0491fa27bf752d30905", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f544243a7c789bbefe9a0491fa27bf752d30905"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68d9284a9b7570ec32178e544f6f8ca7ac0be0f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68d9284a9b7570ec32178e544f6f8ca7ac0be0f9", "html_url": "https://github.com/rust-lang/rust/commit/68d9284a9b7570ec32178e544f6f8ca7ac0be0f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68d9284a9b7570ec32178e544f6f8ca7ac0be0f9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8787a12334439d47e931be26fef53381ce337c3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8787a12334439d47e931be26fef53381ce337c3a", "html_url": "https://github.com/rust-lang/rust/commit/8787a12334439d47e931be26fef53381ce337c3a"}, {"sha": "61c7569d4a88eeeec41d7b1230ad61e2408af7ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/61c7569d4a88eeeec41d7b1230ad61e2408af7ca", "html_url": "https://github.com/rust-lang/rust/commit/61c7569d4a88eeeec41d7b1230ad61e2408af7ca"}], "stats": {"total": 128, "additions": 82, "deletions": 46}, "files": [{"sha": "70b1261730b07092aca68f7cd721d75bb7a7121f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68d9284a9b7570ec32178e544f6f8ca7ac0be0f9/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d9284a9b7570ec32178e544f6f8ca7ac0be0f9/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=68d9284a9b7570ec32178e544f6f8ca7ac0be0f9", "patch": "@@ -673,13 +673,11 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n                                                       cfg,\n                                                       &mut loader);\n         syntax_ext::register_builtins(&mut ecx.syntax_env);\n-        let (ret, macro_names) = syntax::ext::expand::expand_crate(ecx,\n-                                                                   syntax_exts,\n-                                                                   krate);\n+        let ret = syntax::ext::expand::expand_crate(&mut ecx, syntax_exts, krate);\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);\n         }\n-        *sess.available_macros.borrow_mut() = macro_names;\n+        *sess.available_macros.borrow_mut() = ecx.syntax_env.names;\n         ret\n     });\n "}, {"sha": "6ba3b92483fddd8ad617a677fcece75f1f5da94a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68d9284a9b7570ec32178e544f6f8ca7ac0be0f9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d9284a9b7570ec32178e544f6f8ca7ac0be0f9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=68d9284a9b7570ec32178e544f6f8ca7ac0be0f9", "patch": "@@ -633,7 +633,7 @@ impl<'a> ExtCtxt<'a> {\n \n     /// Returns a `Folder` for deeply expanding all macros in an AST node.\n     pub fn expander<'b>(&'b mut self) -> expand::MacroExpander<'b, 'a> {\n-        expand::MacroExpander::new(self)\n+        expand::MacroExpander::new(self, false, false)\n     }\n \n     pub fn new_parser_from_tts(&self, tts: &[tokenstream::TokenTree])"}, {"sha": "031d9a2d3f46e781debb012b0325b787345ddcfb", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 79, "deletions": 41, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/68d9284a9b7570ec32178e544f6f8ca7ac0be0f9/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68d9284a9b7570ec32178e544f6f8ca7ac0be0f9/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=68d9284a9b7570ec32178e544f6f8ca7ac0be0f9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, Ident, Mac_, Name, PatKind};\n+use ast::{Block, Crate, Ident, Mac_, PatKind};\n use ast::{MacStmtStyle, Stmt, StmtKind, ItemKind};\n use ast;\n use ext::hygiene::Mark;\n@@ -29,8 +29,6 @@ use visit;\n use visit::Visitor;\n use std_inject;\n \n-use std::collections::HashSet;\n-\n // A trait for AST nodes and AST node lists into which macro invocations may expand.\n trait MacroGenerable: Sized {\n     // Expand the given MacResult using its appropriate `make_*` method.\n@@ -218,8 +216,7 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     }\n                 });\n \n-                // DON'T mark before expansion.\n-                fld.cx.insert_macro(ast::MacroDef {\n+                let def = ast::MacroDef {\n                     ident: ident,\n                     id: ast::DUMMY_NODE_ID,\n                     span: call_site,\n@@ -229,10 +226,30 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     export: attr::contains_name(&attrs, \"macro_export\"),\n                     allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n                     attrs: attrs,\n-                });\n+                };\n \n-                // macro_rules! has a side effect but expands to nothing.\n-                Some(Box::new(MacroScopePlaceholder))\n+                fld.cx.insert_macro(def.clone());\n+\n+                // macro_rules! has a side effect, but expands to nothing.\n+                // If keep_macs is true, expands to a MacEager::items instead.\n+                if fld.keep_macs {\n+                    Some(MacEager::items(SmallVector::one(P(ast::Item {\n+                        ident: def.ident,\n+                        attrs: def.attrs.clone(),\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: ast::ItemKind::Mac(ast::Mac {\n+                            span: def.span,\n+                            node: ast::Mac_ {\n+                                path: path.clone(),\n+                                tts: def.body.clone(),\n+                            }\n+                        }),\n+                        vis: ast::Visibility::Inherited,\n+                        span: def.span,\n+                    }))))\n+                } else {\n+                    Some(Box::new(MacroScopePlaceholder))\n+                }\n             }\n \n             MultiDecorator(..) | MultiModifier(..) => {\n@@ -260,7 +277,13 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n     let marked = expanded.fold_with(&mut Marker { mark: mark, expn_id: Some(fld.cx.backtrace()) });\n     let configured = marked.fold_with(&mut fld.strip_unconfigured());\n     fld.load_macros(&configured);\n-    let fully_expanded = configured.fold_with(fld);\n+\n+    let fully_expanded = if fld.single_step {\n+        configured\n+    } else {\n+        configured.fold_with(fld)\n+    };\n+\n     fld.cx.bt_pop();\n     fully_expanded\n }\n@@ -490,11 +513,19 @@ pub fn expand_type(t: P<ast::Ty>, fld: &mut MacroExpander) -> P<ast::Ty> {\n /// A tree-folder that performs macro expansion\n pub struct MacroExpander<'a, 'b:'a> {\n     pub cx: &'a mut ExtCtxt<'b>,\n+    pub single_step: bool,\n+    pub keep_macs: bool,\n }\n \n impl<'a, 'b> MacroExpander<'a, 'b> {\n-    pub fn new(cx: &'a mut ExtCtxt<'b>) -> MacroExpander<'a, 'b> {\n-        MacroExpander { cx: cx }\n+    pub fn new(cx: &'a mut ExtCtxt<'b>,\n+               single_step: bool,\n+               keep_macs: bool) -> MacroExpander<'a, 'b> {\n+        MacroExpander {\n+            cx: cx,\n+            single_step: single_step,\n+            keep_macs: keep_macs\n+        }\n     }\n \n     fn strip_unconfigured(&mut self) -> StripUnconfigured {\n@@ -672,38 +703,45 @@ impl<'feat> ExpansionConfig<'feat> {\n     }\n }\n \n-pub fn expand_crate(mut cx: ExtCtxt,\n+pub fn expand_crate(cx: &mut ExtCtxt,\n                     user_exts: Vec<NamedSyntaxExtension>,\n-                    mut c: Crate) -> (Crate, HashSet<Name>) {\n+                    c: Crate) -> Crate {\n+    let mut expander = MacroExpander::new(cx, false, false);\n+    expand_crate_with_expander(&mut expander, user_exts, c)\n+}\n+\n+// Expands crate using supplied MacroExpander - allows for\n+// non-standard expansion behaviour (e.g. step-wise).\n+pub fn expand_crate_with_expander(expander: &mut MacroExpander,\n+                                  user_exts: Vec<NamedSyntaxExtension>,\n+                                  mut c: Crate) -> Crate {\n     if std_inject::no_core(&c) {\n-        cx.crate_root = None;\n+        expander.cx.crate_root = None;\n     } else if std_inject::no_std(&c) {\n-        cx.crate_root = Some(\"core\");\n+        expander.cx.crate_root = Some(\"core\");\n     } else {\n-        cx.crate_root = Some(\"std\");\n+        expander.cx.crate_root = Some(\"std\");\n     }\n-    let ret = {\n-        let mut expander = MacroExpander::new(&mut cx);\n \n-        for (name, extension) in user_exts {\n-            expander.cx.syntax_env.insert(name, extension);\n-        }\n+    // User extensions must be added before expander.load_macros is called,\n+    // so that macros from external crates shadow user defined extensions.\n+    for (name, extension) in user_exts {\n+        expander.cx.syntax_env.insert(name, extension);\n+    }\n \n-        let items = SmallVector::many(c.module.items);\n-        expander.load_macros(&items);\n-        c.module.items = items.into();\n+    let items = SmallVector::many(c.module.items);\n+    expander.load_macros(&items);\n+    c.module.items = items.into();\n \n-        let err_count = cx.parse_sess.span_diagnostic.err_count();\n-        let mut ret = expander.fold_crate(c);\n-        ret.exported_macros = expander.cx.exported_macros.clone();\n+    let err_count = expander.cx.parse_sess.span_diagnostic.err_count();\n+    let mut ret = expander.fold_crate(c);\n+    ret.exported_macros = expander.cx.exported_macros.clone();\n \n-        if cx.parse_sess.span_diagnostic.err_count() > err_count {\n-            cx.parse_sess.span_diagnostic.abort_if_errors();\n-        }\n+    if expander.cx.parse_sess.span_diagnostic.err_count() > err_count {\n+        expander.cx.parse_sess.span_diagnostic.abort_if_errors();\n+    }\n \n-        ret\n-    };\n-    return (ret, cx.syntax_env.names);\n+    ret\n }\n \n // A Marker adds the given mark to the syntax context and\n@@ -779,8 +817,8 @@ mod tests {\n             Vec::new(), &sess).unwrap();\n         // should fail:\n         let mut loader = DummyMacroLoader;\n-        let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut loader);\n-        expand_crate(ecx, vec![], crate_ast);\n+        let mut ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut loader);\n+        expand_crate(&mut ecx, vec![], crate_ast);\n     }\n \n     // make sure that macros can't escape modules\n@@ -794,8 +832,8 @@ mod tests {\n             src,\n             Vec::new(), &sess).unwrap();\n         let mut loader = DummyMacroLoader;\n-        let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut loader);\n-        expand_crate(ecx, vec![], crate_ast);\n+        let mut ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut loader);\n+        expand_crate(&mut ecx, vec![], crate_ast);\n     }\n \n     // macro_use modules should allow macros to escape\n@@ -808,17 +846,17 @@ mod tests {\n             src,\n             Vec::new(), &sess).unwrap();\n         let mut loader = DummyMacroLoader;\n-        let ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut loader);\n-        expand_crate(ecx, vec![], crate_ast);\n+        let mut ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut loader);\n+        expand_crate(&mut ecx, vec![], crate_ast);\n     }\n \n     fn expand_crate_str(crate_str: String) -> ast::Crate {\n         let ps = parse::ParseSess::new();\n         let crate_ast = panictry!(string_to_parser(&ps, crate_str).parse_crate_mod());\n         // the cfg argument actually does matter, here...\n         let mut loader = DummyMacroLoader;\n-        let ecx = ExtCtxt::new(&ps, vec![], test_ecfg(), &mut loader);\n-        expand_crate(ecx, vec![], crate_ast).0\n+        let mut ecx = ExtCtxt::new(&ps, vec![], test_ecfg(), &mut loader);\n+        expand_crate(&mut ecx, vec![], crate_ast)\n     }\n \n     #[test] fn macro_tokens_should_match(){"}]}