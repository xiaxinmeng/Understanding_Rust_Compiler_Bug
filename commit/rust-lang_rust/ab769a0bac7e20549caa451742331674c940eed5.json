{"sha": "ab769a0bac7e20549caa451742331674c940eed5", "node_id": "C_kwDOAAsO6NoAKGFiNzY5YTBiYWM3ZTIwNTQ5Y2FhNDUxNzQyMzMxNjc0Yzk0MGVlZDU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-28T04:20:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-28T04:20:19Z"}, "message": "Rollup merge of #107344 - compiler-errors:new-solver-tweaks, r=lcnr\n\nMinor tweaks in the new solver\n\n1. `InferCtxt::probe` is not needed in `compute_subtype_goal` and `compute_well_formed_goal`.\n2. Add a handful of comments.\n3. Add a micro-optimization in `consider_assumption` where we check the def-ids of the assumption and goal match before instantiating any binders.\n\nr? ``@lcnr``", "tree": {"sha": "780a847a7957cbcac2a7d57c204f4d7f0beee0e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/780a847a7957cbcac2a7d57c204f4d7f0beee0e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab769a0bac7e20549caa451742331674c940eed5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj1KKDCRBK7hj4Ov3rIwAAtmYIAIqeKUx6JaS8Z4UQxvRAEEZz\nrX1v9WBlaqsHVb2aDgBy3RVNmH/NLyt9kTG0RcxZRzTmrFRx4eP+FEqycuMQPp8I\nIWYbT1rHFvSPnDNejP9kFCai2uMojHZBhBESEUEZzjHTyBNiMwvP4HiTt9t5067Y\njqN5fw+mO6CYHFsHQXAVTA8NMSi25qLfeondpIBkdnB1zgwUZfFzxMHibHek66N3\nfn+IbCMG7T5FpiZBhYsL1L4NB0CDtYMRaNF8x4LOjN70o3dt+JmEtEFPQ1RDu1FJ\nw2Ol5H/Zv3WH5hMfFebB9T+dp12McnntAEsjd9TNyYnrDDgqJLsezkqtdBVNzjc=\n=XdLI\n-----END PGP SIGNATURE-----\n", "payload": "tree 780a847a7957cbcac2a7d57c204f4d7f0beee0e1\nparent a5caa989c94f0a0ca3f977b013a1a7c2c2c5c3a0\nparent 8a0b2156d5b899f740f128dfeb6090e0f408d33b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1674879619 +0100\ncommitter GitHub <noreply@github.com> 1674879619 +0100\n\nRollup merge of #107344 - compiler-errors:new-solver-tweaks, r=lcnr\n\nMinor tweaks in the new solver\n\n1. `InferCtxt::probe` is not needed in `compute_subtype_goal` and `compute_well_formed_goal`.\n2. Add a handful of comments.\n3. Add a micro-optimization in `consider_assumption` where we check the def-ids of the assumption and goal match before instantiating any binders.\n\nr? ``@lcnr``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab769a0bac7e20549caa451742331674c940eed5", "html_url": "https://github.com/rust-lang/rust/commit/ab769a0bac7e20549caa451742331674c940eed5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab769a0bac7e20549caa451742331674c940eed5/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5caa989c94f0a0ca3f977b013a1a7c2c2c5c3a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5caa989c94f0a0ca3f977b013a1a7c2c2c5c3a0", "html_url": "https://github.com/rust-lang/rust/commit/a5caa989c94f0a0ca3f977b013a1a7c2c2c5c3a0"}, {"sha": "8a0b2156d5b899f740f128dfeb6090e0f408d33b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a0b2156d5b899f740f128dfeb6090e0f408d33b", "html_url": "https://github.com/rust-lang/rust/commit/8a0b2156d5b899f740f128dfeb6090e0f408d33b"}], "stats": {"total": 77, "additions": 54, "deletions": 23}, "files": [{"sha": "f7cf81da497529af14920277b0bb892aa9323ae6", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ab769a0bac7e20549caa451742331674c940eed5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab769a0bac7e20549caa451742331674c940eed5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=ab769a0bac7e20549caa451742331674c940eed5", "patch": "@@ -1,6 +1,8 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n use super::infcx_ext::InferCtxtExt;\n+#[cfg(doc)]\n+use super::trait_goals::structural_traits::*;\n use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n@@ -98,52 +100,75 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n         assumption: ty::Predicate<'tcx>,\n     ) -> QueryResult<'tcx>;\n \n+    // A type implements an `auto trait` if its components do as well. These components\n+    // are given by built-in rules from [`instantiate_constituent_tys_for_auto_trait`].\n     fn consider_auto_trait_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A trait alias holds if the RHS traits and `where` clauses hold.\n     fn consider_trait_alias_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A type is `Copy` or `Clone` if its components are `Sized`. These components\n+    // are given by built-in rules from [`instantiate_constituent_tys_for_sized_trait`].\n     fn consider_builtin_sized_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A type is `Copy` or `Clone` if its components are `Copy` or `Clone`. These\n+    // components are given by built-in rules from [`instantiate_constituent_tys_for_copy_clone_trait`].\n     fn consider_builtin_copy_clone_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A type is `PointerSized` if we can compute its layout, and that layout\n+    // matches the layout of `usize`.\n     fn consider_builtin_pointer_sized_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A callable type (a closure, fn def, or fn ptr) is known to implement the `Fn<A>`\n+    // family of traits where `A` is given by the signature of the type.\n     fn consider_builtin_fn_trait_candidates(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx>;\n \n+    // `Tuple` is implemented if the `Self` type is a tuple.\n     fn consider_builtin_tuple_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // `Pointee` is always implemented.\n+    //\n+    // See the projection implementation for the `Metadata` types for all of\n+    // the built-in types. For structs, the metadata type is given by the struct\n+    // tail.\n     fn consider_builtin_pointee_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A generator (that comes from an `async` desugaring) is known to implement\n+    // `Future<Output = O>`, where `O` is given by the generator's return type\n+    // that was computed during type-checking.\n     fn consider_builtin_future_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A generator (that doesn't come from an `async` desugaring) is known to\n+    // implement `Generator<R, Yield = Y, Return = O>`, given the resume, yield,\n+    // and return types of the generator computed during type-checking.\n     fn consider_builtin_generator_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,"}, {"sha": "e240dd5a2257a062f2b8e117e104c7a34b952f79", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ab769a0bac7e20549caa451742331674c940eed5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab769a0bac7e20549caa451742331674c940eed5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=ab769a0bac7e20549caa451742331674c940eed5", "patch": "@@ -335,15 +335,13 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             // That won't actually reflect in the query response, so it seems moot.\n             self.make_canonical_response(Certainty::AMBIGUOUS)\n         } else {\n-            self.infcx.probe(|_| {\n-                let InferOk { value: (), obligations } = self\n-                    .infcx\n-                    .at(&ObligationCause::dummy(), goal.param_env)\n-                    .sub(goal.predicate.a, goal.predicate.b)?;\n-                self.evaluate_all_and_make_canonical_response(\n-                    obligations.into_iter().map(|pred| pred.into()).collect(),\n-                )\n-            })\n+            let InferOk { value: (), obligations } = self\n+                .infcx\n+                .at(&ObligationCause::dummy(), goal.param_env)\n+                .sub(goal.predicate.a, goal.predicate.b)?;\n+            self.evaluate_all_and_make_canonical_response(\n+                obligations.into_iter().map(|pred| pred.into()).collect(),\n+            )\n         }\n     }\n \n@@ -376,22 +374,22 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         &mut self,\n         goal: Goal<'tcx, ty::GenericArg<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        self.infcx.probe(|_| {\n-            match crate::traits::wf::unnormalized_obligations(\n-                self.infcx,\n-                goal.param_env,\n-                goal.predicate,\n-            ) {\n-                Some(obligations) => self.evaluate_all_and_make_canonical_response(\n-                    obligations.into_iter().map(|o| o.into()).collect(),\n-                ),\n-                None => self.make_canonical_response(Certainty::AMBIGUOUS),\n-            }\n-        })\n+        match crate::traits::wf::unnormalized_obligations(\n+            self.infcx,\n+            goal.param_env,\n+            goal.predicate,\n+        ) {\n+            Some(obligations) => self.evaluate_all_and_make_canonical_response(\n+                obligations.into_iter().map(|o| o.into()).collect(),\n+            ),\n+            None => self.make_canonical_response(Certainty::AMBIGUOUS),\n+        }\n     }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    // Recursively evaluates a list of goals to completion, returning the certainty\n+    // of all of the goals.\n     fn evaluate_all(\n         &mut self,\n         mut goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n@@ -428,6 +426,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         })\n     }\n \n+    // Recursively evaluates a list of goals to completion, making a query response.\n+    //\n+    // This is just a convenient way of calling [`EvalCtxt::evaluate_all`],\n+    // then [`EvalCtxt::make_canonical_response`].\n     fn evaluate_all_and_make_canonical_response(\n         &mut self,\n         goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,"}, {"sha": "638efaa2ba5d2f388a4ddd432ccc68bf0f0812ad", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab769a0bac7e20549caa451742331674c940eed5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab769a0bac7e20549caa451742331674c940eed5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=ab769a0bac7e20549caa451742331674c940eed5", "patch": "@@ -296,7 +296,9 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n     ) -> QueryResult<'tcx> {\n-        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred() {\n+        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n+            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n+        {\n             ecx.infcx.probe(|_| {\n                 let assumption_projection_pred =\n                     ecx.infcx.instantiate_bound_vars_with_infer(poly_projection_pred);"}, {"sha": "45b6a5f4ec578b3ce19b4c9f60a03c9649fc88b5", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab769a0bac7e20549caa451742331674c940eed5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab769a0bac7e20549caa451742331674c940eed5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=ab769a0bac7e20549caa451742331674c940eed5", "patch": "@@ -65,7 +65,9 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n     ) -> QueryResult<'tcx> {\n-        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred() {\n+        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n+            && poly_trait_pred.def_id() == goal.predicate.def_id()\n+        {\n             // FIXME: Constness and polarity\n             ecx.infcx.probe(|_| {\n                 let assumption_trait_pred ="}]}