{"sha": "61ed2cfb5516f76487509766b1054275f1340f70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZWQyY2ZiNTUxNmY3NjQ4NzUwOTc2NmIxMDU0Mjc1ZjEzNDBmNzA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-14T01:48:47Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-24T21:21:57Z"}, "message": "Remove even more of std::io\n\nBig fish fried here:\n\n    extra::json\n    most of the compiler\n    extra::io_util removed\n    extra::fileinput removed\n\nFish left to fry\n\n    extra::ebml", "tree": {"sha": "815c604da80638dfc659220ee9f697b074954f47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/815c604da80638dfc659220ee9f697b074954f47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61ed2cfb5516f76487509766b1054275f1340f70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61ed2cfb5516f76487509766b1054275f1340f70", "html_url": "https://github.com/rust-lang/rust/commit/61ed2cfb5516f76487509766b1054275f1340f70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61ed2cfb5516f76487509766b1054275f1340f70/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "html_url": "https://github.com/rust-lang/rust/commit/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be"}], "stats": {"total": 2944, "additions": 916, "deletions": 2028}, "files": [{"sha": "4ae9ad81daff6220aac720ec12e00be33db86f15", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -21,7 +21,10 @@ use util;\n use util::logv;\n \n use std::cell::Cell;\n-use std::io;\n+use std::rt::io;\n+use std::rt::io::Writer;\n+use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::file::FileInfo;\n use std::os;\n use std::str;\n use std::task::{spawn_sched, SingleThreaded};\n@@ -60,7 +63,7 @@ pub fn run(config: config, testfile: ~str) {\n pub fn run_metrics(config: config, testfile: ~str, mm: &mut MetricMap) {\n     if config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n-        io::stdout().write_str(\"\\n\\n\");\n+        print!(\"\\n\\n\");\n     }\n     let testfile = Path::new(testfile);\n     debug!(\"running {}\", testfile.display());\n@@ -170,7 +173,9 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let rounds =\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n-    let mut srcs = ~[io::read_whole_file_str(testfile).unwrap()];\n+    let src = testfile.open_reader(io::Open).read_to_end();\n+    let src = str::from_utf8_owned(src);\n+    let mut srcs = ~[src];\n \n     let mut round = 0;\n     while round < rounds {\n@@ -190,7 +195,8 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let mut expected = match props.pp_exact {\n         Some(ref file) => {\n             let filepath = testfile.dir_path().join(file);\n-            io::read_whole_file_str(&filepath).unwrap()\n+            let s = filepath.open_reader(io::Open).read_to_end();\n+            str::from_utf8_owned(s)\n           }\n           None => { srcs[srcs.len() - 2u].clone() }\n         };\n@@ -228,8 +234,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     fn compare_source(expected: &str, actual: &str) {\n         if expected != actual {\n             error(~\"pretty-printed source does not match expected source\");\n-            let msg =\n-                format!(\"\\n\\\n+            println!(\"\\n\\\n expected:\\n\\\n ------------------------------------------\\n\\\n {}\\n\\\n@@ -240,7 +245,6 @@ actual:\\n\\\n ------------------------------------------\\n\\\n \\n\",\n                      expected, actual);\n-            io::stdout().write_str(msg);\n             fail!();\n         }\n     }\n@@ -741,9 +745,7 @@ fn dump_output(config: &config, testfile: &Path, out: &str, err: &str) {\n fn dump_output_file(config: &config, testfile: &Path,\n                     out: &str, extension: &str) {\n     let outfile = make_out_name(config, testfile, extension);\n-    let writer =\n-        io::file_writer(&outfile, [io::Create, io::Truncate]).unwrap();\n-    writer.write_str(out);\n+    outfile.open_writer(io::CreateOrTruncate).write(out.as_bytes());\n }\n \n fn make_out_name(config: &config, testfile: &Path, extension: &str) -> Path {\n@@ -771,24 +773,20 @@ fn output_base_name(config: &config, testfile: &Path) -> Path {\n \n fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n     if config.verbose {\n-        let sep1 = format!(\"------{}------------------------------\", \"stdout\");\n-        let sep2 = format!(\"------{}------------------------------\", \"stderr\");\n-        let sep3 = ~\"------------------------------------------\";\n-        io::stdout().write_line(sep1);\n-        io::stdout().write_line(out);\n-        io::stdout().write_line(sep2);\n-        io::stdout().write_line(err);\n-        io::stdout().write_line(sep3);\n+        println!(\"------{}------------------------------\", \"stdout\");\n+        println!(\"{}\", out);\n+        println!(\"------{}------------------------------\", \"stderr\");\n+        println!(\"{}\", err);\n+        println!(\"------------------------------------------\");\n     }\n }\n \n-fn error(err: ~str) { io::stdout().write_line(format!(\"\\nerror: {}\", err)); }\n+fn error(err: ~str) { println!(\"\\nerror: {}\", err); }\n \n fn fatal(err: ~str) -> ! { error(err); fail!(); }\n \n fn fatal_ProcRes(err: ~str, ProcRes: &ProcRes) -> ! {\n-    let msg =\n-        format!(\"\\n\\\n+    print!(\"\\n\\\n error: {}\\n\\\n command: {}\\n\\\n stdout:\\n\\\n@@ -801,7 +799,6 @@ stderr:\\n\\\n ------------------------------------------\\n\\\n \\n\",\n              err, ProcRes.cmdline, ProcRes.stdout, ProcRes.stderr);\n-    io::stdout().write_str(msg);\n     fail!();\n }\n \n@@ -821,9 +818,9 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n         ~[(~\"\",~\"\")], Some(~\"\"));\n \n     if config.verbose {\n-        io::stdout().write_str(format!(\"push ({}) {} {} {}\",\n+        println!(\"push ({}) {} {} {}\",\n             config.target, args.prog,\n-            copy_result.out, copy_result.err));\n+            copy_result.out, copy_result.err);\n     }\n \n     logv(config, format!(\"executing ({}) {}\", config.target, cmdline));\n@@ -913,9 +910,9 @@ fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n                 ~[(~\"\",~\"\")], Some(~\"\"));\n \n             if config.verbose {\n-                io::stdout().write_str(format!(\"push ({}) {} {} {}\",\n+                println!(\"push ({}) {} {} {}\",\n                     config.target, file.display(),\n-                    copy_result.out, copy_result.err));\n+                    copy_result.out, copy_result.err);\n             }\n         }\n     }\n@@ -999,7 +996,8 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n \n \n fn count_extracted_lines(p: &Path) -> uint {\n-    let x = io::read_whole_file_str(&p.with_extension(\"ll\")).unwrap();\n+    let x = p.with_extension(\"ll\").open_reader(io::Open).read_to_end();\n+    let x = str::from_utf8_owned(x);\n     x.line_iter().len()\n }\n "}, {"sha": "ae4a25b80084c20d9887be0483c62675647f3edf", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -10,7 +10,6 @@\n \n use common::config;\n \n-use std::io;\n use std::os::getenv;\n \n /// Conversion table from triple OS name to Rust SYSNAME\n@@ -64,5 +63,5 @@ pub fn path_div() -> ~str { ~\";\" }\n \n pub fn logv(config: &config, s: ~str) {\n     debug!(\"{}\", s);\n-    if config.verbose { io::println(s); }\n+    if config.verbose { println(s); }\n }"}, {"sha": "dc5e11dabdf6822080a5dae22ebbf60a72905f81", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -56,15 +56,15 @@ def scrub(b):\n d.write(\"extern mod extra;\\n\")\n d.write(\"extern mod run_pass_stage2;\\n\")\n d.write(\"use run_pass_stage2::*;\\n\")\n-d.write(\"use std::io::WriterUtil;\\n\");\n-d.write(\"use std::io;\\n\");\n+d.write(\"use std::rt::io;\\n\");\n+d.write(\"use std::rt::io::Writer;\\n\");\n d.write(\"fn main() {\\n\");\n-d.write(\"    let out = io::stdout();\\n\");\n+d.write(\"    let mut out = io::stdout();\\n\");\n i = 0\n for t in stage2_tests:\n     p = os.path.join(\"test\", \"run-pass\", t)\n     p = p.replace(\"\\\\\", \"\\\\\\\\\")\n-    d.write(\"    out.write_str(\\\"run-pass [stage2]: %s\\\\n\\\");\\n\" % p)\n+    d.write(\"    out.write(\\\"run-pass [stage2]: %s\\\\n\\\".as_bytes());\\n\" % p)\n     d.write(\"    t_%d::main();\\n\" % i)\n     i += 1\n d.write(\"}\\n\")"}, {"sha": "3ea164fb456f86d7ac1d875193133bf6329773f3", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -45,7 +45,6 @@ pub use std::os;\n // Utility modules\n \n pub mod c_vec;\n-pub mod io_util;\n \n // Concurrency\n \n@@ -104,7 +103,6 @@ pub mod rational;\n pub mod complex;\n pub mod stats;\n pub mod semver;\n-pub mod fileinput;\n pub mod flate;\n pub mod hex;\n pub mod uuid;"}, {"sha": "49072dab6d025c76ada29125361f0d86affecf8e", "filename": "src/libextra/fileinput.rs", "status": "removed", "additions": 0, "deletions": 629, "changes": 629, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -1,629 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-A library for iterating through the lines in a series of\n-files. Very similar to [the Python module of the same\n-name](http://docs.python.org/3.3/library/fileinput.html).\n-\n-It allows the programmer to automatically take filenames from the\n-command line arguments (via `input` and `input_state`), as well as\n-specify them as a vector directly (`input_vec` and\n-`input_vec_state`). The files are opened as necessary, so any files\n-that can't be opened only cause an error when reached in the\n-iteration.\n-\n-On the command line, `stdin` is represented by a filename of `-` (a\n-single hyphen) and in the functions that take a vector directly\n-(e.g. `input_vec`) it is represented by `None`. Note `stdin` is *not*\n-reset once it has been finished, so attempting to iterate on `[None,\n-None]` will only take input once unless `io::stdin().seek(0, SeekSet)`\n-is called between.\n-\n-The `make_path_option_vec` function handles converting a list of file paths as\n-strings to the appropriate format, including the (optional) conversion\n-of `\"-\"` to `stdin`.\n-\n-# Basic\n-\n-In many cases, one can use the `input_*` functions without having\n-to handle any `FileInput` structs. E.g. a simple `cat` program\n-\n-    for input |line| {\n-        io::println(line)\n-    }\n-\n-or a program that numbers lines after concatenating two files\n-\n-    for input_vec_state(make_path_option_vec([~\"a.txt\", ~\"b.txt\"])) |line, state| {\n-        io::println(format!(\"{}: %s\", state.line_num,\n-                                   line));\n-    }\n-\n-The two `input_vec*` functions take a vec of file names (where empty\n-means read from `stdin`), the other two functions use the command line\n-arguments.\n-\n-# Advanced\n-\n-For more complicated uses (e.g. if one needs to pause iteration and\n-resume it later), a `FileInput` instance can be constructed via the\n-`from_vec`, `from_vec_raw` and `from_args` functions.\n-\n-Once created, the `each_line` (from the `std::io::ReaderUtil` trait)\n-and `each_line_state` methods allow one to iterate on the lines; the\n-latter provides more information about the position within the\n-iteration to the caller.\n-\n-It is possible (and safe) to skip lines and files using the\n-`read_line` and `next_file` methods. Also, `FileInput` implements\n-`std::io::Reader`, and the state will be updated correctly while\n-using any of those methods.\n-\n-E.g. the following program reads until an empty line, pauses for user\n-input, skips the current file and then numbers the remaining lines\n-(where the numbers are from the start of each file, rather than the\n-total line count).\n-\n-    let input = FileInput::from_vec(pathify([~\"a.txt\", ~\"b.txt\", ~\"c.txt\"],\n-                                             true));\n-\n-    for input.each_line |line| {\n-        if line.is_empty() {\n-            break\n-        }\n-        io::println(line);\n-    }\n-\n-    io::println(\"Continue?\");\n-\n-    if io::stdin().read_line() == ~\"yes\" {\n-        input.next_file(); // skip!\n-\n-        for input.each_line_state |line, state| {\n-           io::println(format!(\"{}: %s\", state.line_num_file,\n-                                      line))\n-        }\n-    }\n-*/\n-\n-#[allow(missing_doc)];\n-\n-\n-use std::io::ReaderUtil;\n-use std::io;\n-use std::os;\n-\n-/**\n-A summary of the internal state of a `FileInput` object. `line_num`\n-and `line_num_file` represent the number of lines read in total and in\n-the current file respectively. `current_path` is `None` if the current\n-file is `stdin`.\n-*/\n-#[deriving(Clone)]\n-pub struct FileInputState {\n-    current_path: Option<Path>,\n-    line_num: uint,\n-    line_num_file: uint\n-}\n-\n-impl FileInputState {\n-    fn is_stdin(&self) -> bool {\n-        self.current_path.is_none()\n-    }\n-\n-    fn is_first_line(&self) -> bool {\n-        self.line_num_file == 1\n-    }\n-}\n-\n-struct FileInput_ {\n-    /**\n-    `Some(path)` is the file represented by `path`, `None` is\n-    `stdin`. Consumed as the files are read.\n-    */\n-    files: ~[Option<Path>],\n-    /**\n-    The current file: `Some(r)` for an open file, `None` before\n-    starting and after reading everything.\n-    */\n-    current_reader: Option<@io::Reader>,\n-    state: FileInputState,\n-\n-    /**\n-    Used to keep track of whether we need to insert the newline at the\n-    end of a file that is missing it, which is needed to separate the\n-    last and first lines.\n-    */\n-    previous_was_newline: bool\n-}\n-\n-\n-// FIXME #5723: remove this when Reader has &mut self.\n-// Removing it would mean giving read_byte in the Reader impl for\n-// FileInput &mut self, which in turn means giving most of the\n-// io::Reader trait methods &mut self. That can't be done right now\n-// because of io::with_bytes_reader and #5723.\n-// Should be removable via\n-// \"self.fi\" -> \"self.\" and renaming FileInput_. Documentation above\n-// will likely have to be updated to use `let mut in = ...`.\n-pub struct FileInput  {\n-    priv fi: @mut FileInput_\n-}\n-\n-impl FileInput {\n-    /**\n-    Create a `FileInput` object from a vec of files. An empty\n-    vec means lines are read from `stdin` (use `from_vec_raw` to stop\n-    this behaviour). Any occurrence of `None` represents `stdin`.\n-    */\n-    pub fn from_vec(files: ~[Option<Path>]) -> FileInput {\n-        FileInput::from_vec_raw(\n-            if files.is_empty() {\n-                ~[None]\n-            } else {\n-                files\n-            })\n-    }\n-\n-    /**\n-    Identical to `from_vec`, but an empty `files` vec stays\n-    empty. (`None` is `stdin`.)\n-    */\n-    pub fn from_vec_raw(files: ~[Option<Path>])\n-                                         -> FileInput {\n-        FileInput{\n-            fi: @mut FileInput_ {\n-                files: files,\n-                current_reader: None,\n-                state: FileInputState {\n-                    current_path: None,\n-                    line_num: 0,\n-                    line_num_file: 0\n-                },\n-                // there was no previous unended line\n-                previous_was_newline: true\n-            }\n-        }\n-    }\n-\n-    /**\n-    Create a `FileInput` object from the command line\n-    arguments. `\"-\"` represents `stdin`.\n-    */\n-    pub fn from_args() -> FileInput {\n-        let args = os::args();\n-        let pathed = make_path_option_vec(args.tail(), true);\n-        FileInput::from_vec(pathed)\n-    }\n-\n-    fn current_file_eof(&self) -> bool {\n-        match self.fi.current_reader {\n-            None => false,\n-            Some(r) => r.eof()\n-        }\n-    }\n-\n-    /**\n-    Skip to the next file in the queue. Can `fail` when opening\n-    a file.\n-\n-    Returns `false` if there is no more files, and `true` when it\n-    successfully opens the next file.\n-    */\n-\n-    pub fn next_file(&self) -> bool {\n-        // No more files\n-\n-        if self.fi.files.is_empty() {\n-            self.fi.current_reader = None;\n-            return false;\n-        }\n-\n-        let path_option = self.fi.files.shift();\n-        let file = match path_option {\n-            None => io::stdin(),\n-            Some(ref path) => io::file_reader(path).unwrap()\n-        };\n-\n-        self.fi.current_reader = Some(file);\n-        self.fi.state.current_path = path_option;\n-        self.fi.state.line_num_file = 0;\n-        true\n-    }\n-\n-    /**\n-    Attempt to open the next file if there is none currently open,\n-    or if the current one is EOF'd.\n-\n-    Returns `true` if it had to move to the next file and did\n-    so successfully.\n-    */\n-    fn next_file_if_eof(&self) -> bool {\n-        match self.fi.current_reader {\n-            None => self.next_file(),\n-            Some(r) => {\n-                if r.eof() {\n-                    self.next_file()\n-                } else {\n-                    false\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-    Apply `f` to each line successively, along with some state\n-    (line numbers and file names, see documentation for\n-    `FileInputState`). Otherwise identical to `lines_each`.\n-    */\n-    pub fn each_line_state(&self,\n-                            f: &fn(&str, FileInputState) -> bool) -> bool {\n-         self.each_line(|line| f(line, self.fi.state.clone()))\n-    }\n-\n-\n-    /**\n-    Retrieve the current `FileInputState` information.\n-    */\n-    pub fn state(&self) -> FileInputState {\n-        self.fi.state.clone()\n-    }\n-}\n-\n-impl io::Reader for FileInput {\n-    fn read_byte(&self) -> int {\n-        loop {\n-            let stepped = self.next_file_if_eof();\n-\n-            // if we moved to the next file, and the previous\n-            // character wasn't \\n, then there is an unfinished line\n-            // from the previous file. This library models\n-            // line-by-line processing and the trailing line of the\n-            // previous file and the leading of the current file\n-            // should be considered different, so we need to insert a\n-            // fake line separator\n-            if stepped && !self.fi.previous_was_newline {\n-                self.fi.state.line_num += 1;\n-                self.fi.state.line_num_file += 1;\n-                self.fi.previous_was_newline = true;\n-                return '\\n' as int;\n-            }\n-\n-            match self.fi.current_reader {\n-                None => return -1,\n-                Some(r) => {\n-                    let b = r.read_byte();\n-\n-                    if b < 0 {\n-                        continue;\n-                    }\n-\n-                    if b == '\\n' as int {\n-                        self.fi.state.line_num += 1;\n-                        self.fi.state.line_num_file += 1;\n-                        self.fi.previous_was_newline = true;\n-                    } else {\n-                        self.fi.previous_was_newline = false;\n-                    }\n-\n-                    return b;\n-                }\n-            }\n-        }\n-    }\n-    fn read(&self, buf: &mut [u8], len: uint) -> uint {\n-        let mut count = 0;\n-        while count < len {\n-            let b = self.read_byte();\n-            if b < 0 { break }\n-\n-            buf[count] = b as u8;\n-            count += 1;\n-        }\n-\n-        count\n-    }\n-    fn eof(&self) -> bool {\n-        // we've run out of files, and current_reader is either None or eof.\n-\n-        self.fi.files.is_empty() &&\n-            match self.fi.current_reader { None => true, Some(r) => r.eof() }\n-\n-    }\n-    fn seek(&self, offset: int, whence: io::SeekStyle) {\n-        match self.fi.current_reader {\n-            None => {},\n-            Some(r) => r.seek(offset, whence)\n-        }\n-    }\n-    fn tell(&self) -> uint {\n-        match self.fi.current_reader {\n-            None => 0,\n-            Some(r) => r.tell()\n-        }\n-    }\n-}\n-\n-/**\n-Convert a list of strings to an appropriate form for a `FileInput`\n-instance. `stdin_hyphen` controls whether `-` represents `stdin` or\n-a literal `-`.\n-*/\n-pub fn make_path_option_vec(vec: &[~str], stdin_hyphen : bool) -> ~[Option<Path>] {\n-    vec.iter().map(|s| {\n-        if stdin_hyphen && \"-\" == *s {\n-            None\n-        } else {\n-            Some(Path::new(s.as_slice()))\n-        }\n-    }).collect()\n-}\n-\n-/**\n-Iterate directly over the command line arguments (no arguments implies\n-reading from `stdin`).\n-\n-Fails when attempting to read from a file that can't be opened.\n-*/\n-pub fn input(f: &fn(&str) -> bool) -> bool {\n-    let i = FileInput::from_args();\n-    i.each_line(f)\n-}\n-\n-/**\n-Iterate directly over the command line arguments (no arguments\n-implies reading from `stdin`) with the current state of the iteration\n-provided at each call.\n-\n-Fails when attempting to read from a file that can't be opened.\n-*/\n-pub fn input_state(f: &fn(&str, FileInputState) -> bool) -> bool {\n-    let i = FileInput::from_args();\n-    i.each_line_state(f)\n-}\n-\n-/**\n-Iterate over a vector of files (an empty vector implies just `stdin`).\n-\n-Fails when attempting to read from a file that can't be opened.\n-*/\n-pub fn input_vec(files: ~[Option<Path>], f: &fn(&str) -> bool) -> bool {\n-    let i = FileInput::from_vec(files);\n-    i.each_line(f)\n-}\n-\n-/**\n-Iterate over a vector of files (an empty vector implies just `stdin`)\n-with the current state of the iteration provided at each call.\n-\n-Fails when attempting to read from a file that can't be opened.\n-*/\n-pub fn input_vec_state(files: ~[Option<Path>],\n-                       f: &fn(&str, FileInputState) -> bool) -> bool {\n-    let i = FileInput::from_vec(files);\n-    i.each_line_state(f)\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use super::{FileInput, make_path_option_vec, input_vec, input_vec_state};\n-\n-    use std::rt::io;\n-    use std::rt::io::Writer;\n-    use std::rt::io::file;\n-    use std::vec;\n-\n-    fn make_file(path : &Path, contents: &[~str]) {\n-        let mut file = file::open(path, io::CreateOrTruncate, io::Write).unwrap();\n-\n-        for str in contents.iter() {\n-            file.write(str.as_bytes());\n-            file.write(['\\n' as u8]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_make_path_option_vec() {\n-        let strs = [~\"some/path\",\n-                    ~\"some/other/path\"];\n-        let paths = ~[Some(Path::new(\"some/path\")),\n-                      Some(Path::new(\"some/other/path\"))];\n-\n-        assert_eq!(make_path_option_vec(strs, true), paths.clone());\n-        assert_eq!(make_path_option_vec(strs, false), paths);\n-\n-        assert_eq!(make_path_option_vec([~\"-\"], true), ~[None]);\n-        assert_eq!(make_path_option_vec([~\"-\"], false), ~[Some(Path::new(\"-\"))]);\n-    }\n-\n-    #[test]\n-    fn test_fileinput_read_byte() {\n-        let filenames = make_path_option_vec(vec::from_fn(\n-            3,\n-            |i| format!(\"tmp/lib-fileinput-test-fileinput-read-byte-{}.tmp\", i)), true);\n-\n-        // 3 files containing 0\\n, 1\\n, and 2\\n respectively\n-        for (i, filename) in filenames.iter().enumerate() {\n-            make_file(filename.get_ref(), [format!(\"{}\", i)]);\n-        }\n-\n-        let fi = FileInput::from_vec(filenames.clone());\n-\n-        for (line, c) in \"012\".iter().enumerate() {\n-            assert_eq!(fi.read_byte(), c as int);\n-            assert_eq!(fi.state().line_num, line);\n-            assert_eq!(fi.state().line_num_file, 0);\n-            assert_eq!(fi.read_byte(), '\\n' as int);\n-            assert_eq!(fi.state().line_num, line + 1);\n-            assert_eq!(fi.state().line_num_file, 1);\n-\n-            assert_eq!(fi.state().current_path.clone(), filenames[line].clone());\n-        }\n-\n-        assert_eq!(fi.read_byte(), -1);\n-        assert!(fi.eof());\n-        assert_eq!(fi.state().line_num, 3)\n-\n-    }\n-\n-    #[test]\n-    fn test_fileinput_read() {\n-        let filenames = make_path_option_vec(vec::from_fn(\n-            3,\n-            |i| format!(\"tmp/lib-fileinput-test-fileinput-read-{}.tmp\", i)), true);\n-\n-        // 3 files containing 1\\n, 2\\n, and 3\\n respectively\n-        for (i, filename) in filenames.iter().enumerate() {\n-            make_file(filename.get_ref(), [format!(\"{}\", i)]);\n-        }\n-\n-        let fi = FileInput::from_vec(filenames);\n-        let mut buf : ~[u8] = vec::from_elem(6, 0u8);\n-        let count = fi.read(buf, 10);\n-        assert_eq!(count, 6);\n-        assert_eq!(buf, \"0\\n1\\n2\\n\".as_bytes().to_owned());\n-        assert!(fi.eof())\n-        assert_eq!(fi.state().line_num, 3);\n-    }\n-\n-    #[test]\n-    fn test_input_vec() {\n-        let mut all_lines = ~[];\n-        let filenames = make_path_option_vec(vec::from_fn(\n-            3,\n-            |i| format!(\"tmp/lib-fileinput-test-input-vec-{}.tmp\", i)), true);\n-\n-        for (i, filename) in filenames.iter().enumerate() {\n-            let contents =\n-                vec::from_fn(3, |j| format!(\"{} {}\", i, j));\n-            make_file(filename.get_ref(), contents);\n-            debug!(\"contents={:?}\", contents);\n-            all_lines.push_all(contents);\n-        }\n-\n-        let mut read_lines = ~[];\n-        do input_vec(filenames) |line| {\n-            read_lines.push(line.to_owned());\n-            true\n-        };\n-        assert_eq!(read_lines, all_lines);\n-    }\n-\n-    #[test]\n-    fn test_input_vec_state() {\n-        let filenames = make_path_option_vec(vec::from_fn(\n-            3,\n-            |i| format!(\"tmp/lib-fileinput-test-input-vec-state-{}.tmp\", i)),true);\n-\n-        for (i, filename) in filenames.iter().enumerate() {\n-            let contents =\n-                vec::from_fn(3, |j| format!(\"{} {}\", i, j + 1));\n-            make_file(filename.get_ref(), contents);\n-        }\n-\n-        do input_vec_state(filenames) |line, state| {\n-            let nums: ~[&str] = line.split_iter(' ').collect();\n-            let file_num = from_str::<uint>(nums[0]).unwrap();\n-            let line_num = from_str::<uint>(nums[1]).unwrap();\n-            assert_eq!(line_num, state.line_num_file);\n-            assert_eq!(file_num * 3 + line_num, state.line_num);\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    fn test_empty_files() {\n-        let filenames = make_path_option_vec(vec::from_fn(\n-            3,\n-            |i| format!(\"tmp/lib-fileinput-test-empty-files-{}.tmp\", i)),true);\n-\n-        make_file(filenames[0].get_ref(), [~\"1\", ~\"2\"]);\n-        make_file(filenames[1].get_ref(), []);\n-        make_file(filenames[2].get_ref(), [~\"3\", ~\"4\"]);\n-\n-        let mut count = 0;\n-        do input_vec_state(filenames.clone()) |line, state| {\n-            let expected_path = match line {\n-                \"1\" | \"2\" => filenames[0].clone(),\n-                \"3\" | \"4\" => filenames[2].clone(),\n-                _ => fail!(\"unexpected line\")\n-            };\n-            assert_eq!(state.current_path.clone(), expected_path);\n-            count += 1;\n-            true\n-        };\n-        assert_eq!(count, 4);\n-    }\n-\n-    #[test]\n-    fn test_no_trailing_newline() {\n-        let f1 =\n-            Some(Path::new(\"tmp/lib-fileinput-test-no-trailing-newline-1.tmp\"));\n-        let f2 =\n-            Some(Path::new(\"tmp/lib-fileinput-test-no-trailing-newline-2.tmp\"));\n-\n-        {\n-            let mut wr = file::open(f1.get_ref(), io::CreateOrTruncate,\n-                                    io::Write).unwrap();\n-            wr.write(\"1\\n2\".as_bytes());\n-            let mut wr = file::open(f2.get_ref(), io::CreateOrTruncate,\n-                                    io::Write).unwrap();\n-            wr.write(\"3\\n4\".as_bytes());\n-        }\n-\n-        let mut lines = ~[];\n-        do input_vec(~[f1, f2]) |line| {\n-            lines.push(line.to_owned());\n-            true\n-        };\n-        assert_eq!(lines, ~[~\"1\", ~\"2\", ~\"3\", ~\"4\"]);\n-    }\n-\n-\n-    #[test]\n-    fn test_next_file() {\n-        let filenames = make_path_option_vec(vec::from_fn(\n-            3,\n-            |i| format!(\"tmp/lib-fileinput-test-next-file-{}.tmp\", i)),true);\n-\n-        for (i, filename) in filenames.iter().enumerate() {\n-            let contents = vec::from_fn(3, |j| format!(\"{} {}\", i, j + 1));\n-            make_file(filename.get_ref(), contents);\n-        }\n-\n-        let input = FileInput::from_vec(filenames);\n-\n-        // read once from 0\n-        assert_eq!(input.read_line(), ~\"0 1\");\n-        input.next_file(); // skip the rest of 1\n-\n-        // read all lines from 1 (but don't read any from 2),\n-        for i in range(1u, 4) {\n-            assert_eq!(input.read_line(), format!(\"1 {}\", i));\n-        }\n-        // 1 is finished, but 2 hasn't been started yet, so this will\n-        // just \"skip\" to the beginning of 2 (Python's fileinput does\n-        // the same)\n-        input.next_file();\n-\n-        assert_eq!(input.read_line(), ~\"2 1\");\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_input_vec_missing_file() {\n-        do input_vec(make_path_option_vec([~\"this/file/doesnt/exist\"], true)) |line| {\n-            println(line);\n-            true\n-        };\n-    }\n-}"}, {"sha": "27a09be3a625b81fd1122fcc236317daeca59652", "filename": "src/libextra/io_util.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibextra%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Flibextra%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fio_util.rs?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -1,70 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(missing_doc)];\n-\n-use std::io::{Reader, BytesReader};\n-use std::io;\n-use std::cast;\n-\n-/// An implementation of the io::Reader interface which reads a buffer of bytes\n-pub struct BufReader {\n-    /// The buffer of bytes to read\n-    priv buf: ~[u8],\n-    /// The current position in the buffer of bytes\n-    priv pos: @mut uint\n-}\n-\n-impl BufReader {\n-    /// Creates a new buffer reader for the specified buffer\n-    pub fn new(v: ~[u8]) -> BufReader {\n-        BufReader {\n-            buf: v,\n-            pos: @mut 0\n-        }\n-    }\n-\n-    fn as_bytes_reader<A>(&self, f: &fn(&BytesReader) -> A) -> A {\n-        // FIXME(#5723)\n-        let bytes = ::std::util::id::<&[u8]>(self.buf);\n-        let bytes: &'static [u8] = unsafe { cast::transmute(bytes) };\n-        // Recreating the BytesReader state every call since\n-        // I can't get the borrowing to work correctly\n-        let bytes_reader = BytesReader {\n-            bytes: bytes,\n-            pos: @mut *self.pos\n-        };\n-\n-        let res = f(&bytes_reader);\n-\n-        // FIXME #4429: This isn't correct if f fails\n-        *self.pos = *bytes_reader.pos;\n-\n-        return res;\n-    }\n-}\n-\n-impl Reader for BufReader {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        self.as_bytes_reader(|r| r.read(bytes, len) )\n-    }\n-    fn read_byte(&self) -> int {\n-        self.as_bytes_reader(|r| r.read_byte() )\n-    }\n-    fn eof(&self) -> bool {\n-        self.as_bytes_reader(|r| r.eof() )\n-    }\n-    fn seek(&self, offset: int, whence: io::SeekStyle) {\n-        self.as_bytes_reader(|r| r.seek(offset, whence) )\n-    }\n-    fn tell(&self) -> uint {\n-        self.as_bytes_reader(|r| r.tell() )\n-    }\n-}"}, {"sha": "0aab7b743ba73648147c77bf118c744b2a999573", "filename": "src/libextra/json.rs", "status": "modified", "additions": 96, "deletions": 96, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -20,8 +20,10 @@ use std::char;\n use std::cast::transmute;\n use std::f64;\n use std::hashmap::HashMap;\n-use std::io::WriterUtil;\n-use std::io;\n+use std::rt::io;\n+use std::rt::io::Decorator;\n+use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::mem::MemWriter;\n use std::num;\n use std::str;\n use std::to_str;\n@@ -86,19 +88,17 @@ fn spaces(n: uint) -> ~str {\n \n /// A structure for implementing serialization to JSON.\n pub struct Encoder {\n-    priv wr: @io::Writer,\n+    priv wr: @mut io::Writer,\n }\n \n /// Creates a new JSON encoder whose output will be written to the writer\n /// specified.\n-pub fn Encoder(wr: @io::Writer) -> Encoder {\n-    Encoder {\n-        wr: wr\n-    }\n+pub fn Encoder(wr: @mut io::Writer) -> Encoder {\n+    Encoder { wr: wr }\n }\n \n impl serialize::Encoder for Encoder {\n-    fn emit_nil(&mut self) { self.wr.write_str(\"null\") }\n+    fn emit_nil(&mut self) { write!(self.wr, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n     fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n@@ -114,17 +114,21 @@ impl serialize::Encoder for Encoder {\n \n     fn emit_bool(&mut self, v: bool) {\n         if v {\n-            self.wr.write_str(\"true\");\n+            write!(self.wr, \"true\");\n         } else {\n-            self.wr.write_str(\"false\");\n+            write!(self.wr, \"false\");\n         }\n     }\n \n-    fn emit_f64(&mut self, v: f64) { self.wr.write_str(f64::to_str_digits(v, 6u)) }\n+    fn emit_f64(&mut self, v: f64) {\n+        write!(self.wr, \"{}\", f64::to_str_digits(v, 6u))\n+    }\n     fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n \n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n-    fn emit_str(&mut self, v: &str) { self.wr.write_str(escape_str(v)) }\n+    fn emit_str(&mut self, v: &str) {\n+        write!(self.wr, \"{}\", escape_str(v))\n+    }\n \n     fn emit_enum(&mut self, _name: &str, f: &fn(&mut Encoder)) { f(self) }\n \n@@ -137,23 +141,19 @@ impl serialize::Encoder for Encoder {\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n         if cnt == 0 {\n-            self.wr.write_str(escape_str(name));\n+            write!(self.wr, \"{}\", escape_str(name));\n         } else {\n-            self.wr.write_char('{');\n-            self.wr.write_str(\"\\\"variant\\\"\");\n-            self.wr.write_char(':');\n-            self.wr.write_str(escape_str(name));\n-            self.wr.write_char(',');\n-            self.wr.write_str(\"\\\"fields\\\"\");\n-            self.wr.write_str(\":[\");\n+            write!(self.wr, \"\\\\{\\\"variant\\\":\");\n+            write!(self.wr, \"{}\", escape_str(name));\n+            write!(self.wr, \",\\\"fields\\\":[\");\n             f(self);\n-            self.wr.write_str(\"]}\");\n+            write!(self.wr, \"]\\\\}\");\n         }\n     }\n \n     fn emit_enum_variant_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n         if idx != 0 {\n-            self.wr.write_char(',');\n+            write!(self.wr, \",\");\n         }\n         f(self);\n     }\n@@ -174,18 +174,17 @@ impl serialize::Encoder for Encoder {\n     }\n \n     fn emit_struct(&mut self, _: &str, _: uint, f: &fn(&mut Encoder)) {\n-        self.wr.write_char('{');\n+        write!(self.wr, r\"\\{\");\n         f(self);\n-        self.wr.write_char('}');\n+        write!(self.wr, r\"\\}\");\n     }\n \n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n                          f: &fn(&mut Encoder)) {\n-        if idx != 0 { self.wr.write_char(','); }\n-        self.wr.write_str(escape_str(name));\n-        self.wr.write_char(':');\n+        if idx != 0 { write!(self.wr, \",\") }\n+        write!(self.wr, \"{}:\", escape_str(name));\n         f(self);\n     }\n \n@@ -211,52 +210,52 @@ impl serialize::Encoder for Encoder {\n     fn emit_option_some(&mut self, f: &fn(&mut Encoder)) { f(self); }\n \n     fn emit_seq(&mut self, _len: uint, f: &fn(&mut Encoder)) {\n-        self.wr.write_char('[');\n+        write!(self.wr, \"[\");\n         f(self);\n-        self.wr.write_char(']');\n+        write!(self.wr, \"]\");\n     }\n \n     fn emit_seq_elt(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n         if idx != 0 {\n-            self.wr.write_char(',');\n+            write!(self.wr, \",\");\n         }\n         f(self)\n     }\n \n     fn emit_map(&mut self, _len: uint, f: &fn(&mut Encoder)) {\n-        self.wr.write_char('{');\n+        write!(self.wr, r\"\\{\");\n         f(self);\n-        self.wr.write_char('}');\n+        write!(self.wr, r\"\\}\");\n     }\n \n     fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n-        if idx != 0 { self.wr.write_char(','); }\n+        if idx != 0 { write!(self.wr, \",\") }\n         f(self)\n     }\n \n     fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n-        self.wr.write_char(':');\n+        write!(self.wr, \":\");\n         f(self)\n     }\n }\n \n /// Another encoder for JSON, but prints out human-readable JSON instead of\n /// compact data\n pub struct PrettyEncoder {\n-    priv wr: @io::Writer,\n+    priv wr: @mut io::Writer,\n     priv indent: uint,\n }\n \n /// Creates a new encoder whose output will be written to the specified writer\n-pub fn PrettyEncoder(wr: @io::Writer) -> PrettyEncoder {\n+pub fn PrettyEncoder(wr: @mut io::Writer) -> PrettyEncoder {\n     PrettyEncoder {\n         wr: wr,\n         indent: 0,\n     }\n }\n \n impl serialize::Encoder for PrettyEncoder {\n-    fn emit_nil(&mut self) { self.wr.write_str(\"null\") }\n+    fn emit_nil(&mut self) { write!(self.wr, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n     fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n@@ -272,17 +271,19 @@ impl serialize::Encoder for PrettyEncoder {\n \n     fn emit_bool(&mut self, v: bool) {\n         if v {\n-            self.wr.write_str(\"true\");\n+            write!(self.wr, \"true\");\n         } else {\n-            self.wr.write_str(\"false\");\n+            write!(self.wr, \"false\");\n         }\n     }\n \n-    fn emit_f64(&mut self, v: f64) { self.wr.write_str(f64::to_str_digits(v, 6u)) }\n+    fn emit_f64(&mut self, v: f64) {\n+        write!(self.wr, \"{}\", f64::to_str_digits(v, 6u))\n+    }\n     fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n \n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n-    fn emit_str(&mut self, v: &str) { self.wr.write_str(escape_str(v)); }\n+    fn emit_str(&mut self, v: &str) { write!(self.wr, \"{}\", escape_str(v)); }\n \n     fn emit_enum(&mut self, _name: &str, f: &fn(&mut PrettyEncoder)) {\n         f(self)\n@@ -294,29 +295,23 @@ impl serialize::Encoder for PrettyEncoder {\n                          cnt: uint,\n                          f: &fn(&mut PrettyEncoder)) {\n         if cnt == 0 {\n-            self.wr.write_str(escape_str(name));\n+            write!(self.wr, \"{}\", escape_str(name));\n         } else {\n-            self.wr.write_char('[');\n             self.indent += 2;\n-            self.wr.write_char('\\n');\n-            self.wr.write_str(spaces(self.indent));\n-            self.wr.write_str(escape_str(name));\n-            self.wr.write_str(\",\\n\");\n+            write!(self.wr, \"[\\n{}{},\\n\", spaces(self.indent), escape_str(name));\n             f(self);\n-            self.wr.write_char('\\n');\n             self.indent -= 2;\n-            self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char(']');\n+            write!(self.wr, \"\\n{}]\", spaces(self.indent));\n         }\n     }\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n                              f: &fn(&mut PrettyEncoder)) {\n         if idx != 0 {\n-            self.wr.write_str(\",\\n\");\n+            write!(self.wr, \",\\n\");\n         }\n-        self.wr.write_str(spaces(self.indent));\n+        write!(self.wr, \"{}\", spaces(self.indent));\n         f(self)\n     }\n \n@@ -341,15 +336,13 @@ impl serialize::Encoder for PrettyEncoder {\n                    len: uint,\n                    f: &fn(&mut PrettyEncoder)) {\n         if len == 0 {\n-            self.wr.write_str(\"{}\");\n+            write!(self.wr, \"\\\\{\\\\}\");\n         } else {\n-            self.wr.write_char('{');\n+            write!(self.wr, \"\\\\{\");\n             self.indent += 2;\n             f(self);\n-            self.wr.write_char('\\n');\n             self.indent -= 2;\n-            self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char('}');\n+            write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent));\n         }\n     }\n \n@@ -358,13 +351,11 @@ impl serialize::Encoder for PrettyEncoder {\n                          idx: uint,\n                          f: &fn(&mut PrettyEncoder)) {\n         if idx == 0 {\n-            self.wr.write_char('\\n');\n+            write!(self.wr, \"\\n\");\n         } else {\n-            self.wr.write_str(\",\\n\");\n+            write!(self.wr, \",\\n\");\n         }\n-        self.wr.write_str(spaces(self.indent));\n-        self.wr.write_str(escape_str(name));\n-        self.wr.write_str(\": \");\n+        write!(self.wr, \"{}{}: \", spaces(self.indent), escape_str(name));\n         f(self);\n     }\n \n@@ -393,54 +384,50 @@ impl serialize::Encoder for PrettyEncoder {\n \n     fn emit_seq(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n         if len == 0 {\n-            self.wr.write_str(\"[]\");\n+            write!(self.wr, \"[]\");\n         } else {\n-            self.wr.write_char('[');\n+            write!(self.wr, \"[\");\n             self.indent += 2;\n             f(self);\n-            self.wr.write_char('\\n');\n             self.indent -= 2;\n-            self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char(']');\n+            write!(self.wr, \"\\n{}]\", spaces(self.indent));\n         }\n     }\n \n     fn emit_seq_elt(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n         if idx == 0 {\n-            self.wr.write_char('\\n');\n+            write!(self.wr, \"\\n\");\n         } else {\n-            self.wr.write_str(\",\\n\");\n+            write!(self.wr, \",\\n\");\n         }\n-        self.wr.write_str(spaces(self.indent));\n+        write!(self.wr, \"{}\", spaces(self.indent));\n         f(self)\n     }\n \n     fn emit_map(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n         if len == 0 {\n-            self.wr.write_str(\"{}\");\n+            write!(self.wr, \"\\\\{\\\\}\");\n         } else {\n-            self.wr.write_char('{');\n+            write!(self.wr, \"\\\\{\");\n             self.indent += 2;\n             f(self);\n-            self.wr.write_char('\\n');\n             self.indent -= 2;\n-            self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char('}');\n+            write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent));\n         }\n     }\n \n     fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n         if idx == 0 {\n-            self.wr.write_char('\\n');\n+            write!(self.wr, \"\\n\");\n         } else {\n-            self.wr.write_str(\",\\n\");\n+            write!(self.wr, \",\\n\");\n         }\n-        self.wr.write_str(spaces(self.indent));\n+        write!(self.wr, \"{}\", spaces(self.indent));\n         f(self);\n     }\n \n     fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut PrettyEncoder)) {\n-        self.wr.write_str(\": \");\n+        write!(self.wr, \": \");\n         f(self);\n     }\n }\n@@ -460,21 +447,23 @@ impl<E: serialize::Encoder> serialize::Encodable<E> for Json {\n \n impl Json{\n     /// Encodes a json value into a io::writer.  Uses a single line.\n-    pub fn to_writer(&self, wr: @io::Writer) {\n+    pub fn to_writer(&self, wr: @mut io::Writer) {\n         let mut encoder = Encoder(wr);\n         self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into a io::writer.\n     /// Pretty-prints in a more readable format.\n-    pub fn to_pretty_writer(&self, wr: @io::Writer) {\n+    pub fn to_pretty_writer(&self, wr: @mut io::Writer) {\n         let mut encoder = PrettyEncoder(wr);\n         self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into a string\n     pub fn to_pretty_str(&self) -> ~str {\n-        io::with_str_writer(|wr| self.to_pretty_writer(wr))\n+        let s = @mut MemWriter::new();\n+        self.to_pretty_writer(s as @mut io::Writer);\n+        str::from_utf8(s.inner_ref().as_slice())\n     }\n }\n \n@@ -853,9 +842,9 @@ impl<T : Iterator<char>> Parser<T> {\n     }\n }\n \n-/// Decodes a json value from an @io::Reader\n-pub fn from_reader(rdr: @io::Reader) -> Result<Json, Error> {\n-    let s = str::from_utf8(rdr.read_whole_stream());\n+/// Decodes a json value from an `&mut io::Reader`\n+pub fn from_reader(mut rdr: &mut io::Reader) -> Result<Json, Error> {\n+    let s = str::from_utf8(rdr.read_to_end());\n     let mut parser = Parser(~s.iter());\n     parser.parse()\n }\n@@ -1306,7 +1295,9 @@ impl<A:ToJson> ToJson for Option<A> {\n impl to_str::ToStr for Json {\n     /// Encodes a json value into a string\n     fn to_str(&self) -> ~str {\n-      io::with_str_writer(|wr| self.to_writer(wr))\n+        let s = @mut MemWriter::new();\n+        self.to_writer(s as @mut io::Writer);\n+        str::from_utf8(s.inner_ref().as_slice())\n     }\n }\n \n@@ -1321,8 +1312,7 @@ mod tests {\n \n     use super::*;\n \n-    use std::io;\n-\n+    use std::rt::io;\n     use serialize::Decodable;\n     use treemap::TreeMap;\n \n@@ -1493,18 +1483,28 @@ mod tests {\n         assert_eq!(a.clone(), from_str(a.to_pretty_str()).unwrap());\n     }\n \n+    fn with_str_writer(f: &fn(@mut io::Writer)) -> ~str {\n+        use std::rt::io::mem::MemWriter;\n+        use std::rt::io::Decorator;\n+        use std::str;\n+\n+        let m = @mut MemWriter::new();\n+        f(m as @mut io::Writer);\n+        str::from_utf8(*m.inner_ref())\n+    }\n+\n     #[test]\n     fn test_write_enum() {\n         let animal = Dog;\n         assert_eq!(\n-            do io::with_str_writer |wr| {\n+            do with_str_writer |wr| {\n                 let mut encoder = Encoder(wr);\n                 animal.encode(&mut encoder);\n             },\n             ~\"\\\"Dog\\\"\"\n         );\n         assert_eq!(\n-            do io::with_str_writer |wr| {\n+            do with_str_writer |wr| {\n                 let mut encoder = PrettyEncoder(wr);\n                 animal.encode(&mut encoder);\n             },\n@@ -1513,14 +1513,14 @@ mod tests {\n \n         let animal = Frog(~\"Henry\", 349);\n         assert_eq!(\n-            do io::with_str_writer |wr| {\n+            do with_str_writer |wr| {\n                 let mut encoder = Encoder(wr);\n                 animal.encode(&mut encoder);\n             },\n             ~\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n         );\n         assert_eq!(\n-            do io::with_str_writer |wr| {\n+            do with_str_writer |wr| {\n                 let mut encoder = PrettyEncoder(wr);\n                 animal.encode(&mut encoder);\n             },\n@@ -1536,14 +1536,14 @@ mod tests {\n     #[test]\n     fn test_write_some() {\n         let value = Some(~\"jodhpurs\");\n-        let s = do io::with_str_writer |wr| {\n+        let s = do with_str_writer |wr| {\n             let mut encoder = Encoder(wr);\n             value.encode(&mut encoder);\n         };\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n \n         let value = Some(~\"jodhpurs\");\n-        let s = do io::with_str_writer |wr| {\n+        let s = do with_str_writer |wr| {\n             let mut encoder = PrettyEncoder(wr);\n             value.encode(&mut encoder);\n         };\n@@ -1553,13 +1553,13 @@ mod tests {\n     #[test]\n     fn test_write_none() {\n         let value: Option<~str> = None;\n-        let s = do io::with_str_writer |wr| {\n+        let s = do with_str_writer |wr| {\n             let mut encoder = Encoder(wr);\n             value.encode(&mut encoder);\n         };\n         assert_eq!(s, ~\"null\");\n \n-        let s = do io::with_str_writer |wr| {\n+        let s = do with_str_writer |wr| {\n             let mut encoder = Encoder(wr);\n             value.encode(&mut encoder);\n         };"}, {"sha": "0ab38cdb5df83ff01b70be38a2485a5095d124a9", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -30,8 +30,6 @@\n \n use std::char;\n use std::cmp;\n-use std::io::{ReaderUtil};\n-use std::io;\n use std::option::{Option, Some, None};\n use std::to_str::ToStr;\n \n@@ -147,14 +145,19 @@ condition! {\n     bad_parse: () -> ();\n }\n \n-fn take_nonempty_prefix(rdr: @io::Reader,\n-                        ch: char,\n-                        pred: &fn(char) -> bool) -> (~str, char) {\n+fn take_nonempty_prefix<T: Iterator<char>>(rdr: &mut T,\n+                        pred: &fn(char) -> bool) -> (~str, Option<char>) {\n     let mut buf = ~\"\";\n-    let mut ch = ch;\n-    while pred(ch) {\n-        buf.push_char(ch);\n-        ch = rdr.read_char();\n+    let mut ch = rdr.next();\n+    loop {\n+        match ch {\n+            None => break,\n+            Some(c) if !pred(c) => break,\n+            Some(c) => {\n+                buf.push_char(c);\n+                ch = rdr.next();\n+            }\n+        }\n     }\n     if buf.is_empty() {\n         bad_parse::cond.raise(())\n@@ -163,16 +166,16 @@ fn take_nonempty_prefix(rdr: @io::Reader,\n     (buf, ch)\n }\n \n-fn take_num(rdr: @io::Reader, ch: char) -> (uint, char) {\n-    let (s, ch) = take_nonempty_prefix(rdr, ch, char::is_digit);\n+fn take_num<T: Iterator<char>>(rdr: &mut T) -> (uint, Option<char>) {\n+    let (s, ch) = take_nonempty_prefix(rdr, char::is_digit);\n     match from_str::<uint>(s) {\n         None => { bad_parse::cond.raise(()); (0, ch) },\n         Some(i) => (i, ch)\n     }\n }\n \n-fn take_ident(rdr: @io::Reader, ch: char) -> (Identifier, char) {\n-    let (s,ch) = take_nonempty_prefix(rdr, ch, char::is_alphanumeric);\n+fn take_ident<T: Iterator<char>>(rdr: &mut T) -> (Identifier, Option<char>) {\n+    let (s,ch) = take_nonempty_prefix(rdr, char::is_alphanumeric);\n     if s.iter().all(char::is_digit) {\n         match from_str::<uint>(s) {\n             None => { bad_parse::cond.raise(()); (Numeric(0), ch) },\n@@ -183,38 +186,38 @@ fn take_ident(rdr: @io::Reader, ch: char) -> (Identifier, char) {\n     }\n }\n \n-fn expect(ch: char, c: char) {\n-    if ch != c {\n+fn expect(ch: Option<char>, c: char) {\n+    if ch != Some(c) {\n         bad_parse::cond.raise(())\n     }\n }\n \n-fn parse_reader(rdr: @io::Reader) -> Version {\n-    let (major, ch) = take_num(rdr, rdr.read_char());\n+fn parse_iter<T: Iterator<char>>(rdr: &mut T) -> Version {\n+    let (major, ch) = take_num(rdr);\n     expect(ch, '.');\n-    let (minor, ch) = take_num(rdr, rdr.read_char());\n+    let (minor, ch) = take_num(rdr);\n     expect(ch, '.');\n-    let (patch, ch) = take_num(rdr, rdr.read_char());\n+    let (patch, ch) = take_num(rdr);\n \n     let mut pre = ~[];\n     let mut build = ~[];\n \n     let mut ch = ch;\n-    if ch == '-' {\n+    if ch == Some('-') {\n         loop {\n-            let (id, c) = take_ident(rdr, rdr.read_char());\n+            let (id, c) = take_ident(rdr);\n             pre.push(id);\n             ch = c;\n-            if ch != '.' { break; }\n+            if ch != Some('.') { break; }\n         }\n     }\n \n-    if ch == '+' {\n+    if ch == Some('+') {\n         loop {\n-            let (id, c) = take_ident(rdr, rdr.read_char());\n+            let (id, c) = take_ident(rdr);\n             build.push(id);\n             ch = c;\n-            if ch != '.' { break; }\n+            if ch != Some('.') { break; }\n         }\n     }\n \n@@ -236,13 +239,11 @@ pub fn parse(s: &str) -> Option<Version> {\n     let s = s.trim();\n     let mut bad = false;\n     do bad_parse::cond.trap(|_| { debug!(\"bad\"); bad = true }).inside {\n-        do io::with_str_reader(s) |rdr| {\n-            let v = parse_reader(rdr);\n-            if bad || v.to_str() != s.to_owned() {\n-                None\n-            } else {\n-                Some(v)\n-            }\n+        let v = parse_iter(&mut s.iter());\n+        if bad || v.to_str() != s.to_owned() {\n+            None\n+        } else {\n+            Some(v)\n         }\n     }\n }"}, {"sha": "497145ca7c992c6468422c775e45aa205df5ef5b", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -13,7 +13,7 @@\n use sort;\n use std::cmp;\n use std::hashmap;\n-use std::io;\n+use std::rt::io;\n use std::num;\n \n // NB: this can probably be rewritten in terms of num::Num\n@@ -273,14 +273,14 @@ pub fn winsorize(samples: &mut [f64], pct: f64) {\n }\n \n /// Render writes the min, max and quartiles of the provided `Summary` to the provided `Writer`.\n-pub fn write_5_number_summary(w: @io::Writer, s: &Summary) {\n+pub fn write_5_number_summary(w: &mut io::Writer, s: &Summary) {\n     let (q1,q2,q3) = s.quartiles;\n-    w.write_str(format!(\"(min={}, q1={}, med={}, q3={}, max={})\",\n+    write!(w, \"(min={}, q1={}, med={}, q3={}, max={})\",\n                      s.min,\n                      q1,\n                      q2,\n                      q3,\n-                     s.max));\n+                     s.max);\n }\n \n /// Render a boxplot to the provided writer. The boxplot shows the min, max and quartiles of the\n@@ -295,7 +295,7 @@ pub fn write_5_number_summary(w: @io::Writer, s: &Summary) {\n ///   10 |        [--****#******----------]          | 40\n /// ~~~~\n \n-pub fn write_boxplot(w: @io::Writer, s: &Summary, width_hint: uint) {\n+pub fn write_boxplot(w: &mut io::Writer, s: &Summary, width_hint: uint) {\n \n     let (q1,q2,q3) = s.quartiles;\n \n@@ -325,52 +325,48 @@ pub fn write_boxplot(w: @io::Writer, s: &Summary, width_hint: uint) {\n     let range_width = width_hint - overhead_width;;\n     let char_step = range / (range_width as f64);\n \n-    w.write_str(lostr);\n-    w.write_char(' ');\n-    w.write_char('|');\n+    write!(w, \"{} |\", lostr);\n \n     let mut c = 0;\n     let mut v = lo;\n \n     while c < range_width && v < s.min {\n-        w.write_char(' ');\n+        write!(w, \" \");\n         v += char_step;\n         c += 1;\n     }\n-    w.write_char('[');\n+    write!(w, \"[\");\n     c += 1;\n     while c < range_width && v < q1 {\n-        w.write_char('-');\n+        write!(w, \"-\");\n         v += char_step;\n         c += 1;\n     }\n     while c < range_width && v < q2 {\n-        w.write_char('*');\n+        write!(w, \"*\");\n         v += char_step;\n         c += 1;\n     }\n-    w.write_char('#');\n+    write!(w, r\"\\#\");\n     c += 1;\n     while c < range_width && v < q3 {\n-        w.write_char('*');\n+        write!(w, \"*\");\n         v += char_step;\n         c += 1;\n     }\n     while c < range_width && v < s.max {\n-        w.write_char('-');\n+        write!(w, \"-\");\n         v += char_step;\n         c += 1;\n     }\n-    w.write_char(']');\n+    write!(w, \"]\");\n     while c < range_width {\n-        w.write_char(' ');\n+        write!(w, \" \");\n         v += char_step;\n         c += 1;\n     }\n \n-    w.write_char('|');\n-    w.write_char(' ');\n-    w.write_str(histr);\n+    write!(w, \"| {}\", histr);\n }\n \n /// Returns a HashMap with the number of occurrences of every element in the\n@@ -392,18 +388,20 @@ mod tests {\n     use stats::Summary;\n     use stats::write_5_number_summary;\n     use stats::write_boxplot;\n-    use std::io;\n+    use std::rt::io;\n+    use std::str;\n \n     fn check(samples: &[f64], summ: &Summary) {\n \n         let summ2 = Summary::new(samples);\n \n-        let w = io::stdout();\n-        w.write_char('\\n');\n+        let mut w = io::stdout();\n+        let w = &mut w as &mut io::Writer;\n+        write!(w, \"\\n\");\n         write_5_number_summary(w, &summ2);\n-        w.write_char('\\n');\n+        write!(w, \"\\n\");\n         write_boxplot(w, &summ2, 50);\n-        w.write_char('\\n');\n+        write!(w, \"\\n\");\n \n         assert_eq!(summ.sum, summ2.sum);\n         assert_eq!(summ.min, summ2.min);\n@@ -944,10 +942,11 @@ mod tests {\n     #[test]\n     fn test_boxplot_nonpositive() {\n         fn t(s: &Summary, expected: ~str) {\n-            let out = do io::with_str_writer |w|  {\n-                write_boxplot(w, s, 30)\n-            };\n-\n+            use std::rt::io::mem::MemWriter;\n+            use std::rt::io::Decorator;\n+            let mut m = MemWriter::new();\n+            write_boxplot(&mut m as &mut io::Writer, s, 30);\n+            let out = str::from_utf8_owned(m.inner());\n             assert_eq!(out, expected);\n         }\n "}, {"sha": "22ce833ea24d9b97d4351eda4298a3587b8f7bd2", "filename": "src/libextra/term.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -13,7 +13,7 @@\n #[allow(missing_doc)];\n \n \n-use std::io;\n+use std::rt::io;\n \n #[cfg(not(target_os = \"win32\"))] use std::os;\n #[cfg(not(target_os = \"win32\"))] use terminfo::*;\n@@ -96,19 +96,19 @@ fn cap_for_attr(attr: attr::Attr) -> &'static str {\n #[cfg(not(target_os = \"win32\"))]\n pub struct Terminal {\n     priv num_colors: u16,\n-    priv out: @io::Writer,\n+    priv out: @mut io::Writer,\n     priv ti: ~TermInfo\n }\n \n #[cfg(target_os = \"win32\")]\n pub struct Terminal {\n     priv num_colors: u16,\n-    priv out: @io::Writer,\n+    priv out: @mut io::Writer,\n }\n \n #[cfg(not(target_os = \"win32\"))]\n impl Terminal {\n-    pub fn new(out: @io::Writer) -> Result<Terminal, ~str> {\n+    pub fn new(out: @mut io::Writer) -> Result<Terminal, ~str> {\n         let term = os::getenv(\"TERM\");\n         if term.is_none() {\n             return Err(~\"TERM environment variable undefined\");\n@@ -243,7 +243,7 @@ impl Terminal {\n \n #[cfg(target_os = \"win32\")]\n impl Terminal {\n-    pub fn new(out: @io::Writer) -> Result<Terminal, ~str> {\n+    pub fn new(out: @mut io::Writer) -> Result<Terminal, ~str> {\n         return Ok(Terminal {out: out, num_colors: 0});\n     }\n "}, {"sha": "457f7868e237ae9c93f41d937d04bcd1d5c02cc0", "filename": "src/libextra/test.rs", "status": "modified", "additions": 71, "deletions": 74, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -30,8 +30,8 @@ use treemap::TreeMap;\n \n use std::clone::Clone;\n use std::comm::{stream, SharedChan, GenericPort, GenericChan};\n-use std::io;\n-use std::result;\n+use std::rt::io;\n+use std::rt::io::file::FileInfo;\n use std::task;\n use std::to_str::ToStr;\n use std::f64;\n@@ -336,8 +336,8 @@ pub enum TestResult {\n }\n \n struct ConsoleTestState {\n-    out: @io::Writer,\n-    log_out: Option<@io::Writer>,\n+    out: @mut io::Writer,\n+    log_out: Option<@mut io::Writer>,\n     term: Option<term::Terminal>,\n     use_color: bool,\n     total: uint,\n@@ -353,17 +353,13 @@ struct ConsoleTestState {\n impl ConsoleTestState {\n     pub fn new(opts: &TestOpts) -> ConsoleTestState {\n         let log_out = match opts.logfile {\n-            Some(ref path) => match io::file_writer(path,\n-                                                    [io::Create,\n-                                                     io::Truncate]) {\n-                result::Ok(w) => Some(w),\n-                result::Err(ref s) => {\n-                    fail!(\"can't open output file: {}\", *s)\n-                }\n+            Some(ref path) => {\n+                let out = path.open_writer(io::CreateOrTruncate);\n+                Some(@mut out as @mut io::Writer)\n             },\n             None => None\n         };\n-        let out = io::stdout();\n+        let out = @mut io::stdio::stdout() as @mut io::Writer;\n         let term = match term::Terminal::new(out) {\n             Err(_) => None,\n             Ok(t) => Some(t)\n@@ -424,12 +420,12 @@ impl ConsoleTestState {\n                         word: &str,\n                         color: term::color::Color) {\n         match self.term {\n-            None => self.out.write_str(word),\n+            None => self.out.write(word.as_bytes()),\n             Some(ref t) => {\n                 if self.use_color {\n                     t.fg(color);\n                 }\n-                self.out.write_str(word);\n+                self.out.write(word.as_bytes());\n                 if self.use_color {\n                     t.reset();\n                 }\n@@ -440,12 +436,12 @@ impl ConsoleTestState {\n     pub fn write_run_start(&mut self, len: uint) {\n         self.total = len;\n         let noun = if len != 1 { &\"tests\" } else { &\"test\" };\n-        self.out.write_line(format!(\"\\nrunning {} {}\", len, noun));\n+        write!(self.out, \"\\nrunning {} {}\\n\", len, noun);\n     }\n \n     pub fn write_test_start(&self, test: &TestDesc, align: NamePadding) {\n         let name = test.padded_name(self.max_name_len, align);\n-        self.out.write_str(format!(\"test {} ... \", name));\n+        write!(self.out, \"test {} ... \", name);\n     }\n \n     pub fn write_result(&self, result: &TestResult) {\n@@ -455,41 +451,40 @@ impl ConsoleTestState {\n             TrIgnored => self.write_ignored(),\n             TrMetrics(ref mm) => {\n                 self.write_metric();\n-                self.out.write_str(\": \" + fmt_metrics(mm));\n+                write!(self.out, \": {}\", fmt_metrics(mm));\n             }\n             TrBench(ref bs) => {\n                 self.write_bench();\n-                self.out.write_str(\": \" + fmt_bench_samples(bs))\n+                write!(self.out, \": {}\", fmt_bench_samples(bs));\n             }\n         }\n-        self.out.write_str(&\"\\n\");\n+        write!(self.out, \"\\n\");\n     }\n \n     pub fn write_log(&self, test: &TestDesc, result: &TestResult) {\n         match self.log_out {\n             None => (),\n             Some(out) => {\n-                out.write_line(format!(\"{} {}\",\n-                                    match *result {\n+                write!(out, \"{} {}\",match *result {\n                                         TrOk => ~\"ok\",\n                                         TrFailed => ~\"failed\",\n                                         TrIgnored => ~\"ignored\",\n                                         TrMetrics(ref mm) => fmt_metrics(mm),\n                                         TrBench(ref bs) => fmt_bench_samples(bs)\n-                                    }, test.name.to_str()));\n+                                    }, test.name.to_str());\n             }\n         }\n     }\n \n     pub fn write_failures(&self) {\n-        self.out.write_line(\"\\nfailures:\");\n+        write!(self.out, \"\\nfailures:\\n\");\n         let mut failures = ~[];\n         for f in self.failures.iter() {\n             failures.push(f.name.to_str());\n         }\n         sort::tim_sort(failures);\n         for name in failures.iter() {\n-            self.out.write_line(format!(\"    {}\", name.to_str()));\n+            writeln!(self.out, \"    {}\", name.to_str());\n         }\n     }\n \n@@ -506,36 +501,34 @@ impl ConsoleTestState {\n                 MetricAdded => {\n                     added += 1;\n                     self.write_added();\n-                    self.out.write_line(format!(\": {}\", *k));\n+                    writeln!(self.out, \": {}\", *k);\n                 }\n                 MetricRemoved => {\n                     removed += 1;\n                     self.write_removed();\n-                    self.out.write_line(format!(\": {}\", *k));\n+                    writeln!(self.out, \": {}\", *k);\n                 }\n                 Improvement(pct) => {\n                     improved += 1;\n-                    self.out.write_str(*k);\n-                    self.out.write_str(\": \");\n+                    write!(self.out, \"{}: \", *k);\n                     self.write_improved();\n-                    self.out.write_line(format!(\" by {:.2f}%\", pct as f64))\n+                    writeln!(self.out, \" by {:.2f}%\", pct as f64);\n                 }\n                 Regression(pct) => {\n                     regressed += 1;\n-                    self.out.write_str(*k);\n-                    self.out.write_str(\": \");\n+                    write!(self.out, \"{}: \", *k);\n                     self.write_regressed();\n-                    self.out.write_line(format!(\" by {:.2f}%\", pct as f64))\n+                    writeln!(self.out, \" by {:.2f}%\", pct as f64);\n                 }\n             }\n         }\n-        self.out.write_line(format!(\"result of ratchet: {} matrics added, {} removed, \\\n-                                  {} improved, {} regressed, {} noise\",\n-                                 added, removed, improved, regressed, noise));\n+        writeln!(self.out, \"result of ratchet: {} matrics added, {} removed, \\\n+                            {} improved, {} regressed, {} noise\",\n+                            added, removed, improved, regressed, noise);\n         if regressed == 0 {\n-            self.out.write_line(\"updated ratchet file\")\n+            writeln!(self.out, \"updated ratchet file\");\n         } else {\n-            self.out.write_line(\"left ratchet file untouched\")\n+            writeln!(self.out, \"left ratchet file untouched\");\n         }\n     }\n \n@@ -547,12 +540,12 @@ impl ConsoleTestState {\n         let ratchet_success = match *ratchet_metrics {\n             None => true,\n             Some(ref pth) => {\n-                self.out.write_str(format!(\"\\nusing metrics ratchet: {}\\n\", pth.display()));\n+                write!(self.out, \"\\nusing metrics ratcher: {}\\n\", pth.display());\n                 match ratchet_pct {\n                     None => (),\n                     Some(pct) =>\n-                    self.out.write_str(format!(\"with noise-tolerance forced to: {}%%\\n\",\n-                                            pct as f64))\n+                        writeln!(self.out, \"with noise-tolerance forced to: {}%\",\n+                                 pct)\n                 }\n                 let (diff, ok) = self.metrics.ratchet(pth, ratchet_pct);\n                 self.write_metric_diff(&diff);\n@@ -567,15 +560,15 @@ impl ConsoleTestState {\n \n         let success = ratchet_success && test_success;\n \n-        self.out.write_str(\"\\ntest result: \");\n+        write!(self.out, \"\\ntest result: \");\n         if success {\n             // There's no parallelism at this point so it's safe to use color\n             self.write_ok();\n         } else {\n             self.write_failed();\n         }\n-        self.out.write_str(format!(\". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n-                                self.passed, self.failed, self.ignored, self.measured));\n+        write!(self.out, \". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n+               self.passed, self.failed, self.ignored, self.measured);\n         return success;\n     }\n }\n@@ -659,47 +652,51 @@ pub fn run_tests_console(opts: &TestOpts,\n         None => (),\n         Some(ref pth) => {\n             st.metrics.save(pth);\n-            st.out.write_str(format!(\"\\nmetrics saved to: {}\", pth.display()));\n+            write!(st.out, \"\\nmetrics saved to: {}\", pth.display());\n         }\n     }\n     return st.write_run_finish(&opts.ratchet_metrics, opts.ratchet_noise_percent);\n }\n \n #[test]\n fn should_sort_failures_before_printing_them() {\n+    use std::rt::io;\n+    use std::rt::io::Decorator;\n+    use std::rt::io::mem::MemWriter;\n+    use std::str;\n     fn dummy() {}\n \n-    let s = do io::with_str_writer |wr| {\n-        let test_a = TestDesc {\n-            name: StaticTestName(\"a\"),\n-            ignore: false,\n-            should_fail: false\n-        };\n-\n-        let test_b = TestDesc {\n-            name: StaticTestName(\"b\"),\n-            ignore: false,\n-            should_fail: false\n-        };\n+    let m = @mut MemWriter::new();\n+    let test_a = TestDesc {\n+        name: StaticTestName(\"a\"),\n+        ignore: false,\n+        should_fail: false\n+    };\n \n-        let st = @ConsoleTestState {\n-            out: wr,\n-            log_out: None,\n-            term: None,\n-            use_color: false,\n-            total: 0u,\n-            passed: 0u,\n-            failed: 0u,\n-            ignored: 0u,\n-            measured: 0u,\n-            metrics: MetricMap::new(),\n-            failures: ~[test_b, test_a],\n-            max_name_len: 0u,\n-        };\n+    let test_b = TestDesc {\n+        name: StaticTestName(\"b\"),\n+        ignore: false,\n+        should_fail: false\n+    };\n \n-        st.write_failures();\n+    let st = @ConsoleTestState {\n+        out: m as @mut io::Writer,\n+        log_out: None,\n+        term: None,\n+        use_color: false,\n+        total: 0u,\n+        passed: 0u,\n+        failed: 0u,\n+        ignored: 0u,\n+        measured: 0u,\n+        max_name_len: 10u,\n+        metrics: MetricMap::new(),\n+        failures: ~[test_b, test_a]\n     };\n \n+    st.write_failures();\n+    let s = str::from_utf8(*m.inner_ref());\n+\n     let apos = s.find_str(\"a\").unwrap();\n     let bpos = s.find_str(\"b\").unwrap();\n     assert!(apos < bpos);\n@@ -939,15 +936,15 @@ impl MetricMap {\n     /// Load MetricDiff from a file.\n     pub fn load(p: &Path) -> MetricMap {\n         assert!(os::path_exists(p));\n-        let f = io::file_reader(p).unwrap();\n+        let f = @mut p.open_reader(io::Open) as @mut io::Reader;\n         let mut decoder = json::Decoder(json::from_reader(f).unwrap());\n         MetricMap(Decodable::decode(&mut decoder))\n     }\n \n     /// Write MetricDiff to a file.\n     pub fn save(&self, p: &Path) {\n-        let f = io::file_writer(p, [io::Create, io::Truncate]).unwrap();\n-        self.to_json().to_pretty_writer(f);\n+        let f = @mut p.open_writer(io::CreateOrTruncate);\n+        self.to_json().to_pretty_writer(f as @mut io::Writer);\n     }\n \n     /// Compare against another MetricMap. Optionally compare all"}, {"sha": "2950f02ad19ddcd846d485ae128af18d3c5c6f4e", "filename": "src/libextra/time.rs", "status": "modified", "additions": 75, "deletions": 58, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -10,7 +10,8 @@\n \n #[allow(missing_doc)];\n \n-use std::io;\n+use std::rt::io::Reader;\n+use std::rt::io::mem::BufReader;\n use std::num;\n use std::str;\n \n@@ -666,61 +667,69 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n         }\n     }\n \n-    do io::with_str_reader(format) |rdr| {\n-        let mut tm = Tm {\n-            tm_sec: 0_i32,\n-            tm_min: 0_i32,\n-            tm_hour: 0_i32,\n-            tm_mday: 0_i32,\n-            tm_mon: 0_i32,\n-            tm_year: 0_i32,\n-            tm_wday: 0_i32,\n-            tm_yday: 0_i32,\n-            tm_isdst: 0_i32,\n-            tm_gmtoff: 0_i32,\n-            tm_zone: ~\"\",\n-            tm_nsec: 0_i32,\n-        };\n-        let mut pos = 0u;\n-        let len = s.len();\n-        let mut result = Err(~\"Invalid time\");\n+    let mut rdr = BufReader::new(format.as_bytes());\n+    let mut tm = Tm {\n+        tm_sec: 0_i32,\n+        tm_min: 0_i32,\n+        tm_hour: 0_i32,\n+        tm_mday: 0_i32,\n+        tm_mon: 0_i32,\n+        tm_year: 0_i32,\n+        tm_wday: 0_i32,\n+        tm_yday: 0_i32,\n+        tm_isdst: 0_i32,\n+        tm_gmtoff: 0_i32,\n+        tm_zone: ~\"\",\n+        tm_nsec: 0_i32,\n+    };\n+    let mut pos = 0u;\n+    let len = s.len();\n+    let mut result = Err(~\"Invalid time\");\n \n-        while !rdr.eof() && pos < len {\n-            let range = s.char_range_at(pos);\n-            let ch = range.ch;\n-            let next = range.next;\n-\n-            match rdr.read_char() {\n-                '%' => {\n-                    match parse_type(s, pos, rdr.read_char(), &mut tm) {\n-                        Ok(next) => pos = next,\n-                        Err(e) => { result = Err(e); break; }\n-                    }\n-                },\n-                c => {\n-                    if c != ch { break }\n-                    pos = next;\n+    while pos < len {\n+        let range = s.char_range_at(pos);\n+        let ch = range.ch;\n+        let next = range.next;\n+\n+        let mut buf = [0];\n+        let c = match rdr.read(buf) {\n+            Some(*) => buf[0] as u8 as char,\n+            None => break\n+        };\n+        match c {\n+            '%' => {\n+                let ch = match rdr.read(buf) {\n+                    Some(*) => buf[0] as u8 as char,\n+                    None => break\n+                };\n+                match parse_type(s, pos, ch, &mut tm) {\n+                    Ok(next) => pos = next,\n+                    Err(e) => { result = Err(e); break; }\n                 }\n+            },\n+            c => {\n+                if c != ch { break }\n+                pos = next;\n             }\n         }\n-\n-        if pos == len && rdr.eof() {\n-            Ok(Tm {\n-                tm_sec: tm.tm_sec,\n-                tm_min: tm.tm_min,\n-                tm_hour: tm.tm_hour,\n-                tm_mday: tm.tm_mday,\n-                tm_mon: tm.tm_mon,\n-                tm_year: tm.tm_year,\n-                tm_wday: tm.tm_wday,\n-                tm_yday: tm.tm_yday,\n-                tm_isdst: tm.tm_isdst,\n-                tm_gmtoff: tm.tm_gmtoff,\n-                tm_zone: tm.tm_zone.clone(),\n-                tm_nsec: tm.tm_nsec,\n-            })\n-        } else { result }\n     }\n+\n+    if pos == len && rdr.eof() {\n+        Ok(Tm {\n+            tm_sec: tm.tm_sec,\n+            tm_min: tm.tm_min,\n+            tm_hour: tm.tm_hour,\n+            tm_mday: tm.tm_mday,\n+            tm_mon: tm.tm_mon,\n+            tm_year: tm.tm_year,\n+            tm_wday: tm.tm_wday,\n+            tm_yday: tm.tm_yday,\n+            tm_isdst: tm.tm_isdst,\n+            tm_gmtoff: tm.tm_gmtoff,\n+            tm_zone: tm.tm_zone.clone(),\n+            tm_nsec: tm.tm_nsec,\n+        })\n+    } else { result }\n }\n \n /// Formats the time according to the format string.\n@@ -929,18 +938,26 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n         }\n     }\n \n-    let mut buf = ~\"\";\n+    let mut buf = ~[];\n \n-    do io::with_str_reader(format) |rdr| {\n-        while !rdr.eof() {\n-            match rdr.read_char() {\n-                '%' => buf.push_str(parse_type(rdr.read_char(), tm)),\n-                ch => buf.push_char(ch)\n+    let mut rdr = BufReader::new(format.as_bytes());\n+    loop {\n+        let mut b = [0];\n+        let ch = match rdr.read(b) {\n+            Some(*) => b[0],\n+            None => break,\n+        };\n+        match ch as char {\n+            '%' => {\n+                rdr.read(b);\n+                let s = parse_type(b[0] as char, tm);\n+                buf.push_all(s.as_bytes());\n             }\n+            ch => buf.push(ch as u8)\n         }\n     }\n \n-    buf\n+    str::from_utf8_owned(buf)\n }\n \n #[cfg(test)]"}, {"sha": "bfa3934700a516a38c480ac350a8c27510f3f5f7", "filename": "src/libextra/url.rs", "status": "modified", "additions": 159, "deletions": 135, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -12,10 +12,9 @@\n \n #[allow(missing_doc)];\n \n-\n+use std::rt::io::{Reader, Seek};\n+use std::rt::io::mem::BufReader;\n use std::cmp::Eq;\n-use std::io::{Reader, ReaderUtil};\n-use std::io;\n use std::hashmap::HashMap;\n use std::to_bytes;\n use std::uint;\n@@ -68,42 +67,46 @@ impl UserInfo {\n }\n \n fn encode_inner(s: &str, full_url: bool) -> ~str {\n-    do io::with_str_reader(s) |rdr| {\n-        let mut out = ~\"\";\n-\n-        while !rdr.eof() {\n-            let ch = rdr.read_byte() as u8 as char;\n-            match ch {\n-              // unreserved:\n-              'A' .. 'Z' |\n-              'a' .. 'z' |\n-              '0' .. '9' |\n-              '-' | '.' | '_' | '~' => {\n-                out.push_char(ch);\n-              }\n-              _ => {\n-                  if full_url {\n-                    match ch {\n-                      // gen-delims:\n-                      ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n-\n-                      // sub-delims:\n-                      '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n-                      '+' | ',' | ';' | '=' => {\n-                        out.push_char(ch);\n-                      }\n-\n-                      _ => out.push_str(format!(\"%{:X}\", ch as uint))\n-                    }\n-                } else {\n-                    out.push_str(format!(\"%{:X}\", ch as uint));\n+    let mut rdr = BufReader::new(s.as_bytes());\n+    let mut out = ~\"\";\n+\n+    loop {\n+        let mut buf = [0];\n+        let ch = match rdr.read(buf) {\n+            None => break,\n+            Some(*) => buf[0] as char,\n+        };\n+\n+        match ch {\n+          // unreserved:\n+          'A' .. 'Z' |\n+          'a' .. 'z' |\n+          '0' .. '9' |\n+          '-' | '.' | '_' | '~' => {\n+            out.push_char(ch);\n+          }\n+          _ => {\n+              if full_url {\n+                match ch {\n+                  // gen-delims:\n+                  ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n+\n+                  // sub-delims:\n+                  '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n+                  '+' | ',' | ';' | '=' => {\n+                    out.push_char(ch);\n+                  }\n+\n+                  _ => out.push_str(format!(\"%{:X}\", ch as uint))\n                 }\n-              }\n+            } else {\n+                out.push_str(format!(\"%{:X}\", ch as uint));\n             }\n+          }\n         }\n-\n-        out\n     }\n+\n+    out\n }\n \n /**\n@@ -128,41 +131,49 @@ pub fn encode_component(s: &str) -> ~str {\n }\n \n fn decode_inner(s: &str, full_url: bool) -> ~str {\n-    do io::with_str_reader(s) |rdr| {\n-        let mut out = ~\"\";\n-\n-        while !rdr.eof() {\n-            match rdr.read_char() {\n-              '%' => {\n-                let bytes = rdr.read_bytes(2u);\n-                let ch = uint::parse_bytes(bytes, 16u).unwrap() as u8 as char;\n-\n-                if full_url {\n-                    // Only decode some characters:\n-                    match ch {\n-                      // gen-delims:\n-                      ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n-\n-                      // sub-delims:\n-                      '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n-                      '+' | ',' | ';' | '=' => {\n-                        out.push_char('%');\n-                        out.push_char(bytes[0u] as char);\n-                        out.push_char(bytes[1u] as char);\n-                      }\n-\n-                      ch => out.push_char(ch)\n-                    }\n-                } else {\n-                      out.push_char(ch);\n+    let mut rdr = BufReader::new(s.as_bytes());\n+    let mut out = ~\"\";\n+\n+    loop {\n+        let mut buf = [0];\n+        let ch = match rdr.read(buf) {\n+            None => break,\n+            Some(*) => buf[0] as char\n+        };\n+        match ch {\n+          '%' => {\n+            let mut bytes = [0, 0];\n+            match rdr.read(bytes) {\n+                Some(2) => {}\n+                _ => fail2!() // XXX: malformed url?\n+            }\n+            let ch = uint::parse_bytes(bytes, 16u).unwrap() as u8 as char;\n+\n+            if full_url {\n+                // Only decode some characters:\n+                match ch {\n+                  // gen-delims:\n+                  ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n+\n+                  // sub-delims:\n+                  '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n+                  '+' | ',' | ';' | '=' => {\n+                    out.push_char('%');\n+                    out.push_char(bytes[0u] as char);\n+                    out.push_char(bytes[1u] as char);\n+                  }\n+\n+                  ch => out.push_char(ch)\n                 }\n-              }\n-              ch => out.push_char(ch)\n+            } else {\n+                  out.push_char(ch);\n             }\n+          }\n+          ch => out.push_char(ch)\n         }\n-\n-        out\n     }\n+\n+    out\n }\n \n /**\n@@ -182,22 +193,25 @@ pub fn decode_component(s: &str) -> ~str {\n }\n \n fn encode_plus(s: &str) -> ~str {\n-    do io::with_str_reader(s) |rdr| {\n-        let mut out = ~\"\";\n-\n-        while !rdr.eof() {\n-            let ch = rdr.read_byte() as u8 as char;\n-            match ch {\n-              'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_' | '.' | '-' => {\n-                out.push_char(ch);\n-              }\n-              ' ' => out.push_char('+'),\n-              _ => out.push_str(format!(\"%{:X}\", ch as uint))\n-            }\n-        }\n+    let mut rdr = BufReader::new(s.as_bytes());\n+    let mut out = ~\"\";\n \n-        out\n+    loop {\n+        let mut buf = [0];\n+        let ch = match rdr.read(buf) {\n+            Some(*) => buf[0] as char,\n+            None => break,\n+        };\n+        match ch {\n+          'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '_' | '.' | '-' => {\n+            out.push_char(ch);\n+          }\n+          ' ' => out.push_char('+'),\n+          _ => out.push_str(format!(\"%{:X}\", ch as uint))\n+        }\n     }\n+\n+    out\n }\n \n /**\n@@ -230,78 +244,88 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n  * type into a hashmap.\n  */\n pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n-    do io::with_bytes_reader(s) |rdr| {\n-        let mut m = HashMap::new();\n-        let mut key = ~\"\";\n-        let mut value = ~\"\";\n-        let mut parsing_key = true;\n-\n-        while !rdr.eof() {\n-            match rdr.read_char() {\n-                '&' | ';' => {\n-                    if key != ~\"\" && value != ~\"\" {\n-                        let mut values = match m.pop(&key) {\n-                            Some(values) => values,\n-                            None => ~[],\n-                        };\n-\n-                        values.push(value);\n-                        m.insert(key, values);\n-                    }\n+    let mut rdr = BufReader::new(s);\n+    let mut m = HashMap::new();\n+    let mut key = ~\"\";\n+    let mut value = ~\"\";\n+    let mut parsing_key = true;\n+\n+    loop {\n+        let mut buf = [0];\n+        let ch = match rdr.read(buf) {\n+            Some(*) => buf[0] as char,\n+            None => break,\n+        };\n+        match ch {\n+            '&' | ';' => {\n+                if key != ~\"\" && value != ~\"\" {\n+                    let mut values = match m.pop(&key) {\n+                        Some(values) => values,\n+                        None => ~[],\n+                    };\n \n-                    parsing_key = true;\n-                    key = ~\"\";\n-                    value = ~\"\";\n+                    values.push(value);\n+                    m.insert(key, values);\n                 }\n-                '=' => parsing_key = false,\n-                ch => {\n-                    let ch = match ch {\n-                        '%' => {\n-                            let bytes = rdr.read_bytes(2u);\n-                            uint::parse_bytes(bytes, 16u).unwrap() as u8 as char\n-                        }\n-                        '+' => ' ',\n-                        ch => ch\n-                    };\n \n-                    if parsing_key {\n-                        key.push_char(ch)\n-                    } else {\n-                        value.push_char(ch)\n+                parsing_key = true;\n+                key = ~\"\";\n+                value = ~\"\";\n+            }\n+            '=' => parsing_key = false,\n+            ch => {\n+                let ch = match ch {\n+                    '%' => {\n+                        let mut bytes = [0, 0];\n+                        match rdr.read(bytes) {\n+                            Some(2) => {}\n+                            _ => fail2!() // XXX: malformed?\n+                        }\n+                        uint::parse_bytes(bytes, 16u).unwrap() as u8 as char\n                     }\n+                    '+' => ' ',\n+                    ch => ch\n+                };\n+\n+                if parsing_key {\n+                    key.push_char(ch)\n+                } else {\n+                    value.push_char(ch)\n                 }\n             }\n         }\n+    }\n \n-        if key != ~\"\" && value != ~\"\" {\n-            let mut values = match m.pop(&key) {\n-                Some(values) => values,\n-                None => ~[],\n-            };\n-\n-            values.push(value);\n-            m.insert(key, values);\n-        }\n+    if key != ~\"\" && value != ~\"\" {\n+        let mut values = match m.pop(&key) {\n+            Some(values) => values,\n+            None => ~[],\n+        };\n \n-        m\n+        values.push(value);\n+        m.insert(key, values);\n     }\n+\n+    m\n }\n \n \n fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     let len = s.len();\n     let mut index = len;\n     let mut mat = 0;\n-    do io::with_str_reader(s) |rdr| {\n-        let mut ch;\n-        while !rdr.eof() {\n-            ch = rdr.read_byte() as u8 as char;\n-            if ch == c {\n-                // found a match, adjust markers\n-                index = rdr.tell()-1;\n-                mat = 1;\n-                break;\n-            }\n+    let mut rdr = BufReader::new(s.as_bytes());\n+    loop {\n+        let mut buf = [0];\n+        let ch = match rdr.read(buf) {\n+            Some(*) => buf[0] as char,\n+            None => break,\n+        };\n+        if ch == c {\n+            // found a match, adjust markers\n+            index = (rdr.tell() as uint) - 1;\n+            mat = 1;\n+            break;\n         }\n     }\n     if index+mat == len {"}, {"sha": "30efecde37f9185bda6037f98f925205ed3eb264", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -19,7 +19,13 @@ use arc::{Arc,RWArc};\n use treemap::TreeMap;\n use std::cell::Cell;\n use std::comm::{PortOne, oneshot};\n-use std::{io, os, task};\n+use std::{os, str, task};\n+use std::rt::io;\n+use std::rt::io::Writer;\n+use std::rt::io::Decorator;\n+use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::mem::MemWriter;\n+use std::rt::io::file::FileInfo;\n \n /**\n *\n@@ -174,19 +180,19 @@ impl Database {\n \n     // FIXME #4330: This should have &mut self and should set self.db_dirty to false.\n     fn save(&self) {\n-        let f = io::file_writer(&self.db_filename, [io::Create, io::Truncate]).unwrap();\n-        self.db_cache.to_json().to_pretty_writer(f);\n+        let f = @mut self.db_filename.open_writer(io::CreateOrTruncate);\n+        self.db_cache.to_json().to_pretty_writer(f as @mut io::Writer);\n     }\n \n     fn load(&mut self) {\n         assert!(!self.db_dirty);\n         assert!(os::path_exists(&self.db_filename));\n-        let f = io::file_reader(&self.db_filename);\n+        let f = self.db_filename.open_reader(io::Open);\n         match f {\n-            Err(e) => fail!(\"Couldn't load workcache database {}: {}\",\n-                            self.db_filename.display(), e.to_str()),\n-            Ok(r) =>\n-                match json::from_reader(r) {\n+            None => fail!(\"Couldn't load workcache database {}\",\n+                          self.db_filename.display()),\n+            Some(r) =>\n+                match json::from_reader(@mut r as @mut io::Reader) {\n                     Err(e) => fail!(\"Couldn't parse workcache database (from file {}): {}\",\n                                     self.db_filename.display(), e.to_str()),\n                     Ok(r) => {\n@@ -256,20 +262,18 @@ enum Work<'self, T> {\n }\n \n fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n-    do io::with_str_writer |wr| {\n-        let mut encoder = json::Encoder(wr);\n-        t.encode(&mut encoder);\n-    }\n+    let writer = @mut MemWriter::new();\n+    let mut encoder = json::Encoder(writer as @mut io::Writer);\n+    t.encode(&mut encoder);\n+    str::from_utf8(writer.inner_ref().as_slice())\n }\n \n // FIXME(#5121)\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n     debug!(\"json decoding: {}\", s);\n-    do io::with_str_reader(s) |rdr| {\n-        let j = json::from_reader(rdr).unwrap();\n-        let mut decoder = json::Decoder(j);\n-        Decodable::decode(&mut decoder)\n-    }\n+    let j = json::from_str(s).unwrap();\n+    let mut decoder = json::Decoder(j);\n+    Decodable::decode(&mut decoder)\n }\n \n fn digest<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n@@ -280,8 +284,8 @@ fn digest<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n \n fn digest_file(path: &Path) -> ~str {\n     let mut sha = ~Sha1::new();\n-    let s = io::read_whole_file_str(path);\n-    (*sha).input_str(s.unwrap());\n+    let s = path.open_reader(io::Open).read_to_end();\n+    (*sha).input(s);\n     (*sha).result_str()\n }\n \n@@ -492,7 +496,6 @@ impl<'self, T:Send +\n \n #[test]\n fn test() {\n-    use std::io::WriterUtil;\n     use std::{os, run};\n \n     // Create a path to a new file 'filename' in the directory in which\n@@ -507,8 +510,7 @@ fn test() {\n \n     let pth = make_path(~\"foo.c\");\n     {\n-        let r = io::file_writer(&pth, [io::Create]);\n-        r.unwrap().write_str(\"int main() { return 0; }\");\n+        pth.open_writer(io::Create).write(bytes!(\"int main() { return 0; }\"));\n     }\n \n     let db_path = make_path(~\"db.json\");\n@@ -539,5 +541,5 @@ fn test() {\n         }\n     };\n \n-    io::println(s);\n+    println(s);\n }"}, {"sha": "1b9cb10f1dcfdcb1dcd0715cdce16ac5220bf505", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -26,7 +26,6 @@ use std::c_str::ToCStr;\n use std::char;\n use std::hash::Streaming;\n use std::hash;\n-use std::io;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n use std::os;\n use std::ptr;\n@@ -930,7 +929,7 @@ pub fn link_binary(sess: Session,\n     let cc_args = link_args(sess, obj_filename, out_filename, lm);\n     debug!(\"{} link args: {}\", cc_prog, cc_args.connect(\" \"));\n     if (sess.opts.debugging_opts & session::print_link_args) != 0 {\n-        io::println(format!(\"{} link args: {}\", cc_prog, cc_args.connect(\" \")));\n+        println!(\"{} link args: {}\", cc_prog, cc_args.connect(\" \"));\n     }\n \n     // We run 'cc' here"}, {"sha": "d2b0dad80f656401fb0b8885af15e6596e29315f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -26,7 +26,8 @@ use util::common::time;\n use util::ppaux;\n \n use std::hashmap::{HashMap,HashSet};\n-use std::io;\n+use std::rt::io;\n+use std::rt::io::mem::MemReader;\n use std::os;\n use std::vec;\n use extra::getopts::groups::{optopt, optmulti, optflag, optflagopt};\n@@ -552,17 +553,16 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src = sess.codemap.get_filemap(source_name(input)).src;\n-    do io::with_str_reader(src) |rdr| {\n-        pprust::print_crate(sess.codemap,\n-                            token::get_ident_interner(),\n-                            sess.span_diagnostic,\n-                            &crate,\n-                            source_name(input),\n-                            rdr,\n-                            io::stdout(),\n-                            annotation,\n-                            is_expanded);\n-    }\n+    let rdr = @mut MemReader::new(src.as_bytes().to_owned());\n+    pprust::print_crate(sess.codemap,\n+                        token::get_ident_interner(),\n+                        sess.span_diagnostic,\n+                        &crate,\n+                        source_name(input),\n+                        rdr as @mut io::Reader,\n+                        @mut io::stdout() as @mut io::Writer,\n+                        annotation,\n+                        is_expanded);\n }\n \n pub fn get_os(triple: &str) -> Option<session::Os> {\n@@ -1048,7 +1048,7 @@ pub fn early_error(emitter: @diagnostic::Emitter, msg: &str) -> ! {\n     fail!();\n }\n \n-pub fn list_metadata(sess: Session, path: &Path, out: @io::Writer) {\n+pub fn list_metadata(sess: Session, path: &Path, out: @mut io::Writer) {\n     metadata::loader::list_file_metadata(\n         token::get_ident_interner(),\n         session::sess_os_to_meta_os(sess.targ_cfg.os), path, out);"}, {"sha": "be118792f4987510b244c40d56378985f76ee21d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -27,8 +27,7 @@ use middle::astencode::vtable_decoder_helpers;\n \n \n use std::u64;\n-use std::io::WriterUtil;\n-use std::io;\n+use std::rt::io;\n use std::option;\n use std::str;\n use std::vec;\n@@ -56,14 +55,14 @@ fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: u64) ->\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + (hash % 256 * 4) as uint;\n-    let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4) as uint;\n+    let pos = ::std::io::u64_from_be_bytes(*d.data, hash_pos, 4) as uint;\n     let tagged_doc = reader::doc_at(d.data, pos);\n \n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n     do reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n-        let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4) as uint;\n+        let pos = ::std::io::u64_from_be_bytes(*elt.data, elt.start, 4) as uint;\n         if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n             ret = Some(reader::doc_at(d.data, pos).doc);\n             false\n@@ -78,7 +77,7 @@ pub type GetCrateDataCb<'self> = &'self fn(ast::CrateNum) -> Cmd;\n \n pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n-        return io::u64_from_be_bytes(\n+        return ::std::io::u64_from_be_bytes(\n             bytes.slice(0u, 4u), 0u, 4u) as int\n             == item_id;\n     }\n@@ -1254,7 +1253,7 @@ fn family_names_type(fam: Family) -> bool {\n \n fn read_path(d: ebml::Doc) -> (~str, uint) {\n     do reader::with_doc_data(d) |desc| {\n-        let pos = io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n+        let pos = ::std::io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n         let pathbytes = desc.slice(4u, desc.len());\n         let path = str::from_utf8(pathbytes);\n \n@@ -1353,23 +1352,23 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n \n fn list_meta_items(intr: @ident_interner,\n                    meta_items: ebml::Doc,\n-                   out: @io::Writer) {\n+                   out: @mut io::Writer) {\n     let r = get_meta_items(meta_items);\n     for mi in r.iter() {\n-        out.write_str(format!(\"{}\\n\", pprust::meta_item_to_str(*mi, intr)));\n+        write!(out, \"{}\\n\", pprust::meta_item_to_str(*mi, intr));\n     }\n }\n \n fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n-                         out: @io::Writer) {\n-    out.write_str(format!(\"=Crate Attributes ({})=\\n\", hash));\n+                         out: @mut io::Writer) {\n+    write!(out, \"=Crate Attributes ({})=\\n\", hash);\n \n     let r = get_attributes(md);\n     for attr in r.iter() {\n-        out.write_str(format!(\"{}\\n\", pprust::attribute_to_str(attr, intr)));\n+        write!(out, \"{}\\n\", pprust::attribute_to_str(attr, intr));\n     }\n \n-    out.write_str(\"\\n\\n\");\n+    write!(out, \"\\n\\n\");\n }\n \n pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::Attribute] {\n@@ -1404,17 +1403,16 @@ pub fn get_crate_deps(data: @~[u8]) -> ~[CrateDep] {\n     return deps;\n }\n \n-fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n-    out.write_str(\"=External Dependencies=\\n\");\n+fn list_crate_deps(data: @~[u8], out: @mut io::Writer) {\n+    write!(out, \"=External Dependencies=\\n\");\n \n     let r = get_crate_deps(data);\n     for dep in r.iter() {\n-        out.write_str(\n-            format!(\"{} {}-{}-{}\\n\",\n-                 dep.cnum, token::ident_to_str(&dep.name), dep.hash, dep.vers));\n+        write!(out, \"{} {}-{}-{}\\n\",\n+                 dep.cnum, token::ident_to_str(&dep.name), dep.hash, dep.vers);\n     }\n \n-    out.write_str(\"\\n\");\n+    write!(out, \"\\n\");\n }\n \n pub fn get_crate_hash(data: @~[u8]) -> @str {\n@@ -1434,7 +1432,7 @@ pub fn get_crate_vers(data: @~[u8]) -> @str {\n }\n \n pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n-                           out: @io::Writer) {\n+                           out: @mut io::Writer) {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n     list_crate_attributes(intr, md, hash, out);"}, {"sha": "e6d6b282572184213d54ac313bbfe408f905f225", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -1819,7 +1819,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n             }\n         }\n \n-        io::println(\"metadata stats:\");\n+        println(\"metadata stats:\");\n         println!(\"    inline bytes: {}\", ecx.stats.inline_bytes);\n         println!(\" attribute bytes: {}\", ecx.stats.attr_bytes);\n         println!(\"       dep bytes: {}\", ecx.stats.dep_bytes);"}, {"sha": "34eb387a3f5d4c47df12b2d945ade5b4dd07a565", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -25,7 +25,7 @@ use syntax::attr::AttrMetaMethods;\n \n use std::c_str::ToCStr;\n use std::cast;\n-use std::io;\n+use std::rt::io;\n use std::num;\n use std::option;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n@@ -271,11 +271,11 @@ pub fn read_meta_section_name(os: Os) -> &'static str {\n pub fn list_file_metadata(intr: @ident_interner,\n                           os: Os,\n                           path: &Path,\n-                          out: @io::Writer) {\n+                          out: @mut io::Writer) {\n     match get_metadata_section(os, path) {\n       option::Some(bytes) => decoder::list_crate_metadata(intr, bytes, out),\n       option::None => {\n-        out.write_str(format!(\"could not find metadata in {}.\\n\", path.display()))\n+        write!(out, \"could not find metadata in {}.\\n\", path.display())\n       }\n     }\n }"}, {"sha": "55daff90e62e2e2b965748269cf42eeef8f5a062", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -21,7 +21,6 @@ use util::common::stmt_set;\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n use std::hashmap::{HashSet, HashMap};\n-use std::io;\n use std::ops::{BitOr, BitAnd};\n use std::result::{Result};\n use syntax::ast;\n@@ -99,7 +98,7 @@ pub fn check_crate(\n     visit::walk_crate(bccx, crate, ());\n \n     if tcx.sess.borrowck_stats() {\n-        io::println(\"--- borrowck stats ---\");\n+        println(\"--- borrowck stats ---\");\n         println!(\"paths requiring guarantees: {}\",\n                  bccx.stats.guaranteed_paths);\n         println!(\"paths requiring loans     : {}\","}, {"sha": "7ad55936b9ed737a0ab698a1e94ce43952e82b19", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -18,7 +18,7 @@\n \n \n use std::cast;\n-use std::io;\n+use std::rt::io;\n use std::uint;\n use std::vec;\n use std::hashmap::HashMap;\n@@ -349,12 +349,12 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n         debug!(\"Dataflow result:\");\n         debug!(\"{}\", {\n             let this = @(*self).clone();\n-            this.pretty_print_to(io::stderr(), blk);\n+            this.pretty_print_to(@mut io::stderr() as @mut io::Writer, blk);\n             \"\"\n         });\n     }\n \n-    fn pretty_print_to(@self, wr: @io::Writer, blk: &ast::Block) {\n+    fn pretty_print_to(@self, wr: @mut io::Writer, blk: &ast::Block) {\n         let ps = pprust::rust_printer_annotated(wr,\n                                                 self.tcx.sess.intr(),\n                                                 self as @pprust::pp_ann);"}, {"sha": "695f4a6fd13b5a1ef04571a7d9b8607fb7e8cf76", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -111,7 +111,8 @@ use middle::moves;\n \n use std::cast::transmute;\n use std::hashmap::HashMap;\n-use std::io;\n+use std::rt::io;\n+use std::str;\n use std::to_str;\n use std::uint;\n use std::vec;\n@@ -739,15 +740,14 @@ impl Liveness {\n     }\n \n     pub fn write_vars(&self,\n-                      wr: @io::Writer,\n+                      wr: &mut io::Writer,\n                       ln: LiveNode,\n                       test: &fn(uint) -> LiveNode) {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for var_idx in range(0u, self.ir.num_vars) {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n-                wr.write_str(\" \");\n-                wr.write_str(Variable(var_idx).to_str());\n+                write!(wr, \" {}\", Variable(var_idx).to_str());\n             }\n         }\n     }\n@@ -784,20 +784,14 @@ impl Liveness {\n     }\n \n     pub fn ln_str(&self, ln: LiveNode) -> ~str {\n-        do io::with_str_writer |wr| {\n-            wr.write_str(\"[ln(\");\n-            wr.write_uint(*ln);\n-            wr.write_str(\") of kind \");\n-            wr.write_str(format!(\"{:?}\", self.ir.lnks[*ln]));\n-            wr.write_str(\" reads\");\n+        str::from_utf8_owned(do io::mem::with_mem_writer |wr| {\n+            let wr = wr as &mut io::Writer;\n+            write!(wr, \"[ln({}) of kind {:?} reads\", *ln, self.ir.lnks[*ln]);\n             self.write_vars(wr, ln, |idx| self.users[idx].reader );\n-            wr.write_str(\"  writes\");\n+            write!(wr, \"  writes\");\n             self.write_vars(wr, ln, |idx| self.users[idx].writer );\n-            wr.write_str(\" \");\n-            wr.write_str(\" precedes \");\n-            wr.write_str((self.successors[*ln]).to_str());\n-            wr.write_str(\"]\");\n-        }\n+            write!(wr, \"  precedes {}]\", self.successors[*ln].to_str());\n+        })\n     }\n \n     pub fn init_empty(&self, ln: LiveNode, succ_ln: LiveNode) {"}, {"sha": "8b5167b7e8fa5257fbb636a36ce4836079c4cef3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -70,7 +70,6 @@ use middle::trans::type_::Type;\n use std::c_str::ToCStr;\n use std::hash;\n use std::hashmap::HashMap;\n-use std::io;\n use std::libc::c_uint;\n use std::vec;\n use std::local_data;\n@@ -3163,7 +3162,7 @@ pub fn trans_crate(sess: session::Session,\n     // Translate the metadata.\n     write_metadata(ccx, &crate);\n     if ccx.sess.trans_stats() {\n-        io::println(\"--- trans stats ---\");\n+        println(\"--- trans stats ---\");\n         println!(\"n_static_tydescs: {}\", ccx.stats.n_static_tydescs);\n         println!(\"n_glues_created: {}\", ccx.stats.n_glues_created);\n         println!(\"n_null_glues: {}\", ccx.stats.n_null_glues);\n@@ -3173,7 +3172,7 @@ pub fn trans_crate(sess: session::Session,\n         println!(\"n_monos: {}\", ccx.stats.n_monos);\n         println!(\"n_inlines: {}\", ccx.stats.n_inlines);\n         println!(\"n_closures: {}\", ccx.stats.n_closures);\n-        io::println(\"fn stats:\");\n+        println(\"fn stats:\");\n         do sort::quick_sort(ccx.stats.fn_stats) |&(_, _, insns_a), &(_, _, insns_b)| {\n             insns_a > insns_b\n         }"}, {"sha": "ce50397d00322528679ebeed5b595b0efdaa45e7", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -36,7 +36,8 @@ use driver::session;\n use middle::lint;\n \n use std::comm;\n-use std::io;\n+use std::rt::io;\n+use std::rt::io::extensions::ReaderUtil;\n use std::num;\n use std::os;\n use std::result;\n@@ -181,7 +182,7 @@ Available lint options:\n                  lint::level_to_str(spec.default),\n                  spec.desc);\n     }\n-    io::println(\"\");\n+    println(\"\");\n }\n \n pub fn describe_debug_flags() {\n@@ -247,7 +248,7 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n       1u => {\n         let ifile = matches.free[0].as_slice();\n         if \"-\" == ifile {\n-            let src = str::from_utf8(io::stdin().read_whole_stream());\n+            let src = str::from_utf8(io::stdin().read_to_end());\n             str_input(src.to_managed())\n         } else {\n             file_input(Path::new(ifile))\n@@ -275,7 +276,7 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n     if ls {\n         match input {\n           file_input(ref ifile) => {\n-            list_metadata(sess, &(*ifile), io::stdout());\n+            list_metadata(sess, &(*ifile), @mut io::stdout() as @mut io::Writer);\n           }\n           str_input(_) => {\n             early_error(demitter, \"can not list metadata for stdin\");"}, {"sha": "c0fab1ad98f2f6288823f387a8d4f272422bff48", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -28,6 +28,9 @@ use std::local_data;\n use std::rt::io::Writer;\n use std::rt::io::file::FileInfo;\n use std::rt::io;\n+use std::rt::io::mem::MemWriter;\n+use std::rt::io::Decorator;\n+use std::str;\n use extra::getopts;\n use extra::getopts::groups;\n use extra::json;\n@@ -257,11 +260,11 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, ~str> {\n-    let input = match ::std::io::file_reader(&Path::new(input)) {\n-        Ok(i) => i,\n-        Err(s) => return Err(s),\n+    let input = match Path::new(input).open_reader(io::Open) {\n+        Some(f) => f,\n+        None => return Err(format!(\"couldn't open {} for reading\", input)),\n     };\n-    match json::from_reader(input) {\n+    match json::from_reader(@mut input as @mut io::Reader) {\n         Err(s) => Err(s.to_str()),\n         Ok(json::Object(obj)) => {\n             let mut obj = obj;\n@@ -306,8 +309,10 @@ fn json_output(crate: clean::Crate, res: ~[plugins::PluginJson], dst: Path) {\n \n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n     // straight to the Rust JSON representation.\n-    let crate_json_str = do std::io::with_str_writer |w| {\n-        crate.encode(&mut json::Encoder(w));\n+    let crate_json_str = {\n+        let w = @mut MemWriter::new();\n+        crate.encode(&mut json::Encoder(w as @mut io::Writer));\n+        str::from_utf8(*w.inner_ref())\n     };\n     let crate_json = match json::from_str(crate_json_str) {\n         Ok(j) => j,"}, {"sha": "bee21d70b2d8744c8984e7ec773d0bf45f6933a1", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -10,7 +10,7 @@\n \n // Context data structure used by rustpkg\n \n-use std::{io, os};\n+use std::os;\n use extra::workcache;\n use rustc::driver::session::{OptLevel, No};\n \n@@ -243,43 +243,43 @@ pub fn flags_forbidden_for_cmd(flags: &RustcFlags,\n     };\n \n     if flags.linker.is_some() && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The --linker option can only be used with the build or install commands.\");\n+        println(\"The --linker option can only be used with the build or install commands.\");\n         return true;\n     }\n     if flags.link_args.is_some() && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The --link-args option can only be used with the build or install commands.\");\n+        println(\"The --link-args option can only be used with the build or install commands.\");\n         return true;\n     }\n \n     if !cfgs.is_empty() && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The --cfg option can only be used with the build or install commands.\");\n+        println(\"The --cfg option can only be used with the build or install commands.\");\n         return true;\n     }\n \n     if user_supplied_opt_level && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The -O and --opt-level options can only be used with the build \\\n+        println(\"The -O and --opt-level options can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n \n     if flags.save_temps  && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The --save-temps option can only be used with the build \\\n+        println(\"The --save-temps option can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n \n     if flags.target.is_some()  && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The --target option can only be used with the build \\\n+        println(\"The --target option can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n     if flags.target_cpu.is_some()  && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The --target-cpu option can only be used with the build \\\n+        println(\"The --target-cpu option can only be used with the build \\\n                     or install commands.\");\n         return true;\n     }\n     if flags.experimental_features.is_some() && cmd != \"build\" && cmd != \"install\" {\n-        io::println(\"The -Z option can only be used with the build or install commands.\");\n+        println(\"The -Z option can only be used with the build or install commands.\");\n         return true;\n     }\n "}, {"sha": "79c8ff794ab5613475cbde76a56c7e3ad92b41c7", "filename": "src/librustpkg/messages.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Fmessages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Fmessages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fmessages.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -9,31 +9,38 @@\n // except according to those terms.\n \n use extra::term;\n-use std::io;\n+use std::rt::io;\n \n pub fn note(msg: &str) {\n-    pretty_message(msg, \"note: \", term::color::GREEN, io::stdout())\n+    pretty_message(msg, \"note: \", term::color::GREEN,\n+                   @mut io::stdout() as @mut io::Writer)\n }\n \n pub fn warn(msg: &str) {\n-    pretty_message(msg, \"warning: \", term::color::YELLOW, io::stdout())\n+    pretty_message(msg, \"warning: \", term::color::YELLOW,\n+                   @mut io::stdout() as @mut io::Writer)\n }\n \n pub fn error(msg: &str) {\n-    pretty_message(msg, \"error: \", term::color::RED, io::stdout())\n+    pretty_message(msg, \"error: \", term::color::RED,\n+                   @mut io::stdout() as @mut io::Writer)\n }\n \n-fn pretty_message<'a>(msg: &'a str, prefix: &'a str, color: term::color::Color, out: @io::Writer) {\n+fn pretty_message<'a>(msg: &'a str,\n+                      prefix: &'a str,\n+                      color: term::color::Color,\n+                      out: @mut io::Writer) {\n     let term = term::Terminal::new(out);\n     match term {\n         Ok(ref t) => {\n             t.fg(color);\n-            out.write_str(prefix);\n+            out.write(prefix.as_bytes());\n             t.reset();\n         },\n         _ => {\n-            out.write_str(prefix);\n+            out.write(prefix.as_bytes());\n         }\n     }\n-    out.write_line(msg);\n+    out.write(msg.as_bytes());\n+    out.write(['\\n' as u8]);\n }"}, {"sha": "bd3a1b2f672821aa565b9141592700c38d56bee8", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -24,7 +24,7 @@ extern mod extra;\n extern mod rustc;\n extern mod syntax;\n \n-use std::{io, os, result, run, str, task};\n+use std::{os, result, run, str, task};\n pub use std::path::Path;\n \n use extra::workcache;\n@@ -346,7 +346,7 @@ impl CtxMethods for BuildContext {\n                 }\n             }\n             \"list\" => {\n-                io::println(\"Installed packages:\");\n+                println(\"Installed packages:\");\n                 do installed_packages::list_installed_packages |pkg_id| {\n                     do pkg_id.path.display().with_str |s| {\n                         println(s);\n@@ -726,7 +726,7 @@ impl CtxMethods for BuildContext {\n }\n \n pub fn main() {\n-    io::println(\"WARNING: The Rust package manager is experimental and may be unstable\");\n+    println(\"WARNING: The Rust package manager is experimental and may be unstable\");\n     os::set_exit_status(main_args(os::args()));\n }\n "}, {"sha": "c3e4205dfc972385a18a508776a2bf6fb11277db", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -10,7 +10,7 @@\n \n // Utils for working with version control repositories. Just git right now.\n \n-use std::{io, os, run, str};\n+use std::{os, run, str};\n use std::run::{ProcessOutput, ProcessOptions, Process};\n use extra::tempfile::TempDir;\n use version::*;\n@@ -36,8 +36,8 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n                                                    source.as_str().unwrap().to_owned(),\n                                                    target.as_str().unwrap().to_owned()]);\n             if outp.status != 0 {\n-                io::println(str::from_utf8_owned(outp.output.clone()));\n-                io::println(str::from_utf8_owned(outp.error));\n+                println(str::from_utf8_owned(outp.output.clone()));\n+                println(str::from_utf8_owned(outp.error));\n                 return DirToUse(target.clone());\n             }\n                 else {\n@@ -52,8 +52,8 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n                              format!(\"--git-dir={}\", git_dir.as_str().unwrap().to_owned()),\n                              ~\"checkout\", format!(\"{}\", *s)]);\n                         if outp.status != 0 {\n-                            io::println(str::from_utf8_owned(outp.output.clone()));\n-                            io::println(str::from_utf8_owned(outp.error));\n+                            println(str::from_utf8_owned(outp.output.clone()));\n+                            println(str::from_utf8_owned(outp.error));\n                             return DirToUse(target.clone());\n                         }\n                     }"}, {"sha": "6c9a63fe7bd8a6c8973df812b190a25a4a0b293e", "filename": "src/librustpkg/testsuite/fail/src/no-inferred-crates/src/zzyzx.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Ftestsuite%2Ffail%2Fsrc%2Fno-inferred-crates%2Fsrc%2Fzzyzx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Ftestsuite%2Ffail%2Fsrc%2Fno-inferred-crates%2Fsrc%2Fzzyzx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Ffail%2Fsrc%2Fno-inferred-crates%2Fsrc%2Fzzyzx.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -15,8 +15,6 @@ The test runner should check that, after `rustpkg build hello-world`:\n   * testsuite/hello-world/build/ does not contain a library\n */\n \n-use std::io;\n-\n fn main() {\n-    io::println(~\"Hello world!\");\n+    println(~\"Hello world!\");\n }"}, {"sha": "d4c65954fe6298ee5258767a7a78f4043f94534e", "filename": "src/librustpkg/testsuite/pass/src/hello-world/main.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fhello-world%2Fmain.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -18,8 +18,6 @@ The test runner should check that, after `rustpkg build hello-world`:\n   * testsuite/pass/hello-world/build is empty\n */\n \n-use std::io;\n-\n fn main() {\n-    io::println(~\"Hello world!\");\n+    println(~\"Hello world!\");\n }"}, {"sha": "ef6ac485b7294f80cf91a67bec7c6604daf43c30", "filename": "src/librustpkg/usage.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fusage.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n-\n pub fn general() {\n-    io::println(\"Usage: rustpkg [options] <cmd> [args..]\n+    println(\"Usage: rustpkg [options] <cmd> [args..]\n \n Where <cmd> is one of:\n     build, clean, do, info, install, list, prefer, test, uninstall, unprefer\n@@ -24,7 +22,7 @@ Options:\n }\n \n pub fn build() {\n-    io::println(\"rustpkg build [options..] [package-ID]\n+    println(\"rustpkg build [options..] [package-ID]\n \n Build the given package ID if specified. With no package ID argument,\n build the package in the current directory. In that case, the current\n@@ -50,21 +48,21 @@ Options:\n }\n \n pub fn clean() {\n-    io::println(\"rustpkg clean\n+    println(\"rustpkg clean\n \n Remove all build files in the work cache for the package in the current\n directory.\");\n }\n \n pub fn do_cmd() {\n-    io::println(\"rustpkg do <cmd>\n+    println(\"rustpkg do <cmd>\n \n Runs a command in the package script. You can listen to a command\n by tagging a function with the attribute `#[pkg_do(cmd)]`.\");\n }\n \n pub fn info() {\n-    io::println(\"rustpkg [options..] info\n+    println(\"rustpkg [options..] info\n \n Probe the package script in the current directory for information.\n \n@@ -73,13 +71,13 @@ Options:\n }\n \n pub fn list() {\n-    io::println(\"rustpkg list\n+    println(\"rustpkg list\n \n List all installed packages.\");\n }\n \n pub fn install() {\n-    io::println(\"rustpkg install [options..] [package-ID]\n+    println(\"rustpkg install [options..] [package-ID]\n \n Install the given package ID if specified. With no package ID\n argument, install the package in the current directory.\n@@ -105,14 +103,14 @@ Options:\n }\n \n pub fn uninstall() {\n-    io::println(\"rustpkg uninstall <id|name>[@version]\n+    println(\"rustpkg uninstall <id|name>[@version]\n \n Remove a package by id or name and optionally version. If the package(s)\n is/are depended on by another package then they cannot be removed.\");\n }\n \n pub fn prefer() {\n-    io::println(\"rustpkg [options..] prefer <id|name>[@version]\n+    println(\"rustpkg [options..] prefer <id|name>[@version]\n \n By default all binaries are given a unique name so that multiple versions can\n coexist. The prefer command will symlink the uniquely named binary to\n@@ -130,7 +128,7 @@ Example:\n }\n \n pub fn unprefer() {\n-    io::println(\"rustpkg [options..] unprefer <id|name>[@version]\n+    println(\"rustpkg [options..] unprefer <id|name>[@version]\n \n Remove all symlinks from the store to the binary directory for a package\n name and optionally version. If version is not supplied, the latest version\n@@ -139,7 +137,7 @@ information.\");\n }\n \n pub fn test() {\n-    io::println(\"rustpkg [options..] test\n+    println(\"rustpkg [options..] test\n \n Build all test crates in the current directory with the test flag.\n Then, run all the resulting test executables, redirecting the output\n@@ -150,7 +148,7 @@ Options:\n }\n \n pub fn init() {\n-    io::println(\"rustpkg init\n+    println(\"rustpkg init\n \n This will turn the current working directory into a workspace. The first\n command you run when starting off a new project."}, {"sha": "b68e42d8ebe2423dcc63ba757d3ebd597ef17851", "filename": "src/librustpkg/workcache_support.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Fworkcache_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibrustpkg%2Fworkcache_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkcache_support.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -8,33 +8,37 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::rt::io;\n+use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::file::FileInfo;\n+\n use extra::sha1::Sha1;\n use extra::digest::Digest;\n use extra::workcache;\n-use std::io;\n \n /// Hashes the file contents along with the last-modified time\n pub fn digest_file_with_date(path: &Path) -> ~str {\n     use conditions::bad_path::cond;\n     use cond1 = conditions::bad_stat::cond;\n \n-    let s = io::read_whole_file_str(path);\n-    match s {\n-        Ok(s) => {\n+    let mut err = None;\n+    let bytes = do io::io_error::cond.trap(|e| err = Some(e)).inside {\n+        path.open_reader(io::Open).read_to_end()\n+    };\n+    match err {\n+        None => {\n             let mut sha = Sha1::new();\n-            sha.input_str(s);\n+            sha.input(bytes);\n             let st = match path.stat() {\n                 Some(st) => st,\n                 None => cond1.raise((path.clone(), format!(\"Couldn't get file access time\")))\n             };\n             sha.input_str(st.modified.to_str());\n             sha.result_str()\n         }\n-        Err(e) => {\n-            let path = cond.raise((path.clone(), format!(\"Couldn't read file: {}\", e)));\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n-            // XXX: I'm pretty sure this is the wrong return value\n-            path.as_str().unwrap().to_owned()\n+        Some(e) => {\n+            cond.raise((path.clone(), format!(\"Couldn't read file: {}\", e.desc)));\n+            ~\"\"\n         }\n     }\n }"}, {"sha": "2ffe654d3bdbc7f9a79a34cd1d3adf7da0a7443c", "filename": "src/libstd/io.rs", "status": "modified", "additions": 10, "deletions": 374, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -65,15 +65,17 @@ use ptr;\n use result::{Result, Ok, Err};\n use str::{StrSlice, OwnedStr};\n use str;\n-use to_str::ToStr;\n use uint;\n use vec::{MutableVector, ImmutableVector, OwnedVector, OwnedCopyableVector, CopyableVector};\n use vec;\n \n+#[cfg(stage0)]\n+pub use rt::io::stdio::{print, println};\n+\n #[allow(non_camel_case_types)] // not sure what to do about this\n-pub type fd_t = c_int;\n+type fd_t = c_int;\n \n-pub mod rustrt {\n+mod rustrt {\n     use libc;\n \n     #[link_name = \"rustrt\"]\n@@ -1013,7 +1015,7 @@ pub struct FILERes {\n }\n \n impl FILERes {\n-    pub fn new(f: *libc::FILE) -> FILERes {\n+    fn new(f: *libc::FILE) -> FILERes {\n         FILERes { f: f }\n     }\n }\n@@ -1028,37 +1030,6 @@ impl Drop for FILERes {\n     }\n }\n \n-pub fn FILE_reader(f: *libc::FILE, cleanup: bool) -> @Reader {\n-    if cleanup {\n-        @Wrapper { base: f, cleanup: FILERes::new(f) } as @Reader\n-    } else {\n-        @f as @Reader\n-    }\n-}\n-\n-// FIXME (#2004): this should either be an trait-less impl, a set of\n-// top-level functions that take a reader, or a set of default methods on\n-// reader (which can then be called reader)\n-\n-/**\n-* Gives a `Reader` that allows you to read values from standard input.\n-*\n-* # Example\n-*\n-* ```rust\n-* let stdin = std::io::stdin();\n-* let line = stdin.read_line();\n-* std::io::print(line);\n-* ```\n-*/\n-pub fn stdin() -> @Reader {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    unsafe {\n-        @rustrt::rust_get_stdin() as @Reader\n-    }\n-}\n-\n pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -1073,71 +1044,10 @@ pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n             Err(~\"error opening \" + p)\n         }\n     } else {\n-        Ok(FILE_reader(f, true))\n-    }\n-}\n-\n-\n-// Byte readers\n-pub struct BytesReader {\n-    // FIXME(#5723) see other FIXME below\n-    // FIXME(#7268) this should also be parameterized over <'self>\n-    bytes: &'static [u8],\n-    pos: @mut uint\n-}\n-\n-impl Reader for BytesReader {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        let count = num::min(len, self.bytes.len() - *self.pos);\n-\n-        let view = self.bytes.slice(*self.pos, self.bytes.len());\n-        vec::bytes::copy_memory(bytes, view, count);\n-\n-        *self.pos += count;\n-\n-        count\n-    }\n-\n-    fn read_byte(&self) -> int {\n-        if *self.pos == self.bytes.len() {\n-            return -1;\n-        }\n-\n-        let b = self.bytes[*self.pos];\n-        *self.pos += 1u;\n-        b as int\n-    }\n-\n-    fn eof(&self) -> bool {\n-        *self.pos == self.bytes.len()\n-    }\n-\n-    fn seek(&self, offset: int, whence: SeekStyle) {\n-        let pos = *self.pos;\n-        *self.pos = seek_in_buf(offset, pos, self.bytes.len(), whence);\n-    }\n-\n-    fn tell(&self) -> uint {\n-        *self.pos\n+        Ok(@Wrapper { base: f, cleanup: FILERes::new(f) } as @Reader)\n     }\n }\n \n-pub fn with_bytes_reader<T>(bytes: &[u8], f: &fn(@Reader) -> T) -> T {\n-    // XXX XXX XXX this is glaringly unsound\n-    // FIXME(#5723) Use a &Reader for the callback's argument. Should be:\n-    // fn with_bytes_reader<'r, T>(bytes: &'r [u8], f: &fn(&'r Reader) -> T) -> T\n-    let bytes: &'static [u8] = unsafe { cast::transmute(bytes) };\n-    f(@BytesReader {\n-        bytes: bytes,\n-        pos: @mut 0\n-    } as @Reader)\n-}\n-\n-pub fn with_str_reader<T>(s: &str, f: &fn(@Reader) -> T) -> T {\n-    // FIXME(#5723): As above.\n-    with_bytes_reader(s.as_bytes(), f)\n-}\n-\n // Writing\n pub enum FileFlag { Append, Create, Truncate, NoFlag, }\n \n@@ -1286,7 +1196,7 @@ pub struct FdRes {\n }\n \n impl FdRes {\n-    pub fn new(fd: fd_t) -> FdRes {\n+    fn new(fd: fd_t) -> FdRes {\n         FdRes { fd: fd }\n     }\n }\n@@ -1301,15 +1211,6 @@ impl Drop for FdRes {\n     }\n }\n \n-pub fn fd_writer(fd: fd_t, cleanup: bool) -> @Writer {\n-    if cleanup {\n-        @Wrapper { base: fd, cleanup: FdRes::new(fd) } as @Writer\n-    } else {\n-        @fd as @Writer\n-    }\n-}\n-\n-\n pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n                    -> Result<@Writer, ~str> {\n     #[fixed_stack_segment]; #[inline(never)];\n@@ -1339,7 +1240,7 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n     if fd < (0 as c_int) {\n         Err(format!(\"error opening {}: {}\", path.display(), os::last_os_error()))\n     } else {\n-        Ok(fd_writer(fd, true))\n+        Ok(@Wrapper { base: fd, cleanup: FdRes::new(fd) } as @Writer)\n     }\n }\n \n@@ -1615,64 +1516,6 @@ pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<@Writer, ~str> {\n // FIXME (#2004) why are these different from the way stdin() is\n // implemented?\n \n-\n-/**\n-* Gives a `Writer` which allows you to write to the standard output.\n-*\n-* # Example\n-*\n-* ```rust\n-* let stdout = std::io::stdout();\n-* stdout.write_str(\"hello\\n\");\n-* ```\n-*/\n-pub fn stdout() -> @Writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n-\n-/**\n-* Gives a `Writer` which allows you to write to standard error.\n-*\n-* # Example\n-*\n-* ```rust\n-* let stderr = std::io::stderr();\n-* stderr.write_str(\"hello\\n\");\n-* ```\n-*/\n-pub fn stderr() -> @Writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n-\n-/**\n-* Prints a string to standard output.\n-*\n-* This string will not have an implicit newline at the end. If you want\n-* an implicit newline, please see `println`.\n-*\n-* # Example\n-*\n-* ```rust\n-* // print is imported into the prelude, and so is always available.\n-* print(\"hello\");\n-* ```\n-*/\n-pub fn print(s: &str) {\n-    stdout().write_str(s);\n-}\n-\n-/**\n-* Prints a string to standard output, followed by a newline.\n-*\n-* If you do not want an implicit newline, please see `print`.\n-*\n-* # Example\n-*\n-* ```rust\n-* // println is imported into the prelude, and so is always available.\n-* println(\"hello\");\n-* ```\n-*/\n-pub fn println(s: &str) {\n-    stdout().write_line(s);\n-}\n-\n pub struct BytesWriter {\n     bytes: @mut ~[u8],\n     pos: @mut uint,\n@@ -1736,7 +1579,7 @@ pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n }\n \n // Utility functions\n-pub fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n+fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n    uint {\n     let mut bpos = pos as int;\n     let blen = len as int;\n@@ -1749,137 +1592,6 @@ pub fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n     return bpos as uint;\n }\n \n-pub fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n-    do read_whole_file(file).and_then |bytes| {\n-        if str::is_utf8(bytes) {\n-            Ok(str::from_utf8(bytes))\n-        } else {\n-            Err(file.display().to_str() + \" is not UTF-8\")\n-        }\n-    }\n-}\n-\n-// FIXME (#2004): implement this in a low-level way. Going through the\n-// abstractions is pointless.\n-pub fn read_whole_file(file: &Path) -> Result<~[u8], ~str> {\n-    do file_reader(file).and_then |rdr| {\n-        Ok(rdr.read_whole_stream())\n-    }\n-}\n-\n-// fsync related\n-\n-pub mod fsync {\n-    use io::{FILERes, FdRes, fd_t};\n-    use libc;\n-    use ops::Drop;\n-    use option::{None, Option, Some};\n-    use os;\n-\n-    pub enum Level {\n-        // whatever fsync does on that platform\n-        FSync,\n-\n-        // fdatasync on linux, similiar or more on other platforms\n-        FDataSync,\n-\n-        // full fsync\n-        //\n-        // You must additionally sync the parent directory as well!\n-        FullFSync,\n-    }\n-\n-\n-    // Artifacts that need to fsync on destruction\n-    pub struct Res<t> {\n-        priv arg: Arg<t>,\n-    }\n-\n-    impl <t> Res<t> {\n-        pub fn new(arg: Arg<t>) -> Res<t> {\n-            Res { arg: arg }\n-        }\n-    }\n-\n-    #[unsafe_destructor]\n-    impl<T> Drop for Res<T> {\n-        fn drop(&mut self) {\n-            match self.arg.opt_level {\n-                None => (),\n-                Some(level) => {\n-                  // fail hard if not succesful\n-                  assert!(((self.arg.fsync_fn)(&self.arg.val, level) != -1));\n-                }\n-            }\n-        }\n-    }\n-\n-    pub struct Arg<t> {\n-        priv val: t,\n-        priv opt_level: Option<Level>,\n-        priv fsync_fn: extern \"Rust\" fn(f: &t, Level) -> int,\n-    }\n-\n-    // fsync file after executing blk\n-    // FIXME (#2004) find better way to create resources within lifetime of\n-    // outer res\n-    pub fn FILE_res_sync(file: &FILERes,\n-                         opt_level: Option<Level>,\n-                         blk: &fn(v: Res<*libc::FILE>)) {\n-        blk(Res::new(Arg {\n-            val: file.f,\n-            opt_level: opt_level,\n-            fsync_fn: fsync_FILE,\n-        }));\n-\n-        fn fileno(stream: *libc::FILE) -> libc::c_int {\n-            #[fixed_stack_segment]; #[inline(never)];\n-            unsafe { libc::fileno(stream) }\n-        }\n-\n-        fn fsync_FILE(stream: &*libc::FILE, level: Level) -> int {\n-            fsync_fd(fileno(*stream), level)\n-        }\n-    }\n-\n-    // fsync fd after executing blk\n-    pub fn fd_res_sync(fd: &FdRes, opt_level: Option<Level>,\n-                       blk: &fn(v: Res<fd_t>)) {\n-        blk(Res::new(Arg {\n-            val: fd.fd,\n-            opt_level: opt_level,\n-            fsync_fn: fsync_fd_helper,\n-        }));\n-    }\n-\n-    fn fsync_fd(fd: libc::c_int, level: Level) -> int {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        os::fsync_fd(fd, level) as int\n-    }\n-\n-    fn fsync_fd_helper(fd_ptr: &libc::c_int, level: Level) -> int {\n-        fsync_fd(*fd_ptr, level)\n-    }\n-\n-    // Type of objects that may want to fsync\n-    pub trait FSyncable { fn fsync(&self, l: Level) -> int; }\n-\n-    // Call o.fsync after executing blk\n-    pub fn obj_sync(o: @FSyncable, opt_level: Option<Level>,\n-                    blk: &fn(v: Res<@FSyncable>)) {\n-        blk(Res::new(Arg {\n-            val: o,\n-            opt_level: opt_level,\n-            fsync_fn: obj_fsync_fn,\n-        }));\n-    }\n-\n-    fn obj_fsync_fn(o: &@FSyncable, level: Level) -> int {\n-        (*o).fsync(level)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n@@ -1934,82 +1646,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_readchars_empty() {\n-        do io::with_str_reader(\"\") |inp| {\n-            let res : ~[char] = inp.read_chars(128);\n-            assert_eq!(res.len(), 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_line_utf8() {\n-        do io::with_str_reader(\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\") |inp| {\n-            let line = inp.read_line();\n-            assert_eq!(line, ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\");\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_lines() {\n-        do io::with_str_reader(\"a\\nb\\nc\\n\") |inp| {\n-            assert_eq!(inp.read_lines(), ~[~\"a\", ~\"b\", ~\"c\"]);\n-        }\n-\n-        do io::with_str_reader(\"a\\nb\\nc\") |inp| {\n-            assert_eq!(inp.read_lines(), ~[~\"a\", ~\"b\", ~\"c\"]);\n-        }\n-\n-        do io::with_str_reader(\"\") |inp| {\n-            assert!(inp.read_lines().is_empty());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_readchars_wide() {\n-        let wide_test = ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\";\n-        let ivals : ~[int] = ~[\n-            29983, 38152, 30340, 27748,\n-            21273, 20999, 32905, 27748,\n-            104, 101, 108, 108, 111,\n-            29983, 38152, 30340, 27748,\n-            21273, 20999, 32905, 27748];\n-        fn check_read_ln(len : uint, s: &str, ivals: &[int]) {\n-            do io::with_str_reader(s) |inp| {\n-                let res : ~[char] = inp.read_chars(len);\n-                if len <= ivals.len() {\n-                    assert_eq!(res.len(), len);\n-                }\n-                for (iv, c) in ivals.iter().zip(res.iter()) {\n-                    assert!(*iv == *c as int)\n-                }\n-            }\n-        }\n-        let mut i = 0;\n-        while i < 8 {\n-            check_read_ln(i, wide_test, ivals);\n-            i += 1;\n-        }\n-        // check a long read for good measure\n-        check_read_ln(128, wide_test, ivals);\n-    }\n-\n-    #[test]\n-    fn test_readchar() {\n-        do io::with_str_reader(\"\u751f\") |inp| {\n-            let res = inp.read_char();\n-            assert_eq!(res as int, 29983);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_readchar_empty() {\n-        do io::with_str_reader(\"\") |inp| {\n-            let res = inp.read_char();\n-            assert_eq!(res, unsafe { transmute(-1u32) }); // FIXME: #8971: unsound\n-        }\n-    }\n-\n     #[test]\n     fn file_reader_not_exist() {\n         match io::file_reader(&Path::new(\"not a file\")) {"}, {"sha": "99930b39a6533e5dcfd078f18fceeabb15f50063", "filename": "src/libstd/os.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -32,7 +32,6 @@\n use c_str::CString;\n use clone::Clone;\n use container::Container;\n-use io;\n use iter::range;\n use libc;\n use libc::{c_char, c_void, c_int, size_t};\n@@ -356,64 +355,6 @@ pub fn fdopen(fd: c_int) -> *FILE {\n     }\n }\n \n-\n-// fsync related\n-\n-#[cfg(windows)]\n-pub fn fsync_fd(fd: c_int, _level: io::fsync::Level) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        use libc::funcs::extra::msvcrt::*;\n-        return commit(fd);\n-    }\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"android\")]\n-pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        use libc::funcs::posix01::unistd::*;\n-        match level {\n-          io::fsync::FSync\n-          | io::fsync::FullFSync => return fsync(fd),\n-          io::fsync::FDataSync => return fdatasync(fd)\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"macos\")]\n-pub fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    unsafe {\n-        use libc::consts::os::extra::*;\n-        use libc::funcs::posix88::fcntl::*;\n-        use libc::funcs::posix01::unistd::*;\n-        match level {\n-          io::fsync::FSync => return fsync(fd),\n-          _ => {\n-            // According to man fnctl, the ok retval is only specified to be\n-            // !=-1\n-            if (fcntl(F_FULLFSYNC as c_int, fd) == -1 as c_int)\n-                { return -1 as c_int; }\n-            else\n-                { return 0 as c_int; }\n-          }\n-        }\n-    }\n-}\n-\n-#[cfg(target_os = \"freebsd\")]\n-pub fn fsync_fd(fd: c_int, _l: io::fsync::Level) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    unsafe {\n-        use libc::funcs::posix01::unistd::*;\n-        return fsync(fd);\n-    }\n-}\n-\n pub struct Pipe {\n     input: c_int,\n     out: c_int"}, {"sha": "456d344b838c5baf65ea05744de32202764e452a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -962,7 +962,6 @@ pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> boo\n mod test {\n     use ast::*;\n     use super::*;\n-    use std::io;\n     use opt_vec;\n     use std::hashmap::HashMap;\n \n@@ -1137,7 +1136,7 @@ mod test {\n         // - two renames of the same var.. can only happen if you use\n         // local-expand to prevent the inner binding from being renamed\n         // during the rename-pass caused by the first:\n-        io::println(\"about to run bad test\");\n+        println(\"about to run bad test\");\n         { let sc = unfold_test_sc(~[R(id(a,EMPTY_CTXT),50),\n                                     R(id(a,EMPTY_CTXT),51)],\n                                   EMPTY_CTXT,&mut t);"}, {"sha": "736f92910af204e3fa6737fc051fd53f5280c92a", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -11,7 +11,7 @@\n use codemap::{Pos, Span};\n use codemap;\n \n-use std::io;\n+use std::rt::io;\n use std::local_data;\n use extra::term;\n \n@@ -199,9 +199,14 @@ fn diagnosticcolor(lvl: level) -> term::color::Color {\n fn print_maybe_styled(msg: &str, color: term::attr::Attr) {\n     local_data_key!(tls_terminal: @Option<term::Terminal>)\n \n-    let stderr = io::stderr();\n+    let stderr = @mut io::stderr() as @mut io::Writer;\n+    fn is_stderr_screen() -> bool {\n+        #[fixed_stack_segment];\n+        use std::libc;\n+        unsafe { libc::isatty(libc::STDERR_FILENO) != 0 }\n+    }\n \n-    if stderr.get_type() == io::Screen {\n+    if is_stderr_screen() {\n         let t = match local_data::get(tls_terminal, |v| v.map(|k| *k)) {\n             None => {\n                 let t = term::Terminal::new(stderr);\n@@ -218,21 +223,21 @@ fn print_maybe_styled(msg: &str, color: term::attr::Attr) {\n         match t {\n             &Some(ref term) => {\n                 term.attr(color);\n-                stderr.write_str(msg);\n+                write!(stderr, \"{}\", msg);\n                 term.reset();\n             },\n-            _ => stderr.write_str(msg)\n+            _ => write!(stderr, \"{}\", msg)\n         }\n     } else {\n-        stderr.write_str(msg);\n+        write!(stderr, \"{}\", msg);\n     }\n }\n \n fn print_diagnostic(topic: &str, lvl: level, msg: &str) {\n-    let stderr = io::stderr();\n+    let mut stderr = io::stderr();\n \n     if !topic.is_empty() {\n-        stderr.write_str(format!(\"{} \", topic));\n+        write!(&mut stderr as &mut io::Writer, \"{} \", topic);\n     }\n \n     print_maybe_styled(format!(\"{}: \", diagnosticstr(lvl)),\n@@ -266,6 +271,8 @@ fn highlight_lines(cm: @codemap::CodeMap,\n                    lvl: level,\n                    lines: @codemap::FileLines) {\n     let fm = lines.file;\n+    let mut err = io::stderr();\n+    let err = &mut err as &mut io::Writer;\n \n     // arbitrarily only print up to six lines of the error\n     let max_lines = 6u;\n@@ -277,21 +284,12 @@ fn highlight_lines(cm: @codemap::CodeMap,\n     }\n     // Print the offending lines\n     for line in display_lines.iter() {\n-        io::stderr().write_str(format!(\"{}:{} \", fm.name, *line + 1u));\n-        let s = fm.get_line(*line as int) + \"\\n\";\n-        io::stderr().write_str(s);\n+        write!(err, \"{}:{} {}\\n\", fm.name, *line + 1, fm.get_line(*line as int));\n     }\n     if elided {\n         let last_line = display_lines[display_lines.len() - 1u];\n         let s = format!(\"{}:{} \", fm.name, last_line + 1u);\n-        let mut indent = s.len();\n-        let mut out = ~\"\";\n-        while indent > 0u {\n-            out.push_char(' ');\n-            indent -= 1u;\n-        }\n-        out.push_str(\"...\\n\");\n-        io::stderr().write_str(out);\n+        write!(err, \"{0:1$}...\\n\", \"\", s.len());\n     }\n \n     // FIXME (#3260)\n@@ -325,7 +323,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n                 _ => s.push_char(' '),\n             };\n         }\n-        io::stderr().write_str(s);\n+        write!(err, \"{}\", s);\n         let mut s = ~\"^\";\n         let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {"}, {"sha": "99bcb36eedbf567af2e01f77a352a493f7c1b5d0", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -1524,7 +1524,8 @@ mod test {\n     }\n \n     fn fake_print_crate(crate: &ast::Crate) {\n-        let s = pprust::rust_printer(std::io::stderr(),get_ident_interner());\n+        let out = @mut std::rt::io::stderr() as @mut std::rt::io::Writer;\n+        let s = pprust::rust_printer(out, get_ident_interner());\n         pprust::print_crate_(s, crate);\n     }\n \n@@ -1536,7 +1537,7 @@ mod test {\n \n     //fn expand_and_resolve(crate_str: @str) -> ast::crate {\n         //let expanded_ast = expand_crate_str(crate_str);\n-        // std::io::println(format!(\"expanded: {:?}\\n\",expanded_ast));\n+        // println(format!(\"expanded: {:?}\\n\",expanded_ast));\n         //mtwt_resolve_crate(expanded_ast)\n     //}\n     //fn expand_and_resolve_and_pretty_print (crate_str : @str) -> ~str {\n@@ -1645,9 +1646,9 @@ mod test {\n                     let varref_marks = mtwt_marksof(varref.segments[0].identifier.ctxt,\n                                                     invalid_name);\n                     if (!(varref_name==binding_name)){\n-                        std::io::println(\"uh oh, should match but doesn't:\");\n-                        std::io::println(format!(\"varref: {:?}\",varref));\n-                        std::io::println(format!(\"binding: {:?}\", bindings[binding_idx]));\n+                        println(\"uh oh, should match but doesn't:\");\n+                        println!(\"varref: {:?}\",varref);\n+                        println!(\"binding: {:?}\", bindings[binding_idx]);\n                         ast_util::display_sctable(get_sctable());\n                     }\n                     assert_eq!(varref_name,binding_name);\n@@ -1665,12 +1666,12 @@ mod test {\n                         println!(\"text of test case: \\\"{}\\\"\", teststr);\n                         println!(\"\");\n                         println!(\"uh oh, matches but shouldn't:\");\n-                        std::io::println(format!(\"varref: {:?}\",varref));\n+                        println!(\"varref: {:?}\",varref);\n                         // good lord, you can't make a path with 0 segments, can you?\n                         println!(\"varref's first segment's uint: {}, and string: \\\"{}\\\"\",\n                                  varref.segments[0].identifier.name,\n                                  ident_to_str(&varref.segments[0].identifier));\n-                        std::io::println(format!(\"binding: {:?}\", bindings[binding_idx]));\n+                        println!(\"binding: {:?}\", bindings[binding_idx]);\n                         ast_util::display_sctable(get_sctable());\n                     }\n                     assert!(!fail);\n@@ -1703,17 +1704,17 @@ foo_module!()\n                                           && (@\"xx\" == (ident_to_str(&p.segments[0].identifier)))\n                                      }).enumerate() {\n             if (mtwt_resolve(v.segments[0].identifier) != resolved_binding) {\n-                std::io::println(\"uh oh, xx binding didn't match xx varref:\");\n-                std::io::println(format!(\"this is xx varref \\\\# {:?}\",idx));\n-                std::io::println(format!(\"binding: {:?}\",cxbind));\n-                std::io::println(format!(\"resolves to: {:?}\",resolved_binding));\n-                std::io::println(format!(\"varref: {:?}\",v.segments[0].identifier));\n-                std::io::println(format!(\"resolves to: {:?}\",\n-                                         mtwt_resolve(v.segments[0].identifier)));\n+                println(\"uh oh, xx binding didn't match xx varref:\");\n+                println!(\"this is xx varref \\\\# {:?}\",idx);\n+                println!(\"binding: {:?}\",cxbind);\n+                println!(\"resolves to: {:?}\",resolved_binding);\n+                println!(\"varref: {:?}\",v.segments[0].identifier);\n+                println!(\"resolves to: {:?}\",\n+                         mtwt_resolve(v.segments[0].identifier));\n                 let table = get_sctable();\n-                std::io::println(\"SC table:\");\n+                println(\"SC table:\");\n                 for (idx,val) in table.table.iter().enumerate() {\n-                    std::io::println(format!(\"{:4u} : {:?}\",idx,val));\n+                    println!(\"{:4u} : {:?}\",idx,val);\n                 }\n             }\n             assert_eq!(mtwt_resolve(v.segments[0].identifier),resolved_binding);"}, {"sha": "3e07b16221ec113be82f3d72d94d8f2b9c7403d9", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -15,15 +15,13 @@ use ext::base;\n use print;\n use parse::token::{get_ident_interner};\n \n-use std::io;\n-\n pub fn expand_syntax_ext(cx: @ExtCtxt,\n                          sp: codemap::Span,\n                          tt: &[ast::token_tree])\n                       -> base::MacResult {\n \n     cx.print_backtrace();\n-    io::stdout().write_line(\n+    println(\n         print::pprust::tt_to_str(\n             &ast::tt_delim(@mut tt.to_owned()),\n             get_ident_interner()));"}, {"sha": "df177cf75dc72f9d024d46982602342c660a28fb", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -19,8 +19,10 @@ use parse;\n use parse::token::{get_ident_interner};\n use print::pprust;\n \n-use std::io;\n-use std::result;\n+use std::rt::io;\n+use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::file::FileInfo;\n+use std::str;\n \n // These macros all relate to the file system; they either return\n // the column/row/filename of the expression, or they include\n@@ -89,14 +91,23 @@ pub fn expand_include(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n pub fn expand_include_str(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n-    let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path::new(file)));\n-    match res {\n-      result::Ok(res) => {\n-          base::MRExpr(cx.expr_str(sp, res.to_managed()))\n-      }\n-      result::Err(e) => {\n-        cx.span_fatal(sp, e);\n-      }\n+    let file = res_rel_file(cx, sp, &Path::new(file));\n+    let mut error = None;\n+    let bytes = do io::read_error::cond.trap(|e| error = Some(e)).inside {\n+        file.open_reader(io::Open).read_to_end()\n+    };\n+    match error {\n+        Some(e) => {\n+            cx.span_fatal(sp, format!(\"couldn't read {}: {}\",\n+                                      file.display(), e.desc));\n+        }\n+        None => {}\n+    }\n+    match str::from_utf8_owned_opt(bytes) {\n+        Some(s) => base::MRExpr(cx.expr_str(sp, s.to_managed())),\n+        None => {\n+            cx.span_fatal(sp, format!(\"{} wasn't a utf-8 file\", file.display()));\n+        }\n     }\n }\n \n@@ -106,13 +117,21 @@ pub fn expand_include_bin(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     use std::at_vec;\n \n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n-    match io::read_whole_file(&res_rel_file(cx, sp, &Path::new(file))) {\n-        result::Ok(src) => {\n-            let v = at_vec::to_managed_move(src);\n-            base::MRExpr(cx.expr_lit(sp, ast::lit_binary(v)))\n+    let file = res_rel_file(cx, sp, &Path::new(file));\n+\n+    let mut error = None;\n+    let bytes = do io::read_error::cond.trap(|e| error = Some(e)).inside {\n+        do io::io_error::cond.trap(|e| error = Some(e)).inside {\n+            file.open_reader(io::Open).read_to_end()\n+        }\n+    };\n+    match error {\n+        Some(e) => {\n+            cx.span_fatal(sp, format!(\"couldn't read {}: {}\",\n+                                      file.display(), e.desc));\n         }\n-        result::Err(ref e) => {\n-            cx.parse_sess().span_diagnostic.handler().fatal((*e))\n+        None => {\n+            base::MRExpr(cx.expr_lit(sp, ast::lit_binary(bytes)))\n         }\n     }\n }"}, {"sha": "e9e6eb872c86f6e814f5d9cc1d2b5d424e943e44", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -18,7 +18,8 @@ use parse::lexer;\n use parse::token;\n use parse::token::{get_ident_interner};\n \n-use std::io;\n+use std::rt::io;\n+use std::rt::io::extensions::ReaderUtil;\n use std::str;\n use std::uint;\n \n@@ -346,9 +347,9 @@ pub struct lit {\n pub fn gather_comments_and_literals(span_diagnostic:\n                                     @mut diagnostic::span_handler,\n                                     path: @str,\n-                                    srdr: @io::Reader)\n+                                    mut srdr: &mut io::Reader)\n                                  -> (~[cmnt], ~[lit]) {\n-    let src = str::from_utf8(srdr.read_whole_stream()).to_managed();\n+    let src = str::from_utf8(srdr.read_to_end()).to_managed();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);"}, {"sha": "93e5d3dd7727f0dba23fcc960cda7dd4d17db8a1", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -19,8 +19,11 @@ use parse::attr::parser_attr;\n use parse::lexer::reader;\n use parse::parser::Parser;\n \n-use std::io;\n use std::path::Path;\n+use std::rt::io;\n+use std::rt::io::extensions::ReaderUtil;\n+use std::rt::io::file::FileInfo;\n+use std::str;\n \n pub mod lexer;\n pub mod parser;\n@@ -260,16 +263,34 @@ pub fn new_parser_from_tts(sess: @mut ParseSess,\n /// add the path to the session's codemap and return the new filemap.\n pub fn file_to_filemap(sess: @mut ParseSess, path: &Path, spanopt: Option<Span>)\n     -> @FileMap {\n-    match io::read_whole_file_str(path) {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        Ok(src) => string_to_filemap(sess, src.to_managed(), path.as_str().unwrap().to_managed()),\n-        Err(e) => {\n-            match spanopt {\n-                Some(span) => sess.span_diagnostic.span_fatal(span, e),\n-                None => sess.span_diagnostic.handler().fatal(e)\n-            }\n+    let err = |msg: &str| {\n+        match spanopt {\n+            Some(sp) => sess.span_diagnostic.span_fatal(sp, msg),\n+            None => sess.span_diagnostic.handler().fatal(msg),\n+        }\n+    };\n+    let mut error = None;\n+    let bytes = do io::io_error::cond.trap(|e| error = Some(e)).inside {\n+        do io::read_error::cond.trap(|e| error = Some(e)).inside {\n+            path.open_reader(io::Open).read_to_end()\n         }\n+    };\n+    match error {\n+        Some(e) => {\n+            err(format!(\"couldn't read {}: {}\", path.display(), e.desc));\n+        }\n+        None => {}\n     }\n+    match str::from_utf8_owned_opt(bytes) {\n+        Some(s) => {\n+            return string_to_filemap(sess, s.to_managed(),\n+                                     path.as_str().unwrap().to_managed());\n+        }\n+        None => {\n+            err(format!(\"{} is not UTF-8 encoded\", path.display()))\n+        }\n+    }\n+    unreachable!()\n }\n \n // given a session and a string, add the string to\n@@ -318,7 +339,10 @@ mod test {\n     use super::*;\n     use extra::serialize::Encodable;\n     use extra;\n-    use std::io;\n+    use std::rt::io;\n+    use std::rt::io::Decorator;\n+    use std::rt::io::mem::MemWriter;\n+    use std::str;\n     use codemap::{Span, BytePos, Spanned};\n     use opt_vec;\n     use ast;\n@@ -330,10 +354,10 @@ mod test {\n     use util::parser_testing::string_to_stmt;\n \n     #[cfg(test)] fn to_json_str<E : Encodable<extra::json::Encoder>>(val: @E) -> ~str {\n-        do io::with_str_writer |writer| {\n-            let mut encoder = extra::json::Encoder(writer);\n-            val.encode(&mut encoder);\n-        }\n+        let writer = @mut MemWriter::new();\n+        let mut encoder = extra::json::Encoder(writer as @mut io::Writer);\n+        val.encode(&mut encoder);\n+        str::from_utf8(*writer.inner_ref())\n     }\n \n     // produce a codemap::span"}, {"sha": "4801fa21fc4936043f6181a1769d50212e0113cc", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -61,7 +61,7 @@\n  * avoid combining it with other lines and making matters even worse.\n  */\n \n-use std::io;\n+use std::rt::io;\n use std::vec;\n \n #[deriving(Clone, Eq)]\n@@ -148,7 +148,7 @@ pub struct print_stack_elt {\n \n pub static size_infinity: int = 0xffff;\n \n-pub fn mk_printer(out: @io::Writer, linewidth: uint) -> @mut Printer {\n+pub fn mk_printer(out: @mut io::Writer, linewidth: uint) -> @mut Printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n     let n: uint = 3 * linewidth;\n@@ -157,7 +157,7 @@ pub fn mk_printer(out: @io::Writer, linewidth: uint) -> @mut Printer {\n     let size: ~[int] = vec::from_elem(n, 0);\n     let scan_stack: ~[uint] = vec::from_elem(n, 0u);\n     @mut Printer {\n-        out: @out,\n+        out: out,\n         buf_len: n,\n         margin: linewidth as int,\n         space: linewidth as int,\n@@ -255,7 +255,7 @@ pub fn mk_printer(out: @io::Writer, linewidth: uint) -> @mut Printer {\n  * called 'print'.\n  */\n pub struct Printer {\n-    out: @@io::Writer,\n+    out: @mut io::Writer,\n     buf_len: uint,\n     margin: int, // width of lines we're constrained to\n     space: int, // number of spaces left on line\n@@ -452,7 +452,7 @@ impl Printer {\n     }\n     pub fn print_newline(&mut self, amount: int) {\n         debug!(\"NEWLINE {}\", amount);\n-        (*self.out).write_str(\"\\n\");\n+        write!(self.out, \"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n     }\n@@ -474,10 +474,10 @@ impl Printer {\n     }\n     pub fn print_str(&mut self, s: &str) {\n         while self.pending_indentation > 0 {\n-            (*self.out).write_str(\" \");\n+            write!(self.out, \" \");\n             self.pending_indentation -= 1;\n         }\n-        (*self.out).write_str(s);\n+        write!(self.out, \"{}\", s);\n     }\n     pub fn print(&mut self, x: token, L: int) {\n         debug!(\"print {} {} (remaining line space={})\", tok_str(x), L,"}, {"sha": "400ff804485239d79070b39826f30169eee8f2a4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -28,7 +28,10 @@ use print::pp;\n use print::pprust;\n \n use std::char;\n-use std::io;\n+use std::str;\n+use std::rt::io;\n+use std::rt::io::Decorator;\n+use std::rt::io::mem::MemWriter;\n \n // The @ps is stored here to prevent recursive type.\n pub enum ann_node<'self> {\n@@ -83,11 +86,11 @@ pub fn end(s: @ps) {\n     pp::end(s.s);\n }\n \n-pub fn rust_printer(writer: @io::Writer, intr: @ident_interner) -> @ps {\n+pub fn rust_printer(writer: @mut io::Writer, intr: @ident_interner) -> @ps {\n     return rust_printer_annotated(writer, intr, @no_ann::new() as @pp_ann);\n }\n \n-pub fn rust_printer_annotated(writer: @io::Writer,\n+pub fn rust_printer_annotated(writer: @mut io::Writer,\n                               intr: @ident_interner,\n                               ann: @pp_ann)\n                               -> @ps {\n@@ -118,8 +121,8 @@ pub fn print_crate(cm: @CodeMap,\n                    span_diagnostic: @mut diagnostic::span_handler,\n                    crate: &ast::Crate,\n                    filename: @str,\n-                   input: @io::Reader,\n-                   out: @io::Writer,\n+                   input: @mut io::Reader,\n+                   out: @mut io::Writer,\n                    ann: @pp_ann,\n                    is_expanded: bool) {\n     let (cmnts, lits) = comments::gather_comments_and_literals(\n@@ -200,26 +203,26 @@ pub fn path_to_str(p: &ast::Path, intr: @ident_interner) -> ~str {\n pub fn fun_to_str(decl: &ast::fn_decl, purity: ast::purity, name: ast::Ident,\n                   opt_explicit_self: Option<ast::explicit_self_>,\n                   generics: &ast::Generics, intr: @ident_interner) -> ~str {\n-    do io::with_str_writer |wr| {\n-        let s = rust_printer(wr, intr);\n-        print_fn(s, decl, Some(purity), AbiSet::Rust(),\n-                 name, generics, opt_explicit_self, ast::inherited);\n-        end(s); // Close the head box\n-        end(s); // Close the outer box\n-        eof(s.s);\n-    }\n+    let wr = @mut MemWriter::new();\n+    let s = rust_printer(wr as @mut io::Writer, intr);\n+    print_fn(s, decl, Some(purity), AbiSet::Rust(),\n+             name, generics, opt_explicit_self, ast::inherited);\n+    end(s); // Close the head box\n+    end(s); // Close the outer box\n+    eof(s.s);\n+    str::from_utf8(*wr.inner_ref())\n }\n \n pub fn block_to_str(blk: &ast::Block, intr: @ident_interner) -> ~str {\n-    do io::with_str_writer |wr| {\n-        let s = rust_printer(wr, intr);\n-        // containing cbox, will be closed by print-block at }\n-        cbox(s, indent_unit);\n-        // head-ibox, will be closed by print-block after {\n-        ibox(s, 0u);\n-        print_block(s, blk);\n-        eof(s.s);\n-    }\n+    let wr = @mut MemWriter::new();\n+    let s = rust_printer(wr as @mut io::Writer, intr);\n+    // containing cbox, will be closed by print-block at }\n+    cbox(s, indent_unit);\n+    // head-ibox, will be closed by print-block after {\n+    ibox(s, 0u);\n+    print_block(s, blk);\n+    eof(s.s);\n+    str::from_utf8(*wr.inner_ref())\n }\n \n pub fn meta_item_to_str(mi: &ast::MetaItem, intr: @ident_interner) -> ~str {\n@@ -2196,11 +2199,11 @@ pub fn print_string(s: @ps, st: &str, style: ast::StrStyle) {\n }\n \n pub fn to_str<T>(t: &T, f: &fn(@ps, &T), intr: @ident_interner) -> ~str {\n-    do io::with_str_writer |wr| {\n-        let s = rust_printer(wr, intr);\n-        f(s, t);\n-        eof(s.s);\n-    }\n+    let wr = @mut MemWriter::new();\n+    let s = rust_printer(wr as @mut io::Writer, intr);\n+    f(s, t);\n+    eof(s.s);\n+    str::from_utf8(*wr.inner_ref())\n }\n \n pub fn next_comment(s: @ps) -> Option<comments::cmnt> {"}, {"sha": "f91327b6a6521262d12d14be8938fea305a8e2c6", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -13,7 +13,6 @@ extern mod extra;\n use extra::time;\n use extra::treemap::TreeMap;\n use std::hashmap::{HashMap, HashSet};\n-use std::io;\n use std::os;\n use std::rand::{Rng, IsaacRng, SeedableRng};\n use std::trie::TrieMap;\n@@ -28,7 +27,7 @@ fn timed(label: &str, f: &fn()) {\n }\n \n fn ascending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n-    io::println(\" Ascending integers:\");\n+    println(\" Ascending integers:\");\n \n     do timed(\"insert\") {\n         for i in range(0u, n_keys) {\n@@ -50,7 +49,7 @@ fn ascending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n }\n \n fn descending<M: MutableMap<uint, uint>>(map: &mut M, n_keys: uint) {\n-    io::println(\" Descending integers:\");\n+    println(\" Descending integers:\");\n \n     do timed(\"insert\") {\n         for i in range(0, n_keys).invert() {\n@@ -118,7 +117,7 @@ fn main() {\n \n     println!(\"{} keys\", n_keys);\n \n-    io::println(\"\\nTreeMap:\");\n+    println(\"\\nTreeMap:\");\n \n     {\n         let mut map: TreeMap<uint,uint> = TreeMap::new();\n@@ -131,12 +130,12 @@ fn main() {\n     }\n \n     {\n-        io::println(\" Random integers:\");\n+        println(\" Random integers:\");\n         let mut map: TreeMap<uint,uint> = TreeMap::new();\n         vector(&mut map, n_keys, rand);\n     }\n \n-    io::println(\"\\nHashMap:\");\n+    println(\"\\nHashMap:\");\n \n     {\n         let mut map: HashMap<uint,uint> = HashMap::new();\n@@ -149,12 +148,12 @@ fn main() {\n     }\n \n     {\n-        io::println(\" Random integers:\");\n+        println(\" Random integers:\");\n         let mut map: HashMap<uint,uint> = HashMap::new();\n         vector(&mut map, n_keys, rand);\n     }\n \n-    io::println(\"\\nTrieMap:\");\n+    println(\"\\nTrieMap:\");\n \n     {\n         let mut map: TrieMap<uint> = TrieMap::new();\n@@ -167,7 +166,7 @@ fn main() {\n     }\n \n     {\n-        io::println(\" Random integers:\");\n+        println(\" Random integers:\");\n         let mut map: TrieMap<uint> = TrieMap::new();\n         vector(&mut map, n_keys, rand);\n     }"}, {"sha": "9f65dc1e5555bd3ce182a277876521b0460f7093", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -13,7 +13,6 @@ extern mod extra;\n use extra::bitv::BitvSet;\n use extra::treemap::TreeSet;\n use std::hashmap::HashSet;\n-use std::io;\n use std::os;\n use std::rand;\n use std::uint;\n@@ -123,12 +122,11 @@ impl Results {\n }\n \n fn write_header(header: &str) {\n-    io::stdout().write_str(header);\n-    io::stdout().write_str(\"\\n\");\n+    println(header);\n }\n \n fn write_row(label: &str, value: f64) {\n-    io::stdout().write_str(format!(\"{:30s} {} s\\n\", label, value));\n+    println!(\"{:30s} {} s\\n\", label, value);\n }\n \n fn write_results(label: &str, results: &Results) {"}, {"sha": "2a5971be216b876c1229205f9d597af31fad9f54", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -22,7 +22,6 @@ extern mod extra;\n \n use std::comm::{Port, Chan, SharedChan};\n use std::comm;\n-use std::io;\n use std::os;\n use std::task;\n use std::uint;\n@@ -90,10 +89,10 @@ fn run(args: &[~str]) {\n     let result = from_child.recv();\n     let end = extra::time::precise_time_s();\n     let elapsed = end - start;\n-    io::stdout().write_str(format!(\"Count is {:?}\\n\", result));\n-    io::stdout().write_str(format!(\"Test took {:?} seconds\\n\", elapsed));\n+    print!(\"Count is {:?}\\n\", result);\n+    print!(\"Test took {:?} seconds\\n\", elapsed);\n     let thruput = ((size / workers * workers) as f64) / (elapsed as f64);\n-    io::stdout().write_str(format!(\"Throughput={} per sec\\n\", thruput));\n+    print!(\"Throughput={} per sec\\n\", thruput);\n     assert_eq!(result, num_bytes * size);\n }\n "}, {"sha": "1ff531324b3585cb9c4bf1c0d35ebd9bcda5ede3", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -17,7 +17,6 @@\n extern mod extra;\n \n use std::comm::{SharedChan, Chan, stream};\n-use std::io;\n use std::os;\n use std::task;\n use std::uint;\n@@ -84,10 +83,10 @@ fn run(args: &[~str]) {\n     let result = from_child.recv();\n     let end = extra::time::precise_time_s();\n     let elapsed = end - start;\n-    io::stdout().write_str(format!(\"Count is {:?}\\n\", result));\n-    io::stdout().write_str(format!(\"Test took {:?} seconds\\n\", elapsed));\n+    print!(\"Count is {:?}\\n\", result);\n+    print!(\"Test took {:?} seconds\\n\", elapsed);\n     let thruput = ((size / workers * workers) as f64) / (elapsed as f64);\n-    io::stdout().write_str(format!(\"Throughput={} per sec\\n\", thruput));\n+    print!(\"Throughput={} per sec\\n\", thruput);\n     assert_eq!(result, num_bytes * size);\n }\n "}, {"sha": "6bfb731badd5b741beb517bfdb9ff92dfcff9942", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -14,7 +14,6 @@ extern mod extra;\n \n use std::cell::Cell;\n use std::comm::{stream, SharedChan};\n-use std::io;\n use std::option;\n use std::os;\n use std::task;\n@@ -191,15 +190,15 @@ fn rendezvous(nn: uint, set: ~[color]) {\n     }\n \n     // print each color in the set\n-    io::println(show_color_list(set));\n+    println(show_color_list(set));\n \n     // print each creature's stats\n     for rep in report.iter() {\n-        io::println(*rep);\n+        println(*rep);\n     }\n \n     // print the total number of creatures met\n-    io::println(show_number(creatures_met));\n+    println(show_number(creatures_met));\n }\n \n fn main() {\n@@ -215,10 +214,10 @@ fn main() {\n     let nn = from_str::<uint>(args[1]).unwrap();\n \n     print_complements();\n-    io::println(\"\");\n+    println(\"\");\n \n     rendezvous(nn, ~[Blue, Red, Yellow]);\n-    io::println(\"\");\n+    println(\"\");\n \n     rendezvous(nn,\n         ~[Blue, Red, Yellow, Red, Yellow, Blue, Red, Yellow, Red, Blue]);"}, {"sha": "3d1362b2f2931122574334d93b7cd7acf94cb87e", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -18,7 +18,7 @@\n extern mod extra;\n \n use std::int;\n-use std::io;\n+use std::rt::io;\n use std::os;\n use std::rand::Rng;\n use std::rand;\n@@ -68,12 +68,12 @@ fn select_random(r: u32, genelist: ~[AminoAcids]) -> char {\n     bisect(genelist.clone(), 0, genelist.len() - 1, r)\n }\n \n-fn make_random_fasta(wr: @io::Writer,\n+fn make_random_fasta(wr: @mut io::Writer,\n                      id: ~str,\n                      desc: ~str,\n                      genelist: ~[AminoAcids],\n                      n: int) {\n-    wr.write_line(~\">\" + id + \" \" + desc);\n+    writeln!(wr, \">{} {}\", id, desc);\n     let mut rng = rand::rng();\n     let rng = @mut MyRandom {\n         last: rng.gen()\n@@ -83,26 +83,26 @@ fn make_random_fasta(wr: @io::Writer,\n         op.push_char(select_random(myrandom_next(rng, 100u32),\n                                    genelist.clone()));\n         if op.len() >= LINE_LENGTH {\n-            wr.write_line(op);\n+            writeln!(wr, \"{}\", op);\n             op = ~\"\";\n         }\n     }\n-    if op.len() > 0u { wr.write_line(op); }\n+    if op.len() > 0u { writeln!(wr, \"{}\", op); }\n }\n \n-fn make_repeat_fasta(wr: @io::Writer, id: ~str, desc: ~str, s: ~str, n: int) {\n-    wr.write_line(~\">\" + id + \" \" + desc);\n+fn make_repeat_fasta(wr: @mut io::Writer, id: ~str, desc: ~str, s: ~str, n: int) {\n+    writeln!(wr, \">{} {}\", id, desc);\n     let mut op = str::with_capacity( LINE_LENGTH );\n     let sl = s.len();\n     for i in range(0u, n as uint) {\n         if (op.len() >= LINE_LENGTH) {\n-            wr.write_line( op );\n+            writeln!(wr, \"{}\", op);\n             op = str::with_capacity( LINE_LENGTH );\n         }\n         op.push_char( s[i % sl] as char );\n     }\n     if op.len() > 0 {\n-        wr.write_line(op)\n+        writeln!(wr, \"{}\", op);\n     }\n }\n \n@@ -122,10 +122,10 @@ fn main() {\n     };\n \n     let writer = if os::getenv(\"RUST_BENCH\").is_some() {\n-        io::file_writer(&Path::new(\"./shootout-fasta.data\"),\n-                        [io::Truncate, io::Create]).unwrap()\n+        let file = \"./shootout-fasta.data\".open_writer(io::CreateOrTruncate);\n+        @mut file as @mut io::Writer\n     } else {\n-        io::stdout()\n+        @mut io::stdout() as @mut io::Writer\n     };\n \n     let n = from_str::<int>(args[1]).unwrap();"}, {"sha": "83a0fbd42ced2ed404c28496fba623254a297cf0", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -18,8 +18,6 @@ use std::cmp::Ord;\n use std::comm::{stream, Port, Chan};\n use std::comm;\n use std::hashmap::HashMap;\n-use std::io::ReaderUtil;\n-use std::io;\n use std::option;\n use std::os;\n use std::str;\n@@ -237,6 +235,6 @@ fn main() {\n \n    // now fetch and print result messages\n     for (ii, _sz) in sizes.iter().enumerate() {\n-      io::println(from_child[ii].recv());\n+      println(from_child[ii].recv());\n    }\n }"}, {"sha": "b3c3fa4db6fb601d279ba3e6ab468e2163bc82f0", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -23,8 +23,6 @@ extern mod extra;\n \n use extra::{time, getopts};\n use std::comm::{stream, SharedChan};\n-use std::io::WriterUtil;\n-use std::io;\n use std::os;\n use std::result::{Ok, Err};\n use std::task;\n@@ -113,8 +111,6 @@ fn main() {\n \n         let num_trials = 10;\n \n-        let out = io::stdout();\n-\n         for n in range(1, max + 1) {\n             for _ in range(0, num_trials) {\n                 let start = time::precise_time_ns();\n@@ -123,8 +119,7 @@ fn main() {\n \n                 let elapsed = stop - start;\n \n-                out.write_line(format!(\"{}\\t{}\\t{}\", n, fibn,\n-                                       elapsed.to_str()));\n+                println!(\"{}\\t{}\\t{}\", n, fibn, elapsed.to_str());\n             }\n         }\n     }"}, {"sha": "e1b1f59298ed47602bcd86e790b8d50e78b9e368", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -13,8 +13,6 @@\n extern mod extra;\n \n use extra::smallintmap::SmallIntMap;\n-use std::io::WriterUtil;\n-use std::io;\n use std::os;\n use std::uint;\n \n@@ -59,8 +57,8 @@ fn main() {\n \n     let maxf = max as f64;\n \n-    io::stdout().write_str(format!(\"insert(): {:?} seconds\\n\", checkf));\n-    io::stdout().write_str(format!(\"        : {} op/sec\\n\", maxf/checkf));\n-    io::stdout().write_str(format!(\"get()   : {:?} seconds\\n\", appendf));\n-    io::stdout().write_str(format!(\"        : {} op/sec\\n\", maxf/appendf));\n+    println!(\"insert(): {:?} seconds\\n\", checkf);\n+    println!(\"        : {} op/sec\\n\", maxf/checkf);\n+    println!(\"get()   : {:?} seconds\\n\", appendf);\n+    println!(\"        : {} op/sec\\n\", maxf/appendf);\n }"}, {"sha": "21d492d85fc338c21790e019e73f7c1041391e22", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -14,8 +14,7 @@\n \n extern mod extra;\n \n-use std::io::{ReaderUtil, WriterUtil};\n-use std::io;\n+use std::rt::io;\n use std::os;\n use std::uint;\n use std::unstable::intrinsics::cttz16;\n@@ -67,7 +66,7 @@ impl Sudoku {\n         return true;\n     }\n \n-    pub fn read(reader: @io::Reader) -> Sudoku {\n+    pub fn read(reader: @mut io::Reader) -> Sudoku {\n         assert!(reader.read_line() == ~\"9,9\"); /* assert first line is exactly \"9,9\" */\n \n         let mut g = vec::from_fn(10u, { |_i| ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8] });\n@@ -87,7 +86,7 @@ impl Sudoku {\n         return Sudoku::new(g)\n     }\n \n-    pub fn write(&self, writer: @io::Writer) {\n+    pub fn write(&self, writer: @mut io::Writer) {\n         for row in range(0u8, 9u8) {\n             writer.write_str(format!(\"{}\", self.grid[row][0] as uint));\n             for col in range(1u8, 9u8) {\n@@ -278,8 +277,8 @@ fn main() {\n     let mut sudoku = if use_default {\n         Sudoku::from_vec(&DEFAULT_SUDOKU)\n     } else {\n-        Sudoku::read(io::stdin())\n+        Sudoku::read(@mut io::stdin() as @mut io::Reader)\n     };\n     sudoku.solve();\n-    sudoku.write(io::stdout());\n+    sudoku.write(@mut io::stdout() as @mut io::Writer);\n }"}, {"sha": "ef5ad2766ca69b8804bd26a5d74a2d61ec565154", "filename": "src/test/compile-fail/issue-5060-fail.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fcompile-fail%2Fissue-5060-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fcompile-fail%2Fissue-5060-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5060-fail.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -10,17 +10,15 @@\n \n #[feature(macro_rules)];\n \n-use std::io;\n-\n macro_rules! print_hd_tl (\n     ($field_hd:ident, $($field_tl:ident),+) => ({\n-        io::print(stringify!($field)); //~ ERROR unknown macro variable\n-        io::print(\"::[\");\n+        print(stringify!($field)); //~ ERROR unknown macro variable\n+        print(\"::[\");\n         $(\n-            io::print(stringify!($field_tl));\n-            io::print(\", \");\n+            print(stringify!($field_tl));\n+            print(\", \");\n         )+\n-        io::print(\"]\\n\");\n+        print(\"]\\n\");\n     })\n )\n "}, {"sha": "621510cea99e44b54ba82d0e7bf57ffdf5e2a599", "filename": "src/test/compile-fail/issue-5883.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5883.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n+trait A {}\n \n struct Struct {\n-    r: io::Reader //~ ERROR reference to trait `io::Reader` where a type is expected\n+    r: A //~ ERROR reference to trait `A` where a type is expected\n }\n \n-fn new_struct(r: io::Reader) -> Struct { //~ ERROR reference to trait `io::Reader` where a type is expected\n+fn new_struct(r: A) -> Struct { //~ ERROR reference to trait `A` where a type is expected\n     Struct { r: r }\n }\n "}, {"sha": "9dc29e59f904a0238126761ffe329ade0fe97e19", "filename": "src/test/compile-fail/issue-7573.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7573.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n-\n pub struct PkgId {\n     local_path: ~str,\n     junk: ~str\n@@ -32,7 +30,7 @@ pub fn remove_package_from_database() {\n     list_database(push_id);\n \n     for l in lines_to_use.iter() {\n-        io::stdout().write_line(l.local_path);\n+        println!(\"{}\", l.local_path);\n     }\n \n }"}, {"sha": "2818214c994b1363d585e63219cc56d33431cad4", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -13,8 +13,6 @@\n \n use cal = bar::c::cc;\n \n-use std::io;\n-\n use std::either::Right;        //~ ERROR unused import\n \n use std::util::*;              // shouldn't get errors for not using\n@@ -24,15 +22,23 @@ use std::util::*;              // shouldn't get errors for not using\n use std::option::{Some, None}; //~ ERROR unused import\n                                 //~^ ERROR unused import\n \n-use std::io::ReaderUtil;       //~ ERROR unused import\n+use test::A;       //~ ERROR unused import\n // Be sure that if we just bring some methods into scope that they're also\n // counted as being used.\n-use std::io::WriterUtil;\n+use test::B;\n \n // Make sure this import is warned about when at least one of its imported names\n // is unused\n use std::vec::{from_fn, from_elem};   //~ ERROR unused import\n \n+mod test {\n+    pub trait A { fn a(&self) {} }\n+    pub trait B { fn b(&self) {} }\n+    pub struct C;\n+    impl A for C {}\n+    impl B for C {}\n+}\n+\n mod foo {\n     pub struct Point{x: int, y: int}\n     pub struct Square{p: Point, h: uint, w: uint}\n@@ -58,6 +64,6 @@ fn main() {\n     cal(foo::Point{x:3, y:9});\n     let a = 3;\n     ignore(a);\n-    io::stdout().write_str(\"a\");\n+    test::C.b();\n     let _a = from_elem(0, 0);\n }"}, {"sha": "863663334f8ed444fda789b0d78c842c83dc31d7", "filename": "src/test/run-fail/issue-2156.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb53360541baf3e6df36dc0f0766bc7c1c9f8be/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2156.rs?ref=4eb53360541baf3e6df36dc0f0766bc7c1c9f8be", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(unnecessary_allocation)];\n-\n-// error-pattern:explicit failure\n-// Don't double free the string\n-extern mod extra;\n-\n-use std::io::ReaderUtil;\n-use std::io;\n-\n-fn main() {\n-    do io::with_str_reader(~\"\") |rdr| {\n-        match rdr.read_char() { '=' => { } _ => { fail!() } }\n-    }\n-}"}, {"sha": "5211e76d3d7d2073565b5e2bb382f9d489524f33", "filename": "src/test/run-pass/auto-ref-bounded-ty-param.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fauto-ref-bounded-ty-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fauto-ref-bounded-ty-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-bounded-ty-param.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n-\n trait Foo {\n     fn f(&self);\n }\n@@ -30,7 +28,7 @@ impl<T:Baz> Foo for T {\n \n impl Baz for Bar {\n     fn g(&self) {\n-        io::println(self.x.to_str());\n+        println(self.x.to_str());\n     }\n }\n "}, {"sha": "2831740deaf477f54a2d837a06e93022201dfea1", "filename": "src/test/run-pass/expr-repeat-vstore.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -1,7 +1,5 @@\n #[feature(managed_boxes)];\n \n-use std::io::println;\n-\n pub fn main() {\n     let v: ~[int] = ~[ 1, ..5 ];\n     println(v[0].to_str());"}, {"sha": "5a3b177aadcd2786019f855fa80165b399f511a9", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -16,8 +16,7 @@\n \n extern mod extra;\n \n-use std::io::ReaderUtil;\n-use std::io;\n+use std::rt::io;\n use std::to_str;\n \n enum square {\n@@ -64,16 +63,15 @@ fn square_from_char(c: char) -> square {\n }\n \n fn read_board_grid<rdr:'static + io::Reader>(input: rdr) -> ~[~[square]] {\n-    let input = @input as @io::Reader;\n+    let input = @mut input as @mut io::Reader;\n     let mut grid = ~[];\n-    do input.each_line |line| {\n-        let mut row = ~[];\n-        for c in line.iter() {\n-            row.push(square_from_char(c))\n-        }\n-        grid.push(row);\n-        true\n-    };\n+    let mut line = [0, ..10];\n+    input.read(line);\n+    let mut row = ~[];\n+    for c in line.iter() {\n+        row.push(square_from_char(*c as char))\n+    }\n+    grid.push(row);\n     let width = grid[0].len();\n     for row in grid.iter() { assert!(row.len() == width) }\n     grid"}, {"sha": "e092d45ce68c8a4c97b7ef8b5ad077721b2d737d", "filename": "src/test/run-pass/issue-3556.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3556.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -12,9 +12,6 @@\n \n extern mod extra;\n \n-use std::io::WriterUtil;\n-use std::io;\n-\n enum Token {\n         Text(@~str),\n         ETag(@~[~str], @~str),\n@@ -28,8 +25,7 @@ fn check_strs(actual: &str, expected: &str) -> bool\n {\n         if actual != expected\n         {\n-            io::stderr().write_line(format!(\"Found {}, but expected {}\", actual,\n-                                            expected));\n+            println!(\"Found {}, but expected {}\", actual, expected);\n             return false;\n         }\n         return true;"}, {"sha": "ba92434ba69af6f12798d32e2da4a9c633655797", "filename": "src/test/run-pass/issue-3559.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3559.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -13,13 +13,11 @@\n // rustc --test map_to_str.rs && ./map_to_str\n extern mod extra;\n \n-use std::io::{WriterUtil};\n-\n fn check_strs(actual: &str, expected: &str) -> bool\n {\n     if actual != expected\n     {\n-        io::stderr().write_line(fmt!(\"Found %s, but expected %s\", actual, expected));\n+        println!(\"Found %s, but expected %s\", actual, expected);\n         return false;\n     }\n     return true;"}, {"sha": "50d6a3ae6b8db4b209cd3328ebe6325a12b9f669", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -20,8 +20,6 @@ extern mod extra;\n \n // Extern mod controls linkage. Use controls the visibility of names to modules that are\n // already linked in. Using WriterUtil allows us to use the write_line method.\n-use std::io::WriterUtil;\n-use std::io;\n use std::str;\n use std::vec;\n \n@@ -150,7 +148,7 @@ impl Canvas for AsciiArt {\n // this little helper.\n pub fn check_strs(actual: &str, expected: &str) -> bool {\n     if actual != expected {\n-        io::stderr().write_line(format!(\"Found:\\n{}\\nbut expected\\n{}\", actual, expected));\n+        println!(\"Found:\\n{}\\nbut expected\\n{}\", actual, expected);\n         return false;\n     }\n     return true;"}, {"sha": "86cef39abc81f5b023e25676789b57e6861d74ef", "filename": "src/test/run-pass/issue-4333.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-4333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-4333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4333.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n+use std::rt::io;\n \n pub fn main() {\n-    let stdout = &io::stdout() as &io::WriterUtil;\n-    stdout.write_line(\"Hello!\");\n+    let stdout = &mut io::stdout() as &mut io::Writer;\n+    stdout.write(bytes!(\"Hello!\"));\n }"}, {"sha": "32e13f5ac7f461051ab276acd0b30d09bfdc3549", "filename": "src/test/run-pass/issue-4541.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-4541.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-4541.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4541.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n-\n fn parse_args() -> ~str {\n     let args = ::std::os::args();\n     let mut n = 0;\n@@ -28,5 +26,5 @@ fn parse_args() -> ~str {\n }\n \n pub fn main() {\n-    io::println(parse_args());\n+    println(parse_args());\n }"}, {"sha": "7b96d5a48b9fdcf1a6d4a61522ab309d889b2d6d", "filename": "src/test/run-pass/issue-5060.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-5060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-5060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5060.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -10,17 +10,15 @@\n \n #[feature(macro_rules)];\n \n-use std::io;\n-\n macro_rules! print_hd_tl (\n     ($field_hd:ident, $($field_tl:ident),+) => ({\n-        io::print(stringify!($field_hd));\n-        io::print(\"::[\");\n+        print(stringify!($field_hd));\n+        print(\"::[\");\n         $(\n-            io::print(stringify!($field_tl));\n-            io::print(\", \");\n+            print(stringify!($field_tl));\n+            print(\", \");\n         )+\n-        io::print(\"]\\n\");\n+        print(\"]\\n\");\n     })\n )\n "}, {"sha": "4282e7acf19b123844419b98c94cf3c16cbea0ec", "filename": "src/test/run-pass/issue-5741.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-5741.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-5741.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5741.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -10,9 +10,7 @@\n \n #[allow(unreachable_code)];\n \n-use std::io;\n-\n pub fn main() {\n     return;\n-    while io::stdin().read_line() != ~\"quit\" { };\n+    while true {};\n }"}, {"sha": "247b74e4643122bb8373a6e448f775e0c43ddb2a", "filename": "src/test/run-pass/issue-8498.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-8498.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fissue-8498.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8498.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -9,14 +9,13 @@\n // except according to those terms.\n \n // xfail-test\n-use std::io;\n \n fn main() {\n // This is ok\n     match &[(~5,~7)] {\n         ps => {\n            let (ref y, _) = ps[0];\n-           io::println(fmt!(\"1. y = %d\", **y));\n+           println(fmt!(\"1. y = %d\", **y));\n            assert!(**y == 5);\n         }\n     }\n@@ -25,8 +24,8 @@ fn main() {\n     match Some(&[(~5,)]) {\n         Some(ps) => {\n            let (ref y,) = ps[0];\n-           io::println(fmt!(\"2. y = %d\", **y));\n-           if **y != 5 { io::println(\"sadness\"); }\n+           println(fmt!(\"2. y = %d\", **y));\n+           if **y != 5 { println(\"sadness\"); }\n         }\n         None => ()\n     }\n@@ -35,7 +34,7 @@ fn main() {\n     match Some(&[(~5,~7)]) {\n         Some(ps) => {\n            let (ref y, ref z) = ps[0];\n-           io::println(fmt!(\"3. y = %d z = %d\", **y, **z));\n+           println(fmt!(\"3. y = %d z = %d\", **y, **z));\n            assert!(**y == 5);\n         }\n         None => ()"}, {"sha": "0580bc938d7d424be1b3b9b001f8c2d8ea93c764", "filename": "src/test/run-pass/match-drop-strs-issue-4541.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fmatch-drop-strs-issue-4541.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fmatch-drop-strs-issue-4541.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-drop-strs-issue-4541.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -2,7 +2,6 @@\n // copying, and moving to ensure that we don't segfault\n // or double-free, as we were wont to do in the past.\n \n-use std::io;\n use std::os;\n \n fn parse_args() -> ~str {\n@@ -23,5 +22,5 @@ fn parse_args() -> ~str {\n }\n \n pub fn main() {\n-    io::println(parse_args());\n+    println(parse_args());\n }"}, {"sha": "5e03b47d1b1dcc1fcb6332e930ed478aeecfb45b", "filename": "src/test/run-pass/monomorphized-callees-with-ty-params-3314.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonomorphized-callees-with-ty-params-3314.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -12,8 +12,6 @@\n \n extern mod extra;\n \n-use std::io;\n-\n trait Serializer {\n }\n \n@@ -33,15 +31,13 @@ impl<A:Serializable> Serializable for F<A> {\n     }\n }\n \n-impl Serializer for @io::Writer {\n+impl Serializer for int {\n }\n \n pub fn main() {\n-    do io::with_str_writer |wr| {\n-        let foo = F { a: 1 };\n-        foo.serialize(wr);\n+    let foo = F { a: 1 };\n+    foo.serialize(1i);\n \n-        let bar = F { a: F {a: 1 } };\n-        bar.serialize(wr);\n-    };\n+    let bar = F { a: F {a: 1 } };\n+    bar.serialize(2i);\n }"}, {"sha": "ef59606afe347e03d5e6d1b663975d692736926c", "filename": "src/test/run-pass/new-import-syntax.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fnew-import-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fnew-import-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-import-syntax.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::println;\n-\n pub fn main() {\n     println(\"Hello world!\");\n }"}, {"sha": "fa681c81398fecfa1cedaa55739b3bfed5b8b007", "filename": "src/test/run-pass/new-style-constants.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fnew-style-constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fnew-style-constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-style-constants.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::println;\n-\n static FOO: int = 3;\n \n pub fn main() {"}, {"sha": "85cf265c2d0e861223259f097a7c1b45bab3a5a3", "filename": "src/test/run-pass/stat.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -13,20 +13,22 @@\n extern mod extra;\n \n use extra::tempfile;\n-use std::io::WriterUtil;\n-use std::io;\n+use std::rt::io;\n+use std::rt::io::Writer;\n+use std::rt::io::file::FileInfo;\n use std::os;\n \n pub fn main() {\n     let dir = tempfile::TempDir::new_in(&Path::new(\".\"), \"\").unwrap();\n     let path = dir.path().join(\"file\");\n \n     {\n-        match io::file_writer(&path, [io::Create, io::Truncate]) {\n-            Err(ref e) => fail!(\"{}\", e.clone()),\n-            Ok(f) => {\n+        match path.open_writer(io::CreateOrTruncate) {\n+            None => unreachable!(),\n+            Some(f) => {\n+                let mut f = f;\n                 for _ in range(0u, 1000) {\n-                    f.write_u8(0);\n+                    f.write([0]);\n                 }\n             }\n         }"}, {"sha": "c8f2afe8c6171351e223242efcebed36db317c0b", "filename": "src/test/run-pass/trait-static-method-overwriting.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61ed2cfb5516f76487509766b1054275f1340f70/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-static-method-overwriting.rs?ref=61ed2cfb5516f76487509766b1054275f1340f70", "patch": "@@ -11,8 +11,6 @@\n // except according to those terms.\n \n mod base {\n-    use std::io;\n-\n     pub trait HasNew<T> {\n         fn new() -> Self;\n     }\n@@ -34,7 +32,7 @@ mod base {\n \n     impl ::base::HasNew<Bar> for Bar {\n         fn new() -> Bar {\n-            io::println(\"Bar\");\n+            println(\"Bar\");\n             Bar { dummy: () }\n         }\n     }"}]}