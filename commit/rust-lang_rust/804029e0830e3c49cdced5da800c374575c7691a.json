{"sha": "804029e0830e3c49cdced5da800c374575c7691a", "node_id": "C_kwDOAAsO6NoAKDgwNDAyOWUwODMwZTNjNDljZGNlZDVkYTgwMGMzNzQ1NzVjNzY5MWE", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-08-30T23:47:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-30T23:47:22Z"}, "message": "Rollup merge of #101197 - lnicola:rust-analyzer-2022-08-30, r=lnicola\n\n:arrow_up: rust-analyzer\n\nr? ``@ghost``", "tree": {"sha": "67633a0ea645492d817cdfd9d97c2134b37b5840", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67633a0ea645492d817cdfd9d97c2134b37b5840"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/804029e0830e3c49cdced5da800c374575c7691a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDqGKCRBK7hj4Ov3rIwAATD4IAISj/Ro3vP3yAD9RJuSIMlzv\nQDbHFhUspwnE7UXKEdQatapIB/dSFyuiPE395Vr8uMR6BJAix7X32QJxF+TQgKpD\njvqh2zaBRhksmVzpb/WyNGwMEkpdm51LTiBFqWTp//GVKje3E/UUJK9BPTj0NWhr\nKyVU6B/lPB0e0vBcG2X+Fm5QzM8Uhm3OsGLaKseXGJiuNWLTsNafn6ARC3GtWDYK\nDrgd09/9f66nGgugu8w8POVTpepLxsDoG98GO3R2t14tpRRoL/ObXqG6+SGNz2vg\nR/bZYAS/vxSvKlVOfHqxkR1Ii5E/2esuKSp6WcX8WdQ64cl9SRDgw+QmvnMUfkw=\n=n2tr\n-----END PGP SIGNATURE-----\n", "payload": "tree 67633a0ea645492d817cdfd9d97c2134b37b5840\nparent f19783dbb8b7ba6d7a76b199b4314c87ed1cb8c1\nparent 367f2ad8b6844192b3b9b2becfec89a159eecd57\nauthor Yuki Okushi <jtitor@2k36.org> 1661903242 +0900\ncommitter GitHub <noreply@github.com> 1661903242 +0900\n\nRollup merge of #101197 - lnicola:rust-analyzer-2022-08-30, r=lnicola\n\n:arrow_up: rust-analyzer\n\nr? ``@ghost``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/804029e0830e3c49cdced5da800c374575c7691a", "html_url": "https://github.com/rust-lang/rust/commit/804029e0830e3c49cdced5da800c374575c7691a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/804029e0830e3c49cdced5da800c374575c7691a/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f19783dbb8b7ba6d7a76b199b4314c87ed1cb8c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f19783dbb8b7ba6d7a76b199b4314c87ed1cb8c1", "html_url": "https://github.com/rust-lang/rust/commit/f19783dbb8b7ba6d7a76b199b4314c87ed1cb8c1"}, {"sha": "367f2ad8b6844192b3b9b2becfec89a159eecd57", "url": "https://api.github.com/repos/rust-lang/rust/commits/367f2ad8b6844192b3b9b2becfec89a159eecd57", "html_url": "https://github.com/rust-lang/rust/commit/367f2ad8b6844192b3b9b2becfec89a159eecd57"}], "stats": {"total": 2870, "additions": 2005, "deletions": 865}, "files": [{"sha": "9f10d92c4e3ab0dc90c60ff09287ade92fbdff6d", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 54, "deletions": 27, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -247,20 +247,6 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n-[[package]]\n-name = \"crossbeam\"\n-version = \"0.8.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2801af0d36612ae591caa9568261fddce32ce6e08a7275ea334a06a4ad021a2c\"\n-dependencies = [\n- \"cfg-if\",\n- \"crossbeam-channel\",\n- \"crossbeam-deque\",\n- \"crossbeam-epoch\",\n- \"crossbeam-queue\",\n- \"crossbeam-utils\",\n-]\n-\n [[package]]\n name = \"crossbeam-channel\"\n version = \"0.5.6\"\n@@ -296,16 +282,6 @@ dependencies = [\n  \"scopeguard\",\n ]\n \n-[[package]]\n-name = \"crossbeam-queue\"\n-version = \"0.3.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1cd42583b04998a5363558e5f9291ee5a5ff6b49944332103f251e7479a82aa7\"\n-dependencies = [\n- \"cfg-if\",\n- \"crossbeam-utils\",\n-]\n-\n [[package]]\n name = \"crossbeam-utils\"\n version = \"0.8.11\"\n@@ -728,6 +704,7 @@ dependencies = [\n  \"ide-db\",\n  \"itertools\",\n  \"parser\",\n+ \"stdx\",\n  \"syntax\",\n  \"test-utils\",\n  \"text-edit\",\n@@ -895,9 +872,9 @@ dependencies = [\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.93.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"70c74e2173b2b31f8655d33724b4b45ac13f439386f66290f539c22b144c2212\"\n+checksum = \"a3bcfee315dde785ba887edb540b08765fd7df75a7d948844be6bf5712246734\"\n dependencies = [\n  \"bitflags\",\n  \"serde\",\n@@ -1178,7 +1155,6 @@ dependencies = [\n name = \"proc-macro-srv\"\n version = \"0.0.0\"\n dependencies = [\n- \"crossbeam\",\n  \"expect-test\",\n  \"libloading\",\n  \"mbe\",\n@@ -1254,6 +1230,26 @@ dependencies = [\n  \"tracing\",\n ]\n \n+[[package]]\n+name = \"protobuf\"\n+version = \"3.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4ee4a7d8b91800c8f167a6268d1a1026607368e1adc84e98fe044aeb905302f7\"\n+dependencies = [\n+ \"once_cell\",\n+ \"protobuf-support\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"protobuf-support\"\n+version = \"3.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8ca157fe12fc7ee2e315f2f735e27df41b3d97cdd70ea112824dac1ffb08ee1c\"\n+dependencies = [\n+ \"thiserror\",\n+]\n+\n [[package]]\n name = \"pulldown-cmark\"\n version = \"0.9.2\"\n@@ -1385,6 +1381,7 @@ dependencies = [\n  \"project-model\",\n  \"rayon\",\n  \"rustc-hash\",\n+ \"scip\",\n  \"serde\",\n  \"serde_json\",\n  \"sourcegen\",\n@@ -1471,6 +1468,15 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n+[[package]]\n+name = \"scip\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b2bfbb10286f69fad7c78db71004b7839bf957788359fe0c479f029f9849136b\"\n+dependencies = [\n+ \"protobuf\",\n+]\n+\n [[package]]\n name = \"scoped-tls\"\n version = \"1.0.0\"\n@@ -1656,6 +1662,26 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"288cb548dbe72b652243ea797201f3d481a0609a967980fcc5b2315ea811560a\"\n \n+[[package]]\n+name = \"thiserror\"\n+version = \"1.0.31\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bd829fe32373d27f76265620b5309d0340cb8550f523c1dda251d6298069069a\"\n+dependencies = [\n+ \"thiserror-impl\",\n+]\n+\n+[[package]]\n+name = \"thiserror-impl\"\n+version = \"1.0.31\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0396bc89e626244658bef819e22d0cc459e795a5ebe878e6ec336d1674a8d79a\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"thread_local\"\n version = \"1.1.4\"\n@@ -1896,6 +1922,7 @@ dependencies = [\n  \"indexmap\",\n  \"paths\",\n  \"rustc-hash\",\n+ \"stdx\",\n ]\n \n [[package]]"}, {"sha": "b388e47dee6e4ecd4411158467ca7e39a4da34f5", "filename": "src/tools/rust-analyzer/crates/base-db/src/input.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -9,10 +9,11 @@\n use std::{fmt, ops, panic::RefUnwindSafe, str::FromStr, sync::Arc};\n \n use cfg::CfgOptions;\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n+use stdx::hash::{NoHashHashMap, NoHashHashSet};\n use syntax::SmolStr;\n use tt::Subtree;\n-use vfs::{file_set::FileSet, FileId, VfsPath};\n+use vfs::{file_set::FileSet, AnchoredPath, FileId, VfsPath};\n \n /// Files are grouped into source roots. A source root is a directory on the\n /// file systems which is watched for changes. Typically it corresponds to a\n@@ -31,22 +32,30 @@ pub struct SourceRoot {\n     /// Libraries are considered mostly immutable, this assumption is used to\n     /// optimize salsa's query structure\n     pub is_library: bool,\n-    pub(crate) file_set: FileSet,\n+    file_set: FileSet,\n }\n \n impl SourceRoot {\n     pub fn new_local(file_set: FileSet) -> SourceRoot {\n         SourceRoot { is_library: false, file_set }\n     }\n+\n     pub fn new_library(file_set: FileSet) -> SourceRoot {\n         SourceRoot { is_library: true, file_set }\n     }\n+\n     pub fn path_for_file(&self, file: &FileId) -> Option<&VfsPath> {\n         self.file_set.path_for_file(file)\n     }\n+\n     pub fn file_for_path(&self, path: &VfsPath) -> Option<&FileId> {\n         self.file_set.file_for_path(path)\n     }\n+\n+    pub fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n+        self.file_set.resolve_path(path)\n+    }\n+\n     pub fn iter(&self) -> impl Iterator<Item = FileId> + '_ {\n         self.file_set.iter()\n     }\n@@ -72,12 +81,19 @@ impl SourceRoot {\n /// <https://github.com/rust-lang/rust-analyzer/blob/master/docs/dev/architecture.md#serialization>\n #[derive(Debug, Clone, Default /* Serialize, Deserialize */)]\n pub struct CrateGraph {\n-    arena: FxHashMap<CrateId, CrateData>,\n+    arena: NoHashHashMap<CrateId, CrateData>,\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct CrateId(pub u32);\n \n+impl stdx::hash::NoHashHashable for CrateId {}\n+impl std::hash::Hash for CrateId {\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        self.0.hash(state);\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct CrateName(SmolStr);\n \n@@ -342,7 +358,7 @@ impl CrateGraph {\n         // Check if adding a dep from `from` to `to` creates a cycle. To figure\n         // that out, look for a  path in the *opposite* direction, from `to` to\n         // `from`.\n-        if let Some(path) = self.find_path(&mut FxHashSet::default(), dep.crate_id, from) {\n+        if let Some(path) = self.find_path(&mut NoHashHashSet::default(), dep.crate_id, from) {\n             let path = path.into_iter().map(|it| (it, self[it].display_name.clone())).collect();\n             let err = CyclicDependenciesError { path };\n             assert!(err.from().0 == from && err.to().0 == dep.crate_id);\n@@ -365,7 +381,7 @@ impl CrateGraph {\n     /// including the crate itself.\n     pub fn transitive_deps(&self, of: CrateId) -> impl Iterator<Item = CrateId> {\n         let mut worklist = vec![of];\n-        let mut deps = FxHashSet::default();\n+        let mut deps = NoHashHashSet::default();\n \n         while let Some(krate) = worklist.pop() {\n             if !deps.insert(krate) {\n@@ -382,10 +398,10 @@ impl CrateGraph {\n     /// including the crate itself.\n     pub fn transitive_rev_deps(&self, of: CrateId) -> impl Iterator<Item = CrateId> {\n         let mut worklist = vec![of];\n-        let mut rev_deps = FxHashSet::default();\n+        let mut rev_deps = NoHashHashSet::default();\n         rev_deps.insert(of);\n \n-        let mut inverted_graph = FxHashMap::<_, Vec<_>>::default();\n+        let mut inverted_graph = NoHashHashMap::<_, Vec<_>>::default();\n         self.arena.iter().for_each(|(&krate, data)| {\n             data.dependencies\n                 .iter()\n@@ -409,7 +425,7 @@ impl CrateGraph {\n     /// come before the crate itself).\n     pub fn crates_in_topological_order(&self) -> Vec<CrateId> {\n         let mut res = Vec::new();\n-        let mut visited = FxHashSet::default();\n+        let mut visited = NoHashHashSet::default();\n \n         for krate in self.arena.keys().copied() {\n             go(self, &mut visited, &mut res, krate);\n@@ -419,7 +435,7 @@ impl CrateGraph {\n \n         fn go(\n             graph: &CrateGraph,\n-            visited: &mut FxHashSet<CrateId>,\n+            visited: &mut NoHashHashSet<CrateId>,\n             res: &mut Vec<CrateId>,\n             source: CrateId,\n         ) {\n@@ -459,7 +475,7 @@ impl CrateGraph {\n \n     fn find_path(\n         &self,\n-        visited: &mut FxHashSet<CrateId>,\n+        visited: &mut NoHashHashSet<CrateId>,\n         from: CrateId,\n         to: CrateId,\n     ) -> Option<Vec<CrateId>> {"}, {"sha": "da11e4ae7bb96f36b2532b79423407e93786cfcf", "filename": "src/tools/rust-analyzer/crates/base-db/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -8,7 +8,7 @@ pub mod fixture;\n \n use std::{panic, sync::Arc};\n \n-use rustc_hash::FxHashSet;\n+use stdx::hash::NoHashHashSet;\n use syntax::{ast, Parse, SourceFile, TextRange, TextSize};\n \n pub use crate::{\n@@ -58,7 +58,7 @@ pub trait FileLoader {\n     /// Text of the file.\n     fn file_text(&self, file_id: FileId) -> Arc<String>;\n     fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId>;\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>>;\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<NoHashHashSet<CrateId>>;\n }\n \n /// Database which stores all significant input facts: source code and project\n@@ -94,10 +94,10 @@ pub trait SourceDatabaseExt: SourceDatabase {\n     #[salsa::input]\n     fn source_root(&self, id: SourceRootId) -> Arc<SourceRoot>;\n \n-    fn source_root_crates(&self, id: SourceRootId) -> Arc<FxHashSet<CrateId>>;\n+    fn source_root_crates(&self, id: SourceRootId) -> Arc<NoHashHashSet<CrateId>>;\n }\n \n-fn source_root_crates(db: &dyn SourceDatabaseExt, id: SourceRootId) -> Arc<FxHashSet<CrateId>> {\n+fn source_root_crates(db: &dyn SourceDatabaseExt, id: SourceRootId) -> Arc<NoHashHashSet<CrateId>> {\n     let graph = db.crate_graph();\n     let res = graph\n         .iter()\n@@ -120,10 +120,10 @@ impl<T: SourceDatabaseExt> FileLoader for FileLoaderDelegate<&'_ T> {\n         // FIXME: this *somehow* should be platform agnostic...\n         let source_root = self.0.file_source_root(path.anchor);\n         let source_root = self.0.source_root(source_root);\n-        source_root.file_set.resolve_path(path)\n+        source_root.resolve_path(path)\n     }\n \n-    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<NoHashHashSet<CrateId>> {\n         let _p = profile::span(\"relevant_crates\");\n         let source_root = self.0.file_source_root(file_id);\n         self.0.source_root_crates(source_root)"}, {"sha": "d9f4ef5b7ff578deceae41a0a1866b15d7dd9753", "filename": "src/tools/rust-analyzer/crates/flycheck/src/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -125,6 +125,7 @@ pub enum Progress {\n     DidCheckCrate(String),\n     DidFinish(io::Result<()>),\n     DidCancel,\n+    DidFailToRestart(String),\n }\n \n enum Restart {\n@@ -193,10 +194,11 @@ impl FlycheckActor {\n                             self.progress(Progress::DidStart);\n                         }\n                         Err(error) => {\n-                            tracing::error!(\n-                                command = ?self.check_command(),\n-                                %error, \"failed to restart flycheck\"\n-                            );\n+                            self.progress(Progress::DidFailToRestart(format!(\n+                                \"Failed to run the following command: {:?} error={}\",\n+                                self.check_command(),\n+                                error\n+                            )));\n                         }\n                     }\n                 }"}, {"sha": "631ae3cf11fa7e0fc9ddc2d57843ac383d1d6e65", "filename": "src/tools/rust-analyzer/crates/hir-def/src/data.rs", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -2,7 +2,7 @@\n \n use std::sync::Arc;\n \n-use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, MacroCallId, MacroDefKind};\n+use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, InFile, MacroCallId, MacroDefKind};\n use smallvec::SmallVec;\n use syntax::ast;\n \n@@ -12,7 +12,10 @@ use crate::{\n     db::DefDatabase,\n     intern::Interned,\n     item_tree::{self, AssocItem, FnFlags, ItemTree, ItemTreeId, ModItem, Param, TreeId},\n-    nameres::{attr_resolution::ResolvedAttr, proc_macro::ProcMacroKind, DefMap},\n+    nameres::{\n+        attr_resolution::ResolvedAttr, diagnostics::DefDiagnostic, proc_macro::ProcMacroKind,\n+        DefMap,\n+    },\n     type_ref::{TraitRef, TypeBound, TypeRef},\n     visibility::RawVisibility,\n     AssocItemId, AstIdWithPath, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n@@ -210,6 +213,13 @@ pub struct TraitData {\n \n impl TraitData {\n     pub(crate) fn trait_data_query(db: &dyn DefDatabase, tr: TraitId) -> Arc<TraitData> {\n+        db.trait_data_with_diagnostics(tr).0\n+    }\n+\n+    pub(crate) fn trait_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        tr: TraitId,\n+    ) -> (Arc<TraitData>, Arc<Vec<DefDiagnostic>>) {\n         let tr_loc @ ItemLoc { container: module_id, id: tree_id } = tr.lookup(db);\n         let item_tree = tree_id.item_tree(db);\n         let tr_def = &item_tree[tree_id.value];\n@@ -229,17 +239,20 @@ impl TraitData {\n         let mut collector =\n             AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::TraitId(tr));\n         collector.collect(&item_tree, tree_id.tree_id(), &tr_def.items);\n-        let (items, attribute_calls) = collector.finish();\n-\n-        Arc::new(TraitData {\n-            name,\n-            attribute_calls,\n-            items,\n-            is_auto,\n-            is_unsafe,\n-            visibility,\n-            skip_array_during_method_dispatch,\n-        })\n+        let (items, attribute_calls, diagnostics) = collector.finish();\n+\n+        (\n+            Arc::new(TraitData {\n+                name,\n+                attribute_calls,\n+                items,\n+                is_auto,\n+                is_unsafe,\n+                visibility,\n+                skip_array_during_method_dispatch,\n+            }),\n+            Arc::new(diagnostics),\n+        )\n     }\n \n     pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {\n@@ -280,7 +293,14 @@ pub struct ImplData {\n \n impl ImplData {\n     pub(crate) fn impl_data_query(db: &dyn DefDatabase, id: ImplId) -> Arc<ImplData> {\n-        let _p = profile::span(\"impl_data_query\");\n+        db.impl_data_with_diagnostics(id).0\n+    }\n+\n+    pub(crate) fn impl_data_with_diagnostics_query(\n+        db: &dyn DefDatabase,\n+        id: ImplId,\n+    ) -> (Arc<ImplData>, Arc<Vec<DefDiagnostic>>) {\n+        let _p = profile::span(\"impl_data_with_diagnostics_query\");\n         let ItemLoc { container: module_id, id: tree_id } = id.lookup(db);\n \n         let item_tree = tree_id.item_tree(db);\n@@ -293,10 +313,13 @@ impl ImplData {\n             AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::ImplId(id));\n         collector.collect(&item_tree, tree_id.tree_id(), &impl_def.items);\n \n-        let (items, attribute_calls) = collector.finish();\n+        let (items, attribute_calls, diagnostics) = collector.finish();\n         let items = items.into_iter().map(|(_, item)| item).collect();\n \n-        Arc::new(ImplData { target_trait, self_ty, items, is_negative, attribute_calls })\n+        (\n+            Arc::new(ImplData { target_trait, self_ty, items, is_negative, attribute_calls }),\n+            Arc::new(diagnostics),\n+        )\n     }\n \n     pub fn attribute_calls(&self) -> impl Iterator<Item = (AstId<ast::Item>, MacroCallId)> + '_ {\n@@ -437,6 +460,7 @@ struct AssocItemCollector<'a> {\n     db: &'a dyn DefDatabase,\n     module_id: ModuleId,\n     def_map: Arc<DefMap>,\n+    inactive_diagnostics: Vec<DefDiagnostic>,\n     container: ItemContainerId,\n     expander: Expander,\n \n@@ -459,15 +483,21 @@ impl<'a> AssocItemCollector<'a> {\n             expander: Expander::new(db, file_id, module_id),\n             items: Vec::new(),\n             attr_calls: Vec::new(),\n+            inactive_diagnostics: Vec::new(),\n         }\n     }\n \n     fn finish(\n         self,\n-    ) -> (Vec<(Name, AssocItemId)>, Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>) {\n+    ) -> (\n+        Vec<(Name, AssocItemId)>,\n+        Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>,\n+        Vec<DefDiagnostic>,\n+    ) {\n         (\n             self.items,\n             if self.attr_calls.is_empty() { None } else { Some(Box::new(self.attr_calls)) },\n+            self.inactive_diagnostics,\n         )\n     }\n \n@@ -479,6 +509,12 @@ impl<'a> AssocItemCollector<'a> {\n         'items: for &item in assoc_items {\n             let attrs = item_tree.attrs(self.db, self.module_id.krate, ModItem::from(item).into());\n             if !attrs.is_cfg_enabled(self.expander.cfg_options()) {\n+                self.inactive_diagnostics.push(DefDiagnostic::unconfigured_code(\n+                    self.module_id.local_id,\n+                    InFile::new(self.expander.current_file_id(), item.ast_id(&item_tree).upcast()),\n+                    attrs.cfg().unwrap(),\n+                    self.expander.cfg_options().clone(),\n+                ));\n                 continue;\n             }\n "}, {"sha": "40b2f734b7117192afa1fb51b52de20be9a250c8", "filename": "src/tools/rust-analyzer/crates/hir-def/src/db.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -20,7 +20,7 @@ use crate::{\n     intern::Interned,\n     item_tree::{AttrOwner, ItemTree},\n     lang_item::{LangItemTarget, LangItems},\n-    nameres::DefMap,\n+    nameres::{diagnostics::DefDiagnostic, DefMap},\n     visibility::{self, Visibility},\n     AttrDefId, BlockId, BlockLoc, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, ExternBlockId,\n     ExternBlockLoc, FunctionId, FunctionLoc, GenericDefId, ImplId, ImplLoc, LocalEnumVariantId,\n@@ -106,9 +106,16 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(ImplData::impl_data_query)]\n     fn impl_data(&self, e: ImplId) -> Arc<ImplData>;\n \n+    #[salsa::invoke(ImplData::impl_data_with_diagnostics_query)]\n+    fn impl_data_with_diagnostics(&self, e: ImplId) -> (Arc<ImplData>, Arc<Vec<DefDiagnostic>>);\n+\n     #[salsa::invoke(TraitData::trait_data_query)]\n     fn trait_data(&self, e: TraitId) -> Arc<TraitData>;\n \n+    #[salsa::invoke(TraitData::trait_data_with_diagnostics_query)]\n+    fn trait_data_with_diagnostics(&self, tr: TraitId)\n+        -> (Arc<TraitData>, Arc<Vec<DefDiagnostic>>);\n+\n     #[salsa::invoke(TypeAliasData::type_alias_data_query)]\n     fn type_alias_data(&self, e: TypeAliasId) -> Arc<TypeAliasData>;\n "}, {"sha": "ed7e920fd2b83a00ac28b69fca443dc6723a83d1", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -73,7 +73,7 @@ impl DefDiagnostic {\n         Self { in_module: container, kind: DefDiagnosticKind::UnresolvedImport { id, index } }\n     }\n \n-    pub(super) fn unconfigured_code(\n+    pub fn unconfigured_code(\n         container: LocalModuleId,\n         ast: AstId<ast::Item>,\n         cfg: CfgExpr,"}, {"sha": "b7908bddaa1cf785d392cf1e7f4449eee0f64e82", "filename": "src/tools/rust-analyzer/crates/hir-def/src/test_db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -10,7 +10,7 @@ use base_db::{\n     SourceDatabase, Upcast,\n };\n use hir_expand::{db::AstDatabase, InFile};\n-use rustc_hash::FxHashSet;\n+use stdx::hash::NoHashHashSet;\n use syntax::{algo, ast, AstNode};\n \n use crate::{\n@@ -76,7 +76,7 @@ impl FileLoader for TestDB {\n     fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n         FileLoaderDelegate(self).resolve_path(path)\n     }\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<NoHashHashSet<CrateId>> {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n }"}, {"sha": "3f6d0844e9c1f27afc10ece6dde6b3414c169937", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lower.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -6,7 +6,7 @@\n //!\n //! This usually involves resolving names, collecting generic arguments etc.\n use std::{\n-    cell::{Cell, RefCell},\n+    cell::{Cell, RefCell, RefMut},\n     iter,\n     sync::Arc,\n };\n@@ -330,26 +330,26 @@ impl<'a> TyLoweringContext<'a> {\n                 }\n             }\n             TypeRef::Macro(macro_call) => {\n-                let (expander, recursion_start) = {\n-                    let mut expander = self.expander.borrow_mut();\n-                    if expander.is_some() {\n-                        (Some(expander), false)\n-                    } else {\n-                        *expander = Some(Expander::new(\n-                            self.db.upcast(),\n-                            macro_call.file_id,\n-                            self.resolver.module(),\n-                        ));\n-                        (Some(expander), true)\n+                let (mut expander, recursion_start) = {\n+                    match RefMut::filter_map(self.expander.borrow_mut(), Option::as_mut) {\n+                        Ok(expander) => (expander, false),\n+                        Err(expander) => (\n+                            RefMut::map(expander, |it| {\n+                                it.insert(Expander::new(\n+                                    self.db.upcast(),\n+                                    macro_call.file_id,\n+                                    self.resolver.module(),\n+                                ))\n+                            }),\n+                            true,\n+                        ),\n                     }\n                 };\n-                let ty = if let Some(mut expander) = expander {\n-                    let expander_mut = expander.as_mut().unwrap();\n+                let ty = {\n                     let macro_call = macro_call.to_node(self.db.upcast());\n-                    match expander_mut.enter_expand::<ast::Type>(self.db.upcast(), macro_call) {\n+                    match expander.enter_expand::<ast::Type>(self.db.upcast(), macro_call) {\n                         Ok(ExpandResult { value: Some((mark, expanded)), .. }) => {\n-                            let ctx =\n-                                LowerCtx::new(self.db.upcast(), expander_mut.current_file_id());\n+                            let ctx = LowerCtx::new(self.db.upcast(), expander.current_file_id());\n                             let type_ref = TypeRef::from_ast(&ctx, expanded);\n \n                             drop(expander);\n@@ -364,8 +364,6 @@ impl<'a> TyLoweringContext<'a> {\n                         }\n                         _ => None,\n                     }\n-                } else {\n-                    None\n                 };\n                 if recursion_start {\n                     *self.expander.borrow_mut() = None;\n@@ -479,7 +477,14 @@ impl<'a> TyLoweringContext<'a> {\n                         TyKind::Placeholder(to_placeholder_idx(self.db, param_id.into()))\n                     }\n                     ParamLoweringMode::Variable => {\n-                        let idx = generics.param_idx(param_id.into()).expect(\"matching generics\");\n+                        let idx = match generics.param_idx(param_id.into()) {\n+                            None => {\n+                                never!(\"no matching generics\");\n+                                return (TyKind::Error.intern(Interner), None);\n+                            }\n+                            Some(idx) => idx,\n+                        };\n+\n                         TyKind::BoundVar(BoundVar::new(self.in_binders, idx))\n                     }\n                 }"}, {"sha": "118e5311e9a6414ebf6ab084762257883bb2d4dd", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/test_db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -10,7 +10,7 @@ use base_db::{\n };\n use hir_def::{db::DefDatabase, ModuleId};\n use hir_expand::db::AstDatabase;\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use stdx::hash::{NoHashHashMap, NoHashHashSet};\n use syntax::TextRange;\n use test_utils::extract_annotations;\n \n@@ -80,7 +80,7 @@ impl FileLoader for TestDB {\n     fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n         FileLoaderDelegate(self).resolve_path(path)\n     }\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<NoHashHashSet<CrateId>> {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n }\n@@ -102,7 +102,7 @@ impl TestDB {\n         self.module_for_file_opt(file_id).unwrap()\n     }\n \n-    pub(crate) fn extract_annotations(&self) -> FxHashMap<FileId, Vec<(TextRange, String)>> {\n+    pub(crate) fn extract_annotations(&self) -> NoHashHashMap<FileId, Vec<(TextRange, String)>> {\n         let mut files = Vec::new();\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter() {"}, {"sha": "c7895db1afbf5e523a3e6c9a03f09df74cd0aa73", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -1526,6 +1526,34 @@ unsafe impl Storage for InlineStorage {\n     );\n }\n \n+#[test]\n+fn gat_crash_3() {\n+    // FIXME: This test currently crashes rust analyzer in a debug build but not in a\n+    // release build (i.e. for the user). With the assumption that tests will always be run\n+    // in debug mode, we catch the unwind and expect that it panicked. See the\n+    // [`crate::utils::generics`] function for more information.\n+    cov_mark::check!(ignore_gats);\n+    std::panic::catch_unwind(|| {\n+        check_no_mismatches(\n+            r#\"\n+trait Collection {\n+    type Item;\n+    type Member<T>: Collection<Item = T>;\n+    fn add(&mut self, value: Self::Item) -> Result<(), Self::Error>;\n+}\n+struct ConstGen<T, const N: usize> {\n+    data: [T; N],\n+}\n+impl<T, const N: usize> Collection for ConstGen<T, N> {\n+    type Item = T;\n+    type Member<U> = ConstGen<U, N>;\n+}\n+        \"#,\n+        );\n+    })\n+    .expect_err(\"must panic\");\n+}\n+\n #[test]\n fn cfgd_out_self_param() {\n     cov_mark::check!(cfgd_out_self_param);"}, {"sha": "d6638db02851183c5f080dc8cfc3fed5503ae76c", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/utils.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -176,10 +176,19 @@ pub(crate) fn generics(db: &dyn DefDatabase, def: GenericDefId) -> Generics {\n     let parent_generics = parent_generic_def(db, def).map(|def| Box::new(generics(db, def)));\n     if parent_generics.is_some() && matches!(def, GenericDefId::TypeAliasId(_)) {\n         let params = db.generic_params(def);\n+        let parent_params = &parent_generics.as_ref().unwrap().params;\n         let has_consts =\n             params.iter().any(|(_, x)| matches!(x, TypeOrConstParamData::ConstParamData(_)));\n-        return if has_consts {\n-            // XXX: treat const generic associated types as not existing to avoid crashes (#11769)\n+        let parent_has_consts =\n+            parent_params.iter().any(|(_, x)| matches!(x, TypeOrConstParamData::ConstParamData(_)));\n+        return if has_consts || parent_has_consts {\n+            // XXX: treat const generic associated types as not existing to avoid crashes\n+            // (#11769)\n+            //\n+            // Note: Also crashes when the parent has const generics (also even if the GAT\n+            // doesn't use them), see `tests::regression::gat_crash_3` for an example.\n+            // Avoids that by disabling GATs when the parent (i.e. `impl` block) has\n+            // const generics (#12193).\n             //\n             // Chalk expects the inner associated type's parameters to come\n             // *before*, not after the trait's generics as we've always done it.\n@@ -264,12 +273,8 @@ impl Generics {\n \n     fn find_param(&self, param: TypeOrConstParamId) -> Option<(usize, &TypeOrConstParamData)> {\n         if param.parent == self.def {\n-            let (idx, (_local_id, data)) = self\n-                .params\n-                .iter()\n-                .enumerate()\n-                .find(|(_, (idx, _))| *idx == param.local_id)\n-                .unwrap();\n+            let (idx, (_local_id, data)) =\n+                self.params.iter().enumerate().find(|(_, (idx, _))| *idx == param.local_id)?;\n             let parent_len = self.parent_generics().map_or(0, Generics::len);\n             Some((parent_len + idx, data))\n         } else {"}, {"sha": "6dccf2ed20b8e8e6dc00534678e42e7a558de526", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -511,6 +511,7 @@ impl Module {\n             .collect()\n     }\n \n+    /// Fills `acc` with the module's diagnostics.\n     pub fn diagnostics(self, db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>) {\n         let _p = profile::span(\"Module::diagnostics\").detail(|| {\n             format!(\"{:?}\", self.name(db).map_or(\"<unknown>\".into(), |name| name.to_string()))\n@@ -531,11 +532,21 @@ impl Module {\n                         m.diagnostics(db, acc)\n                     }\n                 }\n+                ModuleDef::Trait(t) => {\n+                    for diag in db.trait_data_with_diagnostics(t.id).1.iter() {\n+                        emit_def_diagnostic(db, acc, diag);\n+                    }\n+                    acc.extend(decl.diagnostics(db))\n+                }\n                 _ => acc.extend(decl.diagnostics(db)),\n             }\n         }\n \n         for impl_def in self.impl_defs(db) {\n+            for diag in db.impl_data_with_diagnostics(impl_def.id).1.iter() {\n+                emit_def_diagnostic(db, acc, diag);\n+            }\n+\n             for item in impl_def.items(db) {\n                 let def: DefWithBody = match item {\n                     AssocItem::Function(it) => it.into(),"}, {"sha": "03aa8601d14e1ef3e34207da916dd4574d175bbf", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_type_alias.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -171,6 +171,25 @@ fn collect_used_generics<'gp>(\n         ast::Type::RefType(ref_) => generics.extend(\n             ref_.lifetime().and_then(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n         ),\n+        ast::Type::ArrayType(ar) => {\n+            if let Some(expr) = ar.expr() {\n+                if let ast::Expr::PathExpr(p) = expr {\n+                    if let Some(path) = p.path() {\n+                        if let Some(name_ref) = path.as_single_name_ref() {\n+                            if let Some(param) = known_generics.iter().find(|gp| {\n+                                if let ast::GenericParam::ConstParam(cp) = gp {\n+                                    cp.name().map_or(false, |n| n.text() == name_ref.text())\n+                                } else {\n+                                    false\n+                                }\n+                            }) {\n+                                generics.push(param);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n         _ => (),\n     });\n     // stable resort to lifetime, type, const\n@@ -357,4 +376,29 @@ impl<'outer, Outer, const OUTER: usize> () {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn issue_11197() {\n+        check_assist(\n+            extract_type_alias,\n+            r#\"\n+struct Foo<T, const N: usize>\n+where\n+    [T; N]: Sized,\n+{\n+    arr: $0[T; N]$0,\n+}\n+            \"#,\n+            r#\"\n+type $0Type<T, const N: usize> = [T; N];\n+\n+struct Foo<T, const N: usize>\n+where\n+    [T; N]: Sized,\n+{\n+    arr: Type<T, N>,\n+}\n+            \"#,\n+        );\n+    }\n }"}, {"sha": "96890ad51a6f941e3399fea772058ab19d653af9", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/inline_call.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -311,12 +311,16 @@ fn inline(\n     } else {\n         fn_body.clone_for_update()\n     };\n-    if let Some(t) = body.syntax().ancestors().find_map(ast::Impl::cast).and_then(|i| i.self_ty()) {\n-        body.syntax()\n-            .descendants_with_tokens()\n-            .filter_map(NodeOrToken::into_token)\n-            .filter(|tok| tok.kind() == SyntaxKind::SELF_TYPE_KW)\n-            .for_each(|tok| ted::replace(tok, t.syntax()));\n+    if let Some(imp) = body.syntax().ancestors().find_map(ast::Impl::cast) {\n+        if !node.syntax().ancestors().any(|anc| &anc == imp.syntax()) {\n+            if let Some(t) = imp.self_ty() {\n+                body.syntax()\n+                    .descendants_with_tokens()\n+                    .filter_map(NodeOrToken::into_token)\n+                    .filter(|tok| tok.kind() == SyntaxKind::SELF_TYPE_KW)\n+                    .for_each(|tok| ted::replace(tok, t.syntax()));\n+            }\n+        }\n     }\n     let usages_for_locals = |local| {\n         Definition::Local(local)\n@@ -1221,6 +1225,31 @@ impl A {\n fn main() {\n     A(114514);\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn inline_call_with_self_type_but_within_same_impl() {\n+        check_assist(\n+            inline_call,\n+            r#\"\n+struct A(u32);\n+impl A {\n+    fn f() -> Self { Self(1919810) }\n+    fn main() {\n+        Self::f$0();\n+    }\n+}\n+\"#,\n+            r#\"\n+struct A(u32);\n+impl A {\n+    fn f() -> Self { Self(1919810) }\n+    fn main() {\n+        Self(1919810);\n+    }\n+}\n \"#,\n         )\n     }"}, {"sha": "a5e854b74df9d268504f2b4e39684c6002e4c335", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -64,8 +64,11 @@ pub(crate) struct PathCompletionCtx {\n     pub(super) qualified: Qualified,\n     /// The parent of the path we are completing.\n     pub(super) parent: Option<ast::Path>,\n+    #[allow(dead_code)]\n     /// The path of which we are completing the segment\n     pub(super) path: ast::Path,\n+    /// The path of which we are completing the segment in the original file\n+    pub(crate) original_path: Option<ast::Path>,\n     pub(super) kind: PathKind,\n     /// Whether the path segment has type args or not.\n     pub(super) has_type_args: bool,"}, {"sha": "01dd9a234f553c354a47eb3487fc610a37b8df26", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -588,12 +588,15 @@ impl<'a> CompletionContext<'a> {\n         };\n \n         let path = segment.parent_path();\n+        let original_path = find_node_in_file_compensated(sema, original_file, &path);\n+\n         let mut path_ctx = PathCompletionCtx {\n             has_call_parens: false,\n             has_macro_bang: false,\n             qualified: Qualified::No,\n             parent: None,\n             path: path.clone(),\n+            original_path,\n             kind: PathKind::Item { kind: ItemListKind::SourceFile },\n             has_type_args: false,\n             use_tree_parent: false,"}, {"sha": "86302cb0678f198687dfe2b4eed26997c642efa6", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -323,9 +323,7 @@ fn render_resolution_path(\n             ..CompletionRelevance::default()\n         });\n \n-        if let Some(ref_match) = compute_ref_match(completion, &ty) {\n-            item.ref_match(ref_match, path_ctx.path.syntax().text_range().start());\n-        }\n+        path_ref_match(completion, path_ctx, &ty, &mut item);\n     };\n     item\n }\n@@ -453,6 +451,29 @@ fn compute_ref_match(\n     None\n }\n \n+fn path_ref_match(\n+    completion: &CompletionContext<'_>,\n+    path_ctx: &PathCompletionCtx,\n+    ty: &hir::Type,\n+    item: &mut Builder,\n+) {\n+    if let Some(original_path) = &path_ctx.original_path {\n+        // At least one char was typed by the user already, in that case look for the original path\n+        if let Some(original_path) = completion.sema.original_ast_node(original_path.clone()) {\n+            if let Some(ref_match) = compute_ref_match(completion, ty) {\n+                item.ref_match(ref_match, original_path.syntax().text_range().start());\n+            }\n+        }\n+    } else {\n+        // completion requested on an empty identifier, there is no path here yet.\n+        // FIXME: This might create inconsistent completions where we show a ref match in macro inputs\n+        // as long as nothing was typed yet\n+        if let Some(ref_match) = compute_ref_match(completion, ty) {\n+            item.ref_match(ref_match, completion.position.offset);\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::cmp;"}, {"sha": "37612084604764eee2c66ec568d9dc7fda0c236f", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/function.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -79,18 +79,18 @@ fn render(\n         ..ctx.completion_relevance()\n     });\n \n-    if let Some(ref_match) = compute_ref_match(completion, &ret_type) {\n-        match func_kind {\n-            FuncKind::Function(path_ctx) => {\n-                item.ref_match(ref_match, path_ctx.path.syntax().text_range().start());\n-            }\n-            FuncKind::Method(DotAccess { receiver: Some(receiver), .. }, _) => {\n-                if let Some(original_expr) = completion.sema.original_ast_node(receiver.clone()) {\n+    match func_kind {\n+        FuncKind::Function(path_ctx) => {\n+            super::path_ref_match(completion, path_ctx, &ret_type, &mut item);\n+        }\n+        FuncKind::Method(DotAccess { receiver: Some(receiver), .. }, _) => {\n+            if let Some(original_expr) = completion.sema.original_ast_node(receiver.clone()) {\n+                if let Some(ref_match) = compute_ref_match(completion, &ret_type) {\n                     item.ref_match(ref_match, original_expr.syntax().text_range().start());\n                 }\n             }\n-            _ => (),\n         }\n+        _ => (),\n     }\n \n     item.set_documentation(ctx.docs(func))"}, {"sha": "0c791ac570c566f95f511c1a94805ffe03b96af1", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/literal.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -2,13 +2,12 @@\n \n use hir::{db::HirDatabase, Documentation, HasAttrs, StructKind};\n use ide_db::SymbolKind;\n-use syntax::AstNode;\n \n use crate::{\n     context::{CompletionContext, PathCompletionCtx, PathKind},\n     item::{Builder, CompletionItem},\n     render::{\n-        compute_ref_match, compute_type_match,\n+        compute_type_match,\n         variant::{\n             format_literal_label, format_literal_lookup, render_record_lit, render_tuple_lit,\n             visible_fields, RenderedLiteral,\n@@ -125,9 +124,8 @@ fn render(\n         type_match: compute_type_match(ctx.completion, &ty),\n         ..ctx.completion_relevance()\n     });\n-    if let Some(ref_match) = compute_ref_match(completion, &ty) {\n-        item.ref_match(ref_match, path_ctx.path.syntax().text_range().start());\n-    }\n+\n+    super::path_ref_match(completion, path_ctx, &ty, &mut item);\n \n     if let Some(import_to_add) = ctx.import_to_add {\n         item.add_import(import_to_add);"}, {"sha": "1ec62a8425a39b3fcb5f1fb6287047e7cf1b4002", "filename": "src/tools/rust-analyzer/crates/ide-db/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -52,6 +52,7 @@ use hir::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     symbols::FileSymbolKind,\n };\n+use stdx::hash::NoHashHashSet;\n \n use crate::{line_index::LineIndex, symbol_index::SymbolsDatabase};\n pub use rustc_hash::{FxHashMap, FxHashSet, FxHasher};\n@@ -118,7 +119,7 @@ impl FileLoader for RootDatabase {\n     fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n         FileLoaderDelegate(self).resolve_path(path)\n     }\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<NoHashHashSet<CrateId>> {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n }"}, {"sha": "75d49ff2fd77fc040779ee51238811c3b4348777", "filename": "src/tools/rust-analyzer/crates/ide-db/src/line_index.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -2,15 +2,15 @@\n //! representation.\n use std::{iter, mem};\n \n-use rustc_hash::FxHashMap;\n+use stdx::hash::NoHashHashMap;\n use syntax::{TextRange, TextSize};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct LineIndex {\n     /// Offset the the beginning of each line, zero-based\n     pub(crate) newlines: Vec<TextSize>,\n     /// List of non-ASCII characters on each line\n-    pub(crate) utf16_lines: FxHashMap<u32, Vec<Utf16Char>>,\n+    pub(crate) utf16_lines: NoHashHashMap<u32, Vec<Utf16Char>>,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n@@ -55,7 +55,7 @@ impl Utf16Char {\n \n impl LineIndex {\n     pub fn new(text: &str) -> LineIndex {\n-        let mut utf16_lines = FxHashMap::default();\n+        let mut utf16_lines = NoHashHashMap::default();\n         let mut utf16_chars = Vec::new();\n \n         let mut newlines = vec![0.into()];"}, {"sha": "7deffe8e0f637917c2ab05cac45ee069037caf69", "filename": "src/tools/rust-analyzer/crates/ide-db/src/search.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -9,7 +9,7 @@ use std::{mem, sync::Arc};\n use base_db::{FileId, FileRange, SourceDatabase, SourceDatabaseExt};\n use hir::{DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility};\n use once_cell::unsync::Lazy;\n-use rustc_hash::FxHashMap;\n+use stdx::hash::NoHashHashMap;\n use syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n \n use crate::{\n@@ -20,7 +20,7 @@ use crate::{\n \n #[derive(Debug, Default, Clone)]\n pub struct UsageSearchResult {\n-    pub references: FxHashMap<FileId, Vec<FileReference>>,\n+    pub references: NoHashHashMap<FileId, Vec<FileReference>>,\n }\n \n impl UsageSearchResult {\n@@ -45,7 +45,7 @@ impl UsageSearchResult {\n \n impl IntoIterator for UsageSearchResult {\n     type Item = (FileId, Vec<FileReference>);\n-    type IntoIter = <FxHashMap<FileId, Vec<FileReference>> as IntoIterator>::IntoIter;\n+    type IntoIter = <NoHashHashMap<FileId, Vec<FileReference>> as IntoIterator>::IntoIter;\n \n     fn into_iter(self) -> Self::IntoIter {\n         self.references.into_iter()\n@@ -78,17 +78,17 @@ pub enum ReferenceCategory {\n /// e.g. for things like local variables.\n #[derive(Clone, Debug)]\n pub struct SearchScope {\n-    entries: FxHashMap<FileId, Option<TextRange>>,\n+    entries: NoHashHashMap<FileId, Option<TextRange>>,\n }\n \n impl SearchScope {\n-    fn new(entries: FxHashMap<FileId, Option<TextRange>>) -> SearchScope {\n+    fn new(entries: NoHashHashMap<FileId, Option<TextRange>>) -> SearchScope {\n         SearchScope { entries }\n     }\n \n     /// Build a search scope spanning the entire crate graph of files.\n     fn crate_graph(db: &RootDatabase) -> SearchScope {\n-        let mut entries = FxHashMap::default();\n+        let mut entries = NoHashHashMap::default();\n \n         let graph = db.crate_graph();\n         for krate in graph.iter() {\n@@ -102,7 +102,7 @@ impl SearchScope {\n \n     /// Build a search scope spanning all the reverse dependencies of the given crate.\n     fn reverse_dependencies(db: &RootDatabase, of: hir::Crate) -> SearchScope {\n-        let mut entries = FxHashMap::default();\n+        let mut entries = NoHashHashMap::default();\n         for rev_dep in of.transitive_reverse_dependencies(db) {\n             let root_file = rev_dep.root_file(db);\n             let source_root_id = db.file_source_root(root_file);\n@@ -117,14 +117,12 @@ impl SearchScope {\n         let root_file = of.root_file(db);\n         let source_root_id = db.file_source_root(root_file);\n         let source_root = db.source_root(source_root_id);\n-        SearchScope {\n-            entries: source_root.iter().map(|id| (id, None)).collect::<FxHashMap<_, _>>(),\n-        }\n+        SearchScope { entries: source_root.iter().map(|id| (id, None)).collect() }\n     }\n \n     /// Build a search scope spanning the given module and all its submodules.\n     fn module_and_children(db: &RootDatabase, module: hir::Module) -> SearchScope {\n-        let mut entries = FxHashMap::default();\n+        let mut entries = NoHashHashMap::default();\n \n         let (file_id, range) = {\n             let InFile { file_id, value } = module.definition_source(db);\n@@ -157,7 +155,7 @@ impl SearchScope {\n \n     /// Build an empty search scope.\n     pub fn empty() -> SearchScope {\n-        SearchScope::new(FxHashMap::default())\n+        SearchScope::new(NoHashHashMap::default())\n     }\n \n     /// Build a empty search scope spanning the given file."}, {"sha": "8e338061df43345c6d18b2cd6eb1d7fefb41a707", "filename": "src/tools/rust-analyzer/crates/ide-db/src/source_change.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsource_change.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -6,16 +6,15 @@\n use std::{collections::hash_map::Entry, iter, mem};\n \n use base_db::{AnchoredPathBuf, FileId};\n-use rustc_hash::FxHashMap;\n-use stdx::never;\n+use stdx::{hash::NoHashHashMap, never};\n use syntax::{algo, AstNode, SyntaxNode, SyntaxNodePtr, TextRange, TextSize};\n use text_edit::{TextEdit, TextEditBuilder};\n \n use crate::SnippetCap;\n \n #[derive(Default, Debug, Clone)]\n pub struct SourceChange {\n-    pub source_file_edits: FxHashMap<FileId, TextEdit>,\n+    pub source_file_edits: NoHashHashMap<FileId, TextEdit>,\n     pub file_system_edits: Vec<FileSystemEdit>,\n     pub is_snippet: bool,\n }\n@@ -24,7 +23,7 @@ impl SourceChange {\n     /// Creates a new SourceChange with the given label\n     /// from the edits.\n     pub fn from_edits(\n-        source_file_edits: FxHashMap<FileId, TextEdit>,\n+        source_file_edits: NoHashHashMap<FileId, TextEdit>,\n         file_system_edits: Vec<FileSystemEdit>,\n     ) -> Self {\n         SourceChange { source_file_edits, file_system_edits, is_snippet: false }\n@@ -78,8 +77,8 @@ impl Extend<FileSystemEdit> for SourceChange {\n     }\n }\n \n-impl From<FxHashMap<FileId, TextEdit>> for SourceChange {\n-    fn from(source_file_edits: FxHashMap<FileId, TextEdit>) -> SourceChange {\n+impl From<NoHashHashMap<FileId, TextEdit>> for SourceChange {\n+    fn from(source_file_edits: NoHashHashMap<FileId, TextEdit>) -> SourceChange {\n         SourceChange { source_file_edits, file_system_edits: Vec::new(), is_snippet: false }\n     }\n }"}, {"sha": "04918891b254ca4a45f7cd12ef8187fc60d9c2c2", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/inactive_code.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -106,18 +106,17 @@ fn f() {\n \n     #[test]\n     fn inactive_assoc_item() {\n-        // FIXME these currently don't work, hence the *\n         check(\n             r#\"\n struct Foo;\n impl Foo {\n     #[cfg(any())] pub fn f() {}\n-  //*************************** weak: code is inactive due to #[cfg] directives\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives\n }\n \n trait Bar {\n     #[cfg(any())] pub fn f() {}\n-  //*************************** weak: code is inactive due to #[cfg] directives\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^^ weak: code is inactive due to #[cfg] directives\n }\n \"#,\n         );"}, {"sha": "73314e0f330bc67a30b291e55bdb588ff30bdde7", "filename": "src/tools/rust-analyzer/crates/ide-ssr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -20,6 +20,7 @@ parser = { path = \"../parser\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }\n ide-db = { path = \"../ide-db\", version = \"0.0.0\" }\n hir = { path = \"../hir\", version = \"0.0.0\" }\n+stdx = { path = \"../stdx\", version = \"0.0.0\" }\n \n [dev-dependencies]\n test-utils = { path = \"../test-utils\" }"}, {"sha": "d9834ee63adccf1368681f8397672e93ef0c3e66", "filename": "src/tools/rust-analyzer/crates/ide-ssr/src/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Flib.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -86,11 +86,9 @@ pub use crate::{errors::SsrError, from_comment::ssr_from_comment, matching::Matc\n \n use crate::{errors::bail, matching::MatchFailureReason};\n use hir::Semantics;\n-use ide_db::{\n-    base_db::{FileId, FilePosition, FileRange},\n-    FxHashMap,\n-};\n+use ide_db::base_db::{FileId, FilePosition, FileRange};\n use resolving::ResolvedRule;\n+use stdx::hash::NoHashHashMap;\n use syntax::{ast, AstNode, SyntaxNode, TextRange};\n use text_edit::TextEdit;\n \n@@ -170,9 +168,9 @@ impl<'db> MatchFinder<'db> {\n     }\n \n     /// Finds matches for all added rules and returns edits for all found matches.\n-    pub fn edits(&self) -> FxHashMap<FileId, TextEdit> {\n+    pub fn edits(&self) -> NoHashHashMap<FileId, TextEdit> {\n         use ide_db::base_db::SourceDatabaseExt;\n-        let mut matches_by_file = FxHashMap::default();\n+        let mut matches_by_file = NoHashHashMap::default();\n         for m in self.matches().matches {\n             matches_by_file\n                 .entry(m.range.file_id)"}, {"sha": "92ce26b422e1dab0f13af86930c8c62e674fd7fd", "filename": "src/tools/rust-analyzer/crates/ide/src/doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fdoc_links.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -184,10 +184,10 @@ pub(crate) fn resolve_doc_path_for_def(\n         Definition::TypeAlias(it) => it.resolve_doc_path(db, link, ns),\n         Definition::Macro(it) => it.resolve_doc_path(db, link, ns),\n         Definition::Field(it) => it.resolve_doc_path(db, link, ns),\n+        Definition::SelfType(it) => it.resolve_doc_path(db, link, ns),\n         Definition::BuiltinAttr(_)\n         | Definition::ToolModule(_)\n         | Definition::BuiltinType(_)\n-        | Definition::SelfType(_)\n         | Definition::Local(_)\n         | Definition::GenericParam(_)\n         | Definition::Label(_)"}, {"sha": "d61d69a090b33850049acfa36b8327ba7b887965", "filename": "src/tools/rust-analyzer/crates/ide/src/lib.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -87,7 +87,7 @@ pub use crate::{\n     },\n     join_lines::JoinLinesConfig,\n     markup::Markup,\n-    moniker::{MonikerKind, MonikerResult, PackageInformation},\n+    moniker::{MonikerDescriptorKind, MonikerKind, MonikerResult, PackageInformation},\n     move_item::Direction,\n     navigation_target::NavigationTarget,\n     prime_caches::ParallelPrimeCachesProgress,\n@@ -98,7 +98,7 @@ pub use crate::{\n     static_index::{StaticIndex, StaticIndexedFile, TokenId, TokenStaticData},\n     syntax_highlighting::{\n         tags::{Highlight, HlMod, HlMods, HlOperator, HlPunct, HlTag},\n-        HlRange,\n+        HighlightConfig, HlRange,\n     },\n };\n pub use hir::{Documentation, Semantics};\n@@ -517,8 +517,12 @@ impl Analysis {\n     }\n \n     /// Computes syntax highlighting for the given file\n-    pub fn highlight(&self, file_id: FileId) -> Cancellable<Vec<HlRange>> {\n-        self.with_db(|db| syntax_highlighting::highlight(db, file_id, None, false))\n+    pub fn highlight(\n+        &self,\n+        highlight_config: HighlightConfig,\n+        file_id: FileId,\n+    ) -> Cancellable<Vec<HlRange>> {\n+        self.with_db(|db| syntax_highlighting::highlight(db, highlight_config, file_id, None))\n     }\n \n     /// Computes all ranges to highlight for a given item in a file.\n@@ -533,9 +537,13 @@ impl Analysis {\n     }\n \n     /// Computes syntax highlighting for the given file range.\n-    pub fn highlight_range(&self, frange: FileRange) -> Cancellable<Vec<HlRange>> {\n+    pub fn highlight_range(\n+        &self,\n+        highlight_config: HighlightConfig,\n+        frange: FileRange,\n+    ) -> Cancellable<Vec<HlRange>> {\n         self.with_db(|db| {\n-            syntax_highlighting::highlight(db, frange.file_id, Some(frange.range), false)\n+            syntax_highlighting::highlight(db, highlight_config, frange.file_id, Some(frange.range))\n         })\n     }\n "}, {"sha": "600a526300c76a10594fe7f4b8b5c28ec4a072b8", "filename": "src/tools/rust-analyzer/crates/ide/src/moniker.rs", "status": "modified", "additions": 118, "deletions": 13, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -13,17 +13,39 @@ use syntax::{AstNode, SyntaxKind::*, T};\n \n use crate::{doc_links::token_as_doc_comment, RangeInfo};\n \n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum MonikerDescriptorKind {\n+    Namespace,\n+    Type,\n+    Term,\n+    Method,\n+    TypeParameter,\n+    Parameter,\n+    Macro,\n+    Meta,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct MonikerDescriptor {\n+    pub name: Name,\n+    pub desc: MonikerDescriptorKind,\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct MonikerIdentifier {\n-    crate_name: String,\n-    path: Vec<Name>,\n+    pub crate_name: String,\n+    pub description: Vec<MonikerDescriptor>,\n }\n \n impl ToString for MonikerIdentifier {\n     fn to_string(&self) -> String {\n         match self {\n-            MonikerIdentifier { path, crate_name } => {\n-                format!(\"{}::{}\", crate_name, path.iter().map(|x| x.to_string()).join(\"::\"))\n+            MonikerIdentifier { description, crate_name } => {\n+                format!(\n+                    \"{}::{}\",\n+                    crate_name,\n+                    description.iter().map(|x| x.name.to_string()).join(\"::\")\n+                )\n             }\n         }\n     }\n@@ -42,6 +64,12 @@ pub struct MonikerResult {\n     pub package_information: PackageInformation,\n }\n \n+impl MonikerResult {\n+    pub fn from_def(db: &RootDatabase, def: Definition, from_crate: Crate) -> Option<Self> {\n+        def_to_moniker(db, def, from_crate)\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PackageInformation {\n     pub name: String,\n@@ -105,13 +133,23 @@ pub(crate) fn def_to_moniker(\n     def: Definition,\n     from_crate: Crate,\n ) -> Option<MonikerResult> {\n-    if matches!(def, Definition::GenericParam(_) | Definition::SelfType(_) | Definition::Local(_)) {\n+    if matches!(\n+        def,\n+        Definition::GenericParam(_)\n+            | Definition::Label(_)\n+            | Definition::DeriveHelper(_)\n+            | Definition::BuiltinAttr(_)\n+            | Definition::ToolModule(_)\n+    ) {\n         return None;\n     }\n+\n     let module = def.module(db)?;\n     let krate = module.krate();\n-    let mut path = vec![];\n-    path.extend(module.path_to_root(db).into_iter().filter_map(|x| x.name(db)));\n+    let mut description = vec![];\n+    description.extend(module.path_to_root(db).into_iter().filter_map(|x| {\n+        Some(MonikerDescriptor { name: x.name(db)?, desc: MonikerDescriptorKind::Namespace })\n+    }));\n \n     // Handle associated items within a trait\n     if let Some(assoc) = def.as_assoc_item(db) {\n@@ -120,31 +158,98 @@ pub(crate) fn def_to_moniker(\n             AssocItemContainer::Trait(trait_) => {\n                 // Because different traits can have functions with the same name,\n                 // we have to include the trait name as part of the moniker for uniqueness.\n-                path.push(trait_.name(db));\n+                description.push(MonikerDescriptor {\n+                    name: trait_.name(db),\n+                    desc: MonikerDescriptorKind::Type,\n+                });\n             }\n             AssocItemContainer::Impl(impl_) => {\n                 // Because a struct can implement multiple traits, for implementations\n                 // we add both the struct name and the trait name to the path\n                 if let Some(adt) = impl_.self_ty(db).as_adt() {\n-                    path.push(adt.name(db));\n+                    description.push(MonikerDescriptor {\n+                        name: adt.name(db),\n+                        desc: MonikerDescriptorKind::Type,\n+                    });\n                 }\n \n                 if let Some(trait_) = impl_.trait_(db) {\n-                    path.push(trait_.name(db));\n+                    description.push(MonikerDescriptor {\n+                        name: trait_.name(db),\n+                        desc: MonikerDescriptorKind::Type,\n+                    });\n                 }\n             }\n         }\n     }\n \n     if let Definition::Field(it) = def {\n-        path.push(it.parent_def(db).name(db));\n+        description.push(MonikerDescriptor {\n+            name: it.parent_def(db).name(db),\n+            desc: MonikerDescriptorKind::Type,\n+        });\n     }\n \n-    path.push(def.name(db)?);\n+    let name_desc = match def {\n+        // These are handled by top-level guard (for performance).\n+        Definition::GenericParam(_)\n+        | Definition::Label(_)\n+        | Definition::DeriveHelper(_)\n+        | Definition::BuiltinAttr(_)\n+        | Definition::ToolModule(_) => return None,\n+\n+        Definition::Local(local) => {\n+            if !local.is_param(db) {\n+                return None;\n+            }\n+\n+            MonikerDescriptor { name: local.name(db), desc: MonikerDescriptorKind::Parameter }\n+        }\n+        Definition::Macro(m) => {\n+            MonikerDescriptor { name: m.name(db), desc: MonikerDescriptorKind::Macro }\n+        }\n+        Definition::Function(f) => {\n+            MonikerDescriptor { name: f.name(db), desc: MonikerDescriptorKind::Method }\n+        }\n+        Definition::Variant(v) => {\n+            MonikerDescriptor { name: v.name(db), desc: MonikerDescriptorKind::Type }\n+        }\n+        Definition::Const(c) => {\n+            MonikerDescriptor { name: c.name(db)?, desc: MonikerDescriptorKind::Term }\n+        }\n+        Definition::Trait(trait_) => {\n+            MonikerDescriptor { name: trait_.name(db), desc: MonikerDescriptorKind::Type }\n+        }\n+        Definition::TypeAlias(ta) => {\n+            MonikerDescriptor { name: ta.name(db), desc: MonikerDescriptorKind::TypeParameter }\n+        }\n+        Definition::Module(m) => {\n+            MonikerDescriptor { name: m.name(db)?, desc: MonikerDescriptorKind::Namespace }\n+        }\n+        Definition::BuiltinType(b) => {\n+            MonikerDescriptor { name: b.name(), desc: MonikerDescriptorKind::Type }\n+        }\n+        Definition::SelfType(imp) => MonikerDescriptor {\n+            name: imp.self_ty(db).as_adt()?.name(db),\n+            desc: MonikerDescriptorKind::Type,\n+        },\n+        Definition::Field(it) => {\n+            MonikerDescriptor { name: it.name(db), desc: MonikerDescriptorKind::Term }\n+        }\n+        Definition::Adt(adt) => {\n+            MonikerDescriptor { name: adt.name(db), desc: MonikerDescriptorKind::Type }\n+        }\n+        Definition::Static(s) => {\n+            MonikerDescriptor { name: s.name(db), desc: MonikerDescriptorKind::Meta }\n+        }\n+    };\n+\n+    description.push(name_desc);\n+\n     Some(MonikerResult {\n         identifier: MonikerIdentifier {\n             crate_name: krate.display_name(db)?.crate_name().to_string(),\n-            path,\n+            description,\n         },\n         kind: if krate == from_crate { MonikerKind::Export } else { MonikerKind::Import },\n         package_information: {"}, {"sha": "87b3ef380c5943e0986ea4521be48591c74c9317", "filename": "src/tools/rust-analyzer/crates/ide/src/prime_caches.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fprime_caches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fprime_caches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fprime_caches.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -12,8 +12,9 @@ use ide_db::{\n         salsa::{Database, ParallelDatabase, Snapshot},\n         Cancelled, CrateGraph, CrateId, SourceDatabase, SourceDatabaseExt,\n     },\n-    FxHashSet, FxIndexMap,\n+    FxIndexMap,\n };\n+use stdx::hash::NoHashHashSet;\n \n use crate::RootDatabase;\n \n@@ -141,7 +142,7 @@ pub(crate) fn parallel_prime_caches(\n     }\n }\n \n-fn compute_crates_to_prime(db: &RootDatabase, graph: &CrateGraph) -> FxHashSet<CrateId> {\n+fn compute_crates_to_prime(db: &RootDatabase, graph: &CrateGraph) -> NoHashHashSet<CrateId> {\n     // We're only interested in the workspace crates and the `ImportMap`s of their direct\n     // dependencies, though in practice the latter also compute the `DefMap`s.\n     // We don't prime transitive dependencies because they're generally not visible in"}, {"sha": "99614b645e48ff02160b38fcf377f12bf01b4705", "filename": "src/tools/rust-analyzer/crates/ide/src/references.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -14,8 +14,9 @@ use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameClass, NameRefClass},\n     search::{ReferenceCategory, SearchScope, UsageSearchResult},\n-    FxHashMap, RootDatabase,\n+    RootDatabase,\n };\n+use stdx::hash::NoHashHashMap;\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, HasName},\n@@ -29,7 +30,7 @@ use crate::{FilePosition, NavigationTarget, TryToNav};\n #[derive(Debug, Clone)]\n pub struct ReferenceSearchResult {\n     pub declaration: Option<Declaration>,\n-    pub references: FxHashMap<FileId, Vec<(TextRange, Option<ReferenceCategory>)>>,\n+    pub references: NoHashHashMap<FileId, Vec<(TextRange, Option<ReferenceCategory>)>>,\n }\n \n #[derive(Debug, Clone)]"}, {"sha": "50371d620eb2a41954412a3f1dd79bc33c18756e", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 56, "deletions": 18, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -14,7 +14,7 @@ mod html;\n mod tests;\n \n use hir::{Name, Semantics};\n-use ide_db::{FxHashMap, RootDatabase};\n+use ide_db::{FxHashMap, RootDatabase, SymbolKind};\n use syntax::{\n     ast, AstNode, AstToken, NodeOrToken, SyntaxKind::*, SyntaxNode, TextRange, WalkEvent, T,\n };\n@@ -24,7 +24,7 @@ use crate::{\n         escape::highlight_escape_string, format::highlight_format_string, highlights::Highlights,\n         macro_::MacroHighlighter, tags::Highlight,\n     },\n-    FileId, HlMod, HlTag,\n+    FileId, HlMod, HlOperator, HlPunct, HlTag,\n };\n \n pub(crate) use html::highlight_as_html;\n@@ -36,6 +36,26 @@ pub struct HlRange {\n     pub binding_hash: Option<u64>,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct HighlightConfig {\n+    /// Whether to highlight strings\n+    pub strings: bool,\n+    /// Whether to highlight punctuation\n+    pub punctuation: bool,\n+    /// Whether to specialize punctuation highlights\n+    pub specialize_punctuation: bool,\n+    /// Whether to highlight operator\n+    pub operator: bool,\n+    /// Whether to specialize operator highlights\n+    pub specialize_operator: bool,\n+    /// Whether to inject highlights into doc comments\n+    pub inject_doc_comment: bool,\n+    /// Whether to highlight the macro call bang\n+    pub macro_bang: bool,\n+    /// Whether to highlight unresolved things be their syntax\n+    pub syntactic_name_ref_highlighting: bool,\n+}\n+\n // Feature: Semantic Syntax Highlighting\n //\n // rust-analyzer highlights the code semantically.\n@@ -155,9 +175,9 @@ pub struct HlRange {\n // image::https://user-images.githubusercontent.com/48062697/113187625-f7f50100-9250-11eb-825e-91c58f236071.png[]\n pub(crate) fn highlight(\n     db: &RootDatabase,\n+    config: HighlightConfig,\n     file_id: FileId,\n     range_to_highlight: Option<TextRange>,\n-    syntactic_name_ref_highlighting: bool,\n ) -> Vec<HlRange> {\n     let _p = profile::span(\"highlight\");\n     let sema = Semantics::new(db);\n@@ -183,26 +203,18 @@ pub(crate) fn highlight(\n         Some(it) => it.krate(),\n         None => return hl.to_vec(),\n     };\n-    traverse(\n-        &mut hl,\n-        &sema,\n-        file_id,\n-        &root,\n-        krate,\n-        range_to_highlight,\n-        syntactic_name_ref_highlighting,\n-    );\n+    traverse(&mut hl, &sema, config, file_id, &root, krate, range_to_highlight);\n     hl.to_vec()\n }\n \n fn traverse(\n     hl: &mut Highlights,\n     sema: &Semantics<'_, RootDatabase>,\n+    config: HighlightConfig,\n     file_id: FileId,\n     root: &SyntaxNode,\n     krate: hir::Crate,\n     range_to_highlight: TextRange,\n-    syntactic_name_ref_highlighting: bool,\n ) {\n     let is_unlinked = sema.to_module_def(file_id).is_none();\n     let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n@@ -323,9 +335,11 @@ fn traverse(\n             Enter(it) => it,\n             Leave(NodeOrToken::Token(_)) => continue,\n             Leave(NodeOrToken::Node(node)) => {\n-                // Doc comment highlighting injection, we do this when leaving the node\n-                // so that we overwrite the highlighting of the doc comment itself.\n-                inject::doc_comment(hl, sema, file_id, &node);\n+                if config.inject_doc_comment {\n+                    // Doc comment highlighting injection, we do this when leaving the node\n+                    // so that we overwrite the highlighting of the doc comment itself.\n+                    inject::doc_comment(hl, sema, config, file_id, &node);\n+                }\n                 continue;\n             }\n         };\n@@ -400,7 +414,8 @@ fn traverse(\n                 let string_to_highlight = ast::String::cast(descended_token.clone());\n                 if let Some((string, expanded_string)) = string.zip(string_to_highlight) {\n                     if string.is_raw() {\n-                        if inject::ra_fixture(hl, sema, &string, &expanded_string).is_some() {\n+                        if inject::ra_fixture(hl, sema, config, &string, &expanded_string).is_some()\n+                        {\n                             continue;\n                         }\n                     }\n@@ -421,7 +436,7 @@ fn traverse(\n                 sema,\n                 krate,\n                 &mut bindings_shadow_count,\n-                syntactic_name_ref_highlighting,\n+                config.syntactic_name_ref_highlighting,\n                 name_like,\n             ),\n             NodeOrToken::Token(token) => highlight::token(sema, token).zip(Some(None)),\n@@ -439,6 +454,29 @@ fn traverse(\n                 // something unresolvable. FIXME: There should be a way to prevent that\n                 continue;\n             }\n+\n+            // apply config filtering\n+            match &mut highlight.tag {\n+                HlTag::StringLiteral if !config.strings => continue,\n+                // If punctuation is disabled, make the macro bang part of the macro call again.\n+                tag @ HlTag::Punctuation(HlPunct::MacroBang) => {\n+                    if !config.macro_bang {\n+                        *tag = HlTag::Symbol(SymbolKind::Macro);\n+                    } else if !config.specialize_punctuation {\n+                        *tag = HlTag::Punctuation(HlPunct::Other);\n+                    }\n+                }\n+                HlTag::Punctuation(_) if !config.punctuation => continue,\n+                tag @ HlTag::Punctuation(_) if !config.specialize_punctuation => {\n+                    *tag = HlTag::Punctuation(HlPunct::Other);\n+                }\n+                HlTag::Operator(_) if !config.operator && highlight.mods.is_empty() => continue,\n+                tag @ HlTag::Operator(_) if !config.specialize_operator => {\n+                    *tag = HlTag::Operator(HlOperator::Other);\n+                }\n+                _ => (),\n+            }\n+\n             if inside_attribute {\n                 highlight |= HlMod::Attribute\n             }"}, {"sha": "e91fd7f12571649cee96e51e652165cad39bc993", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/html.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -5,7 +5,10 @@ use oorandom::Rand32;\n use stdx::format_to;\n use syntax::AstNode;\n \n-use crate::{syntax_highlighting::highlight, FileId, RootDatabase};\n+use crate::{\n+    syntax_highlighting::{highlight, HighlightConfig},\n+    FileId, RootDatabase,\n+};\n \n pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: bool) -> String {\n     let parse = db.parse(file_id);\n@@ -20,7 +23,21 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n         )\n     }\n \n-    let hl_ranges = highlight(db, file_id, None, false);\n+    let hl_ranges = highlight(\n+        db,\n+        HighlightConfig {\n+            strings: true,\n+            punctuation: true,\n+            specialize_punctuation: true,\n+            specialize_operator: true,\n+            operator: true,\n+            inject_doc_comment: true,\n+            macro_bang: true,\n+            syntactic_name_ref_highlighting: false,\n+        },\n+        file_id,\n+        None,\n+    );\n     let text = parse.tree().syntax().to_string();\n     let mut buf = String::new();\n     buf.push_str(STYLE);"}, {"sha": "9139528c7ed96d08685e6bb646e50aa7482bf5e4", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -15,13 +15,14 @@ use syntax::{\n \n use crate::{\n     doc_links::{doc_attributes, extract_definitions_from_docs, resolve_doc_path_for_def},\n-    syntax_highlighting::{highlights::Highlights, injector::Injector},\n+    syntax_highlighting::{highlights::Highlights, injector::Injector, HighlightConfig},\n     Analysis, HlMod, HlRange, HlTag, RootDatabase,\n };\n \n pub(super) fn ra_fixture(\n     hl: &mut Highlights,\n     sema: &Semantics<'_, RootDatabase>,\n+    config: HighlightConfig,\n     literal: &ast::String,\n     expanded: &ast::String,\n ) -> Option<()> {\n@@ -63,7 +64,13 @@ pub(super) fn ra_fixture(\n \n     let (analysis, tmp_file_id) = Analysis::from_single_file(inj.take_text());\n \n-    for mut hl_range in analysis.highlight(tmp_file_id).unwrap() {\n+    for mut hl_range in analysis\n+        .highlight(\n+            HighlightConfig { syntactic_name_ref_highlighting: false, ..config },\n+            tmp_file_id,\n+        )\n+        .unwrap()\n+    {\n         for range in inj.map_range_up(hl_range.range) {\n             if let Some(range) = literal.map_range_up(range) {\n                 hl_range.range = range;\n@@ -86,6 +93,7 @@ const RUSTDOC_FENCES: [&str; 2] = [\"```\", \"~~~\"];\n pub(super) fn doc_comment(\n     hl: &mut Highlights,\n     sema: &Semantics<'_, RootDatabase>,\n+    config: HighlightConfig,\n     src_file_id: FileId,\n     node: &SyntaxNode,\n ) {\n@@ -206,7 +214,14 @@ pub(super) fn doc_comment(\n \n     let (analysis, tmp_file_id) = Analysis::from_single_file(inj.take_text());\n \n-    if let Ok(ranges) = analysis.with_db(|db| super::highlight(db, tmp_file_id, None, true)) {\n+    if let Ok(ranges) = analysis.with_db(|db| {\n+        super::highlight(\n+            db,\n+            HighlightConfig { syntactic_name_ref_highlighting: true, ..config },\n+            tmp_file_id,\n+            None,\n+        )\n+    }) {\n         for HlRange { range, highlight, binding_hash } in ranges {\n             for range in inj.map_range_up(range) {\n                 hl.add(HlRange { range, highlight: highlight | HlMod::Injected, binding_hash });"}, {"sha": "3949f1189bd5ed47d946d46dec67cc2102c7bd40", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/tags.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -199,7 +199,7 @@ impl fmt::Display for HlTag {\n }\n \n impl HlMod {\n-    const ALL: &'static [HlMod; HlMod::Unsafe as u8 as usize + 1] = &[\n+    const ALL: &'static [HlMod; 19] = &[\n         HlMod::Associated,\n         HlMod::Async,\n         HlMod::Attribute,\n@@ -296,7 +296,7 @@ impl Highlight {\n         Highlight { tag, mods: HlMods::default() }\n     }\n     pub fn is_empty(&self) -> bool {\n-        self.tag == HlTag::None && self.mods == HlMods::default()\n+        self.tag == HlTag::None && self.mods.is_empty()\n     }\n }\n \n@@ -330,6 +330,10 @@ impl ops::BitOr<HlMod> for Highlight {\n }\n \n impl HlMods {\n+    pub fn is_empty(&self) -> bool {\n+        self.0 == 0\n+    }\n+\n     pub fn contains(self, m: HlMod) -> bool {\n         self.0 & m.mask() == m.mask()\n     }"}, {"sha": "eef5baea9839239e3d1b0e8220f102d24cec7db0", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/test_data/highlight_doctest.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -56,7 +56,7 @@\n     <span class=\"field declaration\">bar</span><span class=\"colon\">:</span> <span class=\"builtin_type\">bool</span><span class=\"comma\">,</span>\n <span class=\"brace\">}</span>\n \n-<span class=\"comment documentation\">/// This is an impl with a code block.</span>\n+<span class=\"comment documentation\">/// This is an impl of </span><span class=\"struct documentation injected intra_doc_link\">[`Foo`]</span><span class=\"comment documentation\"> with a code block.</span>\n <span class=\"comment documentation\">///</span>\n <span class=\"comment documentation\">/// ```</span>\n <span class=\"comment documentation\">///</span><span class=\"comment documentation\"> </span><span class=\"keyword injected\">fn</span><span class=\"none injected\"> </span><span class=\"function declaration injected\">foo</span><span class=\"parenthesis injected\">(</span><span class=\"parenthesis injected\">)</span><span class=\"none injected\"> </span><span class=\"brace injected\">{</span>"}, {"sha": "46cc667fc454f4f08f842017232a1b28e506e2fd", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -4,7 +4,18 @@ use expect_test::{expect_file, ExpectFile};\n use ide_db::SymbolKind;\n use test_utils::{bench, bench_fixture, skip_slow_tests, AssertLinear};\n \n-use crate::{fixture, FileRange, HlTag, TextRange};\n+use crate::{fixture, FileRange, HighlightConfig, HlTag, TextRange};\n+\n+const HL_CONFIG: HighlightConfig = HighlightConfig {\n+    strings: true,\n+    punctuation: true,\n+    specialize_punctuation: true,\n+    specialize_operator: true,\n+    operator: true,\n+    inject_doc_comment: true,\n+    macro_bang: true,\n+    syntactic_name_ref_highlighting: false,\n+};\n \n #[test]\n fn attributes() {\n@@ -613,7 +624,7 @@ struct Foo {\n     bar: bool,\n }\n \n-/// This is an impl with a code block.\n+/// This is an impl of [`Foo`] with a code block.\n ///\n /// ```\n /// fn foo() {\n@@ -996,7 +1007,10 @@ struct Foo {\n \n     // The \"x\"\n     let highlights = &analysis\n-        .highlight_range(FileRange { file_id, range: TextRange::at(45.into(), 1.into()) })\n+        .highlight_range(\n+            HL_CONFIG,\n+            FileRange { file_id, range: TextRange::at(45.into(), 1.into()) },\n+        )\n         .unwrap();\n \n     assert_eq!(&highlights[0].highlight.to_string(), \"field.declaration.public\");\n@@ -1011,7 +1025,7 @@ macro_rules! test {}\n }\"#\n         .trim(),\n     );\n-    let _ = analysis.highlight(file_id).unwrap();\n+    let _ = analysis.highlight(HL_CONFIG, file_id).unwrap();\n }\n \n /// Highlights the code given by the `ra_fixture` argument, renders the\n@@ -1035,7 +1049,7 @@ fn benchmark_syntax_highlighting_long_struct() {\n     let hash = {\n         let _pt = bench(\"syntax highlighting long struct\");\n         analysis\n-            .highlight(file_id)\n+            .highlight(HL_CONFIG, file_id)\n             .unwrap()\n             .iter()\n             .filter(|it| it.highlight.tag == HlTag::Symbol(SymbolKind::Struct))\n@@ -1061,7 +1075,7 @@ fn syntax_highlighting_not_quadratic() {\n             let time = Instant::now();\n \n             let hash = analysis\n-                .highlight(file_id)\n+                .highlight(HL_CONFIG, file_id)\n                 .unwrap()\n                 .iter()\n                 .filter(|it| it.highlight.tag == HlTag::Symbol(SymbolKind::Struct))\n@@ -1086,7 +1100,7 @@ fn benchmark_syntax_highlighting_parser() {\n     let hash = {\n         let _pt = bench(\"syntax highlighting parser\");\n         analysis\n-            .highlight(file_id)\n+            .highlight(HL_CONFIG, file_id)\n             .unwrap()\n             .iter()\n             .filter(|it| it.highlight.tag == HlTag::Symbol(SymbolKind::Function))"}, {"sha": "17a1e385b77248b4ed974d271745a3ffeddf5919", "filename": "src/tools/rust-analyzer/crates/ide/src/view_crate_graph.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_crate_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_crate_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_crate_graph.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -3,8 +3,9 @@ use std::sync::Arc;\n use dot::{Id, LabelText};\n use ide_db::{\n     base_db::{CrateGraph, CrateId, Dependency, SourceDatabase, SourceDatabaseExt},\n-    FxHashSet, RootDatabase,\n+    RootDatabase,\n };\n+use stdx::hash::NoHashHashSet;\n \n // Feature: View Crate Graph\n //\n@@ -41,7 +42,7 @@ pub(crate) fn view_crate_graph(db: &RootDatabase, full: bool) -> Result<String,\n \n struct DotCrateGraph {\n     graph: Arc<CrateGraph>,\n-    crates_to_render: FxHashSet<CrateId>,\n+    crates_to_render: NoHashHashSet<CrateId>,\n }\n \n type Edge<'a> = (CrateId, &'a Dependency);"}, {"sha": "bc1224af9b212c639bcf80026661554887f19d07", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/patterns.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -13,6 +13,8 @@ pub(super) const PATTERN_FIRST: TokenSet =\n         T![.],\n     ]));\n \n+const PAT_TOP_FIRST: TokenSet = PATTERN_FIRST.union(TokenSet::new(&[T![|]]));\n+\n pub(crate) fn pattern(p: &mut Parser<'_>) {\n     pattern_r(p, PAT_RECOVERY_SET);\n }\n@@ -228,6 +230,7 @@ fn path_or_macro_pat(p: &mut Parser<'_>) -> CompletedMarker {\n //     let S(_) = ();\n //     let S(_,) = ();\n //     let S(_, .. , x) = ();\n+//     let S(| a) = ();\n // }\n fn tuple_pat_fields(p: &mut Parser<'_>) {\n     assert!(p.at(T!['(']));\n@@ -363,6 +366,7 @@ fn ref_pat(p: &mut Parser<'_>) -> CompletedMarker {\n //     let (a,) = ();\n //     let (..) = ();\n //     let () = ();\n+//     let (| a | a, | b) = ((),());\n // }\n fn tuple_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T!['(']));\n@@ -373,13 +377,13 @@ fn tuple_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     let mut has_rest = false;\n     while !p.at(EOF) && !p.at(T![')']) {\n         has_pat = true;\n-        if !p.at_ts(PATTERN_FIRST) {\n+        if !p.at_ts(PAT_TOP_FIRST) {\n             p.error(\"expected a pattern\");\n             break;\n         }\n         has_rest |= p.at(T![..]);\n \n-        pattern(p);\n+        pattern_top(p);\n         if !p.at(T![')']) {\n             has_comma = true;\n             p.expect(T![,]);\n@@ -393,6 +397,7 @@ fn tuple_pat(p: &mut Parser<'_>) -> CompletedMarker {\n // test slice_pat\n // fn main() {\n //     let [a, b, ..] = [];\n+//     let [| a, ..] = [];\n // }\n fn slice_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     assert!(p.at(T!['[']));\n@@ -405,12 +410,12 @@ fn slice_pat(p: &mut Parser<'_>) -> CompletedMarker {\n \n fn pat_list(p: &mut Parser<'_>, ket: SyntaxKind) {\n     while !p.at(EOF) && !p.at(ket) {\n-        if !p.at_ts(PATTERN_FIRST) {\n+        if !p.at_ts(PAT_TOP_FIRST) {\n             p.error(\"expected a pattern\");\n             break;\n         }\n \n-        pattern(p);\n+        pattern_top(p);\n         if !p.at(ket) {\n             p.expect(T![,]);\n         }"}, {"sha": "dff72ba886fe82db58644325c4f72f57e8f543a5", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0024_slice_pat.rast", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0024_slice_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0024_slice_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0024_slice_pat.rast?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -37,6 +37,29 @@ SOURCE_FILE\n             L_BRACK \"[\"\n             R_BRACK \"]\"\n           SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        LET_STMT\n+          LET_KW \"let\"\n+          WHITESPACE \" \"\n+          SLICE_PAT\n+            L_BRACK \"[\"\n+            PIPE \"|\"\n+            WHITESPACE \" \"\n+            IDENT_PAT\n+              NAME\n+                IDENT \"a\"\n+            COMMA \",\"\n+            WHITESPACE \" \"\n+            REST_PAT\n+              DOT2 \"..\"\n+            R_BRACK \"]\"\n+          WHITESPACE \" \"\n+          EQ \"=\"\n+          WHITESPACE \" \"\n+          ARRAY_EXPR\n+            L_BRACK \"[\"\n+            R_BRACK \"]\"\n+          SEMICOLON \";\"\n         WHITESPACE \"\\n\"\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\""}, {"sha": "855ba89b1e9d9ec911ba50b82cce76ac9f2a21c6", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0024_slice_pat.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0024_slice_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0024_slice_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0024_slice_pat.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -1,3 +1,4 @@\n fn main() {\n     let [a, b, ..] = [];\n+    let [| a, ..] = [];\n }"}, {"sha": "55baf2fdcb4f6a525a166c6c1f40fc049ee7d519", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0026_tuple_pat_fields.rast", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0026_tuple_pat_fields.rast", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0026_tuple_pat_fields.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0026_tuple_pat_fields.rast?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -100,6 +100,29 @@ SOURCE_FILE\n             L_PAREN \"(\"\n             R_PAREN \")\"\n           SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        LET_STMT\n+          LET_KW \"let\"\n+          WHITESPACE \" \"\n+          TUPLE_STRUCT_PAT\n+            PATH\n+              PATH_SEGMENT\n+                NAME_REF\n+                  IDENT \"S\"\n+            L_PAREN \"(\"\n+            PIPE \"|\"\n+            WHITESPACE \" \"\n+            IDENT_PAT\n+              NAME\n+                IDENT \"a\"\n+            R_PAREN \")\"\n+          WHITESPACE \" \"\n+          EQ \"=\"\n+          WHITESPACE \" \"\n+          TUPLE_EXPR\n+            L_PAREN \"(\"\n+            R_PAREN \")\"\n+          SEMICOLON \";\"\n         WHITESPACE \"\\n\"\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\""}, {"sha": "8ec6f4ca93e031ed6f3365e859f0b42ab959e328", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0026_tuple_pat_fields.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0026_tuple_pat_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0026_tuple_pat_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0026_tuple_pat_fields.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -3,4 +3,5 @@ fn foo() {\n     let S(_) = ();\n     let S(_,) = ();\n     let S(_, .. , x) = ();\n+    let S(| a) = ();\n }"}, {"sha": "1a01e0f69381feff531618d16b6f6cce6b85901a", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0111_tuple_pat.rast", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0111_tuple_pat.rast", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0111_tuple_pat.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0111_tuple_pat.rast?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -85,6 +85,46 @@ SOURCE_FILE\n             L_PAREN \"(\"\n             R_PAREN \")\"\n           SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        LET_STMT\n+          LET_KW \"let\"\n+          WHITESPACE \" \"\n+          TUPLE_PAT\n+            L_PAREN \"(\"\n+            PIPE \"|\"\n+            WHITESPACE \" \"\n+            OR_PAT\n+              IDENT_PAT\n+                NAME\n+                  IDENT \"a\"\n+              WHITESPACE \" \"\n+              PIPE \"|\"\n+              WHITESPACE \" \"\n+              IDENT_PAT\n+                NAME\n+                  IDENT \"a\"\n+            COMMA \",\"\n+            WHITESPACE \" \"\n+            PIPE \"|\"\n+            WHITESPACE \" \"\n+            IDENT_PAT\n+              NAME\n+                IDENT \"b\"\n+            R_PAREN \")\"\n+          WHITESPACE \" \"\n+          EQ \"=\"\n+          WHITESPACE \" \"\n+          TUPLE_EXPR\n+            L_PAREN \"(\"\n+            TUPLE_EXPR\n+              L_PAREN \"(\"\n+              R_PAREN \")\"\n+            COMMA \",\"\n+            TUPLE_EXPR\n+              L_PAREN \"(\"\n+              R_PAREN \")\"\n+            R_PAREN \")\"\n+          SEMICOLON \";\"\n         WHITESPACE \"\\n\"\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\""}, {"sha": "fbd7f48f66bd93da02e9d44cd51d47feae0e2015", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0111_tuple_pat.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0111_tuple_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0111_tuple_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0111_tuple_pat.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -3,4 +3,5 @@ fn main() {\n     let (a,) = ();\n     let (..) = ();\n     let () = ();\n+    let (| a | a, | b) = ((),());\n }"}, {"sha": "e39026ac70bfd52e4d78b7b6a08a85d6938306ac", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2FCargo.toml?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -24,7 +24,6 @@ tt = { path = \"../tt\", version = \"0.0.0\" }\n mbe = { path = \"../mbe\", version = \"0.0.0\" }\n paths = { path = \"../paths\", version = \"0.0.0\" }\n proc-macro-api = { path = \"../proc-macro-api\", version = \"0.0.0\" }\n-crossbeam = \"0.8.1\"\n \n [dev-dependencies]\n expect-test = \"1.4.0\""}, {"sha": "3679bfc43c980a85a40909698dbe9fc7f27f9715", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/lib.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Flib.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -26,6 +26,7 @@ use std::{\n     ffi::OsString,\n     fs,\n     path::{Path, PathBuf},\n+    thread,\n     time::SystemTime,\n };\n \n@@ -65,18 +66,16 @@ impl ProcMacroSrv {\n \n         let macro_body = task.macro_body.to_subtree();\n         let attributes = task.attributes.map(|it| it.to_subtree());\n-        // FIXME: replace this with std's scoped threads once they stabilize\n-        // (then remove dependency on crossbeam)\n-        let result = crossbeam::scope(|s| {\n-            let res = match s\n-                .builder()\n+        let result = thread::scope(|s| {\n+            let thread = thread::Builder::new()\n                 .stack_size(EXPANDER_STACK_SIZE)\n                 .name(task.macro_name.clone())\n-                .spawn(|_| {\n+                .spawn_scoped(s, || {\n                     expander\n                         .expand(&task.macro_name, &macro_body, attributes.as_ref())\n                         .map(|it| FlatTree::new(&it))\n-                }) {\n+                });\n+            let res = match thread {\n                 Ok(handle) => handle.join(),\n                 Err(e) => std::panic::resume_unwind(Box::new(e)),\n             };\n@@ -86,10 +85,6 @@ impl ProcMacroSrv {\n                 Err(e) => std::panic::resume_unwind(e),\n             }\n         });\n-        let result = match result {\n-            Ok(result) => result,\n-            Err(e) => std::panic::resume_unwind(e),\n-        };\n \n         prev_env.rollback();\n "}, {"sha": "9ccb6e9101ef440c4604350b1901060375df66ae", "filename": "src/tools/rust-analyzer/crates/project-model/src/tests.rs", "status": "modified", "additions": 357, "deletions": 357, "changes": 714, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -185,10 +185,10 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        2,\n+                        1,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            3,\n+                            2,\n                         ),\n                         edition: Edition2018,\n                         version: Some(\n@@ -197,9 +197,9 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"an_example\",\n+                                    \"hello_world\",\n                                 ),\n-                                canonical_name: \"an-example\",\n+                                canonical_name: \"hello-world\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -260,77 +260,85 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        4,\n+                        2,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            5,\n+                            3,\n                         ),\n-                        edition: Edition2015,\n+                        edition: Edition2018,\n                         version: Some(\n-                            \"0.2.98\",\n+                            \"0.1.0\",\n                         ),\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"libc\",\n+                                    \"an_example\",\n                                 ),\n-                                canonical_name: \"libc\",\n+                                canonical_name: \"an-example\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n-                                \"feature=default\",\n-                                \"feature=std\",\n                             ],\n                         ),\n                         potential_cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n-                                \"feature=align\",\n-                                \"feature=const-extern-fn\",\n-                                \"feature=default\",\n-                                \"feature=extra_traits\",\n-                                \"feature=rustc-dep-of-std\",\n-                                \"feature=std\",\n-                                \"feature=use_std\",\n                             ],\n                         ),\n                         env: Env {\n                             entries: {\n                                 \"CARGO_PKG_LICENSE\": \"\",\n                                 \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n-                                \"CARGO_MANIFEST_DIR\": \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n-                                \"CARGO_PKG_VERSION\": \"0.2.98\",\n+                                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n+                                \"CARGO_PKG_VERSION\": \"0.1.0\",\n                                 \"CARGO_PKG_AUTHORS\": \"\",\n-                                \"CARGO_CRATE_NAME\": \"libc\",\n+                                \"CARGO_CRATE_NAME\": \"hello_world\",\n                                 \"CARGO_PKG_LICENSE_FILE\": \"\",\n                                 \"CARGO_PKG_HOMEPAGE\": \"\",\n                                 \"CARGO_PKG_DESCRIPTION\": \"\",\n-                                \"CARGO_PKG_NAME\": \"libc\",\n-                                \"CARGO_PKG_VERSION_PATCH\": \"98\",\n+                                \"CARGO_PKG_NAME\": \"hello-world\",\n+                                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n                                 \"CARGO\": \"cargo\",\n                                 \"CARGO_PKG_REPOSITORY\": \"\",\n-                                \"CARGO_PKG_VERSION_MINOR\": \"2\",\n+                                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n                                 \"CARGO_PKG_VERSION_PRE\": \"\",\n                             },\n                         },\n-                        dependencies: [],\n+                        dependencies: [\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    0,\n+                                ),\n+                                name: CrateName(\n+                                    \"hello_world\",\n+                                ),\n+                                prelude: true,\n+                            },\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    4,\n+                                ),\n+                                name: CrateName(\n+                                    \"libc\",\n+                                ),\n+                                prelude: true,\n+                            },\n+                        ],\n                         proc_macro: Err(\n                             \"crate has not (yet) been built\",\n                         ),\n                         origin: CratesIo {\n-                            repo: Some(\n-                                \"https://github.com/rust-lang/libc\",\n-                            ),\n+                            repo: None,\n                         },\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        1,\n+                        3,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            2,\n+                            4,\n                         ),\n                         edition: Edition2018,\n                         version: Some(\n@@ -339,9 +347,9 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"hello_world\",\n+                                    \"it\",\n                                 ),\n-                                canonical_name: \"hello-world\",\n+                                canonical_name: \"it\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -402,77 +410,69 @@ fn cargo_hello_world_project_model_with_wildcard_overrides() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        3,\n+                        4,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            4,\n+                            5,\n                         ),\n-                        edition: Edition2018,\n+                        edition: Edition2015,\n                         version: Some(\n-                            \"0.1.0\",\n+                            \"0.2.98\",\n                         ),\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"it\",\n+                                    \"libc\",\n                                 ),\n-                                canonical_name: \"it\",\n+                                canonical_name: \"libc\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n+                                \"feature=default\",\n+                                \"feature=std\",\n                             ],\n                         ),\n                         potential_cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n+                                \"feature=align\",\n+                                \"feature=const-extern-fn\",\n+                                \"feature=default\",\n+                                \"feature=extra_traits\",\n+                                \"feature=rustc-dep-of-std\",\n+                                \"feature=std\",\n+                                \"feature=use_std\",\n                             ],\n                         ),\n                         env: Env {\n                             entries: {\n                                 \"CARGO_PKG_LICENSE\": \"\",\n                                 \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n-                                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n-                                \"CARGO_PKG_VERSION\": \"0.1.0\",\n+                                \"CARGO_MANIFEST_DIR\": \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n+                                \"CARGO_PKG_VERSION\": \"0.2.98\",\n                                 \"CARGO_PKG_AUTHORS\": \"\",\n-                                \"CARGO_CRATE_NAME\": \"hello_world\",\n+                                \"CARGO_CRATE_NAME\": \"libc\",\n                                 \"CARGO_PKG_LICENSE_FILE\": \"\",\n                                 \"CARGO_PKG_HOMEPAGE\": \"\",\n                                 \"CARGO_PKG_DESCRIPTION\": \"\",\n-                                \"CARGO_PKG_NAME\": \"hello-world\",\n-                                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n+                                \"CARGO_PKG_NAME\": \"libc\",\n+                                \"CARGO_PKG_VERSION_PATCH\": \"98\",\n                                 \"CARGO\": \"cargo\",\n                                 \"CARGO_PKG_REPOSITORY\": \"\",\n-                                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n+                                \"CARGO_PKG_VERSION_MINOR\": \"2\",\n                                 \"CARGO_PKG_VERSION_PRE\": \"\",\n                             },\n                         },\n-                        dependencies: [\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    0,\n-                                ),\n-                                name: CrateName(\n-                                    \"hello_world\",\n-                                ),\n-                                prelude: true,\n-                            },\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    4,\n-                                ),\n-                                name: CrateName(\n-                                    \"libc\",\n-                                ),\n-                                prelude: true,\n-                            },\n-                        ],\n+                        dependencies: [],\n                         proc_macro: Err(\n                             \"crate has not (yet) been built\",\n                         ),\n                         origin: CratesIo {\n-                            repo: None,\n+                            repo: Some(\n+                                \"https://github.com/rust-lang/libc\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n@@ -567,10 +567,10 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        2,\n+                        1,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            3,\n+                            2,\n                         ),\n                         edition: Edition2018,\n                         version: Some(\n@@ -579,9 +579,9 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"an_example\",\n+                                    \"hello_world\",\n                                 ),\n-                                canonical_name: \"an-example\",\n+                                canonical_name: \"hello-world\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -644,77 +644,10 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        4,\n-                    ): CrateData {\n-                        root_file_id: FileId(\n-                            5,\n-                        ),\n-                        edition: Edition2015,\n-                        version: Some(\n-                            \"0.2.98\",\n-                        ),\n-                        display_name: Some(\n-                            CrateDisplayName {\n-                                crate_name: CrateName(\n-                                    \"libc\",\n-                                ),\n-                                canonical_name: \"libc\",\n-                            },\n-                        ),\n-                        cfg_options: CfgOptions(\n-                            [\n-                                \"debug_assertions\",\n-                                \"feature=default\",\n-                                \"feature=std\",\n-                            ],\n-                        ),\n-                        potential_cfg_options: CfgOptions(\n-                            [\n-                                \"debug_assertions\",\n-                                \"feature=align\",\n-                                \"feature=const-extern-fn\",\n-                                \"feature=default\",\n-                                \"feature=extra_traits\",\n-                                \"feature=rustc-dep-of-std\",\n-                                \"feature=std\",\n-                                \"feature=use_std\",\n-                            ],\n-                        ),\n-                        env: Env {\n-                            entries: {\n-                                \"CARGO_PKG_LICENSE\": \"\",\n-                                \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n-                                \"CARGO_MANIFEST_DIR\": \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n-                                \"CARGO_PKG_VERSION\": \"0.2.98\",\n-                                \"CARGO_PKG_AUTHORS\": \"\",\n-                                \"CARGO_CRATE_NAME\": \"libc\",\n-                                \"CARGO_PKG_LICENSE_FILE\": \"\",\n-                                \"CARGO_PKG_HOMEPAGE\": \"\",\n-                                \"CARGO_PKG_DESCRIPTION\": \"\",\n-                                \"CARGO_PKG_NAME\": \"libc\",\n-                                \"CARGO_PKG_VERSION_PATCH\": \"98\",\n-                                \"CARGO\": \"cargo\",\n-                                \"CARGO_PKG_REPOSITORY\": \"\",\n-                                \"CARGO_PKG_VERSION_MINOR\": \"2\",\n-                                \"CARGO_PKG_VERSION_PRE\": \"\",\n-                            },\n-                        },\n-                        dependencies: [],\n-                        proc_macro: Err(\n-                            \"crate has not (yet) been built\",\n-                        ),\n-                        origin: CratesIo {\n-                            repo: Some(\n-                                \"https://github.com/rust-lang/libc\",\n-                            ),\n-                        },\n-                        is_proc_macro: false,\n-                    },\n-                    CrateId(\n-                        1,\n+                        2,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            2,\n+                            3,\n                         ),\n                         edition: Edition2018,\n                         version: Some(\n@@ -723,9 +656,9 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"hello_world\",\n+                                    \"an_example\",\n                                 ),\n-                                canonical_name: \"hello-world\",\n+                                canonical_name: \"an-example\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -864,92 +797,91 @@ fn cargo_hello_world_project_model_with_selective_overrides() {\n                         },\n                         is_proc_macro: false,\n                     },\n-                },\n-            }\"#]],\n-    )\n-}\n-\n-#[test]\n-fn cargo_hello_world_project_model() {\n-    let crate_graph = load_cargo(\"hello-world-metadata.json\");\n-    check_crate_graph(\n-        crate_graph,\n-        expect![[r#\"\n-            CrateGraph {\n-                arena: {\n                     CrateId(\n-                        0,\n+                        4,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            1,\n+                            5,\n                         ),\n-                        edition: Edition2018,\n+                        edition: Edition2015,\n                         version: Some(\n-                            \"0.1.0\",\n+                            \"0.2.98\",\n                         ),\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"hello_world\",\n+                                    \"libc\",\n                                 ),\n-                                canonical_name: \"hello-world\",\n+                                canonical_name: \"libc\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n-                                \"test\",\n+                                \"feature=default\",\n+                                \"feature=std\",\n                             ],\n                         ),\n                         potential_cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n-                                \"test\",\n+                                \"feature=align\",\n+                                \"feature=const-extern-fn\",\n+                                \"feature=default\",\n+                                \"feature=extra_traits\",\n+                                \"feature=rustc-dep-of-std\",\n+                                \"feature=std\",\n+                                \"feature=use_std\",\n                             ],\n                         ),\n                         env: Env {\n                             entries: {\n                                 \"CARGO_PKG_LICENSE\": \"\",\n                                 \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n-                                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n-                                \"CARGO_PKG_VERSION\": \"0.1.0\",\n+                                \"CARGO_MANIFEST_DIR\": \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n+                                \"CARGO_PKG_VERSION\": \"0.2.98\",\n                                 \"CARGO_PKG_AUTHORS\": \"\",\n-                                \"CARGO_CRATE_NAME\": \"hello_world\",\n+                                \"CARGO_CRATE_NAME\": \"libc\",\n                                 \"CARGO_PKG_LICENSE_FILE\": \"\",\n                                 \"CARGO_PKG_HOMEPAGE\": \"\",\n                                 \"CARGO_PKG_DESCRIPTION\": \"\",\n-                                \"CARGO_PKG_NAME\": \"hello-world\",\n-                                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n+                                \"CARGO_PKG_NAME\": \"libc\",\n+                                \"CARGO_PKG_VERSION_PATCH\": \"98\",\n                                 \"CARGO\": \"cargo\",\n                                 \"CARGO_PKG_REPOSITORY\": \"\",\n-                                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n+                                \"CARGO_PKG_VERSION_MINOR\": \"2\",\n                                 \"CARGO_PKG_VERSION_PRE\": \"\",\n                             },\n                         },\n-                        dependencies: [\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    4,\n-                                ),\n-                                name: CrateName(\n-                                    \"libc\",\n-                                ),\n-                                prelude: true,\n-                            },\n-                        ],\n+                        dependencies: [],\n                         proc_macro: Err(\n                             \"crate has not (yet) been built\",\n                         ),\n                         origin: CratesIo {\n-                            repo: None,\n+                            repo: Some(\n+                                \"https://github.com/rust-lang/libc\",\n+                            ),\n                         },\n                         is_proc_macro: false,\n                     },\n+                },\n+            }\"#]],\n+    )\n+}\n+\n+#[test]\n+fn cargo_hello_world_project_model() {\n+    let crate_graph = load_cargo(\"hello-world-metadata.json\");\n+    check_crate_graph(\n+        crate_graph,\n+        expect![[r#\"\n+            CrateGraph {\n+                arena: {\n                     CrateId(\n-                        2,\n+                        0,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            3,\n+                            1,\n                         ),\n                         edition: Edition2018,\n                         version: Some(\n@@ -958,9 +890,9 @@ fn cargo_hello_world_project_model() {\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"an_example\",\n+                                    \"hello_world\",\n                                 ),\n-                                canonical_name: \"an-example\",\n+                                canonical_name: \"hello-world\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -995,15 +927,6 @@ fn cargo_hello_world_project_model() {\n                             },\n                         },\n                         dependencies: [\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    0,\n-                                ),\n-                                name: CrateName(\n-                                    \"hello_world\",\n-                                ),\n-                                prelude: true,\n-                            },\n                             Dependency {\n                                 crate_id: CrateId(\n                                     4,\n@@ -1023,77 +946,87 @@ fn cargo_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        4,\n+                        1,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            5,\n+                            2,\n                         ),\n-                        edition: Edition2015,\n+                        edition: Edition2018,\n                         version: Some(\n-                            \"0.2.98\",\n+                            \"0.1.0\",\n                         ),\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"libc\",\n+                                    \"hello_world\",\n                                 ),\n-                                canonical_name: \"libc\",\n+                                canonical_name: \"hello-world\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n-                                \"feature=default\",\n-                                \"feature=std\",\n+                                \"test\",\n                             ],\n                         ),\n                         potential_cfg_options: CfgOptions(\n                             [\n                                 \"debug_assertions\",\n-                                \"feature=align\",\n-                                \"feature=const-extern-fn\",\n-                                \"feature=default\",\n-                                \"feature=extra_traits\",\n-                                \"feature=rustc-dep-of-std\",\n-                                \"feature=std\",\n-                                \"feature=use_std\",\n+                                \"test\",\n                             ],\n                         ),\n                         env: Env {\n                             entries: {\n                                 \"CARGO_PKG_LICENSE\": \"\",\n                                 \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n-                                \"CARGO_MANIFEST_DIR\": \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n-                                \"CARGO_PKG_VERSION\": \"0.2.98\",\n+                                \"CARGO_MANIFEST_DIR\": \"$ROOT$hello-world\",\n+                                \"CARGO_PKG_VERSION\": \"0.1.0\",\n                                 \"CARGO_PKG_AUTHORS\": \"\",\n-                                \"CARGO_CRATE_NAME\": \"libc\",\n+                                \"CARGO_CRATE_NAME\": \"hello_world\",\n                                 \"CARGO_PKG_LICENSE_FILE\": \"\",\n                                 \"CARGO_PKG_HOMEPAGE\": \"\",\n                                 \"CARGO_PKG_DESCRIPTION\": \"\",\n-                                \"CARGO_PKG_NAME\": \"libc\",\n-                                \"CARGO_PKG_VERSION_PATCH\": \"98\",\n+                                \"CARGO_PKG_NAME\": \"hello-world\",\n+                                \"CARGO_PKG_VERSION_PATCH\": \"0\",\n                                 \"CARGO\": \"cargo\",\n                                 \"CARGO_PKG_REPOSITORY\": \"\",\n-                                \"CARGO_PKG_VERSION_MINOR\": \"2\",\n+                                \"CARGO_PKG_VERSION_MINOR\": \"1\",\n                                 \"CARGO_PKG_VERSION_PRE\": \"\",\n                             },\n                         },\n-                        dependencies: [],\n+                        dependencies: [\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    0,\n+                                ),\n+                                name: CrateName(\n+                                    \"hello_world\",\n+                                ),\n+                                prelude: true,\n+                            },\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    4,\n+                                ),\n+                                name: CrateName(\n+                                    \"libc\",\n+                                ),\n+                                prelude: true,\n+                            },\n+                        ],\n                         proc_macro: Err(\n                             \"crate has not (yet) been built\",\n                         ),\n                         origin: CratesIo {\n-                            repo: Some(\n-                                \"https://github.com/rust-lang/libc\",\n-                            ),\n+                            repo: None,\n                         },\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        1,\n+                        2,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            2,\n+                            3,\n                         ),\n                         edition: Edition2018,\n                         version: Some(\n@@ -1102,9 +1035,9 @@ fn cargo_hello_world_project_model() {\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"hello_world\",\n+                                    \"an_example\",\n                                 ),\n-                                canonical_name: \"hello-world\",\n+                                canonical_name: \"an-example\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1243,6 +1176,73 @@ fn cargo_hello_world_project_model() {\n                         },\n                         is_proc_macro: false,\n                     },\n+                    CrateId(\n+                        4,\n+                    ): CrateData {\n+                        root_file_id: FileId(\n+                            5,\n+                        ),\n+                        edition: Edition2015,\n+                        version: Some(\n+                            \"0.2.98\",\n+                        ),\n+                        display_name: Some(\n+                            CrateDisplayName {\n+                                crate_name: CrateName(\n+                                    \"libc\",\n+                                ),\n+                                canonical_name: \"libc\",\n+                            },\n+                        ),\n+                        cfg_options: CfgOptions(\n+                            [\n+                                \"debug_assertions\",\n+                                \"feature=default\",\n+                                \"feature=std\",\n+                            ],\n+                        ),\n+                        potential_cfg_options: CfgOptions(\n+                            [\n+                                \"debug_assertions\",\n+                                \"feature=align\",\n+                                \"feature=const-extern-fn\",\n+                                \"feature=default\",\n+                                \"feature=extra_traits\",\n+                                \"feature=rustc-dep-of-std\",\n+                                \"feature=std\",\n+                                \"feature=use_std\",\n+                            ],\n+                        ),\n+                        env: Env {\n+                            entries: {\n+                                \"CARGO_PKG_LICENSE\": \"\",\n+                                \"CARGO_PKG_VERSION_MAJOR\": \"0\",\n+                                \"CARGO_MANIFEST_DIR\": \"$ROOT$.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.98\",\n+                                \"CARGO_PKG_VERSION\": \"0.2.98\",\n+                                \"CARGO_PKG_AUTHORS\": \"\",\n+                                \"CARGO_CRATE_NAME\": \"libc\",\n+                                \"CARGO_PKG_LICENSE_FILE\": \"\",\n+                                \"CARGO_PKG_HOMEPAGE\": \"\",\n+                                \"CARGO_PKG_DESCRIPTION\": \"\",\n+                                \"CARGO_PKG_NAME\": \"libc\",\n+                                \"CARGO_PKG_VERSION_PATCH\": \"98\",\n+                                \"CARGO\": \"cargo\",\n+                                \"CARGO_PKG_REPOSITORY\": \"\",\n+                                \"CARGO_PKG_VERSION_MINOR\": \"2\",\n+                                \"CARGO_PKG_VERSION_PRE\": \"\",\n+                            },\n+                        },\n+                        dependencies: [],\n+                        proc_macro: Err(\n+                            \"crate has not (yet) been built\",\n+                        ),\n+                        origin: CratesIo {\n+                            repo: Some(\n+                                \"https://github.com/rust-lang/libc\",\n+                            ),\n+                        },\n+                        is_proc_macro: false,\n+                    },\n                 },\n             }\"#]],\n     )\n@@ -1301,19 +1301,53 @@ fn rust_project_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        10,\n+                        1,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            11,\n+                            2,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"unwind\",\n+                                    \"core\",\n                                 ),\n-                                canonical_name: \"unwind\",\n+                                canonical_name: \"core\",\n+                            },\n+                        ),\n+                        cfg_options: CfgOptions(\n+                            [],\n+                        ),\n+                        potential_cfg_options: CfgOptions(\n+                            [],\n+                        ),\n+                        env: Env {\n+                            entries: {},\n+                        },\n+                        dependencies: [],\n+                        proc_macro: Err(\n+                            \"no proc macro loaded for sysroot crate\",\n+                        ),\n+                        origin: Lang(\n+                            Core,\n+                        ),\n+                        is_proc_macro: false,\n+                    },\n+                    CrateId(\n+                        2,\n+                    ): CrateData {\n+                        root_file_id: FileId(\n+                            3,\n+                        ),\n+                        edition: Edition2018,\n+                        version: None,\n+                        display_name: Some(\n+                            CrateDisplayName {\n+                                crate_name: CrateName(\n+                                    \"panic_abort\",\n+                                ),\n+                                canonical_name: \"panic_abort\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1335,19 +1369,19 @@ fn rust_project_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        7,\n+                        3,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            8,\n+                            4,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"std_detect\",\n+                                    \"panic_unwind\",\n                                 ),\n-                                canonical_name: \"std_detect\",\n+                                canonical_name: \"panic_unwind\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1413,19 +1447,19 @@ fn rust_project_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        1,\n+                        5,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            2,\n+                            6,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"core\",\n+                                    \"profiler_builtins\",\n                                 ),\n-                                canonical_name: \"core\",\n+                                canonical_name: \"profiler_builtins\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1442,24 +1476,24 @@ fn rust_project_hello_world_project_model() {\n                             \"no proc macro loaded for sysroot crate\",\n                         ),\n                         origin: Lang(\n-                            Core,\n+                            Other,\n                         ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        11,\n+                        6,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            12,\n+                            7,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"hello_world\",\n+                                    \"std\",\n                                 ),\n-                                canonical_name: \"hello_world\",\n+                                canonical_name: \"std\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1472,6 +1506,15 @@ fn rust_project_hello_world_project_model() {\n                             entries: {},\n                         },\n                         dependencies: [\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    0,\n+                                ),\n+                                name: CrateName(\n+                                    \"alloc\",\n+                                ),\n+                                prelude: true,\n+                            },\n                             Dependency {\n                                 crate_id: CrateId(\n                                     1,\n@@ -1483,19 +1526,46 @@ fn rust_project_hello_world_project_model() {\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    0,\n+                                    2,\n                                 ),\n                                 name: CrateName(\n-                                    \"alloc\",\n+                                    \"panic_abort\",\n                                 ),\n                                 prelude: true,\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    6,\n+                                    3,\n                                 ),\n                                 name: CrateName(\n-                                    \"std\",\n+                                    \"panic_unwind\",\n+                                ),\n+                                prelude: true,\n+                            },\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    5,\n+                                ),\n+                                name: CrateName(\n+                                    \"profiler_builtins\",\n+                                ),\n+                                prelude: true,\n+                            },\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    7,\n+                                ),\n+                                name: CrateName(\n+                                    \"std_detect\",\n+                                ),\n+                                prelude: true,\n+                            },\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    8,\n+                                ),\n+                                name: CrateName(\n+                                    \"term\",\n                                 ),\n                                 prelude: true,\n                             },\n@@ -1506,31 +1576,40 @@ fn rust_project_hello_world_project_model() {\n                                 name: CrateName(\n                                     \"test\",\n                                 ),\n-                                prelude: false,\n+                                prelude: true,\n+                            },\n+                            Dependency {\n+                                crate_id: CrateId(\n+                                    10,\n+                                ),\n+                                name: CrateName(\n+                                    \"unwind\",\n+                                ),\n+                                prelude: true,\n                             },\n                         ],\n                         proc_macro: Err(\n-                            \"no proc macro dylib present\",\n+                            \"no proc macro loaded for sysroot crate\",\n+                        ),\n+                        origin: Lang(\n+                            Std,\n                         ),\n-                        origin: CratesIo {\n-                            repo: None,\n-                        },\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        8,\n+                        7,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            9,\n+                            8,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"term\",\n+                                    \"std_detect\",\n                                 ),\n-                                canonical_name: \"term\",\n+                                canonical_name: \"std_detect\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1552,19 +1631,19 @@ fn rust_project_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        5,\n+                        8,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            6,\n+                            9,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"profiler_builtins\",\n+                                    \"term\",\n                                 ),\n-                                canonical_name: \"profiler_builtins\",\n+                                canonical_name: \"term\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1586,19 +1665,19 @@ fn rust_project_hello_world_project_model() {\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        2,\n+                        9,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            3,\n+                            10,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"panic_abort\",\n+                                    \"test\",\n                                 ),\n-                                canonical_name: \"panic_abort\",\n+                                canonical_name: \"test\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1615,24 +1694,24 @@ fn rust_project_hello_world_project_model() {\n                             \"no proc macro loaded for sysroot crate\",\n                         ),\n                         origin: Lang(\n-                            Other,\n+                            Test,\n                         ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        9,\n+                        10,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            10,\n+                            11,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"test\",\n+                                    \"unwind\",\n                                 ),\n-                                canonical_name: \"test\",\n+                                canonical_name: \"unwind\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1649,24 +1728,24 @@ fn rust_project_hello_world_project_model() {\n                             \"no proc macro loaded for sysroot crate\",\n                         ),\n                         origin: Lang(\n-                            Test,\n+                            Other,\n                         ),\n                         is_proc_macro: false,\n                     },\n                     CrateId(\n-                        6,\n+                        11,\n                     ): CrateData {\n                         root_file_id: FileId(\n-                            7,\n+                            12,\n                         ),\n                         edition: Edition2018,\n                         version: None,\n                         display_name: Some(\n                             CrateDisplayName {\n                                 crate_name: CrateName(\n-                                    \"std\",\n+                                    \"hello_world\",\n                                 ),\n-                                canonical_name: \"std\",\n+                                canonical_name: \"hello_world\",\n                             },\n                         ),\n                         cfg_options: CfgOptions(\n@@ -1679,15 +1758,6 @@ fn rust_project_hello_world_project_model() {\n                             entries: {},\n                         },\n                         dependencies: [\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    0,\n-                                ),\n-                                name: CrateName(\n-                                    \"alloc\",\n-                                ),\n-                                prelude: true,\n-                            },\n                             Dependency {\n                                 crate_id: CrateId(\n                                     1,\n@@ -1699,46 +1769,19 @@ fn rust_project_hello_world_project_model() {\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    2,\n-                                ),\n-                                name: CrateName(\n-                                    \"panic_abort\",\n-                                ),\n-                                prelude: true,\n-                            },\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    3,\n-                                ),\n-                                name: CrateName(\n-                                    \"panic_unwind\",\n-                                ),\n-                                prelude: true,\n-                            },\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    5,\n-                                ),\n-                                name: CrateName(\n-                                    \"profiler_builtins\",\n-                                ),\n-                                prelude: true,\n-                            },\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    7,\n+                                    0,\n                                 ),\n                                 name: CrateName(\n-                                    \"std_detect\",\n+                                    \"alloc\",\n                                 ),\n                                 prelude: true,\n                             },\n                             Dependency {\n                                 crate_id: CrateId(\n-                                    8,\n+                                    6,\n                                 ),\n                                 name: CrateName(\n-                                    \"term\",\n+                                    \"std\",\n                                 ),\n                                 prelude: true,\n                             },\n@@ -1749,58 +1792,15 @@ fn rust_project_hello_world_project_model() {\n                                 name: CrateName(\n                                     \"test\",\n                                 ),\n-                                prelude: true,\n-                            },\n-                            Dependency {\n-                                crate_id: CrateId(\n-                                    10,\n-                                ),\n-                                name: CrateName(\n-                                    \"unwind\",\n-                                ),\n-                                prelude: true,\n+                                prelude: false,\n                             },\n                         ],\n                         proc_macro: Err(\n-                            \"no proc macro loaded for sysroot crate\",\n-                        ),\n-                        origin: Lang(\n-                            Std,\n-                        ),\n-                        is_proc_macro: false,\n-                    },\n-                    CrateId(\n-                        3,\n-                    ): CrateData {\n-                        root_file_id: FileId(\n-                            4,\n-                        ),\n-                        edition: Edition2018,\n-                        version: None,\n-                        display_name: Some(\n-                            CrateDisplayName {\n-                                crate_name: CrateName(\n-                                    \"panic_unwind\",\n-                                ),\n-                                canonical_name: \"panic_unwind\",\n-                            },\n-                        ),\n-                        cfg_options: CfgOptions(\n-                            [],\n-                        ),\n-                        potential_cfg_options: CfgOptions(\n-                            [],\n+                            \"no proc macro dylib present\",\n                         ),\n-                        env: Env {\n-                            entries: {},\n+                        origin: CratesIo {\n+                            repo: None,\n                         },\n-                        dependencies: [],\n-                        proc_macro: Err(\n-                            \"no proc macro loaded for sysroot crate\",\n-                        ),\n-                        origin: Lang(\n-                            Other,\n-                        ),\n                         is_proc_macro: false,\n                     },\n                 },"}, {"sha": "818bbed6af2ec73600d2bde661d2f420d48969f7", "filename": "src/tools/rust-analyzer/crates/project-model/src/workspace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -13,7 +13,7 @@ use cfg::{CfgDiff, CfgOptions};\n use paths::{AbsPath, AbsPathBuf};\n use rustc_hash::{FxHashMap, FxHashSet};\n use semver::Version;\n-use stdx::always;\n+use stdx::{always, hash::NoHashHashMap};\n \n use crate::{\n     build_scripts::BuildScriptOutput,\n@@ -471,7 +471,7 @@ fn project_json_to_crate_graph(\n         .map(|sysroot| sysroot_to_crate_graph(&mut crate_graph, sysroot, rustc_cfg.clone(), load));\n \n     let mut cfg_cache: FxHashMap<&str, Vec<CfgFlag>> = FxHashMap::default();\n-    let crates: FxHashMap<CrateId, CrateId> = project\n+    let crates: NoHashHashMap<CrateId, CrateId> = project\n         .crates()\n         .filter_map(|(crate_id, krate)| {\n             let file_path = &krate.root_module;"}, {"sha": "5392589186d1db8bcb563f90808b16f29ebd79d9", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -22,7 +22,8 @@ anyhow = \"1.0.57\"\n crossbeam-channel = \"0.5.5\"\n dissimilar = \"1.0.4\"\n itertools = \"0.10.3\"\n-lsp-types = { version = \"0.93.0\", features = [\"proposed\"] }\n+scip = \"0.1.1\"\n+lsp-types = { version = \"0.93.1\", features = [\"proposed\"] }\n parking_lot = \"0.12.1\"\n xflags = \"0.2.4\"\n oorandom = \"11.1.3\"\n@@ -88,5 +89,5 @@ in-rust-tree = [\n     \"proc-macro-srv/sysroot-abi\",\n     \"sourcegen/in-rust-tree\",\n     \"ide/in-rust-tree\",\n-    \"syntax/in-rust-tree\"\n+    \"syntax/in-rust-tree\",\n ]"}, {"sha": "f6a6802972525c09002f18bdc81bacb60a39d3dd", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -93,6 +93,7 @@ fn try_main() -> Result<()> {\n         flags::RustAnalyzerCmd::Ssr(cmd) => cmd.run()?,\n         flags::RustAnalyzerCmd::Search(cmd) => cmd.run()?,\n         flags::RustAnalyzerCmd::Lsif(cmd) => cmd.run()?,\n+        flags::RustAnalyzerCmd::Scip(cmd) => cmd.run()?,\n     }\n     Ok(())\n }"}, {"sha": "60ba67e25f93bc08679072f4a25de7bf10bdaf7c", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -9,6 +9,7 @@ mod analysis_stats;\n mod diagnostics;\n mod ssr;\n mod lsif;\n+mod scip;\n \n mod progress_report;\n "}, {"sha": "aa32654fbdca1efc3afc748e8ac59fb5b28e4c85", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/flags.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -112,6 +112,10 @@ xflags::xflags! {\n         cmd lsif\n             required path: PathBuf\n         {}\n+\n+        cmd scip\n+            required path: PathBuf\n+        {}\n     }\n }\n \n@@ -140,6 +144,7 @@ pub enum RustAnalyzerCmd {\n     Search(Search),\n     ProcMacro(ProcMacro),\n     Lsif(Lsif),\n+    Scip(Scip),\n }\n \n #[derive(Debug)]\n@@ -207,6 +212,11 @@ pub struct Lsif {\n     pub path: PathBuf,\n }\n \n+#[derive(Debug)]\n+pub struct Scip {\n+    pub path: PathBuf,\n+}\n+\n impl RustAnalyzer {\n     pub const HELP: &'static str = Self::HELP_;\n "}, {"sha": "65cc993c45e7145f8936532d002ba8133b7d6105", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/scip.rs", "status": "added", "additions": 448, "deletions": 0, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -0,0 +1,448 @@\n+//! SCIP generator\n+\n+use std::{\n+    collections::{HashMap, HashSet},\n+    time::Instant,\n+};\n+\n+use crate::line_index::{LineEndings, LineIndex, OffsetEncoding};\n+use hir::Name;\n+use ide::{\n+    LineCol, MonikerDescriptorKind, MonikerResult, StaticIndex, StaticIndexedFile, TextRange,\n+    TokenId,\n+};\n+use ide_db::LineIndexDatabase;\n+use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n+use scip::types as scip_types;\n+use std::env;\n+\n+use crate::cli::{\n+    flags,\n+    load_cargo::{load_workspace, LoadCargoConfig},\n+    Result,\n+};\n+\n+impl flags::Scip {\n+    pub fn run(self) -> Result<()> {\n+        eprintln!(\"Generating SCIP start...\");\n+        let now = Instant::now();\n+        let cargo_config = CargoConfig::default();\n+\n+        let no_progress = &|s| (eprintln!(\"rust-analyzer: Loading {}\", s));\n+        let load_cargo_config = LoadCargoConfig {\n+            load_out_dirs_from_check: true,\n+            with_proc_macro: true,\n+            prefill_caches: true,\n+        };\n+        let path = vfs::AbsPathBuf::assert(env::current_dir()?.join(&self.path));\n+        let rootpath = path.normalize();\n+        let manifest = ProjectManifest::discover_single(&path)?;\n+\n+        let workspace = ProjectWorkspace::load(manifest, &cargo_config, no_progress)?;\n+\n+        let (host, vfs, _) = load_workspace(workspace, &load_cargo_config)?;\n+        let db = host.raw_database();\n+        let analysis = host.analysis();\n+\n+        let si = StaticIndex::compute(&analysis);\n+\n+        let mut index = scip_types::Index {\n+            metadata: Some(scip_types::Metadata {\n+                version: scip_types::ProtocolVersion::UnspecifiedProtocolVersion.into(),\n+                tool_info: Some(scip_types::ToolInfo {\n+                    name: \"rust-analyzer\".to_owned(),\n+                    version: \"0.1\".to_owned(),\n+                    arguments: vec![],\n+                    ..Default::default()\n+                })\n+                .into(),\n+                project_root: format!(\n+                    \"file://{}\",\n+                    path.normalize()\n+                        .as_os_str()\n+                        .to_str()\n+                        .ok_or(anyhow::anyhow!(\"Unable to normalize project_root path\"))?\n+                        .to_string()\n+                ),\n+                text_document_encoding: scip_types::TextEncoding::UTF8.into(),\n+                ..Default::default()\n+            })\n+            .into(),\n+            ..Default::default()\n+        };\n+\n+        let mut symbols_emitted: HashSet<TokenId> = HashSet::default();\n+        let mut tokens_to_symbol: HashMap<TokenId, String> = HashMap::new();\n+\n+        for file in si.files {\n+            let mut local_count = 0;\n+            let mut new_local_symbol = || {\n+                let new_symbol = scip::types::Symbol::new_local(local_count);\n+                local_count += 1;\n+\n+                new_symbol\n+            };\n+\n+            let StaticIndexedFile { file_id, tokens, .. } = file;\n+            let relative_path = match get_relative_filepath(&vfs, &rootpath, file_id) {\n+                Some(relative_path) => relative_path,\n+                None => continue,\n+            };\n+\n+            let line_index = LineIndex {\n+                index: db.line_index(file_id),\n+                encoding: OffsetEncoding::Utf8,\n+                endings: LineEndings::Unix,\n+            };\n+\n+            let mut doc = scip_types::Document {\n+                relative_path,\n+                language: \"rust\".to_string(),\n+                ..Default::default()\n+            };\n+\n+            tokens.into_iter().for_each(|(range, id)| {\n+                let token = si.tokens.get(id).unwrap();\n+\n+                let mut occurrence = scip_types::Occurrence::default();\n+                occurrence.range = text_range_to_scip_range(&line_index, range);\n+                occurrence.symbol = match tokens_to_symbol.get(&id) {\n+                    Some(symbol) => symbol.clone(),\n+                    None => {\n+                        let symbol = match &token.moniker {\n+                            Some(moniker) => moniker_to_symbol(&moniker),\n+                            None => new_local_symbol(),\n+                        };\n+\n+                        let symbol = scip::symbol::format_symbol(symbol);\n+                        tokens_to_symbol.insert(id, symbol.clone());\n+                        symbol\n+                    }\n+                };\n+\n+                if let Some(def) = token.definition {\n+                    if def.range == range {\n+                        occurrence.symbol_roles |= scip_types::SymbolRole::Definition as i32;\n+                    }\n+\n+                    if !symbols_emitted.contains(&id) {\n+                        symbols_emitted.insert(id);\n+\n+                        let mut symbol_info = scip_types::SymbolInformation::default();\n+                        symbol_info.symbol = occurrence.symbol.clone();\n+                        if let Some(hover) = &token.hover {\n+                            if !hover.markup.as_str().is_empty() {\n+                                symbol_info.documentation = vec![hover.markup.as_str().to_string()];\n+                            }\n+                        }\n+\n+                        doc.symbols.push(symbol_info)\n+                    }\n+                }\n+\n+                doc.occurrences.push(occurrence);\n+            });\n+\n+            if doc.occurrences.is_empty() {\n+                continue;\n+            }\n+\n+            index.documents.push(doc);\n+        }\n+\n+        scip::write_message_to_file(\"index.scip\", index)\n+            .map_err(|err| anyhow::anyhow!(\"Failed to write scip to file: {}\", err))?;\n+\n+        eprintln!(\"Generating SCIP finished {:?}\", now.elapsed());\n+        Ok(())\n+    }\n+}\n+\n+fn get_relative_filepath(\n+    vfs: &vfs::Vfs,\n+    rootpath: &vfs::AbsPathBuf,\n+    file_id: ide::FileId,\n+) -> Option<String> {\n+    Some(vfs.file_path(file_id).as_path()?.strip_prefix(&rootpath)?.as_ref().to_str()?.to_string())\n+}\n+\n+// SCIP Ranges have a (very large) optimization that ranges if they are on the same line\n+// only encode as a vector of [start_line, start_col, end_col].\n+//\n+// This transforms a line index into the optimized SCIP Range.\n+fn text_range_to_scip_range(line_index: &LineIndex, range: TextRange) -> Vec<i32> {\n+    let LineCol { line: start_line, col: start_col } = line_index.index.line_col(range.start());\n+    let LineCol { line: end_line, col: end_col } = line_index.index.line_col(range.end());\n+\n+    if start_line == end_line {\n+        vec![start_line as i32, start_col as i32, end_col as i32]\n+    } else {\n+        vec![start_line as i32, start_col as i32, end_line as i32, end_col as i32]\n+    }\n+}\n+\n+fn new_descriptor_str(\n+    name: &str,\n+    suffix: scip_types::descriptor::Suffix,\n+) -> scip_types::Descriptor {\n+    scip_types::Descriptor {\n+        name: name.to_string(),\n+        disambiguator: \"\".to_string(),\n+        suffix: suffix.into(),\n+        ..Default::default()\n+    }\n+}\n+\n+fn new_descriptor(name: Name, suffix: scip_types::descriptor::Suffix) -> scip_types::Descriptor {\n+    let mut name = name.to_string();\n+    if name.contains(\"'\") {\n+        name = format!(\"`{}`\", name);\n+    }\n+\n+    new_descriptor_str(name.as_str(), suffix)\n+}\n+\n+/// Loosely based on `def_to_moniker`\n+///\n+/// Only returns a Symbol when it's a non-local symbol.\n+///     So if the visibility isn't outside of a document, then it will return None\n+fn moniker_to_symbol(moniker: &MonikerResult) -> scip_types::Symbol {\n+    use scip_types::descriptor::Suffix::*;\n+\n+    let package_name = moniker.package_information.name.clone();\n+    let version = moniker.package_information.version.clone();\n+    let descriptors = moniker\n+        .identifier\n+        .description\n+        .iter()\n+        .map(|desc| {\n+            new_descriptor(\n+                desc.name.clone(),\n+                match desc.desc {\n+                    MonikerDescriptorKind::Namespace => Namespace,\n+                    MonikerDescriptorKind::Type => Type,\n+                    MonikerDescriptorKind::Term => Term,\n+                    MonikerDescriptorKind::Method => Method,\n+                    MonikerDescriptorKind::TypeParameter => TypeParameter,\n+                    MonikerDescriptorKind::Parameter => Parameter,\n+                    MonikerDescriptorKind::Macro => Macro,\n+                    MonikerDescriptorKind::Meta => Meta,\n+                },\n+            )\n+        })\n+        .collect();\n+\n+    scip_types::Symbol {\n+        scheme: \"rust-analyzer\".into(),\n+        package: Some(scip_types::Package {\n+            manager: \"cargo\".to_string(),\n+            name: package_name,\n+            version,\n+            ..Default::default()\n+        })\n+        .into(),\n+        descriptors,\n+        ..Default::default()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use hir::Semantics;\n+    use ide::{AnalysisHost, FilePosition};\n+    use ide_db::defs::IdentClass;\n+    use ide_db::{base_db::fixture::ChangeFixture, helpers::pick_best_token};\n+    use scip::symbol::format_symbol;\n+    use syntax::SyntaxKind::*;\n+    use syntax::{AstNode, T};\n+\n+    fn position(ra_fixture: &str) -> (AnalysisHost, FilePosition) {\n+        let mut host = AnalysisHost::default();\n+        let change_fixture = ChangeFixture::parse(ra_fixture);\n+        host.raw_database_mut().apply_change(change_fixture.change);\n+        let (file_id, range_or_offset) =\n+            change_fixture.file_position.expect(\"expected a marker ($0)\");\n+        let offset = range_or_offset.expect_offset();\n+        (host, FilePosition { file_id, offset })\n+    }\n+\n+    /// If expected == \"\", then assert that there are no symbols (this is basically local symbol)\n+    #[track_caller]\n+    fn check_symbol(ra_fixture: &str, expected: &str) {\n+        let (host, position) = position(ra_fixture);\n+\n+        let FilePosition { file_id, offset } = position;\n+\n+        let db = host.raw_database();\n+        let sema = &Semantics::new(db);\n+        let file = sema.parse(file_id).syntax().clone();\n+        let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n+            IDENT\n+            | INT_NUMBER\n+            | LIFETIME_IDENT\n+            | T![self]\n+            | T![super]\n+            | T![crate]\n+            | T![Self]\n+            | COMMENT => 2,\n+            kind if kind.is_trivia() => 0,\n+            _ => 1,\n+        })\n+        .expect(\"OK OK\");\n+\n+        let navs = sema\n+            .descend_into_macros(original_token.clone())\n+            .into_iter()\n+            .filter_map(|token| {\n+                IdentClass::classify_token(sema, &token).map(IdentClass::definitions).map(|it| {\n+                    it.into_iter().flat_map(|def| {\n+                        let module = def.module(db).unwrap();\n+                        let current_crate = module.krate();\n+\n+                        match MonikerResult::from_def(sema.db, def, current_crate) {\n+                            Some(moniker_result) => Some(moniker_to_symbol(&moniker_result)),\n+                            None => None,\n+                        }\n+                    })\n+                })\n+            })\n+            .flatten()\n+            .collect::<Vec<_>>();\n+\n+        if expected == \"\" {\n+            assert_eq!(0, navs.len(), \"must have no symbols {:?}\", navs);\n+            return;\n+        }\n+\n+        assert_eq!(1, navs.len(), \"must have one symbol {:?}\", navs);\n+\n+        let res = navs.get(0).unwrap();\n+        let formatted = format_symbol(res.clone());\n+        assert_eq!(formatted, expected);\n+    }\n+\n+    #[test]\n+    fn basic() {\n+        check_symbol(\n+            r#\"\n+//- /lib.rs crate:main deps:foo\n+use foo::example_mod::func;\n+fn main() {\n+    func$0();\n+}\n+//- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+pub mod example_mod {\n+    pub fn func() {}\n+}\n+\"#,\n+            \"rust-analyzer cargo foo 0.1.0 example_mod/func().\",\n+        );\n+    }\n+\n+    #[test]\n+    fn symbol_for_trait() {\n+        check_symbol(\n+            r#\"\n+//- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+pub mod module {\n+    pub trait MyTrait {\n+        pub fn func$0() {}\n+    }\n+}\n+\"#,\n+            \"rust-analyzer cargo foo 0.1.0 module/MyTrait#func().\",\n+        );\n+    }\n+\n+    #[test]\n+    fn symbol_for_trait_constant() {\n+        check_symbol(\n+            r#\"\n+    //- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+    pub mod module {\n+        pub trait MyTrait {\n+            const MY_CONST$0: u8;\n+        }\n+    }\n+    \"#,\n+            \"rust-analyzer cargo foo 0.1.0 module/MyTrait#MY_CONST.\",\n+        );\n+    }\n+\n+    #[test]\n+    fn symbol_for_trait_type() {\n+        check_symbol(\n+            r#\"\n+    //- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+    pub mod module {\n+        pub trait MyTrait {\n+            type MyType$0;\n+        }\n+    }\n+    \"#,\n+            // \"foo::module::MyTrait::MyType\",\n+            \"rust-analyzer cargo foo 0.1.0 module/MyTrait#[MyType]\",\n+        );\n+    }\n+\n+    #[test]\n+    fn symbol_for_trait_impl_function() {\n+        check_symbol(\n+            r#\"\n+    //- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+    pub mod module {\n+        pub trait MyTrait {\n+            pub fn func() {}\n+        }\n+\n+        struct MyStruct {}\n+\n+        impl MyTrait for MyStruct {\n+            pub fn func$0() {}\n+        }\n+    }\n+    \"#,\n+            // \"foo::module::MyStruct::MyTrait::func\",\n+            \"rust-analyzer cargo foo 0.1.0 module/MyStruct#MyTrait#func().\",\n+        );\n+    }\n+\n+    #[test]\n+    fn symbol_for_field() {\n+        check_symbol(\n+            r#\"\n+    //- /lib.rs crate:main deps:foo\n+    use foo::St;\n+    fn main() {\n+        let x = St { a$0: 2 };\n+    }\n+    //- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+    pub struct St {\n+        pub a: i32,\n+    }\n+    \"#,\n+            \"rust-analyzer cargo foo 0.1.0 St#a.\",\n+        );\n+    }\n+\n+    #[test]\n+    fn local_symbol_for_local() {\n+        check_symbol(\n+            r#\"\n+    //- /lib.rs crate:main deps:foo\n+    use foo::module::func;\n+    fn main() {\n+        func();\n+    }\n+    //- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+    pub mod module {\n+        pub fn func() {\n+            let x$0 = 2;\n+        }\n+    }\n+    \"#,\n+            \"\",\n+        );\n+    }\n+}"}, {"sha": "54dcb42d99c789ea142e8873dee91d246114692e", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -12,8 +12,8 @@ use std::{ffi::OsString, fmt, iter, path::PathBuf};\n use flycheck::FlycheckConfig;\n use ide::{\n     AssistConfig, CallableSnippets, CompletionConfig, DiagnosticsConfig, ExprFillDefaultMode,\n-    HighlightRelatedConfig, HoverConfig, HoverDocFormat, InlayHintsConfig, JoinLinesConfig,\n-    Snippet, SnippetScope,\n+    HighlightConfig, HighlightRelatedConfig, HoverConfig, HoverDocFormat, InlayHintsConfig,\n+    JoinLinesConfig, Snippet, SnippetScope,\n };\n use ide_db::{\n     imports::insert_use::{ImportGranularity, InsertUseConfig, PrefixKind},\n@@ -385,6 +385,34 @@ config_data! {\n         /// available on a nightly build.\n         rustfmt_rangeFormatting_enable: bool = \"false\",\n \n+        /// Inject additional highlighting into doc comments.\n+        ///\n+        /// When enabled, rust-analyzer will highlight rust source in doc comments as well as intra\n+        /// doc links.\n+        semanticHighlighting_doc_comment_inject_enable: bool = \"true\",\n+        /// Use semantic tokens for operators.\n+        ///\n+        /// When disabled, rust-analyzer will emit semantic tokens only for operator tokens when\n+        /// they are tagged with modifiers.\n+        semanticHighlighting_operator_enable: bool = \"true\",\n+        /// Use specialized semantic tokens for operators.\n+        ///\n+        /// When enabled, rust-analyzer will emit special token types for operator tokens instead\n+        /// of the generic `operator` token type.\n+        semanticHighlighting_operator_specialization_enable: bool = \"false\",\n+        /// Use semantic tokens for punctuations.\n+        ///\n+        /// When disabled, rust-analyzer will emit semantic tokens only for punctuation tokens when\n+        /// they are tagged with modifiers or have a special role.\n+        semanticHighlighting_punctuation_enable: bool = \"false\",\n+        /// When enabled, rust-analyzer will emit a punctuation semantic token for the `!` of macro\n+        /// calls.\n+        semanticHighlighting_punctuation_separate_macro_bang: bool = \"false\",\n+        /// Use specialized semantic tokens for punctuations.\n+        ///\n+        /// When enabled, rust-analyzer will emit special token types for punctuation tokens instead\n+        /// of the generic `punctuation` token type.\n+        semanticHighlighting_punctuation_specialization_enable: bool = \"false\",\n         /// Use semantic tokens for strings.\n         ///\n         /// In some editors (e.g. vscode) semantic tokens override other highlighting grammars.\n@@ -1171,8 +1199,19 @@ impl Config {\n         }\n     }\n \n-    pub fn highlighting_strings(&self) -> bool {\n-        self.data.semanticHighlighting_strings_enable\n+    pub fn highlighting_config(&self) -> HighlightConfig {\n+        HighlightConfig {\n+            strings: self.data.semanticHighlighting_strings_enable,\n+            punctuation: self.data.semanticHighlighting_punctuation_enable,\n+            specialize_punctuation: self\n+                .data\n+                .semanticHighlighting_punctuation_specialization_enable,\n+            macro_bang: self.data.semanticHighlighting_punctuation_separate_macro_bang,\n+            operator: self.data.semanticHighlighting_operator_enable,\n+            specialize_operator: self.data.semanticHighlighting_operator_specialization_enable,\n+            inject_doc_comment: self.data.semanticHighlighting_doc_comment_inject_enable,\n+            syntactic_name_ref_highlighting: false,\n+        }\n     }\n \n     pub fn hover(&self) -> HoverConfig {"}, {"sha": "f516c194da467f7afee60a4f123aeff25c06b26d", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -4,11 +4,12 @@ pub(crate) mod to_proto;\n use std::{mem, sync::Arc};\n \n use ide::FileId;\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use ide_db::FxHashMap;\n+use stdx::hash::{NoHashHashMap, NoHashHashSet};\n \n use crate::lsp_ext;\n \n-pub(crate) type CheckFixes = Arc<FxHashMap<usize, FxHashMap<FileId, Vec<Fix>>>>;\n+pub(crate) type CheckFixes = Arc<NoHashHashMap<usize, NoHashHashMap<FileId, Vec<Fix>>>>;\n \n #[derive(Debug, Default, Clone)]\n pub struct DiagnosticsMapConfig {\n@@ -19,12 +20,12 @@ pub struct DiagnosticsMapConfig {\n \n #[derive(Debug, Default, Clone)]\n pub(crate) struct DiagnosticCollection {\n-    // FIXME: should be FxHashMap<FileId, Vec<ra_id::Diagnostic>>\n-    pub(crate) native: FxHashMap<FileId, Vec<lsp_types::Diagnostic>>,\n+    // FIXME: should be NoHashHashMap<FileId, Vec<ra_id::Diagnostic>>\n+    pub(crate) native: NoHashHashMap<FileId, Vec<lsp_types::Diagnostic>>,\n     // FIXME: should be Vec<flycheck::Diagnostic>\n-    pub(crate) check: FxHashMap<usize, FxHashMap<FileId, Vec<lsp_types::Diagnostic>>>,\n+    pub(crate) check: NoHashHashMap<usize, NoHashHashMap<FileId, Vec<lsp_types::Diagnostic>>>,\n     pub(crate) check_fixes: CheckFixes,\n-    changes: FxHashSet<FileId>,\n+    changes: NoHashHashSet<FileId>,\n }\n \n #[derive(Debug, Clone)]\n@@ -105,7 +106,7 @@ impl DiagnosticCollection {\n         native.chain(check)\n     }\n \n-    pub(crate) fn take_changes(&mut self) -> Option<FxHashSet<FileId>> {\n+    pub(crate) fn take_changes(&mut self) -> Option<NoHashHashSet<FileId>> {\n         if self.changes.is_empty() {\n             return None;\n         }"}, {"sha": "706e1742dffde38a695d9119413849ad8fb497ac", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -14,6 +14,7 @@ use parking_lot::{Mutex, RwLock};\n use proc_macro_api::ProcMacroServer;\n use project_model::{CargoWorkspace, ProjectWorkspace, Target, WorkspaceBuildScripts};\n use rustc_hash::FxHashMap;\n+use stdx::hash::NoHashHashMap;\n use vfs::AnchoredPathBuf;\n \n use crate::{\n@@ -67,7 +68,7 @@ pub(crate) struct GlobalState {\n     pub(crate) flycheck_sender: Sender<flycheck::Message>,\n     pub(crate) flycheck_receiver: Receiver<flycheck::Message>,\n \n-    pub(crate) vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n+    pub(crate) vfs: Arc<RwLock<(vfs::Vfs, NoHashHashMap<FileId, LineEndings>)>>,\n     pub(crate) vfs_config_version: u32,\n     pub(crate) vfs_progress_config_version: u32,\n     pub(crate) vfs_progress_n_total: usize,\n@@ -113,7 +114,7 @@ pub(crate) struct GlobalStateSnapshot {\n     pub(crate) check_fixes: CheckFixes,\n     mem_docs: MemDocs,\n     pub(crate) semantic_tokens_cache: Arc<Mutex<FxHashMap<Url, SemanticTokens>>>,\n-    vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n+    vfs: Arc<RwLock<(vfs::Vfs, NoHashHashMap<FileId, LineEndings>)>>,\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n }\n \n@@ -157,7 +158,7 @@ impl GlobalState {\n             flycheck_sender,\n             flycheck_receiver,\n \n-            vfs: Arc::new(RwLock::new((vfs::Vfs::default(), FxHashMap::default()))),\n+            vfs: Arc::new(RwLock::new((vfs::Vfs::default(), NoHashHashMap::default()))),\n             vfs_config_version: 0,\n             vfs_progress_config_version: 0,\n             vfs_progress_n_total: 0,"}, {"sha": "d89f0f5a3cf456d24c7889deec9355b3098e7a34", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -1504,10 +1504,8 @@ pub(crate) fn handle_semantic_tokens_full(\n     let text = snap.analysis.file_text(file_id)?;\n     let line_index = snap.file_line_index(file_id)?;\n \n-    let highlights = snap.analysis.highlight(file_id)?;\n-    let highlight_strings = snap.config.highlighting_strings();\n-    let semantic_tokens =\n-        to_proto::semantic_tokens(&text, &line_index, highlights, highlight_strings);\n+    let highlights = snap.analysis.highlight(snap.config.highlighting_config(), file_id)?;\n+    let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n \n     // Unconditionally cache the tokens\n     snap.semantic_tokens_cache.lock().insert(params.text_document.uri, semantic_tokens.clone());\n@@ -1525,10 +1523,8 @@ pub(crate) fn handle_semantic_tokens_full_delta(\n     let text = snap.analysis.file_text(file_id)?;\n     let line_index = snap.file_line_index(file_id)?;\n \n-    let highlights = snap.analysis.highlight(file_id)?;\n-    let highlight_strings = snap.config.highlighting_strings();\n-    let semantic_tokens =\n-        to_proto::semantic_tokens(&text, &line_index, highlights, highlight_strings);\n+    let highlights = snap.analysis.highlight(snap.config.highlighting_config(), file_id)?;\n+    let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n \n     let mut cache = snap.semantic_tokens_cache.lock();\n     let cached_tokens = cache.entry(params.text_document.uri).or_default();\n@@ -1556,10 +1552,8 @@ pub(crate) fn handle_semantic_tokens_range(\n     let text = snap.analysis.file_text(frange.file_id)?;\n     let line_index = snap.file_line_index(frange.file_id)?;\n \n-    let highlights = snap.analysis.highlight_range(frange)?;\n-    let highlight_strings = snap.config.highlighting_strings();\n-    let semantic_tokens =\n-        to_proto::semantic_tokens(&text, &line_index, highlights, highlight_strings);\n+    let highlights = snap.analysis.highlight_range(snap.config.highlighting_config(), frange)?;\n+    let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n     Ok(Some(semantic_tokens.into()))\n }\n "}, {"sha": "3cfbc2e4e45037cbaefb2a5116987ba995bfaa3a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -328,8 +328,33 @@ impl GlobalState {\n                 }\n \n                 let uri = file_id_to_url(&self.vfs.read().0, file_id);\n-                let diagnostics =\n+                let mut diagnostics =\n                     self.diagnostics.diagnostics_for(file_id).cloned().collect::<Vec<_>>();\n+\n+                // VSCode assumes diagnostic messages to be non-empty strings, so we need to patch\n+                // empty diagnostics. Neither the docs of VSCode nor the LSP spec say whether\n+                // diagnostic messages are actually allowed to be empty or not and patching this\n+                // in the VSCode client does not work as the assertion happens in the protocol\n+                // conversion. So this hack is here to stay, and will be considered a hack\n+                // until the LSP decides to state that empty messages are allowed.\n+\n+                // See https://github.com/rust-lang/rust-analyzer/issues/11404\n+                // See https://github.com/rust-lang/rust-analyzer/issues/13130\n+                let patch_empty = |message: &mut String| {\n+                    if message.is_empty() {\n+                        *message = \" \".to_string();\n+                    }\n+                };\n+\n+                for d in &mut diagnostics {\n+                    patch_empty(&mut d.message);\n+                    if let Some(dri) = &mut d.related_information {\n+                        for dri in dri {\n+                            patch_empty(&mut dri.message);\n+                        }\n+                    }\n+                }\n+\n                 let version = from_proto::vfs_path(&uri)\n                     .map(|path| self.mem_docs.get(&path).map(|it| it.version))\n                     .unwrap_or_default();\n@@ -529,6 +554,13 @@ impl GlobalState {\n                     }\n                     flycheck::Progress::DidCheckCrate(target) => (Progress::Report, Some(target)),\n                     flycheck::Progress::DidCancel => (Progress::End, None),\n+                    flycheck::Progress::DidFailToRestart(err) => {\n+                        self.show_and_log_error(\n+                            \"cargo check failed\".to_string(),\n+                            Some(err.to_string()),\n+                        );\n+                        return;\n+                    }\n                     flycheck::Progress::DidFinish(result) => {\n                         if let Err(err) = result {\n                             self.show_and_log_error("}, {"sha": "c48410ed55e98472d4f0bc774703225e80048cad", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/semantic_tokens.rs", "status": "modified", "additions": 107, "deletions": 84, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fsemantic_tokens.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -8,107 +8,130 @@ use lsp_types::{\n };\n \n macro_rules! define_semantic_token_types {\n-    ($(($ident:ident, $string:literal)),*$(,)?) => {\n-        $(pub(crate) const $ident: SemanticTokenType = SemanticTokenType::new($string);)*\n+    (\n+        standard {\n+            $($standard:ident),*$(,)?\n+        }\n+        custom {\n+            $(($custom:ident, $string:literal)),*$(,)?\n+        }\n+\n+    ) => {\n+        $(pub(crate) const $standard: SemanticTokenType = SemanticTokenType::$standard;)*\n+        $(pub(crate) const $custom: SemanticTokenType = SemanticTokenType::new($string);)*\n \n         pub(crate) const SUPPORTED_TYPES: &[SemanticTokenType] = &[\n-            SemanticTokenType::COMMENT,\n-            SemanticTokenType::KEYWORD,\n-            SemanticTokenType::STRING,\n-            SemanticTokenType::NUMBER,\n-            SemanticTokenType::REGEXP,\n-            SemanticTokenType::OPERATOR,\n-            SemanticTokenType::NAMESPACE,\n-            SemanticTokenType::TYPE,\n-            SemanticTokenType::STRUCT,\n-            SemanticTokenType::CLASS,\n-            SemanticTokenType::INTERFACE,\n-            SemanticTokenType::ENUM,\n-            SemanticTokenType::ENUM_MEMBER,\n-            SemanticTokenType::TYPE_PARAMETER,\n-            SemanticTokenType::FUNCTION,\n-            SemanticTokenType::METHOD,\n-            SemanticTokenType::PROPERTY,\n-            SemanticTokenType::MACRO,\n-            SemanticTokenType::VARIABLE,\n-            SemanticTokenType::PARAMETER,\n-            $($ident),*\n+            $(SemanticTokenType::$standard,)*\n+            $($custom),*\n         ];\n     };\n }\n \n define_semantic_token_types![\n-    (ANGLE, \"angle\"),\n-    (ARITHMETIC, \"arithmetic\"),\n-    (ATTRIBUTE, \"attribute\"),\n-    (ATTRIBUTE_BRACKET, \"attributeBracket\"),\n-    (BITWISE, \"bitwise\"),\n-    (BOOLEAN, \"boolean\"),\n-    (BRACE, \"brace\"),\n-    (BRACKET, \"bracket\"),\n-    (BUILTIN_ATTRIBUTE, \"builtinAttribute\"),\n-    (BUILTIN_TYPE, \"builtinType\"),\n-    (CHAR, \"character\"),\n-    (COLON, \"colon\"),\n-    (COMMA, \"comma\"),\n-    (COMPARISON, \"comparison\"),\n-    (CONST_PARAMETER, \"constParameter\"),\n-    (DERIVE, \"derive\"),\n-    (DERIVE_HELPER, \"deriveHelper\"),\n-    (DOT, \"dot\"),\n-    (ESCAPE_SEQUENCE, \"escapeSequence\"),\n-    (FORMAT_SPECIFIER, \"formatSpecifier\"),\n-    (GENERIC, \"generic\"),\n-    (LABEL, \"label\"),\n-    (LIFETIME, \"lifetime\"),\n-    (LOGICAL, \"logical\"),\n-    (MACRO_BANG, \"macroBang\"),\n-    (OPERATOR, \"operator\"),\n-    (PARENTHESIS, \"parenthesis\"),\n-    (PUNCTUATION, \"punctuation\"),\n-    (SELF_KEYWORD, \"selfKeyword\"),\n-    (SELF_TYPE_KEYWORD, \"selfTypeKeyword\"),\n-    (SEMICOLON, \"semicolon\"),\n-    (TYPE_ALIAS, \"typeAlias\"),\n-    (TOOL_MODULE, \"toolModule\"),\n-    (UNION, \"union\"),\n-    (UNRESOLVED_REFERENCE, \"unresolvedReference\"),\n+    standard {\n+        COMMENT,\n+        DECORATOR,\n+        ENUM_MEMBER,\n+        ENUM,\n+        FUNCTION,\n+        INTERFACE,\n+        KEYWORD,\n+        MACRO,\n+        METHOD,\n+        NAMESPACE,\n+        NUMBER,\n+        OPERATOR,\n+        PARAMETER,\n+        PROPERTY,\n+        STRING,\n+        STRUCT,\n+        TYPE_PARAMETER,\n+        VARIABLE,\n+    }\n+\n+    custom {\n+        (ANGLE, \"angle\"),\n+        (ARITHMETIC, \"arithmetic\"),\n+        (ATTRIBUTE, \"attribute\"),\n+        (ATTRIBUTE_BRACKET, \"attributeBracket\"),\n+        (BITWISE, \"bitwise\"),\n+        (BOOLEAN, \"boolean\"),\n+        (BRACE, \"brace\"),\n+        (BRACKET, \"bracket\"),\n+        (BUILTIN_ATTRIBUTE, \"builtinAttribute\"),\n+        (BUILTIN_TYPE, \"builtinType\"),\n+        (CHAR, \"character\"),\n+        (COLON, \"colon\"),\n+        (COMMA, \"comma\"),\n+        (COMPARISON, \"comparison\"),\n+        (CONST_PARAMETER, \"constParameter\"),\n+        (DERIVE, \"derive\"),\n+        (DERIVE_HELPER, \"deriveHelper\"),\n+        (DOT, \"dot\"),\n+        (ESCAPE_SEQUENCE, \"escapeSequence\"),\n+        (FORMAT_SPECIFIER, \"formatSpecifier\"),\n+        (GENERIC, \"generic\"),\n+        (LABEL, \"label\"),\n+        (LIFETIME, \"lifetime\"),\n+        (LOGICAL, \"logical\"),\n+        (MACRO_BANG, \"macroBang\"),\n+        (PARENTHESIS, \"parenthesis\"),\n+        (PUNCTUATION, \"punctuation\"),\n+        (SELF_KEYWORD, \"selfKeyword\"),\n+        (SELF_TYPE_KEYWORD, \"selfTypeKeyword\"),\n+        (SEMICOLON, \"semicolon\"),\n+        (TYPE_ALIAS, \"typeAlias\"),\n+        (TOOL_MODULE, \"toolModule\"),\n+        (UNION, \"union\"),\n+        (UNRESOLVED_REFERENCE, \"unresolvedReference\"),\n+    }\n ];\n \n macro_rules! define_semantic_token_modifiers {\n-    ($(($ident:ident, $string:literal)),*$(,)?) => {\n-        $(pub(crate) const $ident: SemanticTokenModifier = SemanticTokenModifier::new($string);)*\n+    (\n+        standard {\n+            $($standard:ident),*$(,)?\n+        }\n+        custom {\n+            $(($custom:ident, $string:literal)),*$(,)?\n+        }\n+\n+    ) => {\n+\n+        $(pub(crate) const $standard: SemanticTokenModifier = SemanticTokenModifier::$standard;)*\n+        $(pub(crate) const $custom: SemanticTokenModifier = SemanticTokenModifier::new($string);)*\n \n         pub(crate) const SUPPORTED_MODIFIERS: &[SemanticTokenModifier] = &[\n-            SemanticTokenModifier::DOCUMENTATION,\n-            SemanticTokenModifier::DECLARATION,\n-            SemanticTokenModifier::DEFINITION,\n-            SemanticTokenModifier::STATIC,\n-            SemanticTokenModifier::ABSTRACT,\n-            SemanticTokenModifier::DEPRECATED,\n-            SemanticTokenModifier::READONLY,\n-            SemanticTokenModifier::DEFAULT_LIBRARY,\n-            $($ident),*\n+            $(SemanticTokenModifier::$standard,)*\n+            $($custom),*\n         ];\n     };\n }\n \n define_semantic_token_modifiers![\n-    (ASYNC, \"async\"),\n-    (ATTRIBUTE_MODIFIER, \"attribute\"),\n-    (CALLABLE, \"callable\"),\n-    (CONSTANT, \"constant\"),\n-    (CONSUMING, \"consuming\"),\n-    (CONTROL_FLOW, \"controlFlow\"),\n-    (CRATE_ROOT, \"crateRoot\"),\n-    (INJECTED, \"injected\"),\n-    (INTRA_DOC_LINK, \"intraDocLink\"),\n-    (LIBRARY, \"library\"),\n-    (MUTABLE, \"mutable\"),\n-    (PUBLIC, \"public\"),\n-    (REFERENCE, \"reference\"),\n-    (TRAIT_MODIFIER, \"trait\"),\n-    (UNSAFE, \"unsafe\"),\n+    standard {\n+        DOCUMENTATION,\n+        DECLARATION,\n+        STATIC,\n+        DEFAULT_LIBRARY,\n+    }\n+    custom {\n+        (ASYNC, \"async\"),\n+        (ATTRIBUTE_MODIFIER, \"attribute\"),\n+        (CALLABLE, \"callable\"),\n+        (CONSTANT, \"constant\"),\n+        (CONSUMING, \"consuming\"),\n+        (CONTROL_FLOW, \"controlFlow\"),\n+        (CRATE_ROOT, \"crateRoot\"),\n+        (INJECTED, \"injected\"),\n+        (INTRA_DOC_LINK, \"intraDocLink\"),\n+        (LIBRARY, \"library\"),\n+        (MUTABLE, \"mutable\"),\n+        (PUBLIC, \"public\"),\n+        (REFERENCE, \"reference\"),\n+        (TRAIT_MODIFIER, \"trait\"),\n+        (UNSAFE, \"unsafe\"),\n+    }\n ];\n \n #[derive(Default)]"}, {"sha": "102cd602950439a4188b5006116353dd164299f8", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -517,7 +517,6 @@ pub(crate) fn semantic_tokens(\n     text: &str,\n     line_index: &LineIndex,\n     highlights: Vec<HlRange>,\n-    highlight_strings: bool,\n ) -> lsp_types::SemanticTokens {\n     let id = TOKEN_RESULT_COUNTER.fetch_add(1, Ordering::SeqCst).to_string();\n     let mut builder = semantic_tokens::SemanticTokensBuilder::new(id);\n@@ -526,10 +525,8 @@ pub(crate) fn semantic_tokens(\n         if highlight_range.highlight.is_empty() {\n             continue;\n         }\n+\n         let (ty, mods) = semantic_token_type_and_modifiers(highlight_range.highlight);\n-        if !highlight_strings && ty == lsp_types::SemanticTokenType::STRING {\n-            continue;\n-        }\n         let token_index = semantic_tokens::type_index(ty);\n         let modifier_bitset = mods.0;\n \n@@ -561,55 +558,55 @@ fn semantic_token_type_and_modifiers(\n     let mut mods = semantic_tokens::ModifierSet::default();\n     let type_ = match highlight.tag {\n         HlTag::Symbol(symbol) => match symbol {\n-            SymbolKind::Attribute => semantic_tokens::ATTRIBUTE,\n+            SymbolKind::Attribute => semantic_tokens::DECORATOR,\n             SymbolKind::Derive => semantic_tokens::DERIVE,\n             SymbolKind::DeriveHelper => semantic_tokens::DERIVE_HELPER,\n-            SymbolKind::Module => lsp_types::SemanticTokenType::NAMESPACE,\n+            SymbolKind::Module => semantic_tokens::NAMESPACE,\n             SymbolKind::Impl => semantic_tokens::TYPE_ALIAS,\n-            SymbolKind::Field => lsp_types::SemanticTokenType::PROPERTY,\n-            SymbolKind::TypeParam => lsp_types::SemanticTokenType::TYPE_PARAMETER,\n+            SymbolKind::Field => semantic_tokens::PROPERTY,\n+            SymbolKind::TypeParam => semantic_tokens::TYPE_PARAMETER,\n             SymbolKind::ConstParam => semantic_tokens::CONST_PARAMETER,\n             SymbolKind::LifetimeParam => semantic_tokens::LIFETIME,\n             SymbolKind::Label => semantic_tokens::LABEL,\n-            SymbolKind::ValueParam => lsp_types::SemanticTokenType::PARAMETER,\n+            SymbolKind::ValueParam => semantic_tokens::PARAMETER,\n             SymbolKind::SelfParam => semantic_tokens::SELF_KEYWORD,\n             SymbolKind::SelfType => semantic_tokens::SELF_TYPE_KEYWORD,\n-            SymbolKind::Local => lsp_types::SemanticTokenType::VARIABLE,\n+            SymbolKind::Local => semantic_tokens::VARIABLE,\n             SymbolKind::Function => {\n                 if highlight.mods.contains(HlMod::Associated) {\n-                    lsp_types::SemanticTokenType::METHOD\n+                    semantic_tokens::METHOD\n                 } else {\n-                    lsp_types::SemanticTokenType::FUNCTION\n+                    semantic_tokens::FUNCTION\n                 }\n             }\n             SymbolKind::Const => {\n                 mods |= semantic_tokens::CONSTANT;\n-                mods |= lsp_types::SemanticTokenModifier::STATIC;\n-                lsp_types::SemanticTokenType::VARIABLE\n+                mods |= semantic_tokens::STATIC;\n+                semantic_tokens::VARIABLE\n             }\n             SymbolKind::Static => {\n-                mods |= lsp_types::SemanticTokenModifier::STATIC;\n-                lsp_types::SemanticTokenType::VARIABLE\n+                mods |= semantic_tokens::STATIC;\n+                semantic_tokens::VARIABLE\n             }\n-            SymbolKind::Struct => lsp_types::SemanticTokenType::STRUCT,\n-            SymbolKind::Enum => lsp_types::SemanticTokenType::ENUM,\n-            SymbolKind::Variant => lsp_types::SemanticTokenType::ENUM_MEMBER,\n+            SymbolKind::Struct => semantic_tokens::STRUCT,\n+            SymbolKind::Enum => semantic_tokens::ENUM,\n+            SymbolKind::Variant => semantic_tokens::ENUM_MEMBER,\n             SymbolKind::Union => semantic_tokens::UNION,\n             SymbolKind::TypeAlias => semantic_tokens::TYPE_ALIAS,\n-            SymbolKind::Trait => lsp_types::SemanticTokenType::INTERFACE,\n-            SymbolKind::Macro => lsp_types::SemanticTokenType::MACRO,\n+            SymbolKind::Trait => semantic_tokens::INTERFACE,\n+            SymbolKind::Macro => semantic_tokens::MACRO,\n             SymbolKind::BuiltinAttr => semantic_tokens::BUILTIN_ATTRIBUTE,\n             SymbolKind::ToolModule => semantic_tokens::TOOL_MODULE,\n         },\n         HlTag::AttributeBracket => semantic_tokens::ATTRIBUTE_BRACKET,\n         HlTag::BoolLiteral => semantic_tokens::BOOLEAN,\n         HlTag::BuiltinType => semantic_tokens::BUILTIN_TYPE,\n-        HlTag::ByteLiteral | HlTag::NumericLiteral => lsp_types::SemanticTokenType::NUMBER,\n+        HlTag::ByteLiteral | HlTag::NumericLiteral => semantic_tokens::NUMBER,\n         HlTag::CharLiteral => semantic_tokens::CHAR,\n-        HlTag::Comment => lsp_types::SemanticTokenType::COMMENT,\n+        HlTag::Comment => semantic_tokens::COMMENT,\n         HlTag::EscapeSequence => semantic_tokens::ESCAPE_SEQUENCE,\n         HlTag::FormatSpecifier => semantic_tokens::FORMAT_SPECIFIER,\n-        HlTag::Keyword => lsp_types::SemanticTokenType::KEYWORD,\n+        HlTag::Keyword => semantic_tokens::KEYWORD,\n         HlTag::None => semantic_tokens::GENERIC,\n         HlTag::Operator(op) => match op {\n             HlOperator::Bitwise => semantic_tokens::BITWISE,\n@@ -618,7 +615,7 @@ fn semantic_token_type_and_modifiers(\n             HlOperator::Comparison => semantic_tokens::COMPARISON,\n             HlOperator::Other => semantic_tokens::OPERATOR,\n         },\n-        HlTag::StringLiteral => lsp_types::SemanticTokenType::STRING,\n+        HlTag::StringLiteral => semantic_tokens::STRING,\n         HlTag::UnresolvedReference => semantic_tokens::UNRESOLVED_REFERENCE,\n         HlTag::Punctuation(punct) => match punct {\n             HlPunct::Bracket => semantic_tokens::BRACKET,\n@@ -643,16 +640,16 @@ fn semantic_token_type_and_modifiers(\n             HlMod::Consuming => semantic_tokens::CONSUMING,\n             HlMod::ControlFlow => semantic_tokens::CONTROL_FLOW,\n             HlMod::CrateRoot => semantic_tokens::CRATE_ROOT,\n-            HlMod::DefaultLibrary => lsp_types::SemanticTokenModifier::DEFAULT_LIBRARY,\n-            HlMod::Definition => lsp_types::SemanticTokenModifier::DECLARATION,\n-            HlMod::Documentation => lsp_types::SemanticTokenModifier::DOCUMENTATION,\n+            HlMod::DefaultLibrary => semantic_tokens::DEFAULT_LIBRARY,\n+            HlMod::Definition => semantic_tokens::DECLARATION,\n+            HlMod::Documentation => semantic_tokens::DOCUMENTATION,\n             HlMod::Injected => semantic_tokens::INJECTED,\n             HlMod::IntraDocLink => semantic_tokens::INTRA_DOC_LINK,\n             HlMod::Library => semantic_tokens::LIBRARY,\n             HlMod::Mutable => semantic_tokens::MUTABLE,\n             HlMod::Public => semantic_tokens::PUBLIC,\n             HlMod::Reference => semantic_tokens::REFERENCE,\n-            HlMod::Static => lsp_types::SemanticTokenModifier::STATIC,\n+            HlMod::Static => semantic_tokens::STATIC,\n             HlMod::Trait => semantic_tokens::TRAIT_MODIFIER,\n             HlMod::Unsafe => semantic_tokens::UNSAFE,\n         };"}, {"sha": "9909d71bdf066bd4117531998f054aeeaab45444", "filename": "src/tools/rust-analyzer/crates/stdx/src/hash.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Fhash.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -0,0 +1,80 @@\n+//! A none hashing [`Hasher`] implementation.\n+use std::{\n+    hash::{BuildHasher, Hasher},\n+    marker::PhantomData,\n+};\n+\n+pub type NoHashHashMap<K, V> = std::collections::HashMap<K, V, NoHashHasherBuilder<K>>;\n+pub type NoHashHashSet<K> = std::collections::HashSet<K, NoHashHasherBuilder<K>>;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct NoHashHasherBuilder<T>(PhantomData<T>);\n+\n+impl<T> Default for NoHashHasherBuilder<T> {\n+    fn default() -> Self {\n+        Self(Default::default())\n+    }\n+}\n+\n+pub trait NoHashHashable {}\n+impl NoHashHashable for usize {}\n+impl NoHashHashable for u32 {}\n+\n+pub struct NoHashHasher(u64);\n+\n+impl<T: NoHashHashable> BuildHasher for NoHashHasherBuilder<T> {\n+    type Hasher = NoHashHasher;\n+    fn build_hasher(&self) -> Self::Hasher {\n+        NoHashHasher(0)\n+    }\n+}\n+\n+impl Hasher for NoHashHasher {\n+    fn finish(&self) -> u64 {\n+        self.0\n+    }\n+\n+    fn write(&mut self, _: &[u8]) {\n+        unimplemented!(\"NoHashHasher should only be used for hashing primitive integers\")\n+    }\n+\n+    fn write_u8(&mut self, i: u8) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_u16(&mut self, i: u16) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_u32(&mut self, i: u32) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_u64(&mut self, i: u64) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_usize(&mut self, i: usize) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_i8(&mut self, i: i8) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_i16(&mut self, i: i16) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_i32(&mut self, i: i32) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_i64(&mut self, i: i64) {\n+        self.0 = i as u64;\n+    }\n+\n+    fn write_isize(&mut self, i: isize) {\n+        self.0 = i as u64;\n+    }\n+}"}, {"sha": "51e109798d1df3c22f119920424fd11969986936", "filename": "src/tools/rust-analyzer/crates/stdx/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Flib.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -7,6 +7,7 @@ use std::{cmp::Ordering, ops, time::Instant};\n use std::{io as sio, iter};\n \n mod macros;\n+pub mod hash;\n pub mod process;\n pub mod panic_context;\n pub mod non_empty_vec;"}, {"sha": "d7549a2841539bb1e9df66e5592d99b5d7c8a809", "filename": "src/tools/rust-analyzer/crates/vfs/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2FCargo.toml?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -12,6 +12,7 @@ doctest = false\n [dependencies]\n rustc-hash = \"1.1.0\"\n fst = \"0.4.7\"\n+indexmap = \"1.9.1\"\n \n paths = { path = \"../paths\", version = \"0.0.0\" }\n-indexmap = \"1.9.1\"\n+stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "e0ef737b3fc09efe338e12ac996d8faf3690134a", "filename": "src/tools/rust-analyzer/crates/vfs/src/file_set.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2Fsrc%2Ffile_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2Fsrc%2Ffile_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2Fsrc%2Ffile_set.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -6,14 +6,15 @@ use std::fmt;\n \n use fst::{IntoStreamer, Streamer};\n use rustc_hash::FxHashMap;\n+use stdx::hash::NoHashHashMap;\n \n use crate::{AnchoredPath, FileId, Vfs, VfsPath};\n \n /// A set of [`VfsPath`]s identified by [`FileId`]s.\n #[derive(Default, Clone, Eq, PartialEq)]\n pub struct FileSet {\n     files: FxHashMap<VfsPath, FileId>,\n-    paths: FxHashMap<FileId, VfsPath>,\n+    paths: NoHashHashMap<FileId, VfsPath>,\n }\n \n impl FileSet {"}, {"sha": "afc9a0fa6fb206b1a0c41024137639f016518697", "filename": "src/tools/rust-analyzer/crates/vfs/src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs%2Fsrc%2Flib.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -59,9 +59,16 @@ pub use paths::{AbsPath, AbsPathBuf};\n /// Handle to a file in [`Vfs`]\n ///\n /// Most functions in rust-analyzer use this when they need to refer to a file.\n-#[derive(Copy, Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]\n+#[derive(Copy, Clone, Debug, Ord, PartialOrd, Eq, PartialEq)]\n pub struct FileId(pub u32);\n \n+impl stdx::hash::NoHashHashable for FileId {}\n+impl std::hash::Hash for FileId {\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        self.0.hash(state);\n+    }\n+}\n+\n /// Storage for all files read by rust-analyzer.\n ///\n /// For more information see the [crate-level](crate) documentation."}, {"sha": "72b925726479e014c18142acb6b4546bffc2b2b8", "filename": "src/tools/rust-analyzer/docs/user/generated_config.adoc", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fgenerated_config.adoc?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -587,6 +587,52 @@ Enables the use of rustfmt's unstable range formatting command for the\n `textDocument/rangeFormatting` request. The rustfmt option is unstable and only\n available on a nightly build.\n --\n+[[rust-analyzer.semanticHighlighting.doc.comment.inject.enable]]rust-analyzer.semanticHighlighting.doc.comment.inject.enable (default: `true`)::\n++\n+--\n+Inject additional highlighting into doc comments.\n+\n+When enabled, rust-analyzer will highlight rust source in doc comments as well as intra\n+doc links.\n+--\n+[[rust-analyzer.semanticHighlighting.operator.enable]]rust-analyzer.semanticHighlighting.operator.enable (default: `true`)::\n++\n+--\n+Use semantic tokens for operators.\n+\n+When disabled, rust-analyzer will emit semantic tokens only for operator tokens when\n+they are tagged with modifiers.\n+--\n+[[rust-analyzer.semanticHighlighting.operator.specialization.enable]]rust-analyzer.semanticHighlighting.operator.specialization.enable (default: `false`)::\n++\n+--\n+Use specialized semantic tokens for operators.\n+\n+When enabled, rust-analyzer will emit special token types for operator tokens instead\n+of the generic `operator` token type.\n+--\n+[[rust-analyzer.semanticHighlighting.punctuation.enable]]rust-analyzer.semanticHighlighting.punctuation.enable (default: `false`)::\n++\n+--\n+Use semantic tokens for punctuations.\n+\n+When disabled, rust-analyzer will emit semantic tokens only for punctuation tokens when\n+they are tagged with modifiers or have a special role.\n+--\n+[[rust-analyzer.semanticHighlighting.punctuation.separate.macro.bang]]rust-analyzer.semanticHighlighting.punctuation.separate.macro.bang (default: `false`)::\n++\n+--\n+When enabled, rust-analyzer will emit a punctuation semantic token for the `!` of macro\n+calls.\n+--\n+[[rust-analyzer.semanticHighlighting.punctuation.specialization.enable]]rust-analyzer.semanticHighlighting.punctuation.specialization.enable (default: `false`)::\n++\n+--\n+Use specialized semantic tokens for punctuations.\n+\n+When enabled, rust-analyzer will emit special token types for punctuation tokens instead\n+of the generic `punctuation` token type.\n+--\n [[rust-analyzer.semanticHighlighting.strings.enable]]rust-analyzer.semanticHighlighting.strings.enable (default: `true`)::\n +\n --"}, {"sha": "9bd3b6a692b1a7514263ca06c4b39e97281f42df", "filename": "src/tools/rust-analyzer/docs/user/manual.adoc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -861,3 +861,14 @@ For example, if you want to run https://crates.io/crates/cargo-watch[`cargo watc\n     \"isBackground\": true\n }\n ```\n+\n+==== Live Share\n+\n+VS Code Live Share has partial support for rust-analyzer.\n+\n+Live Share _requires_ the official Microsoft build of VS Code, OSS builds will not work correctly.\n+\n+The host's rust-analyzer instance will be shared with all guests joining the session.\n+The guests do not have to have the rust-analyzer extension installed for this to work.\n+\n+If you are joining a Live Share session and _do_ have rust-analyzer installed locally, commands from the command palette will not work correctly since they will attempt to communicate with the local server."}, {"sha": "767c5875bf7e7e844c1178675ee082288ff1ac29", "filename": "src/tools/rust-analyzer/editors/code/package.json", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -1084,6 +1084,36 @@\n                     \"default\": false,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.semanticHighlighting.doc.comment.inject.enable\": {\n+                    \"markdownDescription\": \"Inject additional highlighting into doc comments.\\n\\nWhen enabled, rust-analyzer will highlight rust source in doc comments as well as intra\\ndoc links.\",\n+                    \"default\": true,\n+                    \"type\": \"boolean\"\n+                },\n+                \"rust-analyzer.semanticHighlighting.operator.enable\": {\n+                    \"markdownDescription\": \"Use semantic tokens for operators.\\n\\nWhen disabled, rust-analyzer will emit semantic tokens only for operator tokens when\\nthey are tagged with modifiers.\",\n+                    \"default\": true,\n+                    \"type\": \"boolean\"\n+                },\n+                \"rust-analyzer.semanticHighlighting.operator.specialization.enable\": {\n+                    \"markdownDescription\": \"Use specialized semantic tokens for operators.\\n\\nWhen enabled, rust-analyzer will emit special token types for operator tokens instead\\nof the generic `operator` token type.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n+                \"rust-analyzer.semanticHighlighting.punctuation.enable\": {\n+                    \"markdownDescription\": \"Use semantic tokens for punctuations.\\n\\nWhen disabled, rust-analyzer will emit semantic tokens only for punctuation tokens when\\nthey are tagged with modifiers or have a special role.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n+                \"rust-analyzer.semanticHighlighting.punctuation.separate.macro.bang\": {\n+                    \"markdownDescription\": \"When enabled, rust-analyzer will emit a punctuation semantic token for the `!` of macro\\ncalls.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n+                \"rust-analyzer.semanticHighlighting.punctuation.specialization.enable\": {\n+                    \"markdownDescription\": \"Use specialized semantic tokens for punctuations.\\n\\nWhen enabled, rust-analyzer will emit special token types for punctuation tokens instead\\nof the generic `punctuation` token type.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n                 \"rust-analyzer.semanticHighlighting.strings.enable\": {\n                     \"markdownDescription\": \"Use semantic tokens for strings.\\n\\nIn some editors (e.g. vscode) semantic tokens override other highlighting grammars.\\nBy disabling semantic tokens for strings, other grammars can be used to highlight\\ntheir contents.\",\n                     \"default\": true,"}, {"sha": "05d4d08f70b62d17436dcb32715011bb53449dd6", "filename": "src/tools/rust-analyzer/editors/code/src/client.ts", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -5,7 +5,6 @@ import * as Is from \"vscode-languageclient/lib/common/utils/is\";\n import { assert } from \"./util\";\n import { WorkspaceEdit } from \"vscode\";\n import { Workspace } from \"./ctx\";\n-import { updateConfig } from \"./config\";\n import { substituteVariablesInEnv } from \"./config\";\n import { outputChannel, traceOutputChannel } from \"./main\";\n import { randomUUID } from \"crypto\";\n@@ -86,11 +85,6 @@ export async function createClient(\n \n     let initializationOptions = vscode.workspace.getConfiguration(\"rust-analyzer\");\n \n-    // Update outdated user configs\n-    await updateConfig(initializationOptions).catch((err) => {\n-        void vscode.window.showErrorMessage(`Failed updating old config keys: ${err.message}`);\n-    });\n-\n     if (workspace.kind === \"Detached Files\") {\n         initializationOptions = {\n             detachedFiles: workspace.files.map((file) => file.uri.fsPath),\n@@ -105,22 +99,6 @@ export async function createClient(\n         traceOutputChannel: traceOutputChannel(),\n         outputChannel: outputChannel(),\n         middleware: {\n-            async handleDiagnostics(uri, diagnostics, next) {\n-                // Workaround for https://github.com/microsoft/vscode/issues/155531\n-                for (const diagnostic of diagnostics) {\n-                    if (!diagnostic.message) {\n-                        diagnostic.message = \" \";\n-                    }\n-                    if (diagnostic.relatedInformation) {\n-                        for (const relatedInformation of diagnostic.relatedInformation) {\n-                            if (!relatedInformation.message) {\n-                                relatedInformation.message = \" \";\n-                            }\n-                        }\n-                    }\n-                }\n-                next(uri, diagnostics);\n-            },\n             async provideHover(\n                 document: vscode.TextDocument,\n                 position: vscode.Position,"}, {"sha": "a9c0f079b3da9350eeb3624fbed5247b465da7d9", "filename": "src/tools/rust-analyzer/editors/code/src/config.ts", "status": "modified", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -3,8 +3,6 @@ import * as vscode from \"vscode\";\n import { Env } from \"./client\";\n import { log } from \"./util\";\n \n-export type UpdatesChannel = \"stable\" | \"nightly\";\n-\n export type RunnableEnvCfg =\n     | undefined\n     | Record<string, string>\n@@ -175,100 +173,6 @@ export class Config {\n     }\n }\n \n-export async function updateConfig(config: vscode.WorkspaceConfiguration) {\n-    const renames = [\n-        [\"assist.allowMergingIntoGlobImports\", \"imports.merge.glob\"],\n-        [\"assist.exprFillDefault\", \"assist.expressionFillDefault\"],\n-        [\"assist.importEnforceGranularity\", \"imports.granularity.enforce\"],\n-        [\"assist.importGranularity\", \"imports.granularity.group\"],\n-        [\"assist.importMergeBehavior\", \"imports.granularity.group\"],\n-        [\"assist.importMergeBehaviour\", \"imports.granularity.group\"],\n-        [\"assist.importGroup\", \"imports.group.enable\"],\n-        [\"assist.importPrefix\", \"imports.prefix\"],\n-        [\"primeCaches.enable\", \"cachePriming.enable\"],\n-        [\"cache.warmup\", \"cachePriming.enable\"],\n-        [\"cargo.loadOutDirsFromCheck\", \"cargo.buildScripts.enable\"],\n-        [\"cargo.runBuildScripts\", \"cargo.buildScripts.enable\"],\n-        [\"cargo.runBuildScriptsCommand\", \"cargo.buildScripts.overrideCommand\"],\n-        [\"cargo.useRustcWrapperForBuildScripts\", \"cargo.buildScripts.useRustcWrapper\"],\n-        [\"completion.snippets\", \"completion.snippets.custom\"],\n-        [\"diagnostics.enableExperimental\", \"diagnostics.experimental.enable\"],\n-        [\"experimental.procAttrMacros\", \"procMacro.attributes.enable\"],\n-        [\"highlighting.strings\", \"semanticHighlighting.strings.enable\"],\n-        [\"highlightRelated.breakPoints\", \"highlightRelated.breakPoints.enable\"],\n-        [\"highlightRelated.exitPoints\", \"highlightRelated.exitPoints.enable\"],\n-        [\"highlightRelated.yieldPoints\", \"highlightRelated.yieldPoints.enable\"],\n-        [\"highlightRelated.references\", \"highlightRelated.references.enable\"],\n-        [\"hover.documentation\", \"hover.documentation.enable\"],\n-        [\"hover.linksInHover\", \"hover.links.enable\"],\n-        [\"hoverActions.linksInHover\", \"hover.links.enable\"],\n-        [\"hoverActions.debug\", \"hover.actions.debug.enable\"],\n-        [\"hoverActions.enable\", \"hover.actions.enable.enable\"],\n-        [\"hoverActions.gotoTypeDef\", \"hover.actions.gotoTypeDef.enable\"],\n-        [\"hoverActions.implementations\", \"hover.actions.implementations.enable\"],\n-        [\"hoverActions.references\", \"hover.actions.references.enable\"],\n-        [\"hoverActions.run\", \"hover.actions.run.enable\"],\n-        [\"inlayHints.chainingHints\", \"inlayHints.chainingHints.enable\"],\n-        [\"inlayHints.closureReturnTypeHints\", \"inlayHints.closureReturnTypeHints.enable\"],\n-        [\"inlayHints.hideNamedConstructorHints\", \"inlayHints.typeHints.hideNamedConstructor\"],\n-        [\"inlayHints.parameterHints\", \"inlayHints.parameterHints.enable\"],\n-        [\"inlayHints.reborrowHints\", \"inlayHints.reborrowHints.enable\"],\n-        [\"inlayHints.typeHints\", \"inlayHints.typeHints.enable\"],\n-        [\"lruCapacity\", \"lru.capacity\"],\n-        [\"runnables.cargoExtraArgs\", \"runnables.extraArgs\"],\n-        [\"runnables.overrideCargo\", \"runnables.command\"],\n-        [\"rustcSource\", \"rustc.source\"],\n-        [\"rustfmt.enableRangeFormatting\", \"rustfmt.rangeFormatting.enable\"],\n-    ];\n-\n-    for (const [oldKey, newKey] of renames) {\n-        const inspect = config.inspect(oldKey);\n-        if (inspect !== undefined) {\n-            const valMatrix = [\n-                {\n-                    val: inspect.globalValue,\n-                    langVal: inspect.globalLanguageValue,\n-                    target: vscode.ConfigurationTarget.Global,\n-                },\n-                {\n-                    val: inspect.workspaceFolderValue,\n-                    langVal: inspect.workspaceFolderLanguageValue,\n-                    target: vscode.ConfigurationTarget.WorkspaceFolder,\n-                },\n-                {\n-                    val: inspect.workspaceValue,\n-                    langVal: inspect.workspaceLanguageValue,\n-                    target: vscode.ConfigurationTarget.Workspace,\n-                },\n-            ];\n-            for (const { val, langVal, target } of valMatrix) {\n-                const patch = (val: unknown) => {\n-                    // some of the updates we do only append \"enable\" or \"custom\"\n-                    // that means on the next run we would find these again, but as objects with\n-                    // these properties causing us to destroy the config\n-                    // so filter those already updated ones out\n-                    return (\n-                        val !== undefined &&\n-                        !(\n-                            typeof val === \"object\" &&\n-                            val !== null &&\n-                            (oldKey === \"completion.snippets\" || !val.hasOwnProperty(\"custom\"))\n-                        )\n-                    );\n-                };\n-                if (patch(val)) {\n-                    await config.update(newKey, val, target, false);\n-                    await config.update(oldKey, undefined, target, false);\n-                }\n-                if (patch(langVal)) {\n-                    await config.update(newKey, langVal, target, true);\n-                    await config.update(oldKey, undefined, target, true);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n export function substituteVariablesInEnv(env: Env): Env {\n     const missingDeps = new Set<string>();\n     // vscode uses `env:ENV_NAME` for env vars resolution, and it's easier"}, {"sha": "e9b62e0cc2578b876747093577439bfec057192e", "filename": "src/tools/rust-analyzer/editors/code/src/main.ts", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -33,7 +33,7 @@ export function outputChannel() {\n }\n \n export interface RustAnalyzerExtensionApi {\n-    client: lc.LanguageClient;\n+    client?: lc.LanguageClient;\n }\n \n export async function activate(\n@@ -48,6 +48,23 @@ export async function activate(\n }\n \n async function tryActivate(context: vscode.ExtensionContext): Promise<RustAnalyzerExtensionApi> {\n+    // We only support local folders, not eg. Live Share (`vlsl:` scheme), so don't activate if\n+    // only those are in use.\n+    // (r-a still somewhat works with Live Share, because commands are tunneled to the host)\n+    const folders = (vscode.workspace.workspaceFolders || []).filter(\n+        (folder) => folder.uri.scheme === \"file\"\n+    );\n+    const rustDocuments = vscode.workspace.textDocuments.filter((document) =>\n+        isRustDocument(document)\n+    );\n+\n+    if (folders.length === 0 && rustDocuments.length === 0) {\n+        // FIXME: Ideally we would choose not to activate at all (and avoid registering\n+        // non-functional editor commands), but VS Code doesn't seem to have a good way of doing\n+        // that\n+        return {};\n+    }\n+\n     const config = new Config(context);\n     const state = new PersistentState(context.globalState);\n     const serverPath = await bootstrap(context, config, state).catch((err) => {\n@@ -60,18 +77,11 @@ async function tryActivate(context: vscode.ExtensionContext): Promise<RustAnalyz\n         throw new Error(message);\n     });\n \n-    if ((vscode.workspace.workspaceFolders || []).length === 0) {\n-        const rustDocuments = vscode.workspace.textDocuments.filter((document) =>\n-            isRustDocument(document)\n-        );\n-        if (rustDocuments.length > 0) {\n-            ctx = await Ctx.create(config, context, serverPath, {\n-                kind: \"Detached Files\",\n-                files: rustDocuments,\n-            });\n-        } else {\n-            throw new Error(\"no rust files are opened\");\n-        }\n+    if (folders.length === 0) {\n+        ctx = await Ctx.create(config, context, serverPath, {\n+            kind: \"Detached Files\",\n+            files: rustDocuments,\n+        });\n     } else {\n         // Note: we try to start the server before we activate type hints so that it\n         // registers its `onDidChangeDocument` handler before us."}, {"sha": "36d728456f77c48248c34102ad2ab5f6fc1da12b", "filename": "src/tools/rust-analyzer/lib/lsp-server/src/socket.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2Fsrc%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/804029e0830e3c49cdced5da800c374575c7691a/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2Fsrc%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2Fsrc%2Fsocket.rs?ref=804029e0830e3c49cdced5da800c374575c7691a", "patch": "@@ -15,7 +15,7 @@ pub(crate) fn socket_transport(\n     stream: TcpStream,\n ) -> (Sender<Message>, Receiver<Message>, IoThreads) {\n     let (reader_receiver, reader) = make_reader(stream.try_clone().unwrap());\n-    let (writer_sender, writer) = make_write(stream.try_clone().unwrap());\n+    let (writer_sender, writer) = make_write(stream);\n     let io_threads = make_io_threads(reader, writer);\n     (writer_sender, reader_receiver, io_threads)\n }"}]}