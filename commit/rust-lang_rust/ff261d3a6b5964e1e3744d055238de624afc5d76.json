{"sha": "ff261d3a6b5964e1e3744d055238de624afc5d76", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMjYxZDNhNmI1OTY0ZTFlMzc0NGQwNTUyMzhkZTYyNGFmYzVkNzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-06T07:35:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-06T07:35:21Z"}, "message": "Auto merge of #38097 - Mark-Simulacrum:fn-sig-slice, r=eddyb\n\nRefactor ty::FnSig to contain a &'tcx Slice<Ty<'tcx>>\n\nWe refactor this in order to achieve the following wins:\n\n - Decrease the size of `FnSig` (`Vec` + `bool`: 32, `&Slice` + `bool`: 24).\n - Potentially decrease total allocated memory due to arena-allocating `FnSig` inputs/output; since they are allocated in the type list arena, other users of type lists can reuse the same allocation for an equivalent type list.\n - Remove the last part of the type system which needs drop glue (#37965 removed the other remaining part). This makes arenas containing `FnSig` faster to drop (since we don't need to drop a Vec for each one), and makes reusing them without clearing/dropping potentially possible.\n\nr? @eddyb", "tree": {"sha": "9560fef7b90152ce605f9c215e53ef94b9088b43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9560fef7b90152ce605f9c215e53ef94b9088b43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff261d3a6b5964e1e3744d055238de624afc5d76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff261d3a6b5964e1e3744d055238de624afc5d76", "html_url": "https://github.com/rust-lang/rust/commit/ff261d3a6b5964e1e3744d055238de624afc5d76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff261d3a6b5964e1e3744d055238de624afc5d76/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7c93c07b8533e1d38395cc2d9d37cd2d9bec978", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7c93c07b8533e1d38395cc2d9d37cd2d9bec978", "html_url": "https://github.com/rust-lang/rust/commit/f7c93c07b8533e1d38395cc2d9d37cd2d9bec978"}, {"sha": "296ec5f9b7bf5aec05ed6672d3499079d35e4594", "url": "https://api.github.com/repos/rust-lang/rust/commits/296ec5f9b7bf5aec05ed6672d3499079d35e4594", "html_url": "https://github.com/rust-lang/rust/commit/296ec5f9b7bf5aec05ed6672d3499079d35e4594"}], "stats": {"total": 555, "additions": 264, "deletions": 291}, "files": [{"sha": "2357549c82e081fedfaea3737221985ebe01a904", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -178,8 +178,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for ExprVisitor<'a, 'gcx, 'tcx> {\n                 let typ = self.infcx.tcx.tables().node_id_to_type(expr.id);\n                 match typ.sty {\n                     ty::TyFnDef(.., ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n-                        let from = bare_fn_ty.sig.0.inputs[0];\n-                        let to = bare_fn_ty.sig.0.output;\n+                        let from = bare_fn_ty.sig.skip_binder().inputs()[0];\n+                        let to = bare_fn_ty.sig.skip_binder().output();\n                         self.check_transmute(expr.span, from, to, expr.id);\n                     }\n                     _ => {"}, {"sha": "0d5c9b98941dc086a78eee65d3cd55e87c597589", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -241,12 +241,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // The `Self` type is erased, so it should not appear in list of\n         // arguments or return type apart from the receiver.\n         let ref sig = self.item_type(method.def_id).fn_sig();\n-        for &input_ty in &sig.0.inputs[1..] {\n+        for input_ty in &sig.skip_binder().inputs()[1..] {\n             if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);\n             }\n         }\n-        if self.contains_illegal_self_type_reference(trait_def_id, sig.0.output) {\n+        if self.contains_illegal_self_type_reference(trait_def_id, sig.output().skip_binder()) {\n             return Some(MethodViolationCode::ReferencesSelf);\n         }\n "}, {"sha": "23cfc2517590c1845b7a7f260dbc7a4a5a19d8c8", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -1368,21 +1368,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyFnDef(.., &ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: Abi::Rust,\n-                sig: ty::Binder(ty::FnSig {\n-                    inputs: _,\n-                    output: _,\n-                    variadic: false\n-                })\n+                ref sig,\n             }) |\n             ty::TyFnPtr(&ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: Abi::Rust,\n-                sig: ty::Binder(ty::FnSig {\n-                    inputs: _,\n-                    output: _,\n-                    variadic: false\n-                })\n-            }) => {\n+                ref sig\n+            }) if !sig.variadic() => {\n                 candidates.vec.push(FnPointerCandidate);\n             }\n "}, {"sha": "cebd8bf87d736cca88ae75bcf5917a22d5193da3", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -487,14 +487,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)>\n     {\n         let arguments_tuple = match tuple_arguments {\n-            TupleArgumentsFlag::No => sig.0.inputs[0],\n-            TupleArgumentsFlag::Yes => self.intern_tup(&sig.0.inputs[..]),\n+            TupleArgumentsFlag::No => sig.skip_binder().inputs()[0],\n+            TupleArgumentsFlag::Yes =>\n+                self.intern_tup(sig.skip_binder().inputs()),\n         };\n         let trait_ref = ty::TraitRef {\n             def_id: fn_trait_def_id,\n             substs: self.mk_substs_trait(self_ty, &[arguments_tuple]),\n         };\n-        ty::Binder((trait_ref, sig.0.output))\n+        ty::Binder((trait_ref, sig.skip_binder().output()))\n     }\n }\n "}, {"sha": "4854a14f733f552c89e10e3252e1cbdb72a792ec", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -1542,6 +1542,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn mk_fn_sig<I>(self, inputs: I, output: I::Item, variadic: bool)\n+        -> <I::Item as InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>>::Output\n+        where I: Iterator,\n+              I::Item: InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>\n+    {\n+        inputs.chain(iter::once(output)).intern_with(|xs| ty::FnSig {\n+            inputs_and_output: self.intern_type_list(xs),\n+            variadic: variadic\n+        })\n+    }\n+\n     pub fn mk_existential_predicates<I: InternAs<[ExistentialPredicate<'tcx>],\n                                      &'tcx Slice<ExistentialPredicate<'tcx>>>>(self, iter: I)\n                                      -> I::Output {"}, {"sha": "7b4d76ad4973e0ce7e3c635916cf559d025b07fd", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -81,7 +81,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             Some(TupleSimplifiedType(tys.len()))\n         }\n         ty::TyFnDef(.., ref f) | ty::TyFnPtr(ref f) => {\n-            Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n+            Some(FunctionSimplifiedType(f.sig.skip_binder().inputs().len()))\n         }\n         ty::TyProjection(_) | ty::TyParam(_) => {\n             if can_simplify_params {"}, {"sha": "a06d3ed6cf4fb093b6352f18a1ccd94111021dd6", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -180,8 +180,8 @@ impl FlagComputation {\n     fn add_fn_sig(&mut self, fn_sig: &ty::PolyFnSig) {\n         let mut computation = FlagComputation::new();\n \n-        computation.add_tys(&fn_sig.0.inputs);\n-        computation.add_ty(fn_sig.0.output);\n+        computation.add_tys(fn_sig.skip_binder().inputs());\n+        computation.add_ty(fn_sig.skip_binder().output());\n \n         self.add_bound_computation(&computation);\n     }"}, {"sha": "76c26d01ac8e2051d1658fb21f06bb75806939c5", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -18,8 +18,10 @@ use ty::subst::{Kind, Substs};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::error::{ExpectedFound, TypeError};\n use std::rc::Rc;\n+use std::iter;\n use syntax::abi;\n use hir as ast;\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n pub type RelateResult<'tcx, T> = Result<T, TypeError<'tcx>>;\n \n@@ -185,32 +187,28 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n                 expected_found(relation, &a.variadic, &b.variadic)));\n         }\n \n-        let inputs = relate_arg_vecs(relation,\n-                                     &a.inputs,\n-                                     &b.inputs)?;\n-        let output = relation.relate(&a.output, &b.output)?;\n+        if a.inputs().len() != b.inputs().len() {\n+            return Err(TypeError::ArgCount);\n+        }\n \n-        Ok(ty::FnSig {inputs: inputs,\n-                      output: output,\n-                      variadic: a.variadic})\n+        let inputs_and_output = a.inputs().iter().cloned()\n+            .zip(b.inputs().iter().cloned())\n+            .map(|x| (x, false))\n+            .chain(iter::once(((a.output(), b.output()), true)))\n+            .map(|((a, b), is_output)| {\n+                if is_output {\n+                    relation.relate(&a, &b)\n+                } else {\n+                    relation.relate_with_variance(ty::Contravariant, &a, &b)\n+                }\n+            }).collect::<Result<AccumulateVec<[_; 8]>, _>>()?;\n+        Ok(ty::FnSig {\n+            inputs_and_output: relation.tcx().intern_type_list(&inputs_and_output),\n+            variadic: a.variadic\n+        })\n     }\n }\n \n-fn relate_arg_vecs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n-                                      a_args: &[Ty<'tcx>],\n-                                      b_args: &[Ty<'tcx>])\n-                                      -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n-    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n-{\n-    if a_args.len() != b_args.len() {\n-        return Err(TypeError::ArgCount);\n-    }\n-\n-    a_args.iter().zip(b_args)\n-          .map(|(a, b)| relation.relate_with_variance(ty::Contravariant, a, b))\n-          .collect()\n-}\n-\n impl<'tcx> Relate<'tcx> for ast::Unsafety {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &ast::Unsafety,"}, {"sha": "0f0478bc8cdb0d8528f3402faa3b941635625522", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -232,14 +232,11 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n     type Lifted = ty::FnSig<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.inputs[..]).and_then(|inputs| {\n-            tcx.lift(&self.output).map(|output| {\n-                ty::FnSig {\n-                    inputs: inputs,\n-                    output: output,\n-                    variadic: self.variadic\n-                }\n-            })\n+        tcx.lift(&self.inputs_and_output).map(|x| {\n+            ty::FnSig {\n+                inputs_and_output: x,\n+                variadic: self.variadic\n+            }\n         })\n     }\n }\n@@ -589,17 +586,20 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::FnSig { inputs: self.inputs.fold_with(folder),\n-                    output: self.output.fold_with(folder),\n-                    variadic: self.variadic }\n+        let inputs_and_output = self.inputs_and_output.fold_with(folder);\n+        ty::FnSig {\n+            inputs_and_output: folder.tcx().intern_type_list(&inputs_and_output),\n+            variadic: self.variadic,\n+        }\n     }\n \n     fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_fn_sig(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.inputs.visit_with(visitor) || self.output.visit_with(visitor)\n+        self.inputs().iter().any(|i| i.visit_with(visitor)) ||\n+        self.output().visit_with(visitor)\n     }\n }\n "}, {"sha": "3b7c46ef7fe175c890b46700bcc3bff19cf12101", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -563,22 +563,31 @@ pub struct ClosureTy<'tcx> {\n /// - `variadic` indicates whether this is a variadic function. (only true for foreign fns)\n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct FnSig<'tcx> {\n-    pub inputs: Vec<Ty<'tcx>>,\n-    pub output: Ty<'tcx>,\n+    pub inputs_and_output: &'tcx Slice<Ty<'tcx>>,\n     pub variadic: bool\n }\n \n+impl<'tcx> FnSig<'tcx> {\n+    pub fn inputs(&self) -> &[Ty<'tcx>] {\n+        &self.inputs_and_output[..self.inputs_and_output.len() - 1]\n+    }\n+\n+    pub fn output(&self) -> Ty<'tcx> {\n+        self.inputs_and_output[self.inputs_and_output.len() - 1]\n+    }\n+}\n+\n pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n \n impl<'tcx> PolyFnSig<'tcx> {\n-    pub fn inputs(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n-        self.map_bound_ref(|fn_sig| fn_sig.inputs.clone())\n+    pub fn inputs(&self) -> Binder<&[Ty<'tcx>]> {\n+        Binder(self.skip_binder().inputs())\n     }\n     pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n-        self.map_bound_ref(|fn_sig| fn_sig.inputs[index])\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs()[index])\n     }\n     pub fn output(&self) -> ty::Binder<Ty<'tcx>> {\n-        self.map_bound_ref(|fn_sig| fn_sig.output.clone())\n+        self.map_bound_ref(|fn_sig| fn_sig.output().clone())\n     }\n     pub fn variadic(&self) -> bool {\n         self.skip_binder().variadic\n@@ -1243,7 +1252,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     }\n \n     // Type accessors for substructures of types\n-    pub fn fn_args(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n+    pub fn fn_args(&self) -> ty::Binder<&[Ty<'tcx>]> {\n         self.fn_sig().inputs()\n     }\n "}, {"sha": "e6db35cc3f5447b9f44c3f8306947b9fd4cccca2", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -530,7 +530,7 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tc\n                 self.hash(f.unsafety);\n                 self.hash(f.abi);\n                 self.hash(f.sig.variadic());\n-                self.hash(f.sig.inputs().skip_binder().len());\n+                self.hash(f.sig.skip_binder().inputs().len());\n             }\n             TyDynamic(ref data, ..) => {\n                 if let Some(p) = data.principal() {"}, {"sha": "3fa7a803141d1d51eafd5993f3d84aff4f42fa43", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -126,6 +126,6 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n }\n \n fn push_sig_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, sig: &ty::PolyFnSig<'tcx>) {\n-    stack.push(sig.0.output);\n-    stack.extend(sig.0.inputs.iter().cloned().rev());\n+    stack.push(sig.skip_binder().output());\n+    stack.extend(sig.skip_binder().inputs().iter().cloned().rev());\n }"}, {"sha": "38b38e5b49764b5bcf4c4d59b90b3bb089125d35", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -595,7 +595,7 @@ impl<'tcx> fmt::Debug for ty::InstantiatedPredicates<'tcx> {\n impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"fn\")?;\n-        fn_sig(f, &self.inputs, self.variadic, self.output)\n+        fn_sig(f, self.inputs(), self.variadic, self.output())\n     }\n }\n \n@@ -625,7 +625,7 @@ impl fmt::Debug for ty::RegionVid {\n \n impl<'tcx> fmt::Debug for ty::FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs, self.variadic, self.output)\n+        write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs(), self.variadic, self.output())\n     }\n }\n "}, {"sha": "b7cebe310730969a701e65e975328cdd9d2d8b9f", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -265,15 +265,10 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_fn(&self, input_tys: &[Ty<'tcx>], output_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let input_args = input_tys.iter().cloned().collect();\n         self.infcx.tcx.mk_fn_ptr(self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: hir::Unsafety::Normal,\n             abi: Abi::Rust,\n-            sig: ty::Binder(ty::FnSig {\n-                inputs: input_args,\n-                output: output_ty,\n-                variadic: false,\n-            }),\n+            sig: ty::Binder(self.infcx.tcx.mk_fn_sig(input_tys.iter().cloned(), output_ty, false)),\n         }))\n     }\n "}, {"sha": "ee6af643154fa9036b66eab463ef52dd099bb7ba", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -1084,8 +1084,8 @@ impl LateLintPass for MutableTransmutes {\n                 let typ = cx.tcx.tables().node_id_to_type(expr.id);\n                 match typ.sty {\n                     ty::TyFnDef(.., ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n-                        let from = bare_fn.sig.0.inputs[0];\n-                        let to = bare_fn.sig.0.output;\n+                        let from = bare_fn.sig.skip_binder().inputs()[0];\n+                        let to = bare_fn.sig.skip_binder().output();\n                         return Some((&from.sty, &to.sty));\n                     }\n                     _ => (),"}, {"sha": "6475166192a25a9fc199adbb97bd4aaa559fd781", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -603,16 +603,16 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 }\n \n                 let sig = cx.erase_late_bound_regions(&bare_fn.sig);\n-                if !sig.output.is_nil() {\n-                    let r = self.check_type_for_ffi(cache, sig.output);\n+                if !sig.output().is_nil() {\n+                    let r = self.check_type_for_ffi(cache, sig.output());\n                     match r {\n                         FfiSafe => {}\n                         _ => {\n                             return r;\n                         }\n                     }\n                 }\n-                for arg in sig.inputs {\n+                for arg in sig.inputs() {\n                     let r = self.check_type_for_ffi(cache, arg);\n                     match r {\n                         FfiSafe => {}\n@@ -678,12 +678,12 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         let sig = self.cx.tcx.item_type(def_id).fn_sig();\n         let sig = self.cx.tcx.erase_late_bound_regions(&sig);\n \n-        for (&input_ty, input_hir) in sig.inputs.iter().zip(&decl.inputs) {\n-            self.check_type_for_ffi_and_report_errors(input_hir.ty.span, &input_ty);\n+        for (input_ty, input_hir) in sig.inputs().iter().zip(&decl.inputs) {\n+            self.check_type_for_ffi_and_report_errors(input_hir.ty.span, input_ty);\n         }\n \n         if let hir::Return(ref ret_hir) = decl.output {\n-            let ret_ty = sig.output;\n+            let ret_ty = sig.output();\n             if !ret_ty.is_nil() {\n                 self.check_type_for_ffi_and_report_errors(ret_hir.span, ret_ty);\n             }"}, {"sha": "ffd9525933b4e5d6f24f43ea414b2ed1db316f2f", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -208,7 +208,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let diverges = match ty.sty {\n                     ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n                         // FIXME(canndrew): This is_never should probably be an is_uninhabited\n-                        f.sig.0.output.is_never()\n+                        f.sig.skip_binder().output().is_never()\n                     }\n                     _ => false\n                 };"}, {"sha": "bd4724159b4cb9ac53a1e535c1a529bfb388bf90", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -247,10 +247,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     span_bug!(expr.span, \"method call has late-bound regions\")\n                 });\n \n-                assert_eq!(sig.inputs.len(), 2);\n+                assert_eq!(sig.inputs().len(), 2);\n \n                 let tupled_args = Expr {\n-                    ty: sig.inputs[1],\n+                    ty: sig.inputs()[1],\n                     temp_lifetime: temp_lifetime,\n                     span: expr.span,\n                     kind: ExprKind::Tuple {"}, {"sha": "e2a516edbc8354ff69a7108d3ba416f03b98d832", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -238,14 +238,14 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n                 .iter()\n                 .enumerate()\n                 .map(|(index, arg)| {\n-                    (fn_sig.inputs[index], Some(&*arg.pat))\n+                    (fn_sig.inputs()[index], Some(&*arg.pat))\n                 });\n \n         let body = self.tcx.map.expr(body_id);\n \n         let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n         self.cx(MirSource::Fn(id)).build(|cx| {\n-            build::construct_fn(cx, id, arguments, abi, fn_sig.output, body)\n+            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)\n         });\n \n         intravisit::walk_fn(self, fk, decl, body_id, span, id);"}, {"sha": "4c86331a525766d5ca759642620a4fca7a94a861", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -506,15 +506,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         match *destination {\n             Some((ref dest, _)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                if let Err(terr) = self.sub_types(sig.output, dest_ty) {\n+                if let Err(terr) = self.sub_types(sig.output(), dest_ty) {\n                     span_mirbug!(self, term,\n                                  \"call dest mismatch ({:?} <- {:?}): {:?}\",\n-                                 dest_ty, sig.output, terr);\n+                                 dest_ty, sig.output(), terr);\n                 }\n             },\n             None => {\n                 // FIXME(canndrew): This is_never should probably be an is_uninhabited\n-                if !sig.output.is_never() {\n+                if !sig.output().is_never() {\n                     span_mirbug!(self, term, \"call to converging function {:?} w/o dest\", sig);\n                 }\n             },\n@@ -528,11 +528,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                          args: &[Operand<'tcx>])\n     {\n         debug!(\"check_call_inputs({:?}, {:?})\", sig, args);\n-        if args.len() < sig.inputs.len() ||\n-           (args.len() > sig.inputs.len() && !sig.variadic) {\n+        if args.len() < sig.inputs().len() ||\n+           (args.len() > sig.inputs().len() && !sig.variadic) {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n-        for (n, (fn_arg, op_arg)) in sig.inputs.iter().zip(args).enumerate() {\n+        for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n             let op_arg_ty = op_arg.ty(mir, self.tcx());\n             if let Err(terr) = self.sub_types(op_arg_ty, fn_arg) {\n                 span_mirbug!(self, term, \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n@@ -562,12 +562,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         // box_free takes a Box as a pointer. Allow for that.\n \n-        if sig.inputs.len() != 1 {\n+        if sig.inputs().len() != 1 {\n             span_mirbug!(self, term, \"box_free should take 1 argument\");\n             return;\n         }\n \n-        let pointee_ty = match sig.inputs[0].sty {\n+        let pointee_ty = match sig.inputs()[0].sty {\n             ty::TyRawPtr(mt) => mt.ty,\n             _ => {\n                 span_mirbug!(self, term, \"box_free should take a raw ptr\");"}, {"sha": "0ac853e99eecdba47d0fc66dd9ca0fe2054a825c", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -367,13 +367,13 @@ impl FnType {\n             Cdecl => llvm::CCallConv,\n         };\n \n-        let mut inputs = &sig.inputs[..];\n+        let mut inputs = sig.inputs();\n         let extra_args = if abi == RustCall {\n             assert!(!sig.variadic && extra_args.is_empty());\n \n-            match inputs[inputs.len() - 1].sty {\n+            match sig.inputs().last().unwrap().sty {\n                 ty::TyTuple(ref tupled_arguments) => {\n-                    inputs = &inputs[..inputs.len() - 1];\n+                    inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n                     &tupled_arguments[..]\n                 }\n                 _ => {\n@@ -428,7 +428,7 @@ impl FnType {\n             }\n         };\n \n-        let ret_ty = sig.output;\n+        let ret_ty = sig.output();\n         let mut ret = arg_of(ret_ty, true);\n \n         if !type_is_fat_ptr(ccx.tcx(), ret_ty) {\n@@ -569,7 +569,7 @@ impl FnType {\n             };\n             // Fat pointers are returned by-value.\n             if !self.ret.is_ignore() {\n-                if !type_is_fat_ptr(ccx.tcx(), sig.output) {\n+                if !type_is_fat_ptr(ccx.tcx(), sig.output()) {\n                     fixup(&mut self.ret);\n                 }\n             }"}, {"sha": "867e4dce19aca30a06f6a15350cb9fdc977538ad", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -1077,8 +1077,8 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n         let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n         let mut arg_idx = 0;\n-        for (i, arg_ty) in sig.inputs.into_iter().enumerate() {\n-            let lldestptr = adt::trans_field_ptr(bcx, sig.output, dest_val, Disr::from(disr), i);\n+        for (i, arg_ty) in sig.inputs().iter().enumerate() {\n+            let lldestptr = adt::trans_field_ptr(bcx, sig.output(), dest_val, Disr::from(disr), i);\n             let arg = &fcx.fn_ty.args[arg_idx];\n             arg_idx += 1;\n             let b = &bcx.build();\n@@ -1091,7 +1091,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 arg.store_fn_arg(b, &mut llarg_idx, lldestptr);\n             }\n         }\n-        adt::trans_set_discr(bcx, sig.output, dest, disr);\n+        adt::trans_set_discr(bcx, sig.output(), dest, disr);\n     }\n \n     fcx.finish(bcx, DebugLoc::None);"}, {"sha": "7fb57dc19fcf995201b7113eabe83a9683166cc5", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -38,6 +38,7 @@ use type_of;\n use Disr;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::hir;\n+use std::iter;\n \n use syntax_pos::DUMMY_SP;\n \n@@ -329,7 +330,11 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Make a version with the type of by-ref closure.\n     let ty::ClosureTy { unsafety, abi, mut sig } = tcx.closure_type(def_id, substs);\n-    sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n+    sig.0 = tcx.mk_fn_sig(\n+        iter::once(ref_closure_ty).chain(sig.0.inputs().iter().cloned()),\n+        sig.0.output(),\n+        sig.0.variadic\n+    );\n     let llref_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: unsafety,\n         abi: abi,\n@@ -342,7 +347,11 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     // Make a version of the closure type with the same arguments, but\n     // with argument #0 being by value.\n     assert_eq!(abi, Abi::RustCall);\n-    sig.0.inputs[0] = closure_ty;\n+    sig.0 = tcx.mk_fn_sig(\n+        iter::once(closure_ty).chain(sig.0.inputs().iter().skip(1).cloned()),\n+        sig.0.output(),\n+        sig.0.variadic\n+    );\n \n     let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n     let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n@@ -491,13 +500,12 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n         }\n     };\n     let sig = tcx.erase_late_bound_regions_and_normalize(sig);\n-    let tuple_input_ty = tcx.intern_tup(&sig.inputs[..]);\n-    let sig = ty::FnSig {\n-        inputs: vec![bare_fn_ty_maybe_ref,\n-                     tuple_input_ty],\n-        output: sig.output,\n-        variadic: false\n-    };\n+    let tuple_input_ty = tcx.intern_tup(sig.inputs());\n+    let sig = tcx.mk_fn_sig(\n+        [bare_fn_ty_maybe_ref, tuple_input_ty].iter().cloned(),\n+        sig.output(),\n+        false\n+    );\n     let fn_ty = FnType::new(ccx, Abi::RustCall, &sig, &[]);\n     let tuple_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: hir::Unsafety::Normal,"}, {"sha": "b1d61cea39ceceaaad7b2164e6c62dcfc1956633", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -418,11 +418,11 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         let ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: hir::Unsafety::Unsafe,\n             abi: Abi::C,\n-            sig: ty::Binder(ty::FnSig {\n-                inputs: vec![tcx.mk_mut_ptr(tcx.types.u8)],\n-                output: tcx.types.never,\n-                variadic: false\n-            }),\n+            sig: ty::Binder(tcx.mk_fn_sig(\n+                iter::once(tcx.mk_mut_ptr(tcx.types.u8)),\n+                tcx.types.never,\n+                false\n+            )),\n         }));\n \n         let unwresume = ccx.eh_unwind_resume();\n@@ -1091,10 +1091,11 @@ pub fn ty_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 ty::ClosureKind::FnOnce => ty,\n             };\n \n-            let sig = sig.map_bound(|sig| ty::FnSig {\n-                inputs: iter::once(env_ty).chain(sig.inputs).collect(),\n-                ..sig\n-            });\n+            let sig = sig.map_bound(|sig| tcx.mk_fn_sig(\n+                iter::once(env_ty).chain(sig.inputs().iter().cloned()),\n+                sig.output(),\n+                sig.variadic\n+            ));\n             Cow::Owned(ty::BareFnTy { unsafety: unsafety, abi: abi, sig: sig })\n         }\n         _ => bug!(\"unexpected type {:?} to ty_fn_sig\", ty)"}, {"sha": "cda9fa46f1754d91464fafddf61e493f834ba348", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -390,16 +390,16 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n {\n     let signature = cx.tcx().erase_late_bound_regions(signature);\n \n-    let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n+    let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs().len() + 1);\n \n     // return type\n-    signature_metadata.push(match signature.output.sty {\n+    signature_metadata.push(match signature.output().sty {\n         ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n-        _ => type_metadata(cx, signature.output, span)\n+        _ => type_metadata(cx, signature.output(), span)\n     });\n \n     // regular arguments\n-    for &argument_type in &signature.inputs {\n+    for &argument_type in signature.inputs() {\n         signature_metadata.push(type_metadata(cx, argument_type, span));\n     }\n "}, {"sha": "aab70ab252a7fb301980631f0b031970bede74bf", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -308,27 +308,27 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             return create_DIArray(DIB(cx), &[]);\n         }\n \n-        let mut signature = Vec::with_capacity(sig.inputs.len() + 1);\n+        let mut signature = Vec::with_capacity(sig.inputs().len() + 1);\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n-        signature.push(match sig.output.sty {\n+        signature.push(match sig.output().sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => ptr::null_mut(),\n-            _ => type_metadata(cx, sig.output, syntax_pos::DUMMY_SP)\n+            _ => type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP)\n         });\n \n         let inputs = if abi == Abi::RustCall {\n-            &sig.inputs[..sig.inputs.len()-1]\n+            &sig.inputs()[..sig.inputs().len() - 1]\n         } else {\n-            &sig.inputs[..]\n+            sig.inputs()\n         };\n \n         // Arguments types\n         for &argument_type in inputs {\n             signature.push(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP));\n         }\n \n-        if abi == Abi::RustCall && !sig.inputs.is_empty() {\n-            if let ty::TyTuple(args) = sig.inputs[sig.inputs.len() - 1].sty {\n+        if abi == Abi::RustCall && !sig.inputs().is_empty() {\n+            if let ty::TyTuple(args) = sig.inputs()[sig.inputs().len() - 1].sty {\n                 for &argument_type in args {\n                     signature.push(type_metadata(cx, argument_type, syntax_pos::DUMMY_SP));\n                 }"}, {"sha": "788ce32937d847a8a9697ec9bd915eddc659aecc", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -116,8 +116,8 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             output.push_str(\"fn(\");\n \n             let sig = cx.tcx().erase_late_bound_regions_and_normalize(sig);\n-            if !sig.inputs.is_empty() {\n-                for &parameter_type in &sig.inputs {\n+            if !sig.inputs().is_empty() {\n+                for &parameter_type in sig.inputs() {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n                     output.push_str(\", \");\n                 }\n@@ -126,7 +126,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n \n             if sig.variadic {\n-                if !sig.inputs.is_empty() {\n+                if !sig.inputs().is_empty() {\n                     output.push_str(\", ...\");\n                 } else {\n                     output.push_str(\"...\");\n@@ -135,9 +135,9 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push(')');\n \n-            if !sig.output.is_nil() {\n+            if !sig.output().is_nil() {\n                 output.push_str(\" -> \");\n-                push_debuginfo_type_name(cx, sig.output, true, output);\n+                push_debuginfo_type_name(cx, sig.output(), true, output);\n             }\n         },\n         ty::TyClosure(..) => {"}, {"sha": "9bf023fc18936e4ca0517df93df0d92db8316408", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -124,7 +124,7 @@ pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n     let llfn = declare_raw_fn(ccx, name, fty.cconv, fty.llvm_type(ccx));\n \n     // FIXME(canndrew): This is_never should really be an is_uninhabited\n-    if sig.output.is_never() {\n+    if sig.output().is_never() {\n         llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n     }\n "}, {"sha": "577ffbad1348ba07673018c6958c0f04bdeeef32", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -36,6 +36,7 @@ use rustc::session::Session;\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::cmp::Ordering;\n+use std::iter;\n \n fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n     let llvm_name = match name {\n@@ -105,8 +106,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     };\n \n     let sig = tcx.erase_late_bound_regions_and_normalize(&fty.sig);\n-    let arg_tys = sig.inputs;\n-    let ret_ty = sig.output;\n+    let arg_tys = sig.inputs();\n+    let ret_ty = sig.output();\n     let name = &*tcx.item_name(def_id).as_str();\n \n     let span = match call_debug_location {\n@@ -674,7 +675,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 // again to find them and extract the arguments\n                 intr.inputs.iter()\n                            .zip(llargs)\n-                           .zip(&arg_tys)\n+                           .zip(arg_tys)\n                            .flat_map(|((t, llarg), ty)| modify_as_needed(bcx, t, ty, *llarg))\n                            .collect()\n             };\n@@ -1012,11 +1013,7 @@ fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n                     trans: &mut for<'b> FnMut(Block<'b, 'tcx>))\n                     -> ValueRef {\n     let ccx = fcx.ccx;\n-    let sig = ty::FnSig {\n-        inputs: inputs,\n-        output: output,\n-        variadic: false,\n-    };\n+    let sig = ccx.tcx().mk_fn_sig(inputs.into_iter(), output, false);\n     let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n \n     let rust_fn_ty = ccx.tcx().mk_fn_ptr(ccx.tcx().mk_bare_fn(ty::BareFnTy {\n@@ -1051,11 +1048,7 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     let fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: hir::Unsafety::Unsafe,\n         abi: Abi::Rust,\n-        sig: ty::Binder(ty::FnSig {\n-            inputs: vec![i8p],\n-            output: tcx.mk_nil(),\n-            variadic: false,\n-        }),\n+        sig: ty::Binder(tcx.mk_fn_sig(iter::once(i8p), tcx.mk_nil(), false)),\n     }));\n     let output = tcx.types.i32;\n     let rust_try = gen_fn(fcx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n@@ -1108,7 +1101,7 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n \n     let tcx = bcx.tcx();\n     let sig = tcx.erase_late_bound_regions_and_normalize(callee_ty.fn_sig());\n-    let arg_tys = sig.inputs;\n+    let arg_tys = sig.inputs();\n \n     // every intrinsic takes a SIMD vector as its first argument\n     require_simd!(arg_tys[0], \"input\");"}, {"sha": "76f5f32b5dcff70b93c6bfface74d8d80b47803c", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -453,7 +453,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     return;\n                 }\n \n-                let extra_args = &args[sig.inputs.len()..];\n+                let extra_args = &args[sig.inputs().len()..];\n                 let extra_args = extra_args.iter().map(|op_arg| {\n                     let op_ty = op_arg.ty(&self.mir, bcx.tcx());\n                     bcx.monomorphize(&op_ty)\n@@ -546,7 +546,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             // Make a fake operand for store_return\n                             let op = OperandRef {\n                                 val: Ref(dst),\n-                                ty: sig.output,\n+                                ty: sig.output(),\n                             };\n                             self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n                         }\n@@ -584,7 +584,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             debug_loc.apply_to_bcx(ret_bcx);\n                             let op = OperandRef {\n                                 val: Immediate(invokeret),\n-                                ty: sig.output,\n+                                ty: sig.output(),\n                             };\n                             self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n                         });\n@@ -595,7 +595,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     if let Some((_, target)) = *destination {\n                         let op = OperandRef {\n                             val: Immediate(llret),\n-                            ty: sig.output,\n+                            ty: sig.output(),\n                         };\n                         self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n                         funclet_br(self, bcx, target);"}, {"sha": "214eaeb817f302b24011f9603d5899aa1bf022cc", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -187,11 +187,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         assert_eq!(dg.ty(), glue::get_drop_glue_type(tcx, dg.ty()));\n         let t = dg.ty();\n \n-        let sig = ty::FnSig {\n-            inputs: vec![tcx.mk_mut_ptr(tcx.types.i8)],\n-            output: tcx.mk_nil(),\n-            variadic: false,\n-        };\n+        let sig = tcx.mk_fn_sig(iter::once(tcx.mk_mut_ptr(tcx.types.i8)), tcx.mk_nil(), false);\n \n         // Create a FnType for fn(*mut i8) and substitute the real type in\n         // later - that prevents FnType from splitting fat pointers up.\n@@ -480,23 +476,19 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n                 output.push_str(\"fn(\");\n \n-                let ty::FnSig {\n-                    inputs: sig_inputs,\n-                    output: sig_output,\n-                    variadic: sig_variadic\n-                } = self.tcx.erase_late_bound_regions_and_normalize(sig);\n+                let sig = self.tcx.erase_late_bound_regions_and_normalize(sig);\n \n-                if !sig_inputs.is_empty() {\n-                    for &parameter_type in &sig_inputs {\n+                if !sig.inputs().is_empty() {\n+                    for &parameter_type in sig.inputs() {\n                         self.push_type_name(parameter_type, output);\n                         output.push_str(\", \");\n                     }\n                     output.pop();\n                     output.pop();\n                 }\n \n-                if sig_variadic {\n-                    if !sig_inputs.is_empty() {\n+                if sig.variadic {\n+                    if !sig.inputs().is_empty() {\n                         output.push_str(\", ...\");\n                     } else {\n                         output.push_str(\"...\");\n@@ -505,9 +497,9 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n                 output.push(')');\n \n-                if !sig_output.is_nil() {\n+                if !sig.output().is_nil() {\n                     output.push_str(\" -> \");\n-                    self.push_type_name(sig_output, output);\n+                    self.push_type_name(sig.output(), output);\n                 }\n             },\n             ty::TyClosure(def_id, ref closure_substs) => {"}, {"sha": "d458c7c009e2ee8fccce3fd31a9d326781a6a7d6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -1595,7 +1595,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // checking for here would be considered early bound\n                 // anyway.)\n                 let inputs = bare_fn_ty.sig.inputs();\n-                let late_bound_in_args = tcx.collect_constrained_late_bound_regions(&inputs);\n+                let late_bound_in_args = tcx.collect_constrained_late_bound_regions(\n+                    &inputs.map_bound(|i| i.to_owned()));\n                 let output = bare_fn_ty.sig.output();\n                 let late_bound_in_ret = tcx.collect_referenced_late_bound_regions(&output);\n                 for br in late_bound_in_ret.difference(&late_bound_in_args) {\n@@ -1795,19 +1796,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::DefaultReturn(..) => self.tcx().mk_nil(),\n         };\n \n-        let input_tys = self_ty.into_iter().chain(arg_tys).collect();\n-\n-        debug!(\"ty_of_method_or_bare_fn: input_tys={:?}\", input_tys);\n         debug!(\"ty_of_method_or_bare_fn: output_ty={:?}\", output_ty);\n \n         self.tcx().mk_bare_fn(ty::BareFnTy {\n             unsafety: unsafety,\n             abi: abi,\n-            sig: ty::Binder(ty::FnSig {\n-                inputs: input_tys,\n-                output: output_ty,\n-                variadic: decl.variadic\n-            }),\n+            sig: ty::Binder(self.tcx().mk_fn_sig(\n+                self_ty.into_iter().chain(arg_tys),\n+                output_ty,\n+                decl.variadic\n+            )),\n         })\n     }\n \n@@ -1849,20 +1847,20 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // that function type\n         let rb = rscope::BindingRscope::new();\n \n-        let input_tys: Vec<_> = decl.inputs.iter().enumerate().map(|(i, a)| {\n+        let input_tys = decl.inputs.iter().enumerate().map(|(i, a)| {\n             let expected_arg_ty = expected_sig.as_ref().and_then(|e| {\n                 // no guarantee that the correct number of expected args\n                 // were supplied\n-                if i < e.inputs.len() {\n-                    Some(e.inputs[i])\n+                if i < e.inputs().len() {\n+                    Some(e.inputs()[i])\n                 } else {\n                     None\n                 }\n             });\n             self.ty_of_arg(&rb, a, expected_arg_ty)\n-        }).collect();\n+        });\n \n-        let expected_ret_ty = expected_sig.map(|e| e.output);\n+        let expected_ret_ty = expected_sig.as_ref().map(|e| e.output());\n \n         let is_infer = match decl.output {\n             hir::Return(ref output) if output.node == hir::TyInfer => true,\n@@ -1879,15 +1877,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::DefaultReturn(..) => bug!(),\n         };\n \n-        debug!(\"ty_of_closure: input_tys={:?}\", input_tys);\n         debug!(\"ty_of_closure: output_ty={:?}\", output_ty);\n \n         ty::ClosureTy {\n             unsafety: unsafety,\n             abi: abi,\n-            sig: ty::Binder(ty::FnSig {inputs: input_tys,\n-                                       output: output_ty,\n-                                       variadic: decl.variadic}),\n+            sig: ty::Binder(self.tcx().mk_fn_sig(input_tys, output_ty, decl.variadic)),\n         }\n     }\n "}, {"sha": "4fba29def226c6eb0a0ed0fa359962e245eac116", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -237,11 +237,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // This is the \"default\" function signature, used in case of error.\n                 // In that case, we check each argument against \"error\" in order to\n                 // set up all the node type bindings.\n-                error_fn_sig = ty::Binder(ty::FnSig {\n-                    inputs: self.err_args(arg_exprs.len()),\n-                    output: self.tcx.types.err,\n-                    variadic: false,\n-                });\n+                error_fn_sig = ty::Binder(self.tcx.mk_fn_sig(\n+                    self.err_args(arg_exprs.len()).into_iter(),\n+                    self.tcx.types.err,\n+                    false,\n+                ));\n \n                 (&error_fn_sig, None)\n             }\n@@ -261,17 +261,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let expected_arg_tys =\n             self.expected_types_for_fn_args(call_expr.span,\n                                             expected,\n-                                            fn_sig.output,\n-                                            &fn_sig.inputs);\n+                                            fn_sig.output(),\n+                                            fn_sig.inputs());\n         self.check_argument_types(call_expr.span,\n-                                  &fn_sig.inputs,\n+                                  fn_sig.inputs(),\n                                   &expected_arg_tys[..],\n                                   arg_exprs,\n                                   fn_sig.variadic,\n                                   TupleArgumentsFlag::DontTupleArguments,\n                                   def_span);\n \n-        fn_sig.output\n+        fn_sig.output()\n     }\n \n     fn confirm_deferred_closure_call(&self,\n@@ -287,18 +287,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let expected_arg_tys = self.expected_types_for_fn_args(call_expr.span,\n                                                                expected,\n-                                                               fn_sig.output.clone(),\n-                                                               &fn_sig.inputs);\n+                                                               fn_sig.output().clone(),\n+                                                               fn_sig.inputs());\n \n         self.check_argument_types(call_expr.span,\n-                                  &fn_sig.inputs,\n+                                  fn_sig.inputs(),\n                                   &expected_arg_tys,\n                                   arg_exprs,\n                                   fn_sig.variadic,\n                                   TupleArgumentsFlag::TupleArguments,\n                                   None);\n \n-        fn_sig.output\n+        fn_sig.output()\n     }\n \n     fn confirm_overloaded_call(&self,\n@@ -365,12 +365,12 @@ impl<'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> for CallResolution<'gcx, 'tc\n \n                 debug!(\"attempt_resolution: method_callee={:?}\", method_callee);\n \n-                for (&method_arg_ty, &self_arg_ty) in\n-                    method_sig.inputs[1..].iter().zip(&self.fn_sig.inputs) {\n-                    fcx.demand_eqtype(self.call_expr.span, self_arg_ty, method_arg_ty);\n+                for (method_arg_ty, self_arg_ty) in\n+                    method_sig.inputs().iter().skip(1).zip(self.fn_sig.inputs()) {\n+                    fcx.demand_eqtype(self.call_expr.span, &self_arg_ty, &method_arg_ty);\n                 }\n \n-                fcx.demand_eqtype(self.call_expr.span, method_sig.output, self.fn_sig.output);\n+                fcx.demand_eqtype(self.call_expr.span, method_sig.output(), self.fn_sig.output());\n \n                 fcx.write_overloaded_call_method_map(self.call_expr, method_callee);\n             }"}, {"sha": "142a8b971110df2fc9a72e79a9c2ffb732a225a7", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -15,6 +15,7 @@ use super::{check_fn, Expectation, FnCtxt};\n use astconv::AstConv;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n use std::cmp;\n+use std::iter;\n use syntax::abi::Abi;\n use rustc::hir;\n \n@@ -86,7 +87,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `closures` table.\n-        fn_ty.sig.0.inputs = vec![self.tcx.intern_tup(&fn_ty.sig.0.inputs[..])];\n+        fn_ty.sig.0 = self.tcx.mk_fn_sig(\n+            iter::once(self.tcx.intern_tup(fn_ty.sig.skip_binder().inputs())),\n+            fn_ty.sig.skip_binder().output(),\n+            fn_ty.sig.variadic()\n+        );\n \n         debug!(\"closure for {:?} --> sig={:?} opt_kind={:?}\",\n                expr_def_id,\n@@ -212,23 +217,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                arg_param_ty);\n \n         let input_tys = match arg_param_ty.sty {\n-            ty::TyTuple(tys) => tys.to_vec(),\n+            ty::TyTuple(tys) => tys.into_iter(),\n             _ => {\n                 return None;\n             }\n         };\n-        debug!(\"deduce_sig_from_projection: input_tys {:?}\", input_tys);\n \n         let ret_param_ty = projection.0.ty;\n         let ret_param_ty = self.resolve_type_vars_if_possible(&ret_param_ty);\n-        debug!(\"deduce_sig_from_projection: ret_param_ty {:?}\",\n-               ret_param_ty);\n+        debug!(\"deduce_sig_from_projection: ret_param_ty {:?}\", ret_param_ty);\n \n-        let fn_sig = ty::FnSig {\n-            inputs: input_tys,\n-            output: ret_param_ty,\n-            variadic: false,\n-        };\n+        let fn_sig = self.tcx.mk_fn_sig(input_tys.cloned(), ret_param_ty, false);\n         debug!(\"deduce_sig_from_projection: fn_sig {:?}\", fn_sig);\n \n         Some(fn_sig)"}, {"sha": "e85dac1a44c4438f8dc932febbf45b60dadf61fa", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -495,8 +495,8 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                         _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m),\n                     };\n \n-                let impl_iter = impl_sig.inputs.iter();\n-                let trait_iter = trait_sig.inputs.iter();\n+                let impl_iter = impl_sig.inputs().iter();\n+                let trait_iter = trait_sig.inputs().iter();\n                 impl_iter.zip(trait_iter)\n                          .zip(impl_m_iter)\n                          .zip(trait_m_iter)\n@@ -508,7 +508,8 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                          })\n                          .next()\n                          .unwrap_or_else(|| {\n-                             if infcx.sub_types(false, &cause, impl_sig.output, trait_sig.output)\n+                             if infcx.sub_types(false, &cause, impl_sig.output(),\n+                                                trait_sig.output())\n                                      .is_err() {\n                                          (impl_m_output.span(), Some(trait_m_output.span()))\n                                      } else {\n@@ -681,9 +682,9 @@ fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     };\n     let impl_m_fty = m_fty(impl_m);\n     let trait_m_fty = m_fty(trait_m);\n-    if impl_m_fty.sig.0.inputs.len() != trait_m_fty.sig.0.inputs.len() {\n-        let trait_number_args = trait_m_fty.sig.0.inputs.len();\n-        let impl_number_args = impl_m_fty.sig.0.inputs.len();\n+    let trait_number_args = trait_m_fty.sig.inputs().skip_binder().len();\n+    let impl_number_args = impl_m_fty.sig.inputs().skip_binder().len();\n+    if trait_number_args != impl_number_args {\n         let trait_m_node_id = tcx.map.as_local_node_id(trait_m.def_id);\n         let trait_span = if let Some(trait_id) = trait_m_node_id {\n             match tcx.map.expect_trait_item(trait_id).node {"}, {"sha": "183a2a48ff523664a30cf9dd0d165bdefb64244c", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -14,7 +14,6 @@\n use intrinsics;\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n use rustc::ty::subst::Substs;\n-use rustc::ty::FnSig;\n use rustc::ty::{self, Ty};\n use rustc::util::nodemap::FxHashMap;\n use {CrateCtxt, require_same_types};\n@@ -26,6 +25,8 @@ use syntax_pos::Span;\n \n use rustc::hir;\n \n+use std::iter;\n+\n fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    it: &hir::ForeignItem,\n                                    n_tps: usize,\n@@ -42,11 +43,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let fty = tcx.mk_fn_def(def_id, substs, tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: hir::Unsafety::Unsafe,\n         abi: abi,\n-        sig: ty::Binder(FnSig {\n-            inputs: inputs,\n-            output: output,\n-            variadic: false,\n-        }),\n+        sig: ty::Binder(tcx.mk_fn_sig(inputs.into_iter(), output, false)),\n     }));\n     let i_n_tps = tcx.item_generics(def_id).types.len();\n     if i_n_tps != n_tps {\n@@ -299,11 +296,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                 let fn_ty = tcx.mk_bare_fn(ty::BareFnTy {\n                     unsafety: hir::Unsafety::Normal,\n                     abi: Abi::Rust,\n-                    sig: ty::Binder(FnSig {\n-                        inputs: vec![mut_u8],\n-                        output: tcx.mk_nil(),\n-                        variadic: false,\n-                    }),\n+                    sig: ty::Binder(tcx.mk_fn_sig(iter::once(mut_u8), tcx.mk_nil(), false)),\n                 });\n                 (0, vec![tcx.mk_fn_ptr(fn_ty), mut_u8, mut_u8], tcx.types.i32)\n             }\n@@ -377,21 +370,21 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n \n                     let sig = tcx.item_type(def_id).fn_sig();\n                     let sig = tcx.no_late_bound_regions(sig).unwrap();\n-                    if intr.inputs.len() != sig.inputs.len() {\n+                    if intr.inputs.len() != sig.inputs().len() {\n                         span_err!(tcx.sess, it.span, E0444,\n                                   \"platform-specific intrinsic has invalid number of \\\n                                    arguments: found {}, expected {}\",\n-                                  sig.inputs.len(), intr.inputs.len());\n+                                  sig.inputs().len(), intr.inputs.len());\n                         return\n                     }\n-                    let input_pairs = intr.inputs.iter().zip(&sig.inputs);\n+                    let input_pairs = intr.inputs.iter().zip(sig.inputs());\n                     for (i, (expected_arg, arg)) in input_pairs.enumerate() {\n                         match_intrinsic_type_to_type(ccx, &format!(\"argument {}\", i + 1), it.span,\n                                                      &mut structural_to_nomimal, expected_arg, arg);\n                     }\n                     match_intrinsic_type_to_type(ccx, \"return value\", it.span,\n                                                  &mut structural_to_nomimal,\n-                                                 &intr.output, sig.output);\n+                                                 &intr.output, sig.output());\n                     return\n                 }\n                 None => {"}, {"sha": "b29eab780e0355df72e290dc5d79dfea719ac727", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                     infer::FnCall,\n                                                                     &fty.sig).0;\n         let fn_sig = self.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n-        let transformed_self_ty = fn_sig.inputs[0];\n+        let transformed_self_ty = fn_sig.inputs()[0];\n         let method_ty = tcx.mk_fn_def(def_id, trait_ref.substs,\n                                       tcx.mk_bare_fn(ty::BareFnTy {\n             sig: ty::Binder(fn_sig),"}, {"sha": "1b35081d5241c7909a5fdd6960cd12ceb56fdc85", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -785,18 +785,18 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n-    let mut fcx = FnCtxt::new(inherited, fn_sig.output, body.id);\n+    let mut fcx = FnCtxt::new(inherited, fn_sig.output(), body.id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(unsafety, unsafety_id);\n \n     fcx.require_type_is_sized(fcx.ret_ty, decl.output.span(), traits::ReturnType);\n     fcx.ret_ty = fcx.instantiate_anon_types(&fcx.ret_ty);\n-    fn_sig.output = fcx.ret_ty;\n+    fn_sig = fcx.tcx.mk_fn_sig(fn_sig.inputs().iter().cloned(), &fcx.ret_ty, fn_sig.variadic);\n \n     {\n         let mut visit = GatherLocalsVisitor { fcx: &fcx, };\n \n         // Add formal parameters.\n-        for (arg_ty, input) in fn_sig.inputs.iter().zip(&decl.inputs) {\n+        for (arg_ty, input) in fn_sig.inputs().iter().zip(&decl.inputs) {\n             // The type of the argument must be well-formed.\n             //\n             // NB -- this is now checked in wfcheck, but that\n@@ -2473,14 +2473,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match method_fn_ty.sty {\n                 ty::TyFnDef(def_id, .., ref fty) => {\n                     // HACK(eddyb) ignore self in the definition (see above).\n-                    let expected_arg_tys = self.expected_types_for_fn_args(sp, expected,\n-                                                                           fty.sig.0.output,\n-                                                                           &fty.sig.0.inputs[1..]);\n-\n-                    self.check_argument_types(sp, &fty.sig.0.inputs[1..], &expected_arg_tys[..],\n+                    let expected_arg_tys = self.expected_types_for_fn_args(\n+                        sp,\n+                        expected,\n+                        fty.sig.0.output(),\n+                        &fty.sig.0.inputs()[1..]\n+                    );\n+                    self.check_argument_types(sp, &fty.sig.0.inputs()[1..], &expected_arg_tys[..],\n                                               args_no_rcvr, fty.sig.0.variadic, tuple_arguments,\n                                               self.tcx.map.span_if_local(def_id));\n-                    fty.sig.0.output\n+                    fty.sig.0.output()\n                 }\n                 _ => {\n                     span_bug!(callee_expr.span, \"method without bare fn type\");"}, {"sha": "eb08e70d4c3e445d0a4da8ae9be41a0f98020fcc", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -296,10 +296,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         //\n         // FIXME(#27579) return types should not be implied bounds\n         let fn_sig_tys: Vec<_> =\n-            fn_sig.inputs.iter()\n-                         .cloned()\n-                         .chain(Some(fn_sig.output))\n-                         .collect();\n+            fn_sig.inputs().iter().cloned().chain(Some(fn_sig.output())).collect();\n \n         let old_body_id = self.set_body_id(body_id.node_id());\n         self.relate_free_regions(&fn_sig_tys[..], body_id.node_id(), span);\n@@ -940,7 +937,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     let fn_sig = method.ty.fn_sig();\n                     let fn_sig = // late-bound regions should have been instantiated\n                         self.tcx.no_late_bound_regions(fn_sig).unwrap();\n-                    let self_ty = fn_sig.inputs[0];\n+                    let self_ty = fn_sig.inputs()[0];\n                     let (m, r) = match self_ty.sty {\n                         ty::TyRef(r, ref m) => (m.mutbl, r),\n                         _ => {\n@@ -967,8 +964,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     self.type_must_outlive(infer::CallRcvr(deref_expr.span),\n                                            self_ty, r_deref_expr);\n                     self.type_must_outlive(infer::CallReturn(deref_expr.span),\n-                                           fn_sig.output, r_deref_expr);\n-                    fn_sig.output\n+                                           fn_sig.output(), r_deref_expr);\n+                    fn_sig.output()\n                 }\n                 None => derefd_ty\n             };"}, {"sha": "7f35c8efeff41fa68a3b6ba485104959992ac2c6", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -449,15 +449,15 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         let fty = fcx.instantiate_type_scheme(span, free_substs, &fty);\n         let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.sig);\n \n-        for &input_ty in &sig.inputs {\n-            fcx.register_wf_obligation(input_ty, span, self.code.clone());\n+        for input_ty in sig.inputs() {\n+            fcx.register_wf_obligation(&input_ty, span, self.code.clone());\n         }\n-        implied_bounds.extend(sig.inputs);\n+        implied_bounds.extend(sig.inputs());\n \n-        fcx.register_wf_obligation(sig.output, span, self.code.clone());\n+        fcx.register_wf_obligation(sig.output(), span, self.code.clone());\n \n         // FIXME(#25759) return types should not be implied bounds\n-        implied_bounds.push(sig.output);\n+        implied_bounds.push(sig.output());\n \n         self.check_where_clauses(fcx, span, predicates);\n     }\n@@ -487,7 +487,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n         debug!(\"check_method_receiver: sig={:?}\", sig);\n \n-        let self_arg_ty = sig.inputs[0];\n+        let self_arg_ty = sig.inputs()[0];\n         let rcvr_ty = match ExplicitSelf::determine(self_ty, self_arg_ty) {\n             ExplicitSelf::ByValue => self_ty,\n             ExplicitSelf::ByReference(region, mutbl) => {"}, {"sha": "fba77d171797e1da459a8cb77716523cf671d078", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -920,21 +920,12 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let ctor_ty = match variant.ctor_kind {\n         CtorKind::Fictive | CtorKind::Const => ty,\n         CtorKind::Fn => {\n-            let inputs: Vec<_> =\n-                variant.fields\n-                .iter()\n-                .map(|field| tcx.item_type(field.did))\n-                .collect();\n-            let substs = mk_item_substs(&ccx.icx(&predicates),\n-                                        ccx.tcx.map.span(ctor_id), def_id);\n+            let inputs = variant.fields.iter().map(|field| tcx.item_type(field.did));\n+            let substs = mk_item_substs(&ccx.icx(&predicates), ccx.tcx.map.span(ctor_id), def_id);\n             tcx.mk_fn_def(def_id, substs, tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: abi::Abi::Rust,\n-                sig: ty::Binder(ty::FnSig {\n-                    inputs: inputs,\n-                    output: ty,\n-                    variadic: false\n-                })\n+                sig: ty::Binder(ccx.tcx.mk_fn_sig(inputs, ty, false))\n             }))\n         }\n     };\n@@ -2085,9 +2076,7 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n     ccx.tcx.mk_fn_def(def_id, substs, ccx.tcx.mk_bare_fn(ty::BareFnTy {\n         abi: abi,\n         unsafety: hir::Unsafety::Unsafe,\n-        sig: ty::Binder(ty::FnSig {inputs: input_tys,\n-                                    output: output,\n-                                    variadic: decl.variadic}),\n+        sig: ty::Binder(ccx.tcx.mk_fn_sig(input_tys.into_iter(), output, decl.variadic)),\n     }))\n }\n "}, {"sha": "50d4c3cd0c994a8fd0e7080a6fc328a6b66f31ce", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -116,6 +116,7 @@ use syntax::ast;\n use syntax::abi::Abi;\n use syntax_pos::Span;\n \n+use std::iter;\n use std::cell::RefCell;\n use util::nodemap::NodeMap;\n \n@@ -222,11 +223,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                                       tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: Abi::Rust,\n-                sig: ty::Binder(ty::FnSig {\n-                    inputs: Vec::new(),\n-                    output: tcx.mk_nil(),\n-                    variadic: false\n-                })\n+                sig: ty::Binder(tcx.mk_fn_sig(iter::empty(), tcx.mk_nil(), false))\n             }));\n \n             require_same_types(\n@@ -274,14 +271,14 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                                       tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: Abi::Rust,\n-                sig: ty::Binder(ty::FnSig {\n-                    inputs: vec![\n+                sig: ty::Binder(tcx.mk_fn_sig(\n+                    [\n                         tcx.types.isize,\n                         tcx.mk_imm_ptr(tcx.mk_imm_ptr(tcx.types.u8))\n-                    ],\n-                    output: tcx.types.isize,\n-                    variadic: false,\n-                }),\n+                    ].iter().cloned(),\n+                    tcx.types.isize,\n+                    false,\n+                )),\n             }));\n \n             require_same_types("}, {"sha": "39f996ee62b541e4d7cc003a54227908c7f73c77", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -467,10 +467,10 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                 sig: &ty::PolyFnSig<'tcx>,\n                                 variance: VarianceTermPtr<'a>) {\n         let contra = self.contravariant(variance);\n-        for &input in &sig.0.inputs {\n+        for &input in sig.0.inputs() {\n             self.add_constraints_from_ty(generics, input, contra);\n         }\n-        self.add_constraints_from_ty(generics, sig.0.output, variance);\n+        self.add_constraints_from_ty(generics, sig.0.output(), variance);\n     }\n \n     /// Adds constraints appropriate for a region appearing in a"}, {"sha": "28ca92f5db6f69e7ed80460d958fade26386261f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff261d3a6b5964e1e3744d055238de624afc5d76/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ff261d3a6b5964e1e3744d055238de624afc5d76", "patch": "@@ -1152,11 +1152,11 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n             cx.tcx.sess.cstore.fn_arg_names(did).into_iter()\n         }.peekable();\n         FnDecl {\n-            output: Return(sig.0.output.clean(cx)),\n+            output: Return(sig.skip_binder().output().clean(cx)),\n             attrs: Attributes::default(),\n-            variadic: sig.0.variadic,\n+            variadic: sig.skip_binder().variadic,\n             inputs: Arguments {\n-                values: sig.0.inputs.iter().map(|t| {\n+                values: sig.skip_binder().inputs().iter().map(|t| {\n                     Argument {\n                         type_: t.clean(cx),\n                         id: ast::CRATE_NODE_ID,"}]}