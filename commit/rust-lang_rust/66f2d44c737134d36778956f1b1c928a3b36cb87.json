{"sha": "66f2d44c737134d36778956f1b1c928a3b36cb87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZjJkNDRjNzM3MTM0ZDM2Nzc4OTU2ZjFiMWM5MjhhM2IzNmNiODc=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-03-17T04:01:05Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-04-28T21:58:50Z"}, "message": "Add tests from #67088 and the issues mentioned in its description", "tree": {"sha": "43a6cfa64bdd4dc3bd1a5e59109ce5d23bbe62dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43a6cfa64bdd4dc3bd1a5e59109ce5d23bbe62dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66f2d44c737134d36778956f1b1c928a3b36cb87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66f2d44c737134d36778956f1b1c928a3b36cb87", "html_url": "https://github.com/rust-lang/rust/commit/66f2d44c737134d36778956f1b1c928a3b36cb87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66f2d44c737134d36778956f1b1c928a3b36cb87/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "796c0ca5548de6d4a5220dbae500e00db616243b", "url": "https://api.github.com/repos/rust-lang/rust/commits/796c0ca5548de6d4a5220dbae500e00db616243b", "html_url": "https://github.com/rust-lang/rust/commit/796c0ca5548de6d4a5220dbae500e00db616243b"}], "stats": {"total": 484, "additions": 468, "deletions": 16}, "files": [{"sha": "70ec95faf6ac593958bc561f97f3a6740379b65f", "filename": "src/test/ui/consts/const_in_pattern/accept_structural.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Faccept_structural.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Faccept_structural.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Faccept_structural.rs?ref=66f2d44c737134d36778956f1b1c928a3b36cb87", "patch": "@@ -0,0 +1,66 @@\n+// run-pass\n+\n+#![warn(indirect_structural_match)]\n+\n+// This test is checking our logic for structural match checking by enumerating\n+// the different kinds of const expressions. This test is collecting cases where\n+// we have accepted the const expression as a pattern in the past and wish to\n+// continue doing so.\n+//\n+// Even if a non-structural-match type is part of an expression in a const's\n+// definition, that does not necessarily disqualify the const from being a match\n+// pattern: in principle, we just need the types involved in the final value to\n+// be structurally matchable.\n+\n+// See also RFC 1445\n+\n+#![feature(type_ascription)]\n+\n+#[derive(Copy, Clone, Debug)]\n+struct NoPartialEq(u32);\n+\n+#[derive(Copy, Clone, Debug)]\n+struct NoDerive(u32);\n+\n+// This impl makes `NoDerive` irreflexive.\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+impl Eq for NoDerive { }\n+\n+type OND = Option<NoDerive>;\n+\n+fn main() {\n+    const FIELD1: u32 = NoPartialEq(1).0;\n+    match 1 { FIELD1 => dbg!(FIELD1), _ => panic!(\"whoops\"), };\n+    const FIELD2: u32 = NoDerive(1).0;\n+    match 1 { FIELD2 => dbg!(FIELD2), _ => panic!(\"whoops\"), };\n+\n+    enum CLike { One = 1, #[allow(dead_code)] Two = 2, }\n+    const ONE_CAST: u32 = CLike::One as u32;\n+    match 1 { ONE_CAST => dbg!(ONE_CAST), _ => panic!(\"whoops\"), };\n+\n+    const NO_DERIVE_NONE: OND = None;\n+    const INDIRECT: OND = NO_DERIVE_NONE;\n+    match None { INDIRECT => dbg!(INDIRECT), _ => panic!(\"whoops\"), };\n+\n+    const TUPLE: (OND, OND) = (None, None);\n+    match (None, None) { TUPLE => dbg!(TUPLE), _ => panic!(\"whoops\"), };\n+\n+    const TYPE: OND = None: OND;\n+    match None { TYPE => dbg!(TYPE), _ => panic!(\"whoops\"), };\n+\n+    const ARRAY: [OND; 2] = [None, None];\n+    match [None; 2] { ARRAY => dbg!(ARRAY), _ => panic!(\"whoops\"), };\n+\n+    const REPEAT: [OND; 2] = [None; 2];\n+    match [None, None] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n+\n+    trait Trait: Sized { const ASSOC: Option<Self>; }\n+    impl Trait for NoDerive { const ASSOC: Option<NoDerive> = None; }\n+    match None { NoDerive::ASSOC => dbg!(NoDerive::ASSOC), _ => panic!(\"whoops\"), };\n+\n+    const BLOCK: OND = { NoDerive(10); None };\n+    match None { BLOCK => dbg!(BLOCK), _ => panic!(\"whoops\"), };\n+\n+    const ADDR_OF: &OND = &None;\n+    match &None { ADDR_OF => dbg!(ADDR_OF),  _ => panic!(\"whoops\"), };\n+}"}, {"sha": "4ea9a283618ea385cbacee8610916f8b6616e9d7", "filename": "src/test/ui/consts/const_in_pattern/issue-62614.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-62614.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-62614.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-62614.rs?ref=66f2d44c737134d36778956f1b1c928a3b36cb87", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+\n+struct Sum(u32, u32);\n+\n+impl PartialEq for Sum {\n+    fn eq(&self, other: &Self) -> bool { self.0 + self.1 == other.0 + other.1 }\n+}\n+\n+impl Eq for Sum { }\n+\n+#[derive(PartialEq, Eq)]\n+enum Eek {\n+    TheConst,\n+    UnusedByTheConst(Sum)\n+}\n+\n+const THE_CONST: Eek = Eek::TheConst;\n+\n+pub fn main() {\n+    match Eek::UnusedByTheConst(Sum(1,2)) {\n+        THE_CONST => { panic!(); }\n+        _ => {}\n+    }\n+}"}, {"sha": "e974fd9397d7be0fce9b232f289a3c66cb73beb2", "filename": "src/test/ui/consts/const_in_pattern/issue-65466.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.rs?ref=66f2d44c737134d36778956f1b1c928a3b36cb87", "patch": "@@ -0,0 +1,19 @@\n+#![deny(indirect_structural_match)]\n+\n+#[derive(PartialEq, Eq)]\n+enum O<T> {\n+    Some(*const T), // Can also use PhantomData<T>\n+    None,\n+}\n+\n+struct B;\n+\n+const C: &[O<B>] = &[O::None];\n+\n+fn main() {\n+    let x = O::None;\n+    match &[x][..] {\n+        C => (),\n+        _ => (),\n+    }\n+}"}, {"sha": "9fe3049d1d85f3a6346dc25a90a0f104de7f6784", "filename": "src/test/ui/consts/const_in_pattern/issue-65466.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.stderr?ref=66f2d44c737134d36778956f1b1c928a3b36cb87", "patch": "@@ -0,0 +1,15 @@\n+error[E0601]: `main` function not found in crate `issue_65466`\n+  --> $DIR/issue-65466.rs:1:1\n+   |\n+LL | / #![deny(indirect_structural_match)]\n+LL | |\n+LL | | #[derive(PartialEq, Eq)]\n+LL | | enum O<T> {\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^ consider adding a `main` function to `$DIR/issue-65466.rs`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0601`."}, {"sha": "a8216901c027f2f057dd416da6961430727c9aae", "filename": "src/test/ui/consts/const_in_pattern/reject_non_partial_eq.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_partial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_partial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_partial_eq.rs?ref=66f2d44c737134d36778956f1b1c928a3b36cb87", "patch": "@@ -0,0 +1,32 @@\n+// This test is illustrating the difference between how failing to derive\n+// `PartialEq` is handled compared to failing to implement it at all.\n+\n+// See also RFC 1445\n+\n+#[derive(PartialEq, Eq)]\n+struct Structural(u32);\n+\n+struct NoPartialEq(u32);\n+\n+struct NoDerive(u32);\n+\n+// This impl makes NoDerive irreflexive.\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+\n+impl Eq for NoDerive { }\n+\n+const NO_DERIVE_NONE: Option<NoDerive> = None;\n+const NO_PARTIAL_EQ_NONE: Option<NoPartialEq> = None;\n+\n+fn main() {\n+    match None {\n+        NO_DERIVE_NONE => println!(\"NO_DERIVE_NONE\"),\n+        _ => panic!(\"whoops\"),\n+    }\n+\n+    match None {\n+        NO_PARTIAL_EQ_NONE => println!(\"NO_PARTIAL_EQ_NONE\"),\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        _ => panic!(\"whoops\"),\n+    }\n+}"}, {"sha": "95cfa4a9ebe95a24b6f29a0f4e0998e68d14f747", "filename": "src/test/ui/consts/const_in_pattern/reject_non_partial_eq.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_partial_eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_partial_eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_partial_eq.stderr?ref=66f2d44c737134d36778956f1b1c928a3b36cb87", "patch": "@@ -0,0 +1,8 @@\n+error: to use a constant of type `NoPartialEq` in a pattern, `NoPartialEq` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_partial_eq.rs:28:9\n+   |\n+LL |         NO_PARTIAL_EQ_NONE => println!(\"NO_PARTIAL_EQ_NONE\"),\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "c39163ee27824d1f1e48a823a8dc3e2b7f17a336", "filename": "src/test/ui/consts/const_in_pattern/reject_non_structural.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.rs?ref=66f2d44c737134d36778956f1b1c928a3b36cb87", "patch": "@@ -0,0 +1,93 @@\n+// This test of structural match checking enumerates the different kinds of\n+// const definitions, collecting cases where the const pattern is rejected.\n+//\n+// Note: Even if a non-structural-match type is part of an expression in a\n+// const's definition, that does not necessarily disqualify the const from being\n+// a match pattern: in principle, we just need the types involved in the final\n+// value to be structurally matchable.\n+\n+// See also RFC 1445\n+\n+#![feature(type_ascription)]\n+#![warn(indirect_structural_match)]\n+//~^ NOTE lint level is defined here\n+\n+#[derive(Copy, Clone, Debug)]\n+struct NoPartialEq;\n+\n+#[derive(Copy, Clone, Debug)]\n+struct NoDerive;\n+\n+// This impl makes `NoDerive` irreflexive.\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+\n+impl Eq for NoDerive { }\n+\n+type OND = Option<NoDerive>;\n+\n+struct TrivialEq(OND);\n+\n+// This impl makes `TrivialEq` trivial.\n+impl PartialEq for TrivialEq { fn eq(&self, _: &Self) -> bool { true } }\n+\n+impl Eq for TrivialEq { }\n+\n+fn main() {\n+    #[derive(PartialEq, Eq, Debug)]\n+    enum Derive<X> { Some(X), None, }\n+\n+    const ENUM: Derive<NoDerive> = Derive::Some(NoDerive);\n+    match Derive::Some(NoDerive) { ENUM => dbg!(ENUM), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const FIELD: OND = TrivialEq(Some(NoDerive)).0;\n+    match Some(NoDerive) { FIELD => dbg!(FIELD), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const NO_DERIVE_SOME: OND = Some(NoDerive);\n+    const INDIRECT: OND = NO_DERIVE_SOME;\n+    match Some(NoDerive) {INDIRECT => dbg!(INDIRECT), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const TUPLE: (OND, OND) = (None, Some(NoDerive));\n+    match (None, Some(NoDerive)) { TUPLE => dbg!(TUPLE), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const TYPE: OND = Some(NoDerive): OND;\n+    match Some(NoDerive) { TYPE => dbg!(TYPE), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const ARRAY: [OND; 2] = [None, Some(NoDerive)];\n+    match [None, Some(NoDerive)] { ARRAY => dbg!(ARRAY), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const REPEAT: [OND; 2] = [Some(NoDerive); 2];\n+    match [Some(NoDerive); 2] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    trait Trait: Sized { const ASSOC: Option<Self>; }\n+    impl Trait for NoDerive { const ASSOC: Option<NoDerive> = Some(NoDerive); }\n+    match Some(NoDerive) { NoDerive::ASSOC => dbg!(NoDerive::ASSOC), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const BLOCK: OND = { NoDerive; Some(NoDerive) };\n+    match Some(NoDerive) { BLOCK => dbg!(BLOCK), _ => panic!(\"whoops\"), };\n+    //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+    const ADDR_OF: &OND = &Some(NoDerive);\n+    match &Some(NoDerive) { ADDR_OF => dbg!(ADDR_OF), _ => panic!(\"whoops\"), };\n+    //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| WARN previously accepted by the compiler but is being phased out\n+    //~| NOTE for more information, see issue #62411\n+}"}, {"sha": "8ea28e259abd9774cf0d3e9235ec98f7c68b4fe8", "filename": "src/test/ui/consts/const_in_pattern/reject_non_structural.stderr", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.stderr?ref=66f2d44c737134d36778956f1b1c928a3b36cb87", "patch": "@@ -0,0 +1,136 @@\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:40:36\n+   |\n+LL |     match Derive::Some(NoDerive) { ENUM => dbg!(ENUM), _ => panic!(\"whoops\"), };\n+   |                                    ^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:45:28\n+   |\n+LL |     match Some(NoDerive) { FIELD => dbg!(FIELD), _ => panic!(\"whoops\"), };\n+   |                            ^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:51:27\n+   |\n+LL |     match Some(NoDerive) {INDIRECT => dbg!(INDIRECT), _ => panic!(\"whoops\"), };\n+   |                           ^^^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:56:36\n+   |\n+LL |     match (None, Some(NoDerive)) { TUPLE => dbg!(TUPLE), _ => panic!(\"whoops\"), };\n+   |                                    ^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:61:28\n+   |\n+LL |     match Some(NoDerive) { TYPE => dbg!(TYPE), _ => panic!(\"whoops\"), };\n+   |                            ^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:66:36\n+   |\n+LL |     match [None, Some(NoDerive)] { ARRAY => dbg!(ARRAY), _ => panic!(\"whoops\"), };\n+   |                                    ^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:71:33\n+   |\n+LL |     match [Some(NoDerive); 2] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n+   |                                 ^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:71:33\n+   |\n+LL |     match [Some(NoDerive); 2] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n+   |                                 ^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:79:28\n+   |\n+LL |     match Some(NoDerive) { NoDerive::ASSOC => dbg!(NoDerive::ASSOC), _ => panic!(\"whoops\"), };\n+   |                            ^^^^^^^^^^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:84:28\n+   |\n+LL |     match Some(NoDerive) { BLOCK => dbg!(BLOCK), _ => panic!(\"whoops\"), };\n+   |                            ^^^^^\n+\n+warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:89:29\n+   |\n+LL |     match &Some(NoDerive) { ADDR_OF => dbg!(ADDR_OF), _ => panic!(\"whoops\"), };\n+   |                             ^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/reject_non_structural.rs:12:9\n+   |\n+LL | #![warn(indirect_structural_match)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:40:36\n+   |\n+LL |     match Derive::Some(NoDerive) { ENUM => dbg!(ENUM), _ => panic!(\"whoops\"), };\n+   |                                    ^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:45:28\n+   |\n+LL |     match Some(NoDerive) { FIELD => dbg!(FIELD), _ => panic!(\"whoops\"), };\n+   |                            ^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:51:27\n+   |\n+LL |     match Some(NoDerive) {INDIRECT => dbg!(INDIRECT), _ => panic!(\"whoops\"), };\n+   |                           ^^^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:56:36\n+   |\n+LL |     match (None, Some(NoDerive)) { TUPLE => dbg!(TUPLE), _ => panic!(\"whoops\"), };\n+   |                                    ^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:61:28\n+   |\n+LL |     match Some(NoDerive) { TYPE => dbg!(TYPE), _ => panic!(\"whoops\"), };\n+   |                            ^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:66:36\n+   |\n+LL |     match [None, Some(NoDerive)] { ARRAY => dbg!(ARRAY), _ => panic!(\"whoops\"), };\n+   |                                    ^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:71:33\n+   |\n+LL |     match [Some(NoDerive); 2] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n+   |                                 ^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:71:33\n+   |\n+LL |     match [Some(NoDerive); 2] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n+   |                                 ^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:79:28\n+   |\n+LL |     match Some(NoDerive) { NoDerive::ASSOC => dbg!(NoDerive::ASSOC), _ => panic!(\"whoops\"), };\n+   |                            ^^^^^^^^^^^^^^^\n+\n+error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/reject_non_structural.rs:84:28\n+   |\n+LL |     match Some(NoDerive) { BLOCK => dbg!(BLOCK), _ => panic!(\"whoops\"), };\n+   |                            ^^^^^\n+\n+error: aborting due to 20 previous errors; 1 warning emitted\n+"}, {"sha": "c6b794de195261329749a6ee6c1140577012bab5", "filename": "src/test/ui/consts/const_in_pattern/warn_corner_cases.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.rs?ref=66f2d44c737134d36778956f1b1c928a3b36cb87", "patch": "@@ -0,0 +1,41 @@\n+// run-pass\n+\n+// This test is checking our logic for structural match checking by enumerating\n+// the different kinds of const expressions. This test is collecting cases where\n+// we have accepted the const expression as a pattern in the past but we want\n+// to begin warning the user that a future version of Rust may start rejecting\n+// such const expressions.\n+\n+// The specific corner cases we are exploring here are instances where the\n+// const-evaluator computes a value that *does* meet the conditions for\n+// structural-match, but the const expression itself has abstractions (like\n+// calls to const functions) that may fit better with a type-based analysis\n+// rather than a committment to a specific value.\n+\n+#![warn(indirect_structural_match)]\n+\n+#[derive(Copy, Clone, Debug)]\n+struct NoDerive(u32);\n+\n+// This impl makes `NoDerive` irreflexive.\n+impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+impl Eq for NoDerive { }\n+\n+fn main() {\n+    const INDEX: Option<NoDerive> = [None, Some(NoDerive(10))][0];\n+    match None { Some(_) => panic!(\"whoops\"), INDEX => dbg!(INDEX), };\n+    //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| WARN this was previously accepted\n+\n+    const fn build() -> Option<NoDerive> { None }\n+    const CALL: Option<NoDerive> = build();\n+    match None { Some(_) => panic!(\"whoops\"), CALL => dbg!(CALL), };\n+    //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| WARN this was previously accepted\n+\n+    impl NoDerive { const fn none() -> Option<NoDerive> { None } }\n+    const METHOD_CALL: Option<NoDerive> = NoDerive::none();\n+    match None { Some(_) => panic!(\"whoops\"), METHOD_CALL => dbg!(METHOD_CALL), };\n+    //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n+    //~| WARN this was previously accepted\n+}"}, {"sha": "3e7ed573c74d75e6259e05fd50ac97ee209eda04", "filename": "src/test/ui/consts/const_in_pattern/warn_corner_cases.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.stderr?ref=66f2d44c737134d36778956f1b1c928a3b36cb87", "patch": "@@ -0,0 +1,34 @@\n+warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/warn_corner_cases.rs:26:47\n+   |\n+LL |     match None { Some(_) => panic!(\"whoops\"), INDEX => dbg!(INDEX), };\n+   |                                               ^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/warn_corner_cases.rs:15:9\n+   |\n+LL | #![warn(indirect_structural_match)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+\n+warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/warn_corner_cases.rs:32:47\n+   |\n+LL |     match None { Some(_) => panic!(\"whoops\"), CALL => dbg!(CALL), };\n+   |                                               ^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+\n+warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/warn_corner_cases.rs:38:47\n+   |\n+LL |     match None { Some(_) => panic!(\"whoops\"), METHOD_CALL => dbg!(METHOD_CALL), };\n+   |                                               ^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "7dfa9c7bcdffebeeed1429c4620af026b1edd172", "filename": "src/test/ui/issues/issue-55511.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fissues%2Fissue-55511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fissues%2Fissue-55511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55511.rs?ref=66f2d44c737134d36778956f1b1c928a3b36cb87", "patch": "@@ -14,8 +14,6 @@ fn main() {\n     //~^ ERROR `a` does not live long enough [E0597]\n     match b {\n         <() as Foo<'static>>::C => { }\n-        //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| WARN will become a hard error in a future release\n         _ => { }\n     }\n }"}, {"sha": "b29ff3f7420faf48175f420d1c300c5b8266a899", "filename": "src/test/ui/issues/issue-55511.stderr", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fissues%2Fissue-55511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/66f2d44c737134d36778956f1b1c928a3b36cb87/src%2Ftest%2Fui%2Fissues%2Fissue-55511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55511.stderr?ref=66f2d44c737134d36778956f1b1c928a3b36cb87", "patch": "@@ -1,17 +1,3 @@\n-warning: to use a constant of type `std::cell::Cell` in a pattern, `std::cell::Cell` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/issue-55511.rs:16:9\n-   |\n-LL |         <() as Foo<'static>>::C => { }\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: the lint level is defined here\n-  --> $DIR/issue-55511.rs:1:9\n-   |\n-LL | #![warn(indirect_structural_match)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n-\n error[E0597]: `a` does not live long enough\n   --> $DIR/issue-55511.rs:13:28\n    |"}]}