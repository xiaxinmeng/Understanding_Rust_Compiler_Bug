{"sha": "7f5bffc3ea8545be1916dd089e4f25a360c83950", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNWJmZmMzZWE4NTQ1YmUxOTE2ZGQwODllNGYyNWEzNjBjODM5NTA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-14T23:59:04Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-14T23:59:04Z"}, "message": "Merge remote branch 'brson/recursive-elseif'", "tree": {"sha": "877d7e430339360c8645a1983707d04088d1cba2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/877d7e430339360c8645a1983707d04088d1cba2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f5bffc3ea8545be1916dd089e4f25a360c83950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f5bffc3ea8545be1916dd089e4f25a360c83950", "html_url": "https://github.com/rust-lang/rust/commit/7f5bffc3ea8545be1916dd089e4f25a360c83950", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f5bffc3ea8545be1916dd089e4f25a360c83950/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b5574ac0981de3f4a6f0b8acc15c07653b1b3ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b5574ac0981de3f4a6f0b8acc15c07653b1b3ae", "html_url": "https://github.com/rust-lang/rust/commit/8b5574ac0981de3f4a6f0b8acc15c07653b1b3ae"}, {"sha": "bbb6836da003be71744b6e6ea7af1fd4674f8291", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb6836da003be71744b6e6ea7af1fd4674f8291", "html_url": "https://github.com/rust-lang/rust/commit/bbb6836da003be71744b6e6ea7af1fd4674f8291"}], "stats": {"total": 240, "additions": 80, "deletions": 160}, "files": [{"sha": "a7ff64fa9a7e83263ad3902324c4a6a7d019f5bd", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=7f5bffc3ea8545be1916dd089e4f25a360c83950", "patch": "@@ -223,7 +223,7 @@ tag expr_ {\n     expr_unary(unop, @expr, ann);\n     expr_lit(@lit, ann);\n     expr_cast(@expr, @ty, ann);\n-    expr_if(@expr, block, vec[tup(@expr, block)], option.t[block], ann);\n+    expr_if(@expr, block, option.t[@expr], ann);\n     expr_while(@expr, block, ann);\n     expr_for(@decl, @expr, block, ann);\n     expr_for_each(@decl, @expr, block, ann);"}, {"sha": "ac2498485ced87e20c3ad5b7b55d662c94b027ab", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=7f5bffc3ea8545be1916dd089e4f25a360c83950", "patch": "@@ -289,7 +289,7 @@ impure fn eval_crate_directive_expr(parser p,\n \n     alt (x.node) {\n \n-        case (ast.expr_if(?cond, ?thn, ?elifs, ?elopt, _)) {\n+        case (ast.expr_if(?cond, ?thn, ?elopt, _)) {\n             auto cv = eval_expr(sess, e, cond);\n             if (!val_is_bool(cv)) {\n                 sess.span_err(x.span, \"bad cond type in 'if'\");\n@@ -301,24 +301,11 @@ impure fn eval_crate_directive_expr(parser p,\n                                                index);\n             }\n \n-            for (tup(@ast.expr, ast.block) elif in elifs) {\n-                auto cv = eval_expr(sess, e, elif._0);\n-                if (!val_is_bool(cv)) {\n-                    sess.span_err(x.span, \"bad cond type in 'else if'\");\n-                }\n-\n-                if (val_as_bool(cv)) {\n-                    ret eval_crate_directive_block(p, e, elif._1, prefix,\n-                                                   view_items, items,\n-                                                   index);\n-                }\n-            }\n-\n             alt (elopt) {\n-                case (some[ast.block](?els)) {\n-                    ret eval_crate_directive_block(p, e, els, prefix,\n-                                                   view_items, items,\n-                                                   index);\n+                case (some[@ast.expr](?els)) {\n+                    ret eval_crate_directive_expr(p, e, els, prefix,\n+                                                  view_items, items,\n+                                                  index);\n                 }\n                 case (_) {\n                     // Absent-else is ok.\n@@ -353,6 +340,12 @@ impure fn eval_crate_directive_expr(parser p,\n             sess.span_err(x.span, \"no cases matched in 'alt'\");\n         }\n \n+        case (ast.expr_block(?block, _)) {\n+            ret eval_crate_directive_block(p, e, block, prefix,\n+                                           view_items, items,\n+                                           index);\n+        }\n+\n         case (_) {\n             sess.span_err(x.span, \"unsupported expr type\");\n         }"}, {"sha": "df57bc190ef2282a60ffd36e922be61263e0bff1", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=7f5bffc3ea8545be1916dd089e4f25a360c83950", "patch": "@@ -1139,40 +1139,32 @@ impure fn parse_if_expr(parser p) -> @ast.expr {\n     auto cond = parse_expr(p);\n     expect(p, token.RPAREN);\n     auto thn = parse_block(p);\n+    let option.t[@ast.expr] els = none[@ast.expr];\n     hi = thn.span;\n-\n-    let vec[tup(@ast.expr, ast.block)] elifs = vec();\n-    let option.t[ast.block] els = none[ast.block];\n-    let bool parsing_elses = true;\n-    while (parsing_elses) {\n-        alt (p.peek()) {\n-            case (token.ELSE) {\n-                expect(p, token.ELSE);\n-                alt (p.peek()) {\n-                    case (token.IF) {\n-                        expect(p, token.IF);\n-                        expect(p, token.LPAREN);\n-                        auto elifcond = parse_expr(p);\n-                        expect(p, token.RPAREN);\n-                        auto elifthn = parse_block(p);\n-                        elifs += tup(elifcond, elifthn);\n-                        hi = elifthn.span;\n-                    }\n-                    case (_) {\n-                        auto eblk = parse_block(p);\n-                        els = some(eblk);\n-                        hi = eblk.span;\n-                        parsing_elses = false;\n-                    }\n-                }\n-            }\n-            case (_) {\n-                parsing_elses = false;\n-            }\n+    alt (p.peek()) {\n+        case (token.ELSE) {\n+            auto elexpr = parse_else_expr(p);\n+            els = some(elexpr);\n+            hi = elexpr.span;\n         }\n+        case (_) { /* fall through */ }\n     }\n \n-    ret @spanned(lo, hi, ast.expr_if(cond, thn, elifs, els, ast.ann_none));\n+    ret @spanned(lo, hi, ast.expr_if(cond, thn, els, ast.ann_none));\n+}\n+\n+impure fn parse_else_expr(parser p) -> @ast.expr {\n+    expect(p, token.ELSE);\n+    alt (p.peek()) {\n+        case (token.IF) {\n+            ret parse_if_expr(p);\n+        }\n+        case (_) {\n+            auto blk = parse_block(p);\n+            ret @spanned(blk.span, blk.span,\n+                         ast.expr_block(blk, ast.ann_none));\n+        }\n+    }\n }\n \n impure fn parse_head_local(parser p) -> @ast.decl {\n@@ -1575,7 +1567,7 @@ fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n                 case (ast.expr_unary(_,_,_))    { ret true; }\n                 case (ast.expr_lit(_,_))        { ret true; }\n                 case (ast.expr_cast(_,_,_))     { ret true; }\n-                case (ast.expr_if(_,_,_,_,_))   { ret false; }\n+                case (ast.expr_if(_,_,_,_))     { ret false; }\n                 case (ast.expr_for(_,_,_,_))    { ret false; }\n                 case (ast.expr_for_each(_,_,_,_))\n                     { ret false; }"}, {"sha": "1fc9169334569ec0e259b812b3b5a6a8fbbaf239", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=7f5bffc3ea8545be1916dd089e4f25a360c83950", "patch": "@@ -107,8 +107,7 @@ type ast_fold[ENV] =\n \n      (fn(&ENV e, &span sp,\n          @expr cond, &block thn,\n-         &vec[tup(@expr, block)] elifs,\n-         &option.t[block] els,\n+         &option.t[@expr] els,\n          ann a) -> @expr)                         fold_expr_if,\n \n      (fn(&ENV e, &span sp,\n@@ -590,27 +589,17 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_cast(env_, e.span, ee, tt, at);\n         }\n \n-        case (ast.expr_if(?cnd, ?thn, ?elifs, ?els, ?t)) {\n+        case (ast.expr_if(?cnd, ?thn, ?els, ?t)) {\n             auto ccnd = fold_expr(env_, fld, cnd);\n             auto tthn = fold_block(env_, fld, thn);\n-\n-            let vec[tup(@ast.expr, ast.block)] eelifs = vec();\n-            for (tup(@expr, block) elif in elifs) {\n-                auto elifcnd = elif._0;\n-                auto elifthn = elif._1;\n-                auto elifccnd = fold_expr(env_, fld, elifcnd);\n-                auto eliftthn = fold_block(env_, fld, elifthn);\n-                eelifs += tup(elifccnd, eliftthn);\n-            }\n-\n-            auto eels = none[block];\n+            auto eels = none[@expr];\n             alt (els) {\n-                case (some[block](?b)) {\n-                    eels = some(fold_block(env_, fld, b));\n+                case (some[@expr](?e)) {\n+                    eels = some(fold_expr(env_, fld, e));\n                 }\n                 case (_) { /* fall through */  }\n             }\n-            ret fld.fold_expr_if(env_, e.span, ccnd, tthn, eelifs, eels, t);\n+            ret fld.fold_expr_if(env_, e.span, ccnd, tthn, eels, t);\n         }\n \n         case (ast.expr_for(?decl, ?seq, ?body, ?t)) {\n@@ -1189,9 +1178,8 @@ fn identity_fold_expr_cast[ENV](&ENV env, &span sp, @ast.expr e,\n \n fn identity_fold_expr_if[ENV](&ENV env, &span sp,\n                               @expr cond, &block thn,\n-                              &vec[tup(@expr, block)] elifs,\n-                              &option.t[block] els, ann a) -> @expr {\n-    ret @respan(sp, ast.expr_if(cond, thn, elifs, els, a));\n+                              &option.t[@expr] els, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_if(cond, thn, els, a));\n }\n \n fn identity_fold_expr_for[ENV](&ENV env, &span sp,\n@@ -1554,7 +1542,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_expr_unary  = bind identity_fold_expr_unary[ENV](_,_,_,_,_),\n          fold_expr_lit    = bind identity_fold_expr_lit[ENV](_,_,_,_),\n          fold_expr_cast   = bind identity_fold_expr_cast[ENV](_,_,_,_,_),\n-         fold_expr_if     = bind identity_fold_expr_if[ENV](_,_,_,_,_,_,_),\n+         fold_expr_if     = bind identity_fold_expr_if[ENV](_,_,_,_,_,_),\n          fold_expr_for    = bind identity_fold_expr_for[ENV](_,_,_,_,_,_),\n          fold_expr_for_each\n              = bind identity_fold_expr_for_each[ENV](_,_,_,_,_,_),"}, {"sha": "4fab34542f82bde7176929ba30056b21f311b89a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 9, "deletions": 31, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7f5bffc3ea8545be1916dd089e4f25a360c83950", "patch": "@@ -2833,9 +2833,8 @@ fn join_results(@block_ctxt parent_cx,\n     ret res(join_cx, phi);\n }\n \n-fn trans_if(@block_ctxt cx, @ast.expr cond, &ast.block thn,\n-            &vec[tup(@ast.expr, ast.block)] elifs,\n-            &option.t[ast.block] els) -> result {\n+fn trans_if(@block_ctxt cx, @ast.expr cond,\n+            &ast.block thn, &option.t[@ast.expr] els) -> result {\n \n     auto cond_res = trans_expr(cx, cond);\n \n@@ -2845,25 +2844,11 @@ fn trans_if(@block_ctxt cx, @ast.expr cond, &ast.block thn,\n     auto else_cx = new_scope_block_ctxt(cx, \"else\");\n     auto else_res = res(else_cx, C_nil());\n \n-    auto num_elifs = _vec.len[tup(@ast.expr, ast.block)](elifs);\n-    if (num_elifs > 0u) {\n-        auto next_elif = elifs.(0u);\n-        auto next_elifthn = next_elif._0;\n-        auto next_elifcnd = next_elif._1;\n-        auto rest_elifs = _vec.shift[tup(@ast.expr, ast.block)](elifs);\n-        else_res = trans_if(else_cx, next_elifthn, next_elifcnd,\n-                            rest_elifs, els);\n-    }\n-\n-    /* else: FIXME: rustboot has a problem here\n-       with preconditions inside an else block */\n-    if (num_elifs == 0u)  {\n-        alt (els) {\n-            case (some[ast.block](?eblk)) {\n-                else_res = trans_block(else_cx, eblk);\n-            }\n-            case (_) { /* fall through */ }\n+    alt (els) {\n+        case (some[@ast.expr](?elexpr)) {\n+            else_res = trans_expr(else_cx, elexpr);\n         }\n+        case (_) { /* fall through */ }\n     }\n \n     cond_res.bcx.build.CondBr(cond_res.val,\n@@ -4303,8 +4288,8 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             ret trans_binary(cx, op, x, y);\n         }\n \n-        case (ast.expr_if(?cond, ?thn, ?elifs, ?els, _)) {\n-            ret trans_if(cx, cond, thn, elifs, els);\n+        case (ast.expr_if(?cond, ?thn, ?els, _)) {\n+            ret trans_if(cx, cond, thn, els);\n         }\n \n         case (ast.expr_for(?decl, ?seq, ?body, _)) {\n@@ -4328,14 +4313,7 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n         }\n \n         case (ast.expr_block(?blk, _)) {\n-            auto sub_cx = new_scope_block_ctxt(cx, \"block-expr body\");\n-            auto next_cx = new_sub_block_ctxt(cx, \"next\");\n-            auto sub = trans_block(sub_cx, blk);\n-\n-            cx.build.Br(sub_cx.llbb);\n-            sub.bcx.build.Br(next_cx.llbb);\n-\n-            ret res(next_cx, sub.val);\n+            ret trans_block(cx, blk);\n         }\n \n         case (ast.expr_assign(?dst, ?src, ?ann)) {"}, {"sha": "0c540f5c0ba5d56cb069d5b378969e24627690c1", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=7f5bffc3ea8545be1916dd089e4f25a360c83950", "patch": "@@ -712,7 +712,7 @@ fn expr_ty(@ast.expr expr) -> @t {\n         case (ast.expr_unary(_, _, ?ann))     { ret ann_to_type(ann); }\n         case (ast.expr_lit(_, ?ann))          { ret ann_to_type(ann); }\n         case (ast.expr_cast(_, _, ?ann))      { ret ann_to_type(ann); }\n-        case (ast.expr_if(_, _, _, _, ?ann))  { ret ann_to_type(ann); }\n+        case (ast.expr_if(_, _, _, ?ann))     { ret ann_to_type(ann); }\n         case (ast.expr_for(_, _, _, ?ann))    { ret ann_to_type(ann); }\n         case (ast.expr_for_each(_, _, _, ?ann))\n                                               { ret ann_to_type(ann); }"}, {"sha": "1818c4fda17fc2cd199c2ebe07dfad86bb60f7ff", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 16, "deletions": 39, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=7f5bffc3ea8545be1916dd089e4f25a360c83950", "patch": "@@ -1272,28 +1272,20 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n             e_1 = ast.expr_cast(sube, ast_ty,\n                                 ast.ann_type(t, none[vec[@ty.t]]));\n         }\n-        case (ast.expr_if(?cond, ?then_0, ?elifs_0, ?else_0, ?ann)) {\n+        case (ast.expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n             auto t = demand_full(fcx, e.span, expected,\n                                  ann_to_type(ann), adk);\n             auto then_1 = demand_block(fcx, expected, then_0);\n \n-            let vec[tup(@ast.expr, ast.block)] elifs_1 = vec();\n-            for (tup(@ast.expr, ast.block) elif in elifs_0) {\n-                auto elifcond = elif._0;\n-                auto elifthn_0 = elif._1;\n-                auto elifthn_1 = demand_block(fcx, expected, elifthn_0);\n-                elifs_1 += tup(elifcond, elifthn_1);\n-            }\n-\n             auto else_1;\n             alt (else_0) {\n-                case (none[ast.block]) { else_1 = none[ast.block]; }\n-                case (some[ast.block](?b_0)) {\n-                    auto b_1 = demand_block(fcx, expected, b_0);\n-                    else_1 = some[ast.block](b_1);\n+                case (none[@ast.expr]) { else_1 = none[@ast.expr]; }\n+                case (some[@ast.expr](?e_0)) {\n+                    auto e_1 = demand_expr(fcx, expected, e_0);\n+                    else_1 = some[@ast.expr](e_1);\n                 }\n             }\n-            e_1 = ast.expr_if(cond, then_1, elifs_1, else_1,\n+            e_1 = ast.expr_if(cond, then_1, else_1,\n                               ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_for(?decl, ?seq, ?bloc, ?ann)) {\n@@ -1875,39 +1867,24 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             ret @fold.respan[ast.expr_](expr.span, newexpr);\n         }\n \n-        case (ast.expr_if(?cond, ?thn, ?elifs, ?elsopt, _)) {\n+        case (ast.expr_if(?cond, ?thn, ?elsopt, _)) {\n             auto cond_0 = check_expr(fcx, cond);\n             auto cond_1 = demand_expr(fcx, plain_ty(ty.ty_bool), cond_0);\n \n             auto thn_0 = check_block(fcx, thn);\n             auto thn_t = block_ty(thn_0);\n \n-            auto num_elifs = _vec.len[tup(@ast.expr, ast.block)](elifs);\n-            let vec[tup(@ast.expr, ast.block)] elifs_1 = vec();\n-            for each (uint i in _uint.range(0u, num_elifs)) {\n-                auto elif = elifs.(i);\n-                auto elifcond = elif._0;\n-                auto elifcond_0 = check_expr(fcx, cond);\n-                auto elifcond_1 = demand_expr(fcx,\n-                                              plain_ty(ty.ty_bool),\n-                                              elifcond_0);\n-                auto elifthn = elif._1;\n-                auto elifthn_0 = check_block(fcx, elifthn);\n-                auto elifthn_1 = demand_block(fcx, thn_t, elifthn_0);\n-                elifs_1 += tup(elifcond_1, elifthn_1);\n-            }\n-\n             auto elsopt_1;\n             auto elsopt_t;\n             alt (elsopt) {\n-                case (some[ast.block](?els)) {\n-                    auto els_0 = check_block(fcx, els);\n-                    auto els_1 = demand_block(fcx, thn_t, els_0);\n-                    elsopt_1 = some[ast.block](els_1);\n-                    elsopt_t = block_ty(els_1);\n-                }\n-                case (none[ast.block]) {\n-                    elsopt_1 = none[ast.block];\n+                case (some[@ast.expr](?els)) {\n+                    auto els_0 = check_expr(fcx, els);\n+                    auto els_1 = demand_expr(fcx, thn_t, els_0);\n+                    elsopt_1 = some[@ast.expr](els_1);\n+                    elsopt_t = expr_ty(els_1);\n+                }\n+                case (none[@ast.expr]) {\n+                    elsopt_1 = none[@ast.expr];\n                     elsopt_t = plain_ty(ty.ty_nil);\n                 }\n             }\n@@ -1917,7 +1894,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto ann = ast.ann_type(elsopt_t, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_if(cond_1, thn_1,\n-                                                    elifs_1, elsopt_1, ann));\n+                                                    elsopt_1, ann));\n         }\n \n         case (ast.expr_for(?decl, ?seq, ?body, _)) {"}, {"sha": "e59c0c3dd4b89b3c5bb2c91bb3e7a7a5d412c346", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5bffc3ea8545be1916dd089e4f25a360c83950/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=7f5bffc3ea8545be1916dd089e4f25a360c83950", "patch": "@@ -376,26 +376,18 @@ impure fn print_expr(ps s, @ast.expr expr) {\n       wrd1(s, \"as\");\n       print_type(s, ty);\n     }\n-    case (ast.expr_if(?test,?block,?clauses,?_else,_)) {\n-      impure fn print_clause(ps s, @ast.expr test, ast.block blk) {\n-        wrd1(s, \"if\");\n-        popen(s);\n-        print_expr(s, test);\n-        pclose(s);\n-        space(s);\n-        print_block(s, blk);\n-      }\n-      print_clause(s, test, block);\n-      for (tup(@ast.expr, ast.block) clause in clauses) {\n-        space(s);\n-        wrd1(s, \"else\");\n-        print_clause(s, clause._0, clause._1);\n-      }\n-      alt (_else) {\n-        case (option.some[ast.block](?blk)) {\n+    case (ast.expr_if(?test,?block,?elseopt,_)) {\n+      wrd1(s, \"if\");\n+      popen(s);\n+      print_expr(s, test);\n+      pclose(s);\n+      space(s);\n+      print_block(s, block);\n+      alt (elseopt) {\n+        case (option.some[@ast.expr](?_else)) {\n           space(s);\n           wrd1(s, \"else\");\n-          print_block(s, blk);\n+          print_expr(s, _else);\n         }\n         case (_) { /* fall through */ }\n       }"}]}