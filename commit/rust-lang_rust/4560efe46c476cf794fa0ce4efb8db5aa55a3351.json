{"sha": "4560efe46c476cf794fa0ce4efb8db5aa55a3351", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NjBlZmU0NmM0NzZjZjc5NGZhMGNlNGVmYjhkYjVhYTU1YTMzNTE=", "commit": {"author": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2021-07-04T16:53:04Z"}, "committer": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2021-07-09T20:14:44Z"}, "message": "Pass type when creating load\n\nThis makes load generation compatible with opaque pointers.\n\nThe generation of nontemporal copies still accesses the pointer\nelement type, as fixing this requires more movement.", "tree": {"sha": "945df75cbe56cff80f8e3f0e931a00dc7ce73ae1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/945df75cbe56cff80f8e3f0e931a00dc7ce73ae1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4560efe46c476cf794fa0ce4efb8db5aa55a3351", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4560efe46c476cf794fa0ce4efb8db5aa55a3351", "html_url": "https://github.com/rust-lang/rust/commit/4560efe46c476cf794fa0ce4efb8db5aa55a3351", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4560efe46c476cf794fa0ce4efb8db5aa55a3351/comments", "author": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33e9a6b565ddd7f20a5fd3f455eb2f3109d41801", "url": "https://api.github.com/repos/rust-lang/rust/commits/33e9a6b565ddd7f20a5fd3f455eb2f3109d41801", "html_url": "https://github.com/rust-lang/rust/commit/33e9a6b565ddd7f20a5fd3f455eb2f3109d41801"}], "stats": {"total": 117, "additions": 65, "deletions": 52}, "files": [{"sha": "2bb0ce68b171e57540b2c1958c71b414ee674903", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=4560efe46c476cf794fa0ce4efb8db5aa55a3351", "patch": "@@ -410,17 +410,17 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn load(&mut self, ptr: &'ll Value, align: Align) -> &'ll Value {\n+    fn load(&mut self, ty: &'ll Type, ptr: &'ll Value, align: Align) -> &'ll Value {\n         unsafe {\n-            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, UNNAMED);\n+            let load = llvm::LLVMBuildLoad2(self.llbuilder, ty, ptr, UNNAMED);\n             llvm::LLVMSetAlignment(load, align.bytes() as c_uint);\n             load\n         }\n     }\n \n-    fn volatile_load(&mut self, ptr: &'ll Value) -> &'ll Value {\n+    fn volatile_load(&mut self, ty: &'ll Type, ptr: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, UNNAMED);\n+            let load = llvm::LLVMBuildLoad2(self.llbuilder, ty, ptr, UNNAMED);\n             llvm::LLVMSetVolatile(load, llvm::True);\n             load\n         }\n@@ -488,7 +488,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n             }\n             let llval = const_llval.unwrap_or_else(|| {\n-                let load = self.load(place.llval, place.align);\n+                let load = self.load(place.layout.llvm_type(self), place.llval, place.align);\n                 if let abi::Abi::Scalar(ref scalar) = place.layout.abi {\n                     scalar_load_metadata(self, load, scalar);\n                 }\n@@ -500,7 +500,8 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n             let mut load = |i, scalar: &abi::Scalar, align| {\n                 let llptr = self.struct_gep(place.llval, i as u64);\n-                let load = self.load(llptr, align);\n+                let llty = place.layout.scalar_pair_element_llvm_type(self, i, false);\n+                let load = self.load(llty, llptr, align);\n                 scalar_load_metadata(self, load, scalar);\n                 self.to_immediate_scalar(load, scalar)\n             };\n@@ -817,13 +818,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         size: &'ll Value,\n         flags: MemFlags,\n     ) {\n-        if flags.contains(MemFlags::NONTEMPORAL) {\n-            // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n-            let val = self.load(src, src_align);\n-            let ptr = self.pointercast(dst, self.type_ptr_to(self.val_ty(val)));\n-            self.store_with_flags(val, ptr, dst_align, flags);\n-            return;\n-        }\n+        assert!(!flags.contains(MemFlags::NONTEMPORAL), \"non-temporal memcpy not supported\");\n         let size = self.intcast(size, self.type_isize(), false);\n         let is_volatile = flags.contains(MemFlags::VOLATILE);\n         let dst = self.pointercast(dst, self.type_i8p());\n@@ -850,13 +845,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         size: &'ll Value,\n         flags: MemFlags,\n     ) {\n-        if flags.contains(MemFlags::NONTEMPORAL) {\n-            // HACK(nox): This is inefficient but there is no nontemporal memmove.\n-            let val = self.load(src, src_align);\n-            let ptr = self.pointercast(dst, self.type_ptr_to(self.val_ty(val)));\n-            self.store_with_flags(val, ptr, dst_align, flags);\n-            return;\n-        }\n+        assert!(!flags.contains(MemFlags::NONTEMPORAL), \"non-temporal memmove not supported\");\n         let size = self.intcast(size, self.type_isize(), false);\n         let is_volatile = flags.contains(MemFlags::VOLATILE);\n         let dst = self.pointercast(dst, self.type_i8p());"}, {"sha": "de3f719b8163c7ab0486ead4761cd579a06c078d", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs?ref=4560efe46c476cf794fa0ce4efb8db5aa55a3351", "patch": "@@ -20,7 +20,7 @@ pub fn insert_reference_to_gdb_debug_scripts_section_global(bx: &mut Builder<'_,\n         // LLVM to keep around the reference to the global.\n         let indices = [bx.const_i32(0), bx.const_i32(0)];\n         let element = bx.inbounds_gep(gdb_debug_scripts_section, &indices);\n-        let volative_load_instruction = bx.volatile_load(element);\n+        let volative_load_instruction = bx.volatile_load(bx.type_i8(), element);\n         unsafe {\n             llvm::LLVMSetAlignment(volative_load_instruction, 1);\n         }"}, {"sha": "a48a694b630f001cd5c17b34d82de0234a3a0d5d", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=4560efe46c476cf794fa0ce4efb8db5aa55a3351", "patch": "@@ -162,11 +162,14 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n             sym::volatile_load | sym::unaligned_volatile_load => {\n                 let tp_ty = substs.type_at(0);\n-                let mut ptr = args[0].immediate();\n-                if let PassMode::Cast(ty) = fn_abi.ret.mode {\n-                    ptr = self.pointercast(ptr, self.type_ptr_to(ty.llvm_type(self)));\n-                }\n-                let load = self.volatile_load(ptr);\n+                let ptr = args[0].immediate();\n+                let load = if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+                    let llty = ty.llvm_type(self);\n+                    let ptr = self.pointercast(ptr, self.type_ptr_to(llty));\n+                    self.volatile_load(llty, ptr)\n+                } else {\n+                    self.volatile_load(self.layout_of(tp_ty).llvm_type(self), ptr)\n+                };\n                 let align = if name == sym::unaligned_volatile_load {\n                     1\n                 } else {\n@@ -319,9 +322,9 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     let integer_ty = self.type_ix(layout.size.bits());\n                     let ptr_ty = self.type_ptr_to(integer_ty);\n                     let a_ptr = self.bitcast(a, ptr_ty);\n-                    let a_val = self.load(a_ptr, layout.align.abi);\n+                    let a_val = self.load(integer_ty, a_ptr, layout.align.abi);\n                     let b_ptr = self.bitcast(b, ptr_ty);\n-                    let b_val = self.load(b_ptr, layout.align.abi);\n+                    let b_val = self.load(integer_ty, b_ptr, layout.align.abi);\n                     self.icmp(IntPredicate::IntEQ, a_val, b_val)\n                 } else {\n                     let i8p_ty = self.type_i8p();\n@@ -540,7 +543,7 @@ fn codegen_msvc_try(\n         // Source: MicrosoftCXXABI::getAddrOfCXXCatchHandlerType in clang\n         let flags = bx.const_i32(8);\n         let funclet = catchpad_rust.catch_pad(cs, &[tydesc, flags, slot]);\n-        let ptr = catchpad_rust.load(slot, ptr_align);\n+        let ptr = catchpad_rust.load(bx.type_i8p(), slot, ptr_align);\n         catchpad_rust.call(catch_func, &[data, ptr], Some(&funclet));\n         catchpad_rust.catch_ret(&funclet, caught.llbb());\n "}, {"sha": "2ade66ac41eda9cce77b737db651a6fe949bf712", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=4560efe46c476cf794fa0ce4efb8db5aa55a3351", "patch": "@@ -1385,7 +1385,12 @@ extern \"C\" {\n         Val: &'a Value,\n         Name: *const c_char,\n     ) -> &'a Value;\n-    pub fn LLVMBuildLoad(B: &Builder<'a>, PointerVal: &'a Value, Name: *const c_char) -> &'a Value;\n+    pub fn LLVMBuildLoad2(\n+        B: &Builder<'a>,\n+        Ty: &'a Type,\n+        PointerVal: &'a Value,\n+        Name: *const c_char,\n+    ) -> &'a Value;\n \n     pub fn LLVMBuildStore(B: &Builder<'a>, Val: &'a Value, Ptr: &'a Value) -> &'a Value;\n "}, {"sha": "9df1bd7d1d9bb20897aa3022a92bfd6aab9d629f", "filename": "compiler/rustc_codegen_llvm/src/va_arg.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs?ref=4560efe46c476cf794fa0ce4efb8db5aa55a3351", "patch": "@@ -32,14 +32,15 @@ fn emit_direct_ptr_va_arg(\n     slot_size: Align,\n     allow_higher_align: bool,\n ) -> (&'ll Value, Align) {\n-    let va_list_ptr_ty = bx.cx().type_ptr_to(bx.cx.type_i8p());\n+    let va_list_ty = bx.type_i8p();\n+    let va_list_ptr_ty = bx.type_ptr_to(va_list_ty);\n     let va_list_addr = if list.layout.llvm_type(bx.cx) != va_list_ptr_ty {\n         bx.bitcast(list.immediate(), va_list_ptr_ty)\n     } else {\n         list.immediate()\n     };\n \n-    let ptr = bx.load(va_list_addr, bx.tcx().data_layout.pointer_align.abi);\n+    let ptr = bx.load(va_list_ty, va_list_addr, bx.tcx().data_layout.pointer_align.abi);\n \n     let (addr, addr_align) = if allow_higher_align && align > slot_size {\n         (round_pointer_up_to_alignment(bx, ptr, align, bx.cx().type_i8p()), align)\n@@ -82,10 +83,10 @@ fn emit_ptr_va_arg(\n     let (addr, addr_align) =\n         emit_direct_ptr_va_arg(bx, list, llty, size, align.abi, slot_size, allow_higher_align);\n     if indirect {\n-        let tmp_ret = bx.load(addr, addr_align);\n-        bx.load(tmp_ret, align.abi)\n+        let tmp_ret = bx.load(llty, addr, addr_align);\n+        bx.load(bx.cx.layout_of(target_ty).llvm_type(bx.cx), tmp_ret, align.abi)\n     } else {\n-        bx.load(addr, addr_align)\n+        bx.load(llty, addr, addr_align)\n     }\n }\n \n@@ -118,7 +119,7 @@ fn emit_aapcs_va_arg(\n     };\n \n     // if the offset >= 0 then the value will be on the stack\n-    let mut reg_off_v = bx.load(reg_off, offset_align);\n+    let mut reg_off_v = bx.load(bx.type_i32(), reg_off, offset_align);\n     let use_stack = bx.icmp(IntPredicate::IntSGE, reg_off_v, zero);\n     bx.cond_br(use_stack, &on_stack.llbb(), &maybe_reg.llbb());\n \n@@ -139,8 +140,9 @@ fn emit_aapcs_va_arg(\n     let use_stack = maybe_reg.icmp(IntPredicate::IntSGT, new_reg_off_v, zero);\n     maybe_reg.cond_br(use_stack, &on_stack.llbb(), &in_reg.llbb());\n \n+    let top_type = bx.type_i8p();\n     let top = in_reg.struct_gep(va_list_addr, reg_top_index);\n-    let top = in_reg.load(top, bx.tcx().data_layout.pointer_align.abi);\n+    let top = in_reg.load(top_type, top, bx.tcx().data_layout.pointer_align.abi);\n \n     // reg_value = *(@top + reg_off_v);\n     let mut reg_addr = in_reg.gep(top, &[reg_off_v]);\n@@ -149,8 +151,9 @@ fn emit_aapcs_va_arg(\n         let offset = bx.const_i32((slot_size - layout.size.bytes()) as i32);\n         reg_addr = in_reg.gep(reg_addr, &[offset]);\n     }\n-    let reg_addr = in_reg.bitcast(reg_addr, bx.cx.type_ptr_to(layout.llvm_type(bx)));\n-    let reg_value = in_reg.load(reg_addr, layout.align.abi);\n+    let reg_type = layout.llvm_type(bx);\n+    let reg_addr = in_reg.bitcast(reg_addr, bx.cx.type_ptr_to(reg_type));\n+    let reg_value = in_reg.load(reg_type, reg_addr, layout.align.abi);\n     in_reg.br(&end.llbb());\n \n     // On Stack block"}, {"sha": "b392b2c4ab8acfc70aa129b04767cb9efb8d9338", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=4560efe46c476cf794fa0ce4efb8db5aa55a3351", "patch": "@@ -20,10 +20,11 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", llvtable, self);\n \n-        let llvtable = bx.pointercast(llvtable, bx.type_ptr_to(bx.fn_ptr_backend_type(fn_abi)));\n+        let llty = bx.fn_ptr_backend_type(fn_abi);\n+        let llvtable = bx.pointercast(llvtable, bx.type_ptr_to(llty));\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let gep = bx.inbounds_gep(llvtable, &[bx.const_usize(self.0)]);\n-        let ptr = bx.load(gep, ptr_align);\n+        let ptr = bx.load(llty, gep, ptr_align);\n         bx.nonnull_metadata(ptr);\n         // Vtable loads are invariant.\n         bx.set_invariant_load(ptr);\n@@ -38,10 +39,11 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_int({:?}, {:?})\", llvtable, self);\n \n-        let llvtable = bx.pointercast(llvtable, bx.type_ptr_to(bx.type_isize()));\n+        let llty = bx.type_isize();\n+        let llvtable = bx.pointercast(llvtable, bx.type_ptr_to(llty));\n         let usize_align = bx.tcx().data_layout.pointer_align.abi;\n         let gep = bx.inbounds_gep(llvtable, &[bx.const_usize(self.0)]);\n-        let ptr = bx.load(gep, usize_align);\n+        let ptr = bx.load(llty, gep, usize_align);\n         // Vtable loads are invariant.\n         bx.set_invariant_load(ptr);\n         ptr"}, {"sha": "b584801a62de2cb91cefe79303dae8bb58d6fb3b", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=4560efe46c476cf794fa0ce4efb8db5aa55a3351", "patch": "@@ -260,7 +260,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 let op = self.codegen_consume(&mut bx, mir::Place::return_place().as_ref());\n                 if let Ref(llval, _, align) = op.val {\n-                    bx.load(llval, align)\n+                    bx.load(bx.backend_type(op.layout), llval, align)\n                 } else {\n                     op.immediate_or_packed_pair(&mut bx)\n                 }\n@@ -287,8 +287,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         llval\n                     }\n                 };\n-                let addr = bx.pointercast(llslot, bx.type_ptr_to(bx.cast_backend_type(&cast_ty)));\n-                bx.load(addr, self.fn_abi.ret.layout.align.abi)\n+                let ty = bx.cast_backend_type(&cast_ty);\n+                let addr = bx.pointercast(llslot, bx.type_ptr_to(ty));\n+                bx.load(ty, addr, self.fn_abi.ret.layout.align.abi)\n             }\n         };\n         bx.ret(llval);\n@@ -1086,15 +1087,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n             if let PassMode::Cast(ty) = arg.mode {\n-                let addr = bx.pointercast(llval, bx.type_ptr_to(bx.cast_backend_type(&ty)));\n-                llval = bx.load(addr, align.min(arg.layout.align.abi));\n+                let llty = bx.cast_backend_type(&ty);\n+                let addr = bx.pointercast(llval, bx.type_ptr_to(llty));\n+                llval = bx.load(llty, addr, align.min(arg.layout.align.abi));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n                 // may have a type we don't treat as immediate, but the ABI\n                 // used for this call is passing it by-value. In that case,\n                 // the load would just produce `OperandValue::Ref` instead\n                 // of the `OperandValue::Immediate` we need for the call.\n-                llval = bx.load(llval, align);\n+                llval = bx.load(bx.backend_type(arg.layout), llval, align);\n                 if let abi::Abi::Scalar(ref scalar) = arg.layout.abi {\n                     if scalar.is_bool() {\n                         bx.range_metadata(llval, 0..2);"}, {"sha": "3481b36bcc00403cd00dc0af0a675cd9619ccc0d", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=4560efe46c476cf794fa0ce4efb8db5aa55a3351", "patch": "@@ -289,6 +289,15 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n         }\n         match self {\n             OperandValue::Ref(r, None, source_align) => {\n+                if flags.contains(MemFlags::NONTEMPORAL) {\n+                    // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n+                    // FIXME: Don't access pointer element type.\n+                    let ty = bx.element_type(bx.val_ty(r));\n+                    let val = bx.load(ty, r, source_align);\n+                    let ptr = bx.pointercast(dest.llval, bx.type_ptr_to(ty));\n+                    bx.store_with_flags(val, ptr, dest.align, flags);\n+                    return;\n+                }\n                 base::memcpy_ty(bx, dest.llval, dest.align, r, source_align, dest.layout, flags)\n             }\n             OperandValue::Ref(_, Some(_), _) => {"}, {"sha": "9906cf59e9a050de55a4be4cfe9568c3398a23a4", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=4560efe46c476cf794fa0ce4efb8db5aa55a3351", "patch": "@@ -407,7 +407,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         let layout = bx.layout_of(target_ty.ty);\n \n         PlaceRef {\n-            llval: bx.load(self.llval, self.align),\n+            llval: bx.load(bx.backend_type(layout), self.llval, self.align),\n             llextra: None,\n             layout,\n             align: layout.align.abi,"}, {"sha": "f0c232a97bc946bd395957a3ecea12640b054b6d", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4560efe46c476cf794fa0ce4efb8db5aa55a3351/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=4560efe46c476cf794fa0ce4efb8db5aa55a3351", "patch": "@@ -137,8 +137,8 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn dynamic_alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n     fn array_alloca(&mut self, ty: Self::Type, len: Self::Value, align: Align) -> Self::Value;\n \n-    fn load(&mut self, ptr: Self::Value, align: Align) -> Self::Value;\n-    fn volatile_load(&mut self, ptr: Self::Value) -> Self::Value;\n+    fn load(&mut self, ty: Self::Type, ptr: Self::Value, align: Align) -> Self::Value;\n+    fn volatile_load(&mut self, ty: Self::Type, ptr: Self::Value) -> Self::Value;\n     fn atomic_load(\n         &mut self,\n         ty: Self::Type,"}]}