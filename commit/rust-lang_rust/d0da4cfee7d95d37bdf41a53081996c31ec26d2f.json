{"sha": "d0da4cfee7d95d37bdf41a53081996c31ec26d2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwZGE0Y2ZlZTdkOTVkMzdiZGY0MWE1MzA4MTk5NmMzMWVjMjZkMmY=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-05-02T18:04:46Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-05-02T19:04:44Z"}, "message": "Implement comparison operators for int and uint SIMD vectors", "tree": {"sha": "643c0c516c323cf5532f922db6c384f142a0944d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/643c0c516c323cf5532f922db6c384f142a0944d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0da4cfee7d95d37bdf41a53081996c31ec26d2f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0da4cfee7d95d37bdf41a53081996c31ec26d2f", "html_url": "https://github.com/rust-lang/rust/commit/d0da4cfee7d95d37bdf41a53081996c31ec26d2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0da4cfee7d95d37bdf41a53081996c31ec26d2f/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dd7a56ed46e6ca9cb75c6a7d01d100ca7a5c04d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dd7a56ed46e6ca9cb75c6a7d01d100ca7a5c04d", "html_url": "https://github.com/rust-lang/rust/commit/6dd7a56ed46e6ca9cb75c6a7d01d100ca7a5c04d"}], "stats": {"total": 155, "additions": 135, "deletions": 20}, "files": [{"sha": "7e38ae29d30aaec34d6986f41c7f39d19bd53c03", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d0da4cfee7d95d37bdf41a53081996c31ec26d2f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0da4cfee7d95d37bdf41a53081996c31ec26d2f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d0da4cfee7d95d37bdf41a53081996c31ec26d2f", "patch": "@@ -619,6 +619,44 @@ pub fn compare_scalar_values<'a>(\n     }\n }\n \n+pub fn compare_simd_types(\n+                    cx: &Block,\n+                    lhs: ValueRef,\n+                    rhs: ValueRef,\n+                    t: ty::t,\n+                    size: uint,\n+                    op: ast::BinOp)\n+                    -> ValueRef {\n+    match ty::get(t).sty {\n+        ty::ty_float(_) => {\n+            // The comparison operators for floating point vectors are challenging.\n+            // LLVM outputs a `< size x i1 >`, but if we perform a sign extension\n+            // then bitcast to a floating point vector, the result will be `-NaN`\n+            // for each truth value. Because of this they are unsupported.\n+            cx.sess().bug(\"compare_simd_types: comparison operators \\\n+                           not supported for floating point SIMD types\")\n+        },\n+        ty::ty_uint(_) | ty::ty_int(_) => {\n+            let cmp = match op {\n+                ast::BiEq => lib::llvm::IntEQ,\n+                ast::BiNe => lib::llvm::IntNE,\n+                ast::BiLt => lib::llvm::IntSLT,\n+                ast::BiLe => lib::llvm::IntSLE,\n+                ast::BiGt => lib::llvm::IntSGT,\n+                ast::BiGe => lib::llvm::IntSGE,\n+                _ => cx.sess().bug(\"compare_simd_types: must be a comparison operator\"),\n+            };\n+            let return_ty = Type::vector(&type_of(cx.ccx(), t), size as u64);\n+            // LLVM outputs an `< size x i1 >`, so we need to perform a sign extension\n+            // to get the correctly sized type. This will compile to a single instruction\n+            // once the IR is converted to assembly if the SIMD instruction is supported\n+            // by the target architecture.\n+            SExt(cx, ICmp(cx, cmp, lhs, rhs), return_ty)\n+        },\n+        _ => cx.sess().bug(\"compare_simd_types: invalid SIMD type\"),\n+    }\n+}\n+\n pub type val_and_ty_fn<'r,'b> =\n     |&'b Block<'b>, ValueRef, ty::t|: 'r -> &'b Block<'b>;\n "}, {"sha": "2e8c60c5dc5f5ef7dd10a0cf8692c94845d498cb", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d0da4cfee7d95d37bdf41a53081996c31ec26d2f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0da4cfee7d95d37bdf41a53081996c31ec26d2f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=d0da4cfee7d95d37bdf41a53081996c31ec26d2f", "patch": "@@ -1259,16 +1259,15 @@ fn trans_eager_binop<'a>(\n                      -> DatumBlock<'a, Expr> {\n     let _icx = push_ctxt(\"trans_eager_binop\");\n \n-    let mut intype = {\n+    let tcx = bcx.tcx();\n+    let is_simd = ty::type_is_simd(tcx, lhs_t);\n+    let intype = {\n         if ty::type_is_bot(lhs_t) { rhs_t }\n+        else if is_simd { ty::simd_type(tcx, lhs_t) }\n         else { lhs_t }\n     };\n-    let tcx = bcx.tcx();\n-    if ty::type_is_simd(tcx, intype) {\n-        intype = ty::simd_type(tcx, intype);\n-    }\n     let is_float = ty::type_is_fp(intype);\n-    let signed = ty::type_is_signed(intype);\n+    let is_signed = ty::type_is_signed(intype);\n \n     let rhs = base::cast_shift_expr_rhs(bcx, op, lhs, rhs);\n \n@@ -1293,7 +1292,7 @@ fn trans_eager_binop<'a>(\n             // Only zero-check integers; fp /0 is NaN\n             bcx = base::fail_if_zero(bcx, binop_expr.span,\n                                      op, rhs, rhs_t);\n-            if signed {\n+            if is_signed {\n                 SDiv(bcx, lhs, rhs)\n             } else {\n                 UDiv(bcx, lhs, rhs)\n@@ -1307,7 +1306,7 @@ fn trans_eager_binop<'a>(\n             // Only zero-check integers; fp %0 is NaN\n             bcx = base::fail_if_zero(bcx, binop_expr.span,\n                                      op, rhs, rhs_t);\n-            if signed {\n+            if is_signed {\n                 SRem(bcx, lhs, rhs)\n             } else {\n                 URem(bcx, lhs, rhs)\n@@ -1319,21 +1318,21 @@ fn trans_eager_binop<'a>(\n       ast::BiBitXor => Xor(bcx, lhs, rhs),\n       ast::BiShl => Shl(bcx, lhs, rhs),\n       ast::BiShr => {\n-        if signed {\n+        if is_signed {\n             AShr(bcx, lhs, rhs)\n         } else { LShr(bcx, lhs, rhs) }\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if ty::type_is_bot(rhs_t) {\n             C_bool(bcx.ccx(), false)\n-        } else {\n-            if !ty::type_is_scalar(rhs_t) {\n-                bcx.tcx().sess.span_bug(binop_expr.span,\n-                                        \"non-scalar comparison\");\n-            }\n+        } else if ty::type_is_scalar(rhs_t) {\n             let cmpr = base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op);\n             bcx = cmpr.bcx;\n             ZExt(bcx, cmpr.val, Type::i8(bcx.ccx()))\n+        } else if is_simd {\n+            base::compare_simd_types(bcx, lhs, rhs, intype, ty::simd_size(tcx, lhs_t), op)\n+        } else {\n+            bcx.tcx().sess.span_bug(binop_expr.span, \"comparison operator unsupported for type\")\n         }\n       }\n       _ => {"}, {"sha": "e7d1a85957f479505679dd84bd20a882f1510807", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d0da4cfee7d95d37bdf41a53081996c31ec26d2f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0da4cfee7d95d37bdf41a53081996c31ec26d2f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d0da4cfee7d95d37bdf41a53081996c31ec26d2f", "patch": "@@ -2102,8 +2102,27 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n             let result_t = match op {\n                 ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGe |\n-                ast::BiGt => ty::mk_bool(),\n-                _ => lhs_t\n+                ast::BiGt => {\n+                    if ty::type_is_simd(tcx, lhs_t) {\n+                        if ty::type_is_fp(ty::simd_type(tcx, lhs_t)) {\n+                            fcx.type_error_message(expr.span,\n+                                |actual| {\n+                                    format!(\"binary comparison operation `{}` not supported \\\n+                                            for floating point SIMD vector `{}`\",\n+                                            ast_util::binop_to_str(op), actual)\n+                                },\n+                                lhs_t,\n+                                None\n+                            );\n+                            ty::mk_err()\n+                        } else {\n+                            lhs_t\n+                        }\n+                    } else {\n+                        ty::mk_bool()\n+                    }\n+                },\n+                _ => lhs_t,\n             };\n \n             fcx.write_ty(expr.id, result_t);"}, {"sha": "281e879592dde592a5b5ce0ba4e1c87cc4a6dd86", "filename": "src/test/compile-fail/simd-binop.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d0da4cfee7d95d37bdf41a53081996c31ec26d2f/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0da4cfee7d95d37bdf41a53081996c31ec26d2f/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-binop.rs?ref=d0da4cfee7d95d37bdf41a53081996c31ec26d2f", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+#![allow(experimental)]\n+\n+use std::unstable::simd::f32x4;\n+\n+fn main() {\n+\n+    let _ = f32x4(0.0, 0.0, 0.0, 0.0) == f32x4(0.0, 0.0, 0.0, 0.0);\n+    //~^ ERROR binary comparison operation `==` not supported for floating point SIMD vector `std::unstable::simd::f32x4`\n+\n+    let _ = f32x4(0.0, 0.0, 0.0, 0.0) != f32x4(0.0, 0.0, 0.0, 0.0);\n+    //~^ ERROR binary comparison operation `!=` not supported for floating point SIMD vector `std::unstable::simd::f32x4`\n+\n+    let _ = f32x4(0.0, 0.0, 0.0, 0.0) < f32x4(0.0, 0.0, 0.0, 0.0);\n+    //~^ ERROR binary comparison operation `<` not supported for floating point SIMD vector `std::unstable::simd::f32x4`\n+\n+    let _ = f32x4(0.0, 0.0, 0.0, 0.0) <= f32x4(0.0, 0.0, 0.0, 0.0);\n+    //~^ ERROR binary comparison operation `<=` not supported for floating point SIMD vector `std::unstable::simd::f32x4`\n+\n+    let _ = f32x4(0.0, 0.0, 0.0, 0.0) >= f32x4(0.0, 0.0, 0.0, 0.0);\n+    //~^ ERROR binary comparison operation `>=` not supported for floating point SIMD vector `std::unstable::simd::f32x4`\n+\n+    let _ = f32x4(0.0, 0.0, 0.0, 0.0) > f32x4(0.0, 0.0, 0.0, 0.0);\n+    //~^ ERROR binary comparison operation `>` not supported for floating point SIMD vector `std::unstable::simd::f32x4`\n+\n+}"}, {"sha": "efcd99a04cedd86534ddb475e9dee433b831cc9a", "filename": "src/test/run-pass/simd-binop.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d0da4cfee7d95d37bdf41a53081996c31ec26d2f/src%2Ftest%2Frun-pass%2Fsimd-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0da4cfee7d95d37bdf41a53081996c31ec26d2f/src%2Ftest%2Frun-pass%2Fsimd-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-binop.rs?ref=d0da4cfee7d95d37bdf41a53081996c31ec26d2f", "patch": "@@ -25,6 +25,8 @@ fn eq_i32x4(i32x4(x0, x1, x2, x3): i32x4, i32x4(y0, y1, y2, y3): i32x4) -> bool\n }\n \n pub fn main() {\n+    // arithmetic operators\n+\n     assert!(eq_u32x4(u32x4(1, 2, 3, 4) + u32x4(4, 3, 2, 1), u32x4(5, 5, 5, 5)));\n     assert!(eq_u32x4(u32x4(4, 5, 6, 7) - u32x4(4, 3, 2, 1), u32x4(0, 2, 4, 6)));\n     assert!(eq_u32x4(u32x4(1, 2, 3, 4) * u32x4(4, 3, 2, 1), u32x4(4, 6, 6, 4)));\n@@ -43,8 +45,28 @@ pub fn main() {\n     assert!(eq_i32x4(i32x4(1, 2, 3, 4) << i32x4(4, 3, 2, 1), i32x4(16, 16, 12, 8)));\n     assert!(eq_i32x4(i32x4(1, 2, 3, 4) >> i32x4(4, 3, 2, 1), i32x4(0, 0, 0, 2)));\n \n-    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) + f32x4(4.0, 3.0, 2.0, 1.0), f32x4(5.0, 5.0, 5.0, 5.0)));\n-    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) - f32x4(4.0, 3.0, 2.0, 1.0), f32x4(-3.0, -1.0, 1.0, 3.0)));\n-    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) * f32x4(4.0, 3.0, 2.0, 1.0), f32x4(4.0, 6.0, 6.0, 4.0)));\n-    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) / f32x4(4.0, 4.0, 2.0, 1.0), f32x4(0.25, 0.5, 1.5, 4.0)));\n+    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) + f32x4(4.0, 3.0, 2.0, 1.0),\n+            f32x4(5.0, 5.0, 5.0, 5.0)));\n+    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) - f32x4(4.0, 3.0, 2.0, 1.0),\n+            f32x4(-3.0, -1.0, 1.0, 3.0)));\n+    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) * f32x4(4.0, 3.0, 2.0, 1.0),\n+            f32x4(4.0, 6.0, 6.0, 4.0)));\n+    assert!(eq_f32x4(f32x4(1.0, 2.0, 3.0, 4.0) / f32x4(4.0, 4.0, 2.0, 1.0),\n+            f32x4(0.25, 0.5, 1.5, 4.0)));\n+\n+    // comparison operators\n+\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) == u32x4(3, 2, 1, 0), u32x4(0, !0, 0, 0)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) != u32x4(3, 2, 1, 0), u32x4(!0, 0, !0, !0)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) < u32x4(3, 2, 1, 0), u32x4(!0, 0, 0, 0)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) <= u32x4(3, 2, 1, 0), u32x4(!0, !0, 0, 0)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) >= u32x4(3, 2, 1, 0), u32x4(0, !0, !0, !0)));\n+    assert!(eq_u32x4(u32x4(1, 2, 3, 4) > u32x4(3, 2, 1, 0), u32x4(0, 0, !0, !0)));\n+\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) == i32x4(3, 2, 1, 0), i32x4(0, !0, 0, 0)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) != i32x4(3, 2, 1, 0), i32x4(!0, 0, !0, !0)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) < i32x4(3, 2, 1, 0), i32x4(!0, 0, 0, 0)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) <= i32x4(3, 2, 1, 0), i32x4(!0, !0, 0, 0)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) >= i32x4(3, 2, 1, 0), i32x4(0, !0, !0, !0)));\n+    assert!(eq_i32x4(i32x4(1, 2, 3, 4) > i32x4(3, 2, 1, 0), i32x4(0, 0, !0, !0)));\n }"}]}