{"sha": "b76f224af867b198e4051806cc6e1ac686085cdc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NmYyMjRhZjg2N2IxOThlNDA1MTgwNmNjNmUxYWM2ODYwODVjZGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-19T01:34:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-19T01:34:50Z"}, "message": "Auto merge of #45525 - MaikKlein:collector, r=eddyb\n\nMove collector to librustc_mir::monomorphize\n\ncc https://github.com/rust-lang/rust/issues/44334 and https://github.com/rust-lang/rust/issues/45276\n\n* I moved the collector to rustc_mir\n\n*  I renamed `TransItem` to `MonoItem`. _(I still need to fix up comments and variable names)_\n\n* I got rid of `common.rs` and `monomorphize.rs` from `librustc_trans_utils`. I moved most of the functionality into `TyCtxt`. I realized that the `librustc_trans_utils::common.rs` was just copy pasted from `librustc_trans::common.rs`.\n\nShould I also get rid of the `librustc_trans::common.rs` in this PR? Most of the functionality seems a bit useless, I decided to put some of it into `TyCtxt` but maybe that is not the correct action here.\n\nShould I also get rid of `librustc_trans_utils` completely here? Or should I do it in a separate PR?", "tree": {"sha": "3b2ac06f4ee7ca2ebef45cb53f098123ed235de6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b2ac06f4ee7ca2ebef45cb53f098123ed235de6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b76f224af867b198e4051806cc6e1ac686085cdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b76f224af867b198e4051806cc6e1ac686085cdc", "html_url": "https://github.com/rust-lang/rust/commit/b76f224af867b198e4051806cc6e1ac686085cdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b76f224af867b198e4051806cc6e1ac686085cdc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7db42fb5b9a620c5669711546663d0ccebf9291", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7db42fb5b9a620c5669711546663d0ccebf9291", "html_url": "https://github.com/rust-lang/rust/commit/e7db42fb5b9a620c5669711546663d0ccebf9291"}, {"sha": "6e78b665786b3f37730d5af3363ce74ad832282d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e78b665786b3f37730d5af3363ce74ad832282d", "html_url": "https://github.com/rust-lang/rust/commit/6e78b665786b3f37730d5af3363ce74ad832282d"}], "stats": {"total": 810, "additions": 372, "deletions": 438}, "files": [{"sha": "c22187ee13e8eaed8de6d38d8aaa4d24fe5b8c64", "filename": "src/Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -1923,6 +1923,7 @@ dependencies = [\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n+ \"rustc_trans_utils 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -2026,6 +2027,7 @@ dependencies = [\n  \"rustc_errors 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n  \"rustc_platform_intrinsics 0.0.0\",\n  \"rustc_trans_utils 0.0.0\",\n  \"serialize 0.0.0\","}, {"sha": "f00830f9ec99299fa8aaffc546cc0c46ec7b2fe4", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -136,7 +136,6 @@ pub mod middle {\n     pub mod recursion_limit;\n     pub mod resolve_lifetime;\n     pub mod stability;\n-    pub mod trans;\n     pub mod weak_lang_items;\n }\n "}, {"sha": "0ac2c2d4de8c0eca2b6e2c70fec7f53a4660ee54", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -44,6 +44,7 @@ pub mod tcx;\n pub mod visit;\n pub mod traversal;\n pub mod interpret;\n+pub mod mono;\n \n /// Types for locals\n type LocalDecls<'tcx> = IndexVec<Local, LocalDecl<'tcx>>;"}, {"sha": "5f74f088237837dba1d576a80e4a4692adba4c30", "filename": "src/librustc/mir/mono.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -17,24 +17,24 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasherResult,\n use ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n-pub enum TransItem<'tcx> {\n+pub enum MonoItem<'tcx> {\n     Fn(Instance<'tcx>),\n     Static(NodeId),\n     GlobalAsm(NodeId),\n }\n \n-impl<'tcx> HashStable<StableHashingContext<'tcx>> for TransItem<'tcx> {\n+impl<'tcx> HashStable<StableHashingContext<'tcx>> for MonoItem<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                            hcx: &mut StableHashingContext<'tcx>,\n                                            hasher: &mut StableHasher<W>) {\n         ::std::mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            TransItem::Fn(ref instance) => {\n+            MonoItem::Fn(ref instance) => {\n                 instance.hash_stable(hcx, hasher);\n             }\n-            TransItem::Static(node_id)    |\n-            TransItem::GlobalAsm(node_id) => {\n+            MonoItem::Static(node_id)    |\n+            MonoItem::GlobalAsm(node_id) => {\n                 hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n                     node_id.hash_stable(hcx, hasher);\n                 })\n@@ -49,7 +49,7 @@ pub struct CodegenUnit<'tcx> {\n     /// contain something unique to this crate (e.g., a module path)\n     /// as well as the crate name and disambiguator.\n     name: InternedString,\n-    items: FxHashMap<TransItem<'tcx>, (Linkage, Visibility)>,\n+    items: FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -110,12 +110,12 @@ impl<'tcx> CodegenUnit<'tcx> {\n         self.name = name;\n     }\n \n-    pub fn items(&self) -> &FxHashMap<TransItem<'tcx>, (Linkage, Visibility)> {\n+    pub fn items(&self) -> &FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)> {\n         &self.items\n     }\n \n     pub fn items_mut(&mut self)\n-        -> &mut FxHashMap<TransItem<'tcx>, (Linkage, Visibility)>\n+        -> &mut FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)>\n     {\n         &mut self.items\n     }", "previous_filename": "src/librustc/middle/trans.rs"}, {"sha": "c873580e3ad6c61243d69d01ee1b140fc8091552", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -17,6 +17,7 @@ use dep_graph::{DepKind, DepTrackingMapConfig};\n use infer::TransNormalize;\n use std::marker::PhantomData;\n use syntax_pos::DUMMY_SP;\n+use hir::def_id::DefId;\n use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext, Vtable};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::{Subst, Substs};\n@@ -119,6 +120,12 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         let substituted = self.erase_regions(&substituted);\n         AssociatedTypeNormalizerEnv::new(self, param_env).fold(&substituted)\n     }\n+\n+    pub fn trans_impl_self_ty(&self, def_id: DefId, substs: &'tcx Substs<'tcx>)\n+                              -> Ty<'tcx>\n+    {\n+        self.trans_apply_param_substs(substs, &self.type_of(def_id))\n+    }\n }\n \n struct AssociatedTypeNormalizer<'a, 'gcx: 'a> {\n@@ -214,4 +221,3 @@ impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n         DepKind::TraitSelect\n     }\n }\n-"}, {"sha": "5b87273194c696f133f71da56e4a788451b712f5", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -45,6 +45,16 @@ pub enum InstanceDef<'tcx> {\n     CloneShim(DefId, Ty<'tcx>),\n }\n \n+impl<'a, 'tcx> Instance<'tcx> {\n+    pub fn ty(&self,\n+              tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+              -> Ty<'tcx>\n+    {\n+        let ty = tcx.type_of(self.def.def_id());\n+        tcx.trans_apply_param_substs(self.substs, &ty)\n+    }\n+}\n+\n impl<'tcx> InstanceDef<'tcx> {\n     #[inline]\n     pub fn def_id(&self) -> DefId {\n@@ -59,15 +69,46 @@ impl<'tcx> InstanceDef<'tcx> {\n         }\n     }\n \n-    #[inline]\n-    pub fn def_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n-        tcx.type_of(self.def_id())\n-    }\n-\n     #[inline]\n     pub fn attrs<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::Attributes<'tcx> {\n         tcx.get_attrs(self.def_id())\n     }\n+\n+    pub fn is_inline<'a>(\n+        &self,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>\n+    ) -> bool {\n+        use hir::map::DefPathData;\n+        let def_id = match *self {\n+            ty::InstanceDef::Item(def_id) => def_id,\n+            ty::InstanceDef::DropGlue(_, Some(_)) => return false,\n+            _ => return true\n+        };\n+        match tcx.def_key(def_id).disambiguated_data.data {\n+            DefPathData::StructCtor |\n+            DefPathData::EnumVariant(..) |\n+            DefPathData::ClosureExpr => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn requires_local<'a>(\n+        &self,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>\n+    ) -> bool {\n+        use syntax::attr::requests_inline;\n+        if self.is_inline(tcx) {\n+            return true\n+        }\n+        if let ty::InstanceDef::DropGlue(..) = *self {\n+            // Drop glue wants to be instantiated at every translation\n+            // unit, but without an #[inline] hint. We should make this\n+            // available to normal end-users.\n+            return true\n+        }\n+        requests_inline(&self.attrs(tcx)[..]) ||\n+            tcx.is_const_fn(self.def_id())\n+    }\n }\n \n impl<'tcx> fmt::Display for Instance<'tcx> {"}, {"sha": "f6dd8b6e021b62d3a39edefd9bf35f4b264a2e2b", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -27,7 +27,7 @@ use middle::resolve_lifetime::{ResolveLifetimes, Region, ObjectLifetimeDefault};\n use middle::stability::{self, DeprecationEntry};\n use middle::lang_items::{LanguageItems, LangItem};\n use middle::exported_symbols::SymbolExportLevel;\n-use middle::trans::{CodegenUnit, Stats};\n+use mir::mono::{CodegenUnit, Stats};\n use mir;\n use session::{CompileResult, CrateDisambiguator};\n use session::config::OutputFilenames;"}, {"sha": "a54f15532b18ff7f64e4ddebe6a925da2933f9ed", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -23,3 +23,4 @@ syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n byteorder = { version = \"1.1\", features = [\"i128\"] }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n+rustc_trans_utils = { path = \"../librustc_trans_utils\" }"}, {"sha": "a37cf41baaba305495555c83cb3fc84c300ac00b", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -57,9 +57,7 @@ pub fn eval_body<'a, 'tcx>(\n     if ecx.tcx.has_attr(instance.def_id(), \"linkage\") {\n         return Err(ConstEvalError::NotConst(\"extern global\".to_string()).into());\n     }\n-    // FIXME(eddyb) use `Instance::ty` when it becomes available.\n-    let instance_ty =\n-        ecx.monomorphize(instance.def.def_ty(tcx), instance.substs);\n+    let instance_ty = instance.ty(tcx);\n     if tcx.interpret_interner.borrow().get_cached(cid).is_none() {\n         let mir = ecx.load_mir(instance.def)?;\n         let layout = ecx.layout_of(instance_ty)?;"}, {"sha": "140da7e1097f5edcc54f87e2ac115b16c03cfffd", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -172,9 +172,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             M::global_item_with_linkage(self, cid.instance, mutability)?;\n             return Ok(false);\n         }\n-        // FIXME(eddyb) use `Instance::ty` when it becomes available.\n-        let instance_ty =\n-            self.monomorphize(instance.def.def_ty(self.tcx), instance.substs);\n+        let instance_ty = instance.ty(self.tcx);\n         let layout = self.layout_of(instance_ty)?;\n         assert!(!layout.is_unsized());\n         let ptr = self.memory.allocate("}, {"sha": "3eef0578360ce54f656f131340d5d1a4766a9603", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -72,9 +72,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     ty::TyFnPtr(sig) => {\n                         let fn_ptr = self.value_to_primval(func)?.to_ptr()?;\n                         let instance = self.memory.get_fn(fn_ptr)?;\n-                        // FIXME(eddyb) use `Instance::ty` when it becomes available.\n-                        let instance_ty =\n-                            self.monomorphize(instance.def.def_ty(self.tcx), instance.substs);\n+                        let instance_ty = instance.ty(self.tcx);\n                         match instance_ty.sty {\n                             ty::TyFnDef(..) => {\n                                 let real_sig = instance_ty.fn_sig(self.tcx);"}, {"sha": "4d26230e0612b184be9003a135009672892ab699", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -54,6 +54,7 @@ extern crate core; // for NonZero\n extern crate log_settings;\n extern crate rustc_apfloat;\n extern crate byteorder;\n+extern crate rustc_trans_utils;\n \n mod diagnostics;\n \n@@ -65,6 +66,7 @@ mod shim;\n pub mod transform;\n pub mod util;\n pub mod interpret;\n+pub mod monomorphize;\n \n use rustc::ty::maps::Providers;\n "}, {"sha": "44dedde52294168eb7af06a9a290c80381ab9288", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "renamed", "additions": 134, "deletions": 121, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Translation Item Collection\n+//! Mono Item Collection\n //! ===========================\n //!\n //! This module is responsible for discovering all items that will contribute to\n@@ -22,7 +22,7 @@\n //! in crate X might produce monomorphizations that are compiled into crate Y.\n //! We also have to collect these here.\n //!\n-//! The following kinds of \"translation items\" are handled here:\n+//! The following kinds of \"mono items\" are handled here:\n //!\n //! - Functions\n //! - Methods\n@@ -43,24 +43,24 @@\n //! -----------------\n //! Let's define some terms first:\n //!\n-//! - A \"translation item\" is something that results in a function or global in\n-//!   the LLVM IR of a codegen unit. Translation items do not stand on their\n-//!   own, they can reference other translation items. For example, if function\n-//!   `foo()` calls function `bar()` then the translation item for `foo()`\n-//!   references the translation item for function `bar()`. In general, the\n-//!   definition for translation item A referencing a translation item B is that\n+//! - A \"mono item\" is something that results in a function or global in\n+//!   the LLVM IR of a codegen unit. Mono items do not stand on their\n+//!   own, they can reference other mono items. For example, if function\n+//!   `foo()` calls function `bar()` then the mono item for `foo()`\n+//!   references the mono item for function `bar()`. In general, the\n+//!   definition for mono item A referencing a mono item B is that\n //!   the LLVM artifact produced for A references the LLVM artifact produced\n //!   for B.\n //!\n-//! - Translation items and the references between them form a directed graph,\n-//!   where the translation items are the nodes and references form the edges.\n-//!   Let's call this graph the \"translation item graph\".\n+//! - Mono items and the references between them form a directed graph,\n+//!   where the mono items are the nodes and references form the edges.\n+//!   Let's call this graph the \"mono item graph\".\n //!\n-//! - The translation item graph for a program contains all translation items\n+//! - The mono item graph for a program contains all mono items\n //!   that are needed in order to produce the complete LLVM IR of the program.\n //!\n //! The purpose of the algorithm implemented in this module is to build the\n-//! translation item graph for the current crate. It runs in two phases:\n+//! mono item graph for the current crate. It runs in two phases:\n //!\n //! 1. Discover the roots of the graph by traversing the HIR of the crate.\n //! 2. Starting from the roots, find neighboring nodes by inspecting the MIR\n@@ -69,26 +69,26 @@\n //!\n //! ### Discovering roots\n //!\n-//! The roots of the translation item graph correspond to the non-generic\n+//! The roots of the mono item graph correspond to the non-generic\n //! syntactic items in the source code. We find them by walking the HIR of the\n //! crate, and whenever we hit upon a function, method, or static item, we\n-//! create a translation item consisting of the items DefId and, since we only\n+//! create a mono item consisting of the items DefId and, since we only\n //! consider non-generic items, an empty type-substitution set.\n //!\n //! ### Finding neighbor nodes\n-//! Given a translation item node, we can discover neighbors by inspecting its\n+//! Given a mono item node, we can discover neighbors by inspecting its\n //! MIR. We walk the MIR and any time we hit upon something that signifies a\n-//! reference to another translation item, we have found a neighbor. Since the\n-//! translation item we are currently at is always monomorphic, we also know the\n+//! reference to another mono item, we have found a neighbor. Since the\n+//! mono item we are currently at is always monomorphic, we also know the\n //! concrete type arguments of its neighbors, and so all neighbors again will be\n //! monomorphic. The specific forms a reference to a neighboring node can take\n //! in MIR are quite diverse. Here is an overview:\n //!\n //! #### Calling Functions/Methods\n-//! The most obvious form of one translation item referencing another is a\n+//! The most obvious form of one mono item referencing another is a\n //! function or method call (represented by a CALL terminator in MIR). But\n //! calls are not the only thing that might introduce a reference between two\n-//! function translation items, and as we will see below, they are just a\n+//! function mono items, and as we will see below, they are just a\n //! specialized of the form described next, and consequently will don't get any\n //! special treatment in the algorithm.\n //!\n@@ -112,10 +112,10 @@\n //! }\n //! ```\n //! The MIR of none of these functions will contain an explicit call to\n-//! `print_val::<i32>`. Nonetheless, in order to translate this program, we need\n+//! `print_val::<i32>`. Nonetheless, in order to mono this program, we need\n //! an instance of this function. Thus, whenever we encounter a function or\n //! method in operand position, we treat it as a neighbor of the current\n-//! translation item. Calls are just a special case of that.\n+//! mono item. Calls are just a special case of that.\n //!\n //! #### Closures\n //! In a way, closures are a simple case. Since every closure object needs to be\n@@ -124,8 +124,8 @@\n //! true for closures inlined from other crates.\n //!\n //! #### Drop glue\n-//! Drop glue translation items are introduced by MIR drop-statements. The\n-//! generated translation item will again have drop-glue item neighbors if the\n+//! Drop glue mono items are introduced by MIR drop-statements. The\n+//! generated mono item will again have drop-glue item neighbors if the\n //! type to be dropped contains nested values that also need to be dropped. It\n //! might also have a function item neighbor for the explicit `Drop::drop`\n //! implementation of its type.\n@@ -150,23 +150,23 @@\n //! defined in the source code of that crate. It will also contain monomorphic\n //! instantiations of any extern generic functions and of functions marked with\n //! #[inline].\n-//! The collection algorithm handles this more or less transparently. If it is\n-//! about to create a translation item for something with an external `DefId`,\n+//! The collection algorithm handles this more or less mono. If it is\n+//! about to create a mono item for something with an external `DefId`,\n //! it will take a look if the MIR for that item is available, and if so just\n //! proceed normally. If the MIR is not available, it assumes that the item is\n //! just linked to and no node is created; which is exactly what we want, since\n //! no machine code should be generated in the current crate for such an item.\n //!\n //! Eager and Lazy Collection Mode\n //! ------------------------------\n-//! Translation item collection can be performed in one of two modes:\n+//! Mono item collection can be performed in one of two modes:\n //!\n //! - Lazy mode means that items will only be instantiated when actually\n //!   referenced. The goal is to produce the least amount of machine code\n //!   possible.\n //!\n //! - Eager mode is meant to be used in conjunction with incremental compilation\n-//!   where a stable set of translation items is more important than a minimal\n+//!   where a stable set of mono items is more important than a minimal\n //!   one. Thus, eager mode will instantiate drop-glue for every drop-able type\n //!   in the crate, even of no drop call for that type exists (yet). It will\n //!   also instantiate default implementations of trait methods, something that\n@@ -183,9 +183,9 @@\n //! statics we cannot inspect these properly.\n //!\n //! ### Const Fns\n-//! Ideally, no translation item should be generated for const fns unless there\n+//! Ideally, no mono item should be generated for const fns unless there\n //! is a call to them that cannot be evaluated at compile time. At the moment\n-//! this is not implemented however: a translation item will be produced\n+//! this is not implemented however: a mono item will be produced\n //! regardless of whether it is actually needed or not.\n \n use rustc::hir;\n@@ -195,42 +195,41 @@ use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem};\n-use rustc::middle::trans::TransItem;\n use rustc::traits;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, TypeFoldable, Ty, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::mir::{self, Location};\n use rustc::mir::visit::Visitor as MirVisitor;\n+use rustc::mir::mono::MonoItem;\n \n-use common::{def_ty, instance_ty, type_has_metadata};\n use monomorphize::{self, Instance};\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n-use trans_item::{TransItemExt, DefPathBasedNames, InstantiationMode};\n+use monomorphize::item::{MonoItemExt, DefPathBasedNames, InstantiationMode};\n \n use rustc_data_structures::bitvec::BitVector;\n \n use syntax::attr;\n \n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n-pub enum TransItemCollectionMode {\n+pub enum MonoItemCollectionMode {\n     Eager,\n     Lazy\n }\n \n-/// Maps every translation item to all translation items it references in its\n+/// Maps every mono item to all mono items it references in its\n /// body.\n pub struct InliningMap<'tcx> {\n-    // Maps a source translation item to the range of translation items\n+    // Maps a source mono item to the range of mono items\n     // accessed by it.\n     // The two numbers in the tuple are the start (inclusive) and\n     // end index (exclusive) within the `targets` vecs.\n-    index: FxHashMap<TransItem<'tcx>, (usize, usize)>,\n-    targets: Vec<TransItem<'tcx>>,\n+    index: FxHashMap<MonoItem<'tcx>, (usize, usize)>,\n+    targets: Vec<MonoItem<'tcx>>,\n \n-    // Contains one bit per translation item in the `targets` field. That bit\n-    // is true if that translation item needs to be inlined into every CGU.\n+    // Contains one bit per mono item in the `targets` field. That bit\n+    // is true if that mono item needs to be inlined into every CGU.\n     inlines: BitVector,\n }\n \n@@ -245,9 +244,9 @@ impl<'tcx> InliningMap<'tcx> {\n     }\n \n     fn record_accesses<I>(&mut self,\n-                          source: TransItem<'tcx>,\n+                          source: MonoItem<'tcx>,\n                           new_targets: I)\n-        where I: Iterator<Item=(TransItem<'tcx>, bool)> + ExactSizeIterator\n+        where I: Iterator<Item=(MonoItem<'tcx>, bool)> + ExactSizeIterator\n     {\n         assert!(!self.index.contains_key(&source));\n \n@@ -271,8 +270,8 @@ impl<'tcx> InliningMap<'tcx> {\n \n     // Internally iterate over all items referenced by `source` which will be\n     // made available for inlining.\n-    pub fn with_inlining_candidates<F>(&self, source: TransItem<'tcx>, mut f: F)\n-        where F: FnMut(TransItem<'tcx>)\n+    pub fn with_inlining_candidates<F>(&self, source: MonoItem<'tcx>, mut f: F)\n+        where F: FnMut(MonoItem<'tcx>)\n     {\n         if let Some(&(start_index, end_index)) = self.index.get(&source) {\n             for (i, candidate) in self.targets[start_index .. end_index]\n@@ -287,21 +286,21 @@ impl<'tcx> InliningMap<'tcx> {\n \n     // Internally iterate over all items and the things each accesses.\n     pub fn iter_accesses<F>(&self, mut f: F)\n-        where F: FnMut(TransItem<'tcx>, &[TransItem<'tcx>])\n+        where F: FnMut(MonoItem<'tcx>, &[MonoItem<'tcx>])\n     {\n         for (&accessor, &(start_index, end_index)) in &self.index {\n             f(accessor, &self.targets[start_index .. end_index])\n         }\n     }\n }\n \n-pub fn collect_crate_translation_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 mode: TransItemCollectionMode)\n-                                                 -> (FxHashSet<TransItem<'tcx>>,\n+pub fn collect_crate_mono_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                          mode: MonoItemCollectionMode)\n+                                          -> (FxHashSet<MonoItem<'tcx>>,\n                                                      InliningMap<'tcx>) {\n     let roots = collect_roots(tcx, mode);\n \n-    debug!(\"Building translation item graph, beginning at roots\");\n+    debug!(\"Building mono item graph, beginning at roots\");\n     let mut visited = FxHashSet();\n     let mut recursion_depths = DefIdMap();\n     let mut inlining_map = InliningMap::new();\n@@ -320,8 +319,8 @@ pub fn collect_crate_translation_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           mode: TransItemCollectionMode)\n-                           -> Vec<TransItem<'tcx>> {\n+                           mode: MonoItemCollectionMode)\n+                           -> Vec<MonoItem<'tcx>> {\n     debug!(\"Collecting roots\");\n     let mut roots = Vec::new();\n \n@@ -348,10 +347,10 @@ fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     roots\n }\n \n-// Collect all monomorphized translation items reachable from `starting_point`\n+// Collect all monomorphized items reachable from `starting_point`\n fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   starting_point: TransItem<'tcx>,\n-                                   visited: &mut FxHashSet<TransItem<'tcx>>,\n+                                   starting_point: MonoItem<'tcx>,\n+                                   visited: &mut FxHashSet<MonoItem<'tcx>>,\n                                    recursion_depths: &mut DefIdMap<usize>,\n                                    inlining_map: &mut InliningMap<'tcx>) {\n     if !visited.insert(starting_point.clone()) {\n@@ -364,23 +363,23 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let recursion_depth_reset;\n \n     match starting_point {\n-        TransItem::Static(node_id) => {\n+        MonoItem::Static(node_id) => {\n             let def_id = tcx.hir.local_def_id(node_id);\n             let instance = Instance::mono(tcx, def_id);\n \n             // Sanity check whether this ended up being collected accidentally\n-            debug_assert!(should_trans_locally(tcx, &instance));\n+            debug_assert!(should_monomorphize_locally(tcx, &instance));\n \n-            let ty = instance_ty(tcx, &instance);\n+            let ty = instance.ty(tcx);\n             visit_drop_use(tcx, ty, true, &mut neighbors);\n \n             recursion_depth_reset = None;\n \n             collect_neighbours(tcx, instance, true, &mut neighbors);\n         }\n-        TransItem::Fn(instance) => {\n+        MonoItem::Fn(instance) => {\n             // Sanity check whether this ended up being collected accidentally\n-            debug_assert!(should_trans_locally(tcx, &instance));\n+            debug_assert!(should_monomorphize_locally(tcx, &instance));\n \n             // Keep track of the monomorphization recursion depth\n             recursion_depth_reset = Some(check_recursion_limit(tcx,\n@@ -390,7 +389,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             collect_neighbours(tcx, instance, false, &mut neighbors);\n         }\n-        TransItem::GlobalAsm(..) => {\n+        MonoItem::GlobalAsm(..) => {\n             recursion_depth_reset = None;\n         }\n     }\n@@ -409,16 +408,16 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn record_accesses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             caller: TransItem<'tcx>,\n-                             callees: &[TransItem<'tcx>],\n+                             caller: MonoItem<'tcx>,\n+                             callees: &[MonoItem<'tcx>],\n                              inlining_map: &mut InliningMap<'tcx>) {\n-    let is_inlining_candidate = |trans_item: &TransItem<'tcx>| {\n-        trans_item.instantiation_mode(tcx) == InstantiationMode::LocalCopy\n+    let is_inlining_candidate = |mono_item: &MonoItem<'tcx>| {\n+        mono_item.instantiation_mode(tcx) == InstantiationMode::LocalCopy\n     };\n \n     let accesses = callees.into_iter()\n-                          .map(|trans_item| {\n-                             (*trans_item, is_inlining_candidate(trans_item))\n+                          .map(|mono_item| {\n+                             (*mono_item, is_inlining_candidate(mono_item))\n                           });\n \n     inlining_map.record_accesses(caller, accesses);\n@@ -495,7 +494,7 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n struct MirNeighborCollector<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a mir::Mir<'tcx>,\n-    output: &'a mut Vec<TransItem<'tcx>>,\n+    output: &'a mut Vec<MonoItem<'tcx>>,\n     param_substs: &'tcx Substs<'tcx>,\n     const_context: bool,\n }\n@@ -522,10 +521,10 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 // from a fixed sized array to a slice. But we are only\n                 // interested in things that produce a vtable.\n                 if target_ty.is_trait() && !source_ty.is_trait() {\n-                    create_trans_items_for_vtable_methods(self.tcx,\n-                                                          target_ty,\n-                                                          source_ty,\n-                                                          self.output);\n+                    create_mono_items_for_vtable_methods(self.tcx,\n+                                                         target_ty,\n+                                                         source_ty,\n+                                                         self.output);\n                 }\n             }\n             mir::Rvalue::Cast(mir::CastKind::ReifyFnPointer, ref operand, _) => {\n@@ -542,7 +541,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     ty::TyClosure(def_id, substs) => {\n                         let instance = monomorphize::resolve_closure(\n                             self.tcx, def_id, substs, ty::ClosureKind::FnOnce);\n-                        self.output.push(create_fn_trans_item(instance));\n+                        self.output.push(create_fn_mono_item(instance));\n                     }\n                     _ => bug!(),\n                 }\n@@ -554,8 +553,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     .require(ExchangeMallocFnLangItem)\n                     .unwrap_or_else(|e| tcx.sess.fatal(&e));\n                 let instance = Instance::mono(tcx, exchange_malloc_fn_def_id);\n-                if should_trans_locally(tcx, &instance) {\n-                    self.output.push(create_fn_trans_item(instance));\n+                if should_monomorphize_locally(tcx, &instance) {\n+                    self.output.push(create_fn_mono_item(instance));\n                 }\n             }\n             _ => { /* not interesting */ }\n@@ -645,9 +644,9 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n         let tcx = self.tcx;\n         let instance = Instance::mono(tcx, static_.def_id);\n-        if should_trans_locally(tcx, &instance) {\n+        if should_monomorphize_locally(tcx, &instance) {\n             let node_id = tcx.hir.as_local_node_id(static_.def_id).unwrap();\n-            self.output.push(TransItem::Static(node_id));\n+            self.output.push(MonoItem::Static(node_id));\n         }\n \n         self.super_static(static_, context, location);\n@@ -657,7 +656,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n fn visit_drop_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             ty: Ty<'tcx>,\n                             is_direct_call: bool,\n-                            output: &mut Vec<TransItem<'tcx>>)\n+                            output: &mut Vec<MonoItem<'tcx>>)\n {\n     let instance = monomorphize::resolve_drop_in_place(tcx, ty);\n     visit_instance_use(tcx, instance, is_direct_call, output);\n@@ -666,7 +665,7 @@ fn visit_drop_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn visit_fn_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           ty: Ty<'tcx>,\n                           is_direct_call: bool,\n-                          output: &mut Vec<TransItem<'tcx>>)\n+                          output: &mut Vec<MonoItem<'tcx>>)\n {\n     if let ty::TyFnDef(def_id, substs) = ty.sty {\n         let instance = ty::Instance::resolve(tcx,\n@@ -680,10 +679,10 @@ fn visit_fn_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn visit_instance_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 instance: ty::Instance<'tcx>,\n                                 is_direct_call: bool,\n-                                output: &mut Vec<TransItem<'tcx>>)\n+                                output: &mut Vec<MonoItem<'tcx>>)\n {\n     debug!(\"visit_item_use({:?}, is_direct_call={:?})\", instance, is_direct_call);\n-    if !should_trans_locally(tcx, &instance) {\n+    if !should_monomorphize_locally(tcx, &instance) {\n         return\n     }\n \n@@ -697,26 +696,26 @@ fn visit_instance_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::InstanceDef::DropGlue(_, None) => {\n             // don't need to emit shim if we are calling directly.\n             if !is_direct_call {\n-                output.push(create_fn_trans_item(instance));\n+                output.push(create_fn_mono_item(instance));\n             }\n         }\n         ty::InstanceDef::DropGlue(_, Some(_)) => {\n-            output.push(create_fn_trans_item(instance));\n+            output.push(create_fn_mono_item(instance));\n         }\n         ty::InstanceDef::ClosureOnceShim { .. } |\n         ty::InstanceDef::Item(..) |\n         ty::InstanceDef::FnPtrShim(..) |\n         ty::InstanceDef::CloneShim(..) => {\n-            output.push(create_fn_trans_item(instance));\n+            output.push(create_fn_mono_item(instance));\n         }\n     }\n }\n \n // Returns true if we should translate an instance in the local crate.\n // Returns false if we can just link to the upstream crate and therefore don't\n-// need a translation item.\n-fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instance<'tcx>)\n-                                  -> bool {\n+// need a mono item.\n+fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instance<'tcx>)\n+                                         -> bool {\n     let def_id = match instance.def {\n         ty::InstanceDef::Item(def_id) => def_id,\n         ty::InstanceDef::ClosureOnceShim { .. } |\n@@ -740,7 +739,7 @@ fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instan\n                 false\n             } else {\n                 if !tcx.is_mir_available(def_id) {\n-                    bug!(\"Cannot create local trans-item for {:?}\", def_id)\n+                    bug!(\"Cannot create local mono-item for {:?}\", def_id)\n                 }\n                 true\n             }\n@@ -790,12 +789,25 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             target_ty: Ty<'tcx>)\n                                             -> (Ty<'tcx>, Ty<'tcx>) {\n     let ptr_vtable = |inner_source: Ty<'tcx>, inner_target: Ty<'tcx>| {\n-        if type_has_metadata(tcx, inner_source) {\n+        let type_has_metadata = |ty: Ty<'tcx>| -> bool {\n+            use syntax_pos::DUMMY_SP;\n+            if ty.is_sized(tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP) {\n+                return false;\n+            }\n+            let tail = tcx.struct_tail(ty);\n+            match tail.sty {\n+                ty::TyForeign(..) => false,\n+                ty::TyStr | ty::TySlice(..) | ty::TyDynamic(..) => true,\n+                _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n+            }\n+        };\n+        if type_has_metadata(inner_source) {\n             (inner_source, inner_target)\n         } else {\n             tcx.struct_lockstep_tails(inner_source, inner_target)\n         }\n     };\n+\n     match (&source_ty.sty, &target_ty.sty) {\n         (&ty::TyRef(_, ty::TypeAndMut { ty: a, .. }),\n          &ty::TyRef(_, ty::TypeAndMut { ty: b, .. })) |\n@@ -838,17 +850,17 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn create_fn_trans_item<'a, 'tcx>(instance: Instance<'tcx>) -> TransItem<'tcx> {\n-    debug!(\"create_fn_trans_item(instance={})\", instance);\n-    TransItem::Fn(instance)\n+fn create_fn_mono_item<'a, 'tcx>(instance: Instance<'tcx>) -> MonoItem<'tcx> {\n+    debug!(\"create_fn_mono_item(instance={})\", instance);\n+    MonoItem::Fn(instance)\n }\n \n-/// Creates a `TransItem` for each method that is referenced by the vtable for\n+/// Creates a `MonoItem` for each method that is referenced by the vtable for\n /// the given trait/impl pair.\n-fn create_trans_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                   trait_ty: Ty<'tcx>,\n-                                                   impl_ty: Ty<'tcx>,\n-                                                   output: &mut Vec<TransItem<'tcx>>) {\n+fn create_mono_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                  trait_ty: Ty<'tcx>,\n+                                                  impl_ty: Ty<'tcx>,\n+                                                  output: &mut Vec<MonoItem<'tcx>>) {\n     assert!(!trait_ty.needs_subst() && !trait_ty.has_escaping_regions() &&\n             !impl_ty.needs_subst() && !impl_ty.has_escaping_regions());\n \n@@ -865,8 +877,8 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         ty::ParamEnv::empty(traits::Reveal::All),\n                         def_id,\n                         substs).unwrap())\n-                .filter(|&instance| should_trans_locally(tcx, &instance))\n-                .map(|instance| create_fn_trans_item(instance));\n+                .filter(|&instance| should_monomorphize_locally(tcx, &instance))\n+                .map(|instance| create_fn_mono_item(instance));\n             output.extend(methods);\n         }\n         // Also add the destructor\n@@ -880,8 +892,8 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mode: TransItemCollectionMode,\n-    output: &'b mut Vec<TransItem<'tcx>>,\n+    mode: MonoItemCollectionMode,\n+    output: &'b mut Vec<MonoItem<'tcx>>,\n     entry_fn: Option<DefId>,\n }\n \n@@ -900,23 +912,23 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n             }\n \n             hir::ItemImpl(..) => {\n-                if self.mode == TransItemCollectionMode::Eager {\n-                    create_trans_items_for_default_impls(self.tcx,\n-                                                         item,\n-                                                         self.output);\n+                if self.mode == MonoItemCollectionMode::Eager {\n+                    create_mono_items_for_default_impls(self.tcx,\n+                                                        item,\n+                                                        self.output);\n                 }\n             }\n \n             hir::ItemEnum(_, ref generics) |\n             hir::ItemStruct(_, ref generics) |\n             hir::ItemUnion(_, ref generics) => {\n                 if !generics.is_parameterized() {\n-                    if self.mode == TransItemCollectionMode::Eager {\n+                    if self.mode == MonoItemCollectionMode::Eager {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n                                def_id_to_string(self.tcx, def_id));\n \n-                        let ty = def_ty(self.tcx, def_id, Substs::empty());\n+                        let ty = Instance::new(def_id, Substs::empty()).ty(self.tcx);\n                         visit_drop_use(self.tcx, ty, true, self.output);\n                     }\n                 }\n@@ -925,16 +937,16 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 debug!(\"RootCollector: ItemGlobalAsm({})\",\n                        def_id_to_string(self.tcx,\n                                         self.tcx.hir.local_def_id(item.id)));\n-                self.output.push(TransItem::GlobalAsm(item.id));\n+                self.output.push(MonoItem::GlobalAsm(item.id));\n             }\n             hir::ItemStatic(..) => {\n                 debug!(\"RootCollector: ItemStatic({})\",\n                        def_id_to_string(self.tcx,\n                                         self.tcx.hir.local_def_id(item.id)));\n-                self.output.push(TransItem::Static(item.id));\n+                self.output.push(MonoItem::Static(item.id));\n             }\n             hir::ItemConst(..) => {\n-                // const items only generate translation items if they are\n+                // const items only generate mono items if they are\n                 // actually used somewhere. Just declaring them is insufficient.\n             }\n             hir::ItemFn(..) => {\n@@ -946,7 +958,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                            def_id_to_string(tcx, def_id));\n \n                     let instance = Instance::mono(tcx, def_id);\n-                    self.output.push(TransItem::Fn(instance));\n+                    self.output.push(MonoItem::Fn(instance));\n                 }\n             }\n         }\n@@ -968,7 +980,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                            def_id_to_string(tcx, def_id));\n \n                     let instance = Instance::mono(tcx, def_id);\n-                    self.output.push(TransItem::Fn(instance));\n+                    self.output.push(MonoItem::Fn(instance));\n                 }\n             }\n             _ => { /* Nothing to do here */ }\n@@ -979,10 +991,10 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n     fn is_root(&self, def_id: DefId) -> bool {\n         !item_has_type_parameters(self.tcx, def_id) && match self.mode {\n-            TransItemCollectionMode::Eager => {\n+            MonoItemCollectionMode::Eager => {\n                 true\n             }\n-            TransItemCollectionMode::Lazy => {\n+            MonoItemCollectionMode::Lazy => {\n                 self.entry_fn == Some(def_id) ||\n                 self.tcx.is_exported_symbol(def_id) ||\n                 attr::contains_name(&self.tcx.get_attrs(def_id),\n@@ -997,9 +1009,9 @@ fn item_has_type_parameters<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n     generics.parent_types as usize + generics.types.len() > 0\n }\n \n-fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                  item: &'tcx hir::Item,\n-                                                  output: &mut Vec<TransItem<'tcx>>) {\n+fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                 item: &'tcx hir::Item,\n+                                                 output: &mut Vec<MonoItem<'tcx>>) {\n     match item.node {\n         hir::ItemImpl(_,\n                       _,\n@@ -1013,7 +1025,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             let impl_def_id = tcx.hir.local_def_id(item.id);\n \n-            debug!(\"create_trans_items_for_default_impls(item={})\",\n+            debug!(\"create_mono_items_for_default_impls(item={})\",\n                    def_id_to_string(tcx, impl_def_id));\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n@@ -1036,9 +1048,10 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                          method.def_id,\n                                                          callee_substs).unwrap();\n \n-                    let trans_item = create_fn_trans_item(instance);\n-                    if trans_item.is_instantiable(tcx) && should_trans_locally(tcx, &instance) {\n-                        output.push(trans_item);\n+                    let mono_item = create_fn_mono_item(instance);\n+                    if mono_item.is_instantiable(tcx)\n+                        && should_monomorphize_locally(tcx, &instance) {\n+                        output.push(mono_item);\n                     }\n                 }\n             }\n@@ -1053,7 +1066,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 instance: Instance<'tcx>,\n                                 const_context: bool,\n-                                output: &mut Vec<TransItem<'tcx>>)\n+                                output: &mut Vec<MonoItem<'tcx>>)\n {\n     let mir = tcx.instance_mir(instance.def);\n ", "previous_filename": "src/librustc_trans_utils/collector.rs"}, {"sha": "c3fb126ea182249df2b430e40f3bdfceb7b653fd", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "renamed", "additions": 53, "deletions": 29, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -14,11 +14,9 @@\n //! item-path. This is used for unit testing the code that generates\n //! paths etc in all kinds of annoying scenarios.\n \n-use common;\n use monomorphize::Instance;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::middle::trans::Linkage;\n use rustc::session::config::OptLevel;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -27,11 +25,12 @@ use syntax::ast;\n use syntax::attr::{self, InlineAttr};\n use std::fmt::{self, Write};\n use std::iter;\n-\n-pub use rustc::middle::trans::TransItem;\n+use rustc::mir::mono::Linkage;\n+use syntax_pos::symbol::Symbol;\n+pub use rustc::mir::mono::MonoItem;\n \n pub fn linkage_by_name(name: &str) -> Option<Linkage> {\n-    use rustc::middle::trans::Linkage::*;\n+    use rustc::mir::mono::Linkage::*;\n \n     // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n     // applicable to variable declarations and may not really make sense for\n@@ -60,7 +59,7 @@ pub fn linkage_by_name(name: &str) -> Option<Linkage> {\n /// Describes how a translation item will be instantiated in object files.\n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n pub enum InstantiationMode {\n-    /// There will be exactly one instance of the given TransItem. It will have\n+    /// There will be exactly one instance of the given MonoItem. It will have\n     /// external linkage so that it can be linked to from other codegen units.\n     GloballyShared {\n         /// In some compilation scenarios we may decide to take functions that\n@@ -77,14 +76,39 @@ pub enum InstantiationMode {\n         may_conflict: bool,\n     },\n \n-    /// Each codegen unit containing a reference to the given TransItem will\n+    /// Each codegen unit containing a reference to the given MonoItem will\n     /// have its own private copy of the function (with internal linkage).\n     LocalCopy,\n }\n \n-pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n-    fn as_trans_item(&self) -> &TransItem<'tcx>;\n+pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n+    fn as_mono_item(&self) -> &MonoItem<'tcx>;\n+\n+    fn is_generic_fn(&self) -> bool {\n+        match *self.as_mono_item() {\n+            MonoItem::Fn(ref instance) => {\n+                instance.substs.types().next().is_some()\n+            }\n+            MonoItem::Static(..) |\n+            MonoItem::GlobalAsm(..) => false,\n+        }\n+    }\n \n+    fn symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::SymbolName {\n+        match *self.as_mono_item() {\n+            MonoItem::Fn(instance) => tcx.symbol_name(instance),\n+            MonoItem::Static(node_id) => {\n+                let def_id = tcx.hir.local_def_id(node_id);\n+                tcx.symbol_name(Instance::mono(tcx, def_id))\n+            }\n+            MonoItem::GlobalAsm(node_id) => {\n+                let def_id = tcx.hir.local_def_id(node_id);\n+                ty::SymbolName {\n+                    name: Symbol::intern(&format!(\"global_asm_{:?}\", def_id)).as_str()\n+                }\n+            }\n+        }\n+    }\n     fn instantiation_mode(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                           -> InstantiationMode {\n@@ -93,12 +117,12 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n                 tcx.sess.opts.optimize != OptLevel::No\n             });\n \n-        match *self.as_trans_item() {\n-            TransItem::Fn(ref instance) => {\n+        match *self.as_mono_item() {\n+            MonoItem::Fn(ref instance) => {\n                 // If this function isn't inlined or otherwise has explicit\n                 // linkage, then we'll be creating a globally shared version.\n                 if self.explicit_linkage(tcx).is_some() ||\n-                    !common::requests_inline(tcx, instance)\n+                    !instance.def.requires_local(tcx)\n                 {\n                     return InstantiationMode::GloballyShared  { may_conflict: false }\n                 }\n@@ -123,20 +147,20 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n                     }\n                 }\n             }\n-            TransItem::Static(..) => {\n+            MonoItem::Static(..) => {\n                 InstantiationMode::GloballyShared { may_conflict: false }\n             }\n-            TransItem::GlobalAsm(..) => {\n+            MonoItem::GlobalAsm(..) => {\n                 InstantiationMode::GloballyShared { may_conflict: false }\n             }\n         }\n     }\n \n     fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Linkage> {\n-        let def_id = match *self.as_trans_item() {\n-            TransItem::Fn(ref instance) => instance.def_id(),\n-            TransItem::Static(node_id) => tcx.hir.local_def_id(node_id),\n-            TransItem::GlobalAsm(..) => return None,\n+        let def_id = match *self.as_mono_item() {\n+            MonoItem::Fn(ref instance) => instance.def_id(),\n+            MonoItem::Static(node_id) => tcx.hir.local_def_id(node_id),\n+            MonoItem::GlobalAsm(..) => return None,\n         };\n \n         let attributes = tcx.get_attrs(def_id);\n@@ -183,11 +207,11 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n     /// which will never be accessed) in its place.\n     fn is_instantiable(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n         debug!(\"is_instantiable({:?})\", self);\n-        let (def_id, substs) = match *self.as_trans_item() {\n-            TransItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n-            TransItem::Static(node_id) => (tcx.hir.local_def_id(node_id), Substs::empty()),\n+        let (def_id, substs) = match *self.as_mono_item() {\n+            MonoItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n+            MonoItem::Static(node_id) => (tcx.hir.local_def_id(node_id), Substs::empty()),\n             // global asm never has predicates\n-            TransItem::GlobalAsm(..) => return true\n+            MonoItem::GlobalAsm(..) => return true\n         };\n \n         let predicates = tcx.predicates_of(def_id).predicates.subst(tcx, substs);\n@@ -197,16 +221,16 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n     fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n         let hir_map = &tcx.hir;\n \n-        return match *self.as_trans_item() {\n-            TransItem::Fn(instance) => {\n+        return match *self.as_mono_item() {\n+            MonoItem::Fn(instance) => {\n                 to_string_internal(tcx, \"fn \", instance)\n             },\n-            TransItem::Static(node_id) => {\n+            MonoItem::Static(node_id) => {\n                 let def_id = hir_map.local_def_id(node_id);\n                 let instance = Instance::new(def_id, tcx.intern_substs(&[]));\n                 to_string_internal(tcx, \"static \", instance)\n             },\n-            TransItem::GlobalAsm(..) => {\n+            MonoItem::GlobalAsm(..) => {\n                 \"global_asm\".to_string()\n             }\n         };\n@@ -224,14 +248,14 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug {\n     }\n }\n \n-impl<'a, 'tcx> TransItemExt<'a, 'tcx> for TransItem<'tcx> {\n-    fn as_trans_item(&self) -> &TransItem<'tcx> {\n+impl<'a, 'tcx> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n+    fn as_mono_item(&self) -> &MonoItem<'tcx> {\n         self\n     }\n }\n \n //=-----------------------------------------------------------------------------\n-// TransItem String Keys\n+// MonoItem String Keys\n //=-----------------------------------------------------------------------------\n \n // The code below allows for producing a unique string key for a trans item.", "previous_filename": "src/librustc_trans_utils/trans_item.rs"}, {"sha": "fcf0d71dccb48ab2a7121c28c745f7efa9635fd2", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "renamed", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -16,6 +16,11 @@ use rustc::ty::subst::Kind;\n use rustc::ty::{self, Ty, TyCtxt};\n \n pub use rustc::ty::Instance;\n+pub use self::item::{MonoItem, MonoItemExt};\n+\n+pub mod collector;\n+pub mod item;\n+pub mod partitioning;\n \n fn fn_once_adapter_instance<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -124,4 +129,3 @@ pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n }\n-", "previous_filename": "src/librustc_trans_utils/monomorphize.rs"}, {"sha": "e2640d695c6d0dc029fc16504515f6272fcc569e", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "renamed", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -102,21 +102,21 @@\n //! source-level module, functions from the same module will be available for\n //! inlining, even when they are not marked #[inline].\n \n-use collector::InliningMap;\n-use common;\n+use monomorphize::collector::InliningMap;\n use rustc::dep_graph::WorkProductId;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n-use rustc::middle::trans::{Linkage, Visibility};\n+use rustc::mir::mono::{Linkage, Visibility};\n use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use std::collections::hash_map::Entry;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n-use trans_item::{TransItem, BaseTransItemExt, TransItemExt, InstantiationMode};\n+use rustc::mir::mono::MonoItem;\n+use monomorphize::item::{MonoItemExt, InstantiationMode};\n \n-pub use rustc::middle::trans::CodegenUnit;\n+pub use rustc::mir::mono::CodegenUnit;\n \n pub enum PartitioningStrategy {\n     /// Generate one codegen unit per source-level module.\n@@ -129,7 +129,7 @@ pub enum PartitioningStrategy {\n pub trait CodegenUnitExt<'tcx> {\n     fn as_codegen_unit(&self) -> &CodegenUnit<'tcx>;\n \n-    fn contains_item(&self, item: &TransItem<'tcx>) -> bool {\n+    fn contains_item(&self, item: &MonoItem<'tcx>) -> bool {\n         self.items().contains_key(item)\n     }\n \n@@ -139,7 +139,7 @@ pub trait CodegenUnitExt<'tcx> {\n         &self.as_codegen_unit().name()\n     }\n \n-    fn items(&self) -> &FxHashMap<TransItem<'tcx>, (Linkage, Visibility)> {\n+    fn items(&self) -> &FxHashMap<MonoItem<'tcx>, (Linkage, Visibility)> {\n         &self.as_codegen_unit().items()\n     }\n \n@@ -149,17 +149,17 @@ pub trait CodegenUnitExt<'tcx> {\n \n     fn items_in_deterministic_order<'a>(&self,\n                                         tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                        -> Vec<(TransItem<'tcx>,\n-                                               (Linkage, Visibility))> {\n+                                        -> Vec<(MonoItem<'tcx>,\n+                                                (Linkage, Visibility))> {\n         // The codegen tests rely on items being process in the same order as\n         // they appear in the file, so for local items, we sort by node_id first\n         #[derive(PartialEq, Eq, PartialOrd, Ord)]\n         pub struct ItemSortKey(Option<NodeId>, ty::SymbolName);\n \n         fn item_sort_key<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   item: TransItem<'tcx>) -> ItemSortKey {\n+                                   item: MonoItem<'tcx>) -> ItemSortKey {\n             ItemSortKey(match item {\n-                TransItem::Fn(ref instance) => {\n+                MonoItem::Fn(ref instance) => {\n                     match instance.def {\n                         // We only want to take NodeIds of user-defined\n                         // instances into account. The others don't matter for\n@@ -178,8 +178,8 @@ pub trait CodegenUnitExt<'tcx> {\n                         }\n                     }\n                 }\n-                TransItem::Static(node_id) |\n-                TransItem::GlobalAsm(node_id) => {\n+                MonoItem::Static(node_id) |\n+                MonoItem::GlobalAsm(node_id) => {\n                     Some(node_id)\n                 }\n             }, item.symbol_name(tcx))\n@@ -207,7 +207,7 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               strategy: PartitioningStrategy,\n                               inlining_map: &InliningMap<'tcx>)\n                               -> Vec<CodegenUnit<'tcx>>\n-    where I: Iterator<Item = TransItem<'tcx>>\n+    where I: Iterator<Item = MonoItem<'tcx>>\n {\n     // In the first step, we place all regular translation items into their\n     // respective 'home' codegen unit. Regular translation items are all\n@@ -254,8 +254,8 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n struct PreInliningPartitioning<'tcx> {\n     codegen_units: Vec<CodegenUnit<'tcx>>,\n-    roots: FxHashSet<TransItem<'tcx>>,\n-    internalization_candidates: FxHashSet<TransItem<'tcx>>,\n+    roots: FxHashSet<MonoItem<'tcx>>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n }\n \n /// For symbol internalization, we need to know whether a symbol/trans-item is\n@@ -269,14 +269,14 @@ enum TransItemPlacement {\n \n struct PostInliningPartitioning<'tcx> {\n     codegen_units: Vec<CodegenUnit<'tcx>>,\n-    trans_item_placements: FxHashMap<TransItem<'tcx>, TransItemPlacement>,\n-    internalization_candidates: FxHashSet<TransItem<'tcx>>,\n+    trans_item_placements: FxHashMap<MonoItem<'tcx>, TransItemPlacement>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n }\n \n fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              trans_items: I)\n                                              -> PreInliningPartitioning<'tcx>\n-    where I: Iterator<Item = TransItem<'tcx>>\n+    where I: Iterator<Item = MonoItem<'tcx>>\n {\n     let mut roots = FxHashSet();\n     let mut codegen_units = FxHashMap();\n@@ -309,7 +309,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             Some(explicit_linkage) => (explicit_linkage, Visibility::Default),\n             None => {\n                 match trans_item {\n-                    TransItem::Fn(ref instance) => {\n+                    MonoItem::Fn(ref instance) => {\n                         let visibility = match instance.def {\n                             InstanceDef::Item(def_id) => {\n                                 if def_id.is_local() {\n@@ -333,8 +333,8 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         };\n                         (Linkage::External, visibility)\n                     }\n-                    TransItem::Static(node_id) |\n-                    TransItem::GlobalAsm(node_id) => {\n+                    MonoItem::Static(node_id) |\n+                    MonoItem::GlobalAsm(node_id) => {\n                         let def_id = tcx.hir.local_def_id(node_id);\n                         let visibility = if tcx.is_exported_symbol(def_id) {\n                             Visibility::Default\n@@ -469,9 +469,9 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n         internalization_candidates,\n     };\n \n-    fn follow_inlining<'tcx>(trans_item: TransItem<'tcx>,\n+    fn follow_inlining<'tcx>(trans_item: MonoItem<'tcx>,\n                              inlining_map: &InliningMap<'tcx>,\n-                             visited: &mut FxHashSet<TransItem<'tcx>>) {\n+                             visited: &mut FxHashSet<MonoItem<'tcx>>) {\n         if !visited.insert(trans_item) {\n             return;\n         }\n@@ -501,7 +501,7 @@ fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Build a map from every translation item to all the translation items that\n     // reference it.\n-    let mut accessor_map: FxHashMap<TransItem<'tcx>, Vec<TransItem<'tcx>>> = FxHashMap();\n+    let mut accessor_map: FxHashMap<MonoItem<'tcx>, Vec<MonoItem<'tcx>>> = FxHashMap();\n     inlining_map.iter_accesses(|accessor, accessees| {\n         for accessee in accessees {\n             accessor_map.entry(*accessee)\n@@ -548,10 +548,10 @@ fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 trans_item: TransItem<'tcx>)\n+                                                 trans_item: MonoItem<'tcx>)\n                                                  -> Option<DefId> {\n     match trans_item {\n-        TransItem::Fn(instance) => {\n+        MonoItem::Fn(instance) => {\n             let def_id = match instance.def {\n                 ty::InstanceDef::Item(def_id) => def_id,\n                 ty::InstanceDef::FnPtrShim(..) |\n@@ -575,16 +575,16 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n                 // This is a method within an inherent impl, find out what the\n                 // self-type is:\n-                let impl_self_ty = common::def_ty(tcx, impl_def_id, instance.substs);\n+                let impl_self_ty = tcx.trans_impl_self_ty(impl_def_id, instance.substs);\n                 if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n                     return Some(def_id);\n                 }\n             }\n \n             Some(def_id)\n         }\n-        TransItem::Static(node_id) |\n-        TransItem::GlobalAsm(node_id) => Some(tcx.hir.local_def_id(node_id)),\n+        MonoItem::Static(node_id) |\n+        MonoItem::GlobalAsm(node_id) => Some(tcx.hir.local_def_id(node_id)),\n     }\n }\n ", "previous_filename": "src/librustc_trans/partitioning.rs"}, {"sha": "f1549d98421543ca0f25857ffd7aa5310428a753", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -28,6 +28,7 @@ rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n rustc_trans_utils = { path = \"../librustc_trans_utils\" }\n+rustc_mir = { path = \"../librustc_mir\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "32dc1067d37c1a8e1484470f636e6ba238e7ceaa", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef, AttributePlace};\n use base;\n use builder::Builder;\n-use common::{instance_ty, ty_fn_sig, C_usize};\n+use common::{ty_fn_sig, C_usize};\n use context::CrateContext;\n use cabi_x86;\n use cabi_x86_64;\n@@ -649,7 +649,7 @@ pub struct FnType<'tcx> {\n impl<'a, 'tcx> FnType<'tcx> {\n     pub fn of_instance(ccx: &CrateContext<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n                        -> Self {\n-        let fn_ty = instance_ty(ccx.tcx(), &instance);\n+        let fn_ty = instance.ty(ccx.tcx());\n         let sig = ty_fn_sig(ccx, fn_ty);\n         let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n         FnType::new(ccx, sig, &[])"}, {"sha": "825f306499a7c41c274c5ce6d79c5139efdd916f", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -98,10 +98,10 @@\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n use monomorphize::Instance;\n-use trans_item::{BaseTransItemExt, InstantiationMode};\n+use trans_item::{BaseMonoItemExt, InstantiationMode};\n \n use rustc::middle::weak_lang_items;\n-use rustc::middle::trans::TransItem;\n+use rustc::mir::mono::MonoItem;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -211,7 +211,7 @@ fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // codegen units) then this symbol may become an exported (but hidden\n         // visibility) symbol. This means that multiple crates may do the same\n         // and we want to be sure to avoid any symbol conflicts here.\n-        match TransItem::Fn(instance).instantiation_mode(tcx) {\n+        match MonoItem::Fn(instance).instantiation_mode(tcx) {\n             InstantiationMode::GloballyShared { may_conflict: true } => {\n                 avoid_cross_crate_conflicts = true;\n             }"}, {"sha": "79b3d314e12ffa00b5708eac8a801216bd2db3ac", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -38,8 +38,8 @@ use llvm;\n use metadata;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::middle::lang_items::StartFnLangItem;\n-use rustc::middle::trans::{Linkage, Visibility, Stats};\n-use rustc::middle::cstore::EncodedMetadata;\n+use rustc::mir::mono::{Linkage, Visibility, Stats};\n+use rustc::middle::cstore::{EncodedMetadata};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf};\n use rustc::ty::maps::Providers;\n@@ -55,7 +55,7 @@ use attributes;\n use builder::Builder;\n use callee;\n use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n-use collector::{self, TransItemCollectionMode};\n+use rustc_mir::monomorphize::collector::{self, MonoItemCollectionMode};\n use common::{self, C_struct_in_context, C_array, CrateContext, val_ty};\n use consts;\n use context::{self, LocalCrateContext, SharedCrateContext};\n@@ -64,10 +64,10 @@ use declare;\n use meth;\n use mir;\n use monomorphize::Instance;\n-use partitioning::{self, PartitioningStrategy, CodegenUnit, CodegenUnitExt};\n+use monomorphize::partitioning::{self, PartitioningStrategy, CodegenUnit, CodegenUnitExt};\n use symbol_names_test;\n use time_graph;\n-use trans_item::{TransItem, BaseTransItemExt, TransItemExt, DefPathBasedNames};\n+use trans_item::{MonoItem, BaseMonoItemExt, MonoItemExt, DefPathBasedNames};\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet, DefIdSet};\n@@ -89,7 +89,7 @@ use syntax::ast;\n use mir::operand::OperandValue;\n \n pub use rustc_trans_utils::{find_exported_symbols, check_for_rustc_errors_attr};\n-pub use rustc_trans_utils::trans_item::linkage_by_name;\n+pub use rustc_mir::monomorphize::item::linkage_by_name;\n \n pub struct StatRecorder<'a, 'tcx: 'a> {\n     ccx: &'a CrateContext<'a, 'tcx>,\n@@ -468,7 +468,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     // release builds.\n     info!(\"trans_instance({})\", instance);\n \n-    let fn_ty = common::instance_ty(ccx.tcx(), &instance);\n+    let fn_ty = instance.ty(ccx.tcx());\n     let sig = common::ty_fn_sig(ccx, fn_ty);\n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n \n@@ -530,7 +530,7 @@ fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n \n     let instance = Instance::mono(ccx.tcx(), main_def_id);\n \n-    if !ccx.codegen_unit().contains_item(&TransItem::Fn(instance)) {\n+    if !ccx.codegen_unit().contains_item(&MonoItem::Fn(instance)) {\n         // We want to create the wrapper in the same codegen unit as Rust's main\n         // function.\n         return;\n@@ -943,7 +943,7 @@ fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n #[inline(never)] // give this a place in the profiler\n fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trans_items: I)\n-    where I: Iterator<Item=&'a TransItem<'tcx>>\n+    where I: Iterator<Item=&'a MonoItem<'tcx>>\n {\n     let mut symbols: Vec<_> = trans_items.map(|trans_item| {\n         (trans_item, trans_item.symbol_name(tcx))\n@@ -1002,7 +1002,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n             let mode_string = s.to_lowercase();\n             let mode_string = mode_string.trim();\n             if mode_string == \"eager\" {\n-                TransItemCollectionMode::Eager\n+                MonoItemCollectionMode::Eager\n             } else {\n                 if mode_string != \"lazy\" {\n                     let message = format!(\"Unknown codegen-item collection mode '{}'. \\\n@@ -1011,15 +1011,15 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n                     tcx.sess.warn(&message);\n                 }\n \n-                TransItemCollectionMode::Lazy\n+                MonoItemCollectionMode::Lazy\n             }\n         }\n-        None => TransItemCollectionMode::Lazy\n+        None => MonoItemCollectionMode::Lazy\n     };\n \n     let (items, inlining_map) =\n         time(time_passes, \"translation item collection\", || {\n-            collector::collect_crate_translation_items(tcx, collection_mode)\n+            collector::collect_crate_mono_items(tcx, collection_mode)\n     });\n \n     assert_symbols_are_distinct(tcx, items.iter());\n@@ -1042,7 +1042,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n \n     let translation_items: DefIdSet = items.iter().filter_map(|trans_item| {\n         match *trans_item {\n-            TransItem::Fn(ref instance) => Some(instance.def_id()),\n+            MonoItem::Fn(ref instance) => Some(instance.def_id()),\n             _ => None,\n         }\n     }).collect();"}, {"sha": "0a0f2615a1bd162242051521a0a71ae9adface6a", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -48,7 +48,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     assert!(!instance.substs.has_escaping_regions());\n     assert!(!instance.substs.has_param_types());\n \n-    let fn_ty = common::instance_ty(ccx.tcx(), &instance);\n+    let fn_ty = instance.ty(ccx.tcx());\n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n         return llfn;\n     }\n@@ -96,7 +96,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         assert_eq!(common::val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n \n-        if common::is_inline_instance(tcx, &instance) {\n+        if instance.def.is_inline(tcx) {\n             attributes::inline(llfn, attributes::InlineAttr::Hint);\n         }\n         let attrs = instance.def.attrs(ccx.tcx());"}, {"sha": "b1bdee3fa5fc55c620400ad4e2cd84a960e11dea", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -16,7 +16,6 @@ use llvm;\n use llvm::{ValueRef, ContextRef, TypeKind};\n use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map::DefPathData;\n use rustc::middle::lang_items::LangItem;\n use abi;\n use base;\n@@ -29,7 +28,7 @@ use value::Value;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n-use rustc::ty::subst::{Kind, Substs};\n+use rustc::ty::subst::Kind;\n use rustc::hir;\n \n use libc::{c_uint, c_char};\n@@ -430,38 +429,3 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn is_inline_instance<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    instance: &ty::Instance<'tcx>\n-) -> bool {\n-    let def_id = match instance.def {\n-        ty::InstanceDef::Item(def_id) => def_id,\n-        ty::InstanceDef::DropGlue(_, Some(_)) => return false,\n-        _ => return true\n-    };\n-    match tcx.def_key(def_id).disambiguated_data.data {\n-        DefPathData::StructCtor |\n-        DefPathData::EnumVariant(..) |\n-        DefPathData::ClosureExpr => true,\n-        _ => false\n-    }\n-}\n-\n-/// Given a DefId and some Substs, produces the monomorphic item type.\n-pub fn def_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        def_id: DefId,\n-                        substs: &'tcx Substs<'tcx>)\n-                        -> Ty<'tcx>\n-{\n-    let ty = tcx.type_of(def_id);\n-    tcx.trans_apply_param_substs(substs, &ty)\n-}\n-\n-/// Return the substituted type of an instance.\n-pub fn instance_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             instance: &ty::Instance<'tcx>)\n-                             -> Ty<'tcx>\n-{\n-    let ty = instance.def.def_ty(tcx);\n-    tcx.trans_apply_param_substs(instance.substs, &ty)\n-}"}, {"sha": "f9fbcebd32e72c03e94dcbbb11ee2fc25c2d2357", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -16,8 +16,8 @@ use rustc::hir::map as hir_map;\n use rustc::middle::const_val::ConstEvalErr;\n use debuginfo;\n use base;\n-use trans_item::{TransItem, TransItemExt};\n-use common::{self, CrateContext, val_ty};\n+use monomorphize::{MonoItem, MonoItemExt};\n+use common::{CrateContext, val_ty};\n use declare;\n use monomorphize::Instance;\n use type_::Type;\n@@ -110,19 +110,19 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n         return g;\n     }\n \n-    let ty = common::instance_ty(ccx.tcx(), &instance);\n+    let ty = instance.ty(ccx.tcx());\n     let g = if let Some(id) = ccx.tcx().hir.as_local_node_id(def_id) {\n \n         let llty = ccx.layout_of(ty).llvm_type(ccx);\n         let (g, attrs) = match ccx.tcx().hir.get(id) {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n-                let sym = TransItem::Static(id).symbol_name(ccx.tcx());\n+                let sym = MonoItem::Static(id).symbol_name(ccx.tcx());\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items()\n-                                                         .contains_key(&TransItem::Static(id));\n+                                                         .contains_key(&MonoItem::Static(id));\n                 assert!(!defined_in_current_codegen_unit);\n \n                 if declare::get_declared_value(ccx, &sym[..]).is_some() {\n@@ -266,7 +266,7 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         };\n \n         let instance = Instance::mono(ccx.tcx(), def_id);\n-        let ty = common::instance_ty(ccx.tcx(), &instance);\n+        let ty = instance.ty(ccx.tcx());\n         let llty = ccx.layout_of(ty).llvm_type(ccx);\n         let g = if val_llty == llty {\n             g"}, {"sha": "d5e71062f74d78e2e859c369eecab6a365f399e6", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -22,19 +22,18 @@ use base;\n use declare;\n use monomorphize::Instance;\n \n-use partitioning::CodegenUnit;\n+use monomorphize::partitioning::CodegenUnit;\n use type_::Type;\n use type_of::PointeeInfo;\n \n use rustc_data_structures::base_n;\n-use rustc::middle::trans::Stats;\n+use rustc::mir::mono::Stats;\n use rustc_data_structures::stable_hasher::StableHashingContextProvider;\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n use rustc::ty::layout::{LayoutError, LayoutOf, Size, TyLayout};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n-use rustc_trans_utils;\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n@@ -325,7 +324,17 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     }\n \n     pub fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n-        rustc_trans_utils::common::type_has_metadata(self.tcx, ty)\n+        use syntax_pos::DUMMY_SP;\n+        if ty.is_sized(self.tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP) {\n+            return false;\n+        }\n+\n+        let tail = self.tcx.struct_tail(ty);\n+        match tail.sty {\n+            ty::TyForeign(..) => false,\n+            ty::TyStr | ty::TySlice(..) | ty::TyDynamic(..) => true,\n+            _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n+        }\n     }\n \n     pub fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> {"}, {"sha": "12cd874f86887ee54ae287ad717fb4241b00a994", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -27,10 +27,10 @@ use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor,\n use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ty::fold::TypeVisitor;\n-use rustc::ty::subst::Substs;\n use rustc::ty::util::TypeIdHasher;\n use rustc::ich::Fingerprint;\n-use common::{self, CrateContext};\n+use rustc::ty::Instance;\n+use common::CrateContext;\n use rustc::ty::{self, AdtKind, Ty};\n use rustc::ty::layout::{self, Align, LayoutOf, Size, TyLayout};\n use rustc::session::{Session, config};\n@@ -1656,7 +1656,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = common::def_ty(cx.tcx(), node_def_id, Substs::empty());\n+    let variable_type = Instance::mono(cx.tcx(), node_def_id).ty(cx.tcx());\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let var_name = tcx.item_name(node_def_id).to_string();\n     let linkage_name = mangled_name_of_item(cx, node_def_id, \"\");"}, {"sha": "ae202f3f14291c47551ccc73a3f690219fc0cd2a", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -27,7 +27,7 @@ use rustc::hir::def_id::{DefId, CrateNum};\n use rustc::ty::subst::Substs;\n \n use abi::Abi;\n-use common::{self, CrateContext};\n+use common::CrateContext;\n use builder::Builder;\n use monomorphize::Instance;\n use rustc::ty::{self, Ty};\n@@ -427,8 +427,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let self_type = cx.tcx().impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n             // If the method does *not* belong to a trait, proceed\n             if cx.tcx().trait_id_of_impl(impl_def_id).is_none() {\n-                let impl_self_ty =\n-                    common::def_ty(cx.tcx(), impl_def_id, instance.substs);\n+                let impl_self_ty = cx.tcx().trans_impl_self_ty(impl_def_id, instance.substs);\n \n                 // Only \"class\" methods are generally understood by LLVM,\n                 // so avoid methods on other types (e.g. `<*mut T>::null`)."}, {"sha": "c4849c621e8d5d136ebca61fda737b339bbf3a7c", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -43,6 +43,7 @@ extern crate libc;\n #[macro_use] extern crate rustc;\n extern crate jobserver;\n extern crate num_cpus;\n+extern crate rustc_mir;\n extern crate rustc_allocator;\n extern crate rustc_apfloat;\n extern crate rustc_back;\n@@ -84,8 +85,7 @@ use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n \n-use rustc_trans_utils::collector;\n-use rustc_trans_utils::monomorphize;\n+use rustc_mir::monomorphize;\n \n mod diagnostics;\n \n@@ -138,7 +138,6 @@ mod llvm_util;\n mod metadata;\n mod meth;\n mod mir;\n-mod partitioning;\n mod symbol_names_test;\n mod time_graph;\n mod trans_item;"}, {"sha": "1cb3a66e4d8cf84860826f91bdcbd8f46adb893b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -273,7 +273,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 args = &args[..1 + place.has_extra() as usize];\n                 let (drop_fn, fn_ty) = match ty.sty {\n                     ty::TyDynamic(..) => {\n-                        let fn_ty = common::instance_ty(bcx.ccx.tcx(), &drop_fn);\n+                        let fn_ty = drop_fn.ty(bcx.ccx.tcx());\n                         let sig = common::ty_fn_sig(bcx.ccx, fn_ty);\n                         let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n                         let fn_ty = FnType::new_vtable(bcx.ccx, sig, &[]);\n@@ -535,8 +535,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     }).collect();\n \n \n-                    let callee_ty = common::instance_ty(\n-                        bcx.ccx.tcx(), instance.as_ref().unwrap());\n+                    let callee_ty = instance.as_ref().unwrap().ty(bcx.ccx.tcx());\n                     trans_intrinsic_call(&bcx, callee_ty, &fn_ty, &args, dest,\n                                          terminator.source_info.span);\n "}, {"sha": "31d8e092c4ae49a05486d78c11ad89d3a054cbce", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 26, "deletions": 54, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -19,35 +19,33 @@ use attributes;\n use base;\n use consts;\n use context::CrateContext;\n-use common;\n use declare;\n use llvm;\n use monomorphize::Instance;\n use type_of::LayoutLlvmExt;\n use rustc::hir;\n-use rustc::middle::trans::{Linkage, Visibility};\n-use rustc::ty::{self, TyCtxt, TypeFoldable};\n+use rustc::mir::mono::{Linkage, Visibility};\n+use rustc::ty::{TyCtxt, TypeFoldable};\n use rustc::ty::layout::LayoutOf;\n use syntax::ast;\n use syntax::attr;\n use syntax_pos::Span;\n-use syntax_pos::symbol::Symbol;\n use std::fmt;\n \n-pub use rustc::middle::trans::TransItem;\n+pub use rustc::mir::mono::MonoItem;\n \n-pub use rustc_trans_utils::trans_item::*;\n-pub use rustc_trans_utils::trans_item::TransItemExt as BaseTransItemExt;\n+pub use rustc_mir::monomorphize::item::*;\n+pub use rustc_mir::monomorphize::item::MonoItemExt as BaseMonoItemExt;\n \n-pub trait TransItemExt<'a, 'tcx>: fmt::Debug + BaseTransItemExt<'a, 'tcx> {\n+pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n     fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n         debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n                self.to_string(ccx.tcx()),\n                self.to_raw_string(),\n                ccx.codegen_unit().name());\n \n-        match *self.as_trans_item() {\n-            TransItem::Static(node_id) => {\n+        match *self.as_mono_item() {\n+            MonoItem::Static(node_id) => {\n                 let tcx = ccx.tcx();\n                 let item = tcx.hir.expect_item(node_id);\n                 if let hir::ItemStatic(_, m, _) = item.node {\n@@ -61,15 +59,15 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug + BaseTransItemExt<'a, 'tcx> {\n                     span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")\n                 }\n             }\n-            TransItem::GlobalAsm(node_id) => {\n+            MonoItem::GlobalAsm(node_id) => {\n                 let item = ccx.tcx().hir.expect_item(node_id);\n                 if let hir::ItemGlobalAsm(ref ga) = item.node {\n                     asm::trans_global_asm(ccx, ga);\n                 } else {\n                     span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")\n                 }\n             }\n-            TransItem::Fn(instance) => {\n+            MonoItem::Fn(instance) => {\n                 base::trans_instance(&ccx, instance);\n             }\n         }\n@@ -93,14 +91,14 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug + BaseTransItemExt<'a, 'tcx> {\n \n         debug!(\"symbol {}\", &symbol_name);\n \n-        match *self.as_trans_item() {\n-            TransItem::Static(node_id) => {\n+        match *self.as_mono_item() {\n+            MonoItem::Static(node_id) => {\n                 predefine_static(ccx, node_id, linkage, visibility, &symbol_name);\n             }\n-            TransItem::Fn(instance) => {\n+            MonoItem::Fn(instance) => {\n                 predefine_fn(ccx, instance, linkage, visibility, &symbol_name);\n             }\n-            TransItem::GlobalAsm(..) => {}\n+            MonoItem::GlobalAsm(..) => {}\n         }\n \n         debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n@@ -109,62 +107,36 @@ pub trait TransItemExt<'a, 'tcx>: fmt::Debug + BaseTransItemExt<'a, 'tcx> {\n                ccx.codegen_unit().name());\n     }\n \n-    fn symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::SymbolName {\n-        match *self.as_trans_item() {\n-            TransItem::Fn(instance) => tcx.symbol_name(instance),\n-            TransItem::Static(node_id) => {\n-                let def_id = tcx.hir.local_def_id(node_id);\n-                tcx.symbol_name(Instance::mono(tcx, def_id))\n-            }\n-            TransItem::GlobalAsm(node_id) => {\n-                let def_id = tcx.hir.local_def_id(node_id);\n-                ty::SymbolName {\n-                    name: Symbol::intern(&format!(\"global_asm_{:?}\", def_id)).as_str()\n-                }\n-            }\n-        }\n-    }\n-\n     fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n-        match *self.as_trans_item() {\n-            TransItem::Fn(Instance { def, .. }) => {\n+        match *self.as_mono_item() {\n+            MonoItem::Fn(Instance { def, .. }) => {\n                 tcx.hir.as_local_node_id(def.def_id())\n             }\n-            TransItem::Static(node_id) |\n-            TransItem::GlobalAsm(node_id) => {\n+            MonoItem::Static(node_id) |\n+            MonoItem::GlobalAsm(node_id) => {\n                 Some(node_id)\n             }\n         }.map(|node_id| tcx.hir.span(node_id))\n     }\n \n-    fn is_generic_fn(&self) -> bool {\n-        match *self.as_trans_item() {\n-            TransItem::Fn(ref instance) => {\n-                instance.substs.types().next().is_some()\n-            }\n-            TransItem::Static(..) |\n-            TransItem::GlobalAsm(..) => false,\n-        }\n-    }\n-\n     fn to_raw_string(&self) -> String {\n-        match *self.as_trans_item() {\n-            TransItem::Fn(instance) => {\n+        match *self.as_mono_item() {\n+            MonoItem::Fn(instance) => {\n                 format!(\"Fn({:?}, {})\",\n                          instance.def,\n                          instance.substs.as_ptr() as usize)\n             }\n-            TransItem::Static(id) => {\n+            MonoItem::Static(id) => {\n                 format!(\"Static({:?})\", id)\n             }\n-            TransItem::GlobalAsm(id) => {\n+            MonoItem::GlobalAsm(id) => {\n                 format!(\"GlobalAsm({:?})\", id)\n             }\n         }\n     }\n }\n \n-impl<'a, 'tcx> TransItemExt<'a, 'tcx> for TransItem<'tcx> {}\n+impl<'a, 'tcx> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {}\n \n fn predefine_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               node_id: ast::NodeId,\n@@ -173,7 +145,7 @@ fn predefine_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               symbol_name: &str) {\n     let def_id = ccx.tcx().hir.local_def_id(node_id);\n     let instance = Instance::mono(ccx.tcx(), def_id);\n-    let ty = common::instance_ty(ccx.tcx(), &instance);\n+    let ty = instance.ty(ccx.tcx());\n     let llty = ccx.layout_of(ty).llvm_type(ccx);\n \n     let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n@@ -198,7 +170,7 @@ fn predefine_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     assert!(!instance.substs.needs_infer() &&\n             !instance.substs.has_param_types());\n \n-    let mono_ty = common::instance_ty(ccx.tcx(), &instance);\n+    let mono_ty = instance.ty(ccx.tcx());\n     let attrs = instance.def.attrs(ccx.tcx());\n     let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n     unsafe { llvm::LLVMRustSetLinkage(lldecl, base::linkage_to_llvm(linkage)) };\n@@ -224,7 +196,7 @@ fn predefine_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     debug!(\"predefine_fn: mono_ty = {:?} instance = {:?}\", mono_ty, instance);\n-    if common::is_inline_instance(ccx.tcx(), &instance) {\n+    if instance.def.is_inline(ccx.tcx()) {\n         attributes::inline(lldecl, attributes::InlineAttr::Hint);\n     }\n     attributes::from_fn_attrs(ccx, &attrs, lldecl);"}, {"sha": "47968afd70d97112675ff0380155c434cef7e5e5", "filename": "src/librustc_trans_utils/common.rs", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e7db42fb5b9a620c5669711546663d0ccebf9291/src%2Flibrustc_trans_utils%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7db42fb5b9a620c5669711546663d0ccebf9291/src%2Flibrustc_trans_utils%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fcommon.rs?ref=e7db42fb5b9a620c5669711546663d0ccebf9291", "patch": "@@ -1,92 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(non_camel_case_types, non_snake_case)]\n-\n-//! Code that is useful in various trans modules.\n-\n-use rustc::hir::def_id::DefId;\n-use rustc::hir::map::DefPathData;\n-use rustc::traits;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::subst::Substs;\n-\n-use syntax::attr;\n-use syntax_pos::DUMMY_SP;\n-\n-pub fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_sized(tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n-}\n-\n-pub fn type_has_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    if type_is_sized(tcx, ty) {\n-        return false;\n-    }\n-\n-    let tail = tcx.struct_tail(ty);\n-    match tail.sty {\n-        ty::TyForeign(..) => false,\n-        ty::TyStr | ty::TySlice(..) | ty::TyDynamic(..) => true,\n-        _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n-    }\n-}\n-\n-pub fn requests_inline<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    instance: &ty::Instance<'tcx>\n-) -> bool {\n-    if is_inline_instance(tcx, instance) {\n-        return true\n-    }\n-    if let ty::InstanceDef::DropGlue(..) = instance.def {\n-        // Drop glue wants to be instantiated at every translation\n-        // unit, but without an #[inline] hint. We should make this\n-        // available to normal end-users.\n-        return true\n-    }\n-    attr::requests_inline(&instance.def.attrs(tcx)[..]) ||\n-        tcx.is_const_fn(instance.def.def_id())\n-}\n-\n-pub fn is_inline_instance<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    instance: &ty::Instance<'tcx>\n-) -> bool {\n-    let def_id = match instance.def {\n-        ty::InstanceDef::Item(def_id) => def_id,\n-        ty::InstanceDef::DropGlue(_, Some(_)) => return false,\n-        _ => return true\n-    };\n-    match tcx.def_key(def_id).disambiguated_data.data {\n-        DefPathData::StructCtor |\n-        DefPathData::EnumVariant(..) |\n-        DefPathData::ClosureExpr => true,\n-        _ => false\n-    }\n-}\n-\n-/// Given a DefId and some Substs, produces the monomorphic item type.\n-pub fn def_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        def_id: DefId,\n-                        substs: &'tcx Substs<'tcx>)\n-                        -> Ty<'tcx>\n-{\n-    let ty = tcx.type_of(def_id);\n-    tcx.trans_apply_param_substs(substs, &ty)\n-}\n-\n-/// Return the substituted type of an instance.\n-pub fn instance_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             instance: &ty::Instance<'tcx>)\n-                             -> Ty<'tcx>\n-{\n-    let ty = instance.def.def_ty(tcx);\n-    tcx.trans_apply_param_substs(instance.substs, &ty)\n-}"}, {"sha": "77afc2899c329517e5958e4568871f85a8fe2995", "filename": "src/librustc_trans_utils/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b76f224af867b198e4051806cc6e1ac686085cdc/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=b76f224af867b198e4051806cc6e1ac686085cdc", "patch": "@@ -35,21 +35,17 @@ extern crate log;\n #[macro_use]\n extern crate rustc;\n extern crate rustc_back;\n-extern crate rustc_data_structures;\n extern crate syntax;\n extern crate syntax_pos;\n+extern crate rustc_data_structures;\n \n use rustc::ty::{TyCtxt, Instance};\n use rustc::hir;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::hir::map as hir_map;\n use rustc::util::nodemap::NodeSet;\n \n-pub mod common;\n pub mod link;\n-pub mod collector;\n-pub mod trans_item;\n-pub mod monomorphize;\n pub mod trans_crate;\n \n /// check for the #[rustc_error] annotation, which forces an\n@@ -107,7 +103,7 @@ pub fn find_exported_symbols<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> NodeSet {\n                 (generics.parent_types == 0 && generics.types.is_empty()) &&\n                 // Functions marked with #[inline] are only ever translated\n                 // with \"internal\" linkage and are never exported.\n-                !common::requests_inline(tcx, &Instance::mono(tcx, def_id))\n+                !Instance::mono(tcx, def_id).def.requires_local(tcx)\n             }\n \n             _ => false"}]}