{"sha": "ed77fcc8a67cbff506ffaf73781e8d25d382a2f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNzdmY2M4YTY3Y2JmZjUwNmZmYWY3Mzc4MWU4ZDI1ZDM4MmEyZjM=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2015-09-15T02:36:39Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2015-09-19T21:35:18Z"}, "message": "Split out the bad_style lints into a new module\n\nPart of #22206", "tree": {"sha": "787d45abbc6175f86e3d9351168467e11d3bb1d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/787d45abbc6175f86e3d9351168467e11d3bb1d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed77fcc8a67cbff506ffaf73781e8d25d382a2f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed77fcc8a67cbff506ffaf73781e8d25d382a2f3", "html_url": "https://github.com/rust-lang/rust/commit/ed77fcc8a67cbff506ffaf73781e8d25d382a2f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed77fcc8a67cbff506ffaf73781e8d25d382a2f3/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "837840c61fce44da78096110ff83c91099a83da7", "url": "https://api.github.com/repos/rust-lang/rust/commits/837840c61fce44da78096110ff83c91099a83da7", "html_url": "https://github.com/rust-lang/rust/commit/837840c61fce44da78096110ff83c91099a83da7"}], "stats": {"total": 736, "additions": 382, "deletions": 354}, "files": [{"sha": "8f57c67069263e93df0fad7cdce4737e801875cd", "filename": "src/librustc_lint/bad_style.rs", "status": "added", "additions": 372, "deletions": 0, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/ed77fcc8a67cbff506ffaf73781e8d25d382a2f3/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed77fcc8a67cbff506ffaf73781e8d25d382a2f3/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=ed77fcc8a67cbff506ffaf73781e8d25d382a2f3", "patch": "@@ -0,0 +1,372 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::def;\n+use middle::def_id::DefId;\n+use middle::ty;\n+use lint::{LateContext, LintContext, LintArray};\n+use lint::{LintPass, LateLintPass};\n+\n+use syntax::ast;\n+use syntax::attr::{self, AttrMetaMethods};\n+use syntax::codemap::Span;\n+\n+use rustc_front::hir;\n+use rustc_front::visit::FnKind;\n+\n+#[derive(PartialEq)]\n+pub enum MethodLateContext {\n+    TraitDefaultImpl,\n+    TraitImpl,\n+    PlainImpl\n+}\n+\n+pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n+    match cx.tcx.impl_or_trait_items.borrow().get(&DefId::local(id)) {\n+        None => cx.sess().span_bug(span, \"missing method descriptor?!\"),\n+        Some(item) => match item.container() {\n+            ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n+            ty::ImplContainer(cid) => {\n+                match cx.tcx.impl_trait_ref(cid) {\n+                    Some(_) => MethodLateContext::TraitImpl,\n+                    None => MethodLateContext::PlainImpl\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub NON_CAMEL_CASE_TYPES,\n+    Warn,\n+    \"types, variants, traits and type parameters should have camel case names\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct NonCamelCaseTypes;\n+\n+impl NonCamelCaseTypes {\n+    fn check_case(&self, cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n+        fn is_camel_case(ident: ast::Ident) -> bool {\n+            let ident = ident.name.as_str();\n+            if ident.is_empty() {\n+                return true;\n+            }\n+            let ident = ident.trim_matches('_');\n+\n+            // start with a non-lowercase letter rather than non-uppercase\n+            // ones (some scripts don't have a concept of upper/lowercase)\n+            !ident.is_empty() && !ident.char_at(0).is_lowercase() && !ident.contains('_')\n+        }\n+\n+        fn to_camel_case(s: &str) -> String {\n+            s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n+                if i == 0 {\n+                    c.to_uppercase().collect::<String>()\n+                } else {\n+                    c.to_lowercase().collect()\n+                }\n+            )).collect::<Vec<_>>().concat()\n+        }\n+\n+        let s = ident.name.as_str();\n+\n+        if !is_camel_case(ident) {\n+            let c = to_camel_case(&s);\n+            let m = if c.is_empty() {\n+                format!(\"{} `{}` should have a camel case name such as `CamelCase`\", sort, s)\n+            } else {\n+                format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n+            };\n+            cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[..]);\n+        }\n+    }\n+}\n+\n+impl LintPass for NonCamelCaseTypes {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NON_CAMEL_CASE_TYPES)\n+    }\n+}\n+\n+impl LateLintPass for NonCamelCaseTypes {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+        let extern_repr_count = it.attrs.iter().filter(|attr| {\n+            attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr).iter()\n+                .any(|r| r == &attr::ReprExtern)\n+        }).count();\n+        let has_extern_repr = extern_repr_count > 0;\n+\n+        if has_extern_repr {\n+            return;\n+        }\n+\n+        match it.node {\n+            hir::ItemTy(..) | hir::ItemStruct(..) => {\n+                self.check_case(cx, \"type\", it.ident, it.span)\n+            }\n+            hir::ItemTrait(..) => {\n+                self.check_case(cx, \"trait\", it.ident, it.span)\n+            }\n+            hir::ItemEnum(ref enum_definition, _) => {\n+                if has_extern_repr {\n+                    return;\n+                }\n+                self.check_case(cx, \"type\", it.ident, it.span);\n+                for variant in &enum_definition.variants {\n+                    self.check_case(cx, \"variant\", variant.node.name, variant.span);\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_generics(&mut self, cx: &LateContext, it: &hir::Generics) {\n+        for gen in it.ty_params.iter() {\n+            self.check_case(cx, \"type parameter\", gen.ident, gen.span);\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub NON_SNAKE_CASE,\n+    Warn,\n+    \"methods, functions, lifetime parameters and modules should have snake case names\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct NonSnakeCase;\n+\n+impl NonSnakeCase {\n+    fn to_snake_case(mut str: &str) -> String {\n+        let mut words = vec![];\n+        // Preserve leading underscores\n+        str = str.trim_left_matches(|c: char| {\n+            if c == '_' {\n+                words.push(String::new());\n+                true\n+            } else {\n+                false\n+            }\n+        });\n+        for s in str.split('_') {\n+            let mut last_upper = false;\n+            let mut buf = String::new();\n+            if s.is_empty() {\n+                continue;\n+            }\n+            for ch in s.chars() {\n+                if !buf.is_empty() && buf != \"'\"\n+                                   && ch.is_uppercase()\n+                                   && !last_upper {\n+                    words.push(buf);\n+                    buf = String::new();\n+                }\n+                last_upper = ch.is_uppercase();\n+                buf.extend(ch.to_lowercase());\n+            }\n+            words.push(buf);\n+        }\n+        words.join(\"_\")\n+    }\n+\n+    fn check_snake_case(&self, cx: &LateContext, sort: &str, name: &str, span: Option<Span>) {\n+        fn is_snake_case(ident: &str) -> bool {\n+            if ident.is_empty() {\n+                return true;\n+            }\n+            let ident = ident.trim_left_matches('\\'');\n+            let ident = ident.trim_matches('_');\n+\n+            let mut allow_underscore = true;\n+            ident.chars().all(|c| {\n+                allow_underscore = match c {\n+                    '_' if !allow_underscore => return false,\n+                    '_' => false,\n+                    // It would be more obvious to use `c.is_lowercase()`,\n+                    // but some characters do not have a lowercase form\n+                    c if !c.is_uppercase() => true,\n+                    _ => return false,\n+                };\n+                true\n+            })\n+        }\n+\n+        if !is_snake_case(name) {\n+            let sc = NonSnakeCase::to_snake_case(name);\n+            let msg = if sc != name {\n+                format!(\"{} `{}` should have a snake case name such as `{}`\",\n+                        sort, name, sc)\n+            } else {\n+                format!(\"{} `{}` should have a snake case name\",\n+                        sort, name)\n+            };\n+            match span {\n+                Some(span) => cx.span_lint(NON_SNAKE_CASE, span, &msg),\n+                None => cx.lint(NON_SNAKE_CASE, &msg),\n+            }\n+        }\n+    }\n+}\n+\n+impl LintPass for NonSnakeCase {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NON_SNAKE_CASE)\n+    }\n+}\n+\n+impl LateLintPass for NonSnakeCase {\n+    fn check_crate(&mut self, cx: &LateContext, cr: &hir::Crate) {\n+        let attr_crate_name = cr.attrs.iter().find(|at| at.check_name(\"crate_name\"))\n+                                      .and_then(|at| at.value_str().map(|s| (at, s)));\n+        if let Some(ref name) = cx.tcx.sess.opts.crate_name {\n+            self.check_snake_case(cx, \"crate\", name, None);\n+        } else if let Some((attr, ref name)) = attr_crate_name {\n+            self.check_snake_case(cx, \"crate\", name, Some(attr.span));\n+        }\n+    }\n+\n+    fn check_fn(&mut self, cx: &LateContext,\n+                fk: FnKind, _: &hir::FnDecl,\n+                _: &hir::Block, span: Span, id: ast::NodeId) {\n+        match fk {\n+            FnKind::Method(ident, _, _) => match method_context(cx, id, span) {\n+                MethodLateContext::PlainImpl => {\n+                    self.check_snake_case(cx, \"method\", &ident.name.as_str(), Some(span))\n+                },\n+                MethodLateContext::TraitDefaultImpl => {\n+                    self.check_snake_case(cx, \"trait method\", &ident.name.as_str(), Some(span))\n+                },\n+                _ => (),\n+            },\n+            FnKind::ItemFn(ident, _, _, _, _, _) => {\n+                self.check_snake_case(cx, \"function\", &ident.name.as_str(), Some(span))\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+        if let hir::ItemMod(_) = it.node {\n+            self.check_snake_case(cx, \"module\", &it.ident.name.as_str(), Some(it.span));\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n+        if let hir::MethodTraitItem(_, None) = trait_item.node {\n+            self.check_snake_case(cx, \"trait method\", &trait_item.ident.name.as_str(),\n+                                  Some(trait_item.span));\n+        }\n+    }\n+\n+    fn check_lifetime_def(&mut self, cx: &LateContext, t: &hir::LifetimeDef) {\n+        self.check_snake_case(cx, \"lifetime\", &t.lifetime.name.as_str(),\n+                              Some(t.lifetime.span));\n+    }\n+\n+    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n+        if let &hir::PatIdent(_, ref path1, _) = &p.node {\n+            let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n+            if let Some(def::DefLocal(_)) = def {\n+                self.check_snake_case(cx, \"variable\", &path1.node.name.as_str(), Some(p.span));\n+            }\n+        }\n+    }\n+\n+    fn check_struct_def(&mut self, cx: &LateContext, s: &hir::StructDef,\n+                        _: ast::Ident, _: &hir::Generics, _: ast::NodeId) {\n+        for sf in &s.fields {\n+            if let hir::StructField_ { kind: hir::NamedField(ident, _), .. } = sf.node {\n+                self.check_snake_case(cx, \"structure field\", &ident.name.as_str(),\n+                                      Some(sf.span));\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub NON_UPPER_CASE_GLOBALS,\n+    Warn,\n+    \"static constants should have uppercase identifiers\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct NonUpperCaseGlobals;\n+\n+impl NonUpperCaseGlobals {\n+    fn check_upper_case(cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n+        let s = ident.name.as_str();\n+\n+        if s.chars().any(|c| c.is_lowercase()) {\n+            let uc = NonSnakeCase::to_snake_case(&s).to_uppercase();\n+            if uc != &s[..] {\n+                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n+                    &format!(\"{} `{}` should have an upper case name such as `{}`\",\n+                             sort, s, uc));\n+            } else {\n+                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n+                    &format!(\"{} `{}` should have an upper case name\",\n+                             sort, s));\n+            }\n+        }\n+    }\n+}\n+\n+impl LintPass for NonUpperCaseGlobals {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NON_UPPER_CASE_GLOBALS)\n+    }\n+}\n+\n+impl LateLintPass for NonUpperCaseGlobals {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+        match it.node {\n+            // only check static constants\n+            hir::ItemStatic(_, hir::MutImmutable, _) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"static constant\", it.ident, it.span);\n+            }\n+            hir::ItemConst(..) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.ident, it.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext, ti: &hir::TraitItem) {\n+        match ti.node {\n+            hir::ConstTraitItem(..) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n+                                                      ti.ident, ti.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext, ii: &hir::ImplItem) {\n+        match ii.node {\n+            hir::ConstImplItem(..) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n+                                                      ii.ident, ii.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n+        // Lint for constants that look like binding identifiers (#7526)\n+        match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n+            (&hir::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n+                                                      path1.node, p.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "fe835f274b674b38d41718d738b0a8facbda6f14", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 350, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/ed77fcc8a67cbff506ffaf73781e8d25d382a2f3/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed77fcc8a67cbff506ffaf73781e8d25d382a2f3/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ed77fcc8a67cbff506ffaf73781e8d25d382a2f3", "patch": "@@ -57,6 +57,8 @@ use rustc_front::hir;\n use rustc_front::visit::{self, FnKind, Visitor};\n use rustc_front::util::is_shift_binop;\n \n+use bad_style::{MethodLateContext, method_context};\n+\n // hardwired lints from librustc\n pub use lint::builtin::*;\n \n@@ -1049,356 +1051,6 @@ impl LateLintPass for UnusedResults {\n     }\n }\n \n-declare_lint! {\n-    pub NON_CAMEL_CASE_TYPES,\n-    Warn,\n-    \"types, variants, traits and type parameters should have camel case names\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct NonCamelCaseTypes;\n-\n-impl NonCamelCaseTypes {\n-    fn check_case(&self, cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n-        fn is_camel_case(ident: ast::Ident) -> bool {\n-            let ident = ident.name.as_str();\n-            if ident.is_empty() {\n-                return true;\n-            }\n-            let ident = ident.trim_matches('_');\n-\n-            // start with a non-lowercase letter rather than non-uppercase\n-            // ones (some scripts don't have a concept of upper/lowercase)\n-            !ident.is_empty() && !ident.char_at(0).is_lowercase() && !ident.contains('_')\n-        }\n-\n-        fn to_camel_case(s: &str) -> String {\n-            s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n-                if i == 0 {\n-                    c.to_uppercase().collect::<String>()\n-                } else {\n-                    c.to_lowercase().collect()\n-                }\n-            )).collect::<Vec<_>>().concat()\n-        }\n-\n-        let s = ident.name.as_str();\n-\n-        if !is_camel_case(ident) {\n-            let c = to_camel_case(&s);\n-            let m = if c.is_empty() {\n-                format!(\"{} `{}` should have a camel case name such as `CamelCase`\", sort, s)\n-            } else {\n-                format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n-            };\n-            cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[..]);\n-        }\n-    }\n-}\n-\n-impl LintPass for NonCamelCaseTypes {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_CAMEL_CASE_TYPES)\n-    }\n-}\n-\n-impl LateLintPass for NonCamelCaseTypes {\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        let extern_repr_count = it.attrs.iter().filter(|attr| {\n-            attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr).iter()\n-                .any(|r| r == &attr::ReprExtern)\n-        }).count();\n-        let has_extern_repr = extern_repr_count > 0;\n-\n-        if has_extern_repr {\n-            return;\n-        }\n-\n-        match it.node {\n-            hir::ItemTy(..) | hir::ItemStruct(..) => {\n-                self.check_case(cx, \"type\", it.ident, it.span)\n-            }\n-            hir::ItemTrait(..) => {\n-                self.check_case(cx, \"trait\", it.ident, it.span)\n-            }\n-            hir::ItemEnum(ref enum_definition, _) => {\n-                if has_extern_repr {\n-                    return;\n-                }\n-                self.check_case(cx, \"type\", it.ident, it.span);\n-                for variant in &enum_definition.variants {\n-                    self.check_case(cx, \"variant\", variant.node.name, variant.span);\n-                }\n-            }\n-            _ => ()\n-        }\n-    }\n-\n-    fn check_generics(&mut self, cx: &LateContext, it: &hir::Generics) {\n-        for gen in it.ty_params.iter() {\n-            self.check_case(cx, \"type parameter\", gen.ident, gen.span);\n-        }\n-    }\n-}\n-\n-#[derive(PartialEq)]\n-enum MethodLateContext {\n-    TraitDefaultImpl,\n-    TraitImpl,\n-    PlainImpl\n-}\n-\n-fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n-    match cx.tcx.impl_or_trait_items.borrow().get(&DefId::local(id)) {\n-        None => cx.sess().span_bug(span, \"missing method descriptor?!\"),\n-        Some(item) => match item.container() {\n-            ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n-            ty::ImplContainer(cid) => {\n-                match cx.tcx.impl_trait_ref(cid) {\n-                    Some(_) => MethodLateContext::TraitImpl,\n-                    None => MethodLateContext::PlainImpl\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub NON_SNAKE_CASE,\n-    Warn,\n-    \"methods, functions, lifetime parameters and modules should have snake case names\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct NonSnakeCase;\n-\n-impl NonSnakeCase {\n-    fn to_snake_case(mut str: &str) -> String {\n-        let mut words = vec![];\n-        // Preserve leading underscores\n-        str = str.trim_left_matches(|c: char| {\n-            if c == '_' {\n-                words.push(String::new());\n-                true\n-            } else {\n-                false\n-            }\n-        });\n-        for s in str.split('_') {\n-            let mut last_upper = false;\n-            let mut buf = String::new();\n-            if s.is_empty() {\n-                continue;\n-            }\n-            for ch in s.chars() {\n-                if !buf.is_empty() && buf != \"'\"\n-                                   && ch.is_uppercase()\n-                                   && !last_upper {\n-                    words.push(buf);\n-                    buf = String::new();\n-                }\n-                last_upper = ch.is_uppercase();\n-                buf.extend(ch.to_lowercase());\n-            }\n-            words.push(buf);\n-        }\n-        words.join(\"_\")\n-    }\n-\n-    fn check_snake_case(&self, cx: &LateContext, sort: &str, name: &str, span: Option<Span>) {\n-        fn is_snake_case(ident: &str) -> bool {\n-            if ident.is_empty() {\n-                return true;\n-            }\n-            let ident = ident.trim_left_matches('\\'');\n-            let ident = ident.trim_matches('_');\n-\n-            let mut allow_underscore = true;\n-            ident.chars().all(|c| {\n-                allow_underscore = match c {\n-                    '_' if !allow_underscore => return false,\n-                    '_' => false,\n-                    // It would be more obvious to use `c.is_lowercase()`,\n-                    // but some characters do not have a lowercase form\n-                    c if !c.is_uppercase() => true,\n-                    _ => return false,\n-                };\n-                true\n-            })\n-        }\n-\n-        if !is_snake_case(name) {\n-            let sc = NonSnakeCase::to_snake_case(name);\n-            let msg = if sc != name {\n-                format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                        sort, name, sc)\n-            } else {\n-                format!(\"{} `{}` should have a snake case name\",\n-                        sort, name)\n-            };\n-            match span {\n-                Some(span) => cx.span_lint(NON_SNAKE_CASE, span, &msg),\n-                None => cx.lint(NON_SNAKE_CASE, &msg),\n-            }\n-        }\n-    }\n-}\n-\n-impl LintPass for NonSnakeCase {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_SNAKE_CASE)\n-    }\n-}\n-\n-impl LateLintPass for NonSnakeCase {\n-    fn check_crate(&mut self, cx: &LateContext, cr: &hir::Crate) {\n-        let attr_crate_name = cr.attrs.iter().find(|at| at.check_name(\"crate_name\"))\n-                                      .and_then(|at| at.value_str().map(|s| (at, s)));\n-        if let Some(ref name) = cx.tcx.sess.opts.crate_name {\n-            self.check_snake_case(cx, \"crate\", name, None);\n-        } else if let Some((attr, ref name)) = attr_crate_name {\n-            self.check_snake_case(cx, \"crate\", name, Some(attr.span));\n-        }\n-    }\n-\n-    fn check_fn(&mut self, cx: &LateContext,\n-                fk: FnKind, _: &hir::FnDecl,\n-                _: &hir::Block, span: Span, id: ast::NodeId) {\n-        match fk {\n-            FnKind::Method(ident, _, _) => match method_context(cx, id, span) {\n-                MethodLateContext::PlainImpl => {\n-                    self.check_snake_case(cx, \"method\", &ident.name.as_str(), Some(span))\n-                },\n-                MethodLateContext::TraitDefaultImpl => {\n-                    self.check_snake_case(cx, \"trait method\", &ident.name.as_str(), Some(span))\n-                },\n-                _ => (),\n-            },\n-            FnKind::ItemFn(ident, _, _, _, _, _) => {\n-                self.check_snake_case(cx, \"function\", &ident.name.as_str(), Some(span))\n-            },\n-            _ => (),\n-        }\n-    }\n-\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        if let hir::ItemMod(_) = it.node {\n-            self.check_snake_case(cx, \"module\", &it.ident.name.as_str(), Some(it.span));\n-        }\n-    }\n-\n-    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n-        if let hir::MethodTraitItem(_, None) = trait_item.node {\n-            self.check_snake_case(cx, \"trait method\", &trait_item.ident.name.as_str(),\n-                                  Some(trait_item.span));\n-        }\n-    }\n-\n-    fn check_lifetime_def(&mut self, cx: &LateContext, t: &hir::LifetimeDef) {\n-        self.check_snake_case(cx, \"lifetime\", &t.lifetime.name.as_str(),\n-                              Some(t.lifetime.span));\n-    }\n-\n-    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n-        if let &hir::PatIdent(_, ref path1, _) = &p.node {\n-            let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n-            if let Some(def::DefLocal(_)) = def {\n-                self.check_snake_case(cx, \"variable\", &path1.node.name.as_str(), Some(p.span));\n-            }\n-        }\n-    }\n-\n-    fn check_struct_def(&mut self, cx: &LateContext, s: &hir::StructDef,\n-                        _: ast::Ident, _: &hir::Generics, _: ast::NodeId) {\n-        for sf in &s.fields {\n-            if let hir::StructField_ { kind: hir::NamedField(ident, _), .. } = sf.node {\n-                self.check_snake_case(cx, \"structure field\", &ident.name.as_str(),\n-                                      Some(sf.span));\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub NON_UPPER_CASE_GLOBALS,\n-    Warn,\n-    \"static constants should have uppercase identifiers\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct NonUpperCaseGlobals;\n-\n-impl NonUpperCaseGlobals {\n-    fn check_upper_case(cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n-        let s = ident.name.as_str();\n-\n-        if s.chars().any(|c| c.is_lowercase()) {\n-            let uc = NonSnakeCase::to_snake_case(&s).to_uppercase();\n-            if uc != &s[..] {\n-                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n-                    &format!(\"{} `{}` should have an upper case name such as `{}`\",\n-                             sort, s, uc));\n-            } else {\n-                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n-                    &format!(\"{} `{}` should have an upper case name\",\n-                             sort, s));\n-            }\n-        }\n-    }\n-}\n-\n-impl LintPass for NonUpperCaseGlobals {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_UPPER_CASE_GLOBALS)\n-    }\n-}\n-\n-impl LateLintPass for NonUpperCaseGlobals {\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        match it.node {\n-            // only check static constants\n-            hir::ItemStatic(_, hir::MutImmutable, _) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"static constant\", it.ident, it.span);\n-            }\n-            hir::ItemConst(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.ident, it.span);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn check_trait_item(&mut self, cx: &LateContext, ti: &hir::TraitItem) {\n-        match ti.node {\n-            hir::ConstTraitItem(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n-                                                      ti.ident, ti.span);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn check_impl_item(&mut self, cx: &LateContext, ii: &hir::ImplItem) {\n-        match ii.node {\n-            hir::ConstImplItem(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n-                                                      ii.ident, ii.span);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n-        // Lint for constants that look like binding identifiers (#7526)\n-        match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n-            (&hir::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n-                                                      path1.node, p.span);\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n declare_lint! {\n     UNUSED_PARENS,\n     Warn,"}, {"sha": "a05abbb3fab9895ce943cc6f9bb4ed19bb5e4cf3", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed77fcc8a67cbff506ffaf73781e8d25d382a2f3/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed77fcc8a67cbff506ffaf73781e8d25d382a2f3/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=ed77fcc8a67cbff506ffaf73781e8d25d382a2f3", "patch": "@@ -58,39 +58,43 @@ pub use rustc::util as util;\n use session::Session;\n use lint::LintId;\n \n+mod bad_style;\n mod builtin;\n \n+use bad_style::*;\n+use builtin::*;\n+\n /// Tell the `LintStore` about all the built-in lints (the ones\n /// defined in this crate and the ones defined in\n /// `rustc::lint::builtin`).\n pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     macro_rules! add_builtin {\n         ($sess:ident, $($name:ident),*,) => (\n             {$(\n-                store.register_late_pass($sess, false, box builtin::$name);\n+                store.register_late_pass($sess, false, box $name);\n                 )*}\n             )\n     }\n \n     macro_rules! add_early_builtin {\n         ($sess:ident, $($name:ident),*,) => (\n             {$(\n-                store.register_early_pass($sess, false, box builtin::$name);\n+                store.register_early_pass($sess, false, box $name);\n                 )*}\n             )\n     }\n \n     macro_rules! add_builtin_with_new {\n         ($sess:ident, $($name:ident),*,) => (\n             {$(\n-                store.register_late_pass($sess, false, box builtin::$name::new());\n+                store.register_late_pass($sess, false, box $name::new());\n                 )*}\n             )\n     }\n \n     macro_rules! add_lint_group {\n         ($sess:ident, $name:expr, $($lint:ident),*) => (\n-            store.register_group($sess, false, $name, vec![$(LintId::of(builtin::$lint)),*]);\n+            store.register_group($sess, false, $name, vec![$(LintId::of($lint)),*]);\n             )\n     }\n "}]}