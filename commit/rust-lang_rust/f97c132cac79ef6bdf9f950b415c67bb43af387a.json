{"sha": "f97c132cac79ef6bdf9f950b415c67bb43af387a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5N2MxMzJjYWM3OWVmNmJkZjlmOTUwYjQxNWM2N2JiNDNhZjM4N2E=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-10-30T00:42:12Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-28T02:18:10Z"}, "message": "rustc: use Span's allow_internal_unstable instead of hir::BlockCheckMode.", "tree": {"sha": "e9b0354787759a02e3c17e7d02506fa6f87c3794", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9b0354787759a02e3c17e7d02506fa6f87c3794"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f97c132cac79ef6bdf9f950b415c67bb43af387a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f97c132cac79ef6bdf9f950b415c67bb43af387a", "html_url": "https://github.com/rust-lang/rust/commit/f97c132cac79ef6bdf9f950b415c67bb43af387a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f97c132cac79ef6bdf9f950b415c67bb43af387a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da47c2e2ac7d3d663646a4928c77f6a7f67a91aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/da47c2e2ac7d3d663646a4928c77f6a7f67a91aa", "html_url": "https://github.com/rust-lang/rust/commit/da47c2e2ac7d3d663646a4928c77f6a7f67a91aa"}], "stats": {"total": 177, "additions": 52, "deletions": 125}, "files": [{"sha": "e93210121b7f10c53d19344ec5fafeb418b3c597", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 44, "deletions": 93, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/f97c132cac79ef6bdf9f950b415c67bb43af387a/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c132cac79ef6bdf9f950b415c67bb43af387a/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f97c132cac79ef6bdf9f950b415c67bb43af387a", "patch": "@@ -52,7 +52,7 @@ use std::iter;\n use syntax::ast::*;\n use syntax::errors;\n use syntax::ptr::P;\n-use syntax::codemap::{respan, Spanned};\n+use syntax::codemap::{self, respan, Spanned};\n use syntax::std_inject;\n use syntax::symbol::{Symbol, keywords};\n use syntax::util::small_vector::SmallVector;\n@@ -171,6 +171,18 @@ impl<'a> LoweringContext<'a> {\n         Symbol::gensym(s)\n     }\n \n+    fn allow_internal_unstable(&self, reason: &'static str, mut span: Span) -> Span {\n+        span.expn_id = self.sess.codemap().record_expansion(codemap::ExpnInfo {\n+            call_site: span,\n+            callee: codemap::NameAndSpan {\n+                format: codemap::CompilerDesugaring(Symbol::intern(reason)),\n+                span: Some(span),\n+                allow_internal_unstable: true,\n+            },\n+        });\n+        span\n+    }\n+\n     fn with_parent_def<T, F>(&mut self, parent_id: NodeId, f: F) -> T\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n@@ -1156,8 +1168,9 @@ impl<'a> LoweringContext<'a> {\n                     let move_val_init = [\"intrinsics\", \"move_val_init\"];\n                     let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n \n+                    let unstable_span = self.allow_internal_unstable(\"<-\", e.span);\n                     let make_call = |this: &mut LoweringContext, p, args| {\n-                        let path = this.expr_std_path(e.span, p, ThinVec::new());\n+                        let path = P(this.expr_std_path(unstable_span, p, ThinVec::new()));\n                         P(this.expr_call(e.span, path, args))\n                     };\n \n@@ -1171,11 +1184,6 @@ impl<'a> LoweringContext<'a> {\n \n                     // let placer = <placer_expr> ;\n                     let (s1, placer_binding) = {\n-                        let placer_expr = P(self.signal_block_expr(hir_vec![],\n-                                                                   placer_expr,\n-                                                                   e.span,\n-                                                                   hir::PopUnstableBlock,\n-                                                                   ThinVec::new()));\n                         mk_stmt_let(self, placer_ident, placer_expr)\n                     };\n \n@@ -1196,11 +1204,6 @@ impl<'a> LoweringContext<'a> {\n \n                     // pop_unsafe!(EXPR));\n                     let pop_unsafe_expr = {\n-                        let value_expr = P(self.signal_block_expr(hir_vec![],\n-                                                                  value_expr,\n-                                                                  e.span,\n-                                                                  hir::PopUnstableBlock,\n-                                                                  ThinVec::new()));\n                         self.signal_block_expr(hir_vec![],\n                                                value_expr,\n                                                e.span,\n@@ -1229,11 +1232,9 @@ impl<'a> LoweringContext<'a> {\n                                                  ThinVec::new()))\n                     };\n \n-                    return self.signal_block_expr(hir_vec![s1, s2, s3],\n-                                                  expr,\n-                                                  e.span,\n-                                                  hir::PushUnstableBlock,\n-                                                  e.attrs.clone());\n+                    let block = self.block_all(e.span, hir_vec![s1, s2, s3], Some(expr));\n+                    // add the attributes to the outer returned expr node\n+                    return self.expr_block(P(block), e.attrs.clone());\n                 }\n \n                 ExprKind::Vec(ref exprs) => {\n@@ -1353,30 +1354,20 @@ impl<'a> LoweringContext<'a> {\n                                    fields: &[(&str, &P<Expr>)]) -> hir::Expr {\n                         let struct_path = &iter::once(&\"ops\").chain(path).map(|s| *s)\n                                                              .collect::<Vec<_>>();\n+                        let unstable_span = this.allow_internal_unstable(\"...\", ast_expr.span);\n \n-                        let hir_expr = if fields.len() == 0 {\n-                            this.expr_std_path(ast_expr.span, struct_path,\n+                        if fields.len() == 0 {\n+                            this.expr_std_path(unstable_span, struct_path,\n                                                ast_expr.attrs.clone())\n                         } else {\n                             let fields = fields.into_iter().map(|&(s, e)| {\n                                 let expr = P(this.lower_expr(&e));\n-                                let signal_block = P(this.signal_block_expr(hir_vec![],\n-                                                                            expr,\n-                                                                            e.span,\n-                                                                            hir::PopUnstableBlock,\n-                                                                            ThinVec::new()));\n-                                this.field(Symbol::intern(s), signal_block, ast_expr.span)\n+                                this.field(Symbol::intern(s), expr, e.span)\n                             }).collect();\n                             let attrs = ast_expr.attrs.clone();\n \n-                            this.expr_std_struct(ast_expr.span, struct_path, fields, None, attrs)\n-                        };\n-\n-                        this.signal_block_expr(hir_vec![],\n-                                               hir_expr,\n-                                               ast_expr.span,\n-                                               hir::PushUnstableBlock,\n-                                               ThinVec::new())\n+                            this.expr_std_struct(unstable_span, struct_path, fields, None, attrs)\n+                        }\n                     }\n \n                     use syntax::ast::RangeLimits::*;\n@@ -1646,7 +1637,7 @@ impl<'a> LoweringContext<'a> {\n                         let iter = P(self.expr_ident(e.span, iter, iter_pat.id));\n                         let ref_mut_iter = self.expr_mut_addr_of(e.span, iter);\n                         let next_path = &[\"iter\", \"Iterator\", \"next\"];\n-                        let next_path = self.expr_std_path(e.span, next_path, ThinVec::new());\n+                        let next_path = P(self.expr_std_path(e.span, next_path, ThinVec::new()));\n                         let next_expr = P(self.expr_call(e.span, next_path,\n                                           hir_vec![ref_mut_iter]));\n                         let arms = hir_vec![pat_arm, break_arm];\n@@ -1674,7 +1665,8 @@ impl<'a> LoweringContext<'a> {\n                     // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n                     let into_iter_expr = {\n                         let into_iter_path = &[\"iter\", \"IntoIterator\", \"into_iter\"];\n-                        let into_iter = self.expr_std_path(e.span, into_iter_path, ThinVec::new());\n+                        let into_iter = P(self.expr_std_path(e.span, into_iter_path,\n+                                                             ThinVec::new()));\n                         P(self.expr_call(e.span, into_iter, hir_vec![head]))\n                     };\n \n@@ -1700,32 +1692,20 @@ impl<'a> LoweringContext<'a> {\n                 ExprKind::Try(ref sub_expr) => {\n                     // to:\n                     //\n-                    // {\n-                    //     match { Carrier::translate( { <expr> } ) } {\n-                    //         Ok(val) => val,\n-                    //         Err(err) => { return Carrier::from_error(From::from(err)); }\n-                    //     }\n+                    // match Carrier::translate(<expr>) {\n+                    //     Ok(val) => val,\n+                    //     Err(err) => return Carrier::from_error(From::from(err))\n                     // }\n+                    let unstable_span = self.allow_internal_unstable(\"?\", e.span);\n \n-                    // { Carrier::translate( { <expr> } ) }\n+                    // Carrier::translate(<expr>)\n                     let discr = {\n                         // expand <expr>\n-                        let sub_expr = P(self.lower_expr(sub_expr));\n-                        let sub_expr = self.signal_block_expr(hir_vec![],\n-                                                              sub_expr,\n-                                                              e.span,\n-                                                              hir::PopUnstableBlock,\n-                                                              ThinVec::new());\n+                        let sub_expr = self.lower_expr(sub_expr);\n \n                         let path = &[\"ops\", \"Carrier\", \"translate\"];\n-                        let path = self.expr_std_path(e.span,path, ThinVec::new());\n-                        let call = P(self.expr_call(e.span, path, hir_vec![sub_expr]));\n-\n-                        P(self.signal_block_expr(hir_vec![],\n-                                                 call,\n-                                                 e.span,\n-                                                 hir::PushUnstableBlock,\n-                                                 ThinVec::new()))\n+                        let path = P(self.expr_std_path(unstable_span, path, ThinVec::new()));\n+                        P(self.expr_call(e.span, path, hir_vec![sub_expr]))\n                     };\n \n                     // Ok(val) => val\n@@ -1738,33 +1718,30 @@ impl<'a> LoweringContext<'a> {\n                         self.arm(hir_vec![ok_pat], val_expr)\n                     };\n \n-                    // Err(err) => { return Carrier::from_error(From::from(err)); }\n+                    // Err(err) => return Carrier::from_error(From::from(err))\n                     let err_arm = {\n                         let err_ident = self.str_to_ident(\"err\");\n                         let err_local = self.pat_ident(e.span, err_ident);\n                         let from_expr = {\n                             let path = &[\"convert\", \"From\", \"from\"];\n-                            let from = self.expr_std_path(e.span, path, ThinVec::new());\n+                            let from = P(self.expr_std_path(e.span, path, ThinVec::new()));\n                             let err_expr = self.expr_ident(e.span, err_ident, err_local.id);\n \n                             self.expr_call(e.span, from, hir_vec![err_expr])\n                         };\n                         let from_err_expr = {\n                             let path = &[\"ops\", \"Carrier\", \"from_error\"];\n-                            let from_err = self.expr_std_path(e.span, path, ThinVec::new());\n+                            let from_err = P(self.expr_std_path(unstable_span, path,\n+                                                                ThinVec::new()));\n                             P(self.expr_call(e.span, from_err, hir_vec![from_expr]))\n                         };\n \n                         let ret_expr = P(self.expr(e.span,\n                                                    hir::Expr_::ExprRet(Some(from_err_expr)),\n                                                                        ThinVec::new()));\n-                        let ret_stmt = self.stmt_expr(ret_expr);\n-                        let block = P(self.signal_block_stmt(ret_stmt, e.span,\n-                                                             hir::PushUnstableBlock,\n-                                                             ThinVec::new()));\n \n                         let err_pat = self.pat_err(e.span, err_local);\n-                        self.arm(hir_vec![err_pat], block)\n+                        self.arm(hir_vec![err_pat], ret_expr)\n                     };\n \n                     return self.expr_match(e.span, discr, hir_vec![err_arm, ok_arm],\n@@ -1938,12 +1915,12 @@ impl<'a> LoweringContext<'a> {\n                      span: Span,\n                      components: &[&str],\n                      attrs: ThinVec<Attribute>)\n-                     -> P<hir::Expr> {\n+                     -> hir::Expr {\n         let path = self.std_path(span, components, true);\n         let def = path.def;\n         let expr = self.expr(span, hir::ExprPath(hir::QPath::Resolved(None, P(path))), attrs);\n         self.resolver.record_resolution(expr.id, def);\n-        P(expr)\n+        expr\n     }\n \n     fn expr_match(&mut self,\n@@ -1968,13 +1945,13 @@ impl<'a> LoweringContext<'a> {\n                        components: &[&str],\n                        fields: hir::HirVec<hir::Field>,\n                        e: Option<P<hir::Expr>>,\n-                       attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n+                       attrs: ThinVec<Attribute>) -> hir::Expr {\n         let path = self.std_path(span, components, false);\n         let def = path.def;\n         let qpath = hir::QPath::Resolved(None, P(path));\n         let expr = self.expr(span, hir::ExprStruct(qpath, fields, e), attrs);\n         self.resolver.record_resolution(expr.id, def);\n-        P(expr)\n+        expr\n     }\n \n     fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> hir::Expr {\n@@ -2006,15 +1983,6 @@ impl<'a> LoweringContext<'a> {\n         (respan(sp, hir::StmtDecl(P(decl), self.next_id())), pat_id)\n     }\n \n-    // Turns `<expr>` into `<expr>;`, note that this produces a StmtSemi, not a\n-    // StmtExpr.\n-    fn stmt_expr(&self, expr: P<hir::Expr>) -> hir::Stmt {\n-        hir::Stmt {\n-            span: expr.span,\n-            node: hir::StmtSemi(expr, self.next_id()),\n-        }\n-    }\n-\n     fn block_expr(&mut self, expr: P<hir::Expr>) -> hir::Block {\n         self.block_all(expr.span, hir::HirVec::new(), Some(expr))\n     }\n@@ -2144,23 +2112,6 @@ impl<'a> LoweringContext<'a> {\n         self.expr_block(block, attrs)\n     }\n \n-    fn signal_block_stmt(&mut self,\n-                         stmt: hir::Stmt,\n-                         span: Span,\n-                         rule: hir::BlockCheckMode,\n-                         attrs: ThinVec<Attribute>)\n-                         -> hir::Expr {\n-        let id = self.next_id();\n-        let block = P(hir::Block {\n-            rules: rule,\n-            span: span,\n-            id: id,\n-            stmts: hir_vec![stmt],\n-            expr: None,\n-        });\n-        self.expr_block(block, attrs)\n-    }\n-\n     fn ty(&mut self, span: Span, node: hir::Ty_) -> P<hir::Ty> {\n         P(hir::Ty {\n             id: self.next_id(),"}, {"sha": "d494299a3c38841232dd3d4dfc1771b683b64a09", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f97c132cac79ef6bdf9f950b415c67bb43af387a/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c132cac79ef6bdf9f950b415c67bb43af387a/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f97c132cac79ef6bdf9f950b415c67bb43af387a", "patch": "@@ -838,9 +838,6 @@ pub enum BlockCheckMode {\n     UnsafeBlock(UnsafeSource),\n     PushUnsafeBlock(UnsafeSource),\n     PopUnsafeBlock(UnsafeSource),\n-    // Within this block (but outside a PopUnstableBlock), we suspend checking of stability.\n-    PushUnstableBlock,\n-    PopUnstableBlock,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]"}, {"sha": "31a8539119398b42c9995c2c48ba7b5196ad287a", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f97c132cac79ef6bdf9f950b415c67bb43af387a/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c132cac79ef6bdf9f950b415c67bb43af387a/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=f97c132cac79ef6bdf9f950b415c67bb43af387a", "patch": "@@ -1128,8 +1128,6 @@ impl<'a> State<'a> {\n             hir::UnsafeBlock(..) => self.word_space(\"unsafe\")?,\n             hir::PushUnsafeBlock(..) => self.word_space(\"push_unsafe\")?,\n             hir::PopUnsafeBlock(..) => self.word_space(\"pop_unsafe\")?,\n-            hir::PushUnstableBlock => self.word_space(\"push_unstable\")?,\n-            hir::PopUnstableBlock => self.word_space(\"pop_unstable\")?,\n             hir::DefaultBlock => (),\n         }\n         self.maybe_print_comment(blk.span.lo)?;"}, {"sha": "1313a3504c0bddfe6010866c20bc22a421523356", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f97c132cac79ef6bdf9f950b415c67bb43af387a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c132cac79ef6bdf9f950b415c67bb43af387a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=f97c132cac79ef6bdf9f950b415c67bb43af387a", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 self.unsafe_context.push_unsafe_count =\n                     self.unsafe_context.push_unsafe_count.checked_sub(1).unwrap();\n             }\n-            hir::DefaultBlock | hir::PushUnstableBlock | hir:: PopUnstableBlock => {}\n+            hir::DefaultBlock => {}\n         }\n \n         intravisit::walk_block(self, block);"}, {"sha": "d01954ab95a4ee966a7d49a44cb736f190e0819c", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f97c132cac79ef6bdf9f950b415c67bb43af387a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c132cac79ef6bdf9f950b415c67bb43af387a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=f97c132cac79ef6bdf9f950b415c67bb43af387a", "patch": "@@ -367,7 +367,6 @@ pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n         tcx: tcx,\n         active_features: active_features,\n         used_features: FxHashMap(),\n-        in_skip_block: 0,\n     };\n     intravisit::walk_crate(&mut checker, tcx.map.krate());\n \n@@ -378,8 +377,6 @@ struct Checker<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     active_features: FxHashSet<Symbol>,\n     used_features: FxHashMap<Symbol, attr::StabilityLevel>,\n-    // Within a block where feature gate checking can be skipped.\n-    in_skip_block: u32,\n }\n \n impl<'a, 'tcx> Checker<'a, 'tcx> {\n@@ -394,11 +391,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             return\n         }\n \n-        // We don't need to check for stability - presumably compiler generated code.\n-        if self.in_skip_block > 0 {\n-            return;\n-        }\n-\n         match *stab {\n             Some(&Stability { level: attr::Unstable {ref reason, issue}, ref feature, .. }) => {\n                 self.used_features.insert(feature.clone(),\n@@ -485,21 +477,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                  &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_ty(self, ty)\n     }\n-\n-    fn visit_block(&mut self, b: &'tcx hir::Block) {\n-        let old_skip_count = self.in_skip_block;\n-        match b.rules {\n-            hir::BlockCheckMode::PushUnstableBlock => {\n-                self.in_skip_block += 1;\n-            }\n-            hir::BlockCheckMode::PopUnstableBlock => {\n-                self.in_skip_block = self.in_skip_block.checked_sub(1).unwrap();\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_block(self, b);\n-        self.in_skip_block = old_skip_count;\n-    }\n }\n \n /// Helper for discovering nodes to check for stability"}, {"sha": "f803262a0ece67dce92ea63bdd4999e6e4b82048", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f97c132cac79ef6bdf9f950b415c67bb43af387a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c132cac79ef6bdf9f950b415c67bb43af387a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f97c132cac79ef6bdf9f950b415c67bb43af387a", "patch": "@@ -341,7 +341,7 @@ impl UnsafetyState {\n                         (unsafety, blk.id, self.unsafe_push_count.checked_sub(1).unwrap()),\n                     hir::UnsafeBlock(..) =>\n                         (hir::Unsafety::Unsafe, blk.id, self.unsafe_push_count),\n-                    hir::DefaultBlock | hir::PushUnstableBlock | hir:: PopUnstableBlock =>\n+                    hir::DefaultBlock =>\n                         (unsafety, self.def, self.unsafe_push_count),\n                 };\n                 UnsafetyState{ def: def,"}, {"sha": "12ce642891173725bd76951abbc40590cecbfb9f", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f97c132cac79ef6bdf9f950b415c67bb43af387a/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f97c132cac79ef6bdf9f950b415c67bb43af387a/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f97c132cac79ef6bdf9f950b415c67bb43af387a", "patch": "@@ -51,6 +51,8 @@ pub enum ExpnFormat {\n     MacroAttribute(Name),\n     /// e.g. `format!()`\n     MacroBang(Name),\n+    /// Desugaring done by the compiler during HIR lowering.\n+    CompilerDesugaring(Name)\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -105,8 +107,9 @@ pub struct NameAndSpan {\n impl NameAndSpan {\n     pub fn name(&self) -> Name {\n         match self.format {\n-            ExpnFormat::MacroAttribute(s) => s,\n-            ExpnFormat::MacroBang(s) => s,\n+            ExpnFormat::MacroAttribute(s) |\n+            ExpnFormat::MacroBang(s) |\n+            ExpnFormat::CompilerDesugaring(s) => s,\n         }\n     }\n }\n@@ -813,6 +816,7 @@ impl CodeMap {\n                     let (pre, post) = match ei.callee.format {\n                         MacroAttribute(..) => (\"#[\", \"]\"),\n                         MacroBang(..) => (\"\", \"!\"),\n+                        CompilerDesugaring(..) => (\"desugaring of `\", \"`\"),\n                     };\n                     let macro_decl_name = format!(\"{}{}{}\",\n                                                   pre,"}]}