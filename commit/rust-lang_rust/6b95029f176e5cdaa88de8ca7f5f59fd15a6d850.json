{"sha": "6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "node_id": "C_kwDOAAsO6NoAKDZiOTUwMjlmMTc2ZTVjZGFhODhkZThjYTdmNWY1OWZkMTVhNmQ4NTA", "commit": {"author": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2023-04-11T13:31:08Z"}, "committer": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2023-04-11T13:31:08Z"}, "message": "Merge commit '83e42a2337dadac915c956d125f1d69132f36425' into clippyup", "tree": {"sha": "a46baab4cf11050924648f768e9d5e2fd5f3f0bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a46baab4cf11050924648f768e9d5e2fd5f3f0bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "html_url": "https://github.com/rust-lang/rust/commit/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe129a022a0ae1c458b065725a819faabcbdb2b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe129a022a0ae1c458b065725a819faabcbdb2b6", "html_url": "https://github.com/rust-lang/rust/commit/fe129a022a0ae1c458b065725a819faabcbdb2b6"}], "stats": {"total": 6423, "additions": 4728, "deletions": 1695}, "files": [{"sha": "4d80d3ce63dac89aae6de38076d10a9feb89e047", "filename": ".cargo/config.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/.cargo%2Fconfig.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/.cargo%2Fconfig.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.cargo%2Fconfig.toml?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -11,3 +11,6 @@ target-dir = \"target\"\n \n [unstable]\n binary-dep-depinfo = true\n+\n+[profile.dev]\n+split-debuginfo = \"unpacked\""}, {"sha": "bc7642bf8c7c927999317658220a129c439c1f09", "filename": ".editorconfig", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/.editorconfig", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/.editorconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.editorconfig?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -11,6 +11,7 @@ trim_trailing_whitespace = true\n insert_final_newline = true\n indent_style = space\n indent_size = 4\n+max_line_length = 120\n \n [*.md]\n # double whitespace at end of line"}, {"sha": "93198aabdb5f5ae8f04369e580ee1ca54ce7f00f", "filename": ".github/workflows/clippy_bors.yml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_bors.yml?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -180,6 +180,8 @@ jobs:\n \n     # Run\n     - name: Build Integration Test\n+      env:\n+        CARGO_PROFILE_DEV_SPLIT_DEBUGINFO: off\n       run: cargo test --test integration --features integration --no-run\n \n     # Upload"}, {"sha": "116058b7c753843d68e4e0409f959bcb5f864129", "filename": ".github/workflows/remark.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/.github%2Fworkflows%2Fremark.yml", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/.github%2Fworkflows%2Fremark.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fremark.yml?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -29,7 +29,7 @@ jobs:\n     - name: Install mdbook\n       run: |\n         mkdir mdbook\n-        curl -Lf https://github.com/rust-lang/mdBook/releases/download/v0.4.18/mdbook-v0.4.18-x86_64-unknown-linux-gnu.tar.gz | tar -xz --directory=./mdbook\n+        curl -Lf https://github.com/rust-lang/mdBook/releases/download/v0.4.28/mdbook-v0.4.28-x86_64-unknown-linux-gnu.tar.gz | tar -xz --directory=./mdbook\n         echo `pwd`/mdbook >> $GITHUB_PATH\n \n     # Run"}, {"sha": "559b560dde4ba3fbd14e5a43d89bb37e0e3b8ccb", "filename": "CHANGELOG.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -4441,6 +4441,7 @@ Released 2018-09-13\n [`chars_last_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_last_cmp\n [`chars_next_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_next_cmp\n [`checked_conversions`]: https://rust-lang.github.io/rust-clippy/master/index.html#checked_conversions\n+[`clear_with_drain`]: https://rust-lang.github.io/rust-clippy/master/index.html#clear_with_drain\n [`clone_double_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_double_ref\n [`clone_on_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy\n [`clone_on_ref_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_ref_ptr\n@@ -4632,6 +4633,7 @@ Released 2018-09-13\n [`large_const_arrays`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_const_arrays\n [`large_digit_groups`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_digit_groups\n [`large_enum_variant`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_enum_variant\n+[`large_futures`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_futures\n [`large_include_file`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_include_file\n [`large_stack_arrays`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_stack_arrays\n [`large_types_passed_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_types_passed_by_value\n@@ -4645,6 +4647,7 @@ Released 2018-09-13\n [`let_underscore_untyped`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_underscore_untyped\n [`let_unit_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_unit_value\n [`let_with_type_underscore`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_with_type_underscore\n+[`lines_filter_map_ok`]: https://rust-lang.github.io/rust-clippy/master/index.html#lines_filter_map_ok\n [`linkedlist`]: https://rust-lang.github.io/rust-clippy/master/index.html#linkedlist\n [`logic_bug`]: https://rust-lang.github.io/rust-clippy/master/index.html#logic_bug\n [`lossy_float_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#lossy_float_literal\n@@ -4671,6 +4674,7 @@ Released 2018-09-13\n [`manual_rem_euclid`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_rem_euclid\n [`manual_retain`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_retain\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n+[`manual_slice_size_calculation`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_slice_size_calculation\n [`manual_split_once`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_split_once\n [`manual_str_repeat`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_str_repeat\n [`manual_string_new`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_string_new\n@@ -4921,6 +4925,7 @@ Released 2018-09-13\n [`suspicious_arithmetic_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_arithmetic_impl\n [`suspicious_assignment_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_assignment_formatting\n [`suspicious_command_arg_space`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_command_arg_space\n+[`suspicious_doc_comments`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_doc_comments\n [`suspicious_else_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_else_formatting\n [`suspicious_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_map\n [`suspicious_op_assign_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_op_assign_impl\n@@ -4933,6 +4938,7 @@ Released 2018-09-13\n [`tabs_in_doc_comments`]: https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments\n [`temporary_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_assignment\n [`temporary_cstring_as_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_cstring_as_ptr\n+[`tests_outside_test_module`]: https://rust-lang.github.io/rust-clippy/master/index.html#tests_outside_test_module\n [`to_digit_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_digit_is_some\n [`to_string_in_display`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_display\n [`to_string_in_format_args`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_format_args\n@@ -4974,6 +4980,7 @@ Released 2018-09-13\n [`unit_hash`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_hash\n [`unit_return_expecting_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_return_expecting_ord\n [`unknown_clippy_lints`]: https://rust-lang.github.io/rust-clippy/master/index.html#unknown_clippy_lints\n+[`unnecessary_box_returns`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_box_returns\n [`unnecessary_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n [`unnecessary_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_filter_map\n [`unnecessary_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_find_map"}, {"sha": "85798e0e80c15ea5a2abaff1c5dcbaeb5883aaa9", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -11,7 +11,7 @@ Lints are divided into categories, each with a default [lint level](https://doc.\n You can choose how much Clippy is supposed to ~~annoy~~ help you by changing the lint level by category.\n \n | Category              | Description                                                                         | Default level |\n-| --------------------- | ----------------------------------------------------------------------------------- | ------------- |\n+|-----------------------|-------------------------------------------------------------------------------------|---------------|\n | `clippy::all`         | all lints that are on by default (correctness, suspicious, style, complexity, perf) | **warn/deny** |\n | `clippy::correctness` | code that is outright wrong or useless                                              | **deny**      |\n | `clippy::suspicious`  | code that is most likely wrong or useless                                           | **warn**      |\n@@ -130,7 +130,7 @@ for example.\n \n You can add Clippy to Travis CI in the same way you use it locally:\n \n-```yml\n+```yaml\n language: rust\n rust:\n   - stable\n@@ -253,7 +253,7 @@ rust-version = \"1.30\"\n \n The MSRV can also be specified as an attribute, like below.\n \n-```rust\n+```rust,ignore\n #![feature(custom_inner_attributes)]\n #![clippy::msrv = \"1.30.0\"]\n "}, {"sha": "3b6270962680efdf48033a12083986de2fec4cf8", "filename": "book/src/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2FREADME.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -14,7 +14,7 @@ much Clippy is supposed to ~~annoy~~ help you by changing the lint level by\n category.\n \n | Category              | Description                                                                         | Default level |\n-| --------------------- | ----------------------------------------------------------------------------------- | ------------- |\n+|-----------------------|-------------------------------------------------------------------------------------|---------------|\n | `clippy::all`         | all lints that are on by default (correctness, suspicious, style, complexity, perf) | **warn/deny** |\n | `clippy::correctness` | code that is outright wrong or useless                                              | **deny**      |\n | `clippy::suspicious`  | code that is most likely wrong or useless                                           | **warn**      |"}, {"sha": "cbd73376dfa070b99071a41b9cb96313164a5ea2", "filename": "book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2FSUMMARY.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -13,6 +13,7 @@\n - [Development](development/README.md)\n     - [Basics](development/basics.md)\n     - [Adding Lints](development/adding_lints.md)\n+    - [Type Checking](development/type_checking.md)\n     - [Common Tools](development/common_tools_writing_lints.md)\n     - [Infrastructure](development/infrastructure/README.md)\n         - [Syncing changes between Clippy and rust-lang/rust](development/infrastructure/sync.md)"}, {"sha": "1304f6a8c2f095bc4056824fc9d1afe2aca3afb3", "filename": "book/src/configuration.md", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fconfiguration.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fconfiguration.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fconfiguration.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -3,7 +3,7 @@\n > **Note:** The configuration file is unstable and may be deprecated in the future.\n \n Some lints can be configured in a TOML file named `clippy.toml` or `.clippy.toml`. It contains a\n-basic `variable = value` mapping eg.\n+basic `variable = value` mapping e.g.\n \n ```toml\n avoid-breaking-exported-api = false\n@@ -60,7 +60,7 @@ And to warn on `lint_name`, run\n cargo clippy -- -W clippy::lint_name\n ```\n \n-This also works with lint groups. For example you can run Clippy with warnings for all lints enabled:\n+This also works with lint groups. For example, you can run Clippy with warnings for all lints enabled:\n \n ```terminal\n cargo clippy -- -W clippy::pedantic\n@@ -84,7 +84,7 @@ msrv = \"1.30.0\"\n \n The MSRV can also be specified as an attribute, like below.\n \n-```rust\n+```rust,ignore\n #![feature(custom_inner_attributes)]\n #![clippy::msrv = \"1.30.0\"]\n \n@@ -96,7 +96,28 @@ fn main() {\n You can also omit the patch version when specifying the MSRV, so `msrv = 1.30`\n is equivalent to `msrv = 1.30.0`.\n \n-Note: `custom_inner_attributes` is an unstable feature so it has to be enabled explicitly.\n+Note: `custom_inner_attributes` is an unstable feature, so it has to be enabled explicitly.\n \n Lints that recognize this configuration option can be\n found [here](https://rust-lang.github.io/rust-clippy/master/index.html#msrv)\n+\n+### Disabling evaluation of certain code\n+\n+> **Note:** This should only be used in cases where other solutions, like `#[allow(clippy::all)]`, are not sufficient.\n+\n+Very rarely, you may wish to prevent Clippy from evaluating certain sections of code entirely. You can do this with\n+[conditional compilation](https://doc.rust-lang.org/reference/conditional-compilation.html) by checking that the\n+`cargo-clippy` feature is not set. You may need to provide a stub so that the code compiles:\n+\n+```rust\n+#[cfg(not(feature = \"cargo-clippy\"))]\n+include!(concat!(env!(\"OUT_DIR\"), \"/my_big_function-generated.rs\"));\n+\n+#[cfg(feature = \"cargo-clippy\")]\n+fn my_big_function(_input: &str) -> Option<MyStruct> {\n+    None\n+}\n+```\n+\n+This feature is not actually part of your crate, so specifying `--all-features` to other tools, e.g. `cargo test\n+--all-features`, will not disable it."}, {"sha": "616e6d182b729d5d97d8402d283ea12b3f270480", "filename": "book/src/development/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2FREADME.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -5,7 +5,7 @@ making Clippy better by contributing to it. In that case, welcome to the\n project!\n \n > _Note:_ If you're just interested in using Clippy, there's nothing to see from\n-> this point onward and you should return to one of the earlier chapters.\n+> this point onward, and you should return to one of the earlier chapters.\n \n ## Getting started\n "}, {"sha": "9dacaaaae5c9277f78f4c301349349b026f8c079", "filename": "book/src/development/adding_lints.md", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fadding_lints.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -18,6 +18,7 @@ because that's clearly a non-descriptive name.\n     - [Cargo lints](#cargo-lints)\n   - [Rustfix tests](#rustfix-tests)\n   - [Testing manually](#testing-manually)\n+  - [Running directly](#running-directly)\n   - [Lint declaration](#lint-declaration)\n   - [Lint registration](#lint-registration)\n   - [Lint passes](#lint-passes)\n@@ -186,6 +187,15 @@ cargo dev lint input.rs\n from the working copy root. With tests in place, let's have a look at\n implementing our lint now.\n \n+## Running directly\n+\n+While it's easier to just use `cargo dev lint`, it might be desirable to get\n+`target/release/cargo-clippy` and `target/release/clippy-driver` to work as well in some cases.\n+By default, they don't work because clippy dynamically links rustc. To help them find rustc,\n+add the path printed by`rustc --print target-libdir` (ran inside this workspace so that the rustc version matches)\n+to your library search path.\n+On linux, this can be done by setting the `LD_LIBRARY_PATH` environment variable to that path.\n+\n ## Lint declaration\n \n Let's start by opening the new file created in the `clippy_lints` crate at\n@@ -265,7 +275,7 @@ When declaring a new lint by hand and `cargo dev update_lints` is used, the lint\n pass may have to be registered manually in the `register_plugins` function in\n `clippy_lints/src/lib.rs`:\n \n-```rust\n+```rust,ignore\n store.register_early_pass(|| Box::new(foo_functions::FooFunctions));\n ```\n \n@@ -291,7 +301,7 @@ either [`EarlyLintPass`][early_lint_pass] or [`LateLintPass`][late_lint_pass].\n \n In short, the `LateLintPass` has access to type information while the\n `EarlyLintPass` doesn't. If you don't need access to type information, use the\n-`EarlyLintPass`. The `EarlyLintPass` is also faster. However linting speed\n+`EarlyLintPass`. The `EarlyLintPass` is also faster. However, linting speed\n hasn't really been a concern with Clippy so far.\n \n Since we don't need type information for checking the function name, we used\n@@ -308,7 +318,7 @@ implementation of the lint logic.\n \n Let's start by implementing the `EarlyLintPass` for our `FooFunctions`:\n \n-```rust\n+```rust,ignore\n impl EarlyLintPass for FooFunctions {\n     fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, span: Span, _: NodeId) {\n         // TODO: Emit lint here\n@@ -327,10 +337,10 @@ variety of lint emission functions. They can all be found in\n [`clippy_utils/src/diagnostics.rs`][diagnostics].\n \n `span_lint_and_help` seems most appropriate in this case. It allows us to\n-provide an extra help message and we can't really suggest a better name\n+provide an extra help message, and we can't really suggest a better name\n automatically. This is how it looks:\n \n-```rust\n+```rust,ignore\n impl EarlyLintPass for FooFunctions {\n     fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, span: Span, _: NodeId) {\n         span_lint_and_help(\n@@ -469,7 +479,7 @@ the value from `clippy.toml`. This can be accounted for using the\n `extract_msrv_attr!(LintContext)` macro and passing\n `LateContext`/`EarlyContext`.\n \n-```rust\n+```rust,ignore\n impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         ...\n@@ -483,7 +493,7 @@ the lint's test file, `tests/ui/manual_strip.rs` in this example. It should\n have a case for the version below the MSRV and one with the same contents but\n for the MSRV version itself.\n \n-```rust\n+```rust,ignore\n ...\n \n #[clippy::msrv = \"1.44\"]\n@@ -514,7 +524,7 @@ define_Conf! {\n \n If you have trouble implementing your lint, there is also the internal `author`\n lint to generate Clippy code that detects the offending pattern. It does not\n-work for all of the Rust syntax, but can give a good starting point.\n+work for all the Rust syntax, but can give a good starting point.\n \n The quickest way to use it, is the [Rust playground:\n play.rust-lang.org][author_example]. Put the code you want to lint into the\n@@ -607,7 +617,7 @@ output in the `stdout` part.\n \n ## PR Checklist\n \n-Before submitting your PR make sure you followed all of the basic requirements:\n+Before submitting your PR make sure you followed all the basic requirements:\n \n <!-- Sync this with `.github/PULL_REQUEST_TEMPLATE` -->\n \n@@ -627,7 +637,7 @@ for some users. Adding a configuration is done in the following steps:\n \n 1. Adding a new configuration entry to [`clippy_lints::utils::conf`] like this:\n \n-   ```rust\n+   ```rust,ignore\n    /// Lint: LINT_NAME.\n    ///\n    /// <The configuration field doc comment>\n@@ -680,7 +690,7 @@ for some users. Adding a configuration is done in the following steps:\n    configuration value is now cloned or copied into a local value that is then\n    passed to the impl struct like this:\n \n-   ```rust\n+   ```rust,ignore\n    // Default generated registration:\n    store.register_*_pass(|| box module::StructName);\n "}, {"sha": "7615dc12f9ebedf280f7cfcce392d14867e1ce89", "filename": "book/src/development/basics.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Fbasics.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Fbasics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fbasics.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -4,8 +4,8 @@ This document explains the basics for hacking on Clippy. Besides others, this\n includes how to build and test Clippy. For a more in depth description on the\n codebase take a look at [Adding Lints] or [Common Tools].\n \n-[Adding Lints]: https://github.com/rust-lang/rust-clippy/blob/master/book/src/development/adding_lints.md\n-[Common Tools]: https://github.com/rust-lang/rust-clippy/blob/master/book/src/development/common_tools_writing_lints.md\n+[Adding Lints]: adding_lints.md\n+[Common Tools]: common_tools_writing_lints.md\n \n - [Basics for hacking on Clippy](#basics-for-hacking-on-clippy)\n   - [Get the Code](#get-the-code)\n@@ -125,7 +125,7 @@ We follow a rustc no merge-commit policy. See\n ## Common Abbreviations\n \n | Abbreviation | Meaning                                |\n-| ------------ | -------------------------------------- |\n+|--------------|----------------------------------------|\n | UB           | Undefined Behavior                     |\n | FP           | False Positive                         |\n | FN           | False Negative                         |"}, {"sha": "09171d86a2097965e286812d951c73fc6c9dddb2", "filename": "book/src/development/common_tools_writing_lints.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -3,7 +3,7 @@\n You may need following tooltips to catch up with common operations.\n \n - [Common tools for writing lints](#common-tools-for-writing-lints)\n-  - [Retrieving the type of an expression](#retrieving-the-type-of-an-expression)\n+  - [Retrieving the type of expression](#retrieving-the-type-of-expression)\n   - [Checking if an expr is calling a specific method](#checking-if-an-expr-is-calling-a-specific-method)\n   - [Checking for a specific type](#checking-for-a-specific-type)\n   - [Checking if a type implements a specific trait](#checking-if-a-type-implements-a-specific-trait)\n@@ -16,7 +16,7 @@ Useful Rustc dev guide links:\n - [Type checking](https://rustc-dev-guide.rust-lang.org/type-checking.html)\n - [Ty module](https://rustc-dev-guide.rust-lang.org/ty.html)\n \n-## Retrieving the type of an expression\n+## Retrieving the type of expression\n \n Sometimes you may want to retrieve the type `Ty` of an expression `Expr`, for\n example to answer following questions:\n@@ -45,7 +45,7 @@ impl LateLintPass<'_> for MyStructLint {\n }\n ```\n \n-Similarly in [`TypeckResults`][TypeckResults] methods, you have the\n+Similarly, in [`TypeckResults`][TypeckResults] methods, you have the\n [`pat_ty()`][pat_ty] method to retrieve a type from a pattern.\n \n Two noticeable items here:\n@@ -192,7 +192,7 @@ functions to deal with macros:\n - `span.from_expansion()`: detects if a span is from macro expansion or\n   desugaring. Checking this is a common first step in a lint.\n \n-   ```rust\n+   ```rust,ignore\n    if expr.span.from_expansion() {\n        // just forget it\n        return;\n@@ -203,11 +203,11 @@ functions to deal with macros:\n   if so, which macro call expanded it. It is sometimes useful to check if the\n   context of two spans are equal.\n \n-  ```rust\n+  ```rust,ignore\n   // expands to `1 + 0`, but don't lint\n   1 + mac!()\n   ```\n-  ```rust\n+  ```rust,ignore\n   if left.span.ctxt() != right.span.ctxt() {\n       // the coder most likely cannot modify this expression\n       return;\n@@ -246,7 +246,7 @@ functions to deal with macros:\n   `macro_rules!` with `a == $b`, `$b` is expanded to some expression with a\n   different context from `a`.\n \n-   ```rust\n+   ```rust,ignore\n    macro_rules! m {\n        ($a:expr, $b:expr) => {\n            if $a.is_some() {"}, {"sha": "de5de4bebaa91ef8bb0dc079a5a480ea22440f44", "filename": "book/src/development/infrastructure/book.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fbook.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fbook.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fbook.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -13,7 +13,7 @@ guide to Clippy that you're reading right now. The Clippy book is formatted with\n While not strictly necessary since the book source is simply Markdown text\n files, having mdBook locally will allow you to build, test and serve the book\n locally to view changes before you commit them to the repository. You likely\n-already have `cargo` installed, so the easiest option is to simply:\n+already have `cargo` installed, so the easiest option is to:\n \n ```shell\n cargo install mdbook\n@@ -26,7 +26,7 @@ instructions for other options.\n \n The book's\n [src](https://github.com/rust-lang/rust-clippy/tree/master/book/src)\n-directory contains all of the markdown files used to generate the book. If you\n+directory contains all the markdown files used to generate the book. If you\n want to see your changes in real time, you can use the mdBook `serve` command to\n run a web server locally that will automatically update changes as they are\n made. From the top level of your `rust-clippy` directory:"}, {"sha": "df9b1bbe18f326a385bf53c0c0c58be6200ce0c6", "filename": "book/src/development/infrastructure/changelog_update.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fchangelog_update.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fchangelog_update.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fchangelog_update.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -101,7 +101,7 @@ Look for the [`beta-accepted`] label and make sure to also include the PRs with\n that label in the changelog. If you can, remove the `beta-accepted` labels\n **after** the changelog PR was merged.\n \n-> _Note:_ Some of those PRs might even got backported to the previous `beta`.\n+> _Note:_ Some of those PRs might even get backported to the previous `beta`.\n > Those have to be included in the changelog of the _previous_ release.\n \n ### 4. Update `clippy::version` attributes"}, {"sha": "98fabf8e89aee9e66dd3ed51c0bf13b9010556f5", "filename": "book/src/development/infrastructure/release.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Frelease.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Frelease.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Frelease.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -44,7 +44,7 @@ $ git push origin backport_remerge  # This can be pushed to your fork\n ```\n \n After this, open a PR to the master branch. In this PR, the commit hash of the\n-`HEAD` of the `beta` branch must exists. In addition to that, no files should be\n+`HEAD` of the `beta` branch must exist. In addition to that, no files should be\n changed by this PR.\n \n ## Update the `beta` branch"}, {"sha": "e1fe92f95250d35d9d59287c17c181b38ae63ed6", "filename": "book/src/development/infrastructure/sync.md", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fsync.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fsync.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Finfrastructure%2Fsync.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -19,8 +19,7 @@ to beta. For reference, the first sync following this cadence was performed the\n 2020-08-27.\n \n This process is described in detail in the following sections. For general\n-information about `subtree`s in the Rust repository see [Rust's\n-`CONTRIBUTING.md`][subtree].\n+information about `subtree`s in the Rust repository see [the rustc-dev-guide][subtree].\n \n ## Patching git-subtree to work with big repos\n \n@@ -47,7 +46,7 @@ sudo chown --reference=/usr/lib/git-core/git-subtree~ /usr/lib/git-core/git-subt\n \n > _Note:_ If you are a Debian user, `dash` is the shell used by default for\n > scripts instead of `sh`. This shell has a hardcoded recursion limit set to\n-> 1000. In order to make this process work, you need to force the script to run\n+> 1,000. In order to make this process work, you need to force the script to run\n > `bash` instead. You can do this by editing the first line of the `git-subtree`\n > script and changing `sh` to `bash`.\n \n@@ -71,10 +70,10 @@ $ git remote add clippy-local /path/to/rust-clippy\n \n ## Performing the sync from [`rust-lang/rust`] to Clippy\n \n-Here is a TL;DR version of the sync process (all of the following commands have\n+Here is a TL;DR version of the sync process (all the following commands have\n to be run inside the `rust` directory):\n \n-1. Clone the [`rust-lang/rust`] repository or make sure it is up to date.\n+1. Clone the [`rust-lang/rust`] repository or make sure it is up-to-date.\n 2. Checkout the commit from the latest available nightly. You can get it using\n    `rustup check`.\n 3. Sync the changes to the rust-copy of Clippy to your Clippy fork:\n@@ -107,7 +106,7 @@ to be run inside the `rust` directory):\n \n ## Performing the sync from Clippy to [`rust-lang/rust`]\n \n-All of the following commands have to be run inside the `rust` directory.\n+All the following commands have to be run inside the `rust` directory.\n \n 1. Make sure you have checked out the latest `master` of `rust-lang/rust`.\n 2. Sync the `rust-lang/rust-clippy` master to the rust-copy of Clippy:\n@@ -118,5 +117,5 @@ All of the following commands have to be run inside the `rust` directory.\n 3. Open a PR to [`rust-lang/rust`]\n \n [gitgitgadget-pr]: https://github.com/gitgitgadget/git/pull/493\n-[subtree]: https://rustc-dev-guide.rust-lang.org/contributing.html#external-dependencies-subtree\n+[subtree]: https://rustc-dev-guide.rust-lang.org/external-repos.html#external-dependencies-subtree\n [`rust-lang/rust`]: https://github.com/rust-lang/rust"}, {"sha": "059c22ce1ce8c003b02e4023b39945a57f7b18d9", "filename": "book/src/development/proposals/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Fproposals%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Fproposals%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fproposals%2FREADME.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -6,6 +6,6 @@ or around Clippy in the long run.\n Besides adding more and more lints and improve the lints that Clippy already\n has, Clippy is also interested in making the experience of its users, developers\n and maintainers better over time. Projects that address bigger picture things\n-like this usually take more time and it is useful to have a proposal for those\n+like this usually take more time, and it is useful to have a proposal for those\n first. This is the place where such proposals are collected, so that we can\n refer to them when working on them."}, {"sha": "4406616bbb613c4faee3aba01b832bc28a621e4d", "filename": "book/src/development/proposals/roadmap-2021.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Fproposals%2Froadmap-2021.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Fproposals%2Froadmap-2021.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fproposals%2Froadmap-2021.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -52,8 +52,8 @@ In the following, plans to improve the usability are covered.\n \n #### No Output After `cargo check`\n \n-Currently when `cargo clippy` is run after `cargo check`, it does not produce\n-any output. This is especially problematic since `rust-analyzer` is on the rise\n+Currently, when `cargo clippy` is run after `cargo check`, it does not produce\n+any output. This is especially problematic since `rust-analyzer` is on the rise,\n and it uses `cargo check` for checking code. A fix is already implemented, but\n it still has to be pushed over the finish line. This also includes the\n stabilization of the `cargo clippy --fix` command or the support of multi-span\n@@ -221,7 +221,7 @@ regarding the user facing issues.\n \n Rust's roadmap process was established by [RFC 1728] in 2016. Since then every\n year a roadmap was published, that defined the bigger plans for the coming\n-years. This years roadmap can be found [here][Rust Roadmap 2021].\n+years. This year roadmap can be found [here][Rust Roadmap 2021].\n \n [RFC 1728]: https://rust-lang.github.io/rfcs/1728-north-star.html\n "}, {"sha": "36d722609f4ace2bf6bd2a136f6cf713ff7e7d51", "filename": "book/src/development/proposals/syntax-tree-patterns.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Fproposals%2Fsyntax-tree-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Fproposals%2Fsyntax-tree-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fproposals%2Fsyntax-tree-patterns.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -16,7 +16,7 @@ lints. For non-trivial lints, it often requires nested pattern matching of AST /\n HIR nodes. For example, testing that an expression is a boolean literal requires\n the following checks:\n \n-```rust\n+```rust,ignore\n if let ast::ExprKind::Lit(lit) = &expr.node {\n     if let ast::LitKind::Bool(_) = &lit.node {\n         ...\n@@ -28,7 +28,7 @@ Writing this kind of matching code quickly becomes a complex task and the\n resulting code is often hard to comprehend. The code below shows a simplified\n version of the pattern matching required by the `collapsible_if` lint:\n \n-```rust\n+```rust,ignore\n // simplified version of the collapsible_if lint\n if let ast::ExprKind::If(check, then, None) = &expr.node {\n     if then.stmts.len() == 1 {\n@@ -111,7 +111,7 @@ expressions that are boolean literals with value `false`.\n \n The pattern can then be used to implement lints in the following way:\n \n-```rust\n+```rust,ignore\n ...\n \n impl EarlyLintPass for MyAwesomeLint {\n@@ -346,7 +346,7 @@ pattern!{\n one could get references to the nodes that matched the subpatterns in the\n following way:\n \n-```rust\n+```rust,ignore\n ...\n fn check_expr(expr: &syntax::ast::Expr) {\n     if let Some(result) = my_pattern(expr) {\n@@ -372,7 +372,7 @@ matches arrays that consist of any number of literal expressions. Because those\n expressions are named `foo`, the result struct contains a `foo` attribute which\n is a vector of expressions:\n \n-```rust\n+```rust,ignore\n ...\n if let Some(result) = my_pattern_seq(expr) {\n     result.foo        // type: Vec<&syntax::ast::Expr>\n@@ -394,7 +394,7 @@ In the pattern above, the `bar` name is only defined if the pattern matches a\n boolean literal. If it matches an integer literal, the name isn't set. To\n account for this, the result struct's `bar` attribute is an option type:\n \n-```rust\n+```rust,ignore\n ...\n if let Some(result) = my_pattern_alt(expr) {\n     result.bar        // type: Option<&bool>\n@@ -404,7 +404,7 @@ if let Some(result) = my_pattern_alt(expr) {\n It's also possible to use a name in multiple alternation branches if they have\n compatible types:\n \n-```rust\n+```rust,ignore\n pattern!{\n     // matches if expression is a boolean or integer literal\n     my_pattern_mult: Expr =\n@@ -519,7 +519,7 @@ The `Alt`, `Seq` and `Opt` structs look like these:\n > Note: The current implementation can be found\n > [here](https://github.com/fkohlgrueber/pattern-matching/blob/dfb3bc9fbab69cec7c91e72564a63ebaa2ede638/pattern-match/src/matchers.rs#L35-L60).\n \n-```rust\n+```rust,ignore\n pub enum Alt<T> {\n     Any,\n     Elmt(Box<T>),\n@@ -580,7 +580,7 @@ implementations is the `IsMatch` trait. It defines how to match *PatternTree*\n nodes against specific syntax tree nodes. A simplified implementation of the\n `IsMatch` trait is shown below:\n \n-```rust\n+```rust,ignore\n pub trait IsMatch<O> {\n     fn is_match(&self, other: &'o O) -> bool;\n }\n@@ -619,7 +619,7 @@ approach (matching against the coarse pattern first and checking for additional\n properties later) might be slower than the current practice of checking for\n structure and additional properties in one pass. For example, the following lint\n \n-```rust\n+```rust,ignore\n pattern!{\n     pat_if_without_else: Expr =\n         If(\n@@ -644,7 +644,7 @@ first matches against the pattern and then checks that the `then` block doesn't\n start with a comment. Using clippy's current approach, it's possible to check\n for these conditions earlier:\n \n-```rust\n+```rust,ignore\n fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     if_chain! {\n         if let ast::ExprKind::If(ref check, ref then, None) = expr.node;\n@@ -708,7 +708,7 @@ is similar to actual Rust syntax (probably like the `quote!` macro). For\n example, a pattern that matches `if` expressions that have `false` in their\n condition could look like this:\n \n-```rust\n+```rust,ignore\n if false {\n     #[*]\n }\n@@ -742,7 +742,7 @@ affects the structure of the resulting AST. `1 + 0 + 0` is parsed as `(1 + 0) +\n Another example of a problem would be named submatches. Take a look at this\n pattern:\n \n-```rust\n+```rust,ignore\n fn test() {\n     1 #foo\n }\n@@ -862,7 +862,7 @@ op b` and recommends changing it to `a op= b` requires that both occurrences of\n `a` are the same. Using `=#...` as syntax for backreferences, the lint could be\n implemented like this:\n \n-```rust\n+```rust,ignore\n pattern!{\n     assign_op_pattern: Expr =\n         Assign(_#target, Binary(_, =#target, _)"}, {"sha": "5ce434b99a1a6ab368b45edcc3397081f2a319ab", "filename": "book/src/development/type_checking.md", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Ftype_checking.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fdevelopment%2Ftype_checking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Ftype_checking.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,144 @@\n+# Type Checking\n+\n+When we work on a new lint or improve an existing lint, we might want\n+to retrieve the type `Ty` of an expression `Expr` for a variety of\n+reasons. This can be achieved by utilizing the [`LateContext`][LateContext]\n+that is available for [`LateLintPass`][LateLintPass].\n+\n+## `LateContext` and `TypeckResults`\n+\n+The lint context [`LateContext`][LateContext] and [`TypeckResults`][TypeckResults]\n+(returned by `LateContext::typeck_results`) are the two most useful data structures\n+in `LateLintPass`. They allow us to jump to type definitions and other compilation\n+stages such as HIR.\n+\n+> Note: `LateContext.typeck_results`'s return value is [`TypeckResults`][TypeckResults]\n+> and is created in the type checking step, it includes useful information such as types of\n+> expressions, ways to resolve methods and so on.\n+\n+`TypeckResults` contains useful methods such as [`expr_ty`][expr_ty],\n+which gives us access to the underlying structure [`Ty`][Ty] of a given expression.\n+\n+```rust\n+pub fn expr_ty(&self, expr: &Expr<'_>) -> Ty<'tcx>\n+```\n+\n+As a side note, besides `expr_ty`, [`TypeckResults`][TypeckResults] contains a\n+[`pat_ty()`][pat_ty] method that is useful for retrieving a type from a pattern.\n+\n+## `Ty`\n+\n+`Ty` struct contains the type information of an expression.\n+Let's take a look at `rustc_middle`'s [`Ty`][Ty] struct to examine this struct:\n+\n+```rust\n+pub struct Ty<'tcx>(Interned<'tcx, WithStableHash<TyS<'tcx>>>);\n+```\n+\n+At a first glance, this struct looks quite esoteric. But at a closer look,\n+we will see that this struct contains many useful methods for type checking.\n+\n+For instance, [`is_char`][is_char] checks if the given `Ty` struct corresponds\n+to the primitive character type.\n+\n+### `is_*` Usage\n+\n+In some scenarios, all we need to do is check if the `Ty` of an expression\n+is a specific type, such as `char` type, so we could write the following:\n+\n+```rust\n+impl LateLintPass<'_> for MyStructLint {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        // Get type of `expr`\n+        let ty = cx.typeck_results().expr_ty(expr);\n+        \n+        // Check if the `Ty` of this expression is of character type\n+        if ty.is_char() {\n+            println!(\"Our expression is a char!\");\n+        }\n+    }\n+}\n+```\n+\n+Furthermore, if we examine the [source code][is_char_source] for `is_char`,\n+we find something very interesting:\n+\n+```rust\n+#[inline]\n+pub fn is_char(self) -> bool {\n+    matches!(self.kind(), Char)\n+}\n+```\n+\n+Indeed, we just discovered `Ty`'s [`kind` method][kind], which provides us\n+with [`TyKind`][TyKind] of a `Ty`.\n+\n+## `TyKind`\n+\n+`TyKind` defines the kinds of types in Rust's type system.\n+Peeking into [`TyKind` documentation][TyKind], we will see that it is an\n+enum of 27 variants, including items such as `Bool`, `Int`, `Ref`, etc.\n+\n+### `kind` Usage\n+\n+The `TyKind` of `Ty` can be returned by calling [`Ty.kind` method][kind].\n+We often use this method to perform pattern matching in Clippy.\n+\n+For instance, if we want to check for a `struct`, we could examine if the\n+`ty.kind` corresponds to an [`Adt`][Adt] (algebraic data type) and if its\n+[`AdtDef`][AdtDef] is a struct:\n+\n+```rust\n+impl LateLintPass<'_> for MyStructLint {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        // Get type of `expr`\n+        let ty = cx.typeck_results().expr_ty(expr);\n+        // Match its kind to enter the type\n+        match ty.kind {\n+            ty::Adt(adt_def, _) if adt_def.is_struct() => println!(\"Our `expr` is a struct!\"),\n+            _ => ()\n+        }\n+    }\n+}\n+```\n+\n+## `hir::Ty` and `ty::Ty`\n+\n+We've been talking about [`ty::Ty`][middle_ty] this whole time without addressing [`hir::Ty`][hir_ty], but the latter\n+is also important to understand.\n+\n+`hir::Ty` would represent *what* an user wrote, while `ty::Ty` would understand the meaning of it (because it has more\n+information).\n+\n+**Example: `fn foo(x: u32) -> u32 { x }`**\n+\n+Here the HIR sees the types without \"thinking\" about them, it knows that the function takes an `u32` and returns\n+an `u32`. But at the `ty::Ty` level the compiler understands that they're the same type, in-depth lifetimes, etc...\n+\n+you can use the [`hir_ty_to_ty`][hir_ty_to_ty] function to convert from a `hir::Ty` to a `ty::Ty`\n+\n+## Useful Links\n+\n+Below are some useful links to further explore the concepts covered\n+in this chapter:\n+\n+- [Stages of compilation](https://rustc-dev-guide.rust-lang.org/compiler-src.html#the-main-stages-of-compilation)\n+- [Diagnostic items](https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-items.html)\n+- [Type checking](https://rustc-dev-guide.rust-lang.org/type-checking.html)\n+- [Ty module](https://rustc-dev-guide.rust-lang.org/ty.html)\n+\n+[Adt]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variant.Adt\n+[AdtDef]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adt/struct.AdtDef.html\n+[expr_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.expr_ty\n+[is_char]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html#method.is_char\n+[is_char_source]: https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_middle/ty/sty.rs.html#1831-1834\n+[kind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html#method.kind\n+[LateContext]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LateContext.html\n+[LateLintPass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html\n+[pat_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TypeckResults.html#method.pat_ty\n+[Ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html\n+[TyKind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html\n+[TypeckResults]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html\n+[middle_ty]: https://doc.rust-lang.org/beta/nightly-rustc/rustc_middle/ty/struct.Ty.html\n+[hir_ty]: https://doc.rust-lang.org/beta/nightly-rustc/rustc_hir/struct.Ty.html\n+[hir_ty_to_ty]: https://doc.rust-lang.org/beta/nightly-rustc/rustc_hir_analysis/fn.hir_ty_to_ty.html"}, {"sha": "d54fff9deba1847f436599dcf58d1580fa06bc20", "filename": "book/src/installation.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Finstallation.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Finstallation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Finstallation.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -17,8 +17,8 @@ $ rustup component add clippy [--toolchain=<name>]\n \n ## From Source\n \n-Take a look at the [Basics] chapter in the Clippy developer guide to find step\n-by step instructions on how to build and install Clippy from source.\n+Take a look at the [Basics] chapter in the Clippy developer guide to find step-by-step\n+instructions on how to build and install Clippy from source.\n \n [Basics]: development/basics.md#install-from-source\n [Usage]: usage.md"}, {"sha": "78e1a55cff32e5ade599b92f3ee8cdd254e6a308", "filename": "book/src/lint_configuration.md", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Flint_configuration.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Flint_configuration.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flint_configuration.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -54,6 +54,7 @@ Please use that command to update the file and do not edit it by hand.\n | [allow-mixed-uninlined-format-args](#allow-mixed-uninlined-format-args) | `true` |\n | [suppress-restriction-lint-in-const](#suppress-restriction-lint-in-const) | `false` |\n | [missing-docs-in-crate-items](#missing-docs-in-crate-items) | `false` |\n+| [future-size-threshold](#future-size-threshold) | `16384` |\n \n ### arithmetic-side-effects-allowed\n Suppress checking of the passed type names in all types of operations.\n@@ -130,6 +131,7 @@ Suppress lints whenever the suggested change would cause breakage for other crat\n * [option_option](https://rust-lang.github.io/rust-clippy/master/index.html#option_option)\n * [linkedlist](https://rust-lang.github.io/rust-clippy/master/index.html#linkedlist)\n * [rc_mutex](https://rust-lang.github.io/rust-clippy/master/index.html#rc_mutex)\n+* [unnecessary_box_returns](https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_box_returns)\n \n \n ### msrv\n@@ -193,7 +195,7 @@ The maximum cognitive complexity a function can have\n ### disallowed-names\n The list of disallowed names to lint about. NB: `bar` is not here since it has legitimate uses. The value\n `\"..\"` can be used as part of the list to indicate, that the configured values should be appended to the\n-default configuration of Clippy. By default any configuration will replace the default value.\n+default configuration of Clippy. By default, any configuration will replace the default value.\n \n **Default Value:** `[\"foo\", \"baz\", \"quux\"]` (`Vec<String>`)\n \n@@ -203,7 +205,7 @@ default configuration of Clippy. By default any configuration will replace the d\n ### doc-valid-idents\n The list of words this lint should not consider as identifiers needing ticks. The value\n `\"..\"` can be used as part of the list to indicate, that the configured values should be appended to the\n-default configuration of Clippy. By default any configuraction will replace the default value. For example:\n+default configuration of Clippy. By default, any configuration will replace the default value. For example:\n * `doc-valid-idents = [\"ClipPy\"]` would replace the default list with `[\"ClipPy\"]`.\n * `doc-valid-idents = [\"ClipPy\", \"..\"]` would append `ClipPy` to the default list.\n \n@@ -413,7 +415,7 @@ For internal testing only, ignores the current `publish` settings in the Cargo m\n Enforce the named macros always use the braces specified.\n \n A `MacroMatcher` can be added like so `{ name = \"macro_name\", brace = \"(\" }`. If the macro\n-is could be used with a full path two `MacroMatcher`s have to be added one with the full path\n+could be used with a full path two `MacroMatcher`s have to be added one with the full path\n `crate_name::macro_name` and one with just the macro name.\n \n **Default Value:** `[]` (`Vec<crate::nonstandard_macro_braces::MacroMatcher>`)\n@@ -447,7 +449,7 @@ Whether to apply the raw pointer heuristic to determine if a type is `Send`.\n \n ### max-suggested-slice-pattern-length\n When Clippy suggests using a slice pattern, this is the maximum number of elements allowed in\n-the slice pattern that is suggested. If more elements would be necessary, the lint is suppressed.\n+the slice pattern that is suggested. If more elements are necessary, the lint is suppressed.\n For example, `[_, _, _, e, ..]` is a slice pattern with 4 elements.\n \n **Default Value:** `3` (`u64`)\n@@ -551,4 +553,12 @@ crate. For example, `pub(crate)` items.\n * [missing_docs_in_private_items](https://rust-lang.github.io/rust-clippy/master/index.html#missing_docs_in_private_items)\n \n \n+### future-size-threshold\n+The maximum byte size a `Future` can have, before it triggers the `clippy::large_futures` lint\n+\n+**Default Value:** `16384` (`u64`)\n+\n+* [large_futures](https://rust-lang.github.io/rust-clippy/master/index.html#large_futures)\n+\n+\n "}, {"sha": "442dc63914e9dafb8df2202369e8a88bab406662", "filename": "book/src/lints.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Flints.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Flints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flints.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -17,7 +17,7 @@ The different lint groups were defined in the [Clippy 1.0 RFC].\n The `clippy::correctness` group is the only lint group in Clippy which lints are\n deny-by-default and abort the compilation when triggered. This is for good\n reason: If you see a `correctness` lint, it means that your code is outright\n-wrong or useless and you should try to fix it.\n+wrong or useless, and you should try to fix it.\n \n Lints in this category are carefully picked and should be free of false\n positives. So just `#[allow]`ing those lints is not recommended.\n@@ -41,7 +41,7 @@ simplify your code. It mostly focuses on code that can be written in a shorter\n and more readable way, while preserving the semantics.\n \n If you should see a complexity lint, it usually means that you can remove or\n-replace some code and it is recommended to do so. However, if you need the more\n+replace some code, and it is recommended to do so. However, if you need the more\n complex code for some expressiveness reason, it is recommended to allow\n complexity lints on a case-by-case basis.\n \n@@ -50,9 +50,9 @@ complexity lints on a case-by-case basis.\n The `clippy::perf` group gives you suggestions on how you can increase the\n performance of your code. Those lints are mostly about code that the compiler\n can't trivially optimize, but has to be written in a slightly different way to\n-make the optimizer's job easier.\n+make the optimizer job easier.\n \n-Perf lints are usually easy to apply and it is recommended to do so.\n+Perf lints are usually easy to apply, and it is recommended to do so.\n \n ## Style\n \n@@ -91,7 +91,7 @@ and your use case.\n \n Lints from this group will restrict you in some way. If you enable a restriction\n lint for your crate it is recommended to also fix code that this lint triggers\n-on. However, those lints are really strict by design and you might want to\n+on. However, those lints are really strict by design, and you might want to\n `#[allow]` them in some special cases, with a comment justifying that.\n \n ## Cargo"}, {"sha": "32084a9199b7327213fd04f5d0339d87b44166dc", "filename": "book/src/usage.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fusage.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/book%2Fsrc%2Fusage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fusage.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -19,7 +19,7 @@ cargo clippy\n ### Lint configuration\n \n The above command will run the default set of lints, which are included in the\n-lint group `clippy::all`. You might want to use even more lints or you might not\n+lint group `clippy::all`. You might want to use even more lints, or you may not\n agree with every Clippy lint, and for that there are ways to configure lint\n levels.\n \n@@ -98,7 +98,7 @@ other of Clippy's lint groups.\n You can configure lint levels in source code the same way you can configure\n `rustc` lints:\n \n-```rust\n+```rust,ignore\n #![allow(clippy::style)]\n \n #[warn(clippy::double_neg)]"}, {"sha": "3a8b070d735160de7c23225b6b438a82cd9a3857", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,3 +1,4 @@\n+#![feature(lazy_cell)]\n #![feature(let_chains)]\n #![feature(rustc_private)]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]"}, {"sha": "13a2770342781a3b5892cb0a5583a01184f39b6b", "filename": "clippy_dev/src/new_lint.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fnew_lint.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -369,9 +369,7 @@ fn create_lint_for_ty(lint: &LintData<'_>, enable_msrv: bool, ty: &str) -> io::R\n                     }}\n                     todo!();\n                 }}\n-           \"#,\n-            context_import = context_import,\n-            name_upper = name_upper,\n+           \"#\n         );\n     } else {\n         let _: fmt::Result = writedoc!(\n@@ -385,9 +383,7 @@ fn create_lint_for_ty(lint: &LintData<'_>, enable_msrv: bool, ty: &str) -> io::R\n                 pub(super) fn check(cx: &{context_import}) {{\n                     todo!();\n                 }}\n-           \"#,\n-            context_import = context_import,\n-            name_upper = name_upper,\n+           \"#\n         );\n     }\n "}, {"sha": "95222a9acdfc53305efcf717d6f792a872bbe2f8", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -537,17 +537,13 @@ fn declare_deprecated(name: &str, path: &Path, reason: &str) -> io::Result<()> {\n             /// Nothing. This lint has been deprecated.\n             ///\n             /// ### Deprecation reason\n-            /// {}\n-            #[clippy::version = \\\"{}\\\"]\n-            pub {},\n-            \\\"{}\\\"\n+            /// {deprecation_reason}\n+            #[clippy::version = \\\"{version}\\\"]\n+            pub {name},\n+            \\\"{reason}\\\"\n         }}\n \n-        \",\n-        deprecation_reason,\n-        version,\n-        name,\n-        reason,\n+        \"\n     )\n }\n "}, {"sha": "18e8bf77225cfb3fff8db08771176fb2dae1d0ba", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -9,6 +9,7 @@ keywords = [\"clippy\", \"lint\", \"plugin\"]\n edition = \"2021\"\n \n [dependencies]\n+arrayvec = { version = \"0.7\", default-features = false }\n cargo_metadata = \"0.15.3\"\n clippy_utils = { path = \"../clippy_utils\" }\n declare_clippy_lint = { path = \"../declare_clippy_lint\" }"}, {"sha": "455f0df7cd0adcc3ab2d8728138e212a34fd9a31", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n use rustc_hir::{BinOpKind, Body, Expr, ExprKind, FnDecl, UnOp};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, Level};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map::Span;\n@@ -430,23 +430,25 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                 }\n             }\n             let nonminimal_bool_lint = |suggestions: Vec<_>| {\n-                span_lint_hir_and_then(\n-                    self.cx,\n-                    NONMINIMAL_BOOL,\n-                    e.hir_id,\n-                    e.span,\n-                    \"this boolean expression can be simplified\",\n-                    |diag| {\n-                        diag.span_suggestions(\n-                            e.span,\n-                            \"try\",\n-                            suggestions.into_iter(),\n-                            // nonminimal_bool can produce minimal but\n-                            // not human readable expressions (#3141)\n-                            Applicability::Unspecified,\n-                        );\n-                    },\n-                );\n+                if self.cx.tcx.lint_level_at_node(NONMINIMAL_BOOL, e.hir_id).0 != Level::Allow {\n+                    span_lint_hir_and_then(\n+                        self.cx,\n+                        NONMINIMAL_BOOL,\n+                        e.hir_id,\n+                        e.span,\n+                        \"this boolean expression can be simplified\",\n+                        |diag| {\n+                            diag.span_suggestions(\n+                                e.span,\n+                                \"try\",\n+                                suggestions.into_iter(),\n+                                // nonminimal_bool can produce minimal but\n+                                // not human readable expressions (#3141)\n+                                Applicability::Unspecified,\n+                            );\n+                        },\n+                    );\n+                }\n             };\n             if improvements.is_empty() {\n                 let mut visitor = NotSimplificationVisitor { cx: self.cx };\n@@ -498,6 +500,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NotSimplificationVisitor<'a, 'tcx> {\n         if let ExprKind::Unary(UnOp::Not, inner) = &expr.kind &&\n             !inner.span.from_expansion() &&\n             let Some(suggestion) = simplify_not(self.cx, inner)\n+\t\t\t&& self.cx.tcx.lint_level_at_node(NONMINIMAL_BOOL, expr.hir_id).0 != Level::Allow\n         {\n             span_lint_and_sugg(\n                 self.cx,"}, {"sha": "95c2ecbf791b5a5262cf308e4ce3338a9a763dd2", "filename": "clippy_lints/src/casts/cast_possible_truncation.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -2,8 +2,9 @@ use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use clippy_utils::expr_or_init;\n use clippy_utils::source::snippet;\n+use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{get_discriminant_value, is_isize_or_usize};\n-use rustc_errors::{Applicability, SuggestionStyle};\n+use rustc_errors::{Applicability, Diagnostic, SuggestionStyle};\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::LateContext;\n@@ -163,19 +164,34 @@ pub(super) fn check(\n         _ => return,\n     };\n \n-    let name_of_cast_from = snippet(cx, cast_expr.span, \"..\");\n-    let cast_to_snip = snippet(cx, cast_to_span, \"..\");\n-    let suggestion = format!(\"{cast_to_snip}::try_from({name_of_cast_from})\");\n-\n     span_lint_and_then(cx, CAST_POSSIBLE_TRUNCATION, expr.span, &msg, |diag| {\n         diag.help(\"if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\");\n-        diag.span_suggestion_with_style(\n-            expr.span,\n-            \"... or use `try_from` and handle the error accordingly\",\n-            suggestion,\n-            Applicability::Unspecified,\n-            // always show the suggestion in a separate line\n-            SuggestionStyle::ShowAlways,\n-        );\n+        if !cast_from.is_floating_point() {\n+            offer_suggestion(cx, expr, cast_expr, cast_to_span, diag);\n+        }\n     });\n }\n+\n+fn offer_suggestion(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    cast_expr: &Expr<'_>,\n+    cast_to_span: Span,\n+    diag: &mut Diagnostic,\n+) {\n+    let cast_to_snip = snippet(cx, cast_to_span, \"..\");\n+    let suggestion = if cast_to_snip == \"_\" {\n+        format!(\"{}.try_into()\", Sugg::hir(cx, cast_expr, \"..\").maybe_par())\n+    } else {\n+        format!(\"{cast_to_snip}::try_from({})\", Sugg::hir(cx, cast_expr, \"..\"))\n+    };\n+\n+    diag.span_suggestion_with_style(\n+        expr.span,\n+        \"... or use `try_from` and handle the error accordingly\",\n+        suggestion,\n+        Applicability::Unspecified,\n+        // always show the suggestion in a separate line\n+        SuggestionStyle::ShowAlways,\n+    );\n+}"}, {"sha": "5e2eb5789f6271bc4a05c38d609397cc7a417267", "filename": "clippy_lints/src/collection_is_never_read.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fcollection_is_never_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fcollection_is_never_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollection_is_never_read.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use clippy_utils::visitors::for_each_expr_with_closures;\n use clippy_utils::{get_enclosing_block, get_parent_node, path_to_local_id};\n use core::ops::ControlFlow;\n-use rustc_hir::{Block, ExprKind, HirId, Local, Node, PatKind};\n+use rustc_hir::{Block, ExprKind, HirId, LangItem, Local, Node, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::sym;\n@@ -44,24 +44,23 @@ declare_clippy_lint! {\n }\n declare_lint_pass!(CollectionIsNeverRead => [COLLECTION_IS_NEVER_READ]);\n \n-static COLLECTIONS: [Symbol; 10] = [\n+// Add `String` here when it is added to diagnostic items\n+static COLLECTIONS: [Symbol; 9] = [\n     sym::BTreeMap,\n     sym::BTreeSet,\n     sym::BinaryHeap,\n     sym::HashMap,\n     sym::HashSet,\n     sym::LinkedList,\n     sym::Option,\n-    sym::String,\n     sym::Vec,\n     sym::VecDeque,\n ];\n \n impl<'tcx> LateLintPass<'tcx> for CollectionIsNeverRead {\n     fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'tcx>) {\n         // Look for local variables whose type is a container. Search surrounding bock for read access.\n-        let ty = cx.typeck_results().pat_ty(local.pat);\n-        if COLLECTIONS.iter().any(|&sym| is_type_diagnostic_item(cx, ty, sym))\n+        if match_acceptable_type(cx, local, &COLLECTIONS)\n             && let PatKind::Binding(_, local_id, _, _) = local.pat.kind\n             && let Some(enclosing_block) = get_enclosing_block(cx, local.hir_id)\n             && has_no_read_access(cx, local_id, enclosing_block)\n@@ -71,6 +70,13 @@ impl<'tcx> LateLintPass<'tcx> for CollectionIsNeverRead {\n     }\n }\n \n+fn match_acceptable_type(cx: &LateContext<'_>, local: &Local<'_>, collections: &[rustc_span::Symbol]) -> bool {\n+    let ty = cx.typeck_results().pat_ty(local.pat);\n+    collections.iter().any(|&sym| is_type_diagnostic_item(cx, ty, sym))\n+    // String type is a lang item but not a diagnostic item for now so we need a separate check\n+        || is_type_lang_item(cx, ty, LangItem::String)\n+}\n+\n fn has_no_read_access<'tcx>(cx: &LateContext<'tcx>, id: HirId, block: &'tcx Block<'tcx>) -> bool {\n     let mut has_access = false;\n     let mut has_read_access = false;\n@@ -95,21 +101,34 @@ fn has_no_read_access<'tcx>(cx: &LateContext<'tcx>, id: HirId, block: &'tcx Bloc\n             return ControlFlow::Continue(());\n         }\n \n-        // Method call on `id` in a statement ignores any return value, so it's not a read access:\n+        // Look for method call with receiver `id`. It might be a non-read access:\n         //\n-        // id.foo(...); // Not reading `id`.\n+        // id.foo(args)\n         //\n         // Only assuming this for \"official\" methods defined on the type. For methods defined in extension\n         // traits (identified as local, based on the orphan rule), pessimistically assume that they might\n         // have side effects, so consider them a read.\n         if let Some(Node::Expr(parent)) = get_parent_node(cx.tcx, expr.hir_id)\n             && let ExprKind::MethodCall(_, receiver, _, _) = parent.kind\n             && path_to_local_id(receiver, id)\n-            && let Some(Node::Stmt(..)) = get_parent_node(cx.tcx, parent.hir_id)\n             && let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(parent.hir_id)\n             && !method_def_id.is_local()\n         {\n-            return ControlFlow::Continue(());\n+            // The method call is a statement, so the return value is not used. That's not a read access:\n+            //\n+            // id.foo(args);\n+            if let Some(Node::Stmt(..)) = get_parent_node(cx.tcx, parent.hir_id) {\n+                return ControlFlow::Continue(());\n+            }\n+\n+            // The method call is not a statement, so its return value is used somehow but its type is the\n+            // unit type, so this is not a real read access. Examples:\n+            //\n+            // let y = x.clear();\n+            // println!(\"{:?}\", x.clear());\n+            if cx.typeck_results().expr_ty(parent).is_unit() {\n+                return ControlFlow::Continue(());\n+            }\n         }\n \n         // Any other access to `id` is a read access. Stop searching."}, {"sha": "f24dab627809546fc455fa820c89bf69e8f5f1d3", "filename": "clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -218,6 +218,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::iter_not_returning_iterator::ITER_NOT_RETURNING_ITERATOR_INFO,\n     crate::large_const_arrays::LARGE_CONST_ARRAYS_INFO,\n     crate::large_enum_variant::LARGE_ENUM_VARIANT_INFO,\n+    crate::large_futures::LARGE_FUTURES_INFO,\n     crate::large_include_file::LARGE_INCLUDE_FILE_INFO,\n     crate::large_stack_arrays::LARGE_STACK_ARRAYS_INFO,\n     crate::len_zero::COMPARISON_TO_EMPTY_INFO,\n@@ -231,6 +232,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::let_with_type_underscore::LET_WITH_TYPE_UNDERSCORE_INFO,\n     crate::lifetimes::EXTRA_UNUSED_LIFETIMES_INFO,\n     crate::lifetimes::NEEDLESS_LIFETIMES_INFO,\n+    crate::lines_filter_map_ok::LINES_FILTER_MAP_OK_INFO,\n     crate::literal_representation::DECIMAL_LITERAL_REPRESENTATION_INFO,\n     crate::literal_representation::INCONSISTENT_DIGIT_GROUPING_INFO,\n     crate::literal_representation::LARGE_DIGIT_GROUPS_INFO,\n@@ -267,6 +269,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE_INFO,\n     crate::manual_rem_euclid::MANUAL_REM_EUCLID_INFO,\n     crate::manual_retain::MANUAL_RETAIN_INFO,\n+    crate::manual_slice_size_calculation::MANUAL_SLICE_SIZE_CALCULATION_INFO,\n     crate::manual_string_new::MANUAL_STRING_NEW_INFO,\n     crate::manual_strip::MANUAL_STRIP_INFO,\n     crate::map_unit_fn::OPTION_MAP_UNIT_FN_INFO,\n@@ -307,6 +310,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::methods::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS_INFO,\n     crate::methods::CHARS_LAST_CMP_INFO,\n     crate::methods::CHARS_NEXT_CMP_INFO,\n+    crate::methods::CLEAR_WITH_DRAIN_INFO,\n     crate::methods::CLONED_INSTEAD_OF_COPIED_INFO,\n     crate::methods::CLONE_DOUBLE_REF_INFO,\n     crate::methods::CLONE_ON_COPY_INFO,\n@@ -565,6 +569,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::strings::STR_TO_STRING_INFO,\n     crate::strings::TRIM_SPLIT_WHITESPACE_INFO,\n     crate::strlen_on_c_strings::STRLEN_ON_C_STRINGS_INFO,\n+    crate::suspicious_doc_comments::SUSPICIOUS_DOC_COMMENTS_INFO,\n     crate::suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS_INFO,\n     crate::suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL_INFO,\n     crate::suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL_INFO,\n@@ -574,6 +579,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::swap_ptr_to_ref::SWAP_PTR_TO_REF_INFO,\n     crate::tabs_in_doc_comments::TABS_IN_DOC_COMMENTS_INFO,\n     crate::temporary_assignment::TEMPORARY_ASSIGNMENT_INFO,\n+    crate::tests_outside_test_module::TESTS_OUTSIDE_TEST_MODULE_INFO,\n     crate::to_digit_is_some::TO_DIGIT_IS_SOME_INFO,\n     crate::trailing_empty_array::TRAILING_EMPTY_ARRAY_INFO,\n     crate::trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS_INFO,\n@@ -616,6 +622,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::unit_types::UNIT_CMP_INFO,\n     crate::unnamed_address::FN_ADDRESS_COMPARISONS_INFO,\n     crate::unnamed_address::VTABLE_ADDRESS_COMPARISONS_INFO,\n+    crate::unnecessary_box_returns::UNNECESSARY_BOX_RETURNS_INFO,\n     crate::unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS_INFO,\n     crate::unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS_INFO,\n     crate::unnecessary_struct_initialization::UNNECESSARY_STRUCT_INITIALIZATION_INFO,"}, {"sha": "c9fad98e43730c167a281aeaaec3e9fbafb3f4f5", "filename": "clippy_lints/src/disallowed_script_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fdisallowed_script_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fdisallowed_script_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_script_idents.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -32,7 +32,7 @@ declare_clippy_lint! {\n     /// ### Example\n     /// ```rust\n     /// // Assuming that `clippy.toml` contains the following line:\n-    /// // allowed-locales = [\"Latin\", \"Cyrillic\"]\n+    /// // allowed-scripts = [\"Latin\", \"Cyrillic\"]\n     /// let counter = 10; // OK, latin is allowed.\n     /// let \u0441\u0447\u0451\u0442\u0447\u0438\u043a = 10; // OK, cyrillic is allowed.\n     /// let z\u00e4hler = 10; // OK, it's still latin."}, {"sha": "315df6c714ffc4681d7189552347f773c4bca68f", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::macros::FormatArgsExpn;\n+use clippy_utils::macros::{find_format_args, format_args_inputs_span};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{is_expn_of, match_function_call, paths};\n use if_chain::if_chain;\n@@ -8,7 +8,7 @@ use rustc_hir::def::Res;\n use rustc_hir::{BindingAnnotation, Block, BlockCheckMode, Expr, ExprKind, Node, PatKind, QPath, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n+use rustc_span::{sym, ExpnId};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -43,23 +43,22 @@ declare_lint_pass!(ExplicitWrite => [EXPLICIT_WRITE]);\n \n impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            // match call to unwrap\n-            if let ExprKind::MethodCall(unwrap_fun, write_call, [], _) = expr.kind;\n-            if unwrap_fun.ident.name == sym::unwrap;\n+        // match call to unwrap\n+        if let ExprKind::MethodCall(unwrap_fun, write_call, [], _) = expr.kind\n+            && unwrap_fun.ident.name == sym::unwrap\n             // match call to write_fmt\n-            if let ExprKind::MethodCall(write_fun, write_recv, [write_arg], _) = look_in_block(cx, &write_call.kind);\n-            if write_fun.ident.name == sym!(write_fmt);\n+            && let ExprKind::MethodCall(write_fun, write_recv, [write_arg], _) = look_in_block(cx, &write_call.kind)\n+            && write_fun.ident.name == sym!(write_fmt)\n             // match calls to std::io::stdout() / std::io::stderr ()\n-            if let Some(dest_name) = if match_function_call(cx, write_recv, &paths::STDOUT).is_some() {\n+            && let Some(dest_name) = if match_function_call(cx, write_recv, &paths::STDOUT).is_some() {\n                 Some(\"stdout\")\n             } else if match_function_call(cx, write_recv, &paths::STDERR).is_some() {\n                 Some(\"stderr\")\n             } else {\n                 None\n-            };\n-            if let Some(format_args) = FormatArgsExpn::parse(cx, write_arg);\n-            then {\n+            }\n+        {\n+            find_format_args(cx, write_arg, ExpnId::root(), |format_args| {\n                 let calling_macro =\n                     // ordering is important here, since `writeln!` uses `write!` internally\n                     if is_expn_of(write_call.span, \"writeln\").is_some() {\n@@ -92,7 +91,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let inputs_snippet = snippet_with_applicability(\n                     cx,\n-                    format_args.inputs_span(),\n+                    format_args_inputs_span(format_args),\n                     \"..\",\n                     &mut applicability,\n                 );\n@@ -104,8 +103,8 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n                     \"try this\",\n                     format!(\"{prefix}{sugg_mac}!({inputs_snippet})\"),\n                     applicability,\n-                )\n-            }\n+                );\n+            });\n         }\n     }\n }"}, {"sha": "eeb4de8b58f484557079b9bf6674195b033254cd", "filename": "clippy_lints/src/extra_unused_type_parameters.rs", "status": "modified", "additions": 117, "deletions": 60, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fextra_unused_type_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fextra_unused_type_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fextra_unused_type_parameters.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,10 +1,10 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::trait_ref_of_method;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::MultiSpan;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_impl_item, walk_item, walk_param_bound, walk_ty, Visitor};\n use rustc_hir::{\n-    BodyId, ExprKind, GenericBound, GenericParamKind, Generics, ImplItem, ImplItemKind, Item, ItemKind,\n+    BodyId, ExprKind, GenericBound, GenericParam, GenericParamKind, Generics, ImplItem, ImplItemKind, Item, ItemKind,\n     PredicateOrigin, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -53,13 +53,19 @@ impl ExtraUnusedTypeParameters {\n         }\n     }\n \n-    /// Don't lint external macros or functions with empty bodies. Also, don't lint public items if\n-    /// the `avoid_breaking_exported_api` config option is set.\n-    fn check_false_positive(&self, cx: &LateContext<'_>, span: Span, def_id: LocalDefId, body_id: BodyId) -> bool {\n+    /// Don't lint external macros or functions with empty bodies. Also, don't lint exported items\n+    /// if the `avoid_breaking_exported_api` config option is set.\n+    fn is_empty_exported_or_macro(\n+        &self,\n+        cx: &LateContext<'_>,\n+        span: Span,\n+        def_id: LocalDefId,\n+        body_id: BodyId,\n+    ) -> bool {\n         let body = cx.tcx.hir().body(body_id).value;\n         let fn_empty = matches!(&body.kind, ExprKind::Block(blk, None) if blk.stmts.is_empty() && blk.expr.is_none());\n         let is_exported = cx.effective_visibilities.is_exported(def_id);\n-        in_external_macro(cx.sess(), span) || (self.avoid_breaking_exported_api && is_exported) || fn_empty\n+        in_external_macro(cx.sess(), span) || fn_empty || (is_exported && self.avoid_breaking_exported_api)\n     }\n }\n \n@@ -69,85 +75,129 @@ impl_lint_pass!(ExtraUnusedTypeParameters => [EXTRA_UNUSED_TYPE_PARAMETERS]);\n /// trait bounds those parameters have.\n struct TypeWalker<'cx, 'tcx> {\n     cx: &'cx LateContext<'tcx>,\n-    /// Collection of all the function's type parameters.\n+    /// Collection of the function's type parameters. Once the function has been walked, this will\n+    /// contain only unused type parameters.\n     ty_params: FxHashMap<DefId, Span>,\n-    /// Collection of any (inline) trait bounds corresponding to each type parameter.\n-    bounds: FxHashMap<DefId, Span>,\n+    /// Collection of any inline trait bounds corresponding to each type parameter.\n+    inline_bounds: FxHashMap<DefId, Span>,\n+    /// Collection of any type parameters with trait bounds that appear in a where clause.\n+    where_bounds: FxHashSet<DefId>,\n     /// The entire `Generics` object of the function, useful for querying purposes.\n     generics: &'tcx Generics<'tcx>,\n-    /// The value of this will remain `true` if *every* parameter:\n-    ///   1. Is a type parameter, and\n-    ///   2. Goes unused in the function.\n-    /// Otherwise, if any type parameters end up being used, or if any lifetime or const-generic\n-    /// parameters are present, this will be set to `false`.\n-    all_params_unused: bool,\n }\n \n impl<'cx, 'tcx> TypeWalker<'cx, 'tcx> {\n     fn new(cx: &'cx LateContext<'tcx>, generics: &'tcx Generics<'tcx>) -> Self {\n-        let mut all_params_unused = true;\n         let ty_params = generics\n             .params\n             .iter()\n-            .filter_map(|param| {\n-                if let GenericParamKind::Type { synthetic, .. } = param.kind {\n-                    (!synthetic).then_some((param.def_id.into(), param.span))\n-                } else {\n-                    if !param.is_elided_lifetime() {\n-                        all_params_unused = false;\n-                    }\n-                    None\n-                }\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Type { synthetic, .. } if !synthetic => Some((param.def_id.into(), param.span)),\n+                _ => None,\n             })\n             .collect();\n \n         Self {\n             cx,\n             ty_params,\n-            bounds: FxHashMap::default(),\n+            inline_bounds: FxHashMap::default(),\n+            where_bounds: FxHashSet::default(),\n             generics,\n-            all_params_unused,\n         }\n     }\n \n-    fn mark_param_used(&mut self, def_id: DefId) {\n-        if self.ty_params.remove(&def_id).is_some() {\n-            self.all_params_unused = false;\n-        }\n+    fn get_bound_span(&self, param: &'tcx GenericParam<'tcx>) -> Span {\n+        self.inline_bounds\n+            .get(&param.def_id.to_def_id())\n+            .map_or(param.span, |bound_span| param.span.with_hi(bound_span.hi()))\n+    }\n+\n+    fn emit_help(&self, spans: Vec<Span>, msg: &str, help: &'static str) {\n+        span_lint_and_help(self.cx, EXTRA_UNUSED_TYPE_PARAMETERS, spans, msg, None, help);\n+    }\n+\n+    fn emit_sugg(&self, spans: Vec<Span>, msg: &str, help: &'static str) {\n+        let suggestions: Vec<(Span, String)> = spans.iter().copied().zip(std::iter::repeat(String::new())).collect();\n+        span_lint_and_then(self.cx, EXTRA_UNUSED_TYPE_PARAMETERS, spans, msg, |diag| {\n+            diag.multipart_suggestion(help, suggestions, Applicability::MachineApplicable);\n+        });\n     }\n \n     fn emit_lint(&self) {\n-        let (msg, help) = match self.ty_params.len() {\n+        let explicit_params = self\n+            .generics\n+            .params\n+            .iter()\n+            .filter(|param| !param.is_elided_lifetime() && !param.is_impl_trait())\n+            .collect::<Vec<_>>();\n+\n+        let extra_params = explicit_params\n+            .iter()\n+            .enumerate()\n+            .filter(|(_, param)| self.ty_params.contains_key(&param.def_id.to_def_id()))\n+            .collect::<Vec<_>>();\n+\n+        let (msg, help) = match extra_params.len() {\n             0 => return,\n             1 => (\n-                \"type parameter goes unused in function definition\",\n+                format!(\n+                    \"type parameter `{}` goes unused in function definition\",\n+                    extra_params[0].1.name.ident()\n+                ),\n                 \"consider removing the parameter\",\n             ),\n             _ => (\n-                \"type parameters go unused in function definition\",\n+                format!(\n+                    \"type parameters go unused in function definition: {}\",\n+                    extra_params\n+                        .iter()\n+                        .map(|(_, param)| param.name.ident().to_string())\n+                        .collect::<Vec<_>>()\n+                        .join(\", \")\n+                ),\n                 \"consider removing the parameters\",\n             ),\n         };\n \n-        let source_map = self.cx.sess().source_map();\n-        let span = if self.all_params_unused {\n-            self.generics.span.into() // Remove the entire list of generics\n+        // If any parameters are bounded in where clauses, don't try to form a suggestion.\n+        // Otherwise, the leftover where bound would produce code that wouldn't compile.\n+        if extra_params\n+            .iter()\n+            .any(|(_, param)| self.where_bounds.contains(&param.def_id.to_def_id()))\n+        {\n+            let spans = extra_params\n+                .iter()\n+                .map(|(_, param)| self.get_bound_span(param))\n+                .collect::<Vec<_>>();\n+            self.emit_help(spans, &msg, help);\n         } else {\n-            MultiSpan::from_spans(\n-                self.ty_params\n+            let spans = if explicit_params.len() == extra_params.len() {\n+                vec![self.generics.span] // Remove the entire list of generics\n+            } else {\n+                let mut end: Option<LocalDefId> = None;\n+                extra_params\n                     .iter()\n-                    .map(|(def_id, &span)| {\n-                        // Extend the span past any trait bounds, and include the comma at the end.\n-                        let span_to_extend = self.bounds.get(def_id).copied().map_or(span, Span::shrink_to_hi);\n-                        let comma_range = source_map.span_extend_to_next_char(span_to_extend, '>', false);\n-                        let comma_span = source_map.span_through_char(comma_range, ',');\n-                        span.with_hi(comma_span.hi())\n+                    .rev()\n+                    .map(|(idx, param)| {\n+                        if let Some(next) = explicit_params.get(idx + 1) && end != Some(next.def_id) {\n+                        // Extend the current span forward, up until the next param in the list.\n+                        param.span.until(next.span)\n+                    } else {\n+                        // Extend the current span back to include the comma following the previous\n+                        // param. If the span of the next param in the list has already been\n+                        // extended, we continue the chain. This is why we're iterating in reverse.\n+                        end = Some(param.def_id);\n+\n+                        // idx will never be 0, else we'd be removing the entire list of generics\n+                        let prev = explicit_params[idx - 1];\n+                        let prev_span = self.get_bound_span(prev);\n+                        self.get_bound_span(param).with_lo(prev_span.hi())\n+                    }\n                     })\n-                    .collect(),\n-            )\n+                    .collect()\n+            };\n+            self.emit_sugg(spans, &msg, help);\n         };\n-\n-        span_lint_and_help(self.cx, EXTRA_UNUSED_TYPE_PARAMETERS, span, msg, None, help);\n     }\n }\n \n@@ -162,7 +212,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for TypeWalker<'cx, 'tcx> {\n \n     fn visit_ty(&mut self, t: &'tcx Ty<'tcx>) {\n         if let Some((def_id, _)) = t.peel_refs().as_generic_param() {\n-            self.mark_param_used(def_id);\n+            self.ty_params.remove(&def_id);\n         } else if let TyKind::OpaqueDef(id, _, _) = t.kind {\n             // Explicitly walk OpaqueDef. Normally `walk_ty` would do the job, but it calls\n             // `visit_nested_item`, which checks that `Self::NestedFilter::INTER` is set. We're\n@@ -176,9 +226,18 @@ impl<'cx, 'tcx> Visitor<'tcx> for TypeWalker<'cx, 'tcx> {\n \n     fn visit_where_predicate(&mut self, predicate: &'tcx WherePredicate<'tcx>) {\n         if let WherePredicate::BoundPredicate(predicate) = predicate {\n-            // Collect spans for any bounds on type parameters. We only keep bounds that appear in\n-            // the list of generics (not in a where-clause).\n+            // Collect spans for any bounds on type parameters.\n             if let Some((def_id, _)) = predicate.bounded_ty.peel_refs().as_generic_param() {\n+                match predicate.origin {\n+                    PredicateOrigin::GenericParam => {\n+                        self.inline_bounds.insert(def_id, predicate.span);\n+                    },\n+                    PredicateOrigin::WhereClause => {\n+                        self.where_bounds.insert(def_id);\n+                    },\n+                    PredicateOrigin::ImplTrait => (),\n+                }\n+\n                 // If the bound contains non-public traits, err on the safe side and don't lint the\n                 // corresponding parameter.\n                 if !predicate\n@@ -187,12 +246,10 @@ impl<'cx, 'tcx> Visitor<'tcx> for TypeWalker<'cx, 'tcx> {\n                     .filter_map(bound_to_trait_def_id)\n                     .all(|id| self.cx.effective_visibilities.is_exported(id))\n                 {\n-                    self.mark_param_used(def_id);\n-                } else if let PredicateOrigin::GenericParam = predicate.origin {\n-                    self.bounds.insert(def_id, predicate.span);\n+                    self.ty_params.remove(&def_id);\n                 }\n             }\n-            // Only walk the right-hand side of where-bounds\n+            // Only walk the right-hand side of where bounds\n             for bound in predicate.bounds {\n                 walk_param_bound(self, bound);\n             }\n@@ -207,7 +264,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for TypeWalker<'cx, 'tcx> {\n impl<'tcx> LateLintPass<'tcx> for ExtraUnusedTypeParameters {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n         if let ItemKind::Fn(_, generics, body_id) = item.kind\n-            && !self.check_false_positive(cx, item.span, item.owner_id.def_id, body_id)\n+            && !self.is_empty_exported_or_macro(cx, item.span, item.owner_id.def_id, body_id)\n         {\n             let mut walker = TypeWalker::new(cx, generics);\n             walk_item(&mut walker, item);\n@@ -219,7 +276,7 @@ impl<'tcx> LateLintPass<'tcx> for ExtraUnusedTypeParameters {\n         // Only lint on inherent methods, not trait methods.\n         if let ImplItemKind::Fn(.., body_id) = item.kind\n             && trait_ref_of_method(cx, item.owner_id.def_id).is_none()\n-            && !self.check_false_positive(cx, item.span, item.owner_id.def_id, body_id)\n+            && !self.is_empty_exported_or_macro(cx, item.span, item.owner_id.def_id, body_id)\n         {\n             let mut walker = TypeWalker::new(cx, item.generics);\n             walk_impl_item(&mut walker, item);"}, {"sha": "d34d6e9279e4dde86fff5f9f0c5d82cec7685471", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 44, "deletions": 47, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,14 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn};\n-use clippy_utils::source::snippet_with_context;\n+use clippy_utils::macros::{find_format_arg_expr, find_format_args, root_macro_call_first_node};\n+use clippy_utils::source::{snippet_opt, snippet_with_context};\n use clippy_utils::sugg::Sugg;\n-use if_chain::if_chain;\n+use rustc_ast::{FormatArgsPiece, FormatOptions, FormatTrait};\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::kw;\n use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n@@ -44,55 +43,53 @@ declare_lint_pass!(UselessFormat => [USELESS_FORMAT]);\n \n impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let (format_args, call_site) = if_chain! {\n-            if let Some(macro_call) = root_macro_call_first_node(cx, expr);\n-            if cx.tcx.is_diagnostic_item(sym::format_macro, macro_call.def_id);\n-            if let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, macro_call.expn);\n-            then {\n-                (format_args, macro_call.span)\n-            } else {\n-                return\n-            }\n-        };\n+        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return };\n+        if !cx.tcx.is_diagnostic_item(sym::format_macro, macro_call.def_id) {\n+            return;\n+        }\n+\n+        find_format_args(cx, expr, macro_call.expn, |format_args| {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let call_site = macro_call.span;\n \n-        let mut applicability = Applicability::MachineApplicable;\n-        if format_args.args.is_empty() {\n-            match *format_args.format_string.parts {\n-                [] => span_useless_format_empty(cx, call_site, \"String::new()\".to_owned(), applicability),\n-                [_] => {\n+            match (format_args.arguments.all_args(), &format_args.template[..]) {\n+                ([], []) => span_useless_format_empty(cx, call_site, \"String::new()\".to_owned(), applicability),\n+                ([], [_]) => {\n                     // Simulate macro expansion, converting {{ and }} to { and }.\n-                    let s_expand = format_args.format_string.snippet.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n+                    let Some(snippet) = snippet_opt(cx, format_args.span) else { return };\n+                    let s_expand = snippet.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n                     let sugg = format!(\"{s_expand}.to_string()\");\n                     span_useless_format(cx, call_site, sugg, applicability);\n                 },\n-                [..] => {},\n-            }\n-        } else if let [arg] = &*format_args.args {\n-            let value = arg.param.value;\n-            if_chain! {\n-                if format_args.format_string.parts == [kw::Empty];\n-                if arg.format.is_default();\n-                if match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n-                    ty::Adt(adt, _) => Some(adt.did()) == cx.tcx.lang_items().string(),\n-                    ty::Str => true,\n-                    _ => false,\n-                };\n-                then {\n-                    let is_new_string = match value.kind {\n-                        ExprKind::Binary(..) => true,\n-                        ExprKind::MethodCall(path, ..) => path.ident.name == sym::to_string,\n-                        _ => false,\n-                    };\n-                    let sugg = if is_new_string {\n-                        snippet_with_context(cx, value.span, call_site.ctxt(), \"..\", &mut applicability).0.into_owned()\n-                    } else {\n-                        let sugg = Sugg::hir_with_context(cx, value, call_site.ctxt(), \"<arg>\", &mut applicability);\n-                        format!(\"{}.to_string()\", sugg.maybe_par())\n-                    };\n-                    span_useless_format(cx, call_site, sugg, applicability);\n-                }\n+                ([arg], [piece]) => {\n+                    if let Ok(value) = find_format_arg_expr(expr, arg)\n+                        && let FormatArgsPiece::Placeholder(placeholder) = piece\n+                        && placeholder.format_trait == FormatTrait::Display\n+                        && placeholder.format_options == FormatOptions::default()\n+                        && match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n+                            ty::Adt(adt, _) => Some(adt.did()) == cx.tcx.lang_items().string(),\n+                            ty::Str => true,\n+                            _ => false,\n+                        }\n+                    {\n+                        let is_new_string = match value.kind {\n+                            ExprKind::Binary(..) => true,\n+                            ExprKind::MethodCall(path, ..) => path.ident.name == sym::to_string,\n+                            _ => false,\n+                        };\n+                        let sugg = if is_new_string {\n+                            snippet_with_context(cx, value.span, call_site.ctxt(), \"..\", &mut applicability).0.into_owned()\n+                        } else {\n+                            let sugg = Sugg::hir_with_context(cx, value, call_site.ctxt(), \"<arg>\", &mut applicability);\n+                            format!(\"{}.to_string()\", sugg.maybe_par())\n+                        };\n+                        span_useless_format(cx, call_site, sugg, applicability);\n+\n+                    }\n+                },\n+                _ => {},\n             }\n-        };\n+        });\n     }\n }\n "}, {"sha": "08e45ed7d0ec8e45a08f1bcc9cdff0630e82354a", "filename": "clippy_lints/src/format_args.rs", "status": "modified", "additions": 132, "deletions": 92, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,27 +1,31 @@\n+use arrayvec::ArrayVec;\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::is_diag_trait_item;\n-use clippy_utils::macros::FormatParamKind::{Implicit, Named, NamedInline, Numbered, Starred};\n use clippy_utils::macros::{\n-    is_assert_macro, is_format_macro, is_panic, root_macro_call, Count, FormatArg, FormatArgsExpn, FormatParam,\n-    FormatParamUsage,\n+    find_format_arg_expr, find_format_args, format_arg_removal_span, format_placeholder_format_span, is_assert_macro,\n+    is_format_macro, is_panic, root_macro_call, root_macro_call_first_node, FormatParamUsage,\n };\n use clippy_utils::msrvs::{self, Msrv};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{implements_trait, is_type_lang_item};\n use if_chain::if_chain;\n use itertools::Itertools;\n+use rustc_ast::{\n+    FormatArgPosition, FormatArgPositionKind, FormatArgsPiece, FormatArgumentKind, FormatCount, FormatOptions,\n+    FormatPlaceholder, FormatTrait,\n+};\n use rustc_errors::{\n     Applicability,\n     SuggestionStyle::{CompletelyHidden, ShowCode},\n };\n-use rustc_hir::{Expr, ExprKind, HirId, LangItem, QPath};\n+use rustc_hir::{Expr, ExprKind, LangItem};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_middle::ty::Ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::def_id::DefId;\n use rustc_span::edition::Edition::Edition2021;\n-use rustc_span::{sym, ExpnData, ExpnKind, Span, Symbol};\n+use rustc_span::{sym, Span, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -184,111 +188,120 @@ impl FormatArgs {\n \n impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if let Some(format_args) = FormatArgsExpn::parse(cx, expr)\n-            && let expr_expn_data = expr.span.ctxt().outer_expn_data()\n-            && let outermost_expn_data = outermost_expn_data(expr_expn_data)\n-            && let Some(macro_def_id) = outermost_expn_data.macro_def_id\n-            && is_format_macro(cx, macro_def_id)\n-            && let ExpnKind::Macro(_, name) = outermost_expn_data.kind\n-        {\n-            for arg in &format_args.args {\n-                check_unused_format_specifier(cx, arg);\n-                if !arg.format.is_default() {\n-                    continue;\n-                }\n-                if is_aliased(&format_args, arg.param.value.hir_id) {\n-                    continue;\n+        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return };\n+        if !is_format_macro(cx, macro_call.def_id) {\n+            return;\n+        }\n+        let name = cx.tcx.item_name(macro_call.def_id);\n+\n+        find_format_args(cx, expr, macro_call.expn, |format_args| {\n+            for piece in &format_args.template {\n+                if let FormatArgsPiece::Placeholder(placeholder) = piece\n+                    && let Ok(index) = placeholder.argument.index\n+                    && let Some(arg) = format_args.arguments.all_args().get(index)\n+                {\n+                    let arg_expr = find_format_arg_expr(expr, arg);\n+\n+                    check_unused_format_specifier(cx, placeholder, arg_expr);\n+\n+                    if placeholder.format_trait != FormatTrait::Display\n+                        || placeholder.format_options != FormatOptions::default()\n+                        || is_aliased(format_args, index)\n+                    {\n+                        continue;\n+                    }\n+\n+                    if let Ok(arg_hir_expr) = arg_expr {\n+                        check_format_in_format_args(cx, macro_call.span, name, arg_hir_expr);\n+                        check_to_string_in_format_args(cx, name, arg_hir_expr);\n+                    }\n                 }\n-                check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg.param.value);\n-                check_to_string_in_format_args(cx, name, arg.param.value);\n             }\n+\n             if self.msrv.meets(msrvs::FORMAT_ARGS_CAPTURE) {\n-                check_uninlined_args(cx, &format_args, outermost_expn_data.call_site, macro_def_id, self.ignore_mixed);\n+                check_uninlined_args(cx, format_args, macro_call.span, macro_call.def_id, self.ignore_mixed);\n             }\n-        }\n+        });\n     }\n \n     extract_msrv_attr!(LateContext);\n }\n \n-fn check_unused_format_specifier(cx: &LateContext<'_>, arg: &FormatArg<'_>) {\n-    let param_ty = cx.typeck_results().expr_ty(arg.param.value).peel_refs();\n+fn check_unused_format_specifier(\n+    cx: &LateContext<'_>,\n+    placeholder: &FormatPlaceholder,\n+    arg_expr: Result<&Expr<'_>, &rustc_ast::Expr>,\n+) {\n+    let ty_or_ast_expr = arg_expr.map(|expr| cx.typeck_results().expr_ty(expr).peel_refs());\n \n-    if let Count::Implied(Some(mut span)) = arg.format.precision\n-        && !span.is_empty()\n-    {\n-        span_lint_and_then(\n-            cx,\n-            UNUSED_FORMAT_SPECS,\n-            span,\n-            \"empty precision specifier has no effect\",\n-            |diag| {\n-                if param_ty.is_floating_point() {\n-                    diag.note(\"a precision specifier is not required to format floats\");\n-                }\n+    let is_format_args = match ty_or_ast_expr {\n+        Ok(ty) => is_type_lang_item(cx, ty, LangItem::FormatArguments),\n+        Err(expr) => matches!(expr.peel_parens_and_refs().kind, rustc_ast::ExprKind::FormatArgs(_)),\n+    };\n \n-                if arg.format.is_default() {\n-                    // If there's no other specifiers remove the `:` too\n-                    span = arg.format_span();\n-                }\n+    let options = &placeholder.format_options;\n \n-                diag.span_suggestion_verbose(span, \"remove the `.`\", \"\", Applicability::MachineApplicable);\n-            },\n-        );\n-    }\n+    let arg_span = match arg_expr {\n+        Ok(expr) => expr.span,\n+        Err(expr) => expr.span,\n+    };\n \n-    if is_type_lang_item(cx, param_ty, LangItem::FormatArguments) && !arg.format.is_default_for_trait() {\n+    if let Some(placeholder_span) = placeholder.span\n+        && is_format_args\n+        && *options != FormatOptions::default()\n+    {\n         span_lint_and_then(\n             cx,\n             UNUSED_FORMAT_SPECS,\n-            arg.span,\n+            placeholder_span,\n             \"format specifiers have no effect on `format_args!()`\",\n             |diag| {\n-                let mut suggest_format = |spec, span| {\n+                let mut suggest_format = |spec| {\n                     let message = format!(\"for the {spec} to apply consider using `format!()`\");\n \n-                    if let Some(mac_call) = root_macro_call(arg.param.value.span)\n+                    if let Some(mac_call) = root_macro_call(arg_span)\n                         && cx.tcx.is_diagnostic_item(sym::format_args_macro, mac_call.def_id)\n-                        && arg.span.eq_ctxt(mac_call.span)\n                     {\n                         diag.span_suggestion(\n                             cx.sess().source_map().span_until_char(mac_call.span, '!'),\n                             message,\n                             \"format\",\n                             Applicability::MaybeIncorrect,\n                         );\n-                    } else if let Some(span) = span {\n-                        diag.span_help(span, message);\n+                    } else {\n+                        diag.help(message);\n                     }\n                 };\n \n-                if !arg.format.width.is_implied() {\n-                    suggest_format(\"width\", arg.format.width.span());\n+                if options.width.is_some() {\n+                    suggest_format(\"width\");\n                 }\n \n-                if !arg.format.precision.is_implied() {\n-                    suggest_format(\"precision\", arg.format.precision.span());\n+                if options.precision.is_some() {\n+                    suggest_format(\"precision\");\n                 }\n \n-                diag.span_suggestion_verbose(\n-                    arg.format_span(),\n-                    \"if the current behavior is intentional, remove the format specifiers\",\n-                    \"\",\n-                    Applicability::MaybeIncorrect,\n-                );\n+                if let Some(format_span) = format_placeholder_format_span(placeholder) {\n+                    diag.span_suggestion_verbose(\n+                        format_span,\n+                        \"if the current behavior is intentional, remove the format specifiers\",\n+                        \"\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n             },\n         );\n     }\n }\n \n fn check_uninlined_args(\n     cx: &LateContext<'_>,\n-    args: &FormatArgsExpn<'_>,\n+    args: &rustc_ast::FormatArgs,\n     call_site: Span,\n     def_id: DefId,\n     ignore_mixed: bool,\n ) {\n-    if args.format_string.span.from_expansion() {\n+    if args.span.from_expansion() {\n         return;\n     }\n     if call_site.edition() < Edition2021 && (is_panic(cx, def_id) || is_assert_macro(cx, def_id)) {\n@@ -303,7 +316,13 @@ fn check_uninlined_args(\n     // we cannot remove any other arguments in the format string,\n     // because the index numbers might be wrong after inlining.\n     // Example of an un-inlinable format:  print!(\"{}{1}\", foo, 2)\n-    if !args.params().all(|p| check_one_arg(args, &p, &mut fixes, ignore_mixed)) || fixes.is_empty() {\n+    for (pos, usage) in format_arg_positions(args) {\n+        if !check_one_arg(args, pos, usage, &mut fixes, ignore_mixed) {\n+            return;\n+        }\n+    }\n+\n+    if fixes.is_empty() {\n         return;\n     }\n \n@@ -332,47 +351,40 @@ fn check_uninlined_args(\n }\n \n fn check_one_arg(\n-    args: &FormatArgsExpn<'_>,\n-    param: &FormatParam<'_>,\n+    args: &rustc_ast::FormatArgs,\n+    pos: &FormatArgPosition,\n+    usage: FormatParamUsage,\n     fixes: &mut Vec<(Span, String)>,\n     ignore_mixed: bool,\n ) -> bool {\n-    if matches!(param.kind, Implicit | Starred | Named(_) | Numbered)\n-        && let ExprKind::Path(QPath::Resolved(None, path)) = param.value.kind\n-        && let [segment] = path.segments\n+    let index = pos.index.unwrap();\n+    let arg = &args.arguments.all_args()[index];\n+\n+    if !matches!(arg.kind, FormatArgumentKind::Captured(_))\n+        && let rustc_ast::ExprKind::Path(None, path) = &arg.expr.kind\n+        && let [segment] = path.segments.as_slice()\n         && segment.args.is_none()\n-        && let Some(arg_span) = args.value_with_prev_comma_span(param.value.hir_id)\n+        && let Some(arg_span) = format_arg_removal_span(args, index)\n+        && let Some(pos_span) = pos.span\n     {\n-        let replacement = match param.usage {\n+        let replacement = match usage {\n             FormatParamUsage::Argument => segment.ident.name.to_string(),\n             FormatParamUsage::Width => format!(\"{}$\", segment.ident.name),\n             FormatParamUsage::Precision => format!(\".{}$\", segment.ident.name),\n         };\n-        fixes.push((param.span, replacement));\n+        fixes.push((pos_span, replacement));\n         fixes.push((arg_span, String::new()));\n         true  // successful inlining, continue checking\n     } else {\n         // Do not continue inlining (return false) in case\n         // * if we can't inline a numbered argument, e.g. `print!(\"{0} ...\", foo.bar, ...)`\n         // * if allow_mixed_uninlined_format_args is false and this arg hasn't been inlined already\n-        param.kind != Numbered && (!ignore_mixed || matches!(param.kind, NamedInline(_)))\n-    }\n-}\n-\n-fn outermost_expn_data(expn_data: ExpnData) -> ExpnData {\n-    if expn_data.call_site.from_expansion() {\n-        outermost_expn_data(expn_data.call_site.ctxt().outer_expn_data())\n-    } else {\n-        expn_data\n+        pos.kind != FormatArgPositionKind::Number\n+            && (!ignore_mixed || matches!(arg.kind, FormatArgumentKind::Captured(_)))\n     }\n }\n \n-fn check_format_in_format_args(\n-    cx: &LateContext<'_>,\n-    call_site: Span,\n-    name: Symbol,\n-    arg: &Expr<'_>,\n-) {\n+fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symbol, arg: &Expr<'_>) {\n     let expn_data = arg.span.ctxt().outer_expn_data();\n     if expn_data.call_site.from_expansion() {\n         return;\n@@ -443,9 +455,33 @@ fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Ex\n     }\n }\n \n-/// Returns true if `hir_id` is referred to by multiple format params\n-fn is_aliased(args: &FormatArgsExpn<'_>, hir_id: HirId) -> bool {\n-    args.params().filter(|param| param.value.hir_id == hir_id).at_most_one().is_err()\n+fn format_arg_positions(\n+    format_args: &rustc_ast::FormatArgs,\n+) -> impl Iterator<Item = (&FormatArgPosition, FormatParamUsage)> {\n+    format_args.template.iter().flat_map(|piece| match piece {\n+        FormatArgsPiece::Placeholder(placeholder) => {\n+            let mut positions = ArrayVec::<_, 3>::new();\n+\n+            positions.push((&placeholder.argument, FormatParamUsage::Argument));\n+            if let Some(FormatCount::Argument(position)) = &placeholder.format_options.width {\n+                positions.push((position, FormatParamUsage::Width));\n+            }\n+            if let Some(FormatCount::Argument(position)) = &placeholder.format_options.precision {\n+                positions.push((position, FormatParamUsage::Precision));\n+            }\n+\n+            positions\n+        },\n+        FormatArgsPiece::Literal(_) => ArrayVec::new(),\n+    })\n+}\n+\n+/// Returns true if the format argument at `index` is referred to by multiple format params\n+fn is_aliased(format_args: &rustc_ast::FormatArgs, index: usize) -> bool {\n+    format_arg_positions(format_args)\n+        .filter(|(position, _)| position.index == Ok(index))\n+        .at_most_one()\n+        .is_err()\n }\n \n fn count_needed_derefs<'tcx, I>(mut ty: Ty<'tcx>, mut iter: I) -> (usize, Ty<'tcx>)\n@@ -455,7 +491,11 @@ where\n     let mut n_total = 0;\n     let mut n_needed = 0;\n     loop {\n-        if let Some(Adjustment { kind: Adjust::Deref(overloaded_deref), target }) = iter.next() {\n+        if let Some(Adjustment {\n+            kind: Adjust::Deref(overloaded_deref),\n+            target,\n+        }) = iter.next()\n+        {\n             n_total += 1;\n             if overloaded_deref.is_some() {\n                 n_needed = n_total;"}, {"sha": "e3ddbfb5981f8fd1e1425b9cc85625caa5e36e91", "filename": "clippy_lints/src/format_impl.rs", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fformat_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fformat_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_impl.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,11 +1,13 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n-use clippy_utils::macros::{is_format_macro, root_macro_call_first_node, FormatArg, FormatArgsExpn};\n+use clippy_utils::macros::{find_format_arg_expr, find_format_args, is_format_macro, root_macro_call_first_node};\n use clippy_utils::{get_parent_as_impl, is_diag_trait_item, path_to_local, peel_ref_operators};\n use if_chain::if_chain;\n+use rustc_ast::{FormatArgsPiece, FormatTrait};\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, Impl, ImplItem, ImplItemKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n use rustc_span::{sym, symbol::kw, Symbol};\n \n declare_clippy_lint! {\n@@ -89,7 +91,7 @@ declare_clippy_lint! {\n }\n \n #[derive(Clone, Copy)]\n-struct FormatTrait {\n+struct FormatTraitNames {\n     /// e.g. `sym::Display`\n     name: Symbol,\n     /// `f` in `fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {}`\n@@ -99,7 +101,7 @@ struct FormatTrait {\n #[derive(Default)]\n pub struct FormatImpl {\n     // Whether we are inside Display or Debug trait impl - None for neither\n-    format_trait_impl: Option<FormatTrait>,\n+    format_trait_impl: Option<FormatTraitNames>,\n }\n \n impl FormatImpl {\n@@ -161,43 +163,57 @@ fn check_to_string_in_display(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     }\n }\n \n-fn check_self_in_format_args<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, impl_trait: FormatTrait) {\n+fn check_self_in_format_args<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, impl_trait: FormatTraitNames) {\n     // Check each arg in format calls - do we ever use Display on self (directly or via deref)?\n-    if_chain! {\n-        if let Some(outer_macro) = root_macro_call_first_node(cx, expr);\n-        if let macro_def_id = outer_macro.def_id;\n-        if let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, outer_macro.expn);\n-        if is_format_macro(cx, macro_def_id);\n-        then {\n-            for arg in format_args.args {\n-                if arg.format.r#trait != impl_trait.name {\n-                    continue;\n+    if let Some(outer_macro) = root_macro_call_first_node(cx, expr)\n+        && let macro_def_id = outer_macro.def_id\n+        && is_format_macro(cx, macro_def_id)\n+    {\n+        find_format_args(cx, expr, outer_macro.expn, |format_args| {\n+            for piece in &format_args.template {\n+                if let FormatArgsPiece::Placeholder(placeholder) = piece\n+                    && let trait_name = match placeholder.format_trait {\n+                        FormatTrait::Display => sym::Display,\n+                        FormatTrait::Debug => sym::Debug,\n+                        FormatTrait::LowerExp => sym!(LowerExp),\n+                        FormatTrait::UpperExp => sym!(UpperExp),\n+                        FormatTrait::Octal => sym!(Octal),\n+                        FormatTrait::Pointer => sym::Pointer,\n+                        FormatTrait::Binary => sym!(Binary),\n+                        FormatTrait::LowerHex => sym!(LowerHex),\n+                        FormatTrait::UpperHex => sym!(UpperHex),\n+                    }\n+                    && trait_name == impl_trait.name\n+                    && let Ok(index) = placeholder.argument.index\n+                    && let Some(arg) = format_args.arguments.all_args().get(index)\n+                    && let Ok(arg_expr) = find_format_arg_expr(expr, arg)\n+                {\n+                    check_format_arg_self(cx, expr.span, arg_expr, impl_trait);\n                 }\n-                check_format_arg_self(cx, expr, &arg, impl_trait);\n             }\n-        }\n+        });\n     }\n }\n \n-fn check_format_arg_self(cx: &LateContext<'_>, expr: &Expr<'_>, arg: &FormatArg<'_>, impl_trait: FormatTrait) {\n+fn check_format_arg_self(cx: &LateContext<'_>, span: Span, arg: &Expr<'_>, impl_trait: FormatTraitNames) {\n     // Handle multiple dereferencing of references e.g. &&self\n     // Handle dereference of &self -> self that is equivalent (i.e. via *self in fmt() impl)\n     // Since the argument to fmt is itself a reference: &self\n-    let reference = peel_ref_operators(cx, arg.param.value);\n+    let reference = peel_ref_operators(cx, arg);\n     let map = cx.tcx.hir();\n     // Is the reference self?\n     if path_to_local(reference).map(|x| map.name(x)) == Some(kw::SelfLower) {\n-        let FormatTrait { name, .. } = impl_trait;\n+        let FormatTraitNames { name, .. } = impl_trait;\n         span_lint(\n             cx,\n             RECURSIVE_FORMAT_IMPL,\n-            expr.span,\n+            span,\n             &format!(\"using `self` as `{name}` in `impl {name}` will cause infinite recursion\"),\n         );\n     }\n }\n \n-fn check_print_in_format_impl(cx: &LateContext<'_>, expr: &Expr<'_>, impl_trait: FormatTrait) {\n+fn check_print_in_format_impl(cx: &LateContext<'_>, expr: &Expr<'_>, impl_trait: FormatTraitNames) {\n     if_chain! {\n         if let Some(macro_call) = root_macro_call_first_node(cx, expr);\n         if let Some(name) = cx.tcx.get_diagnostic_name(macro_call.def_id);\n@@ -227,7 +243,7 @@ fn check_print_in_format_impl(cx: &LateContext<'_>, expr: &Expr<'_>, impl_trait:\n     }\n }\n \n-fn is_format_trait_impl(cx: &LateContext<'_>, impl_item: &ImplItem<'_>) -> Option<FormatTrait> {\n+fn is_format_trait_impl(cx: &LateContext<'_>, impl_item: &ImplItem<'_>) -> Option<FormatTraitNames> {\n     if_chain! {\n         if impl_item.ident.name == sym::fmt;\n         if let ImplItemKind::Fn(_, body_id) = impl_item.kind;\n@@ -241,7 +257,7 @@ fn is_format_trait_impl(cx: &LateContext<'_>, impl_item: &ImplItem<'_>) -> Optio\n                 .and_then(|param| param.pat.simple_ident())\n                 .map(|ident| ident.name);\n \n-            Some(FormatTrait {\n+            Some(FormatTraitNames {\n                 name,\n                 formatter_name,\n             })"}, {"sha": "d0ad26282642c491bd7f7827729d5aa4fa3240a1", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,7 +1,9 @@\n+use hir::FnSig;\n use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::DefIdSet;\n use rustc_hir::{self as hir, def::Res, QPath};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::{\n     lint::in_external_macro,\n@@ -27,7 +29,7 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>\n         let is_public = cx.effective_visibilities.is_exported(item.owner_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n-            check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n+            check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr, sig);\n         } else if is_public && !is_proc_macro(attrs) && !attrs.iter().any(|a| a.has_name(sym::no_mangle)) {\n             check_must_use_candidate(\n                 cx,\n@@ -49,7 +51,7 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n         let attr = cx.tcx.get_attr(item.owner_id, sym::must_use);\n         if let Some(attr) = attr {\n-            check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n+            check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr, sig);\n         } else if is_public && !is_proc_macro(attrs) && trait_ref_of_method(cx, item.owner_id.def_id).is_none() {\n             check_must_use_candidate(\n                 cx,\n@@ -72,7 +74,7 @@ pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Tr\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n         let attr = cx.tcx.get_attr(item.owner_id, sym::must_use);\n         if let Some(attr) = attr {\n-            check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr);\n+            check_needless_must_use(cx, sig.decl, item.owner_id, item.span, fn_header_span, attr, sig);\n         } else if let hir::TraitFn::Provided(eid) = *eid {\n             let body = cx.tcx.hir().body(eid);\n             if attr.is_none() && is_public && !is_proc_macro(attrs) {\n@@ -97,6 +99,7 @@ fn check_needless_must_use(\n     item_span: Span,\n     fn_header_span: Span,\n     attr: &Attribute,\n+    sig: &FnSig<'_>,\n ) {\n     if in_external_macro(cx.sess(), item_span) {\n         return;\n@@ -112,6 +115,15 @@ fn check_needless_must_use(\n             },\n         );\n     } else if attr.value_str().is_none() && is_must_use_ty(cx, return_ty(cx, item_id)) {\n+        // Ignore async functions unless Future::Output type is a must_use type\n+        if sig.header.is_async() {\n+            let infcx = cx.tcx.infer_ctxt().build();\n+            if let Some(future_ty) = infcx.get_impl_future_output_ty(return_ty(cx, item_id))\n+\t\t\t&& !is_must_use_ty(cx, future_ty) {\n+\t\t\t\treturn;\n+\t\t\t}\n+        }\n+\n         span_lint_and_help(\n             cx,\n             DOUBLE_MUST_USE,"}, {"sha": "a7ec57e28505beeeea10087d118cb2fd0113aebe", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,8 +1,8 @@\n //! lint when items are used after statements\n \n-use clippy_utils::diagnostics::span_lint;\n-use rustc_ast::ast::{Block, ItemKind, StmtKind};\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use clippy_utils::diagnostics::span_lint_hir;\n+use rustc_hir::{Block, ItemKind, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -52,33 +52,34 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ItemsAfterStatements => [ITEMS_AFTER_STATEMENTS]);\n \n-impl EarlyLintPass for ItemsAfterStatements {\n-    fn check_block(&mut self, cx: &EarlyContext<'_>, item: &Block) {\n-        if in_external_macro(cx.sess(), item.span) {\n+impl LateLintPass<'_> for ItemsAfterStatements {\n+    fn check_block(&mut self, cx: &LateContext<'_>, block: &Block<'_>) {\n+        if in_external_macro(cx.sess(), block.span) {\n             return;\n         }\n \n-        // skip initial items and trailing semicolons\n-        let stmts = item\n+        // skip initial items\n+        let stmts = block\n             .stmts\n             .iter()\n-            .map(|stmt| &stmt.kind)\n-            .skip_while(|s| matches!(**s, StmtKind::Item(..) | StmtKind::Empty));\n+            .skip_while(|stmt| matches!(stmt.kind, StmtKind::Item(..)));\n \n         // lint on all further items\n         for stmt in stmts {\n-            if let StmtKind::Item(ref it) = *stmt {\n-                if in_external_macro(cx.sess(), it.span) {\n+            if let StmtKind::Item(item_id) = stmt.kind {\n+                let item = cx.tcx.hir().item(item_id);\n+                if in_external_macro(cx.sess(), item.span) || !item.span.eq_ctxt(block.span) {\n                     return;\n                 }\n-                if let ItemKind::MacroDef(..) = it.kind {\n+                if let ItemKind::Macro(..) = item.kind {\n                     // do not lint `macro_rules`, but continue processing further statements\n                     continue;\n                 }\n-                span_lint(\n+                span_lint_hir(\n                     cx,\n                     ITEMS_AFTER_STATEMENTS,\n-                    it.span,\n+                    item.hir_id(),\n+                    item.span,\n                     \"adding items after statements is confusing, since items exist from the \\\n                      start of the scope\",\n                 );"}, {"sha": "1b0544813718abe08f58d6abf48f3c44012f6944", "filename": "clippy_lints/src/large_futures.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Flarge_futures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Flarge_futures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_futures.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,87 @@\n+use clippy_utils::source::snippet;\n+use clippy_utils::{diagnostics::span_lint_and_sugg, ty::implements_trait};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, LangItem, MatchSource, QPath};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_target::abi::Size;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// It checks for the size of a `Future` created by `async fn` or `async {}`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Due to the current [unideal implemention](https://github.com/rust-lang/rust/issues/69826) of `Generator`,\n+    /// large size of a `Future` may cause stack overflows.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// async fn wait(f: impl std::future::Future<Output = ()>) {}\n+    ///\n+    /// async fn big_fut(arg: [u8; 1024]) {}\n+    ///\n+    /// pub async fn test() {\n+    ///     let fut = big_fut([0u8; 1024]);\n+    ///     wait(fut).await;\n+    /// }\n+    /// ```\n+    ///\n+    /// `Box::pin` the big future instead.\n+    ///\n+    /// ```rust\n+    /// async fn wait(f: impl std::future::Future<Output = ()>) {}\n+    ///\n+    /// async fn big_fut(arg: [u8; 1024]) {}\n+    ///\n+    /// pub async fn test() {\n+    ///     let fut = Box::pin(big_fut([0u8; 1024]));\n+    ///     wait(fut).await;\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.68.0\"]\n+    pub LARGE_FUTURES,\n+    pedantic,\n+    \"large future may lead to unexpected stack overflows\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct LargeFuture {\n+    future_size_threshold: u64,\n+}\n+\n+impl LargeFuture {\n+    pub fn new(future_size_threshold: u64) -> Self {\n+        Self { future_size_threshold }\n+    }\n+}\n+\n+impl_lint_pass!(LargeFuture => [LARGE_FUTURES]);\n+\n+impl<'tcx> LateLintPass<'tcx> for LargeFuture {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if matches!(expr.span.ctxt().outer_expn_data().kind, rustc_span::ExpnKind::Macro(..)) {\n+            return;\n+        }\n+        if let ExprKind::Match(expr, _, MatchSource::AwaitDesugar) = expr.kind {\n+            if let ExprKind::Call(func, [expr, ..]) = expr.kind\n+                && let ExprKind::Path(QPath::LangItem(LangItem::IntoFutureIntoFuture, ..)) = func.kind\n+                && let ty = cx.typeck_results().expr_ty(expr)\n+                && let Some(future_trait_def_id) = cx.tcx.lang_items().future_trait()\n+                && implements_trait(cx, ty, future_trait_def_id, &[])\n+                && let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty))\n+                && let size = layout.layout.size()\n+                && size >= Size::from_bytes(self.future_size_threshold)\n+            {\n+                span_lint_and_sugg(\n+                    cx,\n+                    LARGE_FUTURES,\n+                    expr.span,\n+                    &format!(\"large future with a size of {} bytes\", size.bytes()),\n+                    \"consider `Box::pin` on it\",\n+                    format!(\"Box::pin({})\", snippet(cx, expr.span, \"..\")),\n+                    Applicability::Unspecified,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "b0ec14855e71b8d11c113e67d880cb7b8feb70ab", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,7 +1,6 @@\n #![feature(array_windows)]\n #![feature(binary_heap_into_iter_sorted)]\n #![feature(box_patterns)]\n-#![feature(drain_filter)]\n #![feature(if_let_guard)]\n #![feature(iter_intersperse)]\n #![feature(let_chains)]\n@@ -162,13 +161,15 @@ mod items_after_statements;\n mod iter_not_returning_iterator;\n mod large_const_arrays;\n mod large_enum_variant;\n+mod large_futures;\n mod large_include_file;\n mod large_stack_arrays;\n mod len_zero;\n mod let_if_seq;\n mod let_underscore;\n mod let_with_type_underscore;\n mod lifetimes;\n+mod lines_filter_map_ok;\n mod literal_representation;\n mod loops;\n mod macro_use;\n@@ -183,6 +184,7 @@ mod manual_main_separator_str;\n mod manual_non_exhaustive;\n mod manual_rem_euclid;\n mod manual_retain;\n+mod manual_slice_size_calculation;\n mod manual_string_new;\n mod manual_strip;\n mod map_unit_fn;\n@@ -281,13 +283,15 @@ mod slow_vector_initialization;\n mod std_instead_of_core;\n mod strings;\n mod strlen_on_c_strings;\n+mod suspicious_doc_comments;\n mod suspicious_operation_groupings;\n mod suspicious_trait_impl;\n mod suspicious_xor_used_as_pow;\n mod swap;\n mod swap_ptr_to_ref;\n mod tabs_in_doc_comments;\n mod temporary_assignment;\n+mod tests_outside_test_module;\n mod to_digit_is_some;\n mod trailing_empty_array;\n mod trait_bounds;\n@@ -299,6 +303,7 @@ mod uninit_vec;\n mod unit_return_expecting_ord;\n mod unit_types;\n mod unnamed_address;\n+mod unnecessary_box_returns;\n mod unnecessary_owned_empty_strings;\n mod unnecessary_self_imports;\n mod unnecessary_struct_initialization;\n@@ -344,13 +349,17 @@ pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore, sess: &Se\n }\n \n #[doc(hidden)]\n-pub fn read_conf(sess: &Session, path: &io::Result<Option<PathBuf>>) -> Conf {\n+pub fn read_conf(sess: &Session, path: &io::Result<(Option<PathBuf>, Vec<String>)>) -> Conf {\n+    if let Ok((_, warnings)) = path {\n+        for warning in warnings {\n+            sess.warn(warning);\n+        }\n+    }\n     let file_name = match path {\n-        Ok(Some(path)) => path,\n-        Ok(None) => return Conf::default(),\n+        Ok((Some(path), _)) => path,\n+        Ok((None, _)) => return Conf::default(),\n         Err(error) => {\n-            sess.struct_err(format!(\"error finding Clippy's configuration file: {error}\"))\n-                .emit();\n+            sess.err(format!(\"error finding Clippy's configuration file: {error}\"));\n             return Conf::default();\n         },\n     };\n@@ -746,7 +755,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| Box::new(unused_unit::UnusedUnit));\n     store.register_late_pass(|_| Box::new(returns::Return));\n     store.register_early_pass(|| Box::new(collapsible_if::CollapsibleIf));\n-    store.register_early_pass(|| Box::new(items_after_statements::ItemsAfterStatements));\n+    store.register_late_pass(|_| Box::new(items_after_statements::ItemsAfterStatements));\n     store.register_early_pass(|| Box::new(precedence::Precedence));\n     store.register_late_pass(|_| Box::new(needless_parens_on_range_literals::NeedlessParensOnRangeLiterals));\n     store.register_early_pass(|| Box::new(needless_continue::NeedlessContinue));\n@@ -808,6 +817,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move |_| Box::new(dereference::Dereferencing::new(msrv())));\n     store.register_late_pass(|_| Box::new(option_if_let_else::OptionIfLetElse));\n     store.register_late_pass(|_| Box::new(future_not_send::FutureNotSend));\n+    let future_size_threshold = conf.future_size_threshold;\n+    store.register_late_pass(move |_| Box::new(large_futures::LargeFuture::new(future_size_threshold)));\n     store.register_late_pass(|_| Box::new(if_let_mutex::IfLetMutex));\n     store.register_late_pass(|_| Box::new(if_not_else::IfNotElse));\n     store.register_late_pass(|_| Box::new(equatable_if_let::PatternEquality));\n@@ -934,11 +945,20 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(no_mangle_with_rust_abi::NoMangleWithRustAbi));\n     store.register_late_pass(|_| Box::new(collection_is_never_read::CollectionIsNeverRead));\n     store.register_late_pass(|_| Box::new(missing_assert_message::MissingAssertMessage));\n-    store.register_early_pass(|| Box::new(redundant_async_block::RedundantAsyncBlock));\n+    store.register_late_pass(|_| Box::new(redundant_async_block::RedundantAsyncBlock));\n     store.register_late_pass(|_| Box::new(let_with_type_underscore::UnderscoreTyped));\n     store.register_late_pass(|_| Box::new(allow_attributes::AllowAttribute));\n     store.register_late_pass(move |_| Box::new(manual_main_separator_str::ManualMainSeparatorStr::new(msrv())));\n     store.register_late_pass(|_| Box::new(unnecessary_struct_initialization::UnnecessaryStruct));\n+    store.register_late_pass(move |_| {\n+        Box::new(unnecessary_box_returns::UnnecessaryBoxReturns::new(\n+            avoid_breaking_exported_api,\n+        ))\n+    });\n+    store.register_late_pass(|_| Box::new(lines_filter_map_ok::LinesFilterMapOk));\n+    store.register_late_pass(|_| Box::new(tests_outside_test_module::TestsOutsideTestModule));\n+    store.register_late_pass(|_| Box::new(manual_slice_size_calculation::ManualSliceSizeCalculation));\n+    store.register_early_pass(|| Box::new(suspicious_doc_comments::SuspiciousDocComments));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "b0f9276475d3ee96fc491a2bc3e8aed25a752615", "filename": "clippy_lints/src/lines_filter_map_ok.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Flines_filter_map_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Flines_filter_map_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flines_filter_map_ok.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,100 @@\n+use clippy_utils::{\n+    diagnostics::span_lint_and_then, is_diag_item_method, is_trait_method, match_def_path, path_to_local_id, paths,\n+    ty::match_type,\n+};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Body, Closure, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detect uses of `lines.filter_map(Result::ok)` or `lines.flat_map(Result::ok)`\n+    /// when `lines` has type `std::io::Lines`.\n+    ///\n+    /// ### Why is this bad?\n+    /// `Lines` instances might produce a never-ending stream of `Err`, in which case\n+    /// `filter_map(Result::ok)` will enter an infinite loop while waiting for an\n+    /// `Ok` variant. Calling `next()` once is sufficient to enter the infinite loop,\n+    /// even in the absence of explicit loops in the user code.\n+    ///\n+    /// This situation can arise when working with user-provided paths. On some platforms,\n+    /// `std::fs::File::open(path)` might return `Ok(fs)` even when `path` is a directory,\n+    /// but any later attempt to read from `fs` will return an error.\n+    ///\n+    /// ### Known problems\n+    /// This lint suggests replacing `filter_map()` or `flat_map()` applied to a `Lines`\n+    /// instance in all cases. There two cases where the suggestion might not be\n+    /// appropriate or necessary:\n+    ///\n+    /// - If the `Lines` instance can never produce any error, or if an error is produced\n+    ///   only once just before terminating the iterator, using `map_while()` is not\n+    ///   necessary but will not do any harm.\n+    /// - If the `Lines` instance can produce intermittent errors then recover and produce\n+    ///   successful results, using `map_while()` would stop at the first error.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::{fs::File, io::{self, BufRead, BufReader}};\n+    /// # let _ = || -> io::Result<()> {\n+    /// let mut lines = BufReader::new(File::open(\"some-path\")?).lines().filter_map(Result::ok);\n+    /// // If \"some-path\" points to a directory, the next statement never terminates:\n+    /// let first_line: Option<String> = lines.next();\n+    /// # Ok(()) };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::{fs::File, io::{self, BufRead, BufReader}};\n+    /// # let _ = || -> io::Result<()> {\n+    /// let mut lines = BufReader::new(File::open(\"some-path\")?).lines().map_while(Result::ok);\n+    /// let first_line: Option<String> = lines.next();\n+    /// # Ok(()) };\n+    /// ```\n+    #[clippy::version = \"1.70.0\"]\n+    pub LINES_FILTER_MAP_OK,\n+    suspicious,\n+    \"filtering `std::io::Lines` with `filter_map()` or `flat_map()` might cause an infinite loop\"\n+}\n+declare_lint_pass!(LinesFilterMapOk => [LINES_FILTER_MAP_OK]);\n+\n+impl LateLintPass<'_> for LinesFilterMapOk {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        if let ExprKind::MethodCall(fm_method, fm_receiver, [fm_arg], fm_span) = expr.kind &&\n+            is_trait_method(cx, expr, sym::Iterator) &&\n+            (fm_method.ident.as_str() == \"filter_map\" || fm_method.ident.as_str() == \"flat_map\") &&\n+            match_type(cx, cx.typeck_results().expr_ty_adjusted(fm_receiver), &paths::STD_IO_LINES)\n+        {\n+            let lint = match &fm_arg.kind {\n+                // Detect `Result::ok`\n+                ExprKind::Path(qpath) =>\n+                    cx.qpath_res(qpath, fm_arg.hir_id).opt_def_id().map(|did|\n+                        match_def_path(cx, did, &paths::CORE_RESULT_OK_METHOD)).unwrap_or_default(),\n+                // Detect `|x| x.ok()`\n+                ExprKind::Closure(Closure { body, .. }) =>\n+                    if let Body { params: [param], value, .. } = cx.tcx.hir().body(*body) &&\n+                        let ExprKind::MethodCall(method, receiver, [], _) = value.kind &&\n+                        path_to_local_id(receiver, param.pat.hir_id) &&\n+                        let Some(method_did) = cx.typeck_results().type_dependent_def_id(value.hir_id)\n+                    {\n+                        is_diag_item_method(cx, method_did, sym::Result) && method.ident.as_str() == \"ok\"\n+                    } else {\n+                        false\n+                    }\n+                _ => false,\n+            };\n+            if lint {\n+                span_lint_and_then(cx,\n+                    LINES_FILTER_MAP_OK,\n+                    fm_span,\n+                    &format!(\"`{}()` will run forever if the iterator repeatedly produces an `Err`\", fm_method.ident),\n+                    |diag| {\n+                        diag.span_note(\n+                            fm_receiver.span,\n+                            \"this expression returning a `std::io::Lines` may produce an infinite number of `Err` in case of a read error\");\n+                        diag.span_suggestion(fm_span, \"replace with\", \"map_while(Result::ok)\", Applicability::MaybeIncorrect);\n+                    });\n+                }\n+        }\n+    }\n+}"}, {"sha": "92ee79453a3b8698ada615e20561e8a6e6464c7b", "filename": "clippy_lints/src/manual_slice_size_calculation.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fmanual_slice_size_calculation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fmanual_slice_size_calculation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_slice_size_calculation.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,93 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::{expr_or_init, in_constant};\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// When `a` is `&[T]`, detect `a.len() * size_of::<T>()` and suggest `size_of_val(a)`\n+    /// instead.\n+    ///\n+    /// ### Why is this better?\n+    /// * Shorter to write\n+    /// * Removes the need for the human and the compiler to worry about overflow in the\n+    ///   multiplication\n+    /// * Potentially faster at runtime as rust emits special no-wrapping flags when it\n+    ///   calculates the byte length\n+    /// * Less turbofishing\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let data : &[i32] = &[1, 2, 3];\n+    /// let newlen = data.len() * std::mem::size_of::<i32>();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # let data : &[i32] = &[1, 2, 3];\n+    /// let newlen = std::mem::size_of_val(data);\n+    /// ```\n+    #[clippy::version = \"1.70.0\"]\n+    pub MANUAL_SLICE_SIZE_CALCULATION,\n+    complexity,\n+    \"manual slice size calculation\"\n+}\n+declare_lint_pass!(ManualSliceSizeCalculation => [MANUAL_SLICE_SIZE_CALCULATION]);\n+\n+impl<'tcx> LateLintPass<'tcx> for ManualSliceSizeCalculation {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        // Does not apply inside const because size_of_value is not cost in stable.\n+        if !in_constant(cx, expr.hir_id)\n+            && let ExprKind::Binary(ref op, left, right) = expr.kind\n+            && BinOpKind::Mul == op.node\n+            && let Some(_receiver) = simplify(cx, left, right)\n+        {\n+            span_lint_and_help(\n+                cx,\n+                MANUAL_SLICE_SIZE_CALCULATION,\n+                expr.span,\n+                \"manual slice size calculation\",\n+                None,\n+                \"consider using std::mem::size_of_value instead\");\n+        }\n+    }\n+}\n+\n+fn simplify<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr1: &'tcx Expr<'tcx>,\n+    expr2: &'tcx Expr<'tcx>,\n+) -> Option<&'tcx Expr<'tcx>> {\n+    let expr1 = expr_or_init(cx, expr1);\n+    let expr2 = expr_or_init(cx, expr2);\n+\n+    simplify_half(cx, expr1, expr2).or_else(|| simplify_half(cx, expr2, expr1))\n+}\n+\n+fn simplify_half<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr1: &'tcx Expr<'tcx>,\n+    expr2: &'tcx Expr<'tcx>,\n+) -> Option<&'tcx Expr<'tcx>> {\n+    if\n+        // expr1 is `[T1].len()`?\n+        let ExprKind::MethodCall(method_path, receiver, _, _) = expr1.kind\n+        && method_path.ident.name == sym::len\n+        && let receiver_ty = cx.typeck_results().expr_ty(receiver)\n+        && let ty::Slice(ty1) = receiver_ty.peel_refs().kind()\n+        // expr2 is `size_of::<T2>()`?\n+        && let ExprKind::Call(func, _) = expr2.kind\n+        && let ExprKind::Path(ref func_qpath) = func.kind\n+        && let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id()\n+        && cx.tcx.is_diagnostic_item(sym::mem_size_of, def_id)\n+        && let Some(ty2) = cx.typeck_results().node_substs(func.hir_id).types().next()\n+        // T1 == T2?\n+        && *ty1 == ty2\n+    {\n+        Some(receiver)\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "8a921d4af1655a42dc14ba2d7685745b3e4e62a7", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 28, "deletions": 43, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,12 +1,13 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::msrvs::{self, Msrv};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n+use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_non_aggregate_primitive_type;\n-use clippy_utils::{is_default_equivalent, is_res_lang_ctor, path_res};\n+use clippy_utils::{is_default_equivalent, is_res_lang_ctor, path_res, peel_ref_operators};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, QPath};\n+use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -101,40 +102,26 @@ declare_clippy_lint! {\n impl_lint_pass!(MemReplace =>\n     [MEM_REPLACE_OPTION_WITH_NONE, MEM_REPLACE_WITH_UNINIT, MEM_REPLACE_WITH_DEFAULT]);\n \n-fn check_replace_option_with_none(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n-    // Check that second argument is `Option::None`\n-    if is_res_lang_ctor(cx, path_res(cx, src), OptionNone) {\n-        // Since this is a late pass (already type-checked),\n-        // and we already know that the second argument is an\n-        // `Option`, we do not need to check the first\n-        // argument's type. All that's left is to get\n-        // replacee's path.\n-        let replaced_path = match dest.kind {\n-            ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, replaced) => {\n-                if let ExprKind::Path(QPath::Resolved(None, replaced_path)) = replaced.kind {\n-                    replaced_path\n-                } else {\n-                    return;\n-                }\n-            },\n-            ExprKind::Path(QPath::Resolved(None, replaced_path)) => replaced_path,\n-            _ => return,\n-        };\n-\n-        let mut applicability = Applicability::MachineApplicable;\n-        span_lint_and_sugg(\n-            cx,\n-            MEM_REPLACE_OPTION_WITH_NONE,\n-            expr_span,\n-            \"replacing an `Option` with `None`\",\n-            \"consider `Option::take()` instead\",\n-            format!(\n-                \"{}.take()\",\n-                snippet_with_applicability(cx, replaced_path.span, \"\", &mut applicability)\n-            ),\n-            applicability,\n-        );\n-    }\n+fn check_replace_option_with_none(cx: &LateContext<'_>, dest: &Expr<'_>, expr_span: Span) {\n+    // Since this is a late pass (already type-checked),\n+    // and we already know that the second argument is an\n+    // `Option`, we do not need to check the first\n+    // argument's type. All that's left is to get\n+    // the replacee's expr after peeling off the `&mut`\n+    let sugg_expr = peel_ref_operators(cx, dest);\n+    let mut applicability = Applicability::MachineApplicable;\n+    span_lint_and_sugg(\n+        cx,\n+        MEM_REPLACE_OPTION_WITH_NONE,\n+        expr_span,\n+        \"replacing an `Option` with `None`\",\n+        \"consider `Option::take()` instead\",\n+        format!(\n+            \"{}.take()\",\n+            Sugg::hir_with_context(cx, sugg_expr, expr_span.ctxt(), \"\", &mut applicability).maybe_par()\n+        ),\n+        applicability,\n+    );\n }\n \n fn check_replace_with_uninit(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n@@ -200,10 +187,6 @@ fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<\n     if is_non_aggregate_primitive_type(expr_type) {\n         return;\n     }\n-    // disable lint for Option since it is covered in another lint\n-    if is_res_lang_ctor(cx, path_res(cx, src), OptionNone) {\n-        return;\n-    }\n     if is_default_equivalent(cx, src) && !in_external_macro(cx.tcx.sess, expr_span) {\n         span_lint_and_then(\n             cx,\n@@ -246,11 +229,13 @@ impl<'tcx> LateLintPass<'tcx> for MemReplace {\n             if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if cx.tcx.is_diagnostic_item(sym::mem_replace, def_id);\n             then {\n-                check_replace_option_with_none(cx, src, dest, expr.span);\n-                check_replace_with_uninit(cx, src, dest, expr.span);\n-                if self.msrv.meets(msrvs::MEM_TAKE) {\n+                // Check that second argument is `Option::None`\n+                if is_res_lang_ctor(cx, path_res(cx, src), OptionNone) {\n+                    check_replace_option_with_none(cx, dest, expr.span);\n+                } else if self.msrv.meets(msrvs::MEM_TAKE) {\n                     check_replace_with_default(cx, src, dest, expr.span);\n                 }\n+                check_replace_with_uninit(cx, src, dest, expr.span);\n             }\n         }\n     }"}, {"sha": "67ad58d5a8c646b2d23bfcfdd6f97caf4c0aa226", "filename": "clippy_lints/src/methods/clear_with_drain.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fmethods%2Fclear_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fmethods%2Fclear_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclear_with_drain.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,53 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_range_full;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::{Expr, ExprKind, LangItem, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n+\n+use super::CLEAR_WITH_DRAIN;\n+\n+// Add `String` here when it is added to diagnostic items\n+const ACCEPTABLE_TYPES_WITH_ARG: [rustc_span::Symbol; 2] = [sym::Vec, sym::VecDeque];\n+\n+const ACCEPTABLE_TYPES_WITHOUT_ARG: [rustc_span::Symbol; 3] = [sym::BinaryHeap, sym::HashMap, sym::HashSet];\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span, arg: Option<&Expr<'_>>) {\n+    if let Some(arg) = arg {\n+        if match_acceptable_type(cx, recv, &ACCEPTABLE_TYPES_WITH_ARG)\n+            && let ExprKind::Path(QPath::Resolved(None, container_path)) = recv.kind\n+            && is_range_full(cx, arg, Some(container_path))\n+        {\n+            suggest(cx, expr, recv, span);\n+        }\n+    } else if match_acceptable_type(cx, recv, &ACCEPTABLE_TYPES_WITHOUT_ARG) {\n+        suggest(cx, expr, recv, span);\n+    }\n+}\n+\n+fn match_acceptable_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>, types: &[rustc_span::Symbol]) -> bool {\n+    let expr_ty = cx.typeck_results().expr_ty(expr).peel_refs();\n+    types.iter().any(|&ty| is_type_diagnostic_item(cx, expr_ty, ty))\n+    // String type is a lang item but not a diagnostic item for now so we need a separate check\n+        || is_type_lang_item(cx, expr_ty, LangItem::String)\n+}\n+\n+fn suggest(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span) {\n+    if let Some(adt) = cx.typeck_results().expr_ty(recv).ty_adt_def()\n+    // Use `opt_item_name` while `String` is not a diagnostic item\n+        && let Some(ty_name) = cx.tcx.opt_item_name(adt.did())\n+    {\n+        span_lint_and_sugg(\n+            cx,\n+            CLEAR_WITH_DRAIN,\n+            span.with_hi(expr.span.hi()),\n+            &format!(\"`drain` used to clear a `{ty_name}`\"),\n+            \"try\",\n+            \"clear()\".to_string(),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}"}, {"sha": "92d21bb893262af134609248e159380ca1d88efe", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn};\n+use clippy_utils::macros::{find_format_args, format_args_inputs_span, root_macro_call_first_node};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use rustc_errors::Applicability;\n@@ -136,18 +136,19 @@ pub(super) fn check<'tcx>(\n         if !cx.tcx.is_diagnostic_item(sym::format_macro, macro_call.def_id) {\n             return;\n         }\n-        let Some(format_args) = FormatArgsExpn::find_nested(cx, arg_root, macro_call.expn) else { return };\n-        let span = format_args.inputs_span();\n-        let sugg = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n-        span_lint_and_sugg(\n-            cx,\n-            EXPECT_FUN_CALL,\n-            span_replace_word,\n-            &format!(\"use of `{name}` followed by a function call\"),\n-            \"try this\",\n-            format!(\"unwrap_or_else({closure_args} panic!({sugg}))\"),\n-            applicability,\n-        );\n+        find_format_args(cx, arg_root, macro_call.expn, |format_args| {\n+            let span = format_args_inputs_span(format_args);\n+            let sugg = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n+            span_lint_and_sugg(\n+                cx,\n+                EXPECT_FUN_CALL,\n+                span_replace_word,\n+                &format!(\"use of `{name}` followed by a function call\"),\n+                \"try this\",\n+                format!(\"unwrap_or_else({closure_args} panic!({sugg}))\"),\n+                applicability,\n+            );\n+        });\n         return;\n     }\n "}, {"sha": "f6772c5c6b369c03ea12cff1c39647f9577794e6", "filename": "clippy_lints/src/methods/iter_with_drain.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,7 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher::Range;\n-use clippy_utils::is_integer_const;\n-use rustc_ast::ast::RangeLimits;\n+use clippy_utils::is_range_full;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, QPath};\n use rustc_lint::LateContext;\n@@ -15,8 +13,8 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span\n         && let Some(adt) = cx.typeck_results().expr_ty(recv).ty_adt_def()\n         && let Some(ty_name) = cx.tcx.get_diagnostic_name(adt.did())\n         && matches!(ty_name, sym::Vec | sym::VecDeque)\n-        && let Some(range) = Range::hir(arg)\n-        && is_full_range(cx, recv, range)\n+        && let ExprKind::Path(QPath::Resolved(None, container_path)) = recv.kind\n+        && is_range_full(cx, arg, Some(container_path))\n     {\n         span_lint_and_sugg(\n             cx,\n@@ -29,19 +27,3 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span\n         );\n     };\n }\n-\n-fn is_full_range(cx: &LateContext<'_>, container: &Expr<'_>, range: Range<'_>) -> bool {\n-    range.start.map_or(true, |e| is_integer_const(cx, e, 0))\n-        && range.end.map_or(true, |e| {\n-            if range.limits == RangeLimits::HalfOpen\n-                && let ExprKind::Path(QPath::Resolved(None, container_path)) = container.kind\n-                && let ExprKind::MethodCall(name, self_arg, [], _) = e.kind\n-                && name.ident.name == sym::len\n-                && let ExprKind::Path(QPath::Resolved(None, path)) = self_arg.kind\n-            {\n-                container_path.res == path.res\n-            } else {\n-                false\n-            }\n-        })\n-}"}, {"sha": "64bf55ba24c9814378c902ec1a98eeb529980bc1", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -9,6 +9,7 @@ mod chars_last_cmp;\n mod chars_last_cmp_with_unwrap;\n mod chars_next_cmp;\n mod chars_next_cmp_with_unwrap;\n+mod clear_with_drain;\n mod clone_on_copy;\n mod clone_on_ref_ptr;\n mod cloned_instead_of_copied;\n@@ -110,7 +111,7 @@ use clippy_utils::ty::{contains_ty_adt_constructor_opaque, implements_trait, is_\n use clippy_utils::{contains_return, is_bool, is_trait_method, iter_input_pats, return_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n-use rustc_hir::{Expr, ExprKind, TraitItem, TraitItemKind};\n+use rustc_hir::{Expr, ExprKind, Node, Stmt, StmtKind, TraitItem, TraitItemKind};\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -3190,6 +3191,31 @@ declare_clippy_lint! {\n     \"single command line argument that looks like it should be multiple arguments\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usage of `.drain(..)` for the sole purpose of clearing a container.\n+    ///\n+    /// ### Why is this bad?\n+    /// This creates an unnecessary iterator that is dropped immediately.\n+    ///\n+    /// Calling `.clear()` also makes the intent clearer.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut v = vec![1, 2, 3];\n+    /// v.drain(..);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut v = vec![1, 2, 3];\n+    /// v.clear();\n+    /// ```\n+    #[clippy::version = \"1.69.0\"]\n+    pub CLEAR_WITH_DRAIN,\n+    nursery,\n+    \"calling `drain` in order to `clear` a container\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Msrv,\n@@ -3318,6 +3344,7 @@ impl_lint_pass!(Methods => [\n     SEEK_TO_START_INSTEAD_OF_REWIND,\n     NEEDLESS_COLLECT,\n     SUSPICIOUS_COMMAND_ARG_SPACE,\n+    CLEAR_WITH_DRAIN,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -3562,8 +3589,15 @@ impl Methods {\n                     Some((\"bytes\", recv2, [], _, _)) => bytes_count_to_len::check(cx, expr, recv, recv2),\n                     _ => {},\n                 },\n-                (\"drain\", [arg]) => {\n-                    iter_with_drain::check(cx, expr, recv, span, arg);\n+                (\"drain\", ..) => {\n+                    if let Node::Stmt(Stmt { hir_id: _, kind, .. }) = cx.tcx.hir().get_parent(expr.hir_id)\n+                        && matches!(kind, StmtKind::Semi(_))\n+                        && args.len() <= 1\n+                    {\n+                        clear_with_drain::check(cx, expr, recv, span, args.first());\n+                    } else if let [arg] = args {\n+                        iter_with_drain::check(cx, expr, recv, span, arg);\n+                    }\n                 },\n                 (\"ends_with\", [arg]) => {\n                     if let ExprKind::MethodCall(.., span) = expr.kind {"}, {"sha": "f1831a30461afdfba9ab490702efada105d08388", "filename": "clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -41,6 +41,7 @@ declare_clippy_lint! {\n     /// can't be const as it calls a non-const function. Making `a` const and running Clippy again,\n     /// will suggest to make `b` const, too.\n     ///\n+    /// If you are marking a public function with `const`, removing it again will break API compatibility.\n     /// ### Example\n     /// ```rust\n     /// # struct Foo {"}, {"sha": "e5713735672dadd5cea82a5e3f48145afd1ae134", "filename": "clippy_lints/src/operators/arithmetic_side_effects.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Farithmetic_side_effects.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -154,10 +154,18 @@ impl ArithmeticSideEffects {\n                 Self::literal_integer(cx, actual_rhs),\n             ) {\n                 (None, None) => false,\n-                (None, Some(n)) | (Some(n), None) => match (&op.node, n) {\n+                (None, Some(n)) => match (&op.node, n) {\n                     // Division and module are always valid if applied to non-zero integers\n                     (hir::BinOpKind::Div | hir::BinOpKind::Rem, local_n) if local_n != 0 => true,\n-                    // Addition or subtracting zeros is always a no-op\n+                    // Adding or subtracting zeros is always a no-op\n+                    (hir::BinOpKind::Add | hir::BinOpKind::Sub, 0)\n+                    // Multiplication by 1 or 0 will never overflow\n+                    | (hir::BinOpKind::Mul, 0 | 1)\n+                    => true,\n+                    _ => false,\n+                },\n+                (Some(n), None) => match (&op.node, n) {\n+                    // Adding or subtracting zeros is always a no-op\n                     (hir::BinOpKind::Add | hir::BinOpKind::Sub, 0)\n                     // Multiplication by 1 or 0 will never overflow\n                     | (hir::BinOpKind::Mul, 0 | 1)"}, {"sha": "a0f831764d071ddb1247e093bce93caa5c6f3745", "filename": "clippy_lints/src/redundant_async_block.rs", "status": "modified", "additions": 67, "deletions": 78, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fredundant_async_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fredundant_async_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_async_block.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,8 +1,15 @@\n-use clippy_utils::{diagnostics::span_lint_and_sugg, source::snippet};\n-use rustc_ast::ast::{Expr, ExprKind, Stmt, StmtKind};\n-use rustc_ast::visit::Visitor as AstVisitor;\n+use std::ops::ControlFlow;\n+\n+use clippy_utils::{\n+    diagnostics::span_lint_and_sugg,\n+    peel_blocks,\n+    source::{snippet, walk_span_to_context},\n+    visitors::for_each_expr,\n+};\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_hir::{AsyncGeneratorKind, Closure, Expr, ExprKind, GeneratorKind, MatchSource};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::{lint::in_external_macro, ty::UpvarCapture};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -14,106 +21,88 @@ declare_clippy_lint! {\n     ///\n     /// ### Example\n     /// ```rust\n-    /// async fn f() -> i32 {\n-    ///     1 + 2\n-    /// }\n-    ///\n+    /// let f = async {\n+    ///    1 + 2\n+    /// };\n     /// let fut = async {\n-    ///     f().await\n+    ///     f.await\n     /// };\n     /// ```\n     /// Use instead:\n     /// ```rust\n-    /// async fn f() -> i32 {\n-    ///     1 + 2\n-    /// }\n-    ///\n-    /// let fut = f();\n+    /// let f = async {\n+    ///    1 + 2\n+    /// };\n+    /// let fut = f;\n     /// ```\n     #[clippy::version = \"1.69.0\"]\n     pub REDUNDANT_ASYNC_BLOCK,\n-    nursery,\n+    complexity,\n     \"`async { future.await }` can be replaced by `future`\"\n }\n declare_lint_pass!(RedundantAsyncBlock => [REDUNDANT_ASYNC_BLOCK]);\n \n-impl EarlyLintPass for RedundantAsyncBlock {\n-    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-        if let ExprKind::Async(_, block) = &expr.kind && block.stmts.len() == 1 &&\n-            let Some(Stmt { kind: StmtKind::Expr(last), .. }) = block.stmts.last() &&\n-            let ExprKind::Await(future) = &last.kind &&\n-            !future.span.from_expansion() &&\n-            !await_in_expr(future)\n+impl<'tcx> LateLintPass<'tcx> for RedundantAsyncBlock {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        let span = expr.span;\n+        if !in_external_macro(cx.tcx.sess, span) &&\n+            let Some(body_expr) = desugar_async_block(cx, expr) &&\n+            let Some(expr) = desugar_await(peel_blocks(body_expr)) &&\n+            // The await prefix must not come from a macro as its content could change in the future.\n+            expr.span.ctxt() == body_expr.span.ctxt() &&\n+            // An async block does not have immediate side-effects from a `.await` point-of-view.\n+            (!expr.can_have_side_effects() || desugar_async_block(cx, expr).is_some()) &&\n+            let Some(shortened_span) = walk_span_to_context(expr.span, span.ctxt())\n         {\n-            if captures_value(last) {\n-                // If the async block captures variables then there is no equivalence.\n-                return;\n-            }\n-\n             span_lint_and_sugg(\n                 cx,\n                 REDUNDANT_ASYNC_BLOCK,\n-                expr.span,\n+                span,\n                 \"this async expression only awaits a single future\",\n                 \"you can reduce it to\",\n-                snippet(cx, future.span, \"..\").into_owned(),\n+                snippet(cx, shortened_span, \"..\").into_owned(),\n                 Applicability::MachineApplicable,\n             );\n         }\n     }\n }\n \n-/// Check whether an expression contains `.await`\n-fn await_in_expr(expr: &Expr) -> bool {\n-    let mut detector = AwaitDetector::default();\n-    detector.visit_expr(expr);\n-    detector.await_found\n-}\n-\n-#[derive(Default)]\n-struct AwaitDetector {\n-    await_found: bool,\n-}\n-\n-impl<'ast> AstVisitor<'ast> for AwaitDetector {\n-    fn visit_expr(&mut self, ex: &'ast Expr) {\n-        match (&ex.kind, self.await_found) {\n-            (ExprKind::Await(_), _) => self.await_found = true,\n-            (_, false) => rustc_ast::visit::walk_expr(self, ex),\n-            _ => (),\n-        }\n+/// If `expr` is a desugared `async` block, return the original expression if it does not capture\n+/// any variable by ref.\n+fn desugar_async_block<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if let ExprKind::Closure(Closure { body, def_id, .. }) = expr.kind &&\n+        let body = cx.tcx.hir().body(*body) &&\n+        matches!(body.generator_kind, Some(GeneratorKind::Async(AsyncGeneratorKind::Block)))\n+    {\n+        cx\n+            .typeck_results()\n+            .closure_min_captures\n+            .get(def_id)\n+            .map_or(true, |m| {\n+                m.values().all(|places| {\n+                    places\n+                        .iter()\n+                        .all(|place| matches!(place.info.capture_kind, UpvarCapture::ByValue))\n+                })\n+            })\n+            .then_some(body.value)\n+    } else {\n+        None\n     }\n }\n \n-/// Check whether an expression may have captured a local variable.\n-/// This is done by looking for paths with only one segment, except as\n-/// a prefix of `.await` since this would be captured by value.\n-///\n-/// This function will sometimes return `true` even tough there are no\n-/// captures happening: at the AST level, it is impossible to\n-/// dinstinguish a function call from a call to a closure which comes\n-/// from the local environment.\n-fn captures_value(expr: &Expr) -> bool {\n-    let mut detector = CaptureDetector::default();\n-    detector.visit_expr(expr);\n-    detector.capture_found\n-}\n-\n-#[derive(Default)]\n-struct CaptureDetector {\n-    capture_found: bool,\n-}\n-\n-impl<'ast> AstVisitor<'ast> for CaptureDetector {\n-    fn visit_expr(&mut self, ex: &'ast Expr) {\n-        match (&ex.kind, self.capture_found) {\n-            (ExprKind::Await(fut), _) if matches!(fut.kind, ExprKind::Path(..)) => (),\n-            (ExprKind::Path(_, path), _) if path.segments.len() == 1 => self.capture_found = true,\n-            (_, false) => rustc_ast::visit::walk_expr(self, ex),\n-            _ => (),\n-        }\n+/// If `expr` is a desugared `.await`, return the original expression if it does not come from a\n+/// macro expansion.\n+fn desugar_await<'tcx>(expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if let ExprKind::Match(match_value, _, MatchSource::AwaitDesugar) = expr.kind &&\n+        let ExprKind::Call(_, [into_future_arg]) = match_value.kind &&\n+        let ctxt = expr.span.ctxt() &&\n+        for_each_expr(into_future_arg, |e|\n+            walk_span_to_context(e.span, ctxt)\n+                .map_or(ControlFlow::Break(()), |_| ControlFlow::Continue(()))).is_none()\n+    {\n+        Some(into_future_arg)\n+    } else {\n+        None\n     }\n }"}, {"sha": "038dfe8e4803ca8417801108048bf91a6cc9afa4", "filename": "clippy_lints/src/redundant_static_lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::msrvs::{self, Msrv};\n use clippy_utils::source::snippet;\n-use rustc_ast::ast::{Item, ItemKind, Ty, TyKind, StaticItem, ConstItem};\n+use rustc_ast::ast::{ConstItem, Item, ItemKind, StaticItem, Ty, TyKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -106,7 +106,7 @@ impl EarlyLintPass for RedundantStaticLifetimes {\n                 // #2438)\n             }\n \n-            if let ItemKind::Static(box StaticItem { ty: ref var_type,.. }) = item.kind {\n+            if let ItemKind::Static(box StaticItem { ty: ref var_type, .. }) = item.kind {\n                 Self::visit_type(var_type, cx, \"statics have by default a `'static` lifetime\");\n             }\n         }"}, {"sha": "df126d7617ebe6ca13cd69e50e204d8c5bc04994", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, LangItem, MatchSource, PatKind, QPath, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{self, subst::GenericArgKind, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map::Span;\n@@ -175,7 +175,7 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n                 } else {\n                     RetReplacement::Empty\n                 };\n-                check_final_expr(cx, body.value, vec![], replacement);\n+                check_final_expr(cx, body.value, vec![], replacement, None);\n             },\n             FnKind::ItemFn(..) | FnKind::Method(..) => {\n                 check_block_return(cx, &body.value.kind, sp, vec![]);\n@@ -188,11 +188,11 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n fn check_block_return<'tcx>(cx: &LateContext<'tcx>, expr_kind: &ExprKind<'tcx>, sp: Span, mut semi_spans: Vec<Span>) {\n     if let ExprKind::Block(block, _) = expr_kind {\n         if let Some(block_expr) = block.expr {\n-            check_final_expr(cx, block_expr, semi_spans, RetReplacement::Empty);\n+            check_final_expr(cx, block_expr, semi_spans, RetReplacement::Empty, None);\n         } else if let Some(stmt) = block.stmts.iter().last() {\n             match stmt.kind {\n                 StmtKind::Expr(expr) => {\n-                    check_final_expr(cx, expr, semi_spans, RetReplacement::Empty);\n+                    check_final_expr(cx, expr, semi_spans, RetReplacement::Empty, None);\n                 },\n                 StmtKind::Semi(semi_expr) => {\n                     // Remove ending semicolons and any whitespace ' ' in between.\n@@ -202,7 +202,7 @@ fn check_block_return<'tcx>(cx: &LateContext<'tcx>, expr_kind: &ExprKind<'tcx>,\n                             span_find_starting_semi(cx.sess().source_map(), semi_span.with_hi(sp.hi()));\n                         semi_spans.push(semi_span_to_remove);\n                     }\n-                    check_final_expr(cx, semi_expr, semi_spans, RetReplacement::Empty);\n+                    check_final_expr(cx, semi_expr, semi_spans, RetReplacement::Empty, None);\n                 },\n                 _ => (),\n             }\n@@ -216,6 +216,7 @@ fn check_final_expr<'tcx>(\n     semi_spans: Vec<Span>, /* containing all the places where we would need to remove semicolons if finding an\n                             * needless return */\n     replacement: RetReplacement<'tcx>,\n+    match_ty_opt: Option<Ty<'_>>,\n ) {\n     let peeled_drop_expr = expr.peel_drop_temps();\n     match &peeled_drop_expr.kind {\n@@ -244,7 +245,22 @@ fn check_final_expr<'tcx>(\n                     RetReplacement::Expr(snippet, applicability)\n                 }\n             } else {\n-                replacement\n+                match match_ty_opt {\n+                    Some(match_ty) => {\n+                        match match_ty.kind() {\n+                            // If the code got till here with\n+                            // tuple not getting detected before it,\n+                            // then we are sure it's going to be Unit\n+                            // type\n+                            ty::Tuple(_) => RetReplacement::Unit,\n+                            // We don't want to anything in this case\n+                            // cause we can't predict what the user would\n+                            // want here\n+                            _ => return,\n+                        }\n+                    },\n+                    None => replacement,\n+                }\n             };\n \n             if !cx.tcx.hir().attrs(expr.hir_id).is_empty() {\n@@ -268,8 +284,9 @@ fn check_final_expr<'tcx>(\n         // note, if without else is going to be a type checking error anyways\n         // (except for unit type functions) so we don't match it\n         ExprKind::Match(_, arms, MatchSource::Normal) => {\n+            let match_ty = cx.typeck_results().expr_ty(peeled_drop_expr);\n             for arm in arms.iter() {\n-                check_final_expr(cx, arm.body, semi_spans.clone(), RetReplacement::Unit);\n+                check_final_expr(cx, arm.body, semi_spans.clone(), RetReplacement::Unit, Some(match_ty));\n             }\n         },\n         // if it's a whole block, check it\n@@ -293,6 +310,7 @@ fn emit_return_lint(cx: &LateContext<'_>, ret_span: Span, semi_spans: Vec<Span>,\n     if ret_span.from_expansion() {\n         return;\n     }\n+\n     let applicability = replacement.applicability().unwrap_or(Applicability::MachineApplicable);\n     let return_replacement = replacement.to_string();\n     let sugg_help = replacement.sugg_help();"}, {"sha": "5743dd21c2835299e68ce6d397155da193de94e4", "filename": "clippy_lints/src/single_component_path_imports.rs", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsingle_component_path_imports.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,6 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n use rustc_ast::node_id::{NodeId, NodeMap};\n-use rustc_ast::{ptr::P, Crate, Item, ItemKind, MacroDef, ModKind, UseTreeKind};\n+use rustc_ast::visit::{walk_expr, Visitor};\n+use rustc_ast::{ptr::P, Crate, Expr, ExprKind, Item, ItemKind, MacroDef, ModKind, Ty, TyKind, UseTreeKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -55,7 +56,7 @@ impl EarlyLintPass for SingleComponentPathImports {\n             return;\n         }\n \n-        self.check_mod(cx, &krate.items);\n+        self.check_mod(&krate.items);\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n@@ -84,8 +85,43 @@ impl EarlyLintPass for SingleComponentPathImports {\n     }\n }\n \n+#[derive(Default)]\n+struct ImportUsageVisitor {\n+    // keep track of imports reused with `self` keyword, such as `self::std` in the example below.\n+    // Removing the `use std;` would make this a compile error (#10549)\n+    // ```\n+    // use std;\n+    //\n+    // fn main() {\n+    //     let _ = self::std::io::stdout();\n+    // }\n+    // ```\n+    imports_referenced_with_self: Vec<Symbol>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for ImportUsageVisitor {\n+    fn visit_expr(&mut self, expr: &Expr) {\n+        if let ExprKind::Path(_, path) = &expr.kind\n+            && path.segments.len() > 1\n+            && path.segments[0].ident.name == kw::SelfLower\n+        {\n+            self.imports_referenced_with_self.push(path.segments[1].ident.name);\n+        }\n+        walk_expr(self, expr);\n+    }\n+\n+    fn visit_ty(&mut self, ty: &Ty) {\n+        if let TyKind::Path(_, path) = &ty.kind\n+            && path.segments.len() > 1\n+            && path.segments[0].ident.name == kw::SelfLower\n+        {\n+            self.imports_referenced_with_self.push(path.segments[1].ident.name);\n+        }\n+    }\n+}\n+\n impl SingleComponentPathImports {\n-    fn check_mod(&mut self, cx: &EarlyContext<'_>, items: &[P<Item>]) {\n+    fn check_mod(&mut self, items: &[P<Item>]) {\n         // keep track of imports reused with `self` keyword, such as `self::crypto_hash` in the example\n         // below. Removing the `use crypto_hash;` would make this a compile error\n         // ```\n@@ -108,26 +144,23 @@ impl SingleComponentPathImports {\n         // ```\n         let mut macros = Vec::new();\n \n+        let mut import_usage_visitor = ImportUsageVisitor::default();\n         for item in items {\n-            self.track_uses(\n-                cx,\n-                item,\n-                &mut imports_reused_with_self,\n-                &mut single_use_usages,\n-                &mut macros,\n-            );\n+            self.track_uses(item, &mut imports_reused_with_self, &mut single_use_usages, &mut macros);\n+            import_usage_visitor.visit_item(item);\n         }\n \n         for usage in single_use_usages {\n-            if !imports_reused_with_self.contains(&usage.name) {\n+            if !imports_reused_with_self.contains(&usage.name)\n+                && !import_usage_visitor.imports_referenced_with_self.contains(&usage.name)\n+            {\n                 self.found.entry(usage.item_id).or_default().push(usage);\n             }\n         }\n     }\n \n     fn track_uses(\n         &mut self,\n-        cx: &EarlyContext<'_>,\n         item: &Item,\n         imports_reused_with_self: &mut Vec<Symbol>,\n         single_use_usages: &mut Vec<SingleUse>,\n@@ -139,7 +172,7 @@ impl SingleComponentPathImports {\n \n         match &item.kind {\n             ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) => {\n-                self.check_mod(cx, items);\n+                self.check_mod(items);\n             },\n             ItemKind::MacroDef(MacroDef { macro_rules: true, .. }) => {\n                 macros.push(item.ident.name);"}, {"sha": "e5746ca99cac19808c3f272ac3cb6b29117a186b", "filename": "clippy_lints/src/suspicious_doc_comments.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fsuspicious_doc_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fsuspicious_doc_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_doc_comments.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,94 @@\n+use clippy_utils::diagnostics::{multispan_sugg_with_applicability, span_lint_and_then};\n+use if_chain::if_chain;\n+use rustc_ast::{token::CommentKind, AttrKind, AttrStyle, Attribute, Item};\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects the use of outer doc comments (`///`, `/**`) followed by a bang (`!`): `///!`\n+    ///\n+    /// ### Why is this bad?\n+    /// Triple-slash comments (known as \"outer doc comments\") apply to items that follow it.\n+    /// An outer doc comment followed by a bang (i.e. `///!`) has no specific meaning.\n+    ///\n+    /// The user most likely meant to write an inner doc comment (`//!`, `/*!`), which\n+    /// applies to the parent item (i.e. the item that the comment is contained in,\n+    /// usually a module or crate).\n+    ///\n+    /// ### Known problems\n+    /// Inner doc comments can only appear before items, so there are certain cases where the suggestion\n+    /// made by this lint is not valid code. For example:\n+    /// ```rs\n+    /// fn foo() {}\n+    /// ///!\n+    /// fn bar() {}\n+    /// ```\n+    /// This lint detects the doc comment and suggests changing it to `//!`, but an inner doc comment\n+    /// is not valid at that position.\n+    ///\n+    /// ### Example\n+    /// In this example, the doc comment is attached to the *function*, rather than the *module*.\n+    /// ```rust\n+    /// pub mod util {\n+    ///     ///! This module contains utility functions.\n+    ///\n+    ///     pub fn dummy() {}\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// pub mod util {\n+    ///     //! This module contains utility functions.\n+    ///\n+    ///     pub fn dummy() {}\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.70.0\"]\n+    pub SUSPICIOUS_DOC_COMMENTS,\n+    suspicious,\n+    \"suspicious usage of (outer) doc comments\"\n+}\n+declare_lint_pass!(SuspiciousDocComments => [SUSPICIOUS_DOC_COMMENTS]);\n+\n+const WARNING: &str = \"this is an outer doc comment and does not apply to the parent module or crate\";\n+const HELP: &str = \"use an inner doc comment to document the parent module or crate\";\n+\n+impl EarlyLintPass for SuspiciousDocComments {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        let replacements = collect_doc_comment_replacements(&item.attrs);\n+\n+        if let Some(((lo_span, _), (hi_span, _))) = replacements.first().zip(replacements.last()) {\n+            let span = lo_span.to(*hi_span);\n+\n+            span_lint_and_then(cx, SUSPICIOUS_DOC_COMMENTS, span, WARNING, |diag| {\n+                multispan_sugg_with_applicability(diag, HELP, Applicability::MaybeIncorrect, replacements);\n+            });\n+        }\n+    }\n+}\n+\n+fn collect_doc_comment_replacements(attrs: &[Attribute]) -> Vec<(Span, String)> {\n+    attrs\n+        .iter()\n+        .filter_map(|attr| {\n+            if_chain! {\n+                if let AttrKind::DocComment(com_kind, sym) = attr.kind;\n+                if let AttrStyle::Outer = attr.style;\n+                if let Some(com) = sym.as_str().strip_prefix('!');\n+                then {\n+                    let sugg = match com_kind {\n+                        CommentKind::Line => format!(\"//!{com}\"),\n+                        CommentKind::Block => format!(\"/*!{com}*/\")\n+                    };\n+                    Some((attr.span, sugg))\n+                } else {\n+                    None\n+                }\n+            }\n+        })\n+        .collect()\n+}"}, {"sha": "0a0a77082e02ffc485826197166ba30fbaefa691", "filename": "clippy_lints/src/tests_outside_test_module.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Ftests_outside_test_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Ftests_outside_test_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftests_outside_test_module.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,71 @@\n+use clippy_utils::{diagnostics::span_lint_and_note, is_in_cfg_test, is_in_test_function};\n+use rustc_hir::{intravisit::FnKind, Body, FnDecl};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{def_id::LocalDefId, Span};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Triggers when a testing function (marked with the `#[test]` attribute) isn't inside a testing module\n+    /// (marked with `#[cfg(test)]`).\n+    /// ### Why is this bad?\n+    /// The idiomatic (and more performant) way of writing tests is inside a testing module (flagged with `#[cfg(test)]`),\n+    /// having test functions outside of this module is confusing and may lead to them being \"hidden\".\n+    /// ### Example\n+    /// ```rust\n+    /// #[test]\n+    /// fn my_cool_test() {\n+    ///     // [...]\n+    /// }\n+    ///\n+    /// #[cfg(test)]\n+    /// mod tests {\n+    ///     // [...]\n+    /// }\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// #[cfg(test)]\n+    /// mod tests {\n+    ///     #[test]\n+    ///     fn my_cool_test() {\n+    ///         // [...]\n+    ///     }\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.70.0\"]\n+    pub TESTS_OUTSIDE_TEST_MODULE,\n+    restriction,\n+    \"A test function is outside the testing module.\"\n+}\n+\n+declare_lint_pass!(TestsOutsideTestModule => [TESTS_OUTSIDE_TEST_MODULE]);\n+\n+impl LateLintPass<'_> for TestsOutsideTestModule {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'_>,\n+        kind: FnKind<'_>,\n+        _: &FnDecl<'_>,\n+        body: &Body<'_>,\n+        sp: Span,\n+        _: LocalDefId,\n+    ) {\n+        if_chain! {\n+            if !matches!(kind, FnKind::Closure);\n+            if is_in_test_function(cx.tcx, body.id().hir_id);\n+            if !is_in_cfg_test(cx.tcx, body.id().hir_id);\n+            then {\n+                span_lint_and_note(\n+                    cx,\n+                    TESTS_OUTSIDE_TEST_MODULE,\n+                    sp,\n+                    \"this function marked with #[test] is outside a #[cfg(test)] module\",\n+                    None,\n+                    \"move it to a testing module marked with #[cfg(test)]\",\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "85cd74f23ef7e27c5b57a87332974f459001e2d2", "filename": "clippy_lints/src/transmute/transmutes_expressible_as_ptr_casts.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -2,8 +2,9 @@ use super::utils::check_cast;\n use super::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::sugg::Sugg;\n+use rustc_ast::ExprPrecedence;\n use rustc_errors::Applicability;\n-use rustc_hir::Expr;\n+use rustc_hir::{Expr, Node};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{cast::CastKind, Ty};\n \n@@ -19,7 +20,7 @@ pub(super) fn check<'tcx>(\n ) -> bool {\n     use CastKind::{AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast};\n     let mut app = Applicability::MachineApplicable;\n-    let sugg = match check_cast(cx, e, from_ty, to_ty) {\n+    let mut sugg = match check_cast(cx, e, from_ty, to_ty) {\n         Some(PtrPtrCast | AddrPtrCast | ArrayPtrCast | FnPtrPtrCast | FnPtrAddrCast) => {\n             Sugg::hir_with_context(cx, arg, e.span.ctxt(), \"..\", &mut app)\n                 .as_ty(to_ty.to_string())\n@@ -39,6 +40,12 @@ pub(super) fn check<'tcx>(\n         _ => return false,\n     };\n \n+    if let Node::Expr(parent) = cx.tcx.hir().get_parent(e.hir_id)\n+        && parent.precedence().order() > ExprPrecedence::Cast.order()\n+    {\n+        sugg = format!(\"({sugg})\");\n+    }\n+\n     span_lint_and_sugg(\n         cx,\n         TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,"}, {"sha": "912bcda630b83b179d39f42dedeb81dadebb2b55", "filename": "clippy_lints/src/unnecessary_box_returns.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Funnecessary_box_returns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Funnecessary_box_returns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_box_returns.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,120 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use rustc_errors::Applicability;\n+use rustc_hir::{def_id::LocalDefId, FnDecl, FnRetTy, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Symbol;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Checks for a return type containing a `Box<T>` where `T` implements `Sized`\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// It's better to just return `T` in these cases. The caller may not need\n+    /// the value to be boxed, and it's expensive to free the memory once the\n+    /// `Box<T>` been dropped.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn foo() -> Box<String> {\n+    ///     Box::new(String::from(\"Hello, world!\"))\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn foo() -> String {\n+    ///     String::from(\"Hello, world!\")\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.70.0\"]\n+    pub UNNECESSARY_BOX_RETURNS,\n+    pedantic,\n+    \"Needlessly returning a Box\"\n+}\n+\n+pub struct UnnecessaryBoxReturns {\n+    avoid_breaking_exported_api: bool,\n+}\n+\n+impl_lint_pass!(UnnecessaryBoxReturns => [UNNECESSARY_BOX_RETURNS]);\n+\n+impl UnnecessaryBoxReturns {\n+    pub fn new(avoid_breaking_exported_api: bool) -> Self {\n+        Self {\n+            avoid_breaking_exported_api,\n+        }\n+    }\n+\n+    fn check_fn_item(&mut self, cx: &LateContext<'_>, decl: &FnDecl<'_>, def_id: LocalDefId, name: Symbol) {\n+        // we don't want to tell someone to break an exported function if they ask us not to\n+        if self.avoid_breaking_exported_api && cx.effective_visibilities.is_exported(def_id) {\n+            return;\n+        }\n+\n+        // functions which contain the word \"box\" are exempt from this lint\n+        if name.as_str().contains(\"box\") {\n+            return;\n+        }\n+\n+        let FnRetTy::Return(return_ty_hir) = &decl.output else { return };\n+\n+        let return_ty = cx\n+            .tcx\n+            .erase_late_bound_regions(cx.tcx.fn_sig(def_id).skip_binder())\n+            .output();\n+\n+        if !return_ty.is_box() {\n+            return;\n+        }\n+\n+        let boxed_ty = return_ty.boxed_ty();\n+\n+        // it's sometimes useful to return Box<T> if T is unsized, so don't lint those\n+        if boxed_ty.is_sized(cx.tcx, cx.param_env) {\n+            span_lint_and_then(\n+                cx,\n+                UNNECESSARY_BOX_RETURNS,\n+                return_ty_hir.span,\n+                format!(\"boxed return of the sized type `{boxed_ty}`\").as_str(),\n+                |diagnostic| {\n+                    diagnostic.span_suggestion(\n+                        return_ty_hir.span,\n+                        \"try\",\n+                        boxed_ty.to_string(),\n+                        // the return value and function callers also needs to\n+                        // be changed, so this can't be MachineApplicable\n+                        Applicability::Unspecified,\n+                    );\n+                    diagnostic.help(\"changing this also requires a change to the return expressions in this function\");\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+impl LateLintPass<'_> for UnnecessaryBoxReturns {\n+    fn check_trait_item(&mut self, cx: &LateContext<'_>, item: &TraitItem<'_>) {\n+        let TraitItemKind::Fn(signature, _) = &item.kind else { return };\n+        self.check_fn_item(cx, signature.decl, item.owner_id.def_id, item.ident.name);\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'_>, item: &rustc_hir::ImplItem<'_>) {\n+        // Ignore implementations of traits, because the lint should be on the\n+        // trait, not on the implmentation of it.\n+        let Node::Item(parent) = cx.tcx.hir().get_parent(item.hir_id()) else { return };\n+        let ItemKind::Impl(parent) = parent.kind else { return };\n+        if parent.of_trait.is_some() {\n+            return;\n+        }\n+\n+        let ImplItemKind::Fn(signature, ..) = &item.kind else { return };\n+        self.check_fn_item(cx, signature.decl, item.owner_id.def_id, item.ident.name);\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        let ItemKind::Fn(signature, ..) = &item.kind else { return };\n+        self.check_fn_item(cx, signature.decl, item.owner_id.def_id, item.ident.name);\n+    }\n+}"}, {"sha": "084b031982d8c64c010fa9a2e7657ab427bd69f6", "filename": "clippy_lints/src/unnecessary_struct_initialization.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Funnecessary_struct_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Funnecessary_struct_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_struct_initialization.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -9,7 +9,7 @@ declare_clippy_lint! {\n     /// any field.\n     ///\n     /// ### Why is this bad?\n-    /// Readibility suffers from unnecessary struct building.\n+    /// Readability suffers from unnecessary struct building.\n     ///\n     /// ### Example\n     /// ```rust\n@@ -25,9 +25,13 @@ declare_clippy_lint! {\n     /// let a = S { s: String::from(\"Hello, world!\") };\n     /// let b = a;\n     /// ```\n+    ///\n+    /// ### Known Problems\n+    /// Has false positives when the base is a place expression that cannot be\n+    /// moved out of, see [#10547](https://github.com/rust-lang/rust-clippy/issues/10547).\n     #[clippy::version = \"1.70.0\"]\n     pub UNNECESSARY_STRUCT_INITIALIZATION,\n-    complexity,\n+    nursery,\n     \"struct built from a base that can be written mode concisely\"\n }\n declare_lint_pass!(UnnecessaryStruct => [UNNECESSARY_STRUCT_INITIALIZATION]);"}, {"sha": "5a02987453c41ff670e408157dade8f573e3f04c", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -10,8 +10,8 @@ use rustc_hir::{\n     def::{CtorOf, DefKind, Res},\n     def_id::LocalDefId,\n     intravisit::{walk_inf, walk_ty, Visitor},\n-    Expr, ExprKind, FnRetTy, FnSig, GenericArg, GenericArgsParentheses, GenericParam, GenericParamKind, HirId, Impl, ImplItemKind, Item,\n-    ItemKind, Pat, PatKind, Path, QPath, Ty, TyKind,\n+    Expr, ExprKind, FnRetTy, FnSig, GenericArg, GenericArgsParentheses, GenericParam, GenericParamKind, HirId, Impl,\n+    ImplItemKind, Item, ItemKind, Pat, PatKind, Path, QPath, Ty, TyKind,\n };\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{LateContext, LateLintPass};"}, {"sha": "896a01af37d995b10924acdacca1c9ef9305bbc9", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -249,7 +249,7 @@ define_Conf! {\n     /// arithmetic-side-effects-allowed-unary = [\"SomeType\", \"AnotherType\"]\n     /// ```\n     (arithmetic_side_effects_allowed_unary: rustc_data_structures::fx::FxHashSet<String> = <_>::default()),\n-    /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UNUSED_SELF, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION, BOX_COLLECTION, REDUNDANT_ALLOCATION, RC_BUFFER, VEC_BOX, OPTION_OPTION, LINKEDLIST, RC_MUTEX.\n+    /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UNUSED_SELF, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION, BOX_COLLECTION, REDUNDANT_ALLOCATION, RC_BUFFER, VEC_BOX, OPTION_OPTION, LINKEDLIST, RC_MUTEX, UNNECESSARY_BOX_RETURNS.\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n@@ -275,13 +275,13 @@ define_Conf! {\n     ///\n     /// The list of disallowed names to lint about. NB: `bar` is not here since it has legitimate uses. The value\n     /// `\"..\"` can be used as part of the list to indicate, that the configured values should be appended to the\n-    /// default configuration of Clippy. By default any configuration will replace the default value.\n+    /// default configuration of Clippy. By default, any configuration will replace the default value.\n     (disallowed_names: Vec<String> = super::DEFAULT_DISALLOWED_NAMES.iter().map(ToString::to_string).collect()),\n     /// Lint: DOC_MARKDOWN.\n     ///\n     /// The list of words this lint should not consider as identifiers needing ticks. The value\n     /// `\"..\"` can be used as part of the list to indicate, that the configured values should be appended to the\n-    /// default configuration of Clippy. By default any configuraction will replace the default value. For example:\n+    /// default configuration of Clippy. By default, any configuration will replace the default value. For example:\n     /// * `doc-valid-idents = [\"ClipPy\"]` would replace the default list with `[\"ClipPy\"]`.\n     /// * `doc-valid-idents = [\"ClipPy\", \"..\"]` would append `ClipPy` to the default list.\n     ///\n@@ -390,7 +390,7 @@ define_Conf! {\n     /// Enforce the named macros always use the braces specified.\n     ///\n     /// A `MacroMatcher` can be added like so `{ name = \"macro_name\", brace = \"(\" }`. If the macro\n-    /// is could be used with a full path two `MacroMatcher`s have to be added one with the full path\n+    /// could be used with a full path two `MacroMatcher`s have to be added one with the full path\n     /// `crate_name::macro_name` and one with just the macro name.\n     (standard_macro_braces: Vec<crate::nonstandard_macro_braces::MacroMatcher> = Vec::new()),\n     /// Lint: MISSING_ENFORCED_IMPORT_RENAMES.\n@@ -408,7 +408,7 @@ define_Conf! {\n     /// Lint: INDEX_REFUTABLE_SLICE.\n     ///\n     /// When Clippy suggests using a slice pattern, this is the maximum number of elements allowed in\n-    /// the slice pattern that is suggested. If more elements would be necessary, the lint is suppressed.\n+    /// the slice pattern that is suggested. If more elements are necessary, the lint is suppressed.\n     /// For example, `[_, _, _, e, ..]` is a slice pattern with 4 elements.\n     (max_suggested_slice_pattern_length: u64 = 3),\n     /// Lint: AWAIT_HOLDING_INVALID_TYPE.\n@@ -459,24 +459,30 @@ define_Conf! {\n     /// Whether to **only** check for missing documentation in items visible within the current\n     /// crate. For example, `pub(crate)` items.\n     (missing_docs_in_crate_items: bool = false),\n+    /// Lint: LARGE_FUTURES.\n+    ///\n+    /// The maximum byte size a `Future` can have, before it triggers the `clippy::large_futures` lint\n+    (future_size_threshold: u64 = 16 * 1024),\n }\n \n /// Search for the configuration file.\n ///\n /// # Errors\n ///\n /// Returns any unexpected filesystem error encountered when searching for the config file\n-pub fn lookup_conf_file() -> io::Result<Option<PathBuf>> {\n+pub fn lookup_conf_file() -> io::Result<(Option<PathBuf>, Vec<String>)> {\n     /// Possible filename to search for.\n     const CONFIG_FILE_NAMES: [&str; 2] = [\".clippy.toml\", \"clippy.toml\"];\n \n     // Start looking for a config file in CLIPPY_CONF_DIR, or failing that, CARGO_MANIFEST_DIR.\n     // If neither of those exist, use \".\".\n     let mut current = env::var_os(\"CLIPPY_CONF_DIR\")\n         .or_else(|| env::var_os(\"CARGO_MANIFEST_DIR\"))\n-        .map_or_else(|| PathBuf::from(\".\"), PathBuf::from);\n+        .map_or_else(|| PathBuf::from(\".\"), PathBuf::from)\n+        .canonicalize()?;\n \n     let mut found_config: Option<PathBuf> = None;\n+    let mut warnings = vec![];\n \n     loop {\n         for config_file_name in &CONFIG_FILE_NAMES {\n@@ -487,12 +493,12 @@ pub fn lookup_conf_file() -> io::Result<Option<PathBuf>> {\n                     Ok(md) if md.is_dir() => {},\n                     Ok(_) => {\n                         // warn if we happen to find two config files #8323\n-                        if let Some(ref found_config_) = found_config {\n-                            eprintln!(\n-                                \"Using config file `{}`\\nWarning: `{}` will be ignored.\",\n-                                found_config_.display(),\n-                                config_file.display(),\n-                            );\n+                        if let Some(ref found_config) = found_config {\n+                            warnings.push(format!(\n+                                \"using config file `{}`, `{}` will be ignored\",\n+                                found_config.display(),\n+                                config_file.display()\n+                            ));\n                         } else {\n                             found_config = Some(config_file);\n                         }\n@@ -502,12 +508,12 @@ pub fn lookup_conf_file() -> io::Result<Option<PathBuf>> {\n         }\n \n         if found_config.is_some() {\n-            return Ok(found_config);\n+            return Ok((found_config, warnings));\n         }\n \n         // If the current directory has no parent, we're done searching.\n         if !current.pop() {\n-            return Ok(None);\n+            return Ok((None, warnings));\n         }\n     }\n }"}, {"sha": "09fcb82c37c88d95b78a87e20c7b3e7a7359c72a", "filename": "clippy_lints/src/utils/format_args_collector.rs", "status": "modified", "additions": 77, "deletions": 2, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Futils%2Fformat_args_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Futils%2Fformat_args_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fformat_args_collector.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,7 +1,12 @@\n use clippy_utils::macros::collect_ast_format_args;\n-use rustc_ast::{Expr, ExprKind};\n+use clippy_utils::source::snippet_opt;\n+use itertools::Itertools;\n+use rustc_ast::{Expr, ExprKind, FormatArgs};\n+use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::hygiene;\n+use std::iter::once;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -15,9 +20,79 @@ declare_clippy_lint! {\n declare_lint_pass!(FormatArgsCollector => [FORMAT_ARGS_COLLECTOR]);\n \n impl EarlyLintPass for FormatArgsCollector {\n-    fn check_expr(&mut self, _: &EarlyContext<'_>, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         if let ExprKind::FormatArgs(args) = &expr.kind {\n+            if has_span_from_proc_macro(cx, args) {\n+                return;\n+            }\n+\n             collect_ast_format_args(expr.span, args);\n         }\n     }\n }\n+\n+/// Detects if the format string or an argument has its span set by a proc macro to something inside\n+/// a macro callsite, e.g.\n+///\n+/// ```ignore\n+/// println!(some_proc_macro!(\"input {}\"), a);\n+/// ```\n+///\n+/// Where `some_proc_macro` expands to\n+///\n+/// ```ignore\n+/// println!(\"output {}\", a);\n+/// ```\n+///\n+/// But with the span of `\"output {}\"` set to the macro input\n+///\n+/// ```ignore\n+/// println!(some_proc_macro!(\"input {}\"), a);\n+/// //                        ^^^^^^^^^^\n+/// ```\n+fn has_span_from_proc_macro(cx: &EarlyContext<'_>, args: &FormatArgs) -> bool {\n+    let ctxt = args.span.ctxt();\n+\n+    // `format!(\"{} {} {c}\", \"one\", \"two\", c = \"three\")`\n+    //                       ^^^^^  ^^^^^      ^^^^^^^\n+    let argument_span = args\n+        .arguments\n+        .explicit_args()\n+        .iter()\n+        .map(|argument| hygiene::walk_chain(argument.expr.span, ctxt));\n+\n+    // `format!(\"{} {} {c}\", \"one\", \"two\", c = \"three\")`\n+    //                     ^^     ^^     ^^^^^^\n+    let between_spans = once(args.span)\n+        .chain(argument_span)\n+        .tuple_windows()\n+        .map(|(start, end)| start.between(end));\n+\n+    for between_span in between_spans {\n+        let mut seen_comma = false;\n+\n+        let Some(snippet) = snippet_opt(cx, between_span) else { return true };\n+        for token in tokenize(&snippet) {\n+            match token.kind {\n+                TokenKind::LineComment { .. } | TokenKind::BlockComment { .. } | TokenKind::Whitespace => {},\n+                TokenKind::Comma if !seen_comma => seen_comma = true,\n+                // named arguments, `start_val, name = end_val`\n+                //                            ^^^^^^^^^ between_span\n+                TokenKind::Ident | TokenKind::Eq if seen_comma => {},\n+                // An unexpected token usually indicates that we crossed a macro boundary\n+                //\n+                // `println!(some_proc_macro!(\"input {}\"), a)`\n+                //                                      ^^^ between_span\n+                // `println!(\"{}\", val!(x))`\n+                //               ^^^^^^^ between_span\n+                _ => return true,\n+            }\n+        }\n+\n+        if !seen_comma {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "d7c94b909bdc5ea386ae48e314e83d136fb21961", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -463,12 +463,18 @@ fn check_literal(cx: &LateContext<'_>, format_args: &FormatArgs, name: &str) {\n             && let Some(value_string) = snippet_opt(cx, arg.expr.span)\n     {\n             let (replacement, replace_raw) = match lit.kind {\n-                LitKind::Str | LitKind::StrRaw(_)  => extract_str_literal(&value_string),\n+                LitKind::Str | LitKind::StrRaw(_)  => match extract_str_literal(&value_string) {\n+                    Some(extracted) => extracted,\n+                    None => return,\n+                },\n                 LitKind::Char => (\n                     match lit.symbol.as_str() {\n                         \"\\\"\" => \"\\\\\\\"\",\n                         \"\\\\'\" => \"'\",\n-                        _ => &value_string[1..value_string.len() - 1],\n+                        _ => match value_string.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\'')) {\n+                            Some(stripped) => stripped,\n+                            None => return,\n+                        },\n                     }\n                     .to_string(),\n                     false,\n@@ -533,13 +539,13 @@ fn check_literal(cx: &LateContext<'_>, format_args: &FormatArgs, name: &str) {\n /// `r#\"a\"#` -> (`a`, true)\n ///\n /// `\"b\"` -> (`b`, false)\n-fn extract_str_literal(literal: &str) -> (String, bool) {\n+fn extract_str_literal(literal: &str) -> Option<(String, bool)> {\n     let (literal, raw) = match literal.strip_prefix('r') {\n         Some(stripped) => (stripped.trim_matches('#'), true),\n         None => (literal, false),\n     };\n \n-    (literal[1..literal.len() - 1].to_string(), raw)\n+    Some((literal.strip_prefix('\"')?.strip_suffix('\"')?.to_string(), raw))\n }\n \n enum UnescapeErr {"}, {"sha": "1f15598db36d9438b98c6283a424f3872b65f3b0", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -286,8 +286,30 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n     match (l, r) {\n         (ExternCrate(l), ExternCrate(r)) => l == r,\n         (Use(l), Use(r)) => eq_use_tree(l, r),\n-        (Static(box ast::StaticItem { ty: lt, mutability: lm, expr: le}), Static(box ast::StaticItem { ty: rt, mutability: rm, expr: re})) => lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re),\n-        (Const(box ast::ConstItem { defaultness: ld, ty: lt, expr: le}), Const(box ast::ConstItem { defaultness: rd, ty: rt, expr: re} )) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n+        (\n+            Static(box ast::StaticItem {\n+                ty: lt,\n+                mutability: lm,\n+                expr: le,\n+            }),\n+            Static(box ast::StaticItem {\n+                ty: rt,\n+                mutability: rm,\n+                expr: re,\n+            }),\n+        ) => lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re),\n+        (\n+            Const(box ast::ConstItem {\n+                defaultness: ld,\n+                ty: lt,\n+                expr: le,\n+            }),\n+            Const(box ast::ConstItem {\n+                defaultness: rd,\n+                ty: rt,\n+                expr: re,\n+            }),\n+        ) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n         (\n             Fn(box ast::Fn {\n                 defaultness: ld,\n@@ -451,7 +473,18 @@ pub fn eq_foreign_item_kind(l: &ForeignItemKind, r: &ForeignItemKind) -> bool {\n pub fn eq_assoc_item_kind(l: &AssocItemKind, r: &AssocItemKind) -> bool {\n     use AssocItemKind::*;\n     match (l, r) {\n-        (Const(box ast::ConstItem { defaultness: ld, ty: lt, expr: le}), Const(box ast::ConstItem { defaultness: rd, ty: rt, expr: re})) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n+        (\n+            Const(box ast::ConstItem {\n+                defaultness: ld,\n+                ty: lt,\n+                expr: le,\n+            }),\n+            Const(box ast::ConstItem {\n+                defaultness: rd,\n+                ty: rt,\n+                expr: re,\n+            }),\n+        ) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n         (\n             Fn(box ast::Fn {\n                 defaultness: ld,"}, {"sha": "6b677df464147dde2a9174e6ca50297a679a359c", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -32,7 +32,6 @@ extern crate rustc_lexer;\n extern crate rustc_lint;\n extern crate rustc_middle;\n extern crate rustc_mir_dataflow;\n-extern crate rustc_parse_format;\n extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n@@ -77,7 +76,7 @@ use std::sync::OnceLock;\n use std::sync::{Mutex, MutexGuard};\n \n use if_chain::if_chain;\n-use rustc_ast::ast::{self, LitKind};\n+use rustc_ast::ast::{self, LitKind, RangeLimits};\n use rustc_ast::Attribute;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unhash::UnhashMap;\n@@ -95,6 +94,7 @@ use rustc_hir::{\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::place::PlaceBase;\n+use rustc_middle::mir::ConstantKind;\n use rustc_middle::ty as rustc_ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc_middle::ty::binding::BindingMode;\n@@ -113,7 +113,8 @@ use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::abi::Integer;\n \n-use crate::consts::{constant, Constant};\n+use crate::consts::{constant, miri_to_const, Constant};\n+use crate::higher::Range;\n use crate::ty::{can_partially_move_ty, expr_sig, is_copy, is_recursively_primitive_type, ty_is_fn_once_param};\n use crate::visitors::for_each_expr;\n \n@@ -1490,6 +1491,68 @@ pub fn is_else_clause(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n     }\n }\n \n+/// Checks whether the given `Expr` is a range equivalent to a `RangeFull`.\n+/// For the lower bound, this means that:\n+/// - either there is none\n+/// - or it is the smallest value that can be represented by the range's integer type\n+/// For the upper bound, this means that:\n+/// - either there is none\n+/// - or it is the largest value that can be represented by the range's integer type and is\n+///   inclusive\n+/// - or it is a call to some container's `len` method and is exclusive, and the range is passed to\n+///   a method call on that same container (e.g. `v.drain(..v.len())`)\n+/// If the given `Expr` is not some kind of range, the function returns `false`.\n+pub fn is_range_full(cx: &LateContext<'_>, expr: &Expr<'_>, container_path: Option<&Path<'_>>) -> bool {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    if let Some(Range { start, end, limits }) = Range::hir(expr) {\n+        let start_is_none_or_min = start.map_or(true, |start| {\n+            if let rustc_ty::Adt(_, subst) = ty.kind()\n+                && let bnd_ty = subst.type_at(0)\n+                && let Some(min_val) = bnd_ty.numeric_min_val(cx.tcx)\n+                && let const_val = cx.tcx.valtree_to_const_val((bnd_ty, min_val.to_valtree()))\n+                && let min_const_kind = ConstantKind::from_value(const_val, bnd_ty)\n+                && let Some(min_const) = miri_to_const(cx.tcx, min_const_kind)\n+                && let Some((start_const, _)) = constant(cx, cx.typeck_results(), start)\n+            {\n+                start_const == min_const\n+            } else {\n+                false\n+            }\n+        });\n+        let end_is_none_or_max = end.map_or(true, |end| {\n+            match limits {\n+                RangeLimits::Closed => {\n+                    if let rustc_ty::Adt(_, subst) = ty.kind()\n+                        && let bnd_ty = subst.type_at(0)\n+                        && let Some(max_val) = bnd_ty.numeric_max_val(cx.tcx)\n+                        && let const_val = cx.tcx.valtree_to_const_val((bnd_ty, max_val.to_valtree()))\n+                        && let max_const_kind = ConstantKind::from_value(const_val, bnd_ty)\n+                        && let Some(max_const) = miri_to_const(cx.tcx, max_const_kind)\n+                        && let Some((end_const, _)) = constant(cx, cx.typeck_results(), end)\n+                    {\n+                        end_const == max_const\n+                    } else {\n+                        false\n+                    }\n+                },\n+                RangeLimits::HalfOpen => {\n+                    if let Some(container_path) = container_path\n+                        && let ExprKind::MethodCall(name, self_arg, [], _) = end.kind\n+                        && name.ident.name == sym::len\n+                        && let ExprKind::Path(QPath::Resolved(None, path)) = self_arg.kind\n+                    {\n+                        container_path.res == path.res\n+                    } else {\n+                        false\n+                    }\n+                },\n+            }\n+        });\n+        return start_is_none_or_min && end_is_none_or_max;\n+    }\n+    false\n+}\n+\n /// Checks whether the given expression is a constant integer of the given value.\n /// unlike `is_integer_literal`, this version does const folding\n pub fn is_integer_const(cx: &LateContext<'_>, e: &Expr<'_>, value: u128) -> bool {\n@@ -2104,8 +2167,7 @@ pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n         .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n     traits::impossible_predicates(\n         cx.tcx,\n-        traits::elaborate(cx.tcx, predicates)\n-            .collect::<Vec<_>>(),\n+        traits::elaborate(cx.tcx, predicates).collect::<Vec<_>>(),\n     )\n }\n "}, {"sha": "62d388a5ece8d00fbd5979162997fdd611610f85", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 69, "deletions": 731, "changes": 800, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,24 +1,16 @@\n #![allow(clippy::similar_names)] // `expr` and `expn`\n \n-use crate::source::snippet_opt;\n use crate::visitors::{for_each_expr, Descend};\n \n use arrayvec::ArrayVec;\n-use itertools::{izip, Either, Itertools};\n-use rustc_ast::ast::LitKind;\n-use rustc_ast::FormatArgs;\n+use rustc_ast::{FormatArgs, FormatArgument, FormatPlaceholder};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{self as hir, Expr, ExprField, ExprKind, HirId, LangItem, Node, QPath, TyKind};\n-use rustc_lexer::unescape::unescape_literal;\n-use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n+use rustc_hir::{self as hir, Expr, ExprKind, HirId, Node, QPath};\n use rustc_lint::LateContext;\n-use rustc_parse_format::{self as rpf, Alignment};\n use rustc_span::def_id::DefId;\n use rustc_span::hygiene::{self, MacroKind, SyntaxContext};\n-use rustc_span::{sym, BytePos, ExpnData, ExpnId, ExpnKind, Pos, Span, SpanData, Symbol};\n+use rustc_span::{sym, BytePos, ExpnData, ExpnId, ExpnKind, Span, Symbol};\n use std::cell::RefCell;\n-use std::iter::{once, zip};\n use std::ops::ControlFlow;\n use std::sync::atomic::{AtomicBool, Ordering};\n \n@@ -226,11 +218,11 @@ pub enum PanicExpn<'a> {\n     /// A single argument that implements `Display` - `panic!(\"{}\", object)`\n     Display(&'a Expr<'a>),\n     /// Anything else - `panic!(\"error {}: {}\", a, b)`\n-    Format(FormatArgsExpn<'a>),\n+    Format(&'a Expr<'a>),\n }\n \n impl<'a> PanicExpn<'a> {\n-    pub fn parse(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Self> {\n+    pub fn parse(expr: &'a Expr<'a>) -> Option<Self> {\n         let ExprKind::Call(callee, [arg, rest @ ..]) = &expr.kind else { return None };\n         let ExprKind::Path(QPath::Resolved(_, path)) = &callee.kind else { return None };\n         let result = match path.segments.last().unwrap().ident.as_str() {\n@@ -240,7 +232,7 @@ impl<'a> PanicExpn<'a> {\n                 let ExprKind::AddrOf(_, _, e) = &arg.kind else { return None };\n                 Self::Display(e)\n             },\n-            \"panic_fmt\" => Self::Format(FormatArgsExpn::parse(cx, arg)?),\n+            \"panic_fmt\" => Self::Format(arg),\n             // Since Rust 1.52, `assert_{eq,ne}` macros expand to use:\n             // `core::panicking::assert_failed(.., left_val, right_val, None | Some(format_args!(..)));`\n             \"assert_failed\" => {\n@@ -252,7 +244,7 @@ impl<'a> PanicExpn<'a> {\n                 // `msg_arg` is either `None` (no custom message) or `Some(format_args!(..))` (custom message)\n                 let msg_arg = &rest[2];\n                 match msg_arg.kind {\n-                    ExprKind::Call(_, [fmt_arg]) => Self::Format(FormatArgsExpn::parse(cx, fmt_arg)?),\n+                    ExprKind::Call(_, [fmt_arg]) => Self::Format(fmt_arg),\n                     _ => Self::Empty,\n                 }\n             },\n@@ -304,7 +296,7 @@ fn find_assert_args_inner<'a, const N: usize>(\n     let mut args = ArrayVec::new();\n     let panic_expn = for_each_expr(expr, |e| {\n         if args.is_full() {\n-            match PanicExpn::parse(cx, e) {\n+            match PanicExpn::parse(e) {\n                 Some(expn) => ControlFlow::Break(expn),\n                 None => ControlFlow::Continue(Descend::Yes),\n             }\n@@ -391,30 +383,82 @@ pub fn collect_ast_format_args(span: Span, format_args: &FormatArgs) {\n     });\n }\n \n-/// Calls `callback` with an AST [`FormatArgs`] node if one is found\n+/// Calls `callback` with an AST [`FormatArgs`] node if a `format_args` expansion is found as a\n+/// descendant of `expn_id`\n pub fn find_format_args(cx: &LateContext<'_>, start: &Expr<'_>, expn_id: ExpnId, callback: impl FnOnce(&FormatArgs)) {\n     let format_args_expr = for_each_expr(start, |expr| {\n         let ctxt = expr.span.ctxt();\n-        if ctxt == start.span.ctxt() {\n-            ControlFlow::Continue(Descend::Yes)\n-        } else if ctxt.outer_expn().is_descendant_of(expn_id)\n-            && macro_backtrace(expr.span)\n+        if ctxt.outer_expn().is_descendant_of(expn_id) {\n+            if macro_backtrace(expr.span)\n                 .map(|macro_call| cx.tcx.item_name(macro_call.def_id))\n                 .any(|name| matches!(name, sym::const_format_args | sym::format_args | sym::format_args_nl))\n-        {\n-            ControlFlow::Break(expr)\n+            {\n+                ControlFlow::Break(expr)\n+            } else {\n+                ControlFlow::Continue(Descend::Yes)\n+            }\n         } else {\n             ControlFlow::Continue(Descend::No)\n         }\n     });\n \n-    if let Some(format_args_expr) = format_args_expr {\n+    if let Some(expr) = format_args_expr {\n         AST_FORMAT_ARGS.with(|ast_format_args| {\n-            ast_format_args.borrow().get(&format_args_expr.span).map(callback);\n+            ast_format_args.borrow().get(&expr.span).map(callback);\n         });\n     }\n }\n \n+/// Attempt to find the [`rustc_hir::Expr`] that corresponds to the [`FormatArgument`]'s value, if\n+/// it cannot be found it will return the [`rustc_ast::Expr`].\n+pub fn find_format_arg_expr<'hir, 'ast>(\n+    start: &'hir Expr<'hir>,\n+    target: &'ast FormatArgument,\n+) -> Result<&'hir rustc_hir::Expr<'hir>, &'ast rustc_ast::Expr> {\n+    for_each_expr(start, |expr| {\n+        if expr.span == target.expr.span {\n+            ControlFlow::Break(expr)\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    })\n+    .ok_or(&target.expr)\n+}\n+\n+/// Span of the `:` and format specifiers\n+///\n+/// ```ignore\n+/// format!(\"{:.}\"), format!(\"{foo:.}\")\n+///           ^^                  ^^\n+/// ```\n+pub fn format_placeholder_format_span(placeholder: &FormatPlaceholder) -> Option<Span> {\n+    let base = placeholder.span?.data();\n+\n+    // `base.hi` is `{...}|`, subtract 1 byte (the length of '}') so that it points before the closing\n+    // brace `{...|}`\n+    Some(Span::new(\n+        placeholder.argument.span?.hi(),\n+        base.hi - BytePos(1),\n+        base.ctxt,\n+        base.parent,\n+    ))\n+}\n+\n+/// Span covering the format string and values\n+///\n+/// ```ignore\n+/// format(\"{}.{}\", 10, 11)\n+/// //     ^^^^^^^^^^^^^^^\n+/// ```\n+pub fn format_args_inputs_span(format_args: &FormatArgs) -> Span {\n+    match format_args.arguments.explicit_args() {\n+        [] => format_args.span,\n+        [.., last] => format_args\n+            .span\n+            .to(hygiene::walk_chain(last.expr.span, format_args.span.ctxt())),\n+    }\n+}\n+\n /// Returns the [`Span`] of the value at `index` extended to the previous comma, e.g. for the value\n /// `10`\n ///\n@@ -436,251 +480,6 @@ pub fn format_arg_removal_span(format_args: &FormatArgs, index: usize) -> Option\n     Some(current.with_lo(prev.hi()))\n }\n \n-/// The format string doesn't exist in the HIR, so we reassemble it from source code\n-#[derive(Debug)]\n-pub struct FormatString {\n-    /// Span of the whole format string literal, including `[r#]\"`.\n-    pub span: Span,\n-    /// Snippet of the whole format string literal, including `[r#]\"`.\n-    pub snippet: String,\n-    /// If the string is raw `r\"...\"`/`r#\"\"#`, how many `#`s does it have on each side.\n-    pub style: Option<usize>,\n-    /// The unescaped value of the format string, e.g. `\"val \u2013 {}\"` for the literal\n-    /// `\"val \\u{2013} {}\"`.\n-    pub unescaped: String,\n-    /// The format string split by format args like `{..}`.\n-    pub parts: Vec<Symbol>,\n-}\n-\n-impl FormatString {\n-    fn new(cx: &LateContext<'_>, pieces: &Expr<'_>) -> Option<Self> {\n-        // format_args!(r\"a {} b \\\", 1);\n-        //\n-        // expands to\n-        //\n-        // ::core::fmt::Arguments::new_v1(&[\"a \", \" b \\\\\"],\n-        //      &[::core::fmt::ArgumentV1::new_display(&1)]);\n-        //\n-        // where `pieces` is the expression `&[\"a \", \" b \\\\\"]`. It has the span of `r\"a {} b \\\"`\n-        let span = pieces.span;\n-        let snippet = snippet_opt(cx, span)?;\n-\n-        let (inner, style) = match tokenize(&snippet).next()?.kind {\n-            TokenKind::Literal { kind, .. } => {\n-                let style = match kind {\n-                    LiteralKind::Str { .. } => None,\n-                    LiteralKind::RawStr { n_hashes: Some(n), .. } => Some(n.into()),\n-                    _ => return None,\n-                };\n-\n-                let start = style.map_or(1, |n| 2 + n);\n-                let end = snippet.len() - style.map_or(1, |n| 1 + n);\n-\n-                (&snippet[start..end], style)\n-            },\n-            _ => return None,\n-        };\n-\n-        let mode = if style.is_some() {\n-            unescape::Mode::RawStr\n-        } else {\n-            unescape::Mode::Str\n-        };\n-\n-        let mut unescaped = String::with_capacity(inner.len());\n-        // Sometimes the original string comes from a macro which accepts a malformed string, such as in a\n-        // #[display(\"\"somestring)] attribute (accepted by the `displaythis` crate). Reconstructing the\n-        // string from the span will not be possible, so we will just return None here.\n-        let mut unparsable = false;\n-        unescape_literal(inner, mode, &mut |_, ch| match ch {\n-            Ok(ch) => unescaped.push(ch),\n-            Err(e) if !e.is_fatal() => (),\n-            Err(_) => unparsable = true,\n-        });\n-        if unparsable {\n-            return None;\n-        }\n-\n-        let mut parts = Vec::new();\n-        let _: Option<!> = for_each_expr(pieces, |expr| {\n-            if let ExprKind::Lit(lit) = &expr.kind\n-                && let LitKind::Str(symbol, _) = lit.node\n-            {\n-                parts.push(symbol);\n-            }\n-            ControlFlow::Continue(())\n-        });\n-\n-        Some(Self {\n-            span,\n-            snippet,\n-            style,\n-            unescaped,\n-            parts,\n-        })\n-    }\n-}\n-\n-struct FormatArgsValues<'tcx> {\n-    /// Values passed after the format string and implicit captures. `[1, z + 2, x]` for\n-    /// `format!(\"{x} {} {}\", 1, z + 2)`.\n-    value_args: Vec<&'tcx Expr<'tcx>>,\n-    /// Maps an `rt::v1::Argument::position` or an `rt::v1::Count::Param` to its index in\n-    /// `value_args`\n-    pos_to_value_index: Vec<usize>,\n-    /// Used to check if a value is declared inline & to resolve `InnerSpan`s.\n-    format_string_span: SpanData,\n-}\n-\n-impl<'tcx> FormatArgsValues<'tcx> {\n-    fn new_empty(format_string_span: SpanData) -> Self {\n-        Self {\n-            value_args: Vec::new(),\n-            pos_to_value_index: Vec::new(),\n-            format_string_span,\n-        }\n-    }\n-\n-    fn new(args: &'tcx Expr<'tcx>, format_string_span: SpanData) -> Self {\n-        let mut pos_to_value_index = Vec::new();\n-        let mut value_args = Vec::new();\n-        let _: Option<!> = for_each_expr(args, |expr| {\n-            if expr.span.ctxt() == args.span.ctxt() {\n-                // ArgumentV1::new_<format_trait>(<val>)\n-                // ArgumentV1::from_usize(<val>)\n-                if let ExprKind::Call(callee, [val]) = expr.kind\n-                    && let ExprKind::Path(QPath::TypeRelative(ty, _)) = callee.kind\n-                    && let TyKind::Path(QPath::LangItem(LangItem::FormatArgument, _, _)) = ty.kind\n-                {\n-                    let val_idx = if val.span.ctxt() == expr.span.ctxt()\n-                        && let ExprKind::Field(_, field) = val.kind\n-                        && let Ok(idx) = field.name.as_str().parse()\n-                    {\n-                        // tuple index\n-                        idx\n-                    } else {\n-                        // assume the value expression is passed directly\n-                        pos_to_value_index.len()\n-                    };\n-\n-                    pos_to_value_index.push(val_idx);\n-                }\n-                ControlFlow::Continue(Descend::Yes)\n-            } else {\n-                // assume that any expr with a differing span is a value\n-                value_args.push(expr);\n-                ControlFlow::Continue(Descend::No)\n-            }\n-        });\n-\n-        Self {\n-            value_args,\n-            pos_to_value_index,\n-            format_string_span,\n-        }\n-    }\n-}\n-\n-/// The positions of a format argument's value, precision and width\n-///\n-/// A position is an index into the second argument of `Arguments::new_v1[_formatted]`\n-#[derive(Debug, Default, Copy, Clone)]\n-struct ParamPosition {\n-    /// The position stored in `rt::v1::Argument::position`.\n-    value: usize,\n-    /// The position stored in `rt::v1::FormatSpec::width` if it is a `Count::Param`.\n-    width: Option<usize>,\n-    /// The position stored in `rt::v1::FormatSpec::precision` if it is a `Count::Param`.\n-    precision: Option<usize>,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for ParamPosition {\n-    fn visit_expr_field(&mut self, field: &'tcx ExprField<'tcx>) {\n-        match field.ident.name {\n-            sym::position => {\n-                if let ExprKind::Lit(lit) = &field.expr.kind\n-                    && let LitKind::Int(pos, _) = lit.node\n-                {\n-                    self.value = pos as usize;\n-                }\n-            },\n-            sym::precision => {\n-                self.precision = parse_count(field.expr);\n-            },\n-            sym::width => {\n-                self.width = parse_count(field.expr);\n-            },\n-            _ => walk_expr(self, field.expr),\n-        }\n-    }\n-}\n-\n-fn parse_count(expr: &Expr<'_>) -> Option<usize> {\n-    // <::core::fmt::rt::v1::Count>::Param(1usize),\n-    if let ExprKind::Call(ctor, [val]) = expr.kind\n-        && let ExprKind::Path(QPath::TypeRelative(_, path)) = ctor.kind\n-            && path.ident.name == sym::Param\n-            && let ExprKind::Lit(lit) = &val.kind\n-            && let LitKind::Int(pos, _) = lit.node\n-    {\n-        Some(pos as usize)\n-    } else {\n-        None\n-    }\n-}\n-\n-/// Parses the `fmt` arg of `Arguments::new_v1_formatted(pieces, args, fmt, _)`\n-fn parse_rt_fmt<'tcx>(fmt_arg: &'tcx Expr<'tcx>) -> Option<impl Iterator<Item = ParamPosition> + 'tcx> {\n-    if let ExprKind::AddrOf(.., array) = fmt_arg.kind\n-        && let ExprKind::Array(specs) = array.kind\n-    {\n-        Some(specs.iter().map(|spec| {\n-            if let ExprKind::Call(f, args) = spec.kind\n-                && let ExprKind::Path(QPath::TypeRelative(ty, f)) = f.kind\n-                && let TyKind::Path(QPath::LangItem(LangItem::FormatPlaceholder, _, _)) = ty.kind\n-                && f.ident.name == sym::new\n-                && let [position, _fill, _align, _flags, precision, width] = args\n-                && let ExprKind::Lit(position) = &position.kind\n-                && let LitKind::Int(position, _) = position.node {\n-                    ParamPosition {\n-                        value: position as usize,\n-                        width: parse_count(width),\n-                        precision: parse_count(precision),\n-                    }\n-            } else {\n-                ParamPosition::default()\n-            }\n-        }))\n-    } else {\n-        None\n-    }\n-}\n-\n-/// `Span::from_inner`, but for `rustc_parse_format`'s `InnerSpan`\n-fn span_from_inner(base: SpanData, inner: rpf::InnerSpan) -> Span {\n-    Span::new(\n-        base.lo + BytePos::from_usize(inner.start),\n-        base.lo + BytePos::from_usize(inner.end),\n-        base.ctxt,\n-        base.parent,\n-    )\n-}\n-\n-/// How a format parameter is used in the format string\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub enum FormatParamKind {\n-    /// An implicit parameter , such as `{}` or `{:?}`.\n-    Implicit,\n-    /// A parameter with an explicit number, e.g. `{1}`, `{0:?}`, or `{:.0$}`\n-    Numbered,\n-    /// A parameter with an asterisk precision. e.g. `{:.*}`.\n-    Starred,\n-    /// A named parameter with a named `value_arg`, such as the `x` in `format!(\"{x}\", x = 1)`.\n-    Named(Symbol),\n-    /// An implicit named parameter, such as the `y` in `format!(\"{y}\")`.\n-    NamedInline(Symbol),\n-}\n-\n /// Where a format parameter is being used in the format string\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum FormatParamUsage {\n@@ -692,467 +491,6 @@ pub enum FormatParamUsage {\n     Precision,\n }\n \n-/// A `FormatParam` is any place in a `FormatArgument` that refers to a supplied value, e.g.\n-///\n-/// ```\n-/// let precision = 2;\n-/// format!(\"{:.precision$}\", 0.1234);\n-/// ```\n-///\n-/// has two `FormatParam`s, a [`FormatParamKind::Implicit`] `.kind` with a `.value` of `0.1234`\n-/// and a [`FormatParamKind::NamedInline(\"precision\")`] `.kind` with a `.value` of `2`\n-#[derive(Debug, Copy, Clone)]\n-pub struct FormatParam<'tcx> {\n-    /// The expression this parameter refers to.\n-    pub value: &'tcx Expr<'tcx>,\n-    /// How this parameter refers to its `value`.\n-    pub kind: FormatParamKind,\n-    /// Where this format param is being used - argument/width/precision\n-    pub usage: FormatParamUsage,\n-    /// Span of the parameter, may be zero width. Includes the whitespace of implicit parameters.\n-    ///\n-    /// ```text\n-    /// format!(\"{}, {  }, {0}, {name}\", ...);\n-    ///          ^    ~~    ~    ~~~~\n-    /// ```\n-    pub span: Span,\n-}\n-\n-impl<'tcx> FormatParam<'tcx> {\n-    fn new(\n-        mut kind: FormatParamKind,\n-        usage: FormatParamUsage,\n-        position: usize,\n-        inner: rpf::InnerSpan,\n-        values: &FormatArgsValues<'tcx>,\n-    ) -> Option<Self> {\n-        let value_index = *values.pos_to_value_index.get(position)?;\n-        let value = *values.value_args.get(value_index)?;\n-        let span = span_from_inner(values.format_string_span, inner);\n-\n-        // if a param is declared inline, e.g. `format!(\"{x}\")`, the generated expr's span points\n-        // into the format string\n-        if let FormatParamKind::Named(name) = kind && values.format_string_span.contains(value.span.data()) {\n-            kind = FormatParamKind::NamedInline(name);\n-        }\n-\n-        Some(Self {\n-            value,\n-            kind,\n-            usage,\n-            span,\n-        })\n-    }\n-}\n-\n-/// Used by [width](https://doc.rust-lang.org/std/fmt/#width) and\n-/// [precision](https://doc.rust-lang.org/std/fmt/#precision) specifiers.\n-#[derive(Debug, Copy, Clone)]\n-pub enum Count<'tcx> {\n-    /// Specified with a literal number, stores the value.\n-    Is(usize, Span),\n-    /// Specified using `$` and `*` syntaxes. The `*` format is still considered to be\n-    /// `FormatParamKind::Numbered`.\n-    Param(FormatParam<'tcx>),\n-    /// Not specified.\n-    Implied(Option<Span>),\n-}\n-\n-impl<'tcx> Count<'tcx> {\n-    fn new(\n-        usage: FormatParamUsage,\n-        count: rpf::Count<'_>,\n-        position: Option<usize>,\n-        inner: Option<rpf::InnerSpan>,\n-        values: &FormatArgsValues<'tcx>,\n-    ) -> Option<Self> {\n-        let span = inner.map(|inner| span_from_inner(values.format_string_span, inner));\n-\n-        Some(match count {\n-            rpf::Count::CountIs(val) => Self::Is(val, span?),\n-            rpf::Count::CountIsName(name, _) => Self::Param(FormatParam::new(\n-                FormatParamKind::Named(Symbol::intern(name)),\n-                usage,\n-                position?,\n-                inner?,\n-                values,\n-            )?),\n-            rpf::Count::CountIsParam(_) => Self::Param(FormatParam::new(\n-                FormatParamKind::Numbered,\n-                usage,\n-                position?,\n-                inner?,\n-                values,\n-            )?),\n-            rpf::Count::CountIsStar(_) => Self::Param(FormatParam::new(\n-                FormatParamKind::Starred,\n-                usage,\n-                position?,\n-                inner?,\n-                values,\n-            )?),\n-            rpf::Count::CountImplied => Self::Implied(span),\n-        })\n-    }\n-\n-    pub fn is_implied(self) -> bool {\n-        matches!(self, Count::Implied(_))\n-    }\n-\n-    pub fn param(self) -> Option<FormatParam<'tcx>> {\n-        match self {\n-            Count::Param(param) => Some(param),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn span(self) -> Option<Span> {\n-        match self {\n-            Count::Is(_, span) => Some(span),\n-            Count::Param(param) => Some(param.span),\n-            Count::Implied(span) => span,\n-        }\n-    }\n-}\n-\n-/// Specification for the formatting of an argument in the format string. See\n-/// <https://doc.rust-lang.org/std/fmt/index.html#formatting-parameters> for the precise meanings.\n-#[derive(Debug)]\n-pub struct FormatSpec<'tcx> {\n-    /// Optionally specified character to fill alignment with.\n-    pub fill: Option<char>,\n-    /// Optionally specified alignment.\n-    pub align: Alignment,\n-    /// Whether all flag options are set to default (no flags specified).\n-    pub no_flags: bool,\n-    /// Represents either the maximum width or the integer precision.\n-    pub precision: Count<'tcx>,\n-    /// The minimum width, will be padded according to `width`/`align`\n-    pub width: Count<'tcx>,\n-    /// The formatting trait used by the argument, e.g. `sym::Display` for `{}`, `sym::Debug` for\n-    /// `{:?}`.\n-    pub r#trait: Symbol,\n-    pub trait_span: Option<Span>,\n-}\n-\n-impl<'tcx> FormatSpec<'tcx> {\n-    fn new(spec: rpf::FormatSpec<'_>, positions: ParamPosition, values: &FormatArgsValues<'tcx>) -> Option<Self> {\n-        Some(Self {\n-            fill: spec.fill,\n-            align: spec.align,\n-            no_flags: spec.sign.is_none() && !spec.alternate && !spec.zero_pad && spec.debug_hex.is_none(),\n-            precision: Count::new(\n-                FormatParamUsage::Precision,\n-                spec.precision,\n-                positions.precision,\n-                spec.precision_span,\n-                values,\n-            )?,\n-            width: Count::new(\n-                FormatParamUsage::Width,\n-                spec.width,\n-                positions.width,\n-                spec.width_span,\n-                values,\n-            )?,\n-            r#trait: match spec.ty {\n-                \"\" => sym::Display,\n-                \"?\" => sym::Debug,\n-                \"o\" => sym!(Octal),\n-                \"x\" => sym!(LowerHex),\n-                \"X\" => sym!(UpperHex),\n-                \"p\" => sym::Pointer,\n-                \"b\" => sym!(Binary),\n-                \"e\" => sym!(LowerExp),\n-                \"E\" => sym!(UpperExp),\n-                _ => return None,\n-            },\n-            trait_span: spec\n-                .ty_span\n-                .map(|span| span_from_inner(values.format_string_span, span)),\n-        })\n-    }\n-\n-    /// Returns true if this format spec is unchanged from the default. e.g. returns true for `{}`,\n-    /// `{foo}` and `{2}`, but false for `{:?}`, `{foo:5}` and `{3:.5}`\n-    pub fn is_default(&self) -> bool {\n-        self.r#trait == sym::Display && self.is_default_for_trait()\n-    }\n-\n-    /// Has no other formatting specifiers than setting the format trait. returns true for `{}`,\n-    /// `{foo}`, `{:?}`, but false for `{foo:5}`, `{3:.5?}`\n-    pub fn is_default_for_trait(&self) -> bool {\n-        self.width.is_implied() && self.precision.is_implied() && self.align == Alignment::AlignUnknown && self.no_flags\n-    }\n-}\n-\n-/// A format argument, such as `{}`, `{foo:?}`.\n-#[derive(Debug)]\n-pub struct FormatArg<'tcx> {\n-    /// The parameter the argument refers to.\n-    pub param: FormatParam<'tcx>,\n-    /// How to format `param`.\n-    pub format: FormatSpec<'tcx>,\n-    /// span of the whole argument, `{..}`.\n-    pub span: Span,\n-}\n-\n-impl<'tcx> FormatArg<'tcx> {\n-    /// Span of the `:` and format specifiers\n-    ///\n-    /// ```ignore\n-    /// format!(\"{:.}\"), format!(\"{foo:.}\")\n-    ///           ^^                  ^^\n-    /// ```\n-    pub fn format_span(&self) -> Span {\n-        let base = self.span.data();\n-\n-        // `base.hi` is `{...}|`, subtract 1 byte (the length of '}') so that it points before the closing\n-        // brace `{...|}`\n-        Span::new(self.param.span.hi(), base.hi - BytePos(1), base.ctxt, base.parent)\n-    }\n-}\n-\n-/// A parsed `format_args!` expansion.\n-#[derive(Debug)]\n-pub struct FormatArgsExpn<'tcx> {\n-    /// The format string literal.\n-    pub format_string: FormatString,\n-    /// The format arguments, such as `{:?}`.\n-    pub args: Vec<FormatArg<'tcx>>,\n-    /// Has an added newline due to `println!()`/`writeln!()`/etc. The last format string part will\n-    /// include this added newline.\n-    pub newline: bool,\n-    /// Spans of the commas between the format string and explicit values, excluding any trailing\n-    /// comma\n-    ///\n-    /// ```ignore\n-    /// format!(\"..\", 1, 2, 3,)\n-    /// //          ^  ^  ^\n-    /// ```\n-    comma_spans: Vec<Span>,\n-    /// Explicit values passed after the format string, ignoring implicit captures. `[1, z + 2]` for\n-    /// `format!(\"{x} {} {y}\", 1, z + 2)`.\n-    explicit_values: Vec<&'tcx Expr<'tcx>>,\n-}\n-\n-impl<'tcx> FormatArgsExpn<'tcx> {\n-    /// Gets the spans of the commas inbetween the format string and explicit args, not including\n-    /// any trailing comma\n-    ///\n-    /// ```ignore\n-    /// format!(\"{} {}\", a, b)\n-    /// //             ^  ^\n-    /// ```\n-    ///\n-    /// Ensures that the format string and values aren't coming from a proc macro that sets the\n-    /// output span to that of its input\n-    fn comma_spans(cx: &LateContext<'_>, explicit_values: &[&Expr<'_>], fmt_span: Span) -> Option<Vec<Span>> {\n-        // `format!(\"{} {} {c}\", \"one\", \"two\", c = \"three\")`\n-        //                       ^^^^^  ^^^^^      ^^^^^^^\n-        let value_spans = explicit_values\n-            .iter()\n-            .map(|val| hygiene::walk_chain(val.span, fmt_span.ctxt()));\n-\n-        // `format!(\"{} {} {c}\", \"one\", \"two\", c = \"three\")`\n-        //                     ^^     ^^     ^^^^^^\n-        let between_spans = once(fmt_span)\n-            .chain(value_spans)\n-            .tuple_windows()\n-            .map(|(start, end)| start.between(end));\n-\n-        let mut comma_spans = Vec::new();\n-        for between_span in between_spans {\n-            let mut offset = 0;\n-            let mut seen_comma = false;\n-\n-            for token in tokenize(&snippet_opt(cx, between_span)?) {\n-                match token.kind {\n-                    TokenKind::LineComment { .. } | TokenKind::BlockComment { .. } | TokenKind::Whitespace => {},\n-                    TokenKind::Comma if !seen_comma => {\n-                        seen_comma = true;\n-\n-                        let base = between_span.data();\n-                        comma_spans.push(Span::new(\n-                            base.lo + BytePos(offset),\n-                            base.lo + BytePos(offset + 1),\n-                            base.ctxt,\n-                            base.parent,\n-                        ));\n-                    },\n-                    // named arguments, `start_val, name = end_val`\n-                    //                            ^^^^^^^^^ between_span\n-                    TokenKind::Ident | TokenKind::Eq if seen_comma => {},\n-                    // An unexpected token usually indicates the format string or a value came from a proc macro output\n-                    // that sets the span of its output to an input, e.g. `println!(some_proc_macro!(\"input\"), ..)` that\n-                    // emits a string literal with the span set to that of `\"input\"`\n-                    _ => return None,\n-                }\n-                offset += token.len;\n-            }\n-\n-            if !seen_comma {\n-                return None;\n-            }\n-        }\n-\n-        Some(comma_spans)\n-    }\n-\n-    pub fn parse(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<Self> {\n-        let macro_name = macro_backtrace(expr.span)\n-            .map(|macro_call| cx.tcx.item_name(macro_call.def_id))\n-            .find(|&name| matches!(name, sym::const_format_args | sym::format_args | sym::format_args_nl))?;\n-        let newline = macro_name == sym::format_args_nl;\n-\n-        // ::core::fmt::Arguments::new_const(pieces)\n-        // ::core::fmt::Arguments::new_v1(pieces, args)\n-        // ::core::fmt::Arguments::new_v1_formatted(pieces, args, fmt, _unsafe_arg)\n-        if let ExprKind::Call(callee, [pieces, rest @ ..]) = expr.kind\n-            && let ExprKind::Path(QPath::TypeRelative(ty, seg)) = callee.kind\n-            && let TyKind::Path(QPath::LangItem(LangItem::FormatArguments, _, _)) = ty.kind\n-            && matches!(seg.ident.as_str(), \"new_const\" | \"new_v1\" | \"new_v1_formatted\")\n-        {\n-            let format_string = FormatString::new(cx, pieces)?;\n-\n-            let mut parser = rpf::Parser::new(\n-                &format_string.unescaped,\n-                format_string.style,\n-                Some(format_string.snippet.clone()),\n-                // `format_string.unescaped` does not contain the appended newline\n-                false,\n-                rpf::ParseMode::Format,\n-            );\n-\n-            let parsed_args = parser\n-                .by_ref()\n-                .filter_map(|piece| match piece {\n-                    rpf::Piece::NextArgument(a) => Some(a),\n-                    rpf::Piece::String(_) => None,\n-                })\n-                .collect_vec();\n-            if !parser.errors.is_empty() {\n-                return None;\n-            }\n-\n-            let positions = if let Some(fmt_arg) = rest.get(1) {\n-                // If the argument contains format specs, `new_v1_formatted(_, _, fmt, _)`, parse\n-                // them.\n-\n-                Either::Left(parse_rt_fmt(fmt_arg)?)\n-            } else {\n-                // If no format specs are given, the positions are in the given order and there are\n-                // no `precision`/`width`s to consider.\n-\n-                Either::Right((0..).map(|n| ParamPosition {\n-                    value: n,\n-                    width: None,\n-                    precision: None,\n-                }))\n-            };\n-\n-            let values = if let Some(args) = rest.first() {\n-                FormatArgsValues::new(args, format_string.span.data())\n-            } else {\n-                FormatArgsValues::new_empty(format_string.span.data())\n-            };\n-\n-            let args = izip!(positions, parsed_args, parser.arg_places)\n-                .map(|(position, parsed_arg, arg_span)| {\n-                    Some(FormatArg {\n-                        param: FormatParam::new(\n-                            match parsed_arg.position {\n-                                rpf::Position::ArgumentImplicitlyIs(_) => FormatParamKind::Implicit,\n-                                rpf::Position::ArgumentIs(_) => FormatParamKind::Numbered,\n-                                // NamedInline is handled by `FormatParam::new()`\n-                                rpf::Position::ArgumentNamed(name) => FormatParamKind::Named(Symbol::intern(name)),\n-                            },\n-                            FormatParamUsage::Argument,\n-                            position.value,\n-                            parsed_arg.position_span,\n-                            &values,\n-                        )?,\n-                        format: FormatSpec::new(parsed_arg.format, position, &values)?,\n-                        span: span_from_inner(values.format_string_span, arg_span),\n-                    })\n-                })\n-                .collect::<Option<Vec<_>>>()?;\n-\n-            let mut explicit_values = values.value_args;\n-            // remove values generated for implicitly captured vars\n-            let len = explicit_values\n-                .iter()\n-                .take_while(|val| !format_string.span.contains(val.span))\n-                .count();\n-            explicit_values.truncate(len);\n-\n-            let comma_spans = Self::comma_spans(cx, &explicit_values, format_string.span)?;\n-\n-            Some(Self {\n-                format_string,\n-                args,\n-                newline,\n-                comma_spans,\n-                explicit_values,\n-            })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn find_nested(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, expn_id: ExpnId) -> Option<Self> {\n-        for_each_expr(expr, |e| {\n-            let e_ctxt = e.span.ctxt();\n-            if e_ctxt == expr.span.ctxt() {\n-                ControlFlow::Continue(Descend::Yes)\n-            } else if e_ctxt.outer_expn().is_descendant_of(expn_id) {\n-                if let Some(args) = FormatArgsExpn::parse(cx, e) {\n-                    ControlFlow::Break(args)\n-                } else {\n-                    ControlFlow::Continue(Descend::No)\n-                }\n-            } else {\n-                ControlFlow::Continue(Descend::No)\n-            }\n-        })\n-    }\n-\n-    /// Source callsite span of all inputs\n-    pub fn inputs_span(&self) -> Span {\n-        match *self.explicit_values {\n-            [] => self.format_string.span,\n-            [.., last] => self\n-                .format_string\n-                .span\n-                .to(hygiene::walk_chain(last.span, self.format_string.span.ctxt())),\n-        }\n-    }\n-\n-    /// Get the span of a value expanded to the previous comma, e.g. for the value `10`\n-    ///\n-    /// ```ignore\n-    /// format(\"{}.{}\", 10, 11)\n-    /// //            ^^^^\n-    /// ```\n-    pub fn value_with_prev_comma_span(&self, value_id: HirId) -> Option<Span> {\n-        for (comma_span, value) in zip(&self.comma_spans, &self.explicit_values) {\n-            if value.hir_id == value_id {\n-                return Some(comma_span.to(hygiene::walk_chain(value.span, comma_span.ctxt())));\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    /// Iterator of all format params, both values and those referenced by `width`/`precision`s.\n-    pub fn params(&'tcx self) -> impl Iterator<Item = FormatParam<'tcx>> {\n-        self.args\n-            .iter()\n-            .flat_map(|arg| [Some(arg.param), arg.format.precision.param(), arg.format.width.param()])\n-            .flatten()\n-    }\n-}\n-\n /// A node with a `HirId` and a `Span`\n pub trait HirNode {\n     fn hir_id(&self) -> HirId;"}, {"sha": "9be2d0eae80aad31bcc3be248e1dde9403f3d881", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -23,6 +23,7 @@ pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CORE_ITER_CLONED: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"cloned\"];\n pub const CORE_ITER_COPIED: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"copied\"];\n pub const CORE_ITER_FILTER: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"filter\"];\n+pub const CORE_RESULT_OK_METHOD: [&str; 4] = [\"core\", \"result\", \"Result\", \"ok\"];\n pub const CSTRING_AS_C_STR: [&str; 5] = [\"alloc\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n@@ -113,6 +114,7 @@ pub const STDERR: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stderr\"];\n pub const STDOUT: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stdout\"];\n pub const CONVERT_IDENTITY: [&str; 3] = [\"core\", \"convert\", \"identity\"];\n pub const STD_FS_CREATE_DIR: [&str; 3] = [\"std\", \"fs\", \"create_dir\"];\n+pub const STD_IO_LINES: [&str; 3] = [\"std\", \"io\", \"Lines\"];\n pub const STD_IO_SEEK: [&str; 3] = [\"std\", \"io\", \"Seek\"];\n pub const STD_IO_SEEK_FROM_CURRENT: [&str; 4] = [\"std\", \"io\", \"SeekFrom\", \"Current\"];\n pub const STD_IO_SEEKFROM_START: [&str; 4] = [\"std\", \"io\", \"SeekFrom\", \"Start\"];"}, {"sha": "9449f0b55674dbf0a8560cd24342e075411bd2be", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -541,9 +541,25 @@ pub fn same_type_and_consts<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n pub fn is_uninit_value_valid_for_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     cx.tcx\n         .check_validity_requirement((ValidityRequirement::Uninit, cx.param_env.and(ty)))\n-        // For types containing generic parameters we cannot get a layout to check.\n-        // Therefore, we are conservative and assume that they don't allow uninit.\n-        .unwrap_or(false)\n+        .unwrap_or_else(|_| is_uninit_value_valid_for_ty_fallback(cx, ty))\n+}\n+\n+/// A fallback for polymorphic types, which are not supported by `check_validity_requirement`.\n+fn is_uninit_value_valid_for_ty_fallback<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match *ty.kind() {\n+        // The array length may be polymorphic, let's try the inner type.\n+        ty::Array(component, _) => is_uninit_value_valid_for_ty(cx, component),\n+        // Peek through tuples and try their fallbacks.\n+        ty::Tuple(types) => types.iter().all(|ty| is_uninit_value_valid_for_ty(cx, ty)),\n+        // Unions are always fine right now.\n+        // This includes MaybeUninit, the main way people use uninitialized memory.\n+        // For ADTs, we could look at all fields just like for tuples, but that's potentially\n+        // exponential, so let's avoid doing that for now. Code doing that is sketchy enough to\n+        // just use an `#[allow()]`.\n+        ty::Adt(adt, _) => adt.is_union(),\n+        // For the rest, conservatively assume that they cannot be uninit.\n+        _ => false,\n+    }\n }\n \n /// Gets an iterator over all predicates which apply to the given item."}, {"sha": "ffb99cde4f8690facf16da165cef8d8f802d3951", "filename": "etc/relicense/RELICENSE_DOCUMENTATION.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/etc%2Frelicense%2FRELICENSE_DOCUMENTATION.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/etc%2Frelicense%2FRELICENSE_DOCUMENTATION.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/etc%2Frelicense%2FRELICENSE_DOCUMENTATION.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -35,7 +35,7 @@ relicensing are archived on GitHub. We also have saved Wayback Machine copies of\n \n The usernames of commenters on these issues can be found in relicense_comments.txt\n \n-There are a couple people in relicense_comments.txt who are not found in contributors.txt:\n+There are a few people in relicense_comments.txt who are not found in contributors.txt:\n \n - @EpocSquadron has [made minor text contributions to the\n   README](https://github.com/rust-lang/rust-clippy/commits?author=EpocSquadron) which have since been overwritten, and\n@@ -55,7 +55,7 @@ There are a couple people in relicense_comments.txt who are not found in contrib\n   we rewrote (see below)\n \n \n-Two of these contributors had nonminor contributions (#2184, #427) requiring a rewrite, carried out in #3251\n+Two of these contributors had non-minor contributions (#2184, #427) requiring a rewrite, carried out in #3251\n ([archive](http://web.archive.org/web/20181005192411/https://github.com/rust-lang-nursery/rust-clippy/pull/3251),\n [screenshot](https://user-images.githubusercontent.com/1617736/46573515-5cb69580-c94b-11e8-86e5-b456452121b2.png))\n "}, {"sha": "faf3ce9093a21c29601ddc623ff3518188e6005a", "filename": "lintcheck/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/lintcheck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/lintcheck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2FREADME.md?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -16,7 +16,7 @@ or\n cargo lintcheck\n ```\n \n-By default the logs will be saved into\n+By default, the logs will be saved into\n `lintcheck-logs/lintcheck_crates_logs.txt`.\n \n You can set a custom sources.toml by adding `--crates-toml custom.toml` or using"}, {"sha": "91e8ccea1f4344612babefda4c00ed919222e227", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2023-03-24\"\n+channel = \"nightly-2023-04-06\"\n components = [\"cargo\", \"llvm-tools\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "718bc41fb9924c751c64ce7879f89d427a146cc9", "filename": "src/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -130,7 +130,7 @@ impl rustc_driver::Callbacks for ClippyCallbacks {\n     #[allow(rustc::bad_opt_access)]\n     fn config(&mut self, config: &mut interface::Config) {\n         let conf_path = clippy_lints::lookup_conf_file();\n-        let conf_path_string = if let Ok(Some(path)) = &conf_path {\n+        let conf_path_string = if let Ok((Some(path), _)) = &conf_path {\n             path.to_str().map(String::from)\n         } else {\n             None"}, {"sha": "aa1b3c638a036ba0a9e62a9aeb4c97526b258f12", "filename": "tests/ui-cargo/multiple_config_files/warn/src/main.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fsrc%2Fmain.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,2 +1,4 @@\n-Using config file `$SRC_DIR/.clippy.toml`\n-Warning: `$SRC_DIR/clippy.toml` will be ignored.\n+warning: using config file `$SRC_DIR/.clippy.toml`, `$SRC_DIR/clippy.toml` will be ignored\n+\n+warning: 1 warning emitted\n+"}, {"sha": "1be0cda12fc11213b304bdfad651c7649c695667", "filename": "tests/ui-toml/allow_mixed_uninlined_format_args/uninlined_format_args.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-toml%2Fallow_mixed_uninlined_format_args%2Funinlined_format_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-toml%2Fallow_mixed_uninlined_format_args%2Funinlined_format_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fallow_mixed_uninlined_format_args%2Funinlined_format_args.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -11,29 +11,29 @@ LL -     println!(\"val='{}'\", local_i32);\n LL +     println!(\"val='{local_i32}'\");\n    |\n \n-error: literal with an empty format string\n-  --> $DIR/uninlined_format_args.rs:10:35\n+error: variables can be used directly in the `format!` string\n+  --> $DIR/uninlined_format_args.rs:10:5\n    |\n LL |     println!(\"Hello {} is {:.*}\", \"x\", local_i32, local_f64);\n-   |                                   ^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `-D clippy::print-literal` implied by `-D warnings`\n-help: try this\n+help: change this to\n    |\n LL -     println!(\"Hello {} is {:.*}\", \"x\", local_i32, local_f64);\n-LL +     println!(\"Hello x is {:.*}\", local_i32, local_f64);\n+LL +     println!(\"Hello {} is {local_f64:.local_i32$}\", \"x\");\n    |\n \n-error: variables can be used directly in the `format!` string\n-  --> $DIR/uninlined_format_args.rs:10:5\n+error: literal with an empty format string\n+  --> $DIR/uninlined_format_args.rs:10:35\n    |\n LL |     println!(\"Hello {} is {:.*}\", \"x\", local_i32, local_f64);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                   ^^^\n    |\n-help: change this to\n+   = note: `-D clippy::print-literal` implied by `-D warnings`\n+help: try this\n    |\n LL -     println!(\"Hello {} is {:.*}\", \"x\", local_i32, local_f64);\n-LL +     println!(\"Hello {} is {local_f64:.local_i32$}\", \"x\");\n+LL +     println!(\"Hello x is {:.*}\", local_i32, local_f64);\n    |\n \n error: variables can be used directly in the `format!` string"}, {"sha": "5f304987aa94a4e34d506e82a7ae7bf3c0111ce0", "filename": "tests/ui-toml/extra_unused_type_parameters/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fclippy.toml?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1 @@\n+avoid-breaking-exported-api = true"}, {"sha": "5655232455cb784eb653b0017a8f2c39fc38772d", "filename": "tests/ui-toml/extra_unused_type_parameters/extra_unused_type_parameters.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fextra_unused_type_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fextra_unused_type_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fextra_unused_type_parameters%2Fextra_unused_type_parameters.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,9 @@\n+pub struct S;\n+\n+impl S {\n+    pub fn exported_fn<T>() {\n+        unimplemented!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "61bb17fdf6bdb4c8b3f85a400a1bce7dff4f2486", "filename": "tests/ui-toml/large_futures/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-toml%2Flarge_futures%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-toml%2Flarge_futures%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Flarge_futures%2Fclippy.toml?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1 @@\n+future-size-threshold = 1024"}, {"sha": "4158df8b5ff55ad8f1acc72f8fb022d19f015668", "filename": "tests/ui-toml/large_futures/large_futures.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-toml%2Flarge_futures%2Flarge_futures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-toml%2Flarge_futures%2Flarge_futures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Flarge_futures%2Flarge_futures.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,27 @@\n+#![warn(clippy::large_futures)]\n+\n+fn main() {}\n+\n+pub async fn should_warn() {\n+    let x = [0u8; 1024];\n+    async {}.await;\n+    dbg!(x);\n+}\n+\n+pub async fn should_not_warn() {\n+    let x = [0u8; 1020];\n+    async {}.await;\n+    dbg!(x);\n+}\n+\n+pub async fn bar() {\n+    should_warn().await;\n+\n+    async {\n+        let x = [0u8; 1024];\n+        dbg!(x);\n+    }\n+    .await;\n+\n+    should_not_warn().await;\n+}"}, {"sha": "b92734de2f08c7ff93861caf8b8e1d30e32ecd3d", "filename": "tests/ui-toml/large_futures/large_futures.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-toml%2Flarge_futures%2Flarge_futures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-toml%2Flarge_futures%2Flarge_futures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Flarge_futures%2Flarge_futures.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,10 @@\n+error: large future with a size of 1026 bytes\n+  --> $DIR/large_futures.rs:18:5\n+   |\n+LL |     should_warn().await;\n+   |     ^^^^^^^^^^^^^ help: consider `Box::pin` on it: `Box::pin(should_warn())`\n+   |\n+   = note: `-D clippy::large-futures` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "8447c31722dd015249440af39faddafc7cd125e3", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -24,6 +24,7 @@ error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown fie\n            enforced-import-renames\n            enum-variant-name-threshold\n            enum-variant-size-threshold\n+           future-size-threshold\n            ignore-interior-mutability\n            large-error-threshold\n            literal-representation-threshold"}, {"sha": "3c06676d7228a4a8a2a52bfb12f6b96333895948", "filename": "tests/ui/arithmetic_side_effects.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Farithmetic_side_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Farithmetic_side_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Farithmetic_side_effects.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -425,4 +425,8 @@ pub fn integer_arithmetic() {\n     i ^= i;\n }\n \n+pub fn issue_10583(a: u16) -> u16 {\n+    10 / a\n+}\n+\n fn main() {}"}, {"sha": "2c8ee2884e7328bc140f50166d481f38a4d02209", "filename": "tests/ui/arithmetic_side_effects.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Farithmetic_side_effects.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Farithmetic_side_effects.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Farithmetic_side_effects.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -576,6 +576,12 @@ error: arithmetic operation that can potentially result in unexpected side-effec\n LL |     i * 2;\n    |     ^^^^^\n \n+error: arithmetic operation that can potentially result in unexpected side-effects\n+  --> $DIR/arithmetic_side_effects.rs:394:5\n+   |\n+LL |     1 % i / 2;\n+   |     ^^^^^\n+\n error: arithmetic operation that can potentially result in unexpected side-effects\n   --> $DIR/arithmetic_side_effects.rs:395:5\n    |\n@@ -642,5 +648,11 @@ error: arithmetic operation that can potentially result in unexpected side-effec\n LL |     i %= var2;\n    |     ^^^^^^^^^\n \n-error: aborting due to 107 previous errors\n+error: arithmetic operation that can potentially result in unexpected side-effects\n+  --> $DIR/arithmetic_side_effects.rs:429:5\n+   |\n+LL |     10 / a\n+   |     ^^^^^^\n+\n+error: aborting due to 109 previous errors\n "}, {"sha": "3d5beab1eff1ce1c6f0cd394270c9634c17bcd47", "filename": "tests/ui/auxiliary/proc_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fauxiliary%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fauxiliary%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fproc_macros.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -63,7 +63,7 @@ fn group_with_span(delimiter: Delimiter, stream: TokenStream, span: Span) -> Gro\n /// Token used to escape the following token from the macro's span rules.\n const ESCAPE_CHAR: char = '$';\n \n-/// Takes a single token followed by a sequence tokens. Returns the sequence of tokens with their\n+/// Takes a single token followed by a sequence of tokens. Returns the sequence of tokens with their\n /// span set to that of the first token. Tokens may be escaped with either `#ident` or `#(tokens)`.\n #[proc_macro]\n pub fn with_span(input: TokenStream) -> TokenStream {"}, {"sha": "a86b85706a345f7b4da741d7fb549a9a6eff7cb2", "filename": "tests/ui/cast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -29,6 +29,12 @@ fn main() {\n     1f64 as isize;\n     1f64 as usize;\n     1f32 as u32 as u16;\n+    {\n+        let _x: i8 = 1i32 as _;\n+        1f32 as i32;\n+        1f64 as i32;\n+        1f32 as u8;\n+    }\n     // Test clippy::cast_possible_wrap\n     1u8 as i8;\n     1u16 as i16;"}, {"sha": "65ecf1aa37aaad744a9ba13f6b7c17e449fdfd9e", "filename": "tests/ui/cast.stderr", "status": "modified", "additions": 65, "deletions": 47, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fcast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fcast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -44,10 +44,6 @@ LL |     1f32 as i32;\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n    = note: `-D clippy::cast-possible-truncation` implied by `-D warnings`\n-help: ... or use `try_from` and handle the error accordingly\n-   |\n-LL |     i32::try_from(1f32);\n-   |     ~~~~~~~~~~~~~~~~~~~\n \n error: casting `f32` to `u32` may truncate the value\n   --> $DIR/cast.rs:25:5\n@@ -56,10 +52,6 @@ LL |     1f32 as u32;\n    |     ^^^^^^^^^^^\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n-help: ... or use `try_from` and handle the error accordingly\n-   |\n-LL |     u32::try_from(1f32);\n-   |     ~~~~~~~~~~~~~~~~~~~\n \n error: casting `f32` to `u32` may lose the sign of the value\n   --> $DIR/cast.rs:25:5\n@@ -76,10 +68,6 @@ LL |     1f64 as f32;\n    |     ^^^^^^^^^^^\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n-help: ... or use `try_from` and handle the error accordingly\n-   |\n-LL |     f32::try_from(1f64);\n-   |     ~~~~~~~~~~~~~~~~~~~\n \n error: casting `i32` to `i8` may truncate the value\n   --> $DIR/cast.rs:27:5\n@@ -112,10 +100,6 @@ LL |     1f64 as isize;\n    |     ^^^^^^^^^^^^^\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n-help: ... or use `try_from` and handle the error accordingly\n-   |\n-LL |     isize::try_from(1f64);\n-   |     ~~~~~~~~~~~~~~~~~~~~~\n \n error: casting `f64` to `usize` may truncate the value\n   --> $DIR/cast.rs:30:5\n@@ -124,10 +108,6 @@ LL |     1f64 as usize;\n    |     ^^^^^^^^^^^^^\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n-help: ... or use `try_from` and handle the error accordingly\n-   |\n-LL |     usize::try_from(1f64);\n-   |     ~~~~~~~~~~~~~~~~~~~~~\n \n error: casting `f64` to `usize` may lose the sign of the value\n   --> $DIR/cast.rs:30:5\n@@ -154,63 +134,101 @@ LL |     1f32 as u32 as u16;\n    |     ^^^^^^^^^^^\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n-help: ... or use `try_from` and handle the error accordingly\n-   |\n-LL |     u32::try_from(1f32) as u16;\n-   |     ~~~~~~~~~~~~~~~~~~~\n \n error: casting `f32` to `u32` may lose the sign of the value\n   --> $DIR/cast.rs:31:5\n    |\n LL |     1f32 as u32 as u16;\n    |     ^^^^^^^^^^^\n \n+error: casting `i32` to `i8` may truncate the value\n+  --> $DIR/cast.rs:33:22\n+   |\n+LL |         let _x: i8 = 1i32 as _;\n+   |                      ^^^^^^^^^\n+   |\n+   = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n+help: ... or use `try_from` and handle the error accordingly\n+   |\n+LL |         let _x: i8 = 1i32.try_into();\n+   |                      ~~~~~~~~~~~~~~~\n+\n+error: casting `f32` to `i32` may truncate the value\n+  --> $DIR/cast.rs:34:9\n+   |\n+LL |         1f32 as i32;\n+   |         ^^^^^^^^^^^\n+   |\n+   = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n+\n+error: casting `f64` to `i32` may truncate the value\n+  --> $DIR/cast.rs:35:9\n+   |\n+LL |         1f64 as i32;\n+   |         ^^^^^^^^^^^\n+   |\n+   = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n+\n+error: casting `f32` to `u8` may truncate the value\n+  --> $DIR/cast.rs:36:9\n+   |\n+LL |         1f32 as u8;\n+   |         ^^^^^^^^^^\n+   |\n+   = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n+\n+error: casting `f32` to `u8` may lose the sign of the value\n+  --> $DIR/cast.rs:36:9\n+   |\n+LL |         1f32 as u8;\n+   |         ^^^^^^^^^^\n+\n error: casting `u8` to `i8` may wrap around the value\n-  --> $DIR/cast.rs:33:5\n+  --> $DIR/cast.rs:39:5\n    |\n LL |     1u8 as i8;\n    |     ^^^^^^^^^\n    |\n    = note: `-D clippy::cast-possible-wrap` implied by `-D warnings`\n \n error: casting `u16` to `i16` may wrap around the value\n-  --> $DIR/cast.rs:34:5\n+  --> $DIR/cast.rs:40:5\n    |\n LL |     1u16 as i16;\n    |     ^^^^^^^^^^^\n \n error: casting `u32` to `i32` may wrap around the value\n-  --> $DIR/cast.rs:35:5\n+  --> $DIR/cast.rs:41:5\n    |\n LL |     1u32 as i32;\n    |     ^^^^^^^^^^^\n \n error: casting `u64` to `i64` may wrap around the value\n-  --> $DIR/cast.rs:36:5\n+  --> $DIR/cast.rs:42:5\n    |\n LL |     1u64 as i64;\n    |     ^^^^^^^^^^^\n \n error: casting `usize` to `isize` may wrap around the value\n-  --> $DIR/cast.rs:37:5\n+  --> $DIR/cast.rs:43:5\n    |\n LL |     1usize as isize;\n    |     ^^^^^^^^^^^^^^^\n \n error: casting `i32` to `u32` may lose the sign of the value\n-  --> $DIR/cast.rs:40:5\n+  --> $DIR/cast.rs:46:5\n    |\n LL |     -1i32 as u32;\n    |     ^^^^^^^^^^^^\n \n error: casting `isize` to `usize` may lose the sign of the value\n-  --> $DIR/cast.rs:42:5\n+  --> $DIR/cast.rs:48:5\n    |\n LL |     -1isize as usize;\n    |     ^^^^^^^^^^^^^^^^\n \n error: casting `i64` to `i8` may truncate the value\n-  --> $DIR/cast.rs:109:5\n+  --> $DIR/cast.rs:115:5\n    |\n LL |     (-99999999999i64).min(1) as i8; // should be linted because signed\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -222,7 +240,7 @@ LL |     i8::try_from((-99999999999i64).min(1)); // should be linted because sig\n    |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: casting `u64` to `u8` may truncate the value\n-  --> $DIR/cast.rs:121:5\n+  --> $DIR/cast.rs:127:5\n    |\n LL |     999999u64.clamp(0, 256) as u8; // should still be linted\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -234,7 +252,7 @@ LL |     u8::try_from(999999u64.clamp(0, 256)); // should still be linted\n    |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: casting `main::E2` to `u8` may truncate the value\n-  --> $DIR/cast.rs:142:21\n+  --> $DIR/cast.rs:148:21\n    |\n LL |             let _ = self as u8;\n    |                     ^^^^^^^^^^\n@@ -246,15 +264,15 @@ LL |             let _ = u8::try_from(self);\n    |                     ~~~~~~~~~~~~~~~~~~\n \n error: casting `main::E2::B` to `u8` will truncate the value\n-  --> $DIR/cast.rs:143:21\n+  --> $DIR/cast.rs:149:21\n    |\n LL |             let _ = Self::B as u8;\n    |                     ^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::cast-enum-truncation` implied by `-D warnings`\n \n error: casting `main::E5` to `i8` may truncate the value\n-  --> $DIR/cast.rs:179:21\n+  --> $DIR/cast.rs:185:21\n    |\n LL |             let _ = self as i8;\n    |                     ^^^^^^^^^^\n@@ -266,13 +284,13 @@ LL |             let _ = i8::try_from(self);\n    |                     ~~~~~~~~~~~~~~~~~~\n \n error: casting `main::E5::A` to `i8` will truncate the value\n-  --> $DIR/cast.rs:180:21\n+  --> $DIR/cast.rs:186:21\n    |\n LL |             let _ = Self::A as i8;\n    |                     ^^^^^^^^^^^^^\n \n error: casting `main::E6` to `i16` may truncate the value\n-  --> $DIR/cast.rs:194:21\n+  --> $DIR/cast.rs:200:21\n    |\n LL |             let _ = self as i16;\n    |                     ^^^^^^^^^^^\n@@ -284,7 +302,7 @@ LL |             let _ = i16::try_from(self);\n    |                     ~~~~~~~~~~~~~~~~~~~\n \n error: casting `main::E7` to `usize` may truncate the value on targets with 32-bit wide pointers\n-  --> $DIR/cast.rs:209:21\n+  --> $DIR/cast.rs:215:21\n    |\n LL |             let _ = self as usize;\n    |                     ^^^^^^^^^^^^^\n@@ -296,7 +314,7 @@ LL |             let _ = usize::try_from(self);\n    |                     ~~~~~~~~~~~~~~~~~~~~~\n \n error: casting `main::E10` to `u16` may truncate the value\n-  --> $DIR/cast.rs:250:21\n+  --> $DIR/cast.rs:256:21\n    |\n LL |             let _ = self as u16;\n    |                     ^^^^^^^^^^^\n@@ -308,28 +326,28 @@ LL |             let _ = u16::try_from(self);\n    |                     ~~~~~~~~~~~~~~~~~~~\n \n error: casting `u32` to `u8` may truncate the value\n-  --> $DIR/cast.rs:258:13\n+  --> $DIR/cast.rs:264:13\n    |\n LL |     let c = (q >> 16) as u8;\n    |             ^^^^^^^^^^^^^^^\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n help: ... or use `try_from` and handle the error accordingly\n    |\n-LL |     let c = u8::try_from((q >> 16));\n-   |             ~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     let c = u8::try_from(q >> 16);\n+   |             ~~~~~~~~~~~~~~~~~~~~~\n \n error: casting `u32` to `u8` may truncate the value\n-  --> $DIR/cast.rs:261:13\n+  --> $DIR/cast.rs:267:13\n    |\n LL |     let c = (q / 1000) as u8;\n    |             ^^^^^^^^^^^^^^^^\n    |\n    = help: if this is intentional allow the lint with `#[allow(clippy::cast_possible_truncation)]` ...\n help: ... or use `try_from` and handle the error accordingly\n    |\n-LL |     let c = u8::try_from((q / 1000));\n-   |             ~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |     let c = u8::try_from(q / 1000);\n+   |             ~~~~~~~~~~~~~~~~~~~~~~\n \n-error: aborting due to 36 previous errors\n+error: aborting due to 41 previous errors\n "}, {"sha": "2d9545eeed1972186b3a8b36b1a0ea14be266958", "filename": "tests/ui/clear_with_drain.fixed", "status": "added", "additions": 358, "deletions": 0, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fclear_with_drain.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fclear_with_drain.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclear_with_drain.fixed?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,358 @@\n+// run-rustfix\n+#![allow(unused)]\n+#![warn(clippy::clear_with_drain)]\n+\n+use std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};\n+\n+fn vec_range() {\n+    // Do not lint because iterator is assigned\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(0..v.len());\n+\n+    // Do not lint because iterator is used\n+    let mut v = vec![1, 2, 3];\n+    let n = v.drain(0..v.len()).count();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(usize::MIN..v.len());\n+    let n = iter.count();\n+\n+    // Do lint\n+    let mut v = vec![1, 2, 3];\n+    v.clear();\n+\n+    // Do lint\n+    let mut v = vec![1, 2, 3];\n+    v.clear();\n+}\n+\n+fn vec_range_from() {\n+    // Do not lint because iterator is assigned\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(0..);\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut v = vec![1, 2, 3];\n+    let mut iter = v.drain(0..);\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut v = vec![1, 2, 3];\n+    let next = v.drain(usize::MIN..).next();\n+\n+    // Do lint\n+    let mut v = vec![1, 2, 3];\n+    v.clear();\n+\n+    // Do lint\n+    let mut v = vec![1, 2, 3];\n+    v.clear();\n+}\n+\n+fn vec_range_full() {\n+    // Do not lint because iterator is assigned\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(..);\n+\n+    // Do not lint because iterator is used\n+    let mut v = vec![1, 2, 3];\n+    for x in v.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut v = vec![1, 2, 3];\n+    v.clear();\n+}\n+\n+fn vec_range_to() {\n+    // Do not lint because iterator is assigned\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(..v.len());\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(..v.len());\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut v = vec![1, 2, 3];\n+    v.clear();\n+}\n+\n+fn vec_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(1..);\n+    let mut v = vec![1, 2, 3];\n+    v.drain(1..).max();\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(..v.len() - 1);\n+    let mut v = vec![1, 2, 3];\n+    v.drain(..v.len() - 1).min();\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(1..v.len() - 1);\n+    let mut v = vec![1, 2, 3];\n+    let w: Vec<i8> = v.drain(1..v.len() - 1).collect();\n+}\n+\n+fn vec_deque_range() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(0..deque.len());\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let n = deque.drain(0..deque.len()).count();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(usize::MIN..deque.len());\n+    let n = iter.count();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+}\n+\n+fn vec_deque_range_from() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(0..);\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let mut iter = deque.drain(0..);\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let next = deque.drain(usize::MIN..).next();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+}\n+\n+fn vec_deque_range_full() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..);\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    for x in deque.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+}\n+\n+fn vec_deque_range_to() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..deque.len());\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..deque.len());\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+}\n+\n+fn vec_deque_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..).max();\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..deque.len() - 1);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..deque.len() - 1).min();\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..deque.len() - 1);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let w: Vec<i8> = deque.drain(1..deque.len() - 1).collect();\n+}\n+\n+fn string_range() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(0..s.len());\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    let n = s.drain(0..s.len()).count();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(usize::MIN..s.len());\n+    let n = iter.count();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+}\n+\n+fn string_range_from() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(0..);\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let mut iter = s.drain(0..);\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    let next = s.drain(usize::MIN..).next();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+}\n+\n+fn string_range_full() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..);\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    for x in s.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+}\n+\n+fn string_range_to() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..s.len());\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..s.len());\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+}\n+\n+fn string_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..);\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..).max();\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..s.len() - 1);\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..s.len() - 1).min();\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..s.len() - 1);\n+    let mut s = String::from(\"Hello, world!\");\n+    let w: String = s.drain(1..s.len() - 1).collect();\n+}\n+\n+fn hash_set() {\n+    // Do not lint because iterator is assigned\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let iter = set.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let mut iter = set.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let next = set.drain().next();\n+\n+    // Do lint\n+    let mut set = HashSet::from([1, 2, 3]);\n+    set.clear();\n+}\n+\n+fn hash_map() {\n+    // Do not lint because iterator is assigned\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let iter = map.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let mut iter = map.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let next = map.drain().next();\n+\n+    // Do lint\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    map.clear();\n+}\n+\n+fn binary_heap() {\n+    // Do not lint because iterator is assigned\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let iter = heap.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let mut iter = heap.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let next = heap.drain().next();\n+\n+    // Do lint\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    heap.clear();\n+}\n+\n+fn main() {}"}, {"sha": "4d60ee46e1865bb12ab1b58cc04491d301052ff5", "filename": "tests/ui/clear_with_drain.rs", "status": "added", "additions": 358, "deletions": 0, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fclear_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fclear_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclear_with_drain.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,358 @@\n+// run-rustfix\n+#![allow(unused)]\n+#![warn(clippy::clear_with_drain)]\n+\n+use std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};\n+\n+fn vec_range() {\n+    // Do not lint because iterator is assigned\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(0..v.len());\n+\n+    // Do not lint because iterator is used\n+    let mut v = vec![1, 2, 3];\n+    let n = v.drain(0..v.len()).count();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(usize::MIN..v.len());\n+    let n = iter.count();\n+\n+    // Do lint\n+    let mut v = vec![1, 2, 3];\n+    v.drain(0..v.len());\n+\n+    // Do lint\n+    let mut v = vec![1, 2, 3];\n+    v.drain(usize::MIN..v.len());\n+}\n+\n+fn vec_range_from() {\n+    // Do not lint because iterator is assigned\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(0..);\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut v = vec![1, 2, 3];\n+    let mut iter = v.drain(0..);\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut v = vec![1, 2, 3];\n+    let next = v.drain(usize::MIN..).next();\n+\n+    // Do lint\n+    let mut v = vec![1, 2, 3];\n+    v.drain(0..);\n+\n+    // Do lint\n+    let mut v = vec![1, 2, 3];\n+    v.drain(usize::MIN..);\n+}\n+\n+fn vec_range_full() {\n+    // Do not lint because iterator is assigned\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(..);\n+\n+    // Do not lint because iterator is used\n+    let mut v = vec![1, 2, 3];\n+    for x in v.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut v = vec![1, 2, 3];\n+    v.drain(..);\n+}\n+\n+fn vec_range_to() {\n+    // Do not lint because iterator is assigned\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(..v.len());\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut v = vec![1, 2, 3];\n+    let iter = v.drain(..v.len());\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut v = vec![1, 2, 3];\n+    v.drain(..v.len());\n+}\n+\n+fn vec_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(1..);\n+    let mut v = vec![1, 2, 3];\n+    v.drain(1..).max();\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(..v.len() - 1);\n+    let mut v = vec![1, 2, 3];\n+    v.drain(..v.len() - 1).min();\n+\n+    let mut v = vec![1, 2, 3];\n+    v.drain(1..v.len() - 1);\n+    let mut v = vec![1, 2, 3];\n+    let w: Vec<i8> = v.drain(1..v.len() - 1).collect();\n+}\n+\n+fn vec_deque_range() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(0..deque.len());\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let n = deque.drain(0..deque.len()).count();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(usize::MIN..deque.len());\n+    let n = iter.count();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(0..deque.len());\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(usize::MIN..deque.len());\n+}\n+\n+fn vec_deque_range_from() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(0..);\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let mut iter = deque.drain(0..);\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let next = deque.drain(usize::MIN..).next();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(0..);\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(usize::MIN..);\n+}\n+\n+fn vec_deque_range_full() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..);\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    for x in deque.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..);\n+}\n+\n+fn vec_deque_range_to() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..deque.len());\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..deque.len());\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..deque.len());\n+}\n+\n+fn vec_deque_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..).max();\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..deque.len() - 1);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..deque.len() - 1).min();\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..deque.len() - 1);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let w: Vec<i8> = deque.drain(1..deque.len() - 1).collect();\n+}\n+\n+fn string_range() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(0..s.len());\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    let n = s.drain(0..s.len()).count();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(usize::MIN..s.len());\n+    let n = iter.count();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(0..s.len());\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(usize::MIN..s.len());\n+}\n+\n+fn string_range_from() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(0..);\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let mut iter = s.drain(0..);\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    let next = s.drain(usize::MIN..).next();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(0..);\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(usize::MIN..);\n+}\n+\n+fn string_range_full() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..);\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    for x in s.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..);\n+}\n+\n+fn string_range_to() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..s.len());\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..s.len());\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..s.len());\n+}\n+\n+fn string_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..);\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..).max();\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..s.len() - 1);\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..s.len() - 1).min();\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..s.len() - 1);\n+    let mut s = String::from(\"Hello, world!\");\n+    let w: String = s.drain(1..s.len() - 1).collect();\n+}\n+\n+fn hash_set() {\n+    // Do not lint because iterator is assigned\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let iter = set.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let mut iter = set.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let next = set.drain().next();\n+\n+    // Do lint\n+    let mut set = HashSet::from([1, 2, 3]);\n+    set.drain();\n+}\n+\n+fn hash_map() {\n+    // Do not lint because iterator is assigned\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let iter = map.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let mut iter = map.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let next = map.drain().next();\n+\n+    // Do lint\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    map.drain();\n+}\n+\n+fn binary_heap() {\n+    // Do not lint because iterator is assigned\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let iter = heap.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let mut iter = heap.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let next = heap.drain().next();\n+\n+    // Do lint\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    heap.drain();\n+}\n+\n+fn main() {}"}, {"sha": "20158da1121b78ac54aed8973cd0be2dbeae2404", "filename": "tests/ui/clear_with_drain.stderr", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fclear_with_drain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fclear_with_drain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclear_with_drain.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,130 @@\n+error: `drain` used to clear a `Vec`\n+  --> $DIR/clear_with_drain.rs:23:7\n+   |\n+LL |     v.drain(0..v.len());\n+   |       ^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+   |\n+   = note: `-D clippy::clear-with-drain` implied by `-D warnings`\n+\n+error: `drain` used to clear a `Vec`\n+  --> $DIR/clear_with_drain.rs:27:7\n+   |\n+LL |     v.drain(usize::MIN..v.len());\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `Vec`\n+  --> $DIR/clear_with_drain.rs:46:7\n+   |\n+LL |     v.drain(0..);\n+   |       ^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `Vec`\n+  --> $DIR/clear_with_drain.rs:50:7\n+   |\n+LL |     v.drain(usize::MIN..);\n+   |       ^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `Vec`\n+  --> $DIR/clear_with_drain.rs:66:7\n+   |\n+LL |     v.drain(..);\n+   |       ^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `Vec`\n+  --> $DIR/clear_with_drain.rs:83:7\n+   |\n+LL |     v.drain(..v.len());\n+   |       ^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:121:11\n+   |\n+LL |     deque.drain(0..deque.len());\n+   |           ^^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:125:11\n+   |\n+LL |     deque.drain(usize::MIN..deque.len());\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:144:11\n+   |\n+LL |     deque.drain(0..);\n+   |           ^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:148:11\n+   |\n+LL |     deque.drain(usize::MIN..);\n+   |           ^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:164:11\n+   |\n+LL |     deque.drain(..);\n+   |           ^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:181:11\n+   |\n+LL |     deque.drain(..deque.len());\n+   |           ^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:219:7\n+   |\n+LL |     s.drain(0..s.len());\n+   |       ^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:223:7\n+   |\n+LL |     s.drain(usize::MIN..s.len());\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:242:7\n+   |\n+LL |     s.drain(0..);\n+   |       ^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:246:7\n+   |\n+LL |     s.drain(usize::MIN..);\n+   |       ^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:262:7\n+   |\n+LL |     s.drain(..);\n+   |       ^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:279:7\n+   |\n+LL |     s.drain(..s.len());\n+   |       ^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `HashSet`\n+  --> $DIR/clear_with_drain.rs:317:9\n+   |\n+LL |     set.drain();\n+   |         ^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `HashMap`\n+  --> $DIR/clear_with_drain.rs:336:9\n+   |\n+LL |     map.drain();\n+   |         ^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `BinaryHeap`\n+  --> $DIR/clear_with_drain.rs:355:10\n+   |\n+LL |     heap.drain();\n+   |          ^^^^^^^ help: try: `clear()`\n+\n+error: aborting due to 21 previous errors\n+"}, {"sha": "01259a983ab6fa03301ceec65c69364c6e00f5eb", "filename": "tests/ui/collection_is_never_read.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fcollection_is_never_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fcollection_is_never_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollection_is_never_read.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -84,13 +84,18 @@ fn shadowing_2() {\n }\n \n #[allow(clippy::let_unit_value)]\n-fn fake_read() {\n-    let mut x = vec![1, 2, 3]; // Ok\n+fn fake_read_1() {\n+    let mut x = vec![1, 2, 3]; // WARNING\n     x.reverse();\n-    // `collection_is_never_read` gets fooled, but other lints should catch this.\n     let _: () = x.clear();\n }\n \n+fn fake_read_2() {\n+    let mut x = vec![1, 2, 3]; // WARNING\n+    x.reverse();\n+    println!(\"{:?}\", x.push(5));\n+}\n+\n fn assignment() {\n     let mut x = vec![1, 2, 3]; // WARNING\n     let y = vec![4, 5, 6]; // Ok\n@@ -163,3 +168,23 @@ fn function_argument() {\n     let x = vec![1, 2, 3]; // Ok\n     foo(&x);\n }\n+\n+fn string() {\n+    // Do lint (write without read)\n+    let mut s = String::new();\n+    s.push_str(\"Hello, World!\");\n+\n+    // Do not lint (read without write)\n+    let mut s = String::from(\"Hello, World!\");\n+    let _ = s.len();\n+\n+    // Do not lint (write and read)\n+    let mut s = String::from(\"Hello, World!\");\n+    s.push_str(\"foo, bar\");\n+    let _ = s.len();\n+\n+    // Do lint the first line, but not the second\n+    let mut s = String::from(\"Hello, World!\");\n+    let t = String::from(\"foo, bar\");\n+    s = t;\n+}"}, {"sha": "cf51a53686f2d290a7dbe28cdbf6cb371bc48456", "filename": "tests/ui/collection_is_never_read.stderr", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fcollection_is_never_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fcollection_is_never_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollection_is_never_read.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -25,28 +25,52 @@ LL |     let mut x = HashMap::new(); // WARNING\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: collection is never read\n-  --> $DIR/collection_is_never_read.rs:95:5\n+  --> $DIR/collection_is_never_read.rs:88:5\n    |\n LL |     let mut x = vec![1, 2, 3]; // WARNING\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: collection is never read\n-  --> $DIR/collection_is_never_read.rs:102:5\n+  --> $DIR/collection_is_never_read.rs:94:5\n    |\n LL |     let mut x = vec![1, 2, 3]; // WARNING\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: collection is never read\n-  --> $DIR/collection_is_never_read.rs:119:5\n+  --> $DIR/collection_is_never_read.rs:100:5\n+   |\n+LL |     let mut x = vec![1, 2, 3]; // WARNING\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: collection is never read\n+  --> $DIR/collection_is_never_read.rs:107:5\n+   |\n+LL |     let mut x = vec![1, 2, 3]; // WARNING\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: collection is never read\n+  --> $DIR/collection_is_never_read.rs:124:5\n    |\n LL |     let mut x = HashSet::new(); // WARNING\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: collection is never read\n-  --> $DIR/collection_is_never_read.rs:133:5\n+  --> $DIR/collection_is_never_read.rs:138:5\n    |\n LL |     let x = vec![1, 2, 3]; // WARNING\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: collection is never read\n+  --> $DIR/collection_is_never_read.rs:174:5\n+   |\n+LL |     let mut s = String::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: collection is never read\n+  --> $DIR/collection_is_never_read.rs:187:5\n+   |\n+LL |     let mut s = String::from(\"Hello, World!\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "26a387b3cf04972f1fe654993930d9db0e6b4d66", "filename": "tests/ui/double_must_use.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fdouble_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fdouble_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdouble_must_use.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -21,6 +21,17 @@ pub fn must_use_with_note() -> Result<(), ()> {\n     unimplemented!();\n }\n \n+// vvvv Should not lint (#10486)\n+#[must_use]\n+async fn async_must_use() -> usize {\n+    unimplemented!();\n+}\n+\n+#[must_use]\n+async fn async_must_use_result() -> Result<(), ()> {\n+    Ok(())\n+}\n+\n fn main() {\n     must_use_result();\n     must_use_tuple();"}, {"sha": "49ab2ea3e12b42c2f287acb45fa6d55d05f10687", "filename": "tests/ui/double_must_use.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fdouble_must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fdouble_must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdouble_must_use.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -23,5 +23,13 @@ LL | pub fn must_use_array() -> [Result<(), ()>; 1] {\n    |\n    = help: either add some descriptive text or remove the attribute\n \n-error: aborting due to 3 previous errors\n+error: this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\n+  --> $DIR/double_must_use.rs:31:1\n+   |\n+LL | async fn async_must_use_result() -> Result<(), ()> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: either add some descriptive text or remove the attribute\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "19e718625582c594ccfa3407e63780062150ad36", "filename": "tests/ui/extra_unused_type_parameters.fixed", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fextra_unused_type_parameters.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fextra_unused_type_parameters.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters.fixed?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,105 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::needless_lifetimes)]\n+#![warn(clippy::extra_unused_type_parameters)]\n+\n+fn unused_ty(x: u8) {\n+    unimplemented!()\n+}\n+\n+fn unused_multi(x: u8) {\n+    unimplemented!()\n+}\n+\n+fn unused_with_lt<'a>(x: &'a u8) {\n+    unimplemented!()\n+}\n+\n+fn used_ty<T>(x: T, y: u8) {}\n+\n+fn used_ref<'a, T>(x: &'a T) {}\n+\n+fn used_ret<T: Default>(x: u8) -> T {\n+    T::default()\n+}\n+\n+fn unused_bounded<U>(x: U) {\n+    unimplemented!();\n+}\n+\n+fn some_unused<B, C>(b: B, c: C) {\n+    unimplemented!();\n+}\n+\n+fn used_opaque<A>(iter: impl Iterator<Item = A>) -> usize {\n+    iter.count()\n+}\n+\n+fn used_ret_opaque<A>() -> impl Iterator<Item = A> {\n+    std::iter::empty()\n+}\n+\n+fn used_vec_box<T>(x: Vec<Box<T>>) {}\n+\n+fn used_body<T: Default + ToString>() -> String {\n+    T::default().to_string()\n+}\n+\n+fn used_closure<T: Default + ToString>() -> impl Fn() {\n+    || println!(\"{}\", T::default().to_string())\n+}\n+\n+struct S;\n+\n+impl S {\n+    fn unused_ty_impl(&self) {\n+        unimplemented!()\n+    }\n+}\n+\n+// Don't lint on trait methods\n+trait Foo {\n+    fn bar<T>(&self);\n+}\n+\n+impl Foo for S {\n+    fn bar<T>(&self) {}\n+}\n+\n+fn skip_index<A, Iter>(iter: Iter, index: usize) -> impl Iterator<Item = A>\n+where\n+    Iter: Iterator<Item = A>,\n+{\n+    iter.enumerate()\n+        .filter_map(move |(i, a)| if i == index { None } else { Some(a) })\n+}\n+\n+fn unused_opaque(dummy: impl Default) {\n+    unimplemented!()\n+}\n+\n+mod unexported_trait_bounds {\n+    mod private {\n+        pub trait Private {}\n+    }\n+\n+    fn priv_trait_bound<T: private::Private>() {\n+        unimplemented!();\n+    }\n+\n+    fn unused_with_priv_trait_bound<T: private::Private>() {\n+        unimplemented!();\n+    }\n+}\n+\n+mod issue10319 {\n+    fn assert_send<T: Send>() {}\n+\n+    fn assert_send_where<T>()\n+    where\n+        T: Send,\n+    {\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e53bb587e89acd0a438b7076afd5ec7b6bd09bb1", "filename": "tests/ui/extra_unused_type_parameters.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fextra_unused_type_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fextra_unused_type_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n #![allow(unused, clippy::needless_lifetimes)]\n #![warn(clippy::extra_unused_type_parameters)]\n \n@@ -21,14 +23,7 @@ fn used_ret<T: Default>(x: u8) -> T {\n     T::default()\n }\n \n-fn unused_bounded<T: Default, U>(x: U) {\n-    unimplemented!();\n-}\n-\n-fn unused_where_clause<T, U>(x: U)\n-where\n-    T: Default,\n-{\n+fn unused_bounded<T: Default, U, V: Default>(x: U) {\n     unimplemented!();\n }\n "}, {"sha": "c042a5a2290e51de8147b7fdece161df2181ccdd", "filename": "tests/ui/extra_unused_type_parameters.stderr", "status": "modified", "additions": 34, "deletions": 45, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fextra_unused_type_parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fextra_unused_type_parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,75 +1,64 @@\n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:4:13\n+error: type parameter `T` goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:6:13\n    |\n LL | fn unused_ty<T>(x: u8) {\n-   |             ^^^\n+   |             ^^^ help: consider removing the parameter\n    |\n-   = help: consider removing the parameter\n    = note: `-D clippy::extra-unused-type-parameters` implied by `-D warnings`\n \n-error: type parameters go unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:8:16\n+error: type parameters go unused in function definition: T, U\n+  --> $DIR/extra_unused_type_parameters.rs:10:16\n    |\n LL | fn unused_multi<T, U>(x: u8) {\n-   |                ^^^^^^\n-   |\n-   = help: consider removing the parameters\n+   |                ^^^^^^ help: consider removing the parameters\n \n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:12:23\n+error: type parameter `T` goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:14:21\n    |\n LL | fn unused_with_lt<'a, T>(x: &'a u8) {\n-   |                       ^\n-   |\n-   = help: consider removing the parameter\n+   |                     ^^^ help: consider removing the parameter\n \n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:24:19\n+error: type parameters go unused in function definition: T, V\n+  --> $DIR/extra_unused_type_parameters.rs:26:19\n    |\n-LL | fn unused_bounded<T: Default, U>(x: U) {\n-   |                   ^^^^^^^^^^^\n+LL | fn unused_bounded<T: Default, U, V: Default>(x: U) {\n+   |                   ^^^^^^^^^^^^ ^^^^^^^^^^^^\n    |\n-   = help: consider removing the parameter\n-\n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:28:24\n+help: consider removing the parameters\n    |\n-LL | fn unused_where_clause<T, U>(x: U)\n-   |                        ^^\n+LL - fn unused_bounded<T: Default, U, V: Default>(x: U) {\n+LL + fn unused_bounded<U>(x: U) {\n    |\n-   = help: consider removing the parameter\n \n-error: type parameters go unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:35:16\n+error: type parameters go unused in function definition: A, D, E\n+  --> $DIR/extra_unused_type_parameters.rs:30:16\n    |\n LL | fn some_unused<A, B, C, D: Iterator<Item = (B, C)>, E>(b: B, c: C) {\n-   |                ^^       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^\n+   |                ^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider removing the parameters\n+   |\n+LL - fn some_unused<A, B, C, D: Iterator<Item = (B, C)>, E>(b: B, c: C) {\n+LL + fn some_unused<B, C>(b: B, c: C) {\n    |\n-   = help: consider removing the parameters\n \n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:60:22\n+error: type parameter `T` goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:55:22\n    |\n LL |     fn unused_ty_impl<T>(&self) {\n-   |                      ^^^\n-   |\n-   = help: consider removing the parameter\n+   |                      ^^^ help: consider removing the parameter\n \n-error: type parameters go unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:82:17\n+error: type parameters go unused in function definition: A, B\n+  --> $DIR/extra_unused_type_parameters.rs:77:17\n    |\n LL | fn unused_opaque<A, B>(dummy: impl Default) {\n-   |                 ^^^^^^\n-   |\n-   = help: consider removing the parameters\n+   |                 ^^^^^^ help: consider removing the parameters\n \n-error: type parameter goes unused in function definition\n-  --> $DIR/extra_unused_type_parameters.rs:95:58\n+error: type parameter `U` goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters.rs:90:56\n    |\n LL |     fn unused_with_priv_trait_bound<T: private::Private, U>() {\n-   |                                                          ^\n-   |\n-   = help: consider removing the parameter\n+   |                                                        ^^^ help: consider removing the parameter\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "10b39aa8f2c5b3c101a728f9648a0b6fdf665c36", "filename": "tests/ui/extra_unused_type_parameters_unfixable.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fextra_unused_type_parameters_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fextra_unused_type_parameters_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters_unfixable.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,24 @@\n+#![warn(clippy::extra_unused_type_parameters)]\n+\n+fn unused_where_clause<T, U>(x: U)\n+where\n+    T: Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn unused_multi_where_clause<T, U, V: Default>(x: U)\n+where\n+    T: Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn unused_all_where_clause<T, U: Default, V: Default>()\n+where\n+    T: Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn main() {}"}, {"sha": "a9580cc894f35bf7324470f5b24f0558507addcb", "filename": "tests/ui/extra_unused_type_parameters_unfixable.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fextra_unused_type_parameters_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fextra_unused_type_parameters_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_type_parameters_unfixable.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,27 @@\n+error: type parameter `T` goes unused in function definition\n+  --> $DIR/extra_unused_type_parameters_unfixable.rs:3:24\n+   |\n+LL | fn unused_where_clause<T, U>(x: U)\n+   |                        ^\n+   |\n+   = help: consider removing the parameter\n+   = note: `-D clippy::extra-unused-type-parameters` implied by `-D warnings`\n+\n+error: type parameters go unused in function definition: T, V\n+  --> $DIR/extra_unused_type_parameters_unfixable.rs:10:30\n+   |\n+LL | fn unused_multi_where_clause<T, U, V: Default>(x: U)\n+   |                              ^     ^^^^^^^^^^\n+   |\n+   = help: consider removing the parameters\n+\n+error: type parameters go unused in function definition: T, U, V\n+  --> $DIR/extra_unused_type_parameters_unfixable.rs:17:28\n+   |\n+LL | fn unused_all_where_clause<T, U: Default, V: Default>()\n+   |                            ^  ^^^^^^^^^^  ^^^^^^^^^^\n+   |\n+   = help: consider removing the parameters\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "423bfaf97965ea54b7951eb201f5825bd0afe070", "filename": "tests/ui/format_args_unfixable.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fformat_args_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fformat_args_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_args_unfixable.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::format_in_format_args, clippy::to_string_in_format_args)]\n+#![allow(unused)]\n #![allow(clippy::assertions_on_constants, clippy::eq_op, clippy::uninlined_format_args)]\n \n use std::io::{stdout, Error, ErrorKind, Write};\n@@ -57,3 +58,46 @@ fn main() {\n     my_macro!();\n     println!(\"error: {}\", my_other_macro!());\n }\n+\n+macro_rules! _internal {\n+    ($($args:tt)*) => {\n+        println!(\"{}\", format_args!($($args)*))\n+    };\n+}\n+\n+macro_rules! my_println2 {\n+   ($target:expr, $($args:tt)+) => {{\n+       if $target {\n+           _internal!($($args)+)\n+       }\n+    }};\n+}\n+\n+macro_rules! my_println2_args {\n+    ($target:expr, $($args:tt)+) => {{\n+       if $target {\n+           _internal!(\"foo: {}\", format_args!($($args)+))\n+       }\n+    }};\n+}\n+\n+fn test2() {\n+    let error = Error::new(ErrorKind::Other, \"bad thing\");\n+\n+    // None of these should be linted without the config change\n+    my_println2!(true, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    my_println2!(\n+        true,\n+        \"{}: {}\",\n+        error,\n+        format!(\"something failed at {}\", Location::caller())\n+    );\n+\n+    my_println2_args!(true, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n+    my_println2_args!(\n+        true,\n+        \"{}: {}\",\n+        error,\n+        format!(\"something failed at {}\", Location::caller())\n+    );\n+}"}, {"sha": "c1be48c3b726944b4693057885ef793ac1e7e6c9", "filename": "tests/ui/format_args_unfixable.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fformat_args_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fformat_args_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_args_unfixable.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,5 +1,5 @@\n error: `format!` in `println!` args\n-  --> $DIR/format_args_unfixable.rs:25:5\n+  --> $DIR/format_args_unfixable.rs:26:5\n    |\n LL |     println!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -9,7 +9,7 @@ LL |     println!(\"error: {}\", format!(\"something failed at {}\", Location::calle\n    = note: `-D clippy::format-in-format-args` implied by `-D warnings`\n \n error: `format!` in `println!` args\n-  --> $DIR/format_args_unfixable.rs:26:5\n+  --> $DIR/format_args_unfixable.rs:27:5\n    |\n LL |     println!(\"{}: {}\", error, format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -18,7 +18,7 @@ LL |     println!(\"{}: {}\", error, format!(\"something failed at {}\", Location::c\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `println!` args\n-  --> $DIR/format_args_unfixable.rs:27:5\n+  --> $DIR/format_args_unfixable.rs:28:5\n    |\n LL |     println!(\"{:?}: {}\", error, format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -27,7 +27,7 @@ LL |     println!(\"{:?}: {}\", error, format!(\"something failed at {}\", Location:\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `println!` args\n-  --> $DIR/format_args_unfixable.rs:28:5\n+  --> $DIR/format_args_unfixable.rs:29:5\n    |\n LL |     println!(\"{{}}: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -36,7 +36,7 @@ LL |     println!(\"{{}}: {}\", format!(\"something failed at {}\", Location::caller\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `println!` args\n-  --> $DIR/format_args_unfixable.rs:29:5\n+  --> $DIR/format_args_unfixable.rs:30:5\n    |\n LL |     println!(r#\"error: \"{}\"\"#, format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -45,7 +45,7 @@ LL |     println!(r#\"error: \"{}\"\"#, format!(\"something failed at {}\", Location::\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `println!` args\n-  --> $DIR/format_args_unfixable.rs:30:5\n+  --> $DIR/format_args_unfixable.rs:31:5\n    |\n LL |     println!(\"error: {}\", format!(r#\"something failed at \"{}\"\"#, Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -54,7 +54,7 @@ LL |     println!(\"error: {}\", format!(r#\"something failed at \"{}\"\"#, Location::\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `println!` args\n-  --> $DIR/format_args_unfixable.rs:31:5\n+  --> $DIR/format_args_unfixable.rs:32:5\n    |\n LL |     println!(\"error: {}\", format!(\"something failed at {} {0}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -63,7 +63,7 @@ LL |     println!(\"error: {}\", format!(\"something failed at {} {0}\", Location::c\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `format!` args\n-  --> $DIR/format_args_unfixable.rs:32:13\n+  --> $DIR/format_args_unfixable.rs:33:13\n    |\n LL |     let _ = format!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -72,7 +72,7 @@ LL |     let _ = format!(\"error: {}\", format!(\"something failed at {}\", Location\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `write!` args\n-  --> $DIR/format_args_unfixable.rs:33:13\n+  --> $DIR/format_args_unfixable.rs:34:13\n    |\n LL |       let _ = write!(\n    |  _____________^\n@@ -86,7 +86,7 @@ LL | |     );\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `writeln!` args\n-  --> $DIR/format_args_unfixable.rs:38:13\n+  --> $DIR/format_args_unfixable.rs:39:13\n    |\n LL |       let _ = writeln!(\n    |  _____________^\n@@ -100,7 +100,7 @@ LL | |     );\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `print!` args\n-  --> $DIR/format_args_unfixable.rs:43:5\n+  --> $DIR/format_args_unfixable.rs:44:5\n    |\n LL |     print!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -109,7 +109,7 @@ LL |     print!(\"error: {}\", format!(\"something failed at {}\", Location::caller(\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `eprint!` args\n-  --> $DIR/format_args_unfixable.rs:44:5\n+  --> $DIR/format_args_unfixable.rs:45:5\n    |\n LL |     eprint!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -118,7 +118,7 @@ LL |     eprint!(\"error: {}\", format!(\"something failed at {}\", Location::caller\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `eprintln!` args\n-  --> $DIR/format_args_unfixable.rs:45:5\n+  --> $DIR/format_args_unfixable.rs:46:5\n    |\n LL |     eprintln!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -127,7 +127,7 @@ LL |     eprintln!(\"error: {}\", format!(\"something failed at {}\", Location::call\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `format_args!` args\n-  --> $DIR/format_args_unfixable.rs:46:13\n+  --> $DIR/format_args_unfixable.rs:47:13\n    |\n LL |     let _ = format_args!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -136,7 +136,7 @@ LL |     let _ = format_args!(\"error: {}\", format!(\"something failed at {}\", Loc\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `assert!` args\n-  --> $DIR/format_args_unfixable.rs:47:5\n+  --> $DIR/format_args_unfixable.rs:48:5\n    |\n LL |     assert!(true, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -145,7 +145,7 @@ LL |     assert!(true, \"error: {}\", format!(\"something failed at {}\", Location::\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `assert_eq!` args\n-  --> $DIR/format_args_unfixable.rs:48:5\n+  --> $DIR/format_args_unfixable.rs:49:5\n    |\n LL |     assert_eq!(0, 0, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -154,7 +154,7 @@ LL |     assert_eq!(0, 0, \"error: {}\", format!(\"something failed at {}\", Locatio\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `assert_ne!` args\n-  --> $DIR/format_args_unfixable.rs:49:5\n+  --> $DIR/format_args_unfixable.rs:50:5\n    |\n LL |     assert_ne!(0, 0, \"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -163,7 +163,7 @@ LL |     assert_ne!(0, 0, \"error: {}\", format!(\"something failed at {}\", Locatio\n    = help: or consider changing `format!` to `format_args!`\n \n error: `format!` in `panic!` args\n-  --> $DIR/format_args_unfixable.rs:50:5\n+  --> $DIR/format_args_unfixable.rs:51:5\n    |\n LL |     panic!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "f12cb8f22e2703286c6218ea5d2891f1bf1de586", "filename": "tests/ui/items_after_statement.rs", "status": "renamed", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fitems_after_statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fitems_after_statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fitems_after_statement.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -51,3 +51,20 @@ fn semicolon() {\n \n     let _ = S::new(3);\n }\n+\n+fn item_from_macro() {\n+    macro_rules! static_assert_size {\n+        ($ty:ty, $size:expr) => {\n+            const _: [(); $size] = [(); ::std::mem::size_of::<$ty>()];\n+        };\n+    }\n+\n+    let _ = 1;\n+    static_assert_size!(u32, 4);\n+}\n+\n+fn allow_attribute() {\n+    let _ = 1;\n+    #[allow(clippy::items_after_statements)]\n+    const _: usize = 1;\n+}", "previous_filename": "tests/ui/item_after_statement.rs"}, {"sha": "f69635a977bd7ca89a4cabb0f5a5c4dd2c22ada8", "filename": "tests/ui/items_after_statement.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fitems_after_statement.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fitems_after_statement.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fitems_after_statement.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,5 +1,5 @@\n error: adding items after statements is confusing, since items exist from the start of the scope\n-  --> $DIR/item_after_statement.rs:13:5\n+  --> $DIR/items_after_statement.rs:13:5\n    |\n LL | /     fn foo() {\n LL | |         println!(\"foo\");\n@@ -9,15 +9,15 @@ LL | |     }\n    = note: `-D clippy::items-after-statements` implied by `-D warnings`\n \n error: adding items after statements is confusing, since items exist from the start of the scope\n-  --> $DIR/item_after_statement.rs:20:5\n+  --> $DIR/items_after_statement.rs:20:5\n    |\n LL | /     fn foo() {\n LL | |         println!(\"foo\");\n LL | |     }\n    | |_____^\n \n error: adding items after statements is confusing, since items exist from the start of the scope\n-  --> $DIR/item_after_statement.rs:33:13\n+  --> $DIR/items_after_statement.rs:33:13\n    |\n LL | /             fn say_something() {\n LL | |                 println!(\"something\");", "previous_filename": "tests/ui/item_after_statement.stderr"}, {"sha": "4a8ba995da556f0546b526b987f6f4a44a80d4f2", "filename": "tests/ui/large_futures.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Flarge_futures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Flarge_futures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_futures.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,61 @@\n+#![feature(generators)]\n+#![warn(clippy::large_futures)]\n+#![allow(clippy::future_not_send)]\n+#![allow(clippy::manual_async_fn)]\n+\n+async fn big_fut(_arg: [u8; 1024 * 16]) {}\n+\n+async fn wait() {\n+    let f = async {\n+        big_fut([0u8; 1024 * 16]).await;\n+    };\n+    f.await\n+}\n+async fn calls_fut(fut: impl std::future::Future<Output = ()>) {\n+    loop {\n+        wait().await;\n+        if true {\n+            return fut.await;\n+        } else {\n+            wait().await;\n+        }\n+    }\n+}\n+\n+pub async fn test() {\n+    let fut = big_fut([0u8; 1024 * 16]);\n+    foo().await;\n+    calls_fut(fut).await;\n+}\n+\n+pub fn foo() -> impl std::future::Future<Output = ()> {\n+    async {\n+        let x = [0i32; 1024 * 16];\n+        async {}.await;\n+        dbg!(x);\n+    }\n+}\n+\n+pub async fn lines() {\n+    async {\n+        let x = [0i32; 1024 * 16];\n+        async {}.await;\n+        println!(\"{:?}\", x);\n+    }\n+    .await;\n+}\n+\n+pub async fn macro_expn() {\n+    macro_rules! macro_ {\n+        () => {\n+            async {\n+                let x = [0i32; 1024 * 16];\n+                async {}.await;\n+                println!(\"macro: {:?}\", x);\n+            }\n+        };\n+    }\n+    macro_!().await\n+}\n+\n+fn main() {}"}, {"sha": "67e0fceff6ef313f8d527564385a9ed8a3a6a3f2", "filename": "tests/ui/large_futures.stderr", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Flarge_futures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Flarge_futures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_futures.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,82 @@\n+error: large future with a size of 16385 bytes\n+  --> $DIR/large_futures.rs:10:9\n+   |\n+LL |         big_fut([0u8; 1024 * 16]).await;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider `Box::pin` on it: `Box::pin(big_fut([0u8; 1024 * 16]))`\n+   |\n+   = note: `-D clippy::large-futures` implied by `-D warnings`\n+\n+error: large future with a size of 16386 bytes\n+  --> $DIR/large_futures.rs:12:5\n+   |\n+LL |     f.await\n+   |     ^ help: consider `Box::pin` on it: `Box::pin(f)`\n+\n+error: large future with a size of 16387 bytes\n+  --> $DIR/large_futures.rs:16:9\n+   |\n+LL |         wait().await;\n+   |         ^^^^^^ help: consider `Box::pin` on it: `Box::pin(wait())`\n+\n+error: large future with a size of 16387 bytes\n+  --> $DIR/large_futures.rs:20:13\n+   |\n+LL |             wait().await;\n+   |             ^^^^^^ help: consider `Box::pin` on it: `Box::pin(wait())`\n+\n+error: large future with a size of 65540 bytes\n+  --> $DIR/large_futures.rs:27:5\n+   |\n+LL |     foo().await;\n+   |     ^^^^^ help: consider `Box::pin` on it: `Box::pin(foo())`\n+\n+error: large future with a size of 49159 bytes\n+  --> $DIR/large_futures.rs:28:5\n+   |\n+LL |     calls_fut(fut).await;\n+   |     ^^^^^^^^^^^^^^ help: consider `Box::pin` on it: `Box::pin(calls_fut(fut))`\n+\n+error: large future with a size of 65540 bytes\n+  --> $DIR/large_futures.rs:40:5\n+   |\n+LL | /     async {\n+LL | |         let x = [0i32; 1024 * 16];\n+LL | |         async {}.await;\n+LL | |         println!(\"{:?}\", x);\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider `Box::pin` on it\n+   |\n+LL ~     Box::pin(async {\n+LL +         let x = [0i32; 1024 * 16];\n+LL +         async {}.await;\n+LL +         println!(\"{:?}\", x);\n+LL +     })\n+   |\n+\n+error: large future with a size of 65540 bytes\n+  --> $DIR/large_futures.rs:51:13\n+   |\n+LL | /             async {\n+LL | |                 let x = [0i32; 1024 * 16];\n+LL | |                 async {}.await;\n+LL | |                 println!(\"macro: {:?}\", x);\n+LL | |             }\n+   | |_____________^\n+...\n+LL |       macro_!().await\n+   |       --------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `macro_` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider `Box::pin` on it\n+   |\n+LL ~             Box::pin(async {\n+LL +                 let x = [0i32; 1024 * 16];\n+LL +                 async {}.await;\n+LL +                 println!(\"macro: {:?}\", x);\n+LL +             })\n+   |\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "f4033cd8ed85069c3b5b59cf04ca728ebeb56aed", "filename": "tests/ui/lines_filter_map_ok.fixed", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Flines_filter_map_ok.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Flines_filter_map_ok.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flines_filter_map_ok.fixed?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,29 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::map_identity)]\n+#![warn(clippy::lines_filter_map_ok)]\n+\n+use std::io::{self, BufRead, BufReader};\n+\n+fn main() -> io::Result<()> {\n+    let f = std::fs::File::open(\"/\")?;\n+    // Lint\n+    BufReader::new(f).lines().map_while(Result::ok).for_each(|_| ());\n+    // Lint\n+    let f = std::fs::File::open(\"/\")?;\n+    BufReader::new(f).lines().map_while(Result::ok).for_each(|_| ());\n+    let s = \"foo\\nbar\\nbaz\\n\";\n+    // Lint\n+    io::stdin().lines().map_while(Result::ok).for_each(|_| ());\n+    // Lint\n+    io::stdin().lines().map_while(Result::ok).for_each(|_| ());\n+    // Do not lint (not a `Lines` iterator)\n+    io::stdin()\n+        .lines()\n+        .map(std::convert::identity)\n+        .filter_map(|x| x.ok())\n+        .for_each(|_| ());\n+    // Do not lint (not a `Result::ok()` extractor)\n+    io::stdin().lines().filter_map(|x| x.err()).for_each(|_| ());\n+    Ok(())\n+}"}, {"sha": "7e11816b2acd3b7e3f8eaf0f9bbf01db3d85696c", "filename": "tests/ui/lines_filter_map_ok.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Flines_filter_map_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Flines_filter_map_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flines_filter_map_ok.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,29 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::map_identity)]\n+#![warn(clippy::lines_filter_map_ok)]\n+\n+use std::io::{self, BufRead, BufReader};\n+\n+fn main() -> io::Result<()> {\n+    let f = std::fs::File::open(\"/\")?;\n+    // Lint\n+    BufReader::new(f).lines().filter_map(Result::ok).for_each(|_| ());\n+    // Lint\n+    let f = std::fs::File::open(\"/\")?;\n+    BufReader::new(f).lines().flat_map(Result::ok).for_each(|_| ());\n+    let s = \"foo\\nbar\\nbaz\\n\";\n+    // Lint\n+    io::stdin().lines().filter_map(Result::ok).for_each(|_| ());\n+    // Lint\n+    io::stdin().lines().filter_map(|x| x.ok()).for_each(|_| ());\n+    // Do not lint (not a `Lines` iterator)\n+    io::stdin()\n+        .lines()\n+        .map(std::convert::identity)\n+        .filter_map(|x| x.ok())\n+        .for_each(|_| ());\n+    // Do not lint (not a `Result::ok()` extractor)\n+    io::stdin().lines().filter_map(|x| x.err()).for_each(|_| ());\n+    Ok(())\n+}"}, {"sha": "cddd403d589c383639c5333877022b100d5cf9f3", "filename": "tests/ui/lines_filter_map_ok.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Flines_filter_map_ok.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Flines_filter_map_ok.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flines_filter_map_ok.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,51 @@\n+error: `filter_map()` will run forever if the iterator repeatedly produces an `Err`\n+  --> $DIR/lines_filter_map_ok.rs:11:31\n+   |\n+LL |     BufReader::new(f).lines().filter_map(Result::ok).for_each(|_| ());\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `map_while(Result::ok)`\n+   |\n+note: this expression returning a `std::io::Lines` may produce an infinite number of `Err` in case of a read error\n+  --> $DIR/lines_filter_map_ok.rs:11:5\n+   |\n+LL |     BufReader::new(f).lines().filter_map(Result::ok).for_each(|_| ());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `-D clippy::lines-filter-map-ok` implied by `-D warnings`\n+\n+error: `flat_map()` will run forever if the iterator repeatedly produces an `Err`\n+  --> $DIR/lines_filter_map_ok.rs:14:31\n+   |\n+LL |     BufReader::new(f).lines().flat_map(Result::ok).for_each(|_| ());\n+   |                               ^^^^^^^^^^^^^^^^^^^^ help: replace with: `map_while(Result::ok)`\n+   |\n+note: this expression returning a `std::io::Lines` may produce an infinite number of `Err` in case of a read error\n+  --> $DIR/lines_filter_map_ok.rs:14:5\n+   |\n+LL |     BufReader::new(f).lines().flat_map(Result::ok).for_each(|_| ());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `filter_map()` will run forever if the iterator repeatedly produces an `Err`\n+  --> $DIR/lines_filter_map_ok.rs:17:25\n+   |\n+LL |     io::stdin().lines().filter_map(Result::ok).for_each(|_| ());\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `map_while(Result::ok)`\n+   |\n+note: this expression returning a `std::io::Lines` may produce an infinite number of `Err` in case of a read error\n+  --> $DIR/lines_filter_map_ok.rs:17:5\n+   |\n+LL |     io::stdin().lines().filter_map(Result::ok).for_each(|_| ());\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: `filter_map()` will run forever if the iterator repeatedly produces an `Err`\n+  --> $DIR/lines_filter_map_ok.rs:19:25\n+   |\n+LL |     io::stdin().lines().filter_map(|x| x.ok()).for_each(|_| ());\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `map_while(Result::ok)`\n+   |\n+note: this expression returning a `std::io::Lines` may produce an infinite number of `Err` in case of a read error\n+  --> $DIR/lines_filter_map_ok.rs:19:5\n+   |\n+LL |     io::stdin().lines().filter_map(|x| x.ok()).for_each(|_| ());\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "5082f931f3c2b0ff1beb75059af1506e90df9124", "filename": "tests/ui/manual_slice_size_calculation.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fmanual_slice_size_calculation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fmanual_slice_size_calculation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_slice_size_calculation.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,36 @@\n+#![allow(unused)]\n+#![warn(clippy::manual_slice_size_calculation)]\n+\n+use core::mem::{align_of, size_of};\n+\n+fn main() {\n+    let v_i32 = Vec::<i32>::new();\n+    let s_i32 = v_i32.as_slice();\n+\n+    // True positives:\n+    let _ = s_i32.len() * size_of::<i32>(); // WARNING\n+    let _ = size_of::<i32>() * s_i32.len(); // WARNING\n+    let _ = size_of::<i32>() * s_i32.len() * 5; // WARNING\n+\n+    let len = s_i32.len();\n+    let size = size_of::<i32>();\n+    let _ = len * size_of::<i32>(); // WARNING\n+    let _ = s_i32.len() * size; // WARNING\n+    let _ = len * size; // WARNING\n+\n+    // True negatives:\n+    let _ = size_of::<i32>() + s_i32.len(); // Ok, not a multiplication\n+    let _ = size_of::<i32>() * s_i32.partition_point(|_| true); // Ok, not len()\n+    let _ = size_of::<i32>() * v_i32.len(); // Ok, not a slice\n+    let _ = align_of::<i32>() * s_i32.len(); // Ok, not size_of()\n+    let _ = size_of::<u32>() * s_i32.len(); // Ok, different types\n+\n+    // False negatives:\n+    let _ = 5 * size_of::<i32>() * s_i32.len(); // Ok (MISSED OPPORTUNITY)\n+    let _ = size_of::<i32>() * 5 * s_i32.len(); // Ok (MISSED OPPORTUNITY)\n+}\n+\n+const fn _const(s_i32: &[i32]) {\n+    // True negative:\n+    let _ = s_i32.len() * size_of::<i32>(); // Ok, can't use size_of_val in const\n+}"}, {"sha": "4a24fc60a0fafcad4e0ddbaba374777e33a554a9", "filename": "tests/ui/manual_slice_size_calculation.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fmanual_slice_size_calculation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fmanual_slice_size_calculation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_slice_size_calculation.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,51 @@\n+error: manual slice size calculation\n+  --> $DIR/manual_slice_size_calculation.rs:11:13\n+   |\n+LL |     let _ = s_i32.len() * size_of::<i32>(); // WARNING\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using std::mem::size_of_value instead\n+   = note: `-D clippy::manual-slice-size-calculation` implied by `-D warnings`\n+\n+error: manual slice size calculation\n+  --> $DIR/manual_slice_size_calculation.rs:12:13\n+   |\n+LL |     let _ = size_of::<i32>() * s_i32.len(); // WARNING\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using std::mem::size_of_value instead\n+\n+error: manual slice size calculation\n+  --> $DIR/manual_slice_size_calculation.rs:13:13\n+   |\n+LL |     let _ = size_of::<i32>() * s_i32.len() * 5; // WARNING\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using std::mem::size_of_value instead\n+\n+error: manual slice size calculation\n+  --> $DIR/manual_slice_size_calculation.rs:17:13\n+   |\n+LL |     let _ = len * size_of::<i32>(); // WARNING\n+   |             ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using std::mem::size_of_value instead\n+\n+error: manual slice size calculation\n+  --> $DIR/manual_slice_size_calculation.rs:18:13\n+   |\n+LL |     let _ = s_i32.len() * size; // WARNING\n+   |             ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using std::mem::size_of_value instead\n+\n+error: manual slice size calculation\n+  --> $DIR/manual_slice_size_calculation.rs:19:13\n+   |\n+LL |     let _ = len * size; // WARNING\n+   |             ^^^^^^^^^^\n+   |\n+   = help: consider using std::mem::size_of_value instead\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "7fd340173af9e43001aa39e8b3cd878beaf3ec15", "filename": "tests/ui/mem_replace.fixed", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fmem_replace.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fmem_replace.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmem_replace.fixed?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -90,3 +90,37 @@ fn msrv_1_40() {\n     let mut s = String::from(\"foo\");\n     let _ = std::mem::take(&mut s);\n }\n+\n+fn issue9824() {\n+    struct Foo<'a>(Option<&'a str>);\n+    impl<'a> std::ops::Deref for Foo<'a> {\n+        type Target = Option<&'a str>;\n+\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    impl<'a> std::ops::DerefMut for Foo<'a> {\n+        fn deref_mut(&mut self) -> &mut Self::Target {\n+            &mut self.0\n+        }\n+    }\n+\n+    struct Bar {\n+        opt: Option<u8>,\n+        val: String,\n+    }\n+\n+    let mut f = Foo(Some(\"foo\"));\n+    let mut b = Bar {\n+        opt: Some(1),\n+        val: String::from(\"bar\"),\n+    };\n+\n+    // replace option with none\n+    let _ = f.0.take();\n+    let _ = (*f).take();\n+    let _ = b.opt.take();\n+    // replace with default\n+    let _ = std::mem::take(&mut b.val);\n+}"}, {"sha": "fa2903addbc0330b68c5683c308f4131a53e2b20", "filename": "tests/ui/mem_replace.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmem_replace.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -90,3 +90,37 @@ fn msrv_1_40() {\n     let mut s = String::from(\"foo\");\n     let _ = std::mem::replace(&mut s, String::default());\n }\n+\n+fn issue9824() {\n+    struct Foo<'a>(Option<&'a str>);\n+    impl<'a> std::ops::Deref for Foo<'a> {\n+        type Target = Option<&'a str>;\n+\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    impl<'a> std::ops::DerefMut for Foo<'a> {\n+        fn deref_mut(&mut self) -> &mut Self::Target {\n+            &mut self.0\n+        }\n+    }\n+\n+    struct Bar {\n+        opt: Option<u8>,\n+        val: String,\n+    }\n+\n+    let mut f = Foo(Some(\"foo\"));\n+    let mut b = Bar {\n+        opt: Some(1),\n+        val: String::from(\"bar\"),\n+    };\n+\n+    // replace option with none\n+    let _ = std::mem::replace(&mut f.0, None);\n+    let _ = std::mem::replace(&mut *f, None);\n+    let _ = std::mem::replace(&mut b.opt, None);\n+    // replace with default\n+    let _ = std::mem::replace(&mut b.val, String::default());\n+}"}, {"sha": "58b57be750702aba27810957b9ad7b7f1d809d6c", "filename": "tests/ui/mem_replace.stderr", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fmem_replace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fmem_replace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmem_replace.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -122,5 +122,29 @@ error: replacing a value of type `T` with `T::default()` is better expressed usi\n LL |     let _ = std::mem::replace(&mut s, String::default());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::mem::take(&mut s)`\n \n-error: aborting due to 20 previous errors\n+error: replacing an `Option` with `None`\n+  --> $DIR/mem_replace.rs:121:13\n+   |\n+LL |     let _ = std::mem::replace(&mut f.0, None);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider `Option::take()` instead: `f.0.take()`\n+\n+error: replacing an `Option` with `None`\n+  --> $DIR/mem_replace.rs:122:13\n+   |\n+LL |     let _ = std::mem::replace(&mut *f, None);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider `Option::take()` instead: `(*f).take()`\n+\n+error: replacing an `Option` with `None`\n+  --> $DIR/mem_replace.rs:123:13\n+   |\n+LL |     let _ = std::mem::replace(&mut b.opt, None);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider `Option::take()` instead: `b.opt.take()`\n+\n+error: replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\n+  --> $DIR/mem_replace.rs:125:13\n+   |\n+LL |     let _ = std::mem::replace(&mut b.val, String::default());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `std::mem::take(&mut b.val)`\n+\n+error: aborting due to 24 previous errors\n "}, {"sha": "57c08996ce25d38660d096451594efdeea17948d", "filename": "tests/ui/needless_return.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fneedless_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fneedless_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.fixed?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -307,4 +307,13 @@ mod issue10049 {\n     }\n }\n \n+fn test_match_as_stmt() {\n+    let x = 9;\n+    match x {\n+        1 => 2,\n+        2 => return,\n+        _ => 0,\n+    };\n+}\n+\n fn main() {}"}, {"sha": "7c1feefbe32bb026fa06e4393c3e8fe0d83e24b0", "filename": "tests/ui/needless_return.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -317,4 +317,13 @@ mod issue10049 {\n     }\n }\n \n+fn test_match_as_stmt() {\n+    let x = 9;\n+    match x {\n+        1 => 2,\n+        2 => return,\n+        _ => 0,\n+    };\n+}\n+\n fn main() {}"}, {"sha": "80cc7c60f56e586d67cf8be08aaf4733edbc2a17", "filename": "tests/ui/nonminimal_bool.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fnonminimal_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fnonminimal_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnonminimal_bool.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -92,3 +92,21 @@ fn issue_10523_2() {\n     }\n     if a!() {}\n }\n+\n+fn issue_10435() {\n+    let x = vec![0];\n+    let y = vec![1];\n+    let z = vec![2];\n+\n+    // vvv Should not lint\n+    #[allow(clippy::nonminimal_bool)]\n+    if !x.is_empty() && !(y.is_empty() || z.is_empty()) {\n+        println!(\"{}\", line!());\n+    }\n+\n+    // vvv Should not lint (#10435 talks about a bug where it lints)\n+    #[allow(clippy::nonminimal_bool)]\n+    if !(x == [0]) {\n+        println!(\"{}\", line!());\n+    }\n+}"}, {"sha": "538513e9156f8851fe0f76b6cf9999937994c395", "filename": "tests/ui/print_literal.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fprint_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fprint_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_literal.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -38,4 +38,8 @@ fn main() {\n     // named args shouldn't change anything either\n     println!(\"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n     println!(\"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n+\n+    // The string literal from `file!()` has a callsite span that isn't marked as coming from an\n+    // expansion\n+    println!(\"file: {}\", file!());\n }"}, {"sha": "ad96993c4a78c470968025745e6ea90b66aa06a5", "filename": "tests/ui/redundant_async_block.fixed", "status": "modified", "additions": 115, "deletions": 33, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fredundant_async_block.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fredundant_async_block.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_async_block.fixed?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused)]\n+#![allow(unused, clippy::manual_async_fn)]\n #![warn(clippy::redundant_async_block)]\n \n use std::future::Future;\n@@ -16,40 +16,16 @@ async fn func2() -> String {\n     x.await\n }\n \n-macro_rules! await_in_macro {\n-    ($e:expr) => {\n-        std::convert::identity($e).await\n-    };\n-}\n-\n-async fn func3(n: usize) -> usize {\n-    // Do not lint (suggestion would be `std::convert::identity(func1(n))`\n-    // which copies code from inside the macro)\n-    async move { await_in_macro!(func1(n)) }.await\n-}\n-\n-// This macro should never be linted as `$e` might contain `.await`\n-macro_rules! async_await_parameter_in_macro {\n-    ($e:expr) => {\n-        async { $e.await }\n-    };\n-}\n-\n-// MISSED OPPORTUNITY: this macro could be linted as the `async` block does not\n-// contain code coming from the parameters\n-macro_rules! async_await_in_macro {\n-    ($f:expr) => {\n-        ($f)(async { func2().await })\n-    };\n-}\n-\n fn main() {\n     let fut1 = async { 17 };\n+    // Lint\n     let fut2 = fut1;\n \n     let fut1 = async { 25 };\n+    // Lint\n     let fut2 = fut1;\n \n+    // Lint\n     let fut = async { 42 };\n \n     // Do not lint: not a single expression\n@@ -60,15 +36,12 @@ fn main() {\n \n     // Do not lint: expression contains `.await`\n     let fut = async { func1(func2().await.len()).await };\n-\n-    let fut = async_await_parameter_in_macro!(func2());\n-    let fut = async_await_in_macro!(std::convert::identity);\n }\n \n #[allow(clippy::let_and_return)]\n fn capture_local() -> impl Future<Output = i32> {\n-    // Lint\n     let fut = async { 17 };\n+    // Lint\n     fut\n }\n \n@@ -80,11 +53,39 @@ fn capture_local_closure(s: &str) -> impl Future<Output = &str> {\n \n #[allow(clippy::let_and_return)]\n fn capture_arg(s: &str) -> impl Future<Output = &str> {\n-    // Lint\n     let fut = async move { s };\n+    // Lint\n     fut\n }\n \n+fn capture_future_arg<T>(f: impl Future<Output = T>) -> impl Future<Output = T> {\n+    // Lint\n+    f\n+}\n+\n+fn capture_func_result<FN, F, T>(f: FN) -> impl Future<Output = T>\n+where\n+    F: Future<Output = T>,\n+    FN: FnOnce() -> F,\n+{\n+    // Do not lint, as f() would be evaluated prematurely\n+    async { f().await }\n+}\n+\n+fn double_future(f: impl Future<Output = impl Future<Output = u32>>) -> impl Future<Output = u32> {\n+    // Do not lint, we will get a `.await` outside a `.async`\n+    async { f.await.await }\n+}\n+\n+fn await_in_async<F, R>(f: F) -> impl Future<Output = u32>\n+where\n+    F: FnOnce() -> R,\n+    R: Future<Output = u32>,\n+{\n+    // Lint\n+    async { f().await + 1 }\n+}\n+\n #[derive(Debug, Clone)]\n struct F {}\n \n@@ -109,3 +110,84 @@ fn capture() {\n     // Do not lint: `val` would not live long enough\n     spawn(async { work(&{ val }).await });\n }\n+\n+fn await_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e:expr) => {\n+            $e.await\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    // or return different things depending on its argument\n+    async { mac!(async { 42 }) }\n+}\n+\n+fn async_expr_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            async { 42 }\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    async { mac!().await }\n+}\n+\n+fn async_expr_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            async { 42 }\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    async { ({ mac!() }).await }\n+}\n+\n+fn all_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            // Lint\n+            async { 42 }\n+        };\n+    }\n+    mac!()\n+}\n+\n+fn parts_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Do not lint: `$e` might not always be side-effect free\n+            async { $e.await }\n+        };\n+    }\n+    mac!(async { 42 })\n+}\n+\n+fn safe_parts_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Lint\n+            async { $e }\n+        };\n+    }\n+    mac!(42)\n+}\n+\n+fn parts_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Do not lint: `$e` might not always be side-effect free\n+            async { ($e,).0.await }\n+        };\n+    }\n+    let f = std::future::ready(42);\n+    mac!(f)\n+}\n+\n+fn await_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e:expr) => {{ $e }.await};\n+    }\n+    // Do not lint: the macro may change in the future\n+    // or return different things depending on its argument\n+    async { mac!(async { 42 }) }\n+}"}, {"sha": "7ae235583694dd2e66371440b9fc1a5920e0b7cd", "filename": "tests/ui/redundant_async_block.rs", "status": "modified", "additions": 115, "deletions": 33, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fredundant_async_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fredundant_async_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_async_block.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused)]\n+#![allow(unused, clippy::manual_async_fn)]\n #![warn(clippy::redundant_async_block)]\n \n use std::future::Future;\n@@ -16,40 +16,16 @@ async fn func2() -> String {\n     x.await\n }\n \n-macro_rules! await_in_macro {\n-    ($e:expr) => {\n-        std::convert::identity($e).await\n-    };\n-}\n-\n-async fn func3(n: usize) -> usize {\n-    // Do not lint (suggestion would be `std::convert::identity(func1(n))`\n-    // which copies code from inside the macro)\n-    async move { await_in_macro!(func1(n)) }.await\n-}\n-\n-// This macro should never be linted as `$e` might contain `.await`\n-macro_rules! async_await_parameter_in_macro {\n-    ($e:expr) => {\n-        async { $e.await }\n-    };\n-}\n-\n-// MISSED OPPORTUNITY: this macro could be linted as the `async` block does not\n-// contain code coming from the parameters\n-macro_rules! async_await_in_macro {\n-    ($f:expr) => {\n-        ($f)(async { func2().await })\n-    };\n-}\n-\n fn main() {\n     let fut1 = async { 17 };\n+    // Lint\n     let fut2 = async { fut1.await };\n \n     let fut1 = async { 25 };\n+    // Lint\n     let fut2 = async move { fut1.await };\n \n+    // Lint\n     let fut = async { async { 42 }.await };\n \n     // Do not lint: not a single expression\n@@ -60,15 +36,12 @@ fn main() {\n \n     // Do not lint: expression contains `.await`\n     let fut = async { func1(func2().await.len()).await };\n-\n-    let fut = async_await_parameter_in_macro!(func2());\n-    let fut = async_await_in_macro!(std::convert::identity);\n }\n \n #[allow(clippy::let_and_return)]\n fn capture_local() -> impl Future<Output = i32> {\n-    // Lint\n     let fut = async { 17 };\n+    // Lint\n     async move { fut.await }\n }\n \n@@ -80,11 +53,39 @@ fn capture_local_closure(s: &str) -> impl Future<Output = &str> {\n \n #[allow(clippy::let_and_return)]\n fn capture_arg(s: &str) -> impl Future<Output = &str> {\n-    // Lint\n     let fut = async move { s };\n+    // Lint\n     async move { fut.await }\n }\n \n+fn capture_future_arg<T>(f: impl Future<Output = T>) -> impl Future<Output = T> {\n+    // Lint\n+    async { f.await }\n+}\n+\n+fn capture_func_result<FN, F, T>(f: FN) -> impl Future<Output = T>\n+where\n+    F: Future<Output = T>,\n+    FN: FnOnce() -> F,\n+{\n+    // Do not lint, as f() would be evaluated prematurely\n+    async { f().await }\n+}\n+\n+fn double_future(f: impl Future<Output = impl Future<Output = u32>>) -> impl Future<Output = u32> {\n+    // Do not lint, we will get a `.await` outside a `.async`\n+    async { f.await.await }\n+}\n+\n+fn await_in_async<F, R>(f: F) -> impl Future<Output = u32>\n+where\n+    F: FnOnce() -> R,\n+    R: Future<Output = u32>,\n+{\n+    // Lint\n+    async { async { f().await + 1 }.await }\n+}\n+\n #[derive(Debug, Clone)]\n struct F {}\n \n@@ -109,3 +110,84 @@ fn capture() {\n     // Do not lint: `val` would not live long enough\n     spawn(async { work(&{ val }).await });\n }\n+\n+fn await_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e:expr) => {\n+            $e.await\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    // or return different things depending on its argument\n+    async { mac!(async { 42 }) }\n+}\n+\n+fn async_expr_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            async { 42 }\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    async { mac!().await }\n+}\n+\n+fn async_expr_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            async { 42 }\n+        };\n+    }\n+    // Do not lint: the macro may change in the future\n+    async { ({ mac!() }).await }\n+}\n+\n+fn all_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        () => {\n+            // Lint\n+            async { async { 42 }.await }\n+        };\n+    }\n+    mac!()\n+}\n+\n+fn parts_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Do not lint: `$e` might not always be side-effect free\n+            async { $e.await }\n+        };\n+    }\n+    mac!(async { 42 })\n+}\n+\n+fn safe_parts_from_macro() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Lint\n+            async { async { $e }.await }\n+        };\n+    }\n+    mac!(42)\n+}\n+\n+fn parts_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e: expr) => {\n+            // Do not lint: `$e` might not always be side-effect free\n+            async { ($e,).0.await }\n+        };\n+    }\n+    let f = std::future::ready(42);\n+    mac!(f)\n+}\n+\n+fn await_from_macro_deep() -> impl Future<Output = u32> {\n+    macro_rules! mac {\n+        ($e:expr) => {{ $e }.await};\n+    }\n+    // Do not lint: the macro may change in the future\n+    // or return different things depending on its argument\n+    async { mac!(async { 42 }) }\n+}"}, {"sha": "f3dcb09b4440ade2e5211149a8e09134d040af9e", "filename": "tests/ui/redundant_async_block.stderr", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fredundant_async_block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fredundant_async_block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_async_block.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -7,34 +7,68 @@ LL |     let x = async { f.await };\n    = note: `-D clippy::redundant-async-block` implied by `-D warnings`\n \n error: this async expression only awaits a single future\n-  --> $DIR/redundant_async_block.rs:48:16\n+  --> $DIR/redundant_async_block.rs:22:16\n    |\n LL |     let fut2 = async { fut1.await };\n    |                ^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `fut1`\n \n error: this async expression only awaits a single future\n-  --> $DIR/redundant_async_block.rs:51:16\n+  --> $DIR/redundant_async_block.rs:26:16\n    |\n LL |     let fut2 = async move { fut1.await };\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `fut1`\n \n error: this async expression only awaits a single future\n-  --> $DIR/redundant_async_block.rs:53:15\n+  --> $DIR/redundant_async_block.rs:29:15\n    |\n LL |     let fut = async { async { 42 }.await };\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `async { 42 }`\n \n error: this async expression only awaits a single future\n-  --> $DIR/redundant_async_block.rs:72:5\n+  --> $DIR/redundant_async_block.rs:45:5\n    |\n LL |     async move { fut.await }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `fut`\n \n error: this async expression only awaits a single future\n-  --> $DIR/redundant_async_block.rs:85:5\n+  --> $DIR/redundant_async_block.rs:58:5\n    |\n LL |     async move { fut.await }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `fut`\n \n-error: aborting due to 6 previous errors\n+error: this async expression only awaits a single future\n+  --> $DIR/redundant_async_block.rs:63:5\n+   |\n+LL |     async { f.await }\n+   |     ^^^^^^^^^^^^^^^^^ help: you can reduce it to: `f`\n+\n+error: this async expression only awaits a single future\n+  --> $DIR/redundant_async_block.rs:86:5\n+   |\n+LL |     async { async { f().await + 1 }.await }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `async { f().await + 1 }`\n+\n+error: this async expression only awaits a single future\n+  --> $DIR/redundant_async_block.rs:149:13\n+   |\n+LL |             async { async { 42 }.await }\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `async { 42 }`\n+...\n+LL |     mac!()\n+   |     ------ in this macro invocation\n+   |\n+   = note: this error originates in the macro `mac` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: this async expression only awaits a single future\n+  --> $DIR/redundant_async_block.rs:169:13\n+   |\n+LL |             async { async { $e }.await }\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `async { $e }`\n+...\n+LL |     mac!(42)\n+   |     -------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `mac` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "8c96c4715d308a08a00f0d2cfd39ce3f79b5f6ac", "filename": "tests/ui/single_component_path_imports.fixed", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsingle_component_path_imports.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsingle_component_path_imports.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_component_path_imports.fixed?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -2,9 +2,11 @@\n #![warn(clippy::single_component_path_imports)]\n #![allow(unused_imports)]\n \n+use core;\n \n use serde as edres;\n pub use serde;\n+use std;\n \n macro_rules! m {\n     () => {\n@@ -17,6 +19,10 @@ fn main() {\n \n     // False positive #5154, shouldn't trigger lint.\n     m!();\n+\n+    // False positive #10549\n+    let _ = self::std::io::stdout();\n+    let _ = 0 as self::core::ffi::c_uint;\n }\n \n mod hello_mod {"}, {"sha": "8434bf7eaf1f55596e56880202a20989e689fda4", "filename": "tests/ui/single_component_path_imports.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsingle_component_path_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsingle_component_path_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_component_path_imports.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -2,9 +2,11 @@\n #![warn(clippy::single_component_path_imports)]\n #![allow(unused_imports)]\n \n+use core;\n use regex;\n use serde as edres;\n pub use serde;\n+use std;\n \n macro_rules! m {\n     () => {\n@@ -17,6 +19,10 @@ fn main() {\n \n     // False positive #5154, shouldn't trigger lint.\n     m!();\n+\n+    // False positive #10549\n+    let _ = self::std::io::stdout();\n+    let _ = 0 as self::core::ffi::c_uint;\n }\n \n mod hello_mod {"}, {"sha": "d69a86470a5e5de43cc686ed8a0bf059e8e9dcb7", "filename": "tests/ui/single_component_path_imports.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsingle_component_path_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsingle_component_path_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_component_path_imports.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,13 +1,13 @@\n error: this import is redundant\n-  --> $DIR/single_component_path_imports.rs:5:1\n+  --> $DIR/single_component_path_imports.rs:6:1\n    |\n LL | use regex;\n    | ^^^^^^^^^^ help: remove it entirely\n    |\n    = note: `-D clippy::single-component-path-imports` implied by `-D warnings`\n \n error: this import is redundant\n-  --> $DIR/single_component_path_imports.rs:23:5\n+  --> $DIR/single_component_path_imports.rs:29:5\n    |\n LL |     use regex;\n    |     ^^^^^^^^^^ help: remove it entirely"}, {"sha": "b404df94d3c29ce2b4cc5fdc5bfa71db838da5db", "filename": "tests/ui/suspicious_doc_comments.fixed", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsuspicious_doc_comments.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsuspicious_doc_comments.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_doc_comments.fixed?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,81 @@\n+// run-rustfix\n+#![allow(unused)]\n+#![warn(clippy::suspicious_doc_comments)]\n+\n+//! Real module documentation.\n+//! Fake module documentation.\n+fn baz() {}\n+\n+pub mod singleline_outer_doc {\n+    //! This module contains useful functions.\n+\n+    pub fn bar() {}\n+}\n+\n+pub mod singleline_inner_doc {\n+    //! This module contains useful functions.\n+\n+    pub fn bar() {}\n+}\n+\n+pub mod multiline_outer_doc {\n+    /*! This module contains useful functions.\n+     */\n+\n+    pub fn bar() {}\n+}\n+\n+pub mod multiline_inner_doc {\n+    /*! This module contains useful functions.\n+     */\n+\n+    pub fn bar() {}\n+}\n+\n+pub mod multiline_outer_doc2 {\n+    //! This module\n+    //! contains\n+    //! useful functions.\n+\n+    pub fn bar() {}\n+}\n+\n+pub mod multiline_outer_doc3 {\n+    //! a\n+    //! b\n+\n+    /// c\n+    pub fn bar() {}\n+}\n+\n+pub mod multiline_outer_doc4 {\n+    //! a\n+    /// b\n+    pub fn bar() {}\n+}\n+\n+pub mod multiline_outer_doc_gap {\n+    //! a\n+\n+    //! b\n+    pub fn bar() {}\n+}\n+\n+pub mod multiline_outer_doc_commented {\n+    /////! This outer doc comment was commented out.\n+    pub fn bar() {}\n+}\n+\n+pub mod outer_doc_macro {\n+    //! Very cool macro\n+    macro_rules! x {\n+        () => {};\n+    }\n+}\n+\n+pub mod useless_outer_doc {\n+    //! Huh.\n+    use std::mem;\n+}\n+\n+fn main() {}"}, {"sha": "46eff51e220f5bd713bdc1fff3997e4ac319f907", "filename": "tests/ui/suspicious_doc_comments.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsuspicious_doc_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsuspicious_doc_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_doc_comments.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,81 @@\n+// run-rustfix\n+#![allow(unused)]\n+#![warn(clippy::suspicious_doc_comments)]\n+\n+//! Real module documentation.\n+///! Fake module documentation.\n+fn baz() {}\n+\n+pub mod singleline_outer_doc {\n+    ///! This module contains useful functions.\n+\n+    pub fn bar() {}\n+}\n+\n+pub mod singleline_inner_doc {\n+    //! This module contains useful functions.\n+\n+    pub fn bar() {}\n+}\n+\n+pub mod multiline_outer_doc {\n+    /**! This module contains useful functions.\n+     */\n+\n+    pub fn bar() {}\n+}\n+\n+pub mod multiline_inner_doc {\n+    /*! This module contains useful functions.\n+     */\n+\n+    pub fn bar() {}\n+}\n+\n+pub mod multiline_outer_doc2 {\n+    ///! This module\n+    ///! contains\n+    ///! useful functions.\n+\n+    pub fn bar() {}\n+}\n+\n+pub mod multiline_outer_doc3 {\n+    ///! a\n+    ///! b\n+\n+    /// c\n+    pub fn bar() {}\n+}\n+\n+pub mod multiline_outer_doc4 {\n+    ///! a\n+    /// b\n+    pub fn bar() {}\n+}\n+\n+pub mod multiline_outer_doc_gap {\n+    ///! a\n+\n+    ///! b\n+    pub fn bar() {}\n+}\n+\n+pub mod multiline_outer_doc_commented {\n+    /////! This outer doc comment was commented out.\n+    pub fn bar() {}\n+}\n+\n+pub mod outer_doc_macro {\n+    ///! Very cool macro\n+    macro_rules! x {\n+        () => {};\n+    }\n+}\n+\n+pub mod useless_outer_doc {\n+    ///! Huh.\n+    use std::mem;\n+}\n+\n+fn main() {}"}, {"sha": "6c167df27873cd96a62b27ea26497d50c9c2bc49", "filename": "tests/ui/suspicious_doc_comments.stderr", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsuspicious_doc_comments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsuspicious_doc_comments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_doc_comments.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,114 @@\n+error: this is an outer doc comment and does not apply to the parent module or crate\n+  --> $DIR/suspicious_doc_comments.rs:6:1\n+   |\n+LL | ///! Fake module documentation.\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::suspicious-doc-comments` implied by `-D warnings`\n+help: use an inner doc comment to document the parent module or crate\n+   |\n+LL | //! Fake module documentation.\n+   |\n+\n+error: this is an outer doc comment and does not apply to the parent module or crate\n+  --> $DIR/suspicious_doc_comments.rs:10:5\n+   |\n+LL |     ///! This module contains useful functions.\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use an inner doc comment to document the parent module or crate\n+   |\n+LL |     //! This module contains useful functions.\n+   |\n+\n+error: this is an outer doc comment and does not apply to the parent module or crate\n+  --> $DIR/suspicious_doc_comments.rs:22:5\n+   |\n+LL | /     /**! This module contains useful functions.\n+LL | |      */\n+   | |_______^\n+   |\n+help: use an inner doc comment to document the parent module or crate\n+   |\n+LL ~     /*! This module contains useful functions.\n+LL +      */\n+   |\n+\n+error: this is an outer doc comment and does not apply to the parent module or crate\n+  --> $DIR/suspicious_doc_comments.rs:36:5\n+   |\n+LL | /     ///! This module\n+LL | |     ///! contains\n+LL | |     ///! useful functions.\n+   | |__________________________^\n+   |\n+help: use an inner doc comment to document the parent module or crate\n+   |\n+LL ~     //! This module\n+LL ~     //! contains\n+LL ~     //! useful functions.\n+   |\n+\n+error: this is an outer doc comment and does not apply to the parent module or crate\n+  --> $DIR/suspicious_doc_comments.rs:44:5\n+   |\n+LL | /     ///! a\n+LL | |     ///! b\n+   | |__________^\n+   |\n+help: use an inner doc comment to document the parent module or crate\n+   |\n+LL ~     //! a\n+LL ~     //! b\n+   |\n+\n+error: this is an outer doc comment and does not apply to the parent module or crate\n+  --> $DIR/suspicious_doc_comments.rs:52:5\n+   |\n+LL |     ///! a\n+   |     ^^^^^^\n+   |\n+help: use an inner doc comment to document the parent module or crate\n+   |\n+LL |     //! a\n+   |\n+\n+error: this is an outer doc comment and does not apply to the parent module or crate\n+  --> $DIR/suspicious_doc_comments.rs:58:5\n+   |\n+LL | /     ///! a\n+LL | |\n+LL | |     ///! b\n+   | |__________^\n+   |\n+help: use an inner doc comment to document the parent module or crate\n+   |\n+LL ~     //! a\n+LL | \n+LL ~     //! b\n+   |\n+\n+error: this is an outer doc comment and does not apply to the parent module or crate\n+  --> $DIR/suspicious_doc_comments.rs:70:5\n+   |\n+LL |     ///! Very cool macro\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use an inner doc comment to document the parent module or crate\n+   |\n+LL |     //! Very cool macro\n+   |\n+\n+error: this is an outer doc comment and does not apply to the parent module or crate\n+  --> $DIR/suspicious_doc_comments.rs:77:5\n+   |\n+LL |     ///! Huh.\n+   |     ^^^^^^^^^\n+   |\n+help: use an inner doc comment to document the parent module or crate\n+   |\n+LL |     //! Huh.\n+   |\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "ad98c7f4966ffcf387f1f33d26bf7fd229ad75e7", "filename": "tests/ui/suspicious_doc_comments_unfixable.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsuspicious_doc_comments_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsuspicious_doc_comments_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_doc_comments_unfixable.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,16 @@\n+#![allow(unused)]\n+#![warn(clippy::suspicious_doc_comments)]\n+\n+///! a\n+///! b\n+/// c\n+///! d\n+pub fn foo() {}\n+\n+///! a\n+///! b\n+/// c\n+///! d\n+use std::mem;\n+\n+fn main() {}"}, {"sha": "f89146dad36e0a07b6573683bb8ba7e09ffed4f1", "filename": "tests/ui/suspicious_doc_comments_unfixable.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsuspicious_doc_comments_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Fsuspicious_doc_comments_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_doc_comments_unfixable.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,37 @@\n+error: this is an outer doc comment and does not apply to the parent module or crate\n+  --> $DIR/suspicious_doc_comments_unfixable.rs:4:1\n+   |\n+LL | / ///! a\n+LL | | ///! b\n+LL | | /// c\n+LL | | ///! d\n+   | |______^\n+   |\n+   = note: `-D clippy::suspicious-doc-comments` implied by `-D warnings`\n+help: use an inner doc comment to document the parent module or crate\n+   |\n+LL + //! a\n+LL + //! b\n+LL | /// c\n+LL + //! d\n+   |\n+\n+error: this is an outer doc comment and does not apply to the parent module or crate\n+  --> $DIR/suspicious_doc_comments_unfixable.rs:10:1\n+   |\n+LL | / ///! a\n+LL | | ///! b\n+LL | | /// c\n+LL | | ///! d\n+   | |______^\n+   |\n+help: use an inner doc comment to document the parent module or crate\n+   |\n+LL + //! a\n+LL + //! b\n+LL | /// c\n+LL + //! d\n+   |\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "1982b1d0107f8c473904885a7489622c2681daca", "filename": "tests/ui/tests_outside_test_module.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Ftests_outside_test_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Ftests_outside_test_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftests_outside_test_module.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,18 @@\n+// compile-flags: --test\n+#![allow(unused)]\n+#![warn(clippy::tests_outside_test_module)]\n+\n+fn main() {\n+    // test code goes here\n+}\n+\n+// Should lint\n+#[test]\n+fn my_test() {}\n+\n+#[cfg(test)]\n+mod tests {\n+    // Should not lint\n+    #[test]\n+    fn my_test() {}\n+}"}, {"sha": "125a79d6edfed9e98eb528a5f17cbda967a902ee", "filename": "tests/ui/tests_outside_test_module.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Ftests_outside_test_module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Ftests_outside_test_module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftests_outside_test_module.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,11 @@\n+error: this function marked with #[test] is outside a #[cfg(test)] module\n+  --> $DIR/tests_outside_test_module.rs:11:1\n+   |\n+LL | fn my_test() {}\n+   | ^^^^^^^^^^^^^^^\n+   |\n+   = note: move it to a testing module marked with #[cfg(test)]\n+   = note: `-D clippy::tests-outside-test-module` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "cc84ba25bd0d79edf9ef503b3ff218ebad3404df", "filename": "tests/ui/transmutes_expressible_as_ptr_casts.fixed", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -4,7 +4,7 @@\n // would otherwise be responsible for\n #![warn(clippy::useless_transmute)]\n #![warn(clippy::transmute_ptr_to_ptr)]\n-#![allow(dead_code, unused_unsafe, clippy::borrow_as_ptr)]\n+#![allow(unused, clippy::borrow_as_ptr)]\n \n use std::mem::{size_of, transmute};\n \n@@ -77,3 +77,9 @@ fn cannot_be_expressed_as_pointer_cast(in_param: Single) -> Pair {\n \n     unsafe { transmute::<Single, Pair>(in_param) }\n }\n+\n+fn issue_10449() {\n+    fn f() {}\n+\n+    let _x: u8 = unsafe { *(f as *const u8) };\n+}"}, {"sha": "aa65ab4dd2475372fa1ba7ab3ddf2a119a279e0e", "filename": "tests/ui/transmutes_expressible_as_ptr_casts.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -4,7 +4,7 @@\n // would otherwise be responsible for\n #![warn(clippy::useless_transmute)]\n #![warn(clippy::transmute_ptr_to_ptr)]\n-#![allow(dead_code, unused_unsafe, clippy::borrow_as_ptr)]\n+#![allow(unused, clippy::borrow_as_ptr)]\n \n use std::mem::{size_of, transmute};\n \n@@ -77,3 +77,9 @@ fn cannot_be_expressed_as_pointer_cast(in_param: Single) -> Pair {\n \n     unsafe { transmute::<Single, Pair>(in_param) }\n }\n+\n+fn issue_10449() {\n+    fn f() {}\n+\n+    let _x: u8 = unsafe { *std::mem::transmute::<fn(), *const u8>(f) };\n+}"}, {"sha": "58f5162c78e78839bdafd892fa8dd5a096cb3095", "filename": "tests/ui/transmutes_expressible_as_ptr_casts.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -58,5 +58,11 @@ error: transmute from a reference to a pointer\n LL |     unsafe { transmute::<&[i32; 1], *const u8>(in_param) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `in_param as *const [i32; 1] as *const u8`\n \n-error: aborting due to 9 previous errors\n+error: transmute from `fn()` to `*const u8` which could be expressed as a pointer cast instead\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:84:28\n+   |\n+LL |     let _x: u8 = unsafe { *std::mem::transmute::<fn(), *const u8>(f) };\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(f as *const u8)`\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "c996de89422b57a7f63f1dee5dd7fdd22b2396ae", "filename": "tests/ui/uninit.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,7 +1,7 @@\n #![feature(stmt_expr_attributes)]\n #![allow(clippy::let_unit_value, invalid_value)]\n \n-use std::mem::{self, MaybeUninit};\n+use std::mem::MaybeUninit;\n \n union MyOwnMaybeUninit {\n     value: u8,\n@@ -30,12 +30,24 @@ fn main() {\n     let _: [u8; 0] = unsafe { MaybeUninit::uninit().assume_init() };\n \n     // Was a false negative.\n-    let _: usize = unsafe { mem::MaybeUninit::uninit().assume_init() };\n+    let _: usize = unsafe { MaybeUninit::uninit().assume_init() };\n \n     polymorphic::<()>();\n+    polymorphic_maybe_uninit_array::<10>();\n+    polymorphic_maybe_uninit::<u8>();\n \n     fn polymorphic<T>() {\n         // We are conservative around polymorphic types.\n-        let _: T = unsafe { mem::MaybeUninit::uninit().assume_init() };\n+        let _: T = unsafe { MaybeUninit::uninit().assume_init() };\n+    }\n+\n+    fn polymorphic_maybe_uninit_array<const N: usize>() {\n+        // While the type is polymorphic, MaybeUninit<u8> is not.\n+        let _: [MaybeUninit<u8>; N] = unsafe { MaybeUninit::uninit().assume_init() };\n+    }\n+\n+    fn polymorphic_maybe_uninit<T>() {\n+        // The entire type is polymorphic, but it's wrapped in a MaybeUninit.\n+        let _: MaybeUninit<T> = unsafe { MaybeUninit::uninit().assume_init() };\n     }\n }"}, {"sha": "248de56da76cbab3e6140038f642da1e473e5203", "filename": "tests/ui/uninit.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funinit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funinit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -9,14 +9,14 @@ LL |     let _: usize = unsafe { MaybeUninit::uninit().assume_init() };\n error: this call for this type may be undefined behavior\n   --> $DIR/uninit.rs:33:29\n    |\n-LL |     let _: usize = unsafe { mem::MaybeUninit::uninit().assume_init() };\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _: usize = unsafe { MaybeUninit::uninit().assume_init() };\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this call for this type may be undefined behavior\n-  --> $DIR/uninit.rs:39:29\n+  --> $DIR/uninit.rs:41:29\n    |\n-LL |         let _: T = unsafe { mem::MaybeUninit::uninit().assume_init() };\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: T = unsafe { MaybeUninit::uninit().assume_init() };\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "79effc82fdf7cbf7c1003e74cf854d0473b32c7c", "filename": "tests/ui/uninit_vec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit_vec.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -124,4 +124,12 @@ fn main() {\n             vec.set_len(10);\n         }\n     }\n+\n+    fn poly_maybe_uninit<T>() {\n+        // We are conservative around polymorphic types.\n+        let mut vec: Vec<MaybeUninit<T>> = Vec::with_capacity(1000);\n+        unsafe {\n+            vec.set_len(10);\n+        }\n+    }\n }"}, {"sha": "3122081a44f98b4aded0fdd62401a82f8efb7a67", "filename": "tests/ui/uninlined_format_args.fixed", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funinlined_format_args.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funinlined_format_args.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args.fixed?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,7 +1,7 @@\n // aux-build:proc_macros.rs\n // run-rustfix\n #![warn(clippy::uninlined_format_args)]\n-#![allow(named_arguments_used_positionally, unused_imports, unused_macros, unused_variables)]\n+#![allow(named_arguments_used_positionally, unused)]\n #![allow(clippy::eq_op, clippy::format_in_format_args, clippy::print_literal)]\n \n extern crate proc_macros;\n@@ -119,7 +119,7 @@ fn tester(fn_arg: i32) {\n     println!(\"Width = {local_i32}, value with width = {local_f64:local_i32$}\");\n     println!(\"{local_i32:width$.prec$}\");\n     println!(\"{width:width$.prec$}\");\n-    println!(\"{}\", format!(\"{local_i32}\"));\n+    println!(\"{}\", format!(\"{}\", local_i32));\n     my_println!(\"{}\", local_i32);\n     my_println_args!(\"{}\", local_i32);\n \n@@ -178,3 +178,87 @@ fn _meets_msrv() {\n fn _do_not_fire() {\n     println!(\"{:?}\", None::<()>);\n }\n+\n+macro_rules! _internal {\n+    ($($args:tt)*) => {\n+        println!(\"{}\", format_args!($($args)*))\n+    };\n+}\n+\n+macro_rules! my_println2 {\n+   ($target:expr, $($args:tt)+) => {{\n+       if $target {\n+           _internal!($($args)+)\n+       }\n+    }};\n+}\n+\n+macro_rules! my_println2_args {\n+    ($target:expr, $($args:tt)+) => {{\n+       if $target {\n+           _internal!(\"foo: {}\", format_args!($($args)+))\n+       }\n+    }};\n+}\n+\n+macro_rules! my_concat {\n+    ($fmt:literal $(, $e:expr)*) => {\n+        println!(concat!(\"ERROR: \", $fmt), $($e,)*)\n+    }\n+}\n+\n+macro_rules! my_good_macro {\n+    ($fmt:literal $(, $e:expr)* $(,)?) => {\n+        println!($fmt $(, $e)*)\n+    }\n+}\n+\n+macro_rules! my_bad_macro {\n+    ($fmt:literal, $($e:expr),*) => {\n+        println!($fmt, $($e,)*)\n+    }\n+}\n+\n+macro_rules! my_bad_macro2 {\n+    ($fmt:literal) => {\n+        let s = $fmt.clone();\n+        println!(\"{}\", s);\n+    };\n+    ($fmt:literal, $($e:expr)+) => {\n+        println!($fmt, $($e,)*)\n+    };\n+}\n+\n+// This abomination was suggested by @Alexendoo, may the Rust gods have mercy on their soul...\n+// https://github.com/rust-lang/rust-clippy/pull/9948#issuecomment-1327965962\n+macro_rules! used_twice {\n+    (\n+        large = $large:literal,\n+        small = $small:literal,\n+        $val:expr,\n+    ) => {\n+        if $val < 5 {\n+            println!($small, $val);\n+        } else {\n+            println!($large, $val);\n+        }\n+    };\n+}\n+\n+fn tester2() {\n+    let local_i32 = 1;\n+    my_println2_args!(true, \"{}\", local_i32);\n+    my_println2!(true, \"{}\", local_i32);\n+    my_concat!(\"{}\", local_i32);\n+    my_good_macro!(\"{}\", local_i32);\n+    my_good_macro!(\"{}\", local_i32,);\n+\n+    // FIXME: Broken false positives, currently unhandled\n+    my_bad_macro!(\"{}\", local_i32);\n+    my_bad_macro2!(\"{}\", local_i32);\n+    used_twice! {\n+        large = \"large value: {}\",\n+        small = \"small value: {}\",\n+        local_i32,\n+    };\n+}"}, {"sha": "b153ef256e0c2d25f38a8f463da6a124dfca386d", "filename": "tests/ui/uninlined_format_args.rs", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funinlined_format_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funinlined_format_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -1,7 +1,7 @@\n // aux-build:proc_macros.rs\n // run-rustfix\n #![warn(clippy::uninlined_format_args)]\n-#![allow(named_arguments_used_positionally, unused_imports, unused_macros, unused_variables)]\n+#![allow(named_arguments_used_positionally, unused)]\n #![allow(clippy::eq_op, clippy::format_in_format_args, clippy::print_literal)]\n \n extern crate proc_macros;\n@@ -183,3 +183,87 @@ fn _meets_msrv() {\n fn _do_not_fire() {\n     println!(\"{:?}\", None::<()>);\n }\n+\n+macro_rules! _internal {\n+    ($($args:tt)*) => {\n+        println!(\"{}\", format_args!($($args)*))\n+    };\n+}\n+\n+macro_rules! my_println2 {\n+   ($target:expr, $($args:tt)+) => {{\n+       if $target {\n+           _internal!($($args)+)\n+       }\n+    }};\n+}\n+\n+macro_rules! my_println2_args {\n+    ($target:expr, $($args:tt)+) => {{\n+       if $target {\n+           _internal!(\"foo: {}\", format_args!($($args)+))\n+       }\n+    }};\n+}\n+\n+macro_rules! my_concat {\n+    ($fmt:literal $(, $e:expr)*) => {\n+        println!(concat!(\"ERROR: \", $fmt), $($e,)*)\n+    }\n+}\n+\n+macro_rules! my_good_macro {\n+    ($fmt:literal $(, $e:expr)* $(,)?) => {\n+        println!($fmt $(, $e)*)\n+    }\n+}\n+\n+macro_rules! my_bad_macro {\n+    ($fmt:literal, $($e:expr),*) => {\n+        println!($fmt, $($e,)*)\n+    }\n+}\n+\n+macro_rules! my_bad_macro2 {\n+    ($fmt:literal) => {\n+        let s = $fmt.clone();\n+        println!(\"{}\", s);\n+    };\n+    ($fmt:literal, $($e:expr)+) => {\n+        println!($fmt, $($e,)*)\n+    };\n+}\n+\n+// This abomination was suggested by @Alexendoo, may the Rust gods have mercy on their soul...\n+// https://github.com/rust-lang/rust-clippy/pull/9948#issuecomment-1327965962\n+macro_rules! used_twice {\n+    (\n+        large = $large:literal,\n+        small = $small:literal,\n+        $val:expr,\n+    ) => {\n+        if $val < 5 {\n+            println!($small, $val);\n+        } else {\n+            println!($large, $val);\n+        }\n+    };\n+}\n+\n+fn tester2() {\n+    let local_i32 = 1;\n+    my_println2_args!(true, \"{}\", local_i32);\n+    my_println2!(true, \"{}\", local_i32);\n+    my_concat!(\"{}\", local_i32);\n+    my_good_macro!(\"{}\", local_i32);\n+    my_good_macro!(\"{}\", local_i32,);\n+\n+    // FIXME: Broken false positives, currently unhandled\n+    my_bad_macro!(\"{}\", local_i32);\n+    my_bad_macro2!(\"{}\", local_i32);\n+    used_twice! {\n+        large = \"large value: {}\",\n+        small = \"small value: {}\",\n+        local_i32,\n+    };\n+}"}, {"sha": "dc4af6ef42ecd5a8201bf00218b4f69b524d8abe", "filename": "tests/ui/uninlined_format_args.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funinlined_format_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funinlined_format_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -774,18 +774,6 @@ LL -     println!(\"{:w$.p$}\", w = width, p = prec);\n LL +     println!(\"{width:width$.prec$}\");\n    |\n \n-error: variables can be used directly in the `format!` string\n-  --> $DIR/uninlined_format_args.rs:125:20\n-   |\n-LL |     println!(\"{}\", format!(\"{}\", local_i32));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: change this to\n-   |\n-LL -     println!(\"{}\", format!(\"{}\", local_i32));\n-LL +     println!(\"{}\", format!(\"{local_i32}\"));\n-   |\n-\n error: variables can be used directly in the `format!` string\n   --> $DIR/uninlined_format_args.rs:143:5\n    |\n@@ -856,5 +844,5 @@ LL -     println!(\"expand='{}'\", local_i32);\n LL +     println!(\"expand='{local_i32}'\");\n    |\n \n-error: aborting due to 72 previous errors\n+error: aborting due to 71 previous errors\n "}, {"sha": "fe60d929759ba8eff87cc691df8f89d345ea78d1", "filename": "tests/ui/unnecessary_box_returns.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funnecessary_box_returns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funnecessary_box_returns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_box_returns.rs?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,60 @@\n+#![warn(clippy::unnecessary_box_returns)]\n+\n+trait Bar {\n+    // lint\n+    fn baz(&self) -> Box<usize>;\n+}\n+\n+pub struct Foo {}\n+\n+impl Bar for Foo {\n+    // don't lint: this is a problem with the trait, not the implementation\n+    fn baz(&self) -> Box<usize> {\n+        Box::new(42)\n+    }\n+}\n+\n+impl Foo {\n+    fn baz(&self) -> Box<usize> {\n+        // lint\n+        Box::new(13)\n+    }\n+}\n+\n+// lint\n+fn bxed_usize() -> Box<usize> {\n+    Box::new(5)\n+}\n+\n+// lint\n+fn _bxed_foo() -> Box<Foo> {\n+    Box::new(Foo {})\n+}\n+\n+// don't lint: this is exported\n+pub fn bxed_foo() -> Box<Foo> {\n+    Box::new(Foo {})\n+}\n+\n+// don't lint: str is unsized\n+fn bxed_str() -> Box<str> {\n+    \"Hello, world!\".to_string().into_boxed_str()\n+}\n+\n+// don't lint: function contains the word, \"box\"\n+fn boxed_usize() -> Box<usize> {\n+    Box::new(7)\n+}\n+\n+// don't lint: this has an unspecified return type\n+fn default() {}\n+\n+// don't lint: this doesn't return a Box\n+fn string() -> String {\n+    String::from(\"Hello, world\")\n+}\n+\n+fn main() {\n+    // don't lint: this is a closure\n+    let a = || -> Box<usize> { Box::new(5) };\n+}"}, {"sha": "b17512c10a1773c343d9c9eb9a7b7dd82f6698b4", "filename": "tests/ui/unnecessary_box_returns.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funnecessary_box_returns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funnecessary_box_returns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_box_returns.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -0,0 +1,35 @@\n+error: boxed return of the sized type `usize`\n+  --> $DIR/unnecessary_box_returns.rs:5:22\n+   |\n+LL |     fn baz(&self) -> Box<usize>;\n+   |                      ^^^^^^^^^^ help: try: `usize`\n+   |\n+   = help: changing this also requires a change to the return expressions in this function\n+   = note: `-D clippy::unnecessary-box-returns` implied by `-D warnings`\n+\n+error: boxed return of the sized type `usize`\n+  --> $DIR/unnecessary_box_returns.rs:18:22\n+   |\n+LL |     fn baz(&self) -> Box<usize> {\n+   |                      ^^^^^^^^^^ help: try: `usize`\n+   |\n+   = help: changing this also requires a change to the return expressions in this function\n+\n+error: boxed return of the sized type `usize`\n+  --> $DIR/unnecessary_box_returns.rs:25:20\n+   |\n+LL | fn bxed_usize() -> Box<usize> {\n+   |                    ^^^^^^^^^^ help: try: `usize`\n+   |\n+   = help: changing this also requires a change to the return expressions in this function\n+\n+error: boxed return of the sized type `Foo`\n+  --> $DIR/unnecessary_box_returns.rs:30:19\n+   |\n+LL | fn _bxed_foo() -> Box<Foo> {\n+   |                   ^^^^^^^^ help: try: `Foo`\n+   |\n+   = help: changing this also requires a change to the return expressions in this function\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "2930722b42d9d4f39d33deb8119a3659b11df891", "filename": "tests/ui/unused_format_specs.fixed", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe129a022a0ae1c458b065725a819faabcbdb2b6/tests%2Fui%2Funused_format_specs.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fe129a022a0ae1c458b065725a819faabcbdb2b6/tests%2Fui%2Funused_format_specs.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs.fixed?ref=fe129a022a0ae1c458b065725a819faabcbdb2b6", "patch": "@@ -1,18 +0,0 @@\n-// run-rustfix\n-\n-#![warn(clippy::unused_format_specs)]\n-#![allow(unused)]\n-\n-fn main() {\n-    let f = 1.0f64;\n-    println!(\"{}\", 1.0);\n-    println!(\"{f} {f:?}\");\n-\n-    println!(\"{}\", 1);\n-}\n-\n-fn should_not_lint() {\n-    let f = 1.0f64;\n-    println!(\"{:.1}\", 1.0);\n-    println!(\"{f:.w$} {f:.*?}\", 3, w = 2);\n-}"}, {"sha": "ee192a000d4b55e6fd4d1a8c8ba72238cc626a4f", "filename": "tests/ui/unused_format_specs.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe129a022a0ae1c458b065725a819faabcbdb2b6/tests%2Fui%2Funused_format_specs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe129a022a0ae1c458b065725a819faabcbdb2b6/tests%2Fui%2Funused_format_specs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs.rs?ref=fe129a022a0ae1c458b065725a819faabcbdb2b6", "patch": "@@ -1,18 +0,0 @@\n-// run-rustfix\n-\n-#![warn(clippy::unused_format_specs)]\n-#![allow(unused)]\n-\n-fn main() {\n-    let f = 1.0f64;\n-    println!(\"{:.}\", 1.0);\n-    println!(\"{f:.} {f:.?}\");\n-\n-    println!(\"{:.}\", 1);\n-}\n-\n-fn should_not_lint() {\n-    let f = 1.0f64;\n-    println!(\"{:.1}\", 1.0);\n-    println!(\"{f:.w$} {f:.*?}\", 3, w = 2);\n-}"}, {"sha": "7231c17e74c19cd9de5c4c36d6c227594917f147", "filename": "tests/ui/unused_format_specs.stderr", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fe129a022a0ae1c458b065725a819faabcbdb2b6/tests%2Fui%2Funused_format_specs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe129a022a0ae1c458b065725a819faabcbdb2b6/tests%2Fui%2Funused_format_specs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs.stderr?ref=fe129a022a0ae1c458b065725a819faabcbdb2b6", "patch": "@@ -1,54 +0,0 @@\n-error: empty precision specifier has no effect\n-  --> $DIR/unused_format_specs.rs:8:17\n-   |\n-LL |     println!(\"{:.}\", 1.0);\n-   |                 ^\n-   |\n-   = note: a precision specifier is not required to format floats\n-   = note: `-D clippy::unused-format-specs` implied by `-D warnings`\n-help: remove the `.`\n-   |\n-LL -     println!(\"{:.}\", 1.0);\n-LL +     println!(\"{}\", 1.0);\n-   |\n-\n-error: empty precision specifier has no effect\n-  --> $DIR/unused_format_specs.rs:9:18\n-   |\n-LL |     println!(\"{f:.} {f:.?}\");\n-   |                  ^\n-   |\n-   = note: a precision specifier is not required to format floats\n-help: remove the `.`\n-   |\n-LL -     println!(\"{f:.} {f:.?}\");\n-LL +     println!(\"{f} {f:.?}\");\n-   |\n-\n-error: empty precision specifier has no effect\n-  --> $DIR/unused_format_specs.rs:9:24\n-   |\n-LL |     println!(\"{f:.} {f:.?}\");\n-   |                        ^\n-   |\n-   = note: a precision specifier is not required to format floats\n-help: remove the `.`\n-   |\n-LL -     println!(\"{f:.} {f:.?}\");\n-LL +     println!(\"{f:.} {f:?}\");\n-   |\n-\n-error: empty precision specifier has no effect\n-  --> $DIR/unused_format_specs.rs:11:17\n-   |\n-LL |     println!(\"{:.}\", 1);\n-   |                 ^\n-   |\n-help: remove the `.`\n-   |\n-LL -     println!(\"{:.}\", 1);\n-LL +     println!(\"{}\", 1);\n-   |\n-\n-error: aborting due to 4 previous errors\n-"}, {"sha": "cb7156b6baf0d8cec40121b324b0e6fa9626f258", "filename": "tests/ui/unused_format_specs_unfixable.stderr", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funused_format_specs_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b95029f176e5cdaa88de8ca7f5f59fd15a6d850/tests%2Fui%2Funused_format_specs_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs_unfixable.stderr?ref=6b95029f176e5cdaa88de8ca7f5f59fd15a6d850", "patch": "@@ -37,11 +37,7 @@ error: format specifiers have no effect on `format_args!()`\n LL |     println!(\"{:5}.\", format_args_from_macro!());\n    |               ^^^^\n    |\n-help: for the width to apply consider using `format!()`\n-  --> $DIR/unused_format_specs_unfixable.rs:16:17\n-   |\n-LL |     println!(\"{:5}.\", format_args_from_macro!());\n-   |                 ^\n+   = help: for the width to apply consider using `format!()`\n help: if the current behavior is intentional, remove the format specifiers\n    |\n LL -     println!(\"{:5}.\", format_args_from_macro!());\n@@ -54,11 +50,7 @@ error: format specifiers have no effect on `format_args!()`\n LL |     println!(\"{args:5}\");\n    |               ^^^^^^^^\n    |\n-help: for the width to apply consider using `format!()`\n-  --> $DIR/unused_format_specs_unfixable.rs:19:21\n-   |\n-LL |     println!(\"{args:5}\");\n-   |                     ^\n+   = help: for the width to apply consider using `format!()`\n help: if the current behavior is intentional, remove the format specifiers\n    |\n LL -     println!(\"{args:5}\");"}]}