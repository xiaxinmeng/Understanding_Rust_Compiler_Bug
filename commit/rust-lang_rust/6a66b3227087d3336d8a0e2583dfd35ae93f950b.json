{"sha": "6a66b3227087d3336d8a0e2583dfd35ae93f950b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNjZiMzIyNzA4N2QzMzM2ZDhhMGUyNTgzZGZkMzVhZTkzZjk1MGI=", "commit": {"author": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-01-14T21:43:17Z"}, "committer": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-01-14T21:43:17Z"}, "message": "Refactor compare_impl_method to use all bounds\n\nRefactor compare_impl_method into its own file. Modify the\ncode to stop comparing individual parameter bounds.\nInstead we now use the predicates list attached to the trait\nand implementation generics. This ensures consistency even\nwhen bounds are declared in different places (i.e on\na parameter vs. in a where clause).", "tree": {"sha": "16508acfc187613ffb06904a6d511412e552bf9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16508acfc187613ffb06904a6d511412e552bf9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a66b3227087d3336d8a0e2583dfd35ae93f950b", "comment_count": 6, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a66b3227087d3336d8a0e2583dfd35ae93f950b", "html_url": "https://github.com/rust-lang/rust/commit/6a66b3227087d3336d8a0e2583dfd35ae93f950b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a66b3227087d3336d8a0e2583dfd35ae93f950b/comments", "author": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "896cb36ecab3eaeb7f101087e030e43771eca5ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/896cb36ecab3eaeb7f101087e030e43771eca5ca", "html_url": "https://github.com/rust-lang/rust/commit/896cb36ecab3eaeb7f101087e030e43771eca5ca"}], "stats": {"total": 1137, "additions": 567, "deletions": 570}, "files": [{"sha": "9ad2dd499cc9deb56b69154a4213847f3167d72d", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=6a66b3227087d3336d8a0e2583dfd35ae93f950b", "patch": "@@ -19,7 +19,7 @@ use util::ppaux::Repr;\n \n use std::fmt;\n use std::slice::Iter;\n-use std::vec::Vec;\n+use std::vec::{Vec, IntoIter};\n use syntax::codemap::{Span, DUMMY_SP};\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -397,6 +397,10 @@ impl<T> VecPerParamSpace<T> {\n         self.content.iter()\n     }\n \n+    pub fn into_iter(self) -> IntoIter<T> {\n+        self.content.into_iter()\n+    }\n+\n     pub fn iter_enumerated<'a>(&'a self) -> EnumeratedItems<'a,T> {\n         EnumeratedItems::new(self)\n     }"}, {"sha": "6d0e60ec495a7bee25ea3fe8249befef125adf29", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 73, "deletions": 53, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=6a66b3227087d3336d8a0e2583dfd35ae93f950b", "patch": "@@ -161,66 +161,80 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n             note_obligation_cause(infcx, obligation);\n         }\n-        SelectionError::Unimplemented => {\n-            match obligation.predicate {\n-                ty::Predicate::Trait(ref trait_predicate) => {\n-                    let trait_predicate =\n-                        infcx.resolve_type_vars_if_possible(trait_predicate);\n-                    if !trait_predicate.references_error() {\n-                        let trait_ref = trait_predicate.to_poly_trait_ref();\n-                        infcx.tcx.sess.span_err(\n-                            obligation.cause.span,\n-                            format!(\n-                                \"the trait `{}` is not implemented for the type `{}`\",\n-                                trait_ref.user_string(infcx.tcx),\n-                                trait_ref.self_ty().user_string(infcx.tcx)).as_slice());\n-                        // Check if it has a custom \"#[rustc_on_unimplemented]\" error message,\n-                        // report with that message if it does\n-                        let custom_note = report_on_unimplemented(infcx, &*trait_ref.0,\n-                                                                  obligation.cause.span);\n-                        if let Some(s) = custom_note {\n-                           infcx.tcx.sess.span_note(obligation.cause.span,\n-                                                    s.as_slice());\n-                        }\n-                    }\n-                }\n \n-                ty::Predicate::Equate(ref predicate) => {\n-                    let predicate = infcx.resolve_type_vars_if_possible(predicate);\n-                    let err = infcx.equality_predicate(obligation.cause.span,\n-                                                             &predicate).unwrap_err();\n+        SelectionError::Unimplemented => {\n+            match &obligation.cause.code {\n+                &ObligationCauseCode::CompareImplMethodObligation => {\n                     infcx.tcx.sess.span_err(\n                         obligation.cause.span,\n                         format!(\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate.user_string(infcx.tcx),\n-                            ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                            \"the requirement `{}` appears on the impl \\\n+                            method but not on the corresponding trait method\",\n+                            obligation.predicate.user_string(infcx.tcx)).as_slice());\n                 }\n+                _ => {\n+                    match obligation.predicate {\n+                        ty::Predicate::Trait(ref trait_predicate) => {\n+                            let trait_predicate =\n+                                infcx.resolve_type_vars_if_possible(trait_predicate);\n \n-                ty::Predicate::RegionOutlives(ref predicate) => {\n-                    let predicate = infcx.resolve_type_vars_if_possible(predicate);\n-                    let err = infcx.region_outlives_predicate(obligation.cause.span,\n-                                                              &predicate).unwrap_err();\n-                    infcx.tcx.sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate.user_string(infcx.tcx),\n-                            ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n-                }\n+                            if !trait_predicate.references_error() {\n+                                let trait_ref = trait_predicate.to_poly_trait_ref();\n+                                infcx.tcx.sess.span_err(\n+                                    obligation.cause.span,\n+                                    format!(\n+                                        \"the trait `{}` is not implemented for the type `{}`\",\n+                                        trait_ref.user_string(infcx.tcx),\n+                                        trait_ref.self_ty().user_string(infcx.tcx)).as_slice());\n+                                // Check if it has a custom \"#[rustc_on_unimplemented]\"\n+                                // error message, report with that message if it does\n+                                let custom_note = report_on_unimplemented(infcx, &*trait_ref.0,\n+                                                                          obligation.cause.span);\n+                                if let Some(s) = custom_note {\n+                                    infcx.tcx.sess.span_note(obligation.cause.span,\n+                                                             s.as_slice());\n+                                }\n+                            }\n+                        }\n \n-                ty::Predicate::Projection(..) |\n-                ty::Predicate::TypeOutlives(..) => {\n-                    let predicate =\n-                        infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-                    infcx.tcx.sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"the requirement `{}` is not satisfied\",\n-                            predicate.user_string(infcx.tcx)).as_slice());\n+                        ty::Predicate::Equate(ref predicate) => {\n+                            let predicate = infcx.resolve_type_vars_if_possible(predicate);\n+                            let err = infcx.equality_predicate(obligation.cause.span,\n+                                                               &predicate).unwrap_err();\n+                            infcx.tcx.sess.span_err(\n+                                obligation.cause.span,\n+                                format!(\n+                                    \"the requirement `{}` is not satisfied (`{}`)\",\n+                                    predicate.user_string(infcx.tcx),\n+                                    ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                        }\n+\n+                        ty::Predicate::RegionOutlives(ref predicate) => {\n+                            let predicate = infcx.resolve_type_vars_if_possible(predicate);\n+                            let err = infcx.region_outlives_predicate(obligation.cause.span,\n+                                                                      &predicate).unwrap_err();\n+                            infcx.tcx.sess.span_err(\n+                                obligation.cause.span,\n+                                format!(\n+                                    \"the requirement `{}` is not satisfied (`{}`)\",\n+                                    predicate.user_string(infcx.tcx),\n+                                    ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                        }\n+\n+                        ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                                let predicate =\n+                                    infcx.resolve_type_vars_if_possible(&obligation.predicate);\n+                                infcx.tcx.sess.span_err(\n+                                    obligation.cause.span,\n+                                    format!(\n+                                        \"the requirement `{}` is not satisfied\",\n+                                        predicate.user_string(infcx.tcx)).as_slice());\n+                        }\n+                    }\n                 }\n             }\n         }\n+\n         OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n             let expected_trait_ref = infcx.resolve_type_vars_if_possible(&*expected_trait_ref);\n             let actual_trait_ref = infcx.resolve_type_vars_if_possible(&*actual_trait_ref);\n@@ -229,12 +243,12 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     obligation.cause.span,\n                     format!(\n                         \"type mismatch: the type `{}` implements the trait `{}`, \\\n-                         but the trait `{}` is required ({})\",\n+                        but the trait `{}` is required ({})\",\n                         expected_trait_ref.self_ty().user_string(infcx.tcx),\n                         expected_trait_ref.user_string(infcx.tcx),\n                         actual_trait_ref.user_string(infcx.tcx),\n                         ty::type_err_to_str(infcx.tcx, e)).as_slice());\n-                note_obligation_cause(infcx, obligation);\n+                    note_obligation_cause(infcx, obligation);\n             }\n         }\n     }\n@@ -330,7 +344,7 @@ fn note_obligation_cause<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n }\n \n fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                        _predicate: &ty::Predicate<'tcx>,\n+                                        predicate: &ty::Predicate<'tcx>,\n                                         cause_span: Span,\n                                         cause_code: &ObligationCauseCode<'tcx>)\n {\n@@ -417,6 +431,12 @@ fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             let parent_predicate = parent_trait_ref.as_predicate();\n             note_obligation_cause_code(infcx, &parent_predicate, cause_span, &*data.parent_code);\n         }\n+        ObligationCauseCode::CompareImplMethodObligation => {\n+            span_note!(tcx.sess, cause_span,\n+                      \"the requirement `{}` appears on the impl method\\\n+                      but not on the corresponding trait method\",\n+                      predicate.user_string(infcx.tcx));\n+        }\n     }\n }\n "}, {"sha": "425765edf870c5c30cd56a007ca2d2a3d7e639c6", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=6a66b3227087d3336d8a0e2583dfd35ae93f950b", "patch": "@@ -121,9 +121,12 @@ pub enum ObligationCauseCode<'tcx> {\n     // static items must have `Sync` type\n     SharedStatic,\n \n+\n     BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n \n     ImplDerivedObligation(DerivedObligationCause<'tcx>),\n+\n+    CompareImplMethodObligation,\n }\n \n #[derive(Clone)]"}, {"sha": "755983c71bba829c96600c914b6068e46d72aa5a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6a66b3227087d3336d8a0e2583dfd35ae93f950b", "patch": "@@ -7341,3 +7341,15 @@ impl<'tcx> Repr<'tcx> for field<'tcx> {\n                 self.mt.repr(tcx))\n     }\n }\n+\n+impl<'a, 'tcx> Repr<'tcx> for ParameterEnvironment<'a, 'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"ParameterEnvironment(\\\n+            free_substs={}, \\\n+            implicit_region_bound={}, \\\n+            caller_bounds={})\",\n+            self.free_substs.repr(tcx),\n+            self.implicit_region_bound.repr(tcx),\n+            self.caller_bounds.repr(tcx))\n+        }\n+    }"}, {"sha": "37886b4a1e1f670681be6705676362901d458074", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=6a66b3227087d3336d8a0e2583dfd35ae93f950b", "patch": "@@ -564,6 +564,18 @@ impl<'tcx> TypeFoldable<'tcx> for ty::UnboxedClosureUpvar<'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'a, 'tcx> where 'tcx: 'a {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ParameterEnvironment<'a, 'tcx> {\n+        ty::ParameterEnvironment {\n+            tcx: self.tcx,\n+            free_substs: self.free_substs.fold_with(folder),\n+            implicit_region_bound: self.implicit_region_bound.fold_with(folder),\n+            caller_bounds: self.caller_bounds.fold_with(folder),\n+            selection_cache: traits::SelectionCache::new(),\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // \"super\" routines: these are the default implementations for TypeFolder.\n //"}, {"sha": "27d4b2055d4cdf76bbb91a87589d1f8a795bedf6", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=6a66b3227087d3336d8a0e2583dfd35ae93f950b", "patch": "@@ -0,0 +1,413 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::infer;\n+use middle::traits;\n+use middle::ty::{self};\n+use middle::subst::{self, Subst, Substs, VecPerParamSpace};\n+use util::ppaux::{self, Repr};\n+\n+use syntax::ast;\n+use syntax::codemap::{Span};\n+use syntax::parse::token;\n+\n+use super::assoc;\n+\n+/// Checks that a method from an impl conforms to the signature of\n+/// the same method as declared in the trait.\n+///\n+/// # Parameters\n+///\n+/// - impl_m: type of the method we are checking\n+/// - impl_m_span: span to use for reporting errors\n+/// - impl_m_body_id: id of the method body\n+/// - trait_m: the method in the trait\n+/// - impl_trait_ref: the TraitRef corresponding to the trait implementation\n+\n+pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                 impl_m: &ty::Method<'tcx>,\n+                                 impl_m_span: Span,\n+                                 impl_m_body_id: ast::NodeId,\n+                                 trait_m: &ty::Method<'tcx>,\n+                                 impl_trait_ref: &ty::TraitRef<'tcx>) {\n+    debug!(\"compare_impl_method(impl_trait_ref={})\",\n+           impl_trait_ref.repr(tcx));\n+\n+    debug!(\"compare_impl_method: impl_trait_ref (liberated) = {}\",\n+           impl_trait_ref.repr(tcx));\n+\n+    let infcx = infer::new_infer_ctxt(tcx);\n+    let mut fulfillment_cx = traits::FulfillmentContext::new();\n+\n+    let trait_to_impl_substs = &impl_trait_ref.substs;\n+\n+    // Try to give more informative error messages about self typing\n+    // mismatches.  Note that any mismatch will also be detected\n+    // below, where we construct a canonical function type that\n+    // includes the self parameter as a normal parameter.  It's just\n+    // that the error messages you get out of this code are a bit more\n+    // inscrutable, particularly for cases where one method has no\n+    // self.\n+    match (&trait_m.explicit_self, &impl_m.explicit_self) {\n+        (&ty::StaticExplicitSelfCategory,\n+         &ty::StaticExplicitSelfCategory) => {}\n+        (&ty::StaticExplicitSelfCategory, _) => {\n+            tcx.sess.span_err(\n+                impl_m_span,\n+                format!(\"method `{}` has a `{}` declaration in the impl, \\\n+                        but not in the trait\",\n+                        token::get_name(trait_m.name),\n+                        ppaux::explicit_self_category_to_str(\n+                            &impl_m.explicit_self)).as_slice());\n+            return;\n+        }\n+        (_, &ty::StaticExplicitSelfCategory) => {\n+            tcx.sess.span_err(\n+                impl_m_span,\n+                format!(\"method `{}` has a `{}` declaration in the trait, \\\n+                        but not in the impl\",\n+                        token::get_name(trait_m.name),\n+                        ppaux::explicit_self_category_to_str(\n+                            &trait_m.explicit_self)).as_slice());\n+            return;\n+        }\n+        _ => {\n+            // Let the type checker catch other errors below\n+        }\n+    }\n+\n+    let num_impl_m_type_params = impl_m.generics.types.len(subst::FnSpace);\n+    let num_trait_m_type_params = trait_m.generics.types.len(subst::FnSpace);\n+    if num_impl_m_type_params != num_trait_m_type_params {\n+        span_err!(tcx.sess, impl_m_span, E0049,\n+            \"method `{}` has {} type parameter{} \\\n+             but its trait declaration has {} type parameter{}\",\n+            token::get_name(trait_m.name),\n+            num_impl_m_type_params,\n+            if num_impl_m_type_params == 1 {\"\"} else {\"s\"},\n+            num_trait_m_type_params,\n+            if num_trait_m_type_params == 1 {\"\"} else {\"s\"});\n+        return;\n+    }\n+\n+    if impl_m.fty.sig.0.inputs.len() != trait_m.fty.sig.0.inputs.len() {\n+        span_err!(tcx.sess, impl_m_span, E0050,\n+            \"method `{}` has {} parameter{} \\\n+             but the declaration in trait `{}` has {}\",\n+            token::get_name(trait_m.name),\n+            impl_m.fty.sig.0.inputs.len(),\n+            if impl_m.fty.sig.0.inputs.len() == 1 {\"\"} else {\"s\"},\n+            ty::item_path_str(tcx, trait_m.def_id),\n+            trait_m.fty.sig.0.inputs.len());\n+        return;\n+    }\n+\n+    // This code is best explained by example. Consider a trait:\n+    //\n+    //     trait Trait<'t,T> {\n+    //          fn method<'a,M>(t: &'t T, m: &'a M) -> Self;\n+    //     }\n+    //\n+    // And an impl:\n+    //\n+    //     impl<'i, 'j, U> Trait<'j, &'i U> for Foo {\n+    //          fn method<'b,N>(t: &'j &'i U, m: &'b N) -> Foo;\n+    //     }\n+    //\n+    // We wish to decide if those two method types are compatible.\n+    //\n+    // We start out with trait_to_impl_substs, that maps the trait\n+    // type parameters to impl type parameters. This is taken from the\n+    // impl trait reference:\n+    //\n+    //     trait_to_impl_substs = {'t => 'j, T => &'i U, Self => Foo}\n+    //\n+    // We create a mapping `dummy_substs` that maps from the impl type\n+    // parameters to fresh types and regions. For type parameters,\n+    // this is the identity transform, but we could as well use any\n+    // skolemized types. For regions, we convert from bound to free\n+    // regions (Note: but only early-bound regions, i.e., those\n+    // declared on the impl or used in type parameter bounds).\n+    //\n+    //     impl_to_skol_substs = {'i => 'i0, U => U0, N => N0 }\n+    //\n+    // Now we can apply skol_substs to the type of the impl method\n+    // to yield a new function type in terms of our fresh, skolemized\n+    // types:\n+    //\n+    //     <'b> fn(t: &'i0 U0, m: &'b) -> Foo\n+    //\n+    // We now want to extract and substitute the type of the *trait*\n+    // method and compare it. To do so, we must create a compound\n+    // substitution by combining trait_to_impl_substs and\n+    // impl_to_skol_substs, and also adding a mapping for the method\n+    // type parameters. We extend the mapping to also include\n+    // the method parameters.\n+    //\n+    //     trait_to_skol_substs = { T => &'i0 U0, Self => Foo, M => N0 }\n+    //\n+    // Applying this to the trait method type yields:\n+    //\n+    //     <'a> fn(t: &'i0 U0, m: &'a) -> Foo\n+    //\n+    // This type is also the same but the name of the bound region ('a\n+    // vs 'b).  However, the normal subtyping rules on fn types handle\n+    // this kind of equivalency just fine.\n+    //\n+    // We now use these subsititions to ensure that all declared bounds are\n+    // satisfied by the implementation's method.\n+    //\n+    // We do this by creating a parameter environment which contains a\n+    // substition corresponding to impl_to_skol_substs. We then build\n+    // trait_to_skol_substs and use it to convert the predicates contained\n+    // in the trait_m.generics to the skolemized form.\n+    //\n+    // Finally we register each of these predicates as an obligation in\n+    // a fresh FulfillmentCtxt, and invoke select_all_or_error.\n+\n+    // Create a parameter environment that represents the implementation's\n+    // method.\n+    let impl_param_env =\n+        ty::ParameterEnvironment::for_item(tcx, impl_m.def_id.node);\n+\n+    // Create mapping from impl to skolemized.\n+    let impl_to_skol_substs = &impl_param_env.free_substs;\n+\n+    // Create mapping from trait to skolemized.\n+    let trait_to_skol_substs =\n+        trait_to_impl_substs\n+        .subst(tcx, impl_to_skol_substs)\n+        .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n+                     impl_to_skol_substs.regions().get_slice(subst::FnSpace).to_vec());\n+    debug!(\"compare_impl_method: trait_to_skol_substs={}\",\n+           trait_to_skol_substs.repr(tcx));\n+\n+    // Check region bounds. FIXME(@jroesch) refactor this away when removing\n+    // ParamBounds.\n+    if !check_region_bounds_on_impl_method(tcx,\n+                                           impl_m_span,\n+                                           impl_m,\n+                                           &trait_m.generics,\n+                                           &impl_m.generics,\n+                                           &trait_to_skol_substs,\n+                                           impl_to_skol_substs) {\n+        return;\n+    }\n+\n+    // Create obligations for each predicate declared by the impl\n+    // definition in the context of the trait's parameter\n+    // environment. We can't just use `impl_env.caller_bounds`,\n+    // however, because we want to replace all late-bound regions with\n+    // region variables.\n+    let impl_bounds =\n+        impl_m.generics.to_bounds(tcx, impl_to_skol_substs);\n+\n+    let (impl_bounds, _) =\n+        infcx.replace_late_bound_regions_with_fresh_var(\n+            impl_m_span,\n+            infer::HigherRankedType,\n+            &ty::Binder(impl_bounds));\n+    debug!(\"compare_impl_method: impl_bounds={}\",\n+           impl_bounds.repr(tcx));\n+\n+    // // Normalize the associated types in the impl_bounds.\n+    // let traits::Normalized { value: impl_bounds, .. } =\n+    //     traits::normalize(&mut selcx, normalize_cause.clone(), &impl_bounds);\n+\n+    // Normalize the associated types in the trait_bounds.\n+    let trait_bounds = trait_m.generics.to_bounds(tcx, &trait_to_skol_substs);\n+    // let traits::Normalized { value: trait_bounds, .. } =\n+    //     traits::normalize(&mut selcx, normalize_cause, &trait_bounds);\n+\n+    // Obtain the predicate split predicate sets for each.\n+    let trait_pred = trait_bounds.predicates.split();\n+    let impl_pred = impl_bounds.predicates.split();\n+\n+    // This is the only tricky bit of the new way we check implementation methods\n+    // We need to build a set of predicates where only the FnSpace bounds\n+    // are from the trait and we assume all other bounds from the implementation\n+    // to be previously satisfied.\n+    //\n+    // We then register the obligations from the impl_m and check to see\n+    // if all constraints hold.\n+    let hybrid_preds = VecPerParamSpace::new(\n+        impl_pred.types,\n+        impl_pred.selfs,\n+        trait_pred.fns\n+    );\n+\n+    // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n+    let mut trait_param_env = impl_param_env.clone();\n+    // The key step here is to update the caller_bounds's predicates to be\n+    // the new hybrid bounds we computed.\n+    trait_param_env.caller_bounds.predicates = hybrid_preds;\n+\n+    debug!(\"compare_impl_method: trait_bounds={}\",\n+        trait_param_env.caller_bounds.repr(tcx));\n+\n+    let mut selcx = traits::SelectionContext::new(&infcx, &trait_param_env);\n+\n+    let normalize_cause =\n+        traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n+\n+    for predicate in impl_pred.fns.into_iter() {\n+        let traits::Normalized { value: predicate, .. } =\n+            traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);\n+\n+        let cause = traits::ObligationCause {\n+            span: impl_m_span,\n+            body_id: impl_m_body_id,\n+            code: traits::ObligationCauseCode::CompareImplMethodObligation\n+        };\n+\n+        fulfillment_cx.register_predicate_obligation(\n+            &infcx,\n+            traits::Obligation::new(cause, predicate));\n+    }\n+\n+    // We now need to check that the signature of the impl method is\n+    // compatible with that of the trait method. We do this by\n+    // checking that `impl_fty <: trait_fty`.\n+    //\n+    // FIXME. Unfortunately, this doesn't quite work right now because\n+    // associated type normalization is not integrated into subtype\n+    // checks. For the comparison to be valid, we need to\n+    // normalize the associated types in the impl/trait methods\n+    // first. However, because function types bind regions, just\n+    // calling `normalize_associated_types_in` would have no effect on\n+    // any associated types appearing in the fn arguments or return\n+    // type.\n+\n+    // Compute skolemized form of impl and trait method tys.\n+    let impl_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(impl_m.fty.clone()));\n+    let impl_fty = impl_fty.subst(tcx, impl_to_skol_substs);\n+    let trait_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(trait_m.fty.clone()));\n+    let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n+\n+    let err = infcx.try(|snapshot| {\n+        let origin = infer::MethodCompatCheck(impl_m_span);\n+\n+        let (impl_sig, _) =\n+            infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n+                                                            infer::HigherRankedType,\n+                                                            &impl_m.fty.sig);\n+        let impl_sig =\n+            impl_sig.subst(tcx, impl_to_skol_substs);\n+        let impl_sig =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &impl_param_env,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_m_span,\n+                                                 impl_m_body_id,\n+                                                 &impl_sig);\n+        let impl_fty =\n+            ty::mk_bare_fn(tcx,\n+                           None,\n+                           tcx.mk_bare_fn(ty::BareFnTy { unsafety: impl_m.fty.unsafety,\n+                                                         abi: impl_m.fty.abi,\n+                                                         sig: ty::Binder(impl_sig) }));\n+        debug!(\"compare_impl_method: impl_fty={}\",\n+               impl_fty.repr(tcx));\n+\n+        let (trait_sig, skol_map) =\n+            infcx.skolemize_late_bound_regions(&trait_m.fty.sig, snapshot);\n+        let trait_sig =\n+            trait_sig.subst(tcx, &trait_to_skol_substs);\n+        let trait_sig =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &impl_param_env,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_m_span,\n+                                                 impl_m_body_id,\n+                                                 &trait_sig);\n+        let trait_fty =\n+            ty::mk_bare_fn(tcx,\n+                           None,\n+                           tcx.mk_bare_fn(ty::BareFnTy { unsafety: trait_m.fty.unsafety,\n+                                                         abi: trait_m.fty.abi,\n+                                                         sig: ty::Binder(trait_sig) }));\n+\n+        debug!(\"compare_impl_method: trait_fty={}\",\n+               trait_fty.repr(tcx));\n+\n+        try!(infer::mk_subty(&infcx, false, origin, impl_fty, trait_fty));\n+\n+        infcx.leak_check(&skol_map, snapshot)\n+    });\n+\n+    match err {\n+        Ok(()) => { }\n+        Err(terr) => {\n+            debug!(\"checking trait method for compatibility: impl ty {}, trait ty {}\",\n+                   impl_fty.repr(tcx),\n+                   trait_fty.repr(tcx));\n+            span_err!(tcx.sess, impl_m_span, E0053,\n+                      \"method `{}` has an incompatible type for trait: {}\",\n+                      token::get_name(trait_m.name),\n+                      ty::type_err_to_str(tcx, &terr));\n+            return;\n+        }\n+    }\n+\n+    // Check that all obligations are satisfied by the implementation's\n+    // version.\n+    match fulfillment_cx.select_all_or_error(&infcx, &trait_param_env) {\n+        Err(ref errors) => { traits::report_fulfillment_errors(&infcx, errors) }\n+        Ok(_) => {}\n+    }\n+\n+    // Finally, resolve all regions. This catches wily misuses of lifetime\n+    // parameters.\n+    infcx.resolve_regions_and_report_errors(impl_m_body_id);\n+\n+    fn check_region_bounds_on_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                                span: Span,\n+                                                impl_m: &ty::Method<'tcx>,\n+                                                trait_generics: &ty::Generics<'tcx>,\n+                                                impl_generics: &ty::Generics<'tcx>,\n+                                                trait_to_skol_substs: &Substs<'tcx>,\n+                                                impl_to_skol_substs: &Substs<'tcx>)\n+                                                -> bool\n+    {\n+\n+        let trait_params = trait_generics.regions.get_slice(subst::FnSpace);\n+        let impl_params = impl_generics.regions.get_slice(subst::FnSpace);\n+\n+        debug!(\"check_region_bounds_on_impl_method: \\\n+               trait_generics={} \\\n+               impl_generics={} \\\n+               trait_to_skol_substs={} \\\n+               impl_to_skol_substs={}\",\n+               trait_generics.repr(tcx),\n+               impl_generics.repr(tcx),\n+               trait_to_skol_substs.repr(tcx),\n+               impl_to_skol_substs.repr(tcx));\n+\n+        // Must have same number of early-bound lifetime parameters.\n+        // Unfortunately, if the user screws up the bounds, then this\n+        // will change classification between early and late.  E.g.,\n+        // if in trait we have `<'a,'b:'a>`, and in impl we just have\n+        // `<'a,'b>`, then we have 2 early-bound lifetime parameters\n+        // in trait but 0 in the impl. But if we report \"expected 2\n+        // but found 0\" it's confusing, because it looks like there\n+        // are zero. Since I don't quite know how to phrase things at\n+        // the moment, give a kind of vague error message.\n+        if trait_params.len() != impl_params.len() {\n+            tcx.sess.span_err(\n+                span,\n+                &format!(\"lifetime parameters or bounds on method `{}` do \\\n+                         not match the trait declaration\",\n+                         token::get_name(impl_m.name))[]);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+}"}, {"sha": "d412ed39c7271b248e6caf4ddd4efb82c6a39518", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 499, "changes": 502, "blob_url": "https://github.com/rust-lang/rust/blob/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6a66b3227087d3336d8a0e2583dfd35ae93f950b", "patch": "@@ -78,6 +78,7 @@ type parameter).\n \n pub use self::LvaluePreference::*;\n pub use self::Expectation::*;\n+pub use self::compare_method::compare_impl_method;\n use self::IsBinopAssignment::*;\n use self::TupleArgumentsFlag::*;\n \n@@ -106,7 +107,7 @@ use TypeAndSubsts;\n use middle::lang_items::TypeIdLangItem;\n use lint;\n use util::common::{block_query, indenter, loop_query};\n-use util::ppaux::{self, UserString, Repr};\n+use util::ppaux::{self, Repr};\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use std::cell::{Cell, Ref, RefCell};\n@@ -137,8 +138,8 @@ mod upvar;\n pub mod wf;\n mod closure;\n mod callee;\n+mod compare_method;\n \n-/// Fields that are part of a `FnCtxt` which are inherited by\n /// closures defined within the function.  For example:\n ///\n ///     fn foo() {\n@@ -993,503 +994,6 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-/// Checks that a method from an impl conforms to the signature of\n-/// the same method as declared in the trait.\n-///\n-/// # Parameters\n-///\n-/// - impl_generics: the generics declared on the impl itself (not the method!)\n-/// - impl_m: type of the method we are checking\n-/// - impl_m_span: span to use for reporting errors\n-/// - impl_m_body_id: id of the method body\n-/// - trait_m: the method in the trait\n-/// - trait_to_impl_substs: the substitutions used on the type of the trait\n-fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                             impl_m: &ty::Method<'tcx>,\n-                             impl_m_span: Span,\n-                             impl_m_body_id: ast::NodeId,\n-                             trait_m: &ty::Method<'tcx>,\n-                             impl_trait_ref: &ty::TraitRef<'tcx>) {\n-    debug!(\"compare_impl_method(impl_trait_ref={})\",\n-           impl_trait_ref.repr(tcx));\n-\n-    debug!(\"impl_trait_ref (liberated) = {}\",\n-           impl_trait_ref.repr(tcx));\n-\n-    let infcx = infer::new_infer_ctxt(tcx);\n-    let mut fulfillment_cx = traits::FulfillmentContext::new();\n-\n-    let trait_to_impl_substs = &impl_trait_ref.substs;\n-\n-    // Try to give more informative error messages about self typing\n-    // mismatches.  Note that any mismatch will also be detected\n-    // below, where we construct a canonical function type that\n-    // includes the self parameter as a normal parameter.  It's just\n-    // that the error messages you get out of this code are a bit more\n-    // inscrutable, particularly for cases where one method has no\n-    // self.\n-    match (&trait_m.explicit_self, &impl_m.explicit_self) {\n-        (&ty::StaticExplicitSelfCategory,\n-         &ty::StaticExplicitSelfCategory) => {}\n-        (&ty::StaticExplicitSelfCategory, _) => {\n-            tcx.sess.span_err(\n-                impl_m_span,\n-                &format!(\"method `{}` has a `{}` declaration in the impl, \\\n-                        but not in the trait\",\n-                        token::get_name(trait_m.name),\n-                        ppaux::explicit_self_category_to_str(\n-                            &impl_m.explicit_self))[]);\n-            return;\n-        }\n-        (_, &ty::StaticExplicitSelfCategory) => {\n-            tcx.sess.span_err(\n-                impl_m_span,\n-                &format!(\"method `{}` has a `{}` declaration in the trait, \\\n-                        but not in the impl\",\n-                        token::get_name(trait_m.name),\n-                        ppaux::explicit_self_category_to_str(\n-                            &trait_m.explicit_self))[]);\n-            return;\n-        }\n-        _ => {\n-            // Let the type checker catch other errors below\n-        }\n-    }\n-\n-    let num_impl_m_type_params = impl_m.generics.types.len(subst::FnSpace);\n-    let num_trait_m_type_params = trait_m.generics.types.len(subst::FnSpace);\n-    if num_impl_m_type_params != num_trait_m_type_params {\n-        span_err!(tcx.sess, impl_m_span, E0049,\n-            \"method `{}` has {} type parameter{} \\\n-             but its trait declaration has {} type parameter{}\",\n-            token::get_name(trait_m.name),\n-            num_impl_m_type_params,\n-            if num_impl_m_type_params == 1 {\"\"} else {\"s\"},\n-            num_trait_m_type_params,\n-            if num_trait_m_type_params == 1 {\"\"} else {\"s\"});\n-        return;\n-    }\n-\n-    if impl_m.fty.sig.0.inputs.len() != trait_m.fty.sig.0.inputs.len() {\n-        span_err!(tcx.sess, impl_m_span, E0050,\n-            \"method `{}` has {} parameter{} \\\n-             but the declaration in trait `{}` has {}\",\n-            token::get_name(trait_m.name),\n-            impl_m.fty.sig.0.inputs.len(),\n-            if impl_m.fty.sig.0.inputs.len() == 1 {\"\"} else {\"s\"},\n-            ty::item_path_str(tcx, trait_m.def_id),\n-            trait_m.fty.sig.0.inputs.len());\n-        return;\n-    }\n-\n-    // This code is best explained by example. Consider a trait:\n-    //\n-    //     trait Trait<'t,T> {\n-    //          fn method<'a,M>(t: &'t T, m: &'a M) -> Self;\n-    //     }\n-    //\n-    // And an impl:\n-    //\n-    //     impl<'i, 'j, U> Trait<'j, &'i U> for Foo {\n-    //          fn method<'b,N>(t: &'j &'i U, m: &'b N) -> Foo;\n-    //     }\n-    //\n-    // We wish to decide if those two method types are compatible.\n-    //\n-    // We start out with trait_to_impl_substs, that maps the trait\n-    // type parameters to impl type parameters. This is taken from the\n-    // impl trait reference:\n-    //\n-    //     trait_to_impl_substs = {'t => 'j, T => &'i U, Self => Foo}\n-    //\n-    // We create a mapping `dummy_substs` that maps from the impl type\n-    // parameters to fresh types and regions. For type parameters,\n-    // this is the identity transform, but we could as well use any\n-    // skolemized types. For regions, we convert from bound to free\n-    // regions (Note: but only early-bound regions, i.e., those\n-    // declared on the impl or used in type parameter bounds).\n-    //\n-    //     impl_to_skol_substs = {'i => 'i0, U => U0, N => N0 }\n-    //\n-    // Now we can apply skol_substs to the type of the impl method\n-    // to yield a new function type in terms of our fresh, skolemized\n-    // types:\n-    //\n-    //     <'b> fn(t: &'i0 U0, m: &'b) -> Foo\n-    //\n-    // We now want to extract and substitute the type of the *trait*\n-    // method and compare it. To do so, we must create a compound\n-    // substitution by combining trait_to_impl_substs and\n-    // impl_to_skol_substs, and also adding a mapping for the method\n-    // type parameters. We extend the mapping to also include\n-    // the method parameters.\n-    //\n-    //     trait_to_skol_substs = { T => &'i0 U0, Self => Foo, M => N0 }\n-    //\n-    // Applying this to the trait method type yields:\n-    //\n-    //     <'a> fn(t: &'i0 U0, m: &'a) -> Foo\n-    //\n-    // This type is also the same but the name of the bound region ('a\n-    // vs 'b).  However, the normal subtyping rules on fn types handle\n-    // this kind of equivalency just fine.\n-\n-    // Create mapping from impl to skolemized.\n-    let impl_param_env = ty::construct_parameter_environment(tcx, &impl_m.generics, impl_m_body_id);\n-    let impl_to_skol_substs = &impl_param_env.free_substs;\n-\n-    // Create mapping from trait to skolemized.\n-    let trait_to_skol_substs =\n-        trait_to_impl_substs\n-        .subst(tcx, impl_to_skol_substs)\n-        .with_method(impl_to_skol_substs.types.get_slice(subst::FnSpace).to_vec(),\n-                     impl_to_skol_substs.regions().get_slice(subst::FnSpace).to_vec());\n-\n-    // Check region bounds.\n-    if !check_region_bounds_on_impl_method(tcx,\n-                                           impl_m_span,\n-                                           impl_m,\n-                                           &trait_m.generics,\n-                                           &impl_m.generics,\n-                                           &trait_to_skol_substs,\n-                                           impl_to_skol_substs) {\n-        return;\n-    }\n-\n-    // Check bounds. Note that the bounds from the impl may reference\n-    // late-bound regions declared on the impl, so liberate those.\n-    // This requires two artificial binding scopes -- one for the impl,\n-    // and one for the method.\n-    //\n-    // An example would be:\n-    //\n-    //     trait Foo<T> { fn method<U:Bound<T>>() { ... } }\n-    //\n-    //     impl<'a> Foo<&'a T> for &'a U {\n-    //         fn method<U:Bound<&'a T>>() { ... }\n-    //     }\n-    //\n-    // Here, the region parameter `'a` is late-bound, so in the bound\n-    // `Bound<&'a T>`, the lifetime `'a` will be late-bound with a\n-    // depth of 3 (it is nested within 3 binders: the impl, method,\n-    // and trait-ref itself). So when we do the liberation, we have\n-    // two introduce two `ty::Binder` scopes, one for the impl and one\n-    // the method.\n-    //\n-    // The only late-bounded regions that can possibly appear here are\n-    // from the impl, not the method. This is because region\n-    // parameters declared on the method which appear in a type bound\n-    // would be early bound. On the trait side, there can be no\n-    // late-bound lifetimes because trait definitions do not introduce\n-    // a late region binder.\n-    let trait_bounds =\n-        trait_m.generics.types.get_slice(subst::FnSpace).iter()\n-        .map(|trait_param_def| &trait_param_def.bounds);\n-    let impl_bounds =\n-        impl_m.generics.types.get_slice(subst::FnSpace).iter()\n-        .map(|impl_param_def| &impl_param_def.bounds);\n-    for (i, (trait_param_bounds, impl_param_bounds)) in\n-        trait_bounds.zip(impl_bounds).enumerate()\n-    {\n-        // Check that the impl does not require any builtin-bounds\n-        // that the trait does not guarantee:\n-        let extra_bounds =\n-            impl_param_bounds.builtin_bounds -\n-            trait_param_bounds.builtin_bounds;\n-        if !extra_bounds.is_empty() {\n-            span_err!(tcx.sess, impl_m_span, E0051,\n-                \"in method `{}`, type parameter {} requires `{}`, \\\n-                 which is not required by the corresponding type parameter \\\n-                 in the trait declaration\",\n-                token::get_name(trait_m.name),\n-                i,\n-                extra_bounds.user_string(tcx));\n-           return;\n-        }\n-\n-        // Check that the trait bounds of the trait imply the bounds of its\n-        // implementation.\n-        //\n-        // FIXME(pcwalton): We could be laxer here regarding sub- and super-\n-        // traits, but I doubt that'll be wanted often, so meh.\n-        for impl_trait_bound in impl_param_bounds.trait_bounds.iter() {\n-            debug!(\"compare_impl_method(): impl-trait-bound subst\");\n-            let impl_trait_bound =\n-                impl_trait_bound.subst(tcx, impl_to_skol_substs);\n-\n-            // There may be late-bound regions from the impl in the\n-            // impl's bound, so \"liberate\" those. Note that the\n-            // trait_to_skol_substs is derived from the impl's\n-            // trait-ref, and the late-bound regions appearing there\n-            // have already been liberated, so the result should match\n-            // up.\n-\n-            let found_match_in_trait =\n-                trait_param_bounds.trait_bounds.iter().any(|trait_bound| {\n-                    debug!(\"compare_impl_method(): trait-bound subst\");\n-                    let trait_bound =\n-                        trait_bound.subst(tcx, &trait_to_skol_substs);\n-                    infer::mk_sub_poly_trait_refs(&infcx,\n-                                                  true,\n-                                                  infer::Misc(impl_m_span),\n-                                                  trait_bound,\n-                                                  impl_trait_bound.clone()).is_ok()\n-                });\n-\n-            if !found_match_in_trait {\n-                span_err!(tcx.sess, impl_m_span, E0052,\n-                          \"in method `{}`, type parameter {} requires bound `{}`, which is not \\\n-                           required by the corresponding type parameter in the trait declaration\",\n-                          token::get_name(trait_m.name),\n-                          i,\n-                          impl_trait_bound.user_string(tcx));\n-            }\n-        }\n-    }\n-\n-    // We now need to check that the signature of the impl method is\n-    // compatible with that of the trait method. We do this by\n-    // checking that `impl_fty <: trait_fty`.\n-    //\n-    // FIXME. Unfortunately, this doesn't quite work right now because\n-    // associated type normalization is not integrated into subtype\n-    // checks. For the comparison to be valid, we need to\n-    // normalize the associated types in the impl/trait methods\n-    // first. However, because function types bind regions, just\n-    // calling `normalize_associated_types_in` would have no effect on\n-    // any associated types appearing in the fn arguments or return\n-    // type.\n-\n-\n-    // Compute skolemized form of impl and trait method tys.\n-    let impl_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(impl_m.fty.clone()));\n-    let impl_fty = impl_fty.subst(tcx, impl_to_skol_substs);\n-    let trait_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(trait_m.fty.clone()));\n-    let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n-\n-    let err = infcx.try(|snapshot| {\n-        let origin = infer::MethodCompatCheck(impl_m_span);\n-\n-        let (impl_sig, _) =\n-            infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n-                                                            infer::HigherRankedType,\n-                                                            &impl_m.fty.sig);\n-        let impl_sig =\n-            impl_sig.subst(tcx, impl_to_skol_substs);\n-        let impl_sig =\n-            assoc::normalize_associated_types_in(&infcx,\n-                                                 &impl_param_env,\n-                                                 &mut fulfillment_cx,\n-                                                 impl_m_span,\n-                                                 impl_m_body_id,\n-                                                 &impl_sig);\n-        let impl_fty =\n-            ty::mk_bare_fn(tcx,\n-                           None,\n-                           tcx.mk_bare_fn(ty::BareFnTy { unsafety: impl_m.fty.unsafety,\n-                                                         abi: impl_m.fty.abi,\n-                                                         sig: ty::Binder(impl_sig) }));\n-        debug!(\"compare_impl_method: impl_fty={}\",\n-               impl_fty.repr(tcx));\n-\n-        let (trait_sig, skol_map) =\n-            infcx.skolemize_late_bound_regions(&trait_m.fty.sig, snapshot);\n-        let trait_sig =\n-            trait_sig.subst(tcx, &trait_to_skol_substs);\n-        let trait_sig =\n-            assoc::normalize_associated_types_in(&infcx,\n-                                                 &impl_param_env,\n-                                                 &mut fulfillment_cx,\n-                                                 impl_m_span,\n-                                                 impl_m_body_id,\n-                                                 &trait_sig);\n-        let trait_fty =\n-            ty::mk_bare_fn(tcx,\n-                           None,\n-                           tcx.mk_bare_fn(ty::BareFnTy { unsafety: trait_m.fty.unsafety,\n-                                                         abi: trait_m.fty.abi,\n-                                                         sig: ty::Binder(trait_sig) }));\n-\n-        debug!(\"compare_impl_method: trait_fty={}\",\n-               trait_fty.repr(tcx));\n-\n-        try!(infer::mk_subty(&infcx, false, origin, impl_fty, trait_fty));\n-\n-        infcx.leak_check(&skol_map, snapshot)\n-    });\n-\n-    match err {\n-        Ok(()) => { }\n-        Err(terr) => {\n-            debug!(\"checking trait method for compatibility: impl ty {}, trait ty {}\",\n-                   impl_fty.repr(tcx),\n-                   trait_fty.repr(tcx));\n-            span_err!(tcx.sess, impl_m_span, E0053,\n-                      \"method `{}` has an incompatible type for trait: {}\",\n-                      token::get_name(trait_m.name),\n-                      ty::type_err_to_str(tcx, &terr));\n-            return;\n-        }\n-    }\n-\n-    // Run the fulfillment context to completion to accommodate any\n-    // associated type normalizations that may have occurred.\n-    match fulfillment_cx.select_all_or_error(&infcx, &impl_param_env) {\n-        Ok(()) => { }\n-        Err(errors) => {\n-            traits::report_fulfillment_errors(&infcx, &errors);\n-        }\n-    }\n-\n-    // Finally, resolve all regions. This catches wily misuses of lifetime\n-    // parameters.\n-    infcx.resolve_regions_and_report_errors(impl_m_body_id);\n-\n-    /// Check that region bounds on impl method are the same as those on the trait. In principle,\n-    /// it could be ok for there to be fewer region bounds on the impl method, but this leads to an\n-    /// annoying corner case that is painful to handle (described below), so for now we can just\n-    /// forbid it.\n-    ///\n-    /// Example (see `src/test/compile-fail/regions-bound-missing-bound-in-impl.rs`):\n-    ///\n-    /// ```\n-    /// trait Foo<'a> {\n-    ///     fn method1<'b>();\n-    ///     fn method2<'b:'a>();\n-    /// }\n-    ///\n-    /// impl<'a> Foo<'a> for ... {\n-    ///     fn method1<'b:'a>() { .. case 1, definitely bad .. }\n-    ///     fn method2<'b>() { .. case 2, could be ok .. }\n-    /// }\n-    /// ```\n-    ///\n-    /// The \"definitely bad\" case is case #1. Here, the impl adds an extra constraint not present\n-    /// in the trait.\n-    ///\n-    /// The \"maybe bad\" case is case #2. Here, the impl adds an extra constraint not present in the\n-    /// trait. We could in principle allow this, but it interacts in a complex way with early/late\n-    /// bound resolution of lifetimes. Basically the presence or absence of a lifetime bound\n-    /// affects whether the lifetime is early/late bound, and right now the code breaks if the\n-    /// trait has an early bound lifetime parameter and the method does not.\n-    fn check_region_bounds_on_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                                span: Span,\n-                                                impl_m: &ty::Method<'tcx>,\n-                                                trait_generics: &ty::Generics<'tcx>,\n-                                                impl_generics: &ty::Generics<'tcx>,\n-                                                trait_to_skol_substs: &Substs<'tcx>,\n-                                                impl_to_skol_substs: &Substs<'tcx>)\n-                                                -> bool\n-    {\n-\n-        let trait_params = trait_generics.regions.get_slice(subst::FnSpace);\n-        let impl_params = impl_generics.regions.get_slice(subst::FnSpace);\n-\n-        debug!(\"check_region_bounds_on_impl_method: \\\n-               trait_generics={} \\\n-               impl_generics={} \\\n-               trait_to_skol_substs={} \\\n-               impl_to_skol_substs={}\",\n-               trait_generics.repr(tcx),\n-               impl_generics.repr(tcx),\n-               trait_to_skol_substs.repr(tcx),\n-               impl_to_skol_substs.repr(tcx));\n-\n-        // Must have same number of early-bound lifetime parameters.\n-        // Unfortunately, if the user screws up the bounds, then this\n-        // will change classification between early and late.  E.g.,\n-        // if in trait we have `<'a,'b:'a>`, and in impl we just have\n-        // `<'a,'b>`, then we have 2 early-bound lifetime parameters\n-        // in trait but 0 in the impl. But if we report \"expected 2\n-        // but found 0\" it's confusing, because it looks like there\n-        // are zero. Since I don't quite know how to phrase things at\n-        // the moment, give a kind of vague error message.\n-        if trait_params.len() != impl_params.len() {\n-            tcx.sess.span_err(\n-                span,\n-                &format!(\"lifetime parameters or bounds on method `{}` do \\\n-                         not match the trait declaration\",\n-                        token::get_name(impl_m.name))[]);\n-            return false;\n-        }\n-\n-        // Each parameter `'a:'b+'c+'d` in trait should have the same\n-        // set of bounds in the impl, after subst.\n-        for (trait_param, impl_param) in\n-            trait_params.iter().zip(\n-                impl_params.iter())\n-        {\n-            let trait_bounds =\n-                trait_param.bounds.subst(tcx, trait_to_skol_substs);\n-            let impl_bounds =\n-                impl_param.bounds.subst(tcx, impl_to_skol_substs);\n-\n-            debug!(\"check_region_bounds_on_impl_method: \\\n-                   trait_param={} \\\n-                   impl_param={} \\\n-                   trait_bounds={} \\\n-                   impl_bounds={}\",\n-                   trait_param.repr(tcx),\n-                   impl_param.repr(tcx),\n-                   trait_bounds.repr(tcx),\n-                   impl_bounds.repr(tcx));\n-\n-            // Collect the set of bounds present in trait but not in\n-            // impl.\n-            let missing: Vec<ty::Region> =\n-                trait_bounds.iter()\n-                .filter(|&b| !impl_bounds.contains(b))\n-                .map(|&b| b)\n-                .collect();\n-\n-            // Collect set present in impl but not in trait.\n-            let extra: Vec<ty::Region> =\n-                impl_bounds.iter()\n-                .filter(|&b| !trait_bounds.contains(b))\n-                .map(|&b| b)\n-                .collect();\n-\n-            debug!(\"missing={} extra={}\",\n-                   missing.repr(tcx), extra.repr(tcx));\n-\n-            let err = if missing.len() != 0 || extra.len() != 0 {\n-                tcx.sess.span_err(\n-                    span,\n-                    &format!(\n-                        \"the lifetime parameter `{}` declared in the impl \\\n-                         has a distinct set of bounds \\\n-                         from its counterpart `{}` \\\n-                         declared in the trait\",\n-                        impl_param.name.user_string(tcx),\n-                        trait_param.name.user_string(tcx))[]);\n-                true\n-            } else {\n-                false\n-            };\n-\n-            if missing.len() != 0 {\n-                tcx.sess.span_note(\n-                    span,\n-                    &format!(\"the impl is missing the following bounds: `{}`\",\n-                            missing.user_string(tcx))[]);\n-            }\n-\n-            if extra.len() != 0 {\n-                tcx.sess.span_note(\n-                    span,\n-                    &format!(\"the impl has the following extra bounds: `{}`\",\n-                            extra.user_string(tcx))[]);\n-            }\n-\n-            if err {\n-                return false;\n-            }\n-        }\n-\n-        return true;\n-    }\n-}\n-\n fn check_cast(fcx: &FnCtxt,\n               cast_expr: &ast::Expr,\n               e: &ast::Expr,"}, {"sha": "22ba54fea14694f86c9dd2594698c5a395c46cdd", "filename": "src/test/compile-fail/issue-14853.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14853.rs?ref=6a66b3227087d3336d8a0e2583dfd35ae93f950b", "patch": "@@ -20,8 +20,7 @@ struct X { data: u32 }\n \n impl Something for X {\n     fn yay<T: Str>(_:Option<X>, thing: &[T]) {\n-//~^ ERROR in method `yay`, type parameter 0 requires bound `Str`, which is not required\n-\n+    //~^ ERROR the requirement `T : Str` appears on the impl method\n     }\n }\n "}, {"sha": "31796e5e20c4492e683642701852db9bc439bfdf", "filename": "src/test/compile-fail/issue-2611-4.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs?ref=6a66b3227087d3336d8a0e2583dfd35ae93f950b", "patch": "@@ -20,7 +20,8 @@ struct E {\n }\n \n impl A for E {\n-  fn b<F: Sync, G>(_x: F) -> F { panic!() } //~ ERROR type parameter 0 requires `Sync`\n+    fn b<F: Sync, G>(_x: F) -> F { panic!() }\n+    //~^ ERROR `F : core::marker::Sync` appears on the impl method\n }\n \n fn main() {}"}, {"sha": "a3c38dff6b0f62f73275240d21286e2a1fdcc758", "filename": "src/test/compile-fail/regions-bound-missing-bound-in-impl.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs?ref=6a66b3227087d3336d8a0e2583dfd35ae93f950b", "patch": "@@ -16,15 +16,16 @@ struct Inv<'a> { // invariant w/r/t 'a\n     x: &'a mut &'a isize\n }\n \n-pub trait Foo<'a> {\n+pub trait Foo<'a, 't> {\n     fn no_bound<'b>(self, b: Inv<'b>);\n     fn has_bound<'b:'a>(self, b: Inv<'b>);\n     fn wrong_bound1<'b,'c,'d:'a+'b>(self, b: Inv<'b>, c: Inv<'c>, d: Inv<'d>);\n-    fn wrong_bound2<'b,'c,'d:'a+'b+'c>(self, b: Inv<'b>, c: Inv<'c>, d: Inv<'d>);\n+    fn okay_bound<'b,'c,'d:'a+'b+'c>(self, b: Inv<'b>, c: Inv<'c>, d: Inv<'d>);\n+    fn another_bound<'x: 'a>(self, x: Inv<'x>);\n }\n \n \n-impl<'a> Foo<'a> for &'a isize {\n+impl<'a, 't> Foo<'a, 't> for &'a isize {\n     fn no_bound<'b:'a>(self, b: Inv<'b>) {\n         //~^ ERROR lifetime parameters or bounds on method `no_bound` do not match\n     }\n@@ -47,9 +48,10 @@ impl<'a> Foo<'a> for &'a isize {\n         // cases.\n     }\n \n-    fn wrong_bound2<'b,'c,'e:'b+'c>(self, b: Inv<'b>, c: Inv<'c>, e: Inv<'e>) {\n-        //~^ ERROR distinct set of bounds from its counterpart\n+    fn okay_bound<'b,'c,'e:'b+'c>(self, b: Inv<'b>, c: Inv<'c>, e: Inv<'e>) {\n     }\n+\n+    fn another_bound<'x: 't>(self, x: Inv<'x>) {}\n }\n \n fn main() { }"}, {"sha": "477bd4f5be9a1a8a942acc1fd2b625b82c1fb5c6", "filename": "src/test/compile-fail/trait-bounds-impl-comparison-1.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-1.rs?ref=6a66b3227087d3336d8a0e2583dfd35ae93f950b", "patch": "@@ -32,15 +32,15 @@ trait Foo {\n impl Foo for isize {\n     // invalid bound for T, was defined as Eq in trait\n     fn test_error1_fn<T: Ord>(&self) {}\n-    //~^ ERROR in method `test_error1_fn`, type parameter 0 requires bound `core::cmp::Ord`\n+    //~^ ERROR the requirement `T : core::cmp::Ord` appears on the impl\n \n     // invalid bound for T, was defined as Eq + Ord in trait\n     fn test_error2_fn<T: Eq + B>(&self) {}\n-    //~^ ERROR in method `test_error2_fn`, type parameter 0 requires bound `B`\n+    //~^ ERROR the requirement `T : B` appears on the impl\n \n     // invalid bound for T, was defined as Eq + Ord in trait\n     fn test_error3_fn<T: B + Eq>(&self) {}\n-    //~^ ERROR in method `test_error3_fn`, type parameter 0 requires bound `B`\n+    //~^ ERROR the requirement `T : B` appears on the impl\n \n     // multiple bounds, same order as in trait\n     fn test3_fn<T: Ord + Eq>(&self) {}\n@@ -50,16 +50,16 @@ impl Foo for isize {\n \n     // parameters in impls must be equal or more general than in the defining trait\n     fn test_error5_fn<T: B>(&self) {}\n-    //~^ ERROR in method `test_error5_fn`, type parameter 0 requires bound `B`\n+    //~^ ERROR the requirement `T : B` appears on the impl\n \n     // bound `std::cmp::Eq` not enforced by this implementation, but this is OK\n     fn test6_fn<T: A>(&self) {}\n \n     fn test_error7_fn<T: A + Eq>(&self) {}\n-    //~^ ERROR in method `test_error7_fn`, type parameter 0 requires bound `core::cmp::Eq`\n+    //~^ ERROR the requirement `T : core::cmp::Eq` appears on the impl\n \n     fn test_error8_fn<T: C>(&self) {}\n-    //~^ ERROR in method `test_error8_fn`, type parameter 0 requires bound `C`\n+    //~^ ERROR the requirement `T : C` appears on the impl\n }\n \n \n@@ -71,8 +71,7 @@ trait Trait {\n \n impl Trait for usize {\n     fn method<G: Getter<usize>>() {}\n-    //~^ ERROR in method `method`, type parameter 0 requires bound `Getter<usize>`\n+    //~^ G : Getter<usize>` appears on the impl method but not on the corresponding trait method\n }\n \n fn main() {}\n-"}, {"sha": "8ad19116e7bb13ba2b11af89f5121e45441c9949", "filename": "src/test/compile-fail/trait-bounds-impl-comparison-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs?ref=6a66b3227087d3336d8a0e2583dfd35ae93f950b", "patch": "@@ -20,7 +20,7 @@ trait IteratorUtil<A> {\n \n impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<T, U> {\n-    //~^ ERROR in method `zip`, type parameter 1 requires bound `Iterator<B>`\n+    //~^ ERROR the requirement `U : Iterator<B>` appears on the impl method\n         ZipIterator{a: self, b: other}\n     }\n }"}, {"sha": "a1a61127f68e05d9a6831e0812d28b018eb03545", "filename": "src/test/run-pass/where-clause-bounds-inconsistency.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Ftest%2Frun-pass%2Fwhere-clause-bounds-inconsistency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a66b3227087d3336d8a0e2583dfd35ae93f950b/src%2Ftest%2Frun-pass%2Fwhere-clause-bounds-inconsistency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhere-clause-bounds-inconsistency.rs?ref=6a66b3227087d3336d8a0e2583dfd35ae93f950b", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Bound {}\n+\n+trait Trait {\n+    fn a<T>(&self, T) where T: Bound;\n+    fn b<T>(&self, T) where T: Bound;\n+    fn c<T: Bound>(&self, T);\n+    fn d<T: Bound>(&self, T);\n+}\n+\n+impl Trait for bool {\n+    fn a<T: Bound>(&self, _: T) {}\n+    //^~ This gets rejected but should be accepted\n+    fn b<T>(&self, _: T) where T: Bound {}\n+    fn c<T: Bound>(&self, _: T) {}\n+    fn d<T>(&self, _: T) where T: Bound {}\n+}\n+\n+fn main() {}"}]}