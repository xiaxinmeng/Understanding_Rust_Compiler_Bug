{"sha": "1ed962b9e34013942304a64bffef786f61c61f9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlZDk2MmI5ZTM0MDEzOTQyMzA0YTY0YmZmZWY3ODZmNjFjNjFmOWQ=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2017-08-25T18:46:49Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2017-08-25T18:46:49Z"}, "message": "Fix #43493 (new trace_macros doesn't work if there's an error during expansion)", "tree": {"sha": "ee98026ce6fead679065c05050289d3251d3218f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee98026ce6fead679065c05050289d3251d3218f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ed962b9e34013942304a64bffef786f61c61f9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ed962b9e34013942304a64bffef786f61c61f9d", "html_url": "https://github.com/rust-lang/rust/commit/1ed962b9e34013942304a64bffef786f61c61f9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ed962b9e34013942304a64bffef786f61c61f9d/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4d11495f9e70ee246ab6a61dec8bdc751fb142a", "html_url": "https://github.com/rust-lang/rust/commit/a4d11495f9e70ee246ab6a61dec8bdc751fb142a"}], "stats": {"total": 13, "additions": 13, "deletions": 0}, "files": [{"sha": "ab0fd678e66f44b462b2a820a5e818fc97bf47ec", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1ed962b9e34013942304a64bffef786f61c61f9d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ed962b9e34013942304a64bffef786f61c61f9d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1ed962b9e34013942304a64bffef786f61c61f9d", "patch": "@@ -391,6 +391,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n                 suggested_limit));\n             err.emit();\n+            self.cx.trace_macros_diag();\n             panic!(FatalError);\n         }\n \n@@ -439,11 +440,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n             ProcMacroDerive(..) | BuiltinDerive(..) => {\n                 self.cx.span_err(attr.span, &format!(\"`{}` is a derive mode\", attr.path));\n+                self.cx.trace_macros_diag();\n                 kind.dummy(attr.span)\n             }\n             _ => {\n                 let msg = &format!(\"macro `{}` may not be used in attributes\", attr.path);\n                 self.cx.span_err(attr.span, msg);\n+                self.cx.trace_macros_diag();\n                 kind.dummy(attr.span)\n             }\n         }\n@@ -482,6 +485,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 if let Err(msg) = validate_and_set_expn_info(def_span.map(|(_, s)| s),\n                                                              false, false) {\n                     self.cx.span_err(path.span, &msg);\n+                    self.cx.trace_macros_diag();\n                     return kind.dummy(span);\n                 }\n                 kind.make_from(expand.expand(self.cx, span, mac.node.stream()))\n@@ -497,6 +501,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                                              allow_internal_unstable,\n                                                              allow_internal_unsafe) {\n                     self.cx.span_err(path.span, &msg);\n+                    self.cx.trace_macros_diag();\n                     return kind.dummy(span);\n                 }\n                 kind.make_from(expander.expand(self.cx, span, mac.node.stream()))\n@@ -506,6 +511,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 if ident.name == keywords::Invalid.name() {\n                     self.cx.span_err(path.span,\n                                     &format!(\"macro {}! expects an ident argument\", path));\n+                    self.cx.trace_macros_diag();\n                     return kind.dummy(span);\n                 };\n \n@@ -526,11 +532,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             MultiDecorator(..) | MultiModifier(..) | AttrProcMacro(..) => {\n                 self.cx.span_err(path.span,\n                                  &format!(\"`{}` can only be used in attributes\", path));\n+                self.cx.trace_macros_diag();\n                 return kind.dummy(span);\n             }\n \n             ProcMacroDerive(..) | BuiltinDerive(..) => {\n                 self.cx.span_err(path.span, &format!(\"`{}` is a derive mode\", path));\n+                self.cx.trace_macros_diag();\n                 return kind.dummy(span);\n             }\n \n@@ -539,6 +547,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let msg =\n                         format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n                     self.cx.span_err(path.span, &msg);\n+                    self.cx.trace_macros_diag();\n                     return kind.dummy(span);\n                 }\n \n@@ -564,6 +573,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n                               name = path.segments[0].identifier.name, kind = kind.name());\n             self.cx.span_err(path.span, &msg);\n+            self.cx.trace_macros_diag();\n             kind.dummy(span)\n         })\n     }\n@@ -617,6 +627,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             _ => {\n                 let msg = &format!(\"macro `{}` may not be used for derive attributes\", attr.path);\n                 self.cx.span_err(span, msg);\n+                self.cx.trace_macros_diag();\n                 kind.dummy(span)\n             }\n         }\n@@ -691,6 +702,7 @@ impl<'a> Parser<'a> {\n                                of `{}!` is likely invalid in {} context\",\n                                macro_path, kind_name);\n             err.span_note(span, &msg).emit();\n+            self.cx.trace_macros_diag();\n         }\n     }\n }\n@@ -739,6 +751,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         if !traits.is_empty() &&\n            (kind == ExpansionKind::TraitItems || kind == ExpansionKind::ImplItems) {\n             self.cx.span_err(traits[0].span, \"`derive` can be only be applied to items\");\n+            self.cx.trace_macros_diag();\n             return kind.expect_from_annotatables(::std::iter::once(item));\n         }\n         self.collect(kind, InvocationKind::Attr { attr: attr, traits: traits, item: item })"}]}