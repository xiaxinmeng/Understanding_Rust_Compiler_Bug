{"sha": "47d27af228e574e281184a10f9a98f47ecce32ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZDI3YWYyMjhlNTc0ZTI4MTE4NGExMGY5YTk4ZjQ3ZWNjZTMyYWM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-22T17:30:03Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-22T17:30:03Z"}, "message": "Merge branch 'master' of github.com:graydon/rust", "tree": {"sha": "d5dce2b742d73bb01ea0a9c528d9f996aacf1216", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5dce2b742d73bb01ea0a9c528d9f996aacf1216"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47d27af228e574e281184a10f9a98f47ecce32ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47d27af228e574e281184a10f9a98f47ecce32ac", "html_url": "https://github.com/rust-lang/rust/commit/47d27af228e574e281184a10f9a98f47ecce32ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47d27af228e574e281184a10f9a98f47ecce32ac/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8005f0c564311fe2a3c0a72a5f3d4482ad0947e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8005f0c564311fe2a3c0a72a5f3d4482ad0947e2", "html_url": "https://github.com/rust-lang/rust/commit/8005f0c564311fe2a3c0a72a5f3d4482ad0947e2"}, {"sha": "07d7f828cd858bed67855e5a5ba24369625a981e", "url": "https://api.github.com/repos/rust-lang/rust/commits/07d7f828cd858bed67855e5a5ba24369625a981e", "html_url": "https://github.com/rust-lang/rust/commit/07d7f828cd858bed67855e5a5ba24369625a981e"}], "stats": {"total": 498, "additions": 176, "deletions": 322}, "files": [{"sha": "c07ef5b37a0b8864dc715de7ded568f543b27aa3", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/47d27af228e574e281184a10f9a98f47ecce32ac/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/47d27af228e574e281184a10f9a98f47ecce32ac/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=47d27af228e574e281184a10f9a98f47ecce32ac", "patch": "@@ -27,6 +27,7 @@ Jesse Ruderman <jruderman@gmail.com>\n Josh Matthews <josh@joshmatthews.net>\n Joshua Wise <joshua@joshuawise.com>\n Kelly Wilson <wilsonk@cpsc.ucalgary.ca>\n+Lennart Kudling\n Lindsey Kuper <lkuper@mozilla.com>\n Marijn Haverbeke <marijnh@gmail.com>\n Matt Brubeck <mbrubeck@limpet.net>"}, {"sha": "169a1354f98681de13f77068225c343e474cd691", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=47d27af228e574e281184a10f9a98f47ecce32ac", "patch": "@@ -653,7 +653,7 @@ fn encode_hash(ebml_w: ebml::writer, hash: str) {\n \n fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> str {\n \n-    let abbrevs = map::mk_hashmap(ty::hash_ty, ty::eq_ty);\n+    let abbrevs = ty::new_ty_hash();\n     let ecx = @{ccx: cx, type_abbrevs: abbrevs};\n \n     let string_w = io::string_writer();"}, {"sha": "1a34fe631e954912bade5569d03f39443757dbb1", "filename": "src/comp/middle/check_const.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_const.rs?ref=47d27af228e574e281184a10f9a98f47ecce32ac", "patch": "@@ -43,7 +43,6 @@ fn check_expr(sess: session, e: @expr, &&is_const: bool, v: visit::vt<bool>) {\n                           \"disallowed operator in constant expression\");\n             ret;\n           }\n-          expr_cast(_, _) { }\n           expr_lit(@{node: lit_str(_), _}) {\n             sess.span_err(e.span,\n                           \"string constants are not supported\");"}, {"sha": "19b1578b29afd13baf436c477fdfda6c5b0d284e", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=47d27af228e574e281184a10f9a98f47ecce32ac", "patch": "@@ -267,8 +267,7 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n     let cache = get_cache(cx);\n     let tg = BasicTypeDescriptorTag;\n     alt cached_metadata::<@metadata<tydesc_md>>(\n-        cache, tg,\n-        {|md| ty::hash_ty(t) == ty::hash_ty(md.data.hash)}) {\n+        cache, tg, {|md| t == md.data.hash}) {\n       option::some(md) { ret md; }\n       option::none. {}\n     }\n@@ -311,7 +310,7 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n                   lli32(0), //XXX flags?\n                   lli32(encoding)];\n     let llnode = llmdnode(lldata);\n-    let mdval = @{node: llnode, data: {hash: ty::hash_ty(t)}};\n+    let mdval = @{node: llnode, data: {hash: t}};\n     update_cache(cache, tg, tydesc_metadata(mdval));\n     add_named_metadata(cx, \"llvm.dbg.ty\", llnode);\n     ret mdval;\n@@ -333,7 +332,7 @@ fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: codemap::span,\n     //let cu_node = create_compile_unit(cx, fname);\n     let llnode = create_derived_type(tg, file_node.node, \"\", 0, size * 8,\n                                      align * 8, 0, pointee.node);\n-    let mdval = @{node: llnode, data: {hash: ty::hash_ty(t)}};\n+    let mdval = @{node: llnode, data: {hash: t}};\n     //update_cache(cache, tg, tydesc_metadata(mdval));\n     add_named_metadata(cx, \"llvm.dbg.ty\", llnode);\n     ret mdval;"}, {"sha": "786ab1886c8643127a49df80479ab14f016993cf", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 9, "deletions": 32, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=47d27af228e574e281184a10f9a98f47ecce32ac", "patch": "@@ -3581,12 +3581,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         }\n         else { ret lval_to_dps(bcx, a, dest); }\n       }\n-      ast::expr_cast(val, _) {\n-        alt tcx.cast_map.find(e.id) {\n-          some(ty::triv_cast.) { ret trans_expr(bcx, val, dest); }\n-          _ { ret trans_cast(bcx, val, e.id, dest); }\n-        }\n-      }\n+      ast::expr_cast(val, _) { ret trans_cast(bcx, val, e.id, dest); }\n       ast::expr_anon_obj(anon_obj) {\n         ret trans_anon_obj(bcx, e.span, anon_obj, e.id, dest);\n       }\n@@ -3615,7 +3610,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         // that is_call_expr(ex) -- but we don't support that\n         // yet\n         // FIXME\n-        check (ast_util::is_tail_call_expr(ex));\n+        check (ast_util::is_call_expr(ex));\n         ret trans_be(bcx, ex);\n       }\n       ast::expr_fail(expr) {\n@@ -3952,8 +3947,7 @@ fn trans_ret(bcx: @block_ctxt, e: option::t<@ast::expr>) -> @block_ctxt {\n fn build_return(bcx: @block_ctxt) { Br(bcx, bcx_fcx(bcx).llreturn); }\n \n // fn trans_be(cx: &@block_ctxt, e: &@ast::expr) -> result {\n-fn trans_be(cx: @block_ctxt, e: @ast::expr) :\n-ast_util::is_tail_call_expr(e) ->\n+fn trans_be(cx: @block_ctxt, e: @ast::expr) : ast_util::is_call_expr(e) ->\n    @block_ctxt {\n     // FIXME: Turn this into a real tail call once\n     // calling convention issues are settled\n@@ -4354,7 +4348,7 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: span, llfndecl: ValueRef,\n           lllocals: new_int_hash::<local_val>(),\n           llupvars: new_int_hash::<ValueRef>(),\n           mutable lltydescs: [],\n-          derived_tydescs: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n+          derived_tydescs: ty::new_ty_hash(),\n           id: id,\n           ret_style: rstyle,\n           sp: sp,\n@@ -4728,16 +4722,6 @@ fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method],\n // that does so later on?\n fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n     alt e.node {\n-      ast::expr_cast(e1, _) {\n-        alt ccx_tcx(cx).cast_map.find(e.id) {\n-          some(ty::triv_cast.) { trans_const_expr(cx, e1) }\n-          _ {\n-              cx.sess.span_err(e.span,\n-                               \"non-trivial cast in constant expression\");\n-              fail;\n-            }\n-        }\n-      }\n       ast::expr_lit(lit) { ret trans_crate_lit(cx, *lit); }\n       ast::expr_binary(b, e1, e2) {\n         let te1 = trans_const_expr(cx, e1);\n@@ -5658,13 +5642,6 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     tn.associate(\"taskptr\", taskptr_type);\n     let tydesc_type = T_tydesc(targ_cfg);\n     tn.associate(\"tydesc\", tydesc_type);\n-    let hasher = ty::hash_ty;\n-    let eqer = ty::eq_ty;\n-    let tag_sizes = map::mk_hashmap::<ty::t, uint>(hasher, eqer);\n-    let tydescs = map::mk_hashmap::<ty::t, @tydesc_info>(hasher, eqer);\n-    let lltypes = map::mk_hashmap::<ty::t, TypeRef>(hasher, eqer);\n-    let sha1s = map::mk_hashmap::<ty::t, str>(hasher, eqer);\n-    let short_names = map::mk_hashmap::<ty::t, str>(hasher, eqer);\n     let crate_map = decl_crate_map(sess, link_meta.name, llmod);\n     let dbg_cx = if sess.get_opts().debuginfo {\n         option::some(@{llmetadata: map::new_int_hash(),\n@@ -5685,18 +5662,18 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           item_symbols: new_int_hash::<str>(),\n           mutable main_fn: none::<ValueRef>,\n           link_meta: link_meta,\n-          tag_sizes: tag_sizes,\n+          tag_sizes: ty::new_ty_hash(),\n           discrims: ast_util::new_def_id_hash::<ValueRef>(),\n           discrim_symbols: new_int_hash::<str>(),\n           consts: new_int_hash::<ValueRef>(),\n           obj_methods: new_int_hash::<()>(),\n-          tydescs: tydescs,\n+          tydescs: ty::new_ty_hash(),\n           module_data: new_str_hash::<ValueRef>(),\n-          lltypes: lltypes,\n+          lltypes: ty::new_ty_hash(),\n           names: namegen(0),\n           sha: sha,\n-          type_sha1s: sha1s,\n-          type_short_names: short_names,\n+          type_sha1s: ty::new_ty_hash(),\n+          type_short_names: ty::new_ty_hash(),\n           tcx: tcx,\n           mut_map: mut_map,\n           copy_map: copy_map,"}, {"sha": "25c8d948a40b6d8bafc2f1286e054ae52472d27d", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 85, "deletions": 142, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=47d27af228e574e281184a10f9a98f47ecce32ac", "patch": "@@ -31,13 +31,11 @@ export ast_constr_to_constr;\n export bind_params_in_type;\n export block_ty;\n export constr;\n-export cast_type;\n export constr_general;\n export constr_table;\n export count_ty_params;\n export ctxt;\n export def_has_ty_params;\n-export eq_ty;\n export expr_has_ty_params;\n export expr_ty;\n export expr_ty_params_and_ty;\n@@ -48,7 +46,6 @@ export field_idx;\n export get_field;\n export fm_general;\n export get_element_type;\n-export hash_ty;\n export idx_nil;\n export is_binopable;\n export is_pred_ty;\n@@ -104,10 +101,9 @@ export stmt_node_id;\n export sty;\n export substitute_type_params;\n export t;\n+export new_ty_hash;\n export tag_variants;\n export tag_variant_with_id;\n-export triv_cast;\n-export triv_eq_ty;\n export ty_param_substs_opt_and_ty;\n export ty_param_kinds_and_ty;\n export ty_native_fn;\n@@ -133,14 +129,14 @@ export ty_param;\n export ty_ptr;\n export ty_rec;\n export ty_tag;\n-export ty_to_machine_ty;\n export ty_tup;\n export ty_type;\n export ty_send_type;\n export ty_uint;\n export ty_uniq;\n export ty_var;\n export ty_named;\n+export same_type, same_method;\n export ty_var_id;\n export ty_param_substs_opt_and_ty_to_monotype;\n export ty_fn_args;\n@@ -211,20 +207,10 @@ type mt = {ty: t, mut: ast::mutability};\n // the types of AST nodes.\n type creader_cache = hashmap<{cnum: int, pos: uint, len: uint}, ty::t>;\n \n-type tag_var_cache =\n-    @smallintmap::smallintmap<@mutable [variant_info]>;\n-\n-tag cast_type {\n-    /* cast may be ignored after substituting primitive with machine types\n-       since expr already has the right type */\n-    triv_cast;\n-}\n-\n type ctxt =\n     @{ts: @type_store,\n       sess: session::session,\n       def_map: resolve::def_map,\n-      cast_map: hashmap<ast::node_id, cast_type>,\n       node_types: node_type_table,\n       items: ast_map::map,\n       freevars: freevars::freevar_map,\n@@ -234,7 +220,7 @@ type ctxt =\n       needs_drop_cache: hashmap<t, bool>,\n       kind_cache: hashmap<t, ast::kind>,\n       ast_ty_to_ty_cache: hashmap<@ast::ty, option::t<t>>,\n-      tag_var_cache: tag_var_cache};\n+      tag_var_cache: hashmap<ast::def_id, @[variant_info]>};\n \n type ty_ctxt = ctxt;\n \n@@ -409,29 +395,31 @@ fn mk_rcache() -> creader_cache {\n     ret map::mk_hashmap(hash_cache_entry, eq_cache_entries);\n }\n \n+fn new_ty_hash<copy V>() -> map::hashmap<t, V> { map::new_uint_hash() }\n \n fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n            freevars: freevars::freevar_map) -> ctxt {\n     let ntt: node_type_table =\n         @smallintmap::mk::<ty::ty_param_substs_opt_and_ty>();\n-    let tcache = new_def_hash::<ty::ty_param_kinds_and_ty>();\n+    fn eq_raw_ty(&&a: @raw_t, &&b: @raw_t) -> bool {\n+        ret a.hash == b.hash && a.struct == b.struct;\n+    }\n     let ts = @interner::mk::<@raw_t>(hash_raw_ty, eq_raw_ty);\n     let cx =\n         @{ts: ts,\n           sess: s,\n           def_map: dm,\n-          cast_map: ast_util::new_node_hash(),\n           node_types: ntt,\n           items: amap,\n           freevars: freevars,\n-          tcache: tcache,\n+          tcache: new_def_hash(),\n           rcache: mk_rcache(),\n-          short_names_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n-          needs_drop_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n-          kind_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n+          short_names_cache: new_ty_hash(),\n+          needs_drop_cache: new_ty_hash(),\n+          kind_cache: new_ty_hash(),\n           ast_ty_to_ty_cache:\n               map::mk_hashmap(ast_util::hash_ty, ast_util::eq_ty),\n-          tag_var_cache: @smallintmap::mk()};\n+          tag_var_cache: new_def_hash()};\n     populate_type_store(cx);\n     ret cx;\n }\n@@ -1245,8 +1233,7 @@ fn type_autoderef(cx: ctxt, t: ty::t) -> ty::t {\n     ret t1;\n }\n \n-// Type hashing. This function is private to this module (and slow); external\n-// users should use `hash_ty()` instead.\n+// Type hashing.\n fn hash_type_structure(st: sty) -> uint {\n     fn hash_uint(id: uint, n: uint) -> uint {\n         let h = id;\n@@ -1261,7 +1248,7 @@ fn hash_type_structure(st: sty) -> uint {\n     }\n     fn hash_subty(id: uint, subty: t) -> uint {\n         let h = id;\n-        h += (h << 5u) + hash_ty(subty);\n+        h += (h << 5u) + subty;\n         ret h;\n     }\n     fn hash_subtys(id: uint, subtys: [t]) -> uint {\n@@ -1296,8 +1283,8 @@ fn hash_type_structure(st: sty) -> uint {\n \n     fn hash_fn(id: uint, args: [arg], rty: t) -> uint {\n         let h = id;\n-        for a: arg in args { h += (h << 5u) + hash_ty(a.ty); }\n-        h += (h << 5u) + hash_ty(rty);\n+        for a: arg in args { h += (h << 5u) + a.ty; }\n+        h += (h << 5u) + rty;\n         ret h;\n     }\n     alt st {\n@@ -1320,14 +1307,14 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_str. { ret 17u; }\n       ty_tag(did, tys) {\n         let h = hash_def(18u, did);\n-        for typ: t in tys { h += (h << 5u) + hash_ty(typ); }\n+        for typ: t in tys { h += (h << 5u) + typ; }\n         ret h;\n       }\n       ty_box(mt) { ret hash_subty(19u, mt.ty); }\n       ty_vec(mt) { ret hash_subty(21u, mt.ty); }\n       ty_rec(fields) {\n         let h = 26u;\n-        for f: field in fields { h += (h << 5u) + hash_ty(f.mt.ty); }\n+        for f: field in fields { h += (h << 5u) + f.mt.ty; }\n         ret h;\n       }\n       ty_tup(ts) { ret hash_subtys(25u, ts); }\n@@ -1366,13 +1353,6 @@ fn hash_type_structure(st: sty) -> uint {\n \n fn hash_raw_ty(&&rt: @raw_t) -> uint { ret rt.hash; }\n \n-fn hash_ty(&&typ: t) -> uint { ret typ; }\n-\n-\n-// Type equality. This function is private to this module (and slow); external\n-// users should use `eq_ty()` instead.\n-fn eq_int(&&x: uint, &&y: uint) -> bool { ret x == y; }\n-\n fn arg_eq<T>(eq: fn(T, T) -> bool, a: @sp_constr_arg<T>, b: @sp_constr_arg<T>)\n    -> bool {\n     alt a.node {\n@@ -1401,6 +1381,7 @@ fn args_eq<T>(eq: fn(T, T) -> bool, a: [@sp_constr_arg<T>],\n }\n \n fn constr_eq(c: @constr, d: @constr) -> bool {\n+    fn eq_int(&&x: uint, &&y: uint) -> bool { ret x == y; }\n     ret path_to_str(c.node.path) == path_to_str(d.node.path) &&\n             // FIXME: hack\n             args_eq(eq_int, c.node.args, d.node.args);\n@@ -1413,52 +1394,6 @@ fn constrs_eq(cs: [@constr], ds: [@constr]) -> bool {\n     ret true;\n }\n \n-// This function is private to this module.\n-fn eq_raw_ty(&&a: @raw_t, &&b: @raw_t) -> bool {\n-    ret a.hash == b.hash && a.struct == b.struct;\n-}\n-\n-\n-// This is the equality function the public should use. It works as long as\n-// the types are interned.\n-fn eq_ty(&&a: t, &&b: t) -> bool { a == b }\n-\n-\n-// Convert type to machine type\n-// (i.e. replace uint, int, float with target architecture machine types)\n-//\n-// FIXME somewhat expensive but this should only be called rarely\n-fn ty_to_machine_ty(cx: ctxt, ty: t) -> t {\n-    fn sub_fn(cx: ctxt, uint_ty: t, int_ty: t, float_ty: t, in: t) -> t {\n-        alt struct(cx, in) {\n-          ty_uint(ast::ty_u.) { ret uint_ty; }\n-          ty_int(ast::ty_i.) { ret int_ty; }\n-          ty_float(ast::ty_f.) { ret float_ty; }\n-          _ { ret in; }\n-        }\n-    }\n-\n-    let cfg      = cx.sess.get_targ_cfg();\n-    let uint_ty  = mk_mach_uint(cx, cfg.uint_type);\n-    let int_ty   = mk_mach_int(cx, cfg.int_type);\n-    let float_ty = mk_mach_float(cx, cfg.float_type);\n-    let fold_m   = fm_general(bind sub_fn(cx, uint_ty, int_ty, float_ty, _));\n-\n-    ret fold_ty(cx, fold_m, ty);\n-}\n-\n-// Two types are trivially equal if they are either\n-// equal or if they are equal after substituting all occurences of\n-//  machine independent primitive types by their machine type equivalents\n-// for the current target architecture\n-fn triv_eq_ty(cx: ctxt, &&a: t, &&b: t) -> bool {\n-    let a = alt interner::get(*cx.ts, a).struct\n-        { ty_named(t, _) { t } _ { a } };\n-    let b = alt interner::get(*cx.ts, b).struct\n-        { ty_named(t, _) { t } _ { b } };\n-    a == b || ty_to_machine_ty(cx, a) == ty_to_machine_ty(cx, b)\n-}\n-\n // Type lookups\n fn node_id_to_ty_param_substs_opt_and_ty(cx: ctxt, id: ast::node_id) ->\n    ty_param_substs_opt_and_ty {\n@@ -1745,7 +1680,7 @@ mod unify {\n     type var_bindings =\n         {sets: ufind::ufind, types: smallintmap::smallintmap<t>};\n \n-    type ctxt = {vb: @var_bindings, tcx: ty_ctxt};\n+    type ctxt = {vb: option::t<@var_bindings>, tcx: ty_ctxt};\n \n     fn mk_var_bindings() -> @var_bindings {\n         ret @{sets: ufind::make(), types: smallintmap::mk::<t>()};\n@@ -1754,31 +1689,32 @@ mod unify {\n     // Unifies two sets.\n     fn union(cx: @ctxt, set_a: uint, set_b: uint,\n              variance: variance) -> union_result {\n-        ufind::grow(cx.vb.sets, float::max(set_a, set_b) + 1u);\n-        let root_a = ufind::find(cx.vb.sets, set_a);\n-        let root_b = ufind::find(cx.vb.sets, set_b);\n+        let vb = option::get(cx.vb);\n+        ufind::grow(vb.sets, float::max(set_a, set_b) + 1u);\n+        let root_a = ufind::find(vb.sets, set_a);\n+        let root_b = ufind::find(vb.sets, set_b);\n \n         let replace_type =\n-            bind fn (cx: @ctxt, t: t, set_a: uint, set_b: uint) {\n-                     ufind::union(cx.vb.sets, set_a, set_b);\n-                     let root_c: uint = ufind::find(cx.vb.sets, set_a);\n-                     smallintmap::insert::<t>(cx.vb.types, root_c, t);\n+            bind fn (vb: @var_bindings, t: t, set_a: uint, set_b: uint) {\n+                     ufind::union(vb.sets, set_a, set_b);\n+                     let root_c: uint = ufind::find(vb.sets, set_a);\n+                     smallintmap::insert::<t>(vb.types, root_c, t);\n                  }(_, _, set_a, set_b);\n \n \n-        alt smallintmap::find(cx.vb.types, root_a) {\n+        alt smallintmap::find(vb.types, root_a) {\n           none. {\n-            alt smallintmap::find(cx.vb.types, root_b) {\n-              none. { ufind::union(cx.vb.sets, set_a, set_b); ret unres_ok; }\n-              some(t_b) { replace_type(cx, t_b); ret unres_ok; }\n+            alt smallintmap::find(vb.types, root_b) {\n+              none. { ufind::union(vb.sets, set_a, set_b); ret unres_ok; }\n+              some(t_b) { replace_type(vb, t_b); ret unres_ok; }\n             }\n           }\n           some(t_a) {\n-            alt smallintmap::find(cx.vb.types, root_b) {\n-              none. { replace_type(cx, t_a); ret unres_ok; }\n+            alt smallintmap::find(vb.types, root_b) {\n+              none. { replace_type(vb, t_a); ret unres_ok; }\n               some(t_b) {\n                 alt unify_step(cx, t_a, t_b, variance) {\n-                  ures_ok(t_c) { replace_type(cx, t_c); ret unres_ok; }\n+                  ures_ok(t_c) { replace_type(vb, t_c); ret unres_ok; }\n                   ures_err(terr) { ret unres_err(terr); }\n                 }\n               }\n@@ -1803,10 +1739,11 @@ mod unify {\n     fn record_var_binding(\n         cx: @ctxt, key: int, typ: t, variance: variance) -> result {\n \n-        ufind::grow(cx.vb.sets, (key as uint) + 1u);\n-        let root = ufind::find(cx.vb.sets, key as uint);\n+        let vb = option::get(cx.vb);\n+        ufind::grow(vb.sets, (key as uint) + 1u);\n+        let root = ufind::find(vb.sets, key as uint);\n         let result_type = typ;\n-        alt smallintmap::find::<t>(cx.vb.types, root) {\n+        alt smallintmap::find(vb.types, root) {\n           some(old_type) {\n             alt unify_step(cx, old_type, typ, variance) {\n               ures_ok(unified_type) { result_type = unified_type; }\n@@ -1815,7 +1752,7 @@ mod unify {\n           }\n           none. {/* fall through */ }\n         }\n-        smallintmap::insert::<t>(cx.vb.types, root, result_type);\n+        smallintmap::insert::<t>(vb.types, root, result_type);\n         ret ures_ok(typ);\n     }\n \n@@ -2136,19 +2073,23 @@ mod unify {\n \n     fn unify_step(cx: @ctxt, expected: t, actual: t,\n                   variance: variance) -> result {\n-        // TODO: rewrite this using tuple pattern matching when available, to\n+        // FIXME: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n+        // NOTE: we have tuple matching now, but that involves copying the\n+        // matched elements into a tuple first, which is expensive, since sty\n+        // holds vectors, which are currently unique\n \n         // Fast path.\n+        if expected == actual { ret ures_ok(expected); }\n \n-        if eq_ty(expected, actual) { ret ures_ok(expected); }\n         // Stage 1: Handle the cases in which one side or another is a type\n         // variable.\n \n         alt struct(cx.tcx, actual) {\n           // If the RHS is a variable type, then just do the\n           // appropriate binding.\n           ty::ty_var(actual_id) {\n+            assert option::is_some(cx.vb);\n             let actual_n = actual_id as uint;\n             alt struct(cx.tcx, expected) {\n               ty::ty_var(expected_id) {\n@@ -2173,8 +2114,8 @@ mod unify {\n         }\n         alt struct(cx.tcx, expected) {\n           ty::ty_var(expected_id) {\n+            assert option::is_some(cx.vb);\n             // Add a binding. (`actual` can't actually be a var here.)\n-\n             alt record_var_binding_for_expected(\n                 cx, expected_id, actual,\n                 variance) {\n@@ -2490,8 +2431,8 @@ mod unify {\n           }\n         }\n     }\n-    fn unify(expected: t, actual: t, vb: @var_bindings, tcx: ty_ctxt) ->\n-       result {\n+    fn unify(expected: t, actual: t, vb: option::t<@var_bindings>,\n+             tcx: ty_ctxt) -> result {\n         let cx = @{vb: vb, tcx: tcx};\n         ret unify_step(cx, expected, actual, covariant);\n     }\n@@ -2564,6 +2505,19 @@ mod unify {\n     }\n }\n \n+fn same_type(cx: ctxt, a: t, b: t) -> bool {\n+    alt unify::unify(a, b, none, cx) {\n+      unify::ures_ok(_) { true }\n+      _ { false }\n+    }\n+}\n+fn same_method(cx: ctxt, a: method, b: method) -> bool {\n+    a.proto == b.proto && a.ident == b.ident &&\n+    vec::all2(a.inputs, b.inputs,\n+              {|a, b| a.mode == b.mode && same_type(cx, a.ty, b.ty) }) &&\n+    same_type(cx, a.output, b.output) && a.cf == b.cf\n+}\n+\n fn type_err_to_str(err: ty::type_err) -> str {\n     alt err {\n       terr_mismatch. { ret \"types differ\"; }\n@@ -2669,45 +2623,34 @@ fn def_has_ty_params(def: ast::def) -> bool {\n // Tag information\n type variant_info = @{args: [ty::t], ctor_ty: ty::t, id: ast::def_id};\n \n-fn tag_variants(cx: ctxt, id: ast::def_id) -> @mutable [variant_info] {\n-    if ast::local_crate != id.crate {\n-        ret @mutable csearch::get_tag_variants(cx, id);\n-    }\n-    assert (id.node >= 0);\n-    alt smallintmap::find(*cx.tag_var_cache, id.node as uint) {\n-      option::some(variants) { ret variants; }\n+fn tag_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n+    alt cx.tag_var_cache.find(id) {\n+      some(variants) { ret variants; }\n       _ { /* fallthrough */ }\n     }\n-    let item =\n-        alt cx.items.find(id.node) {\n-          some(i) { i }\n-          none. { cx.sess.bug(\"expected to find cached node_item\") }\n-        };\n-    alt item {\n-      ast_map::node_item(item) {\n-        alt item.node {\n-          ast::item_tag(variants, _) {\n-            let result: @mutable [variant_info] = @mutable [];\n-            for variant: ast::variant in variants {\n-                let ctor_ty = node_id_to_monotype(cx, variant.node.id);\n-                let arg_tys: [t] = [];\n-                if vec::len(variant.node.args) > 0u {\n-                    for a: arg in ty_fn_args(cx, ctor_ty) {\n-                        arg_tys += [a.ty];\n-                    }\n-                }\n-                let did = variant.node.id;\n-                *result +=\n-                    [@{args: arg_tys,\n-                       ctor_ty: ctor_ty,\n-                       id: ast_util::local_def(did)}];\n+    let result = if ast::local_crate != id.crate {\n+        @csearch::get_tag_variants(cx, id)\n+    } else {\n+        alt cx.items.get(id.node) {\n+          ast_map::node_item(item) {\n+            alt item.node {\n+              ast::item_tag(variants, _) {\n+                @vec::map(variants, {|variant|\n+                    let ctor_ty = node_id_to_monotype(cx, variant.node.id);\n+                    let arg_tys = if vec::len(variant.node.args) > 0u {\n+                        vec::map(ty_fn_args(cx, ctor_ty), {|a| a.ty})\n+                    } else { [] };\n+                    @{args: arg_tys,\n+                      ctor_ty: ctor_ty,\n+                      id: ast_util::local_def(variant.node.id)}\n+                })\n+              }\n             }\n-            smallintmap::insert(*cx.tag_var_cache, id.node as uint, result);\n-            ret result;\n           }\n         }\n-      }\n-    }\n+    };\n+    cx.tag_var_cache.insert(id, result);\n+    result\n }\n \n "}, {"sha": "400411fa68ab11f451ec2ea0366a9ad9ee33df07", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 11, "deletions": 28, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=47d27af228e574e281184a10f9a98f47ecce32ac", "patch": "@@ -791,7 +791,8 @@ mod collect {\n mod unify {\n     fn unify(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) ->\n        ty::unify::result {\n-        ret ty::unify::unify(expected, actual, fcx.var_bindings, fcx.ccx.tcx);\n+        ret ty::unify::unify(expected, actual, some(fcx.var_bindings),\n+                             fcx.ccx.tcx);\n     }\n }\n \n@@ -1106,7 +1107,7 @@ fn gather_locals(ccx: @crate_ctxt,\n             alt ty_opt {\n               none. {/* nothing to do */ }\n               some(typ) {\n-                ty::unify::unify(ty::mk_var(tcx, var_id), typ, vb, tcx);\n+                ty::unify::unify(ty::mk_var(tcx, var_id), typ, some(vb), tcx);\n               }\n             }\n         };\n@@ -1198,8 +1199,8 @@ fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n         check_expr_with(fcx, end, expected);\n         let b_ty = resolve_type_vars_if_possible(fcx, expr_ty(fcx.ccx.tcx,\n                                                               begin));\n-        if b_ty != resolve_type_vars_if_possible(fcx, expr_ty(fcx.ccx.tcx,\n-                                                              end)) {\n+        if !ty::same_type(fcx.ccx.tcx, b_ty, resolve_type_vars_if_possible(\n+            fcx, expr_ty(fcx.ccx.tcx, end))) {\n             fcx.ccx.tcx.sess.span_err(pat.span, \"mismatched types in range\");\n         } else if !ty::type_is_numeric(fcx.ccx.tcx, b_ty) {\n             fcx.ccx.tcx.sess.span_err(pat.span,\n@@ -1850,21 +1851,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_be(e) {\n         // FIXME: prove instead of assert\n-        assert (ast_util::is_tail_call_expr(e));\n+        assert (ast_util::is_call_expr(e));\n         check_expr_with(fcx, e, fcx.ret_ty);\n-\n-        alt e.node {\n-          ast::expr_cast(_, _) {\n-            alt tcx.cast_map.find(e.id) {\n-              option::some(ty::triv_cast.) { }\n-              _ { tcx.sess.span_err(expr.span,\n-                    \"non-trivial cast of tail-call return value\");\n-                }\n-            }\n-          }\n-          _ { /* regular tail call */ }\n-        }\n-\n         bot = true;\n         write::nil_ty(tcx, id);\n       }\n@@ -2066,19 +2054,19 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_cast(e, t) {\n         bot = check_expr(fcx, e);\n         let t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n-        let t_e = expr_ty(tcx, e);\n+        let t_e = ty::expr_ty(tcx, e);\n \n         if ty::type_is_nil(tcx, t_e) {\n             tcx.sess.span_err(expr.span,\n                               \"cast from nil: \" +\n-                                  ty_to_str(tcx, expr_ty(tcx, e)) + \" as \" +\n+                                  ty_to_str(tcx, t_e) + \" as \" +\n                                   ty_to_str(tcx, t_1));\n         }\n \n         if ty::type_is_nil(tcx, t_1) {\n             tcx.sess.span_err(expr.span,\n                               \"cast to nil: \" +\n-                                  ty_to_str(tcx, expr_ty(tcx, e)) + \" as \" +\n+                                  ty_to_str(tcx, t_e) + \" as \" +\n                                   ty_to_str(tcx, t_1));\n         }\n \n@@ -2087,14 +2075,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n              && type_is_scalar(fcx, expr.span, t_1)) {\n             tcx.sess.span_err(expr.span,\n                               \"non-scalar cast: \" +\n-                                  ty_to_str(tcx, expr_ty(tcx, e)) + \" as \" +\n+                                  ty_to_str(tcx, t_e) + \" as \" +\n                                   ty_to_str(tcx, t_1));\n         }\n-\n-        // mark as triv_cast for later dropping in trans\n-        if ty::triv_eq_ty(tcx, t_1, t_e)\n-            { tcx.cast_map.insert(expr.id, ty::triv_cast); }\n-\n         write::ty_only_fixup(fcx, id, t_1);\n       }\n       ast::expr_vec(args, mut) {\n@@ -2342,7 +2325,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                         // We'd better be overriding with one of the same\n                         // type.  Check to make sure.\n                         let new_type = ty_of_method(ccx.tcx, m_check, om);\n-                        if new_type != m {\n+                        if !ty::same_method(ccx.tcx, new_type, m) {\n                             ccx.tcx.sess.span_fatal\n                                 (om.span, \"attempted to override method \"\n                                  + m.ident + \" with one of a different type\");"}, {"sha": "f32b4f7aa93021b19550c18c644d483fd7a29de8", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=47d27af228e574e281184a10f9a98f47ecce32ac", "patch": "@@ -1,19 +1,10 @@\n-import core::{str, option, int};\n-import std::map;\n import codemap::span;\n import ast::*;\n \n fn respan<copy T>(sp: span, t: T) -> spanned<T> {\n     ret {node: t, span: sp};\n }\n \n-fn new_node_hash<copy V>() -> map::hashmap<node_id, V> {\n-    fn node_id_hash(&&i: node_id) -> uint { ret int::hash(i as int); }\n-    fn node_id_eq(&&a: node_id, &&b: node_id) -> bool\n-        { ret int::eq(a as int, b as int); }\n-    ret map::mk_hashmap(node_id_hash, node_id_eq);\n-}\n-\n /* assuming that we're not in macro expansion */\n fn mk_sp(lo: uint, hi: uint) -> span {\n     ret {lo: lo, hi: hi, expanded_from: codemap::os_none};\n@@ -198,14 +189,6 @@ pure fn is_call_expr(e: @expr) -> bool {\n     alt e.node { expr_call(_, _, _) { true } _ { false } }\n }\n \n-pure fn is_tail_call_expr(e: @expr) -> bool {\n-    alt e.node {\n-      expr_call(_, _, _) { true }\n-      expr_cast(inner_e, _) { is_call_expr(inner_e) }\n-      _ { false }\n-    }\n-}\n-\n fn is_constraint_arg(e: @expr) -> bool {\n     alt e.node {\n       expr_lit(_) { ret true; }"}, {"sha": "84c60144501d247b3acfbdcbbb01f4d2befde347", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=47d27af228e574e281184a10f9a98f47ecce32ac", "patch": "@@ -961,7 +961,7 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n         let e = parse_expr(p);\n \n         // FIXME: Is this the right place for this check?\n-        if /*check*/ ast_util::is_tail_call_expr(e) {\n+        if /*check*/ast_util::is_call_expr(e) {\n             hi = e.span.hi;\n             ex = ast::expr_be(e);\n         } else { p.fatal(\"Non-call expression in tail call\"); }"}, {"sha": "fdc5dda996d13d3e5123cb9185a7ff983b74592a", "filename": "src/libcore/float.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=47d27af228e574e281184a10f9a98f47ecce32ac", "patch": "@@ -482,23 +482,23 @@ Function: acos\n Returns the arccosine of an angle (measured in rad)\n */\n pure fn acos(x: float) -> float\n-    { be m_float::acos(x as m_float) as float }\n+    { ret m_float::acos(x as m_float) as float }\n \n /*\n Function: asin\n \n Returns the arcsine of an angle (measured in rad)\n */\n pure fn asin(x: float) -> float\n-    { be m_float::asin(x as m_float) as float }\n+    { ret m_float::asin(x as m_float) as float }\n \n /*\n Function: atan\n \n Returns the arctangents of an angle (measured in rad)\n */\n pure fn atan(x: float) -> float\n-    { be m_float::atan(x as m_float) as float }\n+    { ret m_float::atan(x as m_float) as float }\n \n \n /*\n@@ -507,23 +507,23 @@ Function: atan2\n Returns the arctangent of an angle (measured in rad)\n */\n pure fn atan2(y: float, x: float) -> float\n-    { be m_float::atan2(y as m_float, x as m_float) as float }\n+    { ret m_float::atan2(y as m_float, x as m_float) as float }\n \n /*\n Function: ceil\n \n Returns the smallest integral value less than or equal to `n`\n */\n pure fn ceil(n: float) -> float\n-    { be m_float::ceil(n as m_float) as float }\n+    { ret m_float::ceil(n as m_float) as float }\n \n /*\n Function: cos\n \n Returns the cosine of an angle `x` (measured in rad)\n */\n pure fn cos(x: float) -> float\n-    { be m_float::cos(x as m_float) as float }\n+    { ret m_float::cos(x as m_float) as float }\n \n /*\n Function: cosh\n@@ -532,7 +532,7 @@ Returns the hyperbolic cosine of `x`\n \n */\n pure fn cosh(x: float) -> float\n-    { be m_float::cosh(x as m_float) as float }\n+    { ret m_float::cosh(x as m_float) as float }\n \n \n /*\n@@ -541,47 +541,47 @@ Function: exp\n Returns `consts::e` to the power of `n*\n */\n pure fn exp(n: float) -> float\n-    { be m_float::exp(n as m_float) as float }\n+    { ret m_float::exp(n as m_float) as float }\n \n /*\n Function: abs\n \n Returns the absolute value of  `n`\n */\n pure fn abs(n: float) -> float\n-    { be m_float::abs(n as m_float) as float }\n+    { ret m_float::abs(n as m_float) as float }\n \n /*\n Function: floor\n \n Returns the largest integral value less than or equal to `n`\n */\n pure fn floor(n: float) -> float\n-    { be m_float::floor(n as m_float) as float }\n+    { ret m_float::floor(n as m_float) as float }\n \n /*\n Function: fmod\n \n Returns the floating-point remainder of `x/y`\n */\n pure fn fmod(x: float, y: float) -> float\n-    { be m_float::fmod(x as m_float, y as m_float) as float }\n+    { ret m_float::fmod(x as m_float, y as m_float) as float }\n \n /*\n Function: ln\n \n Returns the natural logaritm of `n`\n */\n pure fn ln(n: float) -> float\n-    { be m_float::ln(n as m_float) as float }\n+    { ret m_float::ln(n as m_float) as float }\n \n /*\n Function: ldexp\n \n Returns `x` multiplied by 2 to the power of `n`\n */\n pure fn ldexp(n: float, i: int) -> float\n-    { be m_float::ldexp(n as m_float, i as c_int) as float }\n+    { ret m_float::ldexp(n as m_float, i as c_int) as float }\n \n /*\n Function: ln1p\n@@ -590,23 +590,23 @@ Returns the natural logarithm of `1+n` accurately,\n even for very small values of `n`\n */\n pure fn ln1p(n: float) -> float\n-    { be m_float::ln1p(n as m_float) as float }\n+    { ret m_float::ln1p(n as m_float) as float }\n \n /*\n Function: log10\n \n Returns the logarithm to base 10 of `n`\n */\n pure fn log10(n: float) -> float\n-    { be m_float::log10(n as m_float) as float }\n+    { ret m_float::log10(n as m_float) as float }\n \n /*\n Function: log2\n \n Returns the logarithm to base 2 of `n`\n */\n pure fn log2(n: float) -> float\n-    { be m_float::log2(n as m_float) as float }\n+    { ret m_float::log2(n as m_float) as float }\n \n /*\n Function: modf\n@@ -622,7 +622,7 @@ The fractional part of `n`\n */\n #[no(warn_trivial_casts)] // FIXME Implement\n pure fn modf(n: float, &iptr: float) -> float { unsafe {\n-    be m_float::modf(n as m_float, ptr::addr_of(iptr) as *m_float) as float\n+    ret m_float::modf(n as m_float, ptr::addr_of(iptr) as *m_float) as float\n } }\n \n /*\n@@ -640,13 +640,13 @@ Returns:\n The fractional part of `n`\n */\n pure fn frexp(n: float, &exp: c_int) -> float\n-    { be m_float::frexp(n as m_float, exp) as float }\n+    { ret m_float::frexp(n as m_float, exp) as float }\n \n /*\n Function: pow\n */\n pure fn pow(v: float, e: float) -> float\n-    { be m_float::pow(v as m_float, e as m_float) as float }\n+    { ret m_float::pow(v as m_float, e as m_float) as float }\n \n \n /*\n@@ -656,7 +656,7 @@ Returns the integral value nearest to `x` (according to the\n prevailing rounding mode) in floating-point format\n */\n pure fn rint(x: float) -> float\n-    { be m_float::rint(x as m_float) as float }\n+    { ret m_float::rint(x as m_float) as float }\n \n /*\n Function: round\n@@ -666,31 +666,31 @@ Return the integral value nearest to `x` rounding half-way\n cases away from zero, regardless of the current rounding direction.\n */\n pure fn round(x: float) -> float\n-    { be m_float::round(x as m_float) as float }\n+    { ret m_float::round(x as m_float) as float }\n \n /*\n Function: sin\n \n Returns the sine of an angle `x` (measured in rad)\n */\n pure fn sin(x: float) -> float\n-    { be m_float::sin(x as m_float) as float }\n+    { ret m_float::sin(x as m_float) as float }\n \n /*\n Function: sinh\n \n Returns the hyperbolic sine of an angle `x` (measured in rad)\n */\n pure fn sinh(x: float) -> float\n-    { be m_float::sinh(x as m_float) as float }\n+    { ret m_float::sinh(x as m_float) as float }\n \n /*\n Function: sqrt\n \n Returns the square root of `x`\n */\n pure fn sqrt(x: float) -> float\n-    { be m_float::sqrt(x as m_float) as float }\n+    { ret m_float::sqrt(x as m_float) as float }\n \n /*\n Function: tan\n@@ -699,7 +699,7 @@ Returns the tangent of an angle `x` (measured in rad)\n \n */\n pure fn tan(x: float) -> float\n-    { be m_float::tan(x as m_float) as float }\n+    { ret m_float::tan(x as m_float) as float }\n \n /*\n Function: tanh\n@@ -708,7 +708,7 @@ Returns the hyperbolic tangent of an angle `x` (measured in rad)\n \n */\n pure fn tanh(x: float) -> float\n-    { be m_float::tanh(x as m_float) as float }\n+    { ret m_float::tanh(x as m_float) as float }\n \n /*\n Function: trunc\n@@ -717,7 +717,7 @@ Returns the integral value nearest to but no larger in magnitude than `x`\n \n */\n pure fn trunc(x: float) -> float\n-    { be m_float::trunc(x as m_float) as float }\n+    { ret m_float::trunc(x as m_float) as float }\n \n //\n // Local Variables:"}, {"sha": "64ce2794bb44c77f270219a5e66e7311f86244ed", "filename": "src/libstd/json.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=47d27af228e574e281184a10f9a98f47ecce32ac", "patch": "@@ -34,6 +34,8 @@ tag json {\n     list(@[json]);\n     /* Variant: dict */\n     dict(map::hashmap<str,json>);\n+    /* Variant: null */\n+    null;\n }\n \n /*\n@@ -63,6 +65,7 @@ fn to_str(j: json) -> str {\n             });\n             str::concat([\"{ \", str::connect(parts, \", \"), \" }\"])\n         }\n+        null { \"null\" }\n     }\n }\n \n@@ -233,6 +236,14 @@ fn from_str_bool(s: str) -> (option::t<json>, str) {\n     }\n }\n \n+fn from_str_null(s: str) -> (option::t<json>, str) {\n+    if (str::starts_with(s, \"null\")) {\n+        (some(null), str::slice(s, 4u, str::byte_len(s)))\n+    } else {\n+        (none, s)\n+    }\n+}\n+\n fn from_str_helper(s: str) -> (option::t<json>, str) {\n     let s = str::trim_left(s);\n     if str::is_empty(s) { ret (none, s); }\n@@ -243,6 +254,7 @@ fn from_str_helper(s: str) -> (option::t<json>, str) {\n         '{' { from_str_dict(s) }\n         '0' to '9' | '-' | '+' | '.' { from_str_float(s) }\n         't' | 'f' { from_str_bool(s) }\n+        'n' { from_str_null(s) }\n         _ { ret (none, s); }\n     }\n }"}, {"sha": "458013a912c9c4d2787108c7024f78ab75b49627", "filename": "src/test/compile-fail/non-triv-cast-be.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8005f0c564311fe2a3c0a72a5f3d4482ad0947e2/src%2Ftest%2Fcompile-fail%2Fnon-triv-cast-be.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8005f0c564311fe2a3c0a72a5f3d4482ad0947e2/src%2Ftest%2Fcompile-fail%2Fnon-triv-cast-be.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-triv-cast-be.rs?ref=8005f0c564311fe2a3c0a72a5f3d4482ad0947e2", "patch": "@@ -1,17 +0,0 @@\n-// error-pattern: non-trivial cast of tail-call return value\n-import core::mtypes::*;\n-\n-fn foo_float() -> m_float { ret 0.0 as m_float; }\n-fn bar_float() -> bool { be foo_float() as bool; }\n-\n-fn foo_int() -> m_int { ret 0 as m_int; }\n-fn bar_int() -> bool { be foo_int() as bool; }\n-\n-fn foo_uint() -> m_uint { ret 0u as m_uint; }\n-fn bar_uint() -> bool { be foo_uint() as bool; }\n-\n-fn main() {\n-    assert bar_float() == 0.0;\n-    assert bar_int() == 0.0;\n-    assert bar_uint() == 0.0;\n-}\n\\ No newline at end of file"}, {"sha": "0fbb1ad283009e230bd6bae5646a7610e457f092", "filename": "src/test/run-pass/triv-cast-be.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8005f0c564311fe2a3c0a72a5f3d4482ad0947e2/src%2Ftest%2Frun-pass%2Ftriv-cast-be.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8005f0c564311fe2a3c0a72a5f3d4482ad0947e2/src%2Ftest%2Frun-pass%2Ftriv-cast-be.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftriv-cast-be.rs?ref=8005f0c564311fe2a3c0a72a5f3d4482ad0947e2", "patch": "@@ -1,28 +0,0 @@\n-import core::ctypes::*;\n-\n-import core::mtypes::m_float;\n-import core::mtypes::m_int;\n-import core::mtypes::m_uint;\n-\n-fn foo_float() -> m_float { ret 0.0 as m_float; }\n-fn bar_float() -> float { be foo_float() as float; }\n-\n-fn foo_int() -> m_int { ret 0 as m_int; }\n-fn bar_int() -> int { be foo_int() as int; }\n-\n-fn foo_uint() -> m_uint { ret 0u as m_uint; }\n-fn bar_uint() -> uint { be foo_uint() as uint; }\n-\n-fn foo_long() -> long { ret 0 as long; }\n-fn bar_long() -> int { be foo_long() as int; }\n-\n-fn foo_ulong() -> ulong { ret 0u as ulong; }\n-fn bar_ulong() -> uint { be foo_uint() as uint; }\n-\n-fn main() {\n-    assert bar_float() == 0.0;\n-    assert bar_int() == 0;\n-    assert bar_uint() == 0u;\n-    assert bar_long() == 0;\n-    assert bar_ulong() == 0u;\n-}\n\\ No newline at end of file"}, {"sha": "0880fc82c48dbbc26bf5a3aa56c441b674dbec11", "filename": "src/test/run-pass/triv-cast-const.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8005f0c564311fe2a3c0a72a5f3d4482ad0947e2/src%2Ftest%2Frun-pass%2Ftriv-cast-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8005f0c564311fe2a3c0a72a5f3d4482ad0947e2/src%2Ftest%2Frun-pass%2Ftriv-cast-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftriv-cast-const.rs?ref=8005f0c564311fe2a3c0a72a5f3d4482ad0947e2", "patch": "@@ -1,13 +0,0 @@\n-import core::mtypes::m_int;\n-\n-// This will be more interesting once there is support\n-// for consts that refer to other consts, i.e. math_f64::consts::pi as m_float\n-#[cfg(target_arch=\"x86\")]\n-const foo: m_int = 0i32 as m_int;\n-\n-#[cfg(target_arch=\"x86_64\")]\n-const foo: m_int = 0i64 as m_int;\n-\n-fn main() {\n-    assert foo == 0 as m_int;\n-}\n\\ No newline at end of file"}, {"sha": "41031b2e16a4c2a42a09d9d72add533abadae0c0", "filename": "src/test/stdtest/json.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Ftest%2Fstdtest%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Ftest%2Fstdtest%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fjson.rs?ref=47d27af228e574e281184a10f9a98f47ecce32ac", "patch": "@@ -5,6 +5,11 @@ import option;\n import std::json::*;\n import option::{none, some};\n \n+#[test]\n+fn test_from_str_null() {\n+    assert(from_str(\"null\") == some(null));\n+}\n+\n #[test]\n fn test_from_str_num() {\n     assert(from_str(\"3\") == some(num(3f)));\n@@ -31,6 +36,7 @@ fn test_from_str_bool() {\n fn test_from_str_list() {\n     assert(from_str(\"[]\") == some(list(@[])));\n     assert(from_str(\"[true]\") == some(list(@[boolean(true)])));\n+    assert(from_str(\"[null]\") == some(list(@[null])));\n     assert(from_str(\"[3, 1]\") == some(list(@[num(3f), num(1f)])));\n     assert(from_str(\"[2, [4, 1]]\") ==\n         some(list(@[num(2f), list(@[num(4f), num(1f)])])));\n@@ -44,6 +50,7 @@ fn test_from_str_list() {\n fn test_from_str_dict() {\n     assert(from_str(\"{}\") != none);\n     assert(from_str(\"{\\\"a\\\": 3}\") != none);\n+    assert(from_str(\"{\\\"a\\\": null}\") != none);\n     assert(from_str(\"{\\\"a\\\": }\") == none);\n     assert(from_str(\"{\\\"a\\\" }\") == none);\n     assert(from_str(\"{\\\"a\\\"\") == none);"}, {"sha": "227e8ad299deec0028057f012e6238df7908f56b", "filename": "src/test/stdtest/list.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Ftest%2Fstdtest%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d27af228e574e281184a10f9a98f47ecce32ac/src%2Ftest%2Fstdtest%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Flist.rs?ref=47d27af228e574e281184a10f9a98f47ecce32ac", "patch": "@@ -15,6 +15,12 @@ fn test_from_vec() {\n     assert (head(tail(tail(l))) == 2);\n }\n \n+#[test]\n+fn test_from_vec_empty() {\n+    let empty : list::list<int> = from_vec([]);\n+    assert (empty == list::nil::<int>);\n+}\n+\n #[test]\n fn test_from_vec_mut() {\n     let l = from_vec([mutable 0, 1, 2]);\n@@ -25,10 +31,11 @@ fn test_from_vec_mut() {\n \n #[test]\n fn test_foldl() {\n-    let l = from_vec([0, 1, 2, 3, 4]);\n     fn add(&&a: uint, &&b: int) -> uint { ret a + (b as uint); }\n-    let rs = list::foldl(l, 0u, add);\n-    assert (rs == 10u);\n+    let l = from_vec([0, 1, 2, 3, 4]);\n+    let empty = list::nil::<int>;\n+    assert (list::foldl(l, 0u, add) == 10u);\n+    assert (list::foldl(empty, 0u, add) == 0u);\n }\n \n #[test]\n@@ -37,26 +44,25 @@ fn test_foldl2() {\n         a - b\n     }\n     let l = from_vec([1, 2, 3, 4]);\n-    let sum = list::foldl(l, 0, sub);\n-    assert sum == -10;\n+    assert (list::foldl(l, 0, sub) == -10);\n }\n \n #[test]\n fn test_find_success() {\n-    let l = from_vec([0, 1, 2]);\n     fn match(&&i: int) -> option::t<int> {\n         ret if i == 2 { option::some(i) } else { option::none::<int> };\n     }\n-    let rs = list::find(l, match);\n-    assert (rs == option::some(2));\n+    let l = from_vec([0, 1, 2]);\n+    assert (list::find(l, match) == option::some(2));\n }\n \n #[test]\n fn test_find_fail() {\n-    let l = from_vec([0, 1, 2]);\n     fn match(&&_i: int) -> option::t<int> { ret option::none::<int>; }\n-    let rs = list::find(l, match);\n-    assert (rs == option::none::<int>);\n+    let l = from_vec([0, 1, 2]);\n+    let empty = list::nil::<int>;\n+    assert (list::find(l, match) == option::none::<int>);\n+    assert (list::find(empty, match) == option::none::<int>);\n }\n \n #[test]\n@@ -72,6 +78,8 @@ fn test_has() {\n #[test]\n fn test_len() {\n     let l = from_vec([0, 1, 2]);\n+    let empty = list::nil::<int>;\n     assert (list::len(l) == 3u);\n+    assert (list::len(empty) == 0u);\n }\n "}]}