{"sha": "29e10c91fe1d2b854b4db7a4cb3c12e3ea8dbddc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ZTEwYzkxZmUxZDJiODU0YjRkYjdhNGNiM2MxMmUzZWE4ZGJkZGM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-14T21:07:32Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-15T18:26:40Z"}, "message": "librustc: Pass through extra parameters in automatically-derived methods. r=brson", "tree": {"sha": "6b153542ee34dd80c31dd39d79b16b2182b5b7e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b153542ee34dd80c31dd39d79b16b2182b5b7e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29e10c91fe1d2b854b4db7a4cb3c12e3ea8dbddc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29e10c91fe1d2b854b4db7a4cb3c12e3ea8dbddc", "html_url": "https://github.com/rust-lang/rust/commit/29e10c91fe1d2b854b4db7a4cb3c12e3ea8dbddc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29e10c91fe1d2b854b4db7a4cb3c12e3ea8dbddc/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7c04d152b92f137cd452ea45dcb9d2568953c86", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7c04d152b92f137cd452ea45dcb9d2568953c86", "html_url": "https://github.com/rust-lang/rust/commit/b7c04d152b92f137cd452ea45dcb9d2568953c86"}], "stats": {"total": 90, "additions": 77, "deletions": 13}, "files": [{"sha": "6b54407781c5132b30a460854fd83e5b20a89584", "filename": "src/librustc/middle/trans/deriving.rs", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/29e10c91fe1d2b854b4db7a4cb3c12e3ea8dbddc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29e10c91fe1d2b854b4db7a4cb3c12e3ea8dbddc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs?ref=29e10c91fe1d2b854b4db7a4cb3c12e3ea8dbddc", "patch": "@@ -1,7 +1,7 @@\n // Translation of automatically-derived trait implementations. This handles\n // enums and structs only; other types cannot be automatically derived.\n \n-use lib::llvm::llvm;\n+use lib::llvm::llvm::{LLVMCountParams, LLVMGetParam};\n use middle::trans::base::{GEP_enum, finish_fn, get_insn_ctxt, get_item_val};\n use middle::trans::base::{new_fn_ctxt, sub_block, top_scope_block};\n use middle::trans::build::{AddCase, Br, CondBr, GEPi, Load, PointerCast};\n@@ -11,6 +11,7 @@ use middle::trans::callee::{ArgVals, Callee, DontAutorefArg, Method};\n use middle::trans::callee::{MethodData};\n use middle::trans::common;\n use middle::trans::common::{C_bool, C_int, T_ptr, block, crate_ctxt};\n+use middle::trans::common::{fn_ctxt};\n use middle::trans::expr::SaveIn;\n use middle::trans::type_of::type_of;\n use middle::ty::DerivedFieldInfo;\n@@ -21,6 +22,10 @@ use syntax::ast_map::path;\n use syntax::ast_util;\n use syntax::ast_util::local_def;\n \n+use core::dvec::DVec;\n+use core::dvec;\n+use core::libc::c_uint;\n+\n /// The kind of deriving method this is.\n enum DerivingKind {\n     BoolKind,   // fn f(&self, other: &other) -> bool\n@@ -93,6 +98,23 @@ pub fn trans_deriving_impl(ccx: @crate_ctxt,\n     }\n }\n \n+fn get_extra_params(llfn: ValueRef, kind: DerivingKind) -> ~[ValueRef] {\n+    let n_params = LLVMCountParams(llfn) as uint;\n+\n+    let initial_extra_param;\n+    match kind {\n+        BoolKind => initial_extra_param = 3,\n+        UnitKind => initial_extra_param = 2,\n+    }\n+\n+    let extra_params = DVec();\n+    for uint::range(initial_extra_param, n_params) |i| {\n+        extra_params.push(LLVMGetParam(llfn, i as c_uint));\n+    }\n+\n+    return dvec::unwrap(move extra_params);\n+}\n+\n fn trans_deriving_struct_method(ccx: @crate_ctxt,\n                                 llfn: ValueRef,\n                                 impl_did: def_id,\n@@ -104,14 +126,16 @@ fn trans_deriving_struct_method(ccx: @crate_ctxt,\n     let lltop = top_bcx.llbb;\n     let mut bcx = top_bcx;\n \n+    let llextraparams = get_extra_params(llfn, kind);\n+\n     let llselfty = type_of(ccx, self_ty);\n     let llselfval = PointerCast(bcx, fcx.llenv, T_ptr(llselfty));\n \n     // If there is an \"other\" value, then get it. The \"other\" value is the\n     // value we're comparing against in the case of Eq and Ord.\n     let llotherval_opt;\n     match kind {\n-        BoolKind => llotherval_opt = Some(llvm::LLVMGetParam(llfn, 2)),\n+        BoolKind => llotherval_opt = Some(LLVMGetParam(llfn, 2)),\n         UnitKind => llotherval_opt = None\n     }\n \n@@ -136,8 +160,12 @@ fn trans_deriving_struct_method(ccx: @crate_ctxt,\n             |llotherval| GEPi(bcx, *llotherval, [0, 0, i]));\n \n         let self_ty = struct_field_tys[i].mt.ty;\n-        bcx = call_substructure_method(bcx, derived_method_info, self_ty,\n-                                       llselfval, llotherval_opt);\n+        bcx = call_substructure_method(bcx,\n+                                       derived_method_info,\n+                                       self_ty,\n+                                       llselfval,\n+                                       llotherval_opt,\n+                                       llextraparams);\n \n         // If this derived method is of boolean kind, return immediately if\n         // the call to the substructure method returned false.\n@@ -176,13 +204,15 @@ fn trans_deriving_enum_method(ccx: @crate_ctxt,\n     let lltop = top_bcx.llbb;\n     let mut bcx = top_bcx;\n \n+    let llextraparams = get_extra_params(llfn, kind);\n+\n     let llselfty = type_of(ccx, self_ty);\n     let llselfval = PointerCast(bcx, fcx.llenv, T_ptr(llselfty));\n \n     let llotherval_opt;\n     match kind {\n         UnitKind => llotherval_opt = None,\n-        BoolKind => llotherval_opt = Some(llvm::LLVMGetParam(llfn, 2))\n+        BoolKind => llotherval_opt = Some(LLVMGetParam(llfn, 2))\n     }\n \n     let enum_id, enum_substs, enum_variant_infos;\n@@ -260,7 +290,8 @@ fn trans_deriving_enum_method(ccx: @crate_ctxt,\n                                                      derived_method_info,\n                                                      self_ty,\n                                                      llselfval,\n-                                                     llotherval_opt);\n+                                                     llotherval_opt,\n+                                                     llextraparams);\n \n                 // If this is a boolean-kind deriving method, then return\n                 // immediately if the call to the substructure returned false.\n@@ -339,7 +370,8 @@ fn call_substructure_method(bcx: block,\n                             derived_field_info: &DerivedFieldInfo,\n                             self_ty: ty::t,\n                             llselfval: ValueRef,\n-                            llotherval_opt: Option<ValueRef>) -> block {\n+                            llotherval_opt: Option<ValueRef>,\n+                            llextraparams: &[ValueRef]) -> block {\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n \n@@ -367,6 +399,7 @@ fn call_substructure_method(bcx: block,\n                                                         vtable_result);\n     let llfn = fn_data.llfn;\n \n+    // Create the callee.\n     let cb: &fn(block) -> Callee = |bloc| {\n         Callee {\n             bcx: bloc,\n@@ -379,18 +412,18 @@ fn call_substructure_method(bcx: block,\n         }\n     };\n \n-    let arg_values;\n-    match llotherval_opt {\n-        None => arg_values = ArgVals(~[]),\n-        Some(copy llotherval) => arg_values = ArgVals(~[llotherval])\n-    }\n+    // Build up the argument list.\n+    let llargvals = DVec();\n+    for llotherval_opt.each |llotherval| { llargvals.push(*llotherval); }\n+    for llextraparams.each |llextraparam| { llargvals.push(*llextraparam); }\n \n+    // And perform the call.\n     callee::trans_call_inner(bcx,\n                              None,\n                              fn_expr_tpbt.ty,\n                              ty::mk_bool(ccx.tcx),\n                              cb,\n-                             move arg_values,\n+                             ArgVals(dvec::unwrap(move llargvals)),\n                              SaveIn(fcx.llretptr),\n                              DontAutorefArg)\n }"}, {"sha": "23c540d9044eddf1e9483563e1a0d9b871cd7942", "filename": "src/test/run-pass/deriving-param-pass-through.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/29e10c91fe1d2b854b4db7a4cb3c12e3ea8dbddc/src%2Ftest%2Frun-pass%2Fderiving-param-pass-through.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29e10c91fe1d2b854b4db7a4cb3c12e3ea8dbddc/src%2Ftest%2Frun-pass%2Fderiving-param-pass-through.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-param-pass-through.rs?ref=29e10c91fe1d2b854b4db7a4cb3c12e3ea8dbddc", "patch": "@@ -0,0 +1,31 @@\n+trait Trait {\n+    #[derivable]\n+    fn f(x: int, y: &str);\n+}\n+\n+impl int : Trait {\n+    fn f(x: int, y: &str) {\n+        assert x == 42;\n+        assert y == \"hello\";\n+    }\n+}\n+\n+impl float : Trait {\n+    fn f(x: int, y: &str) {\n+        assert x == 42;\n+        assert y == \"hello\";\n+    }\n+}\n+\n+struct Foo {\n+    x: int,\n+    y: float\n+}\n+\n+impl Foo : Trait;\n+\n+fn main() {\n+    let a: Foo = Foo { x: 1, y: 2.0 };\n+    a.f(42, \"hello\");\n+}\n+"}]}