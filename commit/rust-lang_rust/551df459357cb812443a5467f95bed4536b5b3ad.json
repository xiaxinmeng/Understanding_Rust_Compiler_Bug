{"sha": "551df459357cb812443a5467f95bed4536b5b3ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MWRmNDU5MzU3Y2I4MTI0NDNhNTQ2N2Y5NWJlZDQ1MzZiNWIzYWQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-08-01T10:55:05Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-08-01T13:30:08Z"}, "message": "Address behaviour changing review comments", "tree": {"sha": "f37e7d4a87beb7acf13442be150b2831cb4042a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f37e7d4a87beb7acf13442be150b2831cb4042a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/551df459357cb812443a5467f95bed4536b5b3ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/551df459357cb812443a5467f95bed4536b5b3ad", "html_url": "https://github.com/rust-lang/rust/commit/551df459357cb812443a5467f95bed4536b5b3ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/551df459357cb812443a5467f95bed4536b5b3ad/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c53aa2989a2553398a1d223811222fd65fb369d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c53aa2989a2553398a1d223811222fd65fb369d7", "html_url": "https://github.com/rust-lang/rust/commit/c53aa2989a2553398a1d223811222fd65fb369d7"}], "stats": {"total": 114, "additions": 58, "deletions": 56}, "files": [{"sha": "c9bb48d27568a87fa1195374ba32b9676cbf8fa7", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/551df459357cb812443a5467f95bed4536b5b3ad/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551df459357cb812443a5467f95bed4536b5b3ad/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=551df459357cb812443a5467f95bed4536b5b3ad", "patch": "@@ -218,15 +218,6 @@ impl ScalarMaybeUndef {\n         Value::ScalarPair(self.into(), Scalar::Ptr(vtable).into())\n     }\n \n-    pub fn ptr_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n-        match self {\n-            ScalarMaybeUndef::Scalar(scalar) => {\n-                scalar.ptr_signed_offset(i, cx).map(ScalarMaybeUndef::Scalar)\n-            },\n-            ScalarMaybeUndef::Undef => Ok(ScalarMaybeUndef::Undef)\n-        }\n-    }\n-\n     pub fn ptr_offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => {\n@@ -235,15 +226,6 @@ impl ScalarMaybeUndef {\n             ScalarMaybeUndef::Undef => Ok(ScalarMaybeUndef::Undef)\n         }\n     }\n-\n-    pub fn ptr_wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n-        match self {\n-            ScalarMaybeUndef::Scalar(scalar) => {\n-                ScalarMaybeUndef::Scalar(scalar.ptr_wrapping_signed_offset(i, cx))\n-            },\n-            ScalarMaybeUndef::Undef => ScalarMaybeUndef::Undef\n-        }\n-    }\n }\n \n impl<'tcx> Scalar {"}, {"sha": "b28858b0cf0157d3459a762d3890153b1b594e62", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/551df459357cb812443a5467f95bed4536b5b3ad/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551df459357cb812443a5467f95bed4536b5b3ad/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=551df459357cb812443a5467f95bed4536b5b3ad", "patch": "@@ -5,7 +5,7 @@ use rustc::hir;\n use rustc::mir::interpret::{ConstEvalErr, ScalarMaybeUndef};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, Ty, Instance};\n-use rustc::ty::layout::{self, LayoutOf, Primitive, TyLayout};\n+use rustc::ty::layout::{self, LayoutOf, Primitive, TyLayout, Size};\n use rustc::ty::subst::Subst;\n use rustc_data_structures::indexed_vec::IndexVec;\n \n@@ -76,9 +76,8 @@ pub fn eval_promoted<'a, 'mir, 'tcx>(\n pub fn value_to_const_value<'tcx>(\n     ecx: &EvalContext<'_, '_, 'tcx, CompileTimeEvaluator>,\n     val: Value,\n-    ty: Ty<'tcx>,\n+    layout: TyLayout<'tcx>,\n ) -> &'tcx ty::Const<'tcx> {\n-    let layout = ecx.layout_of(ty).unwrap();\n     match (val, &layout.abi) {\n         (Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { size: 0, ..})), _) if layout.is_zst() => {},\n         (Value::ByRef(..), _) |\n@@ -103,19 +102,19 @@ pub fn value_to_const_value<'tcx>(\n         }\n     })();\n     match val {\n-        Ok(val) => ty::Const::from_const_value(ecx.tcx.tcx, val, ty),\n-        Err(err) => {\n-            let (frames, span) = ecx.generate_stacktrace(None);\n-            let err = ConstEvalErr {\n-                span,\n-                error: err,\n-                stacktrace: frames,\n-            };\n-            err.report_as_error(\n-                ecx.tcx,\n-                \"failed to convert Value to ConstValue, this is a bug\",\n-            );\n-            span_bug!(span, \"miri error occured when converting Value to ConstValue\")\n+        Ok(val) => ty::Const::from_const_value(ecx.tcx.tcx, val, layout.ty),\n+        Err(error) => {\n+            let (stacktrace, span) = ecx.generate_stacktrace(None);\n+            let err = ConstEvalErr { span, error, stacktrace };\n+            if let Some(mut err) = err.struct_error(ecx.tcx, \"failed to convert Value to ConstValue\") {\n+                err.delay_as_bug();\n+            } else {\n+                span_bug!(span, \"failed to convert Value to ConstValue\")\n+            }\n+            let alloc = Allocation::undef(layout.size, layout.align);\n+            let alloc = ecx.tcx.intern_const_alloc(alloc);\n+            let val = ConstValue::ByRef(alloc, Size::ZERO);\n+            ty::Const::from_const_value(ecx.tcx.tcx, val, layout.ty)\n         }\n     }\n }\n@@ -455,7 +454,7 @@ pub fn const_val_field<'a, 'tcx>(\n             ),\n             _ => {},\n         }\n-        Ok(value_to_const_value(&ecx, new_value, layout.ty))\n+        Ok(value_to_const_value(&ecx, new_value, layout))\n     })();\n     result.map_err(|err| {\n         let (trace, span) = ecx.generate_stacktrace(None);\n@@ -556,7 +555,7 @@ pub fn const_eval_provider<'a, 'tcx>(\n         if tcx.is_static(def_id).is_none() && cid.promoted.is_none() {\n             val = ecx.try_read_by_ref(val, layout.ty)?;\n         }\n-        Ok(value_to_const_value(&ecx, val, layout.ty))\n+        Ok(value_to_const_value(&ecx, val, layout))\n     }).map_err(|err| {\n         let (trace, span) = ecx.generate_stacktrace(None);\n         let err = ConstEvalErr {"}, {"sha": "b4c9d15715097985d8819e35b1ece07525b11389", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/551df459357cb812443a5467f95bed4536b5b3ad/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551df459357cb812443a5467f95bed4536b5b3ad/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=551df459357cb812443a5467f95bed4536b5b3ad", "patch": "@@ -1261,7 +1261,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     },\n                     _ => false,\n                 };\n-                self.memory.write_scalar(dest, dest_align, scalar, layout.size, signed)\n+                self.memory.write_scalar(dest, dest_align, scalar, layout.size, layout.align, signed)\n             }\n             Value::ScalarPair(a_val, b_val) => {\n                 trace!(\"write_value_to_ptr valpair: {:#?}\", layout);\n@@ -1270,12 +1270,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     _ => bug!(\"write_value_to_ptr: invalid ScalarPair layout: {:#?}\", layout)\n                 };\n                 let (a_size, b_size) = (a.size(&self), b.size(&self));\n+                let (a_align, b_align) = (a.align(&self), b.align(&self));\n                 let a_ptr = dest;\n-                let b_offset = a_size.abi_align(b.align(&self));\n+                let b_offset = a_size.abi_align(b_align);\n                 let b_ptr = dest.ptr_offset(b_offset, &self)?.into();\n                 // TODO: What about signedess?\n-                self.memory.write_scalar(a_ptr, dest_align, a_val, a_size, false)?;\n-                self.memory.write_scalar(b_ptr, dest_align, b_val, b_size, false)\n+                self.memory.write_scalar(a_ptr, dest_align, a_val, a_size, a_align, false)?;\n+                self.memory.write_scalar(b_ptr, dest_align, b_val, b_size, b_align, false)\n             }\n         }\n     }\n@@ -1290,7 +1291,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     fn validate_scalar(\n         &self,\n-        value: Scalar,\n+        value: ScalarMaybeUndef,\n         size: Size,\n         scalar: &layout::Scalar,\n         path: &str,\n@@ -1299,6 +1300,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         trace!(\"validate scalar: {:#?}, {:#?}, {:#?}, {}\", value, size, scalar, ty);\n         let (lo, hi) = scalar.valid_range.clone().into_inner();\n \n+        let value = match value {\n+            ScalarMaybeUndef::Scalar(scalar) => scalar,\n+            ScalarMaybeUndef::Undef => return validation_failure!(\"undefined bytes\", path),\n+        };\n+\n         let bits = match value {\n             Scalar::Bits { bits, size: value_size } => {\n                 assert_eq!(value_size as u64, size.bytes());\n@@ -1351,13 +1357,21 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             if in_range(0..=hi) || in_range(lo..=u128::max_value()) {\n                 Ok(())\n             } else {\n-                validation_failure!(\"undefined bytes\", path)\n+                validation_failure!(\n+                    bits,\n+                    path,\n+                    format!(\"something in the range {:?} or {:?}\", ..=hi, lo..)\n+                )\n             }\n         } else {\n             if in_range(scalar.valid_range.clone()) {\n                 Ok(())\n             } else {\n-                validation_failure!(\"undefined bytes\", path)\n+                validation_failure!(\n+                    bits,\n+                    path,\n+                    format!(\"something in the range {:?}\", scalar.valid_range)\n+                )\n             }\n         }\n     }\n@@ -1387,10 +1401,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     mir::Field::new(0),\n                     layout,\n                 )?;\n-                let tag_value = self.value_to_scalar(ValTy {\n-                    value: tag_value,\n-                    ty: tag_layout.ty,\n-                })?;\n+                let tag_value = match self.follow_by_ref_value(tag_value, tag_layout.ty)? {\n+                    Value::Scalar(val) => val,\n+                    _ => bug!(\"tag must be scalar\"),\n+                };\n                 let path = format!(\"{}.TAG\", path);\n                 self.validate_scalar(tag_value, size, tag, &path, tag_layout.ty)?;\n                 let variant_index = self.read_discriminant_as_variant_index(\n@@ -1413,11 +1427,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     // expectation.\n                     layout::Abi::Scalar(ref scalar) => {\n                         let size = scalar.value.size(self);\n-                        let value = self.memory.read_scalar(ptr, ptr_align, size)?.unwrap_or_err()?;\n+                        let value = self.memory.read_scalar(ptr, ptr_align, size)?;\n                         self.validate_scalar(value, size, scalar, &path, layout.ty)?;\n                         if scalar.value == Primitive::Pointer {\n                             // ignore integer pointers, we can't reason about the final hardware\n-                            if let Scalar::Ptr(ptr) = value {\n+                            if let Scalar::Ptr(ptr) = value.unwrap_or_err()? {\n                                 let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n                                 if let Some(AllocType::Static(did)) = alloc_kind {\n                                     // statics from other crates are already checked"}, {"sha": "e251d7ec2bbf932cae77e27deedb6ad035cd922e", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/551df459357cb812443a5467f95bed4536b5b3ad/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551df459357cb812443a5467f95bed4536b5b3ad/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=551df459357cb812443a5467f95bed4536b5b3ad", "patch": "@@ -789,7 +789,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.read_scalar(ptr, ptr_align, self.pointer_size())\n     }\n \n-    pub fn write_scalar(&mut self, ptr: Scalar, ptr_align: Align, val: ScalarMaybeUndef, type_size: Size, signed: bool) -> EvalResult<'tcx> {\n+    pub fn write_scalar(\n+        &mut self,\n+        ptr: Scalar,\n+        ptr_align: Align,\n+        val: ScalarMaybeUndef,\n+        type_size: Size,\n+        type_align: Align,\n+        signed: bool,\n+    ) -> EvalResult<'tcx> {\n         let endianness = self.endianness();\n \n         let val = match val {\n@@ -818,8 +826,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         let ptr = ptr.to_ptr()?;\n \n         {\n-            let align = self.int_align(type_size);\n-            let dst = self.get_bytes_mut(ptr, type_size, ptr_align.min(align))?;\n+            let dst = self.get_bytes_mut(ptr, type_size, ptr_align.min(type_align))?;\n             if signed {\n                 write_target_int(endianness, dst, bytes as i128).unwrap();\n             } else {\n@@ -843,7 +850,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn write_ptr_sized_unsigned(&mut self, ptr: Pointer, ptr_align: Align, val: ScalarMaybeUndef) -> EvalResult<'tcx> {\n         let ptr_size = self.pointer_size();\n-        self.write_scalar(ptr.into(), ptr_align, val, ptr_size, false)\n+        self.write_scalar(ptr.into(), ptr_align, val, ptr_size, ptr_align, false)\n     }\n \n     fn int_align(&self, size: Size) -> Align {"}, {"sha": "91c2519230695a08c8b621c53b387029312a417e", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/551df459357cb812443a5467f95bed4536b5b3ad/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551df459357cb812443a5467f95bed4536b5b3ad/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=551df459357cb812443a5467f95bed4536b5b3ad", "patch": "@@ -62,13 +62,13 @@ impl<'tcx> Place {\n         let (ptr, align, _extra) = self.to_ptr_align_extra();\n         (ptr, align)\n     }\n-/*\n+\n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n         // At this point, we forget about the alignment information -- the place has been turned into a reference,\n         // and no matter where it came from, it now must be aligned.\n-        self.to_ptr_align().0.to_ptr()\n+        self.to_ptr_align().0.unwrap_or_err()?.to_ptr()\n     }\n-*/\n+\n     pub(super) fn elem_ty_and_len(\n         self,\n         ty: Ty<'tcx>,"}]}