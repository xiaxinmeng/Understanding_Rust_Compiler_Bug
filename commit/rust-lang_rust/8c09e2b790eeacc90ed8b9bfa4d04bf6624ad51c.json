{"sha": "8c09e2b790eeacc90ed8b9bfa4d04bf6624ad51c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMDllMmI3OTBlZWFjYzkwZWQ4YjliZmE0ZDA0YmY2NjI0YWQ1MWM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-08-16T16:46:29Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-08-22T08:58:01Z"}, "message": "debuginfo: Big cleanup refactoring and support for foreign_item_fn.", "tree": {"sha": "e8b63d732f8e6ddef205eb0d1123961f84834d09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8b63d732f8e6ddef205eb0d1123961f84834d09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c09e2b790eeacc90ed8b9bfa4d04bf6624ad51c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c09e2b790eeacc90ed8b9bfa4d04bf6624ad51c", "html_url": "https://github.com/rust-lang/rust/commit/8c09e2b790eeacc90ed8b9bfa4d04bf6624ad51c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c09e2b790eeacc90ed8b9bfa4d04bf6624ad51c/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f51d30d7295507d5075a61d8bf9f17be8ad3fbe9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f51d30d7295507d5075a61d8bf9f17be8ad3fbe9", "html_url": "https://github.com/rust-lang/rust/commit/f51d30d7295507d5075a61d8bf9f17be8ad3fbe9"}], "stats": {"total": 209, "additions": 101, "deletions": 108}, "files": [{"sha": "9d5d80373ab00e9e389444842a64896392b93a47", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c09e2b790eeacc90ed8b9bfa4d04bf6624ad51c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c09e2b790eeacc90ed8b9bfa4d04bf6624ad51c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8c09e2b790eeacc90ed8b9bfa4d04bf6624ad51c", "patch": "@@ -136,6 +136,13 @@ fn fcx_has_nonzero_span(fcx: &FunctionContext) -> bool {\n     }\n }\n \n+fn span_is_empty(opt_span: &Option<span>) -> bool {\n+    match *opt_span {\n+        None => true,\n+        Some(span) => *span.lo == 0 && *span.hi == 0\n+    }\n+}\n+\n struct StatRecorder<'self> {\n     ccx: @mut CrateContext,\n     name: &'self str,\n@@ -1623,6 +1630,13 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n         }\n     };\n     let uses_outptr = type_of::return_uses_outptr(ccx.tcx, substd_output_type);\n+\n+    let debug_context = if id != -1 && ccx.sess.opts.debuginfo && !span_is_empty(&sp) {\n+        Some(debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl))\n+    } else {\n+        None\n+    };\n+\n     let fcx = @mut FunctionContext {\n           llfn: llfndecl,\n           llenv: unsafe {\n@@ -1643,7 +1657,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n           span: sp,\n           path: path,\n           ccx: ccx,\n-          debug_context: None,\n+          debug_context: debug_context,\n     };\n     fcx.llenv = unsafe {\n           llvm::LLVMGetParam(llfndecl, fcx.env_arg_pos() as c_uint)\n@@ -1880,10 +1894,6 @@ pub fn trans_closure(ccx: @mut CrateContext,\n         set_fixed_stack_segment(fcx.llfn);\n     }\n \n-    if ccx.sess.opts.debuginfo && fcx_has_nonzero_span(fcx) {\n-        debuginfo::create_function_metadata(fcx);\n-    }\n-\n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n     let bcx_top = fcx.entry_bcx.unwrap();"}, {"sha": "0f9fa61c668bffae359056b9eaab76ca5539e102", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 86, "deletions": 103, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/8c09e2b790eeacc90ed8b9bfa4d04bf6624ad51c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c09e2b790eeacc90ed8b9bfa4d04bf6624ad51c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=8c09e2b790eeacc90ed8b9bfa4d04bf6624ad51c", "patch": "@@ -98,9 +98,7 @@ pub struct DebugContext {\n     priv builder: DIBuilderRef,\n     priv curr_loc: (uint, uint),\n     priv created_files: HashMap<~str, DIFile>,\n-    priv created_functions: HashMap<FunctionCacheKey, DISubprogram>,\n-    priv created_blocks: HashMap<ast::NodeId, DILexicalBlock>,\n-    priv created_types: HashMap<uint, DIType>\n+    priv created_types: HashMap<uint, DIType>,\n }\n \n impl DebugContext {\n@@ -115,29 +113,14 @@ impl DebugContext {\n             builder: builder,\n             curr_loc: (0, 0),\n             created_files: HashMap::new(),\n-            created_functions: HashMap::new(),\n-            created_blocks: HashMap::new(),\n-            created_types: HashMap::new()\n+            created_types: HashMap::new(),\n         };\n     }\n }\n \n-#[deriving(Eq,IterBytes)]\n-struct FunctionCacheKey {\n-    // Use the address of the llvm function (FunctionContext::llfn) as key for the cache. This\n-    // nicely takes care of monomorphization, where two specializations will have the same\n-    // ast::NodeId but different llvm functions (each needing its own debug description).\n-    priv llfn: ValueRef\n-}\n-\n-impl FunctionCacheKey {\n-    fn for_function_context(fcx: &FunctionContext) -> FunctionCacheKey {\n-        FunctionCacheKey { llfn: fcx.llfn }\n-    }\n-}\n-\n pub struct FunctionDebugContext {\n     priv scope_map: HashMap<ast::NodeId, DIScope>,\n+    priv fn_metadata: DISubprogram,\n     priv argument_counter: uint,\n }\n \n@@ -194,7 +177,14 @@ pub fn create_self_argument_metadata(bcx: @mut Block,\n \n     let loc = span_start(cx, span);\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let scope = create_function_metadata(bcx.fcx);\n+    let scope = bcx.fcx.debug_context.get_ref().fn_metadata;\n+\n+    let argument_index = {\n+        let counter = &mut bcx.fcx.debug_context.get_mut_ref().argument_counter;\n+        let argument_index = *counter;\n+        *counter += 1;\n+        argument_index as c_uint\n+    };\n \n     let var_metadata = do cx.sess.str_of(special_idents::self_).to_c_str().with_ref |name| {\n         unsafe {\n@@ -208,7 +198,7 @@ pub fn create_self_argument_metadata(bcx: @mut Block,\n                 type_metadata,\n                 false,\n                 0,\n-                1)\n+                argument_index)\n         }\n     };\n \n@@ -243,7 +233,7 @@ pub fn create_argument_metadata(bcx: @mut Block,\n \n     let def_map = cx.tcx.def_map;\n     let file_metadata = file_metadata(cx, filename);\n-    let scope = create_function_metadata(fcx);\n+    let scope = bcx.fcx.debug_context.get_ref().fn_metadata;//create_function_metadata(fcx);\n \n     do pat_util::pat_bindings(def_map, pattern) |_, node_id, span, path_ref| {\n \n@@ -318,59 +308,53 @@ pub fn update_source_pos(fcx: &FunctionContext,\n     set_debug_location(cx, scope, loc.line, loc.col.to_uint());\n }\n \n-/// Creates debug information for the given function.\n-///\n-/// Adds the created metadata nodes directly to the crate's IR.\n-/// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n-    let cx = fcx.ccx;\n-    let cache_key = FunctionCacheKey::for_function_context(fcx);\n-\n-    match dbg_cx(cx).created_functions.find_copy(&cache_key) {\n-        Some(fn_metadata) => {\n-            assert!(fcx.debug_context.is_some());\n-            return fn_metadata;\n-        }\n-        None => { /* fallthrough */}\n-    }\n+pub fn create_function_debug_context(cx: &mut CrateContext,\n+                                     fn_ast_id: ast::NodeId,\n+                                     param_substs: Option<@param_substs>,\n+                                     llfn: ValueRef) -> ~FunctionDebugContext {\n+    assert!(fn_ast_id != -1);\n \n     let empty_generics = ast::Generics { lifetimes: opt_vec::Empty, ty_params: opt_vec::Empty };\n \n-    let fnitem = cx.tcx.items.get_copy(&fcx.id);\n-    let (ident, fn_decl, generics, span) = match fnitem {\n+    let fnitem = cx.tcx.items.get_copy(&fn_ast_id);\n+    let (ident, fn_decl, generics, top_level_block, span) = match fnitem {\n         ast_map::node_item(ref item, _) => {\n             match item.node {\n-                ast::item_fn(ref fn_decl, _, _, ref generics, _) => {\n-                    (item.ident, fn_decl, generics, item.span)\n+                ast::item_fn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n+                    (item.ident, fn_decl, generics, Some(top_level_block), item.span)\n+                }\n+                _ => {\n+                    cx.sess.span_bug(item.span,\n+                        \"create_function_debug_context: item bound to non-function\");\n                 }\n-                _ => fcx.ccx.sess.span_bug(item.span,\n-                                           \"create_function_metadata: item bound to non-function\")\n             }\n         }\n         ast_map::node_method(\n             @ast::method {\n                 decl: ref fn_decl,\n                 ident: ident,\n                 generics: ref generics,\n+                body: ref top_level_block,\n                 span: span,\n                 _\n             },\n             _,\n             _) => {\n-            (ident, fn_decl, generics, span)\n+            (ident, fn_decl, generics, Some(top_level_block), span)\n         }\n         ast_map::node_expr(ref expr) => {\n             match expr.node {\n-                ast::expr_fn_block(ref fn_decl, _) => {\n+                ast::expr_fn_block(ref fn_decl, ref top_level_block) => {\n                     let name = gensym_name(\"fn\");\n                     (name, fn_decl,\n                         // This is not quite right. It should actually inherit the generics of the\n                         // enclosing function.\n                         &empty_generics,\n+                        Some(top_level_block),\n                         expr.span)\n                 }\n-                _ => fcx.ccx.sess.span_bug(expr.span,\n-                        \"create_function_metadata: expected an expr_fn_block here\")\n+                _ => cx.sess.span_bug(expr.span,\n+                        \"create_function_debug_context: expected an expr_fn_block here\")\n             }\n         }\n         ast_map::node_trait_method(\n@@ -379,34 +363,43 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n                     decl: ref fn_decl,\n                     ident: ident,\n                     generics: ref generics,\n+                    body: ref top_level_block,\n                     span: span,\n                     _\n                 }),\n             _,\n             _) => {\n-            (ident, fn_decl, generics, span)\n+            (ident, fn_decl, generics, Some(top_level_block), span)\n+        }\n+        ast_map::node_foreign_item(@ast::foreign_item {\n+                ident: ident,\n+                node: ast::foreign_item_fn(ref fn_decl, ref generics),\n+                span: span,\n+                _\n+            },\n+            _,\n+            _,\n+            _) => {\n+            (ident, fn_decl, generics, None, span)\n         }\n-        _ => fcx.ccx.sess.bug(fmt!(\"create_function_metadata: unexpected sort of node: %?\", fnitem))\n+        _ => cx.sess.bug(fmt!(\"create_function_debug_context: unexpected sort of node: %?\", fnitem))\n     };\n \n-    debug!(\"create_function_metadata: %s, %s\",\n-           cx.sess.str_of(ident),\n-           cx.sess.codemap.span_to_str(span));\n-\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n     let function_type_metadata = unsafe {\n-        let fn_signature = get_function_signature(fcx, fn_decl);\n+        let fn_signature = get_function_signature(cx, fn_ast_id, fn_decl, param_substs);\n         llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n     };\n \n     // get_template_parameters() will append a `<...>` clause to the function name if necessary.\n     let mut function_name = cx.sess.str_of(ident).to_owned();\n-    let template_parameters = get_template_parameters(fcx,\n-                                                      generics,\n-                                                      file_metadata,\n-                                                      &mut function_name);\n+    let template_parameters = if cx.sess.opts.extra_debuginfo {\n+        get_template_parameters(cx, generics, param_substs, file_metadata, &mut function_name)\n+    } else {\n+        ptr::null()\n+    };\n \n     let fn_metadata = do function_name.to_c_str().with_ref |function_name| {\n         unsafe {\n@@ -423,46 +416,29 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n                 loc.line as c_uint,\n                 FlagPrototyped as c_uint,\n                 cx.sess.opts.optimize != session::No,\n-                fcx.llfn,\n+                llfn,\n                 template_parameters,\n                 ptr::null())\n         }\n     };\n \n-    dbg_cx(cx).created_functions.insert(cache_key, fn_metadata);\n-\n     // Initialize fn debug context (including scope map)\n-    {\n-        assert!(fcx.debug_context.is_none());\n-\n-        let mut fn_debug_context = ~FunctionDebugContext {\n-            scope_map: HashMap::new(),\n-            argument_counter: if fcx.llself.is_some() { 2 } else { 1 }\n-        };\n-\n-        let entry_block_id = fcx.entry_bcx.get_ref().node_info.get_ref().id;\n-        let entry_block = cx.tcx.items.get(&entry_block_id);\n-\n-        match *entry_block {\n-            ast_map::node_block(ref block) => {\n-                let scope_map = &mut fn_debug_context.scope_map;\n-                let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n-\n-                populate_scope_map(cx, arg_pats, block, fn_metadata, scope_map);\n-            }\n-            _ => cx.sess.span_bug(span,\n-                    fmt!(\"debuginfo::create_function_metadata() - \\\n-                         FunctionContext::entry_bcx::node_info points to wrong type of ast_map \\\n-                         entry. Expected: ast_map::node_block, actual: %?\", *entry_block))\n-        }\n+    let mut fn_debug_context = ~FunctionDebugContext {\n+        scope_map: HashMap::new(),\n+        fn_metadata: fn_metadata,\n+        argument_counter: 1,\n+    };\n \n-        fcx.debug_context = Some(fn_debug_context);\n-    }\n+    let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n+    populate_scope_map(cx, arg_pats, top_level_block, fn_metadata, &mut fn_debug_context.scope_map);\n \n-    return fn_metadata;\n+    return fn_debug_context;\n \n-    fn get_function_signature(fcx: &FunctionContext, fn_decl: &ast::fn_decl) -> DIArray {\n-        let cx = fcx.ccx;\n+    fn get_function_signature(cx: &mut CrateContext,\n+                              fn_ast_id: ast::NodeId,\n+                              fn_decl: &ast::fn_decl,\n+                              param_substs: Option<@param_substs>) -> DIArray {\n+        //let cx = fcx.ccx;\n \n         if !cx.sess.opts.extra_debuginfo {\n             return create_DIArray(DIB(cx), []);\n@@ -476,8 +452,8 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n                 signature.push(ptr::null());\n             }\n             _ => {\n-                let return_type = ty::node_id_to_type(cx.tcx, fcx.id);\n-                let return_type = match fcx.param_substs {\n+                let return_type = ty::node_id_to_type(cx.tcx, fn_ast_id);\n+                let return_type = match param_substs {\n                     None => return_type,\n                     Some(substs) => {\n                         ty::subst_tps(cx.tcx, substs.tys, substs.self_ty, return_type)\n@@ -491,7 +467,7 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n         // arguments types\n         for arg in fn_decl.inputs.iter() {\n             let arg_type = ty::node_id_to_type(cx.tcx, arg.pat.id);\n-            let arg_type = match fcx.param_substs {\n+            let arg_type = match param_substs {\n                 None => arg_type,\n                 Some(substs) => {\n                     ty::subst_tps(cx.tcx, substs.tys, substs.self_ty, arg_type)\n@@ -504,14 +480,13 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n         return create_DIArray(DIB(cx), signature);\n     }\n \n-    fn get_template_parameters(fcx: &FunctionContext,\n+    fn get_template_parameters(cx: &mut CrateContext,\n                                generics: &ast::Generics,\n+                               param_substs: Option<@param_substs>,\n                                file_metadata: DIFile,\n                                name_to_append_suffix_to: &mut ~str)\n                             -> DIArray {\n-        let cx = fcx.ccx;\n-\n-        let self_type = match fcx.param_substs {\n+        let self_type = match param_substs {\n             Some(@param_substs{ self_ty: self_type, _ }) => self_type,\n             _ => None\n         };\n@@ -561,7 +536,7 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n         }\n \n         // Handle other generic parameters\n-        let actual_types = match fcx.param_substs {\n+        let actual_types = match param_substs {\n             Some(@param_substs { tys: ref types, _ }) => types,\n             None => {\n                 return create_DIArray(DIB(cx), template_params);\n@@ -604,7 +579,6 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n \n \n \n-\n //=-------------------------------------------------------------------------------------------------\n // Module-Internal debug info creation functions\n //=-------------------------------------------------------------------------------------------------\n@@ -1424,7 +1398,11 @@ fn type_metadata(cx: &mut CrateContext,\n         ty::ty_tup(ref elements) => {\n             tuple_metadata(cx, t, *elements, span)\n         },\n-        _ => cx.sess.bug(\"debuginfo: unexpected type in type_metadata\")\n+        ty::ty_opaque_box => {\n+            cx.sess.span_note(span, \"debuginfo for ty_opaque_box NYI\");\n+            unimplemented_type_metadata(cx, t)\n+        }\n+        _ => cx.sess.bug(fmt!(\"debuginfo: unexpected type in type_metadata: %?\", sty))\n     };\n \n     dbg_cx(cx).created_types.insert(type_id, type_metadata);\n@@ -1498,7 +1476,7 @@ fn assert_fcx_has_span(fcx: &FunctionContext) {\n // shadowing.\n fn populate_scope_map(cx: &mut CrateContext,\n                       arg_pats: &[@ast::pat],\n-                      fn_entry_block: &ast::Block,\n+                      fn_entry_block: Option<&ast::Block>,\n                       fn_metadata: DISubprogram,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n     let def_map = cx.tcx.def_map;\n@@ -1519,7 +1497,10 @@ fn populate_scope_map(cx: &mut CrateContext,\n         }\n     }\n \n-    walk_block(cx, fn_entry_block, &mut scope_stack, scope_map);\n+    for &fn_entry_block in fn_entry_block.iter() {\n+        walk_block(cx, fn_entry_block, &mut scope_stack, scope_map);\n+    }\n+\n \n     // local helper functions for walking the AST.\n \n@@ -1898,7 +1879,9 @@ fn populate_scope_map(cx: &mut CrateContext,\n                     do with_new_scope(cx, arm_span, scope_stack, scope_map) |cx,\n                                                                              scope_stack,\n                                                                              scope_map| {\n-                        walk_pattern(cx, arm_ref.pats[0], scope_stack, scope_map);\n+                        for &pat in arm_ref.pats.iter() {\n+                            walk_pattern(cx, pat, scope_stack, scope_map);\n+                        }\n \n                         for &@ref guard_exp in arm_ref.guard.iter() {\n                             walk_expr(cx, guard_exp, scope_stack, scope_map)"}]}