{"sha": "11a0594a1d94aa6ce39692e9dc46059a0d7c4d08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExYTA1OTRhMWQ5NGFhNmNlMzk2OTJlOWRjNDYwNTlhMGQ3YzRkMDg=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-11-18T09:35:41Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-11-18T09:35:41Z"}, "message": "address comments", "tree": {"sha": "0c8a3dc1b99b9de9f15411b253f20d6433cfb3f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c8a3dc1b99b9de9f15411b253f20d6433cfb3f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11a0594a1d94aa6ce39692e9dc46059a0d7c4d08", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYLsttAAoJEFbW7qD8Z6xGPoMP/3LVOCnYoUsdwMNvHZeMN8pJ\nR90jda2vPGN41tJQf/a6etMWg8uvVuCEa3MMcqVIBy62G0Mu9qaJppyWZi3rPYtM\nBXq2RGVunEmFC0oVO2voqlGZRlc78+VxsJyB88fK23Kl6CMjVatDPtudJH5tJZFZ\nqnqZUFggcog9pYKYOupcf7tauazlDshyM9fYm9xeYT12ZWWJ/yWrVksZ8gB+oe3R\nsjvbRLoK8k+I6alsKSYJiGTlzuNhrB4WnjbT635QColv87VBIaw62HoZ9pA+Hv8N\nI1j/THOLLUYQz4KwTCmkK0flSgMmyrt22LITg6jPOYBIL6eVxB65EQv841e2x1js\nG7fnJspsSnJzmqYr+Kq8Zb2JhxAqWdcwgMzgmi2g21swSiGDIQ+I7Zz832S33rHX\n6QKJAslkXkVvAwa3E5tPs9q4JS48s3FSG2WIr9fGZko79zwtoctgS8o+NwLug53R\nB/6bcaH0RtIhvx3oOsMQ+R254iSDM3hjezkl//hCq3CPWHK/8AGvngNwWyZxv7T5\nLHcYrX/im6ye7xPLs7CdTDTk4XVxhjYqFbTZdJXkmxhvoLy69MT1TMLA4MPdDANL\nPHVGs4QA4Rbc84Pb1JkTjbUvQXlaGBorNlK8iYAJP3KeArNjLkVvROrkAl7vGRD2\n+iVcFir1bSQDro4K1hql\n=HRlG\n-----END PGP SIGNATURE-----", "payload": "tree 0c8a3dc1b99b9de9f15411b253f20d6433cfb3f9\nparent 51ff9fdaf684c89c12ac5bf41980a53eed44ee2d\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1479461741 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1479461741 +0100\n\naddress comments"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11a0594a1d94aa6ce39692e9dc46059a0d7c4d08", "html_url": "https://github.com/rust-lang/rust/commit/11a0594a1d94aa6ce39692e9dc46059a0d7c4d08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11a0594a1d94aa6ce39692e9dc46059a0d7c4d08/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51ff9fdaf684c89c12ac5bf41980a53eed44ee2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d", "html_url": "https://github.com/rust-lang/rust/commit/51ff9fdaf684c89c12ac5bf41980a53eed44ee2d"}], "stats": {"total": 44, "additions": 24, "deletions": 20}, "files": [{"sha": "8f3d06f8301fb98b83f0b7af258d0f4a02dbb94b", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11a0594a1d94aa6ce39692e9dc46059a0d7c4d08/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a0594a1d94aa6ce39692e9dc46059a0d7c4d08/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=11a0594a1d94aa6ce39692e9dc46059a0d7c4d08", "patch": "@@ -389,12 +389,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             StackPopCleanup::Goto(target) => self.goto_block(target),\n             StackPopCleanup::None => {},\n         }\n-        // check that all locals have been deallocated through StorageDead\n+        // deallocate all locals that are backed by an allocation\n         for (i, local) in frame.locals.into_iter().enumerate() {\n             if let Some(Value::ByRef(ptr)) = local {\n                 trace!(\"deallocating local {}: {:?}\", i + 1, ptr);\n                 self.memory.dump(ptr.alloc_id);\n                 match self.memory.deallocate(ptr) {\n+                    // Any frozen memory means that it belongs to a constant or something referenced\n+                    // by a constant. We could alternatively check whether the alloc_id is frozen\n+                    // before calling deallocate, but this is much simpler and is probably the\n+                    // rare case.\n                     Ok(()) | Err(EvalError::DeallocatedFrozenMemory) => {},\n                     other => return other,\n                 }"}, {"sha": "960e397fd04d06fdde6318f59648d215ae9bdfbf", "filename": "src/memory.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/11a0594a1d94aa6ce39692e9dc46059a0d7c4d08/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a0594a1d94aa6ce39692e9dc46059a0d7c4d08/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=11a0594a1d94aa6ce39692e9dc46059a0d7c4d08", "patch": "@@ -1,7 +1,7 @@\n use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian, self};\n use std::collections::Bound::{Included, Excluded};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n-use std::{fmt, iter, ptr};\n+use std::{fmt, iter, ptr, mem};\n \n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, BareFnTy, ClosureTy, ClosureSubsts, TyCtxt};\n@@ -452,25 +452,25 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n /// Reading and writing\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn freeze(&mut self, alloc_id: AllocId) -> EvalResult<'tcx, ()> {\n-        // FIXME: the comment is wrong and do we really still need this check?\n-        // It's not possible to freeze the zero-sized allocation, because it doesn't exist.\n-        if alloc_id != ZST_ALLOC_ID {\n-            // do not use `self.get_mut(alloc_id)` here, because we might have already frozen a\n-            // sub-element or have circular pointers (e.g. `Rc`-cycles)\n-            let allocs: Vec<_> = match self.alloc_map.get_mut(&alloc_id) {\n-                Some(ref mut alloc) if !alloc.immutable => {\n-                    alloc.immutable = true;\n-                    alloc.relocations.values().cloned().collect()\n-                },\n-                None if alloc_id == NEVER_ALLOC_ID || alloc_id == ZST_ALLOC_ID => Vec::new(),\n-                None if !self.functions.contains_key(&alloc_id) => return Err(EvalError::DanglingPointerDeref),\n-                _ => Vec::new(),\n-            };\n-            // recurse into inner allocations\n-            for alloc in allocs {\n-                self.freeze(alloc)?;\n-            }\n+        // do not use `self.get_mut(alloc_id)` here, because we might have already frozen a\n+        // sub-element or have circular pointers (e.g. `Rc`-cycles)\n+        let relocations = match self.alloc_map.get_mut(&alloc_id) {\n+            Some(ref mut alloc) if !alloc.immutable => {\n+                alloc.immutable = true;\n+                // take out the relocations vector to free the borrow on self, so we can call\n+                // freeze recursively\n+                mem::replace(&mut alloc.relocations, Default::default())\n+            },\n+            None if alloc_id == NEVER_ALLOC_ID || alloc_id == ZST_ALLOC_ID => return Ok(()),\n+            None if !self.functions.contains_key(&alloc_id) => return Err(EvalError::DanglingPointerDeref),\n+            _ => return Ok(()),\n+        };\n+        // recurse into inner allocations\n+        for &alloc in relocations.values() {\n+            self.freeze(alloc)?;\n         }\n+        // put back the relocations\n+        self.alloc_map.get_mut(&alloc_id).expect(\"checked above\").relocations = relocations;\n         Ok(())\n     }\n "}]}