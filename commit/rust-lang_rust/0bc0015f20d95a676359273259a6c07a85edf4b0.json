{"sha": "0bc0015f20d95a676359273259a6c07a85edf4b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYzAwMTVmMjBkOTVhNjc2MzU5MjczMjU5YTZjMDdhODVlZGY0YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-14T03:49:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-14T03:49:25Z"}, "message": "Auto merge of #57381 - estebank:if-else-308, r=nikomatsakis\n\nTweak output of type mismatch between \"then\" and `else` `if` arms\n\n```\nerror[E0308]: if and else have incompatible types\n  --> $DIR/if-else-type-mismatch.rs:5:9\n   |\nLL |       let _ = if true {\n   |  _____________-\nLL | |         42i32\n   | |         ----- expected because of this\nLL | |     } else {\nLL | |         42u32\n   | |         ^^^^^ expected i32, found u32\nLL | |     };\n   | |_____- if and else have incompatible types\n   |\n   = note: expected type `i32`\n              found type `u32`\n\nerror[E0308]: if and else have incompatible types\n  --> file.rs:2:38\n   |\nLL |     let _ = if false { 3u8; } else { 3u8 };\n   |                        ----          ^^^ expected (), found u8\n   |                        |  |\n   |                        |  help: consider removing this semicolon\n   |                        expected because of this\n   |\n   = note: expected type `()`\n              found type `u8`\n\nerror[E0308]: if and else have incompatible types\n  --> file.rs:3:37\n   |\nLL |     let _ = if false { 3u8 } else { 3u8; };\n   |                        ---          ^^^-\n   |                        |            |  |\n   |                        |            |  help: consider removing this semicolon\n   |                        |            expected u8, found ()\n   |                        expected because of this\n   |\n   = note: expected type `u8`\n              found type `()`\n\nerror[E0308]: if and else have incompatible types\n  --> file.rs:4:37\n   |\nLL |     let _ = if false { 3i8 } else { 3u8 };\n   |                        ---          ^^^ expected i8, found u8\n   |                        |\n   |                        expected because of this\n   |\n   = note: expected type `i8`\n              found type `u8`\n```\n\nFix #57348.", "tree": {"sha": "877564443acf0b35bc4cc3cdb73ccc46fda35e27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/877564443acf0b35bc4cc3cdb73ccc46fda35e27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bc0015f20d95a676359273259a6c07a85edf4b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bc0015f20d95a676359273259a6c07a85edf4b0", "html_url": "https://github.com/rust-lang/rust/commit/0bc0015f20d95a676359273259a6c07a85edf4b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bc0015f20d95a676359273259a6c07a85edf4b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a16e1a781de15f276d558f542ee40b45a0eab143", "url": "https://api.github.com/repos/rust-lang/rust/commits/a16e1a781de15f276d558f542ee40b45a0eab143", "html_url": "https://github.com/rust-lang/rust/commit/a16e1a781de15f276d558f542ee40b45a0eab143"}, {"sha": "9567544902e1a6cca1b10333b6fc929e50ec1fba", "url": "https://api.github.com/repos/rust-lang/rust/commits/9567544902e1a6cca1b10333b6fc929e50ec1fba", "html_url": "https://github.com/rust-lang/rust/commit/9567544902e1a6cca1b10333b6fc929e50ec1fba"}], "stats": {"total": 359, "additions": 331, "deletions": 28}, "files": [{"sha": "2995b25308d4c9f455565cf6278f92fa3e3fd988", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0bc0015f20d95a676359273259a6c07a85edf4b0", "patch": "@@ -511,6 +511,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             },\n+            ObligationCauseCode::IfExpression { then, outer, semicolon } => {\n+                err.span_label(then, \"expected because of this\");\n+                outer.map(|sp| err.span_label(sp, \"if and else have incompatible types\"));\n+                if let Some(sp) = semicolon {\n+                    err.span_suggestion_short_with_applicability(\n+                        sp,\n+                        \"consider removing this semicolon\",\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n             _ => (),\n         }\n     }\n@@ -1460,7 +1472,7 @@ impl<'tcx> ObligationCause<'tcx> {\n                 }\n                 _ => \"match arms have incompatible types\",\n             }),\n-            IfExpression => Error0308(\"if and else have incompatible types\"),\n+            IfExpression { .. } => Error0308(\"if and else have incompatible types\"),\n             IfExpressionWithNoElse => Error0317(\"if may be missing an else clause\"),\n             MainFunctionType => Error0580(\"main function has wrong type\"),\n             StartFunctionType => Error0308(\"start function has wrong type\"),\n@@ -1488,7 +1500,7 @@ impl<'tcx> ObligationCause<'tcx> {\n                 hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have compatible types\",\n                 _ => \"match arms have compatible types\",\n             },\n-            IfExpression => \"if and else have compatible types\",\n+            IfExpression { .. } => \"if and else have compatible types\",\n             IfExpressionWithNoElse => \"if missing an else returns ()\",\n             MainFunctionType => \"`main` function has the correct type\",\n             StartFunctionType => \"`start` function has the correct type\","}, {"sha": "367a7eacdfcaf50dd4e61a592f163f65a79e82ad", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=0bc0015f20d95a676359273259a6c07a85edf4b0", "patch": "@@ -1445,7 +1445,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ObligationCauseCode::ExprAssignable |\n             ObligationCauseCode::MatchExpressionArm { .. } |\n             ObligationCauseCode::MatchExpressionArmPattern { .. } |\n-            ObligationCauseCode::IfExpression |\n+            ObligationCauseCode::IfExpression { .. } |\n             ObligationCauseCode::IfExpressionWithNoElse |\n             ObligationCauseCode::MainFunctionType |\n             ObligationCauseCode::StartFunctionType |"}, {"sha": "68383bef37a6a90d4f40cc93c43182ea7b40df94", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=0bc0015f20d95a676359273259a6c07a85edf4b0", "patch": "@@ -229,7 +229,11 @@ pub enum ObligationCauseCode<'tcx> {\n     MatchExpressionArmPattern { span: Span, ty: Ty<'tcx> },\n \n     /// Computing common supertype in an if expression\n-    IfExpression,\n+    IfExpression {\n+        then: Span,\n+        outer: Option<Span>,\n+        semicolon: Option<Span>,\n+    },\n \n     /// Computing common supertype of an if expression with no else counter-part\n     IfExpressionWithNoElse,"}, {"sha": "2f5df022218fe3fd4e71c6d0ec0f230f2785b5d5", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=0bc0015f20d95a676359273259a6c07a85edf4b0", "patch": "@@ -520,7 +520,11 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::MatchExpressionArmPattern { span, ty } => {\n                 tcx.lift(&ty).map(|ty| super::MatchExpressionArmPattern { span, ty })\n             }\n-            super::IfExpression => Some(super::IfExpression),\n+            super::IfExpression { then, outer, semicolon } => Some(super::IfExpression {\n+                then,\n+                outer,\n+                semicolon,\n+            }),\n             super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n             super::MainFunctionType => Some(super::MainFunctionType),\n             super::StartFunctionType => Some(super::StartFunctionType),"}, {"sha": "1b07385d4d1f4e95da1d63627bddfddcda2e6f56", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 117, "deletions": 16, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0bc0015f20d95a676359273259a6c07a85edf4b0", "patch": "@@ -3366,13 +3366,103 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let coerce_to_ty = expected.coercion_target_type(self, sp);\n         let mut coerce: DynamicCoerceMany = CoerceMany::new(coerce_to_ty);\n \n-        let if_cause = self.cause(sp, ObligationCauseCode::IfExpression);\n-        coerce.coerce(self, &if_cause, then_expr, then_ty);\n+        coerce.coerce(self, &self.misc(sp), then_expr, then_ty);\n \n         if let Some(else_expr) = opt_else_expr {\n             let else_ty = self.check_expr_with_expectation(else_expr, expected);\n             let else_diverges = self.diverges.get();\n \n+            let mut outer_sp = if self.tcx.sess.source_map().is_multiline(sp) {\n+                // The `if`/`else` isn't in one line in the output, include some context to make it\n+                // clear it is an if/else expression:\n+                // ```\n+                // LL |      let x = if true {\n+                //    | _____________-\n+                // LL ||         10i32\n+                //    ||         ----- expected because of this\n+                // LL ||     } else {\n+                // LL ||         10u32\n+                //    ||         ^^^^^ expected i32, found u32\n+                // LL ||     };\n+                //    ||_____- if and else have incompatible types\n+                // ```\n+                Some(sp)\n+            } else {\n+                // The entire expression is in one line, only point at the arms\n+                // ```\n+                // LL |     let x = if true { 10i32 } else { 10u32 };\n+                //    |                       -----          ^^^^^ expected i32, found u32\n+                //    |                       |\n+                //    |                       expected because of this\n+                // ```\n+                None\n+            };\n+            let mut remove_semicolon = None;\n+            let error_sp = if let ExprKind::Block(block, _) = &else_expr.node {\n+                if let Some(expr) = &block.expr {\n+                    expr.span\n+                } else if let Some(stmt) = block.stmts.last() {\n+                    // possibly incorrect trailing `;` in the else arm\n+                    remove_semicolon = self.could_remove_semicolon(block, then_ty);\n+                    stmt.span\n+                } else {  // empty block, point at its entirety\n+                    // Avoid overlapping spans that aren't as readable:\n+                    // ```\n+                    // 2 |        let x = if true {\n+                    //   |   _____________-\n+                    // 3 |  |         3\n+                    //   |  |         - expected because of this\n+                    // 4 |  |     } else {\n+                    //   |  |____________^\n+                    // 5 | ||\n+                    // 6 | ||     };\n+                    //   | ||     ^\n+                    //   | ||_____|\n+                    //   | |______if and else have incompatible types\n+                    //   |        expected integer, found ()\n+                    // ```\n+                    // by not pointing at the entire expression:\n+                    // ```\n+                    // 2 |       let x = if true {\n+                    //   |               ------- if and else have incompatible types\n+                    // 3 |           3\n+                    //   |           - expected because of this\n+                    // 4 |       } else {\n+                    //   |  ____________^\n+                    // 5 | |\n+                    // 6 | |     };\n+                    //   | |_____^ expected integer, found ()\n+                    // ```\n+                    if outer_sp.is_some() {\n+                        outer_sp = Some(self.tcx.sess.source_map().def_span(sp));\n+                    }\n+                    else_expr.span\n+                }\n+            } else { // shouldn't happen unless the parser has done something weird\n+                else_expr.span\n+            };\n+            let then_sp = if let ExprKind::Block(block, _) = &then_expr.node {\n+                if let Some(expr) = &block.expr {\n+                    expr.span\n+                } else if let Some(stmt) = block.stmts.last() {\n+                    // possibly incorrect trailing `;` in the else arm\n+                    remove_semicolon = remove_semicolon.or(\n+                        self.could_remove_semicolon(block, else_ty));\n+                    stmt.span\n+                } else {  // empty block, point at its entirety\n+                    outer_sp = None;  // same as in `error_sp`, cleanup output\n+                    then_expr.span\n+                }\n+            } else {  // shouldn't happen unless the parser has done something weird\n+                then_expr.span\n+            };\n+\n+            let if_cause = self.cause(error_sp, ObligationCauseCode::IfExpression {\n+                then: then_sp,\n+                outer: outer_sp,\n+                semicolon: remove_semicolon,\n+            });\n+\n             coerce.coerce(self, &if_cause, else_expr, else_ty);\n \n             // We won't diverge unless both branches do (or the condition does).\n@@ -5144,7 +5234,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-\n     /// A common error is to add an extra semicolon:\n     ///\n     /// ```\n@@ -5156,31 +5245,43 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// This routine checks if the final statement in a block is an\n     /// expression with an explicit semicolon whose type is compatible\n     /// with `expected_ty`. If so, it suggests removing the semicolon.\n-    fn consider_hint_about_removing_semicolon(&self,\n-                                              blk: &'gcx hir::Block,\n-                                              expected_ty: Ty<'tcx>,\n-                                              err: &mut DiagnosticBuilder) {\n+    fn consider_hint_about_removing_semicolon(\n+        &self,\n+        blk: &'gcx hir::Block,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut DiagnosticBuilder,\n+    ) {\n+        if let Some(span_semi) = self.could_remove_semicolon(blk, expected_ty) {\n+            err.span_suggestion_with_applicability(\n+                span_semi,\n+                \"consider removing this semicolon\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n+    fn could_remove_semicolon(\n+        &self,\n+        blk: &'gcx hir::Block,\n+        expected_ty: Ty<'tcx>,\n+    ) -> Option<Span> {\n         // Be helpful when the user wrote `{... expr;}` and\n         // taking the `;` off is enough to fix the error.\n         let last_stmt = match blk.stmts.last() {\n             Some(s) => s,\n-            None => return,\n+            None => return None,\n         };\n         let last_expr = match last_stmt.node {\n             hir::StmtKind::Semi(ref e, _) => e,\n-            _ => return,\n+            _ => return None,\n         };\n         let last_expr_ty = self.node_ty(last_expr.hir_id);\n         if self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err() {\n-            return;\n+            return None;\n         }\n         let original_span = original_sp(last_stmt.span, blk.span);\n-        let span_semi = original_span.with_lo(original_span.hi() - BytePos(1));\n-        err.span_suggestion_with_applicability(\n-            span_semi,\n-            \"consider removing this semicolon\",\n-            String::new(),\n-            Applicability::MachineApplicable);\n+        Some(original_span.with_lo(original_span.hi() - BytePos(1)))\n     }\n \n     // Instantiates the given path, which must refer to an item with the given"}, {"sha": "583c3d0b765cf2397296896b38d69930b2d1b2d0", "filename": "src/test/ui/if-else-type-mismatch.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Ftest%2Fui%2Fif-else-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Ftest%2Fui%2Fif-else-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-else-type-mismatch.rs?ref=0bc0015f20d95a676359273259a6c07a85edf4b0", "patch": "@@ -0,0 +1,46 @@\n+fn main() {\n+    let _ = if true {\n+        1i32\n+    } else {\n+        2u32\n+    };\n+    //~^^ ERROR if and else have incompatible types\n+    let _ = if true { 42i32 } else { 42u32 };\n+    //~^ ERROR if and else have incompatible types\n+    let _ = if true {\n+        3u32;\n+    } else {\n+        4u32\n+    };\n+    //~^^ ERROR if and else have incompatible types\n+    let _ = if true {\n+        5u32\n+    } else {\n+        6u32;\n+    };\n+    //~^^ ERROR if and else have incompatible types\n+    let _ = if true {\n+        7i32;\n+    } else {\n+        8u32\n+    };\n+    //~^^ ERROR if and else have incompatible types\n+    let _ = if true {\n+        9i32\n+    } else {\n+        10u32;\n+    };\n+    //~^^ ERROR if and else have incompatible types\n+    let _ = if true {\n+\n+    } else {\n+        11u32\n+    };\n+    //~^^ ERROR if and else have incompatible types\n+    let _ = if true {\n+        12i32\n+    } else {\n+\n+    };\n+    //~^^^ ERROR if and else have incompatible types\n+}"}, {"sha": "b418c961189d6b59f2f2ad6b38506d472b895dff", "filename": "src/test/ui/if-else-type-mismatch.stderr", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Ftest%2Fui%2Fif-else-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Ftest%2Fui%2Fif-else-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif-else-type-mismatch.stderr?ref=0bc0015f20d95a676359273259a6c07a85edf4b0", "patch": "@@ -0,0 +1,130 @@\n+error[E0308]: if and else have incompatible types\n+  --> $DIR/if-else-type-mismatch.rs:5:9\n+   |\n+LL |       let _ = if true {\n+   |  _____________-\n+LL | |         1i32\n+   | |         ---- expected because of this\n+LL | |     } else {\n+LL | |         2u32\n+   | |         ^^^^ expected i32, found u32\n+LL | |     };\n+   | |_____- if and else have incompatible types\n+   |\n+   = note: expected type `i32`\n+              found type `u32`\n+\n+error[E0308]: if and else have incompatible types\n+  --> $DIR/if-else-type-mismatch.rs:8:38\n+   |\n+LL |     let _ = if true { 42i32 } else { 42u32 };\n+   |                       -----          ^^^^^ expected i32, found u32\n+   |                       |\n+   |                       expected because of this\n+   |\n+   = note: expected type `i32`\n+              found type `u32`\n+\n+error[E0308]: if and else have incompatible types\n+  --> $DIR/if-else-type-mismatch.rs:13:9\n+   |\n+LL |       let _ = if true {\n+   |  _____________-\n+LL | |         3u32;\n+   | |         -----\n+   | |         |   |\n+   | |         |   help: consider removing this semicolon\n+   | |         expected because of this\n+LL | |     } else {\n+LL | |         4u32\n+   | |         ^^^^ expected (), found u32\n+LL | |     };\n+   | |_____- if and else have incompatible types\n+   |\n+   = note: expected type `()`\n+              found type `u32`\n+\n+error[E0308]: if and else have incompatible types\n+  --> $DIR/if-else-type-mismatch.rs:19:9\n+   |\n+LL |       let _ = if true {\n+   |  _____________-\n+LL | |         5u32\n+   | |         ---- expected because of this\n+LL | |     } else {\n+LL | |         6u32;\n+   | |         ^^^^-\n+   | |         |   |\n+   | |         |   help: consider removing this semicolon\n+   | |         expected u32, found ()\n+LL | |     };\n+   | |_____- if and else have incompatible types\n+   |\n+   = note: expected type `u32`\n+              found type `()`\n+\n+error[E0308]: if and else have incompatible types\n+  --> $DIR/if-else-type-mismatch.rs:25:9\n+   |\n+LL |       let _ = if true {\n+   |  _____________-\n+LL | |         7i32;\n+   | |         ----- expected because of this\n+LL | |     } else {\n+LL | |         8u32\n+   | |         ^^^^ expected (), found u32\n+LL | |     };\n+   | |_____- if and else have incompatible types\n+   |\n+   = note: expected type `()`\n+              found type `u32`\n+\n+error[E0308]: if and else have incompatible types\n+  --> $DIR/if-else-type-mismatch.rs:31:9\n+   |\n+LL |       let _ = if true {\n+   |  _____________-\n+LL | |         9i32\n+   | |         ---- expected because of this\n+LL | |     } else {\n+LL | |         10u32;\n+   | |         ^^^^^^ expected i32, found ()\n+LL | |     };\n+   | |_____- if and else have incompatible types\n+   |\n+   = note: expected type `i32`\n+              found type `()`\n+\n+error[E0308]: if and else have incompatible types\n+  --> $DIR/if-else-type-mismatch.rs:37:9\n+   |\n+LL |       let _ = if true {\n+   |  _____________________-\n+LL | |\n+LL | |     } else {\n+   | |_____- expected because of this\n+LL |           11u32\n+   |           ^^^^^ expected (), found u32\n+   |\n+   = note: expected type `()`\n+              found type `u32`\n+\n+error[E0308]: if and else have incompatible types\n+  --> $DIR/if-else-type-mismatch.rs:42:12\n+   |\n+LL |       let _ = if true {\n+   |               ------- if and else have incompatible types\n+LL |           12i32\n+   |           ----- expected because of this\n+LL |       } else {\n+   |  ____________^\n+LL | |\n+LL | |     };\n+   | |_____^ expected i32, found ()\n+   |\n+   = note: expected type `i32`\n+              found type `()`\n+\n+error: aborting due to 8 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "74b925f72fff02248f7542a72a2beabce559e4cb", "filename": "src/test/ui/if/if-branch-types.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Ftest%2Fui%2Fif%2Fif-branch-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Ftest%2Fui%2Fif%2Fif-branch-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fif-branch-types.stderr?ref=0bc0015f20d95a676359273259a6c07a85edf4b0", "patch": "@@ -1,8 +1,10 @@\n error[E0308]: if and else have incompatible types\n-  --> $DIR/if-branch-types.rs:2:13\n+  --> $DIR/if-branch-types.rs:2:38\n    |\n LL |     let x = if true { 10i32 } else { 10u32 };\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected i32, found u32\n+   |                       -----          ^^^^^ expected i32, found u32\n+   |                       |\n+   |                       expected because of this\n    |\n    = note: expected type `i32`\n               found type `u32`"}, {"sha": "60e70ddcd97019d20a1aa0c2cab400f6da47db52", "filename": "src/test/ui/regions/region-invariant-static-error-reporting.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Ftest%2Fui%2Fregions%2Fregion-invariant-static-error-reporting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Ftest%2Fui%2Fregions%2Fregion-invariant-static-error-reporting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-invariant-static-error-reporting.stderr?ref=0bc0015f20d95a676359273259a6c07a85edf4b0", "patch": "@@ -1,13 +1,15 @@\n error[E0308]: if and else have incompatible types\n-  --> $DIR/region-invariant-static-error-reporting.rs:14:15\n+  --> $DIR/region-invariant-static-error-reporting.rs:17:9\n    |\n LL |       let bad = if x.is_some() {\n-   |  _______________^\n+   |  _______________-\n LL | |         x.unwrap()\n+   | |         ---------- expected because of this\n LL | |     } else {\n LL | |         mk_static()\n+   | |         ^^^^^^^^^^^ lifetime mismatch\n LL | |     };\n-   | |_____^ lifetime mismatch\n+   | |_____- if and else have incompatible types\n    |\n    = note: expected type `Invariant<'a>`\n               found type `Invariant<'static>`"}, {"sha": "87809d212d79dd4e6b31b19c053b30ed43c80541", "filename": "src/test/ui/str/str-array-assignment.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Ftest%2Fui%2Fstr%2Fstr-array-assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bc0015f20d95a676359273259a6c07a85edf4b0/src%2Ftest%2Fui%2Fstr%2Fstr-array-assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-array-assignment.stderr?ref=0bc0015f20d95a676359273259a6c07a85edf4b0", "patch": "@@ -1,8 +1,10 @@\n error[E0308]: if and else have incompatible types\n-  --> $DIR/str-array-assignment.rs:3:11\n+  --> $DIR/str-array-assignment.rs:3:37\n    |\n LL |   let t = if true { s[..2] } else { s };\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected str, found &str\n+   |                     ------          ^ expected str, found &str\n+   |                     |\n+   |                     expected because of this\n    |\n    = note: expected type `str`\n               found type `&str`"}]}