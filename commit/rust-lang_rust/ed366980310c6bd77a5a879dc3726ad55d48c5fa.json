{"sha": "ed366980310c6bd77a5a879dc3726ad55d48c5fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMzY2OTgwMzEwYzZiZDc3YTVhODc5ZGMzNzI2YWQ1NWQ0OGM1ZmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-02T15:29:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-13T05:29:10Z"}, "message": "compute region values using SCCs not iterative flow\n\nThe strategy is this:\n\n- we compute SCCs once all outlives constraints are known\n- we allocate a set of values **per region** for storing liveness\n- we allocate a set of values **per SCC** for storing the final values\n- when we add a liveness constraint to the region R, we also add it\n  to the final value of the SCC to which R belongs\n- then we can apply the constraints by just walking the DAG for the\n  SCCs and union'ing the children (which have their liveness\n  constraints within)\n\nThere are a few intermediate refactorings that I really ought to have\nbroken out into their own commits:\n\n- reverse the constraint graph so that `R1: R2` means `R1 -> R2` and\n  not `R2 -> R1`. This fits better with the SCC computation and new\n  style of inference (`->` now means \"take value from\" and not \"push\n  value into\")\n  - this does affect some of the UI tests, since they traverse the\n    graph, but mostly the artificial ones and they don't necessarily\n    seem worse\n- put some things (constraint set, etc) into `Rc`. This lets us root\n  them to permit mutation and iteration. It also guarantees they don't\n  change, which is critical to the correctness of the algorithm.\n- Generalize various helpers that previously operated only on points\n  to work on any sort of region element.", "tree": {"sha": "0a0364f9bc5afc869ce3b95224bd9fb91febe0b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a0364f9bc5afc869ce3b95224bd9fb91febe0b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed366980310c6bd77a5a879dc3726ad55d48c5fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed366980310c6bd77a5a879dc3726ad55d48c5fa", "html_url": "https://github.com/rust-lang/rust/commit/ed366980310c6bd77a5a879dc3726ad55d48c5fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed366980310c6bd77a5a879dc3726ad55d48c5fa/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "862c0dd85153aea02ae284a87cb88e9c0de715a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/862c0dd85153aea02ae284a87cb88e9c0de715a2", "html_url": "https://github.com/rust-lang/rust/commit/862c0dd85153aea02ae284a87cb88e9c0de715a2"}], "stats": {"total": 554, "additions": 340, "deletions": 214}, "files": [{"sha": "e7a84e4779754c3404d62e27ad2219101125d4d1", "filename": "src/librustc_data_structures/graph/scc/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs?ref=ed366980310c6bd77a5a879dc3726ad55d48c5fa", "patch": "@@ -54,6 +54,11 @@ impl<N: Idx, S: Idx> Sccs<N, S> {\n         self.scc_data.len()\n     }\n \n+    /// Returns the number of SCCs in the graph.\n+    pub fn all_sccs(&self) -> impl Iterator<Item = S> {\n+        (0 .. self.scc_data.len()).map(S::new)\n+    }\n+\n     /// Returns the SCC to which a node `r` belongs.\n     pub fn scc(&self, r: N) -> S {\n         self.scc_indices[r]"}, {"sha": "68484888477c843400c60a734ce48fe1bd972ed4", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=ed366980310c6bd77a5a879dc3726ad55d48c5fa", "patch": "@@ -210,7 +210,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n         for (region, location) in liveness_set {\n             debug!(\"generate: {:#?} is live at {:#?}\", region, location);\n             let region_vid = regioncx.to_region_vid(region);\n-            regioncx.add_live_point(region_vid, *location);\n+            regioncx.add_live_element(region_vid, *location);\n         }\n \n         if let Some(all_facts) = all_facts {\n@@ -242,7 +242,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n             .tcx\n             .for_each_free_region(&live_ty, |live_region| {\n                 let vid = live_region.to_region_vid();\n-                self.regioncx.add_live_point(vid, location);\n+                self.regioncx.add_live_element(vid, location);\n             });\n     }\n }"}, {"sha": "45ed37a90efce39e0dab88b36e4e63182a09818e", "filename": "src/librustc_mir/borrow_check/nll/constraints/graph.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs?ref=ed366980310c6bd77a5a879dc3726ad55d48c5fa", "patch": "@@ -0,0 +1,134 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::nll::constraints::{ConstraintIndex, ConstraintSet};\n+use rustc::ty::RegionVid;\n+use rustc_data_structures::graph;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+\n+crate struct ConstraintGraph {\n+    first_constraints: IndexVec<RegionVid, Option<ConstraintIndex>>,\n+    next_constraints: IndexVec<ConstraintIndex, Option<ConstraintIndex>>,\n+}\n+\n+impl ConstraintGraph {\n+    /// Create a \"dependency graph\" where each region constraint `R1:\n+    /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n+    /// construct SCCs for region inference but also for error\n+    /// reporting.\n+    crate fn new(set: &ConstraintSet, num_region_vars: usize) -> Self {\n+        let mut first_constraints = IndexVec::from_elem_n(None, num_region_vars);\n+        let mut next_constraints = IndexVec::from_elem(None, &set.constraints);\n+\n+        for (idx, constraint) in set.constraints.iter_enumerated().rev() {\n+            let mut head = &mut first_constraints[constraint.sup];\n+            let mut next = &mut next_constraints[idx];\n+            debug_assert!(next.is_none());\n+            *next = *head;\n+            *head = Some(idx);\n+        }\n+\n+        Self {\n+            first_constraints,\n+            next_constraints,\n+        }\n+    }\n+\n+    /// Given a region `R`, iterate over all constraints `R: R1`.\n+    crate fn outgoing_edges(&self, region_sup: RegionVid) -> Edges<'_> {\n+        let first = self.first_constraints[region_sup];\n+        Edges {\n+            graph: self,\n+            pointer: first,\n+        }\n+    }\n+}\n+\n+crate struct Edges<'s> {\n+    graph: &'s ConstraintGraph,\n+    pointer: Option<ConstraintIndex>,\n+}\n+\n+impl<'s> Iterator for Edges<'s> {\n+    type Item = ConstraintIndex;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let Some(p) = self.pointer {\n+            self.pointer = self.graph.next_constraints[p];\n+            Some(p)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+crate struct RegionGraph<'s> {\n+    set: &'s ConstraintSet,\n+    constraint_graph: &'s ConstraintGraph,\n+}\n+\n+impl<'s> RegionGraph<'s> {\n+    /// Create a \"dependency graph\" where each region constraint `R1:\n+    /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n+    /// construct SCCs for region inference but also for error\n+    /// reporting.\n+    crate fn new(set: &'s ConstraintSet, constraint_graph: &'s ConstraintGraph) -> Self {\n+        Self {\n+            set,\n+            constraint_graph,\n+        }\n+    }\n+\n+    /// Given a region `R`, iterate over all regions `R1` such that\n+    /// there exists a constraint `R: R1`.\n+    crate fn sub_regions(&self, region_sup: RegionVid) -> Successors<'_> {\n+        Successors {\n+            set: self.set,\n+            edges: self.constraint_graph.outgoing_edges(region_sup),\n+        }\n+    }\n+}\n+\n+crate struct Successors<'s> {\n+    set: &'s ConstraintSet,\n+    edges: Edges<'s>,\n+}\n+\n+impl<'s> Iterator for Successors<'s> {\n+    type Item = RegionVid;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.edges.next().map(|c| self.set[c].sub)\n+    }\n+}\n+\n+impl<'s> graph::DirectedGraph for RegionGraph<'s> {\n+    type Node = RegionVid;\n+}\n+\n+impl<'s> graph::WithNumNodes for RegionGraph<'s> {\n+    fn num_nodes(&self) -> usize {\n+        self.constraint_graph.first_constraints.len()\n+    }\n+}\n+\n+impl<'s> graph::WithSuccessors for RegionGraph<'s> {\n+    fn successors<'graph>(\n+        &'graph self,\n+        node: Self::Node,\n+    ) -> <Self as graph::GraphSuccessors<'graph>>::Iter {\n+        self.sub_regions(node)\n+    }\n+}\n+\n+impl<'s, 'graph> graph::GraphSuccessors<'graph> for RegionGraph<'s> {\n+    type Item = RegionVid;\n+    type Iter = Successors<'graph>;\n+}"}, {"sha": "f20802c7d025c34c3e576b17d7f4caebd2a990b4", "filename": "src/librustc_mir/borrow_check/nll/constraints/mod.rs", "status": "modified", "additions": 27, "deletions": 44, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs?ref=ed366980310c6bd77a5a879dc3726ad55d48c5fa", "patch": "@@ -9,19 +9,22 @@\n // except according to those terms.\n \n use rustc::ty::RegionVid;\n+use rustc_data_structures::graph::scc::Sccs;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use borrow_check::nll::type_check::Locations;\n \n use std::fmt;\n use std::ops::Deref;\n \n+crate mod graph;\n+\n #[derive(Clone, Default)]\n crate struct ConstraintSet {\n     constraints: IndexVec<ConstraintIndex, OutlivesConstraint>,\n }\n \n impl ConstraintSet {\n-    pub fn push(&mut self, constraint: OutlivesConstraint) {\n+    crate fn push(&mut self, constraint: OutlivesConstraint) {\n         debug!(\n             \"ConstraintSet::push({:?}: {:?} @ {:?}\",\n             constraint.sup, constraint.sub, constraint.locations\n@@ -32,12 +35,33 @@ impl ConstraintSet {\n         }\n         self.constraints.push(constraint);\n     }\n+\n+    /// Constructs a graph from the constraint set; the graph makes it\n+    /// easy to find the constriants affecting a particular region\n+    /// (you should not mutate the set once this graph is\n+    /// constructed).\n+    crate fn graph(&self, num_region_vars: usize) -> graph::ConstraintGraph {\n+        graph::ConstraintGraph::new(self, num_region_vars)\n+    }\n+\n+    /// Compute cycles (SCCs) in the graph of regions. In particular,\n+    /// find all regions R1, R2 such that R1: R2 and R2: R1 and group\n+    /// them into an SCC, and find the relationships between SCCs.\n+    crate fn compute_sccs(\n+        &self,\n+        constraint_graph: &graph::ConstraintGraph,\n+    ) -> Sccs<RegionVid, ConstraintSccIndex> {\n+        let region_graph = &graph::RegionGraph::new(self, constraint_graph);\n+        Sccs::new(region_graph)\n+    }\n }\n \n impl Deref for ConstraintSet {\n     type Target = IndexVec<ConstraintIndex, OutlivesConstraint>;\n \n-    fn deref(&self) -> &Self::Target { &self.constraints }\n+    fn deref(&self) -> &Self::Target {\n+        &self.constraints\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -68,45 +92,4 @@ impl fmt::Debug for OutlivesConstraint {\n \n newtype_index!(ConstraintIndex { DEBUG_FORMAT = \"ConstraintIndex({})\" });\n \n-crate struct ConstraintGraph {\n-    first_constraints: IndexVec<RegionVid, Option<ConstraintIndex>>,\n-    next_constraints: IndexVec<ConstraintIndex, Option<ConstraintIndex>>,\n-}\n-\n-impl ConstraintGraph {\n-    /// Constraint a graph where each region constraint `R1: R2` is\n-    /// treated as an edge `R2 -> R1`. This is useful for cheaply\n-    /// finding dirty constraints.\n-    crate fn new(set: &ConstraintSet, num_region_vars: usize) -> Self {\n-        let mut first_constraints = IndexVec::from_elem_n(None, num_region_vars);\n-        let mut next_constraints = IndexVec::from_elem(None, &set.constraints);\n-\n-        for (idx, constraint) in set.constraints.iter_enumerated().rev() {\n-            let mut head = &mut first_constraints[constraint.sub];\n-            let mut next = &mut next_constraints[idx];\n-            debug_assert!(next.is_none());\n-            *next = *head;\n-            *head = Some(idx);\n-        }\n-\n-        ConstraintGraph { first_constraints, next_constraints }\n-    }\n-\n-    /// Invokes `op` with the index of any constraints of the form\n-    /// `region_sup: region_sub`.  These are the constraints that must\n-    /// be reprocessed when the value of `R1` changes. If you think of\n-    /// each constraint `R1: R2` as an edge `R2 -> R1`, then this\n-    /// gives the set of successors to R2.\n-    crate fn for_each_dependent(\n-        &self,\n-        region_sub: RegionVid,\n-        mut op: impl FnMut(ConstraintIndex),\n-    ) {\n-        let mut p = self.first_constraints[region_sub];\n-        while let Some(dep_idx) = p {\n-            op(dep_idx);\n-            p = self.next_constraints[dep_idx];\n-        }\n-    }\n-}\n-\n+newtype_index!(ConstraintSccIndex { DEBUG_FORMAT = \"ConstraintSccIndex({})\" });"}, {"sha": "9fd9d6cd97c597e193c9fe42027cdf35645f29e4", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/find_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs?ref=ed366980310c6bd77a5a879dc3726ad55d48c5fa", "patch": "@@ -57,7 +57,7 @@ impl<'cx, 'gcx, 'tcx> UseFinder<'cx, 'gcx, 'tcx> {\n \n         queue.push_back(self.start_point);\n         while let Some(p) = queue.pop_front() {\n-            if !self.regioncx.region_contains_point(self.region_vid, p) {\n+            if !self.regioncx.region_contains(self.region_vid, p) {\n                 continue;\n             }\n "}, {"sha": "c1b73fac893888f35e574edae22a167fd17fc9e7", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=ed366980310c6bd77a5a879dc3726ad55d48c5fa", "patch": "@@ -50,18 +50,10 @@ impl fmt::Display for ConstraintCategory {\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Walks the graph of constraints (where `'a: 'b` is considered\n-    /// an edge `'b -> 'a`) to find all paths from `from_region` to\n+    /// an edge `'a -> 'b`) to find all paths from `from_region` to\n     /// `to_region`. The paths are accumulated into the vector\n     /// `results`. The paths are stored as a series of\n     /// `ConstraintIndex` values -- in other words, a list of *edges*.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `from_region`\n-    /// When reporting an error, it is useful to be able to determine\n-    /// which constraints influenced the region being reported as an\n-    /// error. This function finds all of the paths from the\n-    /// constraint.\n     fn find_constraint_paths_between_regions(\n         &self,\n         from_region: RegionVid,\n@@ -97,25 +89,25 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Check if we reached the region we were looking for.\n         if target_test(current_region) {\n             if !stack.is_empty() {\n-                assert_eq!(self.constraints[stack[0]].sub, from_region);\n+                assert_eq!(self.constraints[stack[0]].sup, from_region);\n                 results.push(stack.clone());\n             }\n             return;\n         }\n \n-        self.constraint_graph.for_each_dependent(current_region, |constraint| {\n-            assert_eq!(self.constraints[constraint].sub, current_region);\n+        for constraint in self.constraint_graph.outgoing_edges(current_region) {\n+            assert_eq!(self.constraints[constraint].sup, current_region);\n             stack.push(constraint);\n             self.find_constraint_paths_between_regions_helper(\n                 from_region,\n-                self.constraints[constraint].sup,\n+                self.constraints[constraint].sub,\n                 target_test,\n                 visited,\n                 stack,\n                 results,\n             );\n             stack.pop();\n-        });\n+        }\n     }\n \n     /// This function will return true if a constraint is interesting and false if a constraint\n@@ -207,7 +199,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         // Find all paths\n-        let constraint_paths = self.find_constraint_paths_between_regions(outlived_fr, |r| r == fr);\n+        let constraint_paths = self.find_constraint_paths_between_regions(fr, |r| r == outlived_fr);\n         debug!(\"report_error: constraint_paths={:#?}\", constraint_paths);\n \n         // Find the shortest such path.\n@@ -316,7 +308,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         while changed {\n             changed = false;\n-            for constraint in &*self.constraints {\n+            for constraint in self.constraints.iter() {\n                 if let Some(n) = result_set[constraint.sup] {\n                     let m = n + 1;\n                     if result_set[constraint.sub]"}, {"sha": "369f6bd36f84603538ee34db60c3f099c5346385", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 124, "deletions": 116, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=ed366980310c6bd77a5a879dc3726ad55d48c5fa", "patch": "@@ -10,8 +10,10 @@\n \n use super::universal_regions::UniversalRegions;\n use borrow_check::nll::constraints::{\n-    ConstraintIndex, ConstraintGraph, ConstraintSet, OutlivesConstraint\n+    ConstraintIndex, ConstraintSccIndex, ConstraintSet, OutlivesConstraint,\n };\n+use borrow_check::nll::constraints::graph::ConstraintGraph;\n+use borrow_check::nll::region_infer::values::ToElementIndex;\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n@@ -25,8 +27,9 @@ use rustc::mir::{\n };\n use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common;\n-use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::graph::scc::Sccs;\n+use rustc_data_structures::indexed_set::{IdxSet, IdxSetBuf};\n+use rustc_data_structures::indexed_vec::IndexVec;\n \n use std::rc::Rc;\n \n@@ -55,22 +58,29 @@ pub struct RegionInferenceContext<'tcx> {\n     /// the entire CFG and `end(R)`.\n     liveness_constraints: RegionValues<RegionVid>,\n \n-    /// The final inferred values of the inference variables; `None`\n-    /// until `solve` is invoked.\n-    inferred_values: Option<RegionValues<RegionVid>>,\n+    /// The outlives constraints computed by the type-check.\n+    constraints: Rc<ConstraintSet>,\n \n-    /// The constraints we have accumulated and used during solving.\n-    constraints: ConstraintSet,\n+    /// The constraint-set, but in graph form, making it easy to traverse\n+    /// the constraints adjacent to a particular region. Used to construct\n+    /// the SCC (see `constraint_sccs`) and for error reporting.\n+    constraint_graph: Rc<ConstraintGraph>,\n \n-    /// The constraint-set, but organized by regions.\n-    constraint_graph: ConstraintGraph,\n+    /// The SCC computed from `constraints` and\n+    /// `constraint_graph`. Used to compute the values of each region.\n+    constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n+\n+    /// The final inferred values of the region variables; we compute\n+    /// one value per SCC. To get the value for any given *region*,\n+    /// you first find which scc it is a part of.\n+    scc_values: RegionValues<ConstraintSccIndex>,\n \n     /// Type constraints that we check after solving.\n     type_tests: Vec<TypeTest<'tcx>>,\n \n     /// Information about the universally quantified regions in scope\n     /// on this function and their (known) relations to one another.\n-    universal_regions: UniversalRegions<'tcx>,\n+    universal_regions: Rc<UniversalRegions<'tcx>>,\n }\n \n struct RegionDefinition<'tcx> {\n@@ -201,6 +211,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         outlives_constraints: ConstraintSet,\n         type_tests: Vec<TypeTest<'tcx>>,\n     ) -> Self {\n+        let universal_regions = Rc::new(universal_regions);\n         let num_region_variables = var_infos.len();\n         let num_universal_regions = universal_regions.len();\n \n@@ -212,15 +223,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .map(|info| RegionDefinition::new(info.origin))\n             .collect();\n \n-        let constraint_graph = ConstraintGraph::new(&outlives_constraints, definitions.len());\n+        let constraints = Rc::new(outlives_constraints); // freeze constraints\n+        let constraint_graph = Rc::new(constraints.graph(definitions.len()));\n+        let constraint_sccs = Rc::new(constraints.compute_sccs(&constraint_graph));\n+\n+        let scc_values = RegionValues::new(elements, constraint_sccs.num_sccs());\n \n         let mut result = Self {\n             definitions,\n             elements: elements.clone(),\n             liveness_constraints: RegionValues::new(elements, num_region_variables),\n-            inferred_values: None,\n-            constraints: outlives_constraints,\n+            constraints,\n+            constraint_sccs,\n             constraint_graph,\n+            scc_values,\n             type_tests,\n             universal_regions,\n         };\n@@ -262,7 +278,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         // For each universally quantified region X:\n-        for variable in self.universal_regions.universal_regions() {\n+        let elements = self.elements.clone();\n+        let universal_regions = self.universal_regions.clone();\n+        for variable in universal_regions.universal_regions() {\n             // These should be free-region variables.\n             assert!(match self.definitions[variable].origin {\n                 RegionVariableOrigin::NLL(NLLRegionVariableOrigin::FreeRegion) => true,\n@@ -272,12 +290,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.definitions[variable].is_universal = true;\n \n             // Add all nodes in the CFG to liveness constraints\n-            for point_index in self.elements.all_point_indices() {\n-                self.liveness_constraints.add_element(variable, point_index);\n+            for point_index in elements.all_point_indices() {\n+                self.add_live_element(variable, point_index);\n             }\n \n             // Add `end(X)` into the set for X.\n-            self.liveness_constraints.add_element(variable, variable);\n+            self.add_live_element(variable, variable);\n         }\n     }\n \n@@ -297,37 +315,38 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Returns true if the region `r` contains the point `p`.\n     ///\n     /// Panics if called before `solve()` executes,\n-    pub fn region_contains_point<R>(&self, r: R, p: Location) -> bool\n-    where\n-        R: ToRegionVid,\n-    {\n-        let inferred_values = self\n-            .inferred_values\n-            .as_ref()\n-            .expect(\"region values not yet inferred\");\n-        inferred_values.contains(r.to_region_vid(), p)\n+    crate fn region_contains(&self, r: impl ToRegionVid, p: impl ToElementIndex) -> bool {\n+        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        self.scc_values.contains(scc, p)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n     crate fn region_value_str(&self, r: RegionVid) -> String {\n-        let inferred_values = self\n-            .inferred_values\n-            .as_ref()\n-            .expect(\"region values not yet inferred\");\n-\n-        inferred_values.region_value_str(r)\n+        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        self.scc_values.region_value_str(scc)\n     }\n \n     /// Indicates that the region variable `v` is live at the point `point`.\n     ///\n     /// Returns `true` if this constraint is new and `false` is the\n     /// constraint was already present.\n-    pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location) -> bool {\n-        debug!(\"add_live_point({:?}, {:?})\", v, point);\n-        assert!(self.inferred_values.is_none(), \"values already inferred\");\n+    pub(super) fn add_live_element(\n+        &mut self,\n+        v: RegionVid,\n+        elem: impl ToElementIndex,\n+    ) -> bool {\n+        debug!(\"add_live_element({:?}, {:?})\", v, elem);\n \n-        let element = self.elements.index(point);\n-        self.liveness_constraints.add_element(v, element)\n+        // Add to the liveness values for `v`...\n+        if self.liveness_constraints.add_element(v, elem) {\n+            // ...but also add to the SCC in which `v` appears.\n+            let scc = self.constraint_sccs.scc(v);\n+            self.scc_values.add_element(scc, elem);\n+\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     /// Perform region inference and report errors if we see any\n@@ -352,8 +371,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n-        assert!(self.inferred_values.is_none(), \"values already inferred\");\n-\n         self.propagate_constraints(mir);\n \n         // If this is a closure, we can propagate unsatisfied\n@@ -388,56 +405,62 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n-    fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n-        assert!(self.inferred_values.is_none());\n-        let inferred_values = self.compute_region_values(mir);\n-        self.inferred_values = Some(inferred_values);\n-    }\n+    fn propagate_constraints(&mut self, _mir: &Mir<'tcx>) {\n+        debug!(\"propagate_constraints()\");\n \n-    fn compute_region_values(&self, _mir: &Mir<'tcx>) -> RegionValues<RegionVid> {\n-        debug!(\"compute_region_values()\");\n-        debug!(\"compute_region_values: constraints={:#?}\", {\n+        debug!(\"propagate_constraints: constraints={:#?}\", {\n             let mut constraints: Vec<_> = self.constraints.iter().collect();\n             constraints.sort();\n             constraints\n         });\n \n-        // The initial values for each region are derived from the liveness\n-        // constraints we have accumulated.\n-        let mut inferred_values = self.liveness_constraints.clone();\n-\n-        // Constraints that may need to be repropagated (initially all):\n-        let mut dirty_list: Vec<_> = self.constraints.indices().collect();\n-\n-        // Set to 0 for each constraint that is on the dirty list:\n-        let mut clean_bit_vec = BitVector::new(dirty_list.len());\n+        // To propagate constriants, we walk the DAG induced by the\n+        // SCC. For each SCC, we visit its successors and compute\n+        // their values, then we union all those values to get our\n+        // own.\n+        let visited = &mut IdxSetBuf::new_empty(self.constraint_sccs.num_sccs());\n+        for scc_index in self.constraint_sccs.all_sccs() {\n+            self.propagate_constraint_sccs_if_new(scc_index, visited);\n+        }\n+    }\n \n-        debug!(\"propagate_constraints: --------------------\");\n-        while let Some(constraint_idx) = dirty_list.pop() {\n-            clean_bit_vec.insert(constraint_idx.index());\n+    #[inline]\n+    fn propagate_constraint_sccs_if_new(\n+        &mut self,\n+        scc_a: ConstraintSccIndex,\n+        visited: &mut IdxSet<ConstraintSccIndex>,\n+    ) {\n+        if visited.add(&scc_a) {\n+            self.propagate_constraint_sccs_new(scc_a, visited);\n+        }\n+    }\n \n-            let constraint = &self.constraints[constraint_idx];\n-            debug!(\"propagate_constraints: constraint={:?}\", constraint);\n+    fn propagate_constraint_sccs_new(\n+        &mut self,\n+        scc_a: ConstraintSccIndex,\n+        visited: &mut IdxSet<ConstraintSccIndex>,\n+    ) {\n+        let constraint_sccs = self.constraint_sccs.clone();\n \n-            if inferred_values.add_region(constraint.sup, constraint.sub) {\n-                debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n-                debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n+        // Walk each SCC `B` such that `A: B`...\n+        for &scc_b in constraint_sccs.successors(scc_a) {\n+            debug!(\n+                \"propagate_constraint_sccs: scc_a = {:?} scc_b = {:?}\",\n+                scc_a, scc_b\n+            );\n \n-                // The region of `constraint.sup` changed, so find all\n-                // constraints of the form `R: constriant.sup` and\n-                // enqueue them as dirty.  We will have to reprocess\n-                // them.\n-                self.constraint_graph.for_each_dependent(constraint.sup, |dep_idx| {\n-                    if clean_bit_vec.remove(dep_idx.index()) {\n-                        dirty_list.push(dep_idx);\n-                    }\n-                });\n-            }\n+            // ...compute the value of `B`...\n+            self.propagate_constraint_sccs_if_new(scc_b, visited);\n \n-            debug!(\"\\n\");\n+            // ...and add elements from `B` into `A`.\n+            self.scc_values.add_region(scc_a, scc_b);\n         }\n \n-        inferred_values\n+        debug!(\n+            \"propagate_constraint_sccs: scc_a = {:?} has value {:?}\",\n+            scc_a,\n+            self.scc_values.region_value_str(scc_a),\n+        );\n     }\n \n     /// Once regions have been propagated, this method is used to see\n@@ -512,12 +535,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         if self.universal_regions.is_universal_region(r) {\n             return self.definitions[r].external_name;\n         } else {\n-            let inferred_values = self\n-                .inferred_values\n-                .as_ref()\n-                .expect(\"region values not yet inferred\");\n+            let r_scc = self.constraint_sccs.scc(r);\n             let upper_bound = self.universal_upper_bound(r);\n-            if inferred_values.contains(r, upper_bound) {\n+            if self.scc_values.contains(r_scc, upper_bound) {\n                 self.to_error_region(upper_bound)\n             } else {\n                 None\n@@ -552,11 +572,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // region, which ensures it can be encoded in a `ClosureOutlivesRequirement`.\n         let lower_bound_plus = self.non_local_universal_upper_bound(*lower_bound);\n         assert!(self.universal_regions.is_universal_region(lower_bound_plus));\n-        assert!(\n-            !self\n-                .universal_regions\n-                .is_local_free_region(lower_bound_plus)\n-        );\n+        assert!(!self.universal_regions\n+            .is_local_free_region(lower_bound_plus));\n \n         propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n             subject,\n@@ -584,10 +601,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<ClosureOutlivesSubject<'gcx>> {\n         let tcx = infcx.tcx;\n         let gcx = tcx.global_tcx();\n-        let inferred_values = self\n-            .inferred_values\n-            .as_ref()\n-            .expect(\"region values not yet inferred\");\n \n         debug!(\"try_promote_type_test_subject(ty = {:?})\", ty);\n \n@@ -630,7 +643,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // `'static` is not contained in `r`, we would fail to\n             // find an equivalent.\n             let upper_bound = self.non_local_universal_upper_bound(region_vid);\n-            if inferred_values.contains(region_vid, upper_bound) {\n+            if self.region_contains(region_vid, upper_bound) {\n                 tcx.mk_region(ty::ReClosureBound(upper_bound))\n             } else {\n                 // In the case of a failure, use a `ReVar`\n@@ -663,12 +676,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// except that it converts further takes the non-local upper\n     /// bound of `'y`, so that the final result is non-local.\n     fn non_local_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        let inferred_values = self.inferred_values.as_ref().unwrap();\n-\n         debug!(\n             \"non_local_universal_upper_bound(r={:?}={})\",\n             r,\n-            inferred_values.region_value_str(r)\n+            self.region_value_str(r)\n         );\n \n         let lub = self.universal_upper_bound(r);\n@@ -700,18 +711,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// - For each `end('x)` element in `'r`, compute the mutual LUB, yielding\n     ///   a result `'y`.\n     fn universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        let inferred_values = self.inferred_values.as_ref().unwrap();\n-\n         debug!(\n             \"universal_upper_bound(r={:?}={})\",\n             r,\n-            inferred_values.region_value_str(r)\n+            self.region_value_str(r)\n         );\n \n         // Find the smallest universal region that contains all other\n         // universal regions within `region`.\n         let mut lub = self.universal_regions.fr_fn_body;\n-        for ur in inferred_values.universal_regions_outlived_by(r) {\n+        let r_scc = self.constraint_sccs.scc(r);\n+        for ur in self.scc_values.universal_regions_outlived_by(r_scc) {\n             lub = self.universal_regions.postdom_upper_bound(lub, ur);\n         }\n \n@@ -756,31 +766,29 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> bool {\n         debug!(\"eval_outlives({:?}: {:?})\", sup_region, sub_region);\n \n-        let inferred_values = self\n-            .inferred_values\n-            .as_ref()\n-            .expect(\"values for regions not yet inferred\");\n-\n         debug!(\n             \"eval_outlives: sup_region's value = {:?}\",\n-            inferred_values.region_value_str(sup_region),\n+            self.region_value_str(sup_region),\n         );\n         debug!(\n             \"eval_outlives: sub_region's value = {:?}\",\n-            inferred_values.region_value_str(sub_region),\n+            self.region_value_str(sub_region),\n         );\n \n+        let sub_region_scc = self.constraint_sccs.scc(sub_region);\n+        let sup_region_scc = self.constraint_sccs.scc(sup_region);\n+\n         // Both the `sub_region` and `sup_region` consist of the union\n         // of some number of universal regions (along with the union\n         // of various points in the CFG; ignore those points for\n         // now). Therefore, the sup-region outlives the sub-region if,\n         // for each universal region R1 in the sub-region, there\n         // exists some region R2 in the sup-region that outlives R1.\n-        let universal_outlives = inferred_values\n-            .universal_regions_outlived_by(sub_region)\n+        let universal_outlives = self.scc_values\n+            .universal_regions_outlived_by(sub_region_scc)\n             .all(|r1| {\n-                inferred_values\n-                    .universal_regions_outlived_by(sup_region)\n+                self.scc_values\n+                    .universal_regions_outlived_by(sup_region_scc)\n                     .any(|r2| self.universal_regions.outlives(r2, r1))\n             });\n \n@@ -796,7 +804,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return true;\n         }\n \n-        inferred_values.contains_points(sup_region, sub_region)\n+        self.scc_values\n+            .contains_points(sup_region_scc, sub_region_scc)\n     }\n \n     /// Once regions have been propagated, this method is used to see\n@@ -825,8 +834,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) {\n         // The universal regions are always found in a prefix of the\n         // full list.\n-        let universal_definitions = self\n-            .definitions\n+        let universal_definitions = self.definitions\n             .iter_enumerated()\n             .take_while(|(_, fr_definition)| fr_definition.is_universal);\n \n@@ -860,13 +868,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n-        let inferred_values = self.inferred_values.as_ref().unwrap();\n-\n         debug!(\"check_universal_region(fr={:?})\", longer_fr);\n \n+        let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n+\n         // Find every region `o` such that `fr: o`\n         // (because `fr` includes `end(o)`).\n-        for shorter_fr in inferred_values.universal_regions_outlived_by(longer_fr) {\n+        for shorter_fr in self.scc_values.universal_regions_outlived_by(longer_fr_scc) {\n             // If it is known that `fr: o`, carry on.\n             if self.universal_regions.outlives(longer_fr, shorter_fr) {\n                 continue;"}, {"sha": "c5bfb1fc6a588addd9254223423593d56f1e6c78", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=ed366980310c6bd77a5a879dc3726ad55d48c5fa", "patch": "@@ -18,15 +18,15 @@ use std::rc::Rc;\n \n /// Maps between the various kinds of elements of a region value to\n /// the internal indices that w use.\n-pub(super) struct RegionValueElements {\n+crate struct RegionValueElements {\n     /// For each basic block, how many points are contained within?\n     statements_before_block: IndexVec<BasicBlock, usize>,\n     num_points: usize,\n     num_universal_regions: usize,\n }\n \n impl RegionValueElements {\n-    pub(super) fn new(mir: &Mir<'_>, num_universal_regions: usize) -> Self {\n+    crate fn new(mir: &Mir<'_>, num_universal_regions: usize) -> Self {\n         let mut num_points = 0;\n         let statements_before_block = mir\n             .basic_blocks()\n@@ -56,22 +56,22 @@ impl RegionValueElements {\n     }\n \n     /// Total number of element indices that exist.\n-    pub(super) fn num_elements(&self) -> usize {\n+    crate fn num_elements(&self) -> usize {\n         self.num_points + self.num_universal_regions\n     }\n \n     /// Converts an element of a region value into a `RegionElementIndex`.\n-    pub(super) fn index<T: ToElementIndex>(&self, elem: T) -> RegionElementIndex {\n+    crate fn index<T: ToElementIndex>(&self, elem: T) -> RegionElementIndex {\n         elem.to_element_index(self)\n     }\n \n     /// Iterates over the `RegionElementIndex` for all points in the CFG.\n-    pub(super) fn all_point_indices<'a>(&'a self) -> impl Iterator<Item = RegionElementIndex> + 'a {\n+    crate fn all_point_indices<'a>(&'a self) -> impl Iterator<Item = RegionElementIndex> + 'a {\n         (0..self.num_points).map(move |i| RegionElementIndex::new(i + self.num_universal_regions))\n     }\n \n     /// Converts a particular `RegionElementIndex` to the `RegionElement` it represents.\n-    pub(super) fn to_element(&self, i: RegionElementIndex) -> RegionElement {\n+    crate fn to_element(&self, i: RegionElementIndex) -> RegionElement {\n         debug!(\"to_element(i={:?})\", i);\n \n         if let Some(r) = self.to_universal_region(i) {\n@@ -114,7 +114,7 @@ impl RegionValueElements {\n     /// Converts a particular `RegionElementIndex` to a universal\n     /// region, if that is what it represents. Returns `None`\n     /// otherwise.\n-    pub(super) fn to_universal_region(&self, i: RegionElementIndex) -> Option<RegionVid> {\n+    crate fn to_universal_region(&self, i: RegionElementIndex) -> Option<RegionVid> {\n         if i.index() < self.num_universal_regions {\n             Some(RegionVid::new(i.index()))\n         } else {\n@@ -138,15 +138,15 @@ newtype_index!(RegionElementIndex { DEBUG_FORMAT = \"RegionElementIndex({})\" });\n /// An individual element in a region value -- the value of a\n /// particular region variable consists of a set of these elements.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub(super) enum RegionElement {\n+crate enum RegionElement {\n     /// A point in the control-flow graph.\n     Location(Location),\n \n     /// An in-scope, universally quantified region (e.g., a lifetime parameter).\n     UniversalRegion(RegionVid),\n }\n \n-pub(super) trait ToElementIndex: Debug + Copy {\n+crate trait ToElementIndex: Debug + Copy {\n     fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex;\n }\n \n@@ -179,7 +179,7 @@ impl ToElementIndex for RegionElementIndex {\n /// variable. The columns consist of either universal regions or\n /// points in the CFG.\n #[derive(Clone)]\n-pub(super) struct RegionValues<N: Idx> {\n+crate struct RegionValues<N: Idx> {\n     elements: Rc<RegionValueElements>,\n     matrix: SparseBitMatrix<N, RegionElementIndex>,\n }\n@@ -188,7 +188,7 @@ impl<N: Idx> RegionValues<N> {\n     /// Creates a new set of \"region values\" that tracks causal information.\n     /// Each of the regions in num_region_variables will be initialized with an\n     /// empty set of points and no causal information.\n-    pub(super) fn new(elements: &Rc<RegionValueElements>, num_region_variables: usize) -> Self {\n+    crate fn new(elements: &Rc<RegionValueElements>, num_region_variables: usize) -> Self {\n         assert!(\n             elements.num_universal_regions <= num_region_variables,\n             \"universal regions are a subset of the region variables\"\n@@ -205,27 +205,31 @@ impl<N: Idx> RegionValues<N> {\n \n     /// Adds the given element to the value for the given region. Returns true if\n     /// the element is newly added (i.e., was not already present).\n-    pub(super) fn add_element<E: ToElementIndex>(&mut self, r: N, elem: E) -> bool {\n+    crate fn add_element(\n+        &mut self,\n+        r: N,\n+        elem: impl ToElementIndex,\n+    ) -> bool {\n         let i = self.elements.index(elem);\n         debug!(\"add(r={:?}, elem={:?})\", r, elem);\n         self.matrix.add(r, i)\n     }\n \n     /// Add all elements in `r_from` to `r_to` (because e.g. `r_to:\n     /// r_from`).\n-    pub(super) fn add_region(&mut self, r_to: N, r_from: N) -> bool {\n+    crate fn add_region(&mut self, r_to: N, r_from: N) -> bool {\n         self.matrix.merge(r_from, r_to)\n     }\n \n     /// True if the region `r` contains the given element.\n-    pub(super) fn contains<E: ToElementIndex>(&self, r: N, elem: E) -> bool {\n+    crate fn contains(&self, r: N, elem: impl ToElementIndex) -> bool {\n         let i = self.elements.index(elem);\n         self.matrix.contains(r, i)\n     }\n \n     /// True if `sup_region` contains all the CFG points that\n     /// `sub_region` contains. Ignores universal regions.\n-    pub(super) fn contains_points(&self, sup_region: N, sub_region: N) -> bool {\n+    crate fn contains_points(&self, sup_region: N, sub_region: N) -> bool {\n         // This could be done faster by comparing the bitsets. But I\n         // am lazy.\n         self.element_indices_contained_in(sub_region)\n@@ -236,15 +240,15 @@ impl<N: Idx> RegionValues<N> {\n     /// Iterate over the value of the region `r`, yielding up element\n     /// indices. You may prefer `universal_regions_outlived_by` or\n     /// `elements_contained_in`.\n-    pub(super) fn element_indices_contained_in<'a>(\n+    crate fn element_indices_contained_in<'a>(\n         &'a self,\n         r: N,\n     ) -> impl Iterator<Item = RegionElementIndex> + 'a {\n         self.matrix.iter(r).map(move |i| i)\n     }\n \n     /// Returns just the universal regions that are contained in a given region's value.\n-    pub(super) fn universal_regions_outlived_by<'a>(\n+    crate fn universal_regions_outlived_by<'a>(\n         &'a self,\n         r: N,\n     ) -> impl Iterator<Item = RegionVid> + 'a {\n@@ -255,7 +259,7 @@ impl<N: Idx> RegionValues<N> {\n     }\n \n     /// Returns all the elements contained in a given region's value.\n-    pub(super) fn elements_contained_in<'a>(\n+    crate fn elements_contained_in<'a>(\n         &'a self,\n         r: N,\n     ) -> impl Iterator<Item = RegionElement> + 'a {\n@@ -264,7 +268,7 @@ impl<N: Idx> RegionValues<N> {\n     }\n \n     /// Returns a \"pretty\" string value of the region. Meant for debugging.\n-    pub(super) fn region_value_str(&self, r: N) -> String {\n+    crate fn region_value_str(&self, r: N) -> String {\n         let mut result = String::new();\n         result.push_str(\"{\");\n "}, {"sha": "9736ab797b2c14967f68ff9cbd93fad62239b6d4", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=ed366980310c6bd77a5a879dc3726ad55d48c5fa", "patch": "@@ -76,7 +76,7 @@ fn precompute_borrows_out_of_scope<'a, 'tcx>(\n     while let Some(location) = stack.pop() {\n         // If region does not contain a point at the location, then add to list and skip\n         // successor locations.\n-        if !regioncx.region_contains_point(borrow_region, location) {\n+        if !regioncx.region_contains(borrow_region, location) {\n             debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, location);\n             borrows_out_of_scope_at_location\n                 .entry(location)"}, {"sha": "39050864768ae3875f20830288e75c67f198a4b3", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs?ref=ed366980310c6bd77a5a879dc3726ad55d48c5fa", "patch": "@@ -52,9 +52,9 @@ fn supply<'a, 'b, 'c>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>, cell_c: Cell\n         cell_c,\n         |_outlives1, _outlives2, _outlives3, x, y| {\n             // Only works if 'x: 'y:\n-            let p = x.get();\n+            let p = x.get(); //~ ERROR\n             //~^ WARN not reporting region error due to nll\n-            demand_y(x, y, p) //~ ERROR\n+            demand_y(x, y, p)\n         },\n     );\n }"}, {"sha": "6588cbe8bdf26c297f93e52a44527fe69ecbaed3", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr?ref=ed366980310c6bd77a5a879dc3726ad55d48c5fa", "patch": "@@ -1,28 +1,28 @@\n warning: not reporting region error due to nll\n   --> $DIR/propagate-approximated-fail-no-postdom.rs:55:21\n    |\n-LL |             let p = x.get();\n+LL |             let p = x.get(); //~ ERROR\n    |                     ^^^^^^^\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-approximated-fail-no-postdom.rs:57:13\n+  --> $DIR/propagate-approximated-fail-no-postdom.rs:55:21\n    |\n LL |         |_outlives1, _outlives2, _outlives3, x, y| {\n    |          ----------              ---------- lifetime `'2` appears in this argument\n    |          |\n    |          lifetime `'1` appears in this argument\n-...\n-LL |             demand_y(x, y, p) //~ ERROR\n-   |             ^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+LL |             // Only works if 'x: 'y:\n+LL |             let p = x.get(); //~ ERROR\n+   |                     ^^^^^^^ argument requires that `'1` must outlive `'2`\n \n note: No external requirements\n   --> $DIR/propagate-approximated-fail-no-postdom.rs:53:9\n    |\n LL | /         |_outlives1, _outlives2, _outlives3, x, y| {\n LL | |             // Only works if 'x: 'y:\n-LL | |             let p = x.get();\n+LL | |             let p = x.get(); //~ ERROR\n LL | |             //~^ WARN not reporting region error due to nll\n-LL | |             demand_y(x, y, p) //~ ERROR\n+LL | |             demand_y(x, y, p)\n LL | |         },\n    | |_________^\n    |"}, {"sha": "8fd5e898c8d9bff140e95e3701a7118ad3d50096", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=ed366980310c6bd77a5a879dc3726ad55d48c5fa", "patch": "@@ -5,15 +5,15 @@ LL |     foo(cell, |cell_a, cell_x| {\n    |     ^^^\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:33:9\n+  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:33:20\n    |\n LL |     foo(cell, |cell_a, cell_x| {\n    |                ------  ------ lifetime `'1` appears in this argument\n    |                |\n    |                lifetime `'2` appears in this argument\n LL |         //~^ WARNING not reporting region error due to nll\n LL |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+   |                    ^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n \n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:31:15"}, {"sha": "c75b3e6670cdc018ff06ec43a3d3bf3eea0ef96e", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr?ref=ed366980310c6bd77a5a879dc3726ad55d48c5fa", "patch": "@@ -5,15 +5,15 @@ LL |         demand_y(x, y, x.get())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:9\n+  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:24\n    |\n LL |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n    |                                                ---------  - lifetime `'1` appears in this argument\n    |                                                |\n    |                                                lifetime `'2` appears in this argument\n LL |         // Only works if 'x: 'y:\n LL |         demand_y(x, y, x.get())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+   |                        ^^^^^^^ argument requires that `'1` must outlive `'2`\n \n note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:45:47"}, {"sha": "2465219ee552a809155510f9178d46559f1f5df0", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed366980310c6bd77a5a879dc3726ad55d48c5fa/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr?ref=ed366980310c6bd77a5a879dc3726ad55d48c5fa", "patch": "@@ -5,15 +5,15 @@ LL |         demand_y(x, y, x.get())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:9\n+  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:24\n    |\n LL |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n    |                                                ----------  ---------- lifetime `'2` appears in this argument\n    |                                                |\n    |                                                lifetime `'1` appears in this argument\n LL |         // Only works if 'x: 'y:\n LL |         demand_y(x, y, x.get())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+   |                        ^^^^^^^ argument requires that `'1` must outlive `'2`\n \n note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:49:47"}]}