{"sha": "63160c66cd31c6f48a4a68ff469c4bdebc8eff2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzMTYwYzY2Y2QzMWM2ZjQ4YTRhNjhmZjQ2OWM0YmRlYmM4ZWZmMmY=", "commit": {"author": {"name": "Christian Poveda", "email": "git@christianpoveda.xyz", "date": "2020-02-11T23:32:28Z"}, "committer": {"name": "Christian Poveda", "email": "git@christianpoveda.xyz", "date": "2020-02-19T22:48:15Z"}, "message": "move pthread related functions", "tree": {"sha": "37c5e417e50e3f08b3eddce3b30dcf5a5a0acf95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37c5e417e50e3f08b3eddce3b30dcf5a5a0acf95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63160c66cd31c6f48a4a68ff469c4bdebc8eff2f", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYIAB0WIQRsB8A/3NrzTlMMjT0nUl7150IKUAUCXk27LwAKCRAnUl7150IK\nUEQvAQCPM0CIDDkvjZ8Um4tqxFQq1Y1aaBm71l95a09yfDOQyAD5AfkPNSgSzuQs\nz03YvMGHcWa9kI6B+lNRIxEpIMeMrgo=\n=jRh4\n-----END PGP SIGNATURE-----", "payload": "tree 37c5e417e50e3f08b3eddce3b30dcf5a5a0acf95\nparent 8fe7543191e10145ba56f676f529e9db4664dee0\nauthor Christian Poveda <git@christianpoveda.xyz> 1581463948 -0500\ncommitter Christian Poveda <git@christianpoveda.xyz> 1582152495 -0500\n\nmove pthread related functions\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63160c66cd31c6f48a4a68ff469c4bdebc8eff2f", "html_url": "https://github.com/rust-lang/rust/commit/63160c66cd31c6f48a4a68ff469c4bdebc8eff2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63160c66cd31c6f48a4a68ff469c4bdebc8eff2f/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fe7543191e10145ba56f676f529e9db4664dee0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fe7543191e10145ba56f676f529e9db4664dee0", "html_url": "https://github.com/rust-lang/rust/commit/8fe7543191e10145ba56f676f529e9db4664dee0"}], "stats": {"total": 224, "additions": 112, "deletions": 112}, "files": [{"sha": "9ad4a6dbaf62eeaf4296eb425e4434935f0c6fef", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 111, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/63160c66cd31c6f48a4a68ff469c4bdebc8eff2f/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63160c66cd31c6f48a4a68ff469c4bdebc8eff2f/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=63160c66cd31c6f48a4a68ff469c4bdebc8eff2f", "patch": "@@ -6,7 +6,7 @@ use std::{convert::TryInto, iter};\n use rustc_hir::def_id::DefId;\n use rustc::mir;\n use rustc::ty;\n-use rustc::ty::layout::{Align, LayoutOf, Size};\n+use rustc::ty::layout::{Align, Size};\n use rustc_apfloat::Float;\n use rustc_span::symbol::sym;\n use syntax::attr;\n@@ -192,7 +192,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         dest: PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let tcx = &{ this.tcx.tcx };\n \n         match link_name {\n             \"malloc\" => {\n@@ -487,115 +486,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n \n-            // Hook pthread calls that go to the thread-local storage memory subsystem.\n-            \"pthread_key_create\" => {\n-                let key_place = this.deref_operand(args[0])?;\n-\n-                // Extract the function type out of the signature (that seems easier than constructing it ourselves).\n-                let dtor = match this.test_null(this.read_scalar(args[1])?.not_undef()?)? {\n-                    Some(dtor_ptr) => Some(this.memory.get_fn(dtor_ptr)?.as_instance()?),\n-                    None => None,\n-                };\n-\n-                // Figure out how large a pthread TLS key actually is.\n-                // This is `libc::pthread_key_t`.\n-                let key_type = args[0].layout.ty\n-                    .builtin_deref(true)\n-                    .ok_or_else(|| err_ub_format!(\n-                        \"wrong signature used for `pthread_key_create`: first argument must be a raw pointer.\"\n-                    ))?\n-                    .ty;\n-                let key_layout = this.layout_of(key_type)?;\n-\n-                // Create key and write it into the memory where `key_ptr` wants it.\n-                let key = this.machine.tls.create_tls_key(dtor) as u128;\n-                if key_layout.size.bits() < 128 && key >= (1u128 << key_layout.size.bits() as u128)\n-                {\n-                    throw_unsup!(OutOfTls);\n-                }\n-\n-                this.write_scalar(Scalar::from_uint(key, key_layout.size), key_place.into())?;\n-\n-                // Return success (`0`).\n-                this.write_null(dest)?;\n-            }\n-            \"pthread_key_delete\" => {\n-                let key = this.read_scalar(args[0])?.to_bits(args[0].layout.size)?;\n-                this.machine.tls.delete_tls_key(key)?;\n-                // Return success (0)\n-                this.write_null(dest)?;\n-            }\n-            \"pthread_getspecific\" => {\n-                let key = this.read_scalar(args[0])?.to_bits(args[0].layout.size)?;\n-                let ptr = this.machine.tls.load_tls(key, tcx)?;\n-                this.write_scalar(ptr, dest)?;\n-            }\n-            \"pthread_setspecific\" => {\n-                let key = this.read_scalar(args[0])?.to_bits(args[0].layout.size)?;\n-                let new_ptr = this.read_scalar(args[1])?.not_undef()?;\n-                this.machine.tls.store_tls(key, this.test_null(new_ptr)?)?;\n-\n-                // Return success (`0`).\n-                this.write_null(dest)?;\n-            }\n-\n-            // Stack size/address stuff.\n-            | \"pthread_attr_init\"\n-            | \"pthread_attr_destroy\"\n-            | \"pthread_self\"\n-            | \"pthread_attr_setstacksize\" => {\n-                this.write_null(dest)?;\n-            }\n-            \"pthread_attr_getstack\" => {\n-                let addr_place = this.deref_operand(args[1])?;\n-                let size_place = this.deref_operand(args[2])?;\n-\n-                this.write_scalar(\n-                    Scalar::from_uint(STACK_ADDR, addr_place.layout.size),\n-                    addr_place.into(),\n-                )?;\n-                this.write_scalar(\n-                    Scalar::from_uint(STACK_SIZE, size_place.layout.size),\n-                    size_place.into(),\n-                )?;\n-\n-                // Return success (`0`).\n-                this.write_null(dest)?;\n-            }\n-\n-            // We don't support threading. (Also for Windows.)\n-            | \"pthread_create\"\n-            | \"CreateThread\"\n-            => {\n-                throw_unsup_format!(\"Miri does not support threading\");\n-            }\n-\n-            // Stub out calls for condvar, mutex and rwlock, to just return `0`.\n-            | \"pthread_mutexattr_init\"\n-            | \"pthread_mutexattr_settype\"\n-            | \"pthread_mutex_init\"\n-            | \"pthread_mutexattr_destroy\"\n-            | \"pthread_mutex_lock\"\n-            | \"pthread_mutex_unlock\"\n-            | \"pthread_mutex_destroy\"\n-            | \"pthread_rwlock_rdlock\"\n-            | \"pthread_rwlock_unlock\"\n-            | \"pthread_rwlock_wrlock\"\n-            | \"pthread_rwlock_destroy\"\n-            | \"pthread_condattr_init\"\n-            | \"pthread_condattr_setclock\"\n-            | \"pthread_cond_init\"\n-            | \"pthread_condattr_destroy\"\n-            | \"pthread_cond_destroy\"\n-            => {\n-                this.write_null(dest)?;\n-            }\n-\n-            // We don't support fork so we don't have to do anything for atfork.\n-            \"pthread_atfork\" => {\n-                this.write_null(dest)?;\n-            }\n-\n             \"posix_fadvise\" => {\n                 // fadvise is only informational, we can ignore it.\n                 this.write_null(dest)?;"}, {"sha": "2ec8b9d7a6011ab015916bdccae3257986d19b6d", "filename": "src/shims/foreign_items/posix.rs", "status": "modified", "additions": 111, "deletions": 1, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/63160c66cd31c6f48a4a68ff469c4bdebc8eff2f/src%2Fshims%2Fforeign_items%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63160c66cd31c6f48a4a68ff469c4bdebc8eff2f/src%2Fshims%2Fforeign_items%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix.rs?ref=63160c66cd31c6f48a4a68ff469c4bdebc8eff2f", "patch": "@@ -2,7 +2,7 @@ mod linux;\n mod macos;\n \n use crate::*;\n-use rustc::ty::layout::{Align, Size};\n+use rustc::ty::layout::{Align, LayoutOf, Size};\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n@@ -157,6 +157,116 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n \n+            // Hook pthread calls that go to the thread-local storage memory subsystem.\n+            \"pthread_key_create\" => {\n+                let key_place = this.deref_operand(args[0])?;\n+\n+                // Extract the function type out of the signature (that seems easier than constructing it ourselves).\n+                let dtor = match this.test_null(this.read_scalar(args[1])?.not_undef()?)? {\n+                    Some(dtor_ptr) => Some(this.memory.get_fn(dtor_ptr)?.as_instance()?),\n+                    None => None,\n+                };\n+\n+                // Figure out how large a pthread TLS key actually is.\n+                // This is `libc::pthread_key_t`.\n+                let key_type = args[0].layout.ty\n+                    .builtin_deref(true)\n+                    .ok_or_else(|| err_ub_format!(\n+                        \"wrong signature used for `pthread_key_create`: first argument must be a raw pointer.\"\n+                    ))?\n+                    .ty;\n+                let key_layout = this.layout_of(key_type)?;\n+\n+                // Create key and write it into the memory where `key_ptr` wants it.\n+                let key = this.machine.tls.create_tls_key(dtor) as u128;\n+                if key_layout.size.bits() < 128 && key >= (1u128 << key_layout.size.bits() as u128)\n+                {\n+                    throw_unsup!(OutOfTls);\n+                }\n+\n+                this.write_scalar(Scalar::from_uint(key, key_layout.size), key_place.into())?;\n+\n+                // Return success (`0`).\n+                this.write_null(dest)?;\n+            }\n+            \"pthread_key_delete\" => {\n+                let key = this.read_scalar(args[0])?.to_bits(args[0].layout.size)?;\n+                this.machine.tls.delete_tls_key(key)?;\n+                // Return success (0)\n+                this.write_null(dest)?;\n+            }\n+            \"pthread_getspecific\" => {\n+                let key = this.read_scalar(args[0])?.to_bits(args[0].layout.size)?;\n+                let ptr = this.machine.tls.load_tls(key, tcx)?;\n+                this.write_scalar(ptr, dest)?;\n+            }\n+            \"pthread_setspecific\" => {\n+                let key = this.read_scalar(args[0])?.to_bits(args[0].layout.size)?;\n+                let new_ptr = this.read_scalar(args[1])?.not_undef()?;\n+                this.machine.tls.store_tls(key, this.test_null(new_ptr)?)?;\n+\n+                // Return success (`0`).\n+                this.write_null(dest)?;\n+            }\n+\n+            // Stack size/address stuff.\n+            | \"pthread_attr_init\"\n+            | \"pthread_attr_destroy\"\n+            | \"pthread_self\"\n+            | \"pthread_attr_setstacksize\" => {\n+                this.write_null(dest)?;\n+            }\n+            \"pthread_attr_getstack\" => {\n+                let addr_place = this.deref_operand(args[1])?;\n+                let size_place = this.deref_operand(args[2])?;\n+\n+                this.write_scalar(\n+                    Scalar::from_uint(STACK_ADDR, addr_place.layout.size),\n+                    addr_place.into(),\n+                )?;\n+                this.write_scalar(\n+                    Scalar::from_uint(STACK_SIZE, size_place.layout.size),\n+                    size_place.into(),\n+                )?;\n+\n+                // Return success (`0`).\n+                this.write_null(dest)?;\n+            }\n+\n+            // We don't support threading. (Also for Windows.)\n+            | \"pthread_create\"\n+            | \"CreateThread\"\n+            => {\n+                throw_unsup_format!(\"Miri does not support threading\");\n+            }\n+\n+            // Stub out calls for condvar, mutex and rwlock, to just return `0`.\n+            | \"pthread_mutexattr_init\"\n+            | \"pthread_mutexattr_settype\"\n+            | \"pthread_mutex_init\"\n+            | \"pthread_mutexattr_destroy\"\n+            | \"pthread_mutex_lock\"\n+            | \"pthread_mutex_unlock\"\n+            | \"pthread_mutex_destroy\"\n+            | \"pthread_rwlock_rdlock\"\n+            | \"pthread_rwlock_unlock\"\n+            | \"pthread_rwlock_wrlock\"\n+            | \"pthread_rwlock_destroy\"\n+            | \"pthread_condattr_init\"\n+            | \"pthread_condattr_setclock\"\n+            | \"pthread_cond_init\"\n+            | \"pthread_condattr_destroy\"\n+            | \"pthread_cond_destroy\"\n+            => {\n+                this.write_null(dest)?;\n+            }\n+\n+            // We don't support fork so we don't have to do anything for atfork.\n+            \"pthread_atfork\" => {\n+                this.write_null(dest)?;\n+            }\n+\n+\n             _ => {\n                 match this.tcx.sess.target.target.target_os.to_lowercase().as_str() {\n                     \"linux\" => linux::EvalContextExt::emulate_foreign_item_by_name(this, link_name, args, dest)?,"}]}