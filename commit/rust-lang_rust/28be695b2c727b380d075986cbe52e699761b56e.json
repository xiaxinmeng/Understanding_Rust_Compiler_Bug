{"sha": "28be695b2c727b380d075986cbe52e699761b56e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4YmU2OTViMmM3MjdiMzgwZDA3NTk4NmNiZTUyZTY5OTc2MWI1NmU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T12:56:37Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-08T12:28:23Z"}, "message": "rustc: fix fallout from the addition of a 'tcx lifetime on tcx.", "tree": {"sha": "d073f7b0e4934e6a360b8f479956b86c6c907fa5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d073f7b0e4934e6a360b8f479956b86c6c907fa5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28be695b2c727b380d075986cbe52e699761b56e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28be695b2c727b380d075986cbe52e699761b56e", "html_url": "https://github.com/rust-lang/rust/commit/28be695b2c727b380d075986cbe52e699761b56e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28be695b2c727b380d075986cbe52e699761b56e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22f8b8462ec7ca725415ca2db3e604ee75fd3251", "url": "https://api.github.com/repos/rust-lang/rust/commits/22f8b8462ec7ca725415ca2db3e604ee75fd3251", "html_url": "https://github.com/rust-lang/rust/commit/22f8b8462ec7ca725415ca2db3e604ee75fd3251"}], "stats": {"total": 1501, "additions": 742, "deletions": 759}, "files": [{"sha": "a3227e4dbf1d49064880dda50c839663f9f2087b", "filename": "src/librustc/driver/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fpretty.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -262,25 +262,25 @@ impl pprust::PpAnn for HygieneAnnotation {\n }\n \n \n-struct TypedAnnotation {\n-    analysis: CrateAnalysis,\n+struct TypedAnnotation<'tcx> {\n+    analysis: CrateAnalysis<'tcx>,\n }\n \n-impl PrinterSupport for TypedAnnotation {\n+impl<'tcx> PrinterSupport for TypedAnnotation<'tcx> {\n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n }\n \n-impl SessionCarrier for TypedAnnotation {\n+impl<'tcx> SessionCarrier for TypedAnnotation<'tcx> {\n     fn sess<'a>(&'a self) -> &'a Session { &self.analysis.ty_cx.sess }\n }\n \n-impl AstMapCarrier for TypedAnnotation {\n+impl<'tcx> AstMapCarrier for TypedAnnotation<'tcx> {\n     fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n         Some(&self.analysis.ty_cx.map)\n     }\n }\n \n-impl pprust::PpAnn for TypedAnnotation {\n+impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n     fn pre(&self,\n            s: &mut pprust::State,\n            node: pprust::AnnNode) -> io::IoResult<()> {"}, {"sha": "c3c4cf51f577540ed5dd0763a427c424377c1140", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -340,11 +340,11 @@ impl LintPass for TypeLimits {\n declare_lint!(CTYPES, Warn,\n               \"proper use of libc types in foreign modules\")\n \n-struct CTypesVisitor<'a> {\n-    cx: &'a Context<'a>\n+struct CTypesVisitor<'a, 'tcx: 'a> {\n+    cx: &'a Context<'a, 'tcx>\n }\n \n-impl<'a> CTypesVisitor<'a> {\n+impl<'a, 'tcx> CTypesVisitor<'a, 'tcx> {\n     fn check_def(&mut self, sp: Span, ty_id: ast::NodeId, path_id: ast::NodeId) {\n         match self.cx.tcx.def_map.borrow().get_copy(&path_id) {\n             def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n@@ -375,7 +375,7 @@ impl<'a> CTypesVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for CTypesVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for CTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n         match ty.node {\n             ast::TyPath(_, _, id) => self.check_def(ty.span, ty.id, id),\n@@ -505,11 +505,11 @@ impl LintPass for HeapMemory {\n declare_lint!(RAW_POINTER_DERIVING, Warn,\n               \"uses of #[deriving] with raw pointers are rarely correct\")\n \n-struct RawPtrDerivingVisitor<'a> {\n-    cx: &'a Context<'a>\n+struct RawPtrDerivingVisitor<'a, 'tcx: 'a> {\n+    cx: &'a Context<'a, 'tcx>\n }\n \n-impl<'a> Visitor<()> for RawPtrDerivingVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for RawPtrDerivingVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n         static MSG: &'static str = \"use of `#[deriving]` with a raw pointer\";\n         match ty.node {"}, {"sha": "26ed5cbfb2cc1b89491c5bfb2fb3502183e11a4f", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -231,9 +231,9 @@ impl LintStore {\n }\n \n /// Context for lint checking.\n-pub struct Context<'a> {\n+pub struct Context<'a, 'tcx: 'a> {\n     /// Type context we're checking in.\n-    pub tcx: &'a ty::ctxt,\n+    pub tcx: &'a ty::ctxt<'tcx>,\n \n     /// The crate being checked.\n     pub krate: &'a ast::Crate,\n@@ -345,10 +345,10 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n     }\n }\n \n-impl<'a> Context<'a> {\n-    fn new(tcx: &'a ty::ctxt,\n+impl<'a, 'tcx> Context<'a, 'tcx> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>,\n            krate: &'a ast::Crate,\n-           exported_items: &'a ExportedItems) -> Context<'a> {\n+           exported_items: &'a ExportedItems) -> Context<'a, 'tcx> {\n         // We want to own the lint store, so move it out of the session.\n         let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(),\n                                       LintStore::new());\n@@ -476,8 +476,8 @@ impl<'a> Context<'a> {\n     }\n }\n \n-impl<'a> AstConv for Context<'a>{\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n+impl<'a, 'tcx> AstConv<'tcx> for Context<'a, 'tcx>{\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n         ty::lookup_item_type(self.tcx, id)\n@@ -492,7 +492,7 @@ impl<'a> AstConv for Context<'a>{\n     }\n }\n \n-impl<'a> Visitor<()> for Context<'a> {\n+impl<'a, 'tcx> Visitor<()> for Context<'a, 'tcx> {\n     fn visit_item(&mut self, it: &ast::Item, _: ()) {\n         self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n             run_lints!(cx, check_item, it);\n@@ -663,7 +663,7 @@ impl<'a> Visitor<()> for Context<'a> {\n }\n \n // Output any lints that were previously added to the session.\n-impl<'a> IdVisitingOperation for Context<'a> {\n+impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n     fn visit_id(&self, id: ast::NodeId) {\n         match self.tcx.sess.lints.borrow_mut().pop(&id) {\n             None => {}"}, {"sha": "a105a56a09b15d9ef0afe3a34bb3a8bcf253b314", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -71,9 +71,9 @@ pub type EncodeInlinedItem<'a> = |ecx: &EncodeContext,\n                                   rbml_w: &mut Encoder,\n                                   ii: InlinedItemRef|: 'a;\n \n-pub struct EncodeParams<'a> {\n+pub struct EncodeParams<'a, 'tcx: 'a> {\n     pub diag: &'a SpanHandler,\n-    pub tcx: &'a ty::ctxt,\n+    pub tcx: &'a ty::ctxt<'tcx>,\n     pub reexports2: &'a middle::resolve::ExportMap2,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n     pub non_inlineable_statics: &'a RefCell<NodeSet>,\n@@ -83,9 +83,9 @@ pub struct EncodeParams<'a> {\n     pub reachable: &'a NodeSet,\n }\n \n-pub struct EncodeContext<'a> {\n+pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub diag: &'a SpanHandler,\n-    pub tcx: &'a ty::ctxt,\n+    pub tcx: &'a ty::ctxt<'tcx>,\n     pub reexports2: &'a middle::resolve::ExportMap2,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n     pub non_inlineable_statics: &'a RefCell<NodeSet>,\n@@ -1793,12 +1793,12 @@ fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &Crate) {\n \n \n \n-struct ImplVisitor<'a,'b:'a,'c:'a> {\n-    ecx: &'a EncodeContext<'b>,\n+struct ImplVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n+    ecx: &'a EncodeContext<'b, 'tcx>,\n     rbml_w: &'a mut Encoder<'c>,\n }\n \n-impl<'a,'b,'c> Visitor<()> for ImplVisitor<'a,'b,'c> {\n+impl<'a, 'b, 'c, 'tcx> Visitor<()> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n         match item.node {\n             ItemImpl(_, Some(ref trait_ref), _, _) => {"}, {"sha": "53203663bb16e080e48165af52a69b12c7bf6406", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -59,11 +59,11 @@ pub enum DefIdSource {\n pub type conv_did<'a> =\n     |source: DefIdSource, ast::DefId|: 'a -> ast::DefId;\n \n-pub struct PState<'a> {\n+pub struct PState<'a, 'tcx: 'a> {\n     data: &'a [u8],\n     krate: ast::CrateNum,\n     pos: uint,\n-    tcx: &'a ty::ctxt\n+    tcx: &'a ty::ctxt<'tcx>\n }\n \n fn peek(st: &PState) -> char {\n@@ -105,8 +105,9 @@ fn parse_ident_(st: &mut PState, is_last: |char| -> bool) -> ast::Ident {\n     })\n }\n \n-pub fn parse_state_from_data<'a>(data: &'a [u8], crate_num: ast::CrateNum,\n-                             pos: uint, tcx: &'a ty::ctxt) -> PState<'a> {\n+pub fn parse_state_from_data<'a, 'tcx>(data: &'a [u8], crate_num: ast::CrateNum,\n+                                       pos: uint, tcx: &'a ty::ctxt<'tcx>)\n+                                       -> PState<'a, 'tcx> {\n     PState {\n         data: data,\n         krate: crate_num,"}, {"sha": "cbf558b6b483e615630ae6fd2640e1de7249f580", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -31,12 +31,12 @@ use rbml::io::SeekableMemWriter;\n \n macro_rules! mywrite( ($($arg:tt)*) => ({ write!($($arg)*); }) )\n \n-pub struct ctxt<'a> {\n+pub struct ctxt<'a, 'tcx: 'a> {\n     pub diag: &'a SpanHandler,\n     // Def -> str Callback:\n     pub ds: fn(DefId) -> String,\n     // The type context.\n-    pub tcx: &'a ty::ctxt,\n+    pub tcx: &'a ty::ctxt<'tcx>,\n     pub abbrevs: &'a abbrev_map\n }\n "}, {"sha": "0e64be3d0b70bbfa347a6f3364a4ed99baa2378d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -54,13 +54,13 @@ use serialize::{EncoderHelpers};\n #[cfg(test)] use syntax::print::pprust;\n #[cfg(test)] use std::gc::Gc;\n \n-struct DecodeContext<'a> {\n+struct DecodeContext<'a, 'tcx: 'a> {\n     cdata: &'a cstore::crate_metadata,\n-    tcx: &'a ty::ctxt,\n+    tcx: &'a ty::ctxt<'tcx>,\n }\n \n-struct ExtendedDecodeContext<'a> {\n-    dcx: &'a DecodeContext<'a>,\n+struct ExtendedDecodeContext<'a, 'tcx: 'a> {\n+    dcx: &'a DecodeContext<'a, 'tcx>,\n     from_id_range: ast_util::IdRange,\n     to_id_range: ast_util::IdRange\n }\n@@ -176,7 +176,7 @@ fn reserve_id_range(sess: &Session,\n     ast_util::IdRange { min: to_id_min, max: to_id_max }\n }\n \n-impl<'a> ExtendedDecodeContext<'a> {\n+impl<'a, 'tcx> ExtendedDecodeContext<'a, 'tcx> {\n     pub fn tr_id(&self, id: ast::NodeId) -> ast::NodeId {\n         /*!\n          * Translates an internal id, meaning a node id that is known\n@@ -382,11 +382,11 @@ fn decode_ast(par_doc: rbml::Doc) -> ast::InlinedItem {\n     Decodable::decode(&mut d).unwrap()\n }\n \n-struct AstRenumberer<'a> {\n-    xcx: &'a ExtendedDecodeContext<'a>,\n+struct AstRenumberer<'a, 'tcx: 'a> {\n+    xcx: &'a ExtendedDecodeContext<'a, 'tcx>,\n }\n \n-impl<'a> ast_map::FoldOps for AstRenumberer<'a> {\n+impl<'a, 'tcx> ast_map::FoldOps for AstRenumberer<'a, 'tcx> {\n     fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n         if id == ast::DUMMY_NODE_ID {\n             // Used by ast_map to map the NodeInlinedParent.\n@@ -914,12 +914,12 @@ fn encode_vec_per_param_space<T>(rbml_w: &mut Encoder,\n // ______________________________________________________________________\n // Encoding and decoding the side tables\n \n-trait get_ty_str_ctxt {\n-    fn ty_str_ctxt<'a>(&'a self) -> tyencode::ctxt<'a>;\n+trait get_ty_str_ctxt<'tcx> {\n+    fn ty_str_ctxt<'a>(&'a self) -> tyencode::ctxt<'a, 'tcx>;\n }\n \n-impl<'a> get_ty_str_ctxt for e::EncodeContext<'a> {\n-    fn ty_str_ctxt<'a>(&'a self) -> tyencode::ctxt<'a> {\n+impl<'a, 'tcx> get_ty_str_ctxt<'tcx> for e::EncodeContext<'a, 'tcx> {\n+    fn ty_str_ctxt<'a>(&'a self) -> tyencode::ctxt<'a, 'tcx> {\n         tyencode::ctxt {\n             diag: self.tcx.sess.diagnostic(),\n             ds: e::def_to_string,"}, {"sha": "df637e7a052dd36473d5de825d3a1c752e3adddc", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -79,14 +79,14 @@ fn owned_ptr_base_path_rc(loan_path: &Rc<LoanPath>) -> Rc<LoanPath> {\n     }\n }\n \n-struct CheckLoanCtxt<'a> {\n-    bccx: &'a BorrowckCtxt<'a>,\n-    dfcx_loans: &'a LoanDataFlow<'a>,\n-    move_data: move_data::FlowedMoveData<'a>,\n+struct CheckLoanCtxt<'a, 'tcx: 'a> {\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n+    dfcx_loans: &'a LoanDataFlow<'a, 'tcx>,\n+    move_data: move_data::FlowedMoveData<'a, 'tcx>,\n     all_loans: &'a [Loan],\n }\n \n-impl<'a> euv::Delegate for CheckLoanCtxt<'a> {\n+impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                consume_span: Span,\n@@ -179,12 +179,12 @@ impl<'a> euv::Delegate for CheckLoanCtxt<'a> {\n     fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) { }\n }\n \n-pub fn check_loans(bccx: &BorrowckCtxt,\n-                   dfcx_loans: &LoanDataFlow,\n-                   move_data: move_data::FlowedMoveData,\n-                   all_loans: &[Loan],\n-                   decl: &ast::FnDecl,\n-                   body: &ast::Block) {\n+pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                     dfcx_loans: &LoanDataFlow<'b, 'tcx>,\n+                                     move_data: move_data::FlowedMoveData<'c, 'tcx>,\n+                                     all_loans: &[Loan],\n+                                     decl: &ast::FnDecl,\n+                                     body: &ast::Block) {\n     debug!(\"check_loans(body id={:?})\", body.id);\n \n     let mut clcx = CheckLoanCtxt {\n@@ -212,8 +212,8 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n     borrow_kind1 == ty::ImmBorrow && borrow_kind2 == ty::ImmBorrow\n }\n \n-impl<'a> CheckLoanCtxt<'a> {\n-    pub fn tcx(&self) -> &'a ty::ctxt { self.bccx.tcx }\n+impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n+    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.bccx.tcx }\n \n     pub fn each_issued_loan(&self, scope_id: ast::NodeId, op: |&Loan| -> bool)\n                             -> bool {"}, {"sha": "e13717e5abd31be1ae23e9a1b91918a6bdcb814e", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -45,8 +45,8 @@ pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n ///////////////////////////////////////////////////////////////////////////\n // Private\n \n-struct GuaranteeLifetimeContext<'a> {\n-    bccx: &'a BorrowckCtxt<'a>,\n+struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n \n     // the node id of the function body for the enclosing item\n     item_scope_id: ast::NodeId,\n@@ -57,7 +57,7 @@ struct GuaranteeLifetimeContext<'a> {\n     cmt_original: mc::cmt\n }\n \n-impl<'a> GuaranteeLifetimeContext<'a> {\n+impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n \n     fn check(&self, cmt: &mc::cmt, discr_scope: Option<ast::NodeId>) -> R {\n         //! Main routine. Walks down `cmt` until we find the \"guarantor\"."}, {"sha": "11189390df565921317ae28cb11b24c1bc6b00bb", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -57,15 +57,15 @@ pub fn gather_loans_in_fn(bccx: &BorrowckCtxt,\n     (all_loans, move_data)\n }\n \n-struct GatherLoanCtxt<'a> {\n-    bccx: &'a BorrowckCtxt<'a>,\n+struct GatherLoanCtxt<'a, 'tcx: 'a> {\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     move_data: move_data::MoveData,\n     move_error_collector: move_error::MoveErrorCollector,\n     all_loans: Vec<Loan>,\n     item_ub: ast::NodeId,\n }\n \n-impl<'a> euv::Delegate for GatherLoanCtxt<'a> {\n+impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                _consume_span: Span,\n@@ -204,8 +204,8 @@ fn check_aliasability(bccx: &BorrowckCtxt,\n     }\n }\n \n-impl<'a> GatherLoanCtxt<'a> {\n-    pub fn tcx(&self) -> &'a ty::ctxt { self.bccx.tcx }\n+impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n+    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.bccx.tcx }\n \n     fn guarantee_valid(&mut self,\n                        borrow_id: ast::NodeId,\n@@ -467,11 +467,11 @@ impl<'a> GatherLoanCtxt<'a> {\n ///\n /// This visitor walks static initializer's expressions and makes\n /// sure the loans being taken are sound.\n-struct StaticInitializerCtxt<'a> {\n-    bccx: &'a BorrowckCtxt<'a>\n+struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>\n }\n \n-impl<'a> visit::Visitor<()> for StaticInitializerCtxt<'a> {\n+impl<'a, 'tcx> visit::Visitor<()> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         match ex.node {\n             ast::ExprAddrOf(mutbl, ref base) => {"}, {"sha": "90e17e4d79cbbce8eec47ea28e653f76e9a5c466", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -44,14 +44,14 @@ pub fn compute_restrictions(bccx: &BorrowckCtxt,\n ///////////////////////////////////////////////////////////////////////////\n // Private\n \n-struct RestrictionsContext<'a> {\n-    bccx: &'a BorrowckCtxt<'a>,\n+struct RestrictionsContext<'a, 'tcx: 'a> {\n+    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     span: Span,\n     loan_region: ty::Region,\n     cause: euv::LoanCause,\n }\n \n-impl<'a> RestrictionsContext<'a> {\n+impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n     fn restrict(&self,\n                 cmt: mc::cmt) -> RestrictionResult {\n         debug!(\"restrict(cmt={})\", cmt.repr(self.bccx.tcx));"}, {"sha": "e75378de5a5c791b5bf495ffc8bd79b5f5a4c474", "filename": "src/librustc/middle/borrowck/graphviz.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -43,14 +43,14 @@ impl Variant {\n     }\n }\n \n-pub struct DataflowLabeller<'a> {\n+pub struct DataflowLabeller<'a, 'tcx: 'a> {\n     pub inner: cfg_dot::LabelledCFG<'a>,\n     pub variants: Vec<Variant>,\n-    pub borrowck_ctxt: &'a BorrowckCtxt<'a>,\n-    pub analysis_data: &'a borrowck::AnalysisData<'a>,\n+    pub borrowck_ctxt: &'a BorrowckCtxt<'a, 'tcx>,\n+    pub analysis_data: &'a borrowck::AnalysisData<'a, 'tcx>,\n }\n \n-impl<'a> DataflowLabeller<'a> {\n+impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n     fn dataflow_for(&self, e: EntryOrExit, n: &Node<'a>) -> String {\n         let id = n.val1().data.id;\n         debug!(\"dataflow_for({}, id={}) {}\", e, id, self.variants);\n@@ -77,7 +77,7 @@ impl<'a> DataflowLabeller<'a> {\n     fn build_set<O:DataFlowOperator>(&self,\n                                      e: EntryOrExit,\n                                      cfgidx: CFGIndex,\n-                                     dfcx: &DataFlowContext<'a, O>,\n+                                     dfcx: &DataFlowContext<'a, 'tcx, O>,\n                                      to_lp: |uint| -> Rc<LoanPath>) -> String {\n         let mut saw_some = false;\n         let mut set = \"{\".to_string();\n@@ -126,7 +126,7 @@ impl<'a> DataflowLabeller<'a> {\n     }\n }\n \n-impl<'a> dot::Labeller<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a> {\n+impl<'a, 'tcx> dot::Labeller<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a, 'tcx> {\n     fn graph_id(&'a self) -> dot::Id<'a> { self.inner.graph_id() }\n     fn node_id(&'a self, n: &Node<'a>) -> dot::Id<'a> { self.inner.node_id(n) }\n     fn node_label(&'a self, n: &Node<'a>) -> dot::LabelText<'a> {\n@@ -140,7 +140,7 @@ impl<'a> dot::Labeller<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a> {\n     fn edge_label(&'a self, e: &Edge<'a>) -> dot::LabelText<'a> { self.inner.edge_label(e) }\n }\n \n-impl<'a> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a> {\n+impl<'a, 'tcx> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a, 'tcx> {\n     fn nodes(&self) -> dot::Nodes<'a, Node<'a>> { self.inner.nodes() }\n     fn edges(&self) -> dot::Edges<'a, Edge<'a>> { self.inner.edges() }\n     fn source(&self, edge: &Edge<'a>) -> Node<'a> { self.inner.source(edge) }"}, {"sha": "f4d3678271c0ded7c8d6c26a980f60b9ce947688", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -58,9 +58,9 @@ pub mod move_data;\n #[deriving(Clone)]\n pub struct LoanDataFlowOperator;\n \n-pub type LoanDataFlow<'a> = DataFlowContext<'a, LoanDataFlowOperator>;\n+pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator>;\n \n-impl<'a> Visitor<()> for BorrowckCtxt<'a> {\n+impl<'a, 'tcx> Visitor<()> for BorrowckCtxt<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl,\n                 b: &Block, s: Span, n: NodeId, _: ()) {\n         borrowck_fn(self, fk, fd, b, s, n);\n@@ -120,10 +120,10 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n }\n \n /// Collection of conclusions determined via borrow checker analyses.\n-pub struct AnalysisData<'a> {\n+pub struct AnalysisData<'a, 'tcx: 'a> {\n     pub all_loans: Vec<Loan>,\n-    pub loans: DataFlowContext<'a, LoanDataFlowOperator>,\n-    pub move_data: move_data::FlowedMoveData<'a>,\n+    pub loans: DataFlowContext<'a, 'tcx, LoanDataFlowOperator>,\n+    pub move_data: move_data::FlowedMoveData<'a, 'tcx>,\n }\n \n fn borrowck_fn(this: &mut BorrowckCtxt,\n@@ -145,13 +145,13 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     visit::walk_fn(this, fk, decl, body, sp, ());\n }\n \n-fn build_borrowck_dataflow_data<'a>(this: &mut BorrowckCtxt<'a>,\n-                                    fk: &FnKind,\n-                                    decl: &ast::FnDecl,\n-                                    cfg: &cfg::CFG,\n-                                    body: &ast::Block,\n-                                    sp: Span,\n-                                    id: ast::NodeId) -> AnalysisData<'a> {\n+fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n+                                          fk: &FnKind,\n+                                          decl: &ast::FnDecl,\n+                                          cfg: &cfg::CFG,\n+                                          body: &ast::Block,\n+                                          sp: Span,\n+                                          id: ast::NodeId) -> AnalysisData<'a, 'tcx> {\n     // Check the body of fn items.\n     let id_range = ast_util::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n     let (all_loans, move_data) =\n@@ -200,9 +200,9 @@ impl<'a> FnPartsWithCFG<'a> {\n \n /// Accessor for introspective clients inspecting `AnalysisData` and\n /// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n-pub fn build_borrowck_dataflow_data_for_fn<'a>(\n-    tcx: &'a ty::ctxt,\n-    input: FnPartsWithCFG<'a>) -> (BorrowckCtxt<'a>, AnalysisData<'a>) {\n+pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n+    tcx: &'a ty::ctxt<'tcx>,\n+    input: FnPartsWithCFG<'a>) -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>) {\n \n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n@@ -230,8 +230,8 @@ pub fn build_borrowck_dataflow_data_for_fn<'a>(\n // ----------------------------------------------------------------------\n // Type definitions\n \n-pub struct BorrowckCtxt<'a> {\n-    tcx: &'a ty::ctxt,\n+pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n \n     // Statistics:\n     stats: Gc<BorrowStats>,\n@@ -390,7 +390,7 @@ pub enum MovedValueUseKind {\n ///////////////////////////////////////////////////////////////////////////\n // Misc\n \n-impl<'a> BorrowckCtxt<'a> {\n+impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region)\n                            -> bool {\n         self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n@@ -401,7 +401,7 @@ impl<'a> BorrowckCtxt<'a> {\n         self.tcx.region_maps.is_subscope_of(r_sub, r_sup)\n     }\n \n-    pub fn mc(&self) -> mc::MemCategorizationContext<'a,ty::ctxt> {\n+    pub fn mc(&self) -> mc::MemCategorizationContext<'a, ty::ctxt<'tcx>> {\n         mc::MemCategorizationContext::new(self.tcx)\n     }\n "}, {"sha": "fdd16c886866d3e0e9dbc6235723f6ec99a80656", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -56,15 +56,15 @@ pub struct MoveData {\n     pub assignee_ids: RefCell<HashSet<ast::NodeId>>,\n }\n \n-pub struct FlowedMoveData<'a> {\n+pub struct FlowedMoveData<'a, 'tcx: 'a> {\n     pub move_data: MoveData,\n \n-    pub dfcx_moves: MoveDataFlow<'a>,\n+    pub dfcx_moves: MoveDataFlow<'a, 'tcx>,\n \n     // We could (and maybe should, for efficiency) combine both move\n     // and assign data flow into one, but this way it's easier to\n     // distinguish the bits that correspond to moves and assignments.\n-    pub dfcx_assign: AssignDataFlow<'a>\n+    pub dfcx_assign: AssignDataFlow<'a, 'tcx>\n }\n \n /// Index into `MoveData.paths`, used like a pointer\n@@ -154,12 +154,12 @@ pub struct Assignment {\n #[deriving(Clone)]\n pub struct MoveDataFlowOperator;\n \n-pub type MoveDataFlow<'a> = DataFlowContext<'a, MoveDataFlowOperator>;\n+pub type MoveDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, MoveDataFlowOperator>;\n \n #[deriving(Clone)]\n pub struct AssignDataFlowOperator;\n \n-pub type AssignDataFlow<'a> = DataFlowContext<'a, AssignDataFlowOperator>;\n+pub type AssignDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, AssignDataFlowOperator>;\n \n fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n     match *loan_path {\n@@ -531,14 +531,14 @@ impl MoveData {\n     }\n }\n \n-impl<'a> FlowedMoveData<'a> {\n+impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     pub fn new(move_data: MoveData,\n-               tcx: &'a ty::ctxt,\n+               tcx: &'a ty::ctxt<'tcx>,\n                cfg: &cfg::CFG,\n                id_range: ast_util::IdRange,\n                decl: &ast::FnDecl,\n                body: &ast::Block)\n-               -> FlowedMoveData<'a> {\n+               -> FlowedMoveData<'a, 'tcx> {\n         let mut dfcx_moves =\n             DataFlowContext::new(tcx,\n                                  \"flowed_move_data_moves\","}, {"sha": "ec414b858187aae059be33986fa1f50f468abe1f", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -19,8 +19,8 @@ use util::nodemap::NodeMap;\n \n use std::gc::Gc;\n \n-struct CFGBuilder<'a> {\n-    tcx: &'a ty::ctxt,\n+struct CFGBuilder<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     exit_map: NodeMap<CFGIndex>,\n     graph: CFGGraph,\n     fn_exit: CFGIndex,\n@@ -65,7 +65,7 @@ fn add_initial_dummy_node(g: &mut CFGGraph) -> CFGIndex {\n     g.add_node(CFGNodeData { id: ast::DUMMY_NODE_ID })\n }\n \n-impl<'a> CFGBuilder<'a> {\n+impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n         for stmt in blk.stmts.iter() {"}, {"sha": "3c8db8d048076cae439776cbb65957c76a6692da", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -21,11 +21,11 @@ use syntax::{ast_util, ast_map};\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-pub struct CheckCrateVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+pub struct CheckCrateVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n }\n \n-impl<'a> Visitor<bool> for CheckCrateVisitor<'a> {\n+impl<'a, 'tcx> Visitor<bool> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &Item, env: bool) {\n         check_item(self, i, env);\n     }"}, {"sha": "6676ea9851db0113bbfb9ab11be9ac32266c0625", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -86,8 +86,8 @@ impl FromIterator<Vec<Gc<Pat>>> for Matrix {\n     }\n }\n \n-pub struct MatchCheckCtxt<'a> {\n-    pub tcx: &'a ty::ctxt\n+pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n+    pub tcx: &'a ty::ctxt<'tcx>\n }\n \n #[deriving(Clone, PartialEq)]\n@@ -119,7 +119,7 @@ enum WitnessPreference {\n     LeaveOutWitness\n }\n \n-impl<'a> Visitor<()> for MatchCheckCtxt<'a> {\n+impl<'a, 'tcx> Visitor<()> for MatchCheckCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         check_expr(self, ex);\n     }\n@@ -304,21 +304,21 @@ fn const_val_to_expr(value: &const_val) -> Gc<Expr> {\n     }\n }\n \n-pub struct StaticInliner<'a> {\n-    pub tcx: &'a ty::ctxt,\n+pub struct StaticInliner<'a, 'tcx: 'a> {\n+    pub tcx: &'a ty::ctxt<'tcx>,\n     pub failed: bool\n }\n \n-impl<'a> StaticInliner<'a> {\n-    pub fn new<'a>(tcx: &'a ty::ctxt) -> StaticInliner<'a> {\n+impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n+    pub fn new<'a>(tcx: &'a ty::ctxt<'tcx>) -> StaticInliner<'a, 'tcx> {\n         StaticInliner {\n             tcx: tcx,\n             failed: false\n         }\n     }\n }\n \n-impl<'a> Folder for StaticInliner<'a> {\n+impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: Gc<Pat>) -> Gc<Pat> {\n         match pat.node {\n             PatIdent(..) | PatEnum(..) => {\n@@ -963,19 +963,19 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n \n /// Ensures that a pattern guard doesn't borrow by mutable reference or\n /// assign.\n-fn check_for_mutation_in_guard<'a>(cx: &'a MatchCheckCtxt<'a>, guard: &Expr) {\n+fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>, guard: &Expr) {\n     let mut checker = MutationChecker {\n         cx: cx,\n     };\n     let mut visitor = ExprUseVisitor::new(&mut checker, checker.cx.tcx);\n     visitor.walk_expr(guard);\n }\n \n-struct MutationChecker<'a> {\n-    cx: &'a MatchCheckCtxt<'a>,\n+struct MutationChecker<'a, 'tcx: 'a> {\n+    cx: &'a MatchCheckCtxt<'a, 'tcx>,\n }\n \n-impl<'a> Delegate for MutationChecker<'a> {\n+impl<'a, 'tcx> Delegate for MutationChecker<'a, 'tcx> {\n     fn consume(&mut self, _: NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n     fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}\n     fn borrow(&mut self,\n@@ -1020,11 +1020,11 @@ fn check_legality_of_bindings_in_at_patterns(cx: &MatchCheckCtxt, pat: &Pat) {\n     visitor.visit_pat(pat, true);\n }\n \n-struct AtBindingPatternVisitor<'a,'b:'a> {\n-    cx: &'a MatchCheckCtxt<'b>,\n+struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n+    cx: &'a MatchCheckCtxt<'b, 'tcx>,\n }\n \n-impl<'a,'b> Visitor<bool> for AtBindingPatternVisitor<'a,'b> {\n+impl<'a, 'b, 'tcx> Visitor<bool> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n     fn visit_pat(&mut self, pat: &Pat, bindings_allowed: bool) {\n         if !bindings_allowed && pat_is_binding(&self.cx.tcx.def_map, pat) {\n             self.cx.tcx.sess.span_err(pat.span,"}, {"sha": "f851ddbeeac238f3e88b6d389c84296e9b1bbbcd", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -26,11 +26,11 @@ pub fn check_crate(tcx: &ty::ctxt,\n     visit::walk_crate(&mut rvcx, krate, ());\n }\n \n-struct RvalueContext<'a> {\n-    tcx: &'a ty::ctxt\n+struct RvalueContext<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>\n }\n \n-impl<'a> visit::Visitor<()> for RvalueContext<'a> {\n+impl<'a, 'tcx> visit::Visitor<()> for RvalueContext<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 _: &visit::FnKind,\n                 fd: &ast::FnDecl,\n@@ -43,7 +43,7 @@ impl<'a> visit::Visitor<()> for RvalueContext<'a> {\n     }\n }\n \n-impl<'a> euv::Delegate for RvalueContext<'a> {\n+impl<'a, 'tcx> euv::Delegate for RvalueContext<'a, 'tcx> {\n     fn consume(&mut self,\n                _: ast::NodeId,\n                span: Span,"}, {"sha": "7b00bb4589c71e8983c2aaaea38d992b8d655d44", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -52,15 +52,15 @@ fn safe_type_for_static_mut(cx: &ty::ctxt, e: &ast::Expr) -> Option<String> {\n     Some(format!(\"mutable static items are not allowed to have {}\", suffix))\n }\n \n-struct CheckStaticVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct CheckStaticVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n }\n \n pub fn check_crate(tcx: &ty::ctxt, krate: &ast::Crate) {\n     visit::walk_crate(&mut CheckStaticVisitor { tcx: tcx }, krate, false)\n }\n \n-impl<'a> CheckStaticVisitor<'a> {\n+impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n     fn report_error(&self, span: Span, result: Option<String>) -> bool {\n         match result {\n             None => { false }\n@@ -72,7 +72,7 @@ impl<'a> CheckStaticVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n+impl<'a, 'tcx> Visitor<bool> for CheckStaticVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, i: &ast::Item, _is_const: bool) {\n         debug!(\"visit_item(item={})\", pprust::item_to_string(i));"}, {"sha": "e853b5961ec4fa4b2ef60246efa8764d33d07ed1", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -176,12 +176,12 @@ pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n     }\n }\n \n-struct ConstEvalVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct ConstEvalVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     ccache: constness_cache,\n }\n \n-impl<'a> ConstEvalVisitor<'a> {\n+impl<'a, 'tcx> ConstEvalVisitor<'a, 'tcx> {\n     fn classify(&mut self, e: &Expr) -> constness {\n         let did = ast_util::local_def(e.id);\n         match self.ccache.find(&did) {\n@@ -266,7 +266,7 @@ impl<'a> ConstEvalVisitor<'a> {\n \n }\n \n-impl<'a> Visitor<()> for ConstEvalVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for ConstEvalVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &Ty, _: ()) {\n         match t.node {\n             TyFixedLengthVec(_, expr) => {\n@@ -365,8 +365,7 @@ pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n     }\n }\n \n-pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n-                            -> Result<const_val, String> {\n+pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, String> {\n     fn fromb(b: bool) -> Result<const_val, String> { Ok(const_int(b as i64)) }\n     match e.node {\n       ExprUnary(UnNeg, ref inner) => {\n@@ -494,12 +493,11 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n         // This tends to get called w/o the type actually having been\n         // populated in the ctxt, which was causing things to blow up\n         // (#5900). Fall back to doing a limited lookup to get past it.\n-        let ety = ty::expr_ty_opt(tcx.ty_ctxt(), e)\n-                .or_else(|| astconv::ast_ty_to_prim_ty(tcx.ty_ctxt(), &**target_ty))\n+        let ety = ty::expr_ty_opt(tcx, e)\n+                .or_else(|| astconv::ast_ty_to_prim_ty(tcx, &**target_ty))\n                 .unwrap_or_else(|| {\n-                    tcx.ty_ctxt().sess.span_fatal(target_ty.span,\n-                                                  \"target type not found for \\\n-                                                   const cast\")\n+                    tcx.sess.span_fatal(target_ty.span,\n+                                        \"target type not found for const cast\")\n                 });\n \n         let base = eval_const_expr_partial(tcx, &**base);\n@@ -540,8 +538,8 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n         }\n       }\n       ExprPath(_) => {\n-          match lookup_const(tcx.ty_ctxt(), e) {\n-              Some(actual_e) => eval_const_expr_partial(tcx.ty_ctxt(), &*actual_e),\n+          match lookup_const(tcx, e) {\n+              Some(actual_e) => eval_const_expr_partial(tcx, &*actual_e),\n               None => Err(\"non-constant path in constant expr\".to_string())\n           }\n       }"}, {"sha": "c32f8db2380e428456e96553142398e8622a9962", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -32,8 +32,8 @@ use util::nodemap::NodeMap;\n pub enum EntryOrExit { Entry, Exit }\n \n #[deriving(Clone)]\n-pub struct DataFlowContext<'a, O> {\n-    tcx: &'a ty::ctxt,\n+pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n+    tcx: &'a ty::ctxt<'tcx>,\n \n     /// a name for the analysis using this dataflow instance\n     analysis_name: &'static str,\n@@ -80,8 +80,8 @@ pub trait DataFlowOperator : BitwiseOperator {\n     fn initial_value(&self) -> bool;\n }\n \n-struct PropagationContext<'a, 'b:'a, O:'a> {\n-    dfcx: &'a mut DataFlowContext<'b, O>,\n+struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O: 'a> {\n+    dfcx: &'a mut DataFlowContext<'b, 'tcx, O>,\n     changed: bool\n }\n \n@@ -92,14 +92,14 @@ fn to_cfgidx_or_die(id: ast::NodeId, index: &NodeMap<CFGIndex>) -> CFGIndex {\n     })\n }\n \n-impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n+impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     fn has_bitset_for_nodeid(&self, n: ast::NodeId) -> bool {\n         assert!(n != ast::DUMMY_NODE_ID);\n         self.nodeid_to_index.contains_key(&n)\n     }\n }\n \n-impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n+impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O> {\n     fn pre(&self,\n            ps: &mut pprust::State,\n            node: pprust::AnnNode) -> io::IoResult<()> {\n@@ -182,14 +182,14 @@ fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n     }\n }\n \n-impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n-    pub fn new(tcx: &'a ty::ctxt,\n+impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n+    pub fn new(tcx: &'a ty::ctxt<'tcx>,\n                analysis_name: &'static str,\n                decl: Option<&ast::FnDecl>,\n                cfg: &cfg::CFG,\n                oper: O,\n                id_range: IdRange,\n-               bits_per_id: uint) -> DataFlowContext<'a, O> {\n+               bits_per_id: uint) -> DataFlowContext<'a, 'tcx, O> {\n         let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n         let num_nodes = cfg.graph.all_nodes().len();\n \n@@ -427,8 +427,8 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n     }\n }\n \n-impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n-//                          ^^^^^^^^^^^^^ only needed for pretty printing\n+impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n+//                                ^^^^^^^^^^^^^ only needed for pretty printing\n     pub fn propagate(&mut self, cfg: &cfg::CFG, blk: &ast::Block) {\n         //! Performs the data flow analysis.\n \n@@ -469,7 +469,7 @@ impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n     }\n }\n \n-impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n+impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n     fn walk_cfg(&mut self,\n                 cfg: &cfg::CFG,\n                 in_out: &mut [uint]) {"}, {"sha": "b7cddd0c23f964876451b05e06c22b815d9070af", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -47,9 +47,9 @@ fn should_explore(tcx: &ty::ctxt, def_id: ast::DefId) -> bool {\n     }\n }\n \n-struct MarkSymbolVisitor<'a> {\n+struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<ast::NodeId>,\n-    tcx: &'a ty::ctxt,\n+    tcx: &'a ty::ctxt<'tcx>,\n     live_symbols: Box<HashSet<ast::NodeId>>,\n }\n \n@@ -58,9 +58,9 @@ struct MarkSymbolVisitorContext {\n     struct_has_extern_repr: bool\n }\n \n-impl<'a> MarkSymbolVisitor<'a> {\n-    fn new(tcx: &'a ty::ctxt,\n-           worklist: Vec<ast::NodeId>) -> MarkSymbolVisitor<'a> {\n+impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>,\n+           worklist: Vec<ast::NodeId>) -> MarkSymbolVisitor<'a, 'tcx> {\n         MarkSymbolVisitor {\n             worklist: worklist,\n             tcx: tcx,\n@@ -232,7 +232,7 @@ impl<'a> MarkSymbolVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<MarkSymbolVisitorContext> for MarkSymbolVisitor<'a> {\n+impl<'a, 'tcx> Visitor<MarkSymbolVisitorContext> for MarkSymbolVisitor<'a, 'tcx> {\n \n     fn visit_struct_def(&mut self, def: &ast::StructDef, _: ast::Ident, _: &ast::Generics,\n                         _: ast::NodeId, ctxt: MarkSymbolVisitorContext) {\n@@ -418,12 +418,12 @@ fn get_struct_ctor_id(item: &ast::Item) -> Option<ast::NodeId> {\n     }\n }\n \n-struct DeadVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct DeadVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     live_symbols: Box<HashSet<ast::NodeId>>,\n }\n \n-impl<'a> DeadVisitor<'a> {\n+impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     fn should_warn_about_field(&mut self, node: &ast::StructField_) -> bool {\n         let is_named = node.ident().is_some();\n         let field_type = ty::node_id_to_type(self.tcx, node.id);\n@@ -490,7 +490,7 @@ impl<'a> DeadVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for DeadVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for DeadVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         let ctor_id = get_struct_ctor_id(item);\n         if !self.symbol_is_live(item.id, ctor_id) && should_warn(item) {"}, {"sha": "ec1430edcddb9c1e02a23edcaff134eedfb34660", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -37,14 +37,14 @@ fn type_is_unsafe_function(ty: ty::t) -> bool {\n     }\n }\n \n-struct EffectCheckVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct EffectCheckVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n \n     /// Whether we're in an unsafe context.\n     unsafe_context: UnsafeContext,\n }\n \n-impl<'a> EffectCheckVisitor<'a> {\n+impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n     fn require_unsafe(&mut self, span: Span, description: &str) {\n         match self.unsafe_context {\n             SafeContext => {\n@@ -86,7 +86,7 @@ impl<'a> EffectCheckVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_fn(&mut self, fn_kind: &visit::FnKind, fn_decl: &ast::FnDecl,\n                 block: &ast::Block, span: Span, _: ast::NodeId, _:()) {\n "}, {"sha": "207620b182907b9229985313f9a998bdf3ea29f4", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -214,7 +214,7 @@ macro_rules! return_if_err(\n     )\n )\n \n-impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n+impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n     pub fn new(delegate: &'d mut Delegate,\n                typer: &'t TYPER)\n                -> ExprUseVisitor<'d,'t,TYPER> {\n@@ -246,7 +246,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n         }\n     }\n \n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+    fn tcx(&self) -> &'t ty::ctxt<'tcx> {\n         self.typer.tcx()\n     }\n "}, {"sha": "df5a6b6d2a113003dcbf2e39329bebeb67ec51f6", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -180,7 +180,7 @@ pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[freevar_entry]|\n     }\n }\n \n-pub fn get_capture_mode<T:Typer>(tcx: &T, closure_expr_id: ast::NodeId)\n-                        -> CaptureMode {\n+pub fn get_capture_mode<'tcx, T:Typer<'tcx>>(tcx: &T, closure_expr_id: ast::NodeId)\n+                                             -> CaptureMode {\n     tcx.capture_mode(closure_expr_id)\n }"}, {"sha": "25a8555565c93ae8e6e62a75ee0461431fd2ef97", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -67,11 +67,11 @@ fn type_size_is_affected_by_type_parameters(tcx: &ty::ctxt, typ: ty::t)\n     result\n }\n \n-struct IntrinsicCheckingVisitor<'a> {\n-    tcx: &'a ctxt,\n+struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ctxt<'tcx>,\n }\n \n-impl<'a> IntrinsicCheckingVisitor<'a> {\n+impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n         let intrinsic = match ty::get(ty::lookup_item_type(self.tcx, def_id).ty).sty {\n             ty::ty_bare_fn(ref bfty) => bfty.abi == RustIntrinsic,\n@@ -116,7 +116,7 @@ impl<'a> IntrinsicCheckingVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for IntrinsicCheckingVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr, (): ()) {\n         match expr.node {\n             ast::ExprPath(..) => {"}, {"sha": "e556c5a59c224696dcb3540358084453a8c0e4d0", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -50,13 +50,13 @@ use syntax::visit;\n // primitives in the stdlib are explicitly annotated to only take sendable\n // types.\n \n-pub struct Context<'a> {\n-    tcx: &'a ty::ctxt,\n+pub struct Context<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     struct_and_enum_bounds_checked: HashSet<ty::t>,\n     parameter_environments: Vec<ParameterEnvironment>,\n }\n \n-impl<'a> Visitor<()> for Context<'a> {\n+impl<'a, 'tcx> Visitor<()> for Context<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         check_expr(self, ex);\n     }\n@@ -94,11 +94,11 @@ pub fn check_crate(tcx: &ty::ctxt,\n     tcx.sess.abort_if_errors();\n }\n \n-struct EmptySubstsFolder<'a> {\n-    tcx: &'a ty::ctxt\n+struct EmptySubstsFolder<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>\n }\n-impl<'a> ty_fold::TypeFolder for EmptySubstsFolder<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for EmptySubstsFolder<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.tcx\n     }\n     fn fold_substs(&mut self, _: &subst::Substs) -> subst::Substs {"}, {"sha": "26aa51b909944cff987fa77254b257d98d59f700", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -179,7 +179,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, cx: &ty::ctxt) -> String {\n     }\n }\n \n-impl<'a> Visitor<()> for IrMaps<'a> {\n+impl<'a, 'tcx> Visitor<()> for IrMaps<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, _: ()) {\n         visit_fn(self, fk, fd, b, s, n);\n     }\n@@ -252,8 +252,8 @@ enum VarKind {\n     ImplicitRet\n }\n \n-struct IrMaps<'a> {\n-    tcx: &'a ty::ctxt,\n+struct IrMaps<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n \n     num_live_nodes: uint,\n     num_vars: uint,\n@@ -264,8 +264,8 @@ struct IrMaps<'a> {\n     lnks: Vec<LiveNodeKind>,\n }\n \n-impl<'a> IrMaps<'a> {\n-    fn new(tcx: &'a ty::ctxt) -> IrMaps<'a> {\n+impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>) -> IrMaps<'a, 'tcx> {\n         IrMaps {\n             tcx: tcx,\n             num_live_nodes: 0,\n@@ -343,7 +343,7 @@ impl<'a> IrMaps<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for Liveness<'a> {\n+impl<'a, 'tcx> Visitor<()> for Liveness<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, _: ()) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n@@ -555,8 +555,8 @@ static ACC_READ: uint = 1u;\n static ACC_WRITE: uint = 2u;\n static ACC_USE: uint = 4u;\n \n-struct Liveness<'a> {\n-    ir: &'a mut IrMaps<'a>,\n+struct Liveness<'a, 'tcx: 'a> {\n+    ir: &'a mut IrMaps<'a, 'tcx>,\n     s: Specials,\n     successors: Vec<LiveNode>,\n     users: Vec<Users>,\n@@ -570,8 +570,8 @@ struct Liveness<'a> {\n     cont_ln: NodeMap<LiveNode>\n }\n \n-impl<'a> Liveness<'a> {\n-    fn new(ir: &'a mut IrMaps<'a>, specials: Specials) -> Liveness<'a> {\n+impl<'a, 'tcx> Liveness<'a, 'tcx> {\n+    fn new(ir: &'a mut IrMaps<'a, 'tcx>, specials: Specials) -> Liveness<'a, 'tcx> {\n         let num_live_nodes = ir.num_live_nodes;\n         let num_vars = ir.num_vars;\n         Liveness {\n@@ -607,7 +607,7 @@ impl<'a> Liveness<'a> {\n \n     fn pat_bindings(&mut self,\n                     pat: &Pat,\n-                    f: |&mut Liveness<'a>, LiveNode, Variable, Span, NodeId|) {\n+                    f: |&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId|) {\n         pat_util::pat_bindings(&self.ir.tcx.def_map, pat, |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n@@ -617,7 +617,7 @@ impl<'a> Liveness<'a> {\n \n     fn arm_pats_bindings(&mut self,\n                          pats: &[Gc<Pat>],\n-                         f: |&mut Liveness<'a>, LiveNode, Variable, Span, NodeId|) {\n+                         f: |&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId|) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n         // the \"authoritative\" set of ids\n@@ -683,7 +683,7 @@ impl<'a> Liveness<'a> {\n     fn indices2(&mut self,\n                 ln: LiveNode,\n                 succ_ln: LiveNode,\n-                op: |&mut Liveness<'a>, uint, uint|) {\n+                op: |&mut Liveness<'a, 'tcx>, uint, uint|) {\n         let node_base_idx = self.idx(ln, Variable(0u));\n         let succ_base_idx = self.idx(succ_ln, Variable(0u));\n         for var_idx in range(0u, self.ir.num_vars) {\n@@ -1376,7 +1376,7 @@ impl<'a> Liveness<'a> {\n                           loop_node_id: NodeId,\n                           break_ln: LiveNode,\n                           cont_ln: LiveNode,\n-                          f: |&mut Liveness<'a>| -> R)\n+                          f: |&mut Liveness<'a, 'tcx>| -> R)\n                           -> R {\n         debug!(\"with_loop_nodes: {} {}\", loop_node_id, break_ln.get());\n         self.loop_scope.push(loop_node_id);\n@@ -1465,7 +1465,7 @@ fn check_fn(_v: &Liveness,\n     // do not check contents of nested fns\n }\n \n-impl<'a> Liveness<'a> {\n+impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_ret(&self,\n                  id: NodeId,\n                  sp: Span,"}, {"sha": "abed04c8f33acf7cf90f98d4dc151af9521822b2", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -264,8 +264,8 @@ pub type McResult<T> = Result<T, ()>;\n  * know that no errors have occurred, so we simply consult the tcx and we\n  * can be sure that only `Ok` results will occur.\n  */\n-pub trait Typer {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n+pub trait Typer<'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n     fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t>;\n     fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t>;\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>>;\n@@ -375,12 +375,12 @@ macro_rules! if_ok(\n     )\n )\n \n-impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n+impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn new(typer: &'t TYPER) -> MemCategorizationContext<'t,TYPER> {\n         MemCategorizationContext { typer: typer }\n     }\n \n-    fn tcx(&self) -> &'t ty::ctxt {\n+    fn tcx(&self) -> &'t ty::ctxt<'tcx> {\n         self.typer.tcx()\n     }\n "}, {"sha": "6017444267a4f2b7583962b05c162e0b60ebfab6", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -133,8 +133,8 @@ impl Visitor<()> for ParentVisitor {\n /// The embargo visitor, used to determine the exports of the ast\n ////////////////////////////////////////////////////////////////////////////////\n \n-struct EmbargoVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct EmbargoVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     exp_map2: &'a resolve::ExportMap2,\n \n     // This flag is an indicator of whether the previous item in the\n@@ -163,7 +163,7 @@ struct EmbargoVisitor<'a> {\n     prev_public: bool,\n }\n \n-impl<'a> EmbargoVisitor<'a> {\n+impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     // There are checks inside of privacy which depend on knowing whether a\n     // trait should be exported or not. The two current consumers of this are:\n     //\n@@ -180,7 +180,7 @@ impl<'a> EmbargoVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for EmbargoVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         let orig_all_pub = self.prev_public;\n         self.prev_public = orig_all_pub && item.vis == ast::Public;\n@@ -355,8 +355,8 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n /// The privacy visitor, where privacy checks take place (violations reported)\n ////////////////////////////////////////////////////////////////////////////////\n \n-struct PrivacyVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct PrivacyVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     curitem: ast::NodeId,\n     in_foreign: bool,\n     parents: NodeMap<ast::NodeId>,\n@@ -376,7 +376,7 @@ enum FieldName {\n     NamedField(ast::Ident),\n }\n \n-impl<'a> PrivacyVisitor<'a> {\n+impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     // used when debugging\n     fn nodestr(&self, id: ast::NodeId) -> String {\n         self.tcx.map.node_to_string(id).to_string()\n@@ -802,7 +802,7 @@ impl<'a> PrivacyVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for PrivacyVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         let orig_curitem = replace(&mut self.curitem, item.id);\n         visit::walk_item(self, item, ());\n@@ -1023,12 +1023,12 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n /// The privacy sanity check visitor, ensures unnecessary visibility isn't here\n ////////////////////////////////////////////////////////////////////////////////\n \n-struct SanePrivacyVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct SanePrivacyVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     in_fn: bool,\n }\n \n-impl<'a> Visitor<()> for SanePrivacyVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for SanePrivacyVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         if self.in_fn {\n             self.check_all_inherited(item);\n@@ -1076,7 +1076,7 @@ impl<'a> Visitor<()> for SanePrivacyVisitor<'a> {\n     }\n }\n \n-impl<'a> SanePrivacyVisitor<'a> {\n+impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n     /// Validates all of the visibility qualifiers placed on the item given. This\n     /// ensures that there are no extraneous qualifiers that don't actually do\n     /// anything. In theory these qualifiers wouldn't parse, but that may happen\n@@ -1215,14 +1215,14 @@ impl<'a> SanePrivacyVisitor<'a> {\n     }\n }\n \n-struct VisiblePrivateTypesVisitor<'a> {\n-    tcx: &'a ty::ctxt,\n+struct VisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     exported_items: &'a ExportedItems,\n     public_items: &'a PublicItems,\n }\n \n-struct CheckTypeForPrivatenessVisitor<'a, 'b:'a> {\n-    inner: &'a VisiblePrivateTypesVisitor<'b>,\n+struct CheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n+    inner: &'a VisiblePrivateTypesVisitor<'b, 'tcx>,\n     /// whether the type refers to private types.\n     contains_private: bool,\n     /// whether we've recurred at all (i.e. if we're pointing at the\n@@ -1232,7 +1232,7 @@ struct CheckTypeForPrivatenessVisitor<'a, 'b:'a> {\n     outer_type_is_public_path: bool,\n }\n \n-impl<'a> VisiblePrivateTypesVisitor<'a> {\n+impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n         let did = match self.tcx.def_map.borrow().find_copy(&path_id) {\n             // `int` etc. (None doesn't seem to occur.)\n@@ -1256,7 +1256,7 @@ impl<'a> VisiblePrivateTypesVisitor<'a> {\n     }\n }\n \n-impl<'a, 'b> Visitor<()> for CheckTypeForPrivatenessVisitor<'a, 'b> {\n+impl<'a, 'b, 'tcx> Visitor<()> for CheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n     fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n         match ty.node {\n             ast::TyPath(_, _, path_id) => {\n@@ -1279,7 +1279,7 @@ impl<'a, 'b> Visitor<()> for CheckTypeForPrivatenessVisitor<'a, 'b> {\n     fn visit_expr(&mut self, _: &ast::Expr, _: ()) {}\n }\n \n-impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         match item.node {\n             // contents of a private mod can be reexported, so we need"}, {"sha": "7ba5144985ef206a3e40ab9a156a0b2263632d00", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -89,9 +89,9 @@ fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n }\n \n // Information needed while computing reachability.\n-struct ReachableContext<'a> {\n+struct ReachableContext<'a, 'tcx: 'a> {\n     // The type context.\n-    tcx: &'a ty::ctxt,\n+    tcx: &'a ty::ctxt<'tcx>,\n     // The set of items which must be exported in the linkage sense.\n     reachable_symbols: NodeSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n@@ -101,7 +101,7 @@ struct ReachableContext<'a> {\n     any_library: bool,\n }\n \n-impl<'a> Visitor<()> for ReachableContext<'a> {\n+impl<'a, 'tcx> Visitor<()> for ReachableContext<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n \n@@ -164,9 +164,9 @@ impl<'a> Visitor<()> for ReachableContext<'a> {\n     }\n }\n \n-impl<'a> ReachableContext<'a> {\n+impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Creates a new reachability computation context.\n-    fn new(tcx: &'a ty::ctxt) -> ReachableContext<'a> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>) -> ReachableContext<'a, 'tcx> {\n         let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n             *ty != config::CrateTypeExecutable\n         });"}, {"sha": "7c7960e0918f46fb1213cc39b77ddb792258e4d4", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -74,9 +74,9 @@ fn generated_code(span: Span) -> bool {\n     span.expn_info.is_some() || span  == DUMMY_SP\n }\n \n-struct DxrVisitor<'l> {\n+struct DxrVisitor<'l, 'tcx: 'l> {\n     sess: &'l Session,\n-    analysis: &'l CrateAnalysis,\n+    analysis: &'l CrateAnalysis<'tcx>,\n \n     collected_paths: Vec<(NodeId, ast::Path, bool, recorder::Row)>,\n     collecting: bool,\n@@ -85,7 +85,7 @@ struct DxrVisitor<'l> {\n     fmt: FmtStrs<'l>,\n }\n \n-impl <'l> DxrVisitor<'l> {\n+impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n         // the current crate\n         self.fmt.crate_str(krate.span, name);\n@@ -1023,7 +1023,7 @@ impl <'l> DxrVisitor<'l> {\n     }\n }\n \n-impl<'l> Visitor<DxrVisitorEnv> for DxrVisitor<'l> {\n+impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n     fn visit_item(&mut self, item:&ast::Item, e: DxrVisitorEnv) {\n         if generated_code(item.span) {\n             return"}, {"sha": "c1c23dff98406b5bee865610afdaaa155ba850ee", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -548,8 +548,8 @@ impl<T:TypeFoldable> Subst for T {\n ///////////////////////////////////////////////////////////////////////////\n // The actual substitution engine itself is a type folder.\n \n-struct SubstFolder<'a> {\n-    tcx: &'a ty::ctxt,\n+struct SubstFolder<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     substs: &'a Substs,\n \n     // The location for which the substitution is performed, if available.\n@@ -562,8 +562,8 @@ struct SubstFolder<'a> {\n     ty_stack_depth: uint,\n }\n \n-impl<'a> TypeFolder for SubstFolder<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n+impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         // Note: This routine only handles regions that are bound on"}, {"sha": "dc1be08e4444c4662f139e0e87e4232ebd8d6d1b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -137,15 +137,16 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     _InsnCtxt { _cannot_construct_outside_of_this_module: () }\n }\n \n-pub struct StatRecorder<'a> {\n-    ccx: &'a CrateContext<'a>,\n+pub struct StatRecorder<'a, 'tcx: 'a> {\n+    ccx: &'a CrateContext<'a, 'tcx>,\n     name: Option<String>,\n     start: u64,\n     istart: uint,\n }\n \n-impl<'a> StatRecorder<'a> {\n-    pub fn new(ccx: &'a CrateContext, name: String) -> StatRecorder<'a> {\n+impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n+    pub fn new(ccx: &'a CrateContext<'a, 'tcx>, name: String)\n+               -> StatRecorder<'a, 'tcx> {\n         let start = if ccx.sess().trans_stats() {\n             time::precise_time_ns()\n         } else {\n@@ -162,7 +163,7 @@ impl<'a> StatRecorder<'a> {\n }\n \n #[unsafe_destructor]\n-impl<'a> Drop for StatRecorder<'a> {\n+impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     fn drop(&mut self) {\n         if self.ccx.sess().trans_stats() {\n             let end = time::precise_time_ns();\n@@ -2142,11 +2143,11 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n     }\n }\n \n-pub struct TransItemVisitor<'a> {\n-    pub ccx: &'a CrateContext<'a>,\n+pub struct TransItemVisitor<'a, 'tcx: 'a> {\n+    pub ccx: &'a CrateContext<'a, 'tcx>,\n }\n \n-impl<'a> Visitor<()> for TransItemVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for TransItemVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item, _:()) {\n         trans_item(self.ccx, i);\n     }\n@@ -2911,20 +2912,20 @@ pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r SharedCrateContext,\n-                                      ie: encoder::EncodeInlinedItem<'r>)\n-    -> encoder::EncodeParams<'r> {\n-        encoder::EncodeParams {\n-            diag: cx.sess().diagnostic(),\n-            tcx: cx.tcx(),\n-            reexports2: cx.exp_map2(),\n-            item_symbols: cx.item_symbols(),\n-            non_inlineable_statics: cx.non_inlineable_statics(),\n-            link_meta: cx.link_meta(),\n-            cstore: &cx.sess().cstore,\n-            encode_inlined_item: ie,\n-            reachable: cx.reachable(),\n-        }\n+pub fn crate_ctxt_to_encode_parms<'a, 'tcx>(cx: &'a SharedCrateContext<'tcx>,\n+                                            ie: encoder::EncodeInlinedItem<'a>)\n+                                            -> encoder::EncodeParams<'a, 'tcx> {\n+    encoder::EncodeParams {\n+        diag: cx.sess().diagnostic(),\n+        tcx: cx.tcx(),\n+        reexports2: cx.exp_map2(),\n+        item_symbols: cx.item_symbols(),\n+        non_inlineable_statics: cx.non_inlineable_statics(),\n+        link_meta: cx.link_meta(),\n+        cstore: &cx.sess().cstore,\n+        encode_inlined_item: ie,\n+        reachable: cx.reachable(),\n+    }\n }\n \n pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {"}, {"sha": "95f6118908e07dbb749ad51bb65d097844df507b", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -34,7 +34,7 @@ pub fn check_not_terminated(cx: &Block) {\n     }\n }\n \n-pub fn B<'a>(cx: &'a Block) -> Builder<'a> {\n+pub fn B<'b, 'tcx>(cx: &'b Block<'b, 'tcx>) -> Builder<'b, 'tcx> {\n     let b = cx.fcx.ccx.builder();\n     b.position_at_end(cx.llbb);\n     b"}, {"sha": "ca7adb97f3d5453a4b0229e6fc866f619c008f48", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -23,9 +23,9 @@ use libc::{c_uint, c_ulonglong, c_char};\n use std::string::String;\n use syntax::codemap::Span;\n \n-pub struct Builder<'a> {\n+pub struct Builder<'a, 'tcx: 'a> {\n     pub llbuilder: BuilderRef,\n-    pub ccx: &'a CrateContext<'a>,\n+    pub ccx: &'a CrateContext<'a, 'tcx>,\n }\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n@@ -35,8 +35,8 @@ pub fn noname() -> *const c_char {\n     &cnull as *const c_char\n }\n \n-impl<'a> Builder<'a> {\n-    pub fn new(ccx: &'a CrateContext) -> Builder<'a> {\n+impl<'a, 'tcx> Builder<'a, 'tcx> {\n+    pub fn new(ccx: &'a CrateContext<'a, 'tcx>) -> Builder<'a, 'tcx> {\n         Builder {\n             llbuilder: ccx.raw_builder(),\n             ccx: ccx,"}, {"sha": "4d62386260bf9c7773aa8fe7be679d19be5fa4fb", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -233,7 +233,7 @@ pub type LvalueDatum = datum::Datum<datum::Lvalue>;\n \n // Function context.  Every LLVM function we create will have one of\n // these.\n-pub struct FunctionContext<'a> {\n+pub struct FunctionContext<'a, 'tcx: 'a> {\n     // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n     // address of the first instruction in the sequence of\n     // instructions for this function that will go in the .text\n@@ -297,7 +297,7 @@ pub struct FunctionContext<'a> {\n     pub block_arena: &'a TypedArena<Block<'a>>,\n \n     // This function's enclosing crate context.\n-    pub ccx: &'a CrateContext<'a>,\n+    pub ccx: &'a CrateContext<'a, 'tcx>,\n \n     // Used and maintained by the debuginfo module.\n     pub debug_context: debuginfo::FunctionDebugContext,\n@@ -306,7 +306,7 @@ pub struct FunctionContext<'a> {\n     pub scopes: RefCell<Vec<cleanup::CleanupScope<'a>> >,\n }\n \n-impl<'a> FunctionContext<'a> {\n+impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     pub fn arg_pos(&self, arg: uint) -> uint {\n         let arg = self.env_arg_pos() + arg;\n         if self.llenv.is_some() {\n@@ -410,7 +410,7 @@ impl<'a> FunctionContext<'a> {\n // code.  Each basic block we generate is attached to a function, typically\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n-pub struct Block<'a> {\n+pub struct Block<'a, 'tcx> {\n     // The BasicBlockRef returned from a call to\n     // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n     // block to the function pointed to by llfn.  We insert\n@@ -429,16 +429,15 @@ pub struct Block<'a> {\n \n     // The function context for the function to which this block is\n     // attached.\n-    pub fcx: &'a FunctionContext<'a>,\n+    pub fcx: &'a FunctionContext<'a, 'tcx>,\n }\n \n-impl<'a> Block<'a> {\n-    pub fn new<'a>(\n-               llbb: BasicBlockRef,\n+impl<'a, 'tcx> Block<'a, 'tcx> {\n+    pub fn new(llbb: BasicBlockRef,\n                is_lpad: bool,\n                opt_node_id: Option<ast::NodeId>,\n-               fcx: &'a FunctionContext<'a>)\n-               -> &'a Block<'a> {\n+               fcx: &'a FunctionContext<'a, 'tcx>)\n+               -> &'a Block<'a, 'tcx> {\n         fcx.block_arena.alloc(Block {\n             llbb: llbb,\n             terminated: Cell::new(false),\n@@ -449,8 +448,8 @@ impl<'a> Block<'a> {\n         })\n     }\n \n-    pub fn ccx(&self) -> &'a CrateContext<'a> { self.fcx.ccx }\n-    pub fn tcx(&self) -> &'a ty::ctxt {\n+    pub fn ccx(&self) -> &'a CrateContext<'a, 'tcx> { self.fcx.ccx }\n+    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n         self.fcx.ccx.tcx()\n     }\n     pub fn sess(&self) -> &'a Session { self.fcx.ccx.sess() }\n@@ -495,8 +494,8 @@ impl<'a> Block<'a> {\n     }\n }\n \n-impl<'a> mc::Typer for Block<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+impl<'blk, 'tcx> mc::Typer<'tcx> for Block<'blk, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.tcx()\n     }\n \n@@ -535,13 +534,13 @@ impl<'a> mc::Typer for Block<'a> {\n     }\n }\n \n-pub struct Result<'a> {\n-    pub bcx: &'a Block<'a>,\n+pub struct Result<'blk, 'tcx: 'blk> {\n+    pub bcx: &'blk Block<'blk, 'tcx>,\n     pub val: ValueRef\n }\n \n-impl<'a> Result<'a> {\n-    pub fn new(bcx: &'a Block<'a>, val: ValueRef) -> Result<'a> {\n+impl<'b, 'tcx> Result<'b, 'tcx> {\n+    pub fn new(bcx: &'b Block<'b, 'tcx>, val: ValueRef) -> Result<'b, 'tcx> {\n         Result {\n             bcx: bcx,\n             val: val,\n@@ -746,11 +745,11 @@ pub fn is_null(val: ValueRef) -> bool {\n     }\n }\n \n-pub fn monomorphize_type(bcx: &Block, t: ty::t) -> ty::t {\n+pub fn monomorphize_type(bcx: Block, t: ty::t) -> ty::t {\n     t.subst(bcx.tcx(), &bcx.fcx.param_substs.substs)\n }\n \n-pub fn node_id_type(bcx: &Block, id: ast::NodeId) -> ty::t {\n+pub fn node_id_type(bcx: Block, id: ast::NodeId) -> ty::t {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n     monomorphize_type(bcx, t)"}, {"sha": "3b4b50c7e85acecb95df1e3b595a8f696204ba39", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -55,7 +55,7 @@ pub struct Stats {\n /// per crate.  The data here is shared between all compilation units of the\n /// crate, so it must not contain references to any LLVM data structures\n /// (aside from metadata-related ones).\n-pub struct SharedCrateContext {\n+pub struct SharedCrateContext<'tcx> {\n     local_ccxs: Vec<LocalCrateContext>,\n \n     metadata_llmod: ModuleRef,\n@@ -70,7 +70,7 @@ pub struct SharedCrateContext {\n     /// that is generated\n     non_inlineable_statics: RefCell<NodeSet>,\n     symbol_hasher: RefCell<Sha256>,\n-    tcx: ty::ctxt,\n+    tcx: ty::ctxt<'tcx>,\n     stats: Stats,\n \n     available_monomorphizations: RefCell<HashSet<String>>,\n@@ -152,21 +152,21 @@ pub struct LocalCrateContext {\n     n_llvm_insns: Cell<uint>,\n }\n \n-pub struct CrateContext<'a> {\n-    shared: &'a SharedCrateContext,\n+pub struct CrateContext<'a, 'tcx: 'a> {\n+    shared: &'a SharedCrateContext<'tcx>,\n     local: &'a LocalCrateContext,\n     /// The index of `local` in `shared.local_ccxs`.  This is used in\n     /// `maybe_iter(true)` to identify the original `LocalCrateContext`.\n     index: uint,\n }\n \n-pub struct CrateContextIterator<'a> {\n-    shared: &'a SharedCrateContext,\n+pub struct CrateContextIterator<'a, 'tcx: 'a> {\n+    shared: &'a SharedCrateContext<'tcx>,\n     index: uint,\n }\n \n-impl<'a> Iterator<CrateContext<'a>> for CrateContextIterator<'a> {\n-    fn next(&mut self) -> Option<CrateContext<'a>> {\n+impl<'a, 'tcx> Iterator<CrateContext<'a, 'tcx>> for CrateContextIterator<'a,'tcx> {\n+    fn next(&mut self) -> Option<CrateContext<'a, 'tcx>> {\n         if self.index >= self.shared.local_ccxs.len() {\n             return None;\n         }\n@@ -183,15 +183,15 @@ impl<'a> Iterator<CrateContext<'a>> for CrateContextIterator<'a> {\n }\n \n /// The iterator produced by `CrateContext::maybe_iter`.\n-pub struct CrateContextMaybeIterator<'a> {\n-    shared: &'a SharedCrateContext,\n+pub struct CrateContextMaybeIterator<'a, 'tcx: 'a> {\n+    shared: &'a SharedCrateContext<'tcx>,\n     index: uint,\n     single: bool,\n     origin: uint,\n }\n \n-impl<'a> Iterator<(CrateContext<'a>, bool)> for CrateContextMaybeIterator<'a> {\n-    fn next(&mut self) -> Option<(CrateContext<'a>, bool)> {\n+impl<'a, 'tcx> Iterator<(CrateContext<'a, 'tcx>, bool)> for CrateContextMaybeIterator<'a, 'tcx> {\n+    fn next(&mut self) -> Option<(CrateContext<'a, 'tcx>, bool)> {\n         if self.index >= self.shared.local_ccxs.len() {\n             return None;\n         }\n@@ -234,15 +234,15 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n     (llcx, llmod)\n }\n \n-impl SharedCrateContext {\n+impl<'tcx> SharedCrateContext<'tcx> {\n     pub fn new(crate_name: &str,\n                local_count: uint,\n-               tcx: ty::ctxt,\n+               tcx: ty::ctxt<'tcx>,\n                emap2: resolve::ExportMap2,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n                reachable: NodeSet)\n-               -> SharedCrateContext {\n+               -> SharedCrateContext<'tcx> {\n         let (metadata_llcx, metadata_llmod) = unsafe {\n             create_context_and_module(&tcx.sess, \"metadata\")\n         };\n@@ -293,22 +293,22 @@ impl SharedCrateContext {\n         shared_ccx\n     }\n \n-    pub fn iter<'a>(&'a self) -> CrateContextIterator<'a> {\n+    pub fn iter<'a>(&'a self) -> CrateContextIterator<'a, 'tcx> {\n         CrateContextIterator {\n             shared: self,\n             index: 0,\n         }\n     }\n \n-    pub fn get_ccx<'a>(&'a self, index: uint) -> CrateContext<'a> {\n+    pub fn get_ccx<'a>(&'a self, index: uint) -> CrateContext<'a, 'tcx> {\n         CrateContext {\n             shared: self,\n             local: &self.local_ccxs[index],\n             index: index,\n         }\n     }\n \n-    fn get_smallest_ccx<'a>(&'a self) -> CrateContext<'a> {\n+    fn get_smallest_ccx<'a>(&'a self) -> CrateContext<'a, 'tcx> {\n         let (local_ccx, index) =\n             self.local_ccxs\n                 .iter()\n@@ -355,11 +355,11 @@ impl SharedCrateContext {\n         &self.symbol_hasher\n     }\n \n-    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         &self.tcx\n     }\n \n-    pub fn take_tcx(self) -> ty::ctxt {\n+    pub fn take_tcx(self) -> ty::ctxt<'tcx> {\n         self.tcx\n     }\n \n@@ -459,7 +459,8 @@ impl LocalCrateContext {\n     /// This is used in the `LocalCrateContext` constructor to allow calling\n     /// functions that expect a complete `CrateContext`, even before the local\n     /// portion is fully initialized and attached to the `SharedCrateContext`.\n-    fn dummy_ccx<'a>(&'a self, shared: &'a SharedCrateContext) -> CrateContext<'a> {\n+    fn dummy_ccx<'a, 'tcx>(&'a self, shared: &'a SharedCrateContext<'tcx>)\n+                           -> CrateContext<'a, 'tcx> {\n         CrateContext {\n             shared: shared,\n             local: self,\n@@ -468,8 +469,8 @@ impl LocalCrateContext {\n     }\n }\n \n-impl<'b> CrateContext<'b> {\n-    pub fn shared(&self) -> &'b SharedCrateContext {\n+impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n+    pub fn shared(&self) -> &'b SharedCrateContext<'tcx> {\n         self.shared\n     }\n \n@@ -480,7 +481,7 @@ impl<'b> CrateContext<'b> {\n \n     /// Get a (possibly) different `CrateContext` from the same\n     /// `SharedCrateContext`.\n-    pub fn rotate(&self) -> CrateContext<'b> {\n+    pub fn rotate(&self) -> CrateContext<'b, 'tcx> {\n         self.shared.get_smallest_ccx()\n     }\n \n@@ -490,7 +491,7 @@ impl<'b> CrateContext<'b> {\n     /// otherwise.  This method is useful for avoiding code duplication in\n     /// cases where it may or may not be necessary to translate code into every\n     /// context.\n-    pub fn maybe_iter(&self, iter_all: bool) -> CrateContextMaybeIterator<'b> {\n+    pub fn maybe_iter(&self, iter_all: bool) -> CrateContextMaybeIterator<'b, 'tcx> {\n         CrateContextMaybeIterator {\n             shared: self.shared,\n             index: if iter_all { 0 } else { self.index },\n@@ -500,15 +501,15 @@ impl<'b> CrateContext<'b> {\n     }\n \n \n-    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         &self.shared.tcx\n     }\n \n     pub fn sess<'a>(&'a self) -> &'a Session {\n         &self.shared.tcx.sess\n     }\n \n-    pub fn builder<'a>(&'a self) -> Builder<'a> {\n+    pub fn builder<'a>(&'a self) -> Builder<'a, 'tcx> {\n         Builder::new(self)\n     }\n "}, {"sha": "feed76233d68aaf1b2e384e85d1a2d62119c37c1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 40, "deletions": 55, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -3468,10 +3468,10 @@ impl AutoRef {\n     }\n }\n \n-pub fn method_call_type_param_defs<T>(typer: &T,\n-                                      origin: typeck::MethodOrigin)\n-                                      -> VecPerParamSpace<TypeParameterDef>\n-                                      where T: mc::Typer {\n+pub fn method_call_type_param_defs<'tcx, T>(typer: &T,\n+                                            origin: typeck::MethodOrigin)\n+                                            -> VecPerParamSpace<TypeParameterDef>\n+                                            where T: mc::Typer<'tcx> {\n     match origin {\n         typeck::MethodStatic(did) => {\n             ty::lookup_item_type(typer.tcx(), did).generics.types.clone()\n@@ -4660,10 +4660,10 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n     let u = TypeNormalizer(cx).fold_ty(t);\n     return u;\n \n-    struct TypeNormalizer<'a>(&'a ctxt);\n+    struct TypeNormalizer<'a, 'tcx: 'a>(&'a ctxt<'tcx>);\n \n-    impl<'a> TypeFolder for TypeNormalizer<'a> {\n-        fn tcx<'a>(&'a self) -> &'a ctxt { let TypeNormalizer(c) = *self; c }\n+    impl<'a, 'tcx> TypeFolder<'tcx> for TypeNormalizer<'a, 'tcx> {\n+        fn tcx<'a>(&'a self) -> &'a ctxt<'tcx> { let TypeNormalizer(c) = *self; c }\n \n         fn fold_ty(&mut self, t: ty::t) -> ty::t {\n             match self.tcx().normalized_cache.borrow().find_copy(&t) {\n@@ -4702,70 +4702,55 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n     }\n }\n \n-pub trait ExprTyProvider {\n-    fn expr_ty(&self, ex: &ast::Expr) -> t;\n-    fn ty_ctxt<'a>(&'a self) -> &'a ctxt;\n-}\n-\n-impl ExprTyProvider for ctxt {\n-    fn expr_ty(&self, ex: &ast::Expr) -> t {\n-        expr_ty(self, ex)\n-    }\n-\n-    fn ty_ctxt<'a>(&'a self) -> &'a ctxt {\n-        self\n-    }\n-}\n-\n // Returns the repeat count for a repeating vector expression.\n-pub fn eval_repeat_count<T: ExprTyProvider>(tcx: &T, count_expr: &ast::Expr) -> uint {\n+pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n     match const_eval::eval_const_expr_partial(tcx, count_expr) {\n       Ok(ref const_val) => match *const_val {\n         const_eval::const_int(count) => if count < 0 {\n-            tcx.ty_ctxt().sess.span_err(count_expr.span,\n-                                        \"expected positive integer for \\\n-                                         repeat count, found negative integer\");\n-            return 0;\n+            tcx.sess.span_err(count_expr.span,\n+                              \"expected positive integer for \\\n+                               repeat count, found negative integer\");\n+            0\n         } else {\n-            return count as uint\n+            count as uint\n         },\n-        const_eval::const_uint(count) => return count as uint,\n+        const_eval::const_uint(count) => count as uint,\n         const_eval::const_float(count) => {\n-            tcx.ty_ctxt().sess.span_err(count_expr.span,\n-                                        \"expected positive integer for \\\n-                                         repeat count, found float\");\n-            return count as uint;\n+            tcx.sess.span_err(count_expr.span,\n+                              \"expected positive integer for \\\n+                               repeat count, found float\");\n+            count as uint\n         }\n         const_eval::const_str(_) => {\n-            tcx.ty_ctxt().sess.span_err(count_expr.span,\n-                                        \"expected positive integer for \\\n-                                         repeat count, found string\");\n-            return 0;\n+            tcx.sess.span_err(count_expr.span,\n+                              \"expected positive integer for \\\n+                               repeat count, found string\");\n+            0\n         }\n         const_eval::const_bool(_) => {\n-            tcx.ty_ctxt().sess.span_err(count_expr.span,\n-                                        \"expected positive integer for \\\n-                                         repeat count, found boolean\");\n-            return 0;\n+            tcx.sess.span_err(count_expr.span,\n+                              \"expected positive integer for \\\n+                               repeat count, found boolean\");\n+            0\n         }\n         const_eval::const_binary(_) => {\n-            tcx.ty_ctxt().sess.span_err(count_expr.span,\n-                                        \"expected positive integer for \\\n-                                         repeat count, found binary array\");\n-            return 0;\n+            tcx.sess.span_err(count_expr.span,\n+                              \"expected positive integer for \\\n+                               repeat count, found binary array\");\n+            0\n         }\n         const_eval::const_nil => {\n-            tcx.ty_ctxt().sess.span_err(count_expr.span,\n-                                        \"expected positive integer for \\\n-                                         repeat count, found ()\");\n-            return 0;\n+            tcx.sess.span_err(count_expr.span,\n+                              \"expected positive integer for \\\n+                               repeat count, found ()\");\n+            0\n         }\n       },\n       Err(..) => {\n-        tcx.ty_ctxt().sess.span_err(count_expr.span,\n-                                    \"expected constant integer for repeat count, \\\n-                                     found variable\");\n-        return 0;\n+        tcx.sess.span_err(count_expr.span,\n+                          \"expected constant integer for repeat count, \\\n+                           found variable\");\n+        0\n       }\n     }\n }\n@@ -5402,8 +5387,8 @@ impl BorrowKind {\n     }\n }\n \n-impl mc::Typer for ty::ctxt {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self\n     }\n "}, {"sha": "bc53568694df632c4fbf1bee8f5711363df34346", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 75, "deletions": 77, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -25,16 +25,16 @@ use util::ppaux::Repr;\n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n pub trait TypeFoldable {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> Self;\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n }\n \n /// The TypeFolder trait defines the actual *folding*. There is a\n /// method defined for every foldable type. Each of these has a\n /// default implementation that does an \"identity\" fold. Within each\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n /// sub-item.\n-pub trait TypeFolder {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n+pub trait TypeFolder<'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n \n     fn fold_ty(&mut self, t: ty::t) -> ty::t {\n         super_fold_ty(self, t)\n@@ -111,111 +111,111 @@ pub trait TypeFolder {\n // needed.\n \n impl<T:TypeFoldable> TypeFoldable for Option<T> {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> Option<T> {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Option<T> {\n         self.as_ref().map(|t| t.fold_with(folder))\n     }\n }\n \n impl<T:TypeFoldable> TypeFoldable for Rc<T> {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> Rc<T> {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n         Rc::new((**self).fold_with(folder))\n     }\n }\n \n impl<T:TypeFoldable> TypeFoldable for Vec<T> {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> Vec<T> {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Vec<T> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n }\n \n impl<T:TypeFoldable> TypeFoldable for OwnedSlice<T> {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> OwnedSlice<T> {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> OwnedSlice<T> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n }\n \n impl<T:TypeFoldable> TypeFoldable for VecPerParamSpace<T> {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> VecPerParamSpace<T> {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> VecPerParamSpace<T> {\n         self.map(|t| t.fold_with(folder))\n     }\n }\n \n impl TypeFoldable for ty::TraitStore {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::TraitStore {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitStore {\n         folder.fold_trait_store(*self)\n     }\n }\n \n impl TypeFoldable for ty::t {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::t {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::t {\n         folder.fold_ty(*self)\n     }\n }\n \n impl TypeFoldable for ty::BareFnTy {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::BareFnTy {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::BareFnTy {\n         folder.fold_bare_fn_ty(self)\n     }\n }\n \n impl TypeFoldable for ty::ClosureTy {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::ClosureTy {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureTy {\n         folder.fold_closure_ty(self)\n     }\n }\n \n impl TypeFoldable for ty::mt {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::mt {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::mt {\n         folder.fold_mt(self)\n     }\n }\n \n impl TypeFoldable for ty::FnSig {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::FnSig {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig {\n         folder.fold_sig(self)\n     }\n }\n \n impl TypeFoldable for ty::sty {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::sty {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::sty {\n         folder.fold_sty(self)\n     }\n }\n \n impl TypeFoldable for ty::TraitRef {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::TraitRef {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef {\n         folder.fold_trait_ref(self)\n     }\n }\n \n impl TypeFoldable for ty::Region {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::Region {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Region {\n         folder.fold_region(*self)\n     }\n }\n \n impl TypeFoldable for subst::Substs {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> subst::Substs {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> subst::Substs {\n         folder.fold_substs(self)\n     }\n }\n \n impl TypeFoldable for ty::ItemSubsts {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::ItemSubsts {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ItemSubsts {\n         ty::ItemSubsts {\n             substs: self.substs.fold_with(folder),\n         }\n     }\n }\n \n impl TypeFoldable for ty::AutoRef {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::AutoRef {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::AutoRef {\n         folder.fold_autoref(self)\n     }\n }\n \n impl TypeFoldable for typeck::vtable_origin {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> typeck::vtable_origin {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> typeck::vtable_origin {\n         match *self {\n             typeck::vtable_static(def_id, ref substs, ref origins) => {\n                 let r_substs = substs.fold_with(folder);\n@@ -236,19 +236,19 @@ impl TypeFoldable for typeck::vtable_origin {\n }\n \n impl TypeFoldable for ty::BuiltinBounds {\n-    fn fold_with<F:TypeFolder>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n         *self\n     }\n }\n \n impl TypeFoldable for ty::ExistentialBounds {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::ExistentialBounds {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ExistentialBounds {\n         folder.fold_existential_bounds(*self)\n     }\n }\n \n impl TypeFoldable for ty::ParamBounds {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::ParamBounds {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ParamBounds {\n         ty::ParamBounds {\n             opt_region_bound: self.opt_region_bound.fold_with(folder),\n             builtin_bounds: self.builtin_bounds.fold_with(folder),\n@@ -258,7 +258,7 @@ impl TypeFoldable for ty::ParamBounds {\n }\n \n impl TypeFoldable for ty::TypeParameterDef {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::TypeParameterDef {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeParameterDef {\n         ty::TypeParameterDef {\n             ident: self.ident,\n             def_id: self.def_id,\n@@ -271,7 +271,7 @@ impl TypeFoldable for ty::TypeParameterDef {\n }\n \n impl TypeFoldable for ty::RegionParameterDef {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::RegionParameterDef {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::RegionParameterDef {\n         ty::RegionParameterDef {\n             name: self.name,\n             def_id: self.def_id,\n@@ -283,7 +283,7 @@ impl TypeFoldable for ty::RegionParameterDef {\n }\n \n impl TypeFoldable for ty::Generics {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::Generics {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Generics {\n         ty::Generics {\n             types: self.types.fold_with(folder),\n             regions: self.regions.fold_with(folder),\n@@ -292,7 +292,7 @@ impl TypeFoldable for ty::Generics {\n }\n \n impl TypeFoldable for ty::UnsizeKind {\n-    fn fold_with<F:TypeFolder>(&self, folder: &mut F) -> ty::UnsizeKind {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::UnsizeKind {\n         match *self {\n             ty::UnsizeLength(len) => ty::UnsizeLength(len),\n             ty::UnsizeStruct(box ref k, n) => ty::UnsizeStruct(box k.fold_with(folder), n),\n@@ -307,17 +307,16 @@ impl TypeFoldable for ty::UnsizeKind {\n // \"super\" routines: these are the default implementations for TypeFolder.\n //\n // They should invoke `foo.fold_with()` to do recursive folding.\n-\n-pub fn super_fold_ty<T:TypeFolder>(this: &mut T,\n-                                   t: ty::t)\n-                                   -> ty::t {\n+pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                t: ty::t)\n+                                                -> ty::t {\n     let sty = ty::get(t).sty.fold_with(this);\n     ty::mk_t(this.tcx(), sty)\n }\n \n-pub fn super_fold_substs<T:TypeFolder>(this: &mut T,\n-                                       substs: &subst::Substs)\n-                                       -> subst::Substs {\n+pub fn super_fold_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                    substs: &subst::Substs)\n+                                                    -> subst::Substs {\n     let regions = match substs.regions {\n         subst::ErasedRegions => {\n             subst::ErasedRegions\n@@ -331,27 +330,27 @@ pub fn super_fold_substs<T:TypeFolder>(this: &mut T,\n                     types: substs.types.fold_with(this) }\n }\n \n-pub fn super_fold_sig<T:TypeFolder>(this: &mut T,\n-                                    sig: &ty::FnSig)\n-                                    -> ty::FnSig {\n+pub fn super_fold_sig<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                 sig: &ty::FnSig)\n+                                                 -> ty::FnSig {\n     ty::FnSig { binder_id: sig.binder_id,\n                 inputs: sig.inputs.fold_with(this),\n                 output: sig.output.fold_with(this),\n                 variadic: sig.variadic }\n }\n \n-pub fn super_fold_bare_fn_ty<T:TypeFolder>(this: &mut T,\n-                                           fty: &ty::BareFnTy)\n-                                           -> ty::BareFnTy\n+pub fn super_fold_bare_fn_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                        fty: &ty::BareFnTy)\n+                                                        -> ty::BareFnTy\n {\n     ty::BareFnTy { sig: fty.sig.fold_with(this),\n                    abi: fty.abi,\n                    fn_style: fty.fn_style }\n }\n \n-pub fn super_fold_closure_ty<T:TypeFolder>(this: &mut T,\n-                                           fty: &ty::ClosureTy)\n-                                           -> ty::ClosureTy\n+pub fn super_fold_closure_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                        fty: &ty::ClosureTy)\n+                                                        -> ty::ClosureTy\n {\n     ty::ClosureTy {\n         store: fty.store.fold_with(this),\n@@ -362,24 +361,23 @@ pub fn super_fold_closure_ty<T:TypeFolder>(this: &mut T,\n         abi: fty.abi,\n     }\n }\n-\n-pub fn super_fold_trait_ref<T:TypeFolder>(this: &mut T,\n-                                          t: &ty::TraitRef)\n-                                          -> ty::TraitRef {\n+pub fn super_fold_trait_ref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                       t: &ty::TraitRef)\n+                                                       -> ty::TraitRef {\n     ty::TraitRef {\n         def_id: t.def_id,\n         substs: t.substs.fold_with(this),\n     }\n }\n \n-pub fn super_fold_mt<T:TypeFolder>(this: &mut T,\n-                                   mt: &ty::mt) -> ty::mt {\n+pub fn super_fold_mt<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                mt: &ty::mt) -> ty::mt {\n     ty::mt {ty: mt.ty.fold_with(this),\n             mutbl: mt.mutbl}\n }\n \n-pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n-                                    sty: &ty::sty) -> ty::sty {\n+pub fn super_fold_sty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                 sty: &ty::sty) -> ty::sty {\n     match *sty {\n         ty::ty_box(typ) => {\n             ty::ty_box(typ.fold_with(this))\n@@ -437,9 +435,9 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n     }\n }\n \n-pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n-                                            trait_store: ty::TraitStore)\n-                                            -> ty::TraitStore {\n+pub fn super_fold_trait_store<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                         trait_store: ty::TraitStore)\n+                                                         -> ty::TraitStore {\n     match trait_store {\n         ty::UniqTraitStore => ty::UniqTraitStore,\n         ty::RegionTraitStore(r, m) => {\n@@ -448,18 +446,18 @@ pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n     }\n }\n \n-pub fn super_fold_existential_bounds<T:TypeFolder>(this: &mut T,\n-                                                   bounds: ty::ExistentialBounds)\n-                                                   -> ty::ExistentialBounds {\n+pub fn super_fold_existential_bounds<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                                bounds: ty::ExistentialBounds)\n+                                                                -> ty::ExistentialBounds {\n     ty::ExistentialBounds {\n         region_bound: bounds.region_bound.fold_with(this),\n         builtin_bounds: bounds.builtin_bounds,\n     }\n }\n \n-pub fn super_fold_autoref<T:TypeFolder>(this: &mut T,\n-                                        autoref: &ty::AutoRef)\n-                                        -> ty::AutoRef\n+pub fn super_fold_autoref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                     autoref: &ty::AutoRef)\n+                                                     -> ty::AutoRef\n {\n     match *autoref {\n         ty::AutoPtr(r, m, None) => ty::AutoPtr(this.fold_region(r), m, None),\n@@ -475,9 +473,9 @@ pub fn super_fold_autoref<T:TypeFolder>(this: &mut T,\n     }\n }\n \n-pub fn super_fold_item_substs<T:TypeFolder>(this: &mut T,\n-                                            substs: ty::ItemSubsts)\n-                                            -> ty::ItemSubsts\n+pub fn super_fold_item_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                         substs: ty::ItemSubsts)\n+                                                         -> ty::ItemSubsts\n {\n     ty::ItemSubsts {\n         substs: substs.substs.fold_with(this),\n@@ -487,13 +485,13 @@ pub fn super_fold_item_substs<T:TypeFolder>(this: &mut T,\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n-pub struct BottomUpFolder<'a> {\n-    pub tcx: &'a ty::ctxt,\n+pub struct BottomUpFolder<'a, 'tcx: 'a> {\n+    pub tcx: &'a ty::ctxt<'tcx>,\n     pub fldop: |ty::t|: 'a -> ty::t,\n }\n \n-impl<'a> TypeFolder for BottomUpFolder<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n+impl<'a, 'tcx> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n         let t1 = super_fold_ty(self, ty);\n@@ -516,18 +514,18 @@ impl<'a> TypeFolder for BottomUpFolder<'a> {\n /// (The distinction between \"free\" and \"bound\" is represented by\n /// keeping track of each `FnSig` in the lexical context of the\n /// current position of the fold.)\n-pub struct RegionFolder<'a> {\n-    tcx: &'a ty::ctxt,\n+pub struct RegionFolder<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     fld_t: |ty::t|: 'a -> ty::t,\n     fld_r: |ty::Region|: 'a -> ty::Region,\n     within_binder_ids: Vec<ast::NodeId>,\n }\n \n-impl<'a> RegionFolder<'a> {\n-    pub fn general(tcx: &'a ty::ctxt,\n+impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n+    pub fn general(tcx: &'a ty::ctxt<'tcx>,\n                    fld_r: |ty::Region|: 'a -> ty::Region,\n                    fld_t: |ty::t|: 'a -> ty::t)\n-                   -> RegionFolder<'a> {\n+                   -> RegionFolder<'a, 'tcx> {\n         RegionFolder {\n             tcx: tcx,\n             fld_t: fld_t,\n@@ -536,8 +534,8 @@ impl<'a> RegionFolder<'a> {\n         }\n     }\n \n-    pub fn regions(tcx: &'a ty::ctxt, fld_r: |ty::Region|: 'a -> ty::Region)\n-                   -> RegionFolder<'a> {\n+    pub fn regions(tcx: &'a ty::ctxt<'tcx>, fld_r: |ty::Region|: 'a -> ty::Region)\n+                   -> RegionFolder<'a, 'tcx> {\n         fn noop(t: ty::t) -> ty::t { t }\n \n         RegionFolder {\n@@ -559,8 +557,8 @@ fn opt_binder_id_of_function(t: ty::t) -> Option<ast::NodeId> {\n     }\n }\n \n-impl<'a> TypeFolder for RegionFolder<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n+impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n         debug!(\"RegionFolder.fold_ty({})\", ty.repr(self.tcx()));"}, {"sha": "f5fa6168a415cb83a8989683cf797031d6dac14a", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -71,8 +71,8 @@ use syntax::abi;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n \n-pub trait AstConv {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n+pub trait AstConv<'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n     fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype;\n     fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef>;\n \n@@ -118,7 +118,7 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n     r\n }\n \n-pub fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n+pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     default_span: Span,\n@@ -152,7 +152,7 @@ pub fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n     r\n }\n \n-fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n+fn ast_path_substs<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     decl_generics: &ty::Generics,\n@@ -271,7 +271,7 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     substs\n }\n \n-pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope>(\n+pub fn ast_path_to_trait_ref<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         this: &AC,\n         rscope: &RS,\n         trait_def_id: ast::DefId,\n@@ -284,7 +284,7 @@ pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope>(\n     })\n }\n \n-pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>(\n+pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     did: ast::DefId,\n@@ -307,7 +307,7 @@ pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>(\n /// and/or region variables are substituted.\n ///\n /// This is used when checking the constructor in struct literals.\n-pub fn ast_path_to_ty_relaxed<AC:AstConv,\n+pub fn ast_path_to_ty_relaxed<'tcx, AC: AstConv<'tcx>,\n                               RS:RegionScope>(\n                               this: &AC,\n                               rscope: &RS,\n@@ -412,12 +412,11 @@ pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n \n /// Converts the given AST type to a built-in type. A \"built-in type\" is, at\n /// present, either a core numeric type, a string, or `Box`.\n-pub fn ast_ty_to_builtin_ty<AC:AstConv,\n-                            RS:RegionScope>(\n-                            this: &AC,\n-                            rscope: &RS,\n-                            ast_ty: &ast::Ty)\n-                            -> Option<ty::t> {\n+pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n+        this: &AC,\n+        rscope: &RS,\n+        ast_ty: &ast::Ty)\n+        -> Option<ty::t> {\n     match ast_ty_to_prim_ty(this.tcx(), ast_ty) {\n         Some(typ) => return Some(typ),\n         None => {}\n@@ -531,7 +530,7 @@ impl PointerTy {\n     }\n }\n \n-pub fn trait_ref_for_unboxed_function<AC:AstConv,\n+pub fn trait_ref_for_unboxed_function<'tcx, AC: AstConv<'tcx>,\n                                       RS:RegionScope>(\n                                       this: &AC,\n                                       rscope: &RS,\n@@ -576,14 +575,13 @@ pub fn trait_ref_for_unboxed_function<AC:AstConv,\n // Handle `~`, `Box`, and `&` being able to mean strs and vecs.\n // If a_seq_ty is a str or a vec, make it a str/vec.\n // Also handle first-class trait types.\n-fn mk_pointer<AC:AstConv,\n-              RS:RegionScope>(\n-              this: &AC,\n-              rscope: &RS,\n-              a_seq_ty: &ast::MutTy,\n-              ptr_ty: PointerTy,\n-              constr: |ty::t| -> ty::t)\n-              -> ty::t {\n+fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n+        this: &AC,\n+        rscope: &RS,\n+        a_seq_ty: &ast::MutTy,\n+        ptr_ty: PointerTy,\n+        constr: |ty::t| -> ty::t)\n+        -> ty::t {\n     let tcx = this.tcx();\n     debug!(\"mk_pointer(ptr_ty={})\", ptr_ty);\n \n@@ -695,8 +693,8 @@ fn mk_pointer<AC:AstConv,\n \n // Parses the programmer's textual representation of a type into our\n // internal notion of a type.\n-pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n-    this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t {\n+pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n+        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t {\n \n     let tcx = this.tcx();\n \n@@ -914,8 +912,10 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n     return typ;\n }\n \n-pub fn ty_of_arg<AC: AstConv, RS: RegionScope>(this: &AC, rscope: &RS, a: &ast::Arg,\n-                                               expected_ty: Option<ty::t>) -> ty::t {\n+pub fn ty_of_arg<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(this: &AC, rscope: &RS,\n+                                                           a: &ast::Arg,\n+                                                           expected_ty: Option<ty::t>)\n+                                                           -> ty::t {\n     match a.ty.node {\n         ast::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n         ast::TyInfer => this.ty_infer(a.ty.span),\n@@ -928,7 +928,7 @@ struct SelfInfo<'a> {\n     explicit_self: ast::ExplicitSelf,\n }\n \n-pub fn ty_of_method<AC:AstConv>(\n+pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n                     this: &AC,\n                     id: ast::NodeId,\n                     fn_style: ast::FnStyle,\n@@ -951,15 +951,15 @@ pub fn ty_of_method<AC:AstConv>(\n     (bare_fn_ty, optional_explicit_self_category.unwrap())\n }\n \n-pub fn ty_of_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n-                                 fn_style: ast::FnStyle, abi: abi::Abi,\n-                                 decl: &ast::FnDecl) -> ty::BareFnTy {\n+pub fn ty_of_bare_fn<'tcx, AC: AstConv<'tcx>>(this: &AC, id: ast::NodeId,\n+                                              fn_style: ast::FnStyle, abi: abi::Abi,\n+                                              decl: &ast::FnDecl) -> ty::BareFnTy {\n     let (bare_fn_ty, _) =\n         ty_of_method_or_bare_fn(this, id, fn_style, abi, None, decl);\n     bare_fn_ty\n }\n \n-fn ty_of_method_or_bare_fn<AC:AstConv>(\n+fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n                            this: &AC,\n                            id: ast::NodeId,\n                            fn_style: ast::FnStyle,\n@@ -1070,7 +1070,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(\n     }, explicit_self_category_result)\n }\n \n-fn determine_explicit_self_category<AC:AstConv,\n+fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n                                     RS:RegionScope>(\n                                     this: &AC,\n                                     rscope: &RS,\n@@ -1145,7 +1145,7 @@ fn determine_explicit_self_category<AC:AstConv,\n     }\n }\n \n-pub fn ty_of_closure<AC:AstConv>(\n+pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n     this: &AC,\n     id: ast::NodeId,\n     fn_style: ast::FnStyle,\n@@ -1196,7 +1196,7 @@ pub fn ty_of_closure<AC:AstConv>(\n     }\n }\n \n-pub fn conv_existential_bounds<AC:AstConv, RS:RegionScope>(\n+pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n@@ -1330,7 +1330,7 @@ pub fn compute_opt_region_bound(tcx: &ty::ctxt,\n     return Some(r);\n }\n \n-fn compute_region_bound<AC:AstConv, RS:RegionScope>(\n+fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,"}, {"sha": "247178770d21a9a4041a3ea228335a934a10c9c5", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -107,8 +107,8 @@ pub fn check_match(fcx: &FnCtxt,\n     fcx.write_ty(expr.id, result_ty);\n }\n \n-pub struct pat_ctxt<'a> {\n-    pub fcx: &'a FnCtxt<'a>,\n+pub struct pat_ctxt<'a, 'tcx: 'a> {\n+    pub fcx: &'a FnCtxt<'a, 'tcx>,\n     pub map: PatIdMap,\n }\n "}, {"sha": "88d9a58ab141a91d603a7846e3ad14d39c21a451", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -123,8 +123,8 @@ pub enum StaticMethodsFlag {\n     IgnoreStaticMethods,\n }\n \n-pub fn lookup<'a>(\n-        fcx: &'a FnCtxt<'a>,\n+pub fn lookup<'a, 'tcx>(\n+        fcx: &'a FnCtxt<'a, 'tcx>,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n         expr: &ast::Expr,                   // The expression `a.b(...)`.\n@@ -170,8 +170,8 @@ pub fn lookup<'a>(\n     lcx.search(self_ty)\n }\n \n-pub fn lookup_in_trait<'a>(\n-        fcx: &'a FnCtxt<'a>,\n+pub fn lookup_in_trait<'a, 'tcx>(\n+        fcx: &'a FnCtxt<'a, 'tcx>,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n         span: Span,                         // The expression `a.b(...)`'s span.\n@@ -303,8 +303,8 @@ fn construct_transformed_self_ty_for_object(\n     }\n }\n \n-struct LookupContext<'a> {\n-    fcx: &'a FnCtxt<'a>,\n+struct LookupContext<'a, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n \n     // The receiver to the method call. Only `None` in the case of\n@@ -350,7 +350,7 @@ pub enum RcvrMatchCondition {\n     RcvrMatchesIfSubtype(ty::t),\n }\n \n-impl<'a> LookupContext<'a> {\n+impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     fn search(&self, self_ty: ty::t) -> Option<MethodCallee> {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         let self_expr_id = self.self_expr.map(|e| e.id);\n@@ -1615,11 +1615,11 @@ impl<'a> LookupContext<'a> {\n             idx + 1u, ty::item_path_str(self.tcx(), did));\n     }\n \n-    fn infcx(&'a self) -> &'a infer::InferCtxt<'a> {\n+    fn infcx(&'a self) -> &'a infer::InferCtxt<'a, 'tcx> {\n         &self.fcx.inh.infcx\n     }\n \n-    fn tcx(&self) -> &'a ty::ctxt {\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n         self.fcx.tcx()\n     }\n "}, {"sha": "01b5fd6e429eeaec1e675f1c7b5f3774b70c06d2", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 48, "deletions": 58, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -89,7 +89,7 @@ use middle::subst;\n use middle::subst::{Subst, Substs, VecPerParamSpace, ParamSpace};\n use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{Polytype};\n-use middle::ty::{Disr, ExprTyProvider, ParamTy, ParameterEnvironment};\n+use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n@@ -159,8 +159,8 @@ pub mod method;\n /// Here, the function `foo()` and the closure passed to\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n-pub struct Inherited<'a> {\n-    infcx: infer::InferCtxt<'a>,\n+pub struct Inherited<'a, 'tcx: 'a> {\n+    infcx: infer::InferCtxt<'a, 'tcx>,\n     locals: RefCell<NodeMap<ty::t>>,\n     param_env: ty::ParameterEnvironment,\n \n@@ -267,7 +267,7 @@ enum IsBinopAssignment{\n }\n \n #[deriving(Clone)]\n-pub struct FnCtxt<'a> {\n+pub struct FnCtxt<'a, 'tcx: 'a> {\n     body_id: ast::NodeId,\n \n     // This flag is set to true if, during the writeback phase, we encounter\n@@ -284,13 +284,13 @@ pub struct FnCtxt<'a> {\n \n     ps: RefCell<FnStyleState>,\n \n-    inh: &'a Inherited<'a>,\n+    inh: &'a Inherited<'a, 'tcx>,\n \n-    ccx: &'a CrateCtxt<'a>,\n+    ccx: &'a CrateCtxt<'a, 'tcx>,\n }\n \n-impl<'a> mem_categorization::Typer for FnCtxt<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n     fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t> {\n@@ -322,10 +322,10 @@ impl<'a> mem_categorization::Typer for FnCtxt<'a> {\n     }\n }\n \n-impl<'a> Inherited<'a> {\n-    fn new(tcx: &'a ty::ctxt,\n+impl<'a, 'tcx> Inherited<'a, 'tcx> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>,\n            param_env: ty::ParameterEnvironment)\n-           -> Inherited<'a> {\n+           -> Inherited<'a, 'tcx> {\n         Inherited {\n             infcx: infer::new_infer_ctxt(tcx),\n             locals: RefCell::new(NodeMap::new()),\n@@ -344,12 +344,11 @@ impl<'a> Inherited<'a> {\n }\n \n // Used by check_const and check_enum_variants\n-pub fn blank_fn_ctxt<'a>(\n-                     ccx: &'a CrateCtxt<'a>,\n-                     inh: &'a Inherited<'a>,\n-                     rty: ty::t,\n-                     body_id: ast::NodeId)\n-                     -> FnCtxt<'a> {\n+pub fn blank_fn_ctxt<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n+                               inh: &'a Inherited<'a, 'tcx>,\n+                               rty: ty::t,\n+                               body_id: ast::NodeId)\n+                               -> FnCtxt<'a, 'tcx> {\n     FnCtxt {\n         body_id: body_id,\n         writeback_errors: Cell::new(false),\n@@ -361,7 +360,8 @@ pub fn blank_fn_ctxt<'a>(\n     }\n }\n \n-fn static_inherited_fields<'a>(ccx: &'a CrateCtxt<'a>) -> Inherited<'a> {\n+fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n+                                    -> Inherited<'a, 'tcx> {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n     let param_env = ty::ParameterEnvironment {\n@@ -372,37 +372,29 @@ fn static_inherited_fields<'a>(ccx: &'a CrateCtxt<'a>) -> Inherited<'a> {\n     Inherited::new(ccx.tcx, param_env)\n }\n \n-impl<'a> ExprTyProvider for FnCtxt<'a> {\n-    fn expr_ty(&self, ex: &ast::Expr) -> ty::t {\n-        self.expr_ty(ex)\n-    }\n-\n-    fn ty_ctxt<'a>(&'a self) -> &'a ty::ctxt {\n-        self.ccx.tcx\n-    }\n-}\n-\n-struct CheckTypeWellFormedVisitor<'a> { ccx: &'a CrateCtxt<'a> }\n+struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n+struct CheckTypeWellFormedVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n \n-impl<'a> Visitor<()> for CheckTypeWellFormedVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         check_type_well_formed(self.ccx, i);\n         visit::walk_item(self, i, ());\n     }\n }\n \n-struct CheckItemTypesVisitor<'a> { ccx: &'a CrateCtxt<'a> }\n \n-impl<'a> Visitor<()> for CheckItemTypesVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         check_item(self.ccx, i);\n         visit::walk_item(self, i, ());\n     }\n }\n \n-struct CheckItemSizedTypesVisitor<'a> { ccx: &'a CrateCtxt<'a> }\n+struct CheckItemSizedTypesVisitor<'a, 'tcx: 'a> {\n+    ccx: &'a CrateCtxt<'a, 'tcx>\n+}\n \n-impl<'a> Visitor<()> for CheckItemSizedTypesVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for CheckItemSizedTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         check_item_sized(self.ccx, i);\n         visit::walk_item(self, i, ());\n@@ -451,11 +443,11 @@ fn check_bare_fn(ccx: &CrateCtxt,\n     }\n }\n \n-struct GatherLocalsVisitor<'a> {\n-    fcx: &'a FnCtxt<'a>\n+struct GatherLocalsVisitor<'a, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'tcx>\n }\n \n-impl<'a> GatherLocalsVisitor<'a> {\n+impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n     fn assign(&mut self, nid: ast::NodeId, ty_opt: Option<ty::t>) {\n             match ty_opt {\n                 None => {\n@@ -472,7 +464,7 @@ impl<'a> GatherLocalsVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n+impl<'a, 'tcx> Visitor<()> for GatherLocalsVisitor<'a, 'tcx> {\n     // Add explicitly-declared locals.\n     fn visit_local(&mut self, local: &ast::Local, _: ()) {\n         let o_ty = match local.ty.node {\n@@ -530,17 +522,15 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n \n }\n \n-fn check_fn<'a>(\n-    ccx: &'a CrateCtxt<'a>,\n-    fn_style: ast::FnStyle,\n-    fn_style_id: ast::NodeId,\n-    fn_sig: &ty::FnSig,\n-    decl: &ast::FnDecl,\n-    fn_id: ast::NodeId,\n-    body: &ast::Block,\n-    inherited: &'a Inherited<'a>)\n-    -> FnCtxt<'a>\n-{\n+fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n+                      fn_style: ast::FnStyle,\n+                      fn_style_id: ast::NodeId,\n+                      fn_sig: &ty::FnSig,\n+                      decl: &ast::FnDecl,\n+                      fn_id: ast::NodeId,\n+                      body: &ast::Block,\n+                      inherited: &'a Inherited<'a, 'tcx>)\n+                      -> FnCtxt<'a, 'tcx> {\n     /*!\n      * Helper used by check_bare_fn and check_expr_fn.  Does the\n      * grungy work of checking a function body and returns the\n@@ -1563,8 +1553,8 @@ fn check_cast(fcx: &FnCtxt,\n     fcx.write_ty(id, t_1);\n }\n \n-impl<'a> AstConv for FnCtxt<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.ccx.tcx }\n+impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.ccx.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n         ty::lookup_item_type(self.tcx(), id)\n@@ -1579,18 +1569,18 @@ impl<'a> AstConv for FnCtxt<'a> {\n     }\n }\n \n-impl<'a> FnCtxt<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.ccx.tcx }\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.ccx.tcx }\n \n-    pub fn infcx<'b>(&'b self) -> &'b infer::InferCtxt<'a> {\n+    pub fn infcx<'b>(&'b self) -> &'b infer::InferCtxt<'a, 'tcx> {\n         &self.inh.infcx\n     }\n \n     pub fn err_count_since_creation(&self) -> uint {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n \n-    pub fn vtable_context<'a>(&'a self) -> VtableContext<'a> {\n+    pub fn vtable_context<'a>(&'a self) -> VtableContext<'a, 'tcx> {\n         VtableContext {\n             infcx: self.infcx(),\n             param_env: &self.inh.param_env,\n@@ -1599,7 +1589,7 @@ impl<'a> FnCtxt<'a> {\n     }\n }\n \n-impl<'a> RegionScope for infer::InferCtxt<'a> {\n+impl<'a, 'tcx> RegionScope for infer::InferCtxt<'a, 'tcx> {\n     fn default_region_bound(&self, span: Span) -> Option<ty::Region> {\n         Some(self.next_region_var(infer::MiscVariable(span)))\n     }\n@@ -1612,7 +1602,7 @@ impl<'a> RegionScope for infer::InferCtxt<'a> {\n     }\n }\n \n-impl<'a> FnCtxt<'a> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn tag(&self) -> String {\n         format!(\"{}\", self as *const FnCtxt)\n     }\n@@ -3919,7 +3909,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprRepeat(ref element, ref count_expr) => {\n         check_expr_has_type(fcx, &**count_expr, ty::mk_uint());\n-        let count = ty::eval_repeat_count(fcx, &**count_expr);\n+        let count = ty::eval_repeat_count(fcx.tcx(), &**count_expr);\n \n         let uty = match expected {\n             ExpectHasType(uty) => {"}, {"sha": "eb630d0fc7bbe083ba7e88e393f1e6395a4f28b1", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -196,8 +196,8 @@ macro_rules! ignore_err(\n     )\n )\n \n-pub struct Rcx<'a> {\n-    fcx: &'a FnCtxt<'a>,\n+pub struct Rcx<'a, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n \n     region_param_pairs: Vec<(ty::Region, ty::ParamTy)>,\n \n@@ -250,15 +250,15 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n     }\n }\n \n-impl<'a> Rcx<'a> {\n-    pub fn new(fcx: &'a FnCtxt<'a>,\n-               initial_repeating_scope: ast::NodeId) -> Rcx<'a> {\n+impl<'a, 'tcx> Rcx<'a, 'tcx> {\n+    pub fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n+               initial_repeating_scope: ast::NodeId) -> Rcx<'a, 'tcx> {\n         Rcx { fcx: fcx,\n               repeating_scope: initial_repeating_scope,\n               region_param_pairs: Vec::new() }\n     }\n \n-    pub fn tcx(&self) -> &'a ty::ctxt {\n+    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n         self.fcx.ccx.tcx\n     }\n \n@@ -438,8 +438,8 @@ impl<'a> Rcx<'a> {\n     }\n }\n \n-impl<'fcx> mc::Typer for Rcx<'fcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.fcx.ccx.tcx\n     }\n \n@@ -479,7 +479,7 @@ impl<'fcx> mc::Typer for Rcx<'fcx> {\n     }\n }\n \n-impl<'a> Visitor<()> for Rcx<'a> {\n+impl<'a, 'tcx> Visitor<()> for Rcx<'a, 'tcx> {\n     // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n     // However, right now we run into an issue whereby some free\n     // regions are not properly related if they appear within the"}, {"sha": "60e502786ab3dbeb684efd32ac3fe64dcc73114a", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -51,8 +51,8 @@ pub enum WfConstraint {\n     RegionSubParamConstraint(Option<ty::t>, ty::Region, ty::ParamTy),\n }\n \n-struct Wf<'a> {\n-    tcx: &'a ty::ctxt,\n+struct Wf<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     stack: Vec<(ty::Region, Option<ty::t>)>,\n     out: Vec<WfConstraint>,\n }\n@@ -78,7 +78,7 @@ pub fn region_wf_constraints(\n     wf.out\n }\n \n-impl<'a> Wf<'a> {\n+impl<'a, 'tcx> Wf<'a, 'tcx> {\n     fn accumulate_from_ty(&mut self, ty: ty::t) {\n         debug!(\"Wf::accumulate_from_ty(ty={})\",\n                ty.repr(self.tcx));"}, {"sha": "16136fcf3e840c5046d7f96e500373142cfcfcbf", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -68,14 +68,14 @@ use syntax::visit::Visitor;\n \n /// A vtable context includes an inference context, a parameter environment,\n /// and a list of unboxed closure types.\n-pub struct VtableContext<'a> {\n-    pub infcx: &'a infer::InferCtxt<'a>,\n+pub struct VtableContext<'a, 'tcx: 'a> {\n+    pub infcx: &'a infer::InferCtxt<'a, 'tcx>,\n     pub param_env: &'a ty::ParameterEnvironment,\n     pub unboxed_closures: &'a RefCell<DefIdMap<ty::UnboxedClosure>>,\n }\n \n-impl<'a> VtableContext<'a> {\n-    pub fn tcx(&self) -> &'a ty::ctxt { self.infcx.tcx }\n+impl<'a, 'tcx> VtableContext<'a, 'tcx> {\n+    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.infcx.tcx }\n }\n \n fn lookup_vtables(vcx: &VtableContext,\n@@ -1025,7 +1025,7 @@ pub fn trans_resolve_method(tcx: &ty::ctxt, id: ast::NodeId,\n                    false)\n }\n \n-impl<'a, 'b> visit::Visitor<()> for &'a FnCtxt<'b> {\n+impl<'a, 'b, 'tcx> visit::Visitor<()> for &'a FnCtxt<'b, 'tcx> {\n     fn visit_expr(&mut self, ex: &ast::Expr, _: ()) {\n         early_resolve_expr(ex, *self, false);\n         visit::walk_expr(self, ex, ());"}, {"sha": "d65172cc0c167a57e922aef74994ed9c7f720a80", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -84,16 +84,16 @@ pub fn resolve_impl_res(infcx: &infer::InferCtxt,\n // there, it applies a few ad-hoc checks that were not convenient to\n // do elsewhere.\n \n-struct WritebackCx<'cx> {\n-    fcx: &'cx FnCtxt<'cx>,\n+struct WritebackCx<'cx, 'tcx: 'cx> {\n+    fcx: &'cx FnCtxt<'cx, 'tcx>,\n }\n \n-impl<'cx> WritebackCx<'cx> {\n-    fn new(fcx: &'cx FnCtxt) -> WritebackCx<'cx> {\n+impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n+    fn new(fcx: &'cx FnCtxt<'cx, 'tcx>) -> WritebackCx<'cx, 'tcx> {\n         WritebackCx { fcx: fcx }\n     }\n \n-    fn tcx(&self) -> &'cx ty::ctxt {\n+    fn tcx(&self) -> &'cx ty::ctxt<'tcx> {\n         self.fcx.tcx()\n     }\n }\n@@ -106,7 +106,7 @@ impl<'cx> WritebackCx<'cx> {\n // below. In general, a function is made into a `visitor` if it must\n // traffic in node-ids or update tables in the type context etc.\n \n-impl<'cx> Visitor<()> for WritebackCx<'cx> {\n+impl<'cx, 'tcx> Visitor<()> for WritebackCx<'cx, 'tcx> {\n     fn visit_item(&mut self, _: &ast::Item, _: ()) {\n         // Ignore items\n     }\n@@ -192,7 +192,7 @@ impl<'cx> Visitor<()> for WritebackCx<'cx> {\n     }\n }\n \n-impl<'cx> WritebackCx<'cx> {\n+impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_upvar_borrow_map(&self) {\n         if self.fcx.writeback_errors.get() {\n             return;\n@@ -400,28 +400,28 @@ impl<T:TypeFoldable> ResolveIn for T {\n // The Resolver. This is the type folding engine that detects\n // unresolved types and so forth.\n \n-struct Resolver<'cx> {\n-    tcx: &'cx ty::ctxt,\n-    infcx: &'cx infer::InferCtxt<'cx>,\n+struct Resolver<'cx, 'tcx: 'cx> {\n+    tcx: &'cx ty::ctxt<'tcx>,\n+    infcx: &'cx infer::InferCtxt<'cx, 'tcx>,\n     writeback_errors: &'cx Cell<bool>,\n     reason: ResolveReason,\n }\n \n-impl<'cx> Resolver<'cx> {\n-    fn new(fcx: &'cx FnCtxt<'cx>,\n+impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n+    fn new(fcx: &'cx FnCtxt<'cx, 'tcx>,\n            reason: ResolveReason)\n-           -> Resolver<'cx>\n+           -> Resolver<'cx, 'tcx>\n     {\n         Resolver { infcx: fcx.infcx(),\n                    tcx: fcx.tcx(),\n                    writeback_errors: &fcx.writeback_errors,\n                    reason: reason }\n     }\n \n-    fn from_infcx(infcx: &'cx infer::InferCtxt<'cx>,\n+    fn from_infcx(infcx: &'cx infer::InferCtxt<'cx, 'tcx>,\n                   writeback_errors: &'cx Cell<bool>,\n                   reason: ResolveReason)\n-                  -> Resolver<'cx>\n+                  -> Resolver<'cx, 'tcx>\n     {\n         Resolver { infcx: infcx,\n                    tcx: infcx.tcx,\n@@ -475,8 +475,8 @@ impl<'cx> Resolver<'cx> {\n     }\n }\n \n-impl<'cx> TypeFolder for Resolver<'cx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.tcx\n     }\n "}, {"sha": "2c6dc94f182b4bd56b4e01062b617fe2410680ca", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -182,16 +182,16 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n     }\n }\n \n-struct CoherenceChecker<'a> {\n-    crate_context: &'a CrateCtxt<'a>,\n-    inference_context: InferCtxt<'a>,\n+struct CoherenceChecker<'a, 'tcx: 'a> {\n+    crate_context: &'a CrateCtxt<'a, 'tcx>,\n+    inference_context: InferCtxt<'a, 'tcx>,\n }\n \n-struct CoherenceCheckVisitor<'a> {\n-    cc: &'a CoherenceChecker<'a>\n+struct CoherenceCheckVisitor<'a, 'tcx: 'a> {\n+    cc: &'a CoherenceChecker<'a, 'tcx>\n }\n \n-impl<'a> visit::Visitor<()> for CoherenceCheckVisitor<'a> {\n+impl<'a, 'tcx> visit::Visitor<()> for CoherenceCheckVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n \n         //debug!(\"(checking coherence) item '{}'\", token::get_ident(item.ident));\n@@ -214,9 +214,11 @@ impl<'a> visit::Visitor<()> for CoherenceCheckVisitor<'a> {\n     }\n }\n \n-struct PrivilegedScopeVisitor<'a> { cc: &'a CoherenceChecker<'a> }\n+struct PrivilegedScopeVisitor<'a, 'tcx: 'a> {\n+    cc: &'a CoherenceChecker<'a, 'tcx>\n+}\n \n-impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n+impl<'a, 'tcx> visit::Visitor<()> for PrivilegedScopeVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n \n         match item.node {\n@@ -263,7 +265,7 @@ impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n     }\n }\n \n-impl<'a> CoherenceChecker<'a> {\n+impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     fn check(&self, krate: &Crate) {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also"}, {"sha": "742d22cc3793ff396dfdde686f2e67f1f69db63e", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -95,11 +95,11 @@ pub fn collect_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n // of type parameters and supertraits. This is information we need to\n // know later when parsing field defs.\n \n-struct CollectTraitDefVisitor<'a> {\n-    ccx: &'a CrateCtxt<'a>\n+struct CollectTraitDefVisitor<'a, 'tcx: 'a> {\n+    ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n-impl<'a> visit::Visitor<()> for CollectTraitDefVisitor<'a> {\n+impl<'a, 'tcx> visit::Visitor<()> for CollectTraitDefVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         match i.node {\n             ast::ItemTrait(..) => {\n@@ -116,11 +116,11 @@ impl<'a> visit::Visitor<()> for CollectTraitDefVisitor<'a> {\n ///////////////////////////////////////////////////////////////////////////\n // Second phase: collection proper.\n \n-struct CollectItemTypesVisitor<'a> {\n-    ccx: &'a CrateCtxt<'a>\n+struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n+    ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n-impl<'a> visit::Visitor<()> for CollectItemTypesVisitor<'a> {\n+impl<'a, 'tcx> visit::Visitor<()> for CollectItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         convert(self.ccx, i);\n         visit::walk_item(self, i, ());\n@@ -138,14 +138,14 @@ pub trait ToTy {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t;\n }\n \n-impl<'a> ToTy for CrateCtxt<'a> {\n+impl<'a, 'tcx> ToTy for CrateCtxt<'a, 'tcx> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n-impl<'a> AstConv for CrateCtxt<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n+impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n         if id.krate != ast::LOCAL_CRATE {"}, {"sha": "44141f25418e404d4383a9132c5e8ef7be82f152", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -82,10 +82,10 @@ use syntax::ast;\n // Note: Coerce is not actually a combiner, in that it does not\n // conform to the same interface, though it performs a similar\n // function.\n-pub struct Coerce<'f>(pub CombineFields<'f>);\n+pub struct Coerce<'f, 'tcx: 'f>(pub CombineFields<'f, 'tcx>);\n \n-impl<'f> Coerce<'f> {\n-    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> {\n+impl<'f, 'tcx> Coerce<'f, 'tcx> {\n+    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f, 'tcx> {\n         let Coerce(ref v) = *self; v\n     }\n "}, {"sha": "66caf10cb408ca59794fcefdf16f144f7a2434cc", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -57,16 +57,16 @@ use syntax::ast::{Onceness, FnStyle};\n use syntax::ast;\n use syntax::abi;\n \n-pub trait Combine {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a>;\n+pub trait Combine<'tcx> {\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx>;\n     fn tag(&self) -> String;\n     fn a_is_expected(&self) -> bool;\n     fn trace(&self) -> TypeTrace;\n \n-    fn equate<'a>(&'a self) -> Equate<'a>;\n-    fn sub<'a>(&'a self) -> Sub<'a>;\n-    fn lub<'a>(&'a self) -> Lub<'a>;\n-    fn glb<'a>(&'a self) -> Glb<'a>;\n+    fn equate<'a>(&'a self) -> Equate<'a, 'tcx>;\n+    fn sub<'a>(&'a self) -> Sub<'a, 'tcx>;\n+    fn lub<'a>(&'a self) -> Lub<'a, 'tcx>;\n+    fn glb<'a>(&'a self) -> Glb<'a, 'tcx>;\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt>;\n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n@@ -138,13 +138,12 @@ pub trait Combine {\n \n         return Ok(substs);\n \n-        fn relate_region_params<C:Combine>(this: &C,\n-                                           item_def_id: ast::DefId,\n-                                           variances: &[ty::Variance],\n-                                           a_rs: &[ty::Region],\n-                                           b_rs: &[ty::Region])\n-                                           -> cres<Vec<ty::Region>>\n-        {\n+        fn relate_region_params<'tcx, C: Combine<'tcx>>(this: &C,\n+                                                        item_def_id: ast::DefId,\n+                                                        variances: &[ty::Variance],\n+                                                        a_rs: &[ty::Region],\n+                                                        b_rs: &[ty::Region])\n+                                                        -> cres<Vec<ty::Region>> {\n             let tcx = this.infcx().tcx;\n             let num_region_params = variances.len();\n \n@@ -305,13 +304,13 @@ pub trait Combine {\n }\n \n #[deriving(Clone)]\n-pub struct CombineFields<'a> {\n-    pub infcx: &'a InferCtxt<'a>,\n+pub struct CombineFields<'a, 'tcx: 'a> {\n+    pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub a_is_expected: bool,\n     pub trace: TypeTrace,\n }\n \n-pub fn expected_found<C:Combine,T>(\n+pub fn expected_found<'tcx, C: Combine<'tcx>, T>(\n         this: &C, a: T, b: T) -> ty::expected_found<T> {\n     if this.a_is_expected() {\n         ty::expected_found {expected: a, found: b}\n@@ -320,9 +319,15 @@ pub fn expected_found<C:Combine,T>(\n     }\n }\n \n-pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+pub fn super_fn_sigs<'tcx, C: Combine<'tcx>>(this: &C,\n+                                             a: &ty::FnSig,\n+                                             b: &ty::FnSig)\n+                                             -> cres<ty::FnSig> {\n \n-    fn argvecs<C:Combine>(this: &C, a_args: &[ty::t], b_args: &[ty::t]) -> cres<Vec<ty::t> > {\n+    fn argvecs<'tcx, C: Combine<'tcx>>(this: &C,\n+                                       a_args: &[ty::t],\n+                                       b_args: &[ty::t])\n+                                       -> cres<Vec<ty::t>> {\n         if a_args.len() == b_args.len() {\n             result::collect(a_args.iter().zip(b_args.iter())\n                             .map(|(a, b)| this.args(*a, *b)))\n@@ -345,18 +350,18 @@ pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<\n               variadic: a.variadic})\n }\n \n-pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n+pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n     // This is a horrible hack - historically, [T] was not treated as a type,\n     // so, for example, &T and &[U] should not unify. In fact the only thing\n     // &[U] should unify with is &[T]. We preserve that behaviour with this\n     // check.\n-    fn check_ptr_to_unsized<C:Combine>(this: &C,\n-                                       a: ty::t,\n-                                       b: ty::t,\n-                                       a_inner: ty::t,\n-                                       b_inner: ty::t,\n-                                       result: ty::t) -> cres<ty::t> {\n+    fn check_ptr_to_unsized<'tcx, C: Combine<'tcx>>(this: &C,\n+                                                    a: ty::t,\n+                                                    b: ty::t,\n+                                                    a_inner: ty::t,\n+                                                    b_inner: ty::t,\n+                                                    result: ty::t) -> cres<ty::t> {\n         match (&ty::get(a_inner).sty, &ty::get(b_inner).sty) {\n             (&ty::ty_vec(_, None), &ty::ty_vec(_, None)) |\n             (&ty::ty_str, &ty::ty_str) |\n@@ -547,7 +552,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       _ => Err(ty::terr_sorts(expected_found(this, a, b)))\n     };\n \n-    fn unify_integral_variable<C:Combine>(\n+    fn unify_integral_variable<'tcx, C: Combine<'tcx>>(\n         this: &C,\n         vid_is_expected: bool,\n         vid: ty::IntVid,\n@@ -560,7 +565,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n         }\n     }\n \n-    fn unify_float_variable<C:Combine>(\n+    fn unify_float_variable<'tcx, C: Combine<'tcx>>(\n         this: &C,\n         vid_is_expected: bool,\n         vid: ty::FloatVid,\n@@ -571,19 +576,19 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n     }\n }\n \n-impl<'f> CombineFields<'f> {\n-    pub fn switch_expected(&self) -> CombineFields<'f> {\n+impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n+    pub fn switch_expected(&self) -> CombineFields<'f, 'tcx> {\n         CombineFields {\n             a_is_expected: !self.a_is_expected,\n             ..(*self).clone()\n         }\n     }\n \n-    fn equate(&self) -> Equate<'f> {\n+    fn equate(&self) -> Equate<'f, 'tcx> {\n         Equate((*self).clone())\n     }\n \n-    fn sub(&self) -> Sub<'f> {\n+    fn sub(&self) -> Sub<'f, 'tcx> {\n         Sub((*self).clone())\n     }\n "}, {"sha": "fd4a5927362188d066f61e5626e03f0225409695", "filename": "src/librustc/middle/typeck/infer/equate.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -23,25 +23,25 @@ use util::ppaux::{Repr};\n \n use syntax::ast::{Onceness, FnStyle};\n \n-pub struct Equate<'f> {\n-    fields: CombineFields<'f>\n+pub struct Equate<'f, 'tcx: 'f> {\n+    fields: CombineFields<'f, 'tcx>\n }\n \n #[allow(non_snake_case)]\n-pub fn Equate<'f>(cf: CombineFields<'f>) -> Equate<'f> {\n+pub fn Equate<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Equate<'f, 'tcx> {\n     Equate { fields: cf }\n }\n \n-impl<'f> Combine for Equate<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n+impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"eq\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n-    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n+    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         self.tys(a, b)"}, {"sha": "e602e6a7b3c56b099c547a8cccc684b1f4d160d4", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -166,7 +166,7 @@ trait ErrorReportingHelpers {\n                                 span: codemap::Span);\n }\n \n-impl<'a> ErrorReporting for InferCtxt<'a> {\n+impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n     fn report_region_errors(&self,\n                             errors: &Vec<RegionResolutionError>) {\n         let p_errors = self.process_errors(errors);\n@@ -900,8 +900,8 @@ struct RebuildPathInfo<'a> {\n     region_names: &'a HashSet<ast::Name>\n }\n \n-struct Rebuilder<'a> {\n-    tcx: &'a ty::ctxt,\n+struct Rebuilder<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     fn_decl: ast::P<ast::FnDecl>,\n     expl_self_opt: Option<ast::ExplicitSelf_>,\n     generics: &'a ast::Generics,\n@@ -916,14 +916,14 @@ enum FreshOrKept {\n     Kept\n }\n \n-impl<'a> Rebuilder<'a> {\n-    fn new(tcx: &'a ty::ctxt,\n+impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n+    fn new(tcx: &'a ty::ctxt<'tcx>,\n            fn_decl: ast::P<ast::FnDecl>,\n            expl_self_opt: Option<ast::ExplicitSelf_>,\n            generics: &'a ast::Generics,\n            same_regions: &'a [SameRegions],\n            life_giver: &'a LifeGiver)\n-           -> Rebuilder<'a> {\n+           -> Rebuilder<'a, 'tcx> {\n         Rebuilder {\n             tcx: tcx,\n             fn_decl: fn_decl,\n@@ -1403,7 +1403,7 @@ impl<'a> Rebuilder<'a> {\n     }\n }\n \n-impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n+impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n     fn give_expl_lifetime_param(&self,\n                                 decl: &ast::FnDecl,\n                                 fn_style: ast::FnStyle,"}, {"sha": "08d4f9f3a86e5f041e9d00a8c8908a79e2982f0b", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -30,25 +30,25 @@ use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Glb<'f> {\n-    fields: CombineFields<'f>\n+pub struct Glb<'f, 'tcx: 'f> {\n+    fields: CombineFields<'f, 'tcx>\n }\n \n #[allow(non_snake_case)]\n-pub fn Glb<'f>(cf: CombineFields<'f>) -> Glb<'f> {\n+pub fn Glb<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Glb<'f, 'tcx> {\n     Glb { fields: cf }\n }\n \n-impl<'f> Combine for Glb<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n+impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"glb\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n-    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n+    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.fields.infcx.tcx;"}, {"sha": "6095e5b0504237823358ee068dd11bcf2d5dde46", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -51,7 +51,7 @@ pub trait LatticeDir {\n     fn relate_bound<'a>(&'a self, v: ty::t, a: ty::t, b: ty::t) -> cres<()>;\n }\n \n-impl<'a> LatticeDir for Lub<'a> {\n+impl<'a, 'tcx> LatticeDir for Lub<'a, 'tcx> {\n     fn ty_bot(&self, t: ty::t) -> cres<ty::t> {\n         Ok(t)\n     }\n@@ -64,7 +64,7 @@ impl<'a> LatticeDir for Lub<'a> {\n     }\n }\n \n-impl<'a> LatticeDir for Glb<'a> {\n+impl<'a, 'tcx> LatticeDir for Glb<'a, 'tcx> {\n     fn ty_bot(&self, _: ty::t) -> cres<ty::t> {\n         Ok(ty::mk_bot())\n     }\n@@ -77,10 +77,10 @@ impl<'a> LatticeDir for Glb<'a> {\n     }\n }\n \n-pub fn super_lattice_tys<L:LatticeDir+Combine>(this: &L,\n-                                               a: ty::t,\n-                                               b: ty::t)\n-                                               -> cres<ty::t>\n+pub fn super_lattice_tys<'tcx, L:LatticeDir+Combine<'tcx>>(this: &L,\n+                                                           a: ty::t,\n+                                                           b: ty::t)\n+                                                           -> cres<ty::t>\n {\n     debug!(\"{}.lattice_tys({}, {})\",\n            this.tag(),\n@@ -115,9 +115,9 @@ pub fn super_lattice_tys<L:LatticeDir+Combine>(this: &L,\n // Random utility functions used by LUB/GLB when computing LUB/GLB of\n // fn types\n \n-pub fn var_ids<T:Combine>(this: &T,\n-                          map: &HashMap<ty::BoundRegion, ty::Region>)\n-                          -> Vec<RegionVid> {\n+pub fn var_ids<'tcx, T: Combine<'tcx>>(this: &T,\n+                                       map: &HashMap<ty::BoundRegion, ty::Region>)\n+                                       -> Vec<RegionVid> {\n     map.iter().map(|(_, r)| match *r {\n             ty::ReInfer(ty::ReVar(r)) => { r }\n             r => {"}, {"sha": "276a22648374173f4eefcf8d885789f619072a09", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -29,25 +29,25 @@ use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n /// \"Least upper bound\" (common supertype)\n-pub struct Lub<'f> {\n-    fields: CombineFields<'f>\n+pub struct Lub<'f, 'tcx: 'f> {\n+    fields: CombineFields<'f, 'tcx>\n }\n \n #[allow(non_snake_case)]\n-pub fn Lub<'f>(cf: CombineFields<'f>) -> Lub<'f> {\n+pub fn Lub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Lub<'f, 'tcx> {\n     Lub { fields: cf }\n }\n \n-impl<'f> Combine for Lub<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n+impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"lub\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n-    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n+    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.fields.infcx.tcx;"}, {"sha": "44ee7ba2de6e4beefdfe74e1b4169fe596ab7d05", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -75,8 +75,8 @@ pub type ures = cres<()>; // \"unify result\"\n pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n pub type CoerceResult = cres<Option<ty::AutoAdjustment>>;\n \n-pub struct InferCtxt<'a> {\n-    pub tcx: &'a ty::ctxt,\n+pub struct InferCtxt<'a, 'tcx: 'a> {\n+    pub tcx: &'a ty::ctxt<'tcx>,\n \n     // We instantiate UnificationTable with bounds<ty::t> because the\n     // types that might instantiate a general type variable have an\n@@ -93,7 +93,7 @@ pub struct InferCtxt<'a> {\n \n     // For region variables.\n     region_vars:\n-        RegionVarBindings<'a>,\n+        RegionVarBindings<'a, 'tcx>,\n }\n \n /// Why did we require that the two types be related?\n@@ -291,7 +291,8 @@ pub fn fixup_err_to_string(f: fixup_err) -> String {\n     }\n }\n \n-pub fn new_infer_ctxt<'a>(tcx: &'a ty::ctxt) -> InferCtxt<'a> {\n+pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>)\n+                                -> InferCtxt<'a, 'tcx> {\n     InferCtxt {\n         tcx: tcx,\n         type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n@@ -518,23 +519,23 @@ pub struct CombinedSnapshot {\n     region_vars_snapshot: RegionSnapshot,\n }\n \n-impl<'a> InferCtxt<'a> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn combine_fields<'a>(&'a self, a_is_expected: bool, trace: TypeTrace)\n-                              -> CombineFields<'a> {\n+                              -> CombineFields<'a, 'tcx> {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        trace: trace}\n     }\n \n-    pub fn equate<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Equate<'a> {\n+    pub fn equate<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Equate<'a, 'tcx> {\n         Equate(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn sub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Sub<'a> {\n+    pub fn sub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Sub<'a, 'tcx> {\n         Sub(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn lub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Lub<'a> {\n+    pub fn lub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Lub<'a, 'tcx> {\n         Lub(self.combine_fields(a_is_expected, trace))\n     }\n \n@@ -635,7 +636,7 @@ impl<'a> InferCtxt<'a> {\n     }\n }\n \n-impl<'a> InferCtxt<'a> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn next_ty_var_id(&self) -> TyVid {\n         self.type_variables\n             .borrow_mut()"}, {"sha": "7e61c254a656b3417d6815734ea5e193cbb58dab", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -151,8 +151,8 @@ impl SameRegions {\n \n pub type CombineMap = HashMap<TwoRegions, RegionVid>;\n \n-pub struct RegionVarBindings<'a> {\n-    tcx: &'a ty::ctxt,\n+pub struct RegionVarBindings<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     var_origins: RefCell<Vec<RegionVariableOrigin>>,\n \n     // Constraints of the form `A <= B` introduced by the region\n@@ -217,8 +217,8 @@ pub struct RegionMark {\n     length: uint\n }\n \n-impl<'a> RegionVarBindings<'a> {\n-    pub fn new(tcx: &'a ty::ctxt) -> RegionVarBindings<'a> {\n+impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n+    pub fn new(tcx: &'a ty::ctxt<'tcx>) -> RegionVarBindings<'a, 'tcx> {\n         RegionVarBindings {\n             tcx: tcx,\n             var_origins: RefCell::new(Vec::new()),\n@@ -711,9 +711,7 @@ impl<'a> RegionVarBindings<'a> {\n         *self.values.borrow_mut() = Some(v);\n         errors\n     }\n-}\n \n-impl<'a> RegionVarBindings<'a> {\n     fn is_subregion_of(&self, sub: Region, sup: Region) -> bool {\n         self.tcx.region_maps.is_subregion_of(sub, sup)\n     }\n@@ -959,7 +957,7 @@ struct RegionAndOrigin {\n \n type RegionGraph = graph::Graph<(), Constraint>;\n \n-impl<'a> RegionVarBindings<'a> {\n+impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn infer_variable_values(&self,\n                              errors: &mut Vec<RegionResolutionError>)\n                              -> Vec<VarValue>"}, {"sha": "dcdae7ed29c8d33a306af5c94a6bb4f3cda26ebf", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -74,18 +74,18 @@ pub static try_resolve_tvar_shallow: uint = 0;\n pub static resolve_and_force_all_but_regions: uint =\n     (resolve_all | force_all) & not_regions;\n \n-pub struct ResolveState<'a> {\n-    infcx: &'a InferCtxt<'a>,\n+pub struct ResolveState<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n     modes: uint,\n     err: Option<fixup_err>,\n     v_seen: Vec<TyVid> ,\n     type_depth: uint,\n }\n \n-pub fn resolver<'a>(infcx: &'a InferCtxt,\n-                    modes: uint,\n-                    _: Option<Span>)\n-                    -> ResolveState<'a> {\n+pub fn resolver<'a, 'tcx>(infcx: &'a InferCtxt<'a, 'tcx>,\n+                          modes: uint,\n+                          _: Option<Span>)\n+                          -> ResolveState<'a, 'tcx> {\n     ResolveState {\n         infcx: infcx,\n         modes: modes,\n@@ -95,8 +95,8 @@ pub fn resolver<'a>(infcx: &'a InferCtxt,\n     }\n }\n \n-impl<'a> ty_fold::TypeFolder for ResolveState<'a> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for ResolveState<'a, 'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -109,7 +109,7 @@ impl<'a> ty_fold::TypeFolder for ResolveState<'a> {\n     }\n }\n \n-impl<'a> ResolveState<'a> {\n+impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n     pub fn should(&mut self, mode: uint) -> bool {\n         (self.modes & mode) == mode\n     }"}, {"sha": "7403d50a2109ca287ef63ea24f739f3db23321de", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -28,25 +28,25 @@ use syntax::ast::{Onceness, FnStyle, MutImmutable, MutMutable};\n \n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Sub<'f> {\n-    fields: CombineFields<'f>\n+pub struct Sub<'f, 'tcx: 'f> {\n+    fields: CombineFields<'f, 'tcx>\n }\n \n #[allow(non_snake_case)]\n-pub fn Sub<'f>(cf: CombineFields<'f>) -> Sub<'f> {\n+pub fn Sub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Sub<'f, 'tcx> {\n     Sub { fields: cf }\n }\n \n-impl<'f> Combine for Sub<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.fields.infcx }\n+impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"sub\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n     fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n \n-    fn equate<'a>(&'a self) -> Equate<'a> { Equate(self.fields.clone()) }\n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.fields.clone()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.fields.clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.fields.clone()) }\n+    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n+    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         Sub(self.fields.switch_expected()).tys(b, a)"}, {"sha": "198857fca5055123c908ed32e2fe76dcba43819c", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -39,10 +39,11 @@ use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note};\n use syntax::ast;\n use util::ppaux::{ty_to_string, UserString};\n \n-struct Env<'a> {\n+use arena::TypedArena;\n+\n+struct Env<'a, 'tcx: 'a> {\n     krate: ast::Crate,\n-    tcx: &'a ty::ctxt,\n-    infcx: &'a infer::InferCtxt<'a>,\n+    infcx: &'a infer::InferCtxt<'a, 'tcx>,\n }\n \n struct RH<'a> {\n@@ -129,7 +130,9 @@ fn test_env(_test_name: &str,\n     let named_region_map = resolve_lifetime::krate(&sess, &krate);\n     let region_map = region::resolve_crate(&sess, &krate);\n     let stability_index = stability::Index::build(&krate);\n+    let type_arena = TypedArena::new();\n     let tcx = ty::mk_ctxt(sess,\n+                          &type_arena,\n                           def_map,\n                           named_region_map,\n                           ast_map,\n@@ -139,19 +142,20 @@ fn test_env(_test_name: &str,\n                           lang_items,\n                           stability_index);\n     let infcx = infer::new_infer_ctxt(&tcx);\n-    let env = Env {krate: krate,\n-                   tcx: &tcx,\n-                   infcx: &infcx};\n+    let env = Env {\n+        krate: krate,\n+        infcx: &infcx\n+    };\n     body(env);\n     infcx.resolve_regions_and_report_errors();\n     assert_eq!(tcx.sess.err_count(), expected_err_count);\n }\n \n-impl<'a> Env<'a> {\n+impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn create_region_hierarchy(&self, rh: &RH) {\n         for child_rh in rh.sub.iter() {\n             self.create_region_hierarchy(child_rh);\n-            self.tcx.region_maps.record_encl_scope(child_rh.id, rh.id);\n+            self.infcx.tcx.region_maps.record_encl_scope(child_rh.id, rh.id);\n         }\n     }\n \n@@ -181,7 +185,7 @@ impl<'a> Env<'a> {\n                       -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n             for item in m.items.iter() {\n-                if item.ident.user_string(this.tcx) == names[idx] {\n+                if item.ident.user_string(this.infcx.tcx) == names[idx] {\n                     return search(this, &**item, idx+1, names);\n                 }\n             }\n@@ -220,7 +224,7 @@ impl<'a> Env<'a> {\n         match infer::mk_subty(self.infcx, true, infer::Misc(DUMMY_SP), a, b) {\n             Ok(_) => true,\n             Err(ref e) => fail!(\"Encountered error: {}\",\n-                                ty::type_err_to_str(self.tcx, e))\n+                                ty::type_err_to_str(self.infcx.tcx, e))\n         }\n     }\n \n@@ -253,7 +257,7 @@ impl<'a> Env<'a> {\n     }\n \n     pub fn ty_to_string(&self, a: ty::t) -> String {\n-        ty_to_string(self.tcx, a)\n+        ty_to_string(self.infcx.tcx, a)\n     }\n \n     pub fn t_fn(&self,\n@@ -262,31 +266,31 @@ impl<'a> Env<'a> {\n                 output_ty: ty::t)\n                 -> ty::t\n     {\n-        ty::mk_ctor_fn(self.tcx, binder_id, input_tys, output_ty)\n+        ty::mk_ctor_fn(self.infcx.tcx, binder_id, input_tys, output_ty)\n     }\n \n     pub fn t_int(&self) -> ty::t {\n         ty::mk_int()\n     }\n \n     pub fn t_rptr_late_bound(&self, binder_id: ast::NodeId, id: uint) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx, ty::ReLateBound(binder_id, ty::BrAnon(id)),\n+        ty::mk_imm_rptr(self.infcx.tcx, ty::ReLateBound(binder_id, ty::BrAnon(id)),\n                         self.t_int())\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx, ty::ReScope(id), self.t_int())\n+        ty::mk_imm_rptr(self.infcx.tcx, ty::ReScope(id), self.t_int())\n     }\n \n     pub fn t_rptr_free(&self, nid: ast::NodeId, id: uint) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx,\n+        ty::mk_imm_rptr(self.infcx.tcx,\n                         ty::ReFree(ty::FreeRegion {scope_id: nid,\n                                                     bound_region: ty::BrAnon(id)}),\n                         self.t_int())\n     }\n \n     pub fn t_rptr_static(&self) -> ty::t {\n-        ty::mk_imm_rptr(self.tcx, ty::ReStatic, self.t_int())\n+        ty::mk_imm_rptr(self.infcx.tcx, ty::ReStatic, self.t_int())\n     }\n \n     pub fn dummy_type_trace(&self) -> infer::TypeTrace {\n@@ -299,12 +303,12 @@ impl<'a> Env<'a> {\n         }\n     }\n \n-    pub fn lub(&self) -> Lub<'a> {\n+    pub fn lub(&self) -> Lub<'a, 'tcx> {\n         let trace = self.dummy_type_trace();\n         Lub(self.infcx.combine_fields(true, trace))\n     }\n \n-    pub fn glb(&self) -> Glb<'a> {\n+    pub fn glb(&self) -> Glb<'a, 'tcx> {\n         let trace = self.dummy_type_trace();\n         Glb(self.infcx.combine_fields(true, trace))\n     }\n@@ -317,7 +321,7 @@ impl<'a> Env<'a> {\n         match self.lub().tys(t1, t2) {\n             Ok(t) => t,\n             Err(ref e) => fail!(\"unexpected error computing LUB: {:?}\",\n-                                ty::type_err_to_str(self.tcx, e))\n+                                ty::type_err_to_str(self.infcx.tcx, e))\n         }\n     }\n \n@@ -329,7 +333,7 @@ impl<'a> Env<'a> {\n             }\n             Err(ref e) => {\n                 fail!(\"unexpected error in LUB: {}\",\n-                      ty::type_err_to_str(self.tcx, e))\n+                      ty::type_err_to_str(self.infcx.tcx, e))\n             }\n         }\n     }"}, {"sha": "22d78340e9637fc90a94769044179b0744ff2f30", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -288,8 +288,8 @@ pub trait InferCtxtMethodsForSimplyUnifiableTypes<V:SimplyUnifiable,\n                     -> ures;\n }\n \n-impl<'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n-    InferCtxtMethodsForSimplyUnifiableTypes<V,K> for InferCtxt<'tcx>\n+impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n+    InferCtxtMethodsForSimplyUnifiableTypes<V,K> for InferCtxt<'a, 'tcx>\n {\n     fn simple_vars(&self,\n                    a_is_expected: bool,"}, {"sha": "7104cb9584444e0bb3117dd8a6ad8953ce7d0f3d", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -281,10 +281,10 @@ pub type vtable_map = RefCell<FnvHashMap<MethodCall, vtable_res>>;\n \n pub type impl_vtable_map = RefCell<DefIdMap<vtable_res>>;\n \n-pub struct CrateCtxt<'a> {\n+pub struct CrateCtxt<'a, 'tcx: 'a> {\n     // A mapping from method call sites to traits that have that method.\n     trait_map: resolve::TraitMap,\n-    tcx: &'a ty::ctxt\n+    tcx: &'a ty::ctxt<'tcx>\n }\n \n // Functions that write types into the node type table"}, {"sha": "7e8c53159fb8d0a39e6f6468db91f71b800d9763", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28be695b2c727b380d075986cbe52e699761b56e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=28be695b2c727b380d075986cbe52e699761b56e", "patch": "@@ -254,8 +254,8 @@ impl<'a> fmt::Show for VarianceTerm<'a> {\n  * The first pass over the crate simply builds up the set of inferreds.\n  */\n \n-struct TermsContext<'a> {\n-    tcx: &'a ty::ctxt,\n+struct TermsContext<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n     arena: &'a Arena,\n \n     empty_variances: Rc<ty::ItemVariances>,\n@@ -283,10 +283,10 @@ struct InferredInfo<'a> {\n     term: VarianceTermPtr<'a>,\n }\n \n-fn determine_parameters_to_be_inferred<'a>(tcx: &'a ty::ctxt,\n-                                           arena: &'a mut Arena,\n-                                           krate: &ast::Crate)\n-                                           -> TermsContext<'a> {\n+fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n+                                                 arena: &'a mut Arena,\n+                                                 krate: &ast::Crate)\n+                                                 -> TermsContext<'a, 'tcx> {\n     let mut terms_cx = TermsContext {\n         tcx: tcx,\n         arena: arena,\n@@ -306,7 +306,7 @@ fn determine_parameters_to_be_inferred<'a>(tcx: &'a ty::ctxt,\n     terms_cx\n }\n \n-impl<'a> TermsContext<'a> {\n+impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n     fn add_inferred(&mut self,\n                     item_id: ast::NodeId,\n                     kind: ParamKind,\n@@ -337,7 +337,7 @@ impl<'a> TermsContext<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for TermsContext<'a> {\n+impl<'a, 'tcx> Visitor<()> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         debug!(\"add_inferreds for item {}\", item.repr(self.tcx));\n \n@@ -402,8 +402,8 @@ impl<'a> Visitor<()> for TermsContext<'a> {\n  * We walk the set of items and, for each member, generate new constraints.\n  */\n \n-struct ConstraintContext<'a> {\n-    terms_cx: TermsContext<'a>,\n+struct ConstraintContext<'a, 'tcx: 'a> {\n+    terms_cx: TermsContext<'a, 'tcx>,\n \n     // These are the def-id of the std::kinds::marker::InvariantType,\n     // std::kinds::marker::InvariantLifetime, and so on. The arrays\n@@ -431,9 +431,9 @@ struct Constraint<'a> {\n     variance: &'a VarianceTerm<'a>,\n }\n \n-fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n-                                  krate: &ast::Crate)\n-                                  -> ConstraintContext<'a> {\n+fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n+                                        krate: &ast::Crate)\n+                                        -> ConstraintContext<'a, 'tcx> {\n     let mut invariant_lang_items = [None, ..2];\n     let mut covariant_lang_items = [None, ..2];\n     let mut contravariant_lang_items = [None, ..2];\n@@ -477,7 +477,7 @@ fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n     constraint_cx\n }\n \n-impl<'a> Visitor<()> for ConstraintContext<'a> {\n+impl<'a, 'tcx> Visitor<()> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         let did = ast_util::local_def(item.id);\n         let tcx = self.terms_cx.tcx;\n@@ -546,8 +546,8 @@ fn is_lifetime(map: &ast_map::Map, param_id: ast::NodeId) -> bool {\n     }\n }\n \n-impl<'a> ConstraintContext<'a> {\n-    fn tcx(&self) -> &'a ty::ctxt {\n+impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n         self.terms_cx.tcx\n     }\n \n@@ -942,8 +942,8 @@ impl<'a> ConstraintContext<'a> {\n  * inferred is then written into the `variance_map` in the tcx.\n  */\n \n-struct SolveContext<'a> {\n-    terms_cx: TermsContext<'a>,\n+struct SolveContext<'a, 'tcx: 'a> {\n+    terms_cx: TermsContext<'a, 'tcx>,\n     constraints: Vec<Constraint<'a>> ,\n \n     // Maps from an InferredIndex to the inferred value for that variable.\n@@ -961,7 +961,7 @@ fn solve_constraints(constraints_cx: ConstraintContext) {\n     solutions_cx.write();\n }\n \n-impl<'a> SolveContext<'a> {\n+impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n     fn solve(&mut self) {\n         // Propagate constraints until a fixed point is reached.  Note\n         // that the maximum number of iterations is 2C where C is the"}]}