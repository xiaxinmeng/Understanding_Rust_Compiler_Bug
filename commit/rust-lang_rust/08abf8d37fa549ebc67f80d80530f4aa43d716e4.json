{"sha": "08abf8d37fa549ebc67f80d80530f4aa43d716e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4YWJmOGQzN2ZhNTQ5ZWJjNjdmODBkODA1MzBmNGFhNDNkNzE2ZTQ=", "commit": {"author": {"name": "Kevin Atkinson", "email": "kevina@cs.utah.edu", "date": "2012-01-10T21:50:40Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-01-10T23:59:57Z"}, "message": "Support explicit discriminant numbers on tag variants.\n\nAddresses issue #1393.\n\nFor now disallow disr. values unless all variants use nullary\ncontractors (i.e. \"enum-like\").\n\nDisr. values are now encoded in the crate metadata, but only when it\nwill differ from the inferred value based on the order.", "tree": {"sha": "f6c9bce62c494a37d989d07be4661f57c0c7eba3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6c9bce62c494a37d989d07be4661f57c0c7eba3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08abf8d37fa549ebc67f80d80530f4aa43d716e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08abf8d37fa549ebc67f80d80530f4aa43d716e4", "html_url": "https://github.com/rust-lang/rust/commit/08abf8d37fa549ebc67f80d80530f4aa43d716e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08abf8d37fa549ebc67f80d80530f4aa43d716e4/comments", "author": {"login": "kevina", "id": 1271492, "node_id": "MDQ6VXNlcjEyNzE0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1271492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kevina", "html_url": "https://github.com/kevina", "followers_url": "https://api.github.com/users/kevina/followers", "following_url": "https://api.github.com/users/kevina/following{/other_user}", "gists_url": "https://api.github.com/users/kevina/gists{/gist_id}", "starred_url": "https://api.github.com/users/kevina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kevina/subscriptions", "organizations_url": "https://api.github.com/users/kevina/orgs", "repos_url": "https://api.github.com/users/kevina/repos", "events_url": "https://api.github.com/users/kevina/events{/privacy}", "received_events_url": "https://api.github.com/users/kevina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0fe6723fc2f431205092bda9ec399d932081bd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0fe6723fc2f431205092bda9ec399d932081bd0", "html_url": "https://github.com/rust-lang/rust/commit/d0fe6723fc2f431205092bda9ec399d932081bd0"}], "stats": {"total": 197, "additions": 167, "deletions": 30}, "files": [{"sha": "e1c05bf2c9f5447d8055215b805686d572e59907", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=08abf8d37fa549ebc67f80d80530f4aa43d716e4", "patch": "@@ -70,6 +70,9 @@ const tag_item_method: uint = 0x31u;\n const tag_impl_iface: uint = 0x32u;\n const tag_impl_iface_did: uint = 0x33u;\n \n+// discriminator value for variants\n+const tag_disr_val: uint = 0x34u;\n+\n // djb's cdb hashes.\n fn hash_node_id(&&node_id: int) -> uint { ret 177573u ^ (node_id as uint); }\n "}, {"sha": "c40e459bb5c822ab97573a327256a05ceaee57ba", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=08abf8d37fa549ebc67f80d80530f4aa43d716e4", "patch": "@@ -88,6 +88,17 @@ fn variant_tag_id(d: ebml::doc) -> ast::def_id {\n     ret parse_def_id(ebml::doc_data(tagdoc));\n }\n \n+fn variant_disr_val(d: ebml::doc) -> option::t<int> {\n+    alt ebml::maybe_get_doc(d, tag_disr_val) {\n+      some(val_doc) {\n+        let val_buf = ebml::doc_data(val_doc);\n+        let val = int::parse_buf(val_buf, 10u);\n+        ret some(val);\n+      }\n+      _ { ret none;}\n+    }\n+}\n+\n fn doc_type(doc: ebml::doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let tp = ebml::get_doc(doc, tag_items_data_item_type);\n     parse_ty_data(tp.data, cdata.cnum, tp.start, tcx, {|did|\n@@ -240,6 +251,7 @@ fn get_tag_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     let item = find_item(id, items);\n     let infos: [ty::variant_info] = [];\n     let variant_ids = tag_variant_ids(item, cdata);\n+    let disr_val = 0;\n     for did: ast::def_id in variant_ids {\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type(item, tcx, cdata);\n@@ -250,7 +262,13 @@ fn get_tag_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n           }\n           _ { /* Nullary tag variant. */ }\n         }\n-        infos += [@{args: arg_tys, ctor_ty: ctor_ty, id: did}];\n+        alt variant_disr_val(item) {\n+          some(val) { disr_val = val; }\n+          _         { /* empty */ }\n+        }\n+        infos += [@{args: arg_tys, ctor_ty: ctor_ty, id: did,\n+                    disr_val: disr_val}];\n+        disr_val += 1;\n     }\n     ret infos;\n }"}, {"sha": "e666d204020c5c8eeba22c118e7ae5e5f5905ad8", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=08abf8d37fa549ebc67f80d80530f4aa43d716e4", "patch": "@@ -228,6 +228,12 @@ fn encode_discriminant(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n     ebml::end_tag(ebml_w);\n }\n \n+fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: ebml::writer, disr_val: int) {\n+    ebml::start_tag(ebml_w, tag_disr_val);\n+    ebml_w.writer.write(str::bytes(int::to_str(disr_val,10u)));\n+    ebml::end_tag(ebml_w);\n+}\n+\n fn encode_tag_id(ebml_w: ebml::writer, id: def_id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_tag_id);\n     ebml_w.writer.write(str::bytes(def_to_str(id)));\n@@ -237,6 +243,7 @@ fn encode_tag_id(ebml_w: ebml::writer, id: def_id) {\n fn encode_tag_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                            id: node_id, variants: [variant],\n                            &index: [entry<int>], ty_params: [ty_param]) {\n+    let disr_val = 0;\n     for variant: variant in variants {\n         index += [{val: variant.node.id, pos: ebml_w.writer.tell()}];\n         ebml::start_tag(ebml_w, tag_items_data_item);\n@@ -249,8 +256,13 @@ fn encode_tag_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n             encode_symbol(ecx, ebml_w, variant.node.id);\n         }\n         encode_discriminant(ecx, ebml_w, variant.node.id);\n+        if variant.node.disr_val != disr_val {\n+            encode_disr_val(ecx, ebml_w, variant.node.disr_val);\n+            disr_val = variant.node.disr_val;\n+        }\n         encode_type_param_bounds(ebml_w, ecx, ty_params);\n         ebml::end_tag(ebml_w);\n+        disr_val += 1;\n     }\n }\n "}, {"sha": "998c944b6e0d3f7ba0bd0198076f87c6a592d876", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=08abf8d37fa549ebc67f80d80530f4aa43d716e4", "patch": "@@ -1726,17 +1726,15 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         Unreachable(unr_cx);\n         let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb, n_variants);\n         let next_cx = new_sub_block_ctxt(cx, \"tag-iter-next\");\n-        let i = 0u;\n         for variant: ty::variant_info in *variants {\n             let variant_cx =\n                 new_sub_block_ctxt(cx,\n                                    \"tag-iter-variant-\" +\n-                                       uint::to_str(i, 10u));\n-            AddCase(llswitch, C_int(ccx, i as int), variant_cx.llbb);\n+                                       int::to_str(variant.disr_val, 10u));\n+            AddCase(llswitch, C_int(ccx, variant.disr_val), variant_cx.llbb);\n             variant_cx =\n                 iter_variant(variant_cx, llunion_a_ptr, variant, tps, tid, f);\n             Br(variant_cx, next_cx.llbb);\n-            i += 1u;\n         }\n         ret next_cx;\n       }\n@@ -2745,12 +2743,9 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n             let bcx = alloc_result.bcx;\n             let lltagptr = PointerCast(bcx, lltagblob, T_ptr(lltagty));\n             let lldiscrimptr = GEPi(bcx, lltagptr, [0, 0]);\n-            let d = if vec::len(*ty::tag_variants(ccx.tcx, tid)) != 1u {\n-                let lldiscrim_gv = lookup_discriminant(bcx.fcx.lcx, vid);\n-                let lldiscrim = Load(bcx, lldiscrim_gv);\n-                lldiscrim\n-            } else { C_int(ccx, 0) };\n-            Store(bcx, d, lldiscrimptr);\n+            let lldiscrim_gv = lookup_discriminant(bcx.fcx.lcx, vid);\n+            let lldiscrim = Load(bcx, lldiscrim_gv);\n+            Store(bcx, lldiscrim, lldiscrimptr);\n             ret lval_no_env(bcx, lltagptr, temporary);\n         }\n       }\n@@ -4685,7 +4680,7 @@ fn trans_res_ctor(cx: @local_ctxt, sp: span, dtor: ast::fn_decl,\n \n \n fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n-                     variant: ast::variant, index: int, is_degen: bool,\n+                     variant: ast::variant, is_degen: bool,\n                      ty_params: [ast::ty_param]) {\n     let ccx = cx.ccx;\n \n@@ -4735,7 +4730,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n             let lltagptr =\n                 PointerCast(bcx, fcx.llretptr, T_opaque_tag_ptr(ccx));\n             let lldiscrimptr = GEPi(bcx, lltagptr, [0, 0]);\n-            Store(bcx, C_int(ccx, index), lldiscrimptr);\n+            Store(bcx, C_int(ccx, variant.node.disr_val), lldiscrimptr);\n             GEPi(bcx, lltagptr, [0, 1])\n         };\n     i = 0u;\n@@ -5086,10 +5081,8 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n       ast::item_tag(variants, tps) {\n         let sub_cx = extend_path(cx, item.ident);\n         let degen = vec::len(variants) == 1u;\n-        let i = 0;\n         for variant: ast::variant in variants {\n-            trans_tag_variant(sub_cx, item.id, variant, i, degen, tps);\n-            i += 1;\n+            trans_tag_variant(sub_cx, item.id, variant, degen, tps);\n         }\n       }\n       ast::item_const(_, expr) { trans_const(cx.ccx, expr, item.id); }\n@@ -5421,19 +5414,18 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n     visit::visit_item(it, new_pt, v);\n     alt it.node {\n       ast::item_tag(variants, _) {\n-        let i = 0u;\n         for variant in variants {\n             let p = new_pt + [variant.node.name, \"discrim\"];\n             let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n+            let disr_val = variant.node.disr_val;\n             let discrim_gvar = str::as_buf(s, {|buf|\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n             });\n-            llvm::LLVMSetInitializer(discrim_gvar, C_int(ccx, i as int));\n+            llvm::LLVMSetInitializer(discrim_gvar, C_int(ccx, disr_val));\n             llvm::LLVMSetGlobalConstant(discrim_gvar, True);\n             ccx.discrims.insert(\n                 ast_util::local_def(variant.node.id), discrim_gvar);\n             ccx.discrim_symbols.insert(variant.node.id, s);\n-            i += 1u;\n         }\n       }\n       ast::item_impl(tps, some(@{node: ast::ty_path(_, id), _}), _, ms) {"}, {"sha": "a7eb94b9288602153ccd55f21ca3d01e54c6b28a", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=08abf8d37fa549ebc67f80d80530f4aa43d716e4", "patch": "@@ -16,7 +16,7 @@ import trans_common::*;\n // An option identifying a branch (either a literal, a tag variant or a range)\n tag opt {\n     lit(@ast::expr);\n-    var(/* variant id */uint, /* variant dids */{tg: def_id, var: def_id});\n+    var(/* disr val */int, /* variant dids */{tg: def_id, var: def_id});\n     range(@ast::expr, @ast::expr);\n }\n fn opt_eq(a: opt, b: opt) -> bool {\n@@ -53,7 +53,7 @@ fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n           }\n         }\n       }\n-      var(id, _) { ret single_result(rslt(bcx, C_int(ccx, id as int))); }\n+      var(disr_val, _) { ret single_result(rslt(bcx, C_int(ccx, disr_val))); }\n       range(l1, l2) {\n         ret range_result(rslt(bcx, trans::trans_const_expr(ccx, l1)),\n                          rslt(bcx, trans::trans_const_expr(ccx, l2)));\n@@ -64,10 +64,8 @@ fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n fn variant_opt(ccx: @crate_ctxt, pat_id: ast::node_id) -> opt {\n     let vdef = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n     let variants = ty::tag_variants(ccx.tcx, vdef.tg);\n-    let i = 0u;\n     for v: ty::variant_info in *variants {\n-        if vdef.var == v.id { ret var(i, vdef); }\n-        i += 1u;\n+        if vdef.var == v.id { ret var(v.disr_val, vdef); }\n     }\n     fail;\n }"}, {"sha": "dbd688de402db2b3109204c4cec6b7dfc4f4e217", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=08abf8d37fa549ebc67f80d80530f4aa43d716e4", "patch": "@@ -2686,7 +2686,8 @@ fn impl_iface(cx: ctxt, id: ast::def_id) -> option::t<t> {\n }\n \n // Tag information\n-type variant_info = @{args: [ty::t], ctor_ty: ty::t, id: ast::def_id};\n+type variant_info = @{args: [ty::t], ctor_ty: ty::t, id: ast::def_id,\n+                      disr_val: int};\n \n fn tag_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n     alt cx.tag_var_cache.find(id) {\n@@ -2705,7 +2706,9 @@ fn tag_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n                 } else { [] };\n                 @{args: arg_tys,\n                   ctor_ty: ctor_ty,\n-                  id: ast_util::local_def(variant.node.id)}\n+                  id: ast_util::local_def(variant.node.id),\n+                  disr_val: variant.node.disr_val\n+                 }\n             })\n           }\n         }"}, {"sha": "d519ff0577f1ea2c08696b1df7c5df58529232b1", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=08abf8d37fa549ebc67f80d80530f4aa43d716e4", "patch": "@@ -416,7 +416,8 @@ type native_mod =\n \n type variant_arg = {ty: @ty, id: node_id};\n \n-type variant_ = {name: ident, args: [variant_arg], id: node_id};\n+type variant_ = {name: ident, args: [variant_arg], id: node_id,\n+                disr_val: int, disr_expr: option::t<@expr>};\n \n type variant = spanned<variant_>;\n "}, {"sha": "70f8d7e34062c9c34f68ed951e8982e039f6bd7f", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=08abf8d37fa549ebc67f80d80530f4aa43d716e4", "patch": "@@ -469,7 +469,9 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n         ret {ty: fld.fold_ty(va.ty), id: va.id};\n     }\n     let fold_variant_arg = bind fold_variant_arg_(_, fld);\n-    ret {name: v.name, args: vec::map(v.args, fold_variant_arg), id: v.id};\n+    ret {name: v.name, args: vec::map(v.args, fold_variant_arg), id: v.id,\n+         disr_val: v.disr_val,  disr_expr: v.disr_expr\n+         /* FIXME: is this right (copying disr_val and disr_expr) */};\n }\n \n fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident { ret i; }"}, {"sha": "a27209424ae3ecdfa7c7b922db08653933393541", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=08abf8d37fa549ebc67f80d80530f4aa43d716e4", "patch": "@@ -2072,11 +2072,16 @@ fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n             spanned(ty.span.lo, ty.span.hi,\n                     {name: id,\n                      args: [{ty: ty, id: p.get_id()}],\n-                     id: p.get_id()});\n+                     id: p.get_id(),\n+                     disr_val: 0,\n+                     disr_expr: none});\n         ret mk_item(p, lo, ty.span.hi, id,\n                     ast::item_tag([variant], ty_params), attrs);\n     }\n     expect(p, token::LBRACE);\n+    let all_nullary = true;\n+    let have_disr = false;\n+    let disr_val = 0;\n     while p.peek() != token::RBRACE {\n         let tok = p.peek();\n         alt tok {\n@@ -2086,8 +2091,10 @@ fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n             p.bump();\n             let args: [ast::variant_arg] = [];\n             let vhi = p.get_hi_pos();\n+            let disr_expr = none;\n             alt p.peek() {\n               token::LPAREN. {\n+                all_nullary = false;\n                 let arg_tys = parse_seq(token::LPAREN, token::RPAREN,\n                                         seq_sep(token::COMMA),\n                                         {|p| parse_ty(p, false)}, p);\n@@ -2096,12 +2103,41 @@ fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                 }\n                 vhi = arg_tys.span.hi;\n               }\n+              token::EQ. {\n+                have_disr = true;\n+                p.bump();\n+                let e = parse_expr(p);\n+                // FIXME: eval_const_expr does no error checking, nor do I.\n+                // Also, the parser is not the right place to do this; likely\n+                // somewhere in the middle end so that constants can be\n+                // refereed to, even if they are after the declaration for the\n+                // type.  Finally, eval_const_expr probably shouldn't exist as\n+                // it Graydon puts it: \"[I] am a little worried at its\n+                // presence since it quasi-duplicates stuff that trans should\n+                // probably be doing.\"  (See issue #1417)\n+                alt syntax::ast_util::eval_const_expr(e) {\n+                  syntax::ast_util::const_int(val) {\n+                    disr_val = val as int;\n+                    // FIXME: check that value is in range\n+                  }\n+                }\n+                if option::is_some\n+                    (vec::find\n+                     (variants, {|v| v.node.disr_val == disr_val}))\n+                {\n+                    p.fatal(\"discriminator value \" + /* str(disr_val) + */\n+                            \"already exists.\");\n+                }\n+                disr_expr = some(e);\n+              }\n               _ {/* empty */ }\n             }\n             expect(p, token::SEMI);\n             p.get_id();\n-            let vr = {name: p.get_str(name), args: args, id: p.get_id()};\n+            let vr = {name: p.get_str(name), args: args, id: p.get_id(),\n+                      disr_val: disr_val, disr_expr: disr_expr};\n             variants += [spanned(vlo, vhi, vr)];\n+            disr_val += 1;\n           }\n           token::RBRACE. {/* empty */ }\n           _ {\n@@ -2111,6 +2147,9 @@ fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n         }\n     }\n     let hi = p.get_hi_pos();\n+    if (have_disr && !all_nullary) {\n+        p.fatal(\"discriminator values can only be used with enum-like tag\");\n+    }\n     p.bump();\n     ret mk_item(p, lo, hi, id, ast::item_tag(variants, ty_params), attrs);\n }"}, {"sha": "c3e671f101150c3b1fdf398237be10f12edda5a0", "filename": "src/test/compile-fail/tag-variant-disr-dup.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Ftest%2Fcompile-fail%2Ftag-variant-disr-dup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Ftest%2Fcompile-fail%2Ftag-variant-disr-dup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-variant-disr-dup.rs?ref=08abf8d37fa549ebc67f80d80530f4aa43d716e4", "patch": "@@ -0,0 +1,11 @@\n+//error-pattern:discriminator value already exists\n+\n+// black and white have the same discriminator value ...\n+\n+tag color {\n+    red = 0xff0000;\n+    green = 0x00ff00;\n+    blue = 0x0000ff;\n+    black = 0x000000;\n+    white = 0x000000;\n+}"}, {"sha": "1d3a59e172ff03dbf272e50715efdebc7ee191c1", "filename": "src/test/compile-fail/tag-variant-disr-non-nullary.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Ftest%2Fcompile-fail%2Ftag-variant-disr-non-nullary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Ftest%2Fcompile-fail%2Ftag-variant-disr-non-nullary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-variant-disr-non-nullary.rs?ref=08abf8d37fa549ebc67f80d80530f4aa43d716e4", "patch": "@@ -0,0 +1,11 @@\n+//error-pattern: discriminator values can only be used with enum-like tag\n+// black and white have the same discriminator value ...\n+\n+tag color {\n+    red = 0xff0000;\n+    green = 0x00ff00;\n+    blue = 0x0000ff;\n+    black = 0x000000;\n+    white = 0xffffff;\n+    other (str);\n+}"}, {"sha": "a09de4794c42a36d8c114f5862b11f831e2f4982", "filename": "src/test/run-pass/tag-variant-disr-val.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08abf8d37fa549ebc67f80d80530f4aa43d716e4/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs?ref=08abf8d37fa549ebc67f80d80530f4aa43d716e4", "patch": "@@ -0,0 +1,47 @@\n+tag color {\n+    red = 0xff0000;\n+    green = 0x00ff00;\n+    blue = 0x0000ff;\n+    black = 0x000000;\n+    white = 0xFFFFFF;\n+    imaginary = -1;\n+}\n+\n+fn main() {\n+    test_color(red, 0xff0000, \"red\");\n+    test_color(green, 0x00ff00, \"green\");\n+    test_color(blue, 0x0000ff, \"blue\");\n+    test_color(black, 0x000000, \"black\");\n+    test_color(white, 0xFFFFFF, \"white\");\n+    test_color(imaginary, -1, \"imaginary\");\n+}\n+\n+fn test_color(color: color, val: int, name: str) unsafe {\n+    assert unsafe::reinterpret_cast(color) == val;\n+    assert get_color_alt(color) == name;\n+    assert get_color_if(color) == name;\n+}\n+\n+fn get_color_alt(color: color) -> str {\n+    alt color {\n+      red. {\"red\"}\n+      green. {\"green\"}\n+      blue. {\"blue\"}\n+      black. {\"black\"}\n+      white. {\"white\"}\n+      imaginary. {\"imaginary\"}\n+      _ {\"unknown\"}\n+    }\n+}\n+\n+fn get_color_if(color: color) -> str {\n+    if color == red {\"red\"}\n+    else if color == green {\"green\"}\n+    else if color == blue {\"blue\"}\n+    else if color == black {\"black\"}\n+    else if color == white {\"white\"}\n+    else if color == imaginary {\"imaginary\"}\n+    else {\"unknown\"}\n+}\n+\n+"}]}