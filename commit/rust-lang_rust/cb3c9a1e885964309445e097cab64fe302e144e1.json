{"sha": "cb3c9a1e885964309445e097cab64fe302e144e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiM2M5YTFlODg1OTY0MzA5NDQ1ZTA5N2NhYjY0ZmUzMDJlMTQ0ZTE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-29T11:40:14Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-16T14:29:22Z"}, "message": "rustc: teach const_eval more about types.", "tree": {"sha": "fa8eb68338d9883b9d5c33c7aad70a5d4be4c5b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa8eb68338d9883b9d5c33c7aad70a5d4be4c5b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb3c9a1e885964309445e097cab64fe302e144e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb3c9a1e885964309445e097cab64fe302e144e1", "html_url": "https://github.com/rust-lang/rust/commit/cb3c9a1e885964309445e097cab64fe302e144e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb3c9a1e885964309445e097cab64fe302e144e1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "html_url": "https://github.com/rust-lang/rust/commit/4d8f995c3a482fecdb9a77455cd8d68d514d62ac"}], "stats": {"total": 335, "additions": 195, "deletions": 140}, "files": [{"sha": "08db053d3f4ac8498b5f969010c65050699e55f1", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=cb3c9a1e885964309445e097cab64fe302e144e1", "patch": "@@ -199,7 +199,7 @@ impl LintPass for TypeLimits {\n                             if let ast::LitInt(shift, _) = lit.node { shift >= bits }\n                             else { false }\n                         } else {\n-                            match eval_const_expr_partial(cx.tcx, &**r) {\n+                            match eval_const_expr_partial(cx.tcx, &**r, Some(cx.tcx.types.uint)) {\n                                 Ok(const_int(shift)) => { shift as u64 >= bits },\n                                 Ok(const_uint(shift)) => { shift >= bits },\n                                 _ => { false }"}, {"sha": "03456f8529028a36a8527a3f00cc3a5e8e99548a", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=cb3c9a1e885964309445e097cab64fe302e144e1", "patch": "@@ -23,6 +23,7 @@ use middle::mem_categorization::cmt;\n use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n+use std::cmp::Ordering;\n use std::fmt;\n use std::iter::{range_inclusive, AdditiveIterator, FromIterator, repeat};\n use std::num::Float;\n@@ -821,7 +822,9 @@ fn range_covered_by_constructor(ctor: &Constructor,\n     let cmp_from = compare_const_vals(c_from, from);\n     let cmp_to = compare_const_vals(c_to, to);\n     match (cmp_from, cmp_to) {\n-        (Some(val1), Some(val2)) => Some(val1 >= 0 && val2 <= 0),\n+        (Some(cmp_from), Some(cmp_to)) => {\n+            Some(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n+        }\n         _ => None\n     }\n }"}, {"sha": "72600347334f9a960271a83319f944912ccd1416", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 142, "deletions": 75, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=cb3c9a1e885964309445e097cab64fe302e144e1", "patch": "@@ -16,7 +16,7 @@ pub use self::const_val::*;\n use metadata::csearch;\n use middle::{astencode, def};\n use middle::pat_util::def_to_path;\n-use middle::ty::{self};\n+use middle::ty::{self, Ty};\n use middle::astconv_util::{ast_ty_to_prim_ty};\n \n use syntax::ast::{self, Expr};\n@@ -25,6 +25,7 @@ use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::{ast_map, ast_util, codemap};\n \n+use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n use std::rc::Rc;\n \n@@ -205,17 +206,23 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n }\n \n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n-    match eval_const_expr_partial(tcx, e) {\n+    match eval_const_expr_partial(tcx, e, None) {\n         Ok(r) => r,\n         Err(s) => tcx.sess.span_fatal(e.span, &s[])\n     }\n }\n \n-pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, String> {\n+pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                     e: &Expr,\n+                                     ty_hint: Option<Ty<'tcx>>)\n+                                     -> Result<const_val, String> {\n     fn fromb(b: bool) -> Result<const_val, String> { Ok(const_int(b as i64)) }\n+\n+    let ety = ty_hint.or_else(|| ty::expr_ty_opt(tcx, e));\n+\n     match e.node {\n       ast::ExprUnary(ast::UnNeg, ref inner) => {\n-        match eval_const_expr_partial(tcx, &**inner) {\n+        match eval_const_expr_partial(tcx, &**inner, ety) {\n           Ok(const_float(f)) => Ok(const_float(-f)),\n           Ok(const_int(i)) => Ok(const_int(-i)),\n           Ok(const_uint(i)) => Ok(const_uint(-i)),\n@@ -225,16 +232,20 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n         }\n       }\n       ast::ExprUnary(ast::UnNot, ref inner) => {\n-        match eval_const_expr_partial(tcx, &**inner) {\n+        match eval_const_expr_partial(tcx, &**inner, ety) {\n           Ok(const_int(i)) => Ok(const_int(!i)),\n           Ok(const_uint(i)) => Ok(const_uint(!i)),\n           Ok(const_bool(b)) => Ok(const_bool(!b)),\n           _ => Err(\"not on float or string\".to_string())\n         }\n       }\n       ast::ExprBinary(op, ref a, ref b) => {\n-        match (eval_const_expr_partial(tcx, &**a),\n-               eval_const_expr_partial(tcx, &**b)) {\n+        let b_ty = match op.node {\n+            ast::BiShl | ast::BiShr => Some(tcx.types.uint),\n+            _ => ety\n+        };\n+        match (eval_const_expr_partial(tcx, &**a, ety),\n+               eval_const_expr_partial(tcx, &**b, b_ty)) {\n           (Ok(const_float(a)), Ok(const_float(b))) => {\n             match op.node {\n               ast::BiAdd => Ok(const_float(a + b)),\n@@ -339,63 +350,53 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n         // This tends to get called w/o the type actually having been\n         // populated in the ctxt, which was causing things to blow up\n         // (#5900). Fall back to doing a limited lookup to get past it.\n-        let ety = ty::expr_ty_opt(tcx, e)\n-                .or_else(|| ast_ty_to_prim_ty(tcx, &**target_ty))\n+        let ety = ety.or_else(|| ast_ty_to_prim_ty(tcx, &**target_ty))\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_fatal(target_ty.span,\n                                         \"target type not found for const cast\")\n                 });\n-\n-        macro_rules! define_casts {\n-            ($val:ident, {\n-                $($ty_pat:pat => (\n-                    $intermediate_ty:ty,\n-                    $const_type:ident,\n-                    $target_ty:ty\n-                )),*\n-            }) => (match ety.sty {\n-                $($ty_pat => {\n-                    match $val {\n-                        const_bool(b) => Ok($const_type(b as $intermediate_ty as $target_ty)),\n-                        const_uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n-                        const_int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n-                        const_float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),\n-                        _ => Err(concat!(\n-                            \"can't cast this type to \", stringify!($const_type)\n-                        ).to_string())\n-                    }\n-                },)*\n-                _ => Err(\"can't cast this type\".to_string())\n-            })\n-        }\n-\n-        eval_const_expr_partial(tcx, &**base)\n-            .and_then(|val| define_casts!(val, {\n-                ty::ty_int(ast::TyIs(_)) => (int, const_int, i64),\n-                ty::ty_int(ast::TyI8) => (i8, const_int, i64),\n-                ty::ty_int(ast::TyI16) => (i16, const_int, i64),\n-                ty::ty_int(ast::TyI32) => (i32, const_int, i64),\n-                ty::ty_int(ast::TyI64) => (i64, const_int, i64),\n-                ty::ty_uint(ast::TyUs(_)) => (uint, const_uint, u64),\n-                ty::ty_uint(ast::TyU8) => (u8, const_uint, u64),\n-                ty::ty_uint(ast::TyU16) => (u16, const_uint, u64),\n-                ty::ty_uint(ast::TyU32) => (u32, const_uint, u64),\n-                ty::ty_uint(ast::TyU64) => (u64, const_uint, u64),\n-                ty::ty_float(ast::TyF32) => (f32, const_float, f64),\n-                ty::ty_float(ast::TyF64) => (f64, const_float, f64)\n-            }))\n+        // Prefer known type to noop, but always have a type hint.\n+        let base_hint = ty::expr_ty_opt(tcx, &**base).unwrap_or(ety);\n+        let val = try!(eval_const_expr_partial(tcx, &**base, Some(base_hint)));\n+        cast_const(val, ety)\n       }\n       ast::ExprPath(_) | ast::ExprQPath(_) => {\n-          match lookup_const(tcx, e) {\n-              Some(actual_e) => eval_const_expr_partial(tcx, &*actual_e),\n-              None => Err(\"non-constant path in constant expr\".to_string())\n-          }\n+          let opt_def = tcx.def_map.borrow().get(&e.id).cloned();\n+          let (const_expr, const_ty) = match opt_def {\n+              Some(def::DefConst(def_id)) => {\n+                  if ast_util::is_local(def_id) {\n+                      match tcx.map.find(def_id.node) {\n+                          Some(ast_map::NodeItem(it)) => match it.node {\n+                              ast::ItemConst(ref ty, ref expr) => {\n+                                  (Some(&**expr), Some(&**ty))\n+                              }\n+                              _ => (None, None)\n+                          },\n+                          _ => (None, None)\n+                      }\n+                  } else {\n+                      (lookup_const_by_id(tcx, def_id), None)\n+                  }\n+              }\n+              Some(def::DefVariant(enum_def, variant_def, _)) => {\n+                  (lookup_variant_by_id(tcx, enum_def, variant_def), None)\n+              }\n+              _ => (None, None)\n+          };\n+          let const_expr = match const_expr {\n+              Some(actual_e) => actual_e,\n+              None => return Err(\"non-constant path in constant expr\".to_string())\n+          };\n+          let ety = ety.or_else(|| const_ty.and_then(|ty| ast_ty_to_prim_ty(tcx, ty)));\n+          eval_const_expr_partial(tcx, const_expr, ety)\n       }\n-      ast::ExprLit(ref lit) => Ok(lit_to_const(&**lit)),\n-      ast::ExprParen(ref e)     => eval_const_expr_partial(tcx, &**e),\n+      ast::ExprLit(ref lit) => {\n+          Ok(lit_to_const(&**lit, ety))\n+      }\n+      ast::ExprParen(ref e)     => eval_const_expr_partial(tcx, &**e, ety),\n       ast::ExprBlock(ref block) => {\n         match block.expr {\n-            Some(ref expr) => eval_const_expr_partial(tcx, &**expr),\n+            Some(ref expr) => eval_const_expr_partial(tcx, &**expr, ety),\n             None => Ok(const_int(0i64))\n         }\n       }\n@@ -404,7 +405,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n         if let Some(&ast::ExprTup(ref fields)) = lookup_const(tcx, &**base).map(|s| &s.node) {\n             // Check that the given index is within bounds and evaluate its value\n             if fields.len() > index.node {\n-                return eval_const_expr_partial(tcx, &*fields[index.node])\n+                return eval_const_expr_partial(tcx, &*fields[index.node], None)\n             } else {\n                 return Err(\"tuple index out of bounds\".to_string())\n             }\n@@ -419,7 +420,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n             // Check that the given field exists and evaluate it\n             if let Some(f) = fields.iter().find(|f|\n                                            f.ident.node.as_str() == field_name.node.as_str()) {\n-                return eval_const_expr_partial(tcx, &*f.expr)\n+                return eval_const_expr_partial(tcx, &*f.expr, None)\n             } else {\n                 return Err(\"nonexistent struct field\".to_string())\n             }\n@@ -431,16 +432,58 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n     }\n }\n \n-pub fn lit_to_const(lit: &ast::Lit) -> const_val {\n+fn cast_const(val: const_val, ty: Ty) -> Result<const_val, String> {\n+    macro_rules! define_casts {\n+        ($($ty_pat:pat => (\n+            $intermediate_ty:ty,\n+            $const_type:ident,\n+            $target_ty:ty\n+        )),*) => (match ty.sty {\n+            $($ty_pat => {\n+                match val {\n+                    const_bool(b) => Ok($const_type(b as $intermediate_ty as $target_ty)),\n+                    const_uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n+                    const_int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n+                    const_float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),\n+                    _ => Err(concat!(\"can't cast this type to \",\n+                                     stringify!($const_type)).to_string())\n+                }\n+            },)*\n+            _ => Err(\"can't cast this type\".to_string())\n+        })\n+    }\n+\n+    define_casts!{\n+        ty::ty_int(ast::TyIs(_)) => (int, const_int, i64),\n+        ty::ty_int(ast::TyI8) => (i8, const_int, i64),\n+        ty::ty_int(ast::TyI16) => (i16, const_int, i64),\n+        ty::ty_int(ast::TyI32) => (i32, const_int, i64),\n+        ty::ty_int(ast::TyI64) => (i64, const_int, i64),\n+        ty::ty_uint(ast::TyUs(_)) => (uint, const_uint, u64),\n+        ty::ty_uint(ast::TyU8) => (u8, const_uint, u64),\n+        ty::ty_uint(ast::TyU16) => (u16, const_uint, u64),\n+        ty::ty_uint(ast::TyU32) => (u32, const_uint, u64),\n+        ty::ty_uint(ast::TyU64) => (u64, const_uint, u64),\n+        ty::ty_float(ast::TyF32) => (f32, const_float, f64),\n+        ty::ty_float(ast::TyF64) => (f64, const_float, f64)\n+    }\n+}\n+\n+fn lit_to_const(lit: &ast::Lit, ty_hint: Option<Ty>) -> const_val {\n     match lit.node {\n         ast::LitStr(ref s, _) => const_str((*s).clone()),\n         ast::LitBinary(ref data) => {\n             const_binary(Rc::new(data.iter().map(|x| *x).collect()))\n         }\n         ast::LitByte(n) => const_uint(n as u64),\n         ast::LitChar(n) => const_uint(n as u64),\n-        ast::LitInt(n, ast::SignedIntLit(_, ast::Plus)) |\n-        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Plus)) => const_int(n as i64),\n+        ast::LitInt(n, ast::SignedIntLit(_, ast::Plus)) => const_int(n as i64),\n+        ast::LitInt(n, ast::UnsuffixedIntLit(ast::Plus)) => {\n+            match ty_hint.map(|ty| &ty.sty) {\n+                Some(&ty::ty_uint(_)) => const_uint(n),\n+                _ => const_int(n as i64)\n+            }\n+        }\n         ast::LitInt(n, ast::SignedIntLit(_, ast::Minus)) |\n         ast::LitInt(n, ast::UnsuffixedIntLit(ast::Minus)) => const_int(-(n as i64)),\n         ast::LitInt(n, ast::UnsignedIntLit(_)) => const_uint(n),\n@@ -452,21 +495,45 @@ pub fn lit_to_const(lit: &ast::Lit) -> const_val {\n     }\n }\n \n-fn compare_vals<T: PartialOrd>(a: T, b: T) -> Option<int> {\n-    Some(if a == b { 0 } else if a < b { -1 } else { 1 })\n-}\n-pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n-    match (a, b) {\n-        (&const_int(a), &const_int(b)) => compare_vals(a, b),\n-        (&const_uint(a), &const_uint(b)) => compare_vals(a, b),\n-        (&const_float(a), &const_float(b)) => compare_vals(a, b),\n-        (&const_str(ref a), &const_str(ref b)) => compare_vals(a, b),\n-        (&const_bool(a), &const_bool(b)) => compare_vals(a, b),\n-        (&const_binary(ref a), &const_binary(ref b)) => compare_vals(a, b),\n-        _ => None\n-    }\n+pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<Ordering> {\n+    Some(match (a, b) {\n+        (&const_int(a), &const_int(b)) => a.cmp(&b),\n+        (&const_uint(a), &const_uint(b)) => a.cmp(&b),\n+        (&const_float(a), &const_float(b)) => {\n+            // This is pretty bad but it is the existing behavior.\n+            if a == b {\n+                Ordering::Equal\n+            } else if a < b {\n+                Ordering::Less\n+            } else {\n+                Ordering::Greater\n+            }\n+        }\n+        (&const_str(ref a), &const_str(ref b)) => a.cmp(b),\n+        (&const_bool(a), &const_bool(b)) => a.cmp(&b),\n+        (&const_binary(ref a), &const_binary(ref b)) => a.cmp(b),\n+        _ => return None\n+    })\n }\n \n-pub fn compare_lit_exprs(tcx: &ty::ctxt, a: &Expr, b: &Expr) -> Option<int> {\n-    compare_const_vals(&eval_const_expr(tcx, a), &eval_const_expr(tcx, b))\n+pub fn compare_lit_exprs<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                               a: &Expr,\n+                               b: &Expr,\n+                               ty_hint: Option<Ty<'tcx>>)\n+                               -> Option<Ordering> {\n+    let a = match eval_const_expr_partial(tcx, a, ty_hint) {\n+        Ok(a) => a,\n+        Err(s) => {\n+            tcx.sess.span_err(a.span, &s[]);\n+            return None;\n+        }\n+    };\n+    let b = match eval_const_expr_partial(tcx, b, ty_hint) {\n+        Ok(b) => b,\n+        Err(s) => {\n+            tcx.sess.span_err(b.span, &s[]);\n+            return None;\n+        }\n+    };\n+    compare_const_vals(&a, &b)\n }"}, {"sha": "6e14f7b09f8afce80ff5fe40dfff0511dc9ff532", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=cb3c9a1e885964309445e097cab64fe302e144e1", "patch": "@@ -5350,26 +5350,25 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                     None => INITIAL_DISCRIMINANT_VALUE\n                                 };\n \n-                                match variant.node.disr_expr {\n-                                    Some(ref e) =>\n-                                        match const_eval::eval_const_expr_partial(cx, &**e) {\n-                                            Ok(const_eval::const_int(val)) => {\n-                                                discriminant = val as Disr\n-                                            }\n-                                            Ok(const_eval::const_uint(val)) => {\n-                                                discriminant = val as Disr\n-                                            }\n-                                            Ok(_) => {\n-                                                span_err!(cx.sess, e.span, E0304,\n-                                                            \"expected signed integer constant\");\n-                                            }\n-                                            Err(ref err) => {\n-                                                span_err!(cx.sess, e.span, E0305,\n-                                                            \"expected constant: {}\",\n-                                                                    *err);\n-                                            }\n-                                        },\n-                                    None => {}\n+                                if let Some(ref e) = variant.node.disr_expr {\n+                                    // Preserve all values, and prefer signed.\n+                                    let ty = Some(cx.types.i64);\n+                                    match const_eval::eval_const_expr_partial(cx, &**e, ty) {\n+                                        Ok(const_eval::const_int(val)) => {\n+                                            discriminant = val as Disr;\n+                                        }\n+                                        Ok(const_eval::const_uint(val)) => {\n+                                            discriminant = val as Disr;\n+                                        }\n+                                        Ok(_) => {\n+                                            span_err!(cx.sess, e.span, E0304,\n+                                                      \"expected signed integer constant\");\n+                                        }\n+                                        Err(err) => {\n+                                            span_err!(cx.sess, e.span, E0305,\n+                                                      \"expected constant: {}\", err);\n+                                        }\n+                                    }\n                                 };\n \n                                 last_discriminant = Some(discriminant);\n@@ -5822,7 +5821,7 @@ pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool\n \n // Returns the repeat count for a repeating vector expression.\n pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n-    match const_eval::eval_const_expr_partial(tcx, count_expr) {\n+    match const_eval::eval_const_expr_partial(tcx, count_expr, Some(tcx.types.uint)) {\n         Ok(val) => {\n             let found = match val {\n                 const_eval::const_uint(count) => return count as uint,"}, {"sha": "6a296674f3fb9f0fdb679e331785c71e1c0e9937", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=cb3c9a1e885964309445e097cab64fe302e144e1", "patch": "@@ -219,6 +219,7 @@ use util::nodemap::FnvHashMap;\n use util::ppaux::{Repr, vec_map_to_string};\n \n use std;\n+use std::cmp::Ordering;\n use std::iter::AdditiveIterator;\n use std::rc::Rc;\n use syntax::ast;\n@@ -232,10 +233,8 @@ struct ConstantExpr<'a>(&'a ast::Expr);\n \n impl<'a> ConstantExpr<'a> {\n     fn eq(self, other: ConstantExpr<'a>, tcx: &ty::ctxt) -> bool {\n-        let ConstantExpr(expr) = self;\n-        let ConstantExpr(other_expr) = other;\n-        match const_eval::compare_lit_exprs(tcx, expr, other_expr) {\n-            Some(val1) => val1 == 0,\n+        match const_eval::compare_lit_exprs(tcx, self.0, other.0, None) {\n+            Some(result) => result == Ordering::Equal,\n             None => panic!(\"compare_list_exprs: type mismatch\"),\n         }\n     }"}, {"sha": "68054c79f274eefa877e792f153cabc474d34832", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=cb3c9a1e885964309445e097cab64fe302e144e1", "patch": "@@ -1183,7 +1183,7 @@ pub fn ast_ty_to_ty<'tcx>(\n                 qpath_to_ty(this, rscope, ast_ty, &**qpath)\n             }\n             ast::TyFixedLengthVec(ref ty, ref e) => {\n-                match const_eval::eval_const_expr_partial(tcx, &**e) {\n+                match const_eval::eval_const_expr_partial(tcx, &**e, Some(tcx.types.uint)) {\n                     Ok(ref r) => {\n                         match *r {\n                             const_eval::const_int(i) =>"}, {"sha": "81868f3695c28dafea22137a4a7edda229cb7603", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=cb3c9a1e885964309445e097cab64fe302e144e1", "patch": "@@ -8,19 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::const_eval;\n use middle::def;\n use middle::infer;\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n use middle::subst::{Substs};\n use middle::ty::{self, Ty};\n use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n-use check::{instantiate_path, structurally_resolved_type, valid_range_bounds};\n+use check::{instantiate_path, structurally_resolved_type};\n use require_same_types;\n use util::nodemap::FnvHashMap;\n use util::ppaux::Repr;\n \n-use std::cmp;\n+use std::cmp::{self, Ordering};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::ast;\n use syntax::ast_util;\n@@ -79,16 +80,17 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 lhs_eq_rhs && (ty::type_is_numeric(lhs_ty) || ty::type_is_char(lhs_ty));\n \n             if numeric_or_char {\n-                match valid_range_bounds(fcx.ccx, &**begin, &**end) {\n-                    Some(false) => {\n+                match const_eval::compare_lit_exprs(tcx, &**begin, &**end, Some(lhs_ty)) {\n+                    Some(Ordering::Less) |\n+                    Some(Ordering::Equal) => {}\n+                    Some(Ordering::Greater) => {\n                         span_err!(tcx.sess, begin.span, E0030,\n                             \"lower range bound must be less than upper\");\n-                    },\n+                    }\n                     None => {\n                         span_err!(tcx.sess, begin.span, E0031,\n                             \"mismatched types in range\");\n-                    },\n-                    Some(true) => {}\n+                    }\n                 }\n             } else {\n                 span_err!(tcx.sess, begin.span, E0029,"}, {"sha": "27b17c9fc970638701e873b64f2c366bdda46ddb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=cb3c9a1e885964309445e097cab64fe302e144e1", "patch": "@@ -2499,16 +2499,6 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn valid_range_bounds(ccx: &CrateCtxt,\n-                          from: &ast::Expr,\n-                          to: &ast::Expr)\n-                       -> Option<bool> {\n-    match const_eval::compare_lit_exprs(ccx.tcx, from, to) {\n-        Some(val) => Some(val <= 0),\n-        None => None\n-    }\n-}\n-\n pub fn check_expr_has_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                      expr: &'tcx ast::Expr,\n                                      expected: Ty<'tcx>) {\n@@ -4550,7 +4540,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                     // that the expression is in a form that eval_const_expr can\n                     // handle, so we may still get an internal compiler error\n \n-                    match const_eval::eval_const_expr_partial(ccx.tcx, &**e) {\n+                    match const_eval::eval_const_expr_partial(ccx.tcx, &**e, Some(declty)) {\n                         Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n                         Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n                         Ok(_) => {"}, {"sha": "c2bd810abad2537858a7a202cc1fed87fff22b73", "filename": "src/test/compile-fail/issue-6977.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fissue-6977.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d8f995c3a482fecdb9a77455cd8d68d514d62ac/src%2Ftest%2Fcompile-fail%2Fissue-6977.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6977.rs?ref=4d8f995c3a482fecdb9a77455cd8d68d514d62ac", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Trying to create a fixed-length vector with a negative size\n-\n-fn main() {\n-      let _x = [0; -1]; //~ ERROR found negative integer\n-}"}, {"sha": "d730add00b7f03c2a936e760762d552d0cd790a8", "filename": "src/test/compile-fail/repeat_count.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb3c9a1e885964309445e097cab64fe302e144e1/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs?ref=cb3c9a1e885964309445e097cab64fe302e144e1", "patch": "@@ -41,8 +41,18 @@ fn main() {\n     //~| expected usize\n     //~| found &-ptr\n     //~| ERROR expected positive integer for repeat count, found string\n-    let f = [0; -4];\n-    //~^ ERROR expected positive integer for repeat count, found negative integer\n-    let f = [0us; -1];\n-    //~^ ERROR expected positive integer for repeat count, found negative integer\n+    let f = [0; -4is];\n+    //~^ ERROR mismatched types\n+    //~| expected `usize`\n+    //~| found `isize`\n+    //~| expected usize\n+    //~| found isize\n+    //~| ERROR expected positive integer for repeat count, found negative integer\n+    let f = [0us; -1is];\n+    //~^ ERROR mismatched types\n+    //~| expected `usize`\n+    //~| found `isize`\n+    //~| expected usize\n+    //~| found isize\n+    //~| ERROR expected positive integer for repeat count, found negative integer\n }"}]}