{"sha": "9413a926fcfc88c46ea04534508284a822e1109f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MTNhOTI2ZmNmYzg4YzQ2ZWEwNDUzNDUwODI4NGE4MjJlMTEwOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-24T10:12:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-24T10:12:20Z"}, "message": "Auto merge of #27215 - pnkfelix:fsk-placer-take-5-just-in, r=nikomatsakis\n\nMacro desugaring of `in PLACE { BLOCK }` into \"simpler\" expressions following the in-development \"Placer\" protocol.\r\n\r\nIncludes Placer API that one can override to integrate support for `in` into one's own type.  (See [RFC 809].)\r\n\r\n[RFC 809]: https://github.com/rust-lang/rfcs/blob/master/text/0809-box-and-in-for-stdlib.md\r\n\r\nPart of #22181\r\n\r\nReplaced PR #26180.\r\n\r\nTurns on the `in PLACE { BLOCK }` syntax, while leaving in support for the old `box (PLACE) EXPR` syntax (since we need to support that at least until we have a snapshot with support for `in PLACE { BLOCK }`.\r\n\r\n(Note that we are not 100% committed to the `in PLACE { BLOCK }` syntax.  In particular I still want to play around with some other alternatives.  Still, I want to get the fundamental framework for the protocol landed so we can play with implementing it for non `Box` types.)\r\n\r\n----\r\n\r\nAlso, this PR leaves out support for desugaring-based `box EXPR`.  We will hopefully land that in the future, but for the short term there are type-inference issues injected by that change that we want to resolve separately.", "tree": {"sha": "191a7b86544a79d59a31a1c2080dc2bc9b5f4aa3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/191a7b86544a79d59a31a1c2080dc2bc9b5f4aa3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9413a926fcfc88c46ea04534508284a822e1109f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9413a926fcfc88c46ea04534508284a822e1109f", "html_url": "https://github.com/rust-lang/rust/commit/9413a926fcfc88c46ea04534508284a822e1109f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9413a926fcfc88c46ea04534508284a822e1109f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "607f74df2ad6b6fb32ce5b862a9e48a8c4afdad2", "url": "https://api.github.com/repos/rust-lang/rust/commits/607f74df2ad6b6fb32ce5b862a9e48a8c4afdad2", "html_url": "https://github.com/rust-lang/rust/commit/607f74df2ad6b6fb32ce5b862a9e48a8c4afdad2"}, {"sha": "d066a7b5069ff857a5bffe7cb5168fe63158144f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d066a7b5069ff857a5bffe7cb5168fe63158144f", "html_url": "https://github.com/rust-lang/rust/commit/d066a7b5069ff857a5bffe7cb5168fe63158144f"}], "stats": {"total": 946, "additions": 899, "deletions": 47}, "files": [{"sha": "acf22094233230f5405f1b0c906c39ef83ef581c", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 103, "deletions": 6, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -55,13 +55,16 @@\n \n use core::prelude::*;\n \n+use heap;\n+\n use core::any::Any;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{self, Hash};\n-use core::marker::Unsize;\n+use core::marker::{self, Unsize};\n use core::mem;\n use core::ops::{CoerceUnsized, Deref, DerefMut};\n+use core::ops::{Placer, Boxed, Place, InPlace, BoxPlace};\n use core::ptr::Unique;\n use core::raw::{TraitObject};\n \n@@ -72,7 +75,7 @@ use core::raw::{TraitObject};\n ///\n /// ```\n /// # #![feature(box_heap)]\n-/// #![feature(box_syntax)]\n+/// #![feature(box_syntax, placement_in_syntax)]\n /// use std::boxed::HEAP;\n ///\n /// fn main() {\n@@ -83,15 +86,110 @@ use core::raw::{TraitObject};\n #[lang = \"exchange_heap\"]\n #[unstable(feature = \"box_heap\",\n            reason = \"may be renamed; uncertain about custom allocator design\")]\n-pub const HEAP: () = ();\n+pub const HEAP: ExchangeHeapSingleton =\n+    ExchangeHeapSingleton { _force_singleton: () };\n+\n+/// This the singleton type used solely for `boxed::HEAP`.\n+#[derive(Copy, Clone)]\n+pub struct ExchangeHeapSingleton { _force_singleton: () }\n \n /// A pointer type for heap allocation.\n ///\n /// See the [module-level documentation](../../std/boxed/index.html) for more.\n #[lang = \"owned_box\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[fundamental]\n-pub struct Box<T>(Unique<T>);\n+pub struct Box<T: ?Sized>(Unique<T>);\n+\n+/// `IntermediateBox` represents uninitialized backing storage for `Box`.\n+///\n+/// FIXME (pnkfelix): Ideally we would just reuse `Box<T>` instead of\n+/// introducing a separate `IntermediateBox<T>`; but then you hit\n+/// issues when you e.g. attempt to destructure an instance of `Box`,\n+/// since it is a lang item and so it gets special handling by the\n+/// compiler.  Easier just to make this parallel type for now.\n+///\n+/// FIXME (pnkfelix): Currently the `box` protocol only supports\n+/// creating instances of sized types. This IntermediateBox is\n+/// designed to be forward-compatible with a future protocol that\n+/// supports creating instances of unsized types; that is why the type\n+/// parameter has the `?Sized` generalization marker, and is also why\n+/// this carries an explicit size. However, it probably does not need\n+/// to carry the explicit alignment; that is just a work-around for\n+/// the fact that the `align_of` intrinsic currently requires the\n+/// input type to be Sized (which I do not think is strictly\n+/// necessary).\n+#[unstable(feature = \"placement_in\", reason = \"placement box design is still being worked out.\")]\n+pub struct IntermediateBox<T: ?Sized>{\n+    ptr: *mut u8,\n+    size: usize,\n+    align: usize,\n+    marker: marker::PhantomData<*mut T>,\n+}\n+\n+impl<T> Place<T> for IntermediateBox<T> {\n+    fn pointer(&mut self) -> *mut T {\n+        unsafe { ::core::mem::transmute(self.ptr) }\n+    }\n+}\n+\n+unsafe fn finalize<T>(b: IntermediateBox<T>) -> Box<T> {\n+    let p = b.ptr as *mut T;\n+    mem::forget(b);\n+    mem::transmute(p)\n+}\n+\n+fn make_place<T>() -> IntermediateBox<T> {\n+    let size = mem::size_of::<T>();\n+    let align = mem::align_of::<T>();\n+\n+    let p = if size == 0 {\n+        heap::EMPTY as *mut u8\n+    } else {\n+        let p = unsafe {\n+            heap::allocate(size, align)\n+        };\n+        if p.is_null() {\n+            panic!(\"Box make_place allocation failure.\");\n+        }\n+        p\n+    };\n+\n+    IntermediateBox { ptr: p, size: size, align: align, marker: marker::PhantomData }\n+}\n+\n+impl<T> BoxPlace<T> for IntermediateBox<T> {\n+    fn make_place() -> IntermediateBox<T> { make_place() }\n+}\n+\n+impl<T> InPlace<T> for IntermediateBox<T> {\n+    type Owner = Box<T>;\n+    unsafe fn finalize(self) -> Box<T> { finalize(self) }\n+}\n+\n+impl<T> Boxed for Box<T> {\n+    type Data = T;\n+    type Place = IntermediateBox<T>;\n+    unsafe fn finalize(b: IntermediateBox<T>) -> Box<T> { finalize(b) }\n+}\n+\n+impl<T> Placer<T> for ExchangeHeapSingleton {\n+    type Place = IntermediateBox<T>;\n+\n+    fn make_place(self) -> IntermediateBox<T> {\n+        make_place()\n+    }\n+}\n+\n+impl<T: ?Sized> Drop for IntermediateBox<T> {\n+    fn drop(&mut self) {\n+        if self.size > 0 {\n+            unsafe {\n+                heap::deallocate(self.ptr, self.size, self.align)\n+            }\n+        }\n+    }\n+}\n \n impl<T> Box<T> {\n     /// Allocates memory on the heap and then moves `x` into it.\n@@ -199,8 +297,7 @@ impl<T: Clone> Clone for Box<T> {\n     /// let y = x.clone();\n     /// ```\n     #[inline]\n-    fn clone(&self) -> Box<T> { box {(**self).clone()} }\n-\n+    fn clone(&self) -> Box<T> { box (HEAP) {(**self).clone()} }\n     /// Copies `source`'s contents into `self` without creating a new allocation.\n     ///\n     /// # Examples"}, {"sha": "f66495c4057c4c283350eaef90296ac81bf0ca51", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -70,6 +70,8 @@\n        test(no_crate_inject))]\n #![no_std]\n \n+// SNAP d4432b3\n+#![allow(unused_features)] // until feature(placement_in_syntax) is in snap\n #![feature(allocator)]\n #![feature(box_syntax)]\n #![feature(coerce_unsized)]\n@@ -82,6 +84,8 @@\n #![feature(no_std)]\n #![feature(nonzero)]\n #![feature(optin_builtin_traits)]\n+#![feature(placement_in_syntax)]\n+#![feature(placement_new_protocol)]\n #![feature(raw)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]"}, {"sha": "1d466895f2cfbb826287d677017ebc5b0fc7413e", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -184,6 +184,14 @@ extern \"rust-intrinsic\" {\n     /// elements.\n     pub fn size_of<T>() -> usize;\n \n+    #[cfg(not(stage0))]\n+    /// Moves a value to an uninitialized memory location.\n+    ///\n+    /// Drop glue is not run on the destination.\n+    pub fn move_val_init<T>(dst: *mut T, src: T);\n+\n+    // SNAP d4432b3\n+    #[cfg(stage0)]\n     /// Moves a value to an uninitialized memory location.\n     ///\n     /// Drop glue is not run on the destination."}, {"sha": "2ea42011a5cf2ff6a2206c52ad780a689bc25394", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -1266,3 +1266,120 @@ impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n \n // *const T -> *const U\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n+\n+/// Both `in (PLACE) EXPR` and `box EXPR` desugar into expressions\n+/// that allocate an intermediate \"place\" that holds uninitialized\n+/// state.  The desugaring evaluates EXPR, and writes the result at\n+/// the address returned by the `pointer` method of this trait.\n+///\n+/// A `Place` can be thought of as a special representation for a\n+/// hypothetical `&uninit` reference (which Rust cannot currently\n+/// express directly). That is, it represents a pointer to\n+/// uninitialized storage.\n+///\n+/// The client is responsible for two steps: First, initializing the\n+/// payload (it can access its address via `pointer`). Second,\n+/// converting the agent to an instance of the owning pointer, via the\n+/// appropriate `finalize` method (see the `InPlace`.\n+///\n+/// If evaluating EXPR fails, then the destructor for the\n+/// implementation of Place to clean up any intermediate state\n+/// (e.g. deallocate box storage, pop a stack, etc).\n+#[unstable(feature = \"placement_new_protocol\")]\n+pub trait Place<Data: ?Sized> {\n+    /// Returns the address where the input value will be written.\n+    /// Note that the data at this address is generally uninitialized,\n+    /// and thus one should use `ptr::write` for initializing it.\n+    fn pointer(&mut self) -> *mut Data;\n+}\n+\n+/// Interface to implementations of  `in (PLACE) EXPR`.\n+///\n+/// `in (PLACE) EXPR` effectively desugars into:\n+///\n+/// ```rust,ignore\n+/// let p = PLACE;\n+/// let mut place = Placer::make_place(p);\n+/// let raw_place = Place::pointer(&mut place);\n+/// let value = EXPR;\n+/// unsafe {\n+///     std::ptr::write(raw_place, value);\n+///     InPlace::finalize(place)\n+/// }\n+/// ```\n+///\n+/// The type of `in (PLACE) EXPR` is derived from the type of `PLACE`;\n+/// if the type of `PLACE` is `P`, then the final type of the whole\n+/// expression is `P::Place::Owner` (see the `InPlace` and `Boxed`\n+/// traits).\n+///\n+/// Values for types implementing this trait usually are transient\n+/// intermediate values (e.g. the return value of `Vec::emplace_back`)\n+/// or `Copy`, since the `make_place` method takes `self` by value.\n+#[unstable(feature = \"placement_new_protocol\")]\n+pub trait Placer<Data: ?Sized> {\n+    /// `Place` is the intermedate agent guarding the\n+    /// uninitialized state for `Data`.\n+    type Place: InPlace<Data>;\n+\n+    /// Creates a fresh place from `self`.\n+    fn make_place(self) -> Self::Place;\n+}\n+\n+/// Specialization of `Place` trait supporting `in (PLACE) EXPR`.\n+#[unstable(feature = \"placement_new_protocol\")]\n+pub trait InPlace<Data: ?Sized>: Place<Data> {\n+    /// `Owner` is the type of the end value of `in (PLACE) EXPR`\n+    ///\n+    /// Note that when `in (PLACE) EXPR` is solely used for\n+    /// side-effecting an existing data-structure,\n+    /// e.g. `Vec::emplace_back`, then `Owner` need not carry any\n+    /// information at all (e.g. it can be the unit type `()` in that\n+    /// case).\n+    type Owner;\n+\n+    /// Converts self into the final value, shifting\n+    /// deallocation/cleanup responsibilities (if any remain), over to\n+    /// the returned instance of `Owner` and forgetting self.\n+    unsafe fn finalize(self) -> Self::Owner;\n+}\n+\n+/// Core trait for the `box EXPR` form.\n+///\n+/// `box EXPR` effectively desugars into:\n+///\n+/// ```rust,ignore\n+/// let mut place = BoxPlace::make_place();\n+/// let raw_place = Place::pointer(&mut place);\n+/// let value = EXPR;\n+/// unsafe {\n+///     ::std::ptr::write(raw_place, value);\n+///     Boxed::finalize(place)\n+/// }\n+/// ```\n+///\n+/// The type of `box EXPR` is supplied from its surrounding\n+/// context; in the above expansion, the result type `T` is used\n+/// to determine which implementation of `Boxed` to use, and that\n+/// `<T as Boxed>` in turn dictates determines which\n+/// implementation of `BoxPlace` to use, namely:\n+/// `<<T as Boxed>::Place as BoxPlace>`.\n+#[unstable(feature = \"placement_new_protocol\")]\n+pub trait Boxed {\n+    /// The kind of data that is stored in this kind of box.\n+    type Data;  /* (`Data` unused b/c cannot yet express below bound.) */\n+    /// The place that will negotiate the storage of the data.\n+    type Place: BoxPlace<Self::Data>;\n+\n+    /// Converts filled place into final owning value, shifting\n+    /// deallocation/cleanup responsibilities (if any remain), over to\n+    /// returned instance of `Self` and forgetting `filled`.\n+    unsafe fn finalize(filled: Self::Place) -> Self;\n+}\n+\n+/// Specialization of `Place` trait supporting `box EXPR`.\n+#[unstable(feature = \"placement_new_protocol\")]\n+pub trait BoxPlace<Data: ?Sized> : Place<Data> {\n+    /// Creates a globally fresh place.\n+    fn make_place() -> Self;\n+}"}, {"sha": "3fe1e2f5e8369903974114a506d532c48e1dd2d1", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -10,7 +10,7 @@\n \n //! Enforces the Rust effect system. Currently there is just one effect,\n //! `unsafe`.\n-use self::UnsafeContext::*;\n+use self::RootUnsafeContext::*;\n \n use middle::def;\n use middle::ty::{self, Ty};\n@@ -21,8 +21,20 @@ use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n+#[derive(Copy, Clone)]\n+struct UnsafeContext {\n+    push_unsafe_count: usize,\n+    root: RootUnsafeContext,\n+}\n+\n+impl UnsafeContext {\n+    fn new(root: RootUnsafeContext) -> UnsafeContext {\n+        UnsafeContext { root: root, push_unsafe_count: 0 }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq)]\n-enum UnsafeContext {\n+enum RootUnsafeContext {\n     SafeContext,\n     UnsafeFn,\n     UnsafeBlock(ast::NodeId),\n@@ -44,7 +56,8 @@ struct EffectCheckVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n     fn require_unsafe(&mut self, span: Span, description: &str) {\n-        match self.unsafe_context {\n+        if self.unsafe_context.push_unsafe_count > 0 { return; }\n+        match self.unsafe_context.root {\n             SafeContext => {\n                 // Report an error.\n                 span_err!(self.tcx.sess, span, E0133,\n@@ -75,9 +88,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n \n         let old_unsafe_context = self.unsafe_context;\n         if is_unsafe_fn {\n-            self.unsafe_context = UnsafeFn\n+            self.unsafe_context = UnsafeContext::new(UnsafeFn)\n         } else if is_item_fn {\n-            self.unsafe_context = SafeContext\n+            self.unsafe_context = UnsafeContext::new(SafeContext)\n         }\n \n         visit::walk_fn(self, fn_kind, fn_decl, block, span);\n@@ -105,10 +118,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 // external blocks (e.g. `unsafe { println(\"\") }`,\n                 // expands to `unsafe { ... unsafe { ... } }` where\n                 // the inner one is compiler generated).\n-                if self.unsafe_context == SafeContext || source == ast::CompilerGenerated {\n-                    self.unsafe_context = UnsafeBlock(block.id)\n+                if self.unsafe_context.root == SafeContext || source == ast::CompilerGenerated {\n+                    self.unsafe_context.root = UnsafeBlock(block.id)\n                 }\n             }\n+            ast::PushUnsafeBlock(..) => {\n+                self.unsafe_context.push_unsafe_count =\n+                    self.unsafe_context.push_unsafe_count.checked_add(1).unwrap();\n+            }\n+            ast::PopUnsafeBlock(..) => {\n+                self.unsafe_context.push_unsafe_count =\n+                    self.unsafe_context.push_unsafe_count.checked_sub(1).unwrap();\n+            }\n         }\n \n         visit::walk_block(self, block);\n@@ -162,7 +183,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n pub fn check_crate(tcx: &ty::ctxt) {\n     let mut visitor = EffectCheckVisitor {\n         tcx: tcx,\n-        unsafe_context: SafeContext,\n+        unsafe_context: UnsafeContext::new(SafeContext),\n     };\n \n     visit::walk_crate(&mut visitor, tcx.map.krate());"}, {"sha": "f27a96545ddfa4835ca2a782ef8579f5e0b99f80", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -555,6 +555,11 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                     None => {}\n                 }\n                 self.consume_expr(&**base);\n+                if place.is_some() {\n+                    self.tcx().sess.span_bug(\n+                        expr.span,\n+                        \"box with explicit place remains after expansion\");\n+                }\n             }\n \n             ast::ExprMac(..) => {"}, {"sha": "6d3bc7fb68c1418ca20b6775212eecb3b056bb9d", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -543,9 +543,19 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &ast::Pat,\n \n fn maybe_do_stability_check(tcx: &ty::ctxt, id: ast::DefId, span: Span,\n                             cb: &mut FnMut(ast::DefId, Span, &Option<&Stability>)) {\n-    if !is_staged_api(tcx, id) { return  }\n-    if is_internal(tcx, span) { return }\n+    if !is_staged_api(tcx, id) {\n+        debug!(\"maybe_do_stability_check: \\\n+                skipping id={:?} since it is not staged_api\", id);\n+        return;\n+    }\n+    if is_internal(tcx, span) {\n+        debug!(\"maybe_do_stability_check: \\\n+                skipping span={:?} since it is internal\", span);\n+        return;\n+    }\n     let ref stability = lookup(tcx, id);\n+    debug!(\"maybe_do_stability_check: \\\n+            inspecting id={:?} span={:?} of stability={:?}\", id, span, stability);\n     cb(id, span, stability);\n }\n "}, {"sha": "9486e4953f8516042bdf14e4c9423bc5246c4b58", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -232,12 +232,13 @@ impl<'tcx> Expectation<'tcx> {\n pub struct UnsafetyState {\n     pub def: ast::NodeId,\n     pub unsafety: ast::Unsafety,\n+    pub unsafe_push_count: u32,\n     from_fn: bool\n }\n \n impl UnsafetyState {\n     pub fn function(unsafety: ast::Unsafety, def: ast::NodeId) -> UnsafetyState {\n-        UnsafetyState { def: def, unsafety: unsafety, from_fn: true }\n+        UnsafetyState { def: def, unsafety: unsafety, unsafe_push_count: 0, from_fn: true }\n     }\n \n     pub fn recurse(&mut self, blk: &ast::Block) -> UnsafetyState {\n@@ -249,13 +250,20 @@ impl UnsafetyState {\n             ast::Unsafety::Unsafe if self.from_fn => *self,\n \n             unsafety => {\n-                let (unsafety, def) = match blk.rules {\n-                    ast::UnsafeBlock(..) => (ast::Unsafety::Unsafe, blk.id),\n-                    ast::DefaultBlock => (unsafety, self.def),\n+                let (unsafety, def, count) = match blk.rules {\n+                    ast::PushUnsafeBlock(..) =>\n+                        (unsafety, blk.id, self.unsafe_push_count.checked_add(1).unwrap()),\n+                    ast::PopUnsafeBlock(..) =>\n+                        (unsafety, blk.id, self.unsafe_push_count.checked_sub(1).unwrap()),\n+                    ast::UnsafeBlock(..) =>\n+                        (ast::Unsafety::Unsafe, blk.id, self.unsafe_push_count),\n+                    ast::DefaultBlock =>\n+                        (unsafety, self.def, self.unsafe_push_count),\n                 };\n                 UnsafetyState{ def: def,\n-                             unsafety: unsafety,\n-                             from_fn: false }\n+                               unsafety: unsafety,\n+                               unsafe_push_count: count,\n+                               from_fn: false }\n             }\n         }\n     }\n@@ -4884,9 +4892,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"move_val_init\" => {\n                 (1,\n                  vec!(\n-                    tcx.mk_mut_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n-                                                                  ty::BrAnon(0))),\n-                                    param(ccx, 0)),\n+                    tcx.mk_mut_ptr(param(ccx, 0)),\n                     param(ccx, 0)\n                   ),\n                tcx.mk_nil())"}, {"sha": "907eb3ed401ff6c795ccb7e8e658a180759f464c", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -203,6 +203,7 @@\n        test(no_crate_inject, attr(deny(warnings))),\n        test(attr(allow(dead_code, deprecated, unused_variables, unused_mut))))]\n \n+#![cfg_attr(stage0, allow(unused_features))]\n #![feature(alloc)]\n #![feature(allow_internal_unstable)]\n #![feature(associated_consts)]\n@@ -234,6 +235,7 @@\n #![feature(no_std)]\n #![feature(oom)]\n #![feature(optin_builtin_traits)]\n+#![feature(placement_in_syntax)]\n #![feature(rand)]\n #![feature(raw)]\n #![feature(reflect_marker)]"}, {"sha": "fba9db401dbb1a2423762c0980beccd87d74f67c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -810,6 +810,8 @@ pub type SpannedIdent = Spanned<Ident>;\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n+    PushUnsafeBlock(UnsafeSource),\n+    PopUnsafeBlock(UnsafeSource),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]"}, {"sha": "17e6b2c2e12df69fc03d79c0793281d380e528bc", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -980,6 +980,10 @@ impl CodeMap {\n                             mac_span.lo <= span.lo && span.hi <= mac_span.hi\n                         });\n \n+                    debug!(\"span_allows_unstable: span: {:?} call_site: {:?} callee: {:?}\",\n+                           (span.lo, span.hi),\n+                           (info.call_site.lo, info.call_site.hi),\n+                           info.callee.span.map(|x| (x.lo, x.hi)));\n                     debug!(\"span_allows_unstable: from this expansion? {}, allows unstable? {}\",\n                            span_comes_from_this_expansion,\n                            info.callee.allow_internal_unstable);"}, {"sha": "409ae86db35d4ebe53404379c8a674e8b3e35c0f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -591,6 +591,12 @@ fn initial_syntax_expander_table<'feat>(ecfg: &expand::ExpansionConfig<'feat>)\n     syntax_expanders.insert(intern(\"cfg\"),\n                             builtin_normal_expander(\n                                     ext::cfg::expand_cfg));\n+    syntax_expanders.insert(intern(\"push_unsafe\"),\n+                            builtin_normal_expander(\n+                                ext::pushpop_safe::expand_push_unsafe));\n+    syntax_expanders.insert(intern(\"pop_unsafe\"),\n+                            builtin_normal_expander(\n+                                ext::pushpop_safe::expand_pop_unsafe));\n     syntax_expanders.insert(intern(\"trace_macros\"),\n                             builtin_normal_expander(\n                                     ext::trace_macros::expand_trace_macros));"}, {"sha": "faa1e5b2f515fff67234c75677733d14e69e8b85", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 157, "deletions": 2, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -33,20 +33,43 @@ use visit;\n use visit::Visitor;\n use std_inject;\n \n+// Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n+// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n+fn mk_core_path(fld: &mut MacroExpander,\n+                span: Span,\n+                suffix: &[&'static str]) -> ast::Path {\n+    let mut idents = vec![fld.cx.ident_of_std(\"core\")];\n+    for s in suffix.iter() { idents.push(fld.cx.ident_of(*s)); }\n+    fld.cx.path_global(span, idents)\n+}\n+\n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     fn push_compiler_expansion(fld: &mut MacroExpander, span: Span, expansion_desc: &str) {\n         fld.cx.bt_push(ExpnInfo {\n             call_site: span,\n             callee: NameAndSpan {\n                 name: expansion_desc.to_string(),\n                 format: CompilerExpansion,\n+\n+                // This does *not* mean code generated after\n+                // `push_compiler_expansion` is automatically exempt\n+                // from stability lints; must also tag such code with\n+                // an appropriate span from `fld.cx.backtrace()`.\n                 allow_internal_unstable: true,\n+\n                 span: None,\n             },\n         });\n     }\n \n-    e.and_then(|ast::Expr {id, node, span}| match node {\n+    // Sets the expn_id so that we can use unstable methods.\n+    fn allow_unstable(fld: &mut MacroExpander, span: Span) -> Span {\n+        Span { expn_id: fld.cx.backtrace(), ..span }\n+    }\n+\n+    let expr_span = e.span;\n+    return e.and_then(|ast::Expr {id, node, span}| match node {\n+\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprMac(mac) => {\n@@ -71,6 +94,118 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             })\n         }\n \n+        // Desugar ExprBox: `in (PLACE) EXPR`\n+        ast::ExprBox(Some(placer), value_expr) => {\n+            // to:\n+            //\n+            // let p = PLACE;\n+            // let mut place = Placer::make_place(p);\n+            // let raw_place = Place::pointer(&mut place);\n+            // push_unsafe!({\n+            //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n+            //     InPlace::finalize(place)\n+            // })\n+\n+            // Ensure feature-gate is enabled\n+            feature_gate::check_for_placement_in(\n+                fld.cx.ecfg.features,\n+                &fld.cx.parse_sess.span_diagnostic,\n+                expr_span);\n+\n+            push_compiler_expansion(fld, expr_span, \"placement-in expansion\");\n+\n+            let value_span = value_expr.span;\n+            let placer_span = placer.span;\n+\n+            let placer_expr = fld.fold_expr(placer);\n+            let value_expr = fld.fold_expr(value_expr);\n+\n+            let placer_ident = token::gensym_ident(\"placer\");\n+            let agent_ident = token::gensym_ident(\"place\");\n+            let p_ptr_ident = token::gensym_ident(\"p_ptr\");\n+\n+            let placer = fld.cx.expr_ident(span, placer_ident);\n+            let agent = fld.cx.expr_ident(span, agent_ident);\n+            let p_ptr = fld.cx.expr_ident(span, p_ptr_ident);\n+\n+            let make_place = [\"ops\", \"Placer\", \"make_place\"];\n+            let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n+            let move_val_init = [\"intrinsics\", \"move_val_init\"];\n+            let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n+\n+            let make_call = |fld: &mut MacroExpander, p, args| {\n+                // We feed in the `expr_span` because codemap's span_allows_unstable\n+                // allows the call_site span to inherit the `allow_internal_unstable`\n+                // setting.\n+                let span_unstable = allow_unstable(fld, expr_span);\n+                let path = mk_core_path(fld, span_unstable, p);\n+                let path = fld.cx.expr_path(path);\n+                let expr_span_unstable = allow_unstable(fld, span);\n+                fld.cx.expr_call(expr_span_unstable, path, args)\n+            };\n+\n+            let stmt_let = |fld: &mut MacroExpander, bind, expr| {\n+                fld.cx.stmt_let(placer_span, false, bind, expr)\n+            };\n+            let stmt_let_mut = |fld: &mut MacroExpander, bind, expr| {\n+                fld.cx.stmt_let(placer_span, true, bind, expr)\n+            };\n+\n+            // let placer = <placer_expr> ;\n+            let s1 = stmt_let(fld, placer_ident, placer_expr);\n+\n+            // let mut place = Placer::make_place(placer);\n+            let s2 = {\n+                let call = make_call(fld, &make_place, vec![placer]);\n+                stmt_let_mut(fld, agent_ident, call)\n+            };\n+\n+            // let p_ptr = Place::pointer(&mut place);\n+            let s3 = {\n+                let args = vec![fld.cx.expr_mut_addr_of(placer_span, agent.clone())];\n+                let call = make_call(fld, &place_pointer, args);\n+                stmt_let(fld, p_ptr_ident, call)\n+            };\n+\n+            // pop_unsafe!(EXPR));\n+            let pop_unsafe_expr = pop_unsafe_expr(fld.cx, value_expr, value_span);\n+\n+            // push_unsafe!({\n+            //     ptr::write(p_ptr, pop_unsafe!(<value_expr>));\n+            //     InPlace::finalize(place)\n+            // })\n+            let expr = {\n+                let call_move_val_init = StmtSemi(make_call(\n+                    fld, &move_val_init, vec![p_ptr, pop_unsafe_expr]), ast::DUMMY_NODE_ID);\n+                let call_move_val_init = codemap::respan(value_span, call_move_val_init);\n+\n+                let call = make_call(fld, &inplace_finalize, vec![agent]);\n+                Some(push_unsafe_expr(fld.cx, vec![P(call_move_val_init)], call, span))\n+            };\n+\n+            let block = fld.cx.block_all(span, vec![s1, s2, s3], expr);\n+            let result = fld.cx.expr_block(block);\n+            fld.cx.bt_pop();\n+            result\n+        }\n+\n+        // Issue #22181:\n+        // Eventually a desugaring for `box EXPR`\n+        // (similar to the desugaring above for `in PLACE BLOCK`)\n+        // should go here, desugaring\n+        //\n+        // to:\n+        //\n+        // let mut place = BoxPlace::make_place();\n+        // let raw_place = Place::pointer(&mut place);\n+        // let value = $value;\n+        // unsafe {\n+        //     ::std::ptr::write(raw_place, value);\n+        //     Boxed::finalize(place)\n+        // }\n+        //\n+        // But for now there are type-inference issues doing that.\n+\n         ast::ExprWhile(cond, body, opt_ident) => {\n             let cond = fld.fold_expr(cond);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n@@ -360,7 +495,26 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n                 span: span\n             }, fld))\n         }\n-    })\n+    });\n+\n+    fn push_unsafe_expr(cx: &mut ExtCtxt, stmts: Vec<P<ast::Stmt>>,\n+                        expr: P<ast::Expr>, span: Span)\n+                        -> P<ast::Expr> {\n+        let rules = ast::PushUnsafeBlock(ast::CompilerGenerated);\n+        cx.expr_block(P(ast::Block {\n+            rules: rules, span: span, id: ast::DUMMY_NODE_ID,\n+            stmts: stmts, expr: Some(expr),\n+        }))\n+    }\n+\n+    fn pop_unsafe_expr(cx: &mut ExtCtxt, expr: P<ast::Expr>, span: Span)\n+                       -> P<ast::Expr> {\n+        let rules = ast::PopUnsafeBlock(ast::CompilerGenerated);\n+        cx.expr_block(P(ast::Block {\n+            rules: rules, span: span, id: ast::DUMMY_NODE_ID,\n+            stmts: vec![], expr: Some(expr),\n+        }))\n+    }\n }\n \n /// Expand a (not-ident-style) macro invocation. Returns the result\n@@ -1504,6 +1658,7 @@ impl<'feat> ExpansionConfig<'feat> {\n         fn enable_trace_macros = allow_trace_macros,\n         fn enable_allow_internal_unstable = allow_internal_unstable,\n         fn enable_custom_derive = allow_custom_derive,\n+        fn enable_pushpop_unsafe = allow_pushpop_unsafe,\n     }\n }\n "}, {"sha": "a67d550d3cd213d193e26f708a5a69c12a164304", "filename": "src/libsyntax/ext/pushpop_safe.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Fext%2Fpushpop_safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Fext%2Fpushpop_safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpushpop_safe.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*\n+ * The compiler code necessary to support the `push_unsafe!` and\n+ * `pop_unsafe!` macros.\n+ *\n+ * This is a hack to allow a kind of \"safety hygiene\", where a macro\n+ * can generate code with an interior expression that inherits the\n+ * safety of some outer context.\n+ *\n+ * For example, in:\n+ *\n+ * ```rust\n+ * fn foo() { push_unsafe!( { EXPR_1; pop_unsafe!( EXPR_2 ) } ) }\n+ * ```\n+ *\n+ * the `EXPR_1` is considered to be in an `unsafe` context,\n+ * but `EXPR_2` is considered to be in a \"safe\" (i.e. checked) context.\n+ *\n+ * For comparison, in:\n+ *\n+ * ```rust\n+ * fn foo() { unsafe { push_unsafe!( { EXPR_1; pop_unsafe!( EXPR_2 ) } ) } }\n+ * ```\n+ *\n+ * both `EXPR_1` and `EXPR_2` are considered to be in `unsafe`\n+ * contexts.\n+ *\n+ */\n+\n+use ast;\n+use codemap::Span;\n+use ext::base::*;\n+use ext::base;\n+use ext::build::AstBuilder;\n+use feature_gate;\n+use ptr::P;\n+\n+enum PushPop { Push, Pop }\n+\n+pub fn expand_push_unsafe<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+                               -> Box<base::MacResult+'cx> {\n+    expand_pushpop_unsafe(cx, sp, tts, PushPop::Push)\n+}\n+\n+pub fn expand_pop_unsafe<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+                               -> Box<base::MacResult+'cx> {\n+    expand_pushpop_unsafe(cx, sp, tts, PushPop::Pop)\n+}\n+\n+fn expand_pushpop_unsafe<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree],\n+                                  pp: PushPop) -> Box<base::MacResult+'cx> {\n+    feature_gate::check_for_pushpop_syntax(\n+        cx.ecfg.features, &cx.parse_sess.span_diagnostic, sp);\n+\n+    let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n+        Some(exprs) => exprs.into_iter(),\n+        None => return DummyResult::expr(sp),\n+    };\n+\n+    let expr = match (exprs.next(), exprs.next()) {\n+        (Some(expr), None) => expr,\n+        _ => {\n+            let msg = match pp {\n+                PushPop::Push => \"push_unsafe! takes 1 arguments\",\n+                PushPop::Pop => \"pop_unsafe! takes 1 arguments\",\n+            };\n+            cx.span_err(sp, msg);\n+            return DummyResult::expr(sp);\n+        }\n+    };\n+\n+    let source = ast::UnsafeSource::CompilerGenerated;\n+    let check_mode = match pp {\n+        PushPop::Push => ast::BlockCheckMode::PushUnsafeBlock(source),\n+        PushPop::Pop => ast::BlockCheckMode::PopUnsafeBlock(source),\n+    };\n+\n+    MacEager::expr(cx.expr_block(P(ast::Block {\n+        stmts: vec![],\n+        expr: Some(expr),\n+        id: ast::DUMMY_NODE_ID,\n+        rules: check_mode,\n+        span: sp\n+    })))\n+}"}, {"sha": "8c6855036f6e9dc4058538179ec02b7207fcc7b2", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -80,6 +80,8 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     (\"visible_private_types\", \"1.0.0\", Active),\n     (\"slicing_syntax\", \"1.0.0\", Accepted),\n     (\"box_syntax\", \"1.0.0\", Active),\n+    (\"placement_in_syntax\", \"1.0.0\", Active),\n+    (\"pushpop_unsafe\", \"1.2.0\", Active),\n     (\"on_unimplemented\", \"1.0.0\", Active),\n     (\"simd_ffi\", \"1.0.0\", Active),\n     (\"allocator\", \"1.0.0\", Active),\n@@ -325,6 +327,9 @@ pub struct Features {\n     pub allow_trace_macros: bool,\n     pub allow_internal_unstable: bool,\n     pub allow_custom_derive: bool,\n+    pub allow_placement_in: bool,\n+    pub allow_box: bool,\n+    pub allow_pushpop_unsafe: bool,\n     pub simd_ffi: bool,\n     pub unmarked_api: bool,\n     pub negate_unsigned: bool,\n@@ -348,6 +353,9 @@ impl Features {\n             allow_trace_macros: false,\n             allow_internal_unstable: false,\n             allow_custom_derive: false,\n+            allow_placement_in: false,\n+            allow_box: false,\n+            allow_pushpop_unsafe: false,\n             simd_ffi: false,\n             unmarked_api: false,\n             negate_unsigned: false,\n@@ -358,6 +366,36 @@ impl Features {\n     }\n }\n \n+const EXPLAIN_BOX_SYNTAX: &'static str =\n+    \"box expression syntax is experimental; you can call `Box::new` instead.\";\n+\n+const EXPLAIN_PLACEMENT_IN: &'static str =\n+    \"placement-in expression syntax is experimental and subject to change.\";\n+\n+const EXPLAIN_PUSHPOP_UNSAFE: &'static str =\n+    \"push/pop_unsafe macros are experimental and subject to change.\";\n+\n+pub fn check_for_box_syntax(f: Option<&Features>, diag: &SpanHandler, span: Span) {\n+    if let Some(&Features { allow_box: true, .. }) = f {\n+        return;\n+    }\n+    emit_feature_err(diag, \"box_syntax\", span, EXPLAIN_BOX_SYNTAX);\n+}\n+\n+pub fn check_for_placement_in(f: Option<&Features>, diag: &SpanHandler, span: Span) {\n+    if let Some(&Features { allow_placement_in: true, .. }) = f {\n+        return;\n+    }\n+    emit_feature_err(diag, \"placement_in_syntax\", span, EXPLAIN_PLACEMENT_IN);\n+}\n+\n+pub fn check_for_pushpop_syntax(f: Option<&Features>, diag: &SpanHandler, span: Span) {\n+    if let Some(&Features { allow_pushpop_unsafe: true, .. }) = f {\n+        return;\n+    }\n+    emit_feature_err(diag, \"pushpop_unsafe\", span, EXPLAIN_PUSHPOP_UNSAFE);\n+}\n+\n struct Context<'a> {\n     features: Vec<&'static str>,\n     span_handler: &'a SpanHandler,\n@@ -366,6 +404,11 @@ struct Context<'a> {\n }\n \n impl<'a> Context<'a> {\n+    fn enable_feature(&mut self, feature: &'static str) {\n+        debug!(\"enabling feature: {}\", feature);\n+        self.features.push(feature);\n+    }\n+\n     fn gate_feature(&self, feature: &str, span: Span, explain: &str) {\n         let has_feature = self.has_feature(feature);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", feature, span, has_feature);\n@@ -488,6 +531,26 @@ impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n     fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n         self.context.check_attribute(attr, true);\n     }\n+\n+    fn visit_expr(&mut self, e: &ast::Expr) {\n+        // Issue 22181: overloaded-`box` and placement-`in` are\n+        // implemented via a desugaring expansion, so their feature\n+        // gates go into MacroVisitor since that works pre-expansion.\n+        //\n+        // Issue 22234: we also check during expansion as well.\n+        // But we keep these checks as a pre-expansion check to catch\n+        // uses in e.g. conditionalized code.\n+\n+        if let ast::ExprBox(None, _) = e.node {\n+            self.context.gate_feature(\"box_syntax\", e.span, EXPLAIN_BOX_SYNTAX);\n+        }\n+\n+        if let ast::ExprBox(Some(_), _) = e.node {\n+            self.context.gate_feature(\"placement_in_syntax\", e.span, EXPLAIN_PLACEMENT_IN);\n+        }\n+\n+        visit::walk_expr(self, e);\n+    }\n }\n \n struct PostExpansionVisitor<'a> {\n@@ -754,7 +817,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n                     match KNOWN_FEATURES.iter()\n                                         .find(|& &(n, _, _)| name == n) {\n                         Some(&(name, _, Active)) => {\n-                            cx.features.push(name);\n+                            cx.enable_feature(name);\n                         }\n                         Some(&(_, _, Removed)) => {\n                             span_handler.span_err(mi.span, \"feature has been removed\");\n@@ -787,6 +850,9 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n         allow_trace_macros: cx.has_feature(\"trace_macros\"),\n         allow_internal_unstable: cx.has_feature(\"allow_internal_unstable\"),\n         allow_custom_derive: cx.has_feature(\"custom_derive\"),\n+        allow_placement_in: cx.has_feature(\"placement_in_syntax\"),\n+        allow_box: cx.has_feature(\"box_syntax\"),\n+        allow_pushpop_unsafe: cx.has_feature(\"pushpop_unsafe\"),\n         simd_ffi: cx.has_feature(\"simd_ffi\"),\n         unmarked_api: cx.has_feature(\"unmarked_api\"),\n         negate_unsigned: cx.has_feature(\"negate_unsigned\"),"}, {"sha": "5424c0b214a4ee980222d7b4fae62b73dfccb3e0", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -120,6 +120,7 @@ pub mod ext {\n     pub mod log_syntax;\n     pub mod mtwt;\n     pub mod quote;\n+    pub mod pushpop_safe;\n     pub mod source_util;\n     pub mod trace_macros;\n "}, {"sha": "c2a2259a80adf7bca2d281e51e31c0521fc2ea7b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -2612,18 +2612,43 @@ impl<'a> Parser<'a> {\n             ex = ExprAddrOf(m, e);\n           }\n           token::Ident(_, _) => {\n-            if !self.check_keyword(keywords::Box) {\n+            if !self.check_keyword(keywords::Box) && !self.check_keyword(keywords::In) {\n                 return self.parse_dot_or_call_expr();\n             }\n \n             let lo = self.span.lo;\n-            let box_hi = self.span.hi;\n+            let keyword_hi = self.span.hi;\n \n+            let is_in = self.token.is_keyword(keywords::In);\n             try!(self.bump());\n \n-            // Check for a place: `box(PLACE) EXPR`.\n+            if is_in {\n+              let place = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n+              let blk = try!(self.parse_block());\n+              hi = blk.span.hi;\n+              let blk_expr = self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk));\n+              ex = ExprBox(Some(place), blk_expr);\n+              return Ok(self.mk_expr(lo, hi, ex));\n+            }\n+\n+            // FIXME (#22181) Remove `box (PLACE) EXPR` support\n+            // entirely after next release (enabling `(box (EXPR))`),\n+            // since it will be replaced by `in PLACE { EXPR }`, ...\n+            //\n+            // ... but for now: check for a place: `box(PLACE) EXPR`.\n+\n             if try!(self.eat(&token::OpenDelim(token::Paren)) ){\n-                // Support `box() EXPR` as the default.\n+                // SNAP d4432b3\n+                // Enable this warning after snapshot ...\n+                //\n+                // let box_span = mk_sp(lo, self.last_span.hi);\n+                // self.span_warn(\n+                //     box_span,\n+                //     \"deprecated syntax; use the `in` keyword now \\\n+                //            (e.g. change `box (<expr>) <expr>` to \\\n+                //                         `in <expr> { <expr> }`)\");\n+\n+                // Continue supporting `box () EXPR` (temporarily)\n                 if !try!(self.eat(&token::CloseDelim(token::Paren)) ){\n                     let place = try!(self.parse_expr_nopanic());\n                     try!(self.expect(&token::CloseDelim(token::Paren)));\n@@ -2634,10 +2659,15 @@ impl<'a> Parser<'a> {\n                         self.span_err(span,\n                                       &format!(\"expected expression, found `{}`\",\n                                               this_token_to_string));\n-                        let box_span = mk_sp(lo, box_hi);\n+\n+                        // Spanning just keyword avoids constructing\n+                        // printout of arg expression (which starts\n+                        // with parenthesis, as established above).\n+\n+                        let box_span = mk_sp(lo, keyword_hi);\n                         self.span_suggestion(box_span,\n-                                             \"try using `box()` instead:\",\n-                                             \"box()\".to_string());\n+                                             \"try using `box ()` instead:\",\n+                                             format!(\"box ()\"));\n                         self.abort_if_errors();\n                     }\n                     let subexpression = try!(self.parse_prefix_expr());\n@@ -2650,6 +2680,7 @@ impl<'a> Parser<'a> {\n             // Otherwise, we use the unique pointer default.\n             let subexpression = try!(self.parse_prefix_expr());\n             hi = subexpression.span.hi;\n+\n             // FIXME (pnkfelix): After working out kinks with box\n             // desugaring, should be `ExprBox(None, subexpression)`\n             // instead."}, {"sha": "448857389da6172b652d71a16b5704aa90c0164c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -1434,8 +1434,8 @@ impl<'a> State<'a> {\n                                       attrs: &[ast::Attribute],\n                                       close_box: bool) -> io::Result<()> {\n         match blk.rules {\n-            ast::UnsafeBlock(..) => try!(self.word_space(\"unsafe\")),\n-            ast::DefaultBlock => ()\n+            ast::UnsafeBlock(..) | ast::PushUnsafeBlock(..) => try!(self.word_space(\"unsafe\")),\n+            ast::DefaultBlock    | ast::PopUnsafeBlock(..) => ()\n         }\n         try!(self.maybe_print_comment(blk.span.lo));\n         try!(self.ann.pre(self, NodeBlock(blk)));"}, {"sha": "9640b2b475b6a028da18e3a878b8097d7af3fae4", "filename": "src/test/compile-fail/feature-gate-box-expr.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-box-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-box-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-box-expr.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -8,15 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main() {\n-    use std::boxed::HEAP;\n+// Check that `box EXPR` is feature-gated.\n+//\n+// See also feature-gate-placement-expr.rs\n+//\n+// (Note that the two tests are separated since the checks appear to\n+// be performed at distinct phases, with an abort_if_errors call\n+// separating them.)\n \n+fn main() {\n     let x = box 'c'; //~ ERROR box expression syntax is experimental\n     println!(\"x: {}\", x);\n \n     let x = box () 'c'; //~ ERROR box expression syntax is experimental\n     println!(\"x: {}\", x);\n-\n-    let x = box (HEAP) 'c'; //~ ERROR box expression syntax is experimental\n-    println!(\"x: {}\", x);\n }"}, {"sha": "64a1d49f9600c1714a368a633d9bc437f401afdf", "filename": "src/test/compile-fail/feature-gate-placement-expr.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-placement-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-placement-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-placement-expr.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that `in PLACE { EXPR }` is feature-gated.\n+//\n+// See also feature-gate-box-expr.rs\n+//\n+// (Note that the two tests are separated since the checks appear to\n+// be performed at distinct phases, with an abort_if_errors call\n+// separating them.)\n+\n+fn main() {\n+    use std::boxed::HEAP;\n+\n+    let x = box (HEAP) 'c'; //~ ERROR placement-in expression syntax is experimental\n+    println!(\"x: {}\", x);\n+\n+    let x = in HEAP { 'c' }; //~ ERROR placement-in expression syntax is experimental\n+    println!(\"x: {}\", x);\n+}"}, {"sha": "e317b4c7d4d2aa3f86368ac7c0da2feacc4c68c2", "filename": "src/test/compile-fail/feature-gate-pushpop-unsafe.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-pushpop-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-pushpop-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-pushpop-unsafe.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let c = push_unsafe!('c'); //~ ERROR push/pop_unsafe macros are experimental\n+    let c = pop_unsafe!('c'); //~ ERROR push/pop_unsafe macros are experimental\n+}"}, {"sha": "8e566d7aafa68f9dc5ded35ea24ac626b9f11912", "filename": "src/test/compile-fail/issue-14084.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -9,8 +9,10 @@\n // except according to those terms.\n \n #![feature(box_syntax)]\n+#![feature(placement_in_syntax)]\n \n fn main() {\n     box ( () ) 0;\n-    //~^ ERROR: only the exchange heap is currently supported\n+    //~^ ERROR: the trait `core::ops::Placer<_>` is not implemented\n+    //~| ERROR: the trait `core::ops::Placer<_>` is not implemented\n }"}, {"sha": "72c065ae714173e769051ea1751c7668a0322140", "filename": "src/test/compile-fail/pushpop-unsafe-rejects.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Fcompile-fail%2Fpushpop-unsafe-rejects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Fcompile-fail%2Fpushpop-unsafe-rejects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpushpop-unsafe-rejects.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic sanity check for `push_unsafe!(EXPR)` and\n+// `pop_unsafe!(EXPR)`: we can call unsafe code when there are a\n+// positive number of pushes in the stack, or if we are within a\n+// normal `unsafe` block, but otherwise cannot.\n+\n+#![feature(pushpop_unsafe)]\n+\n+static mut X: i32 = 0;\n+\n+unsafe fn f() { X += 1; return; }\n+fn g() { unsafe { X += 1_000; } return; }\n+\n+fn main() {\n+    push_unsafe!( {\n+        f(); pop_unsafe!({\n+            f() //~ ERROR: call to unsafe function\n+        })\n+    } );\n+\n+    push_unsafe!({\n+        f();\n+        pop_unsafe!({\n+            g();\n+            f(); //~ ERROR: call to unsafe function\n+        })\n+    } );\n+\n+    push_unsafe!({\n+        g(); pop_unsafe!({\n+            unsafe {\n+                f();\n+            }\n+            f(); //~ ERROR: call to unsafe function\n+        })\n+    });\n+\n+\n+    // Note: For implementation simplicity the compiler just\n+    // ICE's if you underflow the push_unsafe stack.\n+    //\n+    // Thus all of the following cases cause an ICE.\n+    //\n+    // (The \"ERROR\" notes are from an earlier version\n+    //  that used saturated arithmetic rather than checked\n+    //  arithmetic.)\n+\n+    //    pop_unsafe!{ g() };\n+    //\n+    //    push_unsafe!({\n+    //        pop_unsafe!(pop_unsafe!{ g() })\n+    //    });\n+    //\n+    //    push_unsafe!({\n+    //        g();\n+    //        pop_unsafe!(pop_unsafe!({\n+    //            f() // ERROR: call to unsafe function\n+    //        }))\n+    //    });\n+    //\n+    //    pop_unsafe!({\n+    //        f(); // ERROR: call to unsafe function\n+    //    })\n+\n+}"}, {"sha": "4c32d2f041e3c7fabc08c436e972686aab2e7cff", "filename": "src/test/parse-fail/parenthesized-box-expr-message.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Fparse-fail%2Fparenthesized-box-expr-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Fparse-fail%2Fparenthesized-box-expr-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fparenthesized-box-expr-message.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -12,7 +12,7 @@\n \n fn main() {\n     box (1 + 1)\n-    //~^ HELP try using `box()` instead:\n-    //~| SUGGESTION box() (1 + 1)\n+    //~^ HELP try using `box ()` instead:\n+    //~| SUGGESTION box () (1 + 1)\n     ; //~ ERROR expected expression, found `;`\n }"}, {"sha": "84af4fd0a08eae24410d7444eeb7ce1f4fa26b59", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -20,7 +20,7 @@ use std::mem::{self, transmute};\n mod rusti {\n     extern \"rust-intrinsic\" {\n         pub fn init<T>() -> T;\n-        pub fn move_val_init<T>(dst: &mut T, src: T);\n+        pub fn move_val_init<T>(dst: *mut T, src: T);\n     }\n }\n "}, {"sha": "da57e8682ca602b0e11183da4f669081e1490dbe", "filename": "src/test/run-pass/new-box-syntax.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Frun-pass%2Fnew-box-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Frun-pass%2Fnew-box-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-box-syntax.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -13,8 +13,13 @@\n /* Any copyright is dedicated to the Public Domain.\n  * http://creativecommons.org/publicdomain/zero/1.0/ */\n \n-#![allow(warnings)]\n+#![allow(dead_code, unused_variables)]\n #![feature(box_syntax, box_heap)]\n+#![feature(placement_in_syntax)]\n+\n+// during check-pretty, the expanded code needs to opt into these\n+// features\n+#![feature(placement_new_protocol, core_intrinsics)]\n \n // Tests that the new `box` syntax works with unique pointers.\n \n@@ -30,4 +35,9 @@ pub fn main() {\n     let y: Box<isize> = box 2;\n     let b: Box<isize> = box()(1 + 2);\n     let c = box()(3 + 4);\n+\n+    let s: Box<Structure> = box Structure {\n+        x: 3,\n+        y: 4,\n+    };\n }"}, {"sha": "7bda9ae252439b5cfc27014583bac8e6f8eb9d9b", "filename": "src/test/run-pass/placement-in-syntax.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Frun-pass%2Fplacement-in-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Frun-pass%2Fplacement-in-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fplacement-in-syntax.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code, unused_variables)]\n+#![feature(box_heap)]\n+#![feature(placement_in_syntax)]\n+\n+// Tests that the new `in` syntax works with unique pointers.\n+//\n+// Compare with new-box-syntax.rs\n+\n+use std::boxed::{Box, HEAP};\n+\n+struct Structure {\n+    x: isize,\n+    y: isize,\n+}\n+\n+pub fn main() {\n+    let x: Box<isize> = in HEAP { 2 };\n+    let b: Box<isize> = in HEAP { 1 + 2 };\n+    let c = in HEAP { 3 + 4 };\n+\n+    let s: Box<Structure> = in HEAP {\n+        Structure {\n+            x: 3,\n+            y: 4,\n+        }\n+    };\n+}"}, {"sha": "fc402d4136888489b92643ede0448396cf74a0e6", "filename": "src/test/run-pass/pushpop-unsafe-okay.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Frun-pass%2Fpushpop-unsafe-okay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9413a926fcfc88c46ea04534508284a822e1109f/src%2Ftest%2Frun-pass%2Fpushpop-unsafe-okay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpushpop-unsafe-okay.rs?ref=9413a926fcfc88c46ea04534508284a822e1109f", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Basic sanity check for `push_unsafe!(EXPR)` and\n+// `pop_unsafe!(EXPR)`: we can call unsafe code when there are a\n+// positive number of pushes in the stack, or if we are within a\n+// normal `unsafe` block, but otherwise cannot.\n+\n+// ignore-pretty because the `push_unsafe!` and `pop_unsafe!` macros\n+// are not integrated with the pretty-printer.\n+\n+#![feature(pushpop_unsafe)]\n+\n+static mut X: i32 = 0;\n+\n+unsafe fn f() { X += 1; return; }\n+fn g() { unsafe { X += 1_000; } return; }\n+\n+fn check_reset_x(x: i32) -> bool {\n+    #![allow(unused_parens)] // dont you judge my style choices!\n+    unsafe {\n+        let ret = (x == X);\n+        X = 0;\n+        ret\n+    }\n+}\n+\n+fn main() {\n+    // double-check test infrastructure\n+    assert!(check_reset_x(0));\n+    unsafe { f(); }\n+    assert!(check_reset_x(1));\n+    assert!(check_reset_x(0));\n+    { g(); }\n+    assert!(check_reset_x(1000));\n+    assert!(check_reset_x(0));\n+    unsafe { f(); g(); g(); }\n+    assert!(check_reset_x(2001));\n+\n+    push_unsafe!( { f(); pop_unsafe!( g() ) } );\n+    assert!(check_reset_x(1_001));\n+    push_unsafe!( { g(); pop_unsafe!( unsafe { f(); f(); } ) } );\n+    assert!(check_reset_x(1_002));\n+\n+    unsafe { push_unsafe!( { f(); pop_unsafe!( { f(); f(); } ) } ); }\n+    assert!(check_reset_x(3));\n+    push_unsafe!( { f(); push_unsafe!( { pop_unsafe!( { f(); f(); f(); } ) } ); } );\n+    assert!(check_reset_x(4));\n+}"}]}