{"sha": "2561b01211569c376b05f4c8d1434a0e527ac950", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1NjFiMDEyMTE1NjljMzc2YjA1ZjRjOGQxNDM0YTBlNTI3YWM5NTA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-27T00:16:54Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-27T00:16:54Z"}, "message": "Remove residual uses of fold, and fold itself.", "tree": {"sha": "198a4022fda831f721bb015e66c6c19e863f5288", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/198a4022fda831f721bb015e66c6c19e863f5288"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2561b01211569c376b05f4c8d1434a0e527ac950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2561b01211569c376b05f4c8d1434a0e527ac950", "html_url": "https://github.com/rust-lang/rust/commit/2561b01211569c376b05f4c8d1434a0e527ac950", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2561b01211569c376b05f4c8d1434a0e527ac950/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e945dcd817a07d2d952acf431a6bc12a4246061", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e945dcd817a07d2d952acf431a6bc12a4246061", "html_url": "https://github.com/rust-lang/rust/commit/8e945dcd817a07d2d952acf431a6bc12a4246061"}], "stats": {"total": 1998, "additions": 62, "deletions": 1936}, "files": [{"sha": "44c918fca433ef7f766ec856e9ee4f136776a75d", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=2561b01211569c376b05f4c8d1434a0e527ac950", "patch": "@@ -90,8 +90,6 @@ fn compile_input(session::session sess,\n                       bind parse_input(sess, p, input));\n     if (sess.get_opts().output_type == link::output_type_none) {ret;}\n \n-    crate = time(time_passes, \"external crate reading\",\n-                 bind creader::read_crates(sess, crate));\n     auto def_map = time(time_passes, \"resolution\",\n                         bind resolve::resolve_crate(sess, crate));\n \n@@ -121,7 +119,6 @@ fn pretty_print_input(session::session sess, eval::env env, str input,\n \n     auto mode;\n     if (typed) {\n-        crate = creader::read_crates(sess, crate);\n         auto def_map = resolve::resolve_crate(sess, crate);\n         auto ty_cx = ty::mk_ctxt(sess, def_map);\n         typeck::check_crate(ty_cx, crate);"}, {"sha": "50a016f88af2ea78544767771d02fa5670d08800", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=2561b01211569c376b05f4c8d1434a0e527ac950", "patch": "@@ -402,7 +402,7 @@ type variant = spanned[variant_];\n \n type view_item = spanned[view_item_];\n tag view_item_ {\n-    view_item_use(ident, vec[@meta_item], def_id, option::t[int]);\n+    view_item_use(ident, vec[@meta_item], def_id, ann);\n     view_item_import(ident, vec[ident], def_id);\n     view_item_export(ident);\n }"}, {"sha": "297fe402901b16803ca868447c83bff869a0c8f3", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=2561b01211569c376b05f4c8d1434a0e527ac950", "patch": "@@ -6,7 +6,8 @@ import lib::llvm::False;\n import lib::llvm::llvm;\n import lib::llvm::mk_object_file;\n import lib::llvm::mk_section_iter;\n-import middle::fold;\n+import middle::resolve;\n+import middle::walk;\n import middle::metadata;\n import middle::trans;\n import middle::ty;\n@@ -28,13 +29,6 @@ import std::option::some;\n import std::os;\n import std::map::hashmap;\n \n-// TODO: map to a real type here.\n-type env = @rec(\n-    session::session sess,\n-    @hashmap[str, int] crate_cache,\n-    vec[str] library_search_paths,\n-    mutable int next_crate_num\n-);\n \n // Type decoding\n \n@@ -453,38 +447,49 @@ fn load_crate(session::session sess,\n     fail;\n }\n \n-fn fold_view_item_use(&env e, &span sp, &ast::ident ident,\n-                      &vec[@ast::meta_item] meta_items,\n-                      &ast::def_id id, &option::t[int] cnum_opt)\n-    -> @ast::view_item {\n-    auto cnum;\n-    if (!e.crate_cache.contains_key(ident)) {\n-        cnum = e.next_crate_num;\n-        load_crate(e.sess, cnum, ident, e.library_search_paths);\n-        e.crate_cache.insert(ident, e.next_crate_num);\n-        e.next_crate_num += 1;\n-    } else {\n-        cnum = e.crate_cache.get(ident);\n-    }\n+type env = @rec(\n+    session::session sess,\n+    resolve::crate_map crate_map,\n+    @hashmap[str, int] crate_cache,\n+    vec[str] library_search_paths,\n+    mutable int next_crate_num\n+);\n \n-    auto viu = ast::view_item_use(ident, meta_items, id, some[int](cnum));\n-    ret @fold::respan[ast::view_item_](sp, viu);\n+fn visit_view_item(env e, &@ast::view_item i) {\n+    alt (i.node) {\n+        case (ast::view_item_use(?ident, ?meta_items, ?id, ?ann)) {\n+            auto cnum;\n+            if (!e.crate_cache.contains_key(ident)) {\n+                cnum = e.next_crate_num;\n+                load_crate(e.sess, cnum, ident,\n+                           e.library_search_paths);\n+                e.crate_cache.insert(ident, e.next_crate_num);\n+                e.next_crate_num += 1;\n+            } else {\n+                cnum = e.crate_cache.get(ident);\n+            }\n+            e.crate_map.insert(ann.id, cnum);\n+        }\n+        case (_) { }\n+    }\n }\n \n+\n // Reads external crates referenced by \"use\" directives.\n fn read_crates(session::session sess,\n-               @ast::crate crate) -> @ast::crate {\n+               resolve::crate_map crate_map,\n+               &ast::crate crate) {\n     auto e = @rec(\n         sess=sess,\n+        crate_map=crate_map,\n         crate_cache=@common::new_str_hash[int](),\n         library_search_paths=sess.get_opts().library_search_paths,\n         mutable next_crate_num=1\n     );\n \n-    auto f = fold_view_item_use;\n-    auto fld = @rec(fold_view_item_use=f\n-                    with *fold::new_identity_fold[env]());\n-    ret fold::fold_crate[env](e, fld, crate);\n+    auto v = rec(visit_view_item_pre=bind visit_view_item(e, _)\n+                 with walk::default_visitor());\n+    walk::walk_crate(v, crate);\n }\n \n "}, {"sha": "f4b1d1a36bc24169ed1e298519c4fab3dba3ab5a", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=2561b01211569c376b05f4c8d1434a0e527ac950", "patch": "@@ -2181,7 +2181,7 @@ fn parse_use(&parser p) -> @ast::view_item {\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n     auto use_decl = ast::view_item_use(ident, metadata, p.next_def_id(),\n-                                      none[int]);\n+                                       p.get_ann());\n     ret @spanned(lo, hi, use_decl);\n }\n "}, {"sha": "1173c11729e0ce86969d026113c2c7b1fa5de968", "filename": "src/comp/middle/fold.rs", "status": "removed", "additions": 0, "deletions": 1868, "changes": 1868, "blob_url": "https://github.com/rust-lang/rust/blob/8e945dcd817a07d2d952acf431a6bc12a4246061/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e945dcd817a07d2d952acf431a6bc12a4246061/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=8e945dcd817a07d2d952acf431a6bc12a4246061", "patch": "@@ -1,1868 +0,0 @@\n-import std::map::hashmap;\n-import std::option;\n-import std::option::some;\n-import std::option::none;\n-\n-import util::common::new_str_hash;\n-import util::common::spanned;\n-import util::common::span;\n-import util::common::ty_mach;\n-import middle::tstate::ann::ts_ann;\n-\n-import front::ast;\n-import front::ast::fn_decl;\n-import front::ast::ident;\n-import front::ast::path;\n-import front::ast::mutability;\n-import front::ast::controlflow;\n-import front::ast::ty;\n-import front::ast::expr;\n-import front::ast::stmt;\n-import front::ast::block;\n-import front::ast::item;\n-import front::ast::view_item;\n-import front::ast::meta_item;\n-import front::ast::native_item;\n-import front::ast::arg;\n-import front::ast::pat;\n-import front::ast::decl;\n-import front::ast::arm;\n-import front::ast::def;\n-import front::ast::def_id;\n-import front::ast::ann;\n-import front::ast::mt;\n-import front::ast::purity;\n-\n-import std::uint;\n-import std::vec;\n-\n-type ast_fold[ENV] =\n-    @rec\n-    (\n-     // Path fold:\n-     (fn(&ENV e, &span sp, &ast::path_ p) \n-      -> path)                                    fold_path,\n-\n-     // Type folds.\n-     (fn(&ENV e, &span sp) -> @ty)                fold_ty_nil,\n-     (fn(&ENV e, &span sp) -> @ty)                fold_ty_bot,\n-     (fn(&ENV e, &span sp) -> @ty)                fold_ty_bool,\n-     (fn(&ENV e, &span sp) -> @ty)                fold_ty_int,\n-     (fn(&ENV e, &span sp) -> @ty)                fold_ty_uint,\n-     (fn(&ENV e, &span sp) -> @ty)                fold_ty_float,\n-     (fn(&ENV e, &span sp, ty_mach tm) -> @ty)    fold_ty_machine,\n-     (fn(&ENV e, &span sp) -> @ty)                fold_ty_char,\n-     (fn(&ENV e, &span sp) -> @ty)                fold_ty_str,\n-     (fn(&ENV e, &span sp, &mt tm) -> @ty)        fold_ty_box,\n-     (fn(&ENV e, &span sp, &mt tm) -> @ty)        fold_ty_vec,\n-\n-     (fn(&ENV e, &span sp, &vec[mt] elts) -> @ty) fold_ty_tup,\n-\n-     (fn(&ENV e, &span sp,\n-         &vec[ast::ty_field] elts) -> @ty)        fold_ty_rec,\n-\n-     (fn(&ENV e, &span sp,\n-         &vec[ast::ty_method] meths) -> @ty)      fold_ty_obj,\n-\n-     (fn(&ENV e, &span sp,\n-         ast::proto proto,\n-         &vec[rec(ast::mode mode, @ty ty)] inputs,\n-         &@ty output, &controlflow cf) -> @ty)    fold_ty_fn,\n-\n-     (fn(&ENV e, &span sp, &ast::path p,\n-         &ann a) -> @ty)                          fold_ty_path,\n-\n-     (fn(&ENV e, &span sp, &@ty t) -> @ty)        fold_ty_chan,\n-     (fn(&ENV e, &span sp, &@ty t) -> @ty)        fold_ty_port,\n-\n-     // Expr folds.\n-     (fn(&ENV e, &span sp,\n-         &vec[@expr] es, ast::mutability mut,\n-         &ann a) -> @expr)                        fold_expr_vec,\n-\n-     (fn(&ENV e, &span sp,\n-         &vec[ast::elt] es, &ann a) -> @expr)     fold_expr_tup,\n-\n-     (fn(&ENV e, &span sp,\n-         &vec[ast::field] fields,\n-         &option::t[@expr] base, &ann a) -> @expr) fold_expr_rec,\n-\n-     (fn(&ENV e, &span sp,\n-         &@expr f, &vec[@expr] args,\n-         &ann a) -> @expr)                        fold_expr_call,\n-\n-     (fn(&ENV e, &span sp,\n-         &ident id, &ann a) -> @expr)             fold_expr_self_method,\n-\n-     (fn(&ENV e, &span sp,\n-         &@expr f, &vec[option::t[@expr]] args,\n-         &ann a) -> @expr)                        fold_expr_bind,\n-\n-     (fn(&ENV e, &span sp,\n-         ast::spawn_dom dom, &option::t[str] name,\n-         &@expr f, &vec[@expr] args,\n-         &ann a) -> @expr)                        fold_expr_spawn,\n-\n-     (fn(&ENV e, &span sp,\n-         ast::binop,\n-         &@expr lhs, &@expr rhs,\n-         &ann a) -> @expr)                        fold_expr_binary,\n-\n-     (fn(&ENV e, &span sp,\n-         ast::unop, &@expr e,\n-         &ann a) -> @expr)                        fold_expr_unary,\n-\n-     (fn(&ENV e, &span sp,\n-         &@ast::lit, &ann a) -> @expr)            fold_expr_lit,\n-\n-     (fn(&ENV e, &span sp,\n-         &@ast::expr e, &@ast::ty ty,\n-         &ann a) -> @expr)                        fold_expr_cast,\n-\n-     (fn(&ENV e, &span sp,\n-         &@expr cond, &block thn,\n-         &option::t[@expr] els,\n-         &ann a) -> @expr)                        fold_expr_if,\n-\n-     (fn(&ENV e, &span sp,\n-         &@decl decl, &@expr seq, &block body,\n-         &ann a) -> @expr)                        fold_expr_for,\n-\n-     (fn(&ENV e, &span sp,\n-         &@decl decl, &@expr seq, &block body,\n-         &ann a) -> @expr)                        fold_expr_for_each,\n-\n-     (fn(&ENV e, &span sp,\n-         &@expr cond, &block body,\n-         &ann a) -> @expr)                        fold_expr_while,\n-\n-     (fn(&ENV e, &span sp,\n-         &block body, &@expr cond,\n-         &ann a) -> @expr)                        fold_expr_do_while,\n-\n-     (fn(&ENV e, &span sp,\n-         &@expr e, &vec[arm] arms,\n-         &ann a) -> @expr)                        fold_expr_alt,\n-\n-     (fn(&ENV e, &span sp,\n-         &block blk, &ann a) -> @expr)            fold_expr_block,\n-\n-     (fn(&ENV e, &span sp,\n-         &@expr lhs, &@expr rhs,\n-         &ann a) -> @expr)                        fold_expr_assign,\n-\n-     (fn(&ENV e, &span sp,\n-         ast::binop,\n-         &@expr lhs, &@expr rhs,\n-         &ann a) -> @expr)                        fold_expr_assign_op,\n-\n-     (fn(&ENV e, &span sp,\n-         &@expr lhs, &@expr rhs,\n-         &ann a) -> @expr)                        fold_expr_send,\n-\n-     (fn(&ENV e, &span sp,\n-         &@expr lhs, &@expr rhs,\n-         &ann a) -> @expr)                        fold_expr_recv,\n-\n-     (fn(&ENV e, &span sp,\n-         &@expr e, &ident i,\n-         &ann a) -> @expr)                        fold_expr_field,\n-\n-     (fn(&ENV e, &span sp,\n-         &@expr e, &@expr ix,\n-         &ann a) -> @expr)                        fold_expr_index,\n-\n-     (fn(&ENV e, &span sp,\n-         &path p,\n-         &ann a) -> @expr)                        fold_expr_path,\n-\n-     (fn(&ENV e, &span sp,\n-         &path p, &vec[@expr] args,\n-         &option::t[str] body,\n-         &@expr expanded,\n-         &ann a) -> @expr)                        fold_expr_ext,\n-\n-     (fn(&ENV e, &span sp, &ann a) -> @expr)      fold_expr_fail,\n-\n-     (fn(&ENV e, &span sp, &ann a) -> @expr)      fold_expr_break,\n-\n-     (fn(&ENV e, &span sp, &ann a) -> @expr)      fold_expr_cont,\n-\n-     (fn(&ENV e, &span sp,\n-         &option::t[@expr] rv, &ann a) -> @expr)  fold_expr_ret,\n-\n-     (fn(&ENV e, &span sp,\n-         &option::t[@expr] rv, &ann a) -> @expr)  fold_expr_put,\n-\n-     (fn(&ENV e, &span sp,\n-         &@expr e, &ann a) -> @expr)              fold_expr_be,\n-\n-     (fn(&ENV e, &span sp, int lvl,\n-         &@expr e, &ann a) -> @expr)              fold_expr_log,\n-\n-     (fn(&ENV e, &span sp,\n-         &@expr e, &ann a) -> @expr)              fold_expr_check,\n-\n-     (fn(&ENV e, &span sp,\n-         &@expr e, &ann a) -> @expr)              fold_expr_assert,\n-\n-     (fn(&ENV e, &span sp,\n-         &ann a) -> @expr)                        fold_expr_port,\n-\n-     (fn(&ENV e, &span sp,\n-         &@expr e, &ann a) -> @expr)              fold_expr_chan,\n-\n-     (fn(&ENV e, &span sp,\n-         &ast::anon_obj ob,\n-         &vec[ast::ty_param] tps,\n-         &ast::obj_def_ids odid, \n-         &ann a) -> @expr)                        fold_expr_anon_obj,\n-\n-     // Decl folds.\n-     (fn(&ENV e, &span sp,\n-         &@ast::local local) -> @decl)            fold_decl_local,\n-\n-     (fn(&ENV e, &span sp,\n-         &@item item) -> @decl)                   fold_decl_item,\n-\n-\n-     // Pat folds.\n-     (fn(&ENV e, &span sp,\n-         &ann a) -> @pat)                         fold_pat_wild,\n-\n-     (fn(&ENV e, &span sp,\n-         &@ast::lit lit, &ann a) -> @pat)         fold_pat_lit,\n-\n-     (fn(&ENV e, &span sp,\n-         &ident i, &def_id did, &ann a) -> @pat)  fold_pat_bind,\n-\n-     (fn(&ENV e, &span sp,\n-         &path p, &vec[@pat] args,\n-         &ann a) -> @pat)                         fold_pat_tag,\n-\n-\n-     // Stmt folds.\n-     (fn(&ENV e, &span sp,\n-         &@decl decl, &ann a)\n-      -> @stmt)                                   fold_stmt_decl,\n-\n-     (fn(&ENV e, &span sp,\n-         &@expr e, &ann a)\n-      -> @stmt)                                   fold_stmt_expr,\n-\n-     // Item folds.\n-     (fn(&ENV e, &span sp, &ident ident,\n-         &@ty t, &@expr e,\n-         &def_id id, &ann a) -> @item)            fold_item_const,\n-\n-     (fn(&ENV e, &span sp, &ident ident,\n-         &ast::_fn f,\n-         &vec[ast::ty_param] ty_params,\n-         &def_id id, &ann a) -> @item)            fold_item_fn,\n-\n-     (fn(&ENV e, &span sp, &ident ident,\n-         &option::t[str] link_name,\n-         &ast::fn_decl decl,\n-         &vec[ast::ty_param] ty_params,\n-         &def_id id, &ann a) -> @native_item)     fold_native_item_fn,\n-\n-     (fn(&ENV e, &span sp, &ident ident,\n-         &ast::_mod m, &def_id id) -> @item)      fold_item_mod,\n-\n-     (fn(&ENV e, &span sp, &ident ident,\n-         &ast::native_mod m, &def_id id) \n-      -> @item)                                   fold_item_native_mod,\n-\n-     (fn(&ENV e, &span sp, &ident ident,\n-         &@ty t, &vec[ast::ty_param] ty_params,\n-         &def_id id, &ann a) -> @item)            fold_item_ty,\n-\n-     (fn(&ENV e, &span sp, &ident ident,\n-         &def_id id) -> @native_item)             fold_native_item_ty,\n-\n-     (fn(&ENV e, &span sp, &ident ident,\n-         &vec[ast::variant] variants,\n-         &vec[ast::ty_param] ty_params,\n-         &def_id id, &ann a) -> @item)            fold_item_tag,\n-\n-     (fn(&ENV e, &span sp, &ident ident,\n-         &ast::_obj ob,\n-         &vec[ast::ty_param] ty_params,\n-         &ast::obj_def_ids odid, &ann a) \n-      -> @item)                                   fold_item_obj,\n-\n-     // View Item folds.\n-     (fn(&ENV e, &span sp, &ident ident,\n-         &vec[@meta_item] meta_items,\n-         &def_id id,\n-         &option::t[int]) -> @view_item)          fold_view_item_use,\n-\n-     (fn(&ENV e, &span sp, &ident i,\n-         &vec[ident] idents,\n-         &def_id id) -> @view_item)               fold_view_item_import,\n-\n-     (fn(&ENV e, &span sp,\n-         &ident i) -> @view_item)                 fold_view_item_export,\n-\n-     // Annotation folds.\n-     (fn(&ENV e, &ann a) -> ann)                  fold_ann,\n-\n-     // Additional nodes.\n-\n-     (fn(&ENV e, &fn_decl decl,\n-         ast::proto proto,\n-         &block body) -> ast::_fn)                fold_fn,\n-\n-     (fn(&ENV e,\n-         &vec[arg] inputs,\n-         &@ty output,\n-         &purity p, &controlflow c) -> ast::fn_decl) fold_fn_decl,\n-\n-     (fn(&ENV e, &ast::_mod m) -> ast::_mod)      fold_mod,\n-\n-     (fn(&ENV e, &ast::native_mod m) \n-      -> ast::native_mod)                         fold_native_mod,\n-\n-     (fn(&ENV e, &span sp,\n-         &vec[@ast::crate_directive] cdirs,\n-         &ast::_mod m) -> @ast::crate)            fold_crate,\n-\n-     (fn(&ENV e,\n-         &vec[ast::obj_field] fields,\n-         &vec[@ast::method] methods,\n-         &option::t[@ast::method] dtor)\n-      -> ast::_obj)                               fold_obj,\n-\n-     (fn(&ENV e,\n-         &option::t[vec[ast::obj_field]] fields,\n-         &vec[@ast::method] methods,\n-         &option::t[@ast::expr] with_obj) \n-      -> ast::anon_obj)                           fold_anon_obj,\n-\n-     // Env updates.\n-     (fn(&ENV e, &@ast::crate c) -> ENV) update_env_for_crate,\n-     (fn(&ENV e, &@item i) -> ENV) update_env_for_item,\n-     (fn(&ENV e, &@native_item i) -> ENV) update_env_for_native_item,\n-     (fn(&ENV e, &@view_item i) -> ENV) update_env_for_view_item,\n-     (fn(&ENV e, &block b) -> ENV) update_env_for_block,\n-     (fn(&ENV e, &@stmt s) -> ENV) update_env_for_stmt,\n-     (fn(&ENV e, &@decl i) -> ENV) update_env_for_decl,\n-     (fn(&ENV e, &@pat p) -> ENV) update_env_for_pat,\n-     (fn(&ENV e, &arm a) -> ENV) update_env_for_arm,\n-     (fn(&ENV e, &@expr x) -> ENV) update_env_for_expr,\n-     (fn(&ENV e, &@ty t) -> ENV) update_env_for_ty,\n-\n-     // Traversal control.\n-     (fn(&ENV v) -> bool) keep_going\n-     );\n-\n-\n-//// Fold drivers.\n-\n-fn fold_path[ENV](&ENV env, &ast_fold[ENV] fld, &path p) -> path {\n-    let vec[@ast::ty] tys_ = [];\n-    for (@ast::ty t in p.node.types) {\n-        vec::push[@ast::ty](tys_, fold_ty(env, fld, t));\n-    }\n-    let ast::path_ p_ = rec(idents=p.node.idents, types=tys_);\n-    ret fld.fold_path(env, p.span, p_);\n-}\n-\n-fn fold_ty[ENV](&ENV env, &ast_fold[ENV] fld, &@ty t) -> @ty {\n-    let ENV env_ = fld.update_env_for_ty(env, t);\n-\n-    if (!fld.keep_going(env_)) {\n-        ret t;\n-    }\n-\n-    alt (t.node) {\n-        case (ast::ty_nil) { ret fld.fold_ty_nil(env_, t.span); }\n-        case (ast::ty_bot) { ret fld.fold_ty_bot(env_, t.span); }\n-        case (ast::ty_bool) { ret fld.fold_ty_bool(env_, t.span); }\n-        case (ast::ty_int) { ret fld.fold_ty_int(env_, t.span); }\n-        case (ast::ty_uint) { ret fld.fold_ty_uint(env_, t.span); }\n-        case (ast::ty_float) { ret fld.fold_ty_float(env_, t.span); }\n-\n-        case (ast::ty_machine(?m)) {\n-            ret fld.fold_ty_machine(env_, t.span, m);\n-        }\n-\n-        case (ast::ty_char) { ret fld.fold_ty_char(env_, t.span); }\n-        case (ast::ty_str) { ret fld.fold_ty_str(env_, t.span); }\n-\n-        case (ast::ty_box(?tm)) {\n-            auto ty_ = fold_ty(env, fld, tm.ty);\n-            ret fld.fold_ty_box(env_, t.span, rec(ty=ty_, mut=tm.mut));\n-        }\n-\n-        case (ast::ty_vec(?tm)) {\n-            auto ty_ = fold_ty(env, fld, tm.ty);\n-            ret fld.fold_ty_vec(env_, t.span, rec(ty=ty_, mut=tm.mut));\n-        }\n-\n-        case (ast::ty_tup(?elts)) {\n-            let vec[mt] elts_ = [];\n-            for (mt elt in elts) {\n-                auto ty_ = fold_ty(env, fld, elt.ty);\n-                vec::push[mt](elts_, rec(ty=ty_, mut=elt.mut));\n-            }\n-            ret fld.fold_ty_tup(env_, t.span, elts_);\n-        }\n-\n-        case (ast::ty_rec(?flds)) {\n-            let vec[ast::ty_field] flds_ = [];\n-            for (ast::ty_field f in flds) {\n-                auto ty_ = fold_ty(env, fld, f.mt.ty);\n-                vec::push[ast::ty_field]\n-                    (flds_, rec(mt=rec(ty=ty_, mut=f.mt.mut) with f));\n-            }\n-            ret fld.fold_ty_rec(env_, t.span, flds_);\n-        }\n-\n-        case (ast::ty_obj(?meths)) {\n-            let vec[ast::ty_method] meths_ = [];\n-            for (ast::ty_method m in meths) {\n-                auto tfn = fold_ty_fn(env_, fld, t.span, m.proto,\n-                                      m.inputs, m.output, m.cf);\n-                alt (tfn.node) {\n-                    case (ast::ty_fn(?p, ?ins, ?out, ?cf)) {\n-                        vec::push[ast::ty_method]\n-                            (meths_, rec(proto=p, inputs=ins,\n-                                         output=out, cf=cf with m));\n-                    }\n-                }\n-            }\n-            ret fld.fold_ty_obj(env_, t.span, meths_);\n-        }\n-\n-        case (ast::ty_path(?pth, ?ann)) {\n-            auto pth_ = fold_path(env, fld, pth);\n-            ret fld.fold_ty_path(env_, t.span, pth_, ann);\n-        }\n-\n-        case (ast::ty_fn(?proto, ?inputs, ?output, ?cf)) {\n-            ret fold_ty_fn(env_, fld, t.span, proto, inputs, output, cf);\n-        }\n-\n-        case (ast::ty_chan(?ty)) {\n-            auto ty_ = fold_ty(env, fld, ty);\n-            ret fld.fold_ty_chan(env_, t.span, ty_);\n-        }\n-\n-        case (ast::ty_port(?ty)) {\n-            auto ty_ = fold_ty(env, fld, ty);\n-            ret fld.fold_ty_port(env_, t.span, ty_);\n-        }\n-    }\n-}\n-\n-fn fold_ty_fn[ENV](&ENV env, &ast_fold[ENV] fld, &span sp,\n-                   ast::proto proto,\n-                   &vec[rec(ast::mode mode, @ty ty)] inputs,\n-                   &@ty output, &controlflow cf) -> @ty {\n-    auto output_ = fold_ty(env, fld, output);\n-    let vec[rec(ast::mode mode, @ty ty)] inputs_ = [];\n-    for (rec(ast::mode mode, @ty ty) input in inputs) {\n-        auto ty_ = fold_ty(env, fld, input.ty);\n-        auto input_ = rec(ty=ty_ with input);\n-        inputs_ += [input_];\n-    }\n-    ret fld.fold_ty_fn(env, sp, proto, inputs_, output_, cf);\n-}\n-\n-fn fold_decl[ENV](&ENV env, &ast_fold[ENV] fld, &@decl d) -> @decl {\n-    let ENV env_ = fld.update_env_for_decl(env, d);\n-\n-    if (!fld.keep_going(env_)) {\n-        ret d;\n-    }\n-\n-    alt (d.node) {\n-        case (ast::decl_local(?local)) {\n-            auto ty_ = none[@ast::ty];\n-            auto init_ = none[ast::initializer];\n-            alt (local.ty) {\n-                case (some[@ast::ty](?t)) {\n-                    ty_ = some[@ast::ty](fold_ty(env, fld, t));\n-                }\n-                case (_) { /* fall through */  }\n-            }\n-            alt (local.init) {\n-                case (some[ast::initializer](?init)) {\n-                    auto e =  fold_expr(env, fld, init.expr);\n-                    init_ = some[ast::initializer](rec(expr = e with init));\n-                }\n-                case (_) { /* fall through */  }\n-            }\n-            auto ann_ = fld.fold_ann(env_, local.ann);\n-            let @ast::local local_ =\n-                @rec(ty=ty_, init=init_, ann=ann_ with *local);\n-            ret fld.fold_decl_local(env_, d.span, local_);\n-        }\n-\n-        case (ast::decl_item(?item)) {\n-            auto item_ = fold_item(env_, fld, item);\n-            ret fld.fold_decl_item(env_, d.span, item_);\n-        }\n-    }\n-\n-    fail;\n-}\n-\n-fn fold_pat[ENV](&ENV env, &ast_fold[ENV] fld, &@ast::pat p) -> @ast::pat {\n-    let ENV env_ = fld.update_env_for_pat(env, p);\n-\n-    if (!fld.keep_going(env_)) {\n-        ret p;\n-    }\n-\n-    alt (p.node) {\n-        case (ast::pat_wild(?t)) { ret fld.fold_pat_wild(env_, p.span, t); }\n-        case (ast::pat_lit(?lt, ?t)) {\n-            ret fld.fold_pat_lit(env_, p.span, lt, t);\n-        }\n-        case (ast::pat_bind(?id, ?did, ?t)) {\n-            ret fld.fold_pat_bind(env_, p.span, id, did, t);\n-        }\n-        case (ast::pat_tag(?path, ?pats, ?t)) {\n-            auto ppath = fold_path(env, fld, path);\n-\n-            let vec[@ast::pat] ppats = [];\n-            for (@ast::pat pat in pats) {\n-                ppats += [fold_pat(env_, fld, pat)];\n-            }\n-\n-            ret fld.fold_pat_tag(env_, p.span, ppath, ppats, t);\n-        }\n-    }\n-}\n-\n-fn fold_exprs[ENV](&ENV env, &ast_fold[ENV] fld,\n-                   &vec[@expr] es) -> vec[@expr] {\n-    let vec[@expr] exprs = [];\n-    for (@expr e in es) {\n-        vec::push[@expr](exprs, fold_expr(env, fld, e));\n-    }\n-    ret exprs;\n-}\n-\n-fn fold_tup_elt[ENV](&ENV env, &ast_fold[ENV] fld, &ast::elt e) -> ast::elt {\n-    ret rec(expr=fold_expr(env, fld, e.expr) with e);\n-}\n-\n-fn fold_rec_field[ENV](&ENV env, &ast_fold[ENV] fld, &ast::field f)\n-    -> ast::field {\n-    ret rec(expr=fold_expr(env, fld, f.expr) with f);\n-}\n-\n-fn fold_expr[ENV](&ENV env, &ast_fold[ENV] fld, &@expr e) -> @expr {\n-\n-    let ENV env_ = fld.update_env_for_expr(env, e);\n-\n-    if (!fld.keep_going(env_)) {\n-        ret e;\n-    }\n-\n-    alt (e.node) {\n-        case (ast::expr_vec(?es, ?mut, ?t)) {\n-            auto ees = fold_exprs(env_, fld, es);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_vec(env_, e.span, ees, mut, t2);\n-        }\n-\n-        case (ast::expr_tup(?es, ?t)) {\n-            let vec[ast::elt] elts = [];\n-            for (ast::elt e in es) {\n-                elts += [fold_tup_elt[ENV](env, fld, e)];\n-            }\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_tup(env_, e.span, elts, t2);\n-        }\n-\n-        case (ast::expr_rec(?fs, ?base, ?t)) {\n-            let vec[ast::field] fields = [];\n-            let option::t[@expr] b = none[@expr];\n-            for (ast::field f in fs) {\n-                fields += [fold_rec_field(env, fld, f)];\n-            }\n-            alt (base) {\n-                case (none[@ast::expr]) { }\n-                case (some[@ast::expr](?eb)) {\n-                    b = some[@expr](fold_expr(env_, fld, eb));\n-                }\n-            }\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_rec(env_, e.span, fields, b, t2);\n-        }\n-\n-        case (ast::expr_call(?f, ?args, ?t)) {\n-            auto ff = fold_expr(env_, fld, f);\n-            auto aargs = fold_exprs(env_, fld, args);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_call(env_, e.span, ff, aargs, t2);\n-        }\n-\n-        case (ast::expr_self_method(?ident, ?t)) {\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_self_method(env_, e.span, ident, t2);\n-        }\n-\n-        case (ast::expr_bind(?f, ?args_opt, ?t)) {\n-            auto ff = fold_expr(env_, fld, f);\n-            let vec[option::t[@ast::expr]] aargs_opt = [];\n-            for (option::t[@ast::expr] t_opt in args_opt) {\n-                alt (t_opt) {\n-                    case (none[@ast::expr]) {\n-                        aargs_opt += [none[@ast::expr]];\n-                    }\n-                    case (some[@ast::expr](?e)) {\n-                        aargs_opt += [some(fold_expr(env_, fld, e))];\n-                    }\n-                    case (none[@ast::expr]) { /* empty */ }\n-                }\n-            }\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_bind(env_, e.span, ff, aargs_opt, t2);\n-        }\n-\n-        case (ast::expr_spawn(?dom, ?name, ?f, ?args, ?t)) {\n-            auto ff = fold_expr(env_, fld, f);\n-            auto aargs = fold_exprs(env_, fld, args);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_spawn(env_, e.span, dom, name, ff, aargs, t2);\n-        }\n-\n-        case (ast::expr_binary(?op, ?a, ?b, ?t)) {\n-            auto aa = fold_expr(env_, fld, a);\n-            auto bb = fold_expr(env_, fld, b);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_binary(env_, e.span, op, aa, bb, t2);\n-        }\n-\n-        case (ast::expr_unary(?op, ?a, ?t)) {\n-            auto aa = fold_expr(env_, fld, a);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_unary(env_, e.span, op, aa, t2);\n-        }\n-\n-        case (ast::expr_lit(?lit, ?t)) {\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_lit(env_, e.span, lit, t2);\n-        }\n-\n-        case (ast::expr_cast(?e, ?t, ?at)) {\n-            auto ee = fold_expr(env_, fld, e);\n-            auto tt = fold_ty(env, fld, t);\n-            auto at2 = fld.fold_ann(env_, at);\n-            ret fld.fold_expr_cast(env_, e.span, ee, tt, at2);\n-        }\n-\n-        case (ast::expr_if(?cnd, ?thn, ?els, ?t)) {\n-            auto ccnd = fold_expr(env_, fld, cnd);\n-            auto tthn = fold_block(env_, fld, thn);\n-            auto eels = none[@expr];\n-            alt (els) {\n-                case (some[@expr](?e)) {\n-                    eels = some(fold_expr(env_, fld, e));\n-                }\n-                case (_) { /* fall through */  }\n-            }\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_if(env_, e.span, ccnd, tthn, eels, t2);\n-        }\n-\n-        case (ast::expr_for(?decl, ?seq, ?body, ?t)) {\n-            auto ddecl = fold_decl(env_, fld, decl);\n-            auto sseq = fold_expr(env_, fld, seq);\n-            auto bbody = fold_block(env_, fld, body);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_for(env_, e.span, ddecl, sseq, bbody, t2);\n-        }\n-\n-        case (ast::expr_for_each(?decl, ?seq, ?body, ?t)) {\n-            auto ddecl = fold_decl(env_, fld, decl);\n-            auto sseq = fold_expr(env_, fld, seq);\n-            auto bbody = fold_block(env_, fld, body);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_for_each(env_, e.span, ddecl, sseq, bbody, t2);\n-        }\n-\n-        case (ast::expr_while(?cnd, ?body, ?t)) {\n-            auto ccnd = fold_expr(env_, fld, cnd);\n-            auto bbody = fold_block(env_, fld, body);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_while(env_, e.span, ccnd, bbody, t2);\n-        }\n-\n-        case (ast::expr_do_while(?body, ?cnd, ?t)) {\n-            auto bbody = fold_block(env_, fld, body);\n-            auto ccnd = fold_expr(env_, fld, cnd);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_do_while(env_, e.span, bbody, ccnd, t2);\n-        }\n-\n-        case (ast::expr_alt(?expr, ?arms, ?t)) {\n-            auto eexpr = fold_expr(env_, fld, expr);\n-            let vec[ast::arm] aarms = [];\n-            for (ast::arm a in arms) {\n-                aarms += [fold_arm(env_, fld, a)];\n-            }\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_alt(env_, e.span, eexpr, aarms, t2);\n-        }\n-\n-        case (ast::expr_block(?b, ?t)) {\n-            auto bb = fold_block(env_, fld, b);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_block(env_, e.span, bb, t2);\n-        }\n-\n-        case (ast::expr_assign(?lhs, ?rhs, ?t)) {\n-            auto llhs = fold_expr(env_, fld, lhs);\n-            auto rrhs = fold_expr(env_, fld, rhs);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_assign(env_, e.span, llhs, rrhs, t2);\n-        }\n-\n-        case (ast::expr_assign_op(?op, ?lhs, ?rhs, ?t)) {\n-            auto llhs = fold_expr(env_, fld, lhs);\n-            auto rrhs = fold_expr(env_, fld, rhs);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_assign_op(env_, e.span, op, llhs, rrhs, t2);\n-        }\n-\n-        case (ast::expr_send(?lhs, ?rhs, ?t)) {\n-            auto llhs = fold_expr(env_, fld, lhs);\n-            auto rrhs = fold_expr(env_, fld, rhs);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_send(env_, e.span, llhs, rrhs, t2);\n-        }\n-\n-        case (ast::expr_recv(?lhs, ?rhs, ?t)) {\n-            auto llhs = fold_expr(env_, fld, lhs);\n-            auto rrhs = fold_expr(env_, fld, rhs);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_recv(env_, e.span, llhs, rrhs, t2);\n-        }\n-\n-        case (ast::expr_field(?e, ?i, ?t)) {\n-            auto ee = fold_expr(env_, fld, e);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_field(env_, e.span, ee, i, t2);\n-        }\n-\n-        case (ast::expr_index(?e, ?ix, ?t)) {\n-            auto ee = fold_expr(env_, fld, e);\n-            auto iix = fold_expr(env_, fld, ix);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_index(env_, e.span, ee, iix, t2);\n-        }\n-\n-        case (ast::expr_path(?p, ?t)) {\n-            auto p_ = fold_path(env_, fld, p);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_path(env_, e.span, p_, t2);\n-        }\n-\n-        case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?t)) {\n-            // Only fold the expanded expression, not the\n-            // expressions involved in syntax extension\n-            auto exp = fold_expr(env_, fld, expanded);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_ext(env_, e.span, p, args, body,\n-                                  exp, t2);\n-        }\n-\n-        case (ast::expr_fail(?t)) {\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_fail(env_, e.span, t2);\n-        }\n-\n-        case (ast::expr_break(?t)) {\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_break(env_, e.span, t2);\n-        }\n-\n-        case (ast::expr_cont(?t)) {\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_cont(env_, e.span, t2);\n-        }\n-\n-        case (ast::expr_ret(?oe, ?t)) {\n-            auto oee = none[@expr];\n-            alt (oe) {\n-                case (some[@expr](?x)) {\n-                    oee = some(fold_expr(env_, fld, x));\n-                }\n-                case (_) { /* fall through */  }\n-            }\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_ret(env_, e.span, oee, t2);\n-        }\n-\n-        case (ast::expr_put(?oe, ?t)) {\n-            auto oee = none[@expr];\n-            alt (oe) {\n-                case (some[@expr](?x)) {\n-                    oee = some(fold_expr(env_, fld, x));\n-                }\n-                case (_) { /* fall through */  }\n-            }\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_put(env_, e.span, oee, t2);\n-        }\n-\n-        case (ast::expr_be(?x, ?t)) {\n-            auto ee = fold_expr(env_, fld, x);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_be(env_, e.span, ee, t2);\n-        }\n-\n-        case (ast::expr_log(?l, ?x, ?t)) {\n-            auto ee = fold_expr(env_, fld, x);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_log(env_, e.span, l, ee, t2);\n-        }\n-\n-        case (ast::expr_check(?x, ?t)) {\n-            auto ee = fold_expr(env_, fld, x);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_check(env_, e.span, ee, t2);\n-        }\n-\n-        case (ast::expr_assert(?x, ?t)) {\n-            auto ee = fold_expr(env_, fld, x);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_assert(env_, e.span, ee, t2);\n-        }\n-\n-        case (ast::expr_port(?t)) {\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_port(env_, e.span, t2);\n-        }\n-\n-        case (ast::expr_chan(?x, ?t)) {\n-            auto ee = fold_expr(env_, fld, x);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_chan(env_, e.span, ee, t2);\n-        }\n-\n-        case (ast::expr_anon_obj(?ob, ?tps, ?odid, ?t)) {\n-            auto ee = fold_anon_obj(env_, fld, ob);\n-            auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_anon_obj(env_, e.span, ee, tps, odid, t2);\n-        }\n-    }\n-\n-    fail;\n-}\n-\n-\n-fn fold_stmt[ENV](&ENV env, &ast_fold[ENV] fld, &@stmt s) -> @stmt {\n-\n-    let ENV env_ = fld.update_env_for_stmt(env, s);\n-\n-    if (!fld.keep_going(env_)) {\n-        ret s;\n-    }\n-\n-    alt (s.node) {\n-        case (ast::stmt_decl(?d, ?a)) {\n-            auto dd = fold_decl(env_, fld, d);\n-            auto aa = fld.fold_ann(env_, a);\n-            ret fld.fold_stmt_decl(env_, s.span, dd, aa);\n-        }\n-\n-        case (ast::stmt_expr(?e, ?a)) {\n-            auto ee = fold_expr(env_, fld, e);\n-            auto aa = fld.fold_ann(env_, a);\n-            ret fld.fold_stmt_expr(env_, s.span, ee, aa);\n-        }\n-    }\n-    fail;\n-}\n-\n-fn fold_block[ENV](&ENV env, &ast_fold[ENV] fld, &block blk) -> block {\n-\n-    let ENV env_ = fld.update_env_for_block(env, blk);\n-\n-    if (!fld.keep_going(env_)) {\n-        ret blk;\n-    }\n-\n-    let vec[@ast::stmt] stmts = [];\n-    for (@ast::stmt s in blk.node.stmts) {\n-        auto new_stmt = fold_stmt[ENV](env_, fld, s);\n-        vec::push[@ast::stmt](stmts, new_stmt);\n-    }\n-\n-    auto expr = none[@ast::expr];\n-    alt (blk.node.expr) {\n-        case (some[@ast::expr](?e)) {\n-            expr = some[@ast::expr](fold_expr[ENV](env_, fld, e));\n-        }\n-        case (none[@ast::expr]) {\n-            // empty\n-        }\n-    }\n-\n-    auto aa = fld.fold_ann(env, blk.node.a);\n-    ret respan(blk.span, rec(stmts=stmts, expr=expr, a=aa));\n-}\n-\n-fn fold_arm[ENV](&ENV env, &ast_fold[ENV] fld, &arm a) -> arm {\n-    let ENV env_ = fld.update_env_for_arm(env, a);\n-    auto ppat = fold_pat(env_, fld, a.pat);\n-    auto bblock = fold_block(env_, fld, a.block);\n-    ret rec(pat=ppat, block=bblock);\n-}\n-\n-fn fold_arg[ENV](&ENV env, &ast_fold[ENV] fld, &arg a) -> arg {\n-    auto ty = fold_ty(env, fld, a.ty);\n-    ret rec(ty=ty with a);\n-}\n-\n-fn fold_fn_decl[ENV](&ENV env, &ast_fold[ENV] fld,\n-                     &ast::fn_decl decl) -> ast::fn_decl {\n-    let vec[ast::arg] inputs = [];\n-    for (ast::arg a in decl.inputs) {\n-        inputs += [fold_arg(env, fld, a)];\n-    }\n-    auto output = fold_ty[ENV](env, fld, decl.output);\n-    ret fld.fold_fn_decl(env, inputs, output, decl.purity, decl.cf);\n-}\n-\n-fn fold_fn[ENV](&ENV env, &ast_fold[ENV] fld, &ast::_fn f) -> ast::_fn {\n-    auto decl = fold_fn_decl(env, fld, f.decl);\n-\n-    auto body = fold_block[ENV](env, fld, f.body);\n-\n-    ret fld.fold_fn(env, decl, f.proto, body);\n-}\n-\n-\n-fn fold_obj_field[ENV](&ENV env, &ast_fold[ENV] fld,\n-                       &ast::obj_field f) -> ast::obj_field {\n-    auto ty = fold_ty(env, fld, f.ty);\n-    ret rec(ty=ty with f);\n-}\n-\n-\n-fn fold_method[ENV](&ENV env, &ast_fold[ENV] fld,\n-                    &@ast::method m) -> @ast::method {\n-    auto meth = fold_fn(env, fld, m.node.meth);\n-    ret @rec(node=rec(meth=meth with m.node) with *m);\n-}\n-\n-fn fold_obj[ENV](&ENV env, &ast_fold[ENV] fld, &ast::_obj ob) -> ast::_obj {\n-\n-    let vec[ast::obj_field] fields = [];\n-    let vec[@ast::method] meths = [];\n-    for (ast::obj_field f in ob.fields) {\n-        fields += [fold_obj_field(env, fld, f)];\n-    }\n-    let option::t[@ast::method] dtor = none[@ast::method];\n-    alt (ob.dtor) {\n-        case (none[@ast::method]) { }\n-        case (some[@ast::method](?m)) {\n-            dtor = some[@ast::method](fold_method[ENV](env, fld, m));\n-        }\n-    }\n-    let vec[ast::ty_param] tp = [];\n-    for (@ast::method m in ob.methods) {\n-        // Fake-up an ast::item for this method.\n-        // FIXME: this is kinda awful. Maybe we should reformulate\n-        // the way we store methods in the AST?\n-        let @ast::item i = @rec(node=ast::item_fn(m.node.ident,\n-                                                m.node.meth,\n-                                                tp,\n-                                                m.node.id,\n-                                                m.node.ann),\n-                               span=m.span);\n-        let ENV _env = fld.update_env_for_item(env, i);\n-        vec::push[@ast::method](meths, fold_method(_env, fld, m));\n-    }\n-    ret fld.fold_obj(env, fields, meths, dtor);\n-}\n-\n-fn fold_anon_obj[ENV](&ENV env, &ast_fold[ENV] fld, &ast::anon_obj ob) \n-    -> ast::anon_obj {\n-\n-    // Fields\n-    let option::t[vec[ast::obj_field]] fields = none[vec[ast::obj_field]];\n-    alt (ob.fields) {\n-        case (none[vec[ast::obj_field]]) { }\n-        case (some[vec[ast::obj_field]](?v)) {\n-            let vec[ast::obj_field] fields = [];\n-            for (ast::obj_field f in v) {\n-                fields += [fold_obj_field(env, fld, f)];\n-            }\n-        }\n-    }\n-\n-    // with_obj\n-    let option::t[@ast::expr] with_obj = none[@ast::expr];\n-    alt (ob.with_obj) {\n-        case (none[@ast::expr]) { }\n-        case (some[@ast::expr](?e)) {\n-            with_obj = some[@ast::expr](fold_expr(env, fld, e));\n-        }\n-    }\n-\n-    // Methods\n-    let vec[@ast::method] meths = [];\n-    let vec[ast::ty_param] tp = [];\n-    for (@ast::method m in ob.methods) {\n-        // Fake-up an ast::item for this method.\n-        // FIXME: this is kinda awful. Maybe we should reformulate\n-        // the way we store methods in the AST?\n-        let @ast::item i = @rec(node=ast::item_fn(m.node.ident,\n-                                                m.node.meth,\n-                                                tp,\n-                                                m.node.id,\n-                                                m.node.ann),\n-                               span=m.span);\n-        let ENV _env = fld.update_env_for_item(env, i);\n-        vec::push[@ast::method](meths, fold_method(_env, fld, m));\n-    }\n-    ret fld.fold_anon_obj(env, fields, meths, with_obj);\n-}\n-\n-fn fold_view_item[ENV](&ENV env, &ast_fold[ENV] fld, &@view_item vi)\n-    -> @view_item {\n-\n-    let ENV env_ = fld.update_env_for_view_item(env, vi);\n-\n-    if (!fld.keep_going(env_)) {\n-        ret vi;\n-    }\n-\n-    alt (vi.node) {\n-        case (ast::view_item_use(?ident, ?meta_items, ?def_id, ?cnum)) {\n-            ret fld.fold_view_item_use(env_, vi.span, ident, meta_items,\n-                                       def_id, cnum);\n-        }\n-        case (ast::view_item_import(?def_ident, ?idents, ?def_id)) {\n-            ret fld.fold_view_item_import(env_, vi.span, def_ident, idents,\n-                                          def_id);\n-        }\n-\n-        case (ast::view_item_export(?def_ident)) {\n-            ret fld.fold_view_item_export(env_, vi.span, def_ident);\n-        }\n-    }\n-\n-    fail;\n-}\n-\n-fn fold_item[ENV](&ENV env, &ast_fold[ENV] fld, &@item i) -> @item {\n-\n-    let ENV env_ = fld.update_env_for_item(env, i);\n-\n-    if (!fld.keep_going(env_)) {\n-        ret i;\n-    }\n-\n-    alt (i.node) {\n-\n-        case (ast::item_const(?ident, ?t, ?e, ?id, ?ann)) {\n-            let @ast::ty t_ = fold_ty[ENV](env_, fld, t);\n-            let @ast::expr e_ = fold_expr(env_, fld, e);\n-            ret fld.fold_item_const(env_, i.span, ident, t_, e_, id, ann);\n-        }\n-\n-        case (ast::item_fn(?ident, ?ff, ?tps, ?id, ?ann)) {\n-            let ast::_fn ff_ = fold_fn[ENV](env_, fld, ff);\n-            ret fld.fold_item_fn(env_, i.span, ident, ff_, tps, id, ann);\n-        }\n-\n-        case (ast::item_mod(?ident, ?mm, ?id)) {\n-            let ast::_mod mm_ = fold_mod[ENV](env_, fld, mm);\n-            ret fld.fold_item_mod(env_, i.span, ident, mm_, id);\n-        }\n-\n-        case (ast::item_native_mod(?ident, ?mm, ?id)) {\n-            let ast::native_mod mm_ = fold_native_mod[ENV](env_, fld, mm);\n-            ret fld.fold_item_native_mod(env_, i.span, ident, mm_, id);\n-        }\n-\n-        case (ast::item_ty(?ident, ?ty, ?params, ?id, ?ann)) {\n-            let @ast::ty ty_ = fold_ty[ENV](env_, fld, ty);\n-            ret fld.fold_item_ty(env_, i.span, ident, ty_, params, id, ann);\n-        }\n-\n-        case (ast::item_tag(?ident, ?variants, ?ty_params, ?id, ?ann)) {\n-            let vec[ast::variant] new_variants = [];\n-            for (ast::variant v in variants) {\n-                let vec[ast::variant_arg] new_args = [];\n-                for (ast::variant_arg va in v.node.args) {\n-                    auto new_ty = fold_ty[ENV](env_, fld, va.ty);\n-                    new_args += [rec(ty=new_ty, id=va.id)];\n-                }\n-                auto new_v = rec(name=v.node.name, args=new_args,\n-                                 id=v.node.id, ann=v.node.ann);\n-                new_variants += [respan[ast::variant_](v.span, new_v)];\n-            }\n-            ret fld.fold_item_tag(env_, i.span, ident, new_variants,\n-                                  ty_params, id, ann);\n-        }\n-\n-        case (ast::item_obj(?ident, ?ob, ?tps, ?odid, ?ann)) {\n-            let ast::_obj ob_ = fold_obj[ENV](env_, fld, ob);\n-            ret fld.fold_item_obj(env_, i.span, ident, ob_, tps, odid, ann);\n-        }\n-\n-    }\n-\n-    fail;\n-}\n-\n-fn fold_mod[ENV](&ENV e, &ast_fold[ENV] fld, &ast::_mod m) -> ast::_mod {\n-\n-    let vec[@view_item] view_items = [];\n-    let vec[@item] items = [];\n-\n-    for (@view_item vi in m.view_items) {\n-        auto new_vi = fold_view_item[ENV](e, fld, vi);\n-        vec::push[@view_item](view_items, new_vi);\n-    }\n-\n-    for (@item i in m.items) {\n-        auto new_item = fold_item[ENV](e, fld, i);\n-        vec::push[@item](items, new_item);\n-    }\n-\n-    ret fld.fold_mod(e, rec(view_items=view_items, items=items));\n-}\n-\n-fn fold_native_item[ENV](&ENV env, &ast_fold[ENV] fld,\n-                         &@native_item i) -> @native_item {\n-    let ENV env_ = fld.update_env_for_native_item(env, i);\n-\n-    if (!fld.keep_going(env_)) {\n-        ret i;\n-    }\n-    alt (i.node) {\n-        case (ast::native_item_ty(?ident, ?id)) {\n-            ret fld.fold_native_item_ty(env_, i.span, ident, id);\n-        }\n-        case (ast::native_item_fn(?ident, ?lname, ?fn_decl,\n-                                 ?ty_params, ?id, ?ann)) {\n-            auto d = fold_fn_decl[ENV](env_, fld, fn_decl);\n-            ret fld.fold_native_item_fn(env_, i.span, ident, lname, d,\n-                                        ty_params, id, ann);\n-        }\n-    }\n-}\n-\n-fn fold_native_mod[ENV](&ENV e, &ast_fold[ENV] fld,\n-                        &ast::native_mod m) -> ast::native_mod {\n-    let vec[@view_item] view_items = [];\n-    let vec[@native_item] items = [];\n-\n-    for (@view_item vi in m.view_items) {\n-        auto new_vi = fold_view_item[ENV](e, fld, vi);\n-        vec::push[@view_item](view_items, new_vi);\n-    }\n-\n-    for (@native_item i in m.items) {\n-        auto new_item = fold_native_item[ENV](e, fld, i);\n-        vec::push[@native_item](items, new_item);\n-    }\n-\n-    ret fld.fold_native_mod(e, rec(native_name=m.native_name,\n-                                   abi=m.abi,\n-                                   view_items=view_items,\n-                                   items=items));\n-}\n-\n-fn fold_crate[ENV](&ENV env, &ast_fold[ENV] fld,\n-                   &@ast::crate c) -> @ast::crate {\n-    // FIXME: possibly fold the directives so you process any expressions\n-    // within them? Not clear. After front/eval::rs, nothing else should look\n-    // at crate directives.\n-    let ENV env_ = fld.update_env_for_crate(env, c);\n-    let ast::_mod m = fold_mod[ENV](env_, fld, c.node.module);\n-    ret fld.fold_crate(env_, c.span, c.node.directives, m);\n-}\n-\n-//// Identity folds.\n-\n-fn respan[T](&span sp, &T t) -> spanned[T] {\n-    ret rec(node=t, span=sp);\n-}\n-\n-\n-// Path identity.\n-\n-fn identity_fold_path[ENV](&ENV env, &span sp, &ast::path_ p) -> path {\n-    ret respan(sp, p);\n-}\n-\n-// Type identities.\n-\n-fn identity_fold_ty_nil[ENV](&ENV env, &span sp) -> @ty {\n-    ret @respan(sp, ast::ty_nil);\n-}\n-\n-fn identity_fold_ty_bot[ENV](&ENV env, &span sp) -> @ty {\n-    ret @respan(sp, ast::ty_bot);\n-}\n-\n-fn identity_fold_ty_bool[ENV](&ENV env, &span sp) -> @ty {\n-    ret @respan(sp, ast::ty_bool);\n-}\n-\n-fn identity_fold_ty_int[ENV](&ENV env, &span sp) -> @ty {\n-    ret @respan(sp, ast::ty_int);\n-}\n-\n-fn identity_fold_ty_uint[ENV](&ENV env, &span sp) -> @ty {\n-    ret @respan(sp, ast::ty_uint);\n-}\n-\n-fn identity_fold_ty_float[ENV](&ENV env, &span sp) -> @ty {\n-    ret @respan(sp, ast::ty_float);\n-}\n-\n-fn identity_fold_ty_machine[ENV](&ENV env, &span sp,\n-                                 ty_mach tm) -> @ty {\n-    ret @respan(sp, ast::ty_machine(tm));\n-}\n-\n-fn identity_fold_ty_char[ENV](&ENV env, &span sp) -> @ty {\n-    ret @respan(sp, ast::ty_char);\n-}\n-\n-fn identity_fold_ty_str[ENV](&ENV env, &span sp) -> @ty {\n-    ret @respan(sp, ast::ty_str);\n-}\n-\n-fn identity_fold_ty_box[ENV](&ENV env, &span sp, &mt tm) -> @ty {\n-    ret @respan(sp, ast::ty_box(tm));\n-}\n-\n-fn identity_fold_ty_vec[ENV](&ENV env, &span sp, &mt tm) -> @ty {\n-    ret @respan(sp, ast::ty_vec(tm));\n-}\n-\n-fn identity_fold_ty_tup[ENV](&ENV env, &span sp,\n-                             &vec[mt] elts) -> @ty {\n-    ret @respan(sp, ast::ty_tup(elts));\n-}\n-\n-fn identity_fold_ty_rec[ENV](&ENV env, &span sp,\n-                             &vec[ast::ty_field] elts) -> @ty {\n-    ret @respan(sp, ast::ty_rec(elts));\n-}\n-\n-fn identity_fold_ty_obj[ENV](&ENV env, &span sp,\n-                             &vec[ast::ty_method] meths) -> @ty {\n-    ret @respan(sp, ast::ty_obj(meths));\n-}\n-\n-fn identity_fold_ty_fn[ENV](&ENV env, &span sp,\n-                            ast::proto proto,\n-                            &vec[rec(ast::mode mode, @ty ty)] inputs,\n-                            &@ty output, &controlflow cf) -> @ty {\n-    ret @respan(sp, ast::ty_fn(proto, inputs, output, cf));\n-}\n-\n-fn identity_fold_ty_path[ENV](&ENV env, &span sp, &ast::path p,\n-                              &ann a) -> @ty {\n-    ret @respan(sp, ast::ty_path(p, a));\n-}\n-\n-fn identity_fold_ty_chan[ENV](&ENV env, &span sp, &@ty t) -> @ty {\n-    ret @respan(sp, ast::ty_chan(t));\n-}\n-\n-fn identity_fold_ty_port[ENV](&ENV env, &span sp, &@ty t) -> @ty {\n-    ret @respan(sp, ast::ty_port(t));\n-}\n-\n-// Expr identities.\n-\n-fn identity_fold_expr_vec[ENV](&ENV env, &span sp, &vec[@expr] es,\n-                               ast::mutability mut, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_vec(es, mut, a));\n-}\n-\n-fn identity_fold_expr_tup[ENV](&ENV env, &span sp,\n-                               &vec[ast::elt] es, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_tup(es, a));\n-}\n-\n-fn identity_fold_expr_rec[ENV](&ENV env, &span sp,\n-                               &vec[ast::field] fields,\n-                               &option::t[@expr] base, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_rec(fields, base, a));\n-}\n-\n-fn identity_fold_expr_call[ENV](&ENV env, &span sp, &@expr f,\n-                                &vec[@expr] args, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_call(f, args, a));\n-}\n-\n-fn identity_fold_expr_self_method[ENV](&ENV env, &span sp, &ident id,\n-                                       &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_self_method(id, a));\n-}\n-\n-fn identity_fold_expr_bind[ENV](&ENV env, &span sp, &@expr f,\n-                                &vec[option::t[@expr]] args_opt, &ann a)\n-        -> @expr {\n-    ret @respan(sp, ast::expr_bind(f, args_opt, a));\n-}\n-\n-fn identity_fold_expr_spawn[ENV](&ENV env, &span sp,\n-                                 ast::spawn_dom dom, &option::t[str] name,\n-                                 &@expr f, &vec[@expr] args,\n-                                 &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_spawn(dom, name, f, args, a));\n-}\n-\n-fn identity_fold_expr_binary[ENV](&ENV env, &span sp, ast::binop b,\n-                                  &@expr lhs, &@expr rhs,\n-                                  &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_binary(b, lhs, rhs, a));\n-}\n-\n-fn identity_fold_expr_unary[ENV](&ENV env, &span sp,\n-                                 ast::unop u, &@expr e, &ann a)\n-        -> @expr {\n-    ret @respan(sp, ast::expr_unary(u, e, a));\n-}\n-\n-fn identity_fold_expr_lit[ENV](&ENV env, &span sp, &@ast::lit lit,\n-                               &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_lit(lit, a));\n-}\n-\n-fn identity_fold_expr_cast[ENV](&ENV env, &span sp, &@ast::expr e,\n-                                &@ast::ty t, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_cast(e, t, a));\n-}\n-\n-fn identity_fold_expr_if[ENV](&ENV env, &span sp,\n-                              &@expr cond, &block thn,\n-                              &option::t[@expr] els, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_if(cond, thn, els, a));\n-}\n-\n-fn identity_fold_expr_for[ENV](&ENV env, &span sp,\n-                               &@decl d, &@expr seq,\n-                               &block body, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_for(d, seq, body, a));\n-}\n-\n-fn identity_fold_expr_for_each[ENV](&ENV env, &span sp,\n-                                    &@decl d, &@expr seq,\n-                                    &block body, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_for_each(d, seq, body, a));\n-}\n-\n-fn identity_fold_expr_while[ENV](&ENV env, &span sp,\n-                                 &@expr cond, &block body, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_while(cond, body, a));\n-}\n-\n-fn identity_fold_expr_do_while[ENV](&ENV env, &span sp,\n-                                    &block body, &@expr cond,\n-                                    &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_do_while(body, cond, a));\n-}\n-\n-fn identity_fold_expr_alt[ENV](&ENV env, &span sp,\n-                               &@expr e, &vec[arm] arms,\n-                               &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_alt(e, arms, a));\n-}\n-\n-fn identity_fold_expr_block[ENV](&ENV env, &span sp, &block blk,\n-                                 &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_block(blk, a));\n-}\n-\n-fn identity_fold_expr_assign[ENV](&ENV env, &span sp,\n-                                  &@expr lhs, &@expr rhs, &ann a)\n-        -> @expr {\n-    ret @respan(sp, ast::expr_assign(lhs, rhs, a));\n-}\n-\n-fn identity_fold_expr_assign_op[ENV](&ENV env, &span sp, ast::binop op,\n-                                     &@expr lhs, &@expr rhs, &ann a)\n-        -> @expr {\n-    ret @respan(sp, ast::expr_assign_op(op, lhs, rhs, a));\n-}\n-\n-fn identity_fold_expr_send[ENV](&ENV e, &span sp,\n-                                &@expr lhs, &@expr rhs, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_send(lhs, rhs, a));\n-}\n-\n-fn identity_fold_expr_recv[ENV](&ENV e, &span sp,\n-                                &@expr lhs, &@expr rhs, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_recv(lhs, rhs, a));\n-}\n-\n-fn identity_fold_expr_field[ENV](&ENV env, &span sp,\n-                                 &@expr e, &ident i, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_field(e, i, a));\n-}\n-\n-fn identity_fold_expr_index[ENV](&ENV env, &span sp,\n-                                 &@expr e, &@expr ix, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_index(e, ix, a));\n-}\n-\n-fn identity_fold_expr_path[ENV](&ENV env, &span sp,\n-                                &path p, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_path(p, a));\n-}\n-\n-fn identity_fold_expr_ext[ENV](&ENV env, &span sp,\n-                               &path p, &vec[@expr] args,\n-                               &option::t[str] body,\n-                               &@expr expanded,\n-                               &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_ext(p, args, body, expanded, a));\n-}\n-\n-fn identity_fold_expr_fail[ENV](&ENV env, &span sp, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_fail(a));\n-}\n-\n-fn identity_fold_expr_break[ENV](&ENV env, &span sp, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_break(a));\n-}\n-\n-fn identity_fold_expr_cont[ENV](&ENV env, &span sp, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_cont(a));\n-}\n-\n-fn identity_fold_expr_ret[ENV](&ENV env, &span sp,\n-                               &option::t[@expr] rv, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_ret(rv, a));\n-}\n-\n-fn identity_fold_expr_put[ENV](&ENV env, &span sp,\n-                               &option::t[@expr] rv, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_put(rv, a));\n-}\n-\n-fn identity_fold_expr_be[ENV](&ENV env, &span sp,\n-                              &@expr x, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_be(x, a));\n-}\n-\n-fn identity_fold_expr_log[ENV](&ENV e, &span sp, int lvl, &@expr x,\n-                               &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_log(lvl, x, a));\n-}\n-\n-fn identity_fold_expr_check[ENV](&ENV e, &span sp, &@expr x, &ann a)\n-    -> @expr {\n-    ret @respan(sp, ast::expr_check(x, a));\n-}\n-\n-fn identity_fold_expr_assert[ENV](&ENV e, &span sp, &@expr x, &ann a)\n-    -> @expr {\n-    ret @respan(sp, ast::expr_assert(x, a));\n-}\n-\n-fn identity_fold_expr_port[ENV](&ENV e, &span sp, &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_port(a));\n-}\n-\n-fn identity_fold_expr_chan[ENV](&ENV e, &span sp, &@expr x,\n-                                &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_chan(x, a));\n-}\n-\n-fn identity_fold_expr_anon_obj[ENV](&ENV e, &span sp,\n-                                    &ast::anon_obj ob, \n-                                    &vec[ast::ty_param] tps,\n-                                    &ast::obj_def_ids odid, \n-                                    &ann a) -> @expr {\n-    ret @respan(sp, ast::expr_anon_obj(ob, tps, odid, a));\n-}\n-\n-// Decl identities.\n-\n-fn identity_fold_decl_local[ENV](&ENV e, &span sp,\n-                                 &@ast::local local) -> @decl {\n-    ret @respan(sp, ast::decl_local(local));\n-}\n-\n-fn identity_fold_decl_item[ENV](&ENV e, &span sp, &@item i) -> @decl {\n-    ret @respan(sp, ast::decl_item(i));\n-}\n-\n-\n-// Pat identities.\n-\n-fn identity_fold_pat_wild[ENV](&ENV e, &span sp, &ann a) -> @pat {\n-    ret @respan(sp, ast::pat_wild(a));\n-}\n-\n-fn identity_fold_pat_lit[ENV](&ENV e, &span sp,\n-                              &@ast::lit lit, &ann a) -> @pat {\n-    ret @respan(sp, ast::pat_lit(lit, a));\n-}\n-\n-fn identity_fold_pat_bind[ENV](&ENV e, &span sp, &ident i,\n-                               &def_id did, &ann a)\n-        -> @pat {\n-    ret @respan(sp, ast::pat_bind(i, did, a));\n-}\n-\n-fn identity_fold_pat_tag[ENV](&ENV e, &span sp, &path p, &vec[@pat] args,\n-                              &ann a) -> @pat {\n-    ret @respan(sp, ast::pat_tag(p, args, a));\n-}\n-\n-\n-// Stmt identities.\n-\n-fn identity_fold_stmt_decl[ENV](&ENV env, &span sp,\n-                                &@decl d, &ann a) -> @stmt {\n-    ret @respan(sp, ast::stmt_decl(d, a));\n-}\n-\n-fn identity_fold_stmt_expr[ENV](&ENV e, &span sp,\n-                                &@expr x, &ann a) -> @stmt {\n-    ret @respan(sp, ast::stmt_expr(x, a));\n-}\n-\n-\n-// Item identities.\n-\n-fn identity_fold_item_const[ENV](&ENV e, &span sp, &ident i,\n-                                  &@ty t, &@expr ex,\n-                                 &def_id id, &ann a) -> @item {\n-    ret @respan(sp, ast::item_const(i, t, ex, id, a));\n-}\n-\n-fn identity_fold_item_fn[ENV](&ENV e, &span sp, &ident i,\n-                              &ast::_fn f, &vec[ast::ty_param] ty_params,\n-                              &def_id id, &ann a) -> @item {\n-    ret @respan(sp, ast::item_fn(i, f, ty_params, id, a));\n-}\n-\n-fn identity_fold_native_item_fn[ENV](&ENV e, &span sp, &ident i,\n-                                     &option::t[str] link_name,\n-                                     &ast::fn_decl decl,\n-                                     &vec[ast::ty_param] ty_params,\n-                                     &def_id id, &ann a) -> @native_item {\n-    ret @respan(sp, ast::native_item_fn(i, link_name, decl, ty_params,\n-                                        id, a));\n-}\n-\n-fn identity_fold_item_mod[ENV](&ENV e, &span sp, &ident i,\n-                               &ast::_mod m, &def_id id) -> @item {\n-    ret @respan(sp, ast::item_mod(i, m, id));\n-}\n-\n-fn identity_fold_item_native_mod[ENV](&ENV e, &span sp, &ident i,\n-                                      &ast::native_mod m,\n-                                      &def_id id) -> @item {\n-    ret @respan(sp, ast::item_native_mod(i, m, id));\n-}\n-\n-fn identity_fold_item_ty[ENV](&ENV e, &span sp, &ident i,\n-                              &@ty t, &vec[ast::ty_param] ty_params,\n-                              &def_id id, &ann a) -> @item {\n-    ret @respan(sp, ast::item_ty(i, t, ty_params, id, a));\n-}\n-\n-fn identity_fold_native_item_ty[ENV](&ENV e, &span sp, &ident i,\n-                                     &def_id id) -> @native_item {\n-    ret @respan(sp, ast::native_item_ty(i, id));\n-}\n-\n-fn identity_fold_item_tag[ENV](&ENV e, &span sp, &ident i,\n-                               &vec[ast::variant] variants,\n-                               &vec[ast::ty_param] ty_params,\n-                               &def_id id, &ann a) -> @item {\n-    ret @respan(sp, ast::item_tag(i, variants, ty_params, id, a));\n-}\n-\n-fn identity_fold_item_obj[ENV](&ENV e, &span sp, &ident i,\n-                               &ast::_obj ob, &vec[ast::ty_param] ty_params,\n-                               &ast::obj_def_ids odid, &ann a) -> @item {\n-    ret @respan(sp, ast::item_obj(i, ob, ty_params, odid, a));\n-}\n-\n-// View Item folds.\n-\n-fn identity_fold_view_item_use[ENV](&ENV e, &span sp, &ident i,\n-                                    &vec[@meta_item] meta_items,\n-                                    &def_id id, &option::t[int] cnum)\n-    -> @view_item {\n-    ret @respan(sp, ast::view_item_use(i, meta_items, id, cnum));\n-}\n-\n-fn identity_fold_view_item_import[ENV](&ENV e, &span sp, &ident i,\n-                                       &vec[ident] is, &def_id id)\n-    -> @view_item {\n-    ret @respan(sp, ast::view_item_import(i, is, id));\n-}\n-\n-fn identity_fold_view_item_export[ENV](&ENV e, &span sp, &ident i)\n-    -> @view_item {\n-    ret @respan(sp, ast::view_item_export(i));\n-}\n-\n-// Annotation folding.\n-\n-fn identity_fold_ann[ENV](&ENV e, &ann a) -> ann {\n-    ret a;\n-}\n-\n-// Additional identities.\n-\n-fn identity_fold_block[ENV](&ENV e, &span sp, &ast::block_ blk) -> block {\n-    ret respan(sp, blk);\n-}\n-\n-fn identity_fold_fn_decl[ENV](&ENV e,\n-                              &vec[arg] inputs,\n-                              &@ty output,\n-                              &purity p, &controlflow c) -> ast::fn_decl {\n-    ret rec(inputs=inputs, output=output, purity=p, cf=c);\n-}\n-\n-fn identity_fold_fn[ENV](&ENV e,\n-                         &fn_decl decl,\n-                         ast::proto proto,\n-                         &block body) -> ast::_fn {\n-    ret rec(decl=decl, proto=proto, body=body);\n-}\n-\n-fn identity_fold_mod[ENV](&ENV e, &ast::_mod m) -> ast::_mod {\n-    ret m;\n-}\n-\n-fn identity_fold_native_mod[ENV](&ENV e,\n-                                 &ast::native_mod m) -> ast::native_mod {\n-    ret m;\n-}\n-\n-fn identity_fold_crate[ENV](&ENV e, &span sp,\n-                            &vec[@ast::crate_directive] cdirs,\n-                            &ast::_mod m) -> @ast::crate {\n-    ret @respan(sp, rec(directives=cdirs, module=m));\n-}\n-\n-fn identity_fold_obj[ENV](&ENV e,\n-                          &vec[ast::obj_field] fields,\n-                          &vec[@ast::method] methods,\n-                          &option::t[@ast::method] dtor) -> ast::_obj {\n-    ret rec(fields=fields, methods=methods, dtor=dtor);\n-}\n-\n-fn identity_fold_anon_obj[ENV](&ENV e,\n-                               &option::t[vec[ast::obj_field]] fields,\n-                               &vec[@ast::method] methods,\n-                               &option::t[@ast::expr] with_obj) \n-    -> ast::anon_obj {\n-    ret rec(fields=fields, methods=methods, with_obj=with_obj);\n-}\n-\n-// Env update identities.\n-\n-fn identity_update_env_for_crate[ENV](&ENV e, &@ast::crate c) -> ENV {\n-    ret e;\n-}\n-\n-fn identity_update_env_for_item[ENV](&ENV e, &@item i) -> ENV {\n-    ret e;\n-}\n-\n-fn identity_update_env_for_native_item[ENV](&ENV e, &@native_item i) -> ENV {\n-    ret e;\n-}\n-\n-fn identity_update_env_for_view_item[ENV](&ENV e, &@view_item i) -> ENV {\n-    ret e;\n-}\n-\n-fn identity_update_env_for_block[ENV](&ENV e, &block b) -> ENV {\n-    ret e;\n-}\n-\n-fn identity_update_env_for_stmt[ENV](&ENV e, &@stmt s) -> ENV {\n-    ret e;\n-}\n-\n-fn identity_update_env_for_decl[ENV](&ENV e, &@decl d) -> ENV {\n-    ret e;\n-}\n-\n-fn identity_update_env_for_arm[ENV](&ENV e, &arm a) -> ENV {\n-    ret e;\n-}\n-\n-fn identity_update_env_for_pat[ENV](&ENV e, &@pat p) -> ENV {\n-    ret e;\n-}\n-\n-fn identity_update_env_for_expr[ENV](&ENV e, &@expr x) -> ENV {\n-    ret e;\n-}\n-\n-fn identity_update_env_for_ty[ENV](&ENV e, &@ty t) -> ENV {\n-    ret e;\n-}\n-\n-\n-// Always-true traversal control fn.\n-\n-fn always_keep_going[ENV](&ENV e) -> bool {\n-    ret true;\n-}\n-\n-\n-fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n-    ret @rec\n-        (\n-         fold_path       = bind identity_fold_path[ENV](_,_,_),\n-\n-         fold_ty_nil     = bind identity_fold_ty_nil[ENV](_,_),\n-         fold_ty_bot     = bind identity_fold_ty_bot[ENV](_,_),\n-         fold_ty_bool    = bind identity_fold_ty_bool[ENV](_,_),\n-         fold_ty_int     = bind identity_fold_ty_int[ENV](_,_),\n-         fold_ty_uint    = bind identity_fold_ty_uint[ENV](_,_),\n-         fold_ty_float   = bind identity_fold_ty_float[ENV](_,_),\n-         fold_ty_machine = bind identity_fold_ty_machine[ENV](_,_,_),\n-         fold_ty_char    = bind identity_fold_ty_char[ENV](_,_),\n-         fold_ty_str     = bind identity_fold_ty_str[ENV](_,_),\n-         fold_ty_box     = bind identity_fold_ty_box[ENV](_,_,_),\n-         fold_ty_vec     = bind identity_fold_ty_vec[ENV](_,_,_),\n-         fold_ty_tup     = bind identity_fold_ty_tup[ENV](_,_,_),\n-         fold_ty_rec     = bind identity_fold_ty_rec[ENV](_,_,_),\n-         fold_ty_obj     = bind identity_fold_ty_obj[ENV](_,_,_),\n-         fold_ty_fn      = bind identity_fold_ty_fn[ENV](_,_,_,_,_,_),\n-         fold_ty_path    = bind identity_fold_ty_path[ENV](_,_,_,_),\n-         fold_ty_chan    = bind identity_fold_ty_chan[ENV](_,_,_),\n-         fold_ty_port    = bind identity_fold_ty_port[ENV](_,_,_),\n-\n-         fold_expr_vec    = bind identity_fold_expr_vec[ENV](_,_,_,_,_),\n-         fold_expr_tup    = bind identity_fold_expr_tup[ENV](_,_,_,_),\n-         fold_expr_rec    = bind identity_fold_expr_rec[ENV](_,_,_,_,_),\n-         fold_expr_call   = bind identity_fold_expr_call[ENV](_,_,_,_,_),\n-         fold_expr_self_method\n-                          = bind identity_fold_expr_self_method[ENV](_,_,_,_),\n-         fold_expr_bind   = bind identity_fold_expr_bind[ENV](_,_,_,_,_),\n-         fold_expr_spawn  = bind identity_fold_expr_spawn[ENV](_,_,_,_,_,_,_),\n-         fold_expr_binary = bind identity_fold_expr_binary[ENV](_,_,_,_,_,_),\n-         fold_expr_unary  = bind identity_fold_expr_unary[ENV](_,_,_,_,_),\n-         fold_expr_lit    = bind identity_fold_expr_lit[ENV](_,_,_,_),\n-         fold_expr_cast   = bind identity_fold_expr_cast[ENV](_,_,_,_,_),\n-         fold_expr_if     = bind identity_fold_expr_if[ENV](_,_,_,_,_,_),\n-         fold_expr_for    = bind identity_fold_expr_for[ENV](_,_,_,_,_,_),\n-         fold_expr_for_each\n-             = bind identity_fold_expr_for_each[ENV](_,_,_,_,_,_),\n-         fold_expr_while  = bind identity_fold_expr_while[ENV](_,_,_,_,_),\n-         fold_expr_do_while\n-                          = bind identity_fold_expr_do_while[ENV](_,_,_,_,_),\n-         fold_expr_alt    = bind identity_fold_expr_alt[ENV](_,_,_,_,_),\n-         fold_expr_block  = bind identity_fold_expr_block[ENV](_,_,_,_),\n-         fold_expr_assign = bind identity_fold_expr_assign[ENV](_,_,_,_,_),\n-         fold_expr_assign_op\n-                       = bind identity_fold_expr_assign_op[ENV](_,_,_,_,_,_),\n-         fold_expr_send   = bind identity_fold_expr_send[ENV](_,_,_,_,_),\n-         fold_expr_recv   = bind identity_fold_expr_recv[ENV](_,_,_,_,_),\n-         fold_expr_field  = bind identity_fold_expr_field[ENV](_,_,_,_,_),\n-         fold_expr_index  = bind identity_fold_expr_index[ENV](_,_,_,_,_),\n-         fold_expr_path   = bind identity_fold_expr_path[ENV](_,_,_,_),\n-         fold_expr_ext    = bind identity_fold_expr_ext[ENV](_,_,_,_,_,_,_),\n-         fold_expr_fail   = bind identity_fold_expr_fail[ENV](_,_,_),\n-         fold_expr_break  = bind identity_fold_expr_break[ENV](_,_,_),\n-         fold_expr_cont   = bind identity_fold_expr_cont[ENV](_,_,_),\n-         fold_expr_ret    = bind identity_fold_expr_ret[ENV](_,_,_,_),\n-         fold_expr_put    = bind identity_fold_expr_put[ENV](_,_,_,_),\n-         fold_expr_be     = bind identity_fold_expr_be[ENV](_,_,_,_),\n-         fold_expr_log    = bind identity_fold_expr_log[ENV](_,_,_,_,_),\n-         fold_expr_check\n-         = bind identity_fold_expr_check[ENV](_,_,_,_),\n-         fold_expr_assert\n-         = bind identity_fold_expr_assert[ENV](_,_,_,_),\n-\n-         fold_expr_port   = bind identity_fold_expr_port[ENV](_,_,_),\n-         fold_expr_chan   = bind identity_fold_expr_chan[ENV](_,_,_,_),\n-\n-         fold_expr_anon_obj   \n-                        = bind identity_fold_expr_anon_obj[ENV](_,_,_,_,_,_),\n-\n-         fold_decl_local  = bind identity_fold_decl_local[ENV](_,_,_),\n-         fold_decl_item   = bind identity_fold_decl_item[ENV](_,_,_),\n-\n-         fold_pat_wild    = bind identity_fold_pat_wild[ENV](_,_,_),\n-         fold_pat_lit     = bind identity_fold_pat_lit[ENV](_,_,_,_),\n-         fold_pat_bind    = bind identity_fold_pat_bind[ENV](_,_,_,_,_),\n-         fold_pat_tag     = bind identity_fold_pat_tag[ENV](_,_,_,_,_),\n-\n-         fold_stmt_decl   = bind identity_fold_stmt_decl[ENV](_,_,_,_),\n-         fold_stmt_expr   = bind identity_fold_stmt_expr[ENV](_,_,_,_),\n-\n-         fold_item_const= bind identity_fold_item_const[ENV](_,_,_,_,_,_,_),\n-         fold_item_fn   = bind identity_fold_item_fn[ENV](_,_,_,_,_,_,_),\n-         fold_native_item_fn =\n-             bind identity_fold_native_item_fn[ENV](_,_,_,_,_,_,_,_),\n-         fold_item_mod  = bind identity_fold_item_mod[ENV](_,_,_,_,_),\n-         fold_item_native_mod =\n-             bind identity_fold_item_native_mod[ENV](_,_,_,_,_),\n-         fold_item_ty   = bind identity_fold_item_ty[ENV](_,_,_,_,_,_,_),\n-         fold_native_item_ty =\n-             bind identity_fold_native_item_ty[ENV](_,_,_,_),\n-         fold_item_tag  = bind identity_fold_item_tag[ENV](_,_,_,_,_,_,_),\n-         fold_item_obj  = bind identity_fold_item_obj[ENV](_,_,_,_,_,_,_),\n-\n-         fold_view_item_use =\n-             bind identity_fold_view_item_use[ENV](_,_,_,_,_,_),\n-         fold_view_item_import =\n-             bind identity_fold_view_item_import[ENV](_,_,_,_,_),\n-         fold_view_item_export =\n-             bind identity_fold_view_item_export[ENV](_,_,_),\n-\n-         fold_ann = bind identity_fold_ann[ENV](_,_),\n-\n-         fold_fn = bind identity_fold_fn[ENV](_,_,_,_),\n-         fold_fn_decl = bind identity_fold_fn_decl[ENV](_,_,_,_,_),\n-         fold_mod = bind identity_fold_mod[ENV](_,_),\n-         fold_native_mod = bind identity_fold_native_mod[ENV](_,_),\n-         fold_crate = bind identity_fold_crate[ENV](_,_,_,_),\n-         fold_obj = bind identity_fold_obj[ENV](_,_,_,_),\n-         fold_anon_obj = bind identity_fold_anon_obj[ENV](_,_,_,_),\n-\n-         update_env_for_crate = bind identity_update_env_for_crate[ENV](_,_),\n-         update_env_for_item = bind identity_update_env_for_item[ENV](_,_),\n-         update_env_for_native_item =\n-             bind identity_update_env_for_native_item[ENV](_,_),\n-         update_env_for_view_item =\n-             bind identity_update_env_for_view_item[ENV](_,_),\n-         update_env_for_block = bind identity_update_env_for_block[ENV](_,_),\n-         update_env_for_stmt = bind identity_update_env_for_stmt[ENV](_,_),\n-         update_env_for_decl = bind identity_update_env_for_decl[ENV](_,_),\n-         update_env_for_pat = bind identity_update_env_for_pat[ENV](_,_),\n-         update_env_for_arm = bind identity_update_env_for_arm[ENV](_,_),\n-         update_env_for_expr = bind identity_update_env_for_expr[ENV](_,_),\n-         update_env_for_ty = bind identity_update_env_for_ty[ENV](_,_),\n-\n-         keep_going = bind always_keep_going[ENV](_)\n-         );\n-}\n-\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//"}, {"sha": "494e41a8f71d3c03322cc31e37a9ba85d87bd981", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=2561b01211569c376b05f4c8d1434a0e527ac950", "patch": "@@ -9,7 +9,6 @@ import std::option::some;\n import std::option::none;\n \n import front::ast;\n-import middle::fold;\n import middle::trans;\n import middle::ty;\n import back::x86;"}, {"sha": "2c5d4a377a0eb1d1fb6673aa06ead2848403c784", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=2561b01211569c376b05f4c8d1434a0e527ac950", "patch": "@@ -78,10 +78,12 @@ type indexed_mod = rec(option::t[ast::_mod] m, mod_index index);\n /* native modules can't contain tags, and we don't store their ASTs because we\n    only need to look at them to determine exports, which they can't control.*/\n \n+type crate_map = hashmap[uint,ast::crate_num];\n \n type def_map = hashmap[uint,def];\n \n-type env = rec(def_map def_map,\n+type env = rec(crate_map crate_map,\n+               def_map def_map,\n                hashmap[ast::def_num,import_state] imports,\n                hashmap[ast::def_num,@indexed_mod] mod_map,\n                hashmap[def_id,vec[ident]] ext_map,\n@@ -99,12 +101,14 @@ tag namespace {\n }\n \n fn resolve_crate(session sess, @ast::crate crate) -> def_map {\n-    auto e = @rec(def_map = new_uint_hash[def](),\n+    auto e = @rec(crate_map = new_uint_hash[ast::crate_num](),\n+                  def_map = new_uint_hash[def](),\n                   imports = new_int_hash[import_state](),\n                   mod_map = new_int_hash[@indexed_mod](),\n                   ext_map = new_def_hash[vec[ident]](),\n                   ext_cache = new_ext_hash(),\n                   sess = sess);\n+    creader::read_crates(sess, e.crate_map, *crate);\n     map_crate(e, *crate);\n     resolve_imports(*e);\n     check_for_collisions(e, *crate);\n@@ -709,8 +713,8 @@ fn lookup_in_mod(&env e, def m, &ident id, namespace ns, dir dr)\n fn found_view_item(&env e, @ast::view_item vi, namespace ns)\n     -> option::t[def] {\n     alt (vi.node) {\n-        case (ast::view_item_use(_, _, _, ?cnum)) {\n-            ret some(ast::def_mod(tup(option::get(cnum), -1)));\n+        case (ast::view_item_use(_, _, _, ?ann)) {\n+            ret some(ast::def_mod(tup(e.crate_map.get(ann.id), -1)));\n         }\n         case (ast::view_item_import(_, _, ?defid)) {\n             ret lookup_import(e, defid, ns);"}, {"sha": "6af0e299c9fb98ffeb66ecb5000541aa33036611", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=2561b01211569c376b05f4c8d1434a0e527ac950", "patch": "@@ -2,7 +2,6 @@ import front::ast;\n import front::ast::ann;\n import front::ast::mutability;\n import front::creader;\n-import middle::fold;\n import driver::session;\n import util::common;\n import util::common::span;\n@@ -688,7 +687,7 @@ mod collect {\n                 with variant.node\n             );\n             write::ty_only(cx.tcx, variant.node.ann.id, result_ty);\n-            result += [fold::respan(variant.span, variant_t)];\n+            result += [common::respan(variant.span, variant_t)];\n         }\n \n         ret result;\n@@ -1632,7 +1631,6 @@ mod writeback {\n         }\n         fn keep_going(@mutable bool ignore) -> bool { ret !*ignore; }\n \n-        auto fld = fold::new_identity_fold[option::t[@fn_ctxt]]();\n         auto visit = rec(keep_going=bind keep_going(ignore),\n                          visit_item_pre=bind visit_item_pre(ignore, _),\n                          visit_item_post=bind visit_item_post(ignore, _),"}, {"sha": "7fe5d603585e6ecfd41887fe1d40fdd0fffd5adc", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=2561b01211569c376b05f4c8d1434a0e527ac950", "patch": "@@ -12,7 +12,6 @@ use std;\n mod middle {\n     mod trans;\n     mod ty;\n-    mod fold;\n     mod walk;\n     mod metadata;\n     mod resolve;"}, {"sha": "fea905ebdb749cfc3c464929d0cd9bad2179dd8c", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2561b01211569c376b05f4c8d1434a0e527ac950/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=2561b01211569c376b05f4c8d1434a0e527ac950", "patch": "@@ -8,11 +8,9 @@ import std::option::some;\n import front::ast;\n import front::ast::ty;\n import front::ast::pat;\n+import middle::walk;\n import middle::tstate::ann::ts_ann;\n \n-import middle::fold;\n-import middle::fold::respan;\n-\n import std::io::stdout;\n import std::io::str_writer;\n import std::io::string_writer;\n@@ -277,35 +275,25 @@ fn decl_lhs(@ast::decl d) -> ast::def_id {\n                     ret d.ctor; /* This doesn't really make sense */\n                 }\n             }\n-        } \n+        }\n     }\n }\n \n fn has_nonlocal_exits(&ast::block b) -> bool {\n-    /* overkill, but just passing around a mutable bool doesn't seem\n-       to work in rustboot */\n-    auto has_exits = new_str_hash[()]();\n+   auto has_exits = @mutable false;\n \n-   fn set_break(&flag f, &span sp, &ast::ann a) -> @ast::expr {\n-        f.insert(\"foo\", ());\n-        ret @respan(sp, ast::expr_break(a));\n-    }\n-    fn set_cont(&flag f, &span sp, &ast::ann a) -> @ast::expr {\n-        f.insert(\"foo\", ());\n-        ret @respan(sp, ast::expr_cont(a));\n-    }\n-    fn check_b(&flag f) -> bool {\n-        ret (f.size() == 0u);\n-    }\n+   fn visit_expr(@mutable bool flag, &@ast::expr e) {\n+       alt (e.node) {\n+           case (ast::expr_break(_)) { *flag = true; }\n+           case (ast::expr_cont(_)) { *flag = true; }\n+           case (_) { }\n+       }\n+   }\n \n-    auto fld0 = fold::new_identity_fold[flag]();\n-\n-    fld0 = @rec(fold_expr_break = bind set_break(_,_,_),\n-                fold_expr_cont  = bind set_cont(_,_,_),\n-                keep_going      = bind check_b(_) with *fld0);\n-    fold::fold_block[flag](has_exits, fld0, b);\n-\n-    ret (has_exits.size() > 0u);\n+    auto v = rec(visit_expr_pre=bind visit_expr(has_exits, _)\n+                 with walk::default_visitor());\n+    walk::walk_block(v, b);\n+    ret *has_exits;\n }\n \n fn local_rhs_span(&@ast::local l, &ast::span def) -> ast::span {\n@@ -315,6 +303,10 @@ fn local_rhs_span(&@ast::local l, &ast::span def) -> ast::span {\n     }\n }\n \n+fn respan[T](&span sp, &T t) -> spanned[T] {\n+    ret rec(node=t, span=sp);\n+}\n+\n //\n // Local Variables:\n // mode: rust"}]}