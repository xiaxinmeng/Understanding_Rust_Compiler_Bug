{"sha": "4a8467b62d572eabedf50c09b52f177e87160e96", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhODQ2N2I2MmQ1NzJlYWJlZGY1MGMwOWI1MmYxNzdlODcxNjBlOTY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-26T04:16:55Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-26T04:16:55Z"}, "message": "Remove `TokResult`.", "tree": {"sha": "7980da4edff788468464e08d7b0c4fe7144346c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7980da4edff788468464e08d7b0c4fe7144346c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a8467b62d572eabedf50c09b52f177e87160e96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a8467b62d572eabedf50c09b52f177e87160e96", "html_url": "https://github.com/rust-lang/rust/commit/4a8467b62d572eabedf50c09b52f177e87160e96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a8467b62d572eabedf50c09b52f177e87160e96/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b40eaddf12bb58794a5b2448089951e7dd5b9c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b40eaddf12bb58794a5b2448089951e7dd5b9c0", "html_url": "https://github.com/rust-lang/rust/commit/8b40eaddf12bb58794a5b2448089951e7dd5b9c0"}], "stats": {"total": 190, "additions": 29, "deletions": 161}, "files": [{"sha": "495ad176542c10f73c905fc9500d8d54ee3c5a02", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 142, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/4a8467b62d572eabedf50c09b52f177e87160e96/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8467b62d572eabedf50c09b52f177e87160e96/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4a8467b62d572eabedf50c09b52f177e87160e96", "patch": "@@ -18,8 +18,7 @@ use errors::DiagnosticBuilder;\n use ext::expand::{self, Invocation, Expansion};\n use ext::hygiene::Mark;\n use fold::{self, Folder};\n-use parse;\n-use parse::parser::{self, Parser};\n+use parse::{self, parser};\n use parse::token;\n use parse::token::{InternedString, str_to_ident};\n use ptr::P;\n@@ -188,146 +187,6 @@ impl<F> AttrProcMacro for F\n     }\n }\n \n-pub struct TokResult<'a> {\n-    pub parser: Parser<'a>,\n-    pub span: Span,\n-}\n-\n-impl<'a> TokResult<'a> {\n-    // There is quite a lot of overlap here with ParserAnyMacro in ext/tt/macro_rules.rs\n-    // We could probably share more code.\n-    // FIXME(#36641) Unify TokResult and ParserAnyMacro.\n-    fn ensure_complete_parse(&mut self, allow_semi: bool) {\n-        let macro_span = &self.span;\n-        self.parser.ensure_complete_parse(allow_semi, |parser| {\n-            let token_str = parser.this_token_to_string();\n-            let msg = format!(\"macro expansion ignores token `{}` and any following\", token_str);\n-            let span = parser.span;\n-            parser.diagnostic()\n-                  .struct_span_err(span, &msg)\n-                  .span_note(*macro_span, \"caused by the macro expansion here\")\n-                  .emit();\n-        });\n-    }\n-}\n-\n-impl<'a> MacResult for TokResult<'a> {\n-    fn make_items(mut self: Box<Self>) -> Option<SmallVector<P<ast::Item>>> {\n-        if self.parser.sess.span_diagnostic.has_errors() {\n-            return Some(SmallVector::zero());\n-        }\n-\n-        let mut items = SmallVector::zero();\n-        loop {\n-            match self.parser.parse_item() {\n-                Ok(Some(item)) => items.push(item),\n-                Ok(None) => {\n-                    self.ensure_complete_parse(false);\n-                    return Some(items);\n-                }\n-                Err(mut e) => {\n-                    e.emit();\n-                    return Some(SmallVector::zero());\n-                }\n-            }\n-        }\n-    }\n-\n-    fn make_impl_items(mut self: Box<Self>) -> Option<SmallVector<ast::ImplItem>> {\n-        let mut items = SmallVector::zero();\n-        loop {\n-            if self.parser.token == token::Eof {\n-                break;\n-            }\n-            match self.parser.parse_impl_item() {\n-                Ok(item) => items.push(item),\n-                Err(mut e) => {\n-                    e.emit();\n-                    return Some(SmallVector::zero());\n-                }\n-            }\n-        }\n-        self.ensure_complete_parse(false);\n-        Some(items)\n-    }\n-\n-    fn make_trait_items(mut self: Box<Self>) -> Option<SmallVector<ast::TraitItem>> {\n-        let mut items = SmallVector::zero();\n-        loop {\n-            if self.parser.token == token::Eof {\n-                break;\n-            }\n-            match self.parser.parse_trait_item() {\n-                Ok(item) => items.push(item),\n-                Err(mut e) => {\n-                    e.emit();\n-                    return Some(SmallVector::zero());\n-                }\n-            }\n-        }\n-        self.ensure_complete_parse(false);\n-        Some(items)\n-    }\n-\n-    fn make_expr(mut self: Box<Self>) -> Option<P<ast::Expr>> {\n-        match self.parser.parse_expr() {\n-            Ok(e) => {\n-                self.ensure_complete_parse(true);\n-                Some(e)\n-            }\n-            Err(mut e) => {\n-                e.emit();\n-                Some(DummyResult::raw_expr(self.span))\n-            }\n-        }\n-    }\n-\n-    fn make_pat(mut self: Box<Self>) -> Option<P<ast::Pat>> {\n-        match self.parser.parse_pat() {\n-            Ok(e) => {\n-                self.ensure_complete_parse(false);\n-                Some(e)\n-            }\n-            Err(mut e) => {\n-                e.emit();\n-                Some(P(DummyResult::raw_pat(self.span)))\n-            }\n-        }\n-    }\n-\n-    fn make_stmts(mut self: Box<Self>) -> Option<SmallVector<ast::Stmt>> {\n-        let mut stmts = SmallVector::zero();\n-        loop {\n-            if self.parser.token == token::Eof {\n-                break;\n-            }\n-            match self.parser.parse_full_stmt(false) {\n-                Ok(Some(stmt)) => stmts.push(stmt),\n-                Ok(None) => { /* continue */ }\n-                Err(mut e) => {\n-                    e.emit();\n-                    return Some(SmallVector::zero());\n-                }\n-            }\n-        }\n-        self.ensure_complete_parse(false);\n-        Some(stmts)\n-    }\n-\n-    fn make_ty(mut self: Box<Self>) -> Option<P<ast::Ty>> {\n-        match self.parser.parse_ty() {\n-            Ok(e) => {\n-                self.ensure_complete_parse(false);\n-                Some(e)\n-            }\n-            Err(mut e) => {\n-                e.emit();\n-                Some(DummyResult::raw_ty(self.span))\n-            }\n-        }\n-    }\n-}\n-\n /// Represents a thing that maps token trees to Macro Results\n pub trait TTMacroExpander {\n     fn expand<'cx>(&self,"}, {"sha": "0d4e3ebdd205384c4c4560a8fc3da8ae48cb1770", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4a8467b62d572eabedf50c09b52f177e87160e96/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8467b62d572eabedf50c09b52f177e87160e96/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4a8467b62d572eabedf50c09b52f177e87160e96", "patch": "@@ -325,14 +325,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 let item_toks = TokenStream::from_tts(tts_for_item(&item, &self.cx.parse_sess));\n \n                 let tok_result = mac.expand(self.cx, attr.span, attr_toks, item_toks);\n-                let parser = self.cx.new_parser_from_tts(&tok_result.to_tts());\n-                let result = Box::new(TokResult { parser: parser, span: attr.span });\n-\n-                kind.make_from(result).unwrap_or_else(|| {\n-                    let msg = format!(\"macro could not be expanded into {} position\", kind.name());\n-                    self.cx.span_err(attr.span, &msg);\n-                    kind.dummy(attr.span)\n-                })\n+                self.parse_expansion(tok_result, kind, attr.span)\n             }\n             _ => unreachable!(),\n         }\n@@ -429,14 +422,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     },\n                 });\n \n-\n-                let tok_result = expandfun.expand(self.cx,\n-                                                  span,\n-                                                  TokenStream::from_tts(marked_tts));\n-                let parser = self.cx.new_parser_from_tts(&tok_result.to_tts());\n-                let result = Box::new(TokResult { parser: parser, span: span });\n-                // FIXME better span info.\n-                kind.make_from(result).map(|i| i.fold_with(&mut ChangeSpan { span: span }))\n+                let toks = TokenStream::from_tts(marked_tts);\n+                let tok_result = expandfun.expand(self.cx, span, toks);\n+                Some(self.parse_expansion(tok_result, kind, span))\n             }\n         };\n \n@@ -454,10 +442,31 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             expn_id: Some(self.cx.backtrace()),\n         })\n     }\n+\n+    fn parse_expansion(&mut self, toks: TokenStream, kind: ExpansionKind, span: Span) -> Expansion {\n+        let mut parser = self.cx.new_parser_from_tts(&toks.to_tts());\n+        let expansion = match parser.parse_expansion(kind, false) {\n+            Ok(expansion) => expansion,\n+            Err(mut err) => {\n+                err.emit();\n+                return kind.dummy(span);\n+            }\n+        };\n+        parser.ensure_complete_parse(kind == ExpansionKind::Expr, |parser| {\n+            let msg = format!(\"macro expansion ignores token `{}` and any following\",\n+                              parser.this_token_to_string());\n+            parser.diagnostic().struct_span_err(parser.span, &msg)\n+                .span_note(span, \"caused by the macro expansion here\")\n+                .emit();\n+        });\n+        // FIXME better span info\n+        expansion.fold_with(&mut ChangeSpan { span: span })\n+    }\n }\n \n impl<'a> Parser<'a> {\n-    pub fn parse_expansion(&mut self, kind: ExpansionKind) -> PResult<'a, Expansion> {\n+    pub fn parse_expansion(&mut self, kind: ExpansionKind, macro_legacy_warnings: bool)\n+                           -> PResult<'a, Expansion> {\n         Ok(match kind {\n             ExpansionKind::Items => {\n                 let mut items = SmallVector::zero();\n@@ -483,7 +492,7 @@ impl<'a> Parser<'a> {\n             ExpansionKind::Stmts => {\n                 let mut stmts = SmallVector::zero();\n                 while self.token != token::Eof {\n-                    if let Some(stmt) = self.parse_full_stmt(true)? {\n+                    if let Some(stmt) = self.parse_full_stmt(macro_legacy_warnings)? {\n                         stmts.push(stmt);\n                     }\n                 }"}, {"sha": "e78eeb8f7a4f8b0d4f8f7f08084e27d317858ad7", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a8467b62d572eabedf50c09b52f177e87160e96/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8467b62d572eabedf50c09b52f177e87160e96/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=4a8467b62d572eabedf50c09b52f177e87160e96", "patch": "@@ -63,7 +63,7 @@ impl<'a> ParserAnyMacro<'a> {\n     }\n \n     pub fn make(mut self: Box<ParserAnyMacro<'a>>, kind: ExpansionKind) -> Expansion {\n-        let expansion = panictry!(self.parser.parse_expansion(kind));\n+        let expansion = panictry!(self.parser.parse_expansion(kind, true));\n         self.ensure_complete_parse(kind == ExpansionKind::Expr, kind.name());\n         expansion\n     }"}]}