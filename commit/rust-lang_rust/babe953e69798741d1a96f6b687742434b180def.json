{"sha": "babe953e69798741d1a96f6b687742434b180def", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYmU5NTNlNjk3OTg3NDFkMWE5NmY2YjY4Nzc0MjQzNGIxODBkZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-07T19:40:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-07T19:40:03Z"}, "message": "Auto merge of #28852 - steveklabnik:doc_char, r=alexcrichton\n\nMostly adding examples, and reformatting for consistency.", "tree": {"sha": "7ac858530848c6746637735e528f95e1efde4ef6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ac858530848c6746637735e528f95e1efde4ef6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/babe953e69798741d1a96f6b687742434b180def", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/babe953e69798741d1a96f6b687742434b180def", "html_url": "https://github.com/rust-lang/rust/commit/babe953e69798741d1a96f6b687742434b180def", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/babe953e69798741d1a96f6b687742434b180def/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cee9e20f24c0f001295fe8b3d962cc6b5d15e44", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cee9e20f24c0f001295fe8b3d962cc6b5d15e44", "html_url": "https://github.com/rust-lang/rust/commit/3cee9e20f24c0f001295fe8b3d962cc6b5d15e44"}, {"sha": "51097fcdacf7c6415ea58a18c5774071f4790090", "url": "https://api.github.com/repos/rust-lang/rust/commits/51097fcdacf7c6415ea58a18c5774071f4790090", "html_url": "https://github.com/rust-lang/rust/commit/51097fcdacf7c6415ea58a18c5774071f4790090"}], "stats": {"total": 467, "additions": 392, "deletions": 75}, "files": [{"sha": "207dc7aacbf8f3c09a9e6628a846ca95fa738ec0", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 392, "deletions": 75, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/babe953e69798741d1a96f6b687742434b180def/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/babe953e69798741d1a96f6b687742434b180def/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=babe953e69798741d1a96f6b687742434b180def", "patch": "@@ -110,53 +110,122 @@ impl Iterator for CaseMappingIter {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"char\"]\n impl char {\n-    /// Checks if a `char` parses as a numeric digit in the given radix.\n+    /// Checks if a `char` is a digit in the given radix.\n+    ///\n+    /// A 'radix' here is sometimes also called a 'base'. A radix of two\n+    /// indicates a binary number, a radix of ten, decimal, and a radix of\n+    /// sixteen, hexicdecimal, to give some common values. Arbitrary\n+    /// radicum are supported.\n     ///\n     /// Compared to `is_numeric()`, this function only recognizes the characters\n     /// `0-9`, `a-z` and `A-Z`.\n     ///\n-    /// # Return value\n+    /// 'Digit' is defined to be only the following characters:\n     ///\n-    /// Returns `true` if `c` is a valid digit under `radix`, and `false`\n-    /// otherwise.\n+    /// * `0-9`\n+    /// * `a-z`\n+    /// * `A-Z`\n+    ///\n+    /// For a more comprehensive understanding of 'digit', see [`is_numeric()`][is_numeric].\n+    ///\n+    /// [is_numeric]: #method.is_numeric\n     ///\n     /// # Panics\n     ///\n-    /// Panics if given a radix > 36.\n+    /// Panics if given a radix larger than 36.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let c = '1';\n+    /// let d = '1';\n     ///\n-    /// assert!(c.is_digit(10));\n+    /// assert!(d.is_digit(10));\n     ///\n-    /// assert!('f'.is_digit(16));\n+    /// let d = 'f';\n+    ///\n+    /// assert!(d.is_digit(16));\n+    /// assert!(!d.is_digit(10));\n+    /// ```\n+    ///\n+    /// Passing a large radix, causing a panic:\n+    ///\n+    /// ```\n+    /// use std::thread;\n+    ///\n+    /// let result = thread::spawn(|| {\n+    ///     let d = '1';\n+    ///\n+    ///     // this panics\n+    ///     d.is_digit(37);\n+    /// }).join();\n+    ///\n+    /// assert!(result.is_err());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_digit(self, radix: u32) -> bool { C::is_digit(self, radix) }\n \n-    /// Converts a character to the corresponding digit.\n+    /// Converts a `char` to a digit in the given radix.\n+    ///\n+    /// A 'radix' here is sometimes also called a 'base'. A radix of two\n+    /// indicates a binary number, a radix of ten, decimal, and a radix of\n+    /// sixteen, hexicdecimal, to give some common values. Arbitrary\n+    /// radicum are supported.\n+    ///\n+    /// 'Digit' is defined to be only the following characters:\n     ///\n-    /// # Return value\n+    /// * `0-9`\n+    /// * `a-z`\n+    /// * `A-Z`\n     ///\n-    /// If `c` is between '0' and '9', the corresponding value between 0 and\n-    /// 9. If `c` is 'a' or 'A', 10. If `c` is 'b' or 'B', 11, etc. Returns\n-    /// none if the character does not refer to a digit in the given radix.\n+    /// # Failure\n+    ///\n+    /// Returns `None` if the `char` does not refer to a digit in the given radix.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if given a radix outside the range [0..36].\n+    /// Panics if given a radix larger than 36.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let d = '1';\n+    ///\n+    /// assert_eq!(d.to_digit(10), Some(1));\n+    ///\n+    /// let d = 'f';\n+    ///\n+    /// assert_eq!(d.to_digit(16), Some(15));\n+    /// ```\n+    ///\n+    /// Passing a non-digit results in failure:\n+    ///\n     /// ```\n-    /// let c = '1';\n+    /// let d = 'f';\n     ///\n-    /// assert_eq!(c.to_digit(10), Some(1));\n+    /// assert_eq!(d.to_digit(10), None);\n     ///\n-    /// assert_eq!('f'.to_digit(16), Some(15));\n+    /// let d = 'z';\n+    ///\n+    /// assert_eq!(d.to_digit(16), None);\n+    /// ```\n+    ///\n+    /// Passing a large radix, causing a panic:\n+    ///\n+    /// ```\n+    /// use std::thread;\n+    ///\n+    /// let result = thread::spawn(|| {\n+    ///   let d = '1';\n+    ///\n+    ///   d.to_digit(37);\n+    /// }).join();\n+    ///\n+    /// assert!(result.is_err());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -195,21 +264,29 @@ impl char {\n     #[inline]\n     pub fn escape_unicode(self) -> EscapeUnicode { C::escape_unicode(self) }\n \n-    /// Returns an iterator that yields the 'default' ASCII and\n-    /// C++11-like literal escape of a character, as `char`s.\n+    /// Returns an iterator that yields the literal escape code of a `char`.\n     ///\n     /// The default is chosen with a bias toward producing literals that are\n     /// legal in a variety of languages, including C++11 and similar C-family\n     /// languages. The exact rules are:\n     ///\n-    /// * Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n-    /// * Single-quote, double-quote and backslash chars are backslash-\n-    ///   escaped.\n-    /// * Any other chars in the range [0x20,0x7e] are not escaped.\n-    /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n+    /// * Tab is escaped as `\\t`.\n+    /// * Carriage return is escaped as `\\r`.\n+    /// * Line feed is escaped as `\\n`.\n+    /// * Single quote is escaped as `\\'`.\n+    /// * Double quote is escaped as `\\\"`.\n+    /// * Backslash is escaped as `\\\\`.\n+    /// * Any character in the 'printable ASCII' range `0x20` .. `0x7e`\n+    ///   inclusive is not escaped.\n+    /// * All other characters are given hexadecimal Unicode escapes; see\n+    ///   [`escape_unicode`][escape_unicode].\n+    ///\n+    /// [escape_unicode]: #method.escape_unicode\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// for i in '\"'.escape_default() {\n     ///     println!(\"{}\", i);\n@@ -234,29 +311,70 @@ impl char {\n     #[inline]\n     pub fn escape_default(self) -> EscapeDefault { C::escape_default(self) }\n \n-    /// Returns the number of bytes this character would need if encoded in\n-    /// UTF-8.\n+    /// Returns the number of bytes this `char` would need if encoded in UTF-8.\n+    ///\n+    /// That number of bytes is always between 1 and 4, inclusive.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let n = '\u00df'.len_utf8();\n+    /// let len = 'A'.len_utf8();\n+    /// assert_eq!(len, 1);\n+    ///\n+    /// let len = '\u00df'.len_utf8();\n+    /// assert_eq!(len, 2);\n     ///\n-    /// assert_eq!(n, 2);\n+    /// let len = '\u211d'.len_utf8();\n+    /// assert_eq!(len, 3);\n+    ///\n+    /// let len = '\ud83d\udca3'.len_utf8();\n+    /// assert_eq!(len, 4);\n+    /// ```\n+    ///\n+    /// The `&str` type guarantees that its contents are UTF-8, and so we can compare the length it\n+    /// would take if each code point was represented as a `char` vs in the `&str` itself:\n+    ///\n+    /// ```\n+    /// // as chars\n+    /// let eastern = '\u6771';\n+    /// let capitol = '\u4eac';\n+    ///\n+    /// // both can be represented as three bytes\n+    /// assert_eq!(3, eastern.len_utf8());\n+    /// assert_eq!(3, capitol.len_utf8());\n+    ///\n+    /// // as a &str, these two are encoded in UTF-8\n+    /// let tokyo = \"\u6771\u4eac\";\n+    ///\n+    /// let len = eastern.len_utf8() + capitol.len_utf8();\n+    ///\n+    /// // we can see that they take six bytes total...\n+    /// assert_eq!(6, tokyo.len());\n+    ///\n+    /// // ... just like the &str\n+    /// assert_eq!(len, tokyo.len());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn len_utf8(self) -> usize { C::len_utf8(self) }\n \n-    /// Returns the number of 16-bit code units this character would need if\n+    /// Returns the number of 16-bit code units this `char` would need if\n     /// encoded in UTF-16.\n     ///\n+    /// See the documentation for [`len_utf8()`][len_utf8] for more explanation\n+    /// of this concept. This function is a mirror, but for UTF-16 instead of\n+    /// UTF-8.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// let n = '\u00df'.len_utf16();\n-    ///\n     /// assert_eq!(n, 1);\n+    ///\n+    /// let len = '\ud83d\udca3'.len_utf16();\n+    /// assert_eq!(len, 2);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -342,8 +460,24 @@ impl char {\n         C::encode_utf16(self, dst)\n     }\n \n-    /// Returns whether the specified character is considered a Unicode\n-    /// alphabetic code point.\n+    /// Returns true if this `char` is an alphabetic code point, and false if not.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let c = 'a';\n+    ///\n+    /// assert!(c.is_alphabetic());\n+    ///\n+    /// let c = '\u4eac';\n+    /// assert!(c.is_alphabetic());\n+    ///\n+    /// let c = '\ud83d\udc9d';\n+    /// // love is many things, but it is not alphabetic\n+    /// assert!(!c.is_alphabetic());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_alphabetic(self) -> bool {\n@@ -354,20 +488,20 @@ impl char {\n         }\n     }\n \n-    /// Returns whether the specified character satisfies the 'XID_Start'\n-    /// Unicode property.\n+    /// Returns true if this `char` satisfies the 'XID_Start' Unicode property, and false\n+    /// otherwise.\n     ///\n     /// 'XID_Start' is a Unicode Derived Property specified in\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-    /// mostly similar to ID_Start but modified for closure under NFKx.\n+    /// mostly similar to `ID_Start` but modified for closure under `NFKx`.\n     #[unstable(feature = \"unicode\",\n                reason = \"mainly needed for compiler internals\",\n                issue = \"0\")]\n     #[inline]\n     pub fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n \n-    /// Returns whether the specified `char` satisfies the 'XID_Continue'\n-    /// Unicode property.\n+    /// Returns true if this `char` satisfies the 'XID_Continue' Unicode property, and false\n+    /// otherwise.\n     ///\n     /// 'XID_Continue' is a Unicode Derived Property specified in\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n@@ -378,10 +512,32 @@ impl char {\n     #[inline]\n     pub fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n \n-    /// Indicates whether a character is in lowercase.\n+    /// Returns true if this `char` is lowercase, and false otherwise.\n     ///\n-    /// This is defined according to the terms of the Unicode Derived Core\n+    /// 'Lowercase' is defined according to the terms of the Unicode Derived Core\n     /// Property `Lowercase`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let c = 'a';\n+    /// assert!(c.is_lowercase());\n+    ///\n+    /// let c = '\u03b4';\n+    /// assert!(c.is_lowercase());\n+    ///\n+    /// let c = 'A';\n+    /// assert!(!c.is_lowercase());\n+    ///\n+    /// let c = '\u0394';\n+    /// assert!(!c.is_lowercase());\n+    ///\n+    /// // The various Chinese scripts do not have case, and so:\n+    /// let c = '\u4e2d';\n+    /// assert!(!c.is_lowercase());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_lowercase(self) -> bool {\n@@ -392,10 +548,32 @@ impl char {\n         }\n     }\n \n-    /// Indicates whether a character is in uppercase.\n+    /// Returns true if this `char` is uppercase, and false otherwise.\n     ///\n-    /// This is defined according to the terms of the Unicode Derived Core\n+    /// 'Uppercase' is defined according to the terms of the Unicode Derived Core\n     /// Property `Uppercase`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let c = 'a';\n+    /// assert!(!c.is_uppercase());\n+    ///\n+    /// let c = '\u03b4';\n+    /// assert!(!c.is_uppercase());\n+    ///\n+    /// let c = 'A';\n+    /// assert!(c.is_uppercase());\n+    ///\n+    /// let c = '\u0394';\n+    /// assert!(c.is_uppercase());\n+    ///\n+    /// // The various Chinese scripts do not have case, and so:\n+    /// let c = '\u4e2d';\n+    /// assert!(!c.is_uppercase());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_uppercase(self) -> bool {\n@@ -406,9 +584,26 @@ impl char {\n         }\n     }\n \n-    /// Indicates whether a character is whitespace.\n+    /// Returns true if this `char` is whitespace, and false otherwise.\n     ///\n-    /// Whitespace is defined in terms of the Unicode Property `White_Space`.\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived Core\n+    /// Property `White_Space`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let c = ' ';\n+    /// assert!(c.is_whitespace());\n+    ///\n+    /// // a non-breaking space\n+    /// let c = '\\u{A0}';\n+    /// assert!(c.is_whitespace());\n+    ///\n+    /// let c = '\u8d8a';\n+    /// assert!(!c.is_whitespace());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_whitespace(self) -> bool {\n@@ -419,25 +614,101 @@ impl char {\n         }\n     }\n \n-    /// Indicates whether a character is alphanumeric.\n+    /// Returns true if this `char` is alphanumeric, and false otherwise.\n     ///\n-    /// Alphanumericness is defined in terms of the Unicode General Categories\n+    /// 'Alphanumeric'-ness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let c = '\u0663';\n+    /// assert!(c.is_alphanumeric());\n+    ///\n+    /// let c = '7';\n+    /// assert!(c.is_alphanumeric());\n+    ///\n+    /// let c = '\u09ec';\n+    /// assert!(c.is_alphanumeric());\n+    ///\n+    /// let c = 'K';\n+    /// assert!(c.is_alphanumeric());\n+    ///\n+    /// let c = '\u0648';\n+    /// assert!(c.is_alphanumeric());\n+    ///\n+    /// let c = '\u85cf';\n+    /// assert!(c.is_alphanumeric());\n+    ///\n+    /// let c = '\u00be';\n+    /// assert!(!c.is_alphanumeric());\n+    ///\n+    /// let c = '\u2460';\n+    /// assert!(!c.is_alphanumeric());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_alphanumeric(self) -> bool {\n         self.is_alphabetic() || self.is_numeric()\n     }\n \n-    /// Indicates whether a character is a control code point.\n+    /// Returns true if this `char` is a control code point, and false otherwise.\n     ///\n-    /// Control code points are defined in terms of the Unicode General\n+    /// 'Control code point' is defined in terms of the Unicode General\n     /// Category `Cc`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// // U+009C, STRING TERMINATOR\n+    /// let c = '\u009c';\n+    /// assert!(c.is_control());\n+    ///\n+    /// let c = 'q';\n+    /// assert!(!c.is_control());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_control(self) -> bool { general_category::Cc(self) }\n \n-    /// Indicates whether the character is numeric (Nd, Nl, or No).\n+    /// Returns true if this `char` is numeric, and false otherwise.\n+    ///\n+    /// 'Numeric'-ness is defined in terms of the Unicode General Categories\n+    /// 'Nd', 'Nl', 'No'.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let c = '\u0663';\n+    /// assert!(c.is_numeric());\n+    ///\n+    /// let c = '7';\n+    /// assert!(c.is_numeric());\n+    ///\n+    /// let c = '\u09ec';\n+    /// assert!(c.is_numeric());\n+    ///\n+    /// let c = 'K';\n+    /// assert!(!c.is_numeric());\n+    ///\n+    /// let c = '\u0648';\n+    /// assert!(!c.is_numeric());\n+    ///\n+    /// let c = '\u85cf';\n+    /// assert!(!c.is_numeric());\n+    ///\n+    /// let c = '\u00be';\n+    /// assert!(!c.is_numeric());\n+    ///\n+    /// let c = '\u2460';\n+    /// assert!(!c.is_numeric());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_numeric(self) -> bool {\n@@ -448,71 +719,116 @@ impl char {\n         }\n     }\n \n-    /// Converts a character to its lowercase equivalent.\n+    /// Returns an iterator that yields the lowercase equivalent of a `char`.\n     ///\n-    /// This performs complex unconditional mappings with no tailoring.\n-    /// See `to_uppercase()` for references and more information.\n+    /// If no conversion is possible then an iterator with just the input character is returned.\n     ///\n-    /// # Return value\n+    /// This performs complex unconditional mappings with no tailoring: it maps\n+    /// one Unicode character to its lowercase equivalent according to the\n+    /// [Unicode database] and the additional complex mappings\n+    /// [`SpecialCasing.txt`]. Conditional mappings (based on context or\n+    /// language) are not considered here.\n     ///\n-    /// Returns an iterator which yields the characters corresponding to the\n-    /// lowercase equivalent of the character. If no conversion is possible then\n-    /// an iterator with just the input character is returned.\n+    /// For a full reference, see [here][reference].\n+    ///\n+    /// [Unicode database]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+    ///\n+    /// [`SpecialCasing.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n+    ///\n+    /// [reference]: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// assert_eq!(Some('c'), 'C'.to_lowercase().next());\n+    /// let c = 'c';\n+    ///\n+    /// assert_eq!(c.to_uppercase().next(), Some('C'));\n+    ///\n+    /// // Japanese scripts do not have case, and so:\n+    /// let c = '\u5c71';\n+    /// assert_eq!(c.to_uppercase().next(), Some('\u5c71'));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_lowercase(self) -> ToLowercase {\n         ToLowercase(CaseMappingIter::new(conversions::to_lower(self)))\n     }\n \n-    /// Converts a character to its uppercase equivalent.\n-    ///\n-    /// This performs complex unconditional mappings with no tailoring:\n-    /// it maps one Unicode character to its uppercase equivalent\n-    /// according to the Unicode database [1]\n-    /// and the additional complex mappings [`SpecialCasing.txt`].\n-    /// Conditional mappings (based on context or language) are not considered here.\n+    /// Returns an iterator that yields the uppercase equivalent of a `char`.\n     ///\n-    /// A full reference can be found here [2].\n+    /// If no conversion is possible then an iterator with just the input character is returned.\n     ///\n-    /// # Return value\n+    /// This performs complex unconditional mappings with no tailoring: it maps\n+    /// one Unicode character to its uppercase equivalent according to the\n+    /// [Unicode database] and the additional complex mappings\n+    /// [`SpecialCasing.txt`]. Conditional mappings (based on context or\n+    /// language) are not considered here.\n     ///\n-    /// Returns an iterator which yields the characters corresponding to the\n-    /// uppercase equivalent of the character. If no conversion is possible then\n-    /// an iterator with just the input character is returned.\n+    /// For a full reference, see [here][reference].\n     ///\n-    /// [1]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+    /// [Unicode database]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n     ///\n     /// [`SpecialCasing.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n     ///\n-    /// [2]: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n+    /// [reference]: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let c = 'c';\n+    /// assert_eq!(c.to_uppercase().next(), Some('C'));\n+    ///\n+    /// // Japanese does not have case, and so:\n+    /// let c = '\u5c71';\n+    /// assert_eq!(c.to_uppercase().next(), Some('\u5c71'));\n+    /// ```\n+    ///\n+    /// In Turkish, the equivalent of 'i' in Latin has five forms instead of two:\n+    ///\n+    /// * 'Dotless': I / \u0131, sometimes written \u00ef\n+    /// * 'Dotted': \u0130 / i\n+    ///\n+    /// Note that the lowercase dotted 'i' is the same as the Latin. Therefore:\n+    ///\n+    /// ```\n+    /// let i = 'i';\n+    ///\n+    /// let upper_i = i.to_uppercase().next();\n     /// ```\n-    /// assert_eq!(Some('C'), 'c'.to_uppercase().next());\n+    ///\n+    /// The value of `upper_i` here relies on the language of the text: if we're\n+    /// in `en-US`, it should be `Some('I')`, but if we're in `tr_TR`, it should\n+    /// be `Some('\u0130')`. `to_uppercase()` does not take this into account, and so:\n+    ///\n     /// ```\n+    /// let i = 'i';\n+    ///\n+    /// let upper_i = i.to_uppercase().next();\n+    ///\n+    /// assert_eq!(Some('I'), upper_i);\n+    /// ```\n+    ///\n+    /// holds across languages.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_uppercase(self) -> ToUppercase {\n         ToUppercase(CaseMappingIter::new(conversions::to_upper(self)))\n     }\n }\n \n-/// An iterator that decodes UTF-16 encoded codepoints from an iterator of `u16`s.\n+/// An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.\n #[unstable(feature = \"decode_utf16\", reason = \"recently exposed\", issue = \"27830\")]\n #[derive(Clone)]\n pub struct DecodeUtf16<I> where I: Iterator<Item=u16> {\n     iter: I,\n     buf: Option<u16>,\n }\n \n-/// Create an iterator over the UTF-16 encoded codepoints in `iterable`,\n+/// Create an iterator over the UTF-16 encoded code points in `iterable`,\n /// returning unpaired surrogates as `Err`s.\n ///\n /// # Examples\n@@ -612,7 +928,8 @@ impl<I: Iterator<Item=u16>> Iterator for DecodeUtf16<I> {\n     }\n }\n \n-/// U+FFFD REPLACEMENT CHARACTER (\ufffd) is used in Unicode to represent a decoding error.\n-/// It can occur, for example, when giving ill-formed UTF-8 bytes to `String::from_utf8_lossy`.\n+/// `U+FFFD REPLACEMENT CHARACTER` (\ufffd) is used in Unicode to represent a decoding error.\n+/// It can occur, for example, when giving ill-formed UTF-8 bytes to\n+/// [`String::from_utf8_lossy`](../string/struct.String.html#method.from_utf8_lossy).\n #[unstable(feature = \"decode_utf16\", reason = \"recently added\", issue = \"27830\")]\n pub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';"}]}