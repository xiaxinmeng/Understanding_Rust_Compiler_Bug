{"sha": "879abb1641d97be798010f52a875b9fc83881323", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3OWFiYjE2NDFkOTdiZTc5ODAxMGY1MmE4NzViOWZjODM4ODEzMjM=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-03-12T16:00:20Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-04-21T15:46:32Z"}, "message": "Add `AsyncArgument` to AST.\n\nThis commit adds an `AsyncArgument` struct to the AST that contains the\ngenerated argument and statement that will be used in HIR lowering, name\nresolution and def collection.", "tree": {"sha": "795d9bd80cf7f29b8f52244386aabcc1240adb61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/795d9bd80cf7f29b8f52244386aabcc1240adb61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/879abb1641d97be798010f52a875b9fc83881323", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAly8kFgACgkQAXYLT59T\n8VQeCQ//fE2JAoNH1e9/mNV1WrHhp6tKq5apw0GhTPenWxLtB/aeNYxgU+ywZWIJ\nhb8pldMKY4j5WY4Ims4GRlvaEOQulNE/iQm5lwUb4uzgS0byKCbEc31l/BLVLXnr\npRtD8Oth4nPceq/TUOxBfa9IDzIwUWeUbxcWu/MS5/7FjZRs8RO5eckR3BRgigDv\nxYxPmYpllRbfxNUKO1wizhsFao0wkGqWNyUr4dSyYerBTTvqA0i3lJZlg17tIZqw\nQhHlNsvTFMu63LaamPmK/3XqfHhNV2exaDpywHUtM7uqntKOFCSLbcvLlbuf0A7j\n4mQAzjIrv5ouLdSJO60zS27hrI2+tbyGjJZNfmAzAy+zysDy/CS1/X3LoDknCXdZ\n6rrLM5FGsX5C0FqxdhEXFRhrR1IMtBCTPoP7nbTpZzf080YV7Zge3CtzMJb7QpKe\nLTyoA9T7Ik0m+UpvDnd4HZAjoLneCdCzbLG0fqAzW0a7Fl6cJ04NSC/ivcGCHen8\ncNK1ya+Nm0ZDYE9RejjYhzFn1mCpFo2E91RbRUpT1MVtL+0UVTLQNrIdh4TWN3Lm\n2I+ua36+TrzZwcuEHDm62vGw8Ozn7e1WnfFXerhN/RoBBdNRxYLp8n0/8991Jsvd\nL3hXjNtSDFOv2l1F3Bat7+/Rp+8Hd833zL5e7XKqIA6oRgA0hn4=\n=OTrf\n-----END PGP SIGNATURE-----", "payload": "tree 795d9bd80cf7f29b8f52244386aabcc1240adb61\nparent 41c6bb1096abb026d496c2136bb18c001eca46fe\nauthor David Wood <david@davidtw.co> 1552406420 +0100\ncommitter David Wood <david@davidtw.co> 1555861592 +0100\n\nAdd `AsyncArgument` to AST.\n\nThis commit adds an `AsyncArgument` struct to the AST that contains the\ngenerated argument and statement that will be used in HIR lowering, name\nresolution and def collection.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/879abb1641d97be798010f52a875b9fc83881323", "html_url": "https://github.com/rust-lang/rust/commit/879abb1641d97be798010f52a875b9fc83881323", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/879abb1641d97be798010f52a875b9fc83881323/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41c6bb1096abb026d496c2136bb18c001eca46fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/41c6bb1096abb026d496c2136bb18c001eca46fe", "html_url": "https://github.com/rust-lang/rust/commit/41c6bb1096abb026d496c2136bb18c001eca46fe"}], "stats": {"total": 224, "additions": 171, "deletions": 53}, "files": [{"sha": "b653093c1f8a4f4555f79e9a4ae03ff40243aa09", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/879abb1641d97be798010f52a875b9fc83881323/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879abb1641d97be798010f52a875b9fc83881323/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=879abb1641d97be798010f52a875b9fc83881323", "patch": "@@ -58,10 +58,10 @@ impl<'a> FnKind<'a> {\n         }\n     }\n \n-    pub fn header(&self) -> Option<FnHeader> {\n+    pub fn header(&self) -> Option<&FnHeader> {\n         match *self {\n-            FnKind::ItemFn(_, _, header, _, _) => Some(header),\n-            FnKind::Method(_, sig, _, _) => Some(sig.header),\n+            FnKind::ItemFn(_, _, ref header, _, _) => Some(header),\n+            FnKind::Method(_, ref sig, _, _) => Some(&sig.header),\n             FnKind::Closure(_) => None,\n         }\n     }"}, {"sha": "93a327588fef62315f6568615446ab4ef4261ad7", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/879abb1641d97be798010f52a875b9fc83881323/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879abb1641d97be798010f52a875b9fc83881323/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=879abb1641d97be798010f52a875b9fc83881323", "patch": "@@ -3000,13 +3000,13 @@ impl<'a> LoweringContext<'a> {\n     fn lower_async_body(\n         &mut self,\n         decl: &FnDecl,\n-        asyncness: IsAsync,\n+        asyncness: &IsAsync,\n         body: &Block,\n     ) -> hir::BodyId {\n         self.lower_body(Some(decl), |this| {\n             if let IsAsync::Async { closure_id, .. } = asyncness {\n                 let async_expr = this.make_async_expr(\n-                    CaptureBy::Value, closure_id, None,\n+                    CaptureBy::Value, *closure_id, None,\n                     |this| {\n                         let body = this.lower_block(body, false);\n                         this.expr_block(body, ThinVec::new())\n@@ -3067,14 +3067,14 @@ impl<'a> LoweringContext<'a> {\n                     value\n                 )\n             }\n-            ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n+            ItemKind::Fn(ref decl, ref header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n                 self.with_new_scopes(|this| {\n                     // Note: we don't need to change the return type from `T` to\n                     // `impl Future<Output = T>` here because lower_body\n                     // only cares about the input argument patterns in the function\n                     // declaration (decl), not the return types.\n-                    let body_id = this.lower_async_body(decl, header.asyncness.node, body);\n+                    let body_id = this.lower_async_body(decl, &header.asyncness.node, body);\n \n                     let (generics, fn_decl) = this.add_in_band_defs(\n                         generics,\n@@ -3565,7 +3565,7 @@ impl<'a> LoweringContext<'a> {\n                 )\n             }\n             ImplItemKind::Method(ref sig, ref body) => {\n-                let body_id = self.lower_async_body(&sig.decl, sig.header.asyncness.node, body);\n+                let body_id = self.lower_async_body(&sig.decl, &sig.header.asyncness.node, body);\n                 let impl_trait_return_allow = !self.is_in_trait_impl;\n                 let (generics, sig) = self.lower_method_sig(\n                     &i.generics,\n@@ -3767,7 +3767,7 @@ impl<'a> LoweringContext<'a> {\n         impl_trait_return_allow: bool,\n         is_async: Option<NodeId>,\n     ) -> (hir::Generics, hir::MethodSig) {\n-        let header = self.lower_fn_header(sig.header);\n+        let header = self.lower_fn_header(&sig.header);\n         let (generics, decl) = self.add_in_band_defs(\n             generics,\n             fn_def_id,\n@@ -3789,10 +3789,10 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_fn_header(&mut self, h: FnHeader) -> hir::FnHeader {\n+    fn lower_fn_header(&mut self, h: &FnHeader) -> hir::FnHeader {\n         hir::FnHeader {\n             unsafety: self.lower_unsafety(h.unsafety),\n-            asyncness: self.lower_asyncness(h.asyncness.node),\n+            asyncness: self.lower_asyncness(&h.asyncness.node),\n             constness: self.lower_constness(h.constness),\n             abi: h.abi,\n         }\n@@ -3812,7 +3812,7 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_asyncness(&mut self, a: IsAsync) -> hir::IsAsync {\n+    fn lower_asyncness(&mut self, a: &IsAsync) -> hir::IsAsync {\n         match a {\n             IsAsync::Async { .. } => hir::IsAsync::Async,\n             IsAsync::NotAsync => hir::IsAsync::NotAsync,\n@@ -4125,7 +4125,7 @@ impl<'a> LoweringContext<'a> {\n                 })\n             }\n             ExprKind::Closure(\n-                capture_clause, asyncness, movability, ref decl, ref body, fn_decl_span\n+                capture_clause, ref asyncness, movability, ref decl, ref body, fn_decl_span\n             ) => {\n                 if let IsAsync::Async { closure_id, .. } = asyncness {\n                     let outer_decl = FnDecl {\n@@ -4163,7 +4163,7 @@ impl<'a> LoweringContext<'a> {\n                                 Some(&**ty)\n                             } else { None };\n                             let async_body = this.make_async_expr(\n-                                capture_clause, closure_id, async_ret_ty,\n+                                capture_clause, *closure_id, async_ret_ty,\n                                 |this| {\n                                     this.with_new_scopes(|this| this.lower_expr(body))\n                                 });"}, {"sha": "6ba2a65703bdca02d4f9d98aef7ecb93a3cbc5cf", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/879abb1641d97be798010f52a875b9fc83881323/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879abb1641d97be798010f52a875b9fc83881323/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=879abb1641d97be798010f52a875b9fc83881323", "patch": "@@ -68,7 +68,7 @@ impl<'a> DefCollector<'a> {\n         id: NodeId,\n         name: Name,\n         span: Span,\n-        header: &FnHeader,\n+        header: &'a FnHeader,\n         generics: &'a Generics,\n         decl: &'a FnDecl,\n         body: &'a Block,\n@@ -77,6 +77,7 @@ impl<'a> DefCollector<'a> {\n             IsAsync::Async {\n                 closure_id,\n                 return_impl_trait_id,\n+                ..\n             } => (closure_id, return_impl_trait_id),\n             _ => unreachable!(),\n         };\n@@ -290,7 +291,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n         match expr.node {\n             ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id),\n-            ExprKind::Closure(_, asyncness, ..) => {\n+            ExprKind::Closure(_, ref asyncness, ..) => {\n                 let closure_def = self.create_def(expr.id,\n                                           DefPathData::ClosureExpr,\n                                           REGULAR_SPACE,\n@@ -300,7 +301,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 // Async closures desugar to closures inside of closures, so\n                 // we must create two defs.\n                 if let IsAsync::Async { closure_id, .. } = asyncness {\n-                    let async_def = self.create_def(closure_id,\n+                    let async_def = self.create_def(*closure_id,\n                                                     DefPathData::ClosureExpr,\n                                                     REGULAR_SPACE,\n                                                     expr.span);"}, {"sha": "709e5c4cce4eff38ec1f793f3454cff8957ced22", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/879abb1641d97be798010f52a875b9fc83881323/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879abb1641d97be798010f52a875b9fc83881323/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=879abb1641d97be798010f52a875b9fc83881323", "patch": "@@ -1328,6 +1328,22 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n \n         run_early_pass!(self, check_mac, mac);\n     }\n+\n+    fn visit_fn_header(&mut self, header: &'a ast::FnHeader) {\n+        // Unlike in HIR lowering and name resolution, the `AsyncArgument` statements are not added\n+        // to the function body and the arguments do not replace those in the declaration. They are\n+        // still visited manually here so that buffered lints can be emitted.\n+        if let ast::IsAsync::Async { ref arguments, .. } = header.asyncness.node {\n+            for a in arguments {\n+                // Visit the argument..\n+                self.visit_pat(&a.arg.pat);\n+                self.visit_ty(&a.arg.ty);\n+\n+                // ..and the statement.\n+                self.visit_stmt(&a.stmt);\n+            }\n+        }\n+    }\n }\n \n struct LateLintPassObjects<'a> {"}, {"sha": "9dd8a7050fd289374b0bac8685ceaf521f808063", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/879abb1641d97be798010f52a875b9fc83881323/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879abb1641d97be798010f52a875b9fc83881323/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=879abb1641d97be798010f52a875b9fc83881323", "patch": "@@ -222,7 +222,7 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn check_trait_fn_not_async(&self, span: Span, asyncness: IsAsync) {\n+    fn check_trait_fn_not_async(&self, span: Span, asyncness: &IsAsync) {\n         if asyncness.is_async() {\n             struct_span_err!(self.session, span, E0706,\n                              \"trait fns cannot be declared `async`\").emit()\n@@ -570,7 +570,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.invalid_visibility(&impl_item.vis, None);\n                     if let ImplItemKind::Method(ref sig, _) = impl_item.node {\n                         self.check_trait_fn_not_const(sig.header.constness);\n-                        self.check_trait_fn_not_async(impl_item.span, sig.header.asyncness.node);\n+                        self.check_trait_fn_not_async(impl_item.span, &sig.header.asyncness.node);\n                     }\n                 }\n             }\n@@ -642,7 +642,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.no_questions_in_bounds(bounds, \"supertraits\", true);\n                 for trait_item in trait_items {\n                     if let TraitItemKind::Method(ref sig, ref block) = trait_item.node {\n-                        self.check_trait_fn_not_async(trait_item.span, sig.header.asyncness.node);\n+                        self.check_trait_fn_not_async(trait_item.span, &sig.header.asyncness.node);\n                         self.check_trait_fn_not_const(sig.header.constness);\n                         if block.is_none() {\n                             self.check_decl_no_pat(&sig.decl, |span, mut_ident| {"}, {"sha": "de2f04035e41bc23a4969888e7d71b550b3cdb7c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/879abb1641d97be798010f52a875b9fc83881323/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879abb1641d97be798010f52a875b9fc83881323/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=879abb1641d97be798010f52a875b9fc83881323", "patch": "@@ -817,13 +817,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         debug!(\"(resolving function) entering function\");\n         let (rib_kind, asyncness) = match function_kind {\n             FnKind::ItemFn(_, ref header, ..) =>\n-                (FnItemRibKind, header.asyncness.node),\n+                (FnItemRibKind, &header.asyncness.node),\n             FnKind::Method(_, ref sig, _, _) =>\n-                (TraitOrImplItemRibKind, sig.header.asyncness.node),\n+                (TraitOrImplItemRibKind, &sig.header.asyncness.node),\n             FnKind::Closure(_) =>\n                 // Async closures aren't resolved through `visit_fn`-- they're\n                 // processed separately\n-                (ClosureRibKind(node_id), IsAsync::NotAsync),\n+                (ClosureRibKind(node_id), &IsAsync::NotAsync),\n         };\n \n         // Create a value rib for the function.\n@@ -836,16 +836,14 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         let mut bindings_list = FxHashMap::default();\n         for argument in &declaration.inputs {\n             self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n-\n             self.visit_ty(&argument.ty);\n-\n             debug!(\"(resolving function) recorded argument\");\n         }\n         visit::walk_fn_ret_ty(self, &declaration.output);\n \n         // Resolve the function body, potentially inside the body of an async closure\n         if let IsAsync::Async { closure_id, .. } = asyncness {\n-            let rib_kind = ClosureRibKind(closure_id);\n+            let rib_kind = ClosureRibKind(*closure_id);\n             self.ribs[ValueNS].push(Rib::new(rib_kind));\n             self.label_ribs.push(Rib::new(rib_kind));\n         }"}, {"sha": "f9c1f02236dbc69a673df41e0377aac0c23bb15c", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/879abb1641d97be798010f52a875b9fc83881323/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879abb1641d97be798010f52a875b9fc83881323/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=879abb1641d97be798010f52a875b9fc83881323", "patch": "@@ -374,7 +374,7 @@ impl Sig for ast::Item {\n \n                 Ok(extend_sig(ty, text, defs, vec![]))\n             }\n-            ast::ItemKind::Fn(ref decl, header, ref generics, _) => {\n+            ast::ItemKind::Fn(ref decl, ref header, ref generics, _) => {\n                 let mut text = String::new();\n                 if header.constness.node == ast::Constness::Const {\n                     text.push_str(\"const \");"}, {"sha": "e6669e0d6edf270d9d62b4d7603241f7618673b0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/879abb1641d97be798010f52a875b9fc83881323/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879abb1641d97be798010f52a875b9fc83881323/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=879abb1641d97be798010f52a875b9fc83881323", "patch": "@@ -1849,31 +1849,48 @@ pub enum Unsafety {\n     Normal,\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub struct AsyncArgument {\n+    /// `__arg0`\n+    pub ident: Ident,\n+    /// `__arg0: <ty>` argument to replace existing function argument `<pat>: <ty>`.\n+    pub arg: Arg,\n+    /// `let <pat>: <ty> = __arg0;` statement to be inserted at the start of the block.\n+    pub stmt: Stmt,\n+}\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum IsAsync {\n     Async {\n         closure_id: NodeId,\n         return_impl_trait_id: NodeId,\n+        /// This field stores the arguments and statements that are used in HIR lowering to\n+        /// ensure that `async fn` arguments are dropped at the correct time.\n+        ///\n+        /// The argument and statements here are generated at parse time as they are required in\n+        /// both the hir lowering, def collection and name resolution and this stops them needing\n+        /// to be created in each place.\n+        arguments: Vec<AsyncArgument>,\n     },\n     NotAsync,\n }\n \n impl IsAsync {\n-    pub fn is_async(self) -> bool {\n-        if let IsAsync::Async { .. } = self {\n+    pub fn is_async(&self) -> bool {\n+        if let IsAsync::Async { .. } = *self {\n             true\n         } else {\n             false\n         }\n     }\n \n     /// In ths case this is an `async` return, the `NodeId` for the generated `impl Trait` item.\n-    pub fn opt_return_id(self) -> Option<NodeId> {\n+    pub fn opt_return_id(&self) -> Option<NodeId> {\n         match self {\n             IsAsync::Async {\n                 return_impl_trait_id,\n                 ..\n-            } => Some(return_impl_trait_id),\n+            } => Some(*return_impl_trait_id),\n             IsAsync::NotAsync => None,\n         }\n     }\n@@ -2213,7 +2230,7 @@ impl Item {\n ///\n /// All the information between the visibility and the name of the function is\n /// included in this struct (e.g., `async unsafe fn` or `const extern \"C\" fn`).\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub asyncness: Spanned<IsAsync>,"}, {"sha": "68cd3c28676f9cec9e9f5a6b5de9e9f327ff7ba6", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/879abb1641d97be798010f52a875b9fc83881323/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879abb1641d97be798010f52a875b9fc83881323/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=879abb1641d97be798010f52a875b9fc83881323", "patch": "@@ -102,6 +102,13 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n     fn remove(&mut self, id: ast::NodeId) -> AstFragment {\n         self.expanded_fragments.remove(&id).unwrap()\n     }\n+\n+    fn next_id(&mut self, id: &mut ast::NodeId) {\n+        if self.monotonic {\n+            assert_eq!(*id, ast::DUMMY_NODE_ID);\n+            *id = self.cx.resolver.next_node_id()\n+        }\n+    }\n }\n \n impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n@@ -183,9 +190,16 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n         noop_visit_block(block, self);\n \n         for stmt in block.stmts.iter_mut() {\n-            if self.monotonic {\n-                assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n-                stmt.id = self.cx.resolver.next_node_id();\n+            self.next_id(&mut stmt.id);\n+        }\n+    }\n+\n+    fn visit_asyncness(&mut self, a: &mut ast::IsAsync) {\n+        noop_visit_asyncness(a, self);\n+\n+        if let ast::IsAsync::Async { ref mut arguments, .. } = a {\n+            for argument in arguments.iter_mut() {\n+                self.next_id(&mut argument.stmt.id);\n             }\n         }\n     }"}, {"sha": "bb9116e678efc0aa5a0f467a66563c00f3a1b34c", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/879abb1641d97be798010f52a875b9fc83881323/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879abb1641d97be798010f52a875b9fc83881323/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=879abb1641d97be798010f52a875b9fc83881323", "patch": "@@ -679,9 +679,17 @@ pub fn noop_visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis:\n \n pub fn noop_visit_asyncness<T: MutVisitor>(asyncness: &mut IsAsync, vis: &mut T) {\n     match asyncness {\n-        IsAsync::Async { closure_id, return_impl_trait_id } => {\n+        IsAsync::Async { closure_id, return_impl_trait_id, ref mut arguments } => {\n             vis.visit_id(closure_id);\n             vis.visit_id(return_impl_trait_id);\n+            for AsyncArgument { ident, arg, stmt } in arguments.iter_mut() {\n+                vis.visit_ident(ident);\n+                vis.visit_arg(arg);\n+                visit_clobber(stmt, |stmt| {\n+                    vis.flat_map_stmt(stmt)\n+                        .expect_one(\"expected visitor to produce exactly one item\")\n+                });\n+            }\n         }\n         IsAsync::NotAsync => {}\n     }"}, {"sha": "26ede5a1057db2fe54072caca593eac1d751f433", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/879abb1641d97be798010f52a875b9fc83881323/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879abb1641d97be798010f52a875b9fc83881323/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=879abb1641d97be798010f52a875b9fc83881323", "patch": "@@ -1,4 +1,4 @@\n-use crate::ast::{AngleBracketedArgs, ParenthesizedArgs, AttrStyle, BareFnTy};\n+use crate::ast::{AngleBracketedArgs, AsyncArgument, ParenthesizedArgs, AttrStyle, BareFnTy};\n use crate::ast::{GenericBound, TraitBoundModifier};\n use crate::ast::Unsafety;\n use crate::ast::{Mod, AnonConst, Arg, Arm, Guard, Attribute, BindingMode, TraitItemKind};\n@@ -1517,6 +1517,7 @@ impl<'a> Parser<'a> {\n             IsAsync::Async {\n                 closure_id: ast::DUMMY_NODE_ID,\n                 return_impl_trait_id: ast::DUMMY_NODE_ID,\n+                arguments: Vec::new(),\n             }\n         } else {\n             IsAsync::NotAsync\n@@ -1575,7 +1576,7 @@ impl<'a> Parser<'a> {\n             // trait item macro.\n             (keywords::Invalid.ident(), ast::TraitItemKind::Macro(mac), ast::Generics::default())\n         } else {\n-            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n+            let (constness, unsafety, mut asyncness, abi) = self.parse_fn_front_matter()?;\n \n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n@@ -1589,6 +1590,7 @@ impl<'a> Parser<'a> {\n                 p.parse_arg_general(p.span.rust_2018(), true, false)\n             })?;\n             generics.where_clause = self.parse_where_clause()?;\n+            self.construct_async_arguments(&mut asyncness, &d);\n \n             let sig = ast::MethodSig {\n                 header: FnHeader {\n@@ -6567,7 +6569,7 @@ impl<'a> Parser<'a> {\n     /// Parses an item-position function declaration.\n     fn parse_item_fn(&mut self,\n                      unsafety: Unsafety,\n-                     asyncness: Spanned<IsAsync>,\n+                     mut asyncness: Spanned<IsAsync>,\n                      constness: Spanned<Constness>,\n                      abi: Abi)\n                      -> PResult<'a, ItemInfo> {\n@@ -6576,6 +6578,7 @@ impl<'a> Parser<'a> {\n         let decl = self.parse_fn_decl(allow_c_variadic)?;\n         generics.where_clause = self.parse_where_clause()?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+        self.construct_async_arguments(&mut asyncness, &decl);\n         let header = FnHeader { unsafety, asyncness, constness, abi };\n         Ok((ident, ItemKind::Fn(decl, header, generics, body), Some(inner_attrs)))\n     }\n@@ -6751,11 +6754,12 @@ impl<'a> Parser<'a> {\n             Ok((keywords::Invalid.ident(), vec![], ast::Generics::default(),\n                 ast::ImplItemKind::Macro(mac)))\n         } else {\n-            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n+            let (constness, unsafety, mut asyncness, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n             let decl = self.parse_fn_decl_with_self(|p| p.parse_arg())?;\n             generics.where_clause = self.parse_where_clause()?;\n+            self.construct_async_arguments(&mut asyncness, &decl);\n             *at_end = true;\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n             let header = ast::FnHeader { abi, unsafety, constness, asyncness };\n@@ -8177,6 +8181,7 @@ impl<'a> Parser<'a> {\n                                    respan(async_span, IsAsync::Async {\n                                        closure_id: ast::DUMMY_NODE_ID,\n                                        return_impl_trait_id: ast::DUMMY_NODE_ID,\n+                                       arguments: Vec::new(),\n                                    }),\n                                    respan(fn_span, Constness::NotConst),\n                                    Abi::Rust)?;\n@@ -8822,6 +8827,66 @@ impl<'a> Parser<'a> {\n             }\n         }\n     }\n+\n+    /// When lowering a `async fn` to the HIR, we need to move all of the arguments of the function\n+    /// into the generated closure so that they are dropped when the future is polled and not when\n+    /// it is created.\n+    ///\n+    /// The arguments of the function are replaced in HIR lowering with the arguments created by\n+    /// this function and the statements created here are inserted at the top of the closure body.\n+    fn construct_async_arguments(&mut self, asyncness: &mut Spanned<IsAsync>, decl: &FnDecl) {\n+        if let IsAsync::Async { ref mut arguments, .. } = asyncness.node {\n+            for (index, input) in decl.inputs.iter().enumerate() {\n+                let id = ast::DUMMY_NODE_ID;\n+                let span = input.pat.span;\n+\n+                // Construct a name for our temporary argument.\n+                let name = format!(\"__arg{}\", index);\n+                let ident = Ident::from_str(&name);\n+\n+                // Construct an argument representing `__argN: <ty>` to replace the argument of the\n+                // async function.\n+                let arg = Arg {\n+                    ty: input.ty.clone(),\n+                    id,\n+                    pat: P(Pat {\n+                        id,\n+                        node: PatKind::Ident(\n+                            BindingMode::ByValue(Mutability::Immutable), ident, None,\n+                        ),\n+                        span,\n+                    }),\n+                };\n+\n+                // Construct a `let <pat>: <ty> = __argN;` statement to insert at the top of the\n+                // async closure.\n+                let local = P(Local {\n+                    pat: input.pat.clone(),\n+                    ty: Some(P(Ty {\n+                        id,\n+                        node: input.ty.node.clone(),\n+                        span: input.ty.span,\n+                    })),\n+                    init: Some(P(Expr {\n+                        id,\n+                        node: ExprKind::Path(None, ast::Path {\n+                            span,\n+                            segments: vec![PathSegment { ident, id, args: None }],\n+                        }),\n+                        span,\n+                        attrs: ThinVec::new(),\n+                    })),\n+                    id,\n+                    span,\n+                    attrs: ThinVec::new(),\n+                    source: LocalSource::AsyncFn,\n+                });\n+                let stmt = Stmt { id, node: StmtKind::Local(local), span, };\n+\n+                arguments.push(AsyncArgument { ident, arg, stmt });\n+            }\n+        }\n+    }\n }\n \n pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, handler: &errors::Handler) {"}, {"sha": "d440a02f2fda670a5d3603f44807eb7e817136fd", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/879abb1641d97be798010f52a875b9fc83881323/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879abb1641d97be798010f52a875b9fc83881323/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=879abb1641d97be798010f52a875b9fc83881323", "patch": "@@ -372,7 +372,7 @@ pub fn vis_to_string(v: &ast::Visibility) -> String {\n }\n \n pub fn fun_to_string(decl: &ast::FnDecl,\n-                     header: ast::FnHeader,\n+                     header: &ast::FnHeader,\n                      name: ast::Ident,\n                      generics: &ast::Generics)\n                      -> String {\n@@ -1133,7 +1133,7 @@ impl<'a> State<'a> {\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 self.head(\"\")?;\n-                self.print_fn(decl, ast::FnHeader::default(),\n+                self.print_fn(decl, &ast::FnHeader::default(),\n                               Some(item.ident),\n                               generics, &item.vis)?;\n                 self.end()?; // end head-ibox\n@@ -1263,7 +1263,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            ast::ItemKind::Fn(ref decl, header, ref param_names, ref body) => {\n+            ast::ItemKind::Fn(ref decl, ref header, ref param_names, ref body) => {\n                 self.head(\"\")?;\n                 self.print_fn(\n                     decl,\n@@ -1615,7 +1615,7 @@ impl<'a> State<'a> {\n                             vis: &ast::Visibility)\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n-                      m.header,\n+                      &m.header,\n                       Some(ident),\n                       &generics,\n                       vis)\n@@ -2213,7 +2213,7 @@ impl<'a> State<'a> {\n                 self.bclose_(expr.span, INDENT_UNIT)?;\n             }\n             ast::ExprKind::Closure(\n-                capture_clause, asyncness, movability, ref decl, ref body, _) => {\n+                capture_clause, ref asyncness, movability, ref decl, ref body, _) => {\n                 self.print_movability(movability)?;\n                 self.print_asyncness(asyncness)?;\n                 self.print_capture_clause(capture_clause)?;\n@@ -2798,7 +2798,7 @@ impl<'a> State<'a> {\n \n     pub fn print_fn(&mut self,\n                     decl: &ast::FnDecl,\n-                    header: ast::FnHeader,\n+                    header: &ast::FnHeader,\n                     name: Option<ast::Ident>,\n                     generics: &ast::Generics,\n                     vis: &ast::Visibility) -> io::Result<()> {\n@@ -2853,8 +2853,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_asyncness(&mut self, asyncness: ast::IsAsync)\n-                                -> io::Result<()> {\n+    pub fn print_asyncness(&mut self, asyncness: &ast::IsAsync) -> io::Result<()> {\n         if asyncness.is_async() {\n             self.word_nbsp(\"async\")?;\n         }\n@@ -3126,7 +3125,7 @@ impl<'a> State<'a> {\n             span: syntax_pos::DUMMY_SP,\n         };\n         self.print_fn(decl,\n-                      ast::FnHeader { unsafety, abi, ..ast::FnHeader::default() },\n+                      &ast::FnHeader { unsafety, abi, ..ast::FnHeader::default() },\n                       name,\n                       &generics,\n                       &source_map::dummy_spanned(ast::VisibilityKind::Inherited))?;\n@@ -3189,7 +3188,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_header_info(&mut self,\n-                                header: ast::FnHeader,\n+                                header: &ast::FnHeader,\n                                 vis: &ast::Visibility) -> io::Result<()> {\n         self.s.word(visibility_qualified(vis, \"\"))?;\n \n@@ -3198,7 +3197,7 @@ impl<'a> State<'a> {\n             ast::Constness::Const => self.word_nbsp(\"const\")?\n         }\n \n-        self.print_asyncness(header.asyncness.node)?;\n+        self.print_asyncness(&header.asyncness.node)?;\n         self.print_unsafety(header.unsafety)?;\n \n         if header.abi != Abi::Rust {\n@@ -3247,7 +3246,7 @@ mod tests {\n             assert_eq!(\n                 fun_to_string(\n                     &decl,\n-                    ast::FnHeader {\n+                    &ast::FnHeader {\n                         unsafety: ast::Unsafety::Normal,\n                         constness: source_map::dummy_spanned(ast::Constness::NotConst),\n                         asyncness: source_map::dummy_spanned(ast::IsAsync::NotAsync),"}]}