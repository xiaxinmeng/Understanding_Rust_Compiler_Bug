{"sha": "50aee36d26dd78ddc78670b2ad63d276c5faa646", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwYWVlMzZkMjZkZDc4ZGRjNzg2NzBiMmFkNjNkMjc2YzVmYWE2NDY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-03-09T19:06:18Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-03-09T19:07:56Z"}, "message": "Propagate expected type hints through struct literals.", "tree": {"sha": "3b4592c619dbb193692ba4bd5468ab4c3b13eb2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b4592c619dbb193692ba4bd5468ab4c3b13eb2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50aee36d26dd78ddc78670b2ad63d276c5faa646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50aee36d26dd78ddc78670b2ad63d276c5faa646", "html_url": "https://github.com/rust-lang/rust/commit/50aee36d26dd78ddc78670b2ad63d276c5faa646", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50aee36d26dd78ddc78670b2ad63d276c5faa646/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7db40f23256c14f2ef6d43e3091135791e5e153", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7db40f23256c14f2ef6d43e3091135791e5e153", "html_url": "https://github.com/rust-lang/rust/commit/c7db40f23256c14f2ef6d43e3091135791e5e153"}], "stats": {"total": 49, "additions": 41, "deletions": 8}, "files": [{"sha": "f43dcefb84591aacfbebc5bb79545a0b493ac89e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/50aee36d26dd78ddc78670b2ad63d276c5faa646/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50aee36d26dd78ddc78670b2ad63d276c5faa646/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=50aee36d26dd78ddc78670b2ad63d276c5faa646", "patch": "@@ -3061,14 +3061,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_expr_struct_fields(&self,\n                                 adt_ty: Ty<'tcx>,\n+                                expected: Expectation<'tcx>,\n                                 expr_id: ast::NodeId,\n                                 span: Span,\n                                 variant: &'tcx ty::VariantDef,\n                                 ast_fields: &'gcx [hir::Field],\n                                 check_completeness: bool) {\n         let tcx = self.tcx;\n-        let (substs, adt_kind, kind_name) = match adt_ty.sty {\n-            ty::TyAdt(adt, substs) => (substs, adt.adt_kind(), adt.variant_descr()),\n+\n+        let adt_ty_hint =\n+            self.expected_inputs_for_expected_output(span, expected, adt_ty, &[adt_ty])\n+                .get(0).cloned().unwrap_or(adt_ty);\n+\n+        let (substs, hint_substs, adt_kind, kind_name) = match (&adt_ty.sty, &adt_ty_hint.sty) {\n+            (&ty::TyAdt(adt, substs), &ty::TyAdt(_, hint_substs)) => {\n+                (substs, hint_substs, adt.adt_kind(), adt.variant_descr())\n+            }\n             _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n         };\n \n@@ -3083,10 +3091,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Typecheck each field.\n         for field in ast_fields {\n-            let expected_field_type;\n+            let final_field_type;\n+            let field_type_hint;\n \n             if let Some(v_field) = remaining_fields.remove(&field.name.node) {\n-                expected_field_type = self.field_ty(field.span, v_field, substs);\n+                final_field_type = self.field_ty(field.span, v_field, substs);\n+                field_type_hint = self.field_ty(field.span, v_field, hint_substs);\n \n                 seen_fields.insert(field.name.node, field.span);\n \n@@ -3098,7 +3108,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             } else {\n                 error_happened = true;\n-                expected_field_type = tcx.types.err;\n+                final_field_type = tcx.types.err;\n+                field_type_hint = tcx.types.err;\n                 if let Some(_) = variant.find_field_named(field.name.node) {\n                     let mut err = struct_span_err!(self.tcx.sess,\n                                                 field.name.span,\n@@ -3120,7 +3131,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             // Make sure to give a type to the field even if there's\n             // an error, so we can continue typechecking\n-            self.check_expr_coercable_to_type(&field.expr, expected_field_type);\n+            let ty = self.check_expr_with_hint(&field.expr, field_type_hint);\n+            self.demand_coerce(&field.expr, ty, final_field_type);\n         }\n \n         // Make sure the programmer specified correct number of fields.\n@@ -3230,6 +3242,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_expr_struct(&self,\n                          expr: &hir::Expr,\n+                         expected: Expectation<'tcx>,\n                          qpath: &hir::QPath,\n                          fields: &'gcx [hir::Field],\n                          base_expr: &'gcx Option<P<hir::Expr>>) -> Ty<'tcx>\n@@ -3248,7 +3261,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::QPath::TypeRelative(ref qself, _) => qself.span\n         };\n \n-        self.check_expr_struct_fields(struct_ty, expr.id, path_span, variant, fields,\n+        self.check_expr_struct_fields(struct_ty, expected, expr.id, path_span, variant, fields,\n                                       base_expr.is_none());\n         if let &Some(ref base_expr) = base_expr {\n             self.check_expr_has_type(base_expr, struct_ty);\n@@ -3793,7 +3806,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n           }\n           hir::ExprStruct(ref qpath, ref fields, ref base_expr) => {\n-            self.check_expr_struct(expr, qpath, fields, base_expr)\n+            self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n           }\n           hir::ExprField(ref base, ref field) => {\n             self.check_field(expr, lvalue_pref, &base, field)"}, {"sha": "e771fc7464d00322eb20a142355f61b323a5750c", "filename": "src/test/run-pass/issue-31260.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/50aee36d26dd78ddc78670b2ad63d276c5faa646/src%2Ftest%2Frun-pass%2Fissue-31260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50aee36d26dd78ddc78670b2ad63d276c5faa646/src%2Ftest%2Frun-pass%2Fissue-31260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-31260.rs?ref=50aee36d26dd78ddc78670b2ad63d276c5faa646", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Struct<K: 'static> {\n+    pub field: K,\n+}\n+\n+// Partial fix for #31260, doesn't work without {...}.\n+static STRUCT: Struct<&'static [u8]> = Struct {\n+    field: {&[1]}\n+};\n+\n+fn main() {}"}]}