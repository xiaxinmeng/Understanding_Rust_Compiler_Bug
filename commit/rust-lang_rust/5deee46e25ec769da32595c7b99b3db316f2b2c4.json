{"sha": "5deee46e25ec769da32595c7b99b3db316f2b2c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZWVlNDZlMjVlYzc2OWRhMzI1OTVjN2I5OWIzZGIzMTZmMmIyYzQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-08-25T08:22:53Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-08-25T11:38:01Z"}, "message": "Rollup merge of #35947 - SimonSapin:decodeutf8-error-handling, r=alexcrichton\n\nYield Err in char::decode_utf8 per Unicode, like String::from_utf8_lossy\n\nr? @alexcrichton", "tree": {"sha": "e0d3d3ef31c07702cee786fc7ef4767ae3c00005", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0d3d3ef31c07702cee786fc7ef4767ae3c00005"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5deee46e25ec769da32595c7b99b3db316f2b2c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5deee46e25ec769da32595c7b99b3db316f2b2c4", "html_url": "https://github.com/rust-lang/rust/commit/5deee46e25ec769da32595c7b99b3db316f2b2c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5deee46e25ec769da32595c7b99b3db316f2b2c4/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7963bbb08421c4c5483a33e908ca9375d14c9217", "url": "https://api.github.com/repos/rust-lang/rust/commits/7963bbb08421c4c5483a33e908ca9375d14c9217", "html_url": "https://github.com/rust-lang/rust/commit/7963bbb08421c4c5483a33e908ca9375d14c9217"}, {"sha": "46226a7a6e967eaae297c462457df8f2db148565", "url": "https://api.github.com/repos/rust-lang/rust/commits/46226a7a6e967eaae297c462457df8f2db148565", "html_url": "https://github.com/rust-lang/rust/commit/46226a7a6e967eaae297c462457df8f2db148565"}], "stats": {"total": 151, "additions": 114, "deletions": 37}, "files": [{"sha": "f7d4993bee3b99ee04fcf8aef21e891963b845f6", "filename": "src/libcore/char.rs", "status": "modified", "additions": 69, "deletions": 13, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5deee46e25ec769da32595c7b99b3db316f2b2c4/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5deee46e25ec769da32595c7b99b3db316f2b2c4/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=5deee46e25ec769da32595c7b99b3db316f2b2c4", "patch": "@@ -752,25 +752,81 @@ pub struct InvalidSequence(());\n impl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n     type Item = Result<char, InvalidSequence>;\n     #[inline]\n+\n     fn next(&mut self) -> Option<Result<char, InvalidSequence>> {\n-        self.0.next().map(|b| {\n-            if b & 0x80 == 0 { Ok(b as char) } else {\n-                let l = (!b).leading_zeros() as usize; // number of bytes in UTF-8 representation\n-                if l < 2 || l > 6 { return Err(InvalidSequence(())) };\n-                let mut x = (b as u32) & (0x7F >> l);\n-                for _ in 0..l-1 {\n+        self.0.next().map(|first_byte| {\n+            // Emit InvalidSequence according to\n+            // Unicode \u00a75.22 Best Practice for U+FFFD Substitution\n+            // http://www.unicode.org/versions/Unicode9.0.0/ch05.pdf#G40630\n+\n+            // Roughly: consume at least one byte,\n+            // then validate one byte at a time and stop before the first unexpected byte\n+            // (which might be the valid start of the next byte sequence).\n+\n+            let mut code_point;\n+            macro_rules! first_byte {\n+                ($mask: expr) => {\n+                    code_point = u32::from(first_byte & $mask)\n+                }\n+            }\n+            macro_rules! continuation_byte {\n+                () => { continuation_byte!(0x80...0xBF) };\n+                ($range: pat) => {\n                     match self.0.peek() {\n-                        Some(&b) if b & 0xC0 == 0x80 => {\n+                        Some(&byte @ $range) => {\n+                            code_point = (code_point << 6) | u32::from(byte & 0b0011_1111);\n                             self.0.next();\n-                            x = (x << 6) | (b as u32) & 0x3F;\n-                        },\n-                        _ => return Err(InvalidSequence(())),\n+                        }\n+                        _ => return Err(InvalidSequence(()))\n                     }\n                 }\n-                match from_u32(x) {\n-                    Some(x) if l == x.len_utf8() => Ok(x),\n-                    _ => Err(InvalidSequence(())),\n+            }\n+\n+            match first_byte {\n+                0x00...0x7F => {\n+                    first_byte!(0b1111_1111);\n+                }\n+                0xC2...0xDF => {\n+                    first_byte!(0b0001_1111);\n+                    continuation_byte!();\n+                }\n+                0xE0 => {\n+                    first_byte!(0b0000_1111);\n+                    continuation_byte!(0xA0...0xBF);  // 0x80...0x9F here are overlong\n+                    continuation_byte!();\n                 }\n+                0xE1...0xEC | 0xEE...0xEF => {\n+                    first_byte!(0b0000_1111);\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                0xED => {\n+                    first_byte!(0b0000_1111);\n+                    continuation_byte!(0x80...0x9F);  // 0xA0..0xBF here are surrogates\n+                    continuation_byte!();\n+                }\n+                0xF0 => {\n+                    first_byte!(0b0000_0111);\n+                    continuation_byte!(0x90...0xBF);  // 0x80..0x8F here are overlong\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                0xF1...0xF3 => {\n+                    first_byte!(0b0000_0111);\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                0xF4 => {\n+                    first_byte!(0b0000_0111);\n+                    continuation_byte!(0x80...0x8F);  // 0x90..0xBF here are beyond char::MAX\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                _ => return Err(InvalidSequence(()))  // Illegal first byte, overlong, or beyond MAX\n+            }\n+            unsafe {\n+                Ok(from_u32_unchecked(code_point))\n             }\n         })\n     }"}, {"sha": "333503d738943b10cd74584cfb34c1119eed4579", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 45, "deletions": 24, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5deee46e25ec769da32595c7b99b3db316f2b2c4/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5deee46e25ec769da32595c7b99b3db316f2b2c4/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=5deee46e25ec769da32595c7b99b3db316f2b2c4", "patch": "@@ -358,29 +358,50 @@ fn eu_iterator_specializations() {\n \n #[test]\n fn test_decode_utf8() {\n-    use core::char::*;\n-    use core::iter::FromIterator;\n-\n-    for &(str, bs) in [(\"\", &[] as &[u8]),\n-                       (\"A\", &[0x41u8] as &[u8]),\n-                       (\"\ufffd\", &[0xC1u8, 0x81u8] as &[u8]),\n-                       (\"\u2665\", &[0xE2u8, 0x99u8, 0xA5u8]),\n-                       (\"\u2665A\", &[0xE2u8, 0x99u8, 0xA5u8, 0x41u8] as &[u8]),\n-                       (\"\ufffd\", &[0xE2u8, 0x99u8] as &[u8]),\n-                       (\"\ufffdA\", &[0xE2u8, 0x99u8, 0x41u8] as &[u8]),\n-                       (\"\ufffd\", &[0xC0u8] as &[u8]),\n-                       (\"\ufffdA\", &[0xC0u8, 0x41u8] as &[u8]),\n-                       (\"\ufffd\", &[0x80u8] as &[u8]),\n-                       (\"\ufffdA\", &[0x80u8, 0x41u8] as &[u8]),\n-                       (\"\ufffd\", &[0xFEu8] as &[u8]),\n-                       (\"\ufffdA\", &[0xFEu8, 0x41u8] as &[u8]),\n-                       (\"\ufffd\", &[0xFFu8] as &[u8]),\n-                       (\"\ufffdA\", &[0xFFu8, 0x41u8] as &[u8])].into_iter() {\n-        assert!(Iterator::eq(str.chars(),\n-                             decode_utf8(bs.into_iter().map(|&b|b))\n-                                 .map(|r_b| r_b.unwrap_or('\\u{FFFD}'))),\n-                \"chars = {}, bytes = {:?}, decoded = {:?}\", str, bs,\n-                Vec::from_iter(decode_utf8(bs.into_iter().map(|&b|b))\n-                                   .map(|r_b| r_b.unwrap_or('\\u{FFFD}'))));\n+    macro_rules! assert_decode_utf8 {\n+        ($input_bytes: expr, $expected_str: expr) => {\n+            let input_bytes: &[u8] = &$input_bytes;\n+            let s = char::decode_utf8(input_bytes.iter().cloned())\n+                .map(|r_b| r_b.unwrap_or('\\u{FFFD}'))\n+                .collect::<String>();\n+            assert_eq!(s, $expected_str,\n+                       \"input bytes: {:?}, expected str: {:?}, result: {:?}\",\n+                       input_bytes, $expected_str, s);\n+            assert_eq!(String::from_utf8_lossy(&$input_bytes), $expected_str);\n+        }\n     }\n+\n+    assert_decode_utf8!([], \"\");\n+    assert_decode_utf8!([0x41], \"A\");\n+    assert_decode_utf8!([0xC1, 0x81], \"\ufffd\ufffd\");\n+    assert_decode_utf8!([0xE2, 0x99, 0xA5], \"\u2665\");\n+    assert_decode_utf8!([0xE2, 0x99, 0xA5, 0x41], \"\u2665A\");\n+    assert_decode_utf8!([0xE2, 0x99], \"\ufffd\");\n+    assert_decode_utf8!([0xE2, 0x99, 0x41], \"\ufffdA\");\n+    assert_decode_utf8!([0xC0], \"\ufffd\");\n+    assert_decode_utf8!([0xC0, 0x41], \"\ufffdA\");\n+    assert_decode_utf8!([0x80], \"\ufffd\");\n+    assert_decode_utf8!([0x80, 0x41], \"\ufffdA\");\n+    assert_decode_utf8!([0xFE], \"\ufffd\");\n+    assert_decode_utf8!([0xFE, 0x41], \"\ufffdA\");\n+    assert_decode_utf8!([0xFF], \"\ufffd\");\n+    assert_decode_utf8!([0xFF, 0x41], \"\ufffdA\");\n+    assert_decode_utf8!([0xC0, 0x80], \"\ufffd\ufffd\");\n+\n+    // Surrogates\n+    assert_decode_utf8!([0xED, 0x9F, 0xBF], \"\\u{D7FF}\");\n+    assert_decode_utf8!([0xED, 0xA0, 0x80], \"\ufffd\ufffd\ufffd\");\n+    assert_decode_utf8!([0xED, 0xBF, 0x80], \"\ufffd\ufffd\ufffd\");\n+    assert_decode_utf8!([0xEE, 0x80, 0x80], \"\\u{E000}\");\n+\n+    // char::MAX\n+    assert_decode_utf8!([0xF4, 0x8F, 0xBF, 0xBF], \"\\u{10FFFF}\");\n+    assert_decode_utf8!([0xF4, 0x8F, 0xBF, 0x41], \"\ufffdA\");\n+    assert_decode_utf8!([0xF4, 0x90, 0x80, 0x80], \"\ufffd\ufffd\ufffd\ufffd\");\n+\n+    // 5 and 6 bytes sequence\n+    // Part of the original design of UTF-8,\n+    // but invalid now that UTF-8 is artificially restricted to match the range of UTF-16.\n+    assert_decode_utf8!([0xF8, 0x80, 0x80, 0x80, 0x80], \"\ufffd\ufffd\ufffd\ufffd\ufffd\");\n+    assert_decode_utf8!([0xFC, 0x80, 0x80, 0x80, 0x80, 0x80], \"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\");\n }"}]}