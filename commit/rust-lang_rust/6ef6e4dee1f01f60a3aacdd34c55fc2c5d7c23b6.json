{"sha": "6ef6e4dee1f01f60a3aacdd34c55fc2c5d7c23b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlZjZlNGRlZTFmMDFmNjBhM2FhY2RkMzRjNTVmYzJjNWQ3YzIzYjY=", "commit": {"author": {"name": "ivan770", "email": "leshenko.ivan770@gmail.com", "date": "2021-03-30T10:44:09Z"}, "committer": {"name": "ivan770", "email": "leshenko.ivan770@gmail.com", "date": "2021-03-30T10:44:09Z"}, "message": "Improved node lookup algorithm, added more movable nodes", "tree": {"sha": "3263b3dad958ac0002523471cc22be547430695b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3263b3dad958ac0002523471cc22be547430695b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ef6e4dee1f01f60a3aacdd34c55fc2c5d7c23b6", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCgAdFiEEcPkYW+t8+2SKgl5T2MS9WuTZzE0FAmBjAPkACgkQ2MS9WuTZ\nzE3t7gf+LFsppR8w80NQluSajHqbT2hvqBRczr52XIZwtJCpgWHG9m5kmat/hOEJ\n2yqPnOjTxSLcvdXga3Ch570pW5RvW0tfXeQkxc2JwkSSl9/E0fwmgrBGu4KpIyQU\ntX2j5IuEPZpKfenGYALiplANo0+YcMGUV3F/Kpfxa3g0CrNp+m7WX0gc2+LIcDQX\nxomNcn38Jc51pKkzUbePvKVvWX3ihV6R2A31z2qIf8hIvPEyR4GHHjMFAdarfafM\nM7waiw8pKALBIB3Kb0+nsMD3ynLYu9oOy11L135r8HJ0BY1usmufhEdLh4h/0Qei\nVZopQlrm/duIPZPcOdmUxu+msJn5Yw==\n=/jRA\n-----END PGP SIGNATURE-----", "payload": "tree 3263b3dad958ac0002523471cc22be547430695b\nparent 904bdff2241a54c6aebe0f6fd39e6560550a66b0\nauthor ivan770 <leshenko.ivan770@gmail.com> 1617101049 +0200\ncommitter ivan770 <leshenko.ivan770@gmail.com> 1617101049 +0200\n\nImproved node lookup algorithm, added more movable nodes\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ef6e4dee1f01f60a3aacdd34c55fc2c5d7c23b6", "html_url": "https://github.com/rust-lang/rust/commit/6ef6e4dee1f01f60a3aacdd34c55fc2c5d7c23b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ef6e4dee1f01f60a3aacdd34c55fc2c5d7c23b6/comments", "author": {"login": "ivan770", "id": 14003886, "node_id": "MDQ6VXNlcjE0MDAzODg2", "avatar_url": "https://avatars.githubusercontent.com/u/14003886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ivan770", "html_url": "https://github.com/ivan770", "followers_url": "https://api.github.com/users/ivan770/followers", "following_url": "https://api.github.com/users/ivan770/following{/other_user}", "gists_url": "https://api.github.com/users/ivan770/gists{/gist_id}", "starred_url": "https://api.github.com/users/ivan770/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ivan770/subscriptions", "organizations_url": "https://api.github.com/users/ivan770/orgs", "repos_url": "https://api.github.com/users/ivan770/repos", "events_url": "https://api.github.com/users/ivan770/events{/privacy}", "received_events_url": "https://api.github.com/users/ivan770/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ivan770", "id": 14003886, "node_id": "MDQ6VXNlcjE0MDAzODg2", "avatar_url": "https://avatars.githubusercontent.com/u/14003886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ivan770", "html_url": "https://github.com/ivan770", "followers_url": "https://api.github.com/users/ivan770/followers", "following_url": "https://api.github.com/users/ivan770/following{/other_user}", "gists_url": "https://api.github.com/users/ivan770/gists{/gist_id}", "starred_url": "https://api.github.com/users/ivan770/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ivan770/subscriptions", "organizations_url": "https://api.github.com/users/ivan770/orgs", "repos_url": "https://api.github.com/users/ivan770/repos", "events_url": "https://api.github.com/users/ivan770/events{/privacy}", "received_events_url": "https://api.github.com/users/ivan770/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "904bdff2241a54c6aebe0f6fd39e6560550a66b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/904bdff2241a54c6aebe0f6fd39e6560550a66b0", "html_url": "https://github.com/rust-lang/rust/commit/904bdff2241a54c6aebe0f6fd39e6560550a66b0"}], "stats": {"total": 267, "additions": 254, "deletions": 13}, "files": [{"sha": "089383aa639c7921e8b103bb5d07b386d53eb6db", "filename": "crates/ide/src/move_item.rs", "status": "modified", "additions": 254, "deletions": 13, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/6ef6e4dee1f01f60a3aacdd34c55fc2c5d7c23b6/crates%2Fide%2Fsrc%2Fmove_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef6e4dee1f01f60a3aacdd34c55fc2c5d7c23b6/crates%2Fide%2Fsrc%2Fmove_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmove_item.rs?ref=6ef6e4dee1f01f60a3aacdd34c55fc2c5d7c23b6", "patch": "@@ -4,10 +4,12 @@ use hir::Semantics;\n use ide_db::{base_db::FileRange, RootDatabase};\n use itertools::Itertools;\n use syntax::{\n-    algo, ast, match_ast, AstNode, NodeOrToken, SyntaxElement, SyntaxKind, SyntaxNode, TextRange,\n+    algo, ast, match_ast, AstNode, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange,\n+    TokenAtOffset,\n };\n use text_edit::{TextEdit, TextEditBuilder};\n \n+#[derive(Copy, Clone, Debug)]\n pub enum Direction {\n     Up,\n     Down,\n@@ -31,14 +33,19 @@ pub(crate) fn move_item(\n     let sema = Semantics::new(db);\n     let file = sema.parse(range.file_id);\n \n-    let item = file.syntax().covering_element(range.range);\n+    let item = if range.range.is_empty() {\n+        SyntaxElement::Token(pick_best(file.syntax().token_at_offset(range.range.start()))?)\n+    } else {\n+        file.syntax().covering_element(range.range)\n+    };\n+\n     find_ancestors(item, direction, range.range)\n }\n \n fn find_ancestors(item: SyntaxElement, direction: Direction, range: TextRange) -> Option<TextEdit> {\n     let root = match item {\n-        NodeOrToken::Node(node) => node,\n-        NodeOrToken::Token(token) => token.parent()?,\n+        SyntaxElement::Node(node) => node,\n+        SyntaxElement::Token(token) => token.parent()?,\n     };\n \n     let movable = [\n@@ -51,6 +58,11 @@ fn find_ancestors(item: SyntaxElement, direction: Direction, range: TextRange) -\n         SyntaxKind::PARAM,\n         SyntaxKind::LET_STMT,\n         SyntaxKind::EXPR_STMT,\n+        SyntaxKind::IF_EXPR,\n+        SyntaxKind::FOR_EXPR,\n+        SyntaxKind::LOOP_EXPR,\n+        SyntaxKind::WHILE_EXPR,\n+        SyntaxKind::RETURN_EXPR,\n         SyntaxKind::MATCH_EXPR,\n         SyntaxKind::MACRO_CALL,\n         SyntaxKind::TYPE_ALIAS,\n@@ -83,11 +95,11 @@ fn move_in_direction(\n ) -> Option<TextEdit> {\n     match_ast! {\n         match node {\n-            ast::ArgList(it) => swap_sibling_in_list(it.args(), range, direction),\n-            ast::GenericParamList(it) => swap_sibling_in_list(it.generic_params(), range, direction),\n-            ast::GenericArgList(it) => swap_sibling_in_list(it.generic_args(), range, direction),\n-            ast::VariantList(it) => swap_sibling_in_list(it.variants(), range, direction),\n-            ast::TypeBoundList(it) => swap_sibling_in_list(it.bounds(), range, direction),\n+            ast::ArgList(it) => swap_sibling_in_list(node, it.args(), range, direction),\n+            ast::GenericParamList(it) => swap_sibling_in_list(node, it.generic_params(), range, direction),\n+            ast::GenericArgList(it) => swap_sibling_in_list(node, it.generic_args(), range, direction),\n+            ast::VariantList(it) => swap_sibling_in_list(node, it.variants(), range, direction),\n+            ast::TypeBoundList(it) => swap_sibling_in_list(node, it.bounds(), range, direction),\n             _ => Some(replace_nodes(node, &match direction {\n                 Direction::Up => node.prev_sibling(),\n                 Direction::Down => node.next_sibling(),\n@@ -97,19 +109,27 @@ fn move_in_direction(\n }\n \n fn swap_sibling_in_list<A: AstNode + Clone, I: Iterator<Item = A>>(\n+    node: &SyntaxNode,\n     list: I,\n     range: TextRange,\n     direction: Direction,\n ) -> Option<TextEdit> {\n-    let (l, r) = list\n+    let list_lookup = list\n         .tuple_windows()\n         .filter(|(l, r)| match direction {\n             Direction::Up => r.syntax().text_range().contains_range(range),\n             Direction::Down => l.syntax().text_range().contains_range(range),\n         })\n-        .next()?;\n-\n-    Some(replace_nodes(l.syntax(), r.syntax()))\n+        .next();\n+\n+    if let Some((l, r)) = list_lookup {\n+        Some(replace_nodes(l.syntax(), r.syntax()))\n+    } else {\n+        // Cursor is beyond any movable list item (for example, on curly brace in enum).\n+        // It's not necessary, that parent of list is movable (arg list's parent is not, for example),\n+        // and we have to continue tree traversal to find suitable node.\n+        find_ancestors(SyntaxElement::Node(node.parent()?), direction, range)\n+    }\n }\n \n fn replace_nodes(first: &SyntaxNode, second: &SyntaxNode) -> TextEdit {\n@@ -121,6 +141,17 @@ fn replace_nodes(first: &SyntaxNode, second: &SyntaxNode) -> TextEdit {\n     edit.finish()\n }\n \n+fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n+    return tokens.max_by_key(priority);\n+    fn priority(n: &SyntaxToken) -> usize {\n+        match n.kind() {\n+            SyntaxKind::IDENT | SyntaxKind::LIFETIME_IDENT => 2,\n+            kind if kind.is_trivia() => 0,\n+            _ => 1,\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::fixture;\n@@ -260,6 +291,107 @@ fn main() {\n             expect![[r#\"\n fn main() {\n     println!(\"All I want to say is...\");\n+    println!(\"Hello, world\");\n+}\n+            \"#]],\n+            Direction::Up,\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    println!(\"Hello, world\");\n+\n+    if true {\n+        println!(\"Test\");\n+    }$0$0\n+}\n+            \"#,\n+            expect![[r#\"\n+fn main() {\n+    if true {\n+        println!(\"Test\");\n+    }\n+\n+    println!(\"Hello, world\");\n+}\n+            \"#]],\n+            Direction::Up,\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    println!(\"Hello, world\");\n+\n+    for i in 0..10 {\n+        println!(\"Test\");\n+    }$0$0\n+}\n+            \"#,\n+            expect![[r#\"\n+fn main() {\n+    for i in 0..10 {\n+        println!(\"Test\");\n+    }\n+\n+    println!(\"Hello, world\");\n+}\n+            \"#]],\n+            Direction::Up,\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    println!(\"Hello, world\");\n+\n+    loop {\n+        println!(\"Test\");\n+    }$0$0\n+}\n+            \"#,\n+            expect![[r#\"\n+fn main() {\n+    loop {\n+        println!(\"Test\");\n+    }\n+\n+    println!(\"Hello, world\");\n+}\n+            \"#]],\n+            Direction::Up,\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    println!(\"Hello, world\");\n+\n+    while true {\n+        println!(\"Test\");\n+    }$0$0\n+}\n+            \"#,\n+            expect![[r#\"\n+fn main() {\n+    while true {\n+        println!(\"Test\");\n+    }\n+\n+    println!(\"Hello, world\");\n+}\n+            \"#]],\n+            Direction::Up,\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    println!(\"Hello, world\");\n+\n+    return 123;$0$0\n+}\n+            \"#,\n+            expect![[r#\"\n+fn main() {\n+    return 123;\n+\n     println!(\"Hello, world\");\n }\n             \"#]],\n@@ -614,6 +746,115 @@ fn test() {\n         );\n     }\n \n+    #[test]\n+    fn test_cursor_at_item_start() {\n+        check(\n+            r#\"\n+$0$0#[derive(Debug)]\n+enum FooBar {\n+    Foo,\n+    Bar,\n+}\n+\n+fn main() {}\n+            \"#,\n+            expect![[r#\"\n+fn main() {}\n+\n+#[derive(Debug)]\n+enum FooBar {\n+    Foo,\n+    Bar,\n+}\n+            \"#]],\n+            Direction::Down,\n+        );\n+        check(\n+            r#\"\n+$0$0enum FooBar {\n+    Foo,\n+    Bar,\n+}\n+\n+fn main() {}\n+            \"#,\n+            expect![[r#\"\n+fn main() {}\n+\n+enum FooBar {\n+    Foo,\n+    Bar,\n+}\n+            \"#]],\n+            Direction::Down,\n+        );\n+        check(\n+            r#\"\n+struct Test;\n+\n+trait SomeTrait {}\n+\n+$0$0impl SomeTrait for Test {}\n+\n+fn main() {}\n+            \"#,\n+            expect![[r#\"\n+struct Test;\n+\n+impl SomeTrait for Test {}\n+\n+trait SomeTrait {}\n+\n+fn main() {}\n+            \"#]],\n+            Direction::Up,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_cursor_at_item_end() {\n+        check(\n+            r#\"\n+enum FooBar {\n+    Foo,\n+    Bar,\n+}$0$0\n+\n+fn main() {}\n+            \"#,\n+            expect![[r#\"\n+fn main() {}\n+\n+enum FooBar {\n+    Foo,\n+    Bar,\n+}\n+            \"#]],\n+            Direction::Down,\n+        );\n+        check(\n+            r#\"\n+struct Test;\n+\n+trait SomeTrait {}\n+\n+impl SomeTrait for Test {}$0$0\n+\n+fn main() {}\n+            \"#,\n+            expect![[r#\"\n+struct Test;\n+\n+impl SomeTrait for Test {}\n+\n+trait SomeTrait {}\n+\n+fn main() {}\n+            \"#]],\n+            Direction::Up,\n+        );\n+    }\n+\n     #[test]\n     fn handles_empty_file() {\n         check(r#\"$0$0\"#, expect![[r#\"\"#]], Direction::Up);"}]}