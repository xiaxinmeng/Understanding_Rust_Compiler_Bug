{"sha": "25d8a0a3514c3d8dd8362d0eb68272dc50168af3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZDhhMGEzNTE0YzNkOGRkODM2MmQwZWI2ODI3MmRjNTAxNjhhZjM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-17T07:39:25Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-17T09:56:57Z"}, "message": "warn about uninit bools and chars", "tree": {"sha": "2a7e284bd76c91627b466ba733213fe9e87c033b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a7e284bd76c91627b466ba733213fe9e87c033b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25d8a0a3514c3d8dd8362d0eb68272dc50168af3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25d8a0a3514c3d8dd8362d0eb68272dc50168af3", "html_url": "https://github.com/rust-lang/rust/commit/25d8a0a3514c3d8dd8362d0eb68272dc50168af3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25d8a0a3514c3d8dd8362d0eb68272dc50168af3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f7716d11bd7df5dbdffdd97a290c671ec1c54d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f7716d11bd7df5dbdffdd97a290c671ec1c54d5", "html_url": "https://github.com/rust-lang/rust/commit/5f7716d11bd7df5dbdffdd97a290c671ec1c54d5"}], "stats": {"total": 52, "additions": 45, "deletions": 7}, "files": [{"sha": "14bd9a381f0b3f603fb6ec40525df12b72c8f15c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a0a3514c3d8dd8362d0eb68272dc50168af3/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a0a3514c3d8dd8362d0eb68272dc50168af3/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=25d8a0a3514c3d8dd8362d0eb68272dc50168af3", "patch": "@@ -1876,7 +1876,7 @@ declare_lint_pass!(InvalidValue => [INVALID_VALUE]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &hir::Expr) {\n \n-        #[derive(Debug)]\n+        #[derive(Debug, Copy, Clone, PartialEq)]\n         enum InitKind { Zeroed, Uninit };\n \n         /// Determine if this expression is a \"dangerous initialization\".\n@@ -1911,14 +1911,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n \n         /// Return `Some` only if we are sure this type does *not*\n         /// allow zero initialization.\n-        fn ty_find_init_error<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<InitError> {\n+        fn ty_find_init_error<'tcx>(\n+            tcx: TyCtxt<'tcx>,\n+            ty: Ty<'tcx>,\n+            init: InitKind,\n+        ) -> Option<InitError> {\n             use rustc::ty::TyKind::*;\n             match ty.sty {\n                 // Primitive types that don't like 0 as a value.\n                 Ref(..) => Some((format!(\"References must be non-null\"), None)),\n                 Adt(..) if ty.is_box() => Some((format!(\"`Box` must be non-null\"), None)),\n                 FnPtr(..) => Some((format!(\"Function pointers must be non-null\"), None)),\n                 Never => Some((format!(\"The never type (`!`) has no valid value\"), None)),\n+                // Primitive types with other constraints\n+                Bool if init == InitKind::Uninit =>\n+                    Some((format!(\"Booleans must be `true` or `false`\"), None)),\n+                Char if init == InitKind::Uninit =>\n+                    Some((format!(\"Characters must be a valid unicode codepoint\"), None)),\n                 // Recurse for some compound types.\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n                     match adt_def.variants.len() {\n@@ -1931,6 +1940,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                                 ty_find_init_error(\n                                     tcx,\n                                     field.ty(tcx, substs),\n+                                    init,\n                                 ).map(|(mut msg, span)| if span.is_none() {\n                                     // Point to this field, should be helpful for figuring\n                                     // out where the source of the error is.\n@@ -1949,11 +1959,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                 }\n                 Tuple(..) => {\n                     // Proceed recursively, check all fields.\n-                    ty.tuple_fields().find_map(|field| ty_find_init_error(tcx, field))\n+                    ty.tuple_fields().find_map(|field| ty_find_init_error(tcx, field, init))\n                 }\n                 // FIXME: Would be nice to also warn for `NonNull`/`NonZero*`.\n-                // FIXME: *Only for `mem::uninitialized`*, we could also warn for `bool`,\n-                //        `char`, and any multivariant enum.\n+                // FIXME: *Only for `mem::uninitialized`*, we could also warn for multivariant enum.\n                 // Conservative fallback.\n                 _ => None,\n             }\n@@ -1964,7 +1973,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n             // using zeroed or uninitialized memory.\n             // We are extremely conservative with what we warn about.\n             let conjured_ty = cx.tables.expr_ty(expr);\n-            if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty) {\n+            if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty, init) {\n                 let mut err = cx.struct_span_lint(\n                     INVALID_VALUE,\n                     expr.span,"}, {"sha": "aafc8507af61684f5f41ba88893fec26e8f017c8", "filename": "src/test/ui/lint/uninitialized-zeroed.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a0a3514c3d8dd8362d0eb68272dc50168af3/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a0a3514c3d8dd8362d0eb68272dc50168af3/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs?ref=25d8a0a3514c3d8dd8362d0eb68272dc50168af3", "patch": "@@ -56,6 +56,9 @@ fn main() {\n         let _val: Wrap<(RefPair, i32)> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: Wrap<(RefPair, i32)> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: bool = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+        let _val: Wrap<char> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         // Some types that should work just fine.\n         let _val: Option<&'static i32> = mem::zeroed();\n         let _val: Option<fn()> = mem::zeroed();"}, {"sha": "d8a4bf0b04953255d14b3097678d60f1910bc524", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a0a3514c3d8dd8362d0eb68272dc50168af3/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a0a3514c3d8dd8362d0eb68272dc50168af3/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=25d8a0a3514c3d8dd8362d0eb68272dc50168af3", "patch": "@@ -285,5 +285,31 @@ note: References must be non-null (in this struct field)\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 22 previous errors\n+error: the type `bool` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:59:26\n+   |\n+LL |         let _val: bool = mem::uninitialized();\n+   |                          ^^^^^^^^^^^^^^^^^^^^\n+   |                          |\n+   |                          this code causes undefined behavior when executed\n+   |                          help: use `MaybeUninit<T>` instead\n+   |\n+   = note: Booleans must be `true` or `false`\n+\n+error: the type `Wrap<char>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:60:32\n+   |\n+LL |         let _val: Wrap<char> = mem::uninitialized();\n+   |                                ^^^^^^^^^^^^^^^^^^^^\n+   |                                |\n+   |                                this code causes undefined behavior when executed\n+   |                                help: use `MaybeUninit<T>` instead\n+   |\n+note: Characters must be a valid unicode codepoint (in this struct field)\n+  --> $DIR/uninitialized-zeroed.rs:16:18\n+   |\n+LL | struct Wrap<T> { wrapped: T }\n+   |                  ^^^^^^^^^^\n+\n+error: aborting due to 24 previous errors\n "}]}