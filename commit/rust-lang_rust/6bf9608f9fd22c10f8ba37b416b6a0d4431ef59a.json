{"sha": "6bf9608f9fd22c10f8ba37b416b6a0d4431ef59a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZjk2MDhmOWZkMjJjMTBmOGJhMzdiNDE2YjZhMGQ0NDMxZWY1OWE=", "commit": {"author": {"name": "C", "email": "DeveloperC@protonmail.com", "date": "2020-12-05T00:12:42Z"}, "committer": {"name": "C", "email": "DeveloperC@protonmail.com", "date": "2020-12-29T14:03:29Z"}, "message": "refactor: moving Drain into drain.rs", "tree": {"sha": "23e9a39063991000f37760c9a8a575df35d8779f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23e9a39063991000f37760c9a8a575df35d8779f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bf9608f9fd22c10f8ba37b416b6a0d4431ef59a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bf9608f9fd22c10f8ba37b416b6a0d4431ef59a", "html_url": "https://github.com/rust-lang/rust/commit/6bf9608f9fd22c10f8ba37b416b6a0d4431ef59a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bf9608f9fd22c10f8ba37b416b6a0d4431ef59a/comments", "author": {"login": "DeveloperC286", "id": 65925405, "node_id": "MDQ6VXNlcjY1OTI1NDA1", "avatar_url": "https://avatars.githubusercontent.com/u/65925405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DeveloperC286", "html_url": "https://github.com/DeveloperC286", "followers_url": "https://api.github.com/users/DeveloperC286/followers", "following_url": "https://api.github.com/users/DeveloperC286/following{/other_user}", "gists_url": "https://api.github.com/users/DeveloperC286/gists{/gist_id}", "starred_url": "https://api.github.com/users/DeveloperC286/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DeveloperC286/subscriptions", "organizations_url": "https://api.github.com/users/DeveloperC286/orgs", "repos_url": "https://api.github.com/users/DeveloperC286/repos", "events_url": "https://api.github.com/users/DeveloperC286/events{/privacy}", "received_events_url": "https://api.github.com/users/DeveloperC286/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DeveloperC286", "id": 65925405, "node_id": "MDQ6VXNlcjY1OTI1NDA1", "avatar_url": "https://avatars.githubusercontent.com/u/65925405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DeveloperC286", "html_url": "https://github.com/DeveloperC286", "followers_url": "https://api.github.com/users/DeveloperC286/followers", "following_url": "https://api.github.com/users/DeveloperC286/following{/other_user}", "gists_url": "https://api.github.com/users/DeveloperC286/gists{/gist_id}", "starred_url": "https://api.github.com/users/DeveloperC286/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DeveloperC286/subscriptions", "organizations_url": "https://api.github.com/users/DeveloperC286/orgs", "repos_url": "https://api.github.com/users/DeveloperC286/repos", "events_url": "https://api.github.com/users/DeveloperC286/events{/privacy}", "received_events_url": "https://api.github.com/users/DeveloperC286/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17593f258b5bc8a4778df35bf9a82950738b70e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/17593f258b5bc8a4778df35bf9a82950738b70e8", "html_url": "https://github.com/rust-lang/rust/commit/17593f258b5bc8a4778df35bf9a82950738b70e8"}], "stats": {"total": 309, "additions": 162, "deletions": 147}, "files": [{"sha": "e61f17a1c301811c58789f9a09f4bef2fe73f860", "filename": "library/alloc/src/vec/drain.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/6bf9608f9fd22c10f8ba37b416b6a0d4431ef59a/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf9608f9fd22c10f8ba37b416b6a0d4431ef59a/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs?ref=6bf9608f9fd22c10f8ba37b416b6a0d4431ef59a", "patch": "@@ -0,0 +1,157 @@\n+use crate::alloc::{Allocator, Global};\n+use core::iter::{\n+    FusedIterator, TrustedLen,\n+};\n+use core::mem::{self};\n+use core::ptr::{self, NonNull};\n+use core::slice::{self};\n+use core::fmt;\n+\n+use super::{Vec};\n+\n+/// A draining iterator for `Vec<T>`.\n+///\n+/// This `struct` is created by [`Vec::drain`].\n+/// See its documentation for more.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let mut v = vec![0, 1, 2];\n+/// let iter: std::vec::Drain<_> = v.drain(..);\n+/// ```\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+pub struct Drain<\n+    'a,\n+    T: 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + 'a = Global,\n+> {\n+    /// Index of tail to preserve\n+    pub(super) tail_start: usize,\n+    /// Length of tail\n+    pub(super) tail_len: usize,\n+    /// Current remaining range to remove\n+    pub(super) iter: slice::Iter<'a, T>,\n+    pub(super) vec: NonNull<Vec<T, A>>,\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, T, A> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"Drain\").field(&self.iter.as_slice()).finish()\n+    }\n+}\n+\n+impl<'a, T, A: Allocator> Drain<'a, T, A> {\n+    /// Returns the remaining items of this iterator as a slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut vec = vec!['a', 'b', 'c'];\n+    /// let mut drain = vec.drain(..);\n+    /// assert_eq!(drain.as_slice(), &['a', 'b', 'c']);\n+    /// let _ = drain.next().unwrap();\n+    /// assert_eq!(drain.as_slice(), &['b', 'c']);\n+    /// ```\n+    #[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        self.iter.as_slice()\n+    }\n+\n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn allocator(&self) -> &A {\n+        unsafe { self.vec.as_ref().allocator() }\n+    }\n+}\n+\n+#[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n+impl<'a, T, A: Allocator> AsRef<[T]> for Drain<'a, T, A> {\n+    fn as_ref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+unsafe impl<T: Sync, A: Sync + Allocator> Sync for Drain<'_, T, A> {}\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+unsafe impl<T: Send, A: Send + Allocator> Send for Drain<'_, T, A> {}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const _) })\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T, A: Allocator> DoubleEndedIterator for Drain<'_, T, A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n+    fn drop(&mut self) {\n+        /// Continues dropping the remaining elements in the `Drain`, then moves back the\n+        /// un-`Drain`ed elements to restore the original `Vec`.\n+        struct DropGuard<'r, 'a, T, A: Allocator>(&'r mut Drain<'a, T, A>);\n+\n+        impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n+            fn drop(&mut self) {\n+                // Continue the same loop we have below. If the loop already finished, this does\n+                // nothing.\n+                self.0.for_each(drop);\n+\n+                if self.0.tail_len > 0 {\n+                    unsafe {\n+                        let source_vec = self.0.vec.as_mut();\n+                        // memmove back untouched tail, update to new length\n+                        let start = source_vec.len();\n+                        let tail = self.0.tail_start;\n+                        if tail != start {\n+                            let src = source_vec.as_ptr().add(tail);\n+                            let dst = source_vec.as_mut_ptr().add(start);\n+                            ptr::copy(src, dst, self.0.tail_len);\n+                        }\n+                        source_vec.set_len(start + self.0.tail_len);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // exhaust self first\n+        while let Some(item) = self.next() {\n+            let guard = DropGuard(self);\n+            drop(item);\n+            mem::forget(guard);\n+        }\n+\n+        // Drop a `DropGuard` to move back the non-drained tail of `self`.\n+        DropGuard(self);\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T, A: Allocator> ExactSizeIterator for Drain<'_, T, A> {\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T, A: Allocator> TrustedLen for Drain<'_, T, A> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T, A: Allocator> FusedIterator for Drain<'_, T, A> {}"}, {"sha": "1553e367c87ecf5c8d5c2500f19ab7e5d030c2ee", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 5, "deletions": 147, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/6bf9608f9fd22c10f8ba37b416b6a0d4431ef59a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf9608f9fd22c10f8ba37b416b6a0d4431ef59a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=6bf9608f9fd22c10f8ba37b416b6a0d4431ef59a", "patch": "@@ -84,6 +84,11 @@ pub use self::splice::Splice;\n \n mod splice;\n \n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+pub use self::drain::Drain;\n+\n+mod drain;\n+\n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n /// # Examples\n@@ -3320,150 +3325,3 @@ impl<T> AsIntoIter for IntoIter<T> {\n         self\n     }\n }\n-\n-/// A draining iterator for `Vec<T>`.\n-///\n-/// This `struct` is created by [`Vec::drain`].\n-/// See its documentation for more.\n-///\n-/// # Example\n-///\n-/// ```\n-/// let mut v = vec![0, 1, 2];\n-/// let iter: std::vec::Drain<_> = v.drain(..);\n-/// ```\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-pub struct Drain<\n-    'a,\n-    T: 'a,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + 'a = Global,\n-> {\n-    /// Index of tail to preserve\n-    tail_start: usize,\n-    /// Length of tail\n-    tail_len: usize,\n-    /// Current remaining range to remove\n-    iter: slice::Iter<'a, T>,\n-    vec: NonNull<Vec<T, A>>,\n-}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, T, A> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Drain\").field(&self.iter.as_slice()).finish()\n-    }\n-}\n-\n-impl<'a, T, A: Allocator> Drain<'a, T, A> {\n-    /// Returns the remaining items of this iterator as a slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut vec = vec!['a', 'b', 'c'];\n-    /// let mut drain = vec.drain(..);\n-    /// assert_eq!(drain.as_slice(), &['a', 'b', 'c']);\n-    /// let _ = drain.next().unwrap();\n-    /// assert_eq!(drain.as_slice(), &['b', 'c']);\n-    /// ```\n-    #[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n-    pub fn as_slice(&self) -> &[T] {\n-        self.iter.as_slice()\n-    }\n-\n-    /// Returns a reference to the underlying allocator.\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[inline]\n-    pub fn allocator(&self) -> &A {\n-        unsafe { self.vec.as_ref().allocator() }\n-    }\n-}\n-\n-#[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n-impl<'a, T, A: Allocator> AsRef<[T]> for Drain<'a, T, A> {\n-    fn as_ref(&self) -> &[T] {\n-        self.as_slice()\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Sync, A: Sync + Allocator> Sync for Drain<'_, T, A> {}\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Send, A: Send + Allocator> Send for Drain<'_, T, A> {}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<T> {\n-        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const _) })\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: Allocator> DoubleEndedIterator for Drain<'_, T, A> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<T> {\n-        self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n-    fn drop(&mut self) {\n-        /// Continues dropping the remaining elements in the `Drain`, then moves back the\n-        /// un-`Drain`ed elements to restore the original `Vec`.\n-        struct DropGuard<'r, 'a, T, A: Allocator>(&'r mut Drain<'a, T, A>);\n-\n-        impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n-            fn drop(&mut self) {\n-                // Continue the same loop we have below. If the loop already finished, this does\n-                // nothing.\n-                self.0.for_each(drop);\n-\n-                if self.0.tail_len > 0 {\n-                    unsafe {\n-                        let source_vec = self.0.vec.as_mut();\n-                        // memmove back untouched tail, update to new length\n-                        let start = source_vec.len();\n-                        let tail = self.0.tail_start;\n-                        if tail != start {\n-                            let src = source_vec.as_ptr().add(tail);\n-                            let dst = source_vec.as_mut_ptr().add(start);\n-                            ptr::copy(src, dst, self.0.tail_len);\n-                        }\n-                        source_vec.set_len(start + self.0.tail_len);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // exhaust self first\n-        while let Some(item) = self.next() {\n-            let guard = DropGuard(self);\n-            drop(item);\n-            mem::forget(guard);\n-        }\n-\n-        // Drop a `DropGuard` to move back the non-drained tail of `self`.\n-        DropGuard(self);\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: Allocator> ExactSizeIterator for Drain<'_, T, A> {\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T, A: Allocator> TrustedLen for Drain<'_, T, A> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T, A: Allocator> FusedIterator for Drain<'_, T, A> {}"}]}