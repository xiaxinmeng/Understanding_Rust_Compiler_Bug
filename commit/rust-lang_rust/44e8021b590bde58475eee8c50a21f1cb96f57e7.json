{"sha": "44e8021b590bde58475eee8c50a21f1cb96f57e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0ZTgwMjFiNTkwYmRlNTg0NzVlZWU4YzUwYTIxZjFjYjk2ZjU3ZTc=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-04T04:26:11Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-08T19:06:21Z"}, "message": "Even more fallout, this time in std::str\n\n- StrSlice.to_utf16() now returns a Vec<u8>.\n- Other miscellaneous fallout in std::str.", "tree": {"sha": "fc27afa9753555673675c2d1affe52259a86f24c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc27afa9753555673675c2d1affe52259a86f24c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44e8021b590bde58475eee8c50a21f1cb96f57e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44e8021b590bde58475eee8c50a21f1cb96f57e7", "html_url": "https://github.com/rust-lang/rust/commit/44e8021b590bde58475eee8c50a21f1cb96f57e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44e8021b590bde58475eee8c50a21f1cb96f57e7/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e42fde4e7a9e09660628ca4b5a9984b82c67fed", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e42fde4e7a9e09660628ca4b5a9984b82c67fed", "html_url": "https://github.com/rust-lang/rust/commit/8e42fde4e7a9e09660628ca4b5a9984b82c67fed"}], "stats": {"total": 177, "additions": 85, "deletions": 92}, "files": [{"sha": "e1dd4a139102576e16608c8556fa894a748efa9b", "filename": "src/libstd/str.rs", "status": "modified", "additions": 85, "deletions": 92, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/44e8021b590bde58475eee8c50a21f1cb96f57e7/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e8021b590bde58475eee8c50a21f1cb96f57e7/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=44e8021b590bde58475eee8c50a21f1cb96f57e7", "patch": "@@ -87,7 +87,7 @@ use iter::{Iterator, range, AdditiveIterator};\n use option::{None, Option, Some};\n use ptr;\n use from_str::FromStr;\n-use slice::{OwnedVector, ImmutableVector, MutableVector};\n+use slice::{OwnedVector, ImmutableVector, MutableVector, CloneableVector};\n use slice::{Vector};\n use vec::Vec;\n use default::Default;\n@@ -674,19 +674,17 @@ pub mod raw {\n     use ptr;\n     use slice::{MutableVector, OwnedVector, Vector};\n     use str::{is_utf8};\n-    use vec::Vec;\n \n     pub use core::str::raw::{from_utf8, c_str_to_static_slice, slice_bytes};\n     pub use core::str::raw::{slice_unchecked};\n \n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n-        let mut v = Vec::with_capacity(len);\n-        ptr::copy_memory(v.as_mut_ptr(), buf, len);\n-        v.set_len(len);\n-\n-        assert!(is_utf8(v.as_slice()));\n-        ::cast::transmute(v.move_iter().collect::<~[u8]>())\n+        let v = Slice { data: buf, len: len };\n+        let bytes: &[u8] = ::cast::transmute(v);\n+        assert!(is_utf8(bytes));\n+        let s: &str = ::cast::transmute(bytes);\n+        s.to_owned()\n     }\n \n     #[lang=\"strdup_uniq\"]\n@@ -824,27 +822,21 @@ pub trait StrAllocating: Str {\n     /// Copy a slice into a new owned str.\n     #[inline]\n     fn to_owned(&self) -> ~str {\n-        let me = self.as_slice();\n-        let len = me.len();\n         unsafe {\n-            let mut v = Vec::with_capacity(len);\n-\n-            ptr::copy_memory(v.as_mut_ptr(), me.as_ptr(), len);\n-            v.set_len(len);\n-            ::cast::transmute(v.move_iter().collect::<~[u8]>())\n+            ::cast::transmute(self.as_bytes().to_owned())\n         }\n     }\n \n     /// Converts to a vector of `u16` encoded as UTF-16.\n-    fn to_utf16(&self) -> ~[u16] {\n+    fn to_utf16(&self) -> Vec<u16> {\n         let me = self.as_slice();\n-        let mut u = Vec::new();;\n+        let mut u = Vec::new();\n         for ch in me.chars() {\n             let mut buf = [0u16, ..2];\n             let n = ch.encode_utf16(buf /* as mut slice! */);\n             u.push_all(buf.slice_to(n));\n         }\n-        u.move_iter().collect()\n+        u\n     }\n \n     /// Given a string, make a new string with repeated copies of it.\n@@ -1554,7 +1546,8 @@ mod tests {\n         assert_eq!(a.subslice_offset(c), 0);\n \n         let string = \"a\\nb\\nc\";\n-        let lines: ~[&str] = string.lines().collect();\n+        let lines: Vec<&str> = string.lines().collect();\n+        let lines = lines.as_slice();\n         assert_eq!(string.subslice_offset(lines[0]), 0);\n         assert_eq!(string.subslice_offset(lines[1]), 2);\n         assert_eq!(string.subslice_offset(lines[2]), 4);\n@@ -1617,21 +1610,21 @@ mod tests {\n     fn test_utf16() {\n         let pairs =\n             [(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\".to_owned(),\n-              box [0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n+              vec![0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n                 0xd800_u16, 0xdf3b_u16, 0xd800_u16, 0xdf46_u16,\n                 0xd800_u16, 0xdf39_u16, 0xd800_u16, 0xdf3b_u16,\n                 0xd800_u16, 0xdf30_u16, 0x000a_u16]),\n \n              (\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\".to_owned(),\n-              box [0xd801_u16, 0xdc12_u16, 0xd801_u16,\n+              vec![0xd801_u16, 0xdc12_u16, 0xd801_u16,\n                 0xdc49_u16, 0xd801_u16, 0xdc2e_u16, 0xd801_u16,\n                 0xdc40_u16, 0xd801_u16, 0xdc32_u16, 0xd801_u16,\n                 0xdc4b_u16, 0x0020_u16, 0xd801_u16, 0xdc0f_u16,\n                 0xd801_u16, 0xdc32_u16, 0xd801_u16, 0xdc4d_u16,\n                 0x000a_u16]),\n \n              (\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\".to_owned(),\n-              box [0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n+              vec![0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n                 0xd800_u16, 0xdf0b_u16, 0xd800_u16, 0xdf04_u16,\n                 0xd800_u16, 0xdf11_u16, 0xd800_u16, 0xdf09_u16,\n                 0x00b7_u16, 0xd800_u16, 0xdf0c_u16, 0xd800_u16,\n@@ -1640,7 +1633,7 @@ mod tests {\n                 0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]),\n \n              (\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\".to_owned(),\n-              box [0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n+              vec![0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n                 0xd801_u16, 0xdc88_u16, 0xd801_u16, 0xdc91_u16,\n                 0xd801_u16, 0xdc9b_u16, 0xd801_u16, 0xdc92_u16,\n                 0x0020_u16, 0xd801_u16, 0xdc95_u16, 0xd801_u16,\n@@ -1653,18 +1646,18 @@ mod tests {\n                 0x000a_u16 ]),\n              // Issue #12318, even-numbered non-BMP planes\n              (\"\\U00020000\".to_owned(),\n-              box [0xD840, 0xDC00])];\n+              vec![0xD840, 0xDC00])];\n \n         for p in pairs.iter() {\n             let (s, u) = (*p).clone();\n-            assert!(is_utf16(u));\n+            assert!(is_utf16(u.as_slice()));\n             assert_eq!(s.to_utf16(), u);\n \n-            assert_eq!(from_utf16(u).unwrap(), s);\n-            assert_eq!(from_utf16_lossy(u), s);\n+            assert_eq!(from_utf16(u.as_slice()).unwrap(), s);\n+            assert_eq!(from_utf16_lossy(u.as_slice()), s);\n \n-            assert_eq!(from_utf16(s.to_utf16()).unwrap(), s);\n-            assert_eq!(from_utf16(u).unwrap().to_utf16(), u);\n+            assert_eq!(from_utf16(s.to_utf16().as_slice()).unwrap(), s);\n+            assert_eq!(from_utf16(u.as_slice()).unwrap().to_utf16(), u);\n         }\n     }\n \n@@ -1921,105 +1914,105 @@ mod tests {\n     fn test_split_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let split: ~[&str] = data.split(' ').collect();\n-        assert_eq!( split, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        let split: Vec<&str> = data.split(' ').collect();\n+        assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.split(' ').rev().collect();\n+        let mut rsplit: Vec<&str> = data.split(' ').rev().collect();\n         rsplit.reverse();\n-        assert_eq!(rsplit, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let split: ~[&str] = data.split(|c: char| c == ' ').collect();\n-        assert_eq!( split, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        let split: Vec<&str> = data.split(|c: char| c == ' ').collect();\n+        assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.split(|c: char| c == ' ').rev().collect();\n+        let mut rsplit: Vec<&str> = data.split(|c: char| c == ' ').rev().collect();\n         rsplit.reverse();\n-        assert_eq!(rsplit, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         // Unicode\n-        let split: ~[&str] = data.split('\u00e4').collect();\n-        assert_eq!( split, box [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        let split: Vec<&str> = data.split('\u00e4').collect();\n+        assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.split('\u00e4').rev().collect();\n+        let mut rsplit: Vec<&str> = data.split('\u00e4').rev().collect();\n         rsplit.reverse();\n-        assert_eq!(rsplit, box [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let split: ~[&str] = data.split(|c: char| c == '\u00e4').collect();\n-        assert_eq!( split, box [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        let split: Vec<&str> = data.split(|c: char| c == '\u00e4').collect();\n+        assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.split(|c: char| c == '\u00e4').rev().collect();\n+        let mut rsplit: Vec<&str> = data.split(|c: char| c == '\u00e4').rev().collect();\n         rsplit.reverse();\n-        assert_eq!(rsplit, box [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n     }\n \n     #[test]\n     fn test_splitn_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let split: ~[&str] = data.splitn(' ', 3).collect();\n-        assert_eq!(split, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        let split: Vec<&str> = data.splitn(' ', 3).collect();\n+        assert_eq!(split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n-        let split: ~[&str] = data.splitn(|c: char| c == ' ', 3).collect();\n-        assert_eq!(split, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        let split: Vec<&str> = data.splitn(|c: char| c == ' ', 3).collect();\n+        assert_eq!(split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n         // Unicode\n-        let split: ~[&str] = data.splitn('\u00e4', 3).collect();\n-        assert_eq!(split, box [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        let split: Vec<&str> = data.splitn('\u00e4', 3).collect();\n+        assert_eq!(split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n-        let split: ~[&str] = data.splitn(|c: char| c == '\u00e4', 3).collect();\n-        assert_eq!(split, box [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        let split: Vec<&str> = data.splitn(|c: char| c == '\u00e4', 3).collect();\n+        assert_eq!(split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n     }\n \n     #[test]\n     fn test_rsplitn_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let mut split: ~[&str] = data.rsplitn(' ', 3).collect();\n+        let mut split: Vec<&str> = data.rsplitn(' ', 3).collect();\n         split.reverse();\n-        assert_eq!(split, box [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let mut split: ~[&str] = data.rsplitn(|c: char| c == ' ', 3).collect();\n+        let mut split: Vec<&str> = data.rsplitn(|c: char| c == ' ', 3).collect();\n         split.reverse();\n-        assert_eq!(split, box [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         // Unicode\n-        let mut split: ~[&str] = data.rsplitn('\u00e4', 3).collect();\n+        let mut split: Vec<&str> = data.rsplitn('\u00e4', 3).collect();\n         split.reverse();\n-        assert_eq!(split, box [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let mut split: ~[&str] = data.rsplitn(|c: char| c == '\u00e4', 3).collect();\n+        let mut split: Vec<&str> = data.rsplitn(|c: char| c == '\u00e4', 3).collect();\n         split.reverse();\n-        assert_eq!(split, box [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n     }\n \n     #[test]\n     fn test_split_char_iterator_no_trailing() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let split: ~[&str] = data.split('\\n').collect();\n-        assert_eq!(split, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+        let split: Vec<&str> = data.split('\\n').collect();\n+        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n \n-        let split: ~[&str] = data.split_terminator('\\n').collect();\n-        assert_eq!(split, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+        let split: Vec<&str> = data.split_terminator('\\n').collect();\n+        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]\n     fn test_rev_split_char_iterator_no_trailing() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-        let mut split: ~[&str] = data.split('\\n').rev().collect();\n+        let mut split: Vec<&str> = data.split('\\n').rev().collect();\n         split.reverse();\n-        assert_eq!(split, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n \n-        let mut split: ~[&str] = data.split_terminator('\\n').rev().collect();\n+        let mut split: Vec<&str> = data.split_terminator('\\n').rev().collect();\n         split.reverse();\n-        assert_eq!(split, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]\n     fn test_words() {\n         let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n-        let words: ~[&str] = data.words().collect();\n-        assert_eq!(words, box [\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n+        let words: Vec<&str> = data.words().collect();\n+        assert_eq!(words, vec![\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n     }\n \n     #[test]\n@@ -2053,34 +2046,34 @@ mod tests {\n     #[test]\n     fn test_lines() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-        let lines: ~[&str] = data.lines().collect();\n-        assert_eq!(lines, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+        let lines: Vec<&str> = data.lines().collect();\n+        assert_eq!(lines, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n \n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\"; // no trailing \\n\n-        let lines: ~[&str] = data.lines().collect();\n-        assert_eq!(lines, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+        let lines: Vec<&str> = data.lines().collect();\n+        assert_eq!(lines, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]\n     fn test_split_strator() {\n-        fn t<'a>(s: &str, sep: &'a str, u: ~[&str]) {\n-            let v: ~[&str] = s.split_str(sep).collect();\n-            assert_eq!(v, u);\n+        fn t(s: &str, sep: &str, u: &[&str]) {\n+            let v: Vec<&str> = s.split_str(sep).collect();\n+            assert_eq!(v.as_slice(), u.as_slice());\n         }\n-        t(\"--1233345--\", \"12345\", box [\"--1233345--\"]);\n-        t(\"abc::hello::there\", \"::\", box [\"abc\", \"hello\", \"there\"]);\n-        t(\"::hello::there\", \"::\", box [\"\", \"hello\", \"there\"]);\n-        t(\"hello::there::\", \"::\", box [\"hello\", \"there\", \"\"]);\n-        t(\"::hello::there::\", \"::\", box [\"\", \"hello\", \"there\", \"\"]);\n-        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", box [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", \"Vi\u1ec7t Nam\"]);\n-        t(\"zzXXXzzYYYzz\", \"zz\", box [\"\", \"XXX\", \"YYY\", \"\"]);\n-        t(\"zzXXXzYYYz\", \"XXX\", box [\"zz\", \"zYYYz\"]);\n-        t(\".XXX.YYY.\", \".\", box [\"\", \"XXX\", \"YYY\", \"\"]);\n-        t(\"\", \".\", box [\"\"]);\n-        t(\"zz\", \"zz\", box [\"\",\"\"]);\n-        t(\"ok\", \"z\", box [\"ok\"]);\n-        t(\"zzz\", \"zz\", box [\"\",\"z\"]);\n-        t(\"zzzzz\", \"zz\", box [\"\",\"\",\"z\"]);\n+        t(\"--1233345--\", \"12345\", [\"--1233345--\"]);\n+        t(\"abc::hello::there\", \"::\", [\"abc\", \"hello\", \"there\"]);\n+        t(\"::hello::there\", \"::\", [\"\", \"hello\", \"there\"]);\n+        t(\"hello::there::\", \"::\", [\"hello\", \"there\", \"\"]);\n+        t(\"::hello::there::\", \"::\", [\"\", \"hello\", \"there\", \"\"]);\n+        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", \"Vi\u1ec7t Nam\"]);\n+        t(\"zzXXXzzYYYzz\", \"zz\", [\"\", \"XXX\", \"YYY\", \"\"]);\n+        t(\"zzXXXzYYYz\", \"XXX\", [\"zz\", \"zYYYz\"]);\n+        t(\".XXX.YYY.\", \".\", [\"\", \"XXX\", \"YYY\", \"\"]);\n+        t(\"\", \".\", [\"\"]);\n+        t(\"zz\", \"zz\", [\"\",\"\"]);\n+        t(\"ok\", \"z\", [\"ok\"]);\n+        t(\"zzz\", \"zz\", [\"\",\"z\"]);\n+        t(\"zzzzz\", \"zz\", [\"\",\"\",\"z\"]);\n     }\n \n     #[test]"}]}