{"sha": "02a18a659a8ee6dd9de2f1584573e87c724cd7e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYTE4YTY1OWE4ZWU2ZGQ5ZGUyZjE1ODQ1NzNlODdjNzI0Y2Q3ZTc=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-11-24T18:13:32Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-11-26T20:47:44Z"}, "message": "Rebase fixup for lower.rs", "tree": {"sha": "eb151f98050f4bd5511b3db9ec1e931d88f0b6a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb151f98050f4bd5511b3db9ec1e931d88f0b6a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02a18a659a8ee6dd9de2f1584573e87c724cd7e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02a18a659a8ee6dd9de2f1584573e87c724cd7e7", "html_url": "https://github.com/rust-lang/rust/commit/02a18a659a8ee6dd9de2f1584573e87c724cd7e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02a18a659a8ee6dd9de2f1584573e87c724cd7e7/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "296c3613ca7ed1117788f4e56259d2e426e992d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/296c3613ca7ed1117788f4e56259d2e426e992d7", "html_url": "https://github.com/rust-lang/rust/commit/296c3613ca7ed1117788f4e56259d2e426e992d7"}], "stats": {"total": 92, "additions": 55, "deletions": 37}, "files": [{"sha": "5f39376d156032d642b7ea06560482c0929b0c3c", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02a18a659a8ee6dd9de2f1584573e87c724cd7e7/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02a18a659a8ee6dd9de2f1584573e87c724cd7e7/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=02a18a659a8ee6dd9de2f1584573e87c724cd7e7", "patch": "@@ -864,7 +864,7 @@ pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T) -> P<ImplI\n pub fn noop_fold_mod<T: Folder>(Mod { inner, item_ids }: Mod, folder: &mut T) -> Mod {\n     Mod {\n         inner: folder.new_span(inner),\n-        items_ids: item_ids.move_map(|x| folder.fold_item_id(x)),\n+        item_ids: item_ids.move_map(|x| folder.fold_item_id(x)),\n     }\n }\n "}, {"sha": "e8c4a6484e2a2a95d97ee366c68f8b207f357355", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 54, "deletions": 36, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/02a18a659a8ee6dd9de2f1584573e87c724cd7e7/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02a18a659a8ee6dd9de2f1584573e87c724cd7e7/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=02a18a659a8ee6dd9de2f1584573e87c724cd7e7", "patch": "@@ -986,16 +986,16 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n                     let make_call = |lctx: &LoweringContext, p, args| {\n                         let path = core_path(lctx, e.span, p);\n-                        let path = expr_path(lctx, path);\n-                        expr_call(lctx, e.span, path, args)\n+                        let path = expr_path(lctx, path, None);\n+                        expr_call(lctx, e.span, path, args, None)\n                     };\n \n                     let mk_stmt_let = |lctx: &LoweringContext, bind, expr| {\n-                        stmt_let(lctx, e.span, false, bind, expr)\n+                        stmt_let(lctx, e.span, false, bind, expr, None)\n                     };\n \n                     let mk_stmt_let_mut = |lctx: &LoweringContext, bind, expr| {\n-                        stmt_let(lctx, e.span, true, bind, expr)\n+                        stmt_let(lctx, e.span, true, bind, expr, None)\n                     };\n \n                     // let placer = <placer_expr> ;\n@@ -1004,21 +1004,22 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                                             vec![],\n                                                             placer_expr,\n                                                             e.span,\n-                                                            hir::PopUnstableBlock);\n+                                                            hir::PopUnstableBlock,\n+                                                            None);\n                         mk_stmt_let(lctx, placer_ident, placer_expr)\n                     };\n \n                     // let mut place = Placer::make_place(placer);\n                     let s2 = {\n-                        let placer = expr_ident(lctx, e.span, placer_ident);\n+                        let placer = expr_ident(lctx, e.span, placer_ident, None);\n                         let call = make_call(lctx, &make_place, vec![placer]);\n                         mk_stmt_let_mut(lctx, place_ident, call)\n                     };\n \n                     // let p_ptr = Place::pointer(&mut place);\n                     let s3 = {\n-                        let agent = expr_ident(lctx, e.span, place_ident);\n-                        let args = vec![expr_mut_addr_of(lctx, e.span, agent)];\n+                        let agent = expr_ident(lctx, e.span, place_ident, None);\n+                        let args = vec![expr_mut_addr_of(lctx, e.span, agent, None)];\n                         let call = make_call(lctx, &place_pointer, args);\n                         mk_stmt_let(lctx, p_ptr_ident, call)\n                     };\n@@ -1029,40 +1030,42 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                                            vec![],\n                                                            value_expr,\n                                                            e.span,\n-                                                           hir::PopUnstableBlock);\n+                                                           hir::PopUnstableBlock,\n+                                                           None);\n                         signal_block_expr(lctx,\n                                           vec![],\n                                           value_expr,\n                                           e.span,\n-                                          hir::PopUnsafeBlock(hir::CompilerGenerated))\n+                                          hir::PopUnsafeBlock(hir::CompilerGenerated), None)\n                     };\n \n                     // push_unsafe!({\n                     //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n                     //     InPlace::finalize(place)\n                     // })\n                     let expr = {\n-                        let ptr = expr_ident(lctx, e.span, p_ptr_ident);\n+                        let ptr = expr_ident(lctx, e.span, p_ptr_ident, None);\n                         let call_move_val_init =\n                             hir::StmtSemi(\n                                 make_call(lctx, &move_val_init, vec![ptr, pop_unsafe_expr]),\n                                 lctx.next_id());\n                         let call_move_val_init = respan(e.span, call_move_val_init);\n \n-                        let place = expr_ident(lctx, e.span, place_ident);\n+                        let place = expr_ident(lctx, e.span, place_ident, None);\n                         let call = make_call(lctx, &inplace_finalize, vec![place]);\n                         signal_block_expr(lctx,\n                                           vec![P(call_move_val_init)],\n                                           call,\n                                           e.span,\n-                                          hir::PushUnsafeBlock(hir::CompilerGenerated))\n+                                          hir::PushUnsafeBlock(hir::CompilerGenerated), None)\n                     };\n \n                     signal_block_expr(lctx,\n                                       vec![s1, s2, s3],\n                                       expr,\n                                       e.span,\n-                                      hir::PushUnstableBlock)\n+                                      hir::PushUnstableBlock,\n+                                      e.attrs.clone())\n                 });\n             }\n \n@@ -1125,7 +1128,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                     rules: hir::DefaultBlock,\n                                     span: span,\n                                 });\n-                                expr_block(lctx, blk)\n+                                expr_block(lctx, blk, None)\n                             })\n                         }\n                         _ => lower_expr(lctx, els),\n@@ -1241,7 +1244,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = lower_block(lctx, body);\n-                        let body_expr = expr_block(lctx, body);\n+                        let body_expr = expr_block(lctx, body, None);\n                         arm(vec![lower_pat(lctx, pat)], body_expr)\n                     };\n \n@@ -1260,7 +1263,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                                 attrs: vec![],\n                                                 pats: vec![pat_under],\n                                                 guard: Some(cond),\n-                                                body: expr_block(lctx, then),\n+                                                body: expr_block(lctx, then, None),\n                                             });\n                                             else_opt.map(|else_opt| (else_opt, true))\n                                         }\n@@ -1292,7 +1295,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let pat_under = pat_wild(lctx, e.span);\n                         let else_expr =\n                             else_opt.unwrap_or_else(\n-                                || expr_tuple(lctx, e.span, vec![]));\n+                                || expr_tuple(lctx, e.span, vec![], None));\n                         arm(vec![pat_under], else_expr)\n                     };\n \n@@ -1302,13 +1305,15 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     arms.push(else_arm);\n \n                     let sub_expr = lower_expr(lctx, sub_expr);\n+                    // add attributes to the outer returned expr node\n                     expr(lctx,\n                          e.span,\n                          hir::ExprMatch(sub_expr,\n                                         arms,\n                                         hir::MatchSource::IfLetDesugar {\n                                             contains_else_clause: contains_else_clause,\n-                                        }))\n+                                        }),\n+                         e.attrs.clone())\n                 });\n             }\n \n@@ -1328,14 +1333,14 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = lower_block(lctx, body);\n-                        let body_expr = expr_block(lctx, body);\n+                        let body_expr = expr_block(lctx, body, None);\n                         arm(vec![lower_pat(lctx, pat)], body_expr)\n                     };\n \n                     // `_ => break`\n                     let break_arm = {\n                         let pat_under = pat_wild(lctx, e.span);\n-                        let break_expr = expr_break(lctx, e.span);\n+                        let break_expr = expr_break(lctx, e.span, None);\n                         arm(vec![pat_under], break_expr)\n                     };\n \n@@ -1346,11 +1351,13 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                           e.span,\n                                           hir::ExprMatch(sub_expr,\n                                                          arms,\n-                                                         hir::MatchSource::WhileLetDesugar));\n+                                                         hir::MatchSource::WhileLetDesugar),\n+                                          None);\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = block_expr(lctx, match_expr);\n-                    expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident))\n+                    // add attributes to the outer returned expr node\n+                    expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident), e.attrs.clone())\n                 });\n             }\n \n@@ -1387,6 +1394,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                             id: lctx.next_id(),\n                             node: hir::ExprBlock(body_block),\n                             span: body_span,\n+                            attrs: None,\n                         });\n                         let pat = lower_pat(lctx, pat);\n                         let some_pat = pat_some(lctx, e.span, pat);\n@@ -1396,7 +1404,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n                     // `::std::option::Option::None => break`\n                     let break_arm = {\n-                        let break_expr = expr_break(lctx, e.span);\n+                        let break_expr = expr_break(lctx, e.span, None);\n \n                         arm(vec![pat_none(lctx, e.span)], break_expr)\n                     };\n@@ -1408,20 +1416,28 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n                             path_global(e.span, strs)\n                         };\n-                        let iter = expr_ident(lctx, e.span, iter);\n-                        let ref_mut_iter = expr_mut_addr_of(lctx, e.span, iter);\n-                        let next_path = expr_path(lctx, next_path);\n-                        let next_expr = expr_call(lctx, e.span, next_path, vec![ref_mut_iter]);\n+                        let iter = expr_ident(lctx, e.span, iter, None);\n+                        let ref_mut_iter = expr_mut_addr_of(lctx, e.span, iter, None);\n+                        let next_path = expr_path(lctx, next_path, None);\n+                        let next_expr = expr_call(lctx,\n+                                                  e.span,\n+                                                  next_path,\n+                                                  vec![ref_mut_iter],\n+                                                  None);\n                         let arms = vec![pat_arm, break_arm];\n \n                         expr(lctx,\n                              e.span,\n-                             hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar))\n+                             hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n+                             None)\n                     };\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = block_expr(lctx, match_expr);\n-                    let loop_expr = expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n+                    let loop_expr = expr(lctx,\n+                                         e.span,\n+                                         hir::ExprLoop(loop_block, opt_ident),\n+                                         None);\n \n                     // `mut iter => { ... }`\n                     let iter_arm = {\n@@ -1440,22 +1456,24 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                             path_global(e.span, strs)\n                         };\n \n-                        let into_iter = expr_path(lctx, into_iter_path);\n-                        expr_call(lctx, e.span, into_iter, vec![head])\n+                        let into_iter = expr_path(lctx, into_iter_path, None);\n+                        expr_call(lctx, e.span, into_iter, vec![head], None)\n                     };\n \n                     let match_expr = expr_match(lctx,\n                                                 e.span,\n                                                 into_iter_expr,\n                                                 vec![iter_arm],\n-                                                hir::MatchSource::ForLoopDesugar);\n+                                                hir::MatchSource::ForLoopDesugar,\n+                                                None);\n \n                     // `{ let result = ...; result }`\n                     let result_ident = lctx.str_to_ident(\"result\");\n-                    let let_stmt = stmt_let(lctx, e.span, false, result_ident, match_expr);\n-                    let result = expr_ident(lctx, e.span, result_ident);\n+                    let let_stmt = stmt_let(lctx, e.span, false, result_ident, match_expr, None);\n+                    let result = expr_ident(lctx, e.span, result_ident, None);\n                     let block = block_all(lctx, e.span, vec![let_stmt], Some(result));\n-                    expr_block(lctx, block)\n+                    // add the attributes to the outer returned expr node\n+                    expr_block(lctx, block, e.attrs.clone())\n                 });\n             }\n "}]}