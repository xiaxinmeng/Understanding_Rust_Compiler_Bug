{"sha": "f217411bacbe943ead9dfca93a91dff0753c2a96", "node_id": "C_kwDOAAsO6NoAKGYyMTc0MTFiYWNiZTk0M2VhZDlkZmNhOTNhOTFkZmYwNzUzYzJhOTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-18T22:30:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-18T22:30:48Z"}, "message": "Auto merge of #112774 - compiler-errors:rollup-z8oof6r, r=compiler-errors\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #112537 (Don't record adjustments twice in `note_source_of_type_mismatch_constraint`)\n - #112663 (cleanup azure leftovers)\n - #112668 (Test `x.ps1` in `msvc` CI job)\n - #112710 (Re-use the deref-pattern recursion instead of duplicating the logic)\n - #112753 (Don't try to auto-bless 32-bit `mir-opt` tests on ARM Mac hosts)\n - #112758 (refactor(resolve): delete update_resolution function)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c3256c4d063cdeef5ab9dbaee43903634a32cf10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3256c4d063cdeef5ab9dbaee43903634a32cf10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f217411bacbe943ead9dfca93a91dff0753c2a96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f217411bacbe943ead9dfca93a91dff0753c2a96", "html_url": "https://github.com/rust-lang/rust/commit/f217411bacbe943ead9dfca93a91dff0753c2a96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f217411bacbe943ead9dfca93a91dff0753c2a96/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d0aa57684e10f7b3d3fe740ee18d431181583ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d0aa57684e10f7b3d3fe740ee18d431181583ad", "html_url": "https://github.com/rust-lang/rust/commit/2d0aa57684e10f7b3d3fe740ee18d431181583ad"}, {"sha": "3b059e0fdbf0257ac4921552781d070e8288233a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b059e0fdbf0257ac4921552781d070e8288233a", "html_url": "https://github.com/rust-lang/rust/commit/3b059e0fdbf0257ac4921552781d070e8288233a"}], "stats": {"total": 298, "additions": 167, "deletions": 131}, "files": [{"sha": "9ce03060e0fe901e5f302e7db06aae333e91f0e0", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f217411bacbe943ead9dfca93a91dff0753c2a96/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f217411bacbe943ead9dfca93a91dff0753c2a96/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=f217411bacbe943ead9dfca93a91dff0753c2a96", "patch": "@@ -370,13 +370,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // Fudge the receiver, so we can do new inference on it.\n                     let possible_rcvr_ty = possible_rcvr_ty.fold_with(&mut fudger);\n                     let method = self\n-                        .lookup_method(\n+                        .lookup_method_for_diagnostic(\n                             possible_rcvr_ty,\n                             segment,\n                             DUMMY_SP,\n                             call_expr,\n                             binding,\n-                            args,\n                         )\n                         .ok()?;\n                     // Unify the method signature with our incompatible arg, to\n@@ -435,14 +434,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let Some(rcvr_ty) = self.node_ty_opt(rcvr.hir_id) else { continue; };\n                 let rcvr_ty = rcvr_ty.fold_with(&mut fudger);\n                 let Ok(method) =\n-                    self.lookup_method(rcvr_ty, segment, DUMMY_SP, parent_expr, rcvr, args)\n+                    self.lookup_method_for_diagnostic(rcvr_ty, segment, DUMMY_SP, parent_expr, rcvr)\n                 else {\n                     continue;\n                 };\n \n                 let ideal_rcvr_ty = rcvr_ty.fold_with(&mut fudger);\n                 let ideal_method = self\n-                    .lookup_method(ideal_rcvr_ty, segment, DUMMY_SP, parent_expr, rcvr, args)\n+                    .lookup_method_for_diagnostic(ideal_rcvr_ty, segment, DUMMY_SP, parent_expr, rcvr)\n                     .ok()\n                     .and_then(|method| {\n                         let _ = self.at(&ObligationCause::dummy(), self.param_env)"}, {"sha": "6cd7bd5d196df92011cb134678bd31c0efb18b2b", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f217411bacbe943ead9dfca93a91dff0753c2a96/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f217411bacbe943ead9dfca93a91dff0753c2a96/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=f217411bacbe943ead9dfca93a91dff0753c2a96", "patch": "@@ -26,6 +26,7 @@ struct ConfirmContext<'a, 'tcx> {\n     span: Span,\n     self_expr: &'tcx hir::Expr<'tcx>,\n     call_expr: &'tcx hir::Expr<'tcx>,\n+    skip_record_for_diagnostics: bool,\n }\n \n impl<'a, 'tcx> Deref for ConfirmContext<'a, 'tcx> {\n@@ -59,6 +60,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut confirm_cx = ConfirmContext::new(self, span, self_expr, call_expr);\n         confirm_cx.confirm(unadjusted_self_ty, pick, segment)\n     }\n+\n+    pub fn confirm_method_for_diagnostic(\n+        &self,\n+        span: Span,\n+        self_expr: &'tcx hir::Expr<'tcx>,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        unadjusted_self_ty: Ty<'tcx>,\n+        pick: &probe::Pick<'tcx>,\n+        segment: &hir::PathSegment<'_>,\n+    ) -> ConfirmResult<'tcx> {\n+        let mut confirm_cx = ConfirmContext::new(self, span, self_expr, call_expr);\n+        confirm_cx.skip_record_for_diagnostics = true;\n+        confirm_cx.confirm(unadjusted_self_ty, pick, segment)\n+    }\n }\n \n impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n@@ -68,7 +83,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         self_expr: &'tcx hir::Expr<'tcx>,\n         call_expr: &'tcx hir::Expr<'tcx>,\n     ) -> ConfirmContext<'a, 'tcx> {\n-        ConfirmContext { fcx, span, self_expr, call_expr }\n+        ConfirmContext { fcx, span, self_expr, call_expr, skip_record_for_diagnostics: false }\n     }\n \n     fn confirm(\n@@ -219,7 +234,9 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         self.register_predicates(autoderef.into_obligations());\n \n         // Write out the final adjustments.\n-        self.apply_adjustments(self.self_expr, adjustments);\n+        if !self.skip_record_for_diagnostics {\n+            self.apply_adjustments(self.self_expr, adjustments);\n+        }\n \n         target\n     }\n@@ -453,7 +470,10 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             });\n \n             debug!(\"instantiate_method_substs: user_type_annotation={:?}\", user_type_annotation);\n-            self.fcx.write_user_type_annotation(self.call_expr.hir_id, user_type_annotation);\n+\n+            if !self.skip_record_for_diagnostics {\n+                self.fcx.write_user_type_annotation(self.call_expr.hir_id, user_type_annotation);\n+            }\n         }\n \n         self.normalize(self.span, substs)"}, {"sha": "59736b42cf7a8bac5587aef8d3654806a27c8ccc", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f217411bacbe943ead9dfca93a91dff0753c2a96/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f217411bacbe943ead9dfca93a91dff0753c2a96/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=f217411bacbe943ead9dfca93a91dff0753c2a96", "patch": "@@ -254,6 +254,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Ok(result.callee)\n     }\n \n+    pub fn lookup_method_for_diagnostic(\n+        &self,\n+        self_ty: Ty<'tcx>,\n+        segment: &hir::PathSegment<'_>,\n+        span: Span,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        self_expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Result<MethodCallee<'tcx>, MethodError<'tcx>> {\n+        let pick = self.lookup_probe_for_diagnostic(\n+            segment.ident,\n+            self_ty,\n+            call_expr,\n+            ProbeScope::TraitsInScope,\n+            None,\n+        )?;\n+\n+        Ok(self\n+            .confirm_method_for_diagnostic(span, self_expr, call_expr, self_ty, &pick, segment)\n+            .callee)\n+    }\n+\n     #[instrument(level = \"debug\", skip(self, call_expr))]\n     pub fn lookup_probe(\n         &self,"}, {"sha": "a2e00d3bfc57d81c2a33eb9ebc50f62d74ff015d", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 26, "deletions": 59, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f217411bacbe943ead9dfca93a91dff0753c2a96/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f217411bacbe943ead9dfca93a91dff0753c2a96/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=f217411bacbe943ead9dfca93a91dff0753c2a96", "patch": "@@ -359,6 +359,15 @@ impl<'tcx> ConstToPat<'tcx> {\n                     def.non_enum_variant().fields.iter().map(|field| field.ty(self.tcx(), substs)),\n                 ))?,\n             },\n+            ty::Slice(elem_ty) => PatKind::Slice {\n+                prefix: cv\n+                    .unwrap_branch()\n+                    .iter()\n+                    .map(|val| self.recur(*val, *elem_ty, false))\n+                    .collect::<Result<_, _>>()?,\n+                slice: None,\n+                suffix: Box::new([]),\n+            },\n             ty::Array(elem_ty, _) => PatKind::Array {\n                 prefix: cv\n                     .unwrap_branch()\n@@ -372,70 +381,16 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // `&str` is represented as a valtree, let's keep using this\n                 // optimization for now.\n                 ty::Str => PatKind::Constant { value: mir::ConstantKind::Ty(tcx.mk_const(cv, ty)) },\n-                // `b\"foo\"` produces a `&[u8; 3]`, but you can't use constants of array type when\n-                // matching against references, you can only use byte string literals.\n-                // The typechecker has a special case for byte string literals, by treating them\n-                // as slices. This means we turn `&[T; N]` constants into slice patterns, which\n-                // has no negative effects on pattern matching, even if we're actually matching on\n-                // arrays.\n-                ty::Array(elem_ty, _) if !self.treat_byte_string_as_slice => {\n-                    let old = self.behind_reference.replace(true);\n-                    // References have the same valtree representation as their pointee.\n-                    let array = cv;\n-                    let val = PatKind::Deref {\n-                        subpattern: Box::new(Pat {\n-                            kind: PatKind::Array {\n-                                prefix: array.unwrap_branch()\n-                                    .iter()\n-                                    .map(|val| self.recur(*val, elem_ty, false))\n-                                    .collect::<Result<_, _>>()?,\n-                                slice: None,\n-                                suffix: Box::new([]),\n-                            },\n-                            span,\n-                            ty: tcx.mk_slice(elem_ty),\n-                        }),\n-                    };\n-                    self.behind_reference.set(old);\n-                    val\n-                }\n-                ty::Array(elem_ty, _) |\n-                // Cannot merge this with the catch all branch below, because the `const_deref`\n-                // changes the type from slice to array, we need to keep the original type in the\n-                // pattern.\n-                ty::Slice(elem_ty) => {\n-                    let old = self.behind_reference.replace(true);\n-                    // References have the same valtree representation as their pointee.\n-                    let array = cv;\n-                    let val = PatKind::Deref {\n-                        subpattern: Box::new(Pat {\n-                            kind: PatKind::Slice {\n-                                prefix: array.unwrap_branch()\n-                                    .iter()\n-                                    .map(|val| self.recur(*val, elem_ty, false))\n-                                    .collect::<Result<_, _>>()?,\n-                                slice: None,\n-                                suffix: Box::new([]),\n-                            },\n-                            span,\n-                            ty: tcx.mk_slice(elem_ty),\n-                        }),\n-                    };\n-                    self.behind_reference.set(old);\n-                    val\n-                }\n                 // Backwards compatibility hack: support references to non-structural types,\n                 // but hard error if we aren't behind a double reference. We could just use\n                 // the fallback code path below, but that would allow *more* of this fishy\n                 // code to compile, as then it only goes through the future incompat lint\n                 // instead of a hard error.\n                 ty::Adt(_, _) if !self.type_marked_structural(*pointee_ty) => {\n                     if self.behind_reference.get() {\n-                        if !self.saw_const_match_error.get()\n-                            && !self.saw_const_match_lint.get()\n-                        {\n-                           self.saw_const_match_lint.set(true);\n-                           tcx.emit_spanned_lint(\n+                        if !self.saw_const_match_error.get() && !self.saw_const_match_lint.get() {\n+                            self.saw_const_match_lint.set(true);\n+                            tcx.emit_spanned_lint(\n                                 lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                                 self.id,\n                                 span,\n@@ -456,16 +411,28 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // convert the dereferenced constant to a pattern that is the sub-pattern of the\n                 // deref pattern.\n                 _ => {\n-                    if !pointee_ty.is_sized(tcx, param_env) {\n+                    if !pointee_ty.is_sized(tcx, param_env) && !pointee_ty.is_slice() {\n                         let err = UnsizedPattern { span, non_sm_ty: *pointee_ty };\n                         tcx.sess.emit_err(err);\n \n                         // FIXME: introduce PatKind::Error to silence follow up diagnostics due to unreachable patterns.\n                         PatKind::Wild\n                     } else {\n                         let old = self.behind_reference.replace(true);\n+                        // `b\"foo\"` produces a `&[u8; 3]`, but you can't use constants of array type when\n+                        // matching against references, you can only use byte string literals.\n+                        // The typechecker has a special case for byte string literals, by treating them\n+                        // as slices. This means we turn `&[T; N]` constants into slice patterns, which\n+                        // has no negative effects on pattern matching, even if we're actually matching on\n+                        // arrays.\n+                        let pointee_ty = match *pointee_ty.kind() {\n+                            ty::Array(elem_ty, _) if self.treat_byte_string_as_slice => {\n+                                tcx.mk_slice(elem_ty)\n+                            }\n+                            _ => *pointee_ty,\n+                        };\n                         // References have the same valtree representation as their pointee.\n-                        let subpattern = self.recur(cv, *pointee_ty, false)?;\n+                        let subpattern = self.recur(cv, pointee_ty, false)?;\n                         self.behind_reference.set(old);\n                         PatKind::Deref { subpattern }\n                     }"}, {"sha": "23ef9bf53a195f821c676bab575080b1196dc5d8", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 40, "deletions": 53, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/f217411bacbe943ead9dfca93a91dff0753c2a96/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f217411bacbe943ead9dfca93a91dff0753c2a96/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=f217411bacbe943ead9dfca93a91dff0753c2a96", "patch": "@@ -304,21 +304,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let res = binding.res();\n         self.check_reserved_macro_name(key.ident, res);\n         self.set_binding_parent_module(binding, module);\n-        self.update_resolution(module, key, |this, resolution| {\n-            if let Some(old_binding) = resolution.binding {\n-                if res == Res::Err && old_binding.res() != Res::Err {\n-                    // Do not override real bindings with `Res::Err`s from error recovery.\n-                    return Ok(());\n-                }\n+\n+        let mut resolution = self.resolution(module, key).borrow_mut();\n+        let old_binding = resolution.binding();\n+        let mut t = Ok(());\n+        if let Some(old_binding) = resolution.binding {\n+            if res == Res::Err && old_binding.res() != Res::Err {\n+                // Do not override real bindings with `Res::Err`s from error recovery.\n+            } else {\n                 match (old_binding.is_glob_import(), binding.is_glob_import()) {\n                     (true, true) => {\n                         if res != old_binding.res() {\n-                            resolution.binding = Some(this.ambiguity(\n+                            resolution.binding = Some(self.ambiguity(\n                                 AmbiguityKind::GlobVsGlob,\n                                 old_binding,\n                                 binding,\n                             ));\n-                        } else if !old_binding.vis.is_at_least(binding.vis, this.tcx) {\n+                        } else if !old_binding.vis.is_at_least(binding.vis, self.tcx) {\n                             // We are glob-importing the same item but with greater visibility.\n                             resolution.binding = Some(binding);\n                         }\n@@ -330,7 +332,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             && key.ns == MacroNS\n                             && nonglob_binding.expansion != LocalExpnId::ROOT\n                         {\n-                            resolution.binding = Some(this.ambiguity(\n+                            resolution.binding = Some(self.ambiguity(\n                                 AmbiguityKind::GlobVsExpanded,\n                                 nonglob_binding,\n                                 glob_binding,\n@@ -342,66 +344,40 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         if let Some(old_binding) = resolution.shadowed_glob {\n                             assert!(old_binding.is_glob_import());\n                             if glob_binding.res() != old_binding.res() {\n-                                resolution.shadowed_glob = Some(this.ambiguity(\n+                                resolution.shadowed_glob = Some(self.ambiguity(\n                                     AmbiguityKind::GlobVsGlob,\n                                     old_binding,\n                                     glob_binding,\n                                 ));\n-                            } else if !old_binding.vis.is_at_least(binding.vis, this.tcx) {\n+                            } else if !old_binding.vis.is_at_least(binding.vis, self.tcx) {\n                                 resolution.shadowed_glob = Some(glob_binding);\n                             }\n                         } else {\n                             resolution.shadowed_glob = Some(glob_binding);\n                         }\n                     }\n                     (false, false) => {\n-                        return Err(old_binding);\n+                        t = Err(old_binding);\n                     }\n                 }\n-            } else {\n-                resolution.binding = Some(binding);\n             }\n+        } else {\n+            resolution.binding = Some(binding);\n+        };\n \n-            Ok(())\n-        })\n-    }\n-\n-    fn ambiguity(\n-        &self,\n-        kind: AmbiguityKind,\n-        primary_binding: &'a NameBinding<'a>,\n-        secondary_binding: &'a NameBinding<'a>,\n-    ) -> &'a NameBinding<'a> {\n-        self.arenas.alloc_name_binding(NameBinding {\n-            ambiguity: Some((secondary_binding, kind)),\n-            ..primary_binding.clone()\n-        })\n-    }\n-\n-    // Use `f` to mutate the resolution of the name in the module.\n-    // If the resolution becomes a success, define it in the module's glob importers.\n-    fn update_resolution<T, F>(&mut self, module: Module<'a>, key: BindingKey, f: F) -> T\n-    where\n-        F: FnOnce(&mut Resolver<'a, 'tcx>, &mut NameResolution<'a>) -> T,\n-    {\n         // Ensure that `resolution` isn't borrowed when defining in the module's glob importers,\n         // during which the resolution might end up getting re-defined via a glob cycle.\n-        let (binding, t) = {\n-            let resolution = &mut *self.resolution(module, key).borrow_mut();\n-            let old_binding = resolution.binding();\n-\n-            let t = f(self, resolution);\n-\n-            match resolution.binding() {\n-                _ if old_binding.is_some() => return t,\n-                None => return t,\n-                Some(binding) => match old_binding {\n-                    Some(old_binding) if ptr::eq(old_binding, binding) => return t,\n-                    _ => (binding, t),\n-                },\n-            }\n+        let (binding, t) = match resolution.binding() {\n+            _ if old_binding.is_some() => return t,\n+            None => return t,\n+            Some(binding) => match old_binding {\n+                Some(old_binding) if ptr::eq(old_binding, binding) => return t,\n+                _ => (binding, t),\n+            },\n         };\n \n+        drop(resolution);\n+\n         // Define `binding` in `module`s glob importers.\n         for import in module.glob_importers.borrow_mut().iter() {\n             let mut ident = key.ident;\n@@ -420,6 +396,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         t\n     }\n \n+    fn ambiguity(\n+        &self,\n+        kind: AmbiguityKind,\n+        primary_binding: &'a NameBinding<'a>,\n+        secondary_binding: &'a NameBinding<'a>,\n+    ) -> &'a NameBinding<'a> {\n+        self.arenas.alloc_name_binding(NameBinding {\n+            ambiguity: Some((secondary_binding, kind)),\n+            ..primary_binding.clone()\n+        })\n+    }\n+\n     // Define a dummy resolution containing a `Res::Err` as a placeholder for a failed\n     // or indeterminate resolution, also mark such failed imports as used to avoid duplicate diagnostics.\n     fn import_dummy_binding(&mut self, import: &'a Import<'a>, is_indeterminate: bool) {\n@@ -769,9 +757,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 .emit();\n                         }\n                         let key = BindingKey::new(target, ns);\n-                        this.update_resolution(parent, key, |_, resolution| {\n-                            resolution.single_imports.remove(&Interned::new_unchecked(import));\n-                        });\n+                        let mut resolution = this.resolution(parent, key).borrow_mut();\n+                        resolution.single_imports.remove(&Interned::new_unchecked(import));\n                     }\n                 }\n             }"}, {"sha": "9476137968b23b50213b0056de983f690a4e1d63", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f217411bacbe943ead9dfca93a91dff0753c2a96/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/f217411bacbe943ead9dfca93a91dff0753c2a96/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=f217411bacbe943ead9dfca93a91dff0753c2a96", "patch": "@@ -60,8 +60,11 @@ prepare:\n ## MSVC native builders\n \n # this intentionally doesn't use `$(BOOTSTRAP)` so we can test the shebang on Windows\n-ci-msvc:\n-\t$(Q)$(CFG_SRC_DIR)/x.py test --stage 2\n+ci-msvc-py:\n+\t$(Q)$(CFG_SRC_DIR)/x.py test --stage 2 tidy\n+ci-msvc-ps1:\n+\t$(Q)$(CFG_SRC_DIR)/x.ps1 test --stage 2 --exclude tidy\n+ci-msvc: ci-msvc-py ci-msvc-ps1\n \n ## MingW native builders\n "}, {"sha": "9212362f6c9e10e2f7c8a52b9d2ab68e6a07a113", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f217411bacbe943ead9dfca93a91dff0753c2a96/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f217411bacbe943ead9dfca93a91dff0753c2a96/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=f217411bacbe943ead9dfca93a91dff0753c2a96", "patch": "@@ -44,7 +44,8 @@ const MIR_OPT_BLESS_TARGET_MAPPING: &[(&str, &str)] = &[\n     (\"i686-pc-windows-msvc\", \"x86_64-pc-windows-msvc\"),\n     (\"i686-pc-windows-gnu\", \"x86_64-pc-windows-gnu\"),\n     (\"i686-apple-darwin\", \"x86_64-apple-darwin\"),\n-    (\"i686-apple-darwin\", \"aarch64-apple-darwin\"),\n+    // ARM Macs don't have a corresponding 32-bit target that they can (easily)\n+    // build for, so there is no entry for \"aarch64-apple-darwin\" here.\n ];\n \n fn try_run(builder: &Builder<'_>, cmd: &mut Command) -> bool {"}, {"sha": "1ec49f80d632e87743dee1ae26bcfafb57e58520", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f217411bacbe943ead9dfca93a91dff0753c2a96/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f217411bacbe943ead9dfca93a91dff0753c2a96/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=f217411bacbe943ead9dfca93a91dff0753c2a96", "patch": "@@ -159,8 +159,6 @@ pub fn symlink_dir(config: &Config, original: &Path, link: &Path) -> io::Result<\n pub enum CiEnv {\n     /// Not a CI environment.\n     None,\n-    /// The Azure Pipelines environment, for Linux (including Docker), Windows, and macOS builds.\n-    AzurePipelines,\n     /// The GitHub Actions environment, for Linux (including Docker), Windows and macOS builds.\n     GitHubActions,\n }"}, {"sha": "0a098467d949368bf77f9fb540345d78aac76f21", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f217411bacbe943ead9dfca93a91dff0753c2a96/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f217411bacbe943ead9dfca93a91dff0753c2a96/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=f217411bacbe943ead9dfca93a91dff0753c2a96", "patch": "@@ -254,8 +254,6 @@ docker \\\n   --env DEPLOY \\\n   --env DEPLOY_ALT \\\n   --env CI \\\n-  --env TF_BUILD \\\n-  --env BUILD_SOURCEBRANCHNAME \\\n   --env GITHUB_ACTIONS \\\n   --env GITHUB_REF \\\n   --env TOOLSTATE_REPO_ACCESS_TOKEN \\"}, {"sha": "893195b69c21915ad58acaad389823f64136de75", "filename": "src/tools/build_helper/src/ci.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f217411bacbe943ead9dfca93a91dff0753c2a96/src%2Ftools%2Fbuild_helper%2Fsrc%2Fci.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f217411bacbe943ead9dfca93a91dff0753c2a96/src%2Ftools%2Fbuild_helper%2Fsrc%2Fci.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild_helper%2Fsrc%2Fci.rs?ref=f217411bacbe943ead9dfca93a91dff0753c2a96", "patch": "@@ -4,18 +4,14 @@ use std::process::Command;\n pub enum CiEnv {\n     /// Not a CI environment.\n     None,\n-    /// The Azure Pipelines environment, for Linux (including Docker), Windows, and macOS builds.\n-    AzurePipelines,\n     /// The GitHub Actions environment, for Linux (including Docker), Windows and macOS builds.\n     GitHubActions,\n }\n \n impl CiEnv {\n     /// Obtains the current CI environment.\n     pub fn current() -> CiEnv {\n-        if std::env::var(\"TF_BUILD\").map_or(false, |e| e == \"True\") {\n-            CiEnv::AzurePipelines\n-        } else if std::env::var(\"GITHUB_ACTIONS\").map_or(false, |e| e == \"true\") {\n+        if std::env::var(\"GITHUB_ACTIONS\").map_or(false, |e| e == \"true\") {\n             CiEnv::GitHubActions\n         } else {\n             CiEnv::None"}, {"sha": "0c2d71707c9f0c8ec4a0f4e45248e01c5420e80d", "filename": "tests/ui/typeck/dont-record-adjustments-when-pointing-at-arg.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f217411bacbe943ead9dfca93a91dff0753c2a96/tests%2Fui%2Ftypeck%2Fdont-record-adjustments-when-pointing-at-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f217411bacbe943ead9dfca93a91dff0753c2a96/tests%2Fui%2Ftypeck%2Fdont-record-adjustments-when-pointing-at-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fdont-record-adjustments-when-pointing-at-arg.rs?ref=f217411bacbe943ead9dfca93a91dff0753c2a96", "patch": "@@ -0,0 +1,29 @@\n+pub trait NSWindow: Sized {\n+    fn frame(self) -> () {\n+        unimplemented!()\n+    }\n+    fn setFrame_display_(self, display: ()) {}\n+}\n+impl NSWindow for () {}\n+\n+pub struct NSRect {}\n+\n+use std::ops::Deref;\n+struct MainThreadSafe<T = ()>(T);\n+impl<T> Deref for MainThreadSafe<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        unimplemented!()\n+    }\n+}\n+\n+fn main() {\n+    || {\n+        let ns_window = MainThreadSafe(());\n+        // Don't record adjustments twice for `*ns_window`\n+        (*ns_window).frame();\n+        ns_window.setFrame_display_(0);\n+        //~^ ERROR mismatched types\n+    };\n+}"}, {"sha": "02e87d701b68710eda7e7f4b57ea25bb22f50078", "filename": "tests/ui/typeck/dont-record-adjustments-when-pointing-at-arg.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f217411bacbe943ead9dfca93a91dff0753c2a96/tests%2Fui%2Ftypeck%2Fdont-record-adjustments-when-pointing-at-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f217411bacbe943ead9dfca93a91dff0753c2a96/tests%2Fui%2Ftypeck%2Fdont-record-adjustments-when-pointing-at-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fdont-record-adjustments-when-pointing-at-arg.stderr?ref=f217411bacbe943ead9dfca93a91dff0753c2a96", "patch": "@@ -0,0 +1,17 @@\n+error[E0308]: mismatched types\n+  --> $DIR/dont-record-adjustments-when-pointing-at-arg.rs:26:37\n+   |\n+LL |         ns_window.setFrame_display_(0);\n+   |                   ----------------- ^ expected `()`, found integer\n+   |                   |\n+   |                   arguments to this method are incorrect\n+   |\n+note: method defined here\n+  --> $DIR/dont-record-adjustments-when-pointing-at-arg.rs:5:8\n+   |\n+LL |     fn setFrame_display_(self, display: ()) {}\n+   |        ^^^^^^^^^^^^^^^^^       -----------\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}