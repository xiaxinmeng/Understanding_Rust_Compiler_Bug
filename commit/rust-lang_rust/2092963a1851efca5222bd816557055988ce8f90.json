{"sha": "2092963a1851efca5222bd816557055988ce8f90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwOTI5NjNhMTg1MWVmY2E1MjIyYmQ4MTY1NTcwNTU5ODhjZThmOTA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-29T05:24:32Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-05-31T15:24:42Z"}, "message": "rustc_codegen_utils: add new mangling scheme implementation.", "tree": {"sha": "baf9c544ed657535842dd0a4e118371e5a75eba7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/baf9c544ed657535842dd0a4e118371e5a75eba7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2092963a1851efca5222bd816557055988ce8f90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2092963a1851efca5222bd816557055988ce8f90", "html_url": "https://github.com/rust-lang/rust/commit/2092963a1851efca5222bd816557055988ce8f90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2092963a1851efca5222bd816557055988ce8f90/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "654d0596d3f21c8f774c95324bf79e5d6fbb75d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/654d0596d3f21c8f774c95324bf79e5d6fbb75d4", "html_url": "https://github.com/rust-lang/rust/commit/654d0596d3f21c8f774c95324bf79e5d6fbb75d4"}], "stats": {"total": 1731, "additions": 1241, "deletions": 490}, "files": [{"sha": "a13bc0e74760ad30eb4a111677b77c8a525e05fd", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2092963a1851efca5222bd816557055988ce8f90/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2092963a1851efca5222bd816557055988ce8f90/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2092963a1851efca5222bd816557055988ce8f90", "patch": "@@ -2023,6 +2023,11 @@ dependencies = [\n  \"unicase 2.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"punycode\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"quick-error\"\n version = \"1.2.2\"\n@@ -2687,6 +2692,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"flate2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"punycode 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_data_structures 0.0.0\",\n@@ -4277,6 +4283,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum proptest 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"24f5844db2f839e97e3021980975f6ebf8691d9b9b2ca67ed3feb38dc3edb52c\"\n \"checksum pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d6fdf85cda6cadfae5428a54661d431330b312bc767ddbc57adbedc24da66e32\"\n \"checksum pulldown-cmark 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"051e60ace841b3bfecd402fe5051c06cb3bec4a6e6fdd060a37aa8eb829a1db3\"\n+\"checksum punycode 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ddd112cca70a4d30883b2d21568a1d376ff8be4758649f64f973c6845128ad3\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n \"checksum quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07589615d719a60c8dd8a4622e7946465dfef20d1a428f969e3443e7386d5f45\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\""}, {"sha": "f61677fa594993d3061a90068de6ca4dad70cec1", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=2092963a1851efca5222bd816557055988ce8f90", "patch": "@@ -624,6 +624,10 @@ rustc_queries! {\n             fatal_cycle\n             desc { \"test whether a crate has #![no_builtins]\" }\n         }\n+        query symbol_mangling_version(_: CrateNum) -> SymbolManglingVersion {\n+            fatal_cycle\n+            desc { \"query a crate's symbol mangling version\" }\n+        }\n \n         query extern_crate(_: DefId) -> Option<&'tcx ExternCrate> {\n             eval_always"}, {"sha": "d8efa17defe3d06e6bed593c225a2f65a89548ff", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=2092963a1851efca5222bd816557055988ce8f90", "patch": "@@ -131,6 +131,14 @@ impl SwitchWithOptPath {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub enum SymbolManglingVersion {\n+    Legacy,\n+    V0,\n+}\n+\n+impl_stable_hash_via_hash!(SymbolManglingVersion);\n+\n #[derive(Clone, Copy, PartialEq, Hash)]\n pub enum DebugInfo {\n     None,\n@@ -838,11 +846,14 @@ macro_rules! options {\n             Some(\"an optional path to the profiling data output directory\");\n         pub const parse_merge_functions: Option<&str> =\n             Some(\"one of: `disabled`, `trampolines`, or `aliases`\");\n+        pub const parse_symbol_mangling_version: Option<&str> =\n+            Some(\"either `legacy` or `v0` (RFC 2603)\");\n     }\n \n     #[allow(dead_code)]\n     mod $mod_set {\n-        use super::{$struct_name, Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath};\n+        use super::{$struct_name, Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath,\n+            SymbolManglingVersion};\n         use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n         use std::path::PathBuf;\n         use std::str::FromStr;\n@@ -1112,6 +1123,18 @@ macro_rules! options {\n             }\n             true\n         }\n+\n+        fn parse_symbol_mangling_version(\n+            slot: &mut SymbolManglingVersion,\n+            v: Option<&str>,\n+        ) -> bool {\n+            *slot = match v {\n+                Some(\"legacy\") => SymbolManglingVersion::Legacy,\n+                Some(\"v0\") => SymbolManglingVersion::V0,\n+                _ => return false,\n+            };\n+            true\n+        }\n     }\n ) }\n \n@@ -1457,6 +1480,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"only allow the listed language features to be enabled in code (space separated)\"),\n     emit_artifact_notifications: bool = (false, parse_bool, [UNTRACKED],\n         \"emit notifications after each artifact has been output (only in the JSON format)\"),\n+    symbol_mangling_version: SymbolManglingVersion = (SymbolManglingVersion::Legacy,\n+        parse_symbol_mangling_version, [TRACKED],\n+        \"which mangling version to use for symbol names\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -2551,7 +2577,8 @@ mod dep_tracking {\n     use std::path::PathBuf;\n     use std::collections::hash_map::DefaultHasher;\n     use super::{CrateType, DebugInfo, ErrorOutputType, OptLevel, OutputTypes,\n-                Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath};\n+                Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath,\n+                SymbolManglingVersion};\n     use syntax::feature_gate::UnstableFeatures;\n     use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel, TargetTriple};\n     use syntax::edition::Edition;\n@@ -2620,6 +2647,7 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(Edition);\n     impl_dep_tracking_hash_via_hash!(LinkerPluginLto);\n     impl_dep_tracking_hash_via_hash!(SwitchWithOptPath);\n+    impl_dep_tracking_hash_via_hash!(SymbolManglingVersion);\n \n     impl_dep_tracking_hash_for_sortable_vec_of!(String);\n     impl_dep_tracking_hash_for_sortable_vec_of!(PathBuf);\n@@ -2693,7 +2721,7 @@ mod tests {\n     use std::collections::{BTreeMap, BTreeSet};\n     use std::iter::FromIterator;\n     use std::path::PathBuf;\n-    use super::{Externs, OutputType, OutputTypes};\n+    use super::{Externs, OutputType, OutputTypes, SymbolManglingVersion};\n     use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel};\n     use syntax::symbol::sym;\n     use syntax::edition::{Edition, DEFAULT_EDITION};\n@@ -3367,6 +3395,10 @@ mod tests {\n         opts = reference.clone();\n         opts.debugging_opts.allow_features = Some(vec![String::from(\"lang_items\")]);\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+        opts = reference.clone();\n+        opts.debugging_opts.symbol_mangling_version = SymbolManglingVersion::V0;\n+        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n     }\n \n     #[test]"}, {"sha": "a2bced97102a68393b8307a61f344bc1aadf42c3", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=2092963a1851efca5222bd816557055988ce8f90", "patch": "@@ -20,7 +20,7 @@ use crate::mir::mono::CodegenUnit;\n use crate::mir;\n use crate::mir::interpret::GlobalId;\n use crate::session::CrateDisambiguator;\n-use crate::session::config::{EntryFnType, OutputFilenames, OptLevel};\n+use crate::session::config::{EntryFnType, OutputFilenames, OptLevel, SymbolManglingVersion};\n use crate::traits::{self, Vtable};\n use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal,"}, {"sha": "268be2b109114d764fee9e60bb1b107ca8eb073e", "filename": "src/librustc_codegen_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_codegen_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_codegen_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2FCargo.toml?ref=2092963a1851efca5222bd816557055988ce8f90", "patch": "@@ -13,6 +13,7 @@ test = false\n [dependencies]\n flate2 = \"1.0\"\n log = \"0.4\"\n+punycode = \"0.4.0\"\n rustc-demangle = \"0.1.15\"\n \n syntax = { path = \"../libsyntax\" }"}, {"sha": "ea1d08354528b3dc1f9bef55a053bb2c3c884cc9", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=2092963a1851efca5222bd816557055988ce8f90", "patch": "@@ -7,7 +7,9 @@\n #![feature(arbitrary_self_types)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(core_intrinsics)]\n #![feature(custom_attribute)]\n+#![feature(never_type)]\n #![feature(nll)]\n #![allow(unused_attributes)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "134cbaaa3b3983058023eb1d666d2742bcbfdefd", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 60, "deletions": 486, "changes": 546, "blob_url": "https://github.com/rust-lang/rust/blob/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=2092963a1851efca5222bd816557055988ce8f90", "patch": "@@ -87,148 +87,33 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n-use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n-use rustc::ich::NodeIdHashingMode;\n-use rustc::ty::print::{PrettyPrinter, Printer, Print};\n+use rustc::session::config::SymbolManglingVersion;\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::{Kind, SubstsRef, UnpackedKind};\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::mir::interpret::{ConstValue, Scalar};\n-use rustc::util::common::record_time;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc::ty::{self, TyCtxt};\n use rustc_mir::monomorphize::item::{InstantiationMode, MonoItem, MonoItemExt};\n use rustc_mir::monomorphize::Instance;\n \n use syntax_pos::symbol::InternedString;\n \n use log::debug;\n \n-use std::fmt::{self, Write};\n-use std::mem::{self, discriminant};\n+mod legacy;\n+mod v0;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n-        symbol_name,\n+        symbol_name: |tcx, instance| ty::SymbolName {\n+            name: symbol_name(tcx, instance),\n+        },\n \n         ..*providers\n     };\n }\n \n-fn get_symbol_hash<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-\n-    // the DefId of the item this name is for\n-    def_id: DefId,\n-\n-    // instance this name will be for\n-    instance: Instance<'tcx>,\n-\n-    // type of the item, without any generic\n-    // parameters substituted; this is\n-    // included in the hash as a kind of\n-    // safeguard.\n-    item_type: Ty<'tcx>,\n-\n-    // values for generic type parameters,\n-    // if any.\n-    substs: SubstsRef<'tcx>,\n-) -> u64 {\n-    debug!(\n-        \"get_symbol_hash(def_id={:?}, parameters={:?})\",\n-        def_id, substs\n-    );\n-\n-    let mut hasher = StableHasher::<u64>::new();\n-    let mut hcx = tcx.create_stable_hashing_context();\n-\n-    record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n-        // the main symbol name is not necessarily unique; hash in the\n-        // compiler's internal def-path, guaranteeing each symbol has a\n-        // truly unique path\n-        tcx.def_path_hash(def_id).hash_stable(&mut hcx, &mut hasher);\n-\n-        // Include the main item-type. Note that, in this case, the\n-        // assertions about `needs_subst` may not hold, but this item-type\n-        // ought to be the same for every reference anyway.\n-        assert!(!item_type.has_erasable_regions());\n-        hcx.while_hashing_spans(false, |hcx| {\n-            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                item_type.hash_stable(hcx, &mut hasher);\n-            });\n-        });\n-\n-        // If this is a function, we hash the signature as well.\n-        // This is not *strictly* needed, but it may help in some\n-        // situations, see the `run-make/a-b-a-linker-guard` test.\n-        if let ty::FnDef(..) = item_type.sty {\n-            item_type.fn_sig(tcx).hash_stable(&mut hcx, &mut hasher);\n-        }\n-\n-        // also include any type parameters (for generic items)\n-        assert!(!substs.has_erasable_regions());\n-        assert!(!substs.needs_subst());\n-        substs.hash_stable(&mut hcx, &mut hasher);\n-\n-        let is_generic = substs.non_erasable_generics().next().is_some();\n-        let avoid_cross_crate_conflicts =\n-            // If this is an instance of a generic function, we also hash in\n-            // the ID of the instantiating crate. This avoids symbol conflicts\n-            // in case the same instances is emitted in two crates of the same\n-            // project.\n-            is_generic ||\n-\n-            // If we're dealing with an instance of a function that's inlined from\n-            // another crate but we're marking it as globally shared to our\n-            // compliation (aka we're not making an internal copy in each of our\n-            // codegen units) then this symbol may become an exported (but hidden\n-            // visibility) symbol. This means that multiple crates may do the same\n-            // and we want to be sure to avoid any symbol conflicts here.\n-            match MonoItem::Fn(instance).instantiation_mode(tcx) {\n-                InstantiationMode::GloballyShared { may_conflict: true } => true,\n-                _ => false,\n-            };\n-\n-        if avoid_cross_crate_conflicts {\n-            let instantiating_crate = if is_generic {\n-                if !def_id.is_local() && tcx.sess.opts.share_generics() {\n-                    // If we are re-using a monomorphization from another crate,\n-                    // we have to compute the symbol hash accordingly.\n-                    let upstream_monomorphizations = tcx.upstream_monomorphizations_for(def_id);\n-\n-                    upstream_monomorphizations\n-                        .and_then(|monos| monos.get(&substs).cloned())\n-                        .unwrap_or(LOCAL_CRATE)\n-                } else {\n-                    LOCAL_CRATE\n-                }\n-            } else {\n-                LOCAL_CRATE\n-            };\n-\n-            (&tcx.original_crate_name(instantiating_crate).as_str()[..])\n-                .hash_stable(&mut hcx, &mut hasher);\n-            (&tcx.crate_disambiguator(instantiating_crate)).hash_stable(&mut hcx, &mut hasher);\n-        }\n-\n-        // We want to avoid accidental collision between different types of instances.\n-        // Especially, VtableShim may overlap with its original instance without this.\n-        discriminant(&instance.def).hash_stable(&mut hcx, &mut hasher);\n-    });\n-\n-    // 64 bits should be enough to avoid collisions.\n-    hasher.finish()\n-}\n-\n-fn symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) -> ty::SymbolName {\n-    ty::SymbolName {\n-        name: compute_symbol_name(tcx, instance),\n-    }\n-}\n-\n-fn compute_symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) -> InternedString {\n+fn symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) -> InternedString {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n@@ -278,376 +163,65 @@ fn compute_symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) ->\n         return tcx.item_name(def_id).as_interned_str();\n     }\n \n-    // We want to compute the \"type\" of this item. Unfortunately, some\n-    // kinds of items (e.g., closures) don't have an entry in the\n-    // item-type array. So walk back up the find the closest parent\n-    // that DOES have an entry.\n-    let mut ty_def_id = def_id;\n-    let instance_ty;\n-    loop {\n-        let key = tcx.def_key(ty_def_id);\n-        match key.disambiguated_data.data {\n-            DefPathData::TypeNs(_) | DefPathData::ValueNs(_) => {\n-                instance_ty = tcx.type_of(ty_def_id);\n-                break;\n-            }\n-            _ => {\n-                // if we're making a symbol for something, there ought\n-                // to be a value or type-def or something in there\n-                // *somewhere*\n-                ty_def_id.index = key.parent.unwrap_or_else(|| {\n-                    bug!(\n-                        \"finding type for {:?}, encountered def-id {:?} with no \\\n-                         parent\",\n-                        def_id,\n-                        ty_def_id\n-                    );\n-                });\n-            }\n-        }\n-    }\n \n-    // Erase regions because they may not be deterministic when hashed\n-    // and should not matter anyhow.\n-    let instance_ty = tcx.erase_regions(&instance_ty);\n+    let is_generic = substs.non_erasable_generics().next().is_some();\n+    let avoid_cross_crate_conflicts =\n+        // If this is an instance of a generic function, we also hash in\n+        // the ID of the instantiating crate. This avoids symbol conflicts\n+        // in case the same instances is emitted in two crates of the same\n+        // project.\n+        is_generic ||\n \n-    let hash = get_symbol_hash(tcx, def_id, instance, instance_ty, substs);\n-\n-    let mut printer = SymbolPrinter {\n-        tcx,\n-        path: SymbolPath::new(),\n-        keep_within_component: false,\n-    }.print_def_path(def_id, &[]).unwrap();\n-\n-    if instance.is_vtable_shim() {\n-        let _ = printer.write_str(\"{{vtable-shim}}\");\n-    }\n-\n-    InternedString::intern(&printer.path.finish(hash))\n-}\n-\n-// Follow C++ namespace-mangling style, see\n-// http://en.wikipedia.org/wiki/Name_mangling for more info.\n-//\n-// It turns out that on macOS you can actually have arbitrary symbols in\n-// function names (at least when given to LLVM), but this is not possible\n-// when using unix's linker. Perhaps one day when we just use a linker from LLVM\n-// we won't need to do this name mangling. The problem with name mangling is\n-// that it seriously limits the available characters. For example we can't\n-// have things like &T in symbol names when one would theoretically\n-// want them for things like impls of traits on that type.\n-//\n-// To be able to work on all platforms and get *some* reasonable output, we\n-// use C++ name-mangling.\n-#[derive(Debug)]\n-struct SymbolPath {\n-    result: String,\n-    temp_buf: String,\n-}\n-\n-impl SymbolPath {\n-    fn new() -> Self {\n-        let mut result = SymbolPath {\n-            result: String::with_capacity(64),\n-            temp_buf: String::with_capacity(16),\n+        // If we're dealing with an instance of a function that's inlined from\n+        // another crate but we're marking it as globally shared to our\n+        // compliation (aka we're not making an internal copy in each of our\n+        // codegen units) then this symbol may become an exported (but hidden\n+        // visibility) symbol. This means that multiple crates may do the same\n+        // and we want to be sure to avoid any symbol conflicts here.\n+        match MonoItem::Fn(instance).instantiation_mode(tcx) {\n+            InstantiationMode::GloballyShared { may_conflict: true } => true,\n+            _ => false,\n         };\n-        result.result.push_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n-        result\n-    }\n-\n-    fn finalize_pending_component(&mut self) {\n-        if !self.temp_buf.is_empty() {\n-            let _ = write!(self.result, \"{}{}\", self.temp_buf.len(), self.temp_buf);\n-            self.temp_buf.clear();\n-        }\n-    }\n-\n-    fn finish(mut self, hash: u64) -> String {\n-        self.finalize_pending_component();\n-        // E = end name-sequence\n-        let _ = write!(self.result, \"17h{:016x}E\", hash);\n-        self.result\n-    }\n-}\n-\n-struct SymbolPrinter<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    path: SymbolPath,\n-\n-    // When `true`, `finalize_pending_component` isn't used.\n-    // This is needed when recursing into `path_qualified`,\n-    // or `path_generic_args`, as any nested paths are\n-    // logically within one component.\n-    keep_within_component: bool,\n-}\n-\n-// HACK(eddyb) this relies on using the `fmt` interface to get\n-// `PrettyPrinter` aka pretty printing of e.g. types in paths,\n-// symbol names should have their own printing machinery.\n-\n-impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n-    type Error = fmt::Error;\n-\n-    type Path = Self;\n-    type Region = Self;\n-    type Type = Self;\n-    type DynExistential = Self;\n-    type Const = Self;\n-\n-    fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn print_region(\n-        self,\n-        _region: ty::Region<'_>,\n-    ) -> Result<Self::Region, Self::Error> {\n-        Ok(self)\n-    }\n-\n-    fn print_type(\n-        self,\n-        ty: Ty<'tcx>,\n-    ) -> Result<Self::Type, Self::Error> {\n-        match ty.sty {\n-            // Print all nominal types as paths (unlike `pretty_print_type`).\n-            ty::FnDef(def_id, substs) |\n-            ty::Opaque(def_id, substs) |\n-            ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n-            ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n-            ty::Closure(def_id, ty::ClosureSubsts { substs }) |\n-            ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n-                self.print_def_path(def_id, substs)\n-            }\n-            _ => self.pretty_print_type(ty),\n-        }\n-    }\n-\n-    fn print_dyn_existential(\n-        mut self,\n-        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n-    ) -> Result<Self::DynExistential, Self::Error> {\n-        let mut first = true;\n-        for p in predicates {\n-            if !first {\n-                write!(self, \"+\")?;\n-            }\n-            first = false;\n-            self = p.print(self)?;\n-        }\n-        Ok(self)\n-    }\n \n-    fn print_const(\n-        mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<Self::Const, Self::Error> {\n-        // only print integers\n-        if let ConstValue::Scalar(Scalar::Raw { .. }) = ct.val {\n-            if ct.ty.is_integral() {\n-                return self.pretty_print_const(ct);\n-            }\n-        }\n-        self.write_str(\"_\")?;\n-        Ok(self)\n-    }\n-\n-    fn path_crate(\n-        mut self,\n-        cnum: CrateNum,\n-    ) -> Result<Self::Path, Self::Error> {\n-        self.write_str(&self.tcx.original_crate_name(cnum).as_str())?;\n-        Ok(self)\n-    }\n-    fn path_qualified(\n-        self,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        // Similar to `pretty_path_qualified`, but for the other\n-        // types that are printed as paths (see `print_type` above).\n-        match self_ty.sty {\n-            ty::FnDef(..) |\n-            ty::Opaque(..) |\n-            ty::Projection(_) |\n-            ty::UnnormalizedProjection(_) |\n-            ty::Closure(..) |\n-            ty::Generator(..)\n-                if trait_ref.is_none() =>\n-            {\n-                self.print_type(self_ty)\n-            }\n-\n-            _ => self.pretty_path_qualified(self_ty, trait_ref)\n-        }\n-    }\n+    let instantiating_crate = if avoid_cross_crate_conflicts {\n+        Some(if is_generic {\n+            if !def_id.is_local() && tcx.sess.opts.share_generics() {\n+                // If we are re-using a monomorphization from another crate,\n+                // we have to compute the symbol hash accordingly.\n+                let upstream_monomorphizations = tcx.upstream_monomorphizations_for(def_id);\n \n-    fn path_append_impl(\n-        self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        _disambiguated_data: &DisambiguatedDefPathData,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        self.pretty_path_append_impl(\n-            |mut cx| {\n-                cx = print_prefix(cx)?;\n-\n-                if cx.keep_within_component {\n-                    // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n-                    cx.write_str(\"::\")?;\n-                } else {\n-                    cx.path.finalize_pending_component();\n-                }\n-\n-                Ok(cx)\n-            },\n-            self_ty,\n-            trait_ref,\n-        )\n-    }\n-    fn path_append(\n-        mut self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        disambiguated_data: &DisambiguatedDefPathData,\n-    ) -> Result<Self::Path, Self::Error> {\n-        self = print_prefix(self)?;\n-\n-        // Skip `::{{constructor}}` on tuple/unit structs.\n-        match disambiguated_data.data {\n-            DefPathData::Ctor => return Ok(self),\n-            _ => {}\n-        }\n-\n-        if self.keep_within_component {\n-            // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n-            self.write_str(\"::\")?;\n-        } else {\n-            self.path.finalize_pending_component();\n-        }\n-\n-        self.write_str(&disambiguated_data.data.as_interned_str().as_str())?;\n-        Ok(self)\n-    }\n-    fn path_generic_args(\n-        mut self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        args: &[Kind<'tcx>],\n-    )  -> Result<Self::Path, Self::Error> {\n-        self = print_prefix(self)?;\n-\n-        let args = args.iter().cloned().filter(|arg| {\n-            match arg.unpack() {\n-                UnpackedKind::Lifetime(_) => false,\n-                _ => true,\n+                upstream_monomorphizations\n+                    .and_then(|monos| monos.get(&substs).cloned())\n+                    .unwrap_or(LOCAL_CRATE)\n+            } else {\n+                LOCAL_CRATE\n             }\n-        });\n-\n-        if args.clone().next().is_some() {\n-            self.generic_delimiters(|cx| cx.comma_sep(args))\n         } else {\n-            Ok(self)\n-        }\n-    }\n-}\n-\n-impl PrettyPrinter<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n-    fn region_should_not_be_omitted(\n-        &self,\n-        _region: ty::Region<'_>,\n-    ) -> bool {\n-        false\n-    }\n-    fn comma_sep<T>(\n-        mut self,\n-        mut elems: impl Iterator<Item = T>,\n-    ) -> Result<Self, Self::Error>\n-        where T: Print<'tcx, 'tcx, Self, Output = Self, Error = Self::Error>\n-    {\n-        if let Some(first) = elems.next() {\n-            self = first.print(self)?;\n-            for elem in elems {\n-                self.write_str(\",\")?;\n-                self = elem.print(self)?;\n-            }\n-        }\n-        Ok(self)\n-    }\n-\n-    fn generic_delimiters(\n-        mut self,\n-        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n-    ) -> Result<Self, Self::Error> {\n-        write!(self, \"<\")?;\n-\n-        let kept_within_component =\n-            mem::replace(&mut self.keep_within_component, true);\n-        self = f(self)?;\n-        self.keep_within_component = kept_within_component;\n-\n-        write!(self, \">\")?;\n-\n-        Ok(self)\n-    }\n-}\n-\n-impl fmt::Write for SymbolPrinter<'_, '_> {\n-    fn write_str(&mut self, s: &str) -> fmt::Result {\n-        // Name sanitation. LLVM will happily accept identifiers with weird names, but\n-        // gas doesn't!\n-        // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n-        // NVPTX assembly has more strict naming rules than gas, so additionally, dots\n-        // are replaced with '$' there.\n-\n-        for c in s.chars() {\n-            if self.path.temp_buf.is_empty() {\n-                match c {\n-                    'a'..='z' | 'A'..='Z' | '_' => {}\n-                    _ => {\n-                        // Underscore-qualify anything that didn't start as an ident.\n-                        self.path.temp_buf.push('_');\n-                    }\n-                }\n-            }\n-            match c {\n-                // Escape these with $ sequences\n-                '@' => self.path.temp_buf.push_str(\"$SP$\"),\n-                '*' => self.path.temp_buf.push_str(\"$BP$\"),\n-                '&' => self.path.temp_buf.push_str(\"$RF$\"),\n-                '<' => self.path.temp_buf.push_str(\"$LT$\"),\n-                '>' => self.path.temp_buf.push_str(\"$GT$\"),\n-                '(' => self.path.temp_buf.push_str(\"$LP$\"),\n-                ')' => self.path.temp_buf.push_str(\"$RP$\"),\n-                ',' => self.path.temp_buf.push_str(\"$C$\"),\n-\n-                '-' | ':' | '.' if self.tcx.has_strict_asm_symbol_naming() => {\n-                    // NVPTX doesn't support these characters in symbol names.\n-                    self.path.temp_buf.push('$')\n-                }\n-\n-                // '.' doesn't occur in types and functions, so reuse it\n-                // for ':' and '-'\n-                '-' | ':' => self.path.temp_buf.push('.'),\n-\n-                // Avoid segmentation fault on some platforms, see #60925.\n-                'm' if self.path.temp_buf.ends_with(\".llv\") => self.path.temp_buf.push_str(\"$6d$\"),\n+            LOCAL_CRATE\n+        })\n+    } else {\n+        None\n+    };\n \n-                // These are legal symbols\n-                'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '.' | '$' => self.path.temp_buf.push(c),\n+    // Pick the crate responsible for the symbol mangling version, which has to:\n+    // 1. be stable for each instance, whether it's being defined or imported\n+    // 2. obey each crate's own `-Z symbol-mangling-version`, as much as possible\n+    // We solve these as follows:\n+    // 1. because symbol names depend on both `def_id` and `instantiating_crate`,\n+    // both their `CrateNum`s are stable for any given instance, so we can pick\n+    // either and have a stable choice of symbol mangling version\n+    // 2. we favor `instantiating_crate` where possible (i.e. when `Some`)\n+    let mangling_version_crate = instantiating_crate.unwrap_or(def_id.krate);\n+    let mangling_version = if mangling_version_crate == LOCAL_CRATE {\n+        tcx.sess.opts.debugging_opts.symbol_mangling_version\n+    } else {\n+        tcx.symbol_mangling_version(mangling_version_crate)\n+    };\n \n-                _ => {\n-                    self.path.temp_buf.push('$');\n-                    for c in c.escape_unicode().skip(1) {\n-                        match c {\n-                            '{' => {}\n-                            '}' => self.path.temp_buf.push('$'),\n-                            c => self.path.temp_buf.push(c),\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+    let mangled = match mangling_version {\n+        SymbolManglingVersion::Legacy => legacy::mangle(tcx, instance, instantiating_crate),\n+        SymbolManglingVersion::V0 => v0::mangle(tcx, instance, instantiating_crate, true),\n+    };\n \n-        Ok(())\n-    }\n+    InternedString::intern(&mangled)\n }"}, {"sha": "53682b9bdc2c8ef47605270d39bfb8b1f754de00", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "added", "additions": 463, "deletions": 0, "changes": 463, "blob_url": "https://github.com/rust-lang/rust/blob/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=2092963a1851efca5222bd816557055988ce8f90", "patch": "@@ -0,0 +1,463 @@\n+use rustc::hir::def_id::CrateNum;\n+use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n+use rustc::ich::NodeIdHashingMode;\n+use rustc::mir::interpret::{ConstValue, Scalar};\n+use rustc::ty::print::{PrettyPrinter, Printer, Print};\n+use rustc::ty::subst::{Kind, UnpackedKind};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::util::common::record_time;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_mir::monomorphize::Instance;\n+\n+use log::debug;\n+\n+use std::fmt::{self, Write};\n+use std::mem::{self, discriminant};\n+\n+pub(super) fn mangle(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    instance: Instance<'tcx>,\n+    instantiating_crate: Option<CrateNum>,\n+) -> String {\n+    let def_id = instance.def_id();\n+\n+    // We want to compute the \"type\" of this item. Unfortunately, some\n+    // kinds of items (e.g., closures) don't have an entry in the\n+    // item-type array. So walk back up the find the closest parent\n+    // that DOES have an entry.\n+    let mut ty_def_id = def_id;\n+    let instance_ty;\n+    loop {\n+        let key = tcx.def_key(ty_def_id);\n+        match key.disambiguated_data.data {\n+            DefPathData::TypeNs(_) | DefPathData::ValueNs(_) => {\n+                instance_ty = tcx.type_of(ty_def_id);\n+                break;\n+            }\n+            _ => {\n+                // if we're making a symbol for something, there ought\n+                // to be a value or type-def or something in there\n+                // *somewhere*\n+                ty_def_id.index = key.parent.unwrap_or_else(|| {\n+                    bug!(\n+                        \"finding type for {:?}, encountered def-id {:?} with no \\\n+                         parent\",\n+                        def_id,\n+                        ty_def_id\n+                    );\n+                });\n+            }\n+        }\n+    }\n+\n+    // Erase regions because they may not be deterministic when hashed\n+    // and should not matter anyhow.\n+    let instance_ty = tcx.erase_regions(&instance_ty);\n+\n+    let hash = get_symbol_hash(tcx, instance, instance_ty, instantiating_crate);\n+\n+    let mut printer = SymbolPrinter {\n+        tcx,\n+        path: SymbolPath::new(),\n+        keep_within_component: false,\n+    }.print_def_path(def_id, &[]).unwrap();\n+\n+    if instance.is_vtable_shim() {\n+        let _ = printer.write_str(\"{{vtable-shim}}\");\n+    }\n+\n+    printer.path.finish(hash)\n+}\n+\n+fn get_symbol_hash<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+\n+    // instance this name will be for\n+    instance: Instance<'tcx>,\n+\n+    // type of the item, without any generic\n+    // parameters substituted; this is\n+    // included in the hash as a kind of\n+    // safeguard.\n+    item_type: Ty<'tcx>,\n+\n+    instantiating_crate: Option<CrateNum>,\n+) -> u64 {\n+    let def_id = instance.def_id();\n+    let substs = instance.substs;\n+    debug!(\n+        \"get_symbol_hash(def_id={:?}, parameters={:?})\",\n+        def_id, substs\n+    );\n+\n+    let mut hasher = StableHasher::<u64>::new();\n+    let mut hcx = tcx.create_stable_hashing_context();\n+\n+    record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n+        // the main symbol name is not necessarily unique; hash in the\n+        // compiler's internal def-path, guaranteeing each symbol has a\n+        // truly unique path\n+        tcx.def_path_hash(def_id).hash_stable(&mut hcx, &mut hasher);\n+\n+        // Include the main item-type. Note that, in this case, the\n+        // assertions about `needs_subst` may not hold, but this item-type\n+        // ought to be the same for every reference anyway.\n+        assert!(!item_type.has_erasable_regions());\n+        hcx.while_hashing_spans(false, |hcx| {\n+            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+                item_type.hash_stable(hcx, &mut hasher);\n+            });\n+        });\n+\n+        // If this is a function, we hash the signature as well.\n+        // This is not *strictly* needed, but it may help in some\n+        // situations, see the `run-make/a-b-a-linker-guard` test.\n+        if let ty::FnDef(..) = item_type.sty {\n+            item_type.fn_sig(tcx).hash_stable(&mut hcx, &mut hasher);\n+        }\n+\n+        // also include any type parameters (for generic items)\n+        assert!(!substs.has_erasable_regions());\n+        assert!(!substs.needs_subst());\n+        substs.hash_stable(&mut hcx, &mut hasher);\n+\n+        if let Some(instantiating_crate) = instantiating_crate {\n+            (&tcx.original_crate_name(instantiating_crate).as_str()[..])\n+                .hash_stable(&mut hcx, &mut hasher);\n+            (&tcx.crate_disambiguator(instantiating_crate)).hash_stable(&mut hcx, &mut hasher);\n+        }\n+\n+        // We want to avoid accidental collision between different types of instances.\n+        // Especially, VtableShim may overlap with its original instance without this.\n+        discriminant(&instance.def).hash_stable(&mut hcx, &mut hasher);\n+    });\n+\n+    // 64 bits should be enough to avoid collisions.\n+    hasher.finish()\n+}\n+\n+// Follow C++ namespace-mangling style, see\n+// http://en.wikipedia.org/wiki/Name_mangling for more info.\n+//\n+// It turns out that on macOS you can actually have arbitrary symbols in\n+// function names (at least when given to LLVM), but this is not possible\n+// when using unix's linker. Perhaps one day when we just use a linker from LLVM\n+// we won't need to do this name mangling. The problem with name mangling is\n+// that it seriously limits the available characters. For example we can't\n+// have things like &T in symbol names when one would theoretically\n+// want them for things like impls of traits on that type.\n+//\n+// To be able to work on all platforms and get *some* reasonable output, we\n+// use C++ name-mangling.\n+#[derive(Debug)]\n+struct SymbolPath {\n+    result: String,\n+    temp_buf: String,\n+}\n+\n+impl SymbolPath {\n+    fn new() -> Self {\n+        let mut result = SymbolPath {\n+            result: String::with_capacity(64),\n+            temp_buf: String::with_capacity(16),\n+        };\n+        result.result.push_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n+        result\n+    }\n+\n+    fn finalize_pending_component(&mut self) {\n+        if !self.temp_buf.is_empty() {\n+            let _ = write!(self.result, \"{}{}\", self.temp_buf.len(), self.temp_buf);\n+            self.temp_buf.clear();\n+        }\n+    }\n+\n+    fn finish(mut self, hash: u64) -> String {\n+        self.finalize_pending_component();\n+        // E = end name-sequence\n+        let _ = write!(self.result, \"17h{:016x}E\", hash);\n+        self.result\n+    }\n+}\n+\n+struct SymbolPrinter<'a, 'tcx> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    path: SymbolPath,\n+\n+    // When `true`, `finalize_pending_component` isn't used.\n+    // This is needed when recursing into `path_qualified`,\n+    // or `path_generic_args`, as any nested paths are\n+    // logically within one component.\n+    keep_within_component: bool,\n+}\n+\n+// HACK(eddyb) this relies on using the `fmt` interface to get\n+// `PrettyPrinter` aka pretty printing of e.g. types in paths,\n+// symbol names should have their own printing machinery.\n+\n+impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n+    type Error = fmt::Error;\n+\n+    type Path = Self;\n+    type Region = Self;\n+    type Type = Self;\n+    type DynExistential = Self;\n+    type Const = Self;\n+\n+    fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn print_region(\n+        self,\n+        _region: ty::Region<'_>,\n+    ) -> Result<Self::Region, Self::Error> {\n+        Ok(self)\n+    }\n+\n+    fn print_type(\n+        self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error> {\n+        match ty.sty {\n+            // Print all nominal types as paths (unlike `pretty_print_type`).\n+            ty::FnDef(def_id, substs) |\n+            ty::Opaque(def_id, substs) |\n+            ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n+            ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n+            ty::Closure(def_id, ty::ClosureSubsts { substs }) |\n+            ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n+                self.print_def_path(def_id, substs)\n+            }\n+            _ => self.pretty_print_type(ty),\n+        }\n+    }\n+\n+    fn print_dyn_existential(\n+        mut self,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error> {\n+        let mut first = true;\n+        for p in predicates {\n+            if !first {\n+                write!(self, \"+\")?;\n+            }\n+            first = false;\n+            self = p.print(self)?;\n+        }\n+        Ok(self)\n+    }\n+\n+    fn print_const(\n+        mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<Self::Const, Self::Error> {\n+        // only print integers\n+        if let ConstValue::Scalar(Scalar::Raw { .. }) = ct.val {\n+            if ct.ty.is_integral() {\n+                return self.pretty_print_const(ct);\n+            }\n+        }\n+        self.write_str(\"_\")?;\n+        Ok(self)\n+    }\n+\n+    fn path_crate(\n+        mut self,\n+        cnum: CrateNum,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.write_str(&self.tcx.original_crate_name(cnum).as_str())?;\n+        Ok(self)\n+    }\n+    fn path_qualified(\n+        self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        // Similar to `pretty_path_qualified`, but for the other\n+        // types that are printed as paths (see `print_type` above).\n+        match self_ty.sty {\n+            ty::FnDef(..) |\n+            ty::Opaque(..) |\n+            ty::Projection(_) |\n+            ty::UnnormalizedProjection(_) |\n+            ty::Closure(..) |\n+            ty::Generator(..)\n+                if trait_ref.is_none() =>\n+            {\n+                self.print_type(self_ty)\n+            }\n+\n+            _ => self.pretty_path_qualified(self_ty, trait_ref)\n+        }\n+    }\n+\n+    fn path_append_impl(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        _disambiguated_data: &DisambiguatedDefPathData,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.pretty_path_append_impl(\n+            |mut cx| {\n+                cx = print_prefix(cx)?;\n+\n+                if cx.keep_within_component {\n+                    // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n+                    cx.write_str(\"::\")?;\n+                } else {\n+                    cx.path.finalize_pending_component();\n+                }\n+\n+                Ok(cx)\n+            },\n+            self_ty,\n+            trait_ref,\n+        )\n+    }\n+    fn path_append(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        // Skip `::{{constructor}}` on tuple/unit structs.\n+        match disambiguated_data.data {\n+            DefPathData::Ctor => return Ok(self),\n+            _ => {}\n+        }\n+\n+        if self.keep_within_component {\n+            // HACK(eddyb) print the path similarly to how `FmtPrinter` prints it.\n+            self.write_str(\"::\")?;\n+        } else {\n+            self.path.finalize_pending_component();\n+        }\n+\n+        self.write_str(&disambiguated_data.data.as_interned_str().as_str())?;\n+        Ok(self)\n+    }\n+    fn path_generic_args(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        args: &[Kind<'tcx>],\n+    )  -> Result<Self::Path, Self::Error> {\n+        self = print_prefix(self)?;\n+\n+        let args = args.iter().cloned().filter(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(_) => false,\n+                _ => true,\n+            }\n+        });\n+\n+        if args.clone().next().is_some() {\n+            self.generic_delimiters(|cx| cx.comma_sep(args))\n+        } else {\n+            Ok(self)\n+        }\n+    }\n+}\n+\n+impl PrettyPrinter<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n+    fn region_should_not_be_omitted(\n+        &self,\n+        _region: ty::Region<'_>,\n+    ) -> bool {\n+        false\n+    }\n+    fn comma_sep<T>(\n+        mut self,\n+        mut elems: impl Iterator<Item = T>,\n+    ) -> Result<Self, Self::Error>\n+        where T: Print<'tcx, 'tcx, Self, Output = Self, Error = Self::Error>\n+    {\n+        if let Some(first) = elems.next() {\n+            self = first.print(self)?;\n+            for elem in elems {\n+                self.write_str(\",\")?;\n+                self = elem.print(self)?;\n+            }\n+        }\n+        Ok(self)\n+    }\n+\n+    fn generic_delimiters(\n+        mut self,\n+        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n+    ) -> Result<Self, Self::Error> {\n+        write!(self, \"<\")?;\n+\n+        let kept_within_component =\n+            mem::replace(&mut self.keep_within_component, true);\n+        self = f(self)?;\n+        self.keep_within_component = kept_within_component;\n+\n+        write!(self, \">\")?;\n+\n+        Ok(self)\n+    }\n+}\n+\n+impl fmt::Write for SymbolPrinter<'_, '_> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        // Name sanitation. LLVM will happily accept identifiers with weird names, but\n+        // gas doesn't!\n+        // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n+        // NVPTX assembly has more strict naming rules than gas, so additionally, dots\n+        // are replaced with '$' there.\n+\n+        for c in s.chars() {\n+            if self.path.temp_buf.is_empty() {\n+                match c {\n+                    'a'..='z' | 'A'..='Z' | '_' => {}\n+                    _ => {\n+                        // Underscore-qualify anything that didn't start as an ident.\n+                        self.path.temp_buf.push('_');\n+                    }\n+                }\n+            }\n+            match c {\n+                // Escape these with $ sequences\n+                '@' => self.path.temp_buf.push_str(\"$SP$\"),\n+                '*' => self.path.temp_buf.push_str(\"$BP$\"),\n+                '&' => self.path.temp_buf.push_str(\"$RF$\"),\n+                '<' => self.path.temp_buf.push_str(\"$LT$\"),\n+                '>' => self.path.temp_buf.push_str(\"$GT$\"),\n+                '(' => self.path.temp_buf.push_str(\"$LP$\"),\n+                ')' => self.path.temp_buf.push_str(\"$RP$\"),\n+                ',' => self.path.temp_buf.push_str(\"$C$\"),\n+\n+                '-' | ':' | '.' if self.tcx.has_strict_asm_symbol_naming() => {\n+                    // NVPTX doesn't support these characters in symbol names.\n+                    self.path.temp_buf.push('$')\n+                }\n+\n+                // '.' doesn't occur in types and functions, so reuse it\n+                // for ':' and '-'\n+                '-' | ':' => self.path.temp_buf.push('.'),\n+\n+                // Avoid crashing LLVM in certain (LTO-related) situations, see #60925.\n+                'm' if self.path.temp_buf.ends_with(\".llv\") => self.path.temp_buf.push_str(\"$6d$\"),\n+\n+                // These are legal symbols\n+                'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '.' | '$' => self.path.temp_buf.push(c),\n+\n+                _ => {\n+                    self.path.temp_buf.push('$');\n+                    for c in c.escape_unicode().skip(1) {\n+                        match c {\n+                            '{' => {}\n+                            '}' => self.path.temp_buf.push('$'),\n+                            c => self.path.temp_buf.push(c),\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "6d37d4cafc350067edf0feec9c5557af96f096bd", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "added", "additions": 664, "deletions": 0, "changes": 664, "blob_url": "https://github.com/rust-lang/rust/blob/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=2092963a1851efca5222bd816557055988ce8f90", "patch": "@@ -0,0 +1,664 @@\n+use rustc::hir;\n+use rustc::hir::def_id::{CrateNum, DefId};\n+use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::print::{Printer, Print};\n+use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n+use rustc_data_structures::base_n;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_mir::monomorphize::Instance;\n+use rustc_target::spec::abi::Abi;\n+use syntax::ast::{IntTy, UintTy, FloatTy};\n+\n+use std::fmt::Write;\n+use std::ops::Range;\n+\n+pub(super) fn mangle(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    instance: Instance<'tcx>,\n+    instantiating_crate: Option<CrateNum>,\n+    compress: bool,\n+) -> String {\n+    let def_id = instance.def_id();\n+    // FIXME(eddyb) this should ideally not be needed.\n+    let substs =\n+        tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), instance.substs);\n+\n+    let prefix = \"_R\";\n+    let mut cx = SymbolMangler {\n+        tcx,\n+        compress: if compress {\n+            Some(Box::new(CompressionCaches {\n+                start_offset: prefix.len(),\n+\n+                paths: FxHashMap::default(),\n+                types: FxHashMap::default(),\n+                consts: FxHashMap::default(),\n+            }))\n+        } else {\n+            None\n+        },\n+        binders: vec![],\n+        out: String::from(prefix),\n+    };\n+    cx = if instance.is_vtable_shim() {\n+        cx.path_append_ns(\n+            |cx| cx.print_def_path(def_id, substs),\n+            'S',\n+            0,\n+            \"\",\n+        ).unwrap()\n+    } else {\n+        cx.print_def_path(def_id, substs).unwrap()\n+    };\n+    if let Some(instantiating_crate) = instantiating_crate {\n+        cx = cx.print_def_path(instantiating_crate.as_def_id(), &[]).unwrap();\n+    }\n+    cx.out\n+}\n+\n+struct CompressionCaches<'tcx> {\n+    // The length of the prefix in `out` (e.g. 2 for `_R`).\n+    start_offset: usize,\n+\n+    // The values are start positions in `out`, in bytes.\n+    paths: FxHashMap<(DefId, &'tcx [Kind<'tcx>]), usize>,\n+    types: FxHashMap<Ty<'tcx>, usize>,\n+    consts: FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n+}\n+\n+struct BinderLevel {\n+    /// The range of distances from the root of what's\n+    /// being printed, to the lifetimes in a binder.\n+    /// Specifically, a `BrAnon(i)` lifetime has depth\n+    /// `lifetime_depths.start + i`, going away from the\n+    /// the root and towards its use site, as `i` increases.\n+    /// This is used to flatten rustc's pairing of `BrAnon`\n+    /// (intra-binder disambiguation) with a `DebruijnIndex`\n+    /// (binder addressing), to \"true\" de Bruijn indices,\n+    /// by subtracting the depth of a certain lifetime, from\n+    /// the innermost depth at its use site.\n+    lifetime_depths: Range<u32>,\n+}\n+\n+struct SymbolMangler<'a, 'tcx> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    compress: Option<Box<CompressionCaches<'tcx>>>,\n+    binders: Vec<BinderLevel>,\n+    out: String,\n+}\n+\n+impl SymbolMangler<'_, 'tcx> {\n+    fn push(&mut self, s: &str) {\n+        self.out.push_str(s);\n+    }\n+\n+    /// Push a `_`-terminated base 62 integer, using the format\n+    /// specified in the RFC as `<base-62-number>`, that is:\n+    /// * `x = 0` is encoded as just the `\"_\"` terminator\n+    /// * `x > 0` is encoded as `x - 1` in base 62, followed by `\"_\"`,\n+    ///   e.g. `1` becomes `\"0_\"`, `62` becomes `\"Z_\"`, etc.\n+    fn push_integer_62(&mut self, x: u64) {\n+        if let Some(x) = x.checked_sub(1) {\n+            base_n::push_str(x as u128, 62, &mut self.out);\n+        }\n+        self.push(\"_\");\n+    }\n+\n+    /// Push a `tag`-prefixed base 62 integer, when larger than `0`, that is:\n+    /// * `x = 0` is encoded as `\"\"` (nothing)\n+    /// * `x > 0` is encoded as the `tag` followed by `push_integer_62(x - 1)`\n+    ///   e.g. `1` becomes `tag + \"_\"`, `2` becomes `tag + \"0_\"`, etc.\n+    fn push_opt_integer_62(&mut self, tag: &str, x: u64) {\n+        if let Some(x) = x.checked_sub(1) {\n+            self.push(tag);\n+            self.push_integer_62(x);\n+        }\n+    }\n+\n+    fn push_disambiguator(&mut self, dis: u64) {\n+        self.push_opt_integer_62(\"s\", dis);\n+    }\n+\n+    fn push_ident(&mut self, ident: &str) {\n+        let mut use_punycode = false;\n+        for b in ident.bytes() {\n+            match b {\n+                b'_' | b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9' => {}\n+                0x80..=0xff => use_punycode = true,\n+                _ => bug!(\"symbol_names: bad byte {} in ident {:?}\", b, ident),\n+            }\n+        }\n+\n+        let punycode_string;\n+        let ident = if use_punycode {\n+            self.push(\"u\");\n+\n+            // FIXME(eddyb) we should probably roll our own punycode implementation.\n+            let mut punycode_bytes = match ::punycode::encode(ident) {\n+                Ok(s) => s.into_bytes(),\n+                Err(()) => bug!(\"symbol_names: punycode encoding failed for ident {:?}\", ident),\n+            };\n+\n+            // Replace `-` with `_`.\n+            if let Some(c) = punycode_bytes.iter_mut().rfind(|&&mut c| c == b'-') {\n+                *c = b'_';\n+            }\n+\n+            // FIXME(eddyb) avoid rechecking UTF-8 validity.\n+            punycode_string = String::from_utf8(punycode_bytes).unwrap();\n+            &punycode_string\n+        } else {\n+            ident\n+        };\n+\n+        let _ = write!(self.out, \"{}\", ident.len());\n+\n+        // Write a separating `_` if necessary (leading digit or `_`).\n+        match ident.chars().next() {\n+            Some('_') | Some('0'..='9') => {\n+                self.push(\"_\");\n+            }\n+            _ => {}\n+        }\n+\n+        self.push(ident);\n+    }\n+\n+    fn path_append_ns(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self, !>,\n+        ns: char,\n+        disambiguator: u64,\n+        name: &str,\n+    ) -> Result<Self, !> {\n+        self.push(\"N\");\n+        self.out.push(ns);\n+        self = print_prefix(self)?;\n+        self.push_disambiguator(disambiguator as u64);\n+        self.push_ident(name);\n+        Ok(self)\n+    }\n+\n+    fn print_backref(mut self, i: usize) -> Result<Self, !> {\n+        self.push(\"B\");\n+        self.push_integer_62((i - self.compress.as_ref().unwrap().start_offset) as u64);\n+        Ok(self)\n+    }\n+\n+    fn in_binder<T>(\n+        mut self,\n+        value: &ty::Binder<T>,\n+        print_value: impl FnOnce(Self, &T) -> Result<Self, !>\n+    ) -> Result<Self, !>\n+        where T: TypeFoldable<'tcx>\n+    {\n+        let regions = if value.has_late_bound_regions() {\n+            self.tcx.collect_referenced_late_bound_regions(value)\n+        } else {\n+            FxHashSet::default()\n+        };\n+\n+        let mut lifetime_depths =\n+            self.binders.last().map(|b| b.lifetime_depths.end).map_or(0..0, |i| i..i);\n+\n+        let lifetimes = regions.into_iter().map(|br| {\n+            match br {\n+                ty::BrAnon(i) => i + 1,\n+                _ => bug!(\"symbol_names: non-anonymized region `{:?}` in `{:?}`\", br, value),\n+            }\n+        }).max().unwrap_or(0);\n+\n+        self.push_opt_integer_62(\"G\", lifetimes as u64);\n+        lifetime_depths.end += lifetimes;\n+\n+        self.binders.push(BinderLevel { lifetime_depths });\n+        self = print_value(self, value.skip_binder())?;\n+        self.binders.pop();\n+\n+        Ok(self)\n+    }\n+}\n+\n+impl Printer<'tcx, 'tcx> for SymbolMangler<'_, 'tcx> {\n+    type Error = !;\n+\n+    type Path = Self;\n+    type Region = Self;\n+    type Type = Self;\n+    type DynExistential = Self;\n+    type Const = Self;\n+\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn print_def_path(\n+        mut self,\n+        def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        if let Some(&i) = self.compress.as_ref().and_then(|c| c.paths.get(&(def_id, substs))) {\n+            return self.print_backref(i);\n+        }\n+        let start = self.out.len();\n+\n+        self = self.default_print_def_path(def_id, substs)?;\n+\n+        // Only cache paths that do not refer to an enclosing\n+        // binder (which would change depending on context).\n+        if !substs.iter().any(|k| k.has_escaping_bound_vars()) {\n+            if let Some(c) = &mut self.compress {\n+                c.paths.insert((def_id, substs), start);\n+            }\n+        }\n+        Ok(self)\n+    }\n+\n+    fn print_impl_path(\n+        self,\n+        impl_def_id: DefId,\n+        substs: &'tcx [Kind<'tcx>],\n+        mut self_ty: Ty<'tcx>,\n+        mut impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        let key = self.tcx.def_key(impl_def_id);\n+        let parent_def_id = DefId { index: key.parent.unwrap(), ..impl_def_id };\n+\n+        let mut param_env = self.tcx.param_env(impl_def_id)\n+            .with_reveal_all();\n+        if !substs.is_empty() {\n+            param_env = param_env.subst(self.tcx, substs);\n+        }\n+\n+        match &mut impl_trait_ref {\n+            Some(impl_trait_ref) => {\n+                assert_eq!(impl_trait_ref.self_ty(), self_ty);\n+                *impl_trait_ref =\n+                    self.tcx.normalize_erasing_regions(param_env, *impl_trait_ref);\n+                self_ty = impl_trait_ref.self_ty();\n+            }\n+            None => {\n+                self_ty = self.tcx.normalize_erasing_regions(param_env, self_ty);\n+            }\n+        }\n+\n+        self.path_append_impl(\n+            |cx| cx.print_def_path(parent_def_id, &[]),\n+            &key.disambiguated_data,\n+            self_ty,\n+            impl_trait_ref,\n+        )\n+    }\n+\n+    fn print_region(\n+        mut self,\n+        region: ty::Region<'_>,\n+    ) -> Result<Self::Region, Self::Error> {\n+        let i = match *region {\n+            // Erased lifetimes use the index 0, for a\n+            // shorter mangling of `L_`.\n+            ty::ReErased => 0,\n+\n+            // Late-bound lifetimes use indices starting at 1,\n+            // see `BinderLevel` for more details.\n+            ty::ReLateBound(debruijn, ty::BrAnon(i)) => {\n+                let binder = &self.binders[self.binders.len() - 1 - debruijn.index()];\n+                let depth = binder.lifetime_depths.start + i;\n+\n+                1 + (self.binders.last().unwrap().lifetime_depths.end - 1 - depth)\n+            }\n+\n+            _ => bug!(\"symbol_names: non-erased region `{:?}`\", region),\n+        };\n+        self.push(\"L\");\n+        self.push_integer_62(i as u64);\n+        Ok(self)\n+    }\n+\n+    fn print_type(\n+        mut self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error> {\n+        // Basic types, never cached (single-character).\n+        let basic_type = match ty.sty {\n+            ty::Bool => \"b\",\n+            ty::Char => \"c\",\n+            ty::Str => \"e\",\n+            ty::Tuple(_) if ty.is_unit() => \"u\",\n+            ty::Int(IntTy::I8) => \"a\",\n+            ty::Int(IntTy::I16) => \"s\",\n+            ty::Int(IntTy::I32) => \"l\",\n+            ty::Int(IntTy::I64) => \"x\",\n+            ty::Int(IntTy::I128) => \"n\",\n+            ty::Int(IntTy::Isize) => \"i\",\n+            ty::Uint(UintTy::U8) => \"h\",\n+            ty::Uint(UintTy::U16) => \"t\",\n+            ty::Uint(UintTy::U32) => \"m\",\n+            ty::Uint(UintTy::U64) => \"y\",\n+            ty::Uint(UintTy::U128) => \"o\",\n+            ty::Uint(UintTy::Usize) => \"j\",\n+            ty::Float(FloatTy::F32) => \"f\",\n+            ty::Float(FloatTy::F64) => \"d\",\n+            ty::Never => \"z\",\n+\n+            // Placeholders (should be demangled as `_`).\n+            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) |\n+            ty::Infer(_) | ty::Error => \"p\",\n+\n+            _ => \"\",\n+        };\n+        if !basic_type.is_empty() {\n+            self.push(basic_type);\n+            return Ok(self);\n+        }\n+\n+        if let Some(&i) = self.compress.as_ref().and_then(|c| c.types.get(&ty)) {\n+            return self.print_backref(i);\n+        }\n+        let start = self.out.len();\n+\n+        match ty.sty {\n+            // Basic types, handled above.\n+            ty::Bool | ty::Char | ty::Str |\n+            ty::Int(_) | ty::Uint(_) | ty::Float(_) |\n+            ty::Never => unreachable!(),\n+            ty::Tuple(_) if ty.is_unit() => unreachable!(),\n+\n+            // Placeholders, also handled as part of basic types.\n+            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) |\n+            ty::Infer(_) | ty::Error => unreachable!(),\n+\n+            ty::Ref(r, ty, mutbl) => {\n+                self.push(match mutbl {\n+                    hir::MutImmutable => \"R\",\n+                    hir::MutMutable => \"Q\",\n+                });\n+                if *r != ty::ReErased {\n+                    self = r.print(self)?;\n+                }\n+                self = ty.print(self)?;\n+            }\n+\n+            ty::RawPtr(mt) => {\n+                self.push(match mt.mutbl {\n+                    hir::MutImmutable => \"P\",\n+                    hir::MutMutable => \"O\",\n+                });\n+                self = mt.ty.print(self)?;\n+            }\n+\n+            ty::Array(ty, len) => {\n+                self.push(\"A\");\n+                self = ty.print(self)?;\n+                self = self.print_const(len)?;\n+            }\n+            ty::Slice(ty) => {\n+                self.push(\"S\");\n+                self = ty.print(self)?;\n+            }\n+\n+            ty::Tuple(tys) => {\n+                self.push(\"T\");\n+                for ty in tys.iter().map(|k| k.expect_ty()) {\n+                    self = ty.print(self)?;\n+                }\n+                self.push(\"E\");\n+            }\n+\n+            // Mangle all nominal types as paths.\n+            ty::Adt(&ty::AdtDef { did: def_id, .. }, substs) |\n+            ty::FnDef(def_id, substs) |\n+            ty::Opaque(def_id, substs) |\n+            ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n+            ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n+            ty::Closure(def_id, ty::ClosureSubsts { substs }) |\n+            ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n+                self = self.print_def_path(def_id, substs)?;\n+            }\n+            ty::Foreign(def_id) => {\n+                self = self.print_def_path(def_id, &[])?;\n+            }\n+\n+            ty::FnPtr(sig) => {\n+                self.push(\"F\");\n+                self = self.in_binder(&sig, |mut cx, sig| {\n+                    if sig.unsafety == hir::Unsafety::Unsafe {\n+                        cx.push(\"U\");\n+                    }\n+                    match sig.abi {\n+                        Abi::Rust => {}\n+                        Abi::C => cx.push(\"KC\"),\n+                        abi => {\n+                            cx.push(\"K\");\n+                            let name = abi.name();\n+                            if name.contains('-') {\n+                                cx.push_ident(&name.replace('-', \"_\"));\n+                            } else {\n+                                cx.push_ident(name);\n+                            }\n+                        }\n+                    }\n+                    for &ty in sig.inputs() {\n+                        cx = ty.print(cx)?;\n+                    }\n+                    if sig.c_variadic {\n+                        cx.push(\"v\");\n+                    }\n+                    cx.push(\"E\");\n+                    sig.output().print(cx)\n+                })?;\n+            }\n+\n+            ty::Dynamic(predicates, r) => {\n+                self.push(\"D\");\n+                self = self.in_binder(&predicates, |cx, predicates| {\n+                    cx.print_dyn_existential(predicates)\n+                })?;\n+                self = r.print(self)?;\n+            }\n+\n+            ty::GeneratorWitness(_) => {\n+                bug!(\"symbol_names: unexpected `GeneratorWitness`\")\n+            }\n+        }\n+\n+        // Only cache types that do not refer to an enclosing\n+        // binder (which would change depending on context).\n+        if !ty.has_escaping_bound_vars() {\n+            if let Some(c) = &mut self.compress {\n+                c.types.insert(ty, start);\n+            }\n+        }\n+        Ok(self)\n+    }\n+\n+    fn print_dyn_existential(\n+        mut self,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    ) -> Result<Self::DynExistential, Self::Error> {\n+        for predicate in predicates {\n+            match *predicate {\n+                ty::ExistentialPredicate::Trait(trait_ref) => {\n+                    // Use a type that can't appear in defaults of type parameters.\n+                    let dummy_self = self.tcx.mk_ty_infer(ty::FreshTy(0));\n+                    let trait_ref = trait_ref.with_self_ty(self.tcx, dummy_self);\n+                    self = self.print_def_path(trait_ref.def_id, trait_ref.substs)?;\n+                }\n+                ty::ExistentialPredicate::Projection(projection) => {\n+                    let name = self.tcx.associated_item(projection.item_def_id).ident;\n+                    self.push(\"p\");\n+                    self.push_ident(&name.as_str());\n+                    self = projection.ty.print(self)?;\n+                }\n+                ty::ExistentialPredicate::AutoTrait(def_id) => {\n+                    self = self.print_def_path(def_id, &[])?;\n+                }\n+            }\n+        }\n+        self.push(\"E\");\n+        Ok(self)\n+    }\n+\n+    fn print_const(\n+        mut self,\n+        ct: &'tcx ty::Const<'tcx>,\n+    ) -> Result<Self::Const, Self::Error> {\n+        if let Some(&i) = self.compress.as_ref().and_then(|c| c.consts.get(&ct)) {\n+            return self.print_backref(i);\n+        }\n+        let start = self.out.len();\n+\n+        match ct.ty.sty {\n+            ty::Uint(_) => {}\n+            _ => {\n+                bug!(\"symbol_names: unsupported constant of type `{}` ({:?})\",\n+                    ct.ty, ct);\n+            }\n+        }\n+        self = ct.ty.print(self)?;\n+\n+        if let Some(bits) = ct.assert_bits(self.tcx, ty::ParamEnv::empty().and(ct.ty)) {\n+            let _ = write!(self.out, \"{:x}_\", bits);\n+        } else {\n+            // NOTE(eddyb) despite having the path, we need to\n+            // encode a placeholder, as the path could refer\n+            // back to e.g. an `impl` using the constant.\n+            self.push(\"p\");\n+        }\n+\n+        // Only cache consts that do not refer to an enclosing\n+        // binder (which would change depending on context).\n+        if !ct.has_escaping_bound_vars() {\n+            if let Some(c) = &mut self.compress {\n+                c.consts.insert(ct, start);\n+            }\n+        }\n+        Ok(self)\n+    }\n+\n+    fn path_crate(\n+        mut self,\n+        cnum: CrateNum,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.push(\"C\");\n+        let fingerprint = self.tcx.crate_disambiguator(cnum).to_fingerprint();\n+        self.push_disambiguator(fingerprint.to_smaller_hash());\n+        let name = self.tcx.original_crate_name(cnum).as_str();\n+        self.push_ident(&name);\n+        Ok(self)\n+    }\n+    fn path_qualified(\n+        mut self,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        assert!(trait_ref.is_some());\n+        let trait_ref = trait_ref.unwrap();\n+\n+        self.push(\"Y\");\n+        self = self_ty.print(self)?;\n+        self.print_def_path(trait_ref.def_id, trait_ref.substs)\n+    }\n+\n+    fn path_append_impl(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+        self_ty: Ty<'tcx>,\n+        trait_ref: Option<ty::TraitRef<'tcx>>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        self.push(match trait_ref {\n+            Some(_) => \"X\",\n+            None => \"M\",\n+        });\n+        self.push_disambiguator(disambiguated_data.disambiguator as u64);\n+        self = print_prefix(self)?;\n+        self = self_ty.print(self)?;\n+        if let Some(trait_ref) = trait_ref {\n+            self = self.print_def_path(trait_ref.def_id, trait_ref.substs)?;\n+        }\n+        Ok(self)\n+    }\n+    fn path_append(\n+        self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        disambiguated_data: &DisambiguatedDefPathData,\n+    ) -> Result<Self::Path, Self::Error> {\n+        let ns = match disambiguated_data.data {\n+            // Avoid putting the burden on demanglers to ignore this.\n+            DefPathData::Ctor => return print_prefix(self),\n+\n+            // Uppercase categories are more stable than lowercase ones.\n+            DefPathData::TypeNs(_) => 't',\n+            DefPathData::ValueNs(_) => 'v',\n+            DefPathData::ClosureExpr => 'C',\n+            DefPathData::AnonConst => 'k',\n+            DefPathData::ImplTrait => 'i',\n+\n+            // These should never show up as `path_append` arguments.\n+            DefPathData::CrateRoot\n+            | DefPathData::Misc\n+            | DefPathData::Impl\n+            | DefPathData::MacroNs(_)\n+            | DefPathData::LifetimeNs(_)\n+            | DefPathData::GlobalMetaData(_) => {\n+                bug!(\"symbol_names: unexpected DefPathData: {:?}\", disambiguated_data.data)\n+            }\n+        };\n+\n+        let name = disambiguated_data.data.get_opt_name().map(|s| s.as_str());\n+\n+        self.path_append_ns(\n+            print_prefix,\n+            ns,\n+            disambiguated_data.disambiguator as u64,\n+            name.as_ref().map_or(\"\", |s| &s[..])\n+        )\n+    }\n+    fn path_generic_args(\n+        mut self,\n+        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+        args: &[Kind<'tcx>],\n+    ) -> Result<Self::Path, Self::Error> {\n+        // Don't print any regions if they're all erased.\n+        let print_regions = args.iter().any(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n+                _ => false,\n+            }\n+        });\n+        let args = args.iter().cloned().filter(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(_) => print_regions,\n+                _ => true,\n+            }\n+        });\n+\n+        if args.clone().next().is_none() {\n+            return print_prefix(self);\n+        }\n+\n+        self.push(\"I\");\n+        self = print_prefix(self)?;\n+        for arg in args {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(lt) => {\n+                    self = lt.print(self)?;\n+                }\n+                UnpackedKind::Type(ty) => {\n+                    self = ty.print(self)?;\n+                }\n+                UnpackedKind::Const(c) => {\n+                    self.push(\"K\");\n+                    // FIXME(const_generics) implement `ty::print::Print` on `ty::Const`.\n+                    // self = c.print(self)?;\n+                    self = self.print_const(c)?;\n+                }\n+            }\n+        }\n+        self.push(\"E\");\n+\n+        Ok(self)\n+    }\n+}"}, {"sha": "e04372ea280b5dd0c8fab7b8a79cc9588877a606", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=2092963a1851efca5222bd816557055988ce8f90", "patch": "@@ -176,6 +176,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         r.map(|c| &*tcx.arena.alloc(c))\n     }\n     is_no_builtins => { cdata.root.no_builtins }\n+    symbol_mangling_version => { cdata.root.symbol_mangling_version }\n     impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n     reachable_non_generics => {\n         let reachable_non_generics = tcx"}, {"sha": "586fc507dd3ebaa81ec0b3a61bd3f7cede2f8070", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=2092963a1851efca5222bd816557055988ce8f90", "patch": "@@ -498,6 +498,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             panic_runtime: attr::contains_name(&attrs, sym::panic_runtime),\n             profiler_runtime: attr::contains_name(&attrs, sym::profiler_runtime),\n             sanitizer_runtime: attr::contains_name(&attrs, sym::sanitizer_runtime),\n+            symbol_mangling_version: tcx.sess.opts.debugging_opts.symbol_mangling_version,\n \n             crate_deps,\n             dylib_dependency_formats,"}, {"sha": "8d1de4fd6c392a03a4bff6df3080c5581f4d29e5", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2092963a1851efca5222bd816557055988ce8f90/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=2092963a1851efca5222bd816557055988ce8f90", "patch": "@@ -8,6 +8,7 @@ use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary, ForeignMo\n use rustc::middle::lang_items;\n use rustc::mir;\n use rustc::session::CrateDisambiguator;\n+use rustc::session::config::SymbolManglingVersion;\n use rustc::ty::{self, Ty, ReprOptions};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n use rustc_data_structures::svh::Svh;\n@@ -189,6 +190,7 @@ pub struct CrateRoot<'tcx> {\n     pub panic_runtime: bool,\n     pub profiler_runtime: bool,\n     pub sanitizer_runtime: bool,\n+    pub symbol_mangling_version: SymbolManglingVersion,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}]}