{"sha": "a80ec3b3b1d11ed83754885efdd07037d256dbf2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MGVjM2IzYjFkMTFlZDgzNzU0ODg1ZWZkZDA3MDM3ZDI1NmRiZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-30T09:16:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-30T09:16:21Z"}, "message": "Auto merge of #70326 - matthiaskrgr:cl1ppy_single_match, r=Centril\n\nUse if let instead of match when only matching a single variant (clippy::single_match)\n\nMakes code more compact and reduces nesting.", "tree": {"sha": "955fb13c65c6a29f4ad8535485f91c2c77b7233b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/955fb13c65c6a29f4ad8535485f91c2c77b7233b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a80ec3b3b1d11ed83754885efdd07037d256dbf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a80ec3b3b1d11ed83754885efdd07037d256dbf2", "html_url": "https://github.com/rust-lang/rust/commit/a80ec3b3b1d11ed83754885efdd07037d256dbf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a80ec3b3b1d11ed83754885efdd07037d256dbf2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8926bb497d9b127eb318aea5aed0e745d8381591", "url": "https://api.github.com/repos/rust-lang/rust/commits/8926bb497d9b127eb318aea5aed0e745d8381591", "html_url": "https://github.com/rust-lang/rust/commit/8926bb497d9b127eb318aea5aed0e745d8381591"}, {"sha": "9bba047c2e425fce03b039bcb8ccd60ddcbc80a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bba047c2e425fce03b039bcb8ccd60ddcbc80a0", "html_url": "https://github.com/rust-lang/rust/commit/9bba047c2e425fce03b039bcb8ccd60ddcbc80a0"}], "stats": {"total": 1342, "additions": 591, "deletions": 751}, "files": [{"sha": "b319ee76c819f6d64435e307d1721541799b1679", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -1332,17 +1332,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                                         self.resolver.definitions().as_local_node_id(def_id)\n                                     {\n                                         for param in &generics.params {\n-                                            match param.kind {\n-                                                GenericParamKind::Type { .. } => {\n-                                                    if node_id == param.id {\n-                                                        add_bounds\n-                                                            .entry(param.id)\n-                                                            .or_default()\n-                                                            .push(bound.clone());\n-                                                        continue 'next_bound;\n-                                                    }\n+                                            if let GenericParamKind::Type { .. } = param.kind {\n+                                                if node_id == param.id {\n+                                                    add_bounds\n+                                                        .entry(param.id)\n+                                                        .or_default()\n+                                                        .push(bound.clone());\n+                                                    continue 'next_bound;\n                                                 }\n-                                                _ => {}\n                                             }\n                                         }\n                                     }"}, {"sha": "76c790f80b86bd7503f34664bcefad167723b488", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -516,27 +516,25 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n-        match param.kind {\n-            GenericParamKind::Const { .. } => gate_feature_post!(\n+        if let GenericParamKind::Const { .. } = param.kind {\n+            gate_feature_post!(\n                 &self,\n                 const_generics,\n                 param.ident.span,\n                 \"const generics are unstable\"\n-            ),\n-            _ => {}\n+            )\n         }\n         visit::walk_generic_param(self, param)\n     }\n \n     fn visit_assoc_ty_constraint(&mut self, constraint: &'a AssocTyConstraint) {\n-        match constraint.kind {\n-            AssocTyConstraintKind::Bound { .. } => gate_feature_post!(\n+        if let AssocTyConstraintKind::Bound { .. } = constraint.kind {\n+            gate_feature_post!(\n                 &self,\n                 associated_type_bounds,\n                 constraint.span,\n                 \"associated type bounds are unstable\"\n-            ),\n-            _ => {}\n+            )\n         }\n         visit::walk_assoc_ty_constraint(self, constraint)\n     }"}, {"sha": "6541ac156b48705db81f700d716f9eb8bb5203eb", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -637,9 +637,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         match tt {\n             TokenTree::Token(ref token) => {\n                 self.word(token_to_string_ext(&token, convert_dollar_crate));\n-                match token.kind {\n-                    token::DocComment(..) => self.hardbreak(),\n-                    _ => {}\n+                if let token::DocComment(..) = token.kind {\n+                    self.hardbreak()\n                 }\n             }\n             TokenTree::Delimited(dspan, delim, tts) => {\n@@ -1390,13 +1389,10 @@ impl<'a> State<'a> {\n         self.print_visibility(&v.vis);\n         let generics = ast::Generics::default();\n         self.print_struct(&v.data, &generics, v.ident, v.span, false);\n-        match v.disr_expr {\n-            Some(ref d) => {\n-                self.s.space();\n-                self.word_space(\"=\");\n-                self.print_expr(&d.value)\n-            }\n-            _ => {}\n+        if let Some(ref d) = v.disr_expr {\n+            self.s.space();\n+            self.word_space(\"=\");\n+            self.print_expr(&d.value)\n         }\n     }\n \n@@ -2082,12 +2078,10 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::Yield(ref e) => {\n                 self.s.word(\"yield\");\n-                match *e {\n-                    Some(ref expr) => {\n-                        self.s.space();\n-                        self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n-                    }\n-                    _ => (),\n+\n+                if let Some(ref expr) = *e {\n+                    self.s.space();\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n             ast::ExprKind::Try(ref e) => {\n@@ -2139,9 +2133,8 @@ impl<'a> State<'a> {\n         self.s.word(\"::\");\n         let item_segment = path.segments.last().unwrap();\n         self.print_ident(item_segment.ident);\n-        match item_segment.args {\n-            Some(ref args) => self.print_generic_args(args, colons_before_params),\n-            None => {}\n+        if let Some(ref args) = item_segment.args {\n+            self.print_generic_args(args, colons_before_params)\n         }\n     }\n "}, {"sha": "6b0c9f1018b6c3973154307b08d761848135b2b4", "filename": "src/librustc_builtin_macros/format_foreign.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_builtin_macros%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_builtin_macros%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat_foreign.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -27,11 +27,8 @@ pub mod printf {\n         }\n \n         pub fn set_position(&mut self, start: usize, end: usize) {\n-            match self {\n-                Substitution::Format(ref mut fmt) => {\n-                    fmt.position = InnerSpan::new(start, end);\n-                }\n-                _ => {}\n+            if let Substitution::Format(ref mut fmt) = self {\n+                fmt.position = InnerSpan::new(start, end);\n             }\n         }\n \n@@ -311,9 +308,8 @@ pub mod printf {\n \n         let at = {\n             let start = s.find('%')?;\n-            match s[start + 1..].chars().next()? {\n-                '%' => return Some((Substitution::Escape, &s[start + 2..])),\n-                _ => { /* fall-through */ }\n+            if let '%' = s[start + 1..].chars().next()? {\n+                return Some((Substitution::Escape, &s[start + 2..]));\n             }\n \n             Cur::new_at(&s[..], start)"}, {"sha": "b90c7e51ccd6915eefb41bb03663783c200846c7", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -1869,16 +1869,14 @@ fn prepare_enum_metadata(\n \n     let layout = cx.layout_of(enum_type);\n \n-    match (&layout.abi, &layout.variants) {\n-        (\n-            &layout::Abi::Scalar(_),\n-            &layout::Variants::Multiple {\n-                discr_kind: layout::DiscriminantKind::Tag,\n-                ref discr,\n-                ..\n-            },\n-        ) => return FinalMetadata(discriminant_type_metadata(discr.value)),\n-        _ => {}\n+    if let (\n+        &layout::Abi::Scalar(_),\n+        &layout::Variants::Multiple {\n+            discr_kind: layout::DiscriminantKind::Tag, ref discr, ..\n+        },\n+    ) = (&layout.abi, &layout.variants)\n+    {\n+        return FinalMetadata(discriminant_type_metadata(discr.value));\n     }\n \n     if use_enum_fallback(cx) {"}, {"sha": "87777bd674bf2aaff01ddad355e07872b36b74b1", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -177,9 +177,8 @@ impl<'hir> PrinterSupport for IdentifiedAnnotation<'hir> {\n \n impl<'hir> pprust::PpAnn for IdentifiedAnnotation<'hir> {\n     fn pre(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) {\n-        match node {\n-            pprust::AnnNode::Expr(_) => s.popen(),\n-            _ => {}\n+        if let pprust::AnnNode::Expr(_) = node {\n+            s.popen();\n         }\n     }\n     fn post(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) {\n@@ -232,9 +231,8 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n         }\n     }\n     fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n-        match node {\n-            pprust_hir::AnnNode::Expr(_) => s.popen(),\n-            _ => {}\n+        if let pprust_hir::AnnNode::Expr(_) = node {\n+            s.popen();\n         }\n     }\n     fn post(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n@@ -339,21 +337,17 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n         self.tables.set(old_tables);\n     }\n     fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n-        match node {\n-            pprust_hir::AnnNode::Expr(_) => s.popen(),\n-            _ => {}\n+        if let pprust_hir::AnnNode::Expr(_) = node {\n+            s.popen();\n         }\n     }\n     fn post(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n-        match node {\n-            pprust_hir::AnnNode::Expr(expr) => {\n-                s.s.space();\n-                s.s.word(\"as\");\n-                s.s.space();\n-                s.s.word(self.tables.get().expr_ty(expr).to_string());\n-                s.pclose();\n-            }\n-            _ => {}\n+        if let pprust_hir::AnnNode::Expr(expr) = node {\n+            s.s.space();\n+            s.s.word(\"as\");\n+            s.s.space();\n+            s.s.word(self.tables.get().expr_ty(expr).to_string());\n+            s.pclose();\n         }\n     }\n }"}, {"sha": "3a7e108ddafa79e64bbd32bc9b7f29d01da31888", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -1719,40 +1719,36 @@ impl EmitterWriter {\n                 if !self.short_message {\n                     for child in children {\n                         let span = child.render_span.as_ref().unwrap_or(&child.span);\n-                        match self.emit_message_default(\n+                        if let Err(err) = self.emit_message_default(\n                             &span,\n                             &child.styled_message(),\n                             &None,\n                             &child.level,\n                             max_line_num_len,\n                             true,\n                         ) {\n-                            Err(e) => panic!(\"failed to emit error: {}\", e),\n-                            _ => (),\n+                            panic!(\"failed to emit error: {}\", err);\n                         }\n                     }\n                     for sugg in suggestions {\n                         if sugg.style == SuggestionStyle::CompletelyHidden {\n                             // do not display this suggestion, it is meant only for tools\n                         } else if sugg.style == SuggestionStyle::HideCodeAlways {\n-                            match self.emit_message_default(\n+                            if let Err(e) = self.emit_message_default(\n                                 &MultiSpan::new(),\n                                 &[(sugg.msg.to_owned(), Style::HeaderMsg)],\n                                 &None,\n                                 &Level::Help,\n                                 max_line_num_len,\n                                 true,\n                             ) {\n-                                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => (),\n+                                panic!(\"failed to emit error: {}\", e);\n                             }\n-                        } else {\n-                            match self.emit_suggestion_default(sugg, &Level::Help, max_line_num_len)\n-                            {\n-                                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => (),\n-                            }\n-                        }\n+                        } else if let Err(e) =\n+                            self.emit_suggestion_default(sugg, &Level::Help, max_line_num_len)\n+                        {\n+                            panic!(\"failed to emit error: {}\", e);\n+                        };\n                     }\n                 }\n             }\n@@ -1762,10 +1758,11 @@ impl EmitterWriter {\n         let mut dst = self.dst.writable();\n         match writeln!(dst) {\n             Err(e) => panic!(\"failed to emit error: {}\", e),\n-            _ => match dst.flush() {\n-                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                _ => (),\n-            },\n+            _ => {\n+                if let Err(e) = dst.flush() {\n+                    panic!(\"failed to emit error: {}\", e)\n+                }\n+            }\n         }\n     }\n }\n@@ -2149,11 +2146,8 @@ impl<'a> Write for WritableDst<'a> {\n \n impl<'a> Drop for WritableDst<'a> {\n     fn drop(&mut self) {\n-        match *self {\n-            WritableDst::Buffered(ref mut dst, ref mut buf) => {\n-                drop(dst.print(buf));\n-            }\n-            _ => {}\n+        if let WritableDst::Buffered(ref mut dst, ref mut buf) = self {\n+            drop(dst.print(buf));\n         }\n     }\n }"}, {"sha": "7d2c4fbf7af32ea65cffe9354ea647848fe0ecdb", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -354,20 +354,19 @@ fn generic_extension<'cx>(\n                 mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n                 _ => continue,\n             };\n-            match parse_tt(&mut Cow::Borrowed(&parser_from_cx(sess, arg.clone())), lhs_tt) {\n-                Success(_) => {\n-                    if comma_span.is_dummy() {\n-                        err.note(\"you might be missing a comma\");\n-                    } else {\n-                        err.span_suggestion_short(\n-                            comma_span,\n-                            \"missing comma here\",\n-                            \", \".to_string(),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n+            if let Success(_) =\n+                parse_tt(&mut Cow::Borrowed(&parser_from_cx(sess, arg.clone())), lhs_tt)\n+            {\n+                if comma_span.is_dummy() {\n+                    err.note(\"you might be missing a comma\");\n+                } else {\n+                    err.span_suggestion_short(\n+                        comma_span,\n+                        \"missing comma here\",\n+                        \", \".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n                 }\n-                _ => {}\n             }\n         }\n     }"}, {"sha": "8ba14ab5d0b5a7e11e36ee593f13bf1e38317cf7", "filename": "src/librustc_hir_pretty/lib.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_hir_pretty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_hir_pretty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2Flib.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -2036,13 +2036,10 @@ impl<'a> State<'a> {\n             }\n             GenericParamKind::Type { ref default, .. } => {\n                 self.print_bounds(\":\", param.bounds);\n-                match default {\n-                    Some(default) => {\n-                        self.s.space();\n-                        self.word_space(\"=\");\n-                        self.print_type(&default)\n-                    }\n-                    _ => {}\n+                if let Some(default) = default {\n+                    self.s.space();\n+                    self.word_space(\"=\");\n+                    self.print_type(&default)\n                 }\n             }\n             GenericParamKind::Const { ref ty } => {\n@@ -2145,9 +2142,8 @@ impl<'a> State<'a> {\n         }\n         self.end();\n \n-        match decl.output {\n-            hir::FnRetTy::Return(ref output) => self.maybe_print_comment(output.span.lo()),\n-            _ => {}\n+        if let hir::FnRetTy::Return(ref output) = decl.output {\n+            self.maybe_print_comment(output.span.lo())\n         }\n     }\n \n@@ -2222,12 +2218,9 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_extern_opt_abi(&mut self, opt_abi: Option<Abi>) {\n-        match opt_abi {\n-            Some(abi) => {\n-                self.word_nbsp(\"extern\");\n-                self.word_nbsp(abi.to_string())\n-            }\n-            None => {}\n+        if let Some(abi) = opt_abi {\n+            self.word_nbsp(\"extern\");\n+            self.word_nbsp(abi.to_string())\n         }\n     }\n "}, {"sha": "925f92edd7da9cd3e1b0a688728d63db4e213125", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 77, "deletions": 85, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -1386,13 +1386,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         // For some types of errors, expected-found does not make\n         // sense, so just ignore the values we were given.\n-        match terr {\n-            TypeError::CyclicTy(_) => {\n-                values = None;\n-            }\n-            _ => {}\n+        if let TypeError::CyclicTy(_) = terr {\n+            values = None;\n         }\n-\n         struct OpaqueTypesVisitor<'tcx> {\n             types: FxHashMap<TyCategory, FxHashSet<Span>>,\n             expected: FxHashMap<TyCategory, FxHashSet<Span>>,\n@@ -1613,60 +1609,57 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n         diag: &mut DiagnosticBuilder<'tcx>,\n     ) {\n-        match (&exp_found.expected.kind, &exp_found.found.kind) {\n-            (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) => {\n-                if let ty::Adt(found_def, found_substs) = found_ty.kind {\n-                    let path_str = format!(\"{:?}\", exp_def);\n-                    if exp_def == &found_def {\n-                        let opt_msg = \"you can convert from `&Option<T>` to `Option<&T>` using \\\n+        if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n+            (&exp_found.expected.kind, &exp_found.found.kind)\n+        {\n+            if let ty::Adt(found_def, found_substs) = found_ty.kind {\n+                let path_str = format!(\"{:?}\", exp_def);\n+                if exp_def == &found_def {\n+                    let opt_msg = \"you can convert from `&Option<T>` to `Option<&T>` using \\\n                                        `.as_ref()`\";\n-                        let result_msg = \"you can convert from `&Result<T, E>` to \\\n+                    let result_msg = \"you can convert from `&Result<T, E>` to \\\n                                           `Result<&T, &E>` using `.as_ref()`\";\n-                        let have_as_ref = &[\n-                            (\"std::option::Option\", opt_msg),\n-                            (\"core::option::Option\", opt_msg),\n-                            (\"std::result::Result\", result_msg),\n-                            (\"core::result::Result\", result_msg),\n-                        ];\n-                        if let Some(msg) = have_as_ref\n-                            .iter()\n-                            .filter_map(\n-                                |(path, msg)| if &path_str == path { Some(msg) } else { None },\n-                            )\n-                            .next()\n-                        {\n-                            let mut show_suggestion = true;\n-                            for (exp_ty, found_ty) in exp_substs.types().zip(found_substs.types()) {\n-                                match exp_ty.kind {\n-                                    ty::Ref(_, exp_ty, _) => {\n-                                        match (&exp_ty.kind, &found_ty.kind) {\n-                                            (_, ty::Param(_))\n-                                            | (_, ty::Infer(_))\n-                                            | (ty::Param(_), _)\n-                                            | (ty::Infer(_), _) => {}\n-                                            _ if ty::TyS::same_type(exp_ty, found_ty) => {}\n-                                            _ => show_suggestion = false,\n-                                        };\n-                                    }\n-                                    ty::Param(_) | ty::Infer(_) => {}\n-                                    _ => show_suggestion = false,\n+                    let have_as_ref = &[\n+                        (\"std::option::Option\", opt_msg),\n+                        (\"core::option::Option\", opt_msg),\n+                        (\"std::result::Result\", result_msg),\n+                        (\"core::result::Result\", result_msg),\n+                    ];\n+                    if let Some(msg) = have_as_ref\n+                        .iter()\n+                        .filter_map(|(path, msg)| if &path_str == path { Some(msg) } else { None })\n+                        .next()\n+                    {\n+                        let mut show_suggestion = true;\n+                        for (exp_ty, found_ty) in exp_substs.types().zip(found_substs.types()) {\n+                            match exp_ty.kind {\n+                                ty::Ref(_, exp_ty, _) => {\n+                                    match (&exp_ty.kind, &found_ty.kind) {\n+                                        (_, ty::Param(_))\n+                                        | (_, ty::Infer(_))\n+                                        | (ty::Param(_), _)\n+                                        | (ty::Infer(_), _) => {}\n+                                        _ if ty::TyS::same_type(exp_ty, found_ty) => {}\n+                                        _ => show_suggestion = false,\n+                                    };\n                                 }\n+                                ty::Param(_) | ty::Infer(_) => {}\n+                                _ => show_suggestion = false,\n                             }\n-                            if let (Ok(snippet), true) =\n-                                (self.tcx.sess.source_map().span_to_snippet(span), show_suggestion)\n-                            {\n-                                diag.span_suggestion(\n-                                    span,\n-                                    msg,\n-                                    format!(\"{}.as_ref()\", snippet),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n+                        }\n+                        if let (Ok(snippet), true) =\n+                            (self.tcx.sess.source_map().span_to_snippet(span), show_suggestion)\n+                        {\n+                            diag.span_suggestion(\n+                                span,\n+                                msg,\n+                                format!(\"{}.as_ref()\", snippet),\n+                                Applicability::MachineApplicable,\n+                            );\n                         }\n                     }\n                 }\n             }\n-            _ => {}\n         }\n     }\n \n@@ -1955,42 +1948,41 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             \"...\",\n         );\n \n-        match (&sup_origin, &sub_origin) {\n-            (&infer::Subtype(ref sup_trace), &infer::Subtype(ref sub_trace)) => {\n-                debug!(\"report_sub_sup_conflict: var_origin={:?}\", var_origin);\n-                debug!(\"report_sub_sup_conflict: sub_region={:?}\", sub_region);\n-                debug!(\"report_sub_sup_conflict: sub_origin={:?}\", sub_origin);\n-                debug!(\"report_sub_sup_conflict: sup_region={:?}\", sup_region);\n-                debug!(\"report_sub_sup_conflict: sup_origin={:?}\", sup_origin);\n-                debug!(\"report_sub_sup_conflict: sup_trace={:?}\", sup_trace);\n-                debug!(\"report_sub_sup_conflict: sub_trace={:?}\", sub_trace);\n-                debug!(\"report_sub_sup_conflict: sup_trace.values={:?}\", sup_trace.values);\n-                debug!(\"report_sub_sup_conflict: sub_trace.values={:?}\", sub_trace.values);\n-\n-                if let (Some((sup_expected, sup_found)), Some((sub_expected, sub_found))) =\n-                    (self.values_str(&sup_trace.values), self.values_str(&sub_trace.values))\n-                {\n-                    if sub_expected == sup_expected && sub_found == sup_found {\n-                        note_and_explain_region(\n-                            self.tcx,\n-                            region_scope_tree,\n-                            &mut err,\n-                            \"...but the lifetime must also be valid for \",\n-                            sub_region,\n-                            \"...\",\n-                        );\n-                        err.span_note(\n-                            sup_trace.cause.span,\n-                            &format!(\"...so that the {}\", sup_trace.cause.as_requirement_str()),\n-                        );\n+        if let (&infer::Subtype(ref sup_trace), &infer::Subtype(ref sub_trace)) =\n+            (&sup_origin, &sub_origin)\n+        {\n+            debug!(\"report_sub_sup_conflict: var_origin={:?}\", var_origin);\n+            debug!(\"report_sub_sup_conflict: sub_region={:?}\", sub_region);\n+            debug!(\"report_sub_sup_conflict: sub_origin={:?}\", sub_origin);\n+            debug!(\"report_sub_sup_conflict: sup_region={:?}\", sup_region);\n+            debug!(\"report_sub_sup_conflict: sup_origin={:?}\", sup_origin);\n+            debug!(\"report_sub_sup_conflict: sup_trace={:?}\", sup_trace);\n+            debug!(\"report_sub_sup_conflict: sub_trace={:?}\", sub_trace);\n+            debug!(\"report_sub_sup_conflict: sup_trace.values={:?}\", sup_trace.values);\n+            debug!(\"report_sub_sup_conflict: sub_trace.values={:?}\", sub_trace.values);\n+\n+            if let (Some((sup_expected, sup_found)), Some((sub_expected, sub_found))) =\n+                (self.values_str(&sup_trace.values), self.values_str(&sub_trace.values))\n+            {\n+                if sub_expected == sup_expected && sub_found == sup_found {\n+                    note_and_explain_region(\n+                        self.tcx,\n+                        region_scope_tree,\n+                        &mut err,\n+                        \"...but the lifetime must also be valid for \",\n+                        sub_region,\n+                        \"...\",\n+                    );\n+                    err.span_note(\n+                        sup_trace.cause.span,\n+                        &format!(\"...so that the {}\", sup_trace.cause.as_requirement_str()),\n+                    );\n \n-                        err.note_expected_found(&\"\", sup_expected, &\"\", sup_found);\n-                        err.emit();\n-                        return;\n-                    }\n+                    err.note_expected_found(&\"\", sup_expected, &\"\", sup_found);\n+                    err.emit();\n+                    return;\n                 }\n             }\n-            _ => {}\n         }\n \n         self.note_region_origin(&mut err, &sup_origin);"}, {"sha": "a2cd54b48d5204922301c826727c28e2761e047b", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -22,26 +22,25 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 _sup,\n             ) = error.clone()\n             {\n-                match (&sup_origin, &sub_origin) {\n-                    (&Subtype(ref sup_trace), &Subtype(ref sub_trace)) => {\n-                        if let (\n-                            ValuePairs::Types(sub_expected_found),\n-                            ValuePairs::Types(sup_expected_found),\n-                            CompareImplMethodObligation { trait_item_def_id, .. },\n-                        ) = (&sub_trace.values, &sup_trace.values, &sub_trace.cause.code)\n-                        {\n-                            if sup_expected_found == sub_expected_found {\n-                                self.emit_err(\n-                                    var_origin.span(),\n-                                    sub_expected_found.expected,\n-                                    sub_expected_found.found,\n-                                    self.tcx().def_span(*trait_item_def_id),\n-                                );\n-                                return Some(ErrorReported);\n-                            }\n+                if let (&Subtype(ref sup_trace), &Subtype(ref sub_trace)) =\n+                    (&sup_origin, &sub_origin)\n+                {\n+                    if let (\n+                        ValuePairs::Types(sub_expected_found),\n+                        ValuePairs::Types(sup_expected_found),\n+                        CompareImplMethodObligation { trait_item_def_id, .. },\n+                    ) = (&sub_trace.values, &sup_trace.values, &sub_trace.cause.code)\n+                    {\n+                        if sup_expected_found == sub_expected_found {\n+                            self.emit_err(\n+                                var_origin.span(),\n+                                sub_expected_found.expected,\n+                                sub_expected_found.found,\n+                                self.tcx().def_span(*trait_item_def_id),\n+                            );\n+                            return Some(ErrorReported);\n                         }\n                     }\n-                    _ => {}\n                 }\n             }\n         }"}, {"sha": "646febec72334828ea125c2d93e53ff5b7736409", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 29, "deletions": 39, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -645,41 +645,35 @@ declare_lint_pass!(\n \n impl EarlyLintPass for AnonymousParameters {\n     fn check_trait_item(&mut self, cx: &EarlyContext<'_>, it: &ast::AssocItem) {\n-        match it.kind {\n-            ast::AssocItemKind::Fn(_, ref sig, _, _) => {\n-                for arg in sig.decl.inputs.iter() {\n-                    match arg.pat.kind {\n-                        ast::PatKind::Ident(_, ident, None) => {\n-                            if ident.name == kw::Invalid {\n-                                cx.struct_span_lint(ANONYMOUS_PARAMETERS, arg.pat.span, |lint| {\n-                                    let ty_snip = cx.sess.source_map().span_to_snippet(arg.ty.span);\n-\n-                                    let (ty_snip, appl) = if let Ok(ref snip) = ty_snip {\n-                                        (snip.as_str(), Applicability::MachineApplicable)\n-                                    } else {\n-                                        (\"<type>\", Applicability::HasPlaceholders)\n-                                    };\n+        if let ast::AssocItemKind::Fn(_, ref sig, _, _) = it.kind {\n+            for arg in sig.decl.inputs.iter() {\n+                if let ast::PatKind::Ident(_, ident, None) = arg.pat.kind {\n+                    if ident.name == kw::Invalid {\n+                        cx.struct_span_lint(ANONYMOUS_PARAMETERS, arg.pat.span, |lint| {\n+                            let ty_snip = cx.sess.source_map().span_to_snippet(arg.ty.span);\n+\n+                            let (ty_snip, appl) = if let Ok(ref snip) = ty_snip {\n+                                (snip.as_str(), Applicability::MachineApplicable)\n+                            } else {\n+                                (\"<type>\", Applicability::HasPlaceholders)\n+                            };\n \n-                                    lint.build(\n-                                        \"anonymous parameters are deprecated and will be \\\n+                            lint.build(\n+                                \"anonymous parameters are deprecated and will be \\\n                                      removed in the next edition.\",\n-                                    )\n-                                    .span_suggestion(\n-                                        arg.pat.span,\n-                                        \"try naming the parameter or explicitly \\\n+                            )\n+                            .span_suggestion(\n+                                arg.pat.span,\n+                                \"try naming the parameter or explicitly \\\n                                             ignoring it\",\n-                                        format!(\"_: {}\", ty_snip),\n-                                        appl,\n-                                    )\n-                                    .emit();\n-                                })\n-                            }\n-                        }\n-                        _ => (),\n+                                format!(\"_: {}\", ty_snip),\n+                                appl,\n+                            )\n+                            .emit();\n+                        })\n                     }\n                 }\n             }\n-            _ => (),\n         }\n     }\n }\n@@ -887,18 +881,14 @@ declare_lint_pass!(MutableTransmutes => [MUTABLE_TRANSMUTES]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n         use rustc_target::spec::abi::Abi::RustIntrinsic;\n-\n-        match get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.kind, &ty2.kind)) {\n-            Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) => {\n-                if to_mt == hir::Mutability::Mut && from_mt == hir::Mutability::Not {\n-                    let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n+        if let Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) =\n+            get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.kind, &ty2.kind))\n+        {\n+            if to_mt == hir::Mutability::Mut && from_mt == hir::Mutability::Not {\n+                let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n                                consider instead using an UnsafeCell\";\n-                    cx.struct_span_lint(MUTABLE_TRANSMUTES, expr.span, |lint| {\n-                        lint.build(msg).emit()\n-                    });\n-                }\n+                cx.struct_span_lint(MUTABLE_TRANSMUTES, expr.span, |lint| lint.build(msg).emit());\n             }\n-            _ => (),\n         }\n \n         fn get_transmute_from_to<'a, 'tcx>("}, {"sha": "12543cf83ddb20865b6aa2d79f71eb258f8b634a", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -787,9 +787,8 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n                 let mut path = print_prefix(self)?;\n \n                 // Skip `::{{constructor}}` on tuple/unit structs.\n-                match disambiguated_data.data {\n-                    DefPathData::Ctor => return Ok(path),\n-                    _ => {}\n+                if let DefPathData::Ctor = disambiguated_data.data {\n+                    return Ok(path);\n                 }\n \n                 path.push(disambiguated_data.data.as_symbol());"}, {"sha": "6de8fb45d223d80e6e8eb37f63a4d2789906b282", "filename": "src/librustc_lint/internal.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_lint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_lint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Finternal.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -175,18 +175,15 @@ fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment<'_>) -> bo\n }\n \n fn is_ty_or_ty_ctxt(cx: &LateContext<'_, '_>, ty: &Ty<'_>) -> Option<String> {\n-    match &ty.kind {\n-        TyKind::Path(qpath) => {\n-            if let QPath::Resolved(_, path) = qpath {\n-                let did = path.res.opt_def_id()?;\n-                if cx.tcx.is_diagnostic_item(sym::Ty, did) {\n-                    return Some(format!(\"Ty{}\", gen_args(path.segments.last().unwrap())));\n-                } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, did) {\n-                    return Some(format!(\"TyCtxt{}\", gen_args(path.segments.last().unwrap())));\n-                }\n+    if let TyKind::Path(qpath) = &ty.kind {\n+        if let QPath::Resolved(_, path) = qpath {\n+            let did = path.res.opt_def_id()?;\n+            if cx.tcx.is_diagnostic_item(sym::Ty, did) {\n+                return Some(format!(\"Ty{}\", gen_args(path.segments.last().unwrap())));\n+            } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, did) {\n+                return Some(format!(\"TyCtxt{}\", gen_args(path.segments.last().unwrap())));\n             }\n         }\n-        _ => {}\n     }\n \n     None"}, {"sha": "78a67ae6afe731a9bee6c20f62a8b9ebb0d26c26", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -285,12 +285,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n         let attr_info = attr.ident().and_then(|ident| self.builtin_attributes.get(&ident.name));\n \n         if let Some(&&(name, ty, ..)) = attr_info {\n-            match ty {\n-                AttributeType::Whitelisted => {\n-                    debug!(\"{:?} is Whitelisted\", name);\n-                    return;\n-                }\n-                _ => (),\n+            if let AttributeType::Whitelisted = ty {\n+                debug!(\"{:?} is Whitelisted\", name);\n+                return;\n             }\n         }\n "}, {"sha": "f6e2730cb576102141c5668b6a36883aa52afdb2", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -1623,12 +1623,9 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_info_for_expr(&mut self, expr: &hir::Expr<'_>) {\n-        match expr.kind {\n-            hir::ExprKind::Closure(..) => {\n-                let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n-                self.encode_info_for_closure(def_id);\n-            }\n-            _ => {}\n+        if let hir::ExprKind::Closure(..) = expr.kind {\n+            let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n+            self.encode_info_for_closure(def_id);\n         }\n     }\n "}, {"sha": "0e75f34629e0eea6b8f39b9f0810e2377e094f27", "filename": "src/librustc_middle/mir/interpret/allocation.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -379,12 +379,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n             // *Now*, we better make sure that the inside is free of relocations too.\n             self.check_relocations(cx, ptr, size)?;\n         } else {\n-            match self.relocations.get(&ptr.offset) {\n-                Some(&(tag, alloc_id)) => {\n-                    let ptr = Pointer::new_with_tag(alloc_id, Size::from_bytes(bits), tag);\n-                    return Ok(ScalarMaybeUndef::Scalar(ptr.into()));\n-                }\n-                None => {}\n+            if let Some(&(tag, alloc_id)) = self.relocations.get(&ptr.offset) {\n+                let ptr = Pointer::new_with_tag(alloc_id, Size::from_bytes(bits), tag);\n+                return Ok(ScalarMaybeUndef::Scalar(ptr.into()));\n             }\n         }\n         // We don't. Just return the bits.\n@@ -437,11 +434,8 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         write_target_uint(endian, dst, bytes).unwrap();\n \n         // See if we have to also write a relocation.\n-        match val {\n-            Scalar::Ptr(val) => {\n-                self.relocations.insert(ptr.offset, (val.tag, val.alloc_id));\n-            }\n-            _ => {}\n+        if let Scalar::Ptr(val) = val {\n+            self.relocations.insert(ptr.offset, (val.tag, val.alloc_id));\n         }\n \n         Ok(())"}, {"sha": "54fde52ba3a777e4888eb89b163b529e460f8256", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -1356,11 +1356,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         {\n             let mut used_variants = BitSet::new_empty(info.variant_fields.len());\n             for assignment in &assignments {\n-                match assignment {\n-                    Assigned(idx) => {\n-                        used_variants.insert(*idx);\n-                    }\n-                    _ => {}\n+                if let Assigned(idx) = assignment {\n+                    used_variants.insert(*idx);\n                 }\n             }\n             if used_variants.count() < 2 {"}, {"sha": "5c365a57cd12da075b4cc4881920f7d2857acdfd", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -318,18 +318,15 @@ pub trait PrettyPrinter<'tcx>:\n         debug!(\"try_print_visible_def_path: cur_def_key={:?}\", cur_def_key);\n \n         // For a constructor, we want the name of its parent rather than <unnamed>.\n-        match cur_def_key.disambiguated_data.data {\n-            DefPathData::Ctor => {\n-                let parent = DefId {\n-                    krate: def_id.krate,\n-                    index: cur_def_key\n-                        .parent\n-                        .expect(\"`DefPathData::Ctor` / `VariantData` missing a parent\"),\n-                };\n+        if let DefPathData::Ctor = cur_def_key.disambiguated_data.data {\n+            let parent = DefId {\n+                krate: def_id.krate,\n+                index: cur_def_key\n+                    .parent\n+                    .expect(\"`DefPathData::Ctor` / `VariantData` missing a parent\"),\n+            };\n \n-                cur_def_key = self.tcx().def_key(parent);\n-            }\n-            _ => {}\n+            cur_def_key = self.tcx().def_key(parent);\n         }\n \n         let visible_parent = match visible_parent_map.get(&def_id).cloned() {\n@@ -1420,9 +1417,8 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         self = print_prefix(self)?;\n \n         // Skip `::{{constructor}}` on tuple/unit structs.\n-        match disambiguated_data.data {\n-            DefPathData::Ctor => return Ok(self),\n-            _ => {}\n+        if let DefPathData::Ctor = disambiguated_data.data {\n+            return Ok(self);\n         }\n \n         // FIXME(eddyb) `name` should never be empty, but it\n@@ -1784,11 +1780,8 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         struct LateBoundRegionNameCollector<'a>(&'a mut FxHashSet<Symbol>);\n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_> {\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-                match *r {\n-                    ty::ReLateBound(_, ty::BrNamed(_, name)) => {\n-                        self.0.insert(name);\n-                    }\n-                    _ => {}\n+                if let ty::ReLateBound(_, ty::BrNamed(_, name)) = *r {\n+                    self.0.insert(name);\n                 }\n                 r.super_visit_with(self)\n             }"}, {"sha": "a4bed18dcef9bf3ead72ebc789b327b92be98d62", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -549,14 +549,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         place: &Place<'tcx>,\n         borrowed_place: &Place<'tcx>,\n     ) {\n-        match (&place.projection[..], &borrowed_place.projection[..]) {\n-            ([ProjectionElem::Index(_)], [ProjectionElem::Index(_)]) => {\n-                err.help(\n-                    \"consider using `.split_at_mut(position)` or similar method to obtain \\\n+        if let ([ProjectionElem::Index(_)], [ProjectionElem::Index(_)]) =\n+            (&place.projection[..], &borrowed_place.projection[..])\n+        {\n+            err.help(\n+                \"consider using `.split_at_mut(position)` or similar method to obtain \\\n                      two mutable non-overlapping sub-slices\",\n-                );\n-            }\n-            _ => {}\n+            );\n         }\n     }\n "}, {"sha": "a3ab36b8443908fa8fe721b75f39a701a4768e04", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -227,29 +227,26 @@ impl BorrowExplanation {\n         span: Span,\n         region_name: &RegionName,\n     ) {\n-        match category {\n-            ConstraintCategory::OpaqueType => {\n-                if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(span) {\n-                    let suggestable_name = if region_name.was_named() {\n-                        region_name.to_string()\n-                    } else {\n-                        \"'_\".to_string()\n-                    };\n+        if let ConstraintCategory::OpaqueType = category {\n+            if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(span) {\n+                let suggestable_name = if region_name.was_named() {\n+                    region_name.to_string()\n+                } else {\n+                    \"'_\".to_string()\n+                };\n \n-                    err.span_suggestion(\n-                        span,\n-                        &format!(\n-                            \"you can add a bound to the {}to make it last less than \\\n+                err.span_suggestion(\n+                    span,\n+                    &format!(\n+                        \"you can add a bound to the {}to make it last less than \\\n                              `'static` and match `{}`\",\n-                            category.description(),\n-                            region_name,\n-                        ),\n-                        format!(\"{} + {}\", snippet, suggestable_name),\n-                        Applicability::Unspecified,\n-                    );\n-                }\n+                        category.description(),\n+                        region_name,\n+                    ),\n+                    format!(\"{} + {}\", snippet, suggestable_name),\n+                    Applicability::Unspecified,\n+                );\n             }\n-            _ => {}\n         }\n     }\n }"}, {"sha": "2fe72e1aa086a993ff8598f487c77fef2d5f7e82", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 50, "deletions": 52, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -497,62 +497,60 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let mut look_at_return = true;\n         // If we can detect the expression to be an `fn` call where the closure was an argument,\n         // we point at the `fn` definition argument...\n-        match node {\n-            hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Call(func, args), .. }) => {\n-                let arg_pos = args\n-                    .iter()\n-                    .enumerate()\n-                    .filter(|(_, arg)| arg.span == self.body.span)\n-                    .map(|(pos, _)| pos)\n-                    .next();\n-                let def_id = hir.local_def_id(item_id);\n-                let tables = self.infcx.tcx.typeck_tables_of(def_id);\n-                if let Some(ty::FnDef(def_id, _)) =\n-                    tables.node_type_opt(func.hir_id).as_ref().map(|ty| &ty.kind)\n-                {\n-                    let arg = match hir.get_if_local(*def_id) {\n-                        Some(hir::Node::Item(hir::Item {\n-                            ident,\n-                            kind: hir::ItemKind::Fn(sig, ..),\n-                            ..\n-                        }))\n-                        | Some(hir::Node::TraitItem(hir::TraitItem {\n-                            ident,\n-                            kind: hir::TraitItemKind::Fn(sig, _),\n-                            ..\n-                        }))\n-                        | Some(hir::Node::ImplItem(hir::ImplItem {\n-                            ident,\n-                            kind: hir::ImplItemKind::Fn(sig, _),\n-                            ..\n-                        })) => Some(\n-                            arg_pos\n-                                .and_then(|pos| {\n-                                    sig.decl.inputs.get(\n-                                        pos + if sig.decl.implicit_self.has_implicit_self() {\n-                                            1\n-                                        } else {\n-                                            0\n-                                        },\n-                                    )\n-                                })\n-                                .map(|arg| arg.span)\n-                                .unwrap_or(ident.span),\n-                        ),\n-                        _ => None,\n-                    };\n-                    if let Some(span) = arg {\n-                        err.span_label(span, \"change this to accept `FnMut` instead of `Fn`\");\n-                        err.span_label(func.span, \"expects `Fn` instead of `FnMut`\");\n-                        if self.infcx.tcx.sess.source_map().is_multiline(self.body.span) {\n-                            err.span_label(self.body.span, \"in this closure\");\n-                        }\n-                        look_at_return = false;\n+        if let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Call(func, args), .. }) = node {\n+            let arg_pos = args\n+                .iter()\n+                .enumerate()\n+                .filter(|(_, arg)| arg.span == self.body.span)\n+                .map(|(pos, _)| pos)\n+                .next();\n+            let def_id = hir.local_def_id(item_id);\n+            let tables = self.infcx.tcx.typeck_tables_of(def_id);\n+            if let Some(ty::FnDef(def_id, _)) =\n+                tables.node_type_opt(func.hir_id).as_ref().map(|ty| &ty.kind)\n+            {\n+                let arg = match hir.get_if_local(*def_id) {\n+                    Some(hir::Node::Item(hir::Item {\n+                        ident,\n+                        kind: hir::ItemKind::Fn(sig, ..),\n+                        ..\n+                    }))\n+                    | Some(hir::Node::TraitItem(hir::TraitItem {\n+                        ident,\n+                        kind: hir::TraitItemKind::Fn(sig, _),\n+                        ..\n+                    }))\n+                    | Some(hir::Node::ImplItem(hir::ImplItem {\n+                        ident,\n+                        kind: hir::ImplItemKind::Fn(sig, _),\n+                        ..\n+                    })) => Some(\n+                        arg_pos\n+                            .and_then(|pos| {\n+                                sig.decl.inputs.get(\n+                                    pos + if sig.decl.implicit_self.has_implicit_self() {\n+                                        1\n+                                    } else {\n+                                        0\n+                                    },\n+                                )\n+                            })\n+                            .map(|arg| arg.span)\n+                            .unwrap_or(ident.span),\n+                    ),\n+                    _ => None,\n+                };\n+                if let Some(span) = arg {\n+                    err.span_label(span, \"change this to accept `FnMut` instead of `Fn`\");\n+                    err.span_label(func.span, \"expects `Fn` instead of `FnMut`\");\n+                    if self.infcx.tcx.sess.source_map().is_multiline(self.body.span) {\n+                        err.span_label(self.body.span, \"in this closure\");\n                     }\n+                    look_at_return = false;\n                 }\n             }\n-            _ => {}\n         }\n+\n         if look_at_return && hir.get_return_block(closure_id).is_some() {\n             // ...otherwise we are probably in the tail expression of the function, point at the\n             // return type."}, {"sha": "eb1527b874ebec641ddfc6c8fd7d755f06ad7a33", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -76,16 +76,13 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n     }\n \n     fn visit_statement(&mut self, statement: &Statement<'tcx>, _location: Location) {\n-        match &statement.kind {\n-            StatementKind::Assign(box (into, _)) => {\n-                debug!(\n-                    \"visit_statement: statement={:?} local={:?} \\\n+        if let StatementKind::Assign(box (into, _)) = &statement.kind {\n+            debug!(\n+                \"visit_statement: statement={:?} local={:?} \\\n                     never_initialized_mut_locals={:?}\",\n-                    statement, into.local, self.never_initialized_mut_locals\n-                );\n-                self.remove_never_initialized_mut_locals(into);\n-            }\n-            _ => {}\n+                statement, into.local, self.never_initialized_mut_locals\n+            );\n+            self.remove_never_initialized_mut_locals(into);\n         }\n     }\n "}, {"sha": "bdd411213594e40313da771144f040638a339452", "filename": "src/librustc_mir/dataflow/framework/graphviz.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fgraphviz.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -229,26 +229,22 @@ where\n         }\n \n         // Write any changes caused by terminator-specific effects\n-        match terminator.kind {\n-            mir::TerminatorKind::Call { destination: Some(_), .. } => {\n-                let num_state_columns = self.num_state_columns();\n-                self.write_row(w, \"\", \"(on successful return)\", |this, w, fmt| {\n-                    write!(\n-                        w,\n-                        r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n-                        colspan = num_state_columns,\n-                        fmt = fmt,\n-                    )?;\n-\n-                    let state_on_unwind = this.results.get().clone();\n-                    this.results.seek_after_assume_success(terminator_loc);\n-                    write_diff(w, this.results.analysis(), &state_on_unwind, this.results.get())?;\n-\n-                    write!(w, \"</td>\")\n-                })?;\n-            }\n-\n-            _ => {}\n+        if let mir::TerminatorKind::Call { destination: Some(_), .. } = terminator.kind {\n+            let num_state_columns = self.num_state_columns();\n+            self.write_row(w, \"\", \"(on successful return)\", |this, w, fmt| {\n+                write!(\n+                    w,\n+                    r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n+                    colspan = num_state_columns,\n+                    fmt = fmt,\n+                )?;\n+\n+                let state_on_unwind = this.results.get().clone();\n+                this.results.seek_after_assume_success(terminator_loc);\n+                write_diff(w, this.results.analysis(), &state_on_unwind, this.results.get())?;\n+\n+                write!(w, \"</td>\")\n+            })?;\n         };\n \n         write!(w, \"</table>\")"}, {"sha": "3ffa771cb05a14333d97546272843b9af83945d2", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -544,18 +544,15 @@ impl<'tcx> GenKillAnalysis<'tcx> for EverInitializedPlaces<'_, 'tcx> {\n         );\n         trans.gen_all(init_loc_map[location].iter().copied());\n \n-        match stmt.kind {\n-            mir::StatementKind::StorageDead(local) => {\n-                // End inits for StorageDead, so that an immutable variable can\n-                // be reinitialized on the next iteration of the loop.\n-                let move_path_index = rev_lookup.find_local(local);\n-                debug!(\n-                    \"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n-                    stmt, location, &init_path_map[move_path_index]\n-                );\n-                trans.kill_all(init_path_map[move_path_index].iter().copied());\n-            }\n-            _ => {}\n+        if let mir::StatementKind::StorageDead(local) = stmt.kind {\n+            // End inits for StorageDead, so that an immutable variable can\n+            // be reinitialized on the next iteration of the loop.\n+            let move_path_index = rev_lookup.find_local(local);\n+            debug!(\n+                \"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n+                stmt, location, &init_path_map[move_path_index]\n+            );\n+            trans.kill_all(init_path_map[move_path_index].iter().copied());\n         }\n     }\n "}, {"sha": "1f4455318a4cff44ec5d9d1b04a9acc864247460", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -144,15 +144,16 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                         },\n                     ));\n                 }\n-                ty::Array(..) => match elem {\n-                    ProjectionElem::Index(..) => {\n+\n+                ty::Array(..) => {\n+                    if let ProjectionElem::Index(..) = elem {\n                         return Err(MoveError::cannot_move_out_of(\n                             self.loc,\n                             InteriorOfSliceOrArray { ty: place_ty, is_index: true },\n                         ));\n                     }\n-                    _ => {}\n-                },\n+                }\n+\n                 _ => {}\n             };\n "}, {"sha": "b81a454cac40886b24c6330cbefa2a06c88256c2", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -129,9 +129,8 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n         self = print_prefix(self)?;\n \n         // Skip `::{{constructor}}` on tuple/unit structs.\n-        match disambiguated_data.data {\n-            DefPathData::Ctor => return Ok(self),\n-            _ => {}\n+        if disambiguated_data.data == DefPathData::Ctor {\n+            return Ok(self);\n         }\n \n         self.path.push_str(\"::\");"}, {"sha": "e81cd8b3d00d763fdf8de9baab06f4486cefbefe", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -198,13 +198,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // We need a special check for overflowing remainder:\n                 // \"int_min % -1\" overflows and returns 0, but after casting things to a larger int\n                 // type it does *not* overflow nor give an unrepresentable result!\n-                match bin_op {\n-                    Rem => {\n-                        if r == -1 && l == (1 << (size.bits() - 1)) {\n-                            return Ok((Scalar::from_int(0, size), true, left_layout.ty));\n-                        }\n+                if bin_op == Rem {\n+                    if r == -1 && l == (1 << (size.bits() - 1)) {\n+                        return Ok((Scalar::from_int(0, size), true, left_layout.ty));\n                     }\n-                    _ => {}\n                 }\n                 let l = self.sign_extend(l, left_layout) as i128;\n "}, {"sha": "1106eba104682fb2cdfb739369bdcd3145d531f9", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -988,12 +988,9 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n     }\n \n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem<'v>) {\n-        match ii.kind {\n-            hir::ImplItemKind::Fn(hir::FnSig { .. }, _) => {\n-                let def_id = self.tcx.hir().local_def_id(ii.hir_id);\n-                self.push_if_root(def_id);\n-            }\n-            _ => { /* nothing to do here */ }\n+        if let hir::ImplItemKind::Fn(hir::FnSig { .. }, _) = ii.kind {\n+            let def_id = self.tcx.hir().local_def_id(ii.hir_id);\n+            self.push_if_root(def_id);\n         }\n     }\n }"}, {"sha": "e0ff82b1e64f134e98fea918000cee604f4a02d6", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -396,42 +396,40 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                 ProjectionElem::Field(..) => {\n                     let ty =\n                         Place::ty_from(place.local, proj_base, &self.body.local_decls, self.tcx).ty;\n-                    match ty.kind {\n-                        ty::Adt(def, _) => match self.tcx.layout_scalar_valid_range(def.did) {\n-                            (Bound::Unbounded, Bound::Unbounded) => {}\n-                            _ => {\n-                                let (description, details) = if is_mut_use {\n-                                    (\n-                                        \"mutation of layout constrained field\",\n-                                        \"mutating layout constrained fields cannot statically be \\\n+                    if let ty::Adt(def, _) = ty.kind {\n+                        if self.tcx.layout_scalar_valid_range(def.did)\n+                            != (Bound::Unbounded, Bound::Unbounded)\n+                        {\n+                            let (description, details) = if is_mut_use {\n+                                (\n+                                    \"mutation of layout constrained field\",\n+                                    \"mutating layout constrained fields cannot statically be \\\n                                         checked for valid values\",\n-                                    )\n+                                )\n \n-                                // Check `is_freeze` as late as possible to avoid cycle errors\n-                                // with opaque types.\n-                                } else if !place.ty(self.body, self.tcx).ty.is_freeze(\n-                                    self.tcx,\n-                                    self.param_env,\n-                                    self.source_info.span,\n-                                ) {\n-                                    (\n-                                        \"borrow of layout constrained field with interior \\\n+                            // Check `is_freeze` as late as possible to avoid cycle errors\n+                            // with opaque types.\n+                            } else if !place.ty(self.body, self.tcx).ty.is_freeze(\n+                                self.tcx,\n+                                self.param_env,\n+                                self.source_info.span,\n+                            ) {\n+                                (\n+                                    \"borrow of layout constrained field with interior \\\n                                         mutability\",\n-                                        \"references to fields of layout constrained fields \\\n+                                    \"references to fields of layout constrained fields \\\n                                         lose the constraints. Coupled with interior mutability, \\\n                                         the field can be changed to invalid values\",\n-                                    )\n-                                } else {\n-                                    continue;\n-                                };\n-                                self.require_unsafe(\n-                                    description,\n-                                    details,\n-                                    UnsafetyViolationKind::GeneralAndConstFn,\n-                                );\n-                            }\n-                        },\n-                        _ => {}\n+                                )\n+                            } else {\n+                                continue;\n+                            };\n+                            self.require_unsafe(\n+                                description,\n+                                details,\n+                                UnsafetyViolationKind::GeneralAndConstFn,\n+                            );\n+                        }\n                     }\n                 }\n                 _ => {}"}, {"sha": "230a835b910d253186bdb286c902d71ba8056295", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -675,10 +675,9 @@ impl dataflow::ResultsVisitor<'mir, 'tcx> for StorageConflictVisitor<'mir, 'tcx,\n impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n     fn apply_state(&mut self, flow_state: &BitSet<Local>, loc: Location) {\n         // Ignore unreachable blocks.\n-        match self.body.basic_blocks()[loc.block].terminator().kind {\n-            TerminatorKind::Unreachable => return,\n-            _ => (),\n-        };\n+        if self.body.basic_blocks()[loc.block].terminator().kind == TerminatorKind::Unreachable {\n+            return;\n+        }\n \n         let mut eligible_storage_live = flow_state.clone();\n         eligible_storage_live.intersect(&self.stored_locals);"}, {"sha": "34fa12e1b56837379708f4f73a0bbf13cc77d849", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -1064,16 +1064,15 @@ pub fn promote_candidates<'tcx>(\n         match candidate {\n             Candidate::Repeat(Location { block, statement_index })\n             | Candidate::Ref(Location { block, statement_index }) => {\n-                match &body[block].statements[statement_index].kind {\n-                    StatementKind::Assign(box (place, _)) => {\n-                        if let Some(local) = place.as_local() {\n-                            if temps[local] == TempState::PromotedOut {\n-                                // Already promoted.\n-                                continue;\n-                            }\n+                if let StatementKind::Assign(box (place, _)) =\n+                    &body[block].statements[statement_index].kind\n+                {\n+                    if let Some(local) = place.as_local() {\n+                        if temps[local] == TempState::PromotedOut {\n+                            // Already promoted.\n+                            continue;\n                         }\n                     }\n-                    _ => {}\n                 }\n             }\n             Candidate::Argument { .. } => {}\n@@ -1137,15 +1136,12 @@ pub fn promote_candidates<'tcx>(\n             _ => true,\n         });\n         let terminator = block.terminator_mut();\n-        match &terminator.kind {\n-            TerminatorKind::Drop { location: place, target, .. } => {\n-                if let Some(index) = place.as_local() {\n-                    if promoted(index) {\n-                        terminator.kind = TerminatorKind::Goto { target: *target };\n-                    }\n+        if let TerminatorKind::Drop { location: place, target, .. } = &terminator.kind {\n+            if let Some(index) = place.as_local() {\n+                if promoted(index) {\n+                    terminator.kind = TerminatorKind::Goto { target: *target };\n                 }\n             }\n-            _ => {}\n         }\n     }\n "}, {"sha": "5e4fd061c76666ca42492e428c77ccaf956d568b", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -107,16 +107,13 @@ impl RemoveNoopLandingPads {\n                 }\n             }\n \n-            match body[bb].terminator_mut().unwind_mut() {\n-                Some(unwind) => {\n-                    if *unwind == Some(resume_block) {\n-                        debug!(\"    removing noop landing pad\");\n-                        jumps_folded -= 1;\n-                        landing_pads_removed += 1;\n-                        *unwind = None;\n-                    }\n+            if let Some(unwind) = body[bb].terminator_mut().unwind_mut() {\n+                if *unwind == Some(resume_block) {\n+                    debug!(\"    removing noop landing pad\");\n+                    jumps_folded -= 1;\n+                    landing_pads_removed += 1;\n+                    *unwind = None;\n                 }\n-                _ => {}\n             }\n \n             let is_nop_landing_pad = self.is_nop_landing_pad(bb, body, &nop_landing_pads);"}, {"sha": "bd7725c1b5af322a578d2048d3899e0d52258fee", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -391,8 +391,8 @@ impl Visitor<'tcx> for ExtraComments<'tcx> {\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         self.super_rvalue(rvalue, location);\n-        match rvalue {\n-            Rvalue::Aggregate(kind, _) => match **kind {\n+        if let Rvalue::Aggregate(kind, _) = rvalue {\n+            match **kind {\n                 AggregateKind::Closure(def_id, substs) => {\n                     self.push(\"closure\");\n                     self.push(&format!(\"+ def_id: {:?}\", def_id));\n@@ -412,9 +412,7 @@ impl Visitor<'tcx> for ExtraComments<'tcx> {\n                 }\n \n                 _ => {}\n-            },\n-\n-            _ => {}\n+            }\n         }\n     }\n }"}, {"sha": "03f668d562e78ee48cd5c6de7995ac8aa4558721", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -1974,15 +1974,12 @@ fn slice_pat_covered_by_const<'tcx>(\n         .zip(prefix)\n         .chain(data[data.len() - suffix.len()..].iter().zip(suffix))\n     {\n-        match pat.kind {\n-            box PatKind::Constant { value } => {\n-                let b = value.eval_bits(tcx, param_env, pat.ty);\n-                assert_eq!(b as u8 as u128, b);\n-                if b as u8 != *ch {\n-                    return Ok(false);\n-                }\n+        if let box PatKind::Constant { value } = pat.kind {\n+            let b = value.eval_bits(tcx, param_env, pat.ty);\n+            assert_eq!(b as u8 as u128, b);\n+            if b as u8 != *ch {\n+                return Ok(false);\n             }\n-            _ => {}\n         }\n     }\n \n@@ -2197,17 +2194,16 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 let head_ctors =\n                     matrix.heads().filter_map(|pat| pat_constructor(tcx, param_env, pat));\n                 for ctor in head_ctors {\n-                    match ctor {\n-                        Slice(slice) => match slice.pattern_kind() {\n+                    if let Slice(slice) = ctor {\n+                        match slice.pattern_kind() {\n                             FixedLen(len) => {\n                                 max_fixed_len = cmp::max(max_fixed_len, len);\n                             }\n                             VarLen(prefix, suffix) => {\n                                 max_prefix_len = cmp::max(max_prefix_len, prefix);\n                                 max_suffix_len = cmp::max(max_suffix_len, suffix);\n                             }\n-                        },\n-                        _ => {}\n+                        }\n                     }\n                 }\n "}, {"sha": "f15d2fc5caa03bce4385aad622738b16d3f248ec", "filename": "src/librustc_mir_build/hair/pattern/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -1058,18 +1058,15 @@ crate fn compare_const_vals<'tcx>(\n     }\n \n     if let ty::Str = ty.kind {\n-        match (a.val, b.val) {\n-            (\n-                ty::ConstKind::Value(a_val @ ConstValue::Slice { .. }),\n-                ty::ConstKind::Value(b_val @ ConstValue::Slice { .. }),\n-            ) => {\n-                let a_bytes = get_slice_bytes(&tcx, a_val);\n-                let b_bytes = get_slice_bytes(&tcx, b_val);\n-                return from_bool(a_bytes == b_bytes);\n-            }\n-            _ => (),\n+        if let (\n+            ty::ConstKind::Value(a_val @ ConstValue::Slice { .. }),\n+            ty::ConstKind::Value(b_val @ ConstValue::Slice { .. }),\n+        ) = (a.val, b.val)\n+        {\n+            let a_bytes = get_slice_bytes(&tcx, a_val);\n+            let b_bytes = get_slice_bytes(&tcx, b_val);\n+            return from_bool(a_bytes == b_bytes);\n         }\n     }\n-\n     fallback()\n }"}, {"sha": "830bd255dfc3f95de071d0b935c0b41aeb71a5a8", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -300,12 +300,9 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n-        match ty.kind {\n-            TyKind::Def(item_id, _) => {\n-                let item = self.tcx.hir().expect_item(item_id.id);\n-                intravisit::walk_item(self, item);\n-            }\n-            _ => (),\n+        if let TyKind::Def(item_id, _) = ty.kind {\n+            let item = self.tcx.hir().expect_item(item_id.id);\n+            intravisit::walk_item(self, item);\n         }\n         intravisit::walk_ty(self, ty);\n     }"}, {"sha": "567022fe4052f453e24130a3be974147d75a5736", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 31, "deletions": 37, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -1096,52 +1096,46 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n-        match expr.kind {\n-            hir::ExprKind::Struct(ref qpath, fields, ref base) => {\n-                let res = self.tables.qpath_res(qpath, expr.hir_id);\n-                let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n-                let variant = adt.variant_of_res(res);\n-                if let Some(ref base) = *base {\n-                    // If the expression uses FRU we need to make sure all the unmentioned fields\n-                    // are checked for privacy (RFC 736). Rather than computing the set of\n-                    // unmentioned fields, just check them all.\n-                    for (vf_index, variant_field) in variant.fields.iter().enumerate() {\n-                        let field = fields\n-                            .iter()\n-                            .find(|f| self.tcx.field_index(f.hir_id, self.tables) == vf_index);\n-                        let (use_ctxt, span) = match field {\n-                            Some(field) => (field.ident.span, field.span),\n-                            None => (base.span, base.span),\n-                        };\n-                        self.check_field(use_ctxt, span, adt, variant_field, true);\n-                    }\n-                } else {\n-                    for field in fields {\n-                        let use_ctxt = field.ident.span;\n-                        let index = self.tcx.field_index(field.hir_id, self.tables);\n-                        self.check_field(use_ctxt, field.span, adt, &variant.fields[index], false);\n-                    }\n+        if let hir::ExprKind::Struct(ref qpath, fields, ref base) = expr.kind {\n+            let res = self.tables.qpath_res(qpath, expr.hir_id);\n+            let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n+            let variant = adt.variant_of_res(res);\n+            if let Some(ref base) = *base {\n+                // If the expression uses FRU we need to make sure all the unmentioned fields\n+                // are checked for privacy (RFC 736). Rather than computing the set of\n+                // unmentioned fields, just check them all.\n+                for (vf_index, variant_field) in variant.fields.iter().enumerate() {\n+                    let field = fields\n+                        .iter()\n+                        .find(|f| self.tcx.field_index(f.hir_id, self.tables) == vf_index);\n+                    let (use_ctxt, span) = match field {\n+                        Some(field) => (field.ident.span, field.span),\n+                        None => (base.span, base.span),\n+                    };\n+                    self.check_field(use_ctxt, span, adt, variant_field, true);\n+                }\n+            } else {\n+                for field in fields {\n+                    let use_ctxt = field.ident.span;\n+                    let index = self.tcx.field_index(field.hir_id, self.tables);\n+                    self.check_field(use_ctxt, field.span, adt, &variant.fields[index], false);\n                 }\n             }\n-            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr);\n     }\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n-        match pat.kind {\n-            PatKind::Struct(ref qpath, fields, _) => {\n-                let res = self.tables.qpath_res(qpath, pat.hir_id);\n-                let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n-                let variant = adt.variant_of_res(res);\n-                for field in fields {\n-                    let use_ctxt = field.ident.span;\n-                    let index = self.tcx.field_index(field.hir_id, self.tables);\n-                    self.check_field(use_ctxt, field.span, adt, &variant.fields[index], false);\n-                }\n+        if let PatKind::Struct(ref qpath, fields, _) = pat.kind {\n+            let res = self.tables.qpath_res(qpath, pat.hir_id);\n+            let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n+            let variant = adt.variant_of_res(res);\n+            for field in fields {\n+                let use_ctxt = field.ident.span;\n+                let index = self.tcx.field_index(field.hir_id, self.tables);\n+                self.check_field(use_ctxt, field.span, adt, &variant.fields[index], false);\n             }\n-            _ => {}\n         }\n \n         intravisit::walk_pat(self, pat);"}, {"sha": "05eb524dff5e341b79acf6bad39a382c6154b2b3", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -848,10 +848,9 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         if let Some(ref generic_args) = seg.args {\n             if let ast::GenericArgs::AngleBracketed(ref data) = **generic_args {\n                 for arg in &data.args {\n-                    match arg {\n-                        ast::AngleBracketedArg::Arg(ast::GenericArg::Type(ty)) => self.visit_ty(ty),\n-                        _ => {}\n-                    }\n+                    if let ast::AngleBracketedArg::Arg(ast::GenericArg::Type(ty)) = arg {\n+                        self.visit_ty(ty)\n+                    };\n                 }\n             }\n         }"}, {"sha": "01e9356b42f46837277144f029521756b4fdbde8", "filename": "src/librustc_symbol_mangling/legacy.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_symbol_mangling%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_symbol_mangling%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Flegacy.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -308,9 +308,8 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n         self = print_prefix(self)?;\n \n         // Skip `::{{constructor}}` on tuple/unit structs.\n-        match disambiguated_data.data {\n-            DefPathData::Ctor => return Ok(self),\n-            _ => {}\n+        if let DefPathData::Ctor = disambiguated_data.data {\n+            return Ok(self);\n         }\n \n         if self.keep_within_component {"}, {"sha": "a916a53f0cbf75d916d9dfe6d9d8da340fae4bec", "filename": "src/librustc_target/abi/call/riscv.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -300,23 +300,18 @@ fn classify_arg<'a, Ty, C>(\n }\n \n fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n-    match arg.layout.abi {\n-        Abi::Scalar(ref scalar) => {\n-            match scalar.value {\n-                abi::Int(i, _) => {\n-                    // 32-bit integers are always sign-extended\n-                    if i.size().bits() == 32 && xlen > 32 {\n-                        if let PassMode::Direct(ref mut attrs) = arg.mode {\n-                            attrs.set(ArgAttribute::SExt);\n-                            return;\n-                        }\n-                    }\n+    if let Abi::Scalar(ref scalar) = arg.layout.abi {\n+        if let abi::Int(i, _) = scalar.value {\n+            // 32-bit integers are always sign-extended\n+            if i.size().bits() == 32 && xlen > 32 {\n+                if let PassMode::Direct(ref mut attrs) = arg.mode {\n+                    attrs.set(ArgAttribute::SExt);\n+                    return;\n                 }\n-                _ => (),\n             }\n         }\n-        _ => (),\n     }\n+\n     arg.extend_integer_width_to(xlen);\n }\n "}, {"sha": "e01f5bfbcb3da88392a33bcf079c109a698b7e42", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 75, "deletions": 80, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -314,19 +314,17 @@ impl AutoTraitFinder<'tcx> {\n                 &Ok(Some(ref vtable)) => {\n                     // If we see an explicit negative impl (e.g., `impl !Send for MyStruct`),\n                     // we immediately bail out, since it's impossible for us to continue.\n-                    match vtable {\n-                        Vtable::VtableImpl(VtableImplData { impl_def_id, .. }) => {\n-                            // Blame 'tidy' for the weird bracket placement.\n-                            if infcx.tcx.impl_polarity(*impl_def_id) == ty::ImplPolarity::Negative {\n-                                debug!(\n-                                    \"evaluate_nested_obligations: found explicit negative impl\\\n+\n+                    if let Vtable::VtableImpl(VtableImplData { impl_def_id, .. }) = vtable {\n+                        // Blame 'tidy' for the weird bracket placement.\n+                        if infcx.tcx.impl_polarity(*impl_def_id) == ty::ImplPolarity::Negative {\n+                            debug!(\n+                                \"evaluate_nested_obligations: found explicit negative impl\\\n                                         {:?}, bailing out\",\n-                                    impl_def_id\n-                                );\n-                                return None;\n-                            }\n+                                impl_def_id\n+                            );\n+                            return None;\n                         }\n-                        _ => {}\n                     }\n \n                     let obligations = vtable.clone().nested_obligations().into_iter();\n@@ -417,80 +415,77 @@ impl AutoTraitFinder<'tcx> {\n     ) {\n         let mut should_add_new = true;\n         user_computed_preds.retain(|&old_pred| {\n-            match (&new_pred, old_pred) {\n-                (&ty::Predicate::Trait(new_trait, _), ty::Predicate::Trait(old_trait, _)) => {\n-                    if new_trait.def_id() == old_trait.def_id() {\n-                        let new_substs = new_trait.skip_binder().trait_ref.substs;\n-                        let old_substs = old_trait.skip_binder().trait_ref.substs;\n-\n-                        if !new_substs.types().eq(old_substs.types()) {\n-                            // We can't compare lifetimes if the types are different,\n-                            // so skip checking `old_pred`.\n-                            return true;\n-                        }\n+            if let (&ty::Predicate::Trait(new_trait, _), ty::Predicate::Trait(old_trait, _)) =\n+                (&new_pred, old_pred)\n+            {\n+                if new_trait.def_id() == old_trait.def_id() {\n+                    let new_substs = new_trait.skip_binder().trait_ref.substs;\n+                    let old_substs = old_trait.skip_binder().trait_ref.substs;\n+\n+                    if !new_substs.types().eq(old_substs.types()) {\n+                        // We can't compare lifetimes if the types are different,\n+                        // so skip checking `old_pred`.\n+                        return true;\n+                    }\n \n-                        for (new_region, old_region) in\n-                            new_substs.regions().zip(old_substs.regions())\n-                        {\n-                            match (new_region, old_region) {\n-                                // If both predicates have an `ReLateBound` (a HRTB) in the\n-                                // same spot, we do nothing.\n-                                (\n-                                    ty::RegionKind::ReLateBound(_, _),\n-                                    ty::RegionKind::ReLateBound(_, _),\n-                                ) => {}\n-\n-                                (ty::RegionKind::ReLateBound(_, _), _)\n-                                | (_, ty::RegionKind::ReVar(_)) => {\n-                                    // One of these is true:\n-                                    // The new predicate has a HRTB in a spot where the old\n-                                    // predicate does not (if they both had a HRTB, the previous\n-                                    // match arm would have executed). A HRBT is a 'stricter'\n-                                    // bound than anything else, so we want to keep the newer\n-                                    // predicate (with the HRBT) in place of the old predicate.\n-                                    //\n-                                    // OR\n-                                    //\n-                                    // The old predicate has a region variable where the new\n-                                    // predicate has some other kind of region. An region\n-                                    // variable isn't something we can actually display to a user,\n-                                    // so we choose their new predicate (which doesn't have a region\n-                                    // variable).\n-                                    //\n-                                    // In both cases, we want to remove the old predicate,\n-                                    // from `user_computed_preds`, and replace it with the new\n-                                    // one. Having both the old and the new\n-                                    // predicate in a `ParamEnv` would confuse `SelectionContext`.\n-                                    //\n-                                    // We're currently in the predicate passed to 'retain',\n-                                    // so we return `false` to remove the old predicate from\n-                                    // `user_computed_preds`.\n-                                    return false;\n-                                }\n-                                (_, ty::RegionKind::ReLateBound(_, _))\n-                                | (ty::RegionKind::ReVar(_), _) => {\n-                                    // This is the opposite situation as the previous arm.\n-                                    // One of these is true:\n-                                    //\n-                                    // The old predicate has a HRTB lifetime in a place where the\n-                                    // new predicate does not.\n-                                    //\n-                                    // OR\n-                                    //\n-                                    // The new predicate has a region variable where the old\n-                                    // predicate has some other type of region.\n-                                    //\n-                                    // We want to leave the old\n-                                    // predicate in `user_computed_preds`, and skip adding\n-                                    // new_pred to `user_computed_params`.\n-                                    should_add_new = false\n-                                }\n-                                _ => {}\n+                    for (new_region, old_region) in new_substs.regions().zip(old_substs.regions()) {\n+                        match (new_region, old_region) {\n+                            // If both predicates have an `ReLateBound` (a HRTB) in the\n+                            // same spot, we do nothing.\n+                            (\n+                                ty::RegionKind::ReLateBound(_, _),\n+                                ty::RegionKind::ReLateBound(_, _),\n+                            ) => {}\n+\n+                            (ty::RegionKind::ReLateBound(_, _), _)\n+                            | (_, ty::RegionKind::ReVar(_)) => {\n+                                // One of these is true:\n+                                // The new predicate has a HRTB in a spot where the old\n+                                // predicate does not (if they both had a HRTB, the previous\n+                                // match arm would have executed). A HRBT is a 'stricter'\n+                                // bound than anything else, so we want to keep the newer\n+                                // predicate (with the HRBT) in place of the old predicate.\n+                                //\n+                                // OR\n+                                //\n+                                // The old predicate has a region variable where the new\n+                                // predicate has some other kind of region. An region\n+                                // variable isn't something we can actually display to a user,\n+                                // so we choose their new predicate (which doesn't have a region\n+                                // variable).\n+                                //\n+                                // In both cases, we want to remove the old predicate,\n+                                // from `user_computed_preds`, and replace it with the new\n+                                // one. Having both the old and the new\n+                                // predicate in a `ParamEnv` would confuse `SelectionContext`.\n+                                //\n+                                // We're currently in the predicate passed to 'retain',\n+                                // so we return `false` to remove the old predicate from\n+                                // `user_computed_preds`.\n+                                return false;\n+                            }\n+                            (_, ty::RegionKind::ReLateBound(_, _))\n+                            | (ty::RegionKind::ReVar(_), _) => {\n+                                // This is the opposite situation as the previous arm.\n+                                // One of these is true:\n+                                //\n+                                // The old predicate has a HRTB lifetime in a place where the\n+                                // new predicate does not.\n+                                //\n+                                // OR\n+                                //\n+                                // The new predicate has a region variable where the old\n+                                // predicate has some other type of region.\n+                                //\n+                                // We want to leave the old\n+                                // predicate in `user_computed_preds`, and skip adding\n+                                // new_pred to `user_computed_params`.\n+                                should_add_new = false\n                             }\n+                            _ => {}\n                         }\n                     }\n                 }\n-                _ => {}\n             }\n             true\n         });"}, {"sha": "213769d721d73e680d308392e52cc8212da477a4", "filename": "src/librustc_trait_selection/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -219,11 +219,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n         if let ty::Dynamic(traits, _) = self_ty.kind {\n             for t in *traits.skip_binder() {\n-                match t {\n-                    ty::ExistentialPredicate::Trait(trait_ref) => {\n-                        flags.push((sym::_Self, Some(self.tcx.def_path_str(trait_ref.def_id))))\n-                    }\n-                    _ => {}\n+                if let ty::ExistentialPredicate::Trait(trait_ref) = t {\n+                    flags.push((sym::_Self, Some(self.tcx.def_path_str(trait_ref.def_id))))\n                 }\n             }\n         }"}, {"sha": "59b56d673fb007f52d868bf5f8fcf520ed2d1157", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -737,17 +737,14 @@ fn get_generic_bound_spans(\n }\n \n fn is_self_path(kind: &hir::TyKind<'_>) -> bool {\n-    match kind {\n-        hir::TyKind::Path(hir::QPath::Resolved(None, path)) => {\n-            let mut s = path.segments.iter();\n-            if let (Some(segment), None) = (s.next(), s.next()) {\n-                if segment.ident.name == kw::SelfUpper {\n-                    // `type(Self)`\n-                    return true;\n-                }\n+    if let hir::TyKind::Path(hir::QPath::Resolved(None, path)) = kind {\n+        let mut s = path.segments.iter();\n+        if let (Some(segment), None) = (s.next(), s.next()) {\n+            if segment.ident.name == kw::SelfUpper {\n+                // `type(Self)`\n+                return true;\n             }\n         }\n-        _ => {}\n     }\n     false\n }"}, {"sha": "932032bb2b45f925b2db5a16a94865d292e01928", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -1785,9 +1785,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 ));\n             }\n         }\n-\n-        match (&potential_assoc_types[..], &trait_bounds) {\n-            ([], [bound]) => match &bound.trait_ref.path.segments[..] {\n+        if let ([], [bound]) = (&potential_assoc_types[..], &trait_bounds) {\n+            match &bound.trait_ref.path.segments[..] {\n                 // FIXME: `trait_ref.path.span` can point to a full path with multiple\n                 // segments, even though `trait_ref.path.segments` is of length `1`. Work\n                 // around that bug here, even though it should be fixed elsewhere.\n@@ -1819,8 +1818,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         .collect();\n                 }\n                 _ => {}\n-            },\n-            _ => {}\n+            }\n         }\n         names.sort();\n         trait_bound_spans.sort();"}, {"sha": "a16555b3df05635defb63596bd69ecf6fa1ba7d3", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -551,12 +551,11 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             }\n \n             // If we have an autoref followed by unsizing at the end, fix the unsize target.\n-            match adjustments[..] {\n-                [.., Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. }, Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), ref mut target }] =>\n-                {\n-                    *target = method.sig.inputs()[0];\n-                }\n-                _ => {}\n+\n+            if let [.., Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(..)), .. }, Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), ref mut target }] =\n+                adjustments[..]\n+            {\n+                *target = method.sig.inputs()[0];\n             }\n         }\n     }"}, {"sha": "c8632086771f9881f0e9b2ef070457b77fe13806", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -558,26 +558,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         .hir()\n                                         .as_local_hir_id(def.did)\n                                         .map(|id| self.tcx.hir().get(id));\n-                                    match node {\n-                                        Some(hir::Node::Item(hir::Item { kind, .. })) => {\n-                                            if let Some(g) = kind.generics() {\n-                                                let key = match &g.where_clause.predicates[..] {\n-                                                    [.., pred] => {\n-                                                        (pred.span().shrink_to_hi(), false)\n-                                                    }\n-                                                    [] => (\n-                                                        g.where_clause\n-                                                            .span_for_predicates_or_empty_place(),\n-                                                        true,\n-                                                    ),\n-                                                };\n-                                                type_params\n-                                                    .entry(key)\n-                                                    .or_insert_with(FxHashSet::default)\n-                                                    .insert(obligation.to_owned());\n-                                            }\n+                                    if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n+                                        if let Some(g) = kind.generics() {\n+                                            let key = match &g.where_clause.predicates[..] {\n+                                                [.., pred] => (pred.span().shrink_to_hi(), false),\n+                                                [] => (\n+                                                    g.where_clause\n+                                                        .span_for_predicates_or_empty_place(),\n+                                                    true,\n+                                                ),\n+                                            };\n+                                            type_params\n+                                                .entry(key)\n+                                                .or_insert_with(FxHashSet::default)\n+                                                .insert(obligation.to_owned());\n                                         }\n-                                        _ => {}\n                                     }\n                                 }\n                             }"}, {"sha": "2b2ebb3135fd183a32a4b106eb5bd011ba6a8f8b", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a80ec3b3b1d11ed83754885efdd07037d256dbf2/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=a80ec3b3b1d11ed83754885efdd07037d256dbf2", "patch": "@@ -213,18 +213,17 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n                     tables.adjustments_mut().get_mut(base.hir_id).map(|a| {\n                         // Discard the need for a mutable borrow\n-                        match a.pop() {\n-                            // Extra adjustment made when indexing causes a drop\n-                            // of size information - we need to get rid of it\n-                            // Since this is \"after\" the other adjustment to be\n-                            // discarded, we do an extra `pop()`\n-                            Some(Adjustment {\n-                                kind: Adjust::Pointer(PointerCast::Unsize), ..\n-                            }) => {\n-                                // So the borrow discard actually happens here\n-                                a.pop();\n-                            }\n-                            _ => {}\n+\n+                        // Extra adjustment made when indexing causes a drop\n+                        // of size information - we need to get rid of it\n+                        // Since this is \"after\" the other adjustment to be\n+                        // discarded, we do an extra `pop()`\n+                        if let Some(Adjustment {\n+                            kind: Adjust::Pointer(PointerCast::Unsize), ..\n+                        }) = a.pop()\n+                        {\n+                            // So the borrow discard actually happens here\n+                            a.pop();\n                         }\n                     });\n                 }"}]}