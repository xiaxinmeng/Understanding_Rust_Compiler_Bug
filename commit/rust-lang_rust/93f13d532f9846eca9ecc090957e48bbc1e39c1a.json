{"sha": "93f13d532f9846eca9ecc090957e48bbc1e39c1a", "node_id": "C_kwDOAAsO6NoAKDkzZjEzZDUzMmY5ODQ2ZWNhOWVjYzA5MDk1N2U0OGJiYzFlMzljMWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-09T19:28:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-09T19:28:48Z"}, "message": "Auto merge of #7951 - mikerite:matches-20211109, r=llogiq\n\n`match_overlapping_arm` refactoring\n\nThe main purpose of this pull request is to remove the unneeded and scary `unimplented!()` in the `match_arm_overlapping` code.\n\nThe rest is gratuitous refactoring.\n\nchangelog: none", "tree": {"sha": "a10b845b5a862611088217e6084585e8b90f75c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a10b845b5a862611088217e6084585e8b90f75c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93f13d532f9846eca9ecc090957e48bbc1e39c1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93f13d532f9846eca9ecc090957e48bbc1e39c1a", "html_url": "https://github.com/rust-lang/rust/commit/93f13d532f9846eca9ecc090957e48bbc1e39c1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93f13d532f9846eca9ecc090957e48bbc1e39c1a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f69721f37c372708aeefe57c712ce547688451ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/f69721f37c372708aeefe57c712ce547688451ff", "html_url": "https://github.com/rust-lang/rust/commit/f69721f37c372708aeefe57c712ce547688451ff"}, {"sha": "8b7691551acb5f27fe54a6b609f12c88eba78631", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b7691551acb5f27fe54a6b609f12c88eba78631", "html_url": "https://github.com/rust-lang/rust/commit/8b7691551acb5f27fe54a6b609f12c88eba78631"}], "stats": {"total": 130, "additions": 55, "deletions": 75}, "files": [{"sha": "e4e533fa71a5134511391a8a986361376c87b912", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 55, "deletions": 75, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/93f13d532f9846eca9ecc090957e48bbc1e39c1a/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f13d532f9846eca9ecc090957e48bbc1e39c1a/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=93f13d532f9846eca9ecc090957e48bbc1e39c1a", "patch": "@@ -33,7 +33,6 @@ use rustc_span::source_map::{Span, Spanned};\n use rustc_span::sym;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry;\n-use std::ops::Bound;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -1596,27 +1595,27 @@ fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'\n     None\n }\n \n-/// Gets all arms that are unbounded `PatRange`s.\n+/// Gets the ranges for each range pattern arm. Applies `ty` bounds for open ranges.\n fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<FullInt>> {\n     arms.iter()\n         .filter_map(|arm| {\n             if let Arm { pat, guard: None, .. } = *arm {\n                 if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n-                    let lhs = match lhs {\n+                    let lhs_const = match lhs {\n                         Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n                         None => miri_to_const(ty.numeric_min_val(cx.tcx)?)?,\n                     };\n-                    let rhs = match rhs {\n+                    let rhs_const = match rhs {\n                         Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n                         None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n                     };\n \n-                    let lhs_val = lhs.int_value(cx, ty)?;\n-                    let rhs_val = rhs.int_value(cx, ty)?;\n+                    let lhs_val = lhs_const.int_value(cx, ty)?;\n+                    let rhs_val = rhs_const.int_value(cx, ty)?;\n \n                     let rhs_bound = match range_end {\n-                        RangeEnd::Included => Bound::Included(rhs_val),\n-                        RangeEnd::Excluded => Bound::Excluded(rhs_val),\n+                        RangeEnd::Included => EndBound::Included(rhs_val),\n+                        RangeEnd::Excluded => EndBound::Excluded(rhs_val),\n                     };\n                     return Some(SpannedRange {\n                         span: pat.span,\n@@ -1628,7 +1627,7 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                     let value = constant_full_int(cx, cx.typeck_results(), value)?;\n                     return Some(SpannedRange {\n                         span: pat.span,\n-                        node: (value, Bound::Included(value)),\n+                        node: (value, EndBound::Included(value)),\n                     });\n                 }\n             }\n@@ -1637,10 +1636,16 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n         .collect()\n }\n \n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+pub enum EndBound<T> {\n+    Included(T),\n+    Excluded(T),\n+}\n+\n #[derive(Debug, Eq, PartialEq)]\n-pub struct SpannedRange<T> {\n+struct SpannedRange<T> {\n     pub span: Span,\n-    pub node: (T, Bound<T>),\n+    pub node: (T, EndBound<T>),\n }\n \n // Checks if arm has the form `None => None`\n@@ -1689,87 +1694,62 @@ where\n     ref_count > 1\n }\n \n-pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n+fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n where\n     T: Copy + Ord,\n {\n-    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-    enum Kind<'a, T> {\n-        Start(T, &'a SpannedRange<T>),\n-        End(Bound<T>, &'a SpannedRange<T>),\n+    #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n+    enum BoundKind {\n+        EndExcluded,\n+        Start,\n+        EndIncluded,\n     }\n \n-    impl<'a, T: Copy> Kind<'a, T> {\n-        fn value(self) -> Bound<T> {\n-            match self {\n-                Kind::Start(t, _) => Bound::Included(t),\n-                Kind::End(t, _) => t,\n-            }\n-        }\n-    }\n+    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+    struct RangeBound<'a, T>(T, BoundKind, &'a SpannedRange<T>);\n \n-    impl<'a, T: Copy + Ord> PartialOrd for Kind<'a, T> {\n+    impl<'a, T: Copy + Ord> PartialOrd for RangeBound<'a, T> {\n         fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n             Some(self.cmp(other))\n         }\n     }\n \n-    impl<'a, T: Copy + Ord> Ord for Kind<'a, T> {\n-        fn cmp(&self, other: &Self) -> Ordering {\n-            match (self.value(), other.value()) {\n-                (Bound::Included(a), Bound::Included(b)) | (Bound::Excluded(a), Bound::Excluded(b)) => {\n-                    let value_cmp = a.cmp(&b);\n-                    // In the case of ties, starts come before ends\n-                    if value_cmp == Ordering::Equal {\n-                        match (self, other) {\n-                            (Kind::Start(..), Kind::End(..)) => Ordering::Less,\n-                            (Kind::End(..), Kind::Start(..)) => Ordering::Greater,\n-                            _ => Ordering::Equal,\n-                        }\n-                    } else {\n-                        value_cmp\n-                    }\n-                },\n-                // Range patterns cannot be unbounded (yet)\n-                (Bound::Unbounded, _) | (_, Bound::Unbounded) => unimplemented!(),\n-                (Bound::Included(a), Bound::Excluded(b)) => match a.cmp(&b) {\n-                    Ordering::Equal => Ordering::Greater,\n-                    other => other,\n-                },\n-                (Bound::Excluded(a), Bound::Included(b)) => match a.cmp(&b) {\n-                    Ordering::Equal => Ordering::Less,\n-                    other => other,\n-                },\n-            }\n+    impl<'a, T: Copy + Ord> Ord for RangeBound<'a, T> {\n+        fn cmp(&self, RangeBound(other_value, other_kind, _): &Self) -> Ordering {\n+            let RangeBound(self_value, self_kind, _) = *self;\n+            (self_value, self_kind).cmp(&(*other_value, *other_kind))\n         }\n     }\n \n     let mut values = Vec::with_capacity(2 * ranges.len());\n \n-    for r in ranges {\n-        values.push(Kind::Start(r.node.0, r));\n-        values.push(Kind::End(r.node.1, r));\n+    for r @ SpannedRange { node: (start, end), .. } in ranges {\n+        values.push(RangeBound(*start, BoundKind::Start, r));\n+        values.push(match end {\n+            EndBound::Excluded(val) => RangeBound(*val, BoundKind::EndExcluded, r),\n+            EndBound::Included(val) => RangeBound(*val, BoundKind::EndIncluded, r),\n+        });\n     }\n \n     values.sort();\n \n     let mut started = vec![];\n \n-    for value in values {\n-        match value {\n-            Kind::Start(_, r) => started.push(r),\n-            Kind::End(_, er) => {\n+    for RangeBound(_, kind, range) in values {\n+        match kind {\n+            BoundKind::Start => started.push(range),\n+            BoundKind::EndExcluded | BoundKind::EndIncluded => {\n                 let mut overlap = None;\n \n-                while let Some(sr) = started.pop() {\n-                    if sr == er {\n+                while let Some(last_started) = started.pop() {\n+                    if last_started == range {\n                         break;\n                     }\n-                    overlap = Some(sr);\n+                    overlap = Some(last_started);\n                 }\n \n-                if let Some(sr) = overlap {\n-                    return Some((er, sr));\n+                if let Some(first_overlapping) = overlap {\n+                    return Some((range, first_overlapping));\n                 }\n             },\n         }\n@@ -2227,29 +2207,29 @@ fn test_overlapping() {\n     };\n \n     assert_eq!(None, overlapping::<u8>(&[]));\n-    assert_eq!(None, overlapping(&[sp(1, Bound::Included(4))]));\n+    assert_eq!(None, overlapping(&[sp(1, EndBound::Included(4))]));\n     assert_eq!(\n         None,\n-        overlapping(&[sp(1, Bound::Included(4)), sp(5, Bound::Included(6))])\n+        overlapping(&[sp(1, EndBound::Included(4)), sp(5, EndBound::Included(6))])\n     );\n     assert_eq!(\n         None,\n         overlapping(&[\n-            sp(1, Bound::Included(4)),\n-            sp(5, Bound::Included(6)),\n-            sp(10, Bound::Included(11))\n+            sp(1, EndBound::Included(4)),\n+            sp(5, EndBound::Included(6)),\n+            sp(10, EndBound::Included(11))\n         ],)\n     );\n     assert_eq!(\n-        Some((&sp(1, Bound::Included(4)), &sp(3, Bound::Included(6)))),\n-        overlapping(&[sp(1, Bound::Included(4)), sp(3, Bound::Included(6))])\n+        Some((&sp(1, EndBound::Included(4)), &sp(3, EndBound::Included(6)))),\n+        overlapping(&[sp(1, EndBound::Included(4)), sp(3, EndBound::Included(6))])\n     );\n     assert_eq!(\n-        Some((&sp(5, Bound::Included(6)), &sp(6, Bound::Included(11)))),\n+        Some((&sp(5, EndBound::Included(6)), &sp(6, EndBound::Included(11)))),\n         overlapping(&[\n-            sp(1, Bound::Included(4)),\n-            sp(5, Bound::Included(6)),\n-            sp(6, Bound::Included(11))\n+            sp(1, EndBound::Included(4)),\n+            sp(5, EndBound::Included(6)),\n+            sp(6, EndBound::Included(11))\n         ],)\n     );\n }"}]}