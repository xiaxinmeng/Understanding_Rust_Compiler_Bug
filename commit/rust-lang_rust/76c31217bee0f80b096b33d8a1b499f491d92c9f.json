{"sha": "76c31217bee0f80b096b33d8a1b499f491d92c9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YzMxMjE3YmVlMGY4MGIwOTZiMzNkOGExYjQ5OWY0OTFkOTJjOWY=", "commit": {"author": {"name": "gareth", "email": "gareth@gareth-N56VM.(none)", "date": "2013-05-12T12:58:00Z"}, "committer": {"name": "gareth", "email": "gareth@gareth-N56VM.(none)", "date": "2013-05-27T12:50:33Z"}, "message": "Refactor core::run in order to address many of the issues\nmentioned in #2625.\n\nThis change makes the module more oriented around\nProcess values instead of having to deal with process ids\ndirectly.\n\nApart from issues mentioned in #2625, other changes include:\n- Changing the naming to be more consistent - Process/process\n  is now used instead of a mixture of Program/program and\n  Process/process.\n- More docs/tests.\n\nSome io/scheduler related issues remain (mentioned in #2625).", "tree": {"sha": "7acc05357fd53b79704b908c3438c83e86b01341", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7acc05357fd53b79704b908c3438c83e86b01341"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76c31217bee0f80b096b33d8a1b499f491d92c9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76c31217bee0f80b096b33d8a1b499f491d92c9f", "html_url": "https://github.com/rust-lang/rust/commit/76c31217bee0f80b096b33d8a1b499f491d92c9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76c31217bee0f80b096b33d8a1b499f491d92c9f/comments", "author": null, "committer": null, "parents": [{"sha": "d577eafff3fed544e616373c06c987ed0471dfc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d577eafff3fed544e616373c06c987ed0471dfc4", "html_url": "https://github.com/rust-lang/rust/commit/d577eafff3fed544e616373c06c987ed0471dfc4"}], "stats": {"total": 1176, "additions": 693, "deletions": 483}, "files": [{"sha": "a059f97daab7cac05b62b4ec3f57230202cf9dcd", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 16, "deletions": 69, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=76c31217bee0f80b096b33d8a1b499f491d92c9f", "patch": "@@ -10,8 +10,6 @@\n \n use core::prelude::*;\n \n-use core::libc::c_int;\n-use core::run::spawn_process;\n use core::run;\n \n #[cfg(target_os = \"win32\")]\n@@ -38,86 +36,35 @@ fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n fn target_env(_lib_path: &str, _prog: &str) -> ~[(~str,~str)] {\n-    ~[]\n+    os::env()\n }\n \n pub struct Result {status: int, out: ~str, err: ~str}\n \n-// FIXME (#2659): This code is duplicated in core::run::program_output\n pub fn run(lib_path: &str,\n            prog: &str,\n            args: &[~str],\n            env: ~[(~str, ~str)],\n            input: Option<~str>) -> Result {\n-    let pipe_in = os::pipe();\n-    let pipe_out = os::pipe();\n-    let pipe_err = os::pipe();\n-    let pid = spawn_process(prog, args,\n-                            &Some(env + target_env(lib_path, prog)),\n-                            &None, pipe_in.in, pipe_out.out, pipe_err.out);\n-\n-    os::close(pipe_in.in);\n-    os::close(pipe_out.out);\n-    os::close(pipe_err.out);\n-    if pid == -1i32 {\n-        os::close(pipe_in.out);\n-        os::close(pipe_out.in);\n-        os::close(pipe_err.in);\n-        fail!();\n-    }\n \n+    let env = env + target_env(lib_path, prog);\n+    let mut proc = run::Process::new(prog, args, run::ProcessOptions {\n+        env: Some(env.slice(0, env.len())),\n+        dir: None,\n+        in_fd: None,\n+        out_fd: None,\n+        err_fd: None\n+    });\n \n-    writeclose(pipe_in.out, input);\n-    let p = comm::PortSet::new();\n-    let ch = p.chan();\n-    do task::spawn_sched(task::SingleThreaded) || {\n-        let errput = readclose(pipe_err.in);\n-        ch.send((2, errput));\n+    for input.each |input| {\n+        proc.input().write_str(*input);\n     }\n-    let ch = p.chan();\n-    do task::spawn_sched(task::SingleThreaded) || {\n-        let output = readclose(pipe_out.in);\n-        ch.send((1, output));\n-    }\n-    let status = run::waitpid(pid);\n-    let mut errs = ~\"\";\n-    let mut outs = ~\"\";\n-    let mut count = 2;\n-    while count > 0 {\n-        match p.recv() {\n-          (1, s) => {\n-            outs = s;\n-          }\n-          (2, s) => {\n-            errs = s;\n-          }\n-          _ => { fail!() }\n-        };\n-        count -= 1;\n-    };\n-    return Result {status: status, out: outs, err: errs};\n-}\n+    let output = proc.finish_with_output();\n \n-fn writeclose(fd: c_int, s: Option<~str>) {\n-    if s.is_some() {\n-        let writer = io::fd_writer(fd, false);\n-        writer.write_str(s.get());\n+    Result {\n+        status: output.status,\n+        out: str::from_bytes(output.output),\n+        err: str::from_bytes(output.error)\n     }\n-\n-    os::close(fd);\n }\n \n-fn readclose(fd: c_int) -> ~str {\n-    unsafe {\n-        // Copied from run::program_output\n-        let file = os::fdopen(fd);\n-        let reader = io::FILE_reader(file, false);\n-        let mut buf = ~\"\";\n-        while !reader.eof() {\n-            let bytes = reader.read_bytes(4096u);\n-            str::push_str(&mut buf, str::from_bytes(bytes));\n-        }\n-        os::fclose(file);\n-        return buf;\n-    }\n-}"}, {"sha": "9df9ffd9465c2b1355e56c20df7bd8e63215b1d2", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=76c31217bee0f80b096b33d8a1b499f491d92c9f", "patch": "@@ -415,7 +415,7 @@ fn test() {\n         prep.declare_input(\"file\", pth.to_str(), digest_file(&pth));\n         do prep.exec |_exe| {\n             let out = Path(\"foo.o\");\n-            run::run_program(\"gcc\", [~\"foo.c\", ~\"-o\", out.to_str()]);\n+            run::process_status(\"gcc\", [~\"foo.c\", ~\"-o\", out.to_str()]);\n             out.to_str()\n         }\n     };"}, {"sha": "90a93a9e57cc174b11ef01c8c1db63a0f8567afc", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=76c31217bee0f80b096b33d8a1b499f491d92c9f", "patch": "@@ -412,20 +412,20 @@ pub fn check_whole_compiler(code: &str,\n pub fn removeIfExists(filename: &Path) {\n     // So sketchy!\n     assert!(!contains(filename.to_str(), \" \"));\n-    run::program_output(\"bash\", [~\"-c\", ~\"rm \" + filename.to_str()]);\n+    run::process_status(\"bash\", [~\"-c\", ~\"rm \" + filename.to_str()]);\n }\n \n pub fn removeDirIfExists(filename: &Path) {\n     // So sketchy!\n     assert!(!contains(filename.to_str(), \" \"));\n-    run::program_output(\"bash\", [~\"-c\", ~\"rm -r \" + filename.to_str()]);\n+    run::process_status(\"bash\", [~\"-c\", ~\"rm -r \" + filename.to_str()]);\n }\n \n pub fn check_running(exe_filename: &Path) -> happiness {\n-    let p = run::program_output(\n+    let p = run::process_output(\n         \"/Users/jruderman/scripts/timed_run_rust_program.py\",\n         [exe_filename.to_str()]);\n-    let comb = p.out + ~\"\\n\" + p.err;\n+    let comb = str::from_bytes(p.output) + ~\"\\n\" + str::from_bytes(p.error);\n     if str::len(comb) > 1u {\n         error!(\"comb comb comb: %?\", comb);\n     }\n@@ -461,33 +461,35 @@ pub fn check_running(exe_filename: &Path) -> happiness {\n }\n \n pub fn check_compiling(filename: &Path) -> happiness {\n-    let p = run::program_output(\n-        \"/Users/jruderman/code/rust/build/x86_64-apple-darwin/\\\n-         stage1/bin/rustc\",\n+    let p = run::process_output(\n+        \"/Users/jruderman/code/rust/build/x86_64-apple-darwin/stage1/bin/rustc\",\n         [filename.to_str()]);\n \n+    let out = str::from_bytes(p.output);\n+    let err = str::from_bytes(p.error);\n+\n     //error!(\"Status: %d\", p.status);\n     if p.status == 0 {\n         passed\n-    } else if p.err != ~\"\" {\n-        if contains(p.err, \"error:\") {\n+    } else if !err.is_empty() {\n+        if err.contains(\"error:\") {\n             cleanly_rejected(~\"rejected with span_error\")\n         } else {\n-            error!(\"Stderr: %?\", p.err);\n+            error!(\"Stderr: %?\", err);\n             failed(~\"Unfamiliar error message\")\n         }\n-    } else if contains(p.out, \"Assertion\") && contains(p.out, \"failed\") {\n-        error!(\"Stdout: %?\", p.out);\n+    } else if out.contains(\"Assertion\") && out.contains(\"failed\") {\n+        error!(\"Stdout: %?\", out);\n         failed(~\"Looks like an llvm assertion failure\")\n-    } else if contains(p.out, \"internal compiler error unimplemented\") {\n+    } else if out.contains(\"internal compiler error unimplemented\") {\n         known_bug(~\"Something unimplemented\")\n-    } else if contains(p.out, \"internal compiler error\") {\n-        error!(\"Stdout: %?\", p.out);\n+    } else if out.contains(\"internal compiler error\") {\n+        error!(\"Stdout: %?\", out);\n         failed(~\"internal compiler error\")\n \n     } else {\n         error!(\"%?\", p.status);\n-        error!(\"!Stdout: %?\", p.out);\n+        error!(\"!Stdout: %?\", out);\n         failed(~\"What happened?\")\n     }\n }\n@@ -608,9 +610,7 @@ pub fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n         error!(\"Did not converge after %u iterations!\", i);\n         write_file(&Path(\"round-trip-a.rs\"), *oldv);\n         write_file(&Path(\"round-trip-b.rs\"), *newv);\n-        run::run_program(\"diff\",\n-                         [~\"-w\", ~\"-u\", ~\"round-trip-a.rs\",\n-                          ~\"round-trip-b.rs\"]);\n+        run::process_status(\"diff\", [~\"-w\", ~\"-u\", ~\"round-trip-a.rs\", ~\"round-trip-b.rs\"]);\n         fail!(\"Mismatch\");\n     }\n }"}, {"sha": "36246b7a9a14cd7b354a74b8f5c5c99866fd6842", "filename": "src/librust/rust.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibrust%2Frust.rc", "raw_url": "https://github.com/rust-lang/rust/raw/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibrust%2Frust.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rc?ref=76c31217bee0f80b096b33d8a1b499f491d92c9f", "patch": "@@ -163,7 +163,7 @@ fn cmd_test(args: &[~str]) -> ValidUsage {\n             let test_exec = Path(filename).filestem().unwrap() + \"test~\";\n             invoke(\"rustc\", &[~\"--test\", filename.to_owned(),\n                               ~\"-o\", test_exec.to_owned()], rustc::main);\n-            let exit_code = run::run_program(~\"./\" + test_exec, []);\n+            let exit_code = run::process_status(~\"./\" + test_exec, []);\n             Valid(exit_code)\n         }\n         _ => Invalid\n@@ -176,7 +176,7 @@ fn cmd_run(args: &[~str]) -> ValidUsage {\n             let exec = Path(filename).filestem().unwrap() + \"~\";\n             invoke(\"rustc\", &[filename.to_owned(), ~\"-o\", exec.to_owned()],\n                    rustc::main);\n-            let exit_code = run::run_program(~\"./\"+exec, prog_args);\n+            let exit_code = run::process_status(~\"./\"+exec, prog_args);\n             Valid(exit_code)\n         }\n         _ => Invalid"}, {"sha": "0dddbf395e024aa7cf15f69f03c4ec864c87e20d", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=76c31217bee0f80b096b33d8a1b499f491d92c9f", "patch": "@@ -403,14 +403,14 @@ pub mod write {\n         cc_args.push(object.to_str());\n         cc_args.push(assembly.to_str());\n \n-        let prog = run::program_output(cc_prog, cc_args);\n+        let prog = run::process_output(cc_prog, cc_args);\n \n         if prog.status != 0 {\n             sess.err(fmt!(\"building with `%s` failed with code %d\",\n                         cc_prog, prog.status));\n             sess.note(fmt!(\"%s arguments: %s\",\n                         cc_prog, str::connect(cc_args, \" \")));\n-            sess.note(prog.err + prog.out);\n+            sess.note(str::from_bytes(prog.error + prog.output));\n             sess.abort_if_errors();\n         }\n     }\n@@ -817,19 +817,19 @@ pub fn link_binary(sess: Session,\n     let cc_args = link_args(sess, obj_filename, out_filename, lm);\n     debug!(\"%s link args: %s\", cc_prog, str::connect(cc_args, \" \"));\n     // We run 'cc' here\n-    let prog = run::program_output(cc_prog, cc_args);\n+    let prog = run::process_output(cc_prog, cc_args);\n     if 0 != prog.status {\n         sess.err(fmt!(\"linking with `%s` failed with code %d\",\n                       cc_prog, prog.status));\n         sess.note(fmt!(\"%s arguments: %s\",\n                        cc_prog, str::connect(cc_args, \" \")));\n-        sess.note(prog.err + prog.out);\n+        sess.note(str::from_bytes(prog.error + prog.output));\n         sess.abort_if_errors();\n     }\n \n     // Clean up on Darwin\n     if sess.targ_cfg.os == session::os_macos {\n-        run::run_program(\"dsymutil\", [output.to_str()]);\n+        run::process_status(\"dsymutil\", [output.to_str()]);\n     }\n \n     // Remove the temporary object file if we aren't saving temps"}, {"sha": "603ce0de67d933a583372874be646017b8c838ac", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=76c31217bee0f80b096b33d8a1b499f491d92c9f", "patch": "@@ -12,7 +12,7 @@ use core::prelude::*;\n \n use core::cell::Cell;\n use core::run;\n-use core::run::ProgramOutput;\n+use core::run::ProcessOutput;\n use core::result::Result;\n use extra::getopts;\n \n@@ -89,35 +89,35 @@ pub fn default_config(input_crate: &Path) -> Config {\n     }\n }\n \n-type Process = ~fn((&str), (&[~str])) -> ProgramOutput;\n+type Process = ~fn((&str), (&[~str])) -> ProcessOutput;\n \n-pub fn mock_program_output(_prog: &str, _args: &[~str]) -> ProgramOutput {\n-    ProgramOutput {\n+pub fn mock_process_output(_prog: &str, _args: &[~str]) -> ProcessOutput {\n+    ProcessOutput {\n         status: 0,\n-        out: ~\"\",\n-        err: ~\"\"\n+        output: ~[],\n+        error: ~[]\n     }\n }\n \n-pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n-    run::program_output(prog, args)\n+pub fn process_output(prog: &str, args: &[~str]) -> ProcessOutput {\n+    run::process_output(prog, args)\n }\n \n pub fn parse_config(args: &[~str]) -> Result<Config, ~str> {\n-    parse_config_(args, program_output)\n+    parse_config_(args, process_output)\n }\n \n pub fn parse_config_(\n     args: &[~str],\n-    program_output: Process\n+    process_output: Process\n ) -> Result<Config, ~str> {\n     let args = args.tail();\n     let opts = vec::unzip(opts()).first();\n     match getopts::getopts(args, opts) {\n         Ok(matches) => {\n             if matches.free.len() == 1 {\n                 let input_crate = Path(*matches.free.head());\n-                config_from_opts(&input_crate, &matches, program_output)\n+                config_from_opts(&input_crate, &matches, process_output)\n             } else if matches.free.is_empty() {\n                 Err(~\"no crates specified\")\n             } else {\n@@ -133,7 +133,7 @@ pub fn parse_config_(\n fn config_from_opts(\n     input_crate: &Path,\n     matches: &getopts::Matches,\n-    program_output: Process\n+    process_output: Process\n ) -> Result<Config, ~str> {\n \n     let config = default_config(input_crate);\n@@ -175,11 +175,11 @@ fn config_from_opts(\n             }\n         }\n     };\n-    let program_output = Cell(program_output);\n+    let process_output = Cell(process_output);\n     let result = do result::chain(result) |config| {\n         let pandoc_cmd = getopts::opt_maybe_str(matches, opt_pandoc_cmd());\n         let pandoc_cmd = maybe_find_pandoc(\n-            &config, pandoc_cmd, program_output.take());\n+            &config, pandoc_cmd, process_output.take());\n         do result::chain(pandoc_cmd) |pandoc_cmd| {\n             result::Ok(Config {\n                 pandoc_cmd: pandoc_cmd,\n@@ -209,7 +209,7 @@ fn parse_output_style(output_style: &str) -> Result<OutputStyle, ~str> {\n pub fn maybe_find_pandoc(\n     config: &Config,\n     maybe_pandoc_cmd: Option<~str>,\n-    program_output: Process\n+    process_output: Process\n ) -> Result<Option<~str>, ~str> {\n     if config.output_format != PandocHtml {\n         return result::Ok(maybe_pandoc_cmd);\n@@ -228,7 +228,7 @@ pub fn maybe_find_pandoc(\n     };\n \n     let pandoc = do vec::find(possible_pandocs) |pandoc| {\n-        let output = program_output(*pandoc, [~\"--version\"]);\n+        let output = process_output(*pandoc, [~\"--version\"]);\n         debug!(\"testing pandoc cmd %s: %?\", *pandoc, output);\n         output.status == 0\n     };\n@@ -244,10 +244,10 @@ pub fn maybe_find_pandoc(\n mod test {\n     use core::prelude::*;\n     use config::*;\n-    use core::run::ProgramOutput;\n+    use core::run::ProcessOutput;\n \n     fn parse_config(args: &[~str]) -> Result<Config, ~str> {\n-        parse_config_(args, mock_program_output)\n+        parse_config_(args, mock_process_output)\n     }\n \n     #[test]\n@@ -256,10 +256,10 @@ mod test {\n             output_format: PandocHtml,\n             .. default_config(&Path(\"test\"))\n         };\n-        let mock_program_output: ~fn(&str, &[~str]) -> ProgramOutput = |_, _| {\n-            ProgramOutput { status: 0, out: ~\"pandoc 1.8.2.1\", err: ~\"\" }\n+        let mock_process_output: ~fn(&str, &[~str]) -> ProcessOutput = |_, _| {\n+            ProcessOutput { status: 0, output: \"pandoc 1.8.2.1\".to_bytes(), error: ~[] }\n         };\n-        let result = maybe_find_pandoc(&config, None, mock_program_output);\n+        let result = maybe_find_pandoc(&config, None, mock_process_output);\n         assert!(result == result::Ok(Some(~\"pandoc\")));\n     }\n \n@@ -269,10 +269,10 @@ mod test {\n             output_format: PandocHtml,\n             .. default_config(&Path(\"test\"))\n         };\n-        let mock_program_output: ~fn(&str, &[~str]) -> ProgramOutput = |_, _| {\n-            ProgramOutput { status: 1, out: ~\"\", err: ~\"\" }\n+        let mock_process_output: ~fn(&str, &[~str]) -> ProcessOutput = |_, _| {\n+            ProcessOutput { status: 1, output: ~[], error: ~[] }\n         };\n-        let result = maybe_find_pandoc(&config, None, mock_program_output);\n+        let result = maybe_find_pandoc(&config, None, mock_process_output);\n         assert!(result == result::Err(~\"couldn't find pandoc\"));\n     }\n "}, {"sha": "8149dc61fb475a3586797d1b13dd2a0b5a662013", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 7, "deletions": 48, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=76c31217bee0f80b096b33d8a1b499f491d92c9f", "patch": "@@ -14,7 +14,6 @@ use config;\n use doc::ItemUtils;\n use doc;\n \n-use core::libc;\n use core::run;\n use core::comm::*;\n use extra::future;\n@@ -105,60 +104,20 @@ fn pandoc_writer(\n         debug!(\"pandoc cmd: %s\", pandoc_cmd);\n         debug!(\"pandoc args: %s\", str::connect(pandoc_args, \" \"));\n \n-        let pipe_in = os::pipe();\n-        let pipe_out = os::pipe();\n-        let pipe_err = os::pipe();\n-        let pid = run::spawn_process(\n-            pandoc_cmd, pandoc_args, &None, &None,\n-            pipe_in.in, pipe_out.out, pipe_err.out);\n+        let mut proc = run::Process::new(pandoc_cmd, pandoc_args, run::ProcessOptions::new());\n \n-        let writer = io::fd_writer(pipe_in.out, false);\n-        writer.write_str(markdown);\n+        proc.input().write_str(markdown);\n+        let output = proc.finish_with_output();\n \n-        os::close(pipe_in.in);\n-        os::close(pipe_out.out);\n-        os::close(pipe_err.out);\n-        os::close(pipe_in.out);\n-\n-        let (stdout_po, stdout_ch) = comm::stream();\n-        do task::spawn_sched(task::SingleThreaded) || {\n-            stdout_ch.send(readclose(pipe_out.in));\n-        }\n-\n-        let (stderr_po, stderr_ch) = comm::stream();\n-        do task::spawn_sched(task::SingleThreaded) || {\n-            stderr_ch.send(readclose(pipe_err.in));\n-        }\n-        let stdout = stdout_po.recv();\n-        let stderr = stderr_po.recv();\n-\n-        let status = run::waitpid(pid);\n-        debug!(\"pandoc result: %i\", status);\n-        if status != 0 {\n-            error!(\"pandoc-out: %s\", stdout);\n-            error!(\"pandoc-err: %s\", stderr);\n+        debug!(\"pandoc result: %i\", output.status);\n+        if output.status != 0 {\n+            error!(\"pandoc-out: %s\", str::from_bytes(output.output));\n+            error!(\"pandoc-err: %s\", str::from_bytes(output.error));\n             fail!(\"pandoc failed\");\n         }\n     }\n }\n \n-fn readclose(fd: libc::c_int) -> ~str {\n-    // Copied from run::program_output\n-    unsafe {\n-        let file = os::fdopen(fd);\n-        let reader = io::FILE_reader(file, false);\n-        let buf = io::with_bytes_writer(|writer| {\n-            let mut bytes = [0, ..4096];\n-            while !reader.eof() {\n-                let nread = reader.read(bytes, bytes.len());\n-                writer.write(bytes.slice(0, nread).to_owned());\n-            }\n-        });\n-        os::fclose(file);\n-        str::from_bytes(buf)\n-    }\n-}\n-\n fn generic_writer(process: ~fn(markdown: ~str)) -> Writer {\n     let (po, ch) = stream::<WriteInstr>();\n     do task::spawn || {"}, {"sha": "a419bffece72b0fe329ebc0ad8de0b5eb3286deb", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=76c31217bee0f80b096b33d8a1b499f491d92c9f", "patch": "@@ -131,17 +131,17 @@ impl<'self> PkgScript<'self> {\n                                                &exe, @copy os::args()[0],\n                                                driver::cu_everything);\n                 debug!(\"Running program: %s %s %s\", exe.to_str(), root.to_str(), what);\n-                let status = run::run_program(exe.to_str(), [root.to_str(), what]);\n+                let status = run::process_status(exe.to_str(), [root.to_str(), what]);\n                 if status != 0 {\n                     return (~[], status);\n                 }\n                 else {\n                     debug!(\"Running program (configs): %s %s %s\",\n                            exe.to_str(), root.to_str(), \"configs\");\n-                    let output = run::program_output(exe.to_str(), [root.to_str(), ~\"configs\"]);\n+                    let output = run::process_output(exe.to_str(), [root.to_str(), ~\"configs\"]);\n                     // Run the configs() function to get the configs\n                     let mut cfgs = ~[];\n-                    for str::each_word(output.out) |w| {\n+                    for str::each_word(str::from_bytes(output.output)) |w| {\n                         cfgs.push(w.to_owned());\n                     }\n                     (cfgs, output.status)\n@@ -551,7 +551,7 @@ impl PkgSrc {\n         let url = fmt!(\"https://%s\", self.id.remote_path.to_str());\n         util::note(fmt!(\"git clone %s %s\", url, local.to_str()));\n \n-        if run::program_output(\"git\", [~\"clone\", copy url, local.to_str()]).status != 0 {\n+        if run::process_output(\"git\", [~\"clone\", copy url, local.to_str()]).status != 0 {\n             util::note(fmt!(\"fetching %s failed: can't clone repository\", url));\n             return false;\n         }"}, {"sha": "2d3a75d9197bf43557b67c4e9b920e69c3f67ee4", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=76c31217bee0f80b096b33d8a1b499f491d92c9f", "patch": "@@ -23,6 +23,6 @@ pub fn main() {\n     file.write_str(\"pub fn wheeeee() { for [1, 2, 3].each() |_| { assert!(true); } }\");\n \n     // now compile the crate itself\n-    run::run_program(\"rustc\", ~[~\"src/fancy-lib/fancy-lib.rs\", ~\"--lib\",\n-                                ~\"-o\", out_path.push(~\"fancy_lib\").to_str()]);\n+    run::process_status(\"rustc\", [~\"src/fancy-lib/fancy-lib.rs\", ~\"--lib\", ~\"-o\",\n+                        out_path.push(~\"fancy_lib\").to_str()]);\n }\n\\ No newline at end of file"}, {"sha": "49e3c17be1b3e161603de054314155209903a8a4", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=76c31217bee0f80b096b33d8a1b499f491d92c9f", "patch": "@@ -1671,7 +1671,7 @@ mod tests {\n             fail!(\"%s doesn't exist\", in.to_str());\n           }\n           assert!((rs));\n-          let rslt = run::run_program(\"diff\", [in.to_str(), out.to_str()]);\n+          let rslt = run::process_status(\"diff\", [in.to_str(), out.to_str()]);\n           assert_eq!(rslt, 0);\n           assert_eq!(out.get_mode(), in_mode);\n           assert!((remove_file(&in)));"}, {"sha": "1956f4baba646fb4aec170203d335a6faf782a35", "filename": "src/libstd/run.rs", "status": "modified", "additions": 606, "deletions": 303, "changes": 909, "blob_url": "https://github.com/rust-lang/rust/blob/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=76c31217bee0f80b096b33d8a1b499f491d92c9f", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Process spawning\n+//! Process spawning.\n+\n use cast;\n use io;\n use libc;\n@@ -22,80 +23,367 @@ use str;\n use task;\n use vec;\n \n-/// A value representing a child process\n-pub struct Program {\n+/**\n+ * A value representing a child process.\n+ *\n+ * The lifetime of this value is linked to the lifetime of the actual\n+ * process - the Process destructor calls self.finish() which waits\n+ * for the process to terminate.\n+ */\n+pub struct Process {\n+\n+    /// The unique id of the process (this should never be negative).\n     priv pid: pid_t,\n+\n+    /**\n+     * A handle to the process - on unix this will always be NULL, but on\n+     * windows it will be a HANDLE to the process, which will prevent the\n+     * pid being re-used until the handle is closed.\n+     */\n     priv handle: *(),\n-    priv in_fd: c_int,\n-    priv out_file: *libc::FILE,\n-    priv err_file: *libc::FILE,\n-    priv finished: bool,\n+\n+    /// Some(fd), or None when stdin is being redirected from a fd not created by Process::new.\n+    priv input: Option<c_int>,\n+\n+    /// Some(fd), or None when stdout is being redirected to a fd not created by Process::new.\n+    priv output: Option<*libc::FILE>,\n+\n+    /// Some(fd), or None when stderr is being redirected to a fd not created by Process::new.\n+    priv error: Option<*libc::FILE>,\n+\n+    /// None until finish() is called.\n+    priv exit_code: Option<int>,\n }\n \n-impl Drop for Program {\n-    fn finalize(&self) {\n-        // FIXME #4943: transmute is bad.\n-        let mut_self: &mut Program = unsafe { cast::transmute(self) };\n+/// Options that can be given when starting a Process.\n+pub struct ProcessOptions<'self> {\n \n-        mut_self.finish();\n-        mut_self.close_outputs();\n-        free_handle(self.handle);\n+    /**\n+     * If this is None then the new process will have the same initial\n+     * environment as the parent process.\n+     *\n+     * If this is Some(vec-of-names-and-values) then the new process will\n+     * have an environment containing the given named values only.\n+     */\n+    env: Option<&'self [(~str, ~str)]>,\n+\n+    /**\n+     * If this is None then the new process will use the same initial working\n+     * directory as the parent process.\n+     *\n+     * If this is Some(path) then the new process will use the given path\n+     * for its initial working directory.\n+     */\n+    dir: Option<&'self Path>,\n+\n+    /**\n+     * If this is None then a new pipe will be created for the new process's\n+     * input and Process.input() will provide a Writer to write to this pipe.\n+     *\n+     * If this is Some(file-descriptor) then the new process will read its input\n+     * from the given file descriptor, Process.input_redirected() will return\n+     * true, and Process.input() will fail.\n+     */\n+    in_fd: Option<c_int>,\n+\n+    /**\n+     * If this is None then a new pipe will be created for the new progam's\n+     * output and Process.output() will provide a Reader to read from this pipe.\n+     *\n+     * If this is Some(file-descriptor) then the new process will write its output\n+     * to the given file descriptor, Process.output_redirected() will return\n+     * true, and Process.output() will fail.\n+     */\n+    out_fd: Option<c_int>,\n+\n+    /**\n+     * If this is None then a new pipe will be created for the new progam's\n+     * error stream and Process.error() will provide a Reader to read from this pipe.\n+     *\n+     * If this is Some(file-descriptor) then the new process will write its error output\n+     * to the given file descriptor, Process.error_redirected() will return true, and\n+     * and Process.error() will fail.\n+     */\n+    err_fd: Option<c_int>,\n+}\n+\n+impl <'self> ProcessOptions<'self> {\n+    /// Return a ProcessOptions that has None in every field.\n+    pub fn new<'a>() -> ProcessOptions<'a> {\n+        ProcessOptions {\n+            env: None,\n+            dir: None,\n+            in_fd: None,\n+            out_fd: None,\n+            err_fd: None,\n+        }\n     }\n }\n \n-pub impl Program {\n+/// The output of a finished process.\n+pub struct ProcessOutput {\n+\n+    /// The status (exit code) of the process.\n+    status: int,\n+\n+    /// The data that the process wrote to stdout.\n+    output: ~[u8],\n+\n+    /// The data that the process wrote to stderr.\n+    error: ~[u8],\n+}\n+\n+pub impl Process {\n+\n+    /**\n+     * Spawns a new Process.\n+     *\n+     * # Arguments\n+     *\n+     * * prog - The path to an executable.\n+     * * args - Vector of arguments to pass to the child process.\n+     * * options - Options to configure the environment of the process,\n+     *             the working directory and the standard IO streams.\n+     */\n+    pub fn new(prog: &str, args: &[~str], options: ProcessOptions) -> Process {\n+\n+        let (in_pipe, in_fd) = match options.in_fd {\n+            None => {\n+                let pipe = os::pipe();\n+                (Some(pipe), pipe.in)\n+            },\n+            Some(fd) => (None, fd)\n+        };\n+        let (out_pipe, out_fd) = match options.out_fd {\n+            None => {\n+                let pipe = os::pipe();\n+                (Some(pipe), pipe.out)\n+            },\n+            Some(fd) => (None, fd)\n+        };\n+        let (err_pipe, err_fd) = match options.err_fd {\n+            None => {\n+                let pipe = os::pipe();\n+                (Some(pipe), pipe.out)\n+            },\n+            Some(fd) => (None, fd)\n+        };\n+\n+        let res = spawn_process_os(prog, args, options.env, options.dir,\n+                                   in_fd, out_fd, err_fd);\n+\n+        unsafe {\n+            for in_pipe.each  |pipe| { libc::close(pipe.in); }\n+            for out_pipe.each |pipe| { libc::close(pipe.out); }\n+            for err_pipe.each |pipe| { libc::close(pipe.out); }\n+        }\n+\n+        Process {\n+            pid: res.pid,\n+            handle: res.handle,\n+            input: in_pipe.map(|pipe| pipe.out),\n+            output: out_pipe.map(|pipe| os::fdopen(pipe.in)),\n+            error: err_pipe.map(|pipe| os::fdopen(pipe.in)),\n+            exit_code: None,\n+        }\n+    }\n+\n+    /// Returns the unique id of the process\n+    fn get_id(&self) -> pid_t { self.pid }\n+\n+    priv fn unwrap_input(&mut self) -> c_int {\n+        match self.input {\n+            Some(fd) => fd,\n+            None => fail!(\"This Process's stdin was redirected to an \\\n+                           existing file descriptor.\")\n+        }\n+    }\n+\n+    priv fn unwrap_output(&mut self) -> *libc::FILE {\n+        match self.output {\n+            Some(file) => file,\n+            None => fail!(\"This Process's stdout was redirected to an \\\n+                           existing file descriptor.\")\n+        }\n+    }\n+\n+    priv fn unwrap_error(&mut self) -> *libc::FILE {\n+        match self.error {\n+            Some(file) => file,\n+            None => fail!(\"This Process's stderr was redirected to an \\\n+                           existing file descriptor.\")\n+        }\n+    }\n \n-    /// Returns the process id of the program\n-    fn get_id(&mut self) -> pid_t { self.pid }\n+    /**\n+     * Returns whether this process is reading its stdin from an existing file\n+     * descriptor rather than a pipe that was created specifically for this\n+     * process.\n+     *\n+     * If this method returns true then self.input() will fail.\n+     */\n+    fn input_redirected(&self) -> bool {\n+        self.input.is_none()\n+    }\n \n-    /// Returns an io::Writer that can be used to write to stdin\n+    /**\n+     * Returns whether this process is writing its stdout to an existing file\n+     * descriptor rather than a pipe that was created specifically for this\n+     * process.\n+     *\n+     * If this method returns true then self.output() will fail.\n+     */\n+    fn output_redirected(&self) -> bool {\n+        self.output.is_none()\n+    }\n+\n+    /**\n+     * Returns whether this process is writing its stderr to an existing file\n+     * descriptor rather than a pipe that was created specifically for this\n+     * process.\n+     *\n+     * If this method returns true then self.error() will fail.\n+     */\n+    fn error_redirected(&self) -> bool {\n+        self.error.is_none()\n+    }\n+\n+    /**\n+     * Returns an io::Writer that can be used to write to this Process's stdin.\n+     *\n+     * Fails if this Process's stdin was redirected to an existing file descriptor.\n+     */\n     fn input(&mut self) -> @io::Writer {\n-        io::fd_writer(self.in_fd, false)\n+        // FIXME: the Writer can still be used after self is destroyed: #2625\n+       io::fd_writer(self.unwrap_input(), false)\n     }\n \n-    /// Returns an io::Reader that can be used to read from stdout\n+    /**\n+     * Returns an io::Reader that can be used to read from this Process's stdout.\n+     *\n+     * Fails if this Process's stdout was redirected to an existing file descriptor.\n+     */\n     fn output(&mut self) -> @io::Reader {\n-        io::FILE_reader(self.out_file, false)\n+        // FIXME: the Reader can still be used after self is destroyed: #2625\n+        io::FILE_reader(self.unwrap_output(), false)\n     }\n \n-    /// Returns an io::Reader that can be used to read from stderr\n-    fn err(&mut self) -> @io::Reader {\n-        io::FILE_reader(self.err_file, false)\n+    /**\n+     * Returns an io::Reader that can be used to read from this Process's stderr.\n+     *\n+     * Fails if this Process's stderr was redirected to an existing file descriptor.\n+     */\n+    fn error(&mut self) -> @io::Reader {\n+        // FIXME: the Reader can still be used after self is destroyed: #2625\n+        io::FILE_reader(self.unwrap_error(), false)\n     }\n \n-    /// Closes the handle to the child processes standard input\n+    /**\n+     * Closes the handle to the child process's stdin.\n+     *\n+     * If this process is reading its stdin from an existing file descriptor, then this\n+     * method does nothing.\n+     */\n     fn close_input(&mut self) {\n-        let invalid_fd = -1i32;\n-        if self.in_fd != invalid_fd {\n-            unsafe {\n-                libc::close(self.in_fd);\n+        match self.input {\n+            Some(-1) | None => (),\n+            Some(fd) => {\n+                unsafe {\n+                    libc::close(fd);\n+                }\n+                self.input = Some(-1);\n             }\n-            self.in_fd = invalid_fd;\n         }\n     }\n \n     priv fn close_outputs(&mut self) {\n-        unsafe {\n-            fclose_and_null(&mut self.out_file);\n-            fclose_and_null(&mut self.err_file);\n+        fclose_and_null(&mut self.output);\n+        fclose_and_null(&mut self.error);\n+\n+        fn fclose_and_null(f_opt: &mut Option<*libc::FILE>) {\n+            match *f_opt {\n+                Some(f) if !f.is_null() => {\n+                    unsafe {\n+                        libc::fclose(f);\n+                        *f_opt = Some(0 as *libc::FILE);\n+                    }\n+                },\n+                _ => ()\n+            }\n         }\n     }\n \n     /**\n-     * Waits for the child process to terminate. Closes the handle\n-     * to stdin if necessary.\n+     * Closes the handle to stdin, waits for the child process to terminate,\n+     * and returns the exit code.\n+     *\n+     * If the child has already been finished then the exit code is returned.\n      */\n     fn finish(&mut self) -> int {\n-        if self.finished { return 0; }\n-        self.finished = true;\n+        for self.exit_code.each |&code| {\n+            return code;\n+        }\n         self.close_input();\n-        return waitpid(self.pid);\n+        let code = waitpid(self.pid);\n+        self.exit_code = Some(code);\n+        return code;\n+    }\n+\n+    /**\n+     * Closes the handle to stdin, waits for the child process to terminate, and reads\n+     * and returns all remaining output of stdout and stderr, along with the exit code.\n+     *\n+     * If the child has already been finished then the exit code and any remaining\n+     * unread output of stdout and stderr will be returned.\n+     *\n+     * This method will fail if the child process's stdout or stderr streams were\n+     * redirected to existing file descriptors.\n+     */\n+    fn finish_with_output(&mut self) -> ProcessOutput {\n+\n+        let output_file = self.unwrap_output();\n+        let error_file = self.unwrap_error();\n+\n+        // Spawn two entire schedulers to read both stdout and sterr\n+        // in parallel so we don't deadlock while blocking on one\n+        // or the other. FIXME (#2625): Surely there's a much more\n+        // clever way to do this.\n+        let (p, ch) = stream();\n+        let ch = SharedChan::new(ch);\n+        let ch_clone = ch.clone();\n+        do task::spawn_sched(task::SingleThreaded) {\n+            let errput = io::FILE_reader(error_file, false);\n+            ch.send((2, errput.read_whole_stream()));\n+        }\n+        do task::spawn_sched(task::SingleThreaded) {\n+            let output = io::FILE_reader(output_file, false);\n+            ch_clone.send((1, output.read_whole_stream()));\n+        }\n+\n+        let status = self.finish();\n+\n+        let (errs, outs) = match (p.recv(), p.recv()) {\n+            ((1, o), (2, e)) => (e, o),\n+            ((2, e), (1, o)) => (e, o),\n+            ((x, _), (y, _)) => {\n+                fail!(\"unexpected file numbers: %u, %u\", x, y);\n+            }\n+        };\n+\n+        return ProcessOutput {status: status,\n+                              output: outs,\n+                              error: errs};\n     }\n \n     priv fn destroy_internal(&mut self, force: bool) {\n-        killpid(self.pid, force);\n-        self.finish();\n-        self.close_outputs();\n+\n+        // if the process has finished, and therefore had waitpid called,\n+        // and we kill it, then on unix we might ending up killing a\n+        // newer process that happens to have the same (re-used) id\n+        if self.exit_code.is_none() {\n+            killpid(self.pid, force);\n+            self.finish();\n+        }\n \n         #[cfg(windows)]\n         fn killpid(pid: pid_t, _force: bool) {\n@@ -120,7 +408,7 @@ pub impl Program {\n     }\n \n     /**\n-     * Terminate the program, giving it a chance to clean itself up if\n+     * Terminates the process, giving it a chance to clean itself up if\n      * this is supported by the operating system.\n      *\n      * On Posix OSs SIGTERM will be sent to the process. On Win32\n@@ -129,7 +417,7 @@ pub impl Program {\n     fn destroy(&mut self) { self.destroy_internal(false); }\n \n     /**\n-     * Terminate the program as soon as possible without giving it a\n+     * Terminates the process as soon as possible without giving it a\n      * chance to clean itself up.\n      *\n      * On Posix OSs SIGKILL will be sent to the process. On Win32\n@@ -138,47 +426,27 @@ pub impl Program {\n     fn force_destroy(&mut self) { self.destroy_internal(true); }\n }\n \n+impl Drop for Process {\n+    fn finalize(&self) {\n+        // FIXME #4943: transmute is bad.\n+        let mut_self: &mut Process = unsafe { cast::transmute(self) };\n \n-/**\n- * Run a program, providing stdin, stdout and stderr handles\n- *\n- * # Arguments\n- *\n- * * prog - The path to an executable\n- * * args - Vector of arguments to pass to the child process\n- * * env - optional env-modification for child\n- * * dir - optional dir to run child in (default current dir)\n- * * in_fd - A file descriptor for the child to use as std input\n- * * out_fd - A file descriptor for the child to use as std output\n- * * err_fd - A file descriptor for the child to use as std error\n- *\n- * # Return value\n- *\n- * The process id of the spawned process\n- */\n-pub fn spawn_process(prog: &str, args: &[~str],\n-                     env: &Option<~[(~str,~str)]>,\n-                     dir: &Option<~str>,\n-                     in_fd: c_int, out_fd: c_int, err_fd: c_int) -> pid_t {\n-\n-    let res = spawn_process_internal(prog, args, env, dir, in_fd, out_fd, err_fd);\n-    free_handle(res.handle);\n-    return res.pid;\n+        mut_self.finish();\n+        mut_self.close_outputs();\n+        free_handle(self.handle);\n+    }\n }\n \n-struct RunProgramResult {\n-    // the process id of the program (this should never be negative)\n+struct SpawnProcessResult {\n     pid: pid_t,\n-    // a handle to the process - on unix this will always be NULL, but on windows it will be a\n-    // HANDLE to the process, which will prevent the pid being re-used until the handle is closed.\n     handle: *(),\n }\n \n #[cfg(windows)]\n-fn spawn_process_internal(prog: &str, args: &[~str],\n-                          env: &Option<~[(~str,~str)]>,\n-                          dir: &Option<~str>,\n-                          in_fd: c_int, out_fd: c_int, err_fd: c_int) -> RunProgramResult {\n+fn spawn_process_os(prog: &str, args: &[~str],\n+                    env: Option<&[(~str, ~str)]>,\n+                    dir: Option<&Path>,\n+                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n \n     use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n     use libc::consts::os::extra::{\n@@ -203,7 +471,7 @@ fn spawn_process_internal(prog: &str, args: &[~str],\n \n         let cur_proc = GetCurrentProcess();\n \n-        let orig_std_in = get_osfhandle(if in_fd > 0 { in_fd } else { 0 }) as HANDLE;\n+        let orig_std_in = get_osfhandle(in_fd) as HANDLE;\n         if orig_std_in == INVALID_HANDLE_VALUE as HANDLE {\n             fail!(\"failure in get_osfhandle: %s\", os::last_os_error());\n         }\n@@ -212,7 +480,7 @@ fn spawn_process_internal(prog: &str, args: &[~str],\n             fail!(\"failure in DuplicateHandle: %s\", os::last_os_error());\n         }\n \n-        let orig_std_out = get_osfhandle(if out_fd > 0 { out_fd } else { 1 }) as HANDLE;\n+        let orig_std_out = get_osfhandle(out_fd) as HANDLE;\n         if orig_std_out == INVALID_HANDLE_VALUE as HANDLE {\n             fail!(\"failure in get_osfhandle: %s\", os::last_os_error());\n         }\n@@ -221,8 +489,8 @@ fn spawn_process_internal(prog: &str, args: &[~str],\n             fail!(\"failure in DuplicateHandle: %s\", os::last_os_error());\n         }\n \n-        let orig_std_err = get_osfhandle(if err_fd > 0 { err_fd } else { 2 }) as HANDLE;\n-        if orig_std_err as HANDLE == INVALID_HANDLE_VALUE as HANDLE {\n+        let orig_std_err = get_osfhandle(err_fd) as HANDLE;\n+        if orig_std_err == INVALID_HANDLE_VALUE as HANDLE {\n             fail!(\"failure in get_osfhandle: %s\", os::last_os_error());\n         }\n         if DuplicateHandle(cur_proc, orig_std_err, cur_proc, &mut si.hStdError,\n@@ -261,7 +529,7 @@ fn spawn_process_internal(prog: &str, args: &[~str],\n         // until the calling code closes the process handle.\n         CloseHandle(pi.hThread);\n \n-        RunProgramResult {\n+        SpawnProcessResult {\n             pid: pi.dwProcessId as pid_t,\n             handle: pi.hProcess as *()\n         }\n@@ -357,10 +625,10 @@ pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n }\n \n #[cfg(unix)]\n-fn spawn_process_internal(prog: &str, args: &[~str],\n-                          env: &Option<~[(~str,~str)]>,\n-                          dir: &Option<~str>,\n-                          in_fd: c_int, out_fd: c_int, err_fd: c_int) -> RunProgramResult {\n+fn spawn_process_os(prog: &str, args: &[~str],\n+                    env: Option<&[(~str, ~str)]>,\n+                    dir: Option<&Path>,\n+                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n \n     use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n     use libc::funcs::bsd44::getdtablesize;\n@@ -381,30 +649,28 @@ fn spawn_process_internal(prog: &str, args: &[~str],\n         if pid < 0 {\n             fail!(\"failure in fork: %s\", os::last_os_error());\n         } else if pid > 0 {\n-            return RunProgramResult {pid: pid, handle: ptr::null()};\n+            return SpawnProcessResult {pid: pid, handle: ptr::null()};\n         }\n \n         rustrt::rust_unset_sigprocmask();\n \n-        if in_fd > 0 && dup2(in_fd, 0) == -1 {\n+        if dup2(in_fd, 0) == -1 {\n             fail!(\"failure in dup2(in_fd, 0): %s\", os::last_os_error());\n         }\n-        if out_fd > 0 && dup2(out_fd, 1) == -1 {\n+        if dup2(out_fd, 1) == -1 {\n             fail!(\"failure in dup2(out_fd, 1): %s\", os::last_os_error());\n         }\n-        if err_fd > 0 && dup2(err_fd, 2) == -1 {\n+        if dup2(err_fd, 2) == -1 {\n             fail!(\"failure in dup3(err_fd, 2): %s\", os::last_os_error());\n         }\n         // close all other fds\n         for int::range_rev(getdtablesize() as int - 1, 2) |fd| {\n             close(fd as c_int);\n         }\n \n-        for dir.each |dir| {\n-            do str::as_c_str(*dir) |dirp| {\n-                if chdir(dirp) == -1 {\n-                    fail!(\"failure in chdir: %s\", os::last_os_error());\n-                }\n+        do with_dirp(dir) |dirp| {\n+            if !dirp.is_null() && chdir(dirp) == -1 {\n+                fail!(\"failure in chdir: %s\", os::last_os_error());\n             }\n         }\n \n@@ -424,33 +690,32 @@ fn spawn_process_internal(prog: &str, args: &[~str],\n #[cfg(unix)]\n fn with_argv<T>(prog: &str, args: &[~str],\n                 cb: &fn(**libc::c_char) -> T) -> T {\n-    let mut argptrs = str::as_c_str(prog, |b| ~[b]);\n+    let mut argptrs = ~[str::as_c_str(prog, |b| b)];\n     let mut tmps = ~[];\n     for args.each |arg| {\n         let t = @copy *arg;\n         tmps.push(t);\n-        argptrs.push_all(str::as_c_str(*t, |b| ~[b]));\n+        argptrs.push(str::as_c_str(*t, |b| b));\n     }\n     argptrs.push(ptr::null());\n     vec::as_imm_buf(argptrs, |buf, _len| cb(buf))\n }\n \n #[cfg(unix)]\n-fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n-                cb: &fn(*c_void) -> T) -> T {\n+fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n     // On posixy systems we can pass a char** for envp, which is\n     // a null-terminated array of \"k=v\\n\" strings.\n-    match *env {\n-      Some(ref es) if !vec::is_empty(*es) => {\n+    match env {\n+      Some(es) => {\n         let mut tmps = ~[];\n         let mut ptrs = ~[];\n \n-        for (*es).each |e| {\n-            let (k,v) = copy *e;\n-            let t = @(fmt!(\"%s=%s\", k, v));\n-            tmps.push(t);\n-            ptrs.push_all(str::as_c_str(*t, |b| ~[b]));\n+        for es.each |&(k, v)| {\n+            let kv = @fmt!(\"%s=%s\", k, v);\n+            tmps.push(kv);\n+            ptrs.push(str::as_c_str(*kv, |b| b));\n         }\n+\n         ptrs.push(ptr::null());\n         vec::as_imm_buf(ptrs, |p, _len|\n             unsafe { cb(::cast::transmute(p)) }\n@@ -461,47 +726,35 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n }\n \n #[cfg(windows)]\n-fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n-                cb: &fn(*mut c_void) -> T) -> T {\n+fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n     // On win32 we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n-    unsafe {\n-        match *env {\n-          Some(ref es) if !vec::is_empty(*es) => {\n-            let mut blk : ~[u8] = ~[];\n-            for (*es).each |e| {\n-                let (k,v) = copy *e;\n-                let t = fmt!(\"%s=%s\", k, v);\n-                let mut v : ~[u8] = ::cast::transmute(t);\n-                blk += v;\n-                ::cast::forget(v);\n-            }\n-            blk += ~[0_u8];\n-            vec::as_imm_buf(blk, |p, _len| cb(::cast::transmute(p)))\n-          }\n-          _ => cb(ptr::mut_null())\n+    match env {\n+      Some(es) => {\n+        let mut blk = ~[];\n+        for es.each |&(k, v)| {\n+            let kv = fmt!(\"%s=%s\", k, v);\n+            blk.push_all(str::as_bytes_slice(kv));\n+            blk.push(0);\n         }\n+        blk.push(0);\n+        vec::as_imm_buf(blk, |p, _len|\n+            unsafe { cb(::cast::transmute(p)) }\n+        )\n+      }\n+      _ => cb(ptr::mut_null())\n     }\n }\n \n-#[cfg(windows)]\n-fn with_dirp<T>(d: &Option<~str>,\n+fn with_dirp<T>(d: Option<&Path>,\n                 cb: &fn(*libc::c_char) -> T) -> T {\n-    match *d {\n-      Some(ref dir) => str::as_c_str(*dir, cb),\n+    match d {\n+      Some(dir) => str::as_c_str(dir.to_str(), cb),\n       None => cb(ptr::null())\n     }\n }\n \n-/// helper function that closes non-NULL files and then makes them NULL\n-priv unsafe fn fclose_and_null(f: &mut *libc::FILE) {\n-    if *f != 0 as *libc::FILE {\n-        libc::fclose(*f);\n-        *f = 0 as *libc::FILE;\n-    }\n-}\n-\n #[cfg(windows)]\n priv fn free_handle(handle: *()) {\n     unsafe {\n@@ -515,7 +768,8 @@ priv fn free_handle(_handle: *()) {\n }\n \n /**\n- * Spawns a process and waits for it to terminate\n+ * Spawns a process and waits for it to terminate. The process will\n+ * inherit the current stdin/stdout/stderr file descriptors.\n  *\n  * # Arguments\n  *\n@@ -526,71 +780,19 @@ priv fn free_handle(_handle: *()) {\n  *\n  * The process's exit code\n  */\n-pub fn run_program(prog: &str, args: &[~str]) -> int {\n-    let res = spawn_process_internal(prog, args, &None, &None,\n-                                     0i32, 0i32, 0i32);\n-    let code = waitpid(res.pid);\n-    free_handle(res.handle);\n-    return code;\n-}\n-\n-/**\n- * Spawns a process and returns a Program\n- *\n- * The returned value is a <Program> object that can be used for sending and\n- * receiving data over the standard file descriptors.  The class will ensure\n- * that file descriptors are closed properly.\n- *\n- * # Arguments\n- *\n- * * prog - The path to an executable\n- * * args - Vector of arguments to pass to the child process\n- *\n- * # Return value\n- *\n- * A <Program> object\n- */\n-pub fn start_program(prog: &str, args: &[~str]) -> Program {\n-    let pipe_input = os::pipe();\n-    let pipe_output = os::pipe();\n-    let pipe_err = os::pipe();\n-    let res =\n-        spawn_process_internal(prog, args, &None, &None,\n-                               pipe_input.in, pipe_output.out,\n-                               pipe_err.out);\n-\n-    unsafe {\n-        libc::close(pipe_input.in);\n-        libc::close(pipe_output.out);\n-        libc::close(pipe_err.out);\n-    }\n-\n-    Program {\n-        pid: res.pid,\n-        handle: res.handle,\n-        in_fd: pipe_input.out,\n-        out_file: os::fdopen(pipe_output.in),\n-        err_file: os::fdopen(pipe_err.in),\n-        finished: false,\n-    }\n-}\n-\n-fn read_all(rd: @io::Reader) -> ~str {\n-    let buf = io::with_bytes_writer(|wr| {\n-        let mut bytes = [0, ..4096];\n-        while !rd.eof() {\n-            let nread = rd.read(bytes, bytes.len());\n-            wr.write(bytes.slice(0, nread));\n-        }\n+pub fn process_status(prog: &str, args: &[~str]) -> int {\n+    let mut prog = Process::new(prog, args, ProcessOptions {\n+        env: None,\n+        dir: None,\n+        in_fd: Some(0),\n+        out_fd: Some(1),\n+        err_fd: Some(2)\n     });\n-    str::from_bytes(buf)\n+    prog.finish()\n }\n \n-pub struct ProgramOutput {status: int, out: ~str, err: ~str}\n-\n /**\n- * Spawns a process, waits for it to exit, and returns the exit code, and\n- * contents of stdout and stderr.\n+ * Spawns a process, records all its output, and waits for it to terminate.\n  *\n  * # Arguments\n  *\n@@ -599,94 +801,24 @@ pub struct ProgramOutput {status: int, out: ~str, err: ~str}\n  *\n  * # Return value\n  *\n- * A record, {status: int, out: str, err: str} containing the exit code,\n- * the contents of stdout and the contents of stderr.\n+ * The process's stdout/stderr output and exit code.\n  */\n-pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n-    let pipe_in = os::pipe();\n-    let pipe_out = os::pipe();\n-    let pipe_err = os::pipe();\n-    let res = spawn_process_internal(prog, args, &None, &None,\n-                                     pipe_in.in, pipe_out.out, pipe_err.out);\n-\n-    os::close(pipe_in.in);\n-    os::close(pipe_out.out);\n-    os::close(pipe_err.out);\n-    os::close(pipe_in.out);\n-\n-    // Spawn two entire schedulers to read both stdout and sterr\n-    // in parallel so we don't deadlock while blocking on one\n-    // or the other. FIXME (#2625): Surely there's a much more\n-    // clever way to do this.\n-    let (p, ch) = stream();\n-    let ch = SharedChan::new(ch);\n-    let ch_clone = ch.clone();\n-    do task::spawn_sched(task::SingleThreaded) {\n-        let errput = readclose(pipe_err.in);\n-        ch.send((2, errput));\n-    };\n-    do task::spawn_sched(task::SingleThreaded) {\n-        let output = readclose(pipe_out.in);\n-        ch_clone.send((1, output));\n-    };\n-\n-    let status = waitpid(res.pid);\n-    free_handle(res.handle);\n-\n-    let mut errs = ~\"\";\n-    let mut outs = ~\"\";\n-    let mut count = 2;\n-    while count > 0 {\n-        let stream = p.recv();\n-        match stream {\n-            (1, copy s) => {\n-                outs = s;\n-            }\n-            (2, copy s) => {\n-                errs = s;\n-            }\n-            (n, _) => {\n-                fail!(\"program_output received an unexpected file number: %u\", n);\n-            }\n-        };\n-        count -= 1;\n-    };\n-    return ProgramOutput {status: status,\n-                          out: outs,\n-                          err: errs};\n-}\n-\n-pub fn writeclose(fd: c_int, s: ~str) {\n-    use io::WriterUtil;\n-\n-    error!(\"writeclose %d, %s\", fd as int, s);\n-    let writer = io::fd_writer(fd, false);\n-    writer.write_str(s);\n-\n-    os::close(fd);\n-}\n-\n-pub fn readclose(fd: c_int) -> ~str {\n-    unsafe {\n-        let file = os::fdopen(fd);\n-        let reader = io::FILE_reader(file, false);\n-        let buf = io::with_bytes_writer(|writer| {\n-            let mut bytes = [0, ..4096];\n-            while !reader.eof() {\n-                let nread = reader.read(bytes, bytes.len());\n-                writer.write(bytes.slice(0, nread));\n-            }\n-        });\n-        os::fclose(file);\n-        str::from_bytes(buf)\n-    }\n+pub fn process_output(prog: &str, args: &[~str]) -> ProcessOutput {\n+    let mut prog = Process::new(prog, args, ProcessOptions::new());\n+    prog.finish_with_output()\n }\n \n /**\n  * Waits for a process to exit and returns the exit code, failing\n  * if there is no process with the specified id.\n+ *\n+ * Note that this is private to avoid race conditions on unix where if\n+ * a user calls waitpid(some_process.get_id()) then some_process.finish()\n+ * and some_process.destroy() and some_process.drop() will then either\n+ * operate on a none-existant process or, even worse, on a newer process\n+ * with the same id.\n  */\n-pub fn waitpid(pid: pid_t) -> int {\n+priv fn waitpid(pid: pid_t) -> int {\n     return waitpid_os(pid);\n \n     #[cfg(windows)]\n@@ -777,10 +909,13 @@ pub fn waitpid(pid: pid_t) -> int {\n \n #[cfg(test)]\n mod tests {\n-    use option::None;\n+    use io;\n+    use libc::{c_int};\n+    use option::{Option, None, Some};\n     use os;\n-    use run::{readclose, writeclose};\n+    use path::Path;\n     use run;\n+    use str;\n \n     #[test]\n     #[cfg(windows)]\n@@ -803,54 +938,222 @@ mod tests {\n         );\n     }\n \n-    // Regression test for memory leaks\n     #[test]\n-    fn test_leaks() {\n-        run::run_program(\"echo\", []);\n-        run::start_program(\"echo\", []);\n-        run::program_output(\"echo\", []);\n+    fn test_process_status() {\n+        assert_eq!(run::process_status(\"false\", []), 1);\n+        assert_eq!(run::process_status(\"true\", []), 0);\n+    }\n+\n+    #[test]\n+    fn test_process_output_output() {\n+\n+        let run::ProcessOutput {status, output, error}\n+             = run::process_output(\"echo\", [~\"hello\"]);\n+        let output_str = str::from_bytes(output);\n+\n+        assert_eq!(status, 0);\n+        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n+        assert_eq!(error, ~[]);\n+    }\n+\n+    #[test]\n+    fn test_process_output_error() {\n+\n+        let run::ProcessOutput {status, output, error}\n+             = run::process_output(\"mkdir\", [~\".\"]);\n+\n+        assert_eq!(status, 1);\n+        assert_eq!(output, ~[]);\n+        assert!(!error.is_empty());\n     }\n \n     #[test]\n-    #[allow(non_implicitly_copyable_typarams)]\n     fn test_pipes() {\n+\n         let pipe_in = os::pipe();\n         let pipe_out = os::pipe();\n         let pipe_err = os::pipe();\n \n-        let pid =\n-            run::spawn_process(\n-                \"cat\", [], &None, &None,\n-                pipe_in.in, pipe_out.out, pipe_err.out);\n+        let mut proc = run::Process::new(\"cat\", [], run::ProcessOptions {\n+            dir: None,\n+            env: None,\n+            in_fd: Some(pipe_in.in),\n+            out_fd: Some(pipe_out.out),\n+            err_fd: Some(pipe_err.out)\n+        });\n+\n+        assert!(proc.input_redirected());\n+        assert!(proc.output_redirected());\n+        assert!(proc.error_redirected());\n+\n         os::close(pipe_in.in);\n         os::close(pipe_out.out);\n         os::close(pipe_err.out);\n \n-        if pid == -1i32 { fail!(); }\n         let expected = ~\"test\";\n-        writeclose(pipe_in.out, copy expected);\n+        writeclose(pipe_in.out, expected);\n         let actual = readclose(pipe_out.in);\n         readclose(pipe_err.in);\n-        run::waitpid(pid);\n+        proc.finish();\n \n-        debug!(copy expected);\n-        debug!(copy actual);\n         assert_eq!(expected, actual);\n     }\n \n+    fn writeclose(fd: c_int, s: &str) {\n+        let writer = io::fd_writer(fd, false);\n+        writer.write_str(s);\n+        os::close(fd);\n+    }\n+\n+    fn readclose(fd: c_int) -> ~str {\n+        unsafe {\n+            let file = os::fdopen(fd);\n+            let reader = io::FILE_reader(file, false);\n+            let buf = reader.read_whole_stream();\n+            os::fclose(file);\n+            str::from_bytes(buf)\n+        }\n+    }\n+\n     #[test]\n-    fn waitpid() {\n-        let pid = run::spawn_process(\"false\", [],\n-                                     &None, &None,\n-                                     0i32, 0i32, 0i32);\n-        let status = run::waitpid(pid);\n-        assert_eq!(status, 1);\n+    fn test_finish_once() {\n+        let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new());\n+        assert_eq!(prog.finish(), 1);\n+    }\n+\n+    #[test]\n+    fn test_finish_twice() {\n+        let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new());\n+        assert_eq!(prog.finish(), 1);\n+        assert_eq!(prog.finish(), 1);\n+    }\n+\n+    #[test]\n+    fn test_finish_with_output_once() {\n+\n+        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new());\n+        let run::ProcessOutput {status, output, error}\n+            = prog.finish_with_output();\n+        let output_str = str::from_bytes(output);\n+\n+        assert_eq!(status, 0);\n+        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n+        assert_eq!(error, ~[]);\n+    }\n+\n+    #[test]\n+    fn test_finish_with_output_twice() {\n+\n+        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new());\n+        let run::ProcessOutput {status, output, error}\n+            = prog.finish_with_output();\n+\n+        let output_str = str::from_bytes(output);\n+\n+        assert_eq!(status, 0);\n+        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n+        assert_eq!(error, ~[]);\n+\n+        let run::ProcessOutput {status, output, error}\n+            = prog.finish_with_output();\n+\n+        assert_eq!(status, 0);\n+        assert_eq!(output, ~[]);\n+        assert_eq!(error, ~[]);\n     }\n \n     #[test]\n     #[should_fail]\n-    #[ignore(cfg(windows))]\n-    fn waitpid_non_existant_pid() {\n-        run::waitpid(123456789); // assume that this pid doesn't exist\n+    #[cfg(not(windows))]\n+    fn test_finish_with_output_redirected() {\n+        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions {\n+            env: None,\n+            dir: None,\n+            in_fd: Some(0),\n+            out_fd: Some(1),\n+            err_fd: Some(2)\n+        });\n+        // this should fail because it is not valid to read the output when it was redirected\n+        prog.finish_with_output();\n+    }\n+\n+    #[cfg(unix)]\n+    fn run_pwd(dir: Option<&Path>) -> run::Process {\n+        run::Process::new(\"pwd\", [], run::ProcessOptions {\n+            dir: dir,\n+            .. run::ProcessOptions::new()\n+        })\n+    }\n+\n+    #[cfg(windows)]\n+    fn run_pwd(dir: Option<&Path>) -> run::Process {\n+        run::Process::new(\"cmd\", [~\"/c\", ~\"cd\"], run::ProcessOptions {\n+            dir: dir,\n+            .. run::ProcessOptions::new()\n+        })\n+    }\n+\n+    #[test]\n+    fn test_keep_current_working_dir() {\n+\n+        let mut prog = run_pwd(None);\n+\n+        let output = str::from_bytes(prog.finish_with_output().output);\n+        let parent_dir = os::getcwd().normalize();\n+        let child_dir = Path(output.trim()).normalize();\n+\n+        assert_eq!(child_dir.to_str(), parent_dir.to_str());\n+    }\n+\n+    #[test]\n+    fn test_change_working_directory() {\n+\n+        let tmp_path = os::tmpdir().normalize();\n+        let mut prog = run_pwd(Some(&tmp_path));\n+\n+        let output = str::from_bytes(prog.finish_with_output().output);\n+        let child_dir = Path(output.trim()).normalize();\n+\n+        assert_eq!(child_dir.to_str(), tmp_path.to_str());\n+    }\n+\n+    #[cfg(unix)]\n+    fn run_env(env: Option<&[(~str, ~str)]>) -> run::Process {\n+        run::Process::new(\"env\", [], run::ProcessOptions {\n+            env: env,\n+            .. run::ProcessOptions::new()\n+        })\n+    }\n+\n+    #[cfg(windows)]\n+    fn run_env(env: Option<&[(~str, ~str)]>) -> run::Process {\n+        run::Process::new(\"cmd\", [~\"/c\", ~\"set\"], run::ProcessOptions {\n+            env: env,\n+            .. run::ProcessOptions::new()\n+        })\n+    }\n+\n+    #[test]\n+    fn test_inherit_env() {\n+\n+        let mut prog = run_env(None);\n+        let output = str::from_bytes(prog.finish_with_output().output);\n+\n+        for os::env().each |&(k, v)| {\n+            // don't check windows magical empty-named variables\n+            assert!(k.is_empty() || output.contains(fmt!(\"%s=%s\", k, v)));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_add_to_env() {\n+\n+        let mut new_env = os::env();\n+        new_env.push((~\"RUN_TEST_NEW_ENV\", ~\"123\"));\n+\n+        let mut prog = run_env(Some(new_env.slice(0, new_env.len())));\n+        let output = str::from_bytes(prog.finish_with_output().output);\n+\n+        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"));\n     }\n }"}, {"sha": "a80d9661aa20e01159acfb2c37a8ff0dd3e28403", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c31217bee0f80b096b33d8a1b499f491d92c9f/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=76c31217bee0f80b096b33d8a1b499f491d92c9f", "patch": "@@ -20,13 +20,13 @@ use std::run::*;\n \n #[test]\n fn test_destroy_once() {\n-    let mut p = run::start_program(\"echo\", []);\n+    let mut p = run::Process::new(\"echo\", [], run::ProcessOptions::new());\n     p.destroy(); // this shouldn't crash (and nor should the destructor)\n }\n \n #[test]\n fn test_destroy_twice() {\n-    let mut p = run::start_program(\"echo\", []);\n+    let mut p = run::Process::new(\"echo\", [], run::ProcessOptions::new());\n     p.destroy(); // this shouldnt crash...\n     p.destroy(); // ...and nor should this (and nor should the destructor)\n }\n@@ -41,7 +41,8 @@ fn test_destroy_actually_kills(force: bool) {\n \n     #[cfg(unix)]\n     fn process_exists(pid: libc::pid_t) -> bool {\n-        run::program_output(\"ps\", [~\"-p\", pid.to_str()]).out.contains(pid.to_str())\n+        let run::ProcessOutput {output, _} = run::process_output(\"ps\", [~\"-p\", pid.to_str()]);\n+        str::from_bytes(output).contains(pid.to_str())\n     }\n \n     #[cfg(windows)]\n@@ -64,8 +65,8 @@ fn test_destroy_actually_kills(force: bool) {\n         }\n     }\n \n-    // this program will stay alive indefinitely trying to read from stdin\n-    let mut p = run::start_program(BLOCK_COMMAND, []);\n+    // this process will stay alive indefinitely trying to read from stdin\n+    let mut p = run::Process::new(BLOCK_COMMAND, [], run::ProcessOptions::new());\n \n     assert!(process_exists(p.get_id()));\n "}]}