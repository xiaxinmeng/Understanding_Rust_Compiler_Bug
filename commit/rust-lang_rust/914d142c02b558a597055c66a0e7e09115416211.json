{"sha": "914d142c02b558a597055c66a0e7e09115416211", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNGQxNDJjMDJiNTU4YTU5NzA1NWM2NmEwZTdlMDkxMTU0MTYyMTE=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-01-21T23:35:31Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-01-21T23:35:31Z"}, "message": "Extend trailing `>` detection for paths.\n\nThis commit extends the trailing `>` detection to also work for paths\nsuch as `Foo::<Bar>>:Baz`.\n\nThis involves making the existing check take the token that is expected\nto follow the path being checked as a parameter.\n\nCare is taken to ensure that this only happens on the construction of a\nwhole path segment and not a partial path segment (during recursion).\n\nThrough this enhancement, it was also observed that the ordering of\nright shift token and greater than tokens was overfitted to the examples\nbeing tested.\n\nIn practice, given a sequence of `>` characters: `>>>>>>>>>`\n..then they will be split into `>>` eagerly: `>> >> >> >> >`.\n..but when a `<` is prepended, then the first `>>` is split:\n`<T> > >> >> >> >`\n..and then when another `<` is prepended, a right shift is first again:\n`Vec<<T>> >> >> >> >`\n\nIn the previous commits, a example that had two `<<` characters was\nalways used and therefore it was incorrectly assumed that `>>` would\nalways be first - but when there is a single `<`, this is not the case.", "tree": {"sha": "3c63c4c6a3106f6dd4e0a86ced5e8e2b46127290", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c63c4c6a3106f6dd4e0a86ced5e8e2b46127290"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/914d142c02b558a597055c66a0e7e09115416211", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlxGWOkACgkQAXYLT59T\n8VRaNxAAuoxtSwcwz/bL5T2n24Box75/U8UZc1oXfxGC/dS8fii07DotNqVBrq3E\nAYzJgjCSgchMMVjzf6k8ZlAaF8ko48whCayA334ifXkebVl8sGc5vZZY9d5fzPkR\nIn5ySv0TIcTsMsd+d3RRMcOoHknvKOlhrWBXTVk3gzPWVHMDOXl9/kJj9B0tlWd+\nDw9s9ysqxv7T33K4KzsjZJL0nVGahlUkbQrM4aRyS6AKbw7JnW4+IdFEX/NI6S9F\nGdy0K0nB6j5l56Ay3rVaLB9eb5cOC6cEgYbD7MpcZ5ZS/yBNa6Xhh8q8abZhEwZo\n8w5u6rvCVcP7u/gSAiHLV31CPfsNP315cGzvCzSbukEF2ncnxI7ixzRTo5RtVhsR\nrcobyDZvQwWKVlTU0VS1JXmf7H8Y6WTqL06M8PnIJ8uE5tC9YoW1YAGO6hGxleRf\n0ed4MC47eCoG9xR1HKa+i7UYINgqNMnxXdumcutwiLTSOUHPp2fHI+MpLPFwO/H+\n00dqARHo2y31HyjZNOcV/uo3KeknG5qBamGwhHBh8lonIsnp7yfn8EX67WuY/SIN\n55xSL0c/yt4zhNKw4y0KxhLeU/9A1uuF48yP9lDUJ4JUGImPrcqISgD3+fEu+QVF\nb2upyTEHPNPHdMw8WsDyLPlUp7CTStPPV3Psfa+X6mFfNbduTxk=\n=Fab2\n-----END PGP SIGNATURE-----", "payload": "tree 3c63c4c6a3106f6dd4e0a86ced5e8e2b46127290\nparent 3f0fc9b03569e03dbdf5fdc3a67f246aad3b40b8\nauthor David Wood <david@davidtw.co> 1548113731 +0100\ncommitter David Wood <david@davidtw.co> 1548113731 +0100\n\nExtend trailing `>` detection for paths.\n\nThis commit extends the trailing `>` detection to also work for paths\nsuch as `Foo::<Bar>>:Baz`.\n\nThis involves making the existing check take the token that is expected\nto follow the path being checked as a parameter.\n\nCare is taken to ensure that this only happens on the construction of a\nwhole path segment and not a partial path segment (during recursion).\n\nThrough this enhancement, it was also observed that the ordering of\nright shift token and greater than tokens was overfitted to the examples\nbeing tested.\n\nIn practice, given a sequence of `>` characters: `>>>>>>>>>`\n..then they will be split into `>>` eagerly: `>> >> >> >> >`.\n..but when a `<` is prepended, then the first `>>` is split:\n`<T> > >> >> >> >`\n..and then when another `<` is prepended, a right shift is first again:\n`Vec<<T>> >> >> >> >`\n\nIn the previous commits, a example that had two `<<` characters was\nalways used and therefore it was incorrectly assumed that `>>` would\nalways be first - but when there is a single `<`, this is not the case.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/914d142c02b558a597055c66a0e7e09115416211", "html_url": "https://github.com/rust-lang/rust/commit/914d142c02b558a597055c66a0e7e09115416211", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/914d142c02b558a597055c66a0e7e09115416211/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f0fc9b03569e03dbdf5fdc3a67f246aad3b40b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f0fc9b03569e03dbdf5fdc3a67f246aad3b40b8", "html_url": "https://github.com/rust-lang/rust/commit/3f0fc9b03569e03dbdf5fdc3a67f246aad3b40b8"}], "stats": {"total": 164, "additions": 131, "deletions": 33}, "files": [{"sha": "d380948b8913d972a6356ff9c58ed107e457f211", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 61, "deletions": 33, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/914d142c02b558a597055c66a0e7e09115416211/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914d142c02b558a597055c66a0e7e09115416211/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=914d142c02b558a597055c66a0e7e09115416211", "patch": "@@ -2149,7 +2149,27 @@ impl<'a> Parser<'a> {\n                            enable_warning: bool)\n                            -> PResult<'a, ()> {\n         loop {\n-            segments.push(self.parse_path_segment(style, enable_warning)?);\n+            let segment = self.parse_path_segment(style, enable_warning)?;\n+            if style == PathStyle::Expr {\n+                // In order to check for trailing angle brackets, we must have finished\n+                // recursing (`parse_path_segment` can indirectly call this function),\n+                // that is, the next token must be the highlighted part of the below example:\n+                //\n+                // `Foo::<Bar as Baz<T>>::Qux`\n+                //                      ^ here\n+                //\n+                // As opposed to the below highlight (if we had only finished the first\n+                // recursion):\n+                //\n+                // `Foo::<Bar as Baz<T>>::Qux`\n+                //                     ^ here\n+                //\n+                // `PathStyle::Expr` is only provided at the root invocation and never in\n+                // `parse_path_segment` to recurse and therefore can be checked to maintain\n+                // this invariant.\n+                self.check_trailing_angle_brackets(&segment, token::ModSep);\n+            }\n+            segments.push(segment);\n \n             if self.is_import_coupler() || !self.eat(&token::ModSep) {\n                 return Ok(());\n@@ -2757,7 +2777,7 @@ impl<'a> Parser<'a> {\n     // Assuming we have just parsed `.`, continue parsing into an expression.\n     fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n         let segment = self.parse_path_segment(PathStyle::Expr, true)?;\n-        self.check_trailing_angle_brackets(&segment);\n+        self.check_trailing_angle_brackets(&segment, token::OpenDelim(token::Paren));\n \n         Ok(match self.token {\n             token::OpenDelim(token::Paren) => {\n@@ -2793,15 +2813,19 @@ impl<'a> Parser<'a> {\n     /// let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>();\n     ///                                                        ^^ help: remove extra angle brackets\n     /// ```\n-    fn check_trailing_angle_brackets(&mut self, segment: &PathSegment) {\n-        // This function is intended to be invoked from `parse_dot_suffix` where there are two\n+    fn check_trailing_angle_brackets(&mut self, segment: &PathSegment, end: token::Token) {\n+        // This function is intended to be invoked after parsing a path segment where there are two\n         // cases:\n         //\n-        // - A field access (eg. `x.foo`)\n-        // - A method call (eg. `x.foo()`)\n+        // 1. A specific token is expected after the path segment.\n+        //    eg. `x.foo(`, `x.foo::<u32>(` (parenthesis - method call),\n+        //        `Foo::`, or `Foo::<Bar>::` (mod sep - continued path).\n+        // 2. No specific token is expected after the path segment.\n+        //    eg. `x.foo` (field access)\n         //\n-        // This function is called after parsing `.foo` and before parsing any parenthesis (if\n-        // present). This includes any angle bracket arguments, such as `.foo::<u32>`.\n+        // This function is called after parsing `.foo` and before parsing the token `end` (if\n+        // present). This includes any angle bracket arguments, such as `.foo::<u32>` or\n+        // `Foo::<Bar>`.\n \n         // We only care about trailing angle brackets if we previously parsed angle bracket\n         // arguments. This helps stop us incorrectly suggesting that extra angle brackets be\n@@ -2836,43 +2860,47 @@ impl<'a> Parser<'a> {\n         // actual operators and not trailing characters - ie `x.foo >> 3`).\n         let mut position = 0;\n \n-        // The first tokens we will encounter are shift right tokens (`>>`) since pairs of `>`\n-        // characters will have been grouped together by the tokenizer.\n+        // We can encounter `>` or `>>` tokens in any order, so we need to keep track of how\n+        // many of each (so we can correctly pluralize our error messages) and continue to\n+        // advance.\n         let mut number_of_shr = 0;\n-        while self.look_ahead(position, |t| *t == token::BinOp(token::BinOpToken::Shr)) {\n-            number_of_shr += 1;\n-            position += 1;\n-        }\n-\n-        // Afterwards, there will be at most one `>` character remaining (more than one and it'd\n-        // have shown up as a `>>`).\n-        let encountered_gt = self.look_ahead(position, |t| *t == token::Gt);\n-        if encountered_gt {\n+        let mut number_of_gt = 0;\n+        while self.look_ahead(position, |t| {\n+            trace!(\"check_trailing_angle_brackets: t={:?}\", t);\n+            if *t == token::BinOp(token::BinOpToken::Shr) {\n+                number_of_shr += 1;\n+                true\n+            } else if *t == token::Gt {\n+                number_of_gt += 1;\n+                true\n+            } else {\n+                false\n+            }\n+        }) {\n             position += 1;\n         }\n \n-        // If we didn't find any trailing `>>` characters or a trailing `>`, then we have\n-        // nothing to error about.\n+        // If we didn't find any trailing `>` characters, then we have nothing to error about.\n         debug!(\n-            \"check_trailing_angle_brackets: encountered_gt={:?} number_of_shr={:?}\",\n-            encountered_gt, number_of_shr,\n+            \"check_trailing_angle_brackets: number_of_gt={:?} number_of_shr={:?}\",\n+            number_of_gt, number_of_shr,\n         );\n-        if !encountered_gt && number_of_shr < 1 {\n+        if number_of_gt < 1 && number_of_shr < 1 {\n             return;\n         }\n \n-        // Finally, double check that we have a left parenthesis next as otherwise this is the\n-        // field case.\n-        if self.look_ahead(position, |t| *t == token::OpenDelim(token::Paren)) {\n-            // Eat from where we started until the left parenthesis so that parsing can continue\n+        // Finally, double check that we have our end token as otherwise this is the\n+        // second case.\n+        if self.look_ahead(position, |t| {\n+            trace!(\"check_trailing_angle_brackets: t={:?}\", t);\n+            *t == end\n+        }) {\n+            // Eat from where we started until the end token so that parsing can continue\n             // as if we didn't have those extra angle brackets.\n-            self.eat_to_tokens(&[&token::OpenDelim(token::Paren)]);\n+            self.eat_to_tokens(&[&end]);\n             let span = lo.until(self.span);\n \n-            // We needn't check `encountered_gt` to determine if we should pluralize \"bracket\".\n-            // `encountered_gt` can only represent a single `>` character, if `number_of_shr >= 1`\n-            // then there is either `>>` or `>>>` - in either case a plural is warranted.\n-            let plural = number_of_shr >= 1;\n+            let plural = number_of_gt > 1 || number_of_shr >= 1;\n             self.diagnostic()\n                 .struct_span_err(\n                     span,"}, {"sha": "a91c4fe43ea46e066bb67e386fd58c3e5d451505", "filename": "src/test/ui/issues/issue-54521-2.fixed", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/914d142c02b558a597055c66a0e7e09115416211/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/914d142c02b558a597055c66a0e7e09115416211/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.fixed?ref=914d142c02b558a597055c66a0e7e09115416211", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+\n+// This test checks that the following error is emitted and the suggestion works:\n+//\n+// ```\n+// let _ = Vec::<usize>>>::new();\n+//                     ^^ help: remove extra angle brackets\n+// ```\n+\n+fn main() {\n+    let _ = Vec::<usize>::new();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = Vec::<usize>::new();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = Vec::<usize>::new();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = Vec::<usize>::new();\n+    //~^ ERROR unmatched angle bracket\n+}"}, {"sha": "3639aac87ee7fdae4b695fc02f47c1e378f51bc3", "filename": "src/test/ui/issues/issue-54521-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/914d142c02b558a597055c66a0e7e09115416211/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/914d142c02b558a597055c66a0e7e09115416211/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.rs?ref=914d142c02b558a597055c66a0e7e09115416211", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+\n+// This test checks that the following error is emitted and the suggestion works:\n+//\n+// ```\n+// let _ = Vec::<usize>>>::new();\n+//                     ^^ help: remove extra angle brackets\n+// ```\n+\n+fn main() {\n+    let _ = Vec::<usize>>>>>::new();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = Vec::<usize>>>>::new();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = Vec::<usize>>>::new();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = Vec::<usize>>::new();\n+    //~^ ERROR unmatched angle bracket\n+}"}, {"sha": "9556b83b730a4ecbda08ab50a9daad9e3ebf2a75", "filename": "src/test/ui/issues/issue-54521-2.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/914d142c02b558a597055c66a0e7e09115416211/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/914d142c02b558a597055c66a0e7e09115416211/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.stderr?ref=914d142c02b558a597055c66a0e7e09115416211", "patch": "@@ -0,0 +1,26 @@\n+error: unmatched angle brackets\n+  --> $DIR/issue-54521-2.rs:11:25\n+   |\n+LL |     let _ = Vec::<usize>>>>>::new();\n+   |                         ^^^^ help: remove extra angle brackets\n+\n+error: unmatched angle brackets\n+  --> $DIR/issue-54521-2.rs:14:25\n+   |\n+LL |     let _ = Vec::<usize>>>>::new();\n+   |                         ^^^ help: remove extra angle brackets\n+\n+error: unmatched angle brackets\n+  --> $DIR/issue-54521-2.rs:17:25\n+   |\n+LL |     let _ = Vec::<usize>>>::new();\n+   |                         ^^ help: remove extra angle brackets\n+\n+error: unmatched angle bracket\n+  --> $DIR/issue-54521-2.rs:20:25\n+   |\n+LL |     let _ = Vec::<usize>>::new();\n+   |                         ^ help: remove extra angle bracket\n+\n+error: aborting due to 4 previous errors\n+"}]}