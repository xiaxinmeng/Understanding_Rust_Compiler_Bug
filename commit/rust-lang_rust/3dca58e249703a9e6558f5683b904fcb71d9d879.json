{"sha": "3dca58e249703a9e6558f5683b904fcb71d9d879", "node_id": "C_kwDOAAsO6NoAKDNkY2E1OGUyNDk3MDNhOWU2NTU4ZjU2ODNiOTA0ZmNiNzFkOWQ4Nzk", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-12-23T15:15:21Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-17T07:48:19Z"}, "message": "`rustc_const_eval`: remove `ref` patterns (+some pattern matching imps)", "tree": {"sha": "690d6b49d443c009033ecae56cd549c56cc0720d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/690d6b49d443c009033ecae56cd549c56cc0720d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dca58e249703a9e6558f5683b904fcb71d9d879", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dca58e249703a9e6558f5683b904fcb71d9d879", "html_url": "https://github.com/rust-lang/rust/commit/3dca58e249703a9e6558f5683b904fcb71d9d879", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dca58e249703a9e6558f5683b904fcb71d9d879/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85357e3e2ed5f4ae4760d4418bbeab9985a784aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/85357e3e2ed5f4ae4760d4418bbeab9985a784aa", "html_url": "https://github.com/rust-lang/rust/commit/85357e3e2ed5f4ae4760d4418bbeab9985a784aa"}], "stats": {"total": 274, "additions": 130, "deletions": 144}, "files": [{"sha": "0579f7815352772807a19789d6928440256383b2", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=3dca58e249703a9e6558f5683b904fcb71d9d879", "patch": "@@ -36,16 +36,16 @@ impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalErrKind {\n impl fmt::Display for ConstEvalErrKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use self::ConstEvalErrKind::*;\n-        match *self {\n+        match self {\n             ConstAccessesStatic => write!(f, \"constant accesses static\"),\n             ModifiedGlobal => {\n                 write!(f, \"modifying a static's initial value from another static's initializer\")\n             }\n-            AssertFailure(ref msg) => write!(f, \"{:?}\", msg),\n+            AssertFailure(msg) => write!(f, \"{:?}\", msg),\n             Panic { msg, line, col, file } => {\n                 write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col)\n             }\n-            Abort(ref msg) => write!(f, \"{}\", msg),\n+            Abort(msg) => write!(f, \"{}\", msg),\n         }\n     }\n }"}, {"sha": "70487f89c252a96c283c4ee7577de12ec7e50579", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=3dca58e249703a9e6558f5683b904fcb71d9d879", "patch": "@@ -167,7 +167,7 @@ pub(super) fn op_to_const<'tcx>(\n         }\n     };\n     match immediate {\n-        Left(ref mplace) => to_const_value(mplace),\n+        Left(mplace) => to_const_value(&mplace),\n         // see comment on `let try_as_immediate` above\n         Right(imm) => match *imm {\n             _ if imm.layout.is_zst() => ConstValue::ZeroSized,"}, {"sha": "d869ca2c3b8d27e4c436a997d8adc6443fb71d53", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=3dca58e249703a9e6558f5683b904fcb71d9d879", "patch": "@@ -533,7 +533,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         let eval_to_int =\n             |op| ecx.read_immediate(&ecx.eval_operand(op, None)?).map(|x| x.to_const_int());\n         let err = match msg {\n-            BoundsCheck { ref len, ref index } => {\n+            BoundsCheck { len, index } => {\n                 let len = eval_to_int(len)?;\n                 let index = eval_to_int(index)?;\n                 BoundsCheck { len, index }"}, {"sha": "b2c847d3fd8dd6fca2403ecd5d9216ae4c5e63f4", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=3dca58e249703a9e6558f5683b904fcb71d9d879", "patch": "@@ -347,7 +347,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let new_vptr = self.get_vtable_ptr(ty, data_b.principal())?;\n                 self.write_immediate(Immediate::new_dyn_trait(old_data, new_vptr, self), dest)\n             }\n-            (_, &ty::Dynamic(ref data, _, ty::Dyn)) => {\n+            (_, &ty::Dynamic(data, _, ty::Dyn)) => {\n                 // Initial cast from sized to dyn trait\n                 let vtable = self.get_vtable_ptr(src_pointee_ty, data.principal())?;\n                 let ptr = self.read_scalar(src)?;"}, {"sha": "cc7b6c91b607426e57cd6ff9b65b597eb8b4d54e", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=3dca58e249703a9e6558f5683b904fcb71d9d879", "patch": "@@ -79,9 +79,7 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n         }\n         sym::variant_count => match tp_ty.kind() {\n             // Correctly handles non-monomorphic calls, so there is no need for ensure_monomorphic_enough.\n-            ty::Adt(ref adt, _) => {\n-                ConstValue::from_machine_usize(adt.variants().len() as u64, &tcx)\n-            }\n+            ty::Adt(adt, _) => ConstValue::from_machine_usize(adt.variants().len() as u64, &tcx),\n             ty::Alias(..) | ty::Param(_) | ty::Placeholder(_) | ty::Infer(_) => {\n                 throw_inval!(TooGeneric)\n             }"}, {"sha": "f47f99a166f53d63f6f2f4529375a7f2132b7745", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=3dca58e249703a9e6558f5683b904fcb71d9d879", "patch": "@@ -863,7 +863,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n \n             write!(fmt, \"{id:?}\")?;\n             match self.ecx.memory.alloc_map.get(id) {\n-                Some(&(kind, ref alloc)) => {\n+                Some((kind, alloc)) => {\n                     // normal alloc\n                     write!(fmt, \" ({}, \", kind)?;\n                     write_allocation_track_relocs("}, {"sha": "2013de0d3a33dd04e1bac0ebece4c6fcbb01b057", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=3dca58e249703a9e6558f5683b904fcb71d9d879", "patch": "@@ -363,11 +363,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         src: &OpTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, Either<MPlaceTy<'tcx, M::Provenance>, ImmTy<'tcx, M::Provenance>>> {\n         Ok(match src.as_mplace_or_imm() {\n-            Left(ref mplace) => {\n-                if let Some(val) = self.read_immediate_from_mplace_raw(mplace)? {\n+            Left(mplace) => {\n+                if let Some(val) = self.read_immediate_from_mplace_raw(&mplace)? {\n                     Right(val)\n                 } else {\n-                    Left(*mplace)\n+                    Left(mplace)\n                 }\n             }\n             Right(val) => Right(val),\n@@ -533,11 +533,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         use rustc_middle::mir::Operand::*;\n-        let op = match *mir_op {\n+        let op = match mir_op {\n             // FIXME: do some more logic on `move` to invalidate the old location\n-            Copy(place) | Move(place) => self.eval_place_to_op(place, layout)?,\n+            &(Copy(place) | Move(place)) => self.eval_place_to_op(place, layout)?,\n \n-            Constant(ref constant) => {\n+            Constant(constant) => {\n                 let c =\n                     self.subst_from_current_frame_and_normalize_erasing_regions(constant.literal)?;\n "}, {"sha": "2a493b20e5dcabc467988321a32f13c216344192", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=3dca58e249703a9e6558f5683b904fcb71d9d879", "patch": "@@ -87,9 +87,9 @@ where\n         field: usize,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         let base = match base.as_mplace_or_imm() {\n-            Left(ref mplace) => {\n+            Left(mplace) => {\n                 // We can reuse the mplace field computation logic for indirect operands.\n-                let field = self.mplace_field(mplace, field)?;\n+                let field = self.mplace_field(&mplace, field)?;\n                 return Ok(field.into());\n             }\n             Right(value) => value,"}, {"sha": "4bb3100757856bd42a43daf4c6a9a0b772487ec0", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=3dca58e249703a9e6558f5683b904fcb71d9d879", "patch": "@@ -111,7 +111,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 M::retag_place_contents(self, *kind, &dest)?;\n             }\n \n-            Intrinsic(box ref intrinsic) => self.emulate_nondiverging_intrinsic(intrinsic)?,\n+            Intrinsic(box intrinsic) => self.emulate_nondiverging_intrinsic(intrinsic)?,\n \n             // Statements we do not track.\n             AscribeUserType(..) => {}\n@@ -151,50 +151,50 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Also see https://github.com/rust-lang/rust/issues/68364.\n \n         use rustc_middle::mir::Rvalue::*;\n-        match *rvalue {\n+        match rvalue {\n             ThreadLocalRef(did) => {\n-                let ptr = M::thread_local_static_base_pointer(self, did)?;\n+                let ptr = M::thread_local_static_base_pointer(self, *did)?;\n                 self.write_pointer(ptr, &dest)?;\n             }\n \n-            Use(ref operand) => {\n+            Use(operand) => {\n                 // Avoid recomputing the layout\n                 let op = self.eval_operand(operand, Some(dest.layout))?;\n                 self.copy_op(&op, &dest, /*allow_transmute*/ false)?;\n             }\n \n-            CopyForDeref(ref place) => {\n+            CopyForDeref(place) => {\n                 let op = self.eval_place_to_op(*place, Some(dest.layout))?;\n                 self.copy_op(&op, &dest, /* allow_transmute*/ false)?;\n             }\n \n-            BinaryOp(bin_op, box (ref left, ref right)) => {\n-                let layout = binop_left_homogeneous(bin_op).then_some(dest.layout);\n+            BinaryOp(bin_op, box (left, right)) => {\n+                let layout = binop_left_homogeneous(*bin_op).then_some(dest.layout);\n                 let left = self.read_immediate(&self.eval_operand(left, layout)?)?;\n-                let layout = binop_right_homogeneous(bin_op).then_some(left.layout);\n+                let layout = binop_right_homogeneous(*bin_op).then_some(left.layout);\n                 let right = self.read_immediate(&self.eval_operand(right, layout)?)?;\n-                self.binop_ignore_overflow(bin_op, &left, &right, &dest)?;\n+                self.binop_ignore_overflow(*bin_op, &left, &right, &dest)?;\n             }\n \n-            CheckedBinaryOp(bin_op, box (ref left, ref right)) => {\n+            CheckedBinaryOp(bin_op, box (left, right)) => {\n                 // Due to the extra boolean in the result, we can never reuse the `dest.layout`.\n                 let left = self.read_immediate(&self.eval_operand(left, None)?)?;\n-                let layout = binop_right_homogeneous(bin_op).then_some(left.layout);\n+                let layout = binop_right_homogeneous(*bin_op).then_some(left.layout);\n                 let right = self.read_immediate(&self.eval_operand(right, layout)?)?;\n                 self.binop_with_overflow(\n-                    bin_op, /*force_overflow_checks*/ false, &left, &right, &dest,\n+                    *bin_op, /*force_overflow_checks*/ false, &left, &right, &dest,\n                 )?;\n             }\n \n-            UnaryOp(un_op, ref operand) => {\n+            UnaryOp(un_op, operand) => {\n                 // The operand always has the same type as the result.\n                 let val = self.read_immediate(&self.eval_operand(operand, Some(dest.layout))?)?;\n-                let val = self.unary_op(un_op, &val)?;\n+                let val = self.unary_op(*un_op, &val)?;\n                 assert_eq!(val.layout, dest.layout, \"layout mismatch for result of {:?}\", un_op);\n                 self.write_immediate(*val, &dest)?;\n             }\n \n-            Aggregate(box ref kind, ref operands) => {\n+            Aggregate(box kind, operands) => {\n                 assert!(matches!(kind, mir::AggregateKind::Array(..)));\n \n                 for (field_index, operand) in operands.iter().enumerate() {\n@@ -204,7 +204,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n \n-            Repeat(ref operand, _) => {\n+            Repeat(operand, _) => {\n                 let src = self.eval_operand(operand, None)?;\n                 assert!(src.layout.is_sized());\n                 let dest = self.force_allocation(&dest)?;\n@@ -241,14 +241,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Len(place) => {\n-                let src = self.eval_place(place)?;\n+                let src = self.eval_place(*place)?;\n                 let op = self.place_to_op(&src)?;\n                 let len = op.len(self)?;\n                 self.write_scalar(Scalar::from_machine_usize(len, self), &dest)?;\n             }\n \n             Ref(_, borrow_kind, place) => {\n-                let src = self.eval_place(place)?;\n+                let src = self.eval_place(*place)?;\n                 let place = self.force_allocation(&src)?;\n                 let val = ImmTy::from_immediate(place.to_ref(self), dest.layout);\n                 // A fresh reference was created, make sure it gets retagged.\n@@ -274,7 +274,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     false\n                 };\n \n-                let src = self.eval_place(place)?;\n+                let src = self.eval_place(*place)?;\n                 let place = self.force_allocation(&src)?;\n                 let mut val = ImmTy::from_immediate(place.to_ref(self), dest.layout);\n                 if !place_base_raw {\n@@ -285,7 +285,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             NullaryOp(null_op, ty) => {\n-                let ty = self.subst_from_current_frame_and_normalize_erasing_regions(ty)?;\n+                let ty = self.subst_from_current_frame_and_normalize_erasing_regions(*ty)?;\n                 let layout = self.layout_of(ty)?;\n                 if layout.is_unsized() {\n                     // FIXME: This should be a span_bug (#80742)\n@@ -302,21 +302,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(Scalar::from_machine_usize(val, self), &dest)?;\n             }\n \n-            ShallowInitBox(ref operand, _) => {\n+            ShallowInitBox(operand, _) => {\n                 let src = self.eval_operand(operand, None)?;\n                 let v = self.read_immediate(&src)?;\n                 self.write_immediate(*v, &dest)?;\n             }\n \n-            Cast(cast_kind, ref operand, cast_ty) => {\n+            Cast(cast_kind, operand, cast_ty) => {\n                 let src = self.eval_operand(operand, None)?;\n                 let cast_ty =\n-                    self.subst_from_current_frame_and_normalize_erasing_regions(cast_ty)?;\n-                self.cast(&src, cast_kind, cast_ty, &dest)?;\n+                    self.subst_from_current_frame_and_normalize_erasing_regions(*cast_ty)?;\n+                self.cast(&src, *cast_kind, cast_ty, &dest)?;\n             }\n \n             Discriminant(place) => {\n-                let op = self.eval_place_to_op(place, None)?;\n+                let op = self.eval_place_to_op(*place, None)?;\n                 let discr_val = self.read_discriminant(&op)?.0;\n                 self.write_scalar(discr_val, &dest)?;\n             }"}, {"sha": "d53a87225421e53fac0bb9a4cee5e0b49b279f0f", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=3dca58e249703a9e6558f5683b904fcb71d9d879", "patch": "@@ -22,14 +22,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         terminator: &mir::Terminator<'tcx>,\n     ) -> InterpResult<'tcx> {\n         use rustc_middle::mir::TerminatorKind::*;\n-        match terminator.kind {\n+        match &terminator.kind {\n             Return => {\n                 self.pop_stack_frame(/* unwinding */ false)?\n             }\n \n-            Goto { target } => self.go_to_block(target),\n+            Goto { target } => self.go_to_block(*target),\n \n-            SwitchInt { ref discr, ref targets } => {\n+            SwitchInt { discr, targets } => {\n                 let discr = self.read_immediate(&self.eval_operand(discr, None)?)?;\n                 trace!(\"SwitchInt({:?})\", *discr);\n \n@@ -55,15 +55,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.go_to_block(target_block);\n             }\n \n-            Call {\n-                ref func,\n-                ref args,\n-                destination,\n-                target,\n-                ref cleanup,\n-                from_hir_call: _,\n-                fn_span: _,\n-            } => {\n+            Call { func, args, destination, target, cleanup, from_hir_call: _, fn_span: _ } => {\n                 let old_stack = self.frame_idx();\n                 let old_loc = self.frame().loc;\n                 let func = self.eval_operand(func, None)?;\n@@ -97,14 +89,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     ),\n                 };\n \n-                let destination = self.eval_place(destination)?;\n+                let destination = self.eval_place(*destination)?;\n                 self.eval_fn_call(\n                     fn_val,\n                     (fn_sig.abi, fn_abi),\n                     &args,\n                     with_caller_location,\n                     &destination,\n-                    target,\n+                    *target,\n                     match (cleanup, fn_abi.can_unwind) {\n                         (Some(cleanup), true) => StackPopUnwind::Cleanup(*cleanup),\n                         (None, true) => StackPopUnwind::Skip,\n@@ -118,7 +110,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n \n-            Drop { place, target, unwind } => {\n+            &Drop { place, target, unwind } => {\n                 let frame = self.frame();\n                 let ty = place.ty(&frame.body.local_decls, *self.tcx).ty;\n                 let ty = self.subst_from_frame_and_normalize_erasing_regions(frame, ty)?;\n@@ -136,12 +128,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.drop_in_place(&place, instance, target, unwind)?;\n             }\n \n-            Assert { ref cond, expected, ref msg, target, cleanup } => {\n+            Assert { cond, expected, msg, target, cleanup } => {\n                 let cond_val = self.read_scalar(&self.eval_operand(cond, None)?)?.to_bool()?;\n-                if expected == cond_val {\n-                    self.go_to_block(target);\n+                if *expected == cond_val {\n+                    self.go_to_block(*target);\n                 } else {\n-                    M::assert_panic(self, msg, cleanup)?;\n+                    M::assert_panic(self, msg, *cleanup)?;\n                 }\n             }\n \n@@ -174,8 +166,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 terminator.kind\n             ),\n \n-            InlineAsm { template, ref operands, options, destination, .. } => {\n-                M::eval_inline_asm(self, template, operands, options)?;\n+            InlineAsm { template, operands, options, destination, .. } => {\n+                M::eval_inline_asm(self, template, operands, *options)?;\n                 if options.contains(InlineAsmOptions::NORETURN) {\n                     throw_ub_format!(\"returned from noreturn inline assembly\");\n                 }"}, {"sha": "f976aa983be87e3f9cbd72f82757805082b0e7ae", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=3dca58e249703a9e6558f5683b904fcb71d9d879", "patch": "@@ -419,7 +419,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             )\n         }\n         // Recursive checking\n-        if let Some(ref mut ref_tracking) = self.ref_tracking {\n+        if let Some(ref_tracking) = self.ref_tracking.as_deref_mut() {\n             // Proceed recursively even for ZST, no reason to skip them!\n             // `!` is a ZST and we want to validate it.\n             if let Ok((alloc_id, _offset, _prov)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {"}, {"sha": "2fe411c23c463904ebb35cddee71a6665d9ea396", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=3dca58e249703a9e6558f5683b904fcb71d9d879", "patch": "@@ -481,12 +481,12 @@ macro_rules! make_value_visitor {\n                 };\n \n                 // Visit the fields of this value.\n-                match v.layout().fields {\n+                match &v.layout().fields {\n                     FieldsShape::Primitive => {}\n                     FieldsShape::Union(fields) => {\n-                        self.visit_union(v, fields)?;\n+                        self.visit_union(v, *fields)?;\n                     }\n-                    FieldsShape::Arbitrary { ref offsets, .. } => {\n+                    FieldsShape::Arbitrary { offsets, .. } => {\n                         // FIXME: We collect in a vec because otherwise there are lifetime\n                         // errors: Projecting to a field needs access to `ecx`.\n                         let fields: Vec<InterpResult<'tcx, Self::V>> ="}, {"sha": "79f1737e32b21fcabe767b8999d753b5210aaa30", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=3dca58e249703a9e6558f5683b904fcb71d9d879", "patch": "@@ -442,7 +442,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n         self.super_rvalue(rvalue, location);\n \n-        match *rvalue {\n+        match rvalue {\n             Rvalue::ThreadLocalRef(_) => self.check_op(ops::ThreadLocalAccess),\n \n             Rvalue::Use(_)\n@@ -451,18 +451,15 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n             | Rvalue::Discriminant(..)\n             | Rvalue::Len(_) => {}\n \n-            Rvalue::Aggregate(ref kind, ..) => {\n-                if let AggregateKind::Generator(def_id, ..) = kind.as_ref() {\n-                    if let Some(generator_kind) = self.tcx.generator_kind(def_id.to_def_id()) {\n-                        if matches!(generator_kind, hir::GeneratorKind::Async(..)) {\n-                            self.check_op(ops::Generator(generator_kind));\n-                        }\n-                    }\n+            Rvalue::Aggregate(kind, ..) => {\n+                if let AggregateKind::Generator(def_id, ..) = kind.as_ref()\n+                    && let Some(generator_kind @ hir::GeneratorKind::Async(..)) = self.tcx.generator_kind(def_id.to_def_id())\n+                {\n+                    self.check_op(ops::Generator(generator_kind));\n                 }\n             }\n \n-            Rvalue::Ref(_, kind @ BorrowKind::Mut { .. }, ref place)\n-            | Rvalue::Ref(_, kind @ BorrowKind::Unique, ref place) => {\n+            Rvalue::Ref(_, kind @ (BorrowKind::Mut { .. } | BorrowKind::Unique), place) => {\n                 let ty = place.ty(self.body, self.tcx).ty;\n                 let is_allowed = match ty.kind() {\n                     // Inside a `static mut`, `&mut [...]` is allowed.\n@@ -491,12 +488,12 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 }\n             }\n \n-            Rvalue::AddressOf(Mutability::Mut, ref place) => {\n+            Rvalue::AddressOf(Mutability::Mut, place) => {\n                 self.check_mut_borrow(place.local, hir::BorrowKind::Raw)\n             }\n \n-            Rvalue::Ref(_, BorrowKind::Shared | BorrowKind::Shallow, ref place)\n-            | Rvalue::AddressOf(Mutability::Not, ref place) => {\n+            Rvalue::Ref(_, BorrowKind::Shared | BorrowKind::Shallow, place)\n+            | Rvalue::AddressOf(Mutability::Not, place) => {\n                 let borrowed_place_has_mut_interior = qualifs::in_place::<HasMutInterior, _>(\n                     &self.ccx,\n                     &mut |local| self.qualifs.has_mut_interior(self.ccx, local, location),\n@@ -564,7 +561,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n             Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) => {}\n             Rvalue::ShallowInitBox(_, _) => {}\n \n-            Rvalue::UnaryOp(_, ref operand) => {\n+            Rvalue::UnaryOp(_, operand) => {\n                 let ty = operand.ty(self.body, self.tcx);\n                 if is_int_bool_or_char(ty) {\n                     // Int, bool, and char operations are fine.\n@@ -575,8 +572,8 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 }\n             }\n \n-            Rvalue::BinaryOp(op, box (ref lhs, ref rhs))\n-            | Rvalue::CheckedBinaryOp(op, box (ref lhs, ref rhs)) => {\n+            Rvalue::BinaryOp(op, box (lhs, rhs))\n+            | Rvalue::CheckedBinaryOp(op, box (lhs, rhs)) => {\n                 let lhs_ty = lhs.ty(self.body, self.tcx);\n                 let rhs_ty = rhs.ty(self.body, self.tcx);\n \n@@ -585,13 +582,16 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 } else if lhs_ty.is_fn_ptr() || lhs_ty.is_unsafe_ptr() {\n                     assert_eq!(lhs_ty, rhs_ty);\n                     assert!(\n-                        op == BinOp::Eq\n-                            || op == BinOp::Ne\n-                            || op == BinOp::Le\n-                            || op == BinOp::Lt\n-                            || op == BinOp::Ge\n-                            || op == BinOp::Gt\n-                            || op == BinOp::Offset\n+                        matches!(\n+                            op,\n+                            BinOp::Eq\n+                            | BinOp::Ne\n+                            | BinOp::Le\n+                            | BinOp::Lt\n+                            | BinOp::Ge\n+                            | BinOp::Gt\n+                            | BinOp::Offset\n+                        )\n                     );\n \n                     self.check_op(ops::RawPtrComparison);"}, {"sha": "25f3ac7632fcd4fd5e560765590a66a1e96e8dcb", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 49, "deletions": 53, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dca58e249703a9e6558f5683b904fcb71d9d879/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=3dca58e249703a9e6558f5683b904fcb71d9d879", "patch": "@@ -133,7 +133,7 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n                 }\n                 _ => { /* mark as unpromotable below */ }\n             }\n-        } else if let TempState::Defined { ref mut uses, .. } = *temp {\n+        } else if let TempState::Defined { uses, .. } = temp {\n             // We always allow borrows, even mutable ones, as we need\n             // to promote mutable borrows of some ZSTs e.g., `&mut []`.\n             let allowed_use = match context {\n@@ -748,7 +748,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         if loc.statement_index < num_stmts {\n             let (mut rvalue, source_info) = {\n                 let statement = &mut self.source[loc.block].statements[loc.statement_index];\n-                let StatementKind::Assign(box (_, ref mut rhs)) = statement.kind else {\n+                let StatementKind::Assign(box (_, rhs)) = &mut statement.kind else {\n                     span_bug!(\n                         statement.source_info.span,\n                         \"{:?} is not an assignment\",\n@@ -778,9 +778,9 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 self.source[loc.block].terminator().clone()\n             } else {\n                 let terminator = self.source[loc.block].terminator_mut();\n-                let target = match terminator.kind {\n-                    TerminatorKind::Call { target: Some(target), .. } => target,\n-                    ref kind => {\n+                let target = match &terminator.kind {\n+                    TerminatorKind::Call { target: Some(target), .. } => *target,\n+                    kind => {\n                         span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n                     }\n                 };\n@@ -814,7 +814,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         ..terminator\n                     };\n                 }\n-                ref kind => {\n+                kind => {\n                     span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n                 }\n             };\n@@ -847,54 +847,50 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             let local_decls = &mut self.source.local_decls;\n             let loc = candidate.location;\n             let statement = &mut blocks[loc.block].statements[loc.statement_index];\n-            match statement.kind {\n-                StatementKind::Assign(box (\n-                    _,\n-                    Rvalue::Ref(ref mut region, borrow_kind, ref mut place),\n-                )) => {\n-                    // Use the underlying local for this (necessarily interior) borrow.\n-                    let ty = local_decls[place.local].ty;\n-                    let span = statement.source_info.span;\n-\n-                    let ref_ty = tcx.mk_ref(\n-                        tcx.lifetimes.re_erased,\n-                        ty::TypeAndMut { ty, mutbl: borrow_kind.to_mutbl_lossy() },\n-                    );\n+            let StatementKind::Assign(box (_, Rvalue::Ref(region, borrow_kind, place)))= &mut statement.kind else {\n+                bug!()\n+            };\n \n-                    *region = tcx.lifetimes.re_erased;\n-\n-                    let mut projection = vec![PlaceElem::Deref];\n-                    projection.extend(place.projection);\n-                    place.projection = tcx.intern_place_elems(&projection);\n-\n-                    // Create a temp to hold the promoted reference.\n-                    // This is because `*r` requires `r` to be a local,\n-                    // otherwise we would use the `promoted` directly.\n-                    let mut promoted_ref = LocalDecl::new(ref_ty, span);\n-                    promoted_ref.source_info = statement.source_info;\n-                    let promoted_ref = local_decls.push(promoted_ref);\n-                    assert_eq!(self.temps.push(TempState::Unpromotable), promoted_ref);\n-\n-                    let promoted_ref_statement = Statement {\n-                        source_info: statement.source_info,\n-                        kind: StatementKind::Assign(Box::new((\n-                            Place::from(promoted_ref),\n-                            Rvalue::Use(promoted_operand(ref_ty, span)),\n-                        ))),\n-                    };\n-                    self.extra_statements.push((loc, promoted_ref_statement));\n-\n-                    Rvalue::Ref(\n-                        tcx.lifetimes.re_erased,\n-                        borrow_kind,\n-                        Place {\n-                            local: mem::replace(&mut place.local, promoted_ref),\n-                            projection: List::empty(),\n-                        },\n-                    )\n-                }\n-                _ => bug!(),\n-            }\n+            // Use the underlying local for this (necessarily interior) borrow.\n+            let ty = local_decls[place.local].ty;\n+            let span = statement.source_info.span;\n+\n+            let ref_ty = tcx.mk_ref(\n+                tcx.lifetimes.re_erased,\n+                ty::TypeAndMut { ty, mutbl: borrow_kind.to_mutbl_lossy() },\n+            );\n+\n+            *region = tcx.lifetimes.re_erased;\n+\n+            let mut projection = vec![PlaceElem::Deref];\n+            projection.extend(place.projection);\n+            place.projection = tcx.intern_place_elems(&projection);\n+\n+            // Create a temp to hold the promoted reference.\n+            // This is because `*r` requires `r` to be a local,\n+            // otherwise we would use the `promoted` directly.\n+            let mut promoted_ref = LocalDecl::new(ref_ty, span);\n+            promoted_ref.source_info = statement.source_info;\n+            let promoted_ref = local_decls.push(promoted_ref);\n+            assert_eq!(self.temps.push(TempState::Unpromotable), promoted_ref);\n+\n+            let promoted_ref_statement = Statement {\n+                source_info: statement.source_info,\n+                kind: StatementKind::Assign(Box::new((\n+                    Place::from(promoted_ref),\n+                    Rvalue::Use(promoted_operand(ref_ty, span)),\n+                ))),\n+            };\n+            self.extra_statements.push((loc, promoted_ref_statement));\n+\n+            Rvalue::Ref(\n+                tcx.lifetimes.re_erased,\n+                *borrow_kind,\n+                Place {\n+                    local: mem::replace(&mut place.local, promoted_ref),\n+                    projection: List::empty(),\n+                },\n+            )\n         };\n \n         assert_eq!(self.new_block(), START_BLOCK);"}]}