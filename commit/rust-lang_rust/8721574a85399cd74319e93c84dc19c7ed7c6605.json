{"sha": "8721574a85399cd74319e93c84dc19c7ed7c6605", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MjE1NzRhODUzOTljZDc0MzE5ZTkzYzg0ZGMxOWM3ZWQ3YzY2MDU=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-01-03T10:24:50Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-01-04T15:44:27Z"}, "message": "Simplify", "tree": {"sha": "83fb39e8c97fb524e6053937ca2b9dbc69ad053f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83fb39e8c97fb524e6053937ca2b9dbc69ad053f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8721574a85399cd74319e93c84dc19c7ed7c6605", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8721574a85399cd74319e93c84dc19c7ed7c6605", "html_url": "https://github.com/rust-lang/rust/commit/8721574a85399cd74319e93c84dc19c7ed7c6605", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8721574a85399cd74319e93c84dc19c7ed7c6605/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d27dea86b7dd4123f75ad176037b3c754eddfa65", "url": "https://api.github.com/repos/rust-lang/rust/commits/d27dea86b7dd4123f75ad176037b3c754eddfa65", "html_url": "https://github.com/rust-lang/rust/commit/d27dea86b7dd4123f75ad176037b3c754eddfa65"}], "stats": {"total": 64, "additions": 37, "deletions": 27}, "files": [{"sha": "a8bffe7ce722092b2038a43c7be9baa385b8b4bd", "filename": "crates/hir_def/src/import_map.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8721574a85399cd74319e93c84dc19c7ed7c6605/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8721574a85399cd74319e93c84dc19c7ed7c6605/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fimport_map.rs?ref=8721574a85399cd74319e93c84dc19c7ed7c6605", "patch": "@@ -24,7 +24,7 @@ pub struct ImportInfo {\n     /// The module containing this item.\n     pub container: ModuleId,\n     /// Whether the import is a trait associated item or not.\n-    pub is_assoc_item: bool,\n+    pub is_trait_assoc_item: bool,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -105,11 +105,16 @@ impl ImportMap {\n                 for item in per_ns.iter_items() {\n                     let path = mk_path();\n                     let path_len = path.len();\n-                    let import_info = ImportInfo { path, container: module, is_assoc_item: false };\n+                    let import_info =\n+                        ImportInfo { path, container: module, is_trait_assoc_item: false };\n \n-                    // If we've added a path to a trait, add the trait's associated items to the assoc map.\n                     if let Some(ModuleDefId::TraitId(tr)) = item.as_module_def_id() {\n-                        import_map.collect_trait_assoc_items(db, tr, &import_info);\n+                        import_map.collect_trait_assoc_items(\n+                            db,\n+                            tr,\n+                            matches!(item, ItemInNs::Types(_)),\n+                            &import_info,\n+                        );\n                     }\n \n                     match import_map.map.entry(item) {\n@@ -177,17 +182,24 @@ impl ImportMap {\n         &mut self,\n         db: &dyn DefDatabase,\n         tr: TraitId,\n-        import_info: &ImportInfo,\n+        is_type_in_ns: bool,\n+        original_import_info: &ImportInfo,\n     ) {\n-        for (assoc_item_name, item) in db.trait_data(tr).items.iter() {\n-            let assoc_item = ItemInNs::Types(match item.clone() {\n+        for (assoc_item_name, item) in &db.trait_data(tr).items {\n+            let module_def_id = match *item {\n                 AssocItemId::FunctionId(f) => f.into(),\n                 AssocItemId::ConstId(c) => c.into(),\n                 AssocItemId::TypeAliasId(t) => t.into(),\n-            });\n-            let mut assoc_item_info = import_info.to_owned();\n+            };\n+            let assoc_item = if is_type_in_ns {\n+                ItemInNs::Types(module_def_id)\n+            } else {\n+                ItemInNs::Values(module_def_id)\n+            };\n+\n+            let mut assoc_item_info = original_import_info.to_owned();\n             assoc_item_info.path.segments.push(assoc_item_name.to_owned());\n-            assoc_item_info.is_assoc_item = true;\n+            assoc_item_info.is_trait_assoc_item = true;\n             self.map.insert(assoc_item, assoc_item_info);\n         }\n     }\n@@ -314,7 +326,7 @@ impl Query {\n }\n \n fn import_matches_query(import: &ImportInfo, query: &Query, enforce_lowercase: bool) -> bool {\n-    let mut input = if import.is_assoc_item || query.name_only {\n+    let mut input = if import.is_trait_assoc_item || query.name_only {\n         import.path.segments.last().unwrap().to_string()\n     } else {\n         import.path.to_string()\n@@ -455,6 +467,8 @@ mod tests {\n                     None => (\n                         dependency_imports.path_of(dependency)?.to_string(),\n                         match dependency {\n+                            ItemInNs::Types(ModuleDefId::FunctionId(_))\n+                            | ItemInNs::Values(ModuleDefId::FunctionId(_)) => \"f\",\n                             ItemInNs::Types(_) => \"t\",\n                             ItemInNs::Values(_) => \"v\",\n                             ItemInNs::Macros(_) => \"m\",\n@@ -478,7 +492,16 @@ mod tests {\n         dependency_imports: &ImportMap,\n         dependency: ItemInNs,\n     ) -> Option<String> {\n-        let dependency_assoc_item_id = dependency.as_assoc_item_id()?;\n+        let dependency_assoc_item_id = match dependency {\n+            ItemInNs::Types(ModuleDefId::FunctionId(id))\n+            | ItemInNs::Values(ModuleDefId::FunctionId(id)) => AssocItemId::from(id),\n+            ItemInNs::Types(ModuleDefId::ConstId(id))\n+            | ItemInNs::Values(ModuleDefId::ConstId(id)) => AssocItemId::from(id),\n+            ItemInNs::Types(ModuleDefId::TypeAliasId(id))\n+            | ItemInNs::Values(ModuleDefId::TypeAliasId(id)) => AssocItemId::from(id),\n+            _ => return None,\n+        };\n+\n         let trait_ = assoc_to_trait(db, dependency)?;\n         if let ModuleDefId::TraitId(tr) = trait_.as_module_def_id()? {\n             let trait_data = db.trait_data(tr);\n@@ -820,7 +843,7 @@ mod tests {\n                 dep::Fmt (m)\n                 dep::fmt::Display (t)\n                 dep::fmt::Display::fmt (a)\n-                dep::format (v)\n+                dep::format (f)\n             \"#]],\n         );\n "}, {"sha": "2750e1c915d59dcb3174c7a6e89b180d4783b7fb", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8721574a85399cd74319e93c84dc19c7ed7c6605/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8721574a85399cd74319e93c84dc19c7ed7c6605/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=8721574a85399cd74319e93c84dc19c7ed7c6605", "patch": "@@ -12,9 +12,8 @@ use test_utils::mark;\n \n use crate::{\n     db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, HasModule, ImplId,\n-    LocalModuleId, Lookup, MacroDefId, ModuleDefId, TraitId,\n+    LocalModuleId, Lookup, MacroDefId, ModuleDefId, ModuleId, TraitId,\n };\n-use crate::{AssocItemId, ModuleId};\n \n #[derive(Copy, Clone)]\n pub(crate) enum ImportType {\n@@ -349,18 +348,6 @@ impl ItemInNs {\n         }\n     }\n \n-    pub fn as_assoc_item_id(self) -> Option<AssocItemId> {\n-        match self {\n-            ItemInNs::Types(ModuleDefId::FunctionId(id))\n-            | ItemInNs::Values(ModuleDefId::FunctionId(id)) => Some(id.into()),\n-            ItemInNs::Types(ModuleDefId::ConstId(id))\n-            | ItemInNs::Values(ModuleDefId::ConstId(id)) => Some(id.into()),\n-            ItemInNs::Types(ModuleDefId::TypeAliasId(id))\n-            | ItemInNs::Values(ModuleDefId::TypeAliasId(id)) => Some(id.into()),\n-            _ => None,\n-        }\n-    }\n-\n     /// Returns the crate defining this item (or `None` if `self` is built-in).\n     pub fn krate(&self, db: &dyn DefDatabase) -> Option<CrateId> {\n         Some(match self {"}]}