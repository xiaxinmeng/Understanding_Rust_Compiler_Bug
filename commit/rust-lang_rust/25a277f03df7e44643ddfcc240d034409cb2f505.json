{"sha": "25a277f03df7e44643ddfcc240d034409cb2f505", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1YTI3N2YwM2RmN2U0NDY0M2RkZmNjMjQwZDAzNDQwOWNiMmY1MDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-18T08:01:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-18T08:01:32Z"}, "message": "Auto merge of #82973 - ijackson:exitstatuserror, r=yaahc\n\nProvide ExitStatusError\n\nCloses #73125\n\nIn MR #81452 \"Add #[must_use] to [...] process::ExitStatus\" we concluded that the existing arrangements in are too awkward so adding that `#[must_use]` is blocked on improving the ergonomics.\n\nI wrote a mini-RFC-style discusion of the approach in https://github.com/rust-lang/rust/issues/73125#issuecomment-771092741", "tree": {"sha": "c4f00d62c473f44d09ccb147ead2775ce280628d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4f00d62c473f44d09ccb147ead2775ce280628d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25a277f03df7e44643ddfcc240d034409cb2f505", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25a277f03df7e44643ddfcc240d034409cb2f505", "html_url": "https://github.com/rust-lang/rust/commit/25a277f03df7e44643ddfcc240d034409cb2f505", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25a277f03df7e44643ddfcc240d034409cb2f505/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f10d310f475b3ba583b9c590b8d19f6c2fde28f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f10d310f475b3ba583b9c590b8d19f6c2fde28f", "html_url": "https://github.com/rust-lang/rust/commit/5f10d310f475b3ba583b9c590b8d19f6c2fde28f"}, {"sha": "26c782b8e7f939a00f889dfb3f1e969fc8f8c79d", "url": "https://api.github.com/repos/rust-lang/rust/commits/26c782b8e7f939a00f889dfb3f1e969fc8f8c79d", "html_url": "https://github.com/rust-lang/rust/commit/26c782b8e7f939a00f889dfb3f1e969fc8f8c79d"}], "stats": {"total": 301, "additions": 281, "deletions": 20}, "files": [{"sha": "3dc389b7582f702a4f5b1aea51eea6f93c93a0a7", "filename": "library/std/src/os/unix/process.rs", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fos%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fos%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fprocess.rs?ref=25a277f03df7e44643ddfcc240d034409cb2f505", "patch": "@@ -201,22 +201,32 @@ impl CommandExt for process::Command {\n     }\n }\n \n-/// Unix-specific extensions to [`process::ExitStatus`].\n+/// Unix-specific extensions to [`process::ExitStatus`] and\n+/// [`ExitStatusError`](process::ExitStatusError).\n ///\n-/// On Unix, `ExitStatus` **does not necessarily represent an exit status**, as passed to the\n-/// `exit` system call or returned by [`ExitStatus::code()`](crate::process::ExitStatus::code).\n-/// It represents **any wait status**, as returned by one of the `wait` family of system calls.\n+/// On Unix, `ExitStatus` **does not necessarily represent an exit status**, as\n+/// passed to the `exit` system call or returned by\n+/// [`ExitStatus::code()`](crate::process::ExitStatus::code).  It represents **any wait status**\n+/// as returned by one of the `wait` family of system\n+/// calls.\n ///\n-/// This is because a Unix wait status (a Rust `ExitStatus`) can represent a Unix exit status, but\n-/// can also represent other kinds of process event.\n+/// A Unix wait status (a Rust `ExitStatus`) can represent a Unix exit status, but can also\n+/// represent other kinds of process event.\n ///\n /// This trait is sealed: it cannot be implemented outside the standard library.\n /// This is so that future additional methods are not breaking changes.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ExitStatusExt: Sealed {\n-    /// Creates a new `ExitStatus` from the raw underlying integer status value from `wait`\n+    /// Creates a new `ExitStatus` or `ExitStatusError` from the raw underlying integer status\n+    /// value from `wait`\n     ///\n     /// The value should be a **wait status, not an exit status**.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics on an attempt to make an `ExitStatusError` from a wait status of `0`.\n+    ///\n+    /// Making an `ExitStatus` always succeds and never panics.\n     #[stable(feature = \"exit_status_from\", since = \"1.12.0\")]\n     fn from_raw(raw: i32) -> Self;\n \n@@ -278,6 +288,35 @@ impl ExitStatusExt for process::ExitStatus {\n     }\n }\n \n+#[unstable(feature = \"exit_status_error\", issue = \"84908\")]\n+impl ExitStatusExt for process::ExitStatusError {\n+    fn from_raw(raw: i32) -> Self {\n+        process::ExitStatus::from_raw(raw)\n+            .exit_ok()\n+            .expect_err(\"<ExitStatusError as ExitStatusExt>::from_raw(0) but zero is not an error\")\n+    }\n+\n+    fn signal(&self) -> Option<i32> {\n+        self.into_status().signal()\n+    }\n+\n+    fn core_dumped(&self) -> bool {\n+        self.into_status().core_dumped()\n+    }\n+\n+    fn stopped_signal(&self) -> Option<i32> {\n+        self.into_status().stopped_signal()\n+    }\n+\n+    fn continued(&self) -> bool {\n+        self.into_status().continued()\n+    }\n+\n+    fn into_raw(self) -> i32 {\n+        self.into_status().into_raw()\n+    }\n+}\n+\n #[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n impl FromRawFd for process::Stdio {\n     #[inline]"}, {"sha": "6903ba9056089fba54d1af9c0df9da20740cb2d4", "filename": "library/std/src/process.rs", "status": "modified", "additions": 141, "deletions": 3, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=25a277f03df7e44643ddfcc240d034409cb2f505", "patch": "@@ -110,6 +110,7 @@ use crate::ffi::OsStr;\n use crate::fmt;\n use crate::fs;\n use crate::io::{self, Initializer, IoSlice, IoSliceMut};\n+use crate::num::NonZeroI32;\n use crate::path::Path;\n use crate::str;\n use crate::sys::pipe::{read2, AnonPipe};\n@@ -1387,8 +1388,8 @@ impl From<fs::File> for Stdio {\n /// An `ExitStatus` represents every possible disposition of a process.  On Unix this\n /// is the **wait status**.  It is *not* simply an *exit status* (a value passed to `exit`).\n ///\n-/// For proper error reporting of failed processes, print the value of `ExitStatus` using its\n-/// implementation of [`Display`](crate::fmt::Display).\n+/// For proper error reporting of failed processes, print the value of `ExitStatus` or\n+/// `ExitStatusError` using their implementations of [`Display`](crate::fmt::Display).\n ///\n /// [`status`]: Command::status\n /// [`wait`]: Child::wait\n@@ -1401,6 +1402,29 @@ pub struct ExitStatus(imp::ExitStatus);\n impl crate::sealed::Sealed for ExitStatus {}\n \n impl ExitStatus {\n+    /// Was termination successful?  Returns a `Result`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(exit_status_error)]\n+    /// # if cfg!(unix) {\n+    /// use std::process::Command;\n+    ///\n+    /// let status = Command::new(\"ls\")\n+    ///                      .arg(\"/dev/nonexistent\")\n+    ///                      .status()\n+    ///                      .expect(\"ls could not be executed\");\n+    ///\n+    /// println!(\"ls: {}\", status);\n+    /// status.exit_ok().expect_err(\"/dev/nonexistent could be listed!\");\n+    /// # } // cfg!(unix)\n+    /// ```\n+    #[unstable(feature = \"exit_status_error\", issue = \"84908\")]\n+    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n+        self.0.exit_ok().map_err(ExitStatusError)\n+    }\n+\n     /// Was termination successful? Signal termination is not considered a\n     /// success, and success is defined as a zero exit status.\n     ///\n@@ -1422,7 +1446,7 @@ impl ExitStatus {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn success(&self) -> bool {\n-        self.0.success()\n+        self.0.exit_ok().is_ok()\n     }\n \n     /// Returns the exit code of the process, if any.\n@@ -1476,6 +1500,120 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n+/// Allows extension traits within `std`.\n+#[unstable(feature = \"sealed\", issue = \"none\")]\n+impl crate::sealed::Sealed for ExitStatusError {}\n+\n+/// Describes the result of a process after it has failed\n+///\n+/// Produced by the [`.exit_ok`](ExitStatus::exit_ok) method on [`ExitStatus`].\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(exit_status_error)]\n+/// # if cfg!(unix) {\n+/// use std::process::{Command, ExitStatusError};\n+///\n+/// fn run(cmd: &str) -> Result<(),ExitStatusError> {\n+///     Command::new(cmd).status().unwrap().exit_ok()?;\n+///     Ok(())\n+/// }\n+///\n+/// run(\"true\").unwrap();\n+/// run(\"false\").unwrap_err();\n+/// # } // cfg!(unix)\n+/// ```\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+#[unstable(feature = \"exit_status_error\", issue = \"84908\")]\n+// The definition of imp::ExitStatusError should ideally be such that\n+// Result<(), imp::ExitStatusError> has an identical representation to imp::ExitStatus.\n+pub struct ExitStatusError(imp::ExitStatusError);\n+\n+#[unstable(feature = \"exit_status_error\", issue = \"84908\")]\n+impl ExitStatusError {\n+    /// Reports the exit code, if applicable, from an `ExitStatusError`.\n+    ///\n+    /// In Unix terms the return value is the **exit status**: the value passed to `exit`, if the\n+    /// process finished by calling `exit`.  Note that on Unix the exit status is truncated to 8\n+    /// bits, and that values that didn't come from a program's call to `exit` may be invented by the\n+    /// runtime system (often, for example, 255, 254, 127 or 126).\n+    ///\n+    /// On Unix, this will return `None` if the process was terminated by a signal.  If you want to\n+    /// handle such situations specially, consider using methods from\n+    /// [`ExitStatusExt`](crate::os::unix::process::ExitStatusExt).\n+    ///\n+    /// If the process finished by calling `exit` with a nonzero value, this will return\n+    /// that exit status.\n+    ///\n+    /// If the error was something else, it will return `None`.\n+    ///\n+    /// If the process exited successfully (ie, by calling `exit(0)`), there is no\n+    /// `ExitStatusError`.  So the return value from `ExitStatusError::code()` is always nonzero.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(exit_status_error)]\n+    /// # #[cfg(unix)] {\n+    /// use std::process::Command;\n+    ///\n+    /// let bad = Command::new(\"false\").status().unwrap().exit_ok().unwrap_err();\n+    /// assert_eq!(bad.code(), Some(1));\n+    /// # } // #[cfg(unix)]\n+    /// ```\n+    pub fn code(&self) -> Option<i32> {\n+        self.code_nonzero().map(Into::into)\n+    }\n+\n+    /// Reports the exit code, if applicable, from an `ExitStatusError`, as a `NonZero`\n+    ///\n+    /// This is exaclty like [`code()`](Self::code), except that it returns a `NonZeroI32`.\n+    ///\n+    /// Plain `code`, returning a plain integer, is provided because is is often more convenient.\n+    /// The returned value from `code()` is indeed also nonzero; use `code_nonzero()` when you want\n+    /// a type-level guarantee of nonzeroness.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(exit_status_error)]\n+    /// # if cfg!(unix) {\n+    /// use std::convert::TryFrom;\n+    /// use std::num::NonZeroI32;\n+    /// use std::process::Command;\n+    ///\n+    /// let bad = Command::new(\"false\").status().unwrap().exit_ok().unwrap_err();\n+    /// assert_eq!(bad.code_nonzero().unwrap(), NonZeroI32::try_from(1).unwrap());\n+    /// # } // cfg!(unix)\n+    /// ```\n+    pub fn code_nonzero(&self) -> Option<NonZeroI32> {\n+        self.0.code()\n+    }\n+\n+    /// Converts an `ExitStatusError` (back) to an `ExitStatus`.\n+    pub fn into_status(&self) -> ExitStatus {\n+        ExitStatus(self.0.into())\n+    }\n+}\n+\n+#[unstable(feature = \"exit_status_error\", issue = \"84908\")]\n+impl Into<ExitStatus> for ExitStatusError {\n+    fn into(self) -> ExitStatus {\n+        ExitStatus(self.0.into())\n+    }\n+}\n+\n+#[unstable(feature = \"exit_status_error\", issue = \"84908\")]\n+impl fmt::Display for ExitStatusError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"process exited unsuccessfully: {}\", self.into_status())\n+    }\n+}\n+\n+#[unstable(feature = \"exit_status_error\", issue = \"84908\")]\n+impl crate::error::Error for ExitStatusError {}\n+\n /// This type represents the status code a process can return to its\n /// parent under normal termination.\n ///"}, {"sha": "b5a19ed54a2f25e78d1fc25dc52d4589778c5d14", "filename": "library/std/src/sys/unix/process/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fmod.rs?ref=25a277f03df7e44643ddfcc240d034409cb2f505", "patch": "@@ -1,5 +1,5 @@\n pub use self::process_common::{Command, CommandArgs, ExitCode, Stdio, StdioPipes};\n-pub use self::process_inner::{ExitStatus, Process};\n+pub use self::process_inner::{ExitStatus, ExitStatusError, Process};\n pub use crate::ffi::OsString as EnvKey;\n pub use crate::sys_common::process::CommandEnvs;\n "}, {"sha": "507abb27871bf05747ffb0e132c0e99070781909", "filename": "library/std/src/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=25a277f03df7e44643ddfcc240d034409cb2f505", "patch": "@@ -1,7 +1,8 @@\n-use crate::convert::TryInto;\n+use crate::convert::{TryFrom, TryInto};\n use crate::fmt;\n use crate::io;\n use crate::mem;\n+use crate::num::{NonZeroI32, NonZeroI64};\n use crate::ptr;\n \n use crate::sys::process::process_common::*;\n@@ -236,8 +237,11 @@ impl Process {\n pub struct ExitStatus(i64);\n \n impl ExitStatus {\n-    pub fn success(&self) -> bool {\n-        self.code() == Some(0)\n+    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n+        match NonZeroI64::try_from(self.0) {\n+            /* was nonzero */ Ok(failure) => Err(ExitStatusError(failure)),\n+            /* was zero, couldn't convert */ Err(_) => Ok(()),\n+        }\n     }\n \n     pub fn code(&self) -> Option<i32> {\n@@ -306,3 +310,19 @@ impl fmt::Display for ExitStatus {\n         write!(f, \"exit code: {}\", self.0)\n     }\n }\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatusError(NonZeroI64);\n+\n+impl Into<ExitStatus> for ExitStatusError {\n+    fn into(self) -> ExitStatus {\n+        ExitStatus(self.0.into())\n+    }\n+}\n+\n+impl ExitStatusError {\n+    pub fn code(self) -> Option<NonZeroI32> {\n+        // fixme: affected by the same bug as ExitStatus::code()\n+        ExitStatus(self.0.into()).code().map(|st| st.try_into().unwrap())\n+    }\n+}"}, {"sha": "7f8065e750038b15ebe4c32ac065792b5b6ff9ba", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=25a277f03df7e44643ddfcc240d034409cb2f505", "patch": "@@ -1,7 +1,9 @@\n-use crate::convert::TryInto;\n+use crate::convert::{TryFrom, TryInto};\n use crate::fmt;\n use crate::io::{self, Error, ErrorKind};\n use crate::mem;\n+use crate::num::NonZeroI32;\n+use crate::os::raw::NonZero_c_int;\n use crate::ptr;\n use crate::sys;\n use crate::sys::cvt;\n@@ -491,8 +493,16 @@ impl ExitStatus {\n         libc::WIFEXITED(self.0)\n     }\n \n-    pub fn success(&self) -> bool {\n-        self.code() == Some(0)\n+    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n+        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0.  This is\n+        // true on all actual versios of Unix, is widely assumed, and is specified in SuS\n+        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html .  If it is not\n+        // true for a platform pretending to be Unix, the tests (our doctests, and also\n+        // procsss_unix/tests.rs) will spot it.  `ExitStatusError::code` assumes this too.\n+        match NonZero_c_int::try_from(self.0) {\n+            /* was nonzero */ Ok(failure) => Err(ExitStatusError(failure)),\n+            /* was zero, couldn't convert */ Err(_) => Ok(()),\n+        }\n     }\n \n     pub fn code(&self) -> Option<i32> {\n@@ -547,6 +557,21 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatusError(NonZero_c_int);\n+\n+impl Into<ExitStatus> for ExitStatusError {\n+    fn into(self) -> ExitStatus {\n+        ExitStatus(self.0.into())\n+    }\n+}\n+\n+impl ExitStatusError {\n+    pub fn code(self) -> Option<NonZeroI32> {\n+        ExitStatus(self.0.into()).code().map(|st| st.try_into().unwrap())\n+    }\n+}\n+\n #[cfg(test)]\n #[path = \"process_unix/tests.rs\"]\n mod tests;"}, {"sha": "7846e43cfb53ee56aa0be7b9c0e2a11781e05725", "filename": "library/std/src/sys/unsupported/process.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fprocess.rs?ref=25a277f03df7e44643ddfcc240d034409cb2f505", "patch": "@@ -2,6 +2,7 @@ use crate::ffi::OsStr;\n use crate::fmt;\n use crate::io;\n use crate::marker::PhantomData;\n+use crate::num::NonZeroI32;\n use crate::path::Path;\n use crate::sys::fs::File;\n use crate::sys::pipe::AnonPipe;\n@@ -97,7 +98,7 @@ impl fmt::Debug for Command {\n pub struct ExitStatus(!);\n \n impl ExitStatus {\n-    pub fn success(&self) -> bool {\n+    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n         self.0\n     }\n \n@@ -134,6 +135,21 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatusError(ExitStatus);\n+\n+impl Into<ExitStatus> for ExitStatusError {\n+    fn into(self) -> ExitStatus {\n+        self.0.0\n+    }\n+}\n+\n+impl ExitStatusError {\n+    pub fn code(self) -> Option<NonZeroI32> {\n+        self.0.0\n+    }\n+}\n+\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub struct ExitCode(bool);\n "}, {"sha": "e91c489361ea6825b6973907d7a4ab027cae54b6", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=25a277f03df7e44643ddfcc240d034409cb2f505", "patch": "@@ -4,6 +4,7 @@\n #![cfg_attr(test, allow(dead_code))]\n #![unstable(issue = \"none\", feature = \"windows_c\")]\n \n+use crate::os::raw::NonZero_c_ulong;\n use crate::os::raw::{c_char, c_int, c_long, c_longlong, c_uint, c_ulong, c_ushort};\n use crate::ptr;\n \n@@ -13,6 +14,7 @@ pub use self::EXCEPTION_DISPOSITION::*;\n pub use self::FILE_INFO_BY_HANDLE_CLASS::*;\n \n pub type DWORD = c_ulong;\n+pub type NonZeroDWORD = NonZero_c_ulong;\n pub type HANDLE = LPVOID;\n pub type HINSTANCE = HANDLE;\n pub type HMODULE = HINSTANCE;"}, {"sha": "81dbea4a067399755a1fd029fc3ed514c6c44e05", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a277f03df7e44643ddfcc240d034409cb2f505/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=25a277f03df7e44643ddfcc240d034409cb2f505", "patch": "@@ -5,17 +5,20 @@ mod tests;\n \n use crate::borrow::Borrow;\n use crate::collections::BTreeMap;\n+use crate::convert::{TryFrom, TryInto};\n use crate::env;\n use crate::env::split_paths;\n use crate::ffi::{OsStr, OsString};\n use crate::fmt;\n use crate::fs;\n use crate::io::{self, Error, ErrorKind};\n use crate::mem;\n+use crate::num::NonZeroI32;\n use crate::os::windows::ffi::OsStrExt;\n use crate::path::Path;\n use crate::ptr;\n use crate::sys::c;\n+use crate::sys::c::NonZeroDWORD;\n use crate::sys::cvt;\n use crate::sys::fs::{File, OpenOptions};\n use crate::sys::handle::Handle;\n@@ -376,8 +379,11 @@ impl Process {\n pub struct ExitStatus(c::DWORD);\n \n impl ExitStatus {\n-    pub fn success(&self) -> bool {\n-        self.0 == 0\n+    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n+        match NonZeroDWORD::try_from(self.0) {\n+            /* was nonzero */ Ok(failure) => Err(ExitStatusError(failure)),\n+            /* was zero, couldn't convert */ Err(_) => Ok(()),\n+        }\n     }\n     pub fn code(&self) -> Option<i32> {\n         Some(self.0 as i32)\n@@ -406,6 +412,21 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatusError(c::NonZeroDWORD);\n+\n+impl Into<ExitStatus> for ExitStatusError {\n+    fn into(self) -> ExitStatus {\n+        ExitStatus(self.0.into())\n+    }\n+}\n+\n+impl ExitStatusError {\n+    pub fn code(self) -> Option<NonZeroI32> {\n+        Some((u32::from(self.0) as i32).try_into().unwrap())\n+    }\n+}\n+\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub struct ExitCode(c::DWORD);\n "}]}