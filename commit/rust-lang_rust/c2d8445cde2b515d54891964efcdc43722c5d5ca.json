{"sha": "c2d8445cde2b515d54891964efcdc43722c5d5ca", "node_id": "C_kwDOAAsO6NoAKGMyZDg0NDVjZGUyYjUxNWQ1NDg5MTk2NGVmY2RjNDM3MjJjNWQ1Y2E", "commit": {"author": {"name": "\u0410\u0440\u0442\u0451\u043c \u041f\u0430\u0432\u043b\u043e\u0432 [Artyom Pavlov]", "email": "newpavlov@gmail.com", "date": "2022-05-25T02:01:11Z"}, "committer": {"name": "\u0410\u0440\u0442\u0451\u043c \u041f\u0430\u0432\u043b\u043e\u0432 [Artyom Pavlov]", "email": "newpavlov@gmail.com", "date": "2022-05-25T02:01:11Z"}, "message": "implement tie to even", "tree": {"sha": "affa855a58da630cf3c5d06415270f3307415478", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/affa855a58da630cf3c5d06415270f3307415478"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2d8445cde2b515d54891964efcdc43722c5d5ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2d8445cde2b515d54891964efcdc43722c5d5ca", "html_url": "https://github.com/rust-lang/rust/commit/c2d8445cde2b515d54891964efcdc43722c5d5ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2d8445cde2b515d54891964efcdc43722c5d5ca/comments", "author": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65c75b2db7827f8faa63c332139a3264b4ab9427", "url": "https://api.github.com/repos/rust-lang/rust/commits/65c75b2db7827f8faa63c332139a3264b4ab9427", "html_url": "https://github.com/rust-lang/rust/commit/65c75b2db7827f8faa63c332139a3264b4ab9427"}], "stats": {"total": 92, "additions": 73, "deletions": 19}, "files": [{"sha": "7f23cb83e0999bf38e3adae5aa64c293ca819a17", "filename": "library/core/src/time.rs", "status": "modified", "additions": 73, "deletions": 19, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c2d8445cde2b515d54891964efcdc43722c5d5ca/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d8445cde2b515d54891964efcdc43722c5d5ca/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=c2d8445cde2b515d54891964efcdc43722c5d5ca", "patch": "@@ -1270,36 +1270,46 @@ macro_rules! try_from_secs {\n         let mant = (bits & MANT_MASK) | (MANT_MASK + 1);\n         let exp = ((bits >> $mant_bits) & EXP_MASK) as i16 + MIN_EXP;\n \n-        let (secs, nanos) = if exp < -30 {\n-            // the input represents less than 1ns.\n+        let (secs, nanos) = if exp < -31 {\n+            // the input represents less than 1ns and can not be rounded to it\n             (0u64, 0u32)\n         } else if exp < 0 {\n             // the input is less than 1 second\n             let t = <$double_ty>::from(mant) << ($offset + exp);\n             let nanos_offset = $mant_bits + $offset;\n             let nanos_tmp = u128::from(NANOS_PER_SEC) * u128::from(t);\n             let nanos = (nanos_tmp >> nanos_offset) as u32;\n-            if nanos_tmp & (1 << (nanos_offset - 1)) == 0 {\n-                (0, nanos)\n-            } else if nanos + 1 != NANOS_PER_SEC {\n-                (0, nanos + 1)\n-            } else {\n-                (1, 0)\n-            }\n+\n+            let rem_mask = (1 << nanos_offset) - 1;\n+            let rem_msb_mask = 1 << (nanos_offset - 1);\n+            let rem = nanos_tmp & rem_mask;\n+            let is_tie = rem == rem_msb_mask;\n+            let is_even = (nanos & 1) == 0;\n+            let rem_msb = nanos_tmp & rem_msb_mask == 0;\n+            let add_ns = !(rem_msb || (is_even && is_tie));\n+\n+            // note that neither `f32`, nor `f64` can represent\n+            // 0.999_999_999_5 exactly, so the nanos part\n+            // never will be equal to 10^9.\n+            (0, nanos + add_ns as u32)\n         } else if exp < $mant_bits {\n             let secs = u64::from(mant >> ($mant_bits - exp));\n             let t = <$double_ty>::from((mant << exp) & MANT_MASK);\n+            let nanos_offset = $mant_bits;\n             let nanos_tmp = <$double_ty>::from(NANOS_PER_SEC) * t;\n-            let nanos = (nanos_tmp >> $mant_bits) as u32;\n-            if nanos_tmp & (1 << ($mant_bits - 1)) == 0 {\n-                (secs, nanos)\n-            } else if nanos + 1 != NANOS_PER_SEC {\n-                (secs, nanos + 1)\n-            } else {\n-                // `secs + 1` can not overflow since `exp` is less than `$mant_bits`\n-                // and the latter is less than 64 bits for both `f32` and `f64`\n-                (secs + 1, 0)\n-            }\n+            let nanos = (nanos_tmp >> nanos_offset) as u32;\n+\n+            let rem_mask = (1 << nanos_offset) - 1;\n+            let rem_msb_mask = 1 << (nanos_offset - 1);\n+            let rem = nanos_tmp & rem_mask;\n+            let is_tie = rem == rem_msb_mask;\n+            let is_even = (nanos & 1) == 0;\n+            let rem_msb = nanos_tmp & rem_msb_mask == 0;\n+            let add_ns = !(rem_msb || (is_even && is_tie));\n+\n+            // neither `f32`, nor `f64` can represent x.999_999_999_5 exactly,\n+            // so the nanos part never will be equal to 10^9\n+            (secs, nanos + add_ns as u32)\n         } else if exp < 64 {\n             // the input has no fractional part\n             let secs = u64::from(mant) << (exp - $mant_bits);\n@@ -1348,6 +1358,28 @@ impl Duration {\n     /// assert!(res.is_err());\n     /// let res = Duration::try_from_secs_f32(2e19);\n     /// assert!(res.is_err());\n+    ///\n+    /// // this method uses round to nearest, ties to even\n+    ///\n+    /// // this float represents exactly 976562.5e-9\n+    /// let val = f32::from_bits(0x3A80_0000);\n+    /// let res = Duration::try_from_secs_f32(val);\n+    /// assert_eq!(res, Ok(Duration::new(0, 976_562)));\n+    ///\n+    /// // this float represents exactly 2929687.5e-9\n+    /// let val = f32::from_bits(0x3B40_0000);\n+    /// let res = Duration::try_from_secs_f32(val);\n+    /// assert_eq!(res, Ok(Duration::new(0, 2_929_688)));\n+    ///\n+    /// // this float represents exactly 1.000_976_562_5\n+    /// let val = f32::from_bits(0x3F802000);\n+    /// let res = Duration::try_from_secs_f32(val);\n+    /// assert_eq!(res, Ok(Duration::new(1, 976_562)));\n+    ///\n+    /// // this float represents exactly 1.002_929_687_5\n+    /// let val = f32::from_bits(0x3F806000);\n+    /// let res = Duration::try_from_secs_f32(val);\n+    /// assert_eq!(res, Ok(Duration::new(1, 2_929_688)));\n     /// ```\n     #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n     #[inline]\n@@ -1397,6 +1429,28 @@ impl Duration {\n     /// assert!(res.is_err());\n     /// let res = Duration::try_from_secs_f64(2e19);\n     /// assert!(res.is_err());\n+    ///\n+    /// // this method uses round to nearest, ties to even\n+    ///\n+    /// // this float represents exactly 976562.5e-9\n+    /// let val = f64::from_bits(0x3F50_0000_0000_0000);\n+    /// let res = Duration::try_from_secs_f64(val);\n+    /// assert_eq!(res, Ok(Duration::new(0, 976_562)));\n+    ///\n+    /// // this float represents exactly 2929687.5e-9\n+    /// let val = f64::from_bits(0x3F68_0000_0000_0000);\n+    /// let res = Duration::try_from_secs_f64(val);\n+    /// assert_eq!(res, Ok(Duration::new(0, 2_929_688)));\n+    ///\n+    /// // this float represents exactly 1.000_976_562_5\n+    /// let val = f64::from_bits(0x3FF0_0400_0000_0000);\n+    /// let res = Duration::try_from_secs_f64(val);\n+    /// assert_eq!(res, Ok(Duration::new(1, 976_562)));\n+    ///\n+    /// // this float represents exactly 1.002_929_687_5\n+    /// let val = f64::from_bits(0x3_FF00_C000_0000_000);\n+    /// let res = Duration::try_from_secs_f64(val);\n+    /// assert_eq!(res, Ok(Duration::new(1, 2_929_688)));\n     /// ```\n     #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n     #[inline]"}]}