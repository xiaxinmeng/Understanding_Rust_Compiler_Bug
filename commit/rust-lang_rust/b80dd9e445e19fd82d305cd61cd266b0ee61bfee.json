{"sha": "b80dd9e445e19fd82d305cd61cd266b0ee61bfee", "node_id": "C_kwDOAAsO6NoAKGI4MGRkOWU0NDVlMTlmZDgyZDMwNWNkNjFjZDI2NmIwZWU2MWJmZWU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-10-11T21:45:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-11T21:45:46Z"}, "message": "Rollup merge of #89643 - cjgillot:overlap, r=matthewjasper\n\nFix inherent impl overlap check.\n\nThe current implementation of the overlap check was slightly buggy, and unified the wrong connected component in the `ids.len() <= 1` case. This became visible in another PR which changed the iteration order of items.\n\nr? ``@matthewjasper`` since you reviewed the other PR.", "tree": {"sha": "8184e398e99338e18bd47314f05b6105aadf8cc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8184e398e99338e18bd47314f05b6105aadf8cc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b80dd9e445e19fd82d305cd61cd266b0ee61bfee", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhZLCLCRBK7hj4Ov3rIwAArzsIAEz19JyolRehJw33lASx+iul\nOefodexxFnPKmxjqySkWbT0C16Ih8JDZoKw+QCxrrCyXn2f0Qinfp35JXDYSHzQE\nZ/y2BaJCJSMSwefZtyHCRHqrfY7jt4tbvs4odwS4nFa6gsy/GgD2Mc5USDsT46fZ\nPG9/IWoLGWVOCsY03dvTYrcWKg0gseFPr1cXvkXPojquUQOjbhHnM29Xcgq/7hlh\nJp3tMGFN3BImY7E1LY0wiNrIacHhiZXmgcji+tyomw3Xo3xLCyddk2CJ7dejiS1M\nYudegjzP2BiuiH3ZjUhynTstBPAJvfdRqTsOBheD5M8Yrv2HKD/uXpN5Sp2Ec8Y=\n=9w/B\n-----END PGP SIGNATURE-----\n", "payload": "tree 8184e398e99338e18bd47314f05b6105aadf8cc1\nparent 412301b26a8a6edb4cdba2bebb430f5b34e728ac\nparent a3f98a7501384d4cd11ba94a46bdf88b7e2bc816\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1633988746 +0200\ncommitter GitHub <noreply@github.com> 1633988746 +0200\n\nRollup merge of #89643 - cjgillot:overlap, r=matthewjasper\n\nFix inherent impl overlap check.\n\nThe current implementation of the overlap check was slightly buggy, and unified the wrong connected component in the `ids.len() <= 1` case. This became visible in another PR which changed the iteration order of items.\n\nr? ``@matthewjasper`` since you reviewed the other PR.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b80dd9e445e19fd82d305cd61cd266b0ee61bfee", "html_url": "https://github.com/rust-lang/rust/commit/b80dd9e445e19fd82d305cd61cd266b0ee61bfee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b80dd9e445e19fd82d305cd61cd266b0ee61bfee/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "412301b26a8a6edb4cdba2bebb430f5b34e728ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/412301b26a8a6edb4cdba2bebb430f5b34e728ac", "html_url": "https://github.com/rust-lang/rust/commit/412301b26a8a6edb4cdba2bebb430f5b34e728ac"}, {"sha": "a3f98a7501384d4cd11ba94a46bdf88b7e2bc816", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f98a7501384d4cd11ba94a46bdf88b7e2bc816", "html_url": "https://github.com/rust-lang/rust/commit/a3f98a7501384d4cd11ba94a46bdf88b7e2bc816"}], "stats": {"total": 110, "additions": 65, "deletions": 45}, "files": [{"sha": "69578e85f278175564365086d13d8f4bb22cea4e", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b80dd9e445e19fd82d305cd61cd266b0ee61bfee/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80dd9e445e19fd82d305cd61cd266b0ee61bfee/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=b80dd9e445e19fd82d305cd61cd266b0ee61bfee", "patch": "@@ -738,6 +738,12 @@ impl<I: Idx, T> IndexVec<I, Option<T>> {\n         self.ensure_contains_elem(index, || None);\n         self[index].get_or_insert_with(value)\n     }\n+\n+    #[inline]\n+    pub fn remove(&mut self, index: I) -> Option<T> {\n+        self.ensure_contains_elem(index, || None);\n+        self[index].take()\n+    }\n }\n \n impl<I: Idx, T: Clone> IndexVec<I, T> {"}, {"sha": "0373035a09ad80606117228d074bcfadf3f8b22a", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 58, "deletions": 45, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/b80dd9e445e19fd82d305cd61cd266b0ee61bfee/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80dd9e445e19fd82d305cd61cd266b0ee61bfee/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=b80dd9e445e19fd82d305cd61cd266b0ee61bfee", "patch": "@@ -3,6 +3,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_index::vec::IndexVec;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::Symbol;\n use rustc_trait_selection::traits::{self, SkipLeakCheck};\n@@ -158,22 +159,26 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n                     // This is advantageous to running the algorithm over the\n                     // entire graph when there are many connected regions.\n \n+                    rustc_index::newtype_index! {\n+                        pub struct RegionId {\n+                            ENCODABLE = custom\n+                        }\n+                    }\n                     struct ConnectedRegion {\n                         idents: SmallVec<[Symbol; 8]>,\n                         impl_blocks: FxHashSet<usize>,\n                     }\n-                    // Highest connected region id\n-                    let mut highest_region_id = 0;\n+                    let mut connected_regions: IndexVec<RegionId, _> = Default::default();\n+                    // Reverse map from the Symbol to the connected region id.\n                     let mut connected_region_ids = FxHashMap::default();\n-                    let mut connected_regions = FxHashMap::default();\n \n                     for (i, &(&_impl_def_id, impl_items)) in impls_items.iter().enumerate() {\n                         if impl_items.len() == 0 {\n                             continue;\n                         }\n                         // First obtain a list of existing connected region ids\n                         let mut idents_to_add = SmallVec::<[Symbol; 8]>::new();\n-                        let ids = impl_items\n+                        let mut ids = impl_items\n                             .in_definition_order()\n                             .filter_map(|item| {\n                                 let entry = connected_region_ids.entry(item.ident.name);\n@@ -184,62 +189,64 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n                                     None\n                                 }\n                             })\n-                            .collect::<FxHashSet<usize>>();\n-                        match ids.len() {\n-                            0 | 1 => {\n-                                let id_to_set = if ids.is_empty() {\n-                                    // Create a new connected region\n-                                    let region = ConnectedRegion {\n+                            .collect::<SmallVec<[RegionId; 8]>>();\n+                        // Sort the id list so that the algorithm is deterministic\n+                        ids.sort_unstable();\n+                        let ids = ids;\n+                        match &ids[..] {\n+                            // Create a new connected region\n+                            [] => {\n+                                let id_to_set = connected_regions.next_index();\n+                                // Update the connected region ids\n+                                for ident in &idents_to_add {\n+                                    connected_region_ids.insert(*ident, id_to_set);\n+                                }\n+                                connected_regions.insert(\n+                                    id_to_set,\n+                                    ConnectedRegion {\n                                         idents: idents_to_add,\n                                         impl_blocks: std::iter::once(i).collect(),\n-                                    };\n-                                    connected_regions.insert(highest_region_id, region);\n-                                    (highest_region_id, highest_region_id += 1).0\n-                                } else {\n-                                    // Take the only id inside the list\n-                                    let id_to_set = *ids.iter().next().unwrap();\n-                                    let region = connected_regions.get_mut(&id_to_set).unwrap();\n-                                    region.impl_blocks.insert(i);\n-                                    region.idents.extend_from_slice(&idents_to_add);\n-                                    id_to_set\n-                                };\n-                                let (_id, region) = connected_regions.iter().next().unwrap();\n+                                    },\n+                                );\n+                            }\n+                            // Take the only id inside the list\n+                            &[id_to_set] => {\n+                                let region = connected_regions[id_to_set].as_mut().unwrap();\n+                                region.impl_blocks.insert(i);\n+                                region.idents.extend_from_slice(&idents_to_add);\n                                 // Update the connected region ids\n-                                for ident in region.idents.iter() {\n+                                for ident in &idents_to_add {\n                                     connected_region_ids.insert(*ident, id_to_set);\n                                 }\n                             }\n-                            _ => {\n-                                // We have multiple connected regions to merge.\n-                                // In the worst case this might add impl blocks\n-                                // one by one and can thus be O(n^2) in the size\n-                                // of the resulting final connected region, but\n-                                // this is no issue as the final step to check\n-                                // for overlaps runs in O(n^2) as well.\n-\n-                                // Take the smallest id from the list\n-                                let id_to_set = *ids.iter().min().unwrap();\n-\n-                                // Sort the id list so that the algorithm is deterministic\n-                                let mut ids = ids.into_iter().collect::<SmallVec<[usize; 8]>>();\n-                                ids.sort_unstable();\n-\n-                                let mut region = connected_regions.remove(&id_to_set).unwrap();\n-                                region.idents.extend_from_slice(&idents_to_add);\n+                            // We have multiple connected regions to merge.\n+                            // In the worst case this might add impl blocks\n+                            // one by one and can thus be O(n^2) in the size\n+                            // of the resulting final connected region, but\n+                            // this is no issue as the final step to check\n+                            // for overlaps runs in O(n^2) as well.\n+                            &[id_to_set, ..] => {\n+                                let mut region = connected_regions.remove(id_to_set).unwrap();\n                                 region.impl_blocks.insert(i);\n+                                region.idents.extend_from_slice(&idents_to_add);\n+                                // Update the connected region ids\n+                                for ident in &idents_to_add {\n+                                    connected_region_ids.insert(*ident, id_to_set);\n+                                }\n \n+                                // Remove other regions from ids.\n                                 for &id in ids.iter() {\n                                     if id == id_to_set {\n                                         continue;\n                                     }\n-                                    let r = connected_regions.remove(&id).unwrap();\n-                                    // Update the connected region ids\n+                                    let r = connected_regions.remove(id).unwrap();\n                                     for ident in r.idents.iter() {\n                                         connected_region_ids.insert(*ident, id_to_set);\n                                     }\n                                     region.idents.extend_from_slice(&r.idents);\n                                     region.impl_blocks.extend(r.impl_blocks);\n                                 }\n+\n                                 connected_regions.insert(id_to_set, region);\n                             }\n                         }\n@@ -254,16 +261,22 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n                             let avg = impls.len() / connected_regions.len();\n                             let s = connected_regions\n                                 .iter()\n-                                .map(|r| r.1.impl_blocks.len() as isize - avg as isize)\n+                                .flatten()\n+                                .map(|r| r.impl_blocks.len() as isize - avg as isize)\n                                 .map(|v| v.abs() as usize)\n                                 .sum::<usize>();\n                             s / connected_regions.len()\n                         },\n-                        connected_regions.iter().map(|r| r.1.impl_blocks.len()).max().unwrap()\n+                        connected_regions\n+                            .iter()\n+                            .flatten()\n+                            .map(|r| r.impl_blocks.len())\n+                            .max()\n+                            .unwrap()\n                     );\n                     // List of connected regions is built. Now, run the overlap check\n                     // for each pair of impl blocks in the same connected region.\n-                    for (_id, region) in connected_regions.into_iter() {\n+                    for region in connected_regions.into_iter().flatten() {\n                         let mut impl_blocks =\n                             region.impl_blocks.into_iter().collect::<SmallVec<[usize; 8]>>();\n                         impl_blocks.sort_unstable();"}, {"sha": "971776c882a157e4946fbe714bb2a54cafb375fd", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b80dd9e445e19fd82d305cd61cd266b0ee61bfee/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b80dd9e445e19fd82d305cd61cd266b0ee61bfee/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=b80dd9e445e19fd82d305cd61cd266b0ee61bfee", "patch": "@@ -63,6 +63,7 @@ This API is completely unstable and subject to change.\n #![feature(in_band_lifetimes)]\n #![feature(is_sorted)]\n #![feature(iter_zip)]\n+#![feature(min_specialization)]\n #![feature(nll)]\n #![feature(try_blocks)]\n #![feature(never_type)]"}]}