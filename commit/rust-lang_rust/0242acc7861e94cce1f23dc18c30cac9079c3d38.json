{"sha": "0242acc7861e94cce1f23dc18c30cac9079c3d38", "node_id": "C_kwDOAAsO6NoAKDAyNDJhY2M3ODYxZTk0Y2NlMWYyM2RjMThjMzBjYWM5MDc5YzNkMzg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-05T18:47:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-05T18:47:28Z"}, "message": "Auto merge of #2000 - RalfJung:simd, r=RalfJung\n\nimplement missing SIMD comparison operators, simd_xor, and simd_reduce_all", "tree": {"sha": "d4e31159de9e49a46f463d58648196e370294795", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4e31159de9e49a46f463d58648196e370294795"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0242acc7861e94cce1f23dc18c30cac9079c3d38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0242acc7861e94cce1f23dc18c30cac9079c3d38", "html_url": "https://github.com/rust-lang/rust/commit/0242acc7861e94cce1f23dc18c30cac9079c3d38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0242acc7861e94cce1f23dc18c30cac9079c3d38/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7151715348150c2925ade31c67d750ec2f742a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7151715348150c2925ade31c67d750ec2f742a1", "html_url": "https://github.com/rust-lang/rust/commit/a7151715348150c2925ade31c67d750ec2f742a1"}, {"sha": "90207a548481b1abac9fc28c8f8f03897789e6fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/90207a548481b1abac9fc28c8f8f03897789e6fa", "html_url": "https://github.com/rust-lang/rust/commit/90207a548481b1abac9fc28c8f8f03897789e6fa"}], "stats": {"total": 105, "additions": 80, "deletions": 25}, "files": [{"sha": "5bebc52b78285c8d542d98d132fcb69985ccb67a", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0242acc7861e94cce1f23dc18c30cac9079c3d38/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0242acc7861e94cce1f23dc18c30cac9079c3d38/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=0242acc7861e94cce1f23dc18c30cac9079c3d38", "patch": "@@ -356,7 +356,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"simd_shr\"\n             | \"simd_and\"\n             | \"simd_or\"\n-            | \"simd_eq\" => {\n+            | \"simd_xor\"\n+            | \"simd_eq\"\n+            | \"simd_ne\"\n+            | \"simd_lt\"\n+            | \"simd_le\"\n+            | \"simd_gt\"\n+            | \"simd_ge\" => {\n+                use mir::BinOp;\n+\n                 let &[ref left, ref right] = check_arg_count(args)?;\n                 let (left, left_len) = this.operand_to_simd(left)?;\n                 let (right, right_len) = this.operand_to_simd(right)?;\n@@ -366,16 +374,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 assert_eq!(dest_len, right_len);\n \n                 let op = match intrinsic_name {\n-                    \"simd_add\" => mir::BinOp::Add,\n-                    \"simd_sub\" => mir::BinOp::Sub,\n-                    \"simd_mul\" => mir::BinOp::Mul,\n-                    \"simd_div\" => mir::BinOp::Div,\n-                    \"simd_rem\" => mir::BinOp::Rem,\n-                    \"simd_shl\" => mir::BinOp::Shl,\n-                    \"simd_shr\" => mir::BinOp::Shr,\n-                    \"simd_and\" => mir::BinOp::BitAnd,\n-                    \"simd_or\" => mir::BinOp::BitOr,\n-                    \"simd_eq\" => mir::BinOp::Eq,\n+                    \"simd_add\" => BinOp::Add,\n+                    \"simd_sub\" => BinOp::Sub,\n+                    \"simd_mul\" => BinOp::Mul,\n+                    \"simd_div\" => BinOp::Div,\n+                    \"simd_rem\" => BinOp::Rem,\n+                    \"simd_shl\" => BinOp::Shl,\n+                    \"simd_shr\" => BinOp::Shr,\n+                    \"simd_and\" => BinOp::BitAnd,\n+                    \"simd_or\" => BinOp::BitOr,\n+                    \"simd_xor\" => BinOp::BitXor,\n+                    \"simd_eq\" => BinOp::Eq,\n+                    \"simd_ne\" => BinOp::Ne,\n+                    \"simd_lt\" => BinOp::Lt,\n+                    \"simd_le\" => BinOp::Le,\n+                    \"simd_gt\" => BinOp::Gt,\n+                    \"simd_ge\" => BinOp::Ge,\n                     _ => unreachable!(),\n                 };\n \n@@ -384,35 +398,46 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     let right = this.read_immediate(&this.mplace_index(&right, i)?.into())?;\n                     let dest = this.mplace_index(&dest, i)?;\n                     let (val, overflowed, ty) = this.overflowing_binary_op(op, &left, &right)?;\n-                    if matches!(op, mir::BinOp::Shl | mir::BinOp::Shr) {\n+                    if matches!(op, BinOp::Shl | BinOp::Shr) {\n                         // Shifts have extra UB as SIMD operations that the MIR binop does not have.\n                         // See <https://github.com/rust-lang/rust/issues/91237>.\n                         if overflowed {\n                             let r_val = right.to_scalar()?.to_bits(right.layout.size)?;\n                             throw_ub_format!(\"overflowing shift by {} in `{}` in SIMD lane {}\", r_val, intrinsic_name, i);\n                         }\n                     }\n-                    if matches!(op, mir::BinOp::Eq) {\n+                    if matches!(op, BinOp::Eq | BinOp::Ne | BinOp::Lt | BinOp::Le | BinOp::Gt | BinOp::Ge) {\n                         // Special handling for boolean-returning operations\n                         assert_eq!(ty, this.tcx.types.bool);\n                         let val = val.to_bool().unwrap();\n                         let val = bool_to_simd_element(val, dest.layout.size);\n                         this.write_scalar(val, &dest.into())?;\n                     } else {\n+                        assert_ne!(ty, this.tcx.types.bool);\n                         assert_eq!(ty, dest.layout.ty);\n                         this.write_scalar(val, &dest.into())?;\n                     }\n                 }\n             }\n-            \"simd_reduce_any\" => {\n+            \"simd_reduce_any\" | \"simd_reduce_all\" => {\n                 let &[ref op] = check_arg_count(args)?;\n                 let (op, op_len) = this.operand_to_simd(op)?;\n \n-                let mut res = false; // the neutral element\n+                // the neutral element\n+                let mut res = match intrinsic_name {\n+                    \"simd_reduce_any\" => false,\n+                    \"simd_reduce_all\" => true,\n+                    _ => bug!(),\n+                };\n+\n                 for i in 0..op_len {\n                     let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n                     let val = simd_element_to_bool(op)?;\n-                    res = res | val;\n+                    res = match intrinsic_name {\n+                        \"simd_reduce_any\" => res | val,\n+                        \"simd_reduce_all\" => res & val,\n+                        _ => bug!(),\n+                    };\n                 }\n \n                 this.write_scalar(Scalar::from_bool(res), dest)?;"}, {"sha": "d43e7be8b192170a66b324da897e962f76b33f54", "filename": "tests/run-pass/portable-simd.rs", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0242acc7861e94cce1f23dc18c30cac9079c3d38/tests%2Frun-pass%2Fportable-simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0242acc7861e94cce1f23dc18c30cac9079c3d38/tests%2Frun-pass%2Fportable-simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fportable-simd.rs?ref=0242acc7861e94cce1f23dc18c30cac9079c3d38", "patch": "@@ -12,6 +12,14 @@ fn simd_ops_f32() {\n     assert_eq!(a / f32x4::splat(2.0), f32x4::splat(5.0));\n     assert_eq!(a % b, f32x4::from_array([0.0, 0.0, 1.0, 2.0]));\n     assert_eq!(b.abs(), f32x4::from_array([1.0, 2.0, 3.0, 4.0]));\n+\n+    // FIXME use Mask::from_array once simd_cast is implemented.\n+    assert_eq!(a.lanes_eq(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([0, -1, 0, 0])));\n+    assert_eq!(a.lanes_ne(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([-1, 0, -1, -1])));\n+    assert_eq!(a.lanes_le(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([0, -1, -1, 0])));\n+    assert_eq!(a.lanes_lt(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([0, 0, -1, 0])));\n+    assert_eq!(a.lanes_ge(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([-1, -1, 0, -1])));\n+    assert_eq!(a.lanes_gt(f32x4::splat(5.0)*b), Mask::from_int(i32x4::from_array([-1, 0, 0, -1])));\n }\n \n fn simd_ops_f64() {\n@@ -25,30 +33,48 @@ fn simd_ops_f64() {\n     assert_eq!(a / f64x4::splat(2.0), f64x4::splat(5.0));\n     assert_eq!(a % b, f64x4::from_array([0.0, 0.0, 1.0, 2.0]));\n     assert_eq!(b.abs(), f64x4::from_array([1.0, 2.0, 3.0, 4.0]));\n+\n+    // FIXME use Mask::from_array once simd_cast is implemented.\n+    assert_eq!(a.lanes_eq(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([0, -1, 0, 0])));\n+    assert_eq!(a.lanes_ne(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([-1, 0, -1, -1])));\n+    assert_eq!(a.lanes_le(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([0, -1, -1, 0])));\n+    assert_eq!(a.lanes_lt(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([0, 0, -1, 0])));\n+    assert_eq!(a.lanes_ge(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([-1, -1, 0, -1])));\n+    assert_eq!(a.lanes_gt(f64x4::splat(5.0)*b), Mask::from_int(i64x4::from_array([-1, 0, 0, -1])));\n }\n \n fn simd_ops_i32() {\n     let a = i32x4::splat(10);\n-    let b = i32x4::from_array([1, 2, 3, 4]);\n-    assert_eq!(-b, i32x4::from_array([-1, -2, -3, -4]));\n-    assert_eq!(a + b, i32x4::from_array([11, 12, 13, 14]));\n-    assert_eq!(a - b, i32x4::from_array([9, 8, 7, 6]));\n-    assert_eq!(a * b, i32x4::from_array([10, 20, 30, 40]));\n-    assert_eq!(a / b, i32x4::from_array([10, 5, 3, 2]));\n+    let b = i32x4::from_array([1, 2, 3, -4]);\n+    assert_eq!(-b, i32x4::from_array([-1, -2, -3, 4]));\n+    assert_eq!(a + b, i32x4::from_array([11, 12, 13, 6]));\n+    assert_eq!(a - b, i32x4::from_array([9, 8, 7, 14]));\n+    assert_eq!(a * b, i32x4::from_array([10, 20, 30, -40]));\n+    assert_eq!(a / b, i32x4::from_array([10, 5, 3, -2]));\n     assert_eq!(a / i32x4::splat(2), i32x4::splat(5));\n     assert_eq!(i32x2::splat(i32::MIN) / i32x2::splat(-1), i32x2::splat(i32::MIN));\n     assert_eq!(a % b, i32x4::from_array([0, 0, 1, 2]));\n     assert_eq!(i32x2::splat(i32::MIN) % i32x2::splat(-1), i32x2::splat(0));\n-    assert_eq!(b << i32x4::splat(2), i32x4::from_array([4, 8, 12, 16]));\n-    assert_eq!(b >> i32x4::splat(1), i32x4::from_array([0, 1, 1, 2]));\n+    assert_eq!(b << i32x4::splat(2), i32x4::from_array([4, 8, 12, -16]));\n+    assert_eq!(b >> i32x4::splat(1), i32x4::from_array([0, 1, 1, -2]));\n     assert_eq!(b & i32x4::splat(2), i32x4::from_array([0, 2, 2, 0]));\n-    assert_eq!(b | i32x4::splat(2), i32x4::from_array([3, 2, 3, 6]));\n+    assert_eq!(b | i32x4::splat(2), i32x4::from_array([3, 2, 3, -2]));\n+    assert_eq!(b ^ i32x4::splat(2), i32x4::from_array([3, 0, 1, -2]));\n+\n+    // FIXME use Mask::from_array once simd_cast is implemented.\n+    assert_eq!(a.lanes_eq(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([0, -1, 0, 0])));\n+    assert_eq!(a.lanes_ne(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([-1, 0, -1, -1])));\n+    assert_eq!(a.lanes_le(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([0, -1, -1, 0])));\n+    assert_eq!(a.lanes_lt(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([0, 0, -1, 0])));\n+    assert_eq!(a.lanes_ge(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([-1, -1, 0, -1])));\n+    assert_eq!(a.lanes_gt(i32x4::splat(5)*b), Mask::from_int(i32x4::from_array([-1, 0, 0, -1])));\n }\n \n fn simd_intrinsics() {\n     extern \"platform-intrinsic\" {\n         fn simd_eq<T, U>(x: T, y: T) -> U;\n         fn simd_reduce_any<T>(x: T) -> bool;\n+        fn simd_reduce_all<T>(x: T) -> bool;\n         fn simd_select<M, T>(m: M, yes: T, no: T) -> T;\n     }\n     unsafe {\n@@ -60,6 +86,10 @@ fn simd_intrinsics() {\n \n         assert!(!simd_reduce_any(i32x4::splat(0)));\n         assert!(simd_reduce_any(i32x4::splat(-1)));\n+        assert!(simd_reduce_any(i32x2::from_array([0, -1])));\n+        assert!(!simd_reduce_all(i32x4::splat(0)));\n+        assert!(simd_reduce_all(i32x4::splat(-1)));\n+        assert!(!simd_reduce_all(i32x2::from_array([0, -1])));\n \n         assert_eq!(simd_select(i8x4::from_array([0, -1, -1, 0]), a, b), i32x4::from_array([1, 10, 10, 4]));\n         assert_eq!(simd_select(i8x4::from_array([0, -1, -1, 0]), b, a), i32x4::from_array([10, 2, 10, 10]));"}]}