{"sha": "c489636ce1236f0ff3f9b88d212f8f374e600c19", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0ODk2MzZjZTEyMzZmMGZmM2Y5Yjg4ZDIxMmY4ZjM3NGU2MDBjMTk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-15T21:56:42Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-15T21:56:42Z"}, "message": "mention that overwrite-without-drop also violates the drop guarantee, and link some more stuff", "tree": {"sha": "3983e3a28bc4730e323d55a4851a7febb6bf0560", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3983e3a28bc4730e323d55a4851a7febb6bf0560"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c489636ce1236f0ff3f9b88d212f8f374e600c19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c489636ce1236f0ff3f9b88d212f8f374e600c19", "html_url": "https://github.com/rust-lang/rust/commit/c489636ce1236f0ff3f9b88d212f8f374e600c19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c489636ce1236f0ff3f9b88d212f8f374e600c19/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b66dcb98af7c0785ace170a074640388d24e8536", "url": "https://api.github.com/repos/rust-lang/rust/commits/b66dcb98af7c0785ace170a074640388d24e8536", "html_url": "https://github.com/rust-lang/rust/commit/b66dcb98af7c0785ace170a074640388d24e8536"}], "stats": {"total": 22, "additions": 14, "deletions": 8}, "files": [{"sha": "5a9f9a42071c6e321239a127242cdcd4b1cd7d24", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c489636ce1236f0ff3f9b88d212f8f374e600c19/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c489636ce1236f0ff3f9b88d212f8f374e600c19/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=c489636ce1236f0ff3f9b88d212f8f374e600c19", "patch": "@@ -138,10 +138,11 @@\n //! To make this work, not just moving the data is restricted; deallocating, repurposing, or\n //! otherwise invalidating the memory used to store the data is restricted, too.\n //! Concretely, for pinned data you have to maintain the invariant\n-//! that *its memory will not get invalidated from the moment it gets pinned until\n+//! that *its memory will not get invalidated or repurposed from the moment it gets pinned until\n //! when `drop` is called*. Memory can be invalidated by deallocation, but also by\n //! replacing a [`Some(v)`] by [`None`], or calling [`Vec::set_len`] to \"kill\" some elements\n-//! off of a vector.\n+//! off of a vector. It can be repurposed by using [`ptr::write`] to overwrite it without\n+//! calling the destructor first.\n //!\n //! This is exactly the kind of guarantee that the intrusive linked list from the previous\n //! section needs to function correctly.\n@@ -194,7 +195,7 @@\n //! that turn `Pin<&mut Struct>` into a reference to the field, but what\n //! type should that reference have? Is it `Pin<&mut Field>` or `&mut Field`?\n //! The same question arises with the fields of an enum, and also when considering\n-//! container/wrapper types such as `Vec<T>`, `Box<T>`, or `RefCell<T>`.\n+//! container/wrapper types such as [`Vec<T>`], [`Box<T>`], or [`RefCell<T>`].\n //! Also, this question arises for both mutable and shared references, we just\n //! use the more common case of mutable references here for illustration.\n //!\n@@ -267,8 +268,8 @@\n //! 3.  You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n //!     once your struct is pinned, the memory that contains the\n //!     content is not overwritten or deallocated without calling the content's destructors.\n-//!     This can be tricky, as witnessed by `VecDeque<T>`: the destructor of `VecDeque<T>` can fail\n-//!     to call `drop` on all elements if one of the destructors panics. This violates the\n+//!     This can be tricky, as witnessed by [`VecDeque<T>`]: the destructor of `VecDeque<T>`\n+//!     can fail to call `drop` on all elements if one of the destructors panics. This violates the\n //!     `Drop` guarantee, because it can lead to elements being deallocated without\n //!     their destructor being called. (`VecDeque` has no pinning projections, so this\n //!     does not cause unsoundness.)\n@@ -279,7 +280,7 @@\n //!     that operation can be used to move a `T` out of a pinned `Struct<T>` -- which means\n //!     pinning cannot be structural for the field holding this data.\n //!\n-//!     For a more complex example of moving data out of a pinned type, imagine if `RefCell<T>`\n+//!     For a more complex example of moving data out of a pinned type, imagine if [`RefCell<T>`]\n //!     had a method `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`.\n //!     Then we could do the following:\n //!     ```compile_fail\n@@ -296,7 +297,7 @@\n //!\n //! ## Examples\n //!\n-//! For a type like `Vec<T>`, both possibilites (structural pinning or not) make sense.\n+//! For a type like [`Vec<T>`], both possibilites (structural pinning or not) make sense.\n //! A `Vec<T>` with structural pinning could have `get_pin`/`get_pin_mut` methods to get\n //! pinned references to elements. However, it could *not* allow calling\n //! `pop` on a pinned `Vec<T>` because that would move the (structurally pinned) contents!\n@@ -315,7 +316,7 @@\n //! whether the content is pinned is entirely independent of whether the pointer is\n //! pinned, meaning pinning is *not* structural.\n //!\n-//! When implementing a `Future` combinator, you will usually need structural pinning\n+//! When implementing a [`Future`] combinator, you will usually need structural pinning\n //! for the nested futures, as you need to get pinned references to them to call `poll`.\n //! But if your combinator contains any other data that does not need to be pinned,\n //! you can make those fields not structural and hence freely access them with a\n@@ -329,9 +330,14 @@\n //! [`mem::swap`]: ../../std/mem/fn.swap.html\n //! [`mem::forget`]: ../../std/mem/fn.forget.html\n //! [`Box<T>`]: ../../std/boxed/struct.Box.html\n+//! [`Vec<T>`]: ../../std/vec/struct.Vec.html\n //! [`Vec::set_len`]: ../../std/vec/struct.Vec.html#method.set_len\n+//! [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n+//! [`RefCell<T>`]: ../../std/cell/struct.RefCell.html\n //! [`None`]: ../../std/option/enum.Option.html#variant.None\n //! [`Some(v)`]: ../../std/option/enum.Option.html#variant.Some\n+//! [`ptr::write`]: ../ptr/fn.write.html\n+//! [`Future`]: ../../std/future/trait.Future.html\n //! [drop-impl]: #drop-implementation\n //! [drop-guarantee]: #drop-guarantee\n "}]}