{"sha": "2cc0008ec04153d36fd11e6172cfb39b21ca31b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjYzAwMDhlYzA0MTUzZDM2ZmQxMWU2MTcyY2ZiMzliMjFjYTMxYjI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-05T09:26:27Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-05T09:26:27Z"}, "message": "Add trans_temp_expr for what used to be trans_expr, rename t_e_dps to trans_expr\n\nIssue #667", "tree": {"sha": "1be8ab57a2c142ed312d87cfe07cc52ae3ab0fb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1be8ab57a2c142ed312d87cfe07cc52ae3ab0fb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cc0008ec04153d36fd11e6172cfb39b21ca31b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cc0008ec04153d36fd11e6172cfb39b21ca31b2", "html_url": "https://github.com/rust-lang/rust/commit/2cc0008ec04153d36fd11e6172cfb39b21ca31b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cc0008ec04153d36fd11e6172cfb39b21ca31b2/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "975ac55b3de5ead2aa841f9e9e62cb79b408d66c", "url": "https://api.github.com/repos/rust-lang/rust/commits/975ac55b3de5ead2aa841f9e9e62cb79b408d66c", "html_url": "https://github.com/rust-lang/rust/commit/975ac55b3de5ead2aa841f9e9e62cb79b408d66c"}], "stats": {"total": 133, "additions": 65, "deletions": 68}, "files": [{"sha": "86fca87afc44694f8f4c22f6a1e2dcd84365eb14", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 58, "deletions": 61, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/2cc0008ec04153d36fd11e6172cfb39b21ca31b2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc0008ec04153d36fd11e6172cfb39b21ca31b2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2cc0008ec04153d36fd11e6172cfb39b21ca31b2", "patch": "@@ -2188,15 +2188,15 @@ fn node_type(cx: @crate_ctxt, sp: span, id: ast::node_id) -> TypeRef {\n \n fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n                id: ast::node_id, dest: dest) -> @block_ctxt {\n-    if dest == ignore { ret trans_expr_dps(bcx, e, ignore); }\n+    if dest == ignore { ret trans_expr(bcx, e, ignore); }\n     let e_ty = ty::expr_ty(bcx_tcx(bcx), e);\n     alt op {\n       ast::not. {\n-        let {bcx, val} = trans_expr(bcx, e);\n+        let {bcx, val} = trans_temp_expr(bcx, e);\n         ret store_in_dest(bcx, Not(bcx, val), dest);\n       }\n       ast::neg. {\n-        let {bcx, val} = trans_expr(bcx, e);\n+        let {bcx, val} = trans_temp_expr(bcx, e);\n         let neg = if ty::struct(bcx_tcx(bcx), e_ty) == ty::ty_float {\n             FNeg(bcx, val)\n         } else { Neg(bcx, val) };\n@@ -2357,7 +2357,7 @@ fn trans_assign_op(bcx: @block_ctxt, op: ast::binop, dst: @ast::expr,\n       }\n       _ { }\n     }\n-    let {bcx, val: rhs_val} = trans_expr(lhs_res.bcx, src);\n+    let {bcx, val: rhs_val} = trans_temp_expr(lhs_res.bcx, src);\n     if ty::type_is_sequence(tcx, t) {\n         alt op {\n           ast::add. {\n@@ -2422,10 +2422,10 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n fn trans_lazy_binop(bcx: @block_ctxt, op: ast::binop, a: @ast::expr,\n                     b: @ast::expr, dest: dest) -> @block_ctxt {\n     let is_and = alt op { ast::and. { true } ast::or. { false } };\n-    let lhs_res = trans_expr(bcx, a);\n+    let lhs_res = trans_temp_expr(bcx, a);\n     if lhs_res.bcx.unreachable { ret lhs_res.bcx; }\n     let rhs_cx = new_scope_block_ctxt(lhs_res.bcx, \"rhs\");\n-    let rhs_res = trans_expr(rhs_cx, b);\n+    let rhs_res = trans_temp_expr(rhs_cx, b);\n \n     let lhs_past_cx = new_scope_block_ctxt(lhs_res.bcx, \"lhs\");\n     // The following line ensures that any cleanups for rhs\n@@ -2459,8 +2459,8 @@ fn trans_binary(cx: @block_ctxt, op: ast::binop, a: @ast::expr, b: @ast::expr,\n       }\n       _ {\n         // Remaining cases are eager:\n-        let lhs = trans_expr(cx, a);\n-        let rhs = trans_expr(lhs.bcx, b);\n+        let lhs = trans_temp_expr(cx, a);\n+        let rhs = trans_temp_expr(lhs.bcx, b);\n         ret trans_eager_binop(rhs.bcx, op, lhs.val,\n                               ty::expr_ty(bcx_tcx(cx), a), rhs.val,\n                               ty::expr_ty(bcx_tcx(cx), b), dest);\n@@ -2565,7 +2565,7 @@ fn dps_to_result(bcx: @block_ctxt,\n fn trans_if(cx: @block_ctxt, cond: @ast::expr, thn: ast::blk,\n             els: option::t<@ast::expr>, dest: dest)\n     -> @block_ctxt {\n-    let {bcx, val: cond_val} = trans_expr(cx, cond);\n+    let {bcx, val: cond_val} = trans_temp_expr(cx, cond);\n \n     let then_dest = dup_for_join(dest);\n     let else_dest = dup_for_join(dest);\n@@ -2612,7 +2612,7 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n     }\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n     let seq_ty = ty::expr_ty(bcx_tcx(cx), seq);\n-    let {bcx: bcx, val: seq} = trans_expr(cx, seq);\n+    let {bcx: bcx, val: seq} = trans_temp_expr(cx, seq);\n     let seq = PointerCast(bcx, seq, T_ptr(T_ptr(T_opaque_vec())));\n     let fill = tvec::get_fill(bcx, seq);\n     if ty::type_is_str(bcx_tcx(bcx), seq_ty) {\n@@ -2930,10 +2930,10 @@ fn trans_for_each(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n                                         llvm::LLVMGetParam(fcx.llfn, 3u),\n                                         bcx.fcx.lllocals, false);\n     let lltop = bcx.llbb;\n-    let r = trans_block(bcx, body);\n+    bcx = trans_block(bcx, body);\n     finish_fn(fcx, lltop);\n \n-    build_return(r.bcx);\n+    build_return(bcx);\n \n     // Step 3: Call iter passing [lliterbody, llenv], plus other args.\n     alt seq.node {\n@@ -2952,9 +2952,9 @@ fn trans_while(cx: @block_ctxt, cond: @ast::expr, body: ast::blk)\n         new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>, next_cx,\n                                   \"while cond\");\n     let body_cx = new_scope_block_ctxt(cond_cx, \"while loop body\");\n-    let body_res = trans_block(body_cx, body);\n-    let cond_res = trans_expr(cond_cx, cond);\n-    Br(body_res.bcx, cond_cx.llbb);\n+    let body_end = trans_block(body_cx, body);\n+    let cond_res = trans_temp_expr(cond_cx, cond);\n+    Br(body_end, cond_cx.llbb);\n     let cond_bcx = trans_block_cleanups(cond_res.bcx, cond_cx);\n     CondBr(cond_bcx, cond_res.val, body_cx.llbb, next_cx.llbb);\n     Br(cx, cond_cx.llbb);\n@@ -2967,8 +2967,8 @@ fn trans_do_while(cx: @block_ctxt, body: ast::blk, cond: @ast::expr) ->\n     let body_cx =\n         new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>, next_cx,\n                                   \"do-while loop body\");\n-    let body_res = trans_block(body_cx, body);\n-    let cond_res = trans_expr(body_res.bcx, cond);\n+    let body_end = trans_block(body_cx, body);\n+    let cond_res = trans_temp_expr(body_end, cond);\n     CondBr(cond_res.bcx, cond_res.val, body_cx.llbb, next_cx.llbb);\n     Br(cx, body_cx.llbb);\n     ret next_cx;\n@@ -3148,7 +3148,7 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n \n fn trans_object_field(bcx: @block_ctxt, o: @ast::expr, field: ast::ident)\n     -> {bcx: @block_ctxt, mthptr: ValueRef, objptr: ValueRef} {\n-    let {bcx, val} = trans_expr(bcx, o);\n+    let {bcx, val} = trans_temp_expr(bcx, o);\n     let {bcx, val, ty} = autoderef(bcx, val, ty::expr_ty(bcx_tcx(bcx), o));\n     ret trans_object_field_inner(bcx, val, field, ty);\n }\n@@ -3181,7 +3181,7 @@ fn trans_object_field_inner(bcx: @block_ctxt, o: ValueRef,\n \n fn trans_rec_field(bcx: @block_ctxt, base: @ast::expr,\n                    field: ast::ident) -> lval_result {\n-    let {bcx, val} = trans_expr(bcx, base);\n+    let {bcx, val} = trans_temp_expr(bcx, base);\n     let {bcx, val, ty} = autoderef(bcx, val, ty::expr_ty(bcx_tcx(bcx), base));\n     let fields = alt ty::struct(bcx_tcx(bcx), ty) { ty::ty_rec(fs) { fs } };\n     let ix = ty::field_idx(bcx_ccx(bcx).sess, bcx.sp, field, fields);\n@@ -3196,9 +3196,9 @@ fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n     // Is this an interior vector?\n \n     let base_ty = ty::expr_ty(bcx_tcx(cx), base);\n-    let exp = trans_expr(cx, base);\n+    let exp = trans_temp_expr(cx, base);\n     let lv = autoderef(exp.bcx, exp.val, base_ty);\n-    let ix = trans_expr(lv.bcx, idx);\n+    let ix = trans_temp_expr(lv.bcx, idx);\n     let v = lv.val;\n     let bcx = ix.bcx;\n     // Cast to an LLVM integer. Rust is less strict than LLVM in this regard.\n@@ -3303,7 +3303,7 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n       }\n       ast::expr_unary(ast::deref., base) {\n         let ccx = bcx_ccx(cx);\n-        let sub = trans_expr(cx, base);\n+        let sub = trans_temp_expr(cx, base);\n         let t = ty::expr_ty(ccx.tcx, base);\n         let val =\n             alt ty::struct(ccx.tcx, t) {\n@@ -3334,14 +3334,16 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n             let bcx = trans_call(cx, f, none, args, e.id, by_val(cell));\n             ret lval_mem(bcx, *cell);\n         } else { // By-value return\n+            // FIXME[DPS] this will disappear when trans_lval only handles\n+            // lvals\n             let {bcx, val} = dps_to_result(cx, {|bcx, dest|\n                 trans_call(bcx, f, none, args, e.id, dest) },\n                                            ty::expr_ty(bcx_tcx(cx), e));\n             ret lval_val(bcx, val);\n         }\n       }\n       _ {\n-        let res = trans_expr(cx, e);\n+        let res = trans_temp_expr(cx, e);\n         ret lval_val(res.bcx, res.val);\n       }\n     }\n@@ -3406,7 +3408,7 @@ fn float_cast(bcx: @block_ctxt, lldsttype: TypeRef, llsrctype: TypeRef,\n fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n               dest: dest) -> @block_ctxt {\n     let ccx = bcx_ccx(cx);\n-    let e_res = trans_expr(cx, e);\n+    let e_res = trans_temp_expr(cx, e);\n     let ll_t_in = val_ty(e_res.val);\n     let t_in = ty::expr_ty(ccx.tcx, e);\n     let t_out = node_id_type(ccx, id);\n@@ -3664,7 +3666,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n     }\n     let bcx = f_res.bcx;\n     if dest == ignore {\n-        for ex in bound { bcx = trans_expr_dps(bcx, ex, ignore); }\n+        for ex in bound { bcx = trans_expr(bcx, ex, ignore); }\n         ret bcx;\n     }\n \n@@ -4169,7 +4171,7 @@ fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n     let t = node_id_type(bcx.fcx.lcx.ccx, id);\n     let addr = alt dest {\n       ignore. {\n-        for ex in elts { bcx = trans_expr_dps(bcx, ex, ignore); }\n+        for ex in elts { bcx = trans_expr(bcx, ex, ignore); }\n         ret bcx;\n       }\n       save_in(pos) { pos }\n@@ -4194,7 +4196,7 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n     let addr = alt dest {\n       ignore. {\n         for fld in fields {\n-            bcx = trans_expr_dps(bcx, fld.node.expr, ignore);\n+            bcx = trans_expr(bcx, fld.node.expr, ignore);\n         }\n         ret bcx;\n       }\n@@ -4203,7 +4205,7 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n \n     let base_val = alt base {\n       some(bexp) {\n-        let base_res = trans_expr(bcx, bexp);\n+        let base_res = trans_temp_expr(bcx, bexp);\n         bcx = base_res.bcx;\n         base_res.val\n       }\n@@ -4235,57 +4237,53 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n     ret bcx;\n }\n \n-// FIXME[DPS] remove this entirely, rename trans_expr_dps to trans_expr\n-fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n-    if expr_is_lval(bcx_tcx(cx), e) {\n-        let t = ty::expr_ty(bcx_tcx(cx), e);\n-        let sub = trans_lval(cx, e);\n-        let v = sub.val;\n-        if sub.is_mem { v = load_if_immediate(sub.bcx, v, t); }\n-        ret rslt(sub.bcx, v);\n-    } else {\n-        // Fall through to DPS-style\n-        ret dps_to_result(cx, {|bcx, dest| trans_expr_dps(bcx, e, dest)},\n-                          ty::expr_ty(bcx_tcx(cx), e));\n-    }\n-}\n-\n fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n     -> @block_ctxt {\n     let tcx = bcx_tcx(bcx), t = ty::expr_ty(tcx, e);\n     let dst = if ty::type_is_bot(tcx, t) || ty::type_is_nil(tcx, t) {\n         ignore\n     } else { save_in(dest) };\n-    ret trans_expr_dps(bcx, e, dst);\n+    ret trans_expr(bcx, e, dst);\n }\n \n-fn trans_temp_expr(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n+fn trans_temp_lval(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n     if expr_is_lval(bcx_tcx(bcx), e) {\n         ret trans_lval(bcx, e);\n     } else {\n         let tcx = bcx_tcx(bcx);\n         let ty = ty::expr_ty(tcx, e);\n         if ty::type_is_nil(tcx, ty) || ty::type_is_bot(tcx, ty) {\n-            bcx = trans_expr_dps(bcx, e, ignore);\n+            bcx = trans_expr(bcx, e, ignore);\n             ret {bcx: bcx, val: C_nil(), is_mem: false};\n         } else if type_is_immediate(bcx_ccx(bcx), ty) {\n             let cell = empty_dest_cell();\n-            bcx = trans_expr_dps(bcx, e, by_val(cell));\n+            bcx = trans_expr(bcx, e, by_val(cell));\n+            add_clean_temp(bcx, *cell, ty);\n             ret {bcx: bcx, val: *cell, is_mem: false};\n         } else {\n             let {bcx, val: scratch} = alloc_ty(bcx, ty);\n-            bcx = trans_expr_dps(bcx, e, save_in(scratch));\n+            bcx = trans_expr(bcx, e, save_in(scratch));\n+            add_clean_temp(bcx, scratch, ty);\n             ret {bcx: bcx, val: scratch, is_mem: false};\n         }\n     }\n }\n \n+fn trans_temp_expr(bcx: @block_ctxt, e: @ast::expr) -> result {\n+    let {bcx, val, is_mem} = trans_temp_lval(bcx, e);\n+    if is_mem && type_is_immediate(bcx_ccx(bcx),\n+                                   ty::expr_ty(bcx_tcx(bcx), e)) {\n+        val = Load(bcx, val);\n+    }\n+    ret {bcx: bcx, val: val};\n+}\n+\n // Invariants:\n // - things returning nil get dest=ignore\n // - any lvalue expr may be given dest=by_ref\n // - exprs returning an immediate get by_val (or by_ref when lval)\n // - exprs returning non-immediates get save_in (or by_ref when lval)\n-fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n+fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n     -> @block_ctxt {\n     let tcx = bcx_tcx(bcx);\n     if expr_is_lval(tcx, e) { ret lval_to_dps(bcx, e, dest); }\n@@ -4295,7 +4293,7 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n         ret trans_if(bcx, cond, thn, els, dest);\n       }\n       ast::expr_ternary(_, _, _) {\n-        ret trans_expr_dps(bcx, ast_util::ternary_to_if(e), dest);\n+        ret trans_expr(bcx, ast_util::ternary_to_if(e), dest);\n       }\n       ast::expr_alt(expr, arms) {\n         ret trans_alt::trans_alt(bcx, expr, arms, dest);\n@@ -4323,7 +4321,7 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n       ast::expr_fn(f) { ret trans_expr_fn(bcx, f, e.span, e.id, dest); }\n       ast::expr_bind(f, args) { ret trans_bind(bcx, f, args, e.id, dest); }\n       ast::expr_copy(a) {\n-        if !expr_is_lval(tcx, a) { ret trans_expr_dps(bcx, a, dest); }\n+        if !expr_is_lval(tcx, a) { ret trans_expr(bcx, a, dest); }\n         else { ret lval_to_dps(bcx, a, dest); }\n       }\n       ast::expr_cast(val, _) { ret trans_cast(bcx, val, e.id, dest); }\n@@ -4416,7 +4414,7 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n       }\n       ast::expr_assign(dst, src) {\n         assert dest == ignore;\n-        let src_r = trans_temp_expr(bcx, src);\n+        let src_r = trans_temp_lval(bcx, src);\n         let {bcx, val: addr, is_mem} = trans_lval(src_r.bcx, dst);\n         assert is_mem;\n         ret move_val_if_temp(bcx, DROP_EXISTING, addr, src_r,\n@@ -4425,7 +4423,7 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n       ast::expr_move(dst, src) {\n         // FIXME: calculate copy init-ness in typestate.\n         assert dest == ignore;\n-        let src_r = trans_temp_expr(bcx, src);\n+        let src_r = trans_temp_lval(bcx, src);\n         let {bcx, val: addr, is_mem} = trans_lval(src_r.bcx, dst);\n         assert is_mem;\n         ret move_val(bcx, DROP_EXISTING, addr, src_r,\n@@ -4545,7 +4543,7 @@ fn trans_log(lvl: int, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n     let load = Load(cx, global);\n     let test = ICmp(cx, lib::llvm::LLVMIntSGE, load, C_int(lvl));\n     CondBr(cx, test, log_cx.llbb, after_cx.llbb);\n-    let sub = trans_expr(log_cx, e);\n+    let sub = trans_temp_expr(log_cx, e);\n     let e_ty = ty::expr_ty(bcx_tcx(cx), e);\n     let log_bcx = sub.bcx;\n \n@@ -4569,7 +4567,7 @@ fn trans_log(lvl: int, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n }\n \n fn trans_check_expr(cx: @block_ctxt, e: @ast::expr, s: str) -> @block_ctxt {\n-    let cond_res = trans_expr(cx, e);\n+    let cond_res = trans_temp_expr(cx, e);\n     let expr_str = s + \" \" + expr_to_str(e) + \" failed\";\n     let fail_cx = new_sub_block_ctxt(cx, \"fail\");\n     trans_fail(fail_cx, some::<span>(e.span), expr_str);\n@@ -4583,7 +4581,7 @@ fn trans_fail_expr(bcx: @block_ctxt, sp_opt: option::t<span>,\n     alt fail_expr {\n       some(expr) {\n         let tcx = bcx_tcx(bcx);\n-        let expr_res = trans_expr(bcx, expr);\n+        let expr_res = trans_temp_expr(bcx, expr);\n         let e_ty = ty::expr_ty(tcx, expr);\n         bcx = expr_res.bcx;\n \n@@ -4806,7 +4804,7 @@ fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> @block_ctxt {\n \n     let bcx = cx;\n     alt s.node {\n-      ast::stmt_expr(e, _) { bcx = trans_expr_dps(cx, e, ignore); }\n+      ast::stmt_expr(e, _) { bcx = trans_expr(cx, e, ignore); }\n       ast::stmt_decl(d, _) {\n         alt d.node {\n           ast::decl_local(locals) {\n@@ -5023,9 +5021,8 @@ fn alloc_local(cx: @block_ctxt, local: @ast::local) -> result {\n     ret r;\n }\n \n-fn trans_block(bcx: @block_ctxt, b: ast::blk) -> result {\n-    dps_to_result(bcx, {|bcx, dest| trans_block_dps(bcx, b, dest)},\n-                  ty::node_id_to_type(bcx_tcx(bcx), b.node.id))\n+fn trans_block(bcx: @block_ctxt, b: ast::blk) -> @block_ctxt {\n+    trans_block_dps(bcx, b, ignore)\n }\n \n fn trans_block_dps(bcx: @block_ctxt, b: ast::blk, dest: dest)\n@@ -5042,7 +5039,7 @@ fn trans_block_dps(bcx: @block_ctxt, b: ast::blk, dest: dest)\n     alt b.node.expr {\n       some(e) {\n         let bt = ty::type_is_bot(bcx_tcx(bcx), ty::expr_ty(bcx_tcx(bcx), e));\n-        bcx = trans_expr_dps(bcx, e, bt ? ignore : dest);\n+        bcx = trans_expr(bcx, e, bt ? ignore : dest);\n       }\n       _ { assert dest == ignore || bcx.unreachable; }\n     }"}, {"sha": "3414266c57a616aa654c9b698abfd6c07f4a86f4", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cc0008ec04153d36fd11e6172cfb39b21ca31b2/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc0008ec04153d36fd11e6172cfb39b21ca31b2/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=2cc0008ec04153d36fd11e6172cfb39b21ca31b2", "patch": "@@ -361,7 +361,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n                                         option::get(assoc(key, m[0].bound)));\n             }\n             let {bcx: guard_bcx, val: guard_val} =\n-                trans::trans_expr(guard_cx, e);\n+                trans::trans_temp_expr(guard_cx, e);\n             guard_bcx = trans::trans_block_cleanups(guard_bcx, guard_cx);\n             let next_cx = new_sub_block_ctxt(guard_cx, \"submatch_next\");\n             let else_cx = new_sub_block_ctxt(guard_cx, \"submatch_else\");\n@@ -620,7 +620,7 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms: [ast::arm],\n              dest: trans::dest) -> @block_ctxt {\n     let bodies = [];\n     let match: match = [];\n-    let er = trans::trans_expr(cx, expr);\n+    let er = trans::trans_temp_expr(cx, expr);\n     if er.bcx.unreachable { ret er.bcx; }\n \n     for a: ast::arm in arms {"}, {"sha": "3c42ce473dddbde07bc29efadaf3d3acc4deb25a", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2cc0008ec04153d36fd11e6172cfb39b21ca31b2/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc0008ec04153d36fd11e6172cfb39b21ca31b2/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=2cc0008ec04153d36fd11e6172cfb39b21ca31b2", "patch": "@@ -216,7 +216,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n                   id: ast::node_id, dest: trans::dest) -> @block_ctxt {\n     if dest == trans::ignore {\n         alt anon_obj.inner_obj {\n-          some(e) { ret trans::trans_expr_dps(bcx, e, trans::ignore); }\n+          some(e) { ret trans::trans_expr(bcx, e, trans::ignore); }\n           none. { ret bcx; }\n         }\n     }\n@@ -234,7 +234,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n         additional_fields = fields;\n         for f: ast::anon_obj_field in fields {\n             additional_field_tys += [node_id_type(ccx, f.id)];\n-            additional_field_vals += [trans_expr(bcx, f.expr)];\n+            additional_field_vals += [trans_temp_expr(bcx, f.expr)];\n         }\n       }\n     }\n@@ -363,7 +363,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n             // If inner_obj (the object being extended) exists, translate it.\n             // Translating inner_obj returns a ValueRef (pointer to a 2-word\n             // value) wrapped in a result.\n-            let inner_obj_val: result = trans_expr(bcx, e);\n+            let inner_obj_val: result = trans_temp_expr(bcx, e);\n \n             check type_is_tup_like(bcx, body_ty);\n             let body_inner_obj ="}, {"sha": "f76a7e96376a07cd62c19569ed145d1077255885", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cc0008ec04153d36fd11e6172cfb39b21ca31b2/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cc0008ec04153d36fd11e6172cfb39b21ca31b2/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=2cc0008ec04153d36fd11e6172cfb39b21ca31b2", "patch": "@@ -104,7 +104,7 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n     if dest == trans::ignore {\n         for arg in args {\n-            bcx = trans::trans_expr_dps(bcx, arg, trans::ignore);\n+            bcx = trans::trans_expr(bcx, arg, trans::ignore);\n         }\n         ret bcx;\n     }\n@@ -209,7 +209,7 @@ fn trans_append_literal(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n     trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n     let opaque_v = PointerCast(bcx, vptrptr, T_ptr(T_ptr(T_opaque_vec())));\n     for val in vals {\n-        let {bcx: e_bcx, val: elt} = trans::trans_expr(bcx, val);\n+        let {bcx: e_bcx, val: elt} = trans::trans_temp_expr(bcx, val);\n         bcx = e_bcx;\n         let r = trans::spill_if_immediate(bcx, elt, elt_ty);\n         let spilled = r.val;"}]}