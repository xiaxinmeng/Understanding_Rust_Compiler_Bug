{"sha": "057243f16b4f42337b6178a627dcf3ae4c09f056", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NzI0M2YxNmI0ZjQyMzM3YjYxNzhhNjI3ZGNmM2FlNGMwOWYwNTY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-10-02T10:51:38Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-10-02T10:51:38Z"}, "message": "relicensing: Remove map_clone\n\nThis removes the code added in https://github.com/rust-lang-nursery/rust-clippy/pull/427", "tree": {"sha": "3b1cdc823960b70d9396889800939539d7f690ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b1cdc823960b70d9396889800939539d7f690ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/057243f16b4f42337b6178a627dcf3ae4c09f056", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/057243f16b4f42337b6178a627dcf3ae4c09f056", "html_url": "https://github.com/rust-lang/rust/commit/057243f16b4f42337b6178a627dcf3ae4c09f056", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/057243f16b4f42337b6178a627dcf3ae4c09f056/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fffcd093b29a3fa4be22d3836f214cd810836c21", "url": "https://api.github.com/repos/rust-lang/rust/commits/fffcd093b29a3fa4be22d3836f214cd810836c21", "html_url": "https://github.com/rust-lang/rust/commit/fffcd093b29a3fa4be22d3836f214cd810836c21"}], "stats": {"total": 351, "additions": 0, "deletions": 351}, "files": [{"sha": "689dbfa7da96938bd5c10196ff3c9bc35f05f5c9", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/057243f16b4f42337b6178a627dcf3ae4c09f056/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/057243f16b4f42337b6178a627dcf3ae4c09f056/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=057243f16b4f42337b6178a627dcf3ae4c09f056", "patch": "@@ -129,7 +129,6 @@ pub mod let_if_seq;\n pub mod lifetimes;\n pub mod literal_representation;\n pub mod loops;\n-pub mod map_clone;\n pub mod map_unit_fn;\n pub mod matches;\n pub mod mem_forget;\n@@ -346,7 +345,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n     reg.register_late_lint_pass(box needless_borrow::NeedlessBorrow);\n     reg.register_late_lint_pass(box needless_borrowed_ref::NeedlessBorrowedRef);\n     reg.register_late_lint_pass(box no_effect::Pass);\n-    reg.register_late_lint_pass(box map_clone::Pass);\n     reg.register_late_lint_pass(box temporary_assignment::Pass);\n     reg.register_late_lint_pass(box transmute::Transmute);\n     reg.register_late_lint_pass(\n@@ -585,7 +583,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         loops::WHILE_IMMUTABLE_CONDITION,\n         loops::WHILE_LET_LOOP,\n         loops::WHILE_LET_ON_ITERATOR,\n-        map_clone::MAP_CLONE,\n         map_unit_fn::OPTION_MAP_UNIT_FN,\n         map_unit_fn::RESULT_MAP_UNIT_FN,\n         matches::MATCH_AS_REF,\n@@ -745,7 +742,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         loops::FOR_KV_MAP,\n         loops::NEEDLESS_RANGE_LOOP,\n         loops::WHILE_LET_ON_ITERATOR,\n-        map_clone::MAP_CLONE,\n         matches::MATCH_BOOL,\n         matches::MATCH_OVERLAPPING_ARM,\n         matches::MATCH_REF_PATS,"}, {"sha": "239602c6db5ef6d54c6eef26967e649daef9313f", "filename": "clippy_lints/src/map_clone.rs", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/fffcd093b29a3fa4be22d3836f214cd810836c21/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fffcd093b29a3fa4be22d3836f214cd810836c21/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=fffcd093b29a3fa4be22d3836f214cd810836c21", "patch": "@@ -1,140 +0,0 @@\n-use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use crate::rustc::{declare_tool_lint, lint_array};\n-use if_chain::if_chain;\n-use crate::rustc::hir::*;\n-use crate::rustc::ty;\n-use crate::syntax::ast;\n-use crate::utils::{get_arg_ident, is_adjusted, iter_input_pats, match_qpath, match_trait_method, match_type,\n-            paths, remove_blocks, snippet, span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq};\n-\n-/// **What it does:** Checks for mapping `clone()` over an iterator.\n-///\n-/// **Why is this bad?** It makes the code less readable than using the\n-/// `.cloned()` adapter.\n-///\n-/// **Known problems:** Sometimes `.cloned()` requires stricter trait\n-/// bound than `.map(|e| e.clone())` (which works because of the coercion).\n-/// See [#498](https://github.com/rust-lang-nursery/rust-clippy/issues/498).\n-///\n-/// **Example:**\n-/// ```rust\n-/// x.map(|e| e.clone());\n-/// ```\n-declare_clippy_lint! {\n-    pub MAP_CLONE,\n-    style,\n-    \"using `.map(|x| x.clone())` to clone an iterator or option's contents\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct Pass;\n-\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        // call to .map()\n-        if let ExprKind::MethodCall(ref method, _, ref args) = expr.node {\n-            if method.ident.name == \"map\" && args.len() == 2 {\n-                match args[1].node {\n-                    ExprKind::Closure(_, ref decl, closure_eid, _, _) => {\n-                        let body = cx.tcx.hir.body(closure_eid);\n-                        let closure_expr = remove_blocks(&body.value);\n-                        if_chain! {\n-                            // nothing special in the argument, besides reference bindings\n-                            // (e.g. .map(|&x| x) )\n-                            if let Some(first_arg) = iter_input_pats(decl, body).next();\n-                            if let Some(arg_ident) = get_arg_ident(&first_arg.pat);\n-                            // the method is being called on a known type (option or iterator)\n-                            if let Some(type_name) = get_type_name(cx, expr, &args[0]);\n-                            then {\n-                                // We know that body.arguments is not empty at this point\n-                                let ty = cx.tables.pat_ty(&body.arguments[0].pat);\n-                                // look for derefs, for .map(|x| *x)\n-                                if only_derefs(cx, &*closure_expr, arg_ident) &&\n-                                    // .cloned() only removes one level of indirection, don't lint on more\n-                                    walk_ptrs_ty_depth(cx.tables.pat_ty(&first_arg.pat)).1 == 1\n-                                {\n-                                    // the argument is not an &mut T\n-                                    if let ty::Ref(_, _, mutbl) = ty.sty {\n-                                        if mutbl == MutImmutable {\n-                                            span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n-                                                \"you seem to be using .map() to clone the contents of an {}, consider \\\n-                                                using `.cloned()`\", type_name),\n-                                                &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n-                                        }\n-                                    }\n-                                }\n-                                // explicit clone() calls ( .map(|x| x.clone()) )\n-                                else if let ExprKind::MethodCall(ref clone_call, _, ref clone_args) = closure_expr.node {\n-                                    if clone_call.ident.name == \"clone\" &&\n-                                        clone_args.len() == 1 &&\n-                                        match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n-                                        expr_eq_name(cx, &clone_args[0], arg_ident)\n-                                    {\n-                                        span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n-                                            \"you seem to be using .map() to clone the contents of an {}, consider \\\n-                                            using `.cloned()`\", type_name),\n-                                            &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    },\n-                    ExprKind::Path(ref path) => if match_qpath(path, &paths::CLONE) {\n-                        let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n-                        span_help_and_lint(\n-                            cx,\n-                            MAP_CLONE,\n-                            expr.span,\n-                            &format!(\n-                                \"you seem to be using .map() to clone the contents of an \\\n-                                 {}, consider using `.cloned()`\",\n-                                type_name\n-                            ),\n-                            &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")),\n-                        );\n-                    },\n-                    _ => (),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn expr_eq_name(cx: &LateContext<'_, '_>, expr: &Expr, id: ast::Ident) -> bool {\n-    match expr.node {\n-        ExprKind::Path(QPath::Resolved(None, ref path)) => {\n-            let arg_segment = [\n-                PathSegment {\n-                    ident: id,\n-                    args: None,\n-                    infer_types: true,\n-                },\n-            ];\n-            !path.is_global() && SpanlessEq::new(cx).eq_path_segments(&path.segments[..], &arg_segment)\n-        },\n-        _ => false,\n-    }\n-}\n-\n-fn get_type_name(cx: &LateContext<'_, '_>, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n-    if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        Some(\"iterator\")\n-    } else if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(arg)), &paths::OPTION) {\n-        Some(\"Option\")\n-    } else {\n-        None\n-    }\n-}\n-\n-fn only_derefs(cx: &LateContext<'_, '_>, expr: &Expr, id: ast::Ident) -> bool {\n-    match expr.node {\n-        ExprKind::Unary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),\n-        _ => expr_eq_name(cx, expr, id),\n-    }\n-}\n-\n-impl LintPass for Pass {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(MAP_CLONE)\n-    }\n-}"}, {"sha": "90c95be2c1c1cfbb1a4d2d8660a2fd946b8e4f42", "filename": "tests/ui/map_clone.rs", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/fffcd093b29a3fa4be22d3836f214cd810836c21/tests%2Fui%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fffcd093b29a3fa4be22d3836f214cd810836c21/tests%2Fui%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_clone.rs?ref=fffcd093b29a3fa4be22d3836f214cd810836c21", "patch": "@@ -1,105 +0,0 @@\n-#![feature(tool_lints)]\n-\n-\n-#![warn(clippy::map_clone)]\n-\n-#![allow(clippy::clone_on_copy, unused)]\n-\n-use std::ops::Deref;\n-\n-fn map_clone_iter() {\n-    let x = [1,2,3];\n-    x.iter().map(|y| y.clone());\n-\n-    x.iter().map(|&y| y);\n-\n-    x.iter().map(|y| *y);\n-\n-    x.iter().map(|y| { y.clone() });\n-\n-    x.iter().map(|&y| { y });\n-\n-    x.iter().map(|y| { *y });\n-\n-    x.iter().map(Clone::clone);\n-\n-}\n-\n-fn map_clone_option() {\n-    let x = Some(4);\n-    x.as_ref().map(|y| y.clone());\n-\n-    x.as_ref().map(|&y| y);\n-\n-    x.as_ref().map(|y| *y);\n-\n-}\n-\n-fn not_linted_option() {\n-    let x = Some(5);\n-\n-    // Not linted: other statements\n-    x.as_ref().map(|y| {\n-        println!(\"y: {}\", y);\n-        y.clone()\n-    });\n-\n-    // Not linted: argument bindings\n-    let x = Some((6, 7));\n-    x.map(|(y, _)| y.clone());\n-\n-    // Not linted: cloning something else\n-    x.map(|y| y.0.clone());\n-\n-    // Not linted: no dereferences\n-    x.map(|y| y);\n-\n-    // Not linted: multiple dereferences\n-    let _: Option<(i32, i32)> = x.as_ref().as_ref().map(|&&x| x);\n-}\n-\n-#[derive(Copy, Clone)]\n-struct Wrapper<T>(T);\n-impl<T> Wrapper<T> {\n-    fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Wrapper<U> {\n-        Wrapper(f(self.0))\n-    }\n-}\n-\n-fn map_clone_other() {\n-    let eight = 8;\n-    let x = Wrapper(&eight);\n-\n-    // Not linted: not a linted type\n-    x.map(|y| y.clone());\n-    x.map(|&y| y);\n-    x.map(|y| *y);\n-}\n-\n-#[derive(Copy, Clone)]\n-struct UnusualDeref;\n-static NINE: i32 = 9;\n-\n-impl Deref for UnusualDeref {\n-    type Target = i32;\n-    fn deref(&self) -> &i32 { &NINE }\n-}\n-\n-fn map_clone_deref() {\n-    let x = Some(UnusualDeref);\n-    let _: Option<UnusualDeref> = x.as_ref().map(|y| *y);\n-\n-\n-    // Not linted: using deref conversion\n-    let _: Option<i32> = x.map(|y| *y);\n-\n-    // Not linted: using regular deref but also deref conversion\n-    let _: Option<i32> = x.as_ref().map(|y| **y);\n-}\n-\n-// stuff that used to be a false positive\n-fn former_false_positive() {\n-    vec![1].iter_mut().map(|x| *x); // #443\n-}\n-\n-fn main() { }"}, {"sha": "afad65b007101b06ccd045b746455873e9a30102", "filename": "tests/ui/map_clone.stderr", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/fffcd093b29a3fa4be22d3836f214cd810836c21/tests%2Fui%2Fmap_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fffcd093b29a3fa4be22d3836f214cd810836c21/tests%2Fui%2Fmap_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_clone.stderr?ref=fffcd093b29a3fa4be22d3836f214cd810836c21", "patch": "@@ -1,102 +0,0 @@\n-error: you seem to be using .map() to clone the contents of an iterator, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:12:5\n-   |\n-12 |     x.iter().map(|y| y.clone());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::map-clone` implied by `-D warnings`\n-   = help: try\n-           x.iter().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an iterator, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:14:5\n-   |\n-14 |     x.iter().map(|&y| y);\n-   |     ^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.iter().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an iterator, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:16:5\n-   |\n-16 |     x.iter().map(|y| *y);\n-   |     ^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.iter().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an iterator, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:18:5\n-   |\n-18 |     x.iter().map(|y| { y.clone() });\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.iter().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an iterator, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:20:5\n-   |\n-20 |     x.iter().map(|&y| { y });\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.iter().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an iterator, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:22:5\n-   |\n-22 |     x.iter().map(|y| { *y });\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.iter().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an iterator, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:24:5\n-   |\n-24 |     x.iter().map(Clone::clone);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.iter().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an Option, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:30:5\n-   |\n-30 |     x.as_ref().map(|y| y.clone());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.as_ref().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an Option, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:32:5\n-   |\n-32 |     x.as_ref().map(|&y| y);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.as_ref().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an Option, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:34:5\n-   |\n-34 |     x.as_ref().map(|y| *y);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.as_ref().cloned()\n-\n-error: you seem to be using .map() to clone the contents of an Option, consider using `.cloned()`\n-  --> $DIR/map_clone.rs:90:35\n-   |\n-90 |     let _: Option<UnusualDeref> = x.as_ref().map(|y| *y);\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: try\n-           x.as_ref().cloned()\n-\n-error: aborting due to 11 previous errors\n-"}]}