{"sha": "260e46115b922d29ca98b3cbea190011b1d3e63f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MGU0NjExNWI5MjJkMjljYTk4YjNjYmVhMTkwMDExYjFkM2U2M2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-04T16:36:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-04T16:36:41Z"}, "message": "auto merge of #20443 : nikomatsakis/rust/autoderef-overloaded-calls, r=pcwalton\n\nUse autoderef for call notation. This is consistent in that we now autoderef all postfix operators (`.`, `[]`, and `()`). It also means you can call closures without writing `(*f)()`. Note that this is rebased atop the rollup, so only the final commit is relevant.\r\n\r\nr? @pcwalton", "tree": {"sha": "69c371282c03e1dec8830ad1bbc47bf1cafab2ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69c371282c03e1dec8830ad1bbc47bf1cafab2ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/260e46115b922d29ca98b3cbea190011b1d3e63f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/260e46115b922d29ca98b3cbea190011b1d3e63f", "html_url": "https://github.com/rust-lang/rust/commit/260e46115b922d29ca98b3cbea190011b1d3e63f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/260e46115b922d29ca98b3cbea190011b1d3e63f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e21e17d9638d14af41e27e5ca9a21c8a1bc0170", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e21e17d9638d14af41e27e5ca9a21c8a1bc0170", "html_url": "https://github.com/rust-lang/rust/commit/5e21e17d9638d14af41e27e5ca9a21c8a1bc0170"}, {"sha": "dc97247d112dc77bd709417d6bc870bbcfde9b54", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc97247d112dc77bd709417d6bc870bbcfde9b54", "html_url": "https://github.com/rust-lang/rust/commit/dc97247d112dc77bd709417d6bc870bbcfde9b54"}], "stats": {"total": 403, "additions": 268, "deletions": 135}, "files": [{"sha": "de81f307c4d7cfb5286672806ee9f29f784e7a8c", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=260e46115b922d29ca98b3cbea190011b1d3e63f", "patch": "@@ -509,7 +509,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         let method_call = ty::MethodCall::expr(call_expr.id);\n         let return_ty = ty::ty_fn_ret(match self.tcx.method_map.borrow().get(&method_call) {\n             Some(method) => method.ty,\n-            None => ty::expr_ty(self.tcx, func_or_rcvr)\n+            None => ty::expr_ty_adjusted(self.tcx, func_or_rcvr)\n         });\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);"}, {"sha": "77875139be3a3fd5f22d9436a019b44afaba3971", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=260e46115b922d29ca98b3cbea190011b1d3e63f", "patch": "@@ -1149,7 +1149,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           ast::ExprCall(ref f, ref args) => {\n             let diverges = !self.ir.tcx.is_method_call(expr.id) && {\n-                let t_ret = ty::ty_fn_ret(ty::expr_ty(self.ir.tcx, &**f));\n+                let t_ret = ty::ty_fn_ret(ty::expr_ty_adjusted(self.ir.tcx, &**f));\n                 t_ret == ty::FnDiverging\n             };\n             let succ = if diverges {"}, {"sha": "2e244ea0d039d3c2bf8ef5af03a2bb95762a9754", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=260e46115b922d29ca98b3cbea190011b1d3e63f", "patch": "@@ -576,7 +576,7 @@ pub fn trans_call<'a, 'blk, 'tcx>(in_cx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_call\");\n     trans_call_inner(in_cx,\n                      Some(common::expr_info(call_ex)),\n-                     expr_ty(in_cx, f),\n+                     expr_ty_adjusted(in_cx, f),\n                      |cx, _| trans(cx, f),\n                      args,\n                      Some(dest)).bcx"}, {"sha": "153c6463fbebb84c0601638e672c3c08f0dbb01d", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=260e46115b922d29ca98b3cbea190011b1d3e63f", "patch": "@@ -8,8 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use super::autoderef;\n+use super::AutorefArgs;\n+use super::check_argument_types;\n+use super::check_expr;\n+use super::check_method_argument_types;\n+use super::err_args;\n+use super::FnCtxt;\n+use super::LvaluePreference;\n+use super::method;\n+use super::structurally_resolved_type;\n+use super::TupleArgumentsFlag;\n+use super::write_call;\n+\n+use middle::infer;\n+use middle::ty::{mod, Ty};\n use syntax::ast;\n use syntax::codemap::Span;\n+use syntax::parse::token;\n+use syntax::ptr::P;\n use CrateCtxt;\n \n /// Check that it is legal to call methods of the trait corresponding\n@@ -44,3 +61,165 @@ pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id:\n                    \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n     }\n }\n+\n+pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                            call_expr: &ast::Expr,\n+                            callee_expr: &ast::Expr,\n+                            arg_exprs: &[P<ast::Expr>])\n+{\n+    check_expr(fcx, callee_expr);\n+    let original_callee_ty = fcx.expr_ty(callee_expr);\n+    let (callee_ty, _, result) =\n+        autoderef(fcx,\n+                  callee_expr.span,\n+                  original_callee_ty,\n+                  Some(callee_expr.id),\n+                  LvaluePreference::NoPreference,\n+                  |adj_ty, idx| {\n+                      let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };\n+                      try_overloaded_call_step(fcx, call_expr, callee_expr,\n+                                               adj_ty, autoderefref)\n+                  });\n+\n+    match result {\n+        None => {\n+            // this will report an error since original_callee_ty is not a fn\n+            confirm_builtin_call(fcx, call_expr, original_callee_ty, arg_exprs);\n+        }\n+\n+        Some(CallStep::Builtin) => {\n+            confirm_builtin_call(fcx, call_expr, callee_ty, arg_exprs);\n+        }\n+\n+        Some(CallStep::Overloaded(method_callee)) => {\n+            confirm_overloaded_call(fcx, call_expr, arg_exprs, method_callee);\n+        }\n+    }\n+}\n+\n+enum CallStep<'tcx> {\n+    Builtin,\n+    Overloaded(ty::MethodCallee<'tcx>)\n+}\n+\n+fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                      call_expr: &ast::Expr,\n+                                      callee_expr: &ast::Expr,\n+                                      adjusted_ty: Ty<'tcx>,\n+                                      autoderefref: ty::AutoDerefRef<'tcx>)\n+                                      -> Option<CallStep<'tcx>>\n+{\n+    // If the callee is a bare function or a closure, then we're all set.\n+    match structurally_resolved_type(fcx, callee_expr.span, adjusted_ty).sty {\n+        ty::ty_bare_fn(..) | ty::ty_closure(_) => {\n+            fcx.write_adjustment(callee_expr.id,\n+                                 callee_expr.span,\n+                                 ty::AdjustDerefRef(autoderefref));\n+            return Some(CallStep::Builtin);\n+        }\n+\n+        _ => {}\n+    }\n+\n+    // Try the options that are least restrictive on the caller first.\n+    for &(opt_trait_def_id, method_name) in [\n+        (fcx.tcx().lang_items.fn_trait(), token::intern(\"call\")),\n+        (fcx.tcx().lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n+        (fcx.tcx().lang_items.fn_once_trait(), token::intern(\"call_once\")),\n+    ].iter() {\n+        let trait_def_id = match opt_trait_def_id {\n+            Some(def_id) => def_id,\n+            None => continue,\n+        };\n+\n+        match method::lookup_in_trait_adjusted(fcx,\n+                                               call_expr.span,\n+                                               Some(&*callee_expr),\n+                                               method_name,\n+                                               trait_def_id,\n+                                               autoderefref.clone(),\n+                                               adjusted_ty,\n+                                               None) {\n+            None => continue,\n+            Some(method_callee) => {\n+                return Some(CallStep::Overloaded(method_callee));\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                 call_expr: &ast::Expr,\n+                                 callee_ty: Ty<'tcx>,\n+                                 arg_exprs: &[P<ast::Expr>])\n+{\n+    let error_fn_sig;\n+\n+    let fn_sig = match callee_ty.sty {\n+        ty::ty_bare_fn(_, &ty::BareFnTy {ref sig, ..}) |\n+        ty::ty_closure(box ty::ClosureTy {ref sig, ..}) => {\n+            sig\n+        }\n+        _ => {\n+            fcx.type_error_message(call_expr.span, |actual| {\n+                format!(\"expected function, found `{}`\", actual)\n+            }, callee_ty, None);\n+\n+            // This is the \"default\" function signature, used in case of error.\n+            // In that case, we check each argument against \"error\" in order to\n+            // set up all the node type bindings.\n+            error_fn_sig = ty::Binder(ty::FnSig {\n+                inputs: err_args(fcx.tcx(), arg_exprs.len()),\n+                output: ty::FnConverging(fcx.tcx().types.err),\n+                variadic: false\n+            });\n+\n+            &error_fn_sig\n+        }\n+    };\n+\n+    // Replace any late-bound regions that appear in the function\n+    // signature with region variables. We also have to\n+    // renormalize the associated types at this point, since they\n+    // previously appeared within a `Binder<>` and hence would not\n+    // have been normalized before.\n+    let fn_sig =\n+        fcx.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n+                                                              infer::FnCall,\n+                                                              fn_sig).0;\n+    let fn_sig =\n+        fcx.normalize_associated_types_in(call_expr.span, &fn_sig);\n+\n+    // Call the generic checker.\n+    let arg_exprs: Vec<_> = arg_exprs.iter().collect(); // for some weird reason we take &[&P<...>].\n+    check_argument_types(fcx,\n+                         call_expr.span,\n+                         fn_sig.inputs[],\n+                         arg_exprs.as_slice(),\n+                         AutorefArgs::No,\n+                         fn_sig.variadic,\n+                         TupleArgumentsFlag::DontTupleArguments);\n+\n+    write_call(fcx, call_expr, fn_sig.output);\n+}\n+\n+fn confirm_overloaded_call<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                    call_expr: &ast::Expr,\n+                                    arg_exprs: &[P<ast::Expr>],\n+                                    method_callee: ty::MethodCallee<'tcx>)\n+{\n+    let arg_exprs: Vec<_> = arg_exprs.iter().collect(); // for some weird reason we take &[&P<...>].\n+    let output_type = check_method_argument_types(fcx,\n+                                                  call_expr.span,\n+                                                  method_callee.ty,\n+                                                  call_expr,\n+                                                  arg_exprs.as_slice(),\n+                                                  AutorefArgs::No,\n+                                                  TupleArgumentsFlag::TupleArguments);\n+    let method_call = ty::MethodCall::expr(call_expr.id);\n+    fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n+    write_call(fcx, call_expr, output_type);\n+}\n+"}, {"sha": "eaf06e0c330844d5b296bce2599d710b5f961911", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 131, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=260e46115b922d29ca98b3cbea190011b1d3e63f", "patch": "@@ -2229,7 +2229,8 @@ pub enum LvaluePreference {\n ///\n /// Note: this method does not modify the adjustments table. The caller is responsible for\n /// inserting an AutoAdjustment record into the `fcx` using one of the suitable methods.\n-pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n+                                 sp: Span,\n                                  base_ty: Ty<'tcx>,\n                                  expr_id: Option<ast::NodeId>,\n                                  mut lvalue_pref: LvaluePreference,\n@@ -2276,58 +2277,6 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n     (fcx.tcx().types.err, 0, None)\n }\n \n-/// Attempts to resolve a call expression as an overloaded call.\n-fn try_overloaded_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                 call_expression: &ast::Expr,\n-                                 callee: &ast::Expr,\n-                                 callee_type: Ty<'tcx>,\n-                                 args: &[&P<ast::Expr>])\n-                                 -> bool {\n-    // Bail out if the callee is a bare function or a closure. We check those\n-    // manually.\n-    match structurally_resolved_type(fcx, callee.span, callee_type).sty {\n-        ty::ty_bare_fn(..) | ty::ty_closure(_) => return false,\n-        _ => {}\n-    }\n-\n-    // Try the options that are least restrictive on the caller first.\n-    for &(maybe_function_trait, method_name) in [\n-        (fcx.tcx().lang_items.fn_trait(), token::intern(\"call\")),\n-        (fcx.tcx().lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n-        (fcx.tcx().lang_items.fn_once_trait(), token::intern(\"call_once\")),\n-    ].iter() {\n-        let function_trait = match maybe_function_trait {\n-            None => continue,\n-            Some(function_trait) => function_trait,\n-        };\n-        let method_callee =\n-            match method::lookup_in_trait(fcx,\n-                                          call_expression.span,\n-                                          Some(&*callee),\n-                                          method_name,\n-                                          function_trait,\n-                                          callee_type,\n-                                          None) {\n-                None => continue,\n-                Some(method_callee) => method_callee,\n-            };\n-        let method_call = MethodCall::expr(call_expression.id);\n-        let output_type = check_method_argument_types(fcx,\n-                                                      call_expression.span,\n-                                                      method_callee.ty,\n-                                                      call_expression,\n-                                                      args,\n-                                                      AutorefArgs::No,\n-                                                      TupleArguments);\n-        fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n-        write_call(fcx, call_expression, output_type);\n-\n-        return true\n-    }\n-\n-    false\n-}\n-\n fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   span: Span,\n                                   method_call: Option<MethodCall>,\n@@ -2689,7 +2638,6 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         check_argument_types(fcx,\n                              sp,\n                              err_inputs[],\n-                             callee_expr,\n                              args_no_rcvr,\n                              autoref_args,\n                              false,\n@@ -2702,7 +2650,6 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 check_argument_types(fcx,\n                                      sp,\n                                      fty.sig.0.inputs.slice_from(1),\n-                                     callee_expr,\n                                      args_no_rcvr,\n                                      autoref_args,\n                                      fty.sig.0.variadic,\n@@ -2722,7 +2669,6 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   sp: Span,\n                                   fn_inputs: &[Ty<'tcx>],\n-                                  _callee_expr: &ast::Expr,\n                                   args: &[&P<ast::Expr>],\n                                   autoref_args: AutorefArgs,\n                                   variadic: bool,\n@@ -3106,63 +3052,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     debug!(\">> typechecking: expr={} expected={}\",\n            expr.repr(fcx.tcx()), expected.repr(fcx.tcx()));\n \n-    // A generic function for doing all of the checking for call expressions\n-    fn check_call(fcx: &FnCtxt,\n-                  call_expr: &ast::Expr,\n-                  f: &ast::Expr,\n-                  args: &[&P<ast::Expr>]) {\n-        // Store the type of `f` as the type of the callee\n-        let fn_ty = fcx.expr_ty(f);\n-\n-        // Extract the function signature from `in_fty`.\n-        let fn_ty = structurally_resolved_type(fcx, f.span, fn_ty);\n-\n-        // This is the \"default\" function signature, used in case of error.\n-        // In that case, we check each argument against \"error\" in order to\n-        // set up all the node type bindings.\n-        let error_fn_sig = ty::Binder(FnSig {\n-            inputs: err_args(fcx.tcx(), args.len()),\n-            output: ty::FnConverging(fcx.tcx().types.err),\n-            variadic: false\n-        });\n-\n-        let fn_sig = match fn_ty.sty {\n-            ty::ty_bare_fn(_, &ty::BareFnTy {ref sig, ..}) |\n-            ty::ty_closure(box ty::ClosureTy {ref sig, ..}) => sig,\n-            _ => {\n-                fcx.type_error_message(call_expr.span, |actual| {\n-                    format!(\"expected function, found `{}`\", actual)\n-                }, fn_ty, None);\n-                &error_fn_sig\n-            }\n-        };\n-\n-        // Replace any late-bound regions that appear in the function\n-        // signature with region variables. We also have to\n-        // renormalize the associated types at this point, since they\n-        // previously appeared within a `Binder<>` and hence would not\n-        // have been normalized before.\n-        let fn_sig =\n-            fcx.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n-                                                                  infer::FnCall,\n-                                                                  fn_sig).0;\n-        let fn_sig =\n-            fcx.normalize_associated_types_in(call_expr.span,\n-                                              &fn_sig);\n-\n-        // Call the generic checker.\n-        check_argument_types(fcx,\n-                             call_expr.span,\n-                             fn_sig.inputs[],\n-                             f,\n-                             args,\n-                             AutorefArgs::No,\n-                             fn_sig.variadic,\n-                             DontTupleArguments);\n-\n-        write_call(fcx, call_expr, fn_sig.output);\n-    }\n-\n     // Checks a method call.\n     fn check_method_call(fcx: &FnCtxt,\n                          expr: &ast::Expr,\n@@ -4164,24 +4053,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         check_block_with_expected(fcx, &**b, expected);\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n-      ast::ExprCall(ref f, ref args) => {\n-          // Index expressions need to be handled separately, to inform them\n-          // that they appear in call position.\n-          check_expr(fcx, &**f);\n-          let f_ty = fcx.expr_ty(&**f);\n-\n-          let args: Vec<_> = args.iter().map(|x| x).collect();\n-          if !try_overloaded_call(fcx, expr, &**f, f_ty, args[]) {\n-              check_call(fcx, expr, &**f, args[]);\n-              let args_err = args.iter().fold(false,\n-                 |rest_err, a| {\n-                     // is this not working?\n-                     let a_ty = fcx.expr_ty(&***a);\n-                     rest_err || ty::type_is_error(a_ty)});\n-              if ty::type_is_error(f_ty) || args_err {\n-                  fcx.write_error(id);\n-              }\n-          }\n+      ast::ExprCall(ref callee, ref args) => {\n+          callee::check_call(fcx, expr, &**callee, args.as_slice());\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n         check_method_call(fcx, expr, ident, args[], tps[], lvalue_pref);"}, {"sha": "7794c34a04b81bf388e23aa80ea457d3bd0e03e8", "filename": "src/test/compile-fail/issue-19692.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs?ref=260e46115b922d29ca98b3cbea190011b1d3e63f", "patch": "@@ -12,7 +12,7 @@ struct Homura;\n \n fn akemi(homura: Homura) {\n     let Some(ref madoka) = Some(homura.kaname()); //~ ERROR does not implement any method\n-    madoka.clone(); //~ ERROR the type of this value must be known\n+    madoka.clone();\n }\n \n fn main() { }"}, {"sha": "0303954ce2a96733e122810f1fd5e872d630b9f9", "filename": "src/test/run-pass/unboxed-closures-call-fn-autoderef.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Ftest%2Frun-pass%2Funboxed-closures-call-fn-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Ftest%2Frun-pass%2Funboxed-closures-call-fn-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-call-fn-autoderef.rs?ref=260e46115b922d29ca98b3cbea190011b1d3e63f", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the call operator autoderefs when calling a bounded type parameter.\n+\n+#![feature(unboxed_closures)]\n+\n+use std::ops::FnMut;\n+\n+fn call_with_2(x: &fn(int) -> int) -> int\n+{\n+    x(2) // look ma, no `*`\n+}\n+\n+fn subtract_22(x: int) -> int { x - 22 }\n+\n+pub fn main() {\n+    let subtract_22: fn(int) -> int = subtract_22;\n+    let z = call_with_2(&subtract_22);\n+    assert_eq!(z, -20);\n+}"}, {"sha": "305f496e668a8a97a7ea2b302651e10d5aba326b", "filename": "src/test/run-pass/unboxed-closures-call-sugar-autoderef.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Ftest%2Frun-pass%2Funboxed-closures-call-sugar-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Ftest%2Frun-pass%2Funboxed-closures-call-sugar-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-call-sugar-autoderef.rs?ref=260e46115b922d29ca98b3cbea190011b1d3e63f", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the call operator autoderefs when calling a bounded type parameter.\n+\n+#![feature(unboxed_closures)]\n+\n+use std::ops::FnMut;\n+\n+fn call_with_2<F>(x: &mut F) -> int\n+    where F : FnMut(int) -> int\n+{\n+    x(2) // look ma, no `*`\n+}\n+\n+pub fn main() {\n+    let z = call_with_2(&mut |x| x - 22);\n+    assert_eq!(z, -20);\n+}"}, {"sha": "8909f4e261faa31c3441f599d50d9dc07ead9be4", "filename": "src/test/run-pass/unboxed-closures-call-sugar-object-autoderef.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Ftest%2Frun-pass%2Funboxed-closures-call-sugar-object-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260e46115b922d29ca98b3cbea190011b1d3e63f/src%2Ftest%2Frun-pass%2Funboxed-closures-call-sugar-object-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-call-sugar-object-autoderef.rs?ref=260e46115b922d29ca98b3cbea190011b1d3e63f", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the call operator autoderefs when calling to an object type.\n+\n+#![feature(unboxed_closures)]\n+\n+use std::ops::FnMut;\n+\n+fn make_adder(x: int) -> Box<FnMut(int)->int + 'static> {\n+    box move |y| { x + y }\n+}\n+\n+pub fn main() {\n+    let mut adder = make_adder(3);\n+    let z = adder(2);\n+    println!(\"{}\", z);\n+    assert_eq!(z, 5);\n+}\n+"}]}