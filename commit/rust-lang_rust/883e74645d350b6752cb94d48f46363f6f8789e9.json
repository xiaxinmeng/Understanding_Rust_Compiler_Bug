{"sha": "883e74645d350b6752cb94d48f46363f6f8789e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4M2U3NDY0NWQzNTBiNjc1MmNiOTRkNDhmNDYzNjNmNmY4Nzg5ZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-12T12:58:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-12T12:58:09Z"}, "message": "Auto merge of #48770 - bobtwinkles:two_phase_borrows_rewrite, r=pnkfelix\n\nTwo phase borrows rewrite\n\nThis definitely needs a careful review. Both @pnkfelix and @nikomatsakis  were involved with the design of this so they're natural choices here. I'm r?'ing @pnkfelix since they wrote the original two-phase borrow implementation. Also ping @KiChjang who expressed interest in working on this. I'm going to leave a few comments below pointing out some of the more dangerous changes I made (i.e. what I would like reviewers to pay special attention too.)\n\nr? @pnkfelix", "tree": {"sha": "36e010d3dbb928882aab4e19f9ded441530635a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36e010d3dbb928882aab4e19f9ded441530635a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/883e74645d350b6752cb94d48f46363f6f8789e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/883e74645d350b6752cb94d48f46363f6f8789e9", "html_url": "https://github.com/rust-lang/rust/commit/883e74645d350b6752cb94d48f46363f6f8789e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/883e74645d350b6752cb94d48f46363f6f8789e9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "222b0eb583a64299f43d6640617e22f19973ddab", "url": "https://api.github.com/repos/rust-lang/rust/commits/222b0eb583a64299f43d6640617e22f19973ddab", "html_url": "https://github.com/rust-lang/rust/commit/222b0eb583a64299f43d6640617e22f19973ddab"}, {"sha": "9a5d61a840b2dd3dc6d069750945759035c85286", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a5d61a840b2dd3dc6d069750945759035c85286", "html_url": "https://github.com/rust-lang/rust/commit/9a5d61a840b2dd3dc6d069750945759035c85286"}], "stats": {"total": 1172, "additions": 572, "deletions": 600}, "files": [{"sha": "d8c366d2413d9cf15975eb67bf64feb49b5de58f", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=883e74645d350b6752cb94d48f46363f6f8789e9", "patch": "@@ -711,6 +711,12 @@ impl<'a> IntoCow<'a, str> for &'a str {\n     }\n }\n \n+impl<'a> IntoCow<'a, str> for Cow<'a, str> {\n+    fn into_cow(self) -> Cow<'a, str> {\n+        self\n+    }\n+}\n+\n impl<'a, T: Clone> IntoCow<'a, [T]> for Vec<T> {\n     fn into_cow(self) -> Cow<'a, [T]> {\n         Cow::Owned(self)"}, {"sha": "7ab52e98a0ee181646bfc29be7229f8c8c8182fa", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=883e74645d350b6752cb94d48f46363f6f8789e9", "patch": "@@ -18,7 +18,7 @@ use rustc_data_structures::sync::Lrc;\n \n use super::{Context, MirBorrowckCtxt};\n use super::{InitializationRequiringAction, PrefixSet};\n-use dataflow::{ActiveBorrows, BorrowData, FlowAtLocation, MovingOutStatements};\n+use dataflow::{Borrows, BorrowData, FlowAtLocation, MovingOutStatements};\n use dataflow::move_paths::MovePathIndex;\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n@@ -250,7 +250,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         let new_closure_span = self.find_closure_span(span, context.loc);\n         let span = new_closure_span.map(|(args, _)| args).unwrap_or(span);\n-        let old_closure_span = self.find_closure_span(issued_span, issued_borrow.location);\n+        let old_closure_span = self.find_closure_span(issued_span, issued_borrow.reserve_location);\n         let issued_span = old_closure_span\n             .map(|(args, _)| args)\n             .unwrap_or(issued_span);\n@@ -372,15 +372,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n-        borrows: &ActiveBorrows<'cx, 'gcx, 'tcx>,\n+        borrows: &Borrows<'cx, 'gcx, 'tcx>\n     ) {\n         let end_span = borrows.opt_region_end_span(&borrow.region);\n-        let scope_tree = borrows.0.scope_tree();\n+        let scope_tree = borrows.scope_tree();\n         let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n             .last()\n             .unwrap();\n \n-        let borrow_span = self.mir.source_info(borrow.location).span;\n+        let borrow_span = self.mir.source_info(borrow.reserve_location).span;\n         let proper_span = match *root_place {\n             Place::Local(local) => self.mir.local_decls[local].source_info.span,\n             _ => drop_span,\n@@ -817,7 +817,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     // Retrieve span of given borrow from the current MIR representation\n     pub fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n-        self.mir.source_info(borrow.location).span\n+        self.mir.source_info(borrow.reserve_location).span\n     }\n \n     // Retrieve type of a place for the current MIR representation"}, {"sha": "ceff380c594ed48f37abdcab322c14f6f4ef2f4d", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=883e74645d350b6752cb94d48f46363f6f8789e9", "patch": "@@ -17,13 +17,14 @@ use rustc::mir::{BasicBlock, Location};\n \n use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use dataflow::{EverInitializedPlaces, MovingOutStatements};\n-use dataflow::{ActiveBorrows, FlowAtLocation, FlowsAtLocation};\n+use dataflow::{Borrows};\n+use dataflow::{FlowAtLocation, FlowsAtLocation};\n use dataflow::move_paths::HasMoveData;\n use std::fmt;\n \n // (forced to be `pub` due to its use as an associated type below.)\n pub(crate) struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n-    pub borrows: FlowAtLocation<ActiveBorrows<'b, 'gcx, 'tcx>>,\n+    pub borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n     pub inits: FlowAtLocation<MaybeInitializedPlaces<'b, 'gcx, 'tcx>>,\n     pub uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n     pub move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n@@ -32,7 +33,7 @@ pub(crate) struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n \n impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n     pub fn new(\n-        borrows: FlowAtLocation<ActiveBorrows<'b, 'gcx, 'tcx>>,\n+        borrows: FlowAtLocation<Borrows<'b, 'gcx, 'tcx>>,\n         inits: FlowAtLocation<MaybeInitializedPlaces<'b, 'gcx, 'tcx>>,\n         uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n         move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,"}, {"sha": "3f111ebcb78029ddb3ed1d219e007035050f0730", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 15, "deletions": 38, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=883e74645d350b6752cb94d48f46363f6f8789e9", "patch": "@@ -34,11 +34,10 @@ use syntax_pos::Span;\n use dataflow::{do_dataflow, DebugFormatted};\n use dataflow::FlowAtLocation;\n use dataflow::MoveDataParamEnv;\n-use dataflow::{DataflowAnalysis, DataflowResultsConsumer};\n+use dataflow::{DataflowResultsConsumer};\n use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use dataflow::{EverInitializedPlaces, MovingOutStatements};\n use dataflow::{BorrowData, Borrows, ReserveOrActivateIndex};\n-use dataflow::{ActiveBorrows, Reservations};\n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n@@ -54,8 +53,6 @@ mod error_reporting;\n mod flows;\n mod prefixes;\n \n-use std::borrow::Cow;\n-\n pub(crate) mod nll;\n \n pub fn provide(providers: &mut Providers) {\n@@ -209,6 +206,18 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     };\n     let flow_inits = flow_inits; // remove mut\n \n+    let flow_borrows = FlowAtLocation::new(do_dataflow(\n+        tcx,\n+        mir,\n+        id,\n+        &attributes,\n+        &dead_unwinds,\n+        Borrows::new(tcx, mir, opt_regioncx.clone(), def_id, body_id),\n+        |rs, i| {\n+            DebugFormatted::new(&(i.kind(), rs.location(i.borrow_index())))\n+        }\n+    ));\n+\n     let movable_generator = !match tcx.hir.get(id) {\n         hir::map::Node::NodeExpr(&hir::Expr {\n             node: hir::ExprClosure(.., Some(hir::GeneratorMovability::Static)),\n@@ -230,44 +239,12 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         },\n         access_place_error_reported: FxHashSet(),\n         reservation_error_reported: FxHashSet(),\n-        nonlexical_regioncx: opt_regioncx.clone(),\n+        nonlexical_regioncx: opt_regioncx,\n         nonlexical_cause_info: None,\n     };\n \n-    let borrows = Borrows::new(tcx, mir, opt_regioncx, def_id, body_id);\n-    let flow_reservations = do_dataflow(\n-        tcx,\n-        mir,\n-        id,\n-        &attributes,\n-        &dead_unwinds,\n-        Reservations::new(borrows),\n-        |rs, i| {\n-            // In principle we could make the dataflow ensure that\n-            // only reservation bits show up, and assert so here.\n-            //\n-            // In practice it is easier to be looser; in particular,\n-            // it is okay for the kill-sets to hold activation bits.\n-            DebugFormatted::new(&(i.kind(), rs.location(i)))\n-        },\n-    );\n-    let flow_active_borrows = {\n-        let reservations_on_entry = flow_reservations.0.sets.entry_set_state();\n-        let reservations = flow_reservations.0.operator;\n-        let a = DataflowAnalysis::new_with_entry_sets(\n-            mir,\n-            &dead_unwinds,\n-            Cow::Borrowed(reservations_on_entry),\n-            ActiveBorrows::new(reservations),\n-        );\n-        let results = a.run(tcx, id, &attributes, |ab, i| {\n-            DebugFormatted::new(&(i.kind(), ab.location(i)))\n-        });\n-        FlowAtLocation::new(results)\n-    };\n-\n     let mut state = Flows::new(\n-        flow_active_borrows,\n+        flow_borrows,\n         flow_inits,\n         flow_uninits,\n         flow_move_outs,"}, {"sha": "07585c08f6a295d068f36ca5b7127ac91821c8e3", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 143, "deletions": 142, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=883e74645d350b6752cb94d48f46363f6f8789e9", "patch": "@@ -20,12 +20,9 @@ use dot::IntoCow;\n \n use std::fs;\n use std::io;\n-use std::io::prelude::*;\n use std::marker::PhantomData;\n use std::path::Path;\n \n-use util;\n-\n use super::{BitDenotation, DataflowState};\n use super::DataflowBuilder;\n use super::DebugFormatted;\n@@ -98,157 +95,161 @@ impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n     }\n \n     fn node_label(&self, n: &Node) -> dot::LabelText {\n-        // A standard MIR label, as generated by write_node_label, is\n-        // presented in a single column in a table.\n-        //\n-        // The code below does a bunch of formatting work to format a\n-        // node (i.e. MIR basic-block) label with extra\n-        // dataflow-enriched information.  In particular, the goal is\n-        // to add extra columns that present the three dataflow\n-        // bitvectors, and the data those bitvectors represent.\n-        //\n-        // It presents it in the following format (where I am\n-        // presenting the table rendering via ASCII art, one line per\n-        // row of the table, and a chunk size of 3 rather than 5):\n-        //\n-        // ------  -----------------------  ------------  --------------------\n-        //                    [e1, e3, e4]\n-        //             [e8, e9] \"= ENTRY:\"  <ENTRY-BITS>\n-        // ------  -----------------------  ------------  --------------------\n-        // Left\n-        // Most\n-        // Column\n-        // Is\n-        // Just\n-        // Normal\n-        // Series\n-        // Of\n-        // MIR\n-        // Stmts\n-        // ------  -----------------------  ------------  --------------------\n-        //           [g1, g4, g5] \"= GEN:\"  <GEN-BITS>\n-        // ------  -----------------------  ------------  --------------------\n-        //                         \"KILL:\"  <KILL-BITS>   \"=\" [k1, k3, k8]\n-        //                                                [k9]\n-        // ------  -----------------------  ------------  --------------------\n-        //\n-        // (In addition, the added dataflow is rendered with a colored\n-        // background just so it will stand out compared to the\n-        // statements.)\n+        // Node label is something like this:\n+        // +---------+----------------------------------+------------------+------------------+\n+        // | ENTRY   | MIR                              | GEN              | KILL             |\n+        // +---------+----------------------------------+------------------+------------------+\n+        // |         |  0: StorageLive(_7)              | bb3[2]: reserved | bb2[0]: reserved |\n+        // |         |  1: StorageLive(_8)              | bb3[2]: active   | bb2[0]: active   |\n+        // |         |  2: _8 = &mut _1                 |                  | bb4[2]: reserved |\n+        // |         |                                  |                  | bb4[2]: active   |\n+        // |         |                                  |                  | bb9[0]: reserved |\n+        // |         |                                  |                  | bb9[0]: active   |\n+        // |         |                                  |                  | bb10[0]: reserved|\n+        // |         |                                  |                  | bb10[0]: active  |\n+        // |         |                                  |                  | bb11[0]: reserved|\n+        // |         |                                  |                  | bb11[0]: active  |\n+        // +---------+----------------------------------+------------------+------------------+\n+        // | [00-00] | _7 = const Foo::twiddle(move _8) | [0c-00]          | [f3-0f]          |\n+        // +---------+----------------------------------+------------------+------------------+\n         let mut v = Vec::new();\n+        self.node_label_internal(n, &mut v, *n, self.mbcx.mir()).unwrap();\n+        dot::LabelText::html(String::from_utf8(v).unwrap())\n+    }\n+\n+\n+    fn node_shape(&self, _n: &Node) -> Option<dot::LabelText> {\n+        Some(dot::LabelText::label(\"none\"))\n+    }\n+\n+    fn edge_label(&'a self, e: &Edge) -> dot::LabelText<'a> {\n+        let term = self.mbcx.mir()[e.source].terminator();\n+        let label = &term.kind.fmt_successor_labels()[e.index];\n+        dot::LabelText::label(label.clone())\n+    }\n+}\n+\n+impl<'a, 'tcx, MWF, P> Graph<'a, 'tcx, MWF, P>\n+where MWF: MirWithFlowState<'tcx>,\n+      P: Fn(&MWF::BD, <MWF::BD as BitDenotation>::Idx) -> DebugFormatted,\n+{\n+    /// Generate the node label\n+    fn node_label_internal<W: io::Write>(&self,\n+                                         n: &Node,\n+                                         w: &mut W,\n+                                         block: BasicBlock,\n+                                         mir: &Mir) -> io::Result<()> {\n+        // Header rows\n+        const HDRS: [&'static str; 4] = [\"ENTRY\", \"MIR\", \"BLOCK GENS\", \"BLOCK KILLS\"];\n+        const HDR_FMT: &'static str = \"bgcolor=\\\"grey\\\"\";\n+        write!(w, \"<table><tr><td rowspan=\\\"{}\\\">\", HDRS.len())?;\n+        write!(w, \"{:?}\", block.index())?;\n+        write!(w, \"</td></tr><tr>\")?;\n+        for hdr in &HDRS {\n+            write!(w, \"<td {}>{}</td>\", HDR_FMT, hdr)?;\n+        }\n+        write!(w, \"</tr>\")?;\n+\n+        // Data row\n+        self.node_label_verbose_row(n, w, block, mir)?;\n+        self.node_label_final_row(n, w, block, mir)?;\n+        write!(w, \"</table>\")?;\n+\n+        Ok(())\n+    }\n+\n+    /// Build the verbose row: full MIR data, and detailed gen/kill/entry sets\n+    fn node_label_verbose_row<W: io::Write>(&self,\n+                                            n: &Node,\n+                                            w: &mut W,\n+                                            block: BasicBlock,\n+                                            mir: &Mir)\n+                                            -> io::Result<()> {\n         let i = n.index();\n-        let chunk_size = 5;\n-        const BG_FLOWCONTENT: &'static str = r#\"bgcolor=\"pink\"\"#;\n-        const ALIGN_RIGHT: &'static str = r#\"align=\"right\"\"#;\n-        const FACE_MONOSPACE: &'static str = r#\"FACE=\"Courier\"\"#;\n-        fn chunked_present_left<W:io::Write>(w: &mut W,\n-                                             interpreted: &[DebugFormatted],\n-                                             chunk_size: usize)\n-                                             -> io::Result<()>\n-        {\n-            // This function may emit a sequence of <tr>'s, but it\n-            // always finishes with an (unfinished)\n-            // <tr><td></td><td>\n-            //\n-            // Thus, after being called, one should finish both the\n-            // pending <td> as well as the <tr> itself.\n-            let mut seen_one = false;\n-            for c in interpreted.chunks(chunk_size) {\n-                if seen_one {\n-                    // if not the first row, finish off the previous row\n-                    write!(w, \"</td><td></td><td></td></tr>\")?;\n+\n+        macro_rules! dump_set_for {\n+            ($set:ident) => {\n+                write!(w, \"<td>\")?;\n+\n+                let flow = self.mbcx.flow_state();\n+                let entry_interp = flow.interpret_set(&flow.operator,\n+                                                      flow.sets.$set(i),\n+                                                      &self.render_idx);\n+                for e in &entry_interp {\n+                    write!(w, \"{:?}<br/>\", e)?;\n                 }\n-                write!(w, \"<tr><td></td><td {bg} {align}>{objs:?}\",\n-                       bg = BG_FLOWCONTENT,\n-                       align = ALIGN_RIGHT,\n-                       objs = c)?;\n-                seen_one = true;\n+                write!(w, \"</td>\")?;\n             }\n-            if !seen_one {\n-                write!(w, \"<tr><td></td><td {bg} {align}>[]\",\n-                       bg = BG_FLOWCONTENT,\n-                       align = ALIGN_RIGHT)?;\n+        }\n+\n+        write!(w, \"<tr>\")?;\n+        // Entry\n+        dump_set_for!(on_entry_set_for);\n+\n+        // MIR statements\n+        write!(w, \"<td>\")?;\n+        {\n+            let data = &mir[block];\n+            for (i, statement) in data.statements.iter().enumerate() {\n+                write!(w, \"{}<br align=\\\"left\\\"/>\",\n+                       dot::escape_html(&format!(\"{:3}: {:?}\", i, statement)))?;\n             }\n-            Ok(())\n         }\n-        util::write_graphviz_node_label(\n-            *n, self.mbcx.mir(), &mut v, 4,\n-            |w| {\n-                let flow = self.mbcx.flow_state();\n-                let entry_interp = flow.interpret_set(&flow.operator,\n-                                                      flow.sets.on_entry_set_for(i),\n-                                                      &self.render_idx);\n-                chunked_present_left(w, &entry_interp[..], chunk_size)?;\n-                let bits_per_block = flow.sets.bits_per_block();\n-                let entry = flow.sets.on_entry_set_for(i);\n-                debug!(\"entry set for i={i} bits_per_block: {bpb} entry: {e:?} interp: {ei:?}\",\n-                       i=i, e=entry, bpb=bits_per_block, ei=entry_interp);\n-                write!(w, \"= ENTRY:</td><td {bg}><FONT {face}>{entrybits:?}</FONT></td>\\\n-                                        <td></td></tr>\",\n-                       bg = BG_FLOWCONTENT,\n-                       face = FACE_MONOSPACE,\n-                       entrybits=bits_to_string(entry.words(), bits_per_block))\n-            },\n-            |w| {\n+        write!(w, \"</td>\")?;\n+\n+        // Gen\n+        dump_set_for!(gen_set_for);\n+\n+        // Kill\n+        dump_set_for!(kill_set_for);\n+\n+        write!(w, \"</tr>\")?;\n+\n+        Ok(())\n+    }\n+\n+    /// Build the summary row: terminator, gen/kill/entry bit sets\n+    fn node_label_final_row<W: io::Write>(&self,\n+                                          n: &Node,\n+                                          w: &mut W,\n+                                          block: BasicBlock,\n+                                          mir: &Mir)\n+                                          -> io::Result<()> {\n+        let i = n.index();\n+\n+        macro_rules! dump_set_for {\n+            ($set:ident) => {\n                 let flow = self.mbcx.flow_state();\n-                let gen_interp =\n-                    flow.interpret_set(&flow.operator, flow.sets.gen_set_for(i), &self.render_idx);\n-                let kill_interp =\n-                    flow.interpret_set(&flow.operator, flow.sets.kill_set_for(i), &self.render_idx);\n-                chunked_present_left(w, &gen_interp[..], chunk_size)?;\n                 let bits_per_block = flow.sets.bits_per_block();\n-                {\n-                    let gen = flow.sets.gen_set_for(i);\n-                    debug!(\"gen set for i={i} bits_per_block: {bpb} gen: {g:?} interp: {gi:?}\",\n-                           i=i, g=gen, bpb=bits_per_block, gi=gen_interp);\n-                    write!(w, \" = GEN:</td><td {bg}><FONT {face}>{genbits:?}</FONT></td>\\\n-                                           <td></td></tr>\",\n-                           bg = BG_FLOWCONTENT,\n-                           face = FACE_MONOSPACE,\n-                           genbits=bits_to_string(gen.words(), bits_per_block))?;\n-                }\n+                let set = flow.sets.$set(i);\n+                write!(w, \"<td>{:?}</td>\",\n+                       dot::escape_html(&bits_to_string(set.words(), bits_per_block)))?;\n+            }\n+        }\n \n-                {\n-                    let kill = flow.sets.kill_set_for(i);\n-                    debug!(\"kill set for i={i} bits_per_block: {bpb} kill: {k:?} interp: {ki:?}\",\n-                           i=i, k=kill, bpb=bits_per_block, ki=kill_interp);\n-                    write!(w, \"<tr><td></td><td {bg} {align}>KILL:</td>\\\n-                                            <td {bg}><FONT {face}>{killbits:?}</FONT></td>\",\n-                           bg = BG_FLOWCONTENT,\n-                           align = ALIGN_RIGHT,\n-                           face = FACE_MONOSPACE,\n-                           killbits=bits_to_string(kill.words(), bits_per_block))?;\n-                }\n+        write!(w, \"<tr>\")?;\n+        // Entry\n+        dump_set_for!(on_entry_set_for);\n \n-                // (chunked_present_right)\n-                let mut seen_one = false;\n-                for k in kill_interp.chunks(chunk_size) {\n-                    if !seen_one {\n-                        // continuation of row; this is fourth <td>\n-                        write!(w, \"<td {bg}>= {kill:?}</td></tr>\",\n-                               bg = BG_FLOWCONTENT,\n-                               kill=k)?;\n-                    } else {\n-                        // new row, with indent of three <td>'s\n-                        write!(w, \"<tr><td></td><td></td><td></td><td {bg}>{kill:?}</td></tr>\",\n-                               bg = BG_FLOWCONTENT,\n-                               kill=k)?;\n-                    }\n-                    seen_one = true;\n-                }\n-                if !seen_one {\n-                    write!(w, \"<td {bg}>= []</td></tr>\",\n-                           bg = BG_FLOWCONTENT)?;\n-                }\n+        // Terminator\n+        write!(w, \"<td>\")?;\n+        {\n+            let data = &mir[block];\n+            let mut terminator_head = String::new();\n+            data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n+            write!(w, \"{}\", dot::escape_html(&terminator_head))?;\n+        }\n+        write!(w, \"</td>\")?;\n \n-                Ok(())\n-            })\n-            .unwrap();\n-        dot::LabelText::html(String::from_utf8(v).unwrap())\n-    }\n+        // Gen\n+        dump_set_for!(gen_set_for);\n \n-    fn node_shape(&self, _n: &Node) -> Option<dot::LabelText> {\n-        Some(dot::LabelText::label(\"none\"))\n+        // Kill\n+        dump_set_for!(kill_set_for);\n+\n+        write!(w, \"</tr>\")?;\n+\n+        Ok(())\n     }\n }\n "}, {"sha": "499ed55fad41f64ff54d8bbdacae84778aa2575d", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 357, "deletions": 361, "changes": 718, "blob_url": "https://github.com/rust-lang/rust/blob/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=883e74645d350b6752cb94d48f46363f6f8789e9", "patch": "@@ -63,46 +63,25 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     /// to its borrow-indexes.\n     assigned_map: FxHashMap<Place<'tcx>, FxHashSet<BorrowIndex>>,\n \n+    /// Locations which activate borrows.\n+    /// NOTE: A given location may activate more than one borrow in the future\n+    /// when more general two-phase borrow support is introduced, but for now we\n+    /// only need to store one borrow index\n+    activation_map: FxHashMap<Location, BorrowIndex>,\n+\n     /// Every borrow has a region; this maps each such regions back to\n     /// its borrow-indexes.\n     region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+\n+    /// Map from local to all the borrows on that local\n     local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n-    region_span_map: FxHashMap<RegionKind, Span>,\n-    nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n-}\n \n-// Two-phase borrows actually requires two flow analyses; they need\n-// to be separate because the final results of the first are used to\n-// construct the gen+kill sets for the second. (The dataflow system\n-// is not designed to allow the gen/kill sets to change during the\n-// fixed-point iteration.)\n-\n-/// The `Reservations` analysis is the first of the two flow analyses\n-/// tracking (phased) borrows. It computes where a borrow is reserved;\n-/// i.e. where it can reach in the control flow starting from its\n-/// initial `assigned = &'rgn borrowed` statement, and ending\n-/// wherever `'rgn` itself ends.\n-pub(crate) struct Reservations<'a, 'gcx: 'tcx, 'tcx: 'a>(pub(crate) Borrows<'a, 'gcx, 'tcx>);\n-\n-/// The `ActiveBorrows` analysis is the second of the two flow\n-/// analyses tracking (phased) borrows. It computes where any given\n-/// borrow `&assigned = &'rgn borrowed` is *active*, which starts at\n-/// the first use of `assigned` after the reservation has started, and\n-/// ends wherever `'rgn` itself ends.\n-pub(crate) struct ActiveBorrows<'a, 'gcx: 'tcx, 'tcx: 'a>(pub(crate) Borrows<'a, 'gcx, 'tcx>);\n-\n-impl<'a, 'gcx, 'tcx> Reservations<'a, 'gcx, 'tcx> {\n-    pub(crate) fn new(b: Borrows<'a, 'gcx, 'tcx>) -> Self { Reservations(b) }\n-    pub(crate) fn location(&self, idx: ReserveOrActivateIndex) -> &Location {\n-        self.0.location(idx.borrow_index())\n-    }\n-}\n+    /// Maps regions to their corresponding source spans\n+    /// Only contains ReScope()s as keys\n+    region_span_map: FxHashMap<RegionKind, Span>,\n \n-impl<'a, 'gcx, 'tcx> ActiveBorrows<'a, 'gcx, 'tcx> {\n-    pub(crate) fn new(r: Reservations<'a, 'gcx, 'tcx>) -> Self { ActiveBorrows(r.0) }\n-    pub(crate) fn location(&self, idx: ReserveOrActivateIndex) -> &Location {\n-        self.0.location(idx.borrow_index())\n-    }\n+    /// NLL region inference context with which NLL queries should be resolved\n+    nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n }\n \n // temporarily allow some dead fields: `kind` and `region` will be\n@@ -111,10 +90,16 @@ impl<'a, 'gcx, 'tcx> ActiveBorrows<'a, 'gcx, 'tcx> {\n #[allow(dead_code)]\n #[derive(Debug)]\n pub struct BorrowData<'tcx> {\n-    pub(crate) location: Location,\n+    /// Location where the borrow reservation starts.\n+    /// In many cases, this will be equal to the activation location but not always.\n+    pub(crate) reserve_location: Location,\n+    /// What kind of borrow this is\n     pub(crate) kind: mir::BorrowKind,\n+    /// The region for which this borrow is live\n     pub(crate) region: Region<'tcx>,\n+    /// Place from which we are borrowing\n     pub(crate) borrowed_place: mir::Place<'tcx>,\n+    /// Place to which the borrow was stored\n     pub(crate) assigned_place: mir::Place<'tcx>,\n }\n \n@@ -163,9 +148,11 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             idx_vec: IndexVec::new(),\n             location_map: FxHashMap(),\n             assigned_map: FxHashMap(),\n+            activation_map: FxHashMap(),\n             region_map: FxHashMap(),\n             local_map: FxHashMap(),\n-            region_span_map: FxHashMap()\n+            region_span_map: FxHashMap(),\n+            nonlexical_regioncx: nonlexical_regioncx.clone()\n         };\n         visitor.visit_mir(mir);\n         return Borrows { tcx: tcx,\n@@ -175,6 +162,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                          root_scope,\n                          location_map: visitor.location_map,\n                          assigned_map: visitor.assigned_map,\n+                         activation_map: visitor.activation_map,\n                          region_map: visitor.region_map,\n                          local_map: visitor.local_map,\n                          region_span_map: visitor.region_span_map,\n@@ -186,9 +174,11 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n             location_map: FxHashMap<Location, BorrowIndex>,\n             assigned_map: FxHashMap<Place<'tcx>, FxHashSet<BorrowIndex>>,\n+            activation_map: FxHashMap<Location, BorrowIndex>,\n             region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n             local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n             region_span_map: FxHashMap<RegionKind, Span>,\n+            nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n         }\n \n         impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n@@ -208,14 +198,25 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                 if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n                     if is_unsafe_place(self.tcx, self.mir, borrowed_place) { return; }\n \n+                    let activate_location = self.compute_activation_location(location,\n+                                                                             &assigned_place,\n+                                                                             region,\n+                                                                             kind);\n                     let borrow = BorrowData {\n-                        location, kind, region,\n+                        kind, region,\n+                        reserve_location: location,\n                         borrowed_place: borrowed_place.clone(),\n                         assigned_place: assigned_place.clone(),\n                     };\n                     let idx = self.idx_vec.push(borrow);\n                     self.location_map.insert(location, idx);\n \n+                    // This assert is a good sanity check until more general 2-phase borrow\n+                    // support is introduced. See NOTE on the activation_map field for more\n+                    assert!(!self.activation_map.contains_key(&activate_location),\n+                            \"More than one activation introduced at the same location.\");\n+                    self.activation_map.insert(activate_location, idx);\n+\n                     insert(&mut self.assigned_map, assigned_place, idx);\n                     insert(&mut self.region_map, &region, idx);\n                     if let Some(local) = root_local(borrowed_place) {\n@@ -245,7 +246,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                     let mut found_it = false;\n                     for idx in &self.region_map[region] {\n                         let bd = &self.idx_vec[*idx];\n-                        if bd.location == location &&\n+                        if bd.reserve_location == location &&\n                             bd.kind == kind &&\n                             bd.region == region &&\n                             bd.borrowed_place == *place\n@@ -270,29 +271,247 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                 return self.super_statement(block, statement, location);\n             }\n         }\n+\n+        /// A MIR visitor that determines if a specific place is used in a two-phase activating\n+        /// manner in a given chunk of MIR.\n+        struct ContainsUseOfPlace<'b, 'tcx: 'b> {\n+            target: &'b Place<'tcx>,\n+            use_found: bool,\n+        }\n+\n+        impl<'b, 'tcx: 'b> ContainsUseOfPlace<'b, 'tcx> {\n+            fn new(place: &'b Place<'tcx>) -> Self {\n+                Self { target: place, use_found: false }\n+            }\n+\n+            /// return whether `context` should be considered a \"use\" of a\n+            /// place found in that context. \"Uses\" activate associated\n+            /// borrows (at least when such uses occur while the borrow also\n+            /// has a reservation at the time).\n+            fn is_potential_use(context: PlaceContext) -> bool {\n+                match context {\n+                    // storage effects on a place do not activate it\n+                    PlaceContext::StorageLive | PlaceContext::StorageDead => false,\n+\n+                    // validation effects do not activate a place\n+                    //\n+                    // FIXME: Should they? Is it just another read? Or can we\n+                    // guarantee it won't dereference the stored address? How\n+                    // \"deep\" does validation go?\n+                    PlaceContext::Validate => false,\n+\n+                    // FIXME: This is here to not change behaviour from before\n+                    // AsmOutput existed, but it's not necessarily a pure overwrite.\n+                    // so it's possible this should activate the place.\n+                    PlaceContext::AsmOutput |\n+                    // pure overwrites of a place do not activate it. (note\n+                    // PlaceContext::Call is solely about dest place)\n+                    PlaceContext::Store | PlaceContext::Call => false,\n+\n+                    // reads of a place *do* activate it\n+                    PlaceContext::Move |\n+                    PlaceContext::Copy |\n+                    PlaceContext::Drop |\n+                    PlaceContext::Inspect |\n+                    PlaceContext::Borrow { .. } |\n+                    PlaceContext::Projection(..) => true,\n+                }\n+            }\n+        }\n+\n+        impl<'b, 'tcx: 'b> Visitor<'tcx> for ContainsUseOfPlace<'b, 'tcx> {\n+            fn visit_place(&mut self,\n+                           place: &mir::Place<'tcx>,\n+                           context: PlaceContext<'tcx>,\n+                           location: Location) {\n+                if Self::is_potential_use(context) && place == self.target {\n+                    self.use_found = true;\n+                    return;\n+                    // There is no need to keep checking the statement, we already found a use\n+                }\n+\n+                self.super_place(place, context, location);\n+            }\n+        }\n+\n+        impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n+            /// Returns true if the borrow represented by `kind` is\n+            /// allowed to be split into separate Reservation and\n+            /// Activation phases.\n+            fn allow_two_phase_borrow(&self, kind: mir::BorrowKind) -> bool {\n+                self.tcx.two_phase_borrows() &&\n+                    (kind.allows_two_phase_borrow() ||\n+                     self.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n+            }\n+\n+            /// Returns true if the given location contains an NLL-activating use of the given place\n+            fn location_contains_use(&self, location: Location, place: &Place) -> bool {\n+                let mut use_checker = ContainsUseOfPlace::new(place);\n+                let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n+                    panic!(\"could not find block at location {:?}\", location);\n+                });\n+                if location.statement_index != block.statements.len() {\n+                    // This is a statement\n+                    let stmt = block.statements.get(location.statement_index).unwrap_or_else(|| {\n+                        panic!(\"could not find statement at location {:?}\");\n+                    });\n+                    use_checker.visit_statement(location.block, stmt, location);\n+                } else {\n+                    // This is a terminator\n+                    match block.terminator {\n+                        Some(ref term) => {\n+                            use_checker.visit_terminator(location.block, term, location);\n+                        }\n+                        None => {\n+                            // There is no way for Place to be used by the terminator if there is no\n+                            // terminator\n+                        }\n+                    }\n+                }\n+\n+                use_checker.use_found\n+            }\n+\n+            /// Determines if the provided region is terminated after the provided location.\n+            /// EndRegion statements terminate their enclosed region::Scope.\n+            /// We also consult with the NLL region inference engine, should one be available\n+            fn region_terminated_after(&self, region: Region<'tcx>, location: Location) -> bool {\n+                let block_data = &self.mir[location.block];\n+                if location.statement_index != block_data.statements.len() {\n+                    let stmt = &block_data.statements[location.statement_index];\n+                    if let mir::StatementKind::EndRegion(region_scope) = stmt.kind {\n+                        if &ReScope(region_scope) == region {\n+                            // We encountered an EndRegion statement that terminates the provided\n+                            // region\n+                            return true;\n+                        }\n+                    }\n+                }\n+                if let Some(ref regioncx) = self.nonlexical_regioncx {\n+                    if !regioncx.region_contains_point(region, location) {\n+                        // NLL says the region has ended already\n+                        return true;\n+                    }\n+                }\n+\n+                false\n+            }\n+\n+            /// Computes the activation location of a borrow.\n+            /// The general idea is to start at the beginning of the region and perform a DFS\n+            /// until we exit the region, either via an explicit EndRegion or because NLL tells\n+            /// us so. If we find more than one valid activation point, we currently panic the\n+            /// compiler since two-phase borrows are only currently supported for compiler-\n+            /// generated code. More precisely, we only allow two-phase borrows for:\n+            ///   - Function calls (fn some_func(&mut self, ....))\n+            ///   - *Assign operators (a += b -> fn add_assign(&mut self, other: Self))\n+            /// See\n+            ///   - https://github.com/rust-lang/rust/issues/48431\n+            /// for detailed design notes.\n+            /// See the FIXME in the body of the function for notes on extending support to more\n+            /// general two-phased borrows.\n+            fn compute_activation_location(&self,\n+                                           start_location: Location,\n+                                           assigned_place: &mir::Place<'tcx>,\n+                                           region: Region<'tcx>,\n+                                           kind: mir::BorrowKind) -> Location {\n+                debug!(\"Borrows::compute_activation_location({:?}, {:?}, {:?})\",\n+                       start_location,\n+                       assigned_place,\n+                       region);\n+                if !self.allow_two_phase_borrow(kind) {\n+                    debug!(\"  -> {:?}\", start_location);\n+                    return start_location;\n+                }\n+\n+                // Perform the DFS.\n+                // `stack` is the stack of locations still under consideration\n+                // `visited` is the set of points we have already visited\n+                // `found_use` is an Option that becomes Some when we find a use\n+                let mut stack = vec![start_location];\n+                let mut visited = FxHashSet();\n+                let mut found_use = None;\n+                while let Some(curr_loc) = stack.pop() {\n+                    let block_data = &self.mir.basic_blocks()\n+                        .get(curr_loc.block)\n+                        .unwrap_or_else(|| {\n+                            panic!(\"could not find block at location {:?}\", curr_loc);\n+                        });\n+\n+                    if self.region_terminated_after(region, curr_loc) {\n+                        // No need to process this statement.\n+                        // It's either an EndRegion (and thus couldn't use assigned_place) or not\n+                        // contained in the NLL region and thus a use would be invalid\n+                        continue;\n+                    }\n+\n+                    if !visited.insert(curr_loc) {\n+                        debug!(\"  Already visited {:?}\", curr_loc);\n+                        continue;\n+                    }\n+\n+                    if self.location_contains_use(curr_loc, assigned_place) {\n+                        // FIXME: Handle this case a little more gracefully. Perhaps collect\n+                        // all uses in a vector, and find the point in the CFG that dominates\n+                        // all of them?\n+                        // Right now this is sufficient though since there should only be exactly\n+                        // one borrow-activating use of the borrow.\n+                        assert!(found_use.is_none(), \"Found secondary use of place\");\n+                        found_use = Some(curr_loc);\n+                    }\n+\n+                    // Push the points we should consider next.\n+                    if curr_loc.statement_index < block_data.statements.len() {\n+                        stack.push(curr_loc.successor_within_block());\n+                    } else {\n+                        stack.extend(block_data.terminator().successors().iter().map(\n+                            |&basic_block| {\n+                                Location {\n+                                    statement_index: 0,\n+                                    block: basic_block\n+                                }\n+                            }\n+                        ))\n+                    }\n+                }\n+\n+                let found_use = found_use.expect(\"Did not find use of two-phase place\");\n+                debug!(\"  -> {:?}\", found_use);\n+                found_use\n+            }\n+        }\n+    }\n+\n+    /// Returns the span for the \"end point\" given region. This will\n+    /// return `None` if NLL is enabled, since that concept has no\n+    /// meaning there.  Otherwise, return region span if it exists and\n+    /// span for end of the function if it doesn't exist.\n+    pub(crate) fn opt_region_end_span(&self, region: &Region) -> Option<Span> {\n+        match self.nonlexical_regioncx {\n+            Some(_) => None,\n+            None => {\n+                match self.region_span_map.get(region) {\n+                    Some(span) => Some(self.tcx.sess.codemap().end_point(*span)),\n+                    None => Some(self.tcx.sess.codemap().end_point(self.mir.span))\n+                }\n+            }\n+        }\n     }\n \n     pub fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> { &self.borrows }\n \n     pub fn scope_tree(&self) -> &Lrc<region::ScopeTree> { &self.scope_tree }\n \n     pub fn location(&self, idx: BorrowIndex) -> &Location {\n-        &self.borrows[idx].location\n+        &self.borrows[idx].reserve_location\n     }\n \n     /// Add all borrows to the kill set, if those borrows are out of scope at `location`.\n-    ///\n-    /// `is_activations` tracks whether we are in the Reservations or\n-    /// the ActiveBorrows flow analysis, and does not set the\n-    /// activation kill bits in the former case. (Technically, we\n-    /// could set those kill bits without such a guard, since they are\n-    /// never gen'ed by Reservations in the first place.  But it makes\n-    /// the instrumentation and graph renderings nicer to leave\n-    /// activations out when of the Reservations kill sets.)\n+    /// That means either they went out of either a nonlexical scope, if we care about those\n+    /// at the moment, or the location represents a lexical EndRegion\n     fn kill_loans_out_of_scope_at_location(&self,\n                                            sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                                           location: Location,\n-                                           is_activations: bool) {\n+                                           location: Location) {\n         if let Some(ref regioncx) = self.nonlexical_regioncx {\n             // NOTE: The state associated with a given `location`\n             // reflects the dataflow on entry to the statement. If it\n@@ -309,43 +528,71 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                 let borrow_region = borrow_data.region.to_region_vid();\n                 if !regioncx.region_contains_point(borrow_region, location) {\n                     sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n-                    if is_activations {\n-                        sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n-                    }\n+                    sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n                 }\n             }\n         }\n     }\n \n-    /// Models statement effect in Reservations and ActiveBorrows flow\n-    /// analyses; `is activations` tells us if we are in the latter\n-    /// case.\n-    fn statement_effect_on_borrows(&self,\n-                                   sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                                   location: Location,\n-                                   is_activations: bool) {\n+    fn kill_borrows_on_local(&self,\n+                             sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                             local: &rustc::mir::Local)\n+    {\n+        if let Some(borrow_indexes) = self.local_map.get(local) {\n+            sets.kill_all(borrow_indexes.iter()\n+                          .map(|b| ReserveOrActivateIndex::reserved(*b)));\n+            sets.kill_all(borrow_indexes.iter()\n+                          .map(|b| ReserveOrActivateIndex::active(*b)));\n+        }\n+    }\n+\n+    /// Performs the activations for a given location\n+    fn perform_activations_at_location(&self,\n+                                       sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                                       location: Location) {\n+        // Handle activations\n+        match self.activation_map.get(&location) {\n+            Some(&activated) => {\n+                debug!(\"activating borrow {:?}\", activated);\n+                sets.gen(&ReserveOrActivateIndex::active(activated))\n+            }\n+            None => {}\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n+    type Idx = ReserveOrActivateIndex;\n+    fn name() -> &'static str { \"borrows\" }\n+    fn bits_per_block(&self) -> usize {\n+        self.borrows.len() * 2\n+    }\n+\n+    fn start_block_effect(&self, _entry_set: &mut IdxSet<ReserveOrActivateIndex>) {\n+        // no borrows of code region_scopes have been taken prior to\n+        // function execution, so this method has no effect on\n+        // `_sets`.\n+    }\n+\n+    fn before_statement_effect(&self,\n+                               sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                               location: Location) {\n+        debug!(\"Borrows::before_statement_effect sets: {:?} location: {:?}\", sets, location);\n+        self.kill_loans_out_of_scope_at_location(sets, location);\n+    }\n+\n+    fn statement_effect(&self, sets: &mut BlockSets<ReserveOrActivateIndex>, location: Location) {\n+        debug!(\"Borrows::statement_effect sets: {:?} location: {:?}\", sets, location);\n+\n         let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n             panic!(\"could not find block at location {:?}\", location);\n         });\n         let stmt = block.statements.get(location.statement_index).unwrap_or_else(|| {\n             panic!(\"could not find statement at location {:?}\");\n         });\n \n-        // Do kills introduced by NLL before setting up any potential\n-        // gens. (See NOTE in kill_loans_out_of_scope_at_location.)\n-        self.kill_loans_out_of_scope_at_location(sets, location, is_activations);\n-\n-        if is_activations {\n-            // INVARIANT: `sets.on_entry` accurately captures\n-            // reservations on entry to statement (b/c\n-            // accumulates_intrablock_state is overridden for\n-            // ActiveBorrows).\n-            //\n-            // Now compute the activations generated by uses within\n-            // the statement based on that reservation state.\n-            let mut find = FindPlaceUses { sets, assigned_map: &self.assigned_map };\n-            find.visit_statement(location.block, stmt, location);\n-        }\n+        self.perform_activations_at_location(sets, location);\n+        self.kill_loans_out_of_scope_at_location(sets, location);\n \n         match stmt.kind {\n             // EndRegion kills any borrows (reservations and active borrows both)\n@@ -354,9 +601,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                     assert!(self.nonlexical_regioncx.is_none());\n                     for idx in borrow_indexes {\n                         sets.kill(&ReserveOrActivateIndex::reserved(*idx));\n-                        if is_activations {\n-                            sets.kill(&ReserveOrActivateIndex::active(*idx));\n-                        }\n+                        sets.kill(&ReserveOrActivateIndex::active(*idx));\n                     }\n                 } else {\n                     // (if there is no entry, then there are no borrows to be tracked)\n@@ -369,7 +614,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                 if let Place::Local(ref local) = *lhs {\n                     // FIXME: Handle the case in which we're assigning over\n                     // a projection (`foo.bar`).\n-                    self.kill_borrows_on_local(sets, local, is_activations);\n+                    self.kill_borrows_on_local(sets, local);\n                 }\n \n                 // NOTE: if/when the Assign case is revised to inspect\n@@ -379,32 +624,32 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n \n                 if let mir::Rvalue::Ref(region, _, ref place) = *rhs {\n                     if is_unsafe_place(self.tcx, self.mir, place) { return; }\n+                    let index = self.location_map.get(&location).unwrap_or_else(|| {\n+                        panic!(\"could not find BorrowIndex for location {:?}\", location);\n+                    });\n+\n                     if let RegionKind::ReEmpty = region {\n-                        // If the borrowed value is dead, the region for it\n-                        // can be empty. Don't track the borrow in that case.\n+                        // If the borrowed value dies before the borrow is used, the region for\n+                        // the borrow can be empty. Don't track the borrow in that case.\n+                        sets.kill(&ReserveOrActivateIndex::active(*index));\n                         return\n                     }\n \n-                    let index = self.location_map.get(&location).unwrap_or_else(|| {\n-                        panic!(\"could not find BorrowIndex for location {:?}\", location);\n-                    });\n                     assert!(self.region_map.get(region).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndexs for region {:?}\", region);\n                     }).contains(&index));\n                     sets.gen(&ReserveOrActivateIndex::reserved(*index));\n \n-                    if is_activations {\n-                        // Issue #46746: Two-phase borrows handles\n-                        // stmts of form `Tmp = &mut Borrow` ...\n-                        match lhs {\n-                            Place::Local(..) | Place::Static(..) => {} // okay\n-                            Place::Projection(..) => {\n-                                // ... can assign into projections,\n-                                // e.g. `box (&mut _)`. Current\n-                                // conservative solution: force\n-                                // immediate activation here.\n-                                sets.gen(&ReserveOrActivateIndex::active(*index));\n-                            }\n+                    // Issue #46746: Two-phase borrows handles\n+                    // stmts of form `Tmp = &mut Borrow` ...\n+                    match lhs {\n+                        Place::Local(..) | Place::Static(..) => {} // okay\n+                        Place::Projection(..) => {\n+                            // ... can assign into projections,\n+                            // e.g. `box (&mut _)`. Current\n+                            // conservative solution: force\n+                            // immediate activation here.\n+                            sets.gen(&ReserveOrActivateIndex::active(*index));\n                         }\n                     }\n                 }\n@@ -413,7 +658,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             mir::StatementKind::StorageDead(local) => {\n                 // Make sure there are no remaining borrows for locals that\n                 // are gone out of scope.\n-                self.kill_borrows_on_local(sets, &local, is_activations)\n+                self.kill_borrows_on_local(sets, &local)\n             }\n \n             mir::StatementKind::InlineAsm { ref outputs, ref asm, .. } => {\n@@ -424,7 +669,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                         if let Place::Local(ref local) = *output {\n                             // FIXME: Handle the case in which we're assigning over\n                             // a projection (`foo.bar`).\n-                            self.kill_borrows_on_local(sets, local, is_activations);\n+                            self.kill_borrows_on_local(sets, local);\n                         }\n                     }\n                 }\n@@ -438,48 +683,24 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn kill_borrows_on_local(&self,\n-                             sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                             local: &rustc::mir::Local,\n-                             is_activations: bool)\n-    {\n-        if let Some(borrow_indexes) = self.local_map.get(local) {\n-            sets.kill_all(borrow_indexes.iter()\n-                            .map(|b| ReserveOrActivateIndex::reserved(*b)));\n-            if is_activations {\n-                sets.kill_all(borrow_indexes.iter()\n-                                .map(|b| ReserveOrActivateIndex::active(*b)));\n-            }\n-        }\n+    fn before_terminator_effect(&self,\n+                                sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                                location: Location) {\n+        debug!(\"Borrows::before_terminator_effect sets: {:?} location: {:?}\", sets, location);\n+        self.kill_loans_out_of_scope_at_location(sets, location);\n     }\n \n-    /// Models terminator effect in Reservations and ActiveBorrows\n-    /// flow analyses; `is activations` tells us if we are in the\n-    /// latter case.\n-    fn terminator_effect_on_borrows(&self,\n-                                    sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                                    location: Location,\n-                                    is_activations: bool) {\n+    fn terminator_effect(&self, sets: &mut BlockSets<ReserveOrActivateIndex>, location: Location) {\n+        debug!(\"Borrows::terminator_effect sets: {:?} location: {:?}\", sets, location);\n+\n         let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n             panic!(\"could not find block at location {:?}\", location);\n         });\n \n-        // Do kills introduced by NLL before setting up any potential\n-        // gens. (See NOTE in kill_loans_out_of_scope_at_location.)\n-        self.kill_loans_out_of_scope_at_location(sets, location, is_activations);\n-\n         let term = block.terminator();\n-        if is_activations {\n-            // INVARIANT: `sets.on_entry` accurately captures\n-            // reservations on entry to terminator (b/c\n-            // accumulates_intrablock_state is overridden for\n-            // ActiveBorrows).\n-            //\n-            // Now compute effect of the terminator on the activations\n-            // themselves in the ActiveBorrows state.\n-            let mut find = FindPlaceUses { sets, assigned_map: &self.assigned_map };\n-            find.visit_terminator(location.block, term, location);\n-        }\n+        self.perform_activations_at_location(sets, location);\n+        self.kill_loans_out_of_scope_at_location(sets, location);\n+\n \n         match term.kind {\n             mir::TerminatorKind::Resume |\n@@ -501,9 +722,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                                 self.scope_tree.is_subscope_of(*scope, root_scope)\n                             {\n                                 sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n-                                if is_activations {\n-                                    sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n-                                }\n+                                sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n                             }\n                         }\n                     }\n@@ -522,161 +741,6 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             mir::TerminatorKind::Unreachable => {}\n         }\n     }\n-}\n-\n-impl<'a, 'gcx, 'tcx> ActiveBorrows<'a, 'gcx, 'tcx> {\n-    pub(crate) fn borrows(&self) -> &IndexVec<BorrowIndex, BorrowData<'tcx>> {\n-        self.0.borrows()\n-    }\n-\n-    /// Returns the span for the \"end point\" given region. This will\n-    /// return `None` if NLL is enabled, since that concept has no\n-    /// meaning there.  Otherwise, return region span if it exists and\n-    /// span for end of the function if it doesn't exist.\n-    pub(crate) fn opt_region_end_span(&self, region: &Region) -> Option<Span> {\n-        match self.0.nonlexical_regioncx {\n-            Some(_) => None,\n-            None => {\n-                match self.0.region_span_map.get(region) {\n-                    Some(span) => Some(self.0.tcx.sess.codemap().end_point(*span)),\n-                    None => Some(self.0.tcx.sess.codemap().end_point(self.0.mir.span))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// `FindPlaceUses` is a MIR visitor that updates `self.sets` for all\n-/// of the borrows activated by a given statement or terminator.\n-///\n-/// ----\n-///\n-/// The `ActiveBorrows` flow analysis, when inspecting any given\n-/// statement or terminator, needs to \"generate\" (i.e. set to 1) all\n-/// of the bits for the borrows that are activated by that\n-/// statement/terminator.\n-///\n-/// This struct will seek out all places that are assignment-targets\n-/// for borrows (gathered in `self.assigned_map`; see also the\n-/// `assigned_map` in `struct Borrows`), and set the corresponding\n-/// gen-bits for activations of those borrows in `self.sets`\n-struct FindPlaceUses<'a, 'b: 'a, 'tcx: 'a> {\n-    assigned_map: &'a FxHashMap<Place<'tcx>, FxHashSet<BorrowIndex>>,\n-    sets: &'a mut BlockSets<'b, ReserveOrActivateIndex>,\n-}\n-\n-impl<'a, 'b, 'tcx> FindPlaceUses<'a, 'b, 'tcx> {\n-    fn has_been_reserved(&self, b: &BorrowIndex) -> bool {\n-        self.sets.on_entry.contains(&ReserveOrActivateIndex::reserved(*b))\n-    }\n-\n-    /// return whether `context` should be considered a \"use\" of a\n-    /// place found in that context. \"Uses\" activate associated\n-    /// borrows (at least when such uses occur while the borrow also\n-    /// has a reservation at the time).\n-    fn is_potential_use(context: PlaceContext) -> bool {\n-        match context {\n-            // storage effects on a place do not activate it\n-            PlaceContext::StorageLive | PlaceContext::StorageDead => false,\n-\n-            // validation effects do not activate a place\n-            //\n-            // FIXME: Should they? Is it just another read? Or can we\n-            // guarantee it won't dereference the stored address? How\n-            // \"deep\" does validation go?\n-            PlaceContext::Validate => false,\n-\n-            // FIXME: This is here to not change behaviour from before\n-            // AsmOutput existed, but it's not necessarily a pure overwrite.\n-            // so it's possible this should activate the place.\n-            PlaceContext::AsmOutput |\n-            // pure overwrites of a place do not activate it. (note\n-            // PlaceContext::Call is solely about dest place)\n-            PlaceContext::Store | PlaceContext::Call => false,\n-\n-            // reads of a place *do* activate it\n-            PlaceContext::Move |\n-            PlaceContext::Copy |\n-            PlaceContext::Drop |\n-            PlaceContext::Inspect |\n-            PlaceContext::Borrow { .. } |\n-            PlaceContext::Projection(..) => true,\n-        }\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for FindPlaceUses<'a, 'b, 'tcx> {\n-    fn visit_place(&mut self,\n-                    place: &mir::Place<'tcx>,\n-                    context: PlaceContext<'tcx>,\n-                    location: Location) {\n-        debug!(\"FindPlaceUses place: {:?} assigned from borrows: {:?} \\\n-                used in context: {:?} at location: {:?}\",\n-               place, self.assigned_map.get(place), context, location);\n-        if Self::is_potential_use(context) {\n-            if let Some(borrows) = self.assigned_map.get(place) {\n-                for borrow_idx in borrows {\n-                    debug!(\"checking if index {:?} for {:?} is reserved ({}) \\\n-                            and thus needs active gen-bit set in sets {:?}\",\n-                           borrow_idx, place, self.has_been_reserved(&borrow_idx), self.sets);\n-                    if self.has_been_reserved(&borrow_idx) {\n-                        self.sets.gen(&ReserveOrActivateIndex::active(*borrow_idx));\n-                    } else {\n-                        // (This can certainly happen in valid code. I\n-                        // just want to know about it in the short\n-                        // term.)\n-                        debug!(\"encountered use of Place {:?} of borrow_idx {:?} \\\n-                                at location {:?} outside of reservation\",\n-                               place, borrow_idx, location);\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.super_place(place, context, location);\n-    }\n-}\n-\n-\n-impl<'a, 'gcx, 'tcx> BitDenotation for Reservations<'a, 'gcx, 'tcx> {\n-    type Idx = ReserveOrActivateIndex;\n-    fn name() -> &'static str { \"reservations\" }\n-    fn bits_per_block(&self) -> usize {\n-        self.0.borrows.len() * 2\n-    }\n-    fn start_block_effect(&self, _entry_set: &mut IdxSet<ReserveOrActivateIndex>)  {\n-        // no borrows of code region_scopes have been taken prior to\n-        // function execution, so this method has no effect on\n-        // `_sets`.\n-    }\n-\n-    fn before_statement_effect(&self,\n-                               sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                               location: Location) {\n-        debug!(\"Reservations::before_statement_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.kill_loans_out_of_scope_at_location(sets, location, false);\n-    }\n-\n-    fn statement_effect(&self,\n-                        sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                        location: Location) {\n-        debug!(\"Reservations::statement_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.statement_effect_on_borrows(sets, location, false);\n-    }\n-\n-    fn before_terminator_effect(&self,\n-                                sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                                location: Location) {\n-        debug!(\"Reservations::before_terminator_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.kill_loans_out_of_scope_at_location(sets, location, false);\n-    }\n-\n-    fn terminator_effect(&self,\n-                         sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                         location: Location) {\n-        debug!(\"Reservations::terminator_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.terminator_effect_on_borrows(sets, location, false);\n-    }\n \n     fn propagate_call_return(&self,\n                              _in_out: &mut IdxSet<ReserveOrActivateIndex>,\n@@ -691,85 +755,17 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Reservations<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for ActiveBorrows<'a, 'gcx, 'tcx> {\n-    type Idx = ReserveOrActivateIndex;\n-    fn name() -> &'static str { \"active_borrows\" }\n-\n-    /// Overriding this method; `ActiveBorrows` uses the intrablock\n-    /// state in `on_entry` to track the current reservations (which\n-    /// then affect the construction of the gen/kill sets for\n-    /// activations).\n-    fn accumulates_intrablock_state() -> bool { true }\n-\n-    fn bits_per_block(&self) -> usize {\n-        self.0.borrows.len() * 2\n-    }\n-\n-    fn start_block_effect(&self, _entry_sets: &mut IdxSet<ReserveOrActivateIndex>)  {\n-        // no borrows of code region_scopes have been taken prior to\n-        // function execution, so this method has no effect on\n-        // `_sets`.\n-    }\n-\n-    fn before_statement_effect(&self,\n-                               sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                               location: Location) {\n-        debug!(\"ActiveBorrows::before_statement_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.kill_loans_out_of_scope_at_location(sets, location, true);\n-    }\n-\n-    fn statement_effect(&self,\n-                        sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                        location: Location) {\n-        debug!(\"ActiveBorrows::statement_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.statement_effect_on_borrows(sets, location, true);\n-    }\n-\n-    fn before_terminator_effect(&self,\n-                                sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                                location: Location) {\n-        debug!(\"ActiveBorrows::before_terminator_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.kill_loans_out_of_scope_at_location(sets, location, true);\n-    }\n-\n-    fn terminator_effect(&self,\n-                         sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                         location: Location) {\n-        debug!(\"ActiveBorrows::terminator_effect sets: {:?} location: {:?}\", sets, location);\n-        self.0.terminator_effect_on_borrows(sets, location, true);\n-    }\n-\n-    fn propagate_call_return(&self,\n-                             _in_out: &mut IdxSet<ReserveOrActivateIndex>,\n-                             _call_bb: mir::BasicBlock,\n-                             _dest_bb: mir::BasicBlock,\n-                             _dest_place: &mir::Place) {\n-        // there are no effects on borrows from method call return...\n-        //\n-        // ... but If overwriting a place can affect flow state, then\n-        // latter is not true; see NOTE on Assign case in\n-        // statement_effect_on_borrows.\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> BitwiseOperator for Reservations<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for Borrows<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 | pred2 // union effects of preds when computing reservations\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for ActiveBorrows<'a, 'gcx, 'tcx> {\n-    #[inline]\n-    fn join(&self, pred1: usize, pred2: usize) -> usize {\n-        pred1 | pred2 // union effects of preds when computing activations\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> InitialFlow for Reservations<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for Borrows<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n-        false // bottom = no Rvalue::Refs are reserved by default\n+        false // bottom = nothing is reserved or activated yet\n     }\n }\n "}, {"sha": "f7675d611cc5c08de8e7f0688e1e401749e080cc", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=883e74645d350b6752cb94d48f46363f6f8789e9", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::mir::{self, Mir, BasicBlock, BasicBlockData, Location, Statement, Terminator};\n use rustc::session::Session;\n \n-use std::borrow::{Borrow, Cow};\n+use std::borrow::Borrow;\n use std::fmt;\n use std::io;\n use std::mem;\n@@ -31,7 +31,7 @@ pub use self::impls::{DefinitelyInitializedPlaces, MovingOutStatements};\n pub use self::impls::EverInitializedPlaces;\n pub use self::impls::borrows::{Borrows, BorrowData};\n pub use self::impls::HaveBeenBorrowedLocals;\n-pub(crate) use self::impls::borrows::{ActiveBorrows, Reservations, ReserveOrActivateIndex};\n+pub(crate) use self::impls::borrows::{ReserveOrActivateIndex};\n pub use self::at_location::{FlowAtLocation, FlowsAtLocation};\n pub(crate) use self::drop_flag_effects::*;\n \n@@ -584,9 +584,6 @@ impl<E:Idx> AllSets<E> {\n     pub fn on_entry_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n         self.lookup_set_for(&self.on_entry_sets, block_idx)\n     }\n-    pub(crate) fn entry_set_state(&self) -> &Bits<E> {\n-        &self.on_entry_sets\n-    }\n }\n \n /// Parameterization for the precise form of data flow that is used.\n@@ -739,27 +736,17 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n                dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n                denotation: D) -> Self where D: InitialFlow {\n         let bits_per_block = denotation.bits_per_block();\n+        let usize_bits = mem::size_of::<usize>() * 8;\n+        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n         let num_overall = Self::num_bits_overall(mir, bits_per_block);\n+\n+        let zeroes = Bits::new(IdxSetBuf::new_empty(num_overall));\n         let on_entry = Bits::new(if D::bottom_value() {\n             IdxSetBuf::new_filled(num_overall)\n         } else {\n             IdxSetBuf::new_empty(num_overall)\n         });\n \n-        Self::new_with_entry_sets(mir, dead_unwinds, Cow::Owned(on_entry), denotation)\n-    }\n-\n-    pub(crate) fn new_with_entry_sets(mir: &'a Mir<'tcx>,\n-                                      dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n-                                      on_entry: Cow<Bits<D::Idx>>,\n-                                      denotation: D)\n-                                      -> Self {\n-        let bits_per_block = denotation.bits_per_block();\n-        let usize_bits = mem::size_of::<usize>() * 8;\n-        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n-        let num_overall = Self::num_bits_overall(mir, bits_per_block);\n-        assert_eq!(num_overall, on_entry.bits.words().len() * usize_bits);\n-        let zeroes = Bits::new(IdxSetBuf::new_empty(num_overall));\n         DataflowAnalysis {\n             mir,\n             dead_unwinds,\n@@ -769,13 +756,27 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n                     words_per_block,\n                     gen_sets: zeroes.clone(),\n                     kill_sets: zeroes,\n-                    on_entry_sets: on_entry.into_owned(),\n+                    on_entry_sets: on_entry,\n                 },\n                 operator: denotation,\n             }\n         }\n     }\n \n+    pub fn new_from_sets(mir: &'a Mir<'tcx>,\n+                         dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n+                         sets: AllSets<D::Idx>,\n+                         denotation: D) -> Self {\n+        DataflowAnalysis {\n+            mir,\n+            dead_unwinds,\n+            flow_state: DataflowState {\n+                sets: sets,\n+                operator: denotation,\n+            }\n+        }\n+    }\n+\n     fn num_bits_overall(mir: &Mir, bits_per_block: usize) -> usize {\n         let usize_bits = mem::size_of::<usize>() * 8;\n         let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;"}, {"sha": "90933c6b31fa868b8ce7bffe37ce552130639be9", "filename": "src/test/compile-fail/borrowck/two-phase-activation-sharing-interference.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs?ref=883e74645d350b6752cb94d48f46363f6f8789e9", "patch": "@@ -10,10 +10,12 @@\n \n // ignore-tidy-linelength\n \n-// revisions: lxl_beyond nll_beyond nll_target\n+// revisions: nll_target\n \n+// The following revisions are disabled due to missing support from two-phase beyond autorefs\n //[lxl_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref\n //[nll_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref -Z nll\n+\n //[nll_target] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n \n // This is an important corner case pointed out by Niko: one is\n@@ -51,7 +53,6 @@ fn not_ok() {\n     *y += 1;\n     //[lxl_beyond]~^   ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n     //[nll_beyond]~^^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n-    //[nll_target]~^^^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n     read(z);\n }\n "}, {"sha": "d2f4154433ab152b4c9a8eac7657d97233162788", "filename": "src/test/compile-fail/borrowck/two-phase-allow-access-during-reservation.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-allow-access-during-reservation.rs?ref=883e74645d350b6752cb94d48f46363f6f8789e9", "patch": "@@ -10,9 +10,13 @@\n \n // ignore-tidy-linelength\n \n-// revisions: lxl_beyond nll_beyond nll_target\n+// revisions: nll_target\n+\n+// The following revisions are disabled due to missing support for two_phase_beyond_autoref\n //[lxl_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two_phase_beyond_autoref\n //[nll_beyond] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two_phase_beyond_autoref -Z nll\n+\n+\n //[nll_target] compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n \n // This is the second counter-example from Niko's blog post"}, {"sha": "bf8e02adb1ae6580ae5d9cdaf93fbf9ea4f7bded", "filename": "src/test/compile-fail/borrowck/two-phase-nonrecv-autoref.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs?ref=883e74645d350b6752cb94d48f46363f6f8789e9", "patch": "@@ -8,10 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll g2p\n+// revisions: lxl nll\n //[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n //[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+\n //[g2p]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll -Z two-phase-beyond-autoref\n+// the above revision is disabled until two-phase-beyond-autoref support is better\n \n // This is a test checking that when we limit two-phase borrows to\n // method receivers, we do not let other kinds of auto-ref to leak\n@@ -70,10 +72,8 @@ fn overloaded_call_traits() {\n     fn twice_ten_sm<F: FnMut(i32) -> i32>(f: &mut F) {\n         f(f(10));\n         //[lxl]~^     ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[lxl]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[nll]~^^^   ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[nll]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[g2p]~^^^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[nll]~^^   ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[g2p]~^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n     }\n     fn twice_ten_si<F: Fn(i32) -> i32>(f: &mut F) {\n         f(f(10));\n@@ -88,10 +88,8 @@ fn overloaded_call_traits() {\n     fn twice_ten_om(f: &mut FnMut(i32) -> i32) {\n         f(f(10));\n         //[lxl]~^     ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[lxl]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[nll]~^^^   ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[nll]~|     ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[g2p]~^^^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[nll]~^^   ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[g2p]~^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n     }\n     fn twice_ten_oi(f: &mut Fn(i32) -> i32) {\n         f(f(10));"}, {"sha": "058022ad588e85beb9ceae07b977a9e0bfbf0146", "filename": "src/test/compile-fail/borrowck/two-phase-reservation-sharing-interference.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-reservation-sharing-interference.rs?ref=883e74645d350b6752cb94d48f46363f6f8789e9", "patch": "@@ -12,8 +12,12 @@\n \n // revisions: lxl_beyond nll_beyond nll_target\n \n+// The following revisions are disabled due to missing support from two-phase beyond autorefs\n //[lxl_beyond]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref\n+//[lxl_beyond] should-fail\n //[nll_beyond]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z two-phase-beyond-autoref -Z nll\n+//[nll_beyond] should-fail\n+\n //[nll_target]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n \n // This is a corner case that the current implementation is (probably)\n@@ -31,10 +35,6 @@\n // \"nll_beyond\" means the generalization of two-phase borrows to all\n // `&mut`-borrows (doing so makes it easier to write code for specific\n // corner cases).\n-//\n-// FIXME: in \"nll_target\", we currently see the same error reported\n-// twice. This is injected by `-Z two-phase-borrows`; not sure why as\n-// of yet.\n \n fn main() {\n     let mut vec = vec![0, 1];\n@@ -49,7 +49,6 @@ fn main() {\n         //[lxl_beyond]~^   ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n         //[nll_beyond]~^^  ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n         //[nll_target]~^^^ ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n-        //[nll_target]~|   ERROR cannot borrow `vec` as mutable because it is also borrowed as immutable\n \n         shared[0];\n     }"}, {"sha": "a906d193d995e3af7305a887524d7e43da7228b9", "filename": "src/test/ui/issue-45157.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Ftest%2Fui%2Fissue-45157.rs", "raw_url": "https://github.com/rust-lang/rust/raw/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Ftest%2Fui%2Fissue-45157.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-45157.rs?ref=883e74645d350b6752cb94d48f46363f6f8789e9", "patch": "@@ -37,7 +37,6 @@ fn main() {\n         let nref = &u.z.c;\n         //~^ ERROR cannot borrow `u.z.c` as immutable because it is also borrowed as mutable [E0502]\n         println!(\"{} {}\", mref, nref)\n-        //~^ ERROR cannot borrow `u.s.a` as mutable because it is also borrowed as immutable [E0502]\n     }\n }\n "}, {"sha": "07102f68633cf44d26af0d256f6d9f753ce9b2b5", "filename": "src/test/ui/issue-45157.stderr", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Ftest%2Fui%2Fissue-45157.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/883e74645d350b6752cb94d48f46363f6f8789e9/src%2Ftest%2Fui%2Fissue-45157.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-45157.stderr?ref=883e74645d350b6752cb94d48f46363f6f8789e9", "patch": "@@ -10,17 +10,6 @@ LL |         //~^ ERROR cannot borrow `u.z.c` as immutable because it is also bo\n LL |         println!(\"{} {}\", mref, nref)\n    |                           ---- borrow later used here\n \n-error[E0502]: cannot borrow `u.s.a` as mutable because it is also borrowed as immutable\n-  --> $DIR/issue-45157.rs:39:27\n-   |\n-LL |         let nref = &u.z.c;\n-   |                    ------ immutable borrow occurs here\n-LL |         //~^ ERROR cannot borrow `u.z.c` as immutable because it is also borrowed as mutable [E0502]\n-LL |         println!(\"{} {}\", mref, nref)\n-   |                           ^^^^  ---- borrow later used here\n-   |                           |\n-   |                           mutable borrow occurs here\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n If you want more information on this error, try using \"rustc --explain E0502\""}]}