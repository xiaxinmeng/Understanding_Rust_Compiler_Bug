{"sha": "2fdccaffe632e316c43224d0fae6fba903333aa3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmZGNjYWZmZTYzMmUzMTZjNDMyMjRkMGZhZTZmYmE5MDMzMzNhYTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-12T21:39:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-12T21:39:08Z"}, "message": "Auto merge of #44015 - kennytm:hasher, r=alexcrichton\n\n impl Hasher for {&mut Hasher, Box<Hasher>}\n\n**Rationale:** The `Hash` trait has `fn hash<H: Hasher>(&self, state: &mut H)`, which can only accept a `Sized` hasher, even if the `Hasher` trait is object-safe. We cannot retroactively add the `?Sized` bound without breaking stability, thus implementing `Hasher` to a trait object reference is the next best solution.\n\n**Warning:** These `impl` are insta-stable, and should need an FCP. I don't think a full RFC is necessary.", "tree": {"sha": "8c4b986ac2c0e210e943e60146ada289396b6a8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c4b986ac2c0e210e943e60146ada289396b6a8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fdccaffe632e316c43224d0fae6fba903333aa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fdccaffe632e316c43224d0fae6fba903333aa3", "html_url": "https://github.com/rust-lang/rust/commit/2fdccaffe632e316c43224d0fae6fba903333aa3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fdccaffe632e316c43224d0fae6fba903333aa3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd08c30703d052205a68ae34331eea464178cd99", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd08c30703d052205a68ae34331eea464178cd99", "html_url": "https://github.com/rust-lang/rust/commit/dd08c30703d052205a68ae34331eea464178cd99"}, {"sha": "143e2dcd5ce3a7ba5953378cde0f2850850d6e9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/143e2dcd5ce3a7ba5953378cde0f2850850d6e9f", "html_url": "https://github.com/rust-lang/rust/commit/143e2dcd5ce3a7ba5953378cde0f2850850d6e9f"}], "stats": {"total": 126, "additions": 124, "deletions": 2}, "files": [{"sha": "4341b0b2975beeb9fccf93bb750153a929d61403", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2fdccaffe632e316c43224d0fae6fba903333aa3/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdccaffe632e316c43224d0fae6fba903333aa3/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=2fdccaffe632e316c43224d0fae6fba903333aa3", "patch": "@@ -62,7 +62,7 @@ use core::any::Any;\n use core::borrow;\n use core::cmp::Ordering;\n use core::fmt;\n-use core::hash::{self, Hash};\n+use core::hash::{self, Hash, Hasher};\n use core::iter::FusedIterator;\n use core::marker::{self, Unsize};\n use core::mem;\n@@ -456,6 +456,52 @@ impl<T: ?Sized + Hash> Hash for Box<T> {\n     }\n }\n \n+#[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\n+impl<T: ?Sized + Hasher> Hasher for Box<T> {\n+    fn finish(&self) -> u64 {\n+        (**self).finish()\n+    }\n+    fn write(&mut self, bytes: &[u8]) {\n+        (**self).write(bytes)\n+    }\n+    fn write_u8(&mut self, i: u8) {\n+        (**self).write_u8(i)\n+    }\n+    fn write_u16(&mut self, i: u16) {\n+        (**self).write_u16(i)\n+    }\n+    fn write_u32(&mut self, i: u32) {\n+        (**self).write_u32(i)\n+    }\n+    fn write_u64(&mut self, i: u64) {\n+        (**self).write_u64(i)\n+    }\n+    fn write_u128(&mut self, i: u128) {\n+        (**self).write_u128(i)\n+    }\n+    fn write_usize(&mut self, i: usize) {\n+        (**self).write_usize(i)\n+    }\n+    fn write_i8(&mut self, i: i8) {\n+        (**self).write_i8(i)\n+    }\n+    fn write_i16(&mut self, i: i16) {\n+        (**self).write_i16(i)\n+    }\n+    fn write_i32(&mut self, i: i32) {\n+        (**self).write_i32(i)\n+    }\n+    fn write_i64(&mut self, i: i64) {\n+        (**self).write_i64(i)\n+    }\n+    fn write_i128(&mut self, i: i128) {\n+        (**self).write_i128(i)\n+    }\n+    fn write_isize(&mut self, i: isize) {\n+        (**self).write_isize(i)\n+    }\n+}\n+\n #[stable(feature = \"from_for_ptrs\", since = \"1.6.0\")]\n impl<T> From<T> for Box<T> {\n     fn from(t: T) -> Self {"}, {"sha": "2845d349ae165b0961467201e2cd4e30b87e39a4", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fdccaffe632e316c43224d0fae6fba903333aa3/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdccaffe632e316c43224d0fae6fba903333aa3/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=2fdccaffe632e316c43224d0fae6fba903333aa3", "patch": "@@ -121,7 +121,7 @@\n #![feature(unsize)]\n #![feature(allocator_internals)]\n \n-#![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol, swap_with_slice))]\n+#![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol, swap_with_slice, i128))]\n #![cfg_attr(test, feature(test, box_heap))]\n \n // Allow testing this library"}, {"sha": "c5beb63d12e9d0f07052b3fd1d38f54d30198f61", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2fdccaffe632e316c43224d0fae6fba903333aa3/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdccaffe632e316c43224d0fae6fba903333aa3/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=2fdccaffe632e316c43224d0fae6fba903333aa3", "patch": "@@ -50,3 +50,19 @@ fn hash<T: Hash>(t: &T) -> u64 {\n     t.hash(&mut s);\n     s.finish()\n }\n+\n+// FIXME: Instantiated functions with i128 in the signature is not supported in Emscripten.\n+// See https://github.com/kripken/emscripten-fastcomp/issues/169\n+#[cfg(not(target_os = \"emscripten\"))]\n+#[test]\n+fn test_boxed_hasher() {\n+    let ordinary_hash = hash(&5u32);\n+\n+    let mut hasher_1 = Box::new(DefaultHasher::new());\n+    5u32.hash(&mut hasher_1);\n+    assert_eq!(ordinary_hash, hasher_1.finish());\n+\n+    let mut hasher_2 = Box::new(DefaultHasher::new()) as Box<Hasher>;\n+    5u32.hash(&mut hasher_2);\n+    assert_eq!(ordinary_hash, hasher_2.finish());\n+}"}, {"sha": "bc1b911cd78ccdc97d54e531516bbed6bc1b2670", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2fdccaffe632e316c43224d0fae6fba903333aa3/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdccaffe632e316c43224d0fae6fba903333aa3/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=2fdccaffe632e316c43224d0fae6fba903333aa3", "patch": "@@ -359,6 +359,52 @@ pub trait Hasher {\n     }\n }\n \n+#[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\n+impl<'a, H: Hasher + ?Sized> Hasher for &'a mut H {\n+    fn finish(&self) -> u64 {\n+        (**self).finish()\n+    }\n+    fn write(&mut self, bytes: &[u8]) {\n+        (**self).write(bytes)\n+    }\n+    fn write_u8(&mut self, i: u8) {\n+        (**self).write_u8(i)\n+    }\n+    fn write_u16(&mut self, i: u16) {\n+        (**self).write_u16(i)\n+    }\n+    fn write_u32(&mut self, i: u32) {\n+        (**self).write_u32(i)\n+    }\n+    fn write_u64(&mut self, i: u64) {\n+        (**self).write_u64(i)\n+    }\n+    fn write_u128(&mut self, i: u128) {\n+        (**self).write_u128(i)\n+    }\n+    fn write_usize(&mut self, i: usize) {\n+        (**self).write_usize(i)\n+    }\n+    fn write_i8(&mut self, i: i8) {\n+        (**self).write_i8(i)\n+    }\n+    fn write_i16(&mut self, i: i16) {\n+        (**self).write_i16(i)\n+    }\n+    fn write_i32(&mut self, i: i32) {\n+        (**self).write_i32(i)\n+    }\n+    fn write_i64(&mut self, i: i64) {\n+        (**self).write_i64(i)\n+    }\n+    fn write_i128(&mut self, i: i128) {\n+        (**self).write_i128(i)\n+    }\n+    fn write_isize(&mut self, i: isize) {\n+        (**self).write_isize(i)\n+    }\n+}\n+\n /// A trait for creating instances of [`Hasher`].\n ///\n /// A `BuildHasher` is typically used (e.g. by [`HashMap`]) to create"}, {"sha": "e8ea6044f5ffe9b627a7d7dc5dc12796c15380ea", "filename": "src/libcore/tests/hash/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2fdccaffe632e316c43224d0fae6fba903333aa3/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdccaffe632e316c43224d0fae6fba903333aa3/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs?ref=2fdccaffe632e316c43224d0fae6fba903333aa3", "patch": "@@ -109,3 +109,16 @@ fn test_custom_state() {\n \n     assert_eq!(hash(&Custom { hash: 5 }), 5);\n }\n+\n+// FIXME: Instantiated functions with i128 in the signature is not supported in Emscripten.\n+// See https://github.com/kripken/emscripten-fastcomp/issues/169\n+#[cfg(not(target_os = \"emscripten\"))]\n+#[test]\n+fn test_indirect_hasher() {\n+    let mut hasher = MyHasher { hash: 0 };\n+    {\n+        let mut indirect_hasher: &mut Hasher = &mut hasher;\n+        5u32.hash(&mut indirect_hasher);\n+    }\n+    assert_eq!(hasher.hash, 5);\n+}"}, {"sha": "fdbcfd10bde7cc2377be9925e63636de7ad98f30", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fdccaffe632e316c43224d0fae6fba903333aa3/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fdccaffe632e316c43224d0fae6fba903333aa3/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=2fdccaffe632e316c43224d0fae6fba903333aa3", "patch": "@@ -76,6 +76,7 @@ const EXCEPTION_PATHS: &'static [&'static str] = &[\n \n     // std testing crates, ok for now at least\n     \"src/libcore/tests\",\n+    \"src/liballoc/tests/lib.rs\",\n \n     // non-std crates\n     \"src/test\","}]}