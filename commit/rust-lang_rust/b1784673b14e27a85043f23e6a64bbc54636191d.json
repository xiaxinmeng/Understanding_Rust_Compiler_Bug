{"sha": "b1784673b14e27a85043f23e6a64bbc54636191d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxNzg0NjczYjE0ZTI3YTg1MDQzZjIzZTZhNjRiYmM1NDYzNjE5MWQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-02T18:56:07Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-02T18:59:37Z"}, "message": "Clean up task.rs docs and use replace/swap_unwrap", "tree": {"sha": "87e1fbc5c851f190ec31fd85f544fca44ce69d1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87e1fbc5c851f190ec31fd85f544fca44ce69d1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1784673b14e27a85043f23e6a64bbc54636191d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1784673b14e27a85043f23e6a64bbc54636191d", "html_url": "https://github.com/rust-lang/rust/commit/b1784673b14e27a85043f23e6a64bbc54636191d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1784673b14e27a85043f23e6a64bbc54636191d/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9facb15c49488901e0a1a91af016b9516b5a124f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9facb15c49488901e0a1a91af016b9516b5a124f", "html_url": "https://github.com/rust-lang/rust/commit/9facb15c49488901e0a1a91af016b9516b5a124f"}], "stats": {"total": 68, "additions": 27, "deletions": 41}, "files": [{"sha": "576e7244b69fd42405bf003e455b0c0944d1a7f0", "filename": "src/libcore/task.rs", "status": "modified", "additions": 27, "deletions": 41, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b1784673b14e27a85043f23e6a64bbc54636191d/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1784673b14e27a85043f23e6a64bbc54636191d/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=b1784673b14e27a85043f23e6a64bbc54636191d", "patch": "@@ -144,12 +144,12 @@ type sched_opts = {\n  *\n  * # Fields\n  *\n- * * linked - Do not propagate failure to the parent task\n+ * * linked - Propagate failure bidirectionally between child and parent.\n+ *            True by default. If both this and 'supervised' are false, then\n+ *            either task's failure will not affect the other (\"unlinked\").\n  *\n- *     All tasks are linked together via a tree, from parents to children. By\n- *     default children are 'supervised' by their parent and when they fail\n- *     so too will their parents. Settings this flag to false disables that\n- *     behavior.\n+ * * supervised - Propagate failure unidirectionally from parent to child,\n+ *                but not from child to parent. False by default.\n  *\n  * * notify_chan - Enable lifecycle notifications on the given channel\n  *\n@@ -168,7 +168,7 @@ type sched_opts = {\n  */\n type task_opts = {\n     linked: bool,\n-    parented: bool,\n+    supervised: bool,\n     notify_chan: option<comm::chan<notification>>,\n     sched: option<sched_opts>,\n };\n@@ -237,7 +237,7 @@ impl task_builder for task_builder {\n      */\n     fn supervised() -> task_builder {\n         task_builder({\n-            opts: { linked: false, parented: true with self.opts },\n+            opts: { linked: false, supervised: true with self.opts },\n             can_not_copy: none,\n             with *self.consume()\n         })\n@@ -248,7 +248,7 @@ impl task_builder for task_builder {\n      */\n     fn linked() -> task_builder {\n         task_builder({\n-            opts: { linked: true, parented: false with self.opts },\n+            opts: { linked: true, supervised: false with self.opts },\n             can_not_copy: none,\n             with *self.consume()\n         })\n@@ -342,9 +342,7 @@ impl task_builder for task_builder {\n     fn spawn_with<A: send>(+arg: A, +f: fn~(+A)) {\n         let arg = ~mut some(arg);\n         do self.spawn {\n-            let mut my_arg = none;\n-            my_arg <-> *arg;\n-            f(option::unwrap(my_arg))\n+            f(option::swap_unwrap(arg))\n         }\n     }\n \n@@ -385,7 +383,7 @@ fn default_task_opts() -> task_opts {\n \n     {\n         linked: true,\n-        parented: false,\n+        supervised: false,\n         notify_chan: none,\n         sched: none\n     }\n@@ -599,14 +597,14 @@ unsafe fn atomically<U>(f: fn() -> U) -> U {\n  *\n  * (2) The \"tcb\" is a per-task control structure that tracks a task's spawn\n  *     configuration. It contains a reference to its taskgroup_arc, a\n- *     a reference to its node in the ancestor list (below), a flag for\n+ *     reference to its node in the ancestor list (below), a flag for\n  *     whether it's part of the 'main'/'root' taskgroup, and an optionally\n  *     configured notification port. These are stored in TLS.\n  *\n  * (3) The \"ancestor_list\" is a cons-style list of arc::exclusives which\n  *     tracks 'generations' of taskgroups -- a group's ancestors are groups\n  *     which (directly or transitively) spawn_supervised-ed them. Each task\n- *     recorded in the 'descendants' of each of its ancestor groups.\n+ *     is recorded in the 'descendants' of each of its ancestor groups.\n  *\n  *     Spawning a supervised task is O(n) in the number of generations still\n  *     alive, and exiting (by success or failure) that task is also O(n).\n@@ -753,8 +751,7 @@ fn each_ancestor(list:        &mut ancestor_list,\n                 forward_blk:     fn(taskgroup_inner) -> bool,\n                 last_generation: uint) -> bool {\n         // Need to swap the list out to use it, to appease borrowck.\n-        let mut tmp_list = ancestor_list(none);\n-        *list <-> tmp_list;\n+        let tmp_list = util::replace(list, ancestor_list(none));\n         let (coalesce_this, early_break) =\n             iterate(tmp_list, bail_opt, forward_blk, last_generation);\n         // What should our next ancestor end up being?\n@@ -841,9 +838,9 @@ fn each_ancestor(list:        &mut ancestor_list,\n                 need_unwind = need_unwind || !do_continue;\n                 // Tell caller whether or not to coalesce and/or unwind\n                 if nobe_is_dead {\n-                    let mut rest = ancestor_list(none);\n                     // Swap the list out here; the caller replaces us with it.\n-                    nobe.ancestors <-> rest;\n+                    let rest = util::replace(&mut nobe.ancestors,\n+                                             ancestor_list(none));\n                     (some(rest), need_unwind)\n                 } else {\n                     (none, need_unwind)\n@@ -854,11 +851,8 @@ fn each_ancestor(list:        &mut ancestor_list,\n         // Wrapper around exclusive::with that appeases borrowck.\n         fn with_parent_tg<U>(parent_group: &mut option<taskgroup_arc>,\n                              blk: fn(taskgroup_inner) -> U) -> U {\n-            let mut tmp = none;\n-            *parent_group <-> tmp;\n             // If this trips, more likely the problem is 'blk' failed inside.\n-            assert tmp.is_some();\n-            let tmp_arc = option::unwrap(tmp);\n+            let tmp_arc = option::swap_unwrap(parent_group);\n             let result = do access_group(tmp_arc) |tg_opt| { blk(tg_opt) };\n             *parent_group <- some(tmp_arc);\n             result\n@@ -923,8 +917,7 @@ class auto_notify {\n \n fn enlist_in_taskgroup(state: taskgroup_inner, me: *rust_task,\n                        is_member: bool) -> bool {\n-    let mut newstate = none;\n-    *state <-> newstate;\n+    let newstate = util::replace(state, none);\n     // If 'none', the group was failing. Can't enlist.\n     if newstate.is_some() {\n         let group = option::unwrap(newstate);\n@@ -939,8 +932,7 @@ fn enlist_in_taskgroup(state: taskgroup_inner, me: *rust_task,\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n fn leave_taskgroup(state: taskgroup_inner, me: *rust_task, is_member: bool) {\n-    let mut newstate = none;\n-    *state <-> newstate;\n+    let newstate = util::replace(state, none);\n     // If 'none', already failing and we've already gotten a kill signal.\n     if newstate.is_some() {\n         let group = option::unwrap(newstate);\n@@ -960,8 +952,7 @@ fn kill_taskgroup(state: taskgroup_inner, me: *rust_task, is_main: bool) {\n     // so if we're failing, all concurrently exiting tasks must wait for us.\n     // To do it differently, we'd have to use the runtime's task refcounting,\n     // but that could leave task structs around long after their task exited.\n-    let mut newstate = none;\n-    *state <-> newstate;\n+    let newstate = util::replace(state, none);\n     // Might already be none, if somebody is failing simultaneously.\n     // That's ok; only one task needs to do the dirty work. (Might also\n     // see 'none' if somebody already failed and we got a kill signal.)\n@@ -1059,8 +1050,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         // alt ancestors\n         //    some(ancestor_arc) { ancestor_list(some(ancestor_arc.clone())) }\n         //    none               { ancestor_list(none) }\n-        let mut tmp = none;\n-        **ancestors <-> tmp;\n+        let tmp = util::replace(&mut **ancestors, none);\n         if tmp.is_some() {\n             let ancestor_arc = option::unwrap(tmp);\n             let result = ancestor_arc.clone();\n@@ -1074,16 +1064,14 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n \n fn spawn_raw(opts: task_opts, +f: fn~()) {\n     let (child_tg, ancestors, is_main) =\n-        gen_child_taskgroup(opts.linked, opts.parented);\n+        gen_child_taskgroup(opts.linked, opts.supervised);\n \n     unsafe {\n-        let child_data_ptr = ~mut some((child_tg, ancestors, f));\n+        let child_data = ~mut some((child_tg, ancestors, f));\n         // Being killed with the unsafe task/closure pointers would leak them.\n         do unkillable {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n-            let mut child_data = none;\n-            *child_data_ptr <-> child_data;\n-            let (child_tg, ancestors, f) = option::unwrap(child_data);\n+            let (child_tg, ancestors, f) = option::swap_unwrap(child_data);\n             // Create child task.\n             let new_task = alt opts.sched {\n               none             { rustrt::new_task() }\n@@ -1116,12 +1104,10 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n                           -ancestors: ancestor_list, is_main: bool,\n                           notify_chan: option<comm::chan<notification>>,\n                           -f: fn~()) -> fn~() {\n-        let child_tg_ptr = ~mut some((child_arc, ancestors));\n+        let child_data = ~mut some((child_arc, ancestors));\n         return fn~() {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n-            let mut tg_data_opt = none;\n-            *child_tg_ptr <-> tg_data_opt;\n-            let mut (child_arc, ancestors) = option::unwrap(tg_data_opt);\n+            let mut (child_arc, ancestors) = option::swap_unwrap(child_data);\n             // Child task runs this code.\n \n             // Even if the below code fails to kick the child off, we must\n@@ -1528,7 +1514,7 @@ fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n     // they don't make sense (redundant with task().supervised()).\n     let b0 = task();\n     let b1 = task_builder({\n-        opts: { linked: true, parented: true with b0.opts },\n+        opts: { linked: true, supervised: true with b0.opts },\n         can_not_copy: none,\n         with *b0\n     });\n@@ -1541,7 +1527,7 @@ fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n     // they don't make sense (redundant with task().supervised()).\n     let b0 = task();\n     let b1 = task_builder({\n-        opts: { linked: true, parented: true with b0.opts },\n+        opts: { linked: true, supervised: true with b0.opts },\n         can_not_copy: none,\n         with *b0\n     });"}]}