{"sha": "1a4faaffd7608553528e19d1ad973cedf017e3ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhNGZhYWZmZDc2MDg1NTM1MjhlMTlkMWFkOTczY2VkZjAxN2UzY2U=", "commit": {"author": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-02-09T10:33:30Z"}, "committer": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-02-09T10:47:23Z"}, "message": "auto_import: use ra_fmt", "tree": {"sha": "6c980cd32cd60884c6a014b3718fc75a5a035ce1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c980cd32cd60884c6a014b3718fc75a5a035ce1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a4faaffd7608553528e19d1ad973cedf017e3ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a4faaffd7608553528e19d1ad973cedf017e3ce", "html_url": "https://github.com/rust-lang/rust/commit/1a4faaffd7608553528e19d1ad973cedf017e3ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a4faaffd7608553528e19d1ad973cedf017e3ce/comments", "author": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee9b0c89e6a35b09dea708c0c0c619e1812f290e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee9b0c89e6a35b09dea708c0c0c619e1812f290e", "html_url": "https://github.com/rust-lang/rust/commit/ee9b0c89e6a35b09dea708c0c0c619e1812f290e"}], "stats": {"total": 138, "additions": 29, "deletions": 109}, "files": [{"sha": "6a0c351f199444af8e0677b69b1498348f40ad1d", "filename": "crates/ra_assists/src/auto_import.rs", "status": "modified", "additions": 29, "deletions": 109, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/1a4faaffd7608553528e19d1ad973cedf017e3ce/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4faaffd7608553528e19d1ad973cedf017e3ce/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fauto_import.rs?ref=1a4faaffd7608553528e19d1ad973cedf017e3ce", "patch": "@@ -5,42 +5,6 @@ use ra_syntax::{\n };\n use crate::assist_ctx::{AssistCtx, Assist, AssistBuilder};\n \n-// TODO: refactor this before merge\n-mod formatting {\n-    use ra_syntax::{\n-        AstNode, SyntaxNode,\n-        ast::{self, AstToken},\n-        algo::generate,\n-};\n-\n-    /// If the node is on the beginning of the line, calculate indent.\n-    pub fn leading_indent(node: &SyntaxNode) -> Option<&str> {\n-        for leaf in prev_leaves(node) {\n-            if let Some(ws) = ast::Whitespace::cast(leaf) {\n-                let ws_text = ws.text();\n-                if let Some(pos) = ws_text.rfind('\\n') {\n-                    return Some(&ws_text[pos + 1..]);\n-                }\n-            }\n-            if leaf.leaf_text().unwrap().contains('\\n') {\n-                break;\n-            }\n-        }\n-        None\n-    }\n-\n-    fn prev_leaves(node: &SyntaxNode) -> impl Iterator<Item = &SyntaxNode> {\n-        generate(prev_leaf(node), |&node| prev_leaf(node))\n-    }\n-\n-    fn prev_leaf(node: &SyntaxNode) -> Option<&SyntaxNode> {\n-        generate(node.ancestors().find_map(SyntaxNode::prev_sibling), |it| {\n-            it.last_child()\n-        })\n-        .last()\n-    }\n-}\n-\n fn collect_path_segments(path: &ast::Path) -> Option<Vec<&ast::PathSegment>> {\n     let mut v = Vec::new();\n     collect_path_segments_raw(&mut v, path)?;\n@@ -102,11 +66,7 @@ fn fmt_segments_raw(segments: &[&ast::PathSegment], buf: &mut String) {\n \n // Returns the numeber of common segments.\n fn compare_path_segments(left: &[&ast::PathSegment], right: &[&ast::PathSegment]) -> usize {\n-    return left\n-        .iter()\n-        .zip(right)\n-        .filter(|(l, r)| compare_path_segment(l, r))\n-        .count();\n+    return left.iter().zip(right).filter(|(l, r)| compare_path_segment(l, r)).count();\n }\n \n fn compare_path_segment(a: &ast::PathSegment, b: &ast::PathSegment) -> bool {\n@@ -166,10 +126,7 @@ enum ImportAction<'a> {\n \n impl<'a> ImportAction<'a> {\n     fn add_new_use(anchor: Option<&'a SyntaxNode>, add_after_anchor: bool) -> Self {\n-        ImportAction::AddNewUse {\n-            anchor,\n-            add_after_anchor,\n-        }\n+        ImportAction::AddNewUse { anchor, add_after_anchor }\n     }\n \n     fn add_nested_import(\n@@ -191,11 +148,7 @@ impl<'a> ImportAction<'a> {\n         tree_list: &'a ast::UseTreeList,\n         add_self: bool,\n     ) -> Self {\n-        ImportAction::AddInTreeList {\n-            common_segments,\n-            tree_list,\n-            add_self,\n-        }\n+        ImportAction::AddInTreeList { common_segments, tree_list, add_self }\n     }\n \n     fn better<'b>(left: &'b ImportAction<'a>, right: &'b ImportAction<'a>) -> &'b ImportAction<'a> {\n@@ -211,20 +164,12 @@ impl<'a> ImportAction<'a> {\n             (ImportAction::Nothing, _) => true,\n             (ImportAction::AddInTreeList { .. }, ImportAction::Nothing) => false,\n             (\n-                ImportAction::AddNestedImport {\n-                    common_segments: n, ..\n-                },\n-                ImportAction::AddInTreeList {\n-                    common_segments: m, ..\n-                },\n+                ImportAction::AddNestedImport { common_segments: n, .. },\n+                ImportAction::AddInTreeList { common_segments: m, .. },\n             ) => n > m,\n             (\n-                ImportAction::AddInTreeList {\n-                    common_segments: n, ..\n-                },\n-                ImportAction::AddNestedImport {\n-                    common_segments: m, ..\n-                },\n+                ImportAction::AddInTreeList { common_segments: n, .. },\n+                ImportAction::AddNestedImport { common_segments: m, .. },\n             ) => n > m,\n             (ImportAction::AddInTreeList { .. }, _) => true,\n             (ImportAction::AddNestedImport { .. }, ImportAction::Nothing) => false,\n@@ -283,11 +228,7 @@ fn walk_use_tree_for_best_action<'a>(\n             // e.g: target is std::fmt and we can have\n             // use foo::bar\n             // We add a brand new use statement\n-            current_use_tree\n-                .syntax()\n-                .ancestors()\n-                .find_map(ast::UseItem::cast)\n-                .map(AstNode::syntax),\n+            current_use_tree.syntax().ancestors().find_map(ast::UseItem::cast).map(AstNode::syntax),\n             true,\n         ),\n         common if common == left.len() && left.len() == right.len() => {\n@@ -398,8 +339,7 @@ fn best_action_for_target<'b, 'a: 'b>(\n         .filter_map(ast::UseItem::use_tree)\n         .map(|u| walk_use_tree_for_best_action(&mut storage, None, u, target))\n         .fold(None, |best, a| {\n-            best.and_then(|best| Some(*ImportAction::better(&best, &a)))\n-                .or(Some(a))\n+            best.and_then(|best| Some(*ImportAction::better(&best, &a))).or(Some(a))\n         });\n \n     match best_action {\n@@ -421,15 +361,10 @@ fn best_action_for_target<'b, 'a: 'b>(\n \n fn make_assist(action: &ImportAction, target: &[&ast::PathSegment], edit: &mut AssistBuilder) {\n     match action {\n-        ImportAction::AddNewUse {\n-            anchor,\n-            add_after_anchor,\n-        } => make_assist_add_new_use(anchor, *add_after_anchor, target, edit),\n-        ImportAction::AddInTreeList {\n-            common_segments,\n-            tree_list,\n-            add_self,\n-        } => {\n+        ImportAction::AddNewUse { anchor, add_after_anchor } => {\n+            make_assist_add_new_use(anchor, *add_after_anchor, target, edit)\n+        }\n+        ImportAction::AddInTreeList { common_segments, tree_list, add_self } => {\n             // We know that the fist n segments already exists in the use statement we want\n             // to modify, so we want to add only the last target.len() - n segments.\n             let segments_to_add = target.split_at(*common_segments).1;\n@@ -461,7 +396,7 @@ fn make_assist_add_new_use(\n     edit: &mut AssistBuilder,\n ) {\n     if let Some(anchor) = anchor {\n-        let indent = formatting::leading_indent(anchor);\n+        let indent = ra_fmt::leading_indent(anchor);\n         let mut buf = String::new();\n         if after {\n             buf.push_str(\"\\n\");\n@@ -478,11 +413,7 @@ fn make_assist_add_new_use(\n                 buf.push_str(spaces);\n             }\n         }\n-        let position = if after {\n-            anchor.range().end()\n-        } else {\n-            anchor.range().start()\n-        };\n+        let position = if after { anchor.range().end() } else { anchor.range().start() };\n         edit.insert(position, buf);\n     }\n }\n@@ -496,10 +427,7 @@ fn make_assist_add_in_tree_list(\n     let last = tree_list.use_trees().last();\n     if let Some(last) = last {\n         let mut buf = String::new();\n-        let comma = last\n-            .syntax()\n-            .siblings(Direction::Next)\n-            .find(|n| n.kind() == COMMA);\n+        let comma = last.syntax().siblings(Direction::Next).find(|n| n.kind() == COMMA);\n         let offset = if let Some(comma) = comma {\n             comma.range().end()\n         } else {\n@@ -558,12 +486,7 @@ pub(crate) fn auto_import(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n \n     let path = node.ancestors().find_map(ast::Path::cast)?;\n     // We don't want to mess with use statements\n-    if path\n-        .syntax()\n-        .ancestors()\n-        .find_map(ast::UseItem::cast)\n-        .is_some()\n-    {\n+    if path.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n         return None;\n     }\n \n@@ -572,21 +495,18 @@ pub(crate) fn auto_import(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.build(\n-        format!(\"import {} in the current file\", fmt_segments(&segments)),\n-        |edit| {\n-            let action = best_action_for_target(current_file.syntax(), path, &segments);\n-            make_assist(&action, segments.as_slice(), edit);\n-            if let Some(last_segment) = path.segment() {\n-                // Here we are assuming the assist will provide a  correct use statement\n-                // so we can delete the path qualifier\n-                edit.delete(TextRange::from_to(\n-                    path.syntax().range().start(),\n-                    last_segment.syntax().range().start(),\n-                ));\n-            }\n-        },\n-    )\n+    ctx.build(format!(\"import {} in the current file\", fmt_segments(&segments)), |edit| {\n+        let action = best_action_for_target(current_file.syntax(), path, &segments);\n+        make_assist(&action, segments.as_slice(), edit);\n+        if let Some(last_segment) = path.segment() {\n+            // Here we are assuming the assist will provide a  correct use statement\n+            // so we can delete the path qualifier\n+            edit.delete(TextRange::from_to(\n+                path.syntax().range().start(),\n+                last_segment.syntax().range().start(),\n+            ));\n+        }\n+    })\n }\n \n #[cfg(test)]"}]}