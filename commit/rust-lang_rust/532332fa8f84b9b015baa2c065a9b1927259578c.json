{"sha": "532332fa8f84b9b015baa2c065a9b1927259578c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMjMzMmZhOGY4NGI5YjAxNWJhYTJjMDY1YTliMTkyNzI1OTU3OGM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2021-01-23T05:54:19Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2021-02-01T22:08:37Z"}, "message": "Test exploring the interactions between all of the different kinds of method collisions I could imagine.\n\nThe different impls are all guarded by cfg-flags, and the revisions could be\nused to cover the full power-set of combinations.\n\n(I only included 20 of the possible 32 cases here; the null-set is not\ninteresting, and the remaining 11 all yielded ambiguous method resolution errors\nwhich did not mix well with this testing strategy; I'm not trying to check UI\nfor the resolution diagnostics; I'm trying to create checkpoint of current\nresolution semantics when compilation succeeds.)", "tree": {"sha": "9e9c1d9fde8ff7ccf6bd4882a680cc85c82d66e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e9c1d9fde8ff7ccf6bd4882a680cc85c82d66e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/532332fa8f84b9b015baa2c065a9b1927259578c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/532332fa8f84b9b015baa2c065a9b1927259578c", "html_url": "https://github.com/rust-lang/rust/commit/532332fa8f84b9b015baa2c065a9b1927259578c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/532332fa8f84b9b015baa2c065a9b1927259578c/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff4665f45f846f82fd8046c50a0fe501b7f31665", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff4665f45f846f82fd8046c50a0fe501b7f31665", "html_url": "https://github.com/rust-lang/rust/commit/ff4665f45f846f82fd8046c50a0fe501b7f31665"}], "stats": {"total": 190, "additions": 190, "deletions": 0}, "files": [{"sha": "986fe103cdc796cbd6f609d5341eb659fe660948", "filename": "src/test/ui/methods/method-lookup-order.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/532332fa8f84b9b015baa2c065a9b1927259578c/src%2Ftest%2Fui%2Fmethods%2Fmethod-lookup-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532332fa8f84b9b015baa2c065a9b1927259578c/src%2Ftest%2Fui%2Fmethods%2Fmethod-lookup-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-lookup-order.rs?ref=532332fa8f84b9b015baa2c065a9b1927259578c", "patch": "@@ -0,0 +1,190 @@\n+// ignore-tidy-linelength\n+\n+// run-pass\n+\n+// There are five cfg's below. I explored the set of all non-empty combinations\n+// of the below five cfg's, which is 2^5 - 1 = 31 combinations.\n+//\n+// Of the 31, 11 resulted in ambiguous method resolutions; while it may be good\n+// to have a test for all of the eleven variations of that error, I am not sure\n+// this particular test is the best way to encode it. So they are skipped in\n+// this revisions list (but not in the expansion mapping the binary encoding to\n+// the corresponding cfg flags).\n+//\n+// Notable, here are the cases that will be incompatible if something does not override them first:\n+// {bar_for_foo, valbar_for_et_foo}: these are higher precedent than the `&mut self` method on `Foo`, and so no case matching bx1x1x is included.\n+// {mutbar_for_foo, valbar_for_etmut_foo} (which are lower precedent than the inherent `&mut self` method on `Foo`; e.g. b10101 *is* included.\n+\n+// revisions: b00001 b00010 b00011 b00100 b00101 b00110 b00111 b01000 b01001 b01100 b01101 b10000 b10001 b10010 b10011 b10101 b10111 b11000 b11001 b11101\n+\n+//[b00001]compile-flags:  --cfg inherent_mut\n+//[b00010]compile-flags:                     --cfg bar_for_foo\n+//[b00011]compile-flags:  --cfg inherent_mut --cfg bar_for_foo\n+//[b00100]compile-flags:                                       --cfg mutbar_for_foo\n+//[b00101]compile-flags:  --cfg inherent_mut                   --cfg mutbar_for_foo\n+//[b00110]compile-flags:                     --cfg bar_for_foo --cfg mutbar_for_foo\n+//[b00111]compile-flags:  --cfg inherent_mut --cfg bar_for_foo --cfg mutbar_for_foo\n+//[b01000]compile-flags:                                                            --cfg valbar_for_et_foo\n+//[b01001]compile-flags:  --cfg inherent_mut                                        --cfg valbar_for_et_foo\n+//[b01010]compile-flags:                     --cfg bar_for_foo                      --cfg valbar_for_et_foo\n+//[b01011]compile-flags:  --cfg inherent_mut --cfg bar_for_foo                      --cfg valbar_for_et_foo\n+//[b01100]compile-flags:                                       --cfg mutbar_for_foo --cfg valbar_for_et_foo\n+//[b01101]compile-flags:  --cfg inherent_mut                   --cfg mutbar_for_foo --cfg valbar_for_et_foo\n+//[b01110]compile-flags:                     --cfg bar_for_foo --cfg mutbar_for_foo --cfg valbar_for_et_foo\n+//[b01111]compile-flags:  --cfg inherent_mut --cfg bar_for_foo --cfg mutbar_for_foo --cfg valbar_for_et_foo\n+//[b10000]compile-flags:                                                                                    --cfg valbar_for_etmut_foo\n+//[b10001]compile-flags:  --cfg inherent_mut                                                                --cfg valbar_for_etmut_foo\n+//[b10010]compile-flags:                     --cfg bar_for_foo                                              --cfg valbar_for_etmut_foo\n+//[b10011]compile-flags:  --cfg inherent_mut --cfg bar_for_foo                                              --cfg valbar_for_etmut_foo\n+//[b10100]compile-flags:                                       --cfg mutbar_for_foo                         --cfg valbar_for_etmut_foo\n+//[b10101]compile-flags:  --cfg inherent_mut                   --cfg mutbar_for_foo                         --cfg valbar_for_etmut_foo\n+//[b10110]compile-flags:                     --cfg bar_for_foo --cfg mutbar_for_foo                         --cfg valbar_for_etmut_foo\n+//[b10111]compile-flags:  --cfg inherent_mut --cfg bar_for_foo --cfg mutbar_for_foo                         --cfg valbar_for_etmut_foo\n+//[b11000]compile-flags:                                                            --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+//[b11001]compile-flags:  --cfg inherent_mut                                        --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+//[b11010]compile-flags:                     --cfg bar_for_foo                      --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+//[b11011]compile-flags:  --cfg inherent_mut --cfg bar_for_foo                      --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+//[b11100]compile-flags:                                       --cfg mutbar_for_foo --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+//[b11101]compile-flags:  --cfg inherent_mut                   --cfg mutbar_for_foo --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+//[b11110]compile-flags:                     --cfg bar_for_foo --cfg mutbar_for_foo --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+//[b11111]compile-flags:  --cfg inherent_mut --cfg bar_for_foo --cfg mutbar_for_foo --cfg valbar_for_et_foo --cfg valbar_for_etmut_foo\n+\n+struct Foo {}\n+\n+type S = &'static str;\n+\n+trait Bar {\n+    fn bar(&self, _: &str) -> S;\n+}\n+\n+trait MutBar {\n+    fn bar(&mut self, _: &str) -> S;\n+}\n+\n+trait ValBar {\n+    fn bar(self, _: &str) -> S;\n+}\n+\n+#[cfg(inherent_mut)]\n+impl Foo {\n+    fn bar(&mut self, _: &str) -> S {\n+        \"In struct impl!\"\n+    }\n+}\n+\n+#[cfg(bar_for_foo)]\n+impl Bar for Foo {\n+    fn bar(&self, _: &str) -> S {\n+        \"In trait &self impl!\"\n+    }\n+}\n+\n+#[cfg(mutbar_for_foo)]\n+impl MutBar for Foo {\n+    fn bar(&mut self, _: &str) -> S {\n+        \"In trait &mut self impl!\"\n+    }\n+}\n+\n+#[cfg(valbar_for_et_foo)]\n+impl ValBar for &Foo {\n+    fn bar(self, _: &str) -> S {\n+        \"In trait self impl for &Foo!\"\n+    }\n+}\n+\n+#[cfg(valbar_for_etmut_foo)]\n+impl ValBar for &mut Foo {\n+    fn bar(self, _: &str) -> S {\n+        \"In trait self impl for &mut Foo!\"\n+    }\n+}\n+\n+fn main() {\n+    #![allow(unused_mut)] // some of the impls above will want it.\n+\n+    #![allow(unreachable_patterns)] // the cfg-coding pattern below generates unreachable patterns.\n+\n+    {\n+        macro_rules! all_variants_on_value {\n+            ($e:expr) => {\n+                match $e {\n+                    #[cfg(bar_for_foo)]\n+                    x => assert_eq!(x, \"In trait &self impl!\"),\n+\n+                    #[cfg(valbar_for_et_foo)]\n+                    x => assert_eq!(x, \"In trait self impl for &Foo!\"),\n+\n+                    #[cfg(inherent_mut)]\n+                    x => assert_eq!(x, \"In struct impl!\"),\n+\n+                    #[cfg(mutbar_for_foo)]\n+                    x => assert_eq!(x, \"In trait &mut self impl!\"),\n+\n+                    #[cfg(valbar_for_etmut_foo)]\n+                    x => assert_eq!(x, \"In trait self impl for &mut Foo!\"),\n+                }\n+            }\n+        }\n+\n+        let mut f = Foo {};\n+        all_variants_on_value!(f.bar(\"f.bar\"));\n+\n+        let f_mr = &mut Foo {};\n+        all_variants_on_value!((*f_mr).bar(\"(*f_mr).bar\"));\n+    }\n+\n+    // This is sort of interesting: `&mut Foo` ends up with a significantly\n+    // different resolution order than what was devised above. Presumably this\n+    // is because we can get to a `&self` method by first a deref of the given\n+    // `&mut Foo` and then an autoref, and that is a longer path than a mere\n+    // auto-ref of a `Foo`.\n+\n+    {\n+        let f_mr = &mut Foo {};\n+\n+        match f_mr.bar(\"f_mr.bar\") {\n+            #[cfg(inherent_mut)]\n+            x => assert_eq!(x, \"In struct impl!\"),\n+\n+            #[cfg(valbar_for_etmut_foo)]\n+            x => assert_eq!(x, \"In trait self impl for &mut Foo!\"),\n+\n+            #[cfg(mutbar_for_foo)]\n+            x => assert_eq!(x, \"In trait &mut self impl!\"),\n+\n+            #[cfg(valbar_for_et_foo)]\n+            x => assert_eq!(x, \"In trait self impl for &Foo!\"),\n+\n+            #[cfg(bar_for_foo)]\n+            x => assert_eq!(x, \"In trait &self impl!\"),\n+        }\n+    }\n+\n+\n+    // Note that this isn't actually testing a resolution order; if both of these are\n+    // enabled, it yields an ambiguous method resolution error. The test tries to embed\n+    // that fact by testing *both* orders (and so the only way that can be right is if\n+    // they are not actually compatible).\n+    #[cfg(any(bar_for_foo, valbar_for_et_foo))]\n+    {\n+        let f_r = &Foo {};\n+\n+        match f_r.bar(\"f_r.bar\") {\n+            #[cfg(bar_for_foo)]\n+            x => assert_eq!(x, \"In trait &self impl!\"),\n+\n+            #[cfg(valbar_for_et_foo)]\n+            x => assert_eq!(x, \"In trait self impl for &Foo!\"),\n+        }\n+\n+        match f_r.bar(\"f_r.bar\") {\n+            #[cfg(valbar_for_et_foo)]\n+            x => assert_eq!(x, \"In trait self impl for &Foo!\"),\n+\n+            #[cfg(bar_for_foo)]\n+            x => assert_eq!(x, \"In trait &self impl!\"),\n+        }\n+    }\n+\n+}"}]}