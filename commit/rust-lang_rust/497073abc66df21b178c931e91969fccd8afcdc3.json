{"sha": "497073abc66df21b178c931e91969fccd8afcdc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5NzA3M2FiYzY2ZGYyMWIxNzhjOTMxZTkxOTY5ZmNjZDhhZmNkYzM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-04-26T14:56:25Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-04-26T14:58:08Z"}, "message": "For associated type shorthand (T::Item), use the substs from the where clause\n\nSo e.g. if we have `fn foo<T: SomeTrait<u32>>() -> T::Item`, we want to lower\nthat to `<T as SomeTrait<u32>>::Item` and not `<T as SomeTrait<_>>::Item`.", "tree": {"sha": "088b0fda66e9012959a6e26e460c2811156d3e83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/088b0fda66e9012959a6e26e460c2811156d3e83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/497073abc66df21b178c931e91969fccd8afcdc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/497073abc66df21b178c931e91969fccd8afcdc3", "html_url": "https://github.com/rust-lang/rust/commit/497073abc66df21b178c931e91969fccd8afcdc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/497073abc66df21b178c931e91969fccd8afcdc3/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef67e0a497a3f0b65c11bf443e0d35c8e51bd26f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef67e0a497a3f0b65c11bf443e0d35c8e51bd26f", "html_url": "https://github.com/rust-lang/rust/commit/ef67e0a497a3f0b65c11bf443e0d35c8e51bd26f"}], "stats": {"total": 132, "additions": 119, "deletions": 13}, "files": [{"sha": "a8ef32ec59730b08f2353b87bd13e7e5755bff52", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/497073abc66df21b178c931e91969fccd8afcdc3/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497073abc66df21b178c931e91969fccd8afcdc3/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=497073abc66df21b178c931e91969fccd8afcdc3", "patch": "@@ -487,6 +487,18 @@ impl<T> Binders<T> {\n     pub fn new(num_binders: usize, value: T) -> Self {\n         Self { num_binders, value }\n     }\n+\n+    pub fn as_ref(&self) -> Binders<&T> {\n+        Binders { num_binders: self.num_binders, value: &self.value }\n+    }\n+\n+    pub fn map<U>(self, f: impl FnOnce(T) -> U) -> Binders<U> {\n+        Binders { num_binders: self.num_binders, value: f(self.value) }\n+    }\n+\n+    pub fn filter_map<U>(self, f: impl FnOnce(T) -> Option<U>) -> Option<Binders<U>> {\n+        Some(Binders { num_binders: self.num_binders, value: f(self.value)? })\n+    }\n }\n \n impl<T: Clone> Binders<&T> {"}, {"sha": "a6f893037f5dde27454ebfb3f45025921f3d4ff6", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/497073abc66df21b178c931e91969fccd8afcdc3/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497073abc66df21b178c931e91969fccd8afcdc3/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=497073abc66df21b178c931e91969fccd8afcdc3", "patch": "@@ -28,11 +28,11 @@ use crate::{\n     db::HirDatabase,\n     primitive::{FloatTy, IntTy},\n     utils::{\n-        all_super_traits, associated_type_by_name_including_super_traits, generics, make_mut_slice,\n-        variant_data,\n+        all_super_trait_refs, associated_type_by_name_including_super_traits, generics,\n+        make_mut_slice, variant_data,\n     },\n     Binders, BoundVar, DebruijnIndex, FnSig, GenericPredicate, PolyFnSig, ProjectionPredicate,\n-    ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n+    ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n \n #[derive(Debug)]\n@@ -256,7 +256,7 @@ impl Ty {\n         if remaining_segments.len() == 1 {\n             // resolve unselected assoc types\n             let segment = remaining_segments.first().unwrap();\n-            (Ty::select_associated_type(ctx, ty, res, segment), None)\n+            (Ty::select_associated_type(ctx, res, segment), None)\n         } else if remaining_segments.len() > 1 {\n             // FIXME report error (ambiguous associated type)\n             (Ty::Unknown, None)\n@@ -380,21 +380,20 @@ impl Ty {\n \n     fn select_associated_type(\n         ctx: &TyLoweringContext<'_>,\n-        self_ty: Ty,\n         res: Option<TypeNs>,\n         segment: PathSegment<'_>,\n     ) -> Ty {\n         let traits_from_env: Vec<_> = match res {\n             Some(TypeNs::SelfType(impl_id)) => match ctx.db.impl_trait(impl_id) {\n                 None => return Ty::Unknown,\n-                Some(trait_ref) => vec![trait_ref.value.trait_],\n+                Some(trait_ref) => vec![trait_ref.value],\n             },\n             Some(TypeNs::GenericParam(param_id)) => {\n                 let predicates = ctx.db.generic_predicates_for_param(param_id);\n                 let mut traits_: Vec<_> = predicates\n                     .iter()\n                     .filter_map(|pred| match &pred.value {\n-                        GenericPredicate::Implemented(tr) => Some(tr.trait_),\n+                        GenericPredicate::Implemented(tr) => Some(tr.clone()),\n                         _ => None,\n                     })\n                     .collect();\n@@ -404,20 +403,37 @@ impl Ty {\n                     if generics.params.types[param_id.local_id].provenance\n                         == TypeParamProvenance::TraitSelf\n                     {\n-                        traits_.push(trait_id);\n+                        let trait_ref = TraitRef {\n+                            trait_: trait_id,\n+                            substs: Substs::bound_vars(&generics, DebruijnIndex::INNERMOST),\n+                        };\n+                        traits_.push(trait_ref);\n                     }\n                 }\n                 traits_\n             }\n             _ => return Ty::Unknown,\n         };\n-        let traits = traits_from_env.into_iter().flat_map(|t| all_super_traits(ctx.db.upcast(), t));\n+        let traits = traits_from_env.into_iter().flat_map(|t| all_super_trait_refs(ctx.db, t));\n         for t in traits {\n-            if let Some(associated_ty) = ctx.db.trait_data(t).associated_type_by_name(&segment.name)\n+            if let Some(associated_ty) =\n+                ctx.db.trait_data(t.trait_).associated_type_by_name(&segment.name)\n             {\n-                let substs =\n-                    Substs::build_for_def(ctx.db, t).push(self_ty).fill_with_unknown().build();\n-                // FIXME handle type parameters on the segment\n+                let substs = match ctx.type_param_mode {\n+                    TypeParamLoweringMode::Placeholder => {\n+                        // if we're lowering to placeholders, we have to put\n+                        // them in now\n+                        let s = Substs::type_params(\n+                            ctx.db,\n+                            ctx.resolver\n+                                .generic_def()\n+                                .expect(\"there should be generics if there's a generic param\"),\n+                        );\n+                        t.substs.subst_bound_vars(&s)\n+                    }\n+                    TypeParamLoweringMode::Variable => t.substs,\n+                };\n+                // FIXME handle (forbid) type parameters on the segment\n                 return Ty::Projection(ProjectionTy { associated_ty, parameters: substs });\n             }\n         }"}, {"sha": "e555c879a0454922c10998735f8013d728adc354", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/497073abc66df21b178c931e91969fccd8afcdc3/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497073abc66df21b178c931e91969fccd8afcdc3/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=497073abc66df21b178c931e91969fccd8afcdc3", "patch": "@@ -1897,6 +1897,36 @@ fn test() {\n     assert_eq!(t, \"u32\");\n }\n \n+#[test]\n+fn unselected_projection_chalk_fold() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Interner {}\n+trait Fold<I: Interner, TI = I> {\n+    type Result;\n+}\n+\n+struct Ty<I: Interner> {}\n+impl<I: Interner, TI: Interner> Fold<I, TI> for Ty<I> {\n+    type Result = Ty<TI>;\n+}\n+\n+fn fold<I: Interner, T>(interner: &I, t: T) -> T::Result\n+where\n+    T: Fold<I, I>,\n+{\n+    loop {}\n+}\n+\n+fn foo<I: Interner>(interner: &I, t: Ty<I>) {\n+    fold(interner, t)<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"Ty<I>\");\n+}\n+\n #[test]\n fn trait_impl_self_ty() {\n     let t = type_at("}, {"sha": "f98350bf92187369124a8090111423d78437cfcc", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/497073abc66df21b178c931e91969fccd8afcdc3/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497073abc66df21b178c931e91969fccd8afcdc3/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=497073abc66df21b178c931e91969fccd8afcdc3", "patch": "@@ -14,6 +14,8 @@ use hir_def::{\n };\n use hir_expand::name::{name, Name};\n \n+use crate::{db::HirDatabase, GenericPredicate, TraitRef};\n+\n fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n     let resolver = trait_.resolver(db);\n     // returning the iterator directly doesn't easily work because of\n@@ -41,6 +43,28 @@ fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n         .collect()\n }\n \n+fn direct_super_trait_refs(db: &dyn HirDatabase, trait_ref: &TraitRef) -> Vec<TraitRef> {\n+    // returning the iterator directly doesn't easily work because of\n+    // lifetime problems, but since there usually shouldn't be more than a\n+    // few direct traits this should be fine (we could even use some kind of\n+    // SmallVec if performance is a concern)\n+    let generic_params = db.generic_params(trait_ref.trait_.into());\n+    let trait_self = match generic_params.find_trait_self_param() {\n+        Some(p) => TypeParamId { parent: trait_ref.trait_.into(), local_id: p },\n+        None => return Vec::new(),\n+    };\n+    db.generic_predicates_for_param(trait_self)\n+        .iter()\n+        .filter_map(|pred| {\n+            pred.as_ref().filter_map(|pred| match pred {\n+                GenericPredicate::Implemented(tr) => Some(tr.clone()),\n+                _ => None,\n+            })\n+        })\n+        .map(|pred| pred.subst(&trait_ref.substs))\n+        .collect()\n+}\n+\n /// Returns an iterator over the whole super trait hierarchy (including the\n /// trait itself).\n pub(super) fn all_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n@@ -62,6 +86,30 @@ pub(super) fn all_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<Tra\n     result\n }\n \n+/// Given a trait ref (`Self: Trait`), builds all the implied trait refs for\n+/// super traits. The original trait ref will be included. So the difference to\n+/// `all_super_traits` is that we keep track of type parameters; for example if\n+/// we have `Self: Trait<u32, i32>` and `Trait<T, U>: OtherTrait<U>` we'll get\n+/// `Self: OtherTrait<i32>`.\n+pub(super) fn all_super_trait_refs(db: &dyn HirDatabase, trait_ref: TraitRef) -> Vec<TraitRef> {\n+    // we need to take care a bit here to avoid infinite loops in case of cycles\n+    // (i.e. if we have `trait A: B; trait B: A;`)\n+    let mut result = vec![trait_ref];\n+    let mut i = 0;\n+    while i < result.len() {\n+        let t = &result[i];\n+        // yeah this is quadratic, but trait hierarchies should be flat\n+        // enough that this doesn't matter\n+        for tt in direct_super_trait_refs(db, t) {\n+            if !result.iter().any(|tr| tr.trait_ == tt.trait_) {\n+                result.push(tt);\n+            }\n+        }\n+        i += 1;\n+    }\n+    result\n+}\n+\n /// Finds a path from a trait to one of its super traits. Returns an empty\n /// vector if there is no path.\n pub(super) fn find_super_trait_path("}]}