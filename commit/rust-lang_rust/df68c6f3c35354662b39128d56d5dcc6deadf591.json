{"sha": "df68c6f3c35354662b39128d56d5dcc6deadf591", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNjhjNmYzYzM1MzU0NjYyYjM5MTI4ZDU2ZDVkY2M2ZGVhZGY1OTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-21T18:46:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-21T18:46:46Z"}, "message": "auto merge of #15864 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "b51edf6031173f896f136b8cd42c05729109d384", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b51edf6031173f896f136b8cd42c05729109d384"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df68c6f3c35354662b39128d56d5dcc6deadf591", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df68c6f3c35354662b39128d56d5dcc6deadf591", "html_url": "https://github.com/rust-lang/rust/commit/df68c6f3c35354662b39128d56d5dcc6deadf591", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df68c6f3c35354662b39128d56d5dcc6deadf591/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cc39a054d485e46f7b8292cea690407932232ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc39a054d485e46f7b8292cea690407932232ce", "html_url": "https://github.com/rust-lang/rust/commit/9cc39a054d485e46f7b8292cea690407932232ce"}, {"sha": "414862db3cb7ff75f8d2373466e547a0464d683d", "url": "https://api.github.com/repos/rust-lang/rust/commits/414862db3cb7ff75f8d2373466e547a0464d683d", "html_url": "https://github.com/rust-lang/rust/commit/414862db3cb7ff75f8d2373466e547a0464d683d"}], "stats": {"total": 2837, "additions": 2383, "deletions": 454}, "files": [{"sha": "b81851e93c0b30cc455fb166bc0607d71b60a712", "filename": "mk/docs.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -112,8 +112,8 @@ HTML_DEPS += doc/version_info.html\n doc/version_info.html: $(D)/version_info.html.template $(MKFILE_DEPS) \\\n                        $(wildcard $(D)/*.*) | doc/\n \t@$(call E, version-info: $@)\n-\t$(Q)sed -e \"s/VERSION/$(CFG_RELEASE)/; s/SHORT_HASH/$(shell echo \\\n-                    $(CFG_VER_HASH) | head -c 8)/;\\\n+\t$(Q)sed -e \"s/VERSION/$(CFG_RELEASE)/; s/SHORT_HASH/$(\\\n+                    CFG_SHORT_VER_HASH)/;\\\n                 s/STAMP/$(CFG_VER_HASH)/;\" $< >$@\n \n GENERATED += doc/version.tex doc/version_info.html"}, {"sha": "98b83530c8de05bced2bde3a80910e8b2d80617d", "filename": "mk/main.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -46,7 +46,8 @@ ifneq ($(wildcard $(subst $(SPACE),\\$(SPACE),$(CFG_GIT))),)\n ifneq ($(wildcard $(subst $(SPACE),\\$(SPACE),$(CFG_GIT_DIR))),)\n     CFG_VER_DATE = $(shell git --git-dir='$(CFG_GIT_DIR)' log -1 --pretty=format:'%ci')\n     CFG_VER_HASH = $(shell git --git-dir='$(CFG_GIT_DIR)' rev-parse HEAD)\n-    CFG_VERSION += ($(CFG_VER_HASH) $(CFG_VER_DATE))\n+    CFG_SHORT_VER_HASH = $(shell git --git-dir='$(CFG_GIT_DIR)' rev-parse --short=9 HEAD)\n+    CFG_VERSION += ($(CFG_SHORT_VER_HASH) $(CFG_VER_DATE))\n endif\n endif\n "}, {"sha": "e3acb0575d226c07c47fe089742d3cb48da17db7", "filename": "src/doc/guide.md", "status": "modified", "additions": 1010, "deletions": 119, "changes": 1129, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -18,8 +18,9 @@ something special, and we hope you do too.\n \n To show you how to get going with Rust, we're going to write the traditional\n \"Hello, World!\" program. Next, we'll introduce you to a tool that's useful for\n-writing real-world Rust programs and libraries: \"Cargo.\" Then, we'll show off\n-Rust's features by writing a little program together.\n+writing real-world Rust programs and libraries: \"Cargo.\" After that, we'll talk\n+about the basics of Rust, write a little program to try them out, and then learn\n+more advanced things.\n \n Sound good? Let's go!\n \n@@ -357,70 +358,9 @@ That's it! We've successfully built `hello_world` with Cargo. Even though our\n program is simple, it's using much of the real tooling that you'll use for the\n rest of your Rust career.\n \n-Next, we'll learn more about Rust itself, by starting to write a more complicated\n-program. We hope you want to do more with Rust than just print \"Hello, world!\"\n-\n-## Guessing Game\n-\n-Let's write a bigger program in Rust. We could just go through a laundry list\n-of Rust features, but that's boring. Instead, we'll learn more about how to\n-code in Rust by writing a few example projects.\n-\n-For our first project, we'll implement a classic beginner programming problem:\n-the guessing game. Here's how it works: Our program will generate a random\n-integer between one and a hundred. It will then prompt us to enter a guess.\n-Upon entering our guess, it will tell us if we're too low or too high. Once we\n-guess correctly, it will congratulate us, and print the number of guesses we've\n-taken to the screen. Sound good? It sounds easy, but it'll end up showing off a\n-number of basic features of Rust.\n-\n-### Set up\n-\n-Let's set up a new project. Go to your projects directory, and make a new\n-directory for the project, as well as a `src` directory for our code:\n-\n-```{bash}\n-$ cd ~/projects\n-$ mkdir guessing_game\n-$ cd guessing_game\n-$ mkdir src\n-```\n-\n-Great. Next, let's make a `Cargo.toml` file so Cargo knows how to build our\n-project:\n-\n-```{ignore}\n-[package]\n-\n-name = \"guessing_game\"\n-version = \"0.1.0\"\n-authors = [ \"someone@example.com\" ]\n-\n-[[bin]]\n-\n-name = \"guessing_game\"\n-```\n-\n-Finally, we need our source file. Let's just make it hello world for now, so we\n-can check that our setup works. In `src/guessing_game.rs`:\n-\n-```{rust}\n-fn main() {\n-    println!(\"Hello world!\");\n-}\n-```\n-\n-Let's make sure that worked:\n-\n-```{bash}\n-$ cargo build\n-   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n-$\n-```\n-\n-Excellent! Open up your `src/guessing_game.rs` again. We'll be writing all of\n-our code in this file. The next section of the tutorial will show you how to\n-build multiple-file projects.\n+Now that you've got the tools down, let's actually learn more about the Rust\n+language itself. These are the basics that will serve you well through the rest\n+of your time with Rust.\n \n ## Variable bindings\n \n@@ -1143,25 +1083,31 @@ can only be _one_ of `Less`, `Equal`, or `Greater` at any given time. Here's\n an example:\n \n ```rust\n-let x = 5i;\n-let y = 10i;\n+fn cmp(a: int, b: int) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n \n-let ordering = x.cmp(&y);\n+fn main() {\n+    let x = 5i;\n+    let y = 10i;\n \n-if ordering == Less {\n-    println!(\"less\");\n-} else if ordering == Greater {\n-    println!(\"greater\");\n-} else if ordering == Equal {\n-    println!(\"equal\");\n+    let ordering = cmp(x, y);\n+\n+    if ordering == Less {\n+        println!(\"less\");\n+    } else if ordering == Greater {\n+        println!(\"greater\");\n+    } else if ordering == Equal {\n+        println!(\"equal\");\n+    }\n }\n ```\n \n-`cmp` is a function that compares two things, and returns an `Ordering`. The\n-call looks a little bit strange: rather than `cmp(x, y)`, we say `x.cmp(&y)`.\n-We haven't covered methods and references yet, so it should look a little bit\n-foreign. Right now, just pretend it says `cmp(x, y)`, and we'll get to those\n-details soon.\n+`cmp` is a function that compares two things, and returns an `Ordering`. We\n+return either `Less`, `Greater`, or `Equal`, depending on if the two values\n+are greater, less, or equal.\n \n The `ordering` variable has the type `Ordering`, and so contains one of the\n three values. We can then do a bunch of `if`/`else` comparisons to check\n@@ -1172,12 +1118,12 @@ that not only makes them nicer to read, but also makes sure that you never\n miss a case. Before we get to that, though, let's talk about another kind of\n enum: one with values.\n \n-This enum has two variants, one of which has a value.:\n+This enum has two variants, one of which has a value:\n \n-```\n+```{rust}\n enum OptionalInt {\n     Value(int),\n-    Missing\n+    Missing,\n }\n \n fn main() {\n@@ -1261,30 +1207,46 @@ for every possible value of `x`, and so our program will now compile.\n section on enums?\n \n ```{rust}\n-let x = 5i;\n-let y = 10i;\n+fn cmp(a: int, b: int) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n \n-let ordering = x.cmp(&y);\n+fn main() {\n+    let x = 5i;\n+    let y = 10i;\n+\n+    let ordering = cmp(x, y);\n \n-if ordering == Less {\n-    println!(\"less\");\n-} else if ordering == Greater {\n-    println!(\"greater\");\n-} else if ordering == Equal {\n-    println!(\"equal\");\n+    if ordering == Less {\n+        println!(\"less\");\n+    } else if ordering == Greater {\n+        println!(\"greater\");\n+    } else if ordering == Equal {\n+        println!(\"equal\");\n+    }\n }\n ```\n \n We can re-write this as a `match`:\n \n ```{rust}\n-let x = 5i;\n-let y = 10i;\n+fn cmp(a: int, b: int) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+\n+fn main() {\n+    let x = 5i;\n+    let y = 10i;\n \n-match x.cmp(&y) {\n-    Less    => println!(\"less\"),\n-    Greater => println!(\"greater\"),\n-    Equal   => println!(\"equal\"),\n+    match cmp(x, y) {\n+        Less    => println!(\"less\"),\n+        Greater => println!(\"greater\"),\n+        Equal   => println!(\"equal\"),\n+    }\n }\n ```\n \n@@ -1297,17 +1259,25 @@ make sure to cover all of our bases.\n `match` is also an expression, which means we can use it on the right hand side\n of a `let` binding. We could also implement the previous line like this:\n \n-```\n-let x = 5i;\n-let y = 10i;\n+```{rust}\n+fn cmp(a: int, b: int) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n \n-let result = match x.cmp(&y) {\n-    Less    => \"less\",\n-    Greater => \"greater\",\n-    Equal   => \"equal\",\n-};\n+fn main() {\n+    let x = 5i;\n+    let y = 10i;\n+\n+    let result = match cmp(x, y) {\n+        Less    => \"less\",\n+        Greater => \"greater\",\n+        Equal   => \"equal\",\n+    };\n \n-println!(\"{}\", result);\n+    println!(\"{}\", result);\n+}\n ```\n \n In this case, it doesn't make a lot of sense, as we are just making a temporary\n@@ -1463,6 +1433,8 @@ we haven't seen before. Here's a simple program that reads some input,\n and then prints it back out:\n \n ```{rust,ignore}\n+use std::io;\n+\n fn main() {\n     println!(\"Type something!\");\n \n@@ -1474,7 +1446,7 @@ fn main() {\n \n Let's go over these chunks, one by one:\n \n-```{rust}\n+```{rust,ignore}\n std::io::stdin();\n ```\n \n@@ -1527,16 +1499,68 @@ a full line of input. Nice and easy.\n .ok().expect(\"Failed to read line\");\n ```\n \n-Here's the thing: reading a line from standard input could fail. For example,\n-if this program isn't running in a terminal, but is running as part of a cron\n-job, or some other context where there's no standard input. So Rust expects us\n-to handle this case. Given that we plan on always running this program in a\n-terminal, we use the `ok()` method to tell Rust that we're expecting everything\n-to be just peachy, and the `expect()` method on that result to give an error\n-message if our expectation goes wrong.\n+Do you remember this code? \n+\n+```\n+enum OptionalInt {\n+    Value(int),\n+    Missing,\n+}\n+\n+fn main() {\n+    let x = Value(5);\n+    let y = Missing;\n+\n+    match x {\n+        Value(n) => println!(\"x is {:d}\", n),\n+        Missing  => println!(\"x is missing!\"),\n+    }\n+\n+    match y {\n+        Value(n) => println!(\"y is {:d}\", n),\n+        Missing  => println!(\"y is missing!\"),\n+    }\n+}\n+```\n+\n+We had to match each time, to see if we had a value or not. In this case,\n+though, we _know_ that `x` has a `Value`. But `match` forces us to handle\n+the `missing` case. This is what we want 99% of the time, but sometimes, we\n+know better than the compiler.\n+\n+Likewise, `read_line()` does not return a line of input. It _might_ return a\n+line of input. It might also fail to do so. This could happen if our program\n+isn't running in a terminal, but as part of a cron job, or some other context\n+where there's no standard input. Because of this, `read_line` returns a type\n+very similar to our `OptionalInt`: an `IoResult<T>`. We haven't talked about\n+`IoResult<T>` yet because it is the **generic** form of our `OptionalInt`.\n+Until then, you can think of it as being the same thing, just for any type, not\n+just `int`s.\n+\n+Rust provides a method on these `IoResult<T>`s called `ok()`, which does the\n+same thing as our `match` statement, but assuming that we have a valid value.\n+If we don't, it will terminate our program. In this case, if we can't get\n+input, our program doesn't work, so we're okay with that. In most cases, we\n+would want to handle the error case explicitly. The result of `ok()` has a\n+method, `expect()`, which allows us to give an error message if this crash\n+happens.\n \n We will cover the exact details of how all of this works later in the Guide.\n-For now, this is all you need.\n+For now, this gives you enough of a basic understanding to work with.\n+\n+Back to the code we were working on! Here's a refresher:\n+\n+```{rust,ignore}\n+use std::io;\n+\n+fn main() {\n+    println!(\"Type something!\");\n+\n+    let input = io::stdin().read_line().ok().expect(\"Failed to read line\");\n+\n+    println!(\"{}\", input);\n+}\n+```\n \n With long lines like this, Rust gives you some flexibility with the whitespace.\n We _could_ write the example like this:\n@@ -1562,11 +1586,878 @@ here.\n That's all you need to get basic input from the standard input! It's not too\n complicated, but there are a number of small parts.\n \n-## Guessing Game: complete\n+## Guessing Game\n+\n+Okay! We've got the basics of Rust down. Let's write a bigger program.\n+\n+For our first project, we'll implement a classic beginner programming problem:\n+the guessing game. Here's how it works: Our program will generate a random\n+integer between one and a hundred. It will then prompt us to enter a guess.\n+Upon entering our guess, it will tell us if we're too low or too high. Once we\n+guess correctly, it will congratulate us, and print the number of guesses we've\n+taken to the screen. Sound good?\n+\n+### Set up\n+\n+Let's set up a new project. Go to your projects directory, and make a new\n+directory for the project, as well as a `src` directory for our code:\n+\n+```{bash}\n+$ cd ~/projects\n+$ mkdir guessing_game\n+$ cd guessing_game\n+$ mkdir src\n+```\n+\n+Great. Next, let's make a `Cargo.toml` file so Cargo knows how to build our\n+project:\n+\n+```{ignore}\n+[package]\n+\n+name = \"guessing_game\"\n+version = \"0.1.0\"\n+authors = [ \"someone@example.com\" ]\n+\n+[[bin]]\n+\n+name = \"guessing_game\"\n+```\n+\n+Finally, we need our source file. Let's just make it hello world for now, so we\n+can check that our setup works. In `src/guessing_game.rs`:\n+\n+```{rust}\n+fn main() {\n+    println!(\"Hello world!\");\n+}\n+```\n+\n+Let's make sure that worked:\n+\n+```{bash}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+$\n+```\n+\n+Excellent! Open up your `src/guessing_game.rs` again. We'll be writing all of\n+our code in this file. We'll talk about multiple-file projects later on in the\n+guide.\n+\n+### Processing a Guess\n+\n+Let's get to it! The first thing we need to do for our guessing game is\n+allow our player to input a guess. Put this in your `src/guessing_game.rs`:\n+\n+```{rust,no_run}\n+use std::io;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+You've seen this code before, when we talked about standard input. We\n+import the `std::io` module with `use`, and then our `main` function contains\n+our program's logic. We print a little message announcing the game, ask the\n+user to input a guess, get their input, and then print it out.\n+\n+Because we talked about this in the section on standard I/O, I won't go into\n+more details here. If you need a refresher, go re-read that section.\n+\n+### Generating a secret number\n+\n+Next, we need to generate a secret number. To do that, we need to use Rust's\n+random number generation, which we haven't talked about yet. Rust includes a\n+bunch of interesting functions in its standard library. If you need a bit of\n+code, it's possible that it's already been written for you! In this case,\n+we do know that Rust has random number generation, but we don't know how to\n+use it.\n+\n+Enter the docs. Rust has a page specifically to document the standard library.\n+You can find that page [here](std/index.html). There's a lot of information on\n+that page, but the best part is the search bar. Right up at the top, there's\n+a box that you can enter in a search term. The search is pretty primitive\n+right now, but is getting better all the time. If you type 'random' in that\n+box, the page will update to [this\n+one](http://doc.rust-lang.org/std/index.html?search=random). The very first\n+result is a link to\n+[std::rand::random](http://doc.rust-lang.org/std/rand/fn.random.html). If we\n+click on that result, we'll be taken to its documentation page.\n+\n+This page shows us a few things: the type signature of the function, some\n+explanatory text, and then an example. Let's modify our code to add in the\n+`random` function:\n+\n+```{rust,ignore}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random() % 100i) + 1i;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+The first thing we changed was to `use std::rand`, as the docs\n+explained.  We then added in a `let` expression to create a variable binding\n+named `secret_number`, and we printed out its result. Let's try to compile\n+this using `cargo build`:\n+\n+```{notrust,no_run}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+src/guessing_game.rs:7:26: 7:34 error: the type of this value must be known in this context\n+src/guessing_game.rs:7     let secret_number = (rand::random() % 100i) + 1i;\n+                                                ^~~~~~~~\n+error: aborting due to previous error\n+```\n+\n+It didn't work! Rust says \"the type of this value must be known in this\n+context.\" What's up with that? Well, as it turns out, `rand::random()` can\n+generate many kinds of random values, not just integers. And in this case, Rust\n+isn't sure what kind of value `random()` should generate. So we have to help\n+it. With number literals, we just add an `i` onto the end to tell Rust they're\n+integers, but that does not work with functions. There's a different syntax,\n+and it looks like this:\n+\n+```{rust,ignore}\n+rand::random::<int>();\n+```\n+\n+This says \"please give me a random `int` value.\" We can change our code to use\n+this hint...\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<int>() % 100i) + 1i;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+... and then recompile:\n+\n+```{notrust,ignore}\n+$ cargo build\n+  Compiling guessing_game v0.1.0 (file:/home/steve/tmp/guessing_game)\n+$\n+```\n+\n+Excellent! Try running our new program a few times:\n+\n+```{notrust,ignore}\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 7\n+Please input your guess.\n+4\n+You guessed: 4\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 83\n+Please input your guess.\n+5\n+You guessed: 5\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: -29\n+Please input your guess.\n+42\n+You guessed: 42\n+```\n+\n+Wait. Negative 29? We wanted a number between one and a hundred! We have two\n+options here: we can either ask `random()` to generate an unsigned integer, which\n+can only be positive, or we can use the `abs()` function. Let's go with the\n+unsigned integer approach. If we want a random positive number, we should ask for\n+a random positive number. Our code looks like this now:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+\n+    println!(\"You guessed: {}\", input);\n+}\n+```\n+\n+And trying it out:\n+\n+```{notrust,ignore}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 57\n+Please input your guess.\n+3\n+You guessed: 3\n+```\n+\n+Great! Next up: let's compare our guess to the secret guess.\n+\n+### Comparing guesses\n+\n+If you remember, earlier in the tutorial, we made a `cmp` function that compared\n+two numbers. Let's add that in, along with a `match` statement to compare the\n+guess to the secret guess:\n+\n+```{rust,ignore}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+\n+    println!(\"You guessed: {}\", input);\n+\n+    match cmp(input, secret_number) { \n+        Less    => println!(\"Too small!\"),\n+        Greater => println!(\"Too big!\"),\n+        Equal   => { println!(\"You win!\"); },\n+    }\n+}\n+\n+fn cmp(a: int, b: int) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+If we try to compile, we'll get some errors:\n+\n+```{notrust,ignore}\n+$ cargo build\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+src/guessing_game.rs:20:15: 20:20 error: mismatched types: expected `int` but found `collections::string::String` (expected int but found struct collections::string::String)\n+src/guessing_game.rs:20     match cmp(input, secret_number) {\n+                                      ^~~~~\n+src/guessing_game.rs:20:22: 20:35 error: mismatched types: expected `int` but found `uint` (expected int but found uint)\n+src/guessing_game.rs:20     match cmp(input, secret_number) {\n+                                             ^~~~~~~~~~~~~\n+error: aborting due to 2 previous errors\n+```\n+\n+This often happens when writing Rust programs, and is one of Rust's greatest\n+strengths. You try out some code, see if it compiles, and Rust tells you that\n+you've done something wrong. In this case, our `cmp` function works on integers,\n+but we've given it unsigned integers. In this case, the fix is easy, because\n+we wrote the `cmp` function! Let's change it to take `uint`s:\n+\n+```{rust,ignore}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+\n+\n+    println!(\"You guessed: {}\", input);\n+\n+    match cmp(input, secret_number) {\n+        Less    => println!(\"Too small!\"),\n+        Greater => println!(\"Too big!\"),\n+        Equal   => { println!(\"You win!\"); },\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+And try compiling again:\n+\n+```{notrust,ignore}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+src/guessing_game.rs:20:15: 20:20 error: mismatched types: expected `uint` but found `collections::string::String` (expected uint but found struct collections::string::String)\n+src/guessing_game.rs:20     match cmp(input, secret_number) {\n+                                      ^~~~~\n+error: aborting due to previous error\n+```\n+\n+This error is similar to the last one: we expected to get a `uint`, but we got\n+a `String` instead! That's because our `input` variable is coming from the\n+standard input, and you can guess anything. Try it:\n+\n+```{notrust,ignore}\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 73\n+Please input your guess.\n+hello\n+You guessed: hello\n+```\n+\n+Oops! Also, you'll note that we just ran our program even though it didn't compile.\n+This works because the older version we did successfully compile was still lying\n+around. Gotta be careful!\n+\n+Anyway, we have a `String`, but we need a `uint`. What to do? Well, there's\n+a function for that:\n+\n+```{rust,ignore}\n+let input = io::stdin().read_line()\n+                       .ok()\n+                       .expect(\"Failed to read line\");\n+let guess: Option<uint> = from_str(input.as_slice());\n+```\n+\n+The `from_str` function takes in a `&str` value and converts it into something.\n+We tell it what kind of something with a type hint. Remember our type hint with\n+`random()`? It looked like this:\n+\n+```{rust,ignore}\n+rand::random::<uint>();\n+```\n+\n+There's an alternate way of providing a hint too, and that's declaring the type\n+in a `let`:\n+\n+```{rust,ignore}\n+let x: uint = rand::random();\n+```\n+\n+In this case, we say `x` is a `uint` explicitly, so Rust is able to properly\n+tell `random()` what to generate. In a similar fashion, both of these work:\n+\n+```{rust,ignore}\n+let guess = from_str::<Option<uint>>(\"5\");\n+let guess: Option<uint> = from_str(\"5\");\n+```\n+\n+In this case, I happen to prefer the latter, and in the `random()` case, I prefer\n+the former. I think the nested `<>`s make the first option especially ugly and\n+a bit harder to read.\n+\n+Anyway, with us now convering our input to a number, our code looks like this:\n+\n+```{rust,ignore}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+    let input_num: Option<uint> = from_str(input.as_slice());\n+\n+\n+\n+    println!(\"You guessed: {}\", input_num);\n+\n+    match cmp(input_num, secret_number) {\n+        Less    => println!(\"Too small!\"),\n+        Greater => println!(\"Too big!\"),\n+        Equal   => { println!(\"You win!\"); },\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+Let's try it out!\n+\n+```{notrust,ignore}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/steve/tmp/guessing_game)\n+src/guessing_game.rs:22:15: 22:24 error: mismatched types: expected `uint` but found `core::option::Option<uint>` (expected uint but found enum core::option::Option)\n+src/guessing_game.rs:22     match cmp(input_num, secret_number) {\n+                                      ^~~~~~~~~\n+error: aborting due to previous error\n+```\n+\n+Oh yeah! Our `input_num` has the type `Option<uint>`, rather than `uint`. We\n+need to unwrap the Option. If you remember from before, `match` is a great way\n+to do that. Try this code:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+    let input_num: Option<uint> = from_str(input.as_slice());\n+\n+    let num = match input_num {\n+        Some(num) => num,\n+        None      => {\n+            println!(\"Please input a number!\");\n+            return;\n+        }\n+    };\n+\n+\n+    println!(\"You guessed: {}\", num);\n+\n+    match cmp(num, secret_number) {\n+        Less    => println!(\"Too small!\"),\n+        Greater => println!(\"Too big!\"),\n+        Equal   => { println!(\"You win!\"); },\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+We use a `match` to either give us the `uint` inside of the `Option`, or we\n+print an error message and return. Let's give this a shot:\n+\n+```{notrust,ignore}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 17\n+Please input your guess.\n+5\n+Please input a number!\n+$\n+```\n+\n+Uh, what? But we did!\n+\n+... actually, we didn't. See, when you get a line of input from `stdin()`,\n+you get all the input. Including the `\\n` character from you pressing Enter.\n+So, `from_str()` sees the string `\"5\\n\"` and says \"nope, that's not a number,\n+there's non-number stuff in there!\" Luckily for us, `&str`s have an easy\n+method we can use defined on them: `trim()`. One small modification, and our\n+code looks like this:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let input = io::stdin().read_line()\n+                           .ok()\n+                           .expect(\"Failed to read line\");\n+    let input_num: Option<uint> = from_str(input.as_slice().trim());\n+\n+    let num = match input_num {\n+        Some(num) => num,\n+        None      => {\n+            println!(\"Please input a number!\");\n+            return;\n+        }\n+    };\n+\n+\n+    println!(\"You guessed: {}\", num);\n+\n+    match cmp(num, secret_number) {\n+        Less    => println!(\"Too small!\"),\n+        Greater => println!(\"Too big!\"),\n+        Equal   => { println!(\"You win!\"); },\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+Let's try it!\n+\n+```{notrust,ignore}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 58\n+Please input your guess.\n+  76  \n+You guessed: 76\n+Too big!\n+$\n+```\n+\n+Nice! You can see I even added spaces before my guess, and it still figured\n+out that I guessed 76. Run the program a few times, and verify that guessing\n+the number works, as well as guessing a number too small.\n+\n+The Rust compiler helped us out quite a bit there! This technique is called\n+\"lean on the compiler,\" and it's often useful when working on some code. Let\n+the error messages help guide you towards the correct types.\n+\n+Now we've got most of the game working, but we can only make one guess. Let's\n+change that by adding loops!\n+\n+### Looping\n+\n+As we already discussed, the `loop` key word gives us an infinite loop. So\n+let's add that in:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+\n+        println!(\"Please input your guess.\");\n+\n+        let input = io::stdin().read_line()\n+                               .ok()\n+                               .expect(\"Failed to read line\");\n+        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+\n+        let num = match input_num {\n+            Some(num) => num,\n+            None      => {\n+                println!(\"Please input a number!\");\n+                return;\n+            }\n+        };\n+\n+\n+        println!(\"You guessed: {}\", num);\n+\n+        match cmp(num, secret_number) {\n+            Less    => println!(\"Too small!\"),\n+            Greater => println!(\"Too big!\"),\n+            Equal   => { println!(\"You win!\"); },\n+        }\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+And try it out. But wait, didn't we just add an infinite loop? Yup. Remember\n+that `return`? If we give a non-number answer, we'll `return` and quit. Observe:\n+\n+```{notrust,ignore}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+steve@computer:~/tmp/guessing_game$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 59\n+Please input your guess.\n+45\n+You guessed: 45\n+Too small!\n+Please input your guess.\n+60\n+You guessed: 60\n+Too big!\n+Please input your guess.\n+59\n+You guessed: 59\n+You win!\n+Please input your guess.\n+quit\n+Please input a number!\n+$\n+```\n+\n+Ha! `quit` actually quits. As does any other non-number input. Well, this is\n+suboptimal to say the least. First, let's actually quit when you win the game:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+\n+        println!(\"Please input your guess.\");\n+\n+        let input = io::stdin().read_line()\n+                               .ok()\n+                               .expect(\"Failed to read line\");\n+        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+\n+        let num = match input_num {\n+            Some(num) => num,\n+            None      => {\n+                println!(\"Please input a number!\");\n+                return;\n+            }\n+        };\n+\n+\n+        println!(\"You guessed: {}\", num);\n+\n+        match cmp(num, secret_number) {\n+            Less    => println!(\"Too small!\"),\n+            Greater => println!(\"Too big!\"),\n+            Equal   => {\n+                println!(\"You win!\");\n+                return;\n+            },\n+        }\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+By adding the `return` line after the `You win!`, we'll exit the program when\n+we win. We have just one more tweak to make: when someone inputs a non-number,\n+we don't want to quit, we just want to ignore it. Change that `return` to\n+`continue`:\n+\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+\n+        println!(\"Please input your guess.\");\n+\n+        let input = io::stdin().read_line()\n+                               .ok()\n+                               .expect(\"Failed to read line\");\n+        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+\n+        let num = match input_num {\n+            Some(num) => num,\n+            None      => {\n+                println!(\"Please input a number!\");\n+                continue;\n+            }\n+        };\n+\n+\n+        println!(\"You guessed: {}\", num);\n+\n+        match cmp(num, secret_number) {\n+            Less    => println!(\"Too small!\"),\n+            Greater => println!(\"Too big!\"),\n+            Equal   => {\n+                println!(\"You win!\");\n+                return;\n+            },\n+        }\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+Now we should be good! Let's try:\n+\n+```{rust,ignore}\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:/home/you/projects/guessing_game)\n+$ ./target/guessing_game \n+Guess the number!\n+The secret number is: 61\n+Please input your guess.\n+10\n+You guessed: 10\n+Too small!\n+Please input your guess.\n+99\n+You guessed: 99\n+Too big!\n+Please input your guess.\n+foo\n+Please input a number!\n+Please input your guess.\n+61\n+You guessed: 61\n+You win!\n+```\n+\n+Awesome! With one tiny last tweak, we have finished the guessing game. Can you\n+think of what it is? That's right, we don't want to print out the secret number.\n+It was good for testing, but it kind of ruins the game. Here's our final source:\n+\n+```{rust,no_run}\n+use std::io;\n+use std::rand;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+\n+    loop {\n+\n+        println!(\"Please input your guess.\");\n+\n+        let input = io::stdin().read_line()\n+                               .ok()\n+                               .expect(\"Failed to read line\");\n+        let input_num: Option<uint> = from_str(input.as_slice().trim());\n+\n+        let num = match input_num {\n+            Some(num) => num,\n+            None      => {\n+                println!(\"Please input a number!\");\n+                continue;\n+            }\n+        };\n+\n+\n+        println!(\"You guessed: {}\", num);\n+\n+        match cmp(num, secret_number) {\n+            Less    => println!(\"Too small!\"),\n+            Greater => println!(\"Too big!\"),\n+            Equal   => {\n+                println!(\"You win!\");\n+                return;\n+            },\n+        }\n+    }\n+}\n+\n+fn cmp(a: uint, b: uint) -> Ordering {\n+    if a < b { Less }\n+    else if a > b { Greater }\n+    else { Equal }\n+}\n+```\n+\n+### Complete!\n \n At this point, you have successfully built the Guessing Game! Congratulations!\n-For reference, [We've placed the sample code on\n-GitHub](https://github.com/steveklabnik/guessing_game).\n \n You've now learned the basic syntax of Rust. All of this is relatively close to\n various other programming languages you have used in the past. These"}, {"sha": "f1e9eabe8d1ede1a9fae8f4473243ffcef9c1b57", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 754, "deletions": 161, "changes": 915, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -8,6 +8,57 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Collections implemented with bit vectors.\n+//!\n+//! # Example\n+//!\n+//! This is a simple example of the [Sieve of Eratosthenes][sieve]\n+//! which calculates prime numbers up to a given limit.\n+//!\n+//! [sieve]: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n+//!\n+//! ```\n+//! use std::collections::{BitvSet, Bitv};\n+//! use std::iter;\n+//!\n+//! let max_prime = 10000;\n+//!\n+//! // Store the primes as a BitvSet\n+//! let primes = {\n+//!     // Assume all numbers are prime to begin, and then we\n+//!     // cross off non-primes progressively\n+//!     let mut bv = Bitv::with_capacity(max_prime, true);\n+//!\n+//!     // Neither 0 nor 1 are prime\n+//!     bv.set(0, false);\n+//!     bv.set(1, false);\n+//!\n+//!     for i in range(2, max_prime) {\n+//!         // if i is a prime\n+//!         if bv[i] {\n+//!             // Mark all multiples of i as non-prime (any multiples below i * i\n+//!             // will have been marked as non-prime previously)\n+//!             for j in iter::range_step(i * i, max_prime, i) { bv.set(j, false) }\n+//!         }\n+//!     }\n+//!     BitvSet::from_bitv(bv)\n+//! };\n+//!\n+//! // Simple primality tests below our max bound\n+//! let print_primes = 20;\n+//! print!(\"The primes below {} are: \", print_primes);\n+//! for x in range(0, print_primes) {\n+//!     if primes.contains(&x) {\n+//!         print!(\"{} \", x);\n+//!     }\n+//! }\n+//! println!(\"\");\n+//!\n+//! // We can manipulate the internal Bitv\n+//! let num_primes = primes.get_ref().iter().filter(|x| *x).count();\n+//! println!(\"There are {} primes below {}\", num_primes, max_prime);\n+//! ```\n+\n #![allow(missing_doc)]\n \n use core::prelude::*;\n@@ -47,7 +98,7 @@ enum BitvVariant { Big(BigBitv), Small(SmallBitv) }\n /// # Example\n ///\n /// ```rust\n-/// use collections::bitv::Bitv;\n+/// use collections::Bitv;\n ///\n /// let mut bv = Bitv::with_capacity(10, false);\n ///\n@@ -155,13 +206,32 @@ impl Bitv {\n         }\n     }\n \n-    /// Creates an empty Bitv\n+    /// Create an empty Bitv.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    /// let mut bv = Bitv::new();\n+    /// ```\n     pub fn new() -> Bitv {\n         Bitv { storage: Vec::new(), nbits: 0 }\n     }\n \n-    /// Creates a Bitv that holds `nbits` elements, setting each element\n+    /// Create a Bitv that holds `nbits` elements, setting each element\n     /// to `init`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv = Bitv::with_capacity(10u, false);\n+    /// assert_eq!(bv.len(), 10u);\n+    /// for x in bv.iter() {\n+    ///     assert_eq!(x, false);\n+    /// }\n+    /// ```\n     pub fn with_capacity(nbits: uint, init: bool) -> Bitv {\n         Bitv {\n             storage: Vec::from_elem((nbits + uint::BITS - 1) / uint::BITS,\n@@ -170,29 +240,24 @@ impl Bitv {\n         }\n     }\n \n-    /**\n-     * Calculates the union of two bitvectors\n-     *\n-     * Sets `self` to the union of `self` and `v1`. Both bitvectors must be\n-     * the same length. Returns `true` if `self` changed.\n-    */\n-    #[inline]\n-    pub fn union(&mut self, other: &Bitv) -> bool {\n-        self.process(other, |w1, w2| w1 | w2)\n-    }\n-\n-    /**\n-     * Calculates the intersection of two bitvectors\n-     *\n-     * Sets `self` to the intersection of `self` and `v1`. Both bitvectors\n-     * must be the same length. Returns `true` if `self` changed.\n-    */\n-    #[inline]\n-    pub fn intersect(&mut self, other: &Bitv) -> bool {\n-        self.process(other, |w1, w2| w1 & w2)\n-    }\n-\n-    /// Retrieve the value at index `i`\n+    /// Retrieve the value at index `i`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Assert if `i` out of bounds.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::bitv;\n+    ///\n+    /// let bv = bitv::from_bytes([0b01100000]);\n+    /// assert_eq!(bv.get(0), false);\n+    /// assert_eq!(bv.get(1), true);\n+    ///\n+    /// // Can also use array indexing\n+    /// assert_eq!(bv[1], true);\n+    /// ```\n     #[inline]\n     pub fn get(&self, i: uint) -> bool {\n         assert!(i < self.nbits);\n@@ -202,11 +267,21 @@ impl Bitv {\n         x != 0\n     }\n \n-    /**\n-     * Set the value of a bit at a given index\n-     *\n-     * `i` must be less than the length of the bitvector.\n-     */\n+    /// Set the value of a bit at a index `i`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Assert if `i` out of bounds.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv = Bitv::with_capacity(5, false);\n+    /// bv.set(3, true);\n+    /// assert_eq!(bv[3], true);\n+    /// ```\n     #[inline]\n     pub fn set(&mut self, i: uint, x: bool) {\n         assert!(i < self.nbits);\n@@ -217,33 +292,152 @@ impl Bitv {\n                           else { *self.storage.get(w) & !flag };\n     }\n \n-    /// Set all bits to 1\n+    /// Set all bits to 1.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::bitv;\n+    ///\n+    /// let before = 0b01100000;\n+    /// let after  = 0b11111111;\n+    ///\n+    /// let mut bv = bitv::from_bytes([before]);\n+    /// bv.set_all();\n+    /// assert_eq!(bv, bitv::from_bytes([after]));\n+    /// ```\n     #[inline]\n     pub fn set_all(&mut self) {\n         for w in self.storage.mut_iter() { *w = !0u; }\n     }\n \n-    /// Flip all bits\n+    /// Flip all bits.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::bitv;\n+    ///\n+    /// let before = 0b01100000;\n+    /// let after  = 0b10011111;\n+    ///\n+    /// let mut bv = bitv::from_bytes([before]);\n+    /// bv.negate();\n+    /// assert_eq!(bv, bitv::from_bytes([after]));\n+    /// ```\n     #[inline]\n     pub fn negate(&mut self) {\n         for w in self.storage.mut_iter() { *w = !*w; }\n     }\n \n-    /**\n-     * Calculate the difference between two bitvectors\n-     *\n-     * Sets each element of `v0` to the value of that element minus the\n-     * element of `v1` at the same index. Both bitvectors must be the same\n-     * length.\n-     *\n-     * Returns `true` if `v0` was changed.\n-     */\n+    /// Calculate the union of two bitvectors, acts like bitwise or.\n+    ///\n+    /// Set `self` to the union of `self` and `other`. Both bitvectors must be\n+    /// the same length. Return `true` if `self` changed.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Assert if the bitvectors are of different length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::bitv;\n+    ///\n+    /// let a   = 0b01100100;\n+    /// let b   = 0b01011010;\n+    /// let res = 0b01111110;\n+    ///\n+    /// let mut a = bitv::from_bytes([a]);\n+    /// let b = bitv::from_bytes([b]);\n+    ///\n+    /// assert!(a.union(&b));\n+    /// assert_eq!(a, bitv::from_bytes([res]));\n+    /// ```\n+    #[inline]\n+    pub fn union(&mut self, other: &Bitv) -> bool {\n+        self.process(other, |w1, w2| w1 | w2)\n+    }\n+\n+    /// Calculate the intersection of two bitvectors, acts like bitwise and.\n+    ///\n+    /// Set `self` to the intersection of `self` and `other`. Both bitvectors\n+    /// must be the same length. Return `true` if `self` changed.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Assert if the bitvectors are of different length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::bitv;\n+    ///\n+    /// let a   = 0b01100100;\n+    /// let b   = 0b01011010;\n+    /// let res = 0b01000000;\n+    ///\n+    /// let mut a = bitv::from_bytes([a]);\n+    /// let b = bitv::from_bytes([b]);\n+    ///\n+    /// assert!(a.intersect(&b));\n+    /// assert_eq!(a, bitv::from_bytes([res]));\n+    /// ```\n+    #[inline]\n+    pub fn intersect(&mut self, other: &Bitv) -> bool {\n+        self.process(other, |w1, w2| w1 & w2)\n+    }\n+\n+    /// Calculate the difference between two bitvectors.\n+    ///\n+    /// Set each element of `self` to the value of that element minus the\n+    /// element of `other` at the same index. Both bitvectors must be the same\n+    /// length. Return `true` if `self` changed.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Assert if the bitvectors are of different length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::bitv;\n+    ///\n+    /// let a   = 0b01100100;\n+    /// let b   = 0b01011010;\n+    /// let a_b = 0b00100100; // a - b\n+    /// let b_a = 0b00011010; // b - a\n+    ///\n+    /// let mut bva = bitv::from_bytes([a]);\n+    /// let bvb = bitv::from_bytes([b]);\n+    ///\n+    /// assert!(bva.difference(&bvb));\n+    /// assert_eq!(bva, bitv::from_bytes([a_b]));\n+    ///\n+    /// let bva = bitv::from_bytes([a]);\n+    /// let mut bvb = bitv::from_bytes([b]);\n+    ///\n+    /// assert!(bvb.difference(&bva));\n+    /// assert_eq!(bvb, bitv::from_bytes([b_a]));\n+    /// ```\n     #[inline]\n     pub fn difference(&mut self, other: &Bitv) -> bool {\n         self.process(other, |w1, w2| w1 & !w2)\n     }\n \n-    /// Returns `true` if all bits are 1\n+    /// Returns `true` if all bits are 1.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv = Bitv::with_capacity(5, true);\n+    /// assert_eq!(bv.all(), true);\n+    ///\n+    /// bv.set(1, false);\n+    /// assert_eq!(bv.all(), false);\n+    /// ```\n     #[inline]\n     pub fn all(&self) -> bool {\n         let mut last_word = !0u;\n@@ -254,43 +448,77 @@ impl Bitv {\n         (last_word == ((1 << self.nbits % uint::BITS) - 1) || last_word == !0u)\n     }\n \n-    /// Returns an iterator over the elements of the vector in order.\n+    /// Return an iterator over the elements of the vector in order.\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// use collections::bitv::Bitv;\n-    /// let mut bv = Bitv::with_capacity(10, false);\n-    /// bv.set(1, true);\n-    /// bv.set(2, true);\n-    /// bv.set(3, true);\n-    /// bv.set(5, true);\n-    /// bv.set(8, true);\n-    /// // Count bits set to 1; result should be 5\n-    /// println!(\"{}\", bv.iter().filter(|x| *x).count());\n+    /// ```\n+    /// use std::collections::bitv;\n+    ///\n+    /// let bv = bitv::from_bytes([0b01110100, 0b10010010]);\n+    /// assert_eq!(bv.iter().filter(|x| *x).count(), 7);\n     /// ```\n     #[inline]\n     pub fn iter<'a>(&'a self) -> Bits<'a> {\n         Bits {bitv: self, next_idx: 0, end_idx: self.nbits}\n     }\n \n-    /// Returns `true` if all bits are 0\n+    /// Return `true` if all bits are 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv = Bitv::with_capacity(10, false);\n+    /// assert_eq!(bv.none(), true);\n+    ///\n+    /// bv.set(3, true);\n+    /// assert_eq!(bv.none(), false);\n+    /// ```\n     pub fn none(&self) -> bool {\n         self.mask_words(0).all(|(_, w)| w == 0)\n     }\n \n+    /// Return `true` if any bit is 1.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv = Bitv::with_capacity(10, false);\n+    /// assert_eq!(bv.any(), false);\n+    ///\n+    /// bv.set(3, true);\n+    /// assert_eq!(bv.any(), true);\n+    /// ```\n     #[inline]\n-    /// Returns `true` if any bit is 1\n     pub fn any(&self) -> bool {\n         !self.none()\n     }\n \n-    /**\n-     * Organise the bits into bytes, such that the first bit in the\n-     * `Bitv` becomes the high-order bit of the first byte. If the\n-     * size of the `Bitv` is not a multiple of 8 then trailing bits\n-     * will be filled-in with false/0\n-     */\n+    /// Organise the bits into bytes, such that the first bit in the\n+    /// `Bitv` becomes the high-order bit of the first byte. If the\n+    /// size of the `Bitv` is not a multiple of 8 then trailing bits\n+    /// will be filled-in with `false`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv = Bitv::with_capacity(3, true);\n+    /// bv.set(1, false);\n+    ///\n+    /// assert_eq!(bv.to_bytes(), vec!(0b10100000));\n+    ///\n+    /// let mut bv = Bitv::with_capacity(9, false);\n+    /// bv.set(2, true);\n+    /// bv.set(8, true);\n+    ///\n+    /// assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n+    /// ```\n     pub fn to_bytes(&self) -> Vec<u8> {\n         fn bit (bitv: &Bitv, byte: uint, bit: uint) -> u8 {\n             let offset = byte * 8 + bit;\n@@ -315,18 +543,37 @@ impl Bitv {\n         )\n     }\n \n-    /**\n-     * Transform `self` into a `Vec<bool>` by turning each bit into a `bool`.\n-     */\n+    /// Transform `self` into a `Vec<bool>` by turning each bit into a `bool`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::bitv;\n+    ///\n+    /// let bv = bitv::from_bytes([0b10100000]);\n+    /// assert_eq!(bv.to_bools(), vec!(true, false, true, false,\n+    ///                                false, false, false, false));\n+    /// ```\n     pub fn to_bools(&self) -> Vec<bool> {\n         Vec::from_fn(self.nbits, |i| self.get(i))\n     }\n \n-    /**\n-     * Compare a bitvector to a vector of `bool`.\n-     *\n-     * Both the bitvector and vector must have the same length.\n-     */\n+    /// Compare a bitvector to a vector of `bool`.\n+    /// Both the bitvector and vector must have the same length.\n+    /// # Failure\n+    ///\n+    /// Assert if the bitvectors are of different length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::bitv;\n+    ///\n+    /// let bv = bitv::from_bytes([0b10100000]);\n+    ///\n+    /// assert!(bv.eq_vec([true, false, true, false,\n+    ///                    false, false, false, false]));\n+    /// ```\n     pub fn eq_vec(&self, v: &[bool]) -> bool {\n         assert_eq!(self.nbits, v.len());\n         let mut i = 0;\n@@ -344,12 +591,12 @@ impl Bitv {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// use collections::bitv::Bitv;\n-    /// let mut bvec: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n-    /// let expected: Bitv = vec![false, true].iter().map(|n| *n).collect();\n-    /// bvec.truncate(2);\n-    /// assert_eq!(bvec, expected);\n+    /// ```\n+    /// use std::collections::bitv;\n+    ///\n+    /// let mut bv = bitv::from_bytes([0b01001011]);\n+    /// bv.truncate(2);\n+    /// assert!(bv.eq_vec([false, true]));\n     /// ```\n     pub fn truncate(&mut self, len: uint) {\n         if len < self.len() {\n@@ -363,7 +610,18 @@ impl Bitv {\n         }\n     }\n \n-    /// Grows the vector to be able to store `size` bits without resizing\n+    /// Grow the vector to be able to store `size` bits without resizing.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv = Bitv::with_capacity(3, false);\n+    /// bv.reserve(10);\n+    /// assert_eq!(bv.len(), 3);\n+    /// assert!(bv.capacity() >= 10);\n+    /// ```\n     pub fn reserve(&mut self, size: uint) {\n         let old_size = self.storage.len();\n         let size = (size + uint::BITS - 1) / uint::BITS;\n@@ -372,24 +630,34 @@ impl Bitv {\n         }\n     }\n \n-    /// Returns the capacity in bits for this bit vector. Inserting any\n+    /// Return the capacity in bits for this bit vector. Inserting any\n     /// element less than this amount will not trigger a resizing.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv = Bitv::new();\n+    /// bv.reserve(10);\n+    /// assert!(bv.capacity() >= 10);\n+    /// ```\n     #[inline]\n     pub fn capacity(&self) -> uint {\n         self.storage.len() * uint::BITS\n     }\n \n-    /// Grows the `Bitv` in-place.\n-    ///\n-    /// Adds `n` copies of `value` to the `Bitv`.\n+    /// Grow the `Bitv` in-place. Add `n` copies of `value` to the `Bitv`.\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// use collections::bitv::Bitv;\n-    /// let mut bvec: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n-    /// bvec.grow(2, true);\n-    /// assert_eq!(bvec, vec![false, true, true, false, true, true].iter().map(|n| *n).collect());\n+    /// ```\n+    /// use std::collections::bitv;\n+    ///\n+    /// let mut bv = bitv::from_bytes([0b01001011]);\n+    /// bv.grow(2, true);\n+    /// assert_eq!(bv.len(), 10);\n+    /// assert_eq!(bv.to_bytes(), vec!(0b01001011, 0b11000000));\n     /// ```\n     pub fn grow(&mut self, n: uint, value: bool) {\n         let new_nbits = self.nbits + n;\n@@ -420,17 +688,22 @@ impl Bitv {\n         self.nbits = new_nbits;\n     }\n \n-    /// Shorten a `Bitv` by one, returning the removed element\n+    /// Shorten by one and return the removed element.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Assert if empty.\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// use collections::bitv::Bitv;\n-    /// let mut bvec: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n-    /// let expected: Bitv = vec![false, true, true].iter().map(|n| *n).collect();\n-    /// let popped = bvec.pop();\n-    /// assert_eq!(popped, false);\n-    /// assert_eq!(bvec, expected);\n+    /// ```\n+    /// use std::collections::bitv;\n+    ///\n+    /// let mut bv = bitv::from_bytes([0b01001001]);\n+    /// assert_eq!(bv.pop(), true);\n+    /// assert_eq!(bv.pop(), false);\n+    /// assert_eq!(bv.len(), 6);\n+    /// assert_eq!(bv.to_bytes(), vec!(0b01001000));\n     /// ```\n     pub fn pop(&mut self) -> bool {\n         let ret = self.get(self.nbits - 1);\n@@ -442,17 +715,17 @@ impl Bitv {\n         ret\n     }\n \n-    /// Pushes a `bool` onto the `Bitv`\n+    /// Push a `bool` onto the end.\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// use collections::bitv::Bitv;\n-    /// let prototype: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n-    /// let mut bvec: Bitv = vec![false, true].iter().map(|n| *n).collect();\n-    /// bvec.push(true);\n-    /// bvec.push(false);\n-    /// assert_eq!(prototype, bvec);\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv = Bitv::new();\n+    /// bv.push(true);\n+    /// bv.push(false);\n+    /// assert!(bv.eq_vec([true, false]));\n     /// ```\n     pub fn push(&mut self, elem: bool) {\n         let insert_pos = self.nbits;\n@@ -464,11 +737,21 @@ impl Bitv {\n     }\n }\n \n-/**\n- * Transform a byte-vector into a `Bitv`. Each byte becomes 8 bits,\n- * with the most significant bits of each byte coming first. Each\n- * bit becomes `true` if equal to 1 or `false` if equal to 0.\n- */\n+/// Transform a byte-vector into a `Bitv`. Each byte becomes 8 bits,\n+/// with the most significant bits of each byte coming first. Each\n+/// bit becomes `true` if equal to 1 or `false` if equal to 0.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::bitv;\n+///\n+/// let bv = bitv::from_bytes([0b10100000, 0b00010010]);\n+/// assert!(bv.eq_vec([true, false, true, false,\n+///                    false, false, false, false,\n+///                    false, false, false, true,\n+///                    false, false, true, false]));\n+/// ```\n pub fn from_bytes(bytes: &[u8]) -> Bitv {\n     from_fn(bytes.len() * 8, |i| {\n         let b = bytes[i / 8] as uint;\n@@ -477,10 +760,17 @@ pub fn from_bytes(bytes: &[u8]) -> Bitv {\n     })\n }\n \n-/**\n- * Create a `Bitv` of the specified length where the value at each\n- * index is `f(index)`.\n- */\n+/// Create a `Bitv` of the specified length where the value at each\n+/// index is `f(index)`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::bitv::from_fn;\n+///\n+/// let bv = from_fn(5, |i| { i % 2 == 0 });\n+/// assert!(bv.eq_vec([true, false, true, false, true]));\n+/// ```\n pub fn from_fn(len: uint, f: |index: uint| -> bool) -> Bitv {\n     let mut bitv = Bitv::with_capacity(len, false);\n     for i in range(0u, len) {\n@@ -626,11 +916,45 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n }\n \n /// An implementation of a set using a bit vector as an underlying\n-/// representation for holding numerical elements.\n+/// representation for holding unsigned numerical elements.\n ///\n /// It should also be noted that the amount of storage necessary for holding a\n /// set of objects is proportional to the maximum of the objects when viewed\n /// as a `uint`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::{BitvSet, Bitv};\n+/// use std::collections::bitv;\n+///\n+/// // It's a regular set\n+/// let mut s = BitvSet::new();\n+/// s.insert(0);\n+/// s.insert(3);\n+/// s.insert(7);\n+///\n+/// s.remove(&7);\n+///\n+/// if !s.contains(&7) {\n+///     println!(\"There is no 7\");\n+/// }\n+///\n+/// // Can initialize from a `Bitv`\n+/// let other = BitvSet::from_bitv(bitv::from_bytes([0b11010000]));\n+///\n+/// s.union_with(&other);\n+///\n+/// // Print 0, 1, 3 in some order\n+/// for x in s.iter() {\n+///     println!(\"{}\", x);\n+/// }\n+///\n+/// // Can convert back to a `Bitv`\n+/// let bv: Bitv = s.unwrap();\n+/// assert!(bv.eq_vec([true, true, false, true,\n+///                    false, false, false, false]));\n+/// ```\n #[deriving(Clone, PartialEq, Eq)]\n pub struct BitvSet(Bitv);\n \n@@ -640,54 +964,143 @@ impl Default for BitvSet {\n }\n \n impl BitvSet {\n-    /// Creates a new bit vector set with initially no contents\n+    /// Create a new bit vector set with initially no contents.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// let mut s = BitvSet::new();\n+    /// ```\n     #[inline]\n     pub fn new() -> BitvSet {\n         BitvSet(Bitv::new())\n     }\n \n-    /// Creates a new bit vector set with initially no contents, able to\n-    /// hold `nbits` elements without resizing\n+    /// Create a new bit vector set with initially no contents, able to\n+    /// hold `nbits` elements without resizing.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// let mut s = BitvSet::with_capacity(100);\n+    /// assert!(s.capacity() >= 100);\n+    /// ```\n     #[inline]\n     pub fn with_capacity(nbits: uint) -> BitvSet {\n         BitvSet(Bitv::with_capacity(nbits, false))\n     }\n \n-    /// Creates a new bit vector set from the given bit vector\n+    /// Create a new bit vector set from the given bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::{bitv, BitvSet};\n+    ///\n+    /// let bv = bitv::from_bytes([0b01100000]);\n+    /// let s = BitvSet::from_bitv(bv);\n+    ///\n+    /// // Print 1, 2 in arbitrary order\n+    /// for x in s.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn from_bitv(bitv: Bitv) -> BitvSet {\n         BitvSet(bitv)\n     }\n \n     /// Returns the capacity in bits for this bit vector. Inserting any\n     /// element less than this amount will not trigger a resizing.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    ///\n+    /// let mut s = BitvSet::with_capacity(100);\n+    /// assert!(s.capacity() >= 100);\n+    /// ```\n     #[inline]\n     pub fn capacity(&self) -> uint {\n         let &BitvSet(ref bitv) = self;\n         bitv.capacity()\n     }\n \n-    /// Grows the underlying vector to be able to store `size` bits\n+    /// Grows the underlying vector to be able to store `size` bits.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    ///\n+    /// let mut s = BitvSet::new();\n+    /// s.reserve(10);\n+    /// assert!(s.capacity() >= 10);\n+    /// ```\n     pub fn reserve(&mut self, size: uint) {\n         let &BitvSet(ref mut bitv) = self;\n         bitv.reserve(size)\n     }\n \n-    /// Consumes this set to return the underlying bit vector\n+    /// Consume this set to return the underlying bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    ///\n+    /// let mut s = BitvSet::new();\n+    /// s.insert(0);\n+    /// s.insert(3);\n+    ///\n+    /// let bv = s.unwrap();\n+    /// assert!(bv.eq_vec([true, false, false, true]));\n+    /// ```\n     #[inline]\n     pub fn unwrap(self) -> Bitv {\n         let BitvSet(bitv) = self;\n         bitv\n     }\n \n-    /// Returns a reference to the underlying bit vector\n+    /// Return a reference to the underlying bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    ///\n+    /// let mut s = BitvSet::new();\n+    /// s.insert(0);\n+    ///\n+    /// let bv = s.get_ref();\n+    /// assert_eq!(bv[0], true);\n+    /// ```\n     #[inline]\n     pub fn get_ref<'a>(&'a self) -> &'a Bitv {\n         let &BitvSet(ref bitv) = self;\n         bitv\n     }\n \n-    /// Returns a mutable reference to the underlying bit vector\n+    /// Return a mutable reference to the underlying bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    ///\n+    /// let mut s = BitvSet::new();\n+    /// s.insert(0);\n+    /// assert_eq!(s.contains(&0), true);\n+    /// {\n+    ///     // Will free the set during bv's lifetime\n+    ///     let bv = s.get_mut_ref();\n+    ///     bv.set(0, false);\n+    /// }\n+    /// assert_eq!(s.contains(&0), false);\n+    /// ```\n     #[inline]\n     pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut Bitv {\n         let &BitvSet(ref mut bitv) = self;\n@@ -709,8 +1122,25 @@ impl BitvSet {\n         }\n     }\n \n+    /// Truncate the underlying vector to the least length required.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    ///\n+    /// let mut s = BitvSet::new();\n+    /// s.insert(32183231);\n+    /// s.remove(&32183231);\n+    ///\n+    /// // Internal storage will probably be bigger than necessary\n+    /// println!(\"old capacity: {}\", s.capacity());\n+    ///\n+    /// // Now should be smaller\n+    /// s.shrink_to_fit();\n+    /// println!(\"new capacity: {}\", s.capacity());\n+    /// ```\n     #[inline]\n-    /// Truncate the underlying vector to the least length required\n     pub fn shrink_to_fit(&mut self) {\n         let &BitvSet(ref mut bitv) = self;\n         // Obtain original length\n@@ -723,84 +1153,245 @@ impl BitvSet {\n         bitv.nbits = trunc_len * uint::BITS;\n     }\n \n-    /// Union in-place with the specified other bit vector\n-    #[inline]\n-    pub fn union_with(&mut self, other: &BitvSet) {\n-        self.other_op(other, |w1, w2| w1 | w2);\n-    }\n-\n-    /// Intersect in-place with the specified other bit vector\n-    #[inline]\n-    pub fn intersect_with(&mut self, other: &BitvSet) {\n-        self.other_op(other, |w1, w2| w1 & w2);\n-    }\n-\n-    /// Difference in-place with the specified other bit vector\n-    #[inline]\n-    pub fn difference_with(&mut self, other: &BitvSet) {\n-        self.other_op(other, |w1, w2| w1 & !w2);\n-    }\n-\n-    /// Symmetric difference in-place with the specified other bit vector\n-    #[inline]\n-    pub fn symmetric_difference_with(&mut self, other: &BitvSet) {\n-        self.other_op(other, |w1, w2| w1 ^ w2);\n-    }\n-\n-    /// Iterator over each uint stored in the BitvSet\n+    /// Iterator over each uint stored in the BitvSet.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv;\n+    ///\n+    /// let s = BitvSet::from_bitv(bitv::from_bytes([0b01001010]));\n+    ///\n+    /// // Print 1, 4, 6 in arbitrary order\n+    /// for x in s.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn iter<'a>(&'a self) -> BitPositions<'a> {\n         BitPositions {set: self, next_idx: 0}\n     }\n \n-    /// Iterator over each uint stored in the `self` setminus `other`\n+    /// Iterator over each uint stored in `self` union `other`.\n+    /// See [union_with](#method.union_with) for an efficient in-place version.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv;\n+    ///\n+    /// let a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n+    ///\n+    /// // Print 0, 1, 2, 4 in arbitrary order\n+    /// for x in a.union(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n-    pub fn difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+    pub fn union<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n         TwoBitPositions {\n             set: self,\n             other: other,\n-            merge: |w1, w2| w1 & !w2,\n+            merge: |w1, w2| w1 | w2,\n             current_word: 0,\n             next_idx: 0\n         }\n     }\n \n-    /// Iterator over each uint stored in the symmetric difference of `self` and `other`\n+    /// Iterator over each uint stored in `self` intersect `other`.\n+    /// See [intersect_with](#method.intersect_with) for an efficient in-place version.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv;\n+    ///\n+    /// let a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n+    ///\n+    /// // Print 2\n+    /// for x in a.intersection(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+    pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Take<TwoBitPositions<'a>> {\n+        let min = cmp::min(self.capacity(), other.capacity());\n         TwoBitPositions {\n             set: self,\n             other: other,\n-            merge: |w1, w2| w1 ^ w2,\n+            merge: |w1, w2| w1 & w2,\n             current_word: 0,\n             next_idx: 0\n-        }\n+        }.take(min)\n     }\n \n-    /// Iterator over each uint stored in `self` intersect `other`\n+    /// Iterator over each uint stored in the `self` setminus `other`.\n+    /// See [difference_with](#method.difference_with) for an efficient in-place version.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv;\n+    ///\n+    /// let a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n+    ///\n+    /// // Print 2, 4 in arbitrary order\n+    /// for x in a.difference(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// // Note that difference is not symmetric,\n+    /// // and `b - a` means something else.\n+    /// // This prints 0\n+    /// for x in b.difference(&a) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n-    pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Take<TwoBitPositions<'a>> {\n-        let min = cmp::min(self.capacity(), other.capacity());\n+    pub fn difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n         TwoBitPositions {\n             set: self,\n             other: other,\n-            merge: |w1, w2| w1 & w2,\n+            merge: |w1, w2| w1 & !w2,\n             current_word: 0,\n             next_idx: 0\n-        }.take(min)\n+        }\n     }\n \n-    /// Iterator over each uint stored in `self` union `other`\n+    /// Iterator over each uint stored in the symmetric difference of `self` and `other`.\n+    /// See [symmetric_difference_with](#method.symmetric_difference_with) for\n+    /// an efficient in-place version.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv;\n+    ///\n+    /// let a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n+    ///\n+    /// // Print 0, 1, 4 in arbitrary order\n+    /// for x in a.symmetric_difference(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n-    pub fn union<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n         TwoBitPositions {\n             set: self,\n             other: other,\n-            merge: |w1, w2| w1 | w2,\n+            merge: |w1, w2| w1 ^ w2,\n             current_word: 0,\n             next_idx: 0\n         }\n     }\n+\n+    /// Union in-place with the specified other bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv;\n+    ///\n+    /// let a   = 0b01101000;\n+    /// let b   = 0b10100000;\n+    /// let res = 0b11101000;\n+    ///\n+    /// let mut a = BitvSet::from_bitv(bitv::from_bytes([a]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes([b]));\n+    ///\n+    /// a.union_with(&b);\n+    /// assert_eq!(a.unwrap(), bitv::from_bytes([res]));\n+    /// ```\n+    #[inline]\n+    pub fn union_with(&mut self, other: &BitvSet) {\n+        self.other_op(other, |w1, w2| w1 | w2);\n+    }\n+\n+    /// Intersect in-place with the specified other bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv;\n+    ///\n+    /// let a   = 0b01101000;\n+    /// let b   = 0b10100000;\n+    /// let res = 0b00100000;\n+    ///\n+    /// let mut a = BitvSet::from_bitv(bitv::from_bytes([a]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes([b]));\n+    ///\n+    /// a.intersect_with(&b);\n+    /// assert_eq!(a.unwrap(), bitv::from_bytes([res]));\n+    /// ```\n+    #[inline]\n+    pub fn intersect_with(&mut self, other: &BitvSet) {\n+        self.other_op(other, |w1, w2| w1 & w2);\n+    }\n+\n+    /// Difference in-place with the specified other bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv;\n+    ///\n+    /// let a   = 0b01101000;\n+    /// let b   = 0b10100000;\n+    /// let a_b = 0b01001000; // a - b\n+    /// let b_a = 0b10000000; // b - a\n+    ///\n+    /// let mut bva = BitvSet::from_bitv(bitv::from_bytes([a]));\n+    /// let bvb = BitvSet::from_bitv(bitv::from_bytes([b]));\n+    ///\n+    /// bva.difference_with(&bvb);\n+    /// assert_eq!(bva.unwrap(), bitv::from_bytes([a_b]));\n+    ///\n+    /// let bva = BitvSet::from_bitv(bitv::from_bytes([a]));\n+    /// let mut bvb = BitvSet::from_bitv(bitv::from_bytes([b]));\n+    ///\n+    /// bvb.difference_with(&bva);\n+    /// assert_eq!(bvb.unwrap(), bitv::from_bytes([b_a]));\n+    /// ```\n+    #[inline]\n+    pub fn difference_with(&mut self, other: &BitvSet) {\n+        self.other_op(other, |w1, w2| w1 & !w2);\n+    }\n+\n+    /// Symmetric difference in-place with the specified other bit vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::BitvSet;\n+    /// use std::collections::bitv;\n+    ///\n+    /// let a   = 0b01101000;\n+    /// let b   = 0b10100000;\n+    /// let res = 0b11001000;\n+    ///\n+    /// let mut a = BitvSet::from_bitv(bitv::from_bytes([a]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes([b]));\n+    ///\n+    /// a.symmetric_difference_with(&b);\n+    /// assert_eq!(a.unwrap(), bitv::from_bytes([res]));\n+    /// ```\n+    #[inline]\n+    pub fn symmetric_difference_with(&mut self, other: &BitvSet) {\n+        self.other_op(other, |w1, w2| w1 ^ w2);\n+    }\n }\n \n impl fmt::Show for BitvSet {\n@@ -905,11 +1496,13 @@ impl MutableSet<uint> for BitvSet {\n     }\n }\n \n+/// An iterator for `BitvSet`.\n pub struct BitPositions<'a> {\n     set: &'a BitvSet,\n     next_idx: uint\n }\n \n+/// An iterator combining wo `BitvSet` iterators.\n pub struct TwoBitPositions<'a> {\n     set: &'a BitvSet,\n     other: &'a BitvSet,"}, {"sha": "fba89df1bbc6b2555b9cbb75158d3f9f17866b2c", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 179, "deletions": 12, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -327,33 +327,200 @@ pub trait MutableSet<T>: Set<T> + Mutable {\n \n /// A double-ended sequence that allows querying, insertion and deletion at both\n /// ends.\n+///\n+/// # Example\n+///\n+/// With a `Deque` we can simulate a queue efficiently:\n+///\n+/// ```\n+/// use std::collections::{RingBuf, Deque};\n+///\n+/// let mut queue = RingBuf::new();\n+/// queue.push_back(1i);\n+/// queue.push_back(2i);\n+/// queue.push_back(3i);\n+///\n+/// // Will print 1, 2, 3\n+/// while !queue.is_empty() {\n+///     let x = queue.pop_front().unwrap();\n+///     println!(\"{}\", x);\n+/// }\n+/// ```\n+///\n+/// We can also simulate a stack:\n+///\n+/// ```\n+/// use std::collections::{RingBuf, Deque};\n+///\n+/// let mut stack = RingBuf::new();\n+/// stack.push_front(1i);\n+/// stack.push_front(2i);\n+/// stack.push_front(3i);\n+///\n+/// // Will print 3, 2, 1\n+/// while !stack.is_empty() {\n+///     let x = stack.pop_front().unwrap();\n+///     println!(\"{}\", x);\n+/// }\n+/// ```\n+///\n+/// And of course we can mix and match:\n+///\n+/// ```\n+/// use std::collections::{DList, Deque};\n+///\n+/// let mut deque = DList::new();\n+///\n+/// // Init deque with 1, 2, 3, 4\n+/// deque.push_front(2i);\n+/// deque.push_front(1i);\n+/// deque.push_back(3i);\n+/// deque.push_back(4i);\n+///\n+/// // Will print (1, 4) and (2, 3)\n+/// while !deque.is_empty() {\n+///     let f = deque.pop_front().unwrap();\n+///     let b = deque.pop_back().unwrap();\n+///     println!(\"{}\", (f, b));\n+/// }\n+/// ```\n pub trait Deque<T> : Mutable {\n-    /// Provide a reference to the front element, or None if the sequence is\n-    /// empty\n+    /// Provide a reference to the front element, or `None` if the sequence is\n+    /// empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::{RingBuf, Deque};\n+    ///\n+    /// let mut d = RingBuf::new();\n+    /// assert_eq!(d.front(), None);\n+    ///\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n+    /// assert_eq!(d.front(), Some(&1i));\n+    /// ```\n     fn front<'a>(&'a self) -> Option<&'a T>;\n \n-    /// Provide a mutable reference to the front element, or None if the\n-    /// sequence is empty\n+    /// Provide a mutable reference to the front element, or `None` if the\n+    /// sequence is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::{RingBuf, Deque};\n+    ///\n+    /// let mut d = RingBuf::new();\n+    /// assert_eq!(d.front_mut(), None);\n+    ///\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n+    /// match d.front_mut() {\n+    ///     Some(x) => *x = 9i,\n+    ///     None => (),\n+    /// }\n+    /// assert_eq!(d.front(), Some(&9i));\n+    /// ```\n     fn front_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n \n-    /// Provide a reference to the back element, or None if the sequence is\n-    /// empty\n+    /// Provide a reference to the back element, or `None` if the sequence is\n+    /// empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::{DList, Deque};\n+    ///\n+    /// let mut d = DList::new();\n+    /// assert_eq!(d.back(), None);\n+    ///\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n+    /// assert_eq!(d.back(), Some(&2i));\n+    /// ```\n     fn back<'a>(&'a self) -> Option<&'a T>;\n \n-    /// Provide a mutable reference to the back element, or None if the sequence\n-    /// is empty\n+    /// Provide a mutable reference to the back element, or `None` if the sequence\n+    /// is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::{DList, Deque};\n+    ///\n+    /// let mut d = DList::new();\n+    /// assert_eq!(d.back(), None);\n+    ///\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n+    /// match d.back_mut() {\n+    ///     Some(x) => *x = 9i,\n+    ///     None => (),\n+    /// }\n+    /// assert_eq!(d.back(), Some(&9i));\n+    /// ```\n     fn back_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n \n-    /// Insert an element first in the sequence\n+    /// Insert an element first in the sequence.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::{DList, Deque};\n+    ///\n+    /// let mut d = DList::new();\n+    /// d.push_front(1i);\n+    /// d.push_front(2i);\n+    /// assert_eq!(d.front(), Some(&2i));\n+    /// ```\n     fn push_front(&mut self, elt: T);\n \n-    /// Insert an element last in the sequence\n+    /// Insert an element last in the sequence.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::{DList, Deque};\n+    ///\n+    /// let mut d = DList::new();\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n+    /// assert_eq!(d.front(), Some(&1i));\n+    /// ```\n     fn push_back(&mut self, elt: T);\n \n-    /// Remove the last element and return it, or None if the sequence is empty\n+    /// Remove the last element and return it, or `None` if the sequence is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::{RingBuf, Deque};\n+    ///\n+    /// let mut d = RingBuf::new();\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n+    ///\n+    /// assert_eq!(d.pop_back(), Some(2i));\n+    /// assert_eq!(d.pop_back(), Some(1i));\n+    /// assert_eq!(d.pop_back(), None);\n+    /// ```\n     fn pop_back(&mut self) -> Option<T>;\n \n-    /// Remove the first element and return it, or None if the sequence is empty\n+    /// Remove the first element and return it, or `None` if the sequence is empty.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::{RingBuf, Deque};\n+    ///\n+    /// let mut d = RingBuf::new();\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n+    ///\n+    /// assert_eq!(d.pop_front(), Some(1i));\n+    /// assert_eq!(d.pop_front(), Some(2i));\n+    /// assert_eq!(d.pop_front(), None);\n+    /// ```\n     fn pop_front(&mut self) -> Option<T>;\n }\n "}, {"sha": "d33bd4d04bdfcf684ab6d13a8f7ae0d7548067af", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -856,8 +856,7 @@ mod tests {\n \n     #[bench]\n     fn from_utf8_lossy_100_multibyte(b: &mut Bencher) {\n-        let s = \"\u00f0\u0090\u0152\u20ac\u00f0\u0090\u0152\u2013\u00f0\u0090\u0152\u2039\u00f0\u0090\u0152\u201e\u00f0\u0090\u0152\u2018\u00f0\u0090\u0152\u2030\u00e0\u00b8\u203a\u00e0\u00b8\u00a3\u00d8\u00af\u00d9\u02c6\u00d9\u201e\u00d8\u00a9\\\n-            \u00d8\u00a7\u00d9\u201e\u00d9\u0192\u00d9\u02c6\u00d9\u0160\u00d8\u00aa\u00e0\u00b8\u2014\u00e0\u00b8\u00a8\u00e0\u00b9\u201e\u00e0\u00b8\u2014\u00e0\u00b8\u00a2\u00e4\u00b8\u00ad\u00e5\u008d\u017d\u00f0\u0090\u008d\u2026\u00f0\u0090\u0152\u00bf\u00f0\u0090\u0152\u00bb\u00f0\u0090\u008d\u2020\u00f0\u0090\u0152\u00b9\u00f0\u0090\u0152\u00bb\u00f0\u0090\u0152\u00b0\".as_bytes();\n+        let s = \"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\".as_bytes();\n         assert_eq!(100, s.len());\n         b.iter(|| {\n             let _ = String::from_utf8_lossy(s);"}, {"sha": "751775888b7590fee4f9ed3edec0d0074dd38035", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -51,10 +51,27 @@ pub static PTR_MARKER: u8 = 0;\n /// The `vec!` macro is provided to make initialization more convenient:\n ///\n /// ```rust\n-/// let mut vec = vec!(1i, 2i, 3i);\n+/// let mut vec = vec![1i, 2i, 3i];\n /// vec.push(4);\n-/// assert_eq!(vec, vec!(1, 2, 3, 4));\n+/// assert_eq!(vec, vec![1, 2, 3, 4]);\n /// ```\n+///\n+/// # Capacity and reallocation\n+///\n+/// The capacity of a vector is the amount of space allocated for any future\n+/// elements that will be added onto the vector. This is not to be confused\n+/// with the *length* of a vector, which specifies the number of actual\n+/// elements within the vector. If a vector's length exceeds its capacity,\n+/// its capacity will automatically be increased, but its elements will\n+/// have to be reallocated.\n+///\n+/// For example, a vector with capacity 10 and length 0 would be an empty\n+/// vector with space for 10 more elements. Pushing 10 or fewer elements onto\n+/// the vector will not change its capacity or cause reallocation to occur.\n+/// However, if the vector's length is increased to 11, it will have to\n+/// reallocate, which can be slow. For this reason, it is recommended\n+/// to use `Vec::with_capacity` whenever possible to specify how big the vector\n+/// is expected to get.\n #[unsafe_no_drop_flag]\n pub struct Vec<T> {\n     len: uint,\n@@ -87,11 +104,28 @@ impl<T> Vec<T> {\n     /// The vector will be able to hold exactly `capacity` elements without\n     /// reallocating. If `capacity` is 0, the vector will not allocate.\n     ///\n+    /// It is important to note that this function does not specify the\n+    /// *length* of the returned vector, but only the *capacity*. (For an\n+    /// explanation of the difference between length and capacity, see\n+    /// the main `Vec` docs above, 'Capacity and reallocation'.) To create\n+    /// a vector of a given length, use `Vec::from_elem` or `Vec::from_fn`.\n+    ///\n     /// # Example\n     ///\n     /// ```rust\n     /// # use std::vec::Vec;\n-    /// let vec: Vec<int> = Vec::with_capacity(10);\n+    /// let mut vec: Vec<int> = Vec::with_capacity(10);\n+    ///\n+    /// // The vector contains no items, even though it has capacity for more\n+    /// assert_eq!(vec.len(), 0);\n+    ///\n+    /// // These are all done without reallocating...\n+    /// for i in range(0i, 10) {\n+    ///     vec.push(i);\n+    /// }\n+    ///\n+    /// // ...but this may make the vector reallocate\n+    /// vec.push(11);\n     /// ```\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {"}, {"sha": "f55a1ca62f72f06ef7e91f37fb0f92427c7b7e6e", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -548,7 +548,7 @@ mod tests {\n         from: uint, to: uint, label: &'static str\n     }\n \n-    fn Edge(from: uint, to: uint, label: &'static str) -> Edge {\n+    fn edge(from: uint, to: uint, label: &'static str) -> Edge {\n         Edge { from: from, to: to, label: label }\n     }\n \n@@ -723,7 +723,7 @@ r#\"digraph single_node {\n     fn single_edge() {\n         let labels : Trivial = UnlabelledNodes(2);\n         let result = test_input(LabelledGraph::new(\"single_edge\", labels,\n-                                                   vec!(Edge(0, 1, \"E\"))));\n+                                                   vec!(edge(0, 1, \"E\"))));\n         assert_eq!(result.unwrap().as_slice(),\n r#\"digraph single_edge {\n     N0[label=\"N0\"];\n@@ -737,7 +737,7 @@ r#\"digraph single_edge {\n     fn single_cyclic_node() {\n         let labels : Trivial = UnlabelledNodes(1);\n         let r = test_input(LabelledGraph::new(\"single_cyclic_node\", labels,\n-                                              vec!(Edge(0, 0, \"E\"))));\n+                                              vec!(edge(0, 0, \"E\"))));\n         assert_eq!(r.unwrap().as_slice(),\n r#\"digraph single_cyclic_node {\n     N0[label=\"N0\"];\n@@ -751,8 +751,8 @@ r#\"digraph single_cyclic_node {\n         let labels = AllNodesLabelled(vec!(\"{x,y}\", \"{x}\", \"{y}\", \"{}\"));\n         let r = test_input(LabelledGraph::new(\n             \"hasse_diagram\", labels,\n-            vec!(Edge(0, 1, \"\"), Edge(0, 2, \"\"),\n-                 Edge(1, 3, \"\"), Edge(2, 3, \"\"))));\n+            vec!(edge(0, 1, \"\"), edge(0, 2, \"\"),\n+                 edge(1, 3, \"\"), edge(2, 3, \"\"))));\n         assert_eq!(r.unwrap().as_slice(),\n r#\"digraph hasse_diagram {\n     N0[label=\"{x,y}\"];\n@@ -785,8 +785,8 @@ r#\"digraph hasse_diagram {\n \n         let g = LabelledGraphWithEscStrs::new(\n             \"syntax_tree\", labels,\n-            vec!(Edge(0, 1, \"then\"), Edge(0, 2, \"else\"),\n-                 Edge(1, 3, \";\"),    Edge(2, 3, \";\"   )));\n+            vec!(edge(0, 1, \"then\"), edge(0, 2, \"else\"),\n+                 edge(1, 3, \";\"),    edge(2, 3, \";\"   )));\n \n         render(&g, &mut writer).unwrap();\n         let mut r = BufReader::new(writer.get_ref());"}, {"sha": "c7295125f42f7504de4c1c22546b748058b9f197", "filename": "src/librlibc/lib.rs", "status": "modified", "additions": 105, "deletions": 5, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -21,22 +21,26 @@\n //! the system libc library.\n \n #![crate_name = \"rlibc\"]\n+#![experimental]\n #![license = \"MIT/ASL2\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/master/\")]\n-#![feature(intrinsics)]\n \n+#![feature(intrinsics, phase)]\n #![no_std]\n-#![experimental]\n \n // This library defines the builtin functions, so it would be a shame for\n // LLVM to optimize these function calls to themselves!\n #![no_builtins]\n \n-#[cfg(test)] extern crate std;\n #[cfg(test)] extern crate native;\n+#[cfg(test)] extern crate test;\n+#[cfg(test)] extern crate debug;\n+\n+#[cfg(test)] #[phase(plugin, link)] extern crate std;\n+#[cfg(test)] #[phase(plugin, link)] extern crate core;\n \n // Require the offset intrinsics for LLVM to properly optimize the\n // implementations below. If pointer arithmetic is done through integers the\n@@ -95,11 +99,107 @@ pub unsafe extern \"C\" fn memcmp(s1: *const u8, s2: *const u8, n: uint) -> i32 {\n         let a = *offset(s1, i as int);\n         let b = *offset(s2, i as int);\n         if a != b {\n-            return (a - b) as i32\n+            return a as i32 - b as i32\n         }\n         i += 1;\n     }\n     return 0;\n }\n \n-#[test] fn work_on_windows() { } // FIXME #10872 needed for a happy windows\n+#[cfg(test)]\n+mod test {\n+    use core::option::{Some, None};\n+    use core::iter::Iterator;\n+    use core::collections::Collection;\n+    use core::str::StrSlice;\n+    use core::slice::{MutableVector, ImmutableVector};\n+\n+    use super::{memcmp, memset, memcpy, memmove};\n+\n+    #[test]\n+    fn memcmp_single_byte_pointers() {\n+        unsafe {\n+            assert_eq!(memcmp(&0xFAu8, &0xFAu8, 1), 0x00);\n+            assert!(memcmp(&0xEFu8, &0xFEu8, 1) < 0x00);\n+        }\n+    }\n+\n+    #[test]\n+    fn memcmp_strings() {\n+        {\n+            let (x, z) = (\"Hello!\", \"Good Bye.\");\n+            let l = x.len();\n+            unsafe {\n+                assert_eq!(memcmp(x.as_ptr(), x.as_ptr(), l), 0);\n+                assert!(memcmp(x.as_ptr(), z.as_ptr(), l) > 0);\n+                assert!(memcmp(z.as_ptr(), x.as_ptr(), l) < 0);\n+            }\n+        }\n+        {\n+            let (x, z) = (\"hey!\", \"hey.\");\n+            let l = x.len();\n+            unsafe {\n+                assert!(memcmp(x.as_ptr(), z.as_ptr(), l) < 0);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn memset_single_byte_pointers() {\n+        let mut x: u8 = 0xFF;\n+        unsafe {\n+            memset(&mut x, 0xAA, 1);\n+            assert_eq!(x, 0xAA);\n+            memset(&mut x, 0x00, 1);\n+            assert_eq!(x, 0x00);\n+            x = 0x01;\n+            memset(&mut x, 0x12, 0);\n+            assert_eq!(x, 0x01);\n+        }\n+    }\n+\n+    #[test]\n+    fn memset_array() {\n+        let mut buffer = [b'X', .. 100];\n+        unsafe {\n+            memset(buffer.as_mut_ptr(), b'#' as i32, buffer.len());\n+        }\n+        for byte in buffer.iter() { assert_eq!(*byte, b'#'); }\n+    }\n+\n+    #[test]\n+    fn memcpy_and_memcmp_arrays() {\n+        let (src, mut dst) = ([b'X', .. 100], [b'Y', .. 100]);\n+        unsafe {\n+            assert!(memcmp(src.as_ptr(), dst.as_ptr(), 100) != 0);\n+            let _ = memcpy(dst.as_mut_ptr(), src.as_ptr(), 100);\n+            assert_eq!(memcmp(src.as_ptr(), dst.as_ptr(), 100), 0);\n+        }\n+    }\n+\n+    #[test]\n+    fn memmove_overlapping() {\n+        {\n+            let mut buffer = [ b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9' ];\n+            unsafe {\n+                memmove(&mut buffer[4], &buffer[0], 6);\n+                let mut i = 0;\n+                for byte in b\"0123012345\".iter() {\n+                    assert_eq!(buffer[i], *byte);\n+                    i += 1;\n+                }\n+            }\n+        }\n+        {\n+            let mut buffer = [ b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9' ];\n+            unsafe {\n+                memmove(&mut buffer[0], &buffer[4], 6);\n+                let mut i = 0;\n+                for byte in b\"4567896789\".iter() {\n+                    assert_eq!(buffer[i], *byte);\n+                    i += 1;\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "dd951d963e0d7cfcfd35d0c8038e83e4a26dd65e", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -97,6 +97,10 @@ pub struct Options {\n     pub color: ColorConfig,\n     pub externs: HashMap<String, Vec<String>>,\n     pub crate_name: Option<String>,\n+    /// An optional name to use as the crate for std during std injection,\n+    /// written `extern crate std = \"name\"`. Default to \"std\". Used by\n+    /// out-of-tree drivers.\n+    pub alt_std_name: Option<String>\n }\n \n /// Some reasonable defaults\n@@ -124,6 +128,7 @@ pub fn basic_options() -> Options {\n         color: Auto,\n         externs: HashMap::new(),\n         crate_name: None,\n+        alt_std_name: None,\n     }\n }\n \n@@ -577,7 +582,7 @@ pub fn optgroups() -> Vec<getopts::OptGroup> {\n             always = always colorize output;\n             never  = never colorize output\", \"auto|always|never\"),\n         optmulti(\"\", \"extern\", \"Specify where an external rust library is located\",\n-                 \"PATH\"),\n+                 \"NAME=PATH\"),\n     )\n }\n \n@@ -593,24 +598,10 @@ fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n }\n \n pub fn build_session_options(matches: &getopts::Matches) -> Options {\n-    let mut crate_types: Vec<CrateType> = Vec::new();\n+\n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n-    for unparsed_crate_type in unparsed_crate_types.iter() {\n-        for part in unparsed_crate_type.as_slice().split(',') {\n-            let new_part = match part {\n-                \"lib\"       => default_lib_output(),\n-                \"rlib\"      => CrateTypeRlib,\n-                \"staticlib\" => CrateTypeStaticlib,\n-                \"dylib\"     => CrateTypeDylib,\n-                \"bin\"       => CrateTypeExecutable,\n-                _ => {\n-                    early_error(format!(\"unknown crate type: `{}`\",\n-                                        part).as_slice())\n-                }\n-            };\n-            crate_types.push(new_part)\n-        }\n-    }\n+    let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n+        .unwrap_or_else(|e| early_error(e.as_slice()));\n \n     let parse_only = matches.opt_present(\"parse-only\");\n     let no_trans = matches.opt_present(\"no-trans\");\n@@ -801,9 +792,33 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         color: color,\n         externs: externs,\n         crate_name: crate_name,\n+        alt_std_name: None\n     }\n }\n \n+pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateType>, String> {\n+\n+    let mut crate_types: Vec<CrateType> = Vec::new();\n+    for unparsed_crate_type in list_list.iter() {\n+        for part in unparsed_crate_type.as_slice().split(',') {\n+            let new_part = match part {\n+                \"lib\"       => default_lib_output(),\n+                \"rlib\"      => CrateTypeRlib,\n+                \"staticlib\" => CrateTypeStaticlib,\n+                \"dylib\"     => CrateTypeDylib,\n+                \"bin\"       => CrateTypeExecutable,\n+                _ => {\n+                    return Err(format!(\"unknown crate type: `{}`\",\n+                                       part));\n+                }\n+            };\n+            crate_types.push(new_part)\n+        }\n+    }\n+\n+    return Ok(crate_types);\n+}\n+\n impl fmt::Show for CrateType {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {"}, {"sha": "9796aab51fb6b26b125bdc3fdd3524eabe31b2ed", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -69,7 +69,8 @@ pub fn compile_input(sess: Session,\n                      cfg: ast::CrateConfig,\n                      input: &Input,\n                      outdir: &Option<Path>,\n-                     output: &Option<Path>) {\n+                     output: &Option<Path>,\n+                     addl_plugins: Option<Plugins>) {\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n@@ -85,7 +86,8 @@ pub fn compile_input(sess: Session,\n             let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(),\n                                            input);\n             let (expanded_crate, ast_map)\n-                = match phase_2_configure_and_expand(&sess, krate, id.as_slice()) {\n+                = match phase_2_configure_and_expand(&sess, krate, id.as_slice(),\n+                                                     addl_plugins) {\n                     None => return,\n                     Some(p) => p,\n                 };\n@@ -179,14 +181,16 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n // modified\n \n /// Run the \"early phases\" of the compiler: initial `cfg` processing,\n+/// loading compiler plugins (including those from `addl_plugins`),\n /// syntax expansion, secondary `cfg` expansion, synthesis of a test\n /// harness if one is to be provided and injection of a dependency on the\n /// standard library and prelude.\n ///\n /// Returns `None` if we're aborting after handling -W help.\n pub fn phase_2_configure_and_expand(sess: &Session,\n                                     mut krate: ast::Crate,\n-                                    crate_name: &str)\n+                                    crate_name: &str,\n+                                    addl_plugins: Option<Plugins>)\n                                     -> Option<(ast::Crate, syntax::ast_map::Map)> {\n     let time_passes = sess.time_passes();\n \n@@ -212,9 +216,10 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     krate = time(time_passes, \"configuration 1\", krate, |krate|\n                  front::config::strip_unconfigured_items(krate));\n \n+    let mut addl_plugins = Some(addl_plugins);\n     let Plugins { macros, registrars }\n         = time(time_passes, \"plugin loading\", (), |_|\n-               plugin::load::load_plugins(sess, &krate));\n+               plugin::load::load_plugins(sess, &krate, addl_plugins.take_unwrap()));\n \n     let mut registry = Registry::new(&krate);\n \n@@ -697,7 +702,7 @@ pub fn pretty_print_input(sess: Session,\n         PpmExpanded | PpmExpandedIdentified | PpmTyped | PpmFlowGraph(_) => {\n             let (krate, ast_map)\n                 = match phase_2_configure_and_expand(&sess, krate,\n-                                                     id.as_slice()) {\n+                                                     id.as_slice(), None) {\n                     None => return,\n                     Some(p) => p,\n                 };"}, {"sha": "a5df63a9e23fa813400889f76c807bf7a5a19ebe", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -124,7 +124,7 @@ fn run_compiler(args: &[String]) {\n         return;\n     }\n \n-    driver::compile_input(sess, cfg, &input, &odir, &ofile);\n+    driver::compile_input(sess, cfg, &input, &odir, &ofile, None);\n }\n \n /// Prints version information and returns None on success or an error\n@@ -418,7 +418,7 @@ pub fn list_metadata(sess: &Session, path: &Path,\n ///\n /// The diagnostic emitter yielded to the procedure should be used for reporting\n /// errors of the compiler.\n-fn monitor(f: proc():Send) {\n+pub fn monitor(f: proc():Send) {\n     // FIXME: This is a hack for newsched since it doesn't support split stacks.\n     // rustc needs a lot of stack! When optimizations are disabled, it needs\n     // even *more* stack than usual as well."}, {"sha": "940112325fdf42d61040a431d81518d573a2edca", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -60,9 +60,16 @@ struct StandardLibraryInjector<'a> {\n \n impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n     fn fold_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n+\n+        // The name to use in `extern crate std = \"name\";`\n+        let actual_crate_name = match self.sess.opts.alt_std_name {\n+            Some(ref s) => token::intern_and_get_ident(s.as_slice()),\n+            None => token::intern_and_get_ident(\"std\"),\n+        };\n+\n         let mut vis = vec!(ast::ViewItem {\n             node: ast::ViewItemExternCrate(token::str_to_ident(\"std\"),\n-                                           None,\n+                                           Some((actual_crate_name, ast::CookedStr)),\n                                            ast::DUMMY_NODE_ID),\n             attrs: vec!(\n                 attr::mk_attr_outer(attr::mk_attr_id(), attr::mk_list_item("}, {"sha": "08907f6c0ed5d8394a1004f9eac95091e3023ef6", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 66, "deletions": 44, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -16,16 +16,17 @@\n use driver::session::Session;\n use front::config;\n \n-use std::cell::RefCell;\n use std::gc::{Gc, GC};\n use std::slice;\n+use std::mem;\n use std::vec;\n use syntax::ast_util::*;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n+use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::fold::Folder;\n use syntax::fold;\n@@ -46,9 +47,11 @@ struct Test {\n \n struct TestCtxt<'a> {\n     sess: &'a Session,\n-    path: RefCell<Vec<ast::Ident>>,\n+    path: Vec<ast::Ident>,\n+    reexports: Vec<Vec<ast::Ident>>,\n     ext_cx: ExtCtxt<'a>,\n-    testfns: RefCell<Vec<Test> >,\n+    testfns: Vec<Test>,\n+    reexport_mod_ident: ast::Ident,\n     is_test_crate: bool,\n     config: ast::CrateConfig,\n }\n@@ -86,9 +89,9 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n     }\n \n     fn fold_item(&mut self, i: Gc<ast::Item>) -> SmallVector<Gc<ast::Item>> {\n-        self.cx.path.borrow_mut().push(i.ident);\n+        self.cx.path.push(i.ident);\n         debug!(\"current path: {}\",\n-               ast_util::path_name_i(self.cx.path.borrow().as_slice()));\n+               ast_util::path_name_i(self.cx.path.as_slice()));\n \n         if is_test_fn(&self.cx, i) || is_bench_fn(&self.cx, i) {\n             match i.node {\n@@ -102,31 +105,41 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                     debug!(\"this is a test function\");\n                     let test = Test {\n                         span: i.span,\n-                        path: self.cx.path.borrow().clone(),\n+                        path: self.cx.path.clone(),\n                         bench: is_bench_fn(&self.cx, i),\n                         ignore: is_ignored(&self.cx, i),\n                         should_fail: should_fail(i)\n                     };\n-                    self.cx.testfns.borrow_mut().push(test);\n+                    self.cx.testfns.push(test);\n+                    self.cx.reexports.push(self.cx.path.clone());\n                     // debug!(\"have {} test/bench functions\",\n                     //        cx.testfns.len());\n                 }\n             }\n         }\n \n-        let res = fold::noop_fold_item(&*i, self);\n-        self.cx.path.borrow_mut().pop();\n+        // We don't want to recurse into anything other than mods, since\n+        // mods or tests inside of functions will break things\n+        let res = match i.node {\n+            ast::ItemMod(..) => fold::noop_fold_item(&*i, self),\n+            _ => SmallVector::one(i),\n+        };\n+        self.cx.path.pop();\n         res\n     }\n \n     fn fold_mod(&mut self, m: &ast::Mod) -> ast::Mod {\n+        let reexports = mem::replace(&mut self.cx.reexports, Vec::new());\n+        let mut mod_folded = fold::noop_fold_mod(m, self);\n+        let reexports = mem::replace(&mut self.cx.reexports, reexports);\n+\n         // Remove any #[main] from the AST so it doesn't clash with\n         // the one we're going to add. Only if compiling an executable.\n \n         fn nomain(item: Gc<ast::Item>) -> Gc<ast::Item> {\n             box(GC) ast::Item {\n                 attrs: item.attrs.iter().filter_map(|attr| {\n-                    if !attr.name().equiv(&(\"main\")) {\n+                    if !attr.check_name(\"main\") {\n                         Some(*attr)\n                     } else {\n                         None\n@@ -136,27 +149,50 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             }\n         }\n \n-        let mod_nomain = ast::Mod {\n-            inner: m.inner,\n-            view_items: m.view_items.clone(),\n-            items: m.items.iter().map(|i| nomain(*i)).collect(),\n-        };\n+        for i in mod_folded.items.mut_iter() {\n+            *i = nomain(*i);\n+        }\n+        if !reexports.is_empty() {\n+            mod_folded.items.push(mk_reexport_mod(&mut self.cx, reexports));\n+            self.cx.reexports.push(self.cx.path.clone());\n+        }\n+\n+        mod_folded\n+    }\n+}\n \n-        fold::noop_fold_mod(&mod_nomain, self)\n+fn mk_reexport_mod(cx: &mut TestCtxt, reexports: Vec<Vec<ast::Ident>>)\n+                   -> Gc<ast::Item> {\n+    let view_items = reexports.move_iter().map(|r| {\n+        cx.ext_cx.view_use_simple(DUMMY_SP, ast::Public, cx.ext_cx.path(DUMMY_SP, r))\n+    }).collect();\n+    let reexport_mod = ast::Mod {\n+        inner: DUMMY_SP,\n+        view_items: view_items,\n+        items: Vec::new(),\n+    };\n+    box(GC) ast::Item {\n+        ident: cx.reexport_mod_ident.clone(),\n+        attrs: Vec::new(),\n+        id: ast::DUMMY_NODE_ID,\n+        node: ast::ItemMod(reexport_mod),\n+        vis: ast::Public,\n+        span: DUMMY_SP,\n     }\n }\n \n-fn generate_test_harness(sess: &Session, krate: ast::Crate)\n-                         -> ast::Crate {\n+fn generate_test_harness(sess: &Session, krate: ast::Crate) -> ast::Crate {\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         ext_cx: ExtCtxt::new(&sess.parse_sess, sess.opts.cfg.clone(),\n                              ExpansionConfig {\n                                  deriving_hash_type_parameter: false,\n                                  crate_name: \"test\".to_string(),\n                              }),\n-        path: RefCell::new(Vec::new()),\n-        testfns: RefCell::new(Vec::new()),\n+        path: Vec::new(),\n+        reexports: Vec::new(),\n+        testfns: Vec::new(),\n+        reexport_mod_ident: token::str_to_ident(\"__test_reexports\"),\n         is_test_crate: is_test_crate(&krate),\n         config: krate.config.clone(),\n     };\n@@ -171,7 +207,7 @@ fn generate_test_harness(sess: &Session, krate: ast::Crate)\n     });\n \n     let mut fold = TestHarnessGenerator {\n-        cx: cx\n+        cx: cx,\n     };\n     let res = fold.fold_crate(krate);\n     fold.cx.ext_cx.bt_pop();\n@@ -275,7 +311,6 @@ fn add_test_module(cx: &TestCtxt, m: &ast::Mod) -> ast::Mod {\n We're going to be building a module that looks more or less like:\n \n mod __test {\n-  #![!resolve_unexported]\n   extern crate test (name = \"test\", vers = \"...\");\n   fn main() {\n     test::test_main_static(::os::args().as_slice(), tests)\n@@ -332,15 +367,9 @@ fn mk_test_module(cx: &TestCtxt) -> Gc<ast::Item> {\n     };\n     let item_ = ast::ItemMod(testmod);\n \n-    // This attribute tells resolve to let us call unexported functions\n-    let resolve_unexported_str = InternedString::new(\"!resolve_unexported\");\n-    let resolve_unexported_attr =\n-        attr::mk_attr_inner(attr::mk_attr_id(),\n-                            attr::mk_word_item(resolve_unexported_str));\n-\n     let item = ast::Item {\n         ident: token::str_to_ident(\"__test\"),\n-        attrs: vec!(resolve_unexported_attr),\n+        attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n         node: item_,\n         vis: ast::Public,\n@@ -368,18 +397,6 @@ fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n     }\n }\n \n-fn path_node_global(ids: Vec<ast::Ident> ) -> ast::Path {\n-    ast::Path {\n-        span: DUMMY_SP,\n-        global: true,\n-        segments: ids.move_iter().map(|identifier| ast::PathSegment {\n-            identifier: identifier,\n-            lifetimes: Vec::new(),\n-            types: OwnedSlice::empty(),\n-        }).collect()\n-    }\n-}\n-\n fn mk_tests(cx: &TestCtxt) -> Gc<ast::Item> {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_descs(cx);\n@@ -399,13 +416,13 @@ fn is_test_crate(krate: &ast::Crate) -> bool {\n }\n \n fn mk_test_descs(cx: &TestCtxt) -> Gc<ast::Expr> {\n-    debug!(\"building test vector from {} tests\", cx.testfns.borrow().len());\n+    debug!(\"building test vector from {} tests\", cx.testfns.len());\n \n     box(GC) ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprVstore(box(GC) ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::ExprVec(cx.testfns.borrow().iter().map(|test| {\n+            node: ast::ExprVec(cx.testfns.iter().map(|test| {\n                 mk_test_desc_and_fn_rec(cx, test)\n             }).collect()),\n             span: DUMMY_SP,\n@@ -431,7 +448,12 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> Gc<ast::Expr> {\n           span: span\n     };\n \n-    let fn_path = path_node_global(path);\n+    let mut visible_path = Vec::new();\n+    for ident in path.move_iter() {\n+        visible_path.push(cx.reexport_mod_ident.clone());\n+        visible_path.push(ident);\n+    }\n+    let fn_path = cx.ext_cx.path_global(DUMMY_SP, visible_path);\n \n     let fn_expr = box(GC) ast::Expr {\n         id: ast::DUMMY_NODE_ID,"}, {"sha": "7997af1ee5e11980e971a569c5b4548d8db70260", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -1618,8 +1618,8 @@ fn encode_macro_defs(ecx: &EncodeContext,\n                      krate: &Crate,\n                      ebml_w: &mut Encoder) {\n     ebml_w.start_tag(tag_exported_macros);\n-    for span in krate.exported_macros.iter() {\n-        encode_macro_def(ecx, ebml_w, span);\n+    for item in krate.exported_macros.iter() {\n+        encode_macro_def(ecx, ebml_w, &item.span);\n     }\n     ebml_w.end_tag();\n }"}, {"sha": "62b5299f8fbc8619cb0d02319c41f878d8eecc21", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -27,7 +27,6 @@ use util::nodemap::{NodeMap, NodeSet};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{is_local, local_def, PostExpansionMethod};\n-use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::owned_slice::OwnedSlice;\n@@ -326,7 +325,7 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n     }\n \n     fn visit_foreign_item(&mut self, a: &ast::ForeignItem, _: ()) {\n-        if self.prev_exported && a.vis == ast::Public {\n+        if (self.prev_exported && a.vis == ast::Public) || self.reexports.contains(&a.id) {\n             self.exported_items.insert(a.id);\n         }\n     }\n@@ -786,12 +785,6 @@ impl<'a> PrivacyVisitor<'a> {\n \n impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n-        // Do not check privacy inside items with the resolve_unexported\n-        // attribute. This is used for the test runner.\n-        if attr::contains_name(item.attrs.as_slice(), \"!resolve_unexported\") {\n-            return;\n-        }\n-\n         let orig_curitem = replace(&mut self.curitem, item.id);\n         visit::walk_item(self, item, ());\n         self.curitem = orig_curitem;"}, {"sha": "637af96b6321ab23cb2e0521922e89a8e345ff5d", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -117,7 +117,7 @@ fn test_env(_test_name: &str,\n     let input = driver::StrInput(source_string.to_string());\n     let krate = driver::phase_1_parse_input(&sess, krate_config, &input);\n     let (krate, ast_map) =\n-        driver::phase_2_configure_and_expand(&sess, krate, \"test\")\n+        driver::phase_2_configure_and_expand(&sess, krate, \"test\", None)\n             .expect(\"phase 2 aborted\");\n \n     // run just enough stuff to build a tcx:"}, {"sha": "4f38c74893e46630c08420440a49160938272d37", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -66,10 +66,24 @@ impl<'a> PluginLoader<'a> {\n }\n \n /// Read plugin metadata and dynamically load registrar functions.\n-pub fn load_plugins(sess: &Session, krate: &ast::Crate) -> Plugins {\n+pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n+                    addl_plugins: Option<Plugins>) -> Plugins {\n     let mut loader = PluginLoader::new(sess);\n     visit::walk_crate(&mut loader, krate, ());\n-    loader.plugins\n+\n+    let mut plugins = loader.plugins;\n+\n+    match addl_plugins {\n+        Some(addl_plugins) => {\n+            // Add in the additional plugins requested by the frontend\n+            let Plugins { macros: addl_macros, registrars: addl_registrars } = addl_plugins;\n+            plugins.macros.push_all_move(addl_macros);\n+            plugins.registrars.push_all_move(addl_registrars);\n+        }\n+        None => ()\n+    }\n+\n+    return plugins;\n }\n \n // note that macros aren't expanded yet, and therefore macros can't add plugins."}, {"sha": "7f021510f4a0ed85838d81f036856df189155a29", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -77,8 +77,10 @@ pub struct CrateAnalysis {\n     pub inlined: RefCell<Option<HashSet<ast::DefId>>>,\n }\n \n+pub type Externs = HashMap<String, Vec<String>>;\n+\n /// Parses, resolves, and typechecks the given crate\n-fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n+fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>, externs: Externs)\n                        -> (DocContext, CrateAnalysis) {\n     use syntax::codemap::dummy_spanned;\n     use rustc::driver::driver::{FileInput,\n@@ -96,6 +98,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n         addl_lib_search_paths: RefCell::new(libs),\n         crate_types: vec!(driver::config::CrateTypeRlib),\n         lint_opts: vec!((warning_lint, lint::Allow)),\n+        externs: externs,\n         ..rustc::driver::config::basic_options().clone()\n     };\n \n@@ -121,7 +124,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n                                      &input);\n \n     let (krate, ast_map)\n-        = phase_2_configure_and_expand(&sess, krate, name.as_slice())\n+        = phase_2_configure_and_expand(&sess, krate, name.as_slice(), None)\n             .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let driver::driver::CrateAnalysis {\n@@ -148,9 +151,9 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n     })\n }\n \n-pub fn run_core(libs: HashSet<Path>, cfgs: Vec<String>, path: &Path)\n+pub fn run_core(libs: HashSet<Path>, cfgs: Vec<String>, externs: Externs, path: &Path)\n                 -> (clean::Crate, CrateAnalysis) {\n-    let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs);\n+    let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs, externs);\n     let ctxt = box(GC) ctxt;\n     super::ctxtkey.replace(Some(ctxt));\n "}, {"sha": "a7c9ac10118296b3830270a6af0b918aa14d18d3", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -30,6 +30,7 @@ extern crate time;\n use std::io;\n use std::io::{File, MemWriter};\n use std::gc::Gc;\n+use std::collections::HashMap;\n use serialize::{json, Decodable, Encodable};\n use externalfiles::ExternalHtml;\n \n@@ -104,6 +105,7 @@ pub fn opts() -> Vec<getopts::OptGroup> {\n         optmulti(\"L\", \"library-path\", \"directory to add to crate search path\",\n                  \"DIR\"),\n         optmulti(\"\", \"cfg\", \"pass a --cfg to rustc\", \"\"),\n+        optmulti(\"\", \"extern\", \"pass an --extern to rustc\", \"NAME=PATH\"),\n         optmulti(\"\", \"plugin-path\", \"directory to load plugins from\", \"DIR\"),\n         optmulti(\"\", \"passes\", \"space separated list of passes to also run, a \\\n                                 value of `list` will print available passes\",\n@@ -170,6 +172,13 @@ pub fn main_args(args: &[String]) -> int {\n     let input = matches.free[0].as_slice();\n \n     let libs = matches.opt_strs(\"L\").iter().map(|s| Path::new(s.as_slice())).collect();\n+    let externs = match parse_externs(&matches) {\n+        Ok(ex) => ex,\n+        Err(err) => {\n+            println!(\"{}\", err);\n+            return 1;\n+        }\n+    };\n \n     let test_args = matches.opt_strs(\"test-args\");\n     let test_args: Vec<String> = test_args.iter()\n@@ -193,10 +202,10 @@ pub fn main_args(args: &[String]) -> int {\n \n     match (should_test, markdown_input) {\n         (true, true) => {\n-            return markdown::test(input, libs, test_args)\n+            return markdown::test(input, libs, externs, test_args)\n         }\n         (true, false) => {\n-            return test::run(input, cfgs, libs, test_args)\n+            return test::run(input, cfgs, libs, externs, test_args)\n         }\n         (false, true) => return markdown::render(input, output.unwrap_or(Path::new(\"doc\")),\n                                                  &matches, &external_html),\n@@ -215,7 +224,7 @@ pub fn main_args(args: &[String]) -> int {\n         return 0;\n     }\n \n-    let (krate, res) = match acquire_input(input, &matches) {\n+    let (krate, res) = match acquire_input(input, externs, &matches) {\n         Ok(pair) => pair,\n         Err(s) => {\n             println!(\"input error: {}\", s);\n@@ -252,27 +261,53 @@ pub fn main_args(args: &[String]) -> int {\n /// Looks inside the command line arguments to extract the relevant input format\n /// and files and then generates the necessary rustdoc output for formatting.\n fn acquire_input(input: &str,\n+                 externs: core::Externs,\n                  matches: &getopts::Matches) -> Result<Output, String> {\n     match matches.opt_str(\"r\").as_ref().map(|s| s.as_slice()) {\n-        Some(\"rust\") => Ok(rust_input(input, matches)),\n+        Some(\"rust\") => Ok(rust_input(input, externs, matches)),\n         Some(\"json\") => json_input(input),\n         Some(s) => Err(format!(\"unknown input format: {}\", s)),\n         None => {\n             if input.ends_with(\".json\") {\n                 json_input(input)\n             } else {\n-                Ok(rust_input(input, matches))\n+                Ok(rust_input(input, externs, matches))\n             }\n         }\n     }\n }\n \n+/// Extracts `--extern CRATE=PATH` arguments from `matches` and\n+/// returns a `HashMap` mapping crate names to their paths or else an\n+/// error message.\n+fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n+    let mut externs = HashMap::new();\n+    for arg in matches.opt_strs(\"extern\").iter() {\n+        let mut parts = arg.as_slice().splitn('=', 1);\n+        let name = match parts.next() {\n+            Some(s) => s,\n+            None => {\n+                return Err(\"--extern value must not be empty\".to_string());\n+            }\n+        };\n+        let location = match parts.next() {\n+            Some(s) => s,\n+            None => {\n+                return Err(\"--extern value must be of the format `foo=bar`\".to_string());\n+            }\n+        };\n+        let locs = externs.find_or_insert(name.to_string(), Vec::new());\n+        locs.push(location.to_string());\n+    }\n+    Ok(externs)\n+}\n+\n /// Interprets the input file as a rust source file, passing it through the\n /// compiler all the way through the analysis passes. The rustdoc output is then\n /// generated from the cleaned AST of the crate.\n ///\n /// This form of input will run all of the plug/cleaning passes\n-fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n+fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matches) -> Output {\n     let mut default_passes = !matches.opt_present(\"no-defaults\");\n     let mut passes = matches.opt_strs(\"passes\");\n     let mut plugins = matches.opt_strs(\"plugins\");\n@@ -283,12 +318,14 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n                                  .map(|s| Path::new(s.as_slice()))\n                                  .collect();\n     let cfgs = matches.opt_strs(\"cfg\");\n+\n     let cr = Path::new(cratefile);\n     info!(\"starting to run rustc\");\n     let (krate, analysis) = std::task::try(proc() {\n         let cr = cr;\n-        core::run_core(libs.move_iter().map(|x| x.clone()).collect(),\n+        core::run_core(libs.move_iter().collect(),\n                        cfgs,\n+                       externs,\n                        &cr)\n     }).map_err(|boxed_any|format!(\"{:?}\", boxed_any)).unwrap();\n     info!(\"finished with rustc\");"}, {"sha": "47009c1f2cc15ef8cc447fdadc002fc2e4e248ea", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -12,6 +12,7 @@ use std::collections::HashSet;\n use std::io;\n use std::string::String;\n \n+use core;\n use getopts;\n use testing;\n \n@@ -129,10 +130,11 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n }\n \n /// Run any tests/code examples in the markdown file `input`.\n-pub fn test(input: &str, libs: HashSet<Path>, mut test_args: Vec<String>) -> int {\n+pub fn test(input: &str, libs: HashSet<Path>, externs: core::Externs,\n+            mut test_args: Vec<String>) -> int {\n     let input_str = load_or_return!(input, 1, 2);\n \n-    let mut collector = Collector::new(input.to_string(), libs, true);\n+    let mut collector = Collector::new(input.to_string(), libs, externs, true);\n     find_testable_code(input_str.as_slice(), &mut collector);\n     test_args.unshift(\"rustdoctest\".to_string());\n     testing::test_main(test_args.as_slice(), collector.tests);"}, {"sha": "2ed35469dfa8d127db57e0bc66819d339a9206b9", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -40,6 +40,7 @@ use visit_ast::RustdocVisitor;\n pub fn run(input: &str,\n            cfgs: Vec<String>,\n            libs: HashSet<Path>,\n+           externs: core::Externs,\n            mut test_args: Vec<String>)\n            -> int {\n     let input_path = Path::new(input);\n@@ -49,10 +50,10 @@ pub fn run(input: &str,\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: RefCell::new(libs.clone()),\n         crate_types: vec!(config::CrateTypeDylib),\n+        externs: externs.clone(),\n         ..config::basic_options().clone()\n     };\n \n-\n     let codemap = CodeMap::new();\n     let diagnostic_handler = diagnostic::default_handler(diagnostic::Auto, None);\n     let span_diagnostic_handler =\n@@ -69,7 +70,7 @@ pub fn run(input: &str,\n     }));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n     let (krate, _) = driver::phase_2_configure_and_expand(&sess, krate,\n-                                                          \"rustdoc-test\")\n+                                                          \"rustdoc-test\", None)\n         .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let ctx = box(GC) core::DocContext {\n@@ -92,6 +93,7 @@ pub fn run(input: &str,\n \n     let mut collector = Collector::new(krate.name.to_string(),\n                                        libs,\n+                                       externs,\n                                        false);\n     collector.fold_crate(krate);\n \n@@ -102,8 +104,8 @@ pub fn run(input: &str,\n     0\n }\n \n-fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n-           no_run: bool, as_test_harness: bool) {\n+fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, externs: core::Externs,\n+           should_fail: bool, no_run: bool, as_test_harness: bool) {\n     // the test harness wants its own `main` & top level functions, so\n     // never wrap the test in `fn main() { ... }`\n     let test = maketest(test, Some(cratename), true, as_test_harness);\n@@ -115,6 +117,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n         crate_types: vec!(config::CrateTypeExecutable),\n         output_types: vec!(link::OutputTypeExe),\n         no_trans: no_run,\n+        externs: externs,\n         cg: config::CodegenOptions {\n             prefer_dynamic: true,\n             .. config::basic_codegen_options()\n@@ -166,7 +169,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     let out = Some(outdir.path().clone());\n     let cfg = config::build_configuration(&sess);\n     let libdir = sess.target_filesearch().get_lib_path();\n-    driver::compile_input(sess, cfg, &input, &out, &None);\n+    driver::compile_input(sess, cfg, &input, &out, &None, None);\n \n     if no_run { return }\n \n@@ -237,19 +240,21 @@ pub struct Collector {\n     pub tests: Vec<testing::TestDescAndFn>,\n     names: Vec<String>,\n     libs: HashSet<Path>,\n+    externs: core::Externs,\n     cnt: uint,\n     use_headers: bool,\n     current_header: Option<String>,\n     cratename: String,\n }\n \n impl Collector {\n-    pub fn new(cratename: String, libs: HashSet<Path>,\n+    pub fn new(cratename: String, libs: HashSet<Path>, externs: core::Externs,\n                use_headers: bool) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             names: Vec::new(),\n             libs: libs,\n+            externs: externs,\n             cnt: 0,\n             use_headers: use_headers,\n             current_header: None,\n@@ -267,6 +272,7 @@ impl Collector {\n         };\n         self.cnt += 1;\n         let libs = self.libs.clone();\n+        let externs = self.externs.clone();\n         let cratename = self.cratename.to_string();\n         debug!(\"Creating test {}: {}\", name, test);\n         self.tests.push(testing::TestDescAndFn {\n@@ -279,6 +285,7 @@ impl Collector {\n                 runtest(test.as_slice(),\n                         cratename.as_slice(),\n                         libs,\n+                        externs,\n                         should_fail,\n                         no_run,\n                         as_test_harness);"}, {"sha": "594a235339669694357c7693e11a061dfa1cf6c7", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -26,6 +26,14 @@ use std::gc::{Gc, GC};\n use core;\n use doctree::*;\n \n+// looks to me like the first two of these are actually\n+// output parameters, maybe only mutated once; perhaps\n+// better simply to have the visit method return a tuple\n+// containing them?\n+\n+// also, is there some reason that this doesn't use the 'visit'\n+// framework from syntax?\n+\n pub struct RustdocVisitor<'a> {\n     pub module: Module,\n     pub attrs: Vec<ast::Attribute>,\n@@ -64,6 +72,9 @@ impl<'a> RustdocVisitor<'a> {\n                                               ast::CRATE_NODE_ID,\n                                               &krate.module,\n                                               None);\n+        // attach the crate's exported macros to the top-level module:\n+        self.module.macros = krate.exported_macros.iter()\n+            .map(|it| self.visit_macro(&**it)).collect();\n         self.module.is_crate = true;\n     }\n \n@@ -323,15 +334,20 @@ impl<'a> RustdocVisitor<'a> {\n             ast::ItemForeignMod(ref fm) => {\n                 om.foreigns.push(fm.clone());\n             }\n-            ast::ItemMac(ref _m) => {\n-                om.macros.push(Macro {\n-                    id: item.id,\n-                    attrs: item.attrs.iter().map(|x| *x).collect(),\n-                    name: item.ident,\n-                    where: item.span,\n-                    stab: self.stability(item.id),\n-                })\n+            ast::ItemMac(_) => {\n+                fail!(\"rustdoc: macros should be gone, after expansion\");\n             }\n         }\n     }\n+\n+    // convert each exported_macro into a doc item\n+    fn visit_macro(&self, item: &ast::Item) -> Macro {\n+        Macro {\n+            id: item.id,\n+            attrs: item.attrs.iter().map(|x| *x).collect(),\n+            name: item.ident,\n+            where: item.span,\n+            stab: self.stability(item.id),\n+        }\n+    }\n }"}, {"sha": "966e4f8811eaaa12a11fa82bc82f2c82d160b1b7", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -20,7 +20,7 @@ use option::{Option, Some, None};\n use slice::{ImmutableVector, MutableVector, Vector};\n use str::{OwnedStr, Str, StrAllocating, StrSlice};\n use string::String;\n-use to_str::{IntoStr};\n+use to_string::IntoStr;\n use vec::Vec;\n \n /// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero."}, {"sha": "e14092bc8dc1604e04b29883d24396bf480b95fa", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -239,7 +239,7 @@ pub mod gc;\n \n pub mod from_str;\n pub mod num;\n-pub mod to_str;\n+pub mod to_string;\n \n /* Common data structures */\n "}, {"sha": "0fa223305a669d36fb929c9896d864e85768e9bd", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -78,7 +78,7 @@\n #[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek};\n #[doc(no_inline)] pub use str::{Str, StrVector, StrSlice, OwnedStr};\n #[doc(no_inline)] pub use str::{IntoMaybeOwned, StrAllocating, UnicodeStrSlice};\n-#[doc(no_inline)] pub use to_str::{ToString, IntoStr};\n+#[doc(no_inline)] pub use to_string::{ToString, IntoStr};\n #[doc(no_inline)] pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n #[doc(no_inline)] pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n #[doc(no_inline)] pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};"}, {"sha": "19ad81a04834d606ebaa613928f281f6bf8a220f", "filename": "src/libstd/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -106,7 +106,7 @@ use rt::task::Task;\n use str::{Str, SendStr, IntoMaybeOwned};\n use string::String;\n use sync::Future;\n-use to_str::ToString;\n+use to_string::ToString;\n \n /// A means of spawning a task\n pub trait Spawner {"}, {"sha": "c19fd81b5705667185f8a8a9391fca11a9114dba", "filename": "src/libstd/to_string.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibstd%2Fto_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibstd%2Fto_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_string.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "previous_filename": "src/libstd/to_str.rs"}, {"sha": "614bbd1c3ed00f4e5592891798e2ee22aca65d68", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -256,7 +256,7 @@ pub struct Crate {\n     pub attrs: Vec<Attribute>,\n     pub config: CrateConfig,\n     pub span: Span,\n-    pub exported_macros: Vec<Span>\n+    pub exported_macros: Vec<Gc<Item>>\n }\n \n pub type MetaItem = Spanned<MetaItem_>;"}, {"sha": "5341f0c2d61b26ba44c5a12fcb0350db637eed09", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -104,9 +104,9 @@ pub type IdentMacroExpanderFn =\n /// just into the compiler's internal macro table, for `make_def`).\n pub trait MacResult {\n     /// Define a new macro.\n-    // this should go away; the idea that a macro might expand into\n-    // either a macro definition or an expression, depending on what\n-    // the context wants, is kind of silly.\n+    // this particular flavor should go away; the idea that a macro might\n+    // expand into either a macro definition or an expression, depending\n+    // on what the context wants, is kind of silly.\n     fn make_def(&self) -> Option<MacroDef> {\n         None\n     }\n@@ -431,7 +431,7 @@ pub struct ExtCtxt<'a> {\n \n     pub mod_path: Vec<ast::Ident> ,\n     pub trace_mac: bool,\n-    pub exported_macros: Vec<codemap::Span>\n+    pub exported_macros: Vec<Gc<ast::Item>>\n }\n \n impl<'a> ExtCtxt<'a> {\n@@ -562,9 +562,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn name_of(&self, st: &str) -> ast::Name {\n         token::intern(st)\n     }\n-    pub fn push_exported_macro(&mut self, span: codemap::Span) {\n-        self.exported_macros.push(span);\n-    }\n }\n \n /// Extract a string literal from the macro expanded version of `expr`,"}, {"sha": "c10f3ce07749b49399d42924096023a49e844f27", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -536,7 +536,7 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n             // create issue to recommend refactoring here?\n             fld.extsbox.insert(intern(name.as_slice()), ext);\n             if attr::contains_name(it.attrs.as_slice(), \"macro_export\") {\n-                fld.cx.push_exported_macro(it.span);\n+                fld.cx.exported_macros.push(it);\n             }\n             SmallVector::zero()\n         }\n@@ -1039,7 +1039,7 @@ pub struct ExportedMacros {\n pub fn expand_crate(parse_sess: &parse::ParseSess,\n                     cfg: ExpansionConfig,\n                     // these are the macros being imported to this crate:\n-                    macros: Vec<ExportedMacros>,\n+                    imported_macros: Vec<ExportedMacros>,\n                     user_exts: Vec<NamedSyntaxExtension>,\n                     c: Crate) -> Crate {\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n@@ -1048,7 +1048,7 @@ pub fn expand_crate(parse_sess: &parse::ParseSess,\n         cx: &mut cx,\n     };\n \n-    for ExportedMacros { crate_name, macros } in macros.move_iter() {\n+    for ExportedMacros { crate_name, macros } in imported_macros.move_iter() {\n         let name = format!(\"<{} macros>\", token::get_ident(crate_name))\n             .into_string();\n "}, {"sha": "2e86d1c005d1cb416fbfe78b44cdac833821c48c", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -49,6 +49,9 @@ struct Context<'a, 'b> {\n     name_types: HashMap<String, ArgumentType>,\n     name_ordering: Vec<String>,\n \n+    /// The latest consecutive literal strings\n+    literal: Option<String>,\n+\n     /// Collection of the compiled `rt::Piece` structures\n     pieces: Vec<Gc<ast::Expr>>,\n     name_positions: HashMap<String, uint>,\n@@ -362,17 +365,29 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n+    /// Translate the accumulated string literals to a static `rt::Piece`\n+    fn trans_literal_string(&mut self) -> Option<Gc<ast::Expr>> {\n+        let sp = self.fmtsp;\n+        self.literal.take().map(|s| {\n+            let s = token::intern_and_get_ident(s.as_slice());\n+            self.ecx.expr_call_global(sp,\n+                                      self.rtpath(\"String\"),\n+                                      vec!(\n+                self.ecx.expr_str(sp, s)\n+            ))\n+        })\n+    }\n+\n     /// Translate a `parse::Piece` to a static `rt::Piece`\n-    fn trans_piece(&mut self, piece: &parse::Piece) -> Gc<ast::Expr> {\n+    fn trans_piece(&mut self, piece: &parse::Piece) -> Option<Gc<ast::Expr>> {\n         let sp = self.fmtsp;\n         match *piece {\n             parse::String(s) => {\n-                let s = token::intern_and_get_ident(s);\n-                self.ecx.expr_call_global(sp,\n-                                          self.rtpath(\"String\"),\n-                                          vec!(\n-                    self.ecx.expr_str(sp, s)\n-                ))\n+                match self.literal {\n+                    Some(ref mut sb) => sb.push_str(s),\n+                    ref mut empty => *empty = Some(String::from_str(s)),\n+                }\n+                None\n             }\n             parse::Argument(ref arg) => {\n                 // Translate the position\n@@ -430,7 +445,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let s = self.ecx.expr_struct(sp, path, vec!(\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt)));\n-                self.ecx.expr_call_global(sp, self.rtpath(\"Argument\"), vec!(s))\n+                Some(self.ecx.expr_call_global(sp, self.rtpath(\"Argument\"), vec!(s)))\n             }\n         }\n     }\n@@ -694,6 +709,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         name_ordering: name_ordering,\n         nest_level: 0,\n         next_arg: 0,\n+        literal: None,\n         pieces: Vec::new(),\n         method_statics: Vec::new(),\n         fmtsp: sp,\n@@ -712,8 +728,14 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n             Some(piece) => {\n                 if parser.errors.len() > 0 { break }\n                 cx.verify_piece(&piece);\n-                let piece = cx.trans_piece(&piece);\n-                cx.pieces.push(piece);\n+                match cx.trans_piece(&piece) {\n+                    Some(piece) => {\n+                        cx.trans_literal_string().map(|piece|\n+                                                      cx.pieces.push(piece));\n+                        cx.pieces.push(piece);\n+                    }\n+                    None => {}\n+                }\n             }\n             None => break\n         }\n@@ -727,6 +749,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         }\n         None => {}\n     }\n+    cx.trans_literal_string().map(|piece| cx.pieces.push(piece));\n \n     // Make sure that all arguments were used and all arguments have types.\n     for (i, ty) in cx.arg_types.iter().enumerate() {"}, {"sha": "271eee7d08a039db2a196b26630cef891698bb28", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -752,7 +752,7 @@ pub fn noop_fold_crate<T: Folder>(c: Crate, folder: &mut T) -> Crate {\n         attrs: c.attrs.iter().map(|x| folder.fold_attribute(*x)).collect(),\n         config: c.config.iter().map(|x| fold_meta_item_(*x, folder)).collect(),\n         span: folder.new_span(c.span),\n-        exported_macros: c.exported_macros.iter().map(|sp| folder.new_span(*sp)).collect(),\n+        exported_macros: c.exported_macros\n     }\n }\n "}, {"sha": "46e2ca03ef6ed5b6f71a7ab05153a608f8574411", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -842,7 +842,6 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> io::IoR\n #[test]\n fn should_sort_failures_before_printing_them() {\n     use std::io::MemWriter;\n-    use std::str;\n \n     let test_a = TestDesc {\n         name: StaticTestName(\"a\"),"}, {"sha": "0e29e6215032ae104c3531a8748424bae6c0b94b", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -520,7 +520,6 @@ mod test {\n     use super::{Uuid, VariantMicrosoft, VariantNCS, VariantRFC4122,\n                 Version1Mac, Version2Dce, Version3Md5, Version4Random,\n                 Version5Sha1};\n-    use std::str;\n     use std::io::MemWriter;\n     use std::rand;\n "}, {"sha": "ab85d02e84edeea59ac38505a62ec7d0536cc726", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -1 +1 @@\n-Subproject commit 1bba09755d95892bc826c558630e93803b0a4ee6\n+Subproject commit ab85d02e84edeea59ac38505a62ec7d0536cc726"}, {"sha": "348fb01b605efbc0fb72a323de0e8bcb30ccbfd8", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2014-06-20.2\n+2014-07-20"}, {"sha": "e34bfb10a719b9700da5595fd74d44bb5f82bbdb", "filename": "src/test/compile-fail/lint-dead-code-3.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -16,6 +16,11 @@\n \n extern crate libc;\n \n+pub use x = extern_foo;\n+extern {\n+    fn extern_foo();\n+}\n+\n struct Foo; //~ ERROR: code is never used\n impl Foo {\n     fn foo(&self) { //~ ERROR: code is never used"}, {"sha": "a2ae91abd131a170eda6d5f1a3eeabaa550fb0fe", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -11,7 +11,7 @@\n // aux-build:cci_class_cast.rs\n extern crate cci_class_cast;\n \n-use std::to_str::ToString;\n+use std::to_string::ToString;\n use cci_class_cast::kitty::cat;\n \n fn print_out(thing: Box<ToString>, expected: String) {"}, {"sha": "e51c94428dae3095979f0836c0d484d1d05be7d4", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df68c6f3c35354662b39128d56d5dcc6deadf591/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=df68c6f3c35354662b39128d56d5dcc6deadf591", "patch": "@@ -12,7 +12,7 @@ extern crate collections;\n \n use std::collections::{ Map, MutableMap};\n use std::str::{SendStr, Owned, Slice};\n-use std::to_str::ToString;\n+use std::to_string::ToString;\n use self::collections::TreeMap;\n use std::option::Some;\n "}]}