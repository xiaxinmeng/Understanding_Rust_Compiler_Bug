{"sha": "4173e971b8c06d00b5bf9fb0133220cb37cf99da", "node_id": "C_kwDOAAsO6NoAKDQxNzNlOTcxYjhjMDZkMDBiNWJmOWZiMDEzMzIyMGNiMzdjZjk5ZGE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-07T14:36:42Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-27T12:53:04Z"}, "message": "remove an ineffective check in const_prop", "tree": {"sha": "08b5566931ea0fa9d772754bce3a8013efed0a7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08b5566931ea0fa9d772754bce3a8013efed0a7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4173e971b8c06d00b5bf9fb0133220cb37cf99da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4173e971b8c06d00b5bf9fb0133220cb37cf99da", "html_url": "https://github.com/rust-lang/rust/commit/4173e971b8c06d00b5bf9fb0133220cb37cf99da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4173e971b8c06d00b5bf9fb0133220cb37cf99da/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4065b89b1e7287047d7d6c65e7abd7b8ee70bcf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4065b89b1e7287047d7d6c65e7abd7b8ee70bcf0", "html_url": "https://github.com/rust-lang/rust/commit/4065b89b1e7287047d7d6c65e7abd7b8ee70bcf0"}], "stats": {"total": 86, "additions": 60, "deletions": 26}, "files": [{"sha": "d56323448cea19326c2746da29b52385afed217d", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4173e971b8c06d00b5bf9fb0133220cb37cf99da/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4173e971b8c06d00b5bf9fb0133220cb37cf99da/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=4173e971b8c06d00b5bf9fb0133220cb37cf99da", "patch": "@@ -642,7 +642,7 @@ where\n         // avoid force_allocation.\n         let src = match self.read_immediate_raw(src)? {\n             Ok(src_val) => {\n-                assert!(!src.layout.is_unsized(), \"cannot have unsized immediates\");\n+                assert!(!src.layout.is_unsized(), \"cannot copy unsized immediates\");\n                 assert!(\n                     !dest.layout.is_unsized(),\n                     \"the src is sized, so the dest must also be sized\""}, {"sha": "16ce5bc71750a868d845528f8ff068a0a3165495", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4173e971b8c06d00b5bf9fb0133220cb37cf99da/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4173e971b8c06d00b5bf9fb0133220cb37cf99da/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=4173e971b8c06d00b5bf9fb0133220cb37cf99da", "patch": "@@ -100,6 +100,8 @@ where\n         // This makes several assumptions about what layouts we will encounter; we match what\n         // codegen does as good as we can (see `extract_field` in `rustc_codegen_ssa/src/mir/operand.rs`).\n         let field_val: Immediate<_> = match (*base, base.layout.abi) {\n+            // if the entire value is uninit, then so is the field (can happen in ConstProp)\n+            (Immediate::Uninit, _) => Immediate::Uninit,\n             // the field contains no information, can be left uninit\n             _ if field_layout.is_zst() => Immediate::Uninit,\n             // the field covers the entire type\n@@ -124,6 +126,7 @@ where\n                     b_val\n                 })\n             }\n+            // everything else is a bug\n             _ => span_bug!(\n                 self.cur_span(),\n                 \"invalid field access on immediate {}, layout {:#?}\","}, {"sha": "c986aee9e034ff74663c7b83567b9e6251405f76", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4173e971b8c06d00b5bf9fb0133220cb37cf99da/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4173e971b8c06d00b5bf9fb0133220cb37cf99da/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=4173e971b8c06d00b5bf9fb0133220cb37cf99da", "patch": "@@ -248,16 +248,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         local: Local,\n     ) -> InterpResult<'tcx, &'a interpret::Operand<Self::Provenance>> {\n         let l = &frame.locals[local];\n-\n-        if matches!(\n-            l.value,\n-            LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit))\n-        ) {\n-            // For us \"uninit\" means \"we don't know its value, might be initiailized or not\".\n-            // So stop here.\n-            throw_machine_stop_str!(\"tried to access alocal with unknown value \")\n-        }\n-\n+        // Applying restrictions here is meaningless since they can be circumvented via `force_allocation`.\n         l.access()\n     }\n \n@@ -431,7 +422,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n     fn get_const(&self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n         let op = match self.ecx.eval_place_to_op(place, None) {\n-            Ok(op) => op,\n+            Ok(op) => {\n+                if matches!(*op, interpret::Operand::Immediate(Immediate::Uninit)) {\n+                    // Make sure nobody accidentally uses this value.\n+                    return None;\n+                }\n+                op\n+            }\n             Err(e) => {\n                 trace!(\"get_const failed: {}\", e);\n                 return None;\n@@ -643,6 +640,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         if rvalue.needs_subst() {\n             return None;\n         }\n+        if !rvalue\n+            .ty(&self.ecx.frame().body.local_decls, *self.ecx.tcx)\n+            .is_sized(self.ecx.tcx, self.param_env)\n+        {\n+            // the interpreter doesn't support unsized locals (only unsized arguments),\n+            // but rustc does (in a kinda broken way), so we have to skip them here\n+            return None;\n+        }\n \n         if self.tcx.sess.mir_opt_level() >= 4 {\n             self.eval_rvalue_with_identities(rvalue, place)\n@@ -660,18 +665,20 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         self.use_ecx(|this| match rvalue {\n             Rvalue::BinaryOp(op, box (left, right))\n             | Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n-                let l = this.ecx.eval_operand(left, None);\n-                let r = this.ecx.eval_operand(right, None);\n+                let l = this.ecx.eval_operand(left, None).and_then(|x| this.ecx.read_immediate(&x));\n+                let r =\n+                    this.ecx.eval_operand(right, None).and_then(|x| this.ecx.read_immediate(&x));\n \n                 let const_arg = match (l, r) {\n-                    (Ok(ref x), Err(_)) | (Err(_), Ok(ref x)) => this.ecx.read_immediate(x)?,\n-                    (Err(e), Err(_)) => return Err(e),\n-                    (Ok(_), Ok(_)) => return this.ecx.eval_rvalue_into_place(rvalue, place),\n+                    (Ok(x), Err(_)) | (Err(_), Ok(x)) => x, // exactly one side is known\n+                    (Err(e), Err(_)) => return Err(e),      // neither side is known\n+                    (Ok(_), Ok(_)) => return this.ecx.eval_rvalue_into_place(rvalue, place), // both sides are known\n                 };\n \n                 if !matches!(const_arg.layout.abi, abi::Abi::Scalar(..)) {\n                     // We cannot handle Scalar Pair stuff.\n-                    return this.ecx.eval_rvalue_into_place(rvalue, place);\n+                    // No point in calling `eval_rvalue_into_place`, since only one side is known\n+                    throw_machine_stop_str!(\"cannot optimize this\")\n                 }\n \n                 let arg_value = const_arg.to_scalar().to_bits(const_arg.layout.size)?;\n@@ -696,7 +703,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             this.ecx.write_immediate(*const_arg, &dest)\n                         }\n                     }\n-                    _ => this.ecx.eval_rvalue_into_place(rvalue, place),\n+                    _ => throw_machine_stop_str!(\"cannot optimize this\"),\n                 }\n             }\n             _ => this.ecx.eval_rvalue_into_place(rvalue, place),\n@@ -1073,7 +1080,11 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                 if let Some(ref value) = self.eval_operand(&cond) {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n                     let expected = Scalar::from_bool(*expected);\n-                    let value_const = self.ecx.read_scalar(&value).unwrap();\n+                    let Ok(value_const) = self.ecx.read_scalar(&value) else {\n+                        // FIXME should be used use_ecx rather than a local match... but we have\n+                        // quite a few of these read_scalar/read_immediate that need fixing.\n+                        return\n+                    };\n                     if expected != value_const {\n                         // Poison all places this operand references so that further code\n                         // doesn't use the invalid value"}, {"sha": "ed4399d19ecf868c8c6482b1ca0f0ed4b93a144d", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4173e971b8c06d00b5bf9fb0133220cb37cf99da/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4173e971b8c06d00b5bf9fb0133220cb37cf99da/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=4173e971b8c06d00b5bf9fb0133220cb37cf99da", "patch": "@@ -6,6 +6,7 @@ use crate::const_prop::ConstPropMachine;\n use crate::const_prop::ConstPropMode;\n use crate::MirLint;\n use rustc_const_eval::const_eval::ConstEvalErr;\n+use rustc_const_eval::interpret::Immediate;\n use rustc_const_eval::interpret::{\n     self, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, Scalar, StackPopCleanup,\n };\n@@ -229,7 +230,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n     fn get_const(&self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n         let op = match self.ecx.eval_place_to_op(place, None) {\n-            Ok(op) => op,\n+            Ok(op) => {\n+                if matches!(*op, interpret::Operand::Immediate(Immediate::Uninit)) {\n+                    // Make sure nobody accidentally uses this value.\n+                    return None;\n+                }\n+                op\n+            }\n             Err(e) => {\n                 trace!(\"get_const failed: {}\", e);\n                 return None;\n@@ -515,6 +522,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         if rvalue.needs_subst() {\n             return None;\n         }\n+        if !rvalue\n+            .ty(&self.ecx.frame().body.local_decls, *self.ecx.tcx)\n+            .is_sized(self.ecx.tcx, self.param_env)\n+        {\n+            // the interpreter doesn't support unsized locals (only unsized arguments),\n+            // but rustc does (in a kinda broken way), so we have to skip them here\n+            return None;\n+        }\n \n         self.use_ecx(source_info, |this| this.ecx.eval_rvalue_into_place(rvalue, place))\n     }\n@@ -624,7 +639,11 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                 if let Some(ref value) = self.eval_operand(&cond, source_info) {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n                     let expected = Scalar::from_bool(*expected);\n-                    let value_const = self.ecx.read_scalar(&value).unwrap();\n+                    let Ok(value_const) = self.ecx.read_scalar(&value) else {\n+                        // FIXME should be used use_ecx rather than a local match... but we have\n+                        // quite a few of these read_scalar/read_immediate that need fixing.\n+                        return\n+                    };\n                     if expected != value_const {\n                         enum DbgVal<T> {\n                             Val(T),\n@@ -641,9 +660,9 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                         let mut eval_to_int = |op| {\n                             // This can be `None` if the lhs wasn't const propagated and we just\n                             // triggered the assert on the value of the rhs.\n-                            self.eval_operand(op, source_info).map_or(DbgVal::Underscore, |op| {\n-                                DbgVal::Val(self.ecx.read_immediate(&op).unwrap().to_const_int())\n-                            })\n+                            self.eval_operand(op, source_info)\n+                                .and_then(|op| self.ecx.read_immediate(&op).ok())\n+                                .map_or(DbgVal::Underscore, |op| DbgVal::Val(op.to_const_int()))\n                         };\n                         let msg = match msg {\n                             AssertKind::DivisionByZero(op) => {"}, {"sha": "186a953735675ec67382585fca5dc3510245b973", "filename": "src/test/mir-opt/const_prop/mutable_variable_unprop_assign.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4173e971b8c06d00b5bf9fb0133220cb37cf99da/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/4173e971b8c06d00b5bf9fb0133220cb37cf99da/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.main.ConstProp.diff?ref=4173e971b8c06d00b5bf9fb0133220cb37cf99da", "patch": "@@ -41,7 +41,8 @@\n           StorageLive(_4);                 // scope 2 at $DIR/mutable_variable_unprop_assign.rs:+4:9: +4:10\n           _4 = (_2.1: i32);                // scope 2 at $DIR/mutable_variable_unprop_assign.rs:+4:13: +4:16\n           StorageLive(_5);                 // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:9: +5:10\n-          _5 = (_2.0: i32);                // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:13: +5:16\n+-         _5 = (_2.0: i32);                // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:13: +5:16\n++         _5 = const 1_i32;                // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:13: +5:16\n           nop;                             // scope 0 at $DIR/mutable_variable_unprop_assign.rs:+0:11: +6:2\n           StorageDead(_5);                 // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+6:1: +6:2\n           StorageDead(_4);                 // scope 2 at $DIR/mutable_variable_unprop_assign.rs:+6:1: +6:2"}]}