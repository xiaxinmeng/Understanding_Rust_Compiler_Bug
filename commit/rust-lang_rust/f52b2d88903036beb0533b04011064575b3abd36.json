{"sha": "f52b2d88903036beb0533b04011064575b3abd36", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MmIyZDg4OTAzMDM2YmViMDUzM2IwNDAxMTA2NDU3NWIzYWJkMzY=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-07-05T11:16:25Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-06T10:19:31Z"}, "message": "Avoid cycle in nested obligations for object candidate\n\nBounds of the form `type Future: Future<Result=Self::Result>` exist in\nsome ecosystem crates. To validate these bounds for trait objects we\nneed to normalize `Self::Result` in a way that doesn't cause a cycle.", "tree": {"sha": "492c032bb0cbb8b725d7b514488373b5b54030f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/492c032bb0cbb8b725d7b514488373b5b54030f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f52b2d88903036beb0533b04011064575b3abd36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f52b2d88903036beb0533b04011064575b3abd36", "html_url": "https://github.com/rust-lang/rust/commit/f52b2d88903036beb0533b04011064575b3abd36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f52b2d88903036beb0533b04011064575b3abd36/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "582ccec1c577eedf6394078e93366714273f922b", "url": "https://api.github.com/repos/rust-lang/rust/commits/582ccec1c577eedf6394078e93366714273f922b", "html_url": "https://github.com/rust-lang/rust/commit/582ccec1c577eedf6394078e93366714273f922b"}], "stats": {"total": 434, "additions": 382, "deletions": 52}, "files": [{"sha": "09895605dca86936b8b3f1595846fec4d298fbf7", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f52b2d88903036beb0533b04011064575b3abd36/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f52b2d88903036beb0533b04011064575b3abd36/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=f52b2d88903036beb0533b04011064575b3abd36", "patch": "@@ -1513,6 +1513,7 @@ impl<'tcx> ExistentialProjection<'tcx> {\n     /// then this function would return a `exists T. T: Iterator` existential trait\n     /// reference.\n     pub fn trait_ref(&self, tcx: TyCtxt<'_>) -> ty::ExistentialTraitRef<'tcx> {\n+        // FIXME(generic_associated_types): truncate substs to have the right length.\n         let def_id = tcx.associated_item(self.item_def_id).container.id();\n         ty::ExistentialTraitRef { def_id, substs: self.substs }\n     }"}, {"sha": "59399133dff8a36671cbafccd709c4e0fe72a36e", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 175, "deletions": 52, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/f52b2d88903036beb0533b04011064575b3abd36/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f52b2d88903036beb0533b04011064575b3abd36/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=f52b2d88903036beb0533b04011064575b3abd36", "patch": "@@ -9,13 +9,15 @@\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::GrowableBitSet;\n+use rustc_infer::infer::LateBoundRegionConversionTime::HigherRankedType;\n use rustc_infer::infer::{self, InferOk};\n+use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_middle::ty::{ToPolyTraitRef, ToPredicate, WithConstness};\n use rustc_span::def_id::DefId;\n \n-use crate::traits::project::{self, normalize_with_depth};\n+use crate::traits::project::{normalize_with_depth, normalize_with_depth_to};\n use crate::traits::select::TraitObligationExt;\n use crate::traits::util;\n use crate::traits::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n@@ -340,16 +342,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> ImplSourceObjectData<'tcx, PredicateObligation<'tcx>> {\n+        let tcx = self.tcx();\n         debug!(\"confirm_object_candidate({:?})\", obligation);\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n-        let self_ty = self.infcx.replace_bound_vars_with_placeholders(&self_ty);\n+        let trait_predicate =\n+            self.infcx.replace_bound_vars_with_placeholders(&obligation.predicate);\n+        let self_ty = self.infcx.shallow_resolve(trait_predicate.self_ty());\n+        let obligation_trait_ref = ty::Binder::dummy(trait_predicate.trait_ref);\n         let data = match self_ty.kind() {\n-            ty::Dynamic(data, ..) => data,\n+            ty::Dynamic(data, ..) => {\n+                self.infcx\n+                    .replace_bound_vars_with_fresh_vars(\n+                        obligation.cause.span,\n+                        HigherRankedType,\n+                        data,\n+                    )\n+                    .0\n+            }\n             _ => span_bug!(obligation.cause.span, \"object candidate with non-object\"),\n         };\n \n-        let poly_trait_ref = data\n+        let object_trait_ref = data\n             .principal()\n             .unwrap_or_else(|| {\n                 span_bug!(obligation.cause.span, \"object candidate with no principal\")\n@@ -361,24 +374,29 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let vtable_base;\n \n         {\n-            let tcx = self.tcx();\n-\n             // We want to find the first supertrait in the list of\n             // supertraits that we can unify with, and do that\n             // unification. We know that there is exactly one in the list\n             // where we can unify, because otherwise select would have\n             // reported an ambiguity. (When we do find a match, also\n             // record it for later.)\n-            let nonmatching = util::supertraits(tcx, poly_trait_ref).take_while(|&t| {\n-                match self.infcx.commit_if_ok(|_| self.match_poly_trait_ref(obligation, t)) {\n-                    Ok(obligations) => {\n-                        upcast_trait_ref = Some(t);\n-                        nested.extend(obligations);\n-                        false\n+            let nonmatching = util::supertraits(tcx, ty::Binder::dummy(object_trait_ref))\n+                .take_while(|&t| {\n+                    match self.infcx.commit_if_ok(|_| {\n+                        self.infcx\n+                            .at(&obligation.cause, obligation.param_env)\n+                            .sup(obligation_trait_ref, t)\n+                            .map(|InferOk { obligations, .. }| obligations)\n+                            .map_err(|_| ())\n+                    }) {\n+                        Ok(obligations) => {\n+                            upcast_trait_ref = Some(t);\n+                            nested.extend(obligations);\n+                            false\n+                        }\n+                        Err(_) => true,\n                     }\n-                    Err(_) => true,\n-                }\n-            });\n+                });\n \n             // Additionally, for each of the non-matching predicates that\n             // we pass over, we sum up the set of number of vtable\n@@ -387,47 +405,105 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             vtable_base = nonmatching.map(|t| super::util::count_own_vtable_entries(tcx, t)).sum();\n         }\n \n-        for bound in data.skip_binder() {\n-            match bound {\n-                ty::ExistentialPredicate::Projection(projection) => {\n-                    // This maybe belongs in wf, but that can't (doesn't) handle\n-                    // higher-ranked things.\n-                    // Prevent, e.g., `dyn Iterator<Item = str>`.\n-                    // FIXME(generic_associated_types): We need some way to\n-                    // ensure that for `dyn for<'a> X<Item<'a> = &'a ()>` the\n-                    // bound holds for all `'a`.\n-                    let (infer_projection, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n+        // Check supertraits hold\n+        nested.extend(util::supertraits(tcx, obligation_trait_ref).skip(1).map(|super_trait| {\n+            Obligation::new(\n+                obligation.cause.clone(),\n+                obligation.param_env,\n+                super_trait.without_const().to_predicate(tcx),\n+            )\n+        }));\n+\n+        let upcast_trait_ref = upcast_trait_ref.unwrap();\n+\n+        let assoc_types: Vec<_> = tcx\n+            .associated_items(upcast_trait_ref.def_id())\n+            .in_definition_order()\n+            .filter_map(\n+                |item| if item.kind == ty::AssocKind::Type { Some(item.def_id) } else { None },\n+            )\n+            .collect();\n+\n+        if !assoc_types.is_empty() {\n+            let predicates: Vec<_> =\n+                data.iter()\n+                    .filter_map(|pred| match pred {\n+                        ty::ExistentialPredicate::Projection(proj) => {\n+                            if assoc_types.contains(&proj.item_def_id) {\n+                                match self.infcx.commit_if_ok(|_| {\n+                                    self.infcx\n+                                        .at(&obligation.cause, obligation.param_env)\n+                                        .sup(\n+                                            ty::Binder::dummy(\n+                                                proj.trait_ref(tcx).with_self_ty(tcx, self_ty),\n+                                            ),\n+                                            upcast_trait_ref,\n+                                        )\n+                                        .map(|InferOk { obligations, .. }| obligations)\n+                                        .map_err(|_| ())\n+                                }) {\n+                                    Ok(obligations) => {\n+                                        nested.extend(obligations);\n+                                        Some(proj)\n+                                    }\n+                                    Err(_) => None,\n+                                }\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                        ty::ExistentialPredicate::AutoTrait(_)\n+                        | ty::ExistentialPredicate::Trait(_) => None,\n+                    })\n+                    .collect();\n+\n+            let upcast_trait_ref = upcast_trait_ref\n+                .no_bound_vars()\n+                .expect(\"sup shouldn't return binder with bound vars\");\n+            let mut normalizer = ObjectAssociatedTypeNormalizer {\n+                infcx: self.infcx,\n+                object_ty: self_ty,\n+                object_bounds: &predicates,\n+                param_env: obligation.param_env,\n+                cause: &obligation.cause,\n+                nested: &mut nested,\n+            };\n+            for assoc_type in assoc_types {\n+                if !tcx.generics_of(assoc_type).params.is_empty() {\n+                    // FIXME(generic_associated_types) generate placeholders to\n+                    // extend the trait substs.\n+                    tcx.sess.span_fatal(\n                         obligation.cause.span,\n-                        infer::HigherRankedType,\n-                        &ty::Binder::bind(projection),\n+                        \"generic associated types in trait objects are not supported yet\",\n                     );\n-                    let substs: Vec<_> =\n-                        iter::once(self_ty.into()).chain(infer_projection.substs).collect();\n-                    let bounds =\n-                        self.tcx().item_bounds(projection.item_def_id).iter().map(|bound| {\n-                            // In the example above, `bound` is `<Self as Iterator>::Item: Sized`\n-                            // `subst_bound` is `str: Sized`.\n-                            let subst_bound = util::subst_assoc_item_bound(\n-                                self.tcx(),\n-                                bound,\n-                                infer_projection.ty,\n-                                &substs,\n-                            );\n-                            Obligation::new(\n-                                obligation.cause.clone(),\n-                                obligation.param_env.clone(),\n-                                subst_bound,\n-                            )\n-                        });\n-                    debug!(\"confirm_object_candidate: adding bounds: {:?}\", bounds);\n-                    nested.extend(bounds);\n                 }\n-                ty::ExistentialPredicate::Trait(_) | ty::ExistentialPredicate::AutoTrait(_) => {}\n+                // This maybe belongs in wf, but that can't (doesn't) handle\n+                // higher-ranked things.\n+                // Prevent, e.g., `dyn Iterator<Item = str>`.\n+                for bound in self.tcx().item_bounds(assoc_type) {\n+                    let subst_bound = bound.subst(tcx, upcast_trait_ref.substs);\n+                    // Normalize projections the trait object manually to\n+                    // avoid evaluation overflow.\n+                    let object_normalized = subst_bound.fold_with(&mut normalizer);\n+                    let normalized_bound = normalize_with_depth_to(\n+                        self,\n+                        obligation.param_env,\n+                        obligation.cause.clone(),\n+                        obligation.recursion_depth + 1,\n+                        &object_normalized,\n+                        normalizer.nested,\n+                    );\n+                    normalizer.nested.push(Obligation::new(\n+                        obligation.cause.clone(),\n+                        obligation.param_env.clone(),\n+                        normalized_bound,\n+                    ));\n+                }\n             }\n         }\n \n         debug!(\"confirm_object_candidate: nested: {:?}\", nested);\n-        ImplSourceObjectData { upcast_trait_ref: upcast_trait_ref.unwrap(), vtable_base, nested }\n+        ImplSourceObjectData { upcast_trait_ref, vtable_base, nested }\n     }\n \n     fn confirm_fn_pointer_candidate(\n@@ -450,7 +526,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         .map_bound(|(trait_ref, _)| trait_ref);\n \n         let Normalized { value: trait_ref, mut obligations } = ensure_sufficient_stack(|| {\n-            project::normalize_with_depth(\n+            normalize_with_depth(\n                 self,\n                 obligation.param_env,\n                 obligation.cause.clone(),\n@@ -867,3 +943,50 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(ImplSourceBuiltinData { nested })\n     }\n }\n+\n+struct ObjectAssociatedTypeNormalizer<'a, 'tcx> {\n+    infcx: &'a infer::InferCtxt<'a, 'tcx>,\n+    object_ty: Ty<'tcx>,\n+    object_bounds: &'a [ty::ExistentialProjection<'tcx>],\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: &'a ObligationCause<'tcx>,\n+    nested: &'a mut Vec<PredicateObligation<'tcx>>,\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for ObjectAssociatedTypeNormalizer<'_, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        if !t.has_projections() {\n+            return t;\n+        }\n+        if let ty::Projection(proj) = t.kind {\n+            if let ty::Dynamic(..) = proj.self_ty().kind {\n+                for bound in self.object_bounds {\n+                    if proj.item_def_id == bound.item_def_id {\n+                        // FIXME(generic_associated_types): This isn't relating\n+                        // the substs for the associated type.\n+                        match self.infcx.commit_if_ok(|_| {\n+                            self.infcx.at(self.cause, self.param_env).sub(\n+                                bound\n+                                    .with_self_ty(self.infcx.tcx, self.object_ty)\n+                                    .projection_ty\n+                                    .trait_ref(self.infcx.tcx),\n+                                proj.trait_ref(self.infcx.tcx),\n+                            )\n+                        }) {\n+                            Ok(InferOk { value: (), obligations }) => {\n+                                self.nested.extend(obligations);\n+                                return bound.ty;\n+                            }\n+                            Err(_) => {}\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        t.super_fold_with(self)\n+    }\n+}"}, {"sha": "323508db2f2b10788906a1dc8c9fc64855fc4b7d", "filename": "src/test/ui/traits/check-trait-object-bounds-4.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-4.rs?ref=f52b2d88903036beb0533b04011064575b3abd36", "patch": "@@ -0,0 +1,17 @@\n+// Check that we validate associated type bounds on super traits for trait\n+// objects\n+\n+trait Super {\n+    type Y: Clone;\n+}\n+\n+trait X: Super {}\n+\n+fn f<T: X + ?Sized>() {\n+    None::<T::Y>.clone();\n+}\n+\n+fn main() {\n+    f::<dyn X<Y = str>>();\n+    //~^ ERROR the trait bound `str: std::clone::Clone` is not satisfied\n+}"}, {"sha": "75d6862579d11aa4d5b6c36ff147cca0b3019fce", "filename": "src/test/ui/traits/check-trait-object-bounds-4.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-4.stderr?ref=f52b2d88903036beb0533b04011064575b3abd36", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `str: std::clone::Clone` is not satisfied\n+  --> $DIR/check-trait-object-bounds-4.rs:15:5\n+   |\n+LL | fn f<T: X + ?Sized>() {\n+   |         - required by this bound in `f`\n+...\n+LL |     f::<dyn X<Y = str>>();\n+   |     ^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` is not implemented for `str`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "7d733ad26b7528a45d1d98e8d7fc45eb5bcb0f91", "filename": "src/test/ui/traits/check-trait-object-bounds-5.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-5.rs?ref=f52b2d88903036beb0533b04011064575b3abd36", "patch": "@@ -0,0 +1,27 @@\n+// Check that we validate associated type bounds on super traits for trait\n+// objects\n+\n+trait Is {\n+    type T;\n+}\n+\n+impl<U> Is for U {\n+    type T = U;\n+}\n+\n+trait Super {\n+    type V;\n+}\n+\n+trait Obj: Super {\n+    type U: Is<T = Self::V>;\n+}\n+\n+fn is_obj<T: ?Sized + Obj>(_: &T) {}\n+\n+fn f(x: &dyn Obj<U = i32, V = i64>) {\n+    is_obj(x)\n+    //~^ type mismatch resolving `<i32 as Is>::T == i64`\n+}\n+\n+fn main() {}"}, {"sha": "bd2b789cd990896d29c3776659d051bd48f5bf89", "filename": "src/test/ui/traits/check-trait-object-bounds-5.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-5.stderr?ref=f52b2d88903036beb0533b04011064575b3abd36", "patch": "@@ -0,0 +1,12 @@\n+error[E0271]: type mismatch resolving `<i32 as Is>::T == i64`\n+  --> $DIR/check-trait-object-bounds-5.rs:23:5\n+   |\n+LL | fn is_obj<T: ?Sized + Obj>(_: &T) {}\n+   |                       --- required by this bound in `is_obj`\n+...\n+LL |     is_obj(x)\n+   |     ^^^^^^ expected `i64`, found `i32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "cb196d67f673d5467f5d3c3dccb76d9fbfd6d0f3", "filename": "src/test/ui/traits/check-trait-object-bounds-6.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-6.rs?ref=f52b2d88903036beb0533b04011064575b3abd36", "patch": "@@ -0,0 +1,24 @@\n+// Check that we validate associated type bounds on super traits for trait\n+// objects\n+\n+trait Is {\n+    type T;\n+}\n+\n+impl<U> Is for U {\n+    type T = U;\n+}\n+\n+trait Obj {\n+    type U: Is<T = Self::V>;\n+    type V;\n+}\n+\n+fn is_obj<T: ?Sized + Obj>(_: &T) {}\n+\n+fn f(x: &dyn Obj<U = i32, V = i64>) {\n+    is_obj(x)\n+    //~^ ERROR type mismatch resolving `<i32 as Is>::T == i64`\n+}\n+\n+fn main() {}"}, {"sha": "ea1fdaf46f6ae602dc9be10ea72853b78595d68f", "filename": "src/test/ui/traits/check-trait-object-bounds-6.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-6.stderr?ref=f52b2d88903036beb0533b04011064575b3abd36", "patch": "@@ -0,0 +1,12 @@\n+error[E0271]: type mismatch resolving `<i32 as Is>::T == i64`\n+  --> $DIR/check-trait-object-bounds-6.rs:20:5\n+   |\n+LL | fn is_obj<T: ?Sized + Obj>(_: &T) {}\n+   |                       --- required by this bound in `is_obj`\n+...\n+LL |     is_obj(x)\n+   |     ^^^^^^ expected `i64`, found `i32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "3146764927cd815393eee1cb41dc4ceb96782fce", "filename": "src/test/ui/traits/trait-object-bounds-cycle-1.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-1.rs?ref=f52b2d88903036beb0533b04011064575b3abd36", "patch": "@@ -0,0 +1,24 @@\n+// Check that we don't have a cycle when we try to normalize `Self::U` in the\n+// bound below.\n+\n+// check-pass\n+\n+trait Is {\n+    type T;\n+}\n+\n+impl<U> Is for U {\n+    type T = U;\n+}\n+\n+trait Obj {\n+    type U: Is<T = Self::U>;\n+}\n+\n+fn is_obj<T: ?Sized + Obj>(_: &T) {}\n+\n+fn f(x: &dyn Obj<U = i32>) {\n+    is_obj(x)\n+}\n+\n+fn main() {}"}, {"sha": "4c1df38058dad702019acfcd1f4f34cdce0782e2", "filename": "src/test/ui/traits/trait-object-bounds-cycle-2.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-2.rs?ref=f52b2d88903036beb0533b04011064575b3abd36", "patch": "@@ -0,0 +1,28 @@\n+// Check that we don't have a cycle when we try to normalize `Self::V` in the\n+// bound below.\n+\n+// check-pass\n+\n+trait Is {\n+    type T;\n+}\n+\n+impl<U> Is for U {\n+    type T = U;\n+}\n+\n+trait Super {\n+    type V;\n+}\n+\n+trait Obj: Super {\n+    type U: Is<T = Self::V>;\n+}\n+\n+fn is_obj<T: ?Sized + Obj>(_: &T) {}\n+\n+fn f(x: &dyn Obj<U = i32, V = i32>) {\n+    is_obj(x)\n+}\n+\n+fn main() {}"}, {"sha": "55726a5ae4557d21e6cd5cef7c1e5c0055d2f708", "filename": "src/test/ui/traits/trait-object-bounds-cycle-3.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-3.rs?ref=f52b2d88903036beb0533b04011064575b3abd36", "patch": "@@ -0,0 +1,25 @@\n+// Check that we don't have a cycle when we try to normalize `Self::V` in the\n+// bound below.\n+\n+// check-pass\n+\n+trait Is {\n+    type T;\n+}\n+\n+impl<U> Is for U {\n+    type T = U;\n+}\n+\n+trait Obj {\n+    type U: Is<T = Self::V>;\n+    type V;\n+}\n+\n+fn is_obj<T: ?Sized + Obj>(_: &T) {}\n+\n+fn f(x: &dyn Obj<U = i32, V = i32>) {\n+    is_obj(x)\n+}\n+\n+fn main() {}"}, {"sha": "f83cb75c7f29b8d46b244c177c9ab97f4447859f", "filename": "src/test/ui/traits/trait-object-bounds-cycle-4.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f52b2d88903036beb0533b04011064575b3abd36/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-4.rs?ref=f52b2d88903036beb0533b04011064575b3abd36", "patch": "@@ -0,0 +1,25 @@\n+// Check that we don't have a cycle when we try to normalize `Self::U` in the\n+// bound below. Make sure that having a lifetime on the trait object doesn't break things\n+\n+// check-pass\n+\n+trait Is {\n+    type T;\n+}\n+\n+impl<U> Is for U {\n+    type T = U;\n+}\n+\n+trait Obj<'a> {\n+    type U: Is<T = Self::V>;\n+    type V;\n+}\n+\n+fn is_obj<'a, T: ?Sized + Obj<'a>>(_: &T) {}\n+\n+fn f<'a>(x: &dyn Obj<'a, U = i32, V = i32>) {\n+    is_obj(x)\n+}\n+\n+fn main() {}"}]}