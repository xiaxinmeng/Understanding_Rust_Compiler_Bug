{"sha": "da3f196a4e342221aa9852699546892f8cbd3497", "node_id": "C_kwDOAAsO6NoAKGRhM2YxOTZhNGUzNDIyMjFhYTk4NTI2OTk1NDY4OTJmOGNiZDM0OTc", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-12-24T17:38:29Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-12-24T17:38:29Z"}, "message": "Remove special-cased stable hashing for HIR module\n\nAll other 'containers' (e.g. `impl` blocks) hashed their contents\nin the normal, order-dependent way. However, `Mod` was hashing\nits contents in a (sort-of) order-independent way. However, the\nexact order is exposed to consumers through `Mod.item_ids`,\nand through query results like `hir_module_items`. Therefore,\nstable hashing needs to take the order of items into account,\nto avoid fingerprint ICEs.\n\nUnforuntately, I was unable to directly build a reproducer\nfor the ICE, due to the behavior of `Fingerprint::combine_commutative`.\nThis operation swaps the upper and lower `u64` when constructing the\nresult, which makes the function non-associative. Since we start\nthe hashing of module items by combining `Fingerprint::ZERO` with\nthe first item, it's difficult to actually build an example where\nchanging the order of module items leaves the final hash unchanged.\n\nHowever, this appears to have been hit in practice in #92218\nWhile we're not able to reproduce it, the fact that proc-macros\nare involved (which can give an entire module the same span, preventing\nany span-related invalidations) makes me confident that the root\ncause of that issue is our method of hashing module items.\n\nThis PR removes all of the special handling for `Mod`, instead deriving\na `HashStable` implementation. This makes `Mod` consistent with other\n'contains' like `Impl`, which hash their contents through the typical\nderive of `HashStable`.", "tree": {"sha": "30a48e17f2122e044ba251655034c8a3133b3b54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30a48e17f2122e044ba251655034c8a3133b3b54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da3f196a4e342221aa9852699546892f8cbd3497", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmHGB1MACgkQtAh+UQ6Y\nsWSEnQ/+IDlGRy3VwAndn35gdFWCPh0x8JPaLQ7R0L5HrIGdXknHv1z9YjcsBRxI\nEB5ohLxUNE8E45ZbUm3WzSHrXXRffdv3bNb/w8gppiZHVQgLw79rLaVbZPM4Pfj7\nhAZaThJx7Vgo3lD6MiyU9dVyFm9K5eeVMD0bZdpzIkXV5aPD7o09fmhuQ69s5WBm\nXC3l3UgLKHPv+euof/f93pkB1Q6NWedslvH5F3KJKQFh/Ie6ewwEsN/0McXWnZ6d\nnAFkWq3ggZwlGEtxc7I72XbyzNpduY13nI/H/J6wS0cZyIz896qa68g1KDBbpz+s\n5YQBwqzXZiDAG+9Gzb7ew3uTN75KDGs7W55Ioh4nhfRDuKUkiJSAjfH6ORJJDJP3\nVAisIGN4KF37LlRW5K6WCtSyExN/mg70f/TSRp8dTHmFgBrLuuTKqdTlSUVmWwuu\n3FRZEQ8SFrI+bHe7vhmqgARtRbDVqY6NFwJCHwb+LlEpScN2082zL6qDBw0PeK30\nZ4arALMb2RLlYyAWSg+6URrLf5IySXIIa8YSi4kpuImi2uEkaj2g23aM0LZOQfMe\nFEusJh7kkB829/1mTWvXGg3m2Y419bpOVtDzddgnHss7AkLgWsBzmgS6sG80aelt\nBrjlz4QhHaH5DIjKjPgS0RaN383klpaoQV6MA+M2ljJEkLi4K90=\n=F3Hq\n-----END PGP SIGNATURE-----", "payload": "tree 30a48e17f2122e044ba251655034c8a3133b3b54\nparent 489296d82561f596c278e90edc10eb56168ab623\nauthor Aaron Hill <aa1ronham@gmail.com> 1640367509 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1640367509 -0500\n\nRemove special-cased stable hashing for HIR module\n\nAll other 'containers' (e.g. `impl` blocks) hashed their contents\nin the normal, order-dependent way. However, `Mod` was hashing\nits contents in a (sort-of) order-independent way. However, the\nexact order is exposed to consumers through `Mod.item_ids`,\nand through query results like `hir_module_items`. Therefore,\nstable hashing needs to take the order of items into account,\nto avoid fingerprint ICEs.\n\nUnforuntately, I was unable to directly build a reproducer\nfor the ICE, due to the behavior of `Fingerprint::combine_commutative`.\nThis operation swaps the upper and lower `u64` when constructing the\nresult, which makes the function non-associative. Since we start\nthe hashing of module items by combining `Fingerprint::ZERO` with\nthe first item, it's difficult to actually build an example where\nchanging the order of module items leaves the final hash unchanged.\n\nHowever, this appears to have been hit in practice in #92218\nWhile we're not able to reproduce it, the fact that proc-macros\nare involved (which can give an entire module the same span, preventing\nany span-related invalidations) makes me confident that the root\ncause of that issue is our method of hashing module items.\n\nThis PR removes all of the special handling for `Mod`, instead deriving\na `HashStable` implementation. This makes `Mod` consistent with other\n'contains' like `Impl`, which hash their contents through the typical\nderive of `HashStable`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da3f196a4e342221aa9852699546892f8cbd3497", "html_url": "https://github.com/rust-lang/rust/commit/da3f196a4e342221aa9852699546892f8cbd3497", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da3f196a4e342221aa9852699546892f8cbd3497/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "489296d82561f596c278e90edc10eb56168ab623", "url": "https://api.github.com/repos/rust-lang/rust/commits/489296d82561f596c278e90edc10eb56168ab623", "html_url": "https://github.com/rust-lang/rust/commit/489296d82561f596c278e90edc10eb56168ab623"}], "stats": {"total": 64, "additions": 31, "deletions": 33}, "files": [{"sha": "b3446e51c7381d75aa70be7f222341ad207f0d69", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da3f196a4e342221aa9852699546892f8cbd3497/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3f196a4e342221aa9852699546892f8cbd3497/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=da3f196a4e342221aa9852699546892f8cbd3497", "patch": "@@ -2484,7 +2484,7 @@ impl FnRetTy<'_> {\n     }\n }\n \n-#[derive(Encodable, Debug)]\n+#[derive(Encodable, Debug, HashStable_Generic)]\n pub struct Mod<'hir> {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token"}, {"sha": "a43c1f9d9ae3352bb4dd590064b30d20f17644cf", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/da3f196a4e342221aa9852699546892f8cbd3497/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3f196a4e342221aa9852699546892f8cbd3497/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=da3f196a4e342221aa9852699546892f8cbd3497", "patch": "@@ -2,7 +2,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHas\n \n use crate::hir::{\n     AttributeMap, BodyId, Crate, Expr, ForeignItem, ForeignItemId, ImplItem, ImplItemId, Item,\n-    ItemId, Mod, OwnerNodes, TraitCandidate, TraitItem, TraitItemId, Ty, VisibilityKind,\n+    ItemId, OwnerNodes, TraitCandidate, TraitItem, TraitItemId, Ty, VisibilityKind,\n };\n use crate::hir_id::{HirId, ItemLocalId};\n use rustc_span::def_id::DefPathHash;\n@@ -16,7 +16,6 @@ pub trait HashStableContext:\n     fn hash_hir_id(&mut self, _: HirId, hasher: &mut StableHasher);\n     fn hash_body_id(&mut self, _: BodyId, hasher: &mut StableHasher);\n     fn hash_reference_to_item(&mut self, _: HirId, hasher: &mut StableHasher);\n-    fn hash_hir_mod(&mut self, _: &Mod<'_>, hasher: &mut StableHasher);\n     fn hash_hir_expr(&mut self, _: &Expr<'_>, hasher: &mut StableHasher);\n     fn hash_hir_ty(&mut self, _: &Ty<'_>, hasher: &mut StableHasher);\n     fn hash_hir_visibility_kind(&mut self, _: &VisibilityKind<'_>, hasher: &mut StableHasher);\n@@ -132,12 +131,6 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for TraitItemId {\n     }\n }\n \n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Mod<'_> {\n-    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_hir_mod(self, hasher)\n-    }\n-}\n-\n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Expr<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n         hcx.hash_hir_expr(self, hasher)"}, {"sha": "3117140a5b61269bbed304be17d4a2a2903d6b36", "filename": "compiler/rustc_query_system/src/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/da3f196a4e342221aa9852699546892f8cbd3497/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3f196a4e342221aa9852699546892f8cbd3497/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_hir.rs?ref=da3f196a4e342221aa9852699546892f8cbd3497", "patch": "@@ -3,8 +3,7 @@\n \n use crate::ich::hcx::BodyResolver;\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n-use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir as hir;\n use std::mem;\n \n@@ -47,28 +46,6 @@ impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n         })\n     }\n \n-    #[inline]\n-    fn hash_hir_mod(&mut self, module: &hir::Mod<'_>, hasher: &mut StableHasher) {\n-        let hcx = self;\n-        let hir::Mod { inner: ref inner_span, ref item_ids } = *module;\n-\n-        inner_span.hash_stable(hcx, hasher);\n-\n-        // Combining the `DefPathHash`s directly is faster than feeding them\n-        // into the hasher. Because we use a commutative combine, we also don't\n-        // have to sort the array.\n-        let item_ids_hash = item_ids\n-            .iter()\n-            .map(|id| {\n-                let def_path_hash = id.to_stable_hash_key(hcx);\n-                def_path_hash.0\n-            })\n-            .fold(Fingerprint::ZERO, |a, b| a.combine_commutative(b));\n-\n-        item_ids.len().hash_stable(hcx, hasher);\n-        item_ids_hash.hash_stable(hcx, hasher);\n-    }\n-\n     fn hash_hir_expr(&mut self, expr: &hir::Expr<'_>, hasher: &mut StableHasher) {\n         self.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr { hir_id: _, ref span, ref kind } = *expr;"}, {"sha": "fe9af9eeb370c7f281b6aac4ec47f7839dd4397a", "filename": "src/test/incremental/hash-module-order.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/da3f196a4e342221aa9852699546892f8cbd3497/src%2Ftest%2Fincremental%2Fhash-module-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da3f196a4e342221aa9852699546892f8cbd3497/src%2Ftest%2Fincremental%2Fhash-module-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhash-module-order.rs?ref=da3f196a4e342221aa9852699546892f8cbd3497", "patch": "@@ -0,0 +1,28 @@\n+// revisions: rpass1 rpass2\n+// compile-flags: -Z incremental-ignore-spans -Z query-dep-graph\n+\n+// Tests that module hashing depends on the order of the items\n+// (since the order is exposed through `Mod.item_ids`).\n+// Changing the order of items (while keeping `Span`s the same)\n+// should still result in `hir_owner` being invalidated.\n+// Note that it's possible to keep the spans unchanged using\n+// a proc-macro (e.g. producing the module via `quote!`)\n+// but we use `-Z incremental-ignore-spans` for simplicity\n+\n+#![feature(rustc_attrs)]\n+\n+#[cfg(rpass1)]\n+#[rustc_clean(cfg=\"rpass1\",except=\"hir_owner\")]\n+mod foo {\n+    struct First;\n+    struct Second;\n+}\n+\n+#[cfg(rpass2)]\n+#[rustc_clean(cfg=\"rpass2\",except=\"hir_owner\")]\n+mod foo {\n+    struct Second;\n+    struct First;\n+}\n+\n+fn main() {}"}]}