{"sha": "0c127e849487323a9f6be09d25c0da0aeb57314d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMTI3ZTg0OTQ4NzMyM2E5ZjZiZTA5ZDI1YzBkYTBhZWI1NzMxNGQ=", "commit": {"author": {"name": "gnzlbg", "email": "gonzalobg88@gmail.com", "date": "2019-03-26T15:14:32Z"}, "committer": {"name": "gnzlbg", "email": "gonzalobg88@gmail.com", "date": "2019-03-26T15:14:32Z"}, "message": "Life's too short not to use cfg_if", "tree": {"sha": "113d03d71f32979c467eb0dbdf947f8b277712f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/113d03d71f32979c467eb0dbdf947f8b277712f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c127e849487323a9f6be09d25c0da0aeb57314d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c127e849487323a9f6be09d25c0da0aeb57314d", "html_url": "https://github.com/rust-lang/rust/commit/0c127e849487323a9f6be09d25c0da0aeb57314d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c127e849487323a9f6be09d25c0da0aeb57314d/comments", "author": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b6b4899bf699f4098b8cdd773a474b483f23462", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b6b4899bf699f4098b8cdd773a474b483f23462", "html_url": "https://github.com/rust-lang/rust/commit/3b6b4899bf699f4098b8cdd773a474b483f23462"}], "stats": {"total": 124, "additions": 101, "deletions": 23}, "files": [{"sha": "d1ccc148654ca4659b3cc7119186ba78da001e02", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0c127e849487323a9f6be09d25c0da0aeb57314d/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c127e849487323a9f6be09d25c0da0aeb57314d/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=0c127e849487323a9f6be09d25c0da0aeb57314d", "patch": "@@ -97,36 +97,33 @@ pub fn spin_loop() {\n /// elimination.\n ///\n /// This function is a no-op, and does not even read from `dummy`.\n+#[inline]\n #[unstable(feature = \"test\", issue = \"27812\")]\n pub fn black_box<T>(dummy: T) -> T {\n-    #[cfg(not(\n-        any(\n+    cfg_if! {\n+        if #[cfg(any(\n             target_arch = \"asmjs\",\n             all(\n                 target_arch = \"wasm32\",\n                 target_os = \"emscripten\"\n             )\n-        )\n-    ))] {\n-        // we need to \"use\" the argument in some way LLVM can't\n-        // introspect.\n-        unsafe { asm!(\"\" : : \"r\"(&dummy)) }\n-        dummy\n-    }\n-    #[cfg(\n-        any(\n-            target_arch = \"asmjs\",\n-            all(\n-                target_arch = \"wasm32\",\n-                target_os = \"emscripten\"\n-            )\n-        )\n-    )] {\n-        // asm.js and emscripten do not support inline assembly\n-        unsafe {\n-            let ret = crate::ptr::read_volatile(&dummy);\n-            crate::mem::forget(dummy);\n-            ret\n+        ))] {\n+            #[inline]\n+            unsafe fn black_box_impl<T>(d: T) -> T {\n+                // these targets do not support inline assembly\n+                let ret = crate::ptr::read_volatile(&d);\n+                crate::mem::forget(d);\n+                ret\n+            }\n+        } else {\n+            #[inline]\n+            unsafe fn black_box_impl<T>(d: T) -> T {\n+                // we need to \"use\" the argument in some way LLVM can't\n+                // introspect.\n+                asm!(\"\" : : \"r\"(&d));\n+                d\n+            }\n         }\n     }\n+    unsafe { black_box_impl(dummy) }\n }"}, {"sha": "ee6b7d3db48a6f999440d47ef39af4a1434bbfc4", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/0c127e849487323a9f6be09d25c0da0aeb57314d/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c127e849487323a9f6be09d25c0da0aeb57314d/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=0c127e849487323a9f6be09d25c0da0aeb57314d", "patch": "@@ -119,3 +119,84 @@ macro_rules! impl_fn_for_zst {\n         )+\n     }\n }\n+\n+/// A macro for defining `#[cfg]` if-else statements.\n+///\n+/// The macro provided by this crate, `cfg_if`, is similar to the `if/elif` C\n+/// preprocessor macro by allowing definition of a cascade of `#[cfg]` cases,\n+/// emitting the implementation which matches first.\n+///\n+/// This allows you to conveniently provide a long list `#[cfg]`'d blocks of code\n+/// without having to rewrite each clause multiple times.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #[macro_use]\n+/// extern crate cfg_if;\n+///\n+/// cfg_if! {\n+///     if #[cfg(unix)] {\n+///         fn foo() { /* unix specific functionality */ }\n+///     } else if #[cfg(target_pointer_width = \"32\")] {\n+///         fn foo() { /* non-unix, 32-bit functionality */ }\n+///     } else {\n+///         fn foo() { /* fallback implementation */ }\n+///     }\n+/// }\n+///\n+/// # fn main() {}\n+/// ```\n+macro_rules! cfg_if {\n+    // match if/else chains with a final `else`\n+    ($(\n+        if #[cfg($($meta:meta),*)] { $($it:item)* }\n+    ) else * else {\n+        $($it2:item)*\n+    }) => {\n+        cfg_if! {\n+            @__items\n+            () ;\n+            $( ( ($($meta),*) ($($it)*) ), )*\n+            ( () ($($it2)*) ),\n+        }\n+    };\n+\n+    // match if/else chains lacking a final `else`\n+    (\n+        if #[cfg($($i_met:meta),*)] { $($i_it:item)* }\n+        $(\n+            else if #[cfg($($e_met:meta),*)] { $($e_it:item)* }\n+        )*\n+    ) => {\n+        cfg_if! {\n+            @__items\n+            () ;\n+            ( ($($i_met),*) ($($i_it)*) ),\n+            $( ( ($($e_met),*) ($($e_it)*) ), )*\n+            ( () () ),\n+        }\n+    };\n+\n+    // Internal and recursive macro to emit all the items\n+    //\n+    // Collects all the negated cfgs in a list at the beginning and after the\n+    // semicolon is all the remaining items\n+    (@__items ($($not:meta,)*) ; ) => {};\n+    (@__items ($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n+        // Emit all items within one block, applying an approprate #[cfg]. The\n+        // #[cfg] will require all `$m` matchers specified and must also negate\n+        // all previous matchers.\n+        cfg_if! { @__apply cfg(all($($m,)* not(any($($not),*)))), $($it)* }\n+\n+        // Recurse to emit all other items in `$rest`, and when we do so add all\n+        // our `$m` matchers to the list of `$not` matchers as future emissions\n+        // will have to negate everything we just matched as well.\n+        cfg_if! { @__items ($($not,)* $($m,)*) ; $($rest)* }\n+    };\n+\n+    // Internal macro to Apply a cfg attribute to a list of items\n+    (@__apply $m:meta, $($it:item)*) => {\n+        $(#[$m] $it)*\n+    };\n+}"}]}