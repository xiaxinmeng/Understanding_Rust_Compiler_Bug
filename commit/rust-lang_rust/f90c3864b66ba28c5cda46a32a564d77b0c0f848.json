{"sha": "f90c3864b66ba28c5cda46a32a564d77b0c0f848", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MGMzODY0YjY2YmEyOGM1Y2RhNDZhMzJhNTY0ZDc3YjBjMGY4NDg=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-01-21T19:02:52Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-11T12:51:09Z"}, "message": "Add core::marker::PhantomData.\n\nPort `core::ptr::Unique` to have `PhantomData`. Add `PhantomData` to\n`TypedArena` and `Vec` as well.\n\nAs a drive-by, switch `ptr::Unique` from a tuple-struct to a struct\nwith fields.", "tree": {"sha": "4b487d5a24090f3e6f271a47eb8974f3d5824677", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b487d5a24090f3e6f271a47eb8974f3d5824677"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f90c3864b66ba28c5cda46a32a564d77b0c0f848", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f90c3864b66ba28c5cda46a32a564d77b0c0f848", "html_url": "https://github.com/rust-lang/rust/commit/f90c3864b66ba28c5cda46a32a564d77b0c0f848", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f90c3864b66ba28c5cda46a32a564d77b0c0f848/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e02b6d17486ecef8541d03bb6a38c52d1a35b339", "url": "https://api.github.com/repos/rust-lang/rust/commits/e02b6d17486ecef8541d03bb6a38c52d1a35b339", "html_url": "https://github.com/rust-lang/rust/commit/e02b6d17486ecef8541d03bb6a38c52d1a35b339"}], "stats": {"total": 132, "additions": 106, "deletions": 26}, "files": [{"sha": "9e379e4d47553b797b5ef21c2fe79ecfd362241e", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=f90c3864b66ba28c5cda46a32a564d77b0c0f848", "patch": "@@ -42,6 +42,7 @@ use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::intrinsics::{TyDesc, get_tydesc};\n use std::intrinsics;\n+use std::marker;\n use std::mem;\n use std::num::{Int, UnsignedInt};\n use std::ptr;\n@@ -365,6 +366,10 @@ pub struct TypedArena<T> {\n \n     /// A pointer to the first arena segment.\n     first: RefCell<*mut TypedArenaChunk<T>>,\n+\n+    /// Marker indicating that dropping the arena causes its owned\n+    /// instances of `T` to be dropped.\n+    _own: marker::PhantomData<T>,\n }\n \n struct TypedArenaChunk<T> {\n@@ -460,6 +465,7 @@ impl<T> TypedArena<T> {\n                 ptr: Cell::new((*chunk).start() as *const T),\n                 end: Cell::new((*chunk).end() as *const T),\n                 first: RefCell::new(chunk),\n+                _own: marker::PhantomData,\n             }\n         }\n     }"}, {"sha": "24523d4dcc9d327c57edba07739f1390a56c9ab8", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=f90c3864b66ba28c5cda46a32a564d77b0c0f848", "patch": "@@ -278,7 +278,7 @@ impl<T> Drop for RawItems<T> {\n #[unsafe_destructor]\n impl<K, V> Drop for Node<K, V> {\n     fn drop(&mut self) {\n-        if self.keys.0.is_null() {\n+        if self.keys.ptr.is_null() {\n             // We have already cleaned up this node.\n             return;\n         }\n@@ -292,7 +292,7 @@ impl<K, V> Drop for Node<K, V> {\n             self.destroy();\n         }\n \n-        self.keys.0 = ptr::null_mut();\n+        self.keys.ptr = ptr::null_mut();\n     }\n }\n \n@@ -337,18 +337,18 @@ impl<K, V> Node<K, V> {\n     unsafe fn destroy(&mut self) {\n         let (alignment, size) =\n                 calculate_allocation_generic::<K, V>(self.capacity(), self.is_leaf());\n-        heap::deallocate(self.keys.0 as *mut u8, size, alignment);\n+        heap::deallocate(self.keys.ptr as *mut u8, size, alignment);\n     }\n \n     #[inline]\n     pub fn as_slices<'a>(&'a self) -> (&'a [K], &'a [V]) {\n         unsafe {(\n             mem::transmute(raw::Slice {\n-                data: self.keys.0,\n+                data: self.keys.ptr,\n                 len: self.len()\n             }),\n             mem::transmute(raw::Slice {\n-                data: self.vals.0,\n+                data: self.vals.ptr,\n                 len: self.len()\n             })\n         )}\n@@ -368,7 +368,7 @@ impl<K, V> Node<K, V> {\n         } else {\n             unsafe {\n                 mem::transmute(raw::Slice {\n-                    data: self.edges.0,\n+                    data: self.edges.ptr,\n                     len: self.len() + 1\n                 })\n             }\n@@ -586,7 +586,7 @@ impl <K, V> Node<K, V> {\n \n     /// If the node has any children\n     pub fn is_leaf(&self) -> bool {\n-        self.edges.0.is_null()\n+        self.edges.ptr.is_null()\n     }\n \n     /// if the node has too few elements\n@@ -1064,7 +1064,7 @@ impl<K, V> Node<K, V> {\n                     vals: RawItems::from_slice(self.vals()),\n                     edges: RawItems::from_slice(self.edges()),\n \n-                    ptr: self.keys.0 as *mut u8,\n+                    ptr: self.keys.ptr as *mut u8,\n                     capacity: self.capacity(),\n                     is_leaf: self.is_leaf()\n                 },"}, {"sha": "341d91538adb6773d1adca78b1083a3c80506620", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=f90c3864b66ba28c5cda46a32a564d77b0c0f848", "patch": "@@ -57,7 +57,7 @@ use core::default::Default;\n use core::fmt;\n use core::hash::{self, Hash};\n use core::iter::{repeat, FromIterator, IntoIterator};\n-use core::marker::{ContravariantLifetime, InvariantType};\n+use core::marker::{self, ContravariantLifetime, InvariantType};\n use core::mem;\n use core::nonzero::NonZero;\n use core::num::{Int, UnsignedInt};\n@@ -140,6 +140,7 @@ pub struct Vec<T> {\n     ptr: NonZero<*mut T>,\n     len: usize,\n     cap: usize,\n+    _own: marker::PhantomData<T>,\n }\n \n unsafe impl<T: Send> Send for Vec<T> { }\n@@ -166,7 +167,7 @@ impl<T> Vec<T> {\n         // non-null value which is fine since we never call deallocate on the ptr\n         // if cap is 0. The reason for this is because the pointer of a slice\n         // being NULL would break the null pointer optimization for enums.\n-        Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: 0 }\n+        unsafe { Vec::from_raw_parts(EMPTY as *mut T, 0, 0) }\n     }\n \n     /// Constructs a new, empty `Vec<T>` with the specified capacity.\n@@ -198,15 +199,15 @@ impl<T> Vec<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n-            Vec { ptr: unsafe { NonZero::new(EMPTY as *mut T) }, len: 0, cap: usize::MAX }\n+            unsafe { Vec::from_raw_parts(EMPTY as *mut T, 0, usize::MAX) }\n         } else if capacity == 0 {\n             Vec::new()\n         } else {\n             let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             let ptr = unsafe { allocate(size, mem::min_align_of::<T>()) };\n             if ptr.is_null() { ::alloc::oom() }\n-            Vec { ptr: unsafe { NonZero::new(ptr as *mut T) }, len: 0, cap: capacity }\n+            unsafe { Vec::from_raw_parts(ptr as *mut T, 0, capacity) }\n         }\n     }\n \n@@ -247,7 +248,12 @@ impl<T> Vec<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(ptr: *mut T, length: usize,\n                                  capacity: usize) -> Vec<T> {\n-        Vec { ptr: NonZero::new(ptr), len: length, cap: capacity }\n+        Vec {\n+            ptr: NonZero::new(ptr),\n+            len: length,\n+            cap: capacity,\n+            _own: marker::PhantomData,\n+        }\n     }\n \n     /// Creates a vector by copying the elements from a raw pointer.\n@@ -1626,7 +1632,7 @@ impl<T> IntoIter<T> {\n             for _x in self.by_ref() { }\n             let IntoIter { allocation, cap, ptr: _ptr, end: _end } = self;\n             mem::forget(self);\n-            Vec { ptr: NonZero::new(allocation), cap: cap, len: 0 }\n+            Vec::from_raw_parts(allocation, 0, cap)\n         }\n     }\n }"}, {"sha": "da93d4f6ca44e172a8c53d2a5e34260d7ecce63d", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=f90c3864b66ba28c5cda46a32a564d77b0c0f848", "patch": "@@ -202,6 +202,24 @@ pub unsafe trait Sync {\n     // Empty\n }\n \n+/// A marker type that indicates to the compiler that the instances\n+/// of the type itself owns instances of the type parameter `T`.\n+///\n+/// This is used to indicate that one or more instances of the type\n+/// `T` could be dropped when instances of the type itself is dropped,\n+/// though that may not be apparent from the other structure of the\n+/// type itself. For example, the type may hold a `*mut T`, which the\n+/// compiler does not automatically treat as owned.\n+#[unstable(feature = \"core\",\n+           reason = \"Newly added to deal with scoping and destructor changes\")]\n+#[lang=\"phantom_data\"]\n+#[derive(PartialEq, Eq, PartialOrd, Ord)]\n+pub struct PhantomData<T: ?Sized>;\n+\n+impl<T: ?Sized> Copy for PhantomData<T> {}\n+impl<T: ?Sized> Clone for PhantomData<T> {\n+    fn clone(&self) -> PhantomData<T> { *self }\n+}\n \n /// A marker type whose type parameter `T` is considered to be\n /// covariant with respect to the type itself. This is (typically)"}, {"sha": "1b8ec048f8de72334a92dad3aa2ddae454545935", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=f90c3864b66ba28c5cda46a32a564d77b0c0f848", "patch": "@@ -92,7 +92,7 @@ use mem;\n use clone::Clone;\n use intrinsics;\n use option::Option::{self, Some, None};\n-use marker::{Send, Sized, Sync};\n+use marker::{self, Send, Sized, Sync};\n \n use cmp::{PartialEq, Eq, Ord, PartialOrd};\n use cmp::Ordering::{self, Less, Equal, Greater};\n@@ -522,7 +522,11 @@ impl<T> PartialOrd for *mut T {\n /// Useful for building abstractions like `Vec<T>` or `Box<T>`, which\n /// internally use raw pointers to manage the memory that they own.\n #[unstable(feature = \"core\", reason = \"recently added to this module\")]\n-pub struct Unique<T: ?Sized>(pub *mut T);\n+pub struct Unique<T: ?Sized> {\n+    /// The wrapped `*mut T`.\n+    pub ptr: *mut T,\n+    _own: marker::PhantomData<T>,\n+}\n \n /// `Unique` pointers are `Send` if `T` is `Send` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n@@ -550,6 +554,13 @@ impl<T> Unique<T> {\n     #[unstable(feature = \"core\",\n                reason = \"recently added to this module\")]\n     pub unsafe fn offset(self, offset: int) -> *mut T {\n-        self.0.offset(offset)\n+        self.ptr.offset(offset)\n     }\n }\n+\n+/// Creates a `Unique` wrapped around `ptr`, taking ownership of the\n+/// data referenced by `ptr`.\n+#[allow(non_snake_case)]\n+pub fn Unique<T: ?Sized>(ptr: *mut T) -> Unique<T> {\n+    Unique { ptr: ptr, _own: marker::PhantomData }\n+}"}, {"sha": "797c150e8591a7d21652e589457738ee0cca0278", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=f90c3864b66ba28c5cda46a32a564d77b0c0f848", "patch": "@@ -172,7 +172,7 @@ fn test_set_memory() {\n fn test_unsized_unique() {\n     let xs: &mut [_] = &mut [1, 2, 3];\n     let ptr = Unique(xs as *mut [_]);\n-    let ys = unsafe { &mut *ptr.0 };\n+    let ys = unsafe { &mut *ptr.ptr };\n     let zs: &mut [_] = &mut [1, 2, 3];\n     assert!(ys == zs);\n }"}, {"sha": "ff6400a11dfe8b3b7c620228240dafe590ebc81d", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=f90c3864b66ba28c5cda46a32a564d77b0c0f848", "patch": "@@ -45,13 +45,13 @@ pub struct Bytes {\n impl Deref for Bytes {\n     type Target = [u8];\n     fn deref(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts_mut(self.ptr.0, self.len) }\n+        unsafe { slice::from_raw_parts_mut(self.ptr.ptr, self.len) }\n     }\n }\n \n impl Drop for Bytes {\n     fn drop(&mut self) {\n-        unsafe { libc::free(self.ptr.0 as *mut _); }\n+        unsafe { libc::free(self.ptr.ptr as *mut _); }\n     }\n }\n "}, {"sha": "ef72c2242c1e70a48490ba635dad3949a2d6abd0", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=f90c3864b66ba28c5cda46a32a564d77b0c0f848", "patch": "@@ -312,6 +312,8 @@ lets_do_this! {\n     ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;\n     OwnedBoxLangItem,                \"owned_box\",               owned_box;\n \n+    PhantomDataItem,                 \"phantom_data\",            phantom_data;\n+\n     CovariantTypeItem,               \"covariant_type\",          covariant_type;\n     ContravariantTypeItem,           \"contravariant_type\",      contravariant_type;\n     InvariantTypeItem,               \"invariant_type\",          invariant_type;"}, {"sha": "8e94991f6569191209d895e292be044befbb952a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90c3864b66ba28c5cda46a32a564d77b0c0f848/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f90c3864b66ba28c5cda46a32a564d77b0c0f848", "patch": "@@ -72,6 +72,8 @@ use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::fmt;\n use std::hash::{Hash, Writer, SipHasher, Hasher};\n+#[cfg(stage0)]\n+use std::marker;\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n@@ -931,6 +933,26 @@ pub struct TyS<'tcx> {\n \n     // the maximal depth of any bound regions appearing in this type.\n     region_depth: u32,\n+\n+    // force the lifetime to be invariant to work-around\n+    // region-inference issues with a covariant lifetime.\n+    #[cfg(stage0)]\n+    marker: ShowInvariantLifetime<'tcx>,\n+}\n+\n+#[cfg(stage0)]\n+struct ShowInvariantLifetime<'a>(marker::InvariantLifetime<'a>);\n+#[cfg(stage0)]\n+impl<'a> ShowInvariantLifetime<'a> {\n+    fn new() -> ShowInvariantLifetime<'a> {\n+        ShowInvariantLifetime(marker::InvariantLifetime)\n+    }\n+}\n+#[cfg(stage0)]\n+impl<'a> fmt::Debug for ShowInvariantLifetime<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"InvariantLifetime\")\n+    }\n }\n \n impl fmt::Debug for TypeFlags {\n@@ -939,11 +961,20 @@ impl fmt::Debug for TypeFlags {\n     }\n }\n \n+#[cfg(stage0)]\n impl<'tcx> PartialEq for TyS<'tcx> {\n-    fn eq(&self, other: &TyS<'tcx>) -> bool {\n+    fn eq<'a,'b>(&'a self, other: &'b TyS<'tcx>) -> bool {\n+        let other: &'a TyS<'tcx> = unsafe { mem::transmute(other) };\n         (self as *const _) == (other as *const _)\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'tcx> PartialEq for TyS<'tcx> {\n+    fn eq(&self, other: &TyS<'tcx>) -> bool {\n+        // (self as *const _) == (other as *const _)\n+        (self as *const TyS<'tcx>) == (other as *const TyS<'tcx>)\n+    }\n+}\n impl<'tcx> Eq for TyS<'tcx> {}\n \n impl<'tcx, S: Writer + Hasher> Hash<S> for TyS<'tcx> {\n@@ -2475,11 +2506,17 @@ fn intern_ty<'tcx>(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n \n     let flags = FlagComputation::for_sty(&st);\n \n-    let ty = type_arena.alloc(TyS {\n-        sty: st,\n-        flags: flags.flags,\n-        region_depth: flags.depth,\n-    });\n+    let ty = match () {\n+        #[cfg(stage0)]\n+        () => type_arena.alloc(TyS { sty: st,\n+                                     flags: flags.flags,\n+                                     region_depth: flags.depth,\n+                                     marker: ShowInvariantLifetime::new(), }),\n+        #[cfg(not(stage0))]\n+        () => type_arena.alloc(TyS { sty: st,\n+                                     flags: flags.flags,\n+                                     region_depth: flags.depth, }),\n+    };\n \n     debug!(\"Interned type: {:?} Pointer: {:?}\",\n            ty, ty as *const _);"}]}