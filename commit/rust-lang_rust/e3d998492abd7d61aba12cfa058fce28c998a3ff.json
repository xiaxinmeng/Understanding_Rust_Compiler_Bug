{"sha": "e3d998492abd7d61aba12cfa058fce28c998a3ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZDk5ODQ5MmFiZDdkNjFhYmExMmNmYTA1OGZjZTI4Yzk5OGEzZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-12T04:44:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-12T04:44:30Z"}, "message": "Auto merge of #66129 - Nadrieril:refactor-slice-pat-usefulness, r=varkor\n\nRefactor slice pattern usefulness checking\n\nAs a follow up to https://github.com/rust-lang/rust/pull/65874, this PR changes how variable-length slice patterns are handled in usefulness checking. The objectives are: cleaning up that code to make it easier to understand, and paving the way to handling fixed-length slices more cleverly too, for https://github.com/rust-lang/rust/issues/53820.\n\nBefore this, variable-length slice patterns were eagerly expanded into a union of fixed-length slices. Now they have their own special constructor, which allows expanding them a bit more lazily.\nAs a nice side-effect, this improves diagnostics.\n\nThis PR shows a slight performance improvement, mostly due to https://github.com/rust-lang/rust/pull/66129/commits/149792b6080f40875c0072aae378a0eb31d23df0. This will probably have to be reverted in some way when we implement or-patterns.", "tree": {"sha": "2df921d0afe9c64362a52fa52bf5391f2298e706", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2df921d0afe9c64362a52fa52bf5391f2298e706"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3d998492abd7d61aba12cfa058fce28c998a3ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3d998492abd7d61aba12cfa058fce28c998a3ff", "html_url": "https://github.com/rust-lang/rust/commit/e3d998492abd7d61aba12cfa058fce28c998a3ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3d998492abd7d61aba12cfa058fce28c998a3ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e931f00f658b59481925deb0152503038ca69b9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e931f00f658b59481925deb0152503038ca69b9e", "html_url": "https://github.com/rust-lang/rust/commit/e931f00f658b59481925deb0152503038ca69b9e"}, {"sha": "fd9921b41c4354aaf790c2bc0393f818034100d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd9921b41c4354aaf790c2bc0393f818034100d0", "html_url": "https://github.com/rust-lang/rust/commit/fd9921b41c4354aaf790c2bc0393f818034100d0"}], "stats": {"total": 891, "additions": 627, "deletions": 264}, "files": [{"sha": "982330baf9c9568cc386b2b5adce11befa4c3dbd", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 344, "deletions": 249, "changes": 593, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "patch": "@@ -586,8 +586,10 @@ enum Constructor<'tcx> {\n     ConstantValue(&'tcx ty::Const<'tcx>, Span),\n     /// Ranges of literal values (`2..=5` and `2..5`).\n     ConstantRange(u128, u128, Ty<'tcx>, RangeEnd, Span),\n-    /// Array patterns of length n.\n-    Slice(u64),\n+    /// Array patterns of length `n`.\n+    FixedLenSlice(u64),\n+    /// Slice patterns. Captures any array constructor of `length >= i + j`.\n+    VarLenSlice(u64, u64),\n }\n \n // Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n@@ -601,7 +603,11 @@ impl<'tcx> std::cmp::PartialEq for Constructor<'tcx> {\n                 Constructor::ConstantRange(a_start, a_end, a_ty, a_range_end, _),\n                 Constructor::ConstantRange(b_start, b_end, b_ty, b_range_end, _),\n             ) => a_start == b_start && a_end == b_end && a_ty == b_ty && a_range_end == b_range_end,\n-            (Constructor::Slice(a), Constructor::Slice(b)) => a == b,\n+            (Constructor::FixedLenSlice(a), Constructor::FixedLenSlice(b)) => a == b,\n+            (\n+                Constructor::VarLenSlice(a_prefix, a_suffix),\n+                Constructor::VarLenSlice(b_prefix, b_suffix),\n+            ) => a_prefix == b_prefix && a_suffix == b_suffix,\n             _ => false,\n         }\n     }\n@@ -610,7 +616,7 @@ impl<'tcx> std::cmp::PartialEq for Constructor<'tcx> {\n impl<'tcx> Constructor<'tcx> {\n     fn is_slice(&self) -> bool {\n         match self {\n-            Slice { .. } => true,\n+            FixedLenSlice { .. } | VarLenSlice { .. } => true,\n             _ => false,\n         }\n     }\n@@ -644,7 +650,8 @@ impl<'tcx> Constructor<'tcx> {\n                     ty::Const::from_bits(tcx, *hi, ty),\n                 )\n             }\n-            Constructor::Slice(val) => format!(\"[{}]\", val),\n+            Constructor::FixedLenSlice(val) => format!(\"[{}]\", val),\n+            Constructor::VarLenSlice(prefix, suffix) => format!(\"[{}, .., {}]\", prefix, suffix),\n             _ => bug!(\"bad constructor being displayed: `{:?}\", self),\n         }\n     }\n@@ -657,44 +664,183 @@ impl<'tcx> Constructor<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         other_ctors: &Vec<Constructor<'tcx>>,\n     ) -> Vec<Constructor<'tcx>> {\n-        let mut refined_ctors = vec![self.clone()];\n-        for other_ctor in other_ctors {\n-            if other_ctor == self {\n-                // If a constructor appears in a `match` arm, we can\n-                // eliminate it straight away.\n-                refined_ctors = vec![]\n-            } else if let Some(interval) = IntRange::from_ctor(tcx, param_env, other_ctor) {\n-                // Refine the required constructors for the type by subtracting\n-                // the range defined by the current constructor pattern.\n-                refined_ctors = interval.subtract_from(tcx, param_env, refined_ctors);\n+        match *self {\n+            // Those constructors can only match themselves.\n+            Single | Variant(_) => {\n+                if other_ctors.iter().any(|c| c == self) {\n+                    vec![]\n+                } else {\n+                    vec![self.clone()]\n+                }\n+            }\n+            FixedLenSlice(self_len) => {\n+                let overlaps = |c: &Constructor<'_>| match *c {\n+                    FixedLenSlice(other_len) => other_len == self_len,\n+                    VarLenSlice(prefix, suffix) => prefix + suffix <= self_len,\n+                    _ => false,\n+                };\n+                if other_ctors.iter().any(overlaps) { vec![] } else { vec![self.clone()] }\n             }\n+            VarLenSlice(..) => {\n+                let mut remaining_ctors = vec![self.clone()];\n+\n+                // For each used ctor, subtract from the current set of constructors.\n+                // Naming: we remove the \"neg\" constructors from the \"pos\" ones.\n+                // Remember, `VarLenSlice(i, j)` covers the union of `FixedLenSlice` from\n+                // `i + j` to infinity.\n+                for neg_ctor in other_ctors {\n+                    remaining_ctors = remaining_ctors\n+                        .into_iter()\n+                        .flat_map(|pos_ctor| -> SmallVec<[Constructor<'tcx>; 1]> {\n+                            // Compute `pos_ctor \\ neg_ctor`.\n+                            match (&pos_ctor, neg_ctor) {\n+                                (&FixedLenSlice(pos_len), &VarLenSlice(neg_prefix, neg_suffix)) => {\n+                                    let neg_len = neg_prefix + neg_suffix;\n+                                    if neg_len <= pos_len {\n+                                        smallvec![]\n+                                    } else {\n+                                        smallvec![pos_ctor]\n+                                    }\n+                                }\n+                                (\n+                                    &VarLenSlice(pos_prefix, pos_suffix),\n+                                    &VarLenSlice(neg_prefix, neg_suffix),\n+                                ) => {\n+                                    let neg_len = neg_prefix + neg_suffix;\n+                                    let pos_len = pos_prefix + pos_suffix;\n+                                    if neg_len <= pos_len {\n+                                        smallvec![]\n+                                    } else {\n+                                        (pos_len..neg_len).map(FixedLenSlice).collect()\n+                                    }\n+                                }\n+                                (&VarLenSlice(pos_prefix, pos_suffix), &FixedLenSlice(neg_len)) => {\n+                                    let pos_len = pos_prefix + pos_suffix;\n+                                    if neg_len < pos_len {\n+                                        smallvec![pos_ctor]\n+                                    } else {\n+                                        (pos_len..neg_len)\n+                                            .map(FixedLenSlice)\n+                                            // We know that `neg_len + 1 >= pos_len >= pos_suffix`.\n+                                            .chain(Some(VarLenSlice(\n+                                                neg_len + 1 - pos_suffix,\n+                                                pos_suffix,\n+                                            )))\n+                                            .collect()\n+                                    }\n+                                }\n+                                _ if pos_ctor == *neg_ctor => smallvec![],\n+                                _ => smallvec![pos_ctor],\n+                            }\n+                        })\n+                        .collect();\n+\n+                    // If the constructors that have been considered so far already cover\n+                    // the entire range of `self`, no need to look at more constructors.\n+                    if remaining_ctors.is_empty() {\n+                        break;\n+                    }\n+                }\n \n-            // If the constructor patterns that have been considered so far\n-            // already cover the entire range of values, then we know the\n-            // constructor is not missing, and we can move on to the next one.\n-            if refined_ctors.is_empty() {\n-                break;\n+                remaining_ctors\n             }\n-        }\n+            ConstantRange(..) | ConstantValue(..) => {\n+                let mut remaining_ctors = vec![self.clone()];\n+                for other_ctor in other_ctors {\n+                    if other_ctor == self {\n+                        // If a constructor appears in a `match` arm, we can\n+                        // eliminate it straight away.\n+                        remaining_ctors = vec![]\n+                    } else if let Some(interval) = IntRange::from_ctor(tcx, param_env, other_ctor) {\n+                        // Refine the required constructors for the type by subtracting\n+                        // the range defined by the current constructor pattern.\n+                        remaining_ctors = interval.subtract_from(tcx, param_env, remaining_ctors);\n+                    }\n \n-        // If a constructor has not been matched, then it is missing.\n-        // We add `refined_ctors` instead of `self`, because then we can\n-        // provide more detailed error information about precisely which\n-        // ranges have been omitted.\n-        refined_ctors\n+                    // If the constructor patterns that have been considered so far\n+                    // already cover the entire range of values, then we know the\n+                    // constructor is not missing, and we can move on to the next one.\n+                    if remaining_ctors.is_empty() {\n+                        break;\n+                    }\n+                }\n+\n+                // If a constructor has not been matched, then it is missing.\n+                // We add `remaining_ctors` instead of `self`, because then we can\n+                // provide more detailed error information about precisely which\n+                // ranges have been omitted.\n+                remaining_ctors\n+            }\n+        }\n     }\n \n     /// This returns one wildcard pattern for each argument to this constructor.\n     fn wildcard_subpatterns<'a>(\n         &self,\n         cx: &MatchCheckCtxt<'a, 'tcx>,\n         ty: Ty<'tcx>,\n-    ) -> impl Iterator<Item = Pat<'tcx>> + DoubleEndedIterator {\n-        constructor_sub_pattern_tys(cx, self, ty).into_iter().map(|ty| Pat {\n-            ty,\n-            span: DUMMY_SP,\n-            kind: box PatKind::Wild,\n-        })\n+    ) -> Vec<Pat<'tcx>> {\n+        debug!(\"wildcard_subpatterns({:#?}, {:?})\", self, ty);\n+        match ty.kind {\n+            ty::Tuple(ref fs) => {\n+                fs.into_iter().map(|t| t.expect_ty()).map(Pat::wildcard_from_ty).collect()\n+            }\n+            ty::Slice(ty) | ty::Array(ty, _) => match *self {\n+                FixedLenSlice(length) => (0..length).map(|_| Pat::wildcard_from_ty(ty)).collect(),\n+                VarLenSlice(prefix, suffix) => {\n+                    (0..prefix + suffix).map(|_| Pat::wildcard_from_ty(ty)).collect()\n+                }\n+                ConstantValue(..) => vec![],\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n+            },\n+            ty::Ref(_, rty, _) => vec![Pat::wildcard_from_ty(rty)],\n+            ty::Adt(adt, substs) => {\n+                if adt.is_box() {\n+                    // Use T as the sub pattern type of Box<T>.\n+                    vec![Pat::wildcard_from_ty(substs.type_at(0))]\n+                } else {\n+                    let variant = &adt.variants[self.variant_index_for_adt(cx, adt)];\n+                    let is_non_exhaustive =\n+                        variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n+                    variant\n+                        .fields\n+                        .iter()\n+                        .map(|field| {\n+                            let is_visible =\n+                                adt.is_enum() || field.vis.is_accessible_from(cx.module, cx.tcx);\n+                            let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n+                            match (is_visible, is_non_exhaustive, is_uninhabited) {\n+                                // Treat all uninhabited types in non-exhaustive variants as\n+                                // `TyErr`.\n+                                (_, true, true) => cx.tcx.types.err,\n+                                // Treat all non-visible fields as `TyErr`. They can't appear in\n+                                // any other pattern from this match (because they are private), so\n+                                // their type does not matter - but we don't want to know they are\n+                                // uninhabited.\n+                                (false, ..) => cx.tcx.types.err,\n+                                (true, ..) => {\n+                                    let ty = field.ty(cx.tcx, substs);\n+                                    match ty.kind {\n+                                        // If the field type returned is an array of an unknown\n+                                        // size return an TyErr.\n+                                        ty::Array(_, len)\n+                                            if len\n+                                                .try_eval_usize(cx.tcx, cx.param_env)\n+                                                .is_none() =>\n+                                        {\n+                                            cx.tcx.types.err\n+                                        }\n+                                        _ => ty,\n+                                    }\n+                                }\n+                            }\n+                        })\n+                        .map(Pat::wildcard_from_ty)\n+                        .collect()\n+                }\n+            }\n+            _ => vec![],\n+        }\n     }\n \n     /// This computes the arity of a constructor. The arity of a constructor\n@@ -707,7 +853,8 @@ impl<'tcx> Constructor<'tcx> {\n         match ty.kind {\n             ty::Tuple(ref fs) => fs.len() as u64,\n             ty::Slice(..) | ty::Array(..) => match *self {\n-                Slice(length) => length,\n+                FixedLenSlice(length) => length,\n+                VarLenSlice(prefix, suffix) => prefix + suffix,\n                 ConstantValue(..) => 0,\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n             },\n@@ -764,9 +911,18 @@ impl<'tcx> Constructor<'tcx> {\n \n             ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.nth(0).unwrap() },\n \n-            ty::Slice(_) | ty::Array(..) => {\n-                PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n-            }\n+            ty::Slice(_) | ty::Array(..) => match self {\n+                FixedLenSlice(_) => {\n+                    PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n+                }\n+                VarLenSlice(prefix_len, _suffix_len) => {\n+                    let prefix = subpatterns.by_ref().take(*prefix_len as usize).collect();\n+                    let suffix = subpatterns.collect();\n+                    let wild = Pat::wildcard_from_ty(ty);\n+                    PatKind::Slice { prefix, slice: Some(wild), suffix }\n+                }\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n+            },\n \n             _ => match *self {\n                 ConstantValue(value, _) => PatKind::Constant { value },\n@@ -784,7 +940,7 @@ impl<'tcx> Constructor<'tcx> {\n \n     /// Like `apply`, but where all the subpatterns are wildcards `_`.\n     fn apply_wildcards<'a>(&self, cx: &MatchCheckCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Pat<'tcx> {\n-        let subpatterns = self.wildcard_subpatterns(cx, ty).rev();\n+        let subpatterns = self.wildcard_subpatterns(cx, ty).into_iter().rev();\n         self.apply(cx, ty, subpatterns)\n     }\n }\n@@ -831,7 +987,7 @@ impl<'tcx> Usefulness<'tcx> {\n     fn apply_wildcard(self, ty: Ty<'tcx>) -> Self {\n         match self {\n             UsefulWithWitness(witnesses) => {\n-                let wild = Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild };\n+                let wild = Pat::wildcard_from_ty(ty);\n                 UsefulWithWitness(\n                     witnesses\n                         .into_iter()\n@@ -884,7 +1040,6 @@ pub enum WitnessPreference {\n #[derive(Copy, Clone, Debug)]\n struct PatCtxt<'tcx> {\n     ty: Ty<'tcx>,\n-    max_slice_length: u64,\n     span: Span,\n }\n \n@@ -980,14 +1135,14 @@ fn all_constructors<'a, 'tcx>(\n             .collect(),\n         ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n             let len = len.eval_usize(cx.tcx, cx.param_env);\n-            if len != 0 && cx.is_uninhabited(sub_ty) { vec![] } else { vec![Slice(len)] }\n+            if len != 0 && cx.is_uninhabited(sub_ty) { vec![] } else { vec![FixedLenSlice(len)] }\n         }\n         // Treat arrays of a constant but unknown length like slices.\n         ty::Array(ref sub_ty, _) | ty::Slice(ref sub_ty) => {\n             if cx.is_uninhabited(sub_ty) {\n-                vec![Slice(0)]\n+                vec![FixedLenSlice(0)]\n             } else {\n-                (0..pcx.max_slice_length + 1).map(|length| Slice(length)).collect()\n+                vec![VarLenSlice(0, 0)]\n             }\n         }\n         ty::Adt(def, substs) if def.is_enum() => def\n@@ -1042,108 +1197,6 @@ fn all_constructors<'a, 'tcx>(\n     ctors\n }\n \n-fn max_slice_length<'p, 'a, 'tcx, I>(cx: &mut MatchCheckCtxt<'a, 'tcx>, patterns: I) -> u64\n-where\n-    I: Iterator<Item = &'p Pat<'tcx>>,\n-    'tcx: 'p,\n-{\n-    // The exhaustiveness-checking paper does not include any details on\n-    // checking variable-length slice patterns. However, they are matched\n-    // by an infinite collection of fixed-length array patterns.\n-    //\n-    // Checking the infinite set directly would take an infinite amount\n-    // of time. However, it turns out that for each finite set of\n-    // patterns `P`, all sufficiently large array lengths are equivalent:\n-    //\n-    // Each slice `s` with a \"sufficiently-large\" length `l \u2265 L` that applies\n-    // to exactly the subset `P\u209c` of `P` can be transformed to a slice\n-    // `s\u2098` for each sufficiently-large length `m` that applies to exactly\n-    // the same subset of `P`.\n-    //\n-    // Because of that, each witness for reachability-checking from one\n-    // of the sufficiently-large lengths can be transformed to an\n-    // equally-valid witness from any other length, so we only have\n-    // to check slice lengths from the \"minimal sufficiently-large length\"\n-    // and below.\n-    //\n-    // Note that the fact that there is a *single* `s\u2098` for each `m`\n-    // not depending on the specific pattern in `P` is important: if\n-    // you look at the pair of patterns\n-    //     `[true, ..]`\n-    //     `[.., false]`\n-    // Then any slice of length \u22651 that matches one of these two\n-    // patterns can be trivially turned to a slice of any\n-    // other length \u22651 that matches them and vice-versa - for\n-    // but the slice from length 2 `[false, true]` that matches neither\n-    // of these patterns can't be turned to a slice from length 1 that\n-    // matches neither of these patterns, so we have to consider\n-    // slices from length 2 there.\n-    //\n-    // Now, to see that that length exists and find it, observe that slice\n-    // patterns are either \"fixed-length\" patterns (`[_, _, _]`) or\n-    // \"variable-length\" patterns (`[_, .., _]`).\n-    //\n-    // For fixed-length patterns, all slices with lengths *longer* than\n-    // the pattern's length have the same outcome (of not matching), so\n-    // as long as `L` is greater than the pattern's length we can pick\n-    // any `s\u2098` from that length and get the same result.\n-    //\n-    // For variable-length patterns, the situation is more complicated,\n-    // because as seen above the precise value of `s\u2098` matters.\n-    //\n-    // However, for each variable-length pattern `p` with a prefix of length\n-    // `pl\u209a` and suffix of length `sl\u209a`, only the first `pl\u209a` and the last\n-    // `sl\u209a` elements are examined.\n-    //\n-    // Therefore, as long as `L` is positive (to avoid concerns about empty\n-    // types), all elements after the maximum prefix length and before\n-    // the maximum suffix length are not examined by any variable-length\n-    // pattern, and therefore can be added/removed without affecting\n-    // them - creating equivalent patterns from any sufficiently-large\n-    // length.\n-    //\n-    // Of course, if fixed-length patterns exist, we must be sure\n-    // that our length is large enough to miss them all, so\n-    // we can pick `L = max(FIXED_LEN+1 \u222a {max(PREFIX_LEN) + max(SUFFIX_LEN)})`\n-    //\n-    // for example, with the above pair of patterns, all elements\n-    // but the first and last can be added/removed, so any\n-    // witness of length \u22652 (say, `[false, false, true]`) can be\n-    // turned to a witness from any other length \u22652.\n-\n-    let mut max_prefix_len = 0;\n-    let mut max_suffix_len = 0;\n-    let mut max_fixed_len = 0;\n-\n-    for row in patterns {\n-        match *row.kind {\n-            PatKind::Constant { value } => {\n-                // extract the length of an array/slice from a constant\n-                match (value.val, &value.ty.kind) {\n-                    (_, ty::Array(_, n)) => {\n-                        max_fixed_len = cmp::max(max_fixed_len, n.eval_usize(cx.tcx, cx.param_env))\n-                    }\n-                    (ConstValue::Slice { start, end, .. }, ty::Slice(_)) => {\n-                        max_fixed_len = cmp::max(max_fixed_len, (end - start) as u64)\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            PatKind::Slice { ref prefix, slice: None, ref suffix } => {\n-                let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n-                max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n-            }\n-            PatKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n-                max_prefix_len = cmp::max(max_prefix_len, prefix.len() as u64);\n-                max_suffix_len = cmp::max(max_suffix_len, suffix.len() as u64);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    cmp::max(max_fixed_len + 1, max_prefix_len + max_suffix_len)\n-}\n-\n /// An inclusive interval, used for precise integer exhaustiveness checking.\n /// `IntRange`s always store a contiguous range. This means that values are\n /// encoded such that `0` encodes the minimum value for the integer,\n@@ -1508,20 +1561,19 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // introducing uninhabited patterns for inaccessible fields. We\n         // need to figure out how to model that.\n         ty,\n-        max_slice_length: max_slice_length(cx, matrix.heads().chain(Some(v.head()))),\n         span,\n     };\n \n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v.head());\n \n-    if let Some(constructors) = pat_constructors(cx, v.head(), pcx) {\n-        debug!(\"is_useful - expanding constructors: {:#?}\", constructors);\n+    if let Some(constructor) = pat_constructor(cx, v.head(), pcx) {\n+        debug!(\"is_useful - expanding constructor: {:#?}\", constructor);\n         split_grouped_constructors(\n             cx.tcx,\n             cx.param_env,\n-            constructors,\n+            pcx,\n+            vec![constructor],\n             matrix,\n-            pcx.ty,\n             pcx.span,\n             Some(hir_id),\n         )\n@@ -1533,7 +1585,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         debug!(\"is_useful - expanding wildcard\");\n \n         let used_ctors: Vec<Constructor<'_>> =\n-            matrix.heads().flat_map(|p| pat_constructors(cx, p, pcx).unwrap_or(vec![])).collect();\n+            matrix.heads().filter_map(|p| pat_constructor(cx, p, pcx)).collect();\n         debug!(\"used_ctors = {:#?}\", used_ctors);\n         // `all_ctors` are all the constructors for the given type, which\n         // should all be represented (or caught with the wild pattern `_`).\n@@ -1583,19 +1635,13 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n         if missing_ctors.is_empty() && !is_non_exhaustive {\n             let (all_ctors, _) = missing_ctors.into_inner();\n-            split_grouped_constructors(\n-                cx.tcx,\n-                cx.param_env,\n-                all_ctors,\n-                matrix,\n-                pcx.ty,\n-                DUMMY_SP,\n-                None,\n-            )\n-            .into_iter()\n-            .map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness_preference, hir_id))\n-            .find(|result| result.is_useful())\n-            .unwrap_or(NotUseful)\n+            split_grouped_constructors(cx.tcx, cx.param_env, pcx, all_ctors, matrix, DUMMY_SP, None)\n+                .into_iter()\n+                .map(|c| {\n+                    is_useful_specialized(cx, matrix, v, c, pcx.ty, witness_preference, hir_id)\n+                })\n+                .find(|result| result.is_useful())\n+                .unwrap_or(NotUseful)\n         } else {\n             let matrix = matrix.specialize_wildcard();\n             let v = v.to_tail();\n@@ -1673,7 +1719,7 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n ) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n \n-    let ctor_wild_subpatterns_owned: Vec<_> = ctor.wildcard_subpatterns(cx, lty).collect();\n+    let ctor_wild_subpatterns_owned: Vec<_> = ctor.wildcard_subpatterns(cx, lty);\n     let ctor_wild_subpatterns: Vec<_> = ctor_wild_subpatterns_owned.iter().collect();\n     let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n     v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns)\n@@ -1682,44 +1728,39 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n         .unwrap_or(NotUseful)\n }\n \n-/// Determines the constructors that the given pattern can be specialized to.\n-///\n-/// In most cases, there's only one constructor that a specific pattern\n-/// represents, such as a specific enum variant or a specific literal value.\n-/// Slice patterns, however, can match slices of different lengths. For instance,\n-/// `[a, b, tail @ ..]` can match a slice of length 2, 3, 4 and so on.\n-///\n+/// Determines the constructor that the given pattern can be specialized to.\n /// Returns `None` in case of a catch-all, which can't be specialized.\n-fn pat_constructors<'tcx>(\n+fn pat_constructor<'tcx>(\n     cx: &mut MatchCheckCtxt<'_, 'tcx>,\n     pat: &Pat<'tcx>,\n     pcx: PatCtxt<'tcx>,\n-) -> Option<Vec<Constructor<'tcx>>> {\n+) -> Option<Constructor<'tcx>> {\n     match *pat.kind {\n-        PatKind::AscribeUserType { ref subpattern, .. } => pat_constructors(cx, subpattern, pcx),\n+        PatKind::AscribeUserType { ref subpattern, .. } => pat_constructor(cx, subpattern, pcx),\n         PatKind::Binding { .. } | PatKind::Wild => None,\n-        PatKind::Leaf { .. } | PatKind::Deref { .. } => Some(vec![Single]),\n+        PatKind::Leaf { .. } | PatKind::Deref { .. } => Some(Single),\n         PatKind::Variant { adt_def, variant_index, .. } => {\n-            Some(vec![Variant(adt_def.variants[variant_index].def_id)])\n+            Some(Variant(adt_def.variants[variant_index].def_id))\n         }\n-        PatKind::Constant { value } => Some(vec![ConstantValue(value, pat.span)]),\n-        PatKind::Range(PatRange { lo, hi, end }) => Some(vec![ConstantRange(\n+        PatKind::Constant { value } => Some(ConstantValue(value, pat.span)),\n+        PatKind::Range(PatRange { lo, hi, end }) => Some(ConstantRange(\n             lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n             hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n             lo.ty,\n             end,\n             pat.span,\n-        )]),\n+        )),\n         PatKind::Array { .. } => match pcx.ty.kind {\n-            ty::Array(_, length) => Some(vec![Slice(length.eval_usize(cx.tcx, cx.param_env))]),\n+            ty::Array(_, length) => Some(FixedLenSlice(length.eval_usize(cx.tcx, cx.param_env))),\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty),\n         },\n         PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n-            let pat_len = prefix.len() as u64 + suffix.len() as u64;\n+            let prefix = prefix.len() as u64;\n+            let suffix = suffix.len() as u64;\n             if slice.is_some() {\n-                Some((pat_len..pcx.max_slice_length + 1).map(Slice).collect())\n+                Some(VarLenSlice(prefix, suffix))\n             } else {\n-                Some(vec![Slice(pat_len)])\n+                Some(FixedLenSlice(prefix + suffix))\n             }\n         }\n         PatKind::Or { .. } => {\n@@ -1728,68 +1769,6 @@ fn pat_constructors<'tcx>(\n     }\n }\n \n-/// This computes the types of the sub patterns that a constructor should be\n-/// expanded to.\n-///\n-/// For instance, a tuple pattern (43u32, 'a') has sub pattern types [u32, char].\n-fn constructor_sub_pattern_tys<'a, 'tcx>(\n-    cx: &MatchCheckCtxt<'a, 'tcx>,\n-    ctor: &Constructor<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Vec<Ty<'tcx>> {\n-    debug!(\"constructor_sub_pattern_tys({:#?}, {:?})\", ctor, ty);\n-    match ty.kind {\n-        ty::Tuple(ref fs) => fs.into_iter().map(|t| t.expect_ty()).collect(),\n-        ty::Slice(ty) | ty::Array(ty, _) => match *ctor {\n-            Slice(length) => (0..length).map(|_| ty).collect(),\n-            ConstantValue(..) => vec![],\n-            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty),\n-        },\n-        ty::Ref(_, rty, _) => vec![rty],\n-        ty::Adt(adt, substs) => {\n-            if adt.is_box() {\n-                // Use T as the sub pattern type of Box<T>.\n-                vec![substs.type_at(0)]\n-            } else {\n-                let variant = &adt.variants[ctor.variant_index_for_adt(cx, adt)];\n-                let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n-                variant\n-                    .fields\n-                    .iter()\n-                    .map(|field| {\n-                        let is_visible =\n-                            adt.is_enum() || field.vis.is_accessible_from(cx.module, cx.tcx);\n-                        let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n-                        match (is_visible, is_non_exhaustive, is_uninhabited) {\n-                            // Treat all uninhabited types in non-exhaustive variants as `TyErr`.\n-                            (_, true, true) => cx.tcx.types.err,\n-                            // Treat all non-visible fields as `TyErr`. They can't appear in any\n-                            // other pattern from this match (because they are private), so their\n-                            // type does not matter - but we don't want to know they are\n-                            // uninhabited.\n-                            (false, ..) => cx.tcx.types.err,\n-                            (true, ..) => {\n-                                let ty = field.ty(cx.tcx, substs);\n-                                match ty.kind {\n-                                    // If the field type returned is an array of an unknown size\n-                                    // return an TyErr.\n-                                    ty::Array(_, len)\n-                                        if len.try_eval_usize(cx.tcx, cx.param_env).is_none() =>\n-                                    {\n-                                        cx.tcx.types.err\n-                                    }\n-                                    _ => ty,\n-                                }\n-                            }\n-                        }\n-                    })\n-                    .collect()\n-            }\n-        }\n-        _ => vec![],\n-    }\n-}\n-\n // checks whether a constant is equal to a user-written slice pattern. Only supports byte slices,\n // meaning all other types will compare unequal and thus equal patterns often do not cause the\n // second pattern to lint about unreachable match arms.\n@@ -1900,21 +1879,22 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>)\n ///\n /// `hir_id` is `None` when we're evaluating the wildcard pattern, do not lint for overlapping in\n /// ranges that case.\n+///\n+/// This also splits variable-length slices into fixed-length slices.\n fn split_grouped_constructors<'p, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n+    pcx: PatCtxt<'tcx>,\n     ctors: Vec<Constructor<'tcx>>,\n     matrix: &Matrix<'p, 'tcx>,\n-    ty: Ty<'tcx>,\n     span: Span,\n     hir_id: Option<HirId>,\n ) -> Vec<Constructor<'tcx>> {\n+    let ty = pcx.ty;\n     let mut split_ctors = Vec::with_capacity(ctors.len());\n \n     for ctor in ctors.into_iter() {\n         match ctor {\n-            // For now, only ranges may denote groups of \"subconstructors\", so we only need to\n-            // special-case constant ranges.\n             ConstantRange(..) if should_treat_range_exhaustively(tcx, &ctor) => {\n                 // We only care about finding all the subranges within the range of the constructor\n                 // range. Anything else is irrelevant, because it is guaranteed to result in\n@@ -1996,6 +1976,121 @@ fn split_grouped_constructors<'p, 'tcx>(\n                     split_ctors.push(IntRange::range_to_ctor(tcx, ty, range, span));\n                 }\n             }\n+            VarLenSlice(self_prefix, self_suffix) => {\n+                // The exhaustiveness-checking paper does not include any details on\n+                // checking variable-length slice patterns. However, they are matched\n+                // by an infinite collection of fixed-length array patterns.\n+                //\n+                // Checking the infinite set directly would take an infinite amount\n+                // of time. However, it turns out that for each finite set of\n+                // patterns `P`, all sufficiently large array lengths are equivalent:\n+                //\n+                // Each slice `s` with a \"sufficiently-large\" length `l \u2265 L` that applies\n+                // to exactly the subset `P\u209c` of `P` can be transformed to a slice\n+                // `s\u2098` for each sufficiently-large length `m` that applies to exactly\n+                // the same subset of `P`.\n+                //\n+                // Because of that, each witness for reachability-checking from one\n+                // of the sufficiently-large lengths can be transformed to an\n+                // equally-valid witness from any other length, so we only have\n+                // to check slice lengths from the \"minimal sufficiently-large length\"\n+                // and below.\n+                //\n+                // Note that the fact that there is a *single* `s\u2098` for each `m`\n+                // not depending on the specific pattern in `P` is important: if\n+                // you look at the pair of patterns\n+                //     `[true, ..]`\n+                //     `[.., false]`\n+                // Then any slice of length \u22651 that matches one of these two\n+                // patterns can be trivially turned to a slice of any\n+                // other length \u22651 that matches them and vice-versa - for\n+                // but the slice from length 2 `[false, true]` that matches neither\n+                // of these patterns can't be turned to a slice from length 1 that\n+                // matches neither of these patterns, so we have to consider\n+                // slices from length 2 there.\n+                //\n+                // Now, to see that that length exists and find it, observe that slice\n+                // patterns are either \"fixed-length\" patterns (`[_, _, _]`) or\n+                // \"variable-length\" patterns (`[_, .., _]`).\n+                //\n+                // For fixed-length patterns, all slices with lengths *longer* than\n+                // the pattern's length have the same outcome (of not matching), so\n+                // as long as `L` is greater than the pattern's length we can pick\n+                // any `s\u2098` from that length and get the same result.\n+                //\n+                // For variable-length patterns, the situation is more complicated,\n+                // because as seen above the precise value of `s\u2098` matters.\n+                //\n+                // However, for each variable-length pattern `p` with a prefix of length\n+                // `pl\u209a` and suffix of length `sl\u209a`, only the first `pl\u209a` and the last\n+                // `sl\u209a` elements are examined.\n+                //\n+                // Therefore, as long as `L` is positive (to avoid concerns about empty\n+                // types), all elements after the maximum prefix length and before\n+                // the maximum suffix length are not examined by any variable-length\n+                // pattern, and therefore can be added/removed without affecting\n+                // them - creating equivalent patterns from any sufficiently-large\n+                // length.\n+                //\n+                // Of course, if fixed-length patterns exist, we must be sure\n+                // that our length is large enough to miss them all, so\n+                // we can pick `L = max(max(FIXED_LEN)+1, max(PREFIX_LEN) + max(SUFFIX_LEN))`\n+                //\n+                // for example, with the above pair of patterns, all elements\n+                // but the first and last can be added/removed, so any\n+                // witness of length \u22652 (say, `[false, false, true]`) can be\n+                // turned to a witness from any other length \u22652.\n+\n+                let mut max_prefix_len = self_prefix;\n+                let mut max_suffix_len = self_suffix;\n+                let mut max_fixed_len = 0;\n+\n+                for row in matrix.heads() {\n+                    match *row.kind {\n+                        PatKind::Constant { value } => {\n+                            // extract the length of an array/slice from a constant\n+                            match (value.val, &value.ty.kind) {\n+                                (_, ty::Array(_, n)) => {\n+                                    max_fixed_len =\n+                                        cmp::max(max_fixed_len, n.eval_usize(tcx, param_env))\n+                                }\n+                                (ConstValue::Slice { start, end, .. }, ty::Slice(_)) => {\n+                                    max_fixed_len = cmp::max(max_fixed_len, (end - start) as u64)\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+                        PatKind::Slice { ref prefix, slice: None, ref suffix } => {\n+                            let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n+                            max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n+                        }\n+                        PatKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n+                            max_prefix_len = cmp::max(max_prefix_len, prefix.len() as u64);\n+                            max_suffix_len = cmp::max(max_suffix_len, suffix.len() as u64);\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+\n+                // For diagnostics, we keep the prefix and suffix lengths separate, so in the case\n+                // where `max_fixed_len + 1` is the largest, we adapt `max_prefix_len` accordingly,\n+                // so that `L = max_prefix_len + max_suffix_len`.\n+                if max_fixed_len + 1 >= max_prefix_len + max_suffix_len {\n+                    // The subtraction can't overflow thanks to the above check.\n+                    // The new `max_prefix_len` is also guaranteed to be larger than its previous\n+                    // value.\n+                    max_prefix_len = max_fixed_len + 1 - max_suffix_len;\n+                }\n+\n+                // `ctor` originally covered the range `(self_prefix + self_suffix..infinity)`. We\n+                // now split it into two: lengths smaller than `max_prefix_len + max_suffix_len`\n+                // are treated independently as fixed-lengths slices, and lengths above are\n+                // captured by a final VarLenSlice constructor.\n+                split_ctors.extend(\n+                    (self_prefix + self_suffix..max_prefix_len + max_suffix_len).map(FixedLenSlice),\n+                );\n+                split_ctors.push(VarLenSlice(max_prefix_len, max_suffix_len));\n+            }\n             // Any other constructor can be used unchanged.\n             _ => split_ctors.push(ctor),\n         }\n@@ -2238,7 +2333,7 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n \n         PatKind::Array { ref prefix, ref slice, ref suffix }\n         | PatKind::Slice { ref prefix, ref slice, ref suffix } => match *constructor {\n-            Slice(..) => {\n+            FixedLenSlice(..) | VarLenSlice(..) => {\n                 let pat_len = prefix.len() + suffix.len();\n                 if let Some(slice_count) = ctor_wild_subpatterns.len().checked_sub(pat_len) {\n                     if slice_count == 0 || slice.is_some() {"}, {"sha": "ffb3ae44ae1e95a16238459b74d429b73ead8755", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "patch": "@@ -18,7 +18,7 @@ use rustc::hir::{self, Pat};\n \n use std::slice;\n \n-use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n+use syntax_pos::{MultiSpan, Span};\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match tcx.hir().as_local_hir_id(def_id) {\n@@ -491,7 +491,7 @@ fn check_not_useful(\n     matrix: &Matrix<'_, 'tcx>,\n     hir_id: HirId,\n ) -> Result<(), Vec<super::Pat<'tcx>>> {\n-    let wild_pattern = super::Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild };\n+    let wild_pattern = super::Pat::wildcard_from_ty(ty);\n     match is_useful(cx, matrix, &PatStack::from_pattern(&wild_pattern), ConstructWitness, hir_id) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n         UsefulWithWitness(pats) => Err(if pats.is_empty() {"}, {"sha": "f613f6f4b99b90a840fb19fe03cbd44adc0bb8f3", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "patch": "@@ -26,7 +26,7 @@ use rustc_index::vec::Idx;\n use std::cmp::Ordering;\n use std::fmt;\n use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Clone, Debug)]\n pub enum PatternError {\n@@ -55,6 +55,11 @@ pub struct Pat<'tcx> {\n     pub kind: Box<PatKind<'tcx>>,\n }\n \n+impl<'tcx> Pat<'tcx> {\n+    pub(crate) fn wildcard_from_ty(ty: Ty<'tcx>) -> Self {\n+        Pat { ty, span: DUMMY_SP, kind: Box::new(PatKind::Wild) }\n+    }\n+}\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n pub struct PatTyProj<'tcx> {"}, {"sha": "9acb4ad9cbbe5e4c3f8c4616de1b5546c5f8c11b", "filename": "src/test/ui/consts/const_let_refutable.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_refutable.stderr?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in function argument: `&[]`, `&[_]` and `&[_, _, _]` not covered\n+error[E0005]: refutable pattern in function argument: `&[]`, `&[_]` and `&[_, _, _, ..]` not covered\n   --> $DIR/const_let_refutable.rs:3:16\n    |\n LL | const fn slice([a, b]: &[i32]) -> i32 {\n-   |                ^^^^^^ patterns `&[]`, `&[_]` and `&[_, _, _]` not covered\n+   |                ^^^^^^ patterns `&[]`, `&[_]` and `&[_, _, _, ..]` not covered\n \n error[E0723]: can only call other `const fn` within a `const fn`, but `const <&i32 as std::ops::Add>::add` is not stable as `const fn`\n   --> $DIR/const_let_refutable.rs:4:5"}, {"sha": "6e52072e3bfec7f91f6ec8f34307b0c09d289b08", "filename": "src/test/ui/pattern/usefulness/match-byte-array-patterns-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "patch": "@@ -6,11 +6,11 @@ LL |     match buf {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: `&[]`, `&[_]`, `&[_, _]` and 3 more not covered\n+error[E0004]: non-exhaustive patterns: `&[..]` not covered\n   --> $DIR/match-byte-array-patterns-2.rs:10:11\n    |\n LL |     match buf {\n-   |           ^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 3 more not covered\n+   |           ^^^ pattern `&[..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "af7fd53a1f1e916dc505338cf469b4183ae8a094", "filename": "src/test/ui/pattern/usefulness/match-slice-patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-slice-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-slice-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-slice-patterns.rs?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "patch": "@@ -2,7 +2,7 @@\n \n fn check(list: &[Option<()>]) {\n     match list {\n-    //~^ ERROR `&[_, Some(_), None, _]` not covered\n+    //~^ ERROR `&[_, Some(_), .., None, _]` not covered\n         &[] => {},\n         &[_] => {},\n         &[_, _] => {},"}, {"sha": "72ae5d5fe3b33e172a1a499ee984a3d1ecc2c149", "filename": "src/test/ui/pattern/usefulness/match-slice-patterns.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-slice-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-slice-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-slice-patterns.stderr?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `&[_, Some(_), None, _]` not covered\n+error[E0004]: non-exhaustive patterns: `&[_, Some(_), .., None, _]` not covered\n   --> $DIR/match-slice-patterns.rs:4:11\n    |\n LL |     match list {\n-   |           ^^^^ pattern `&[_, Some(_), None, _]` not covered\n+   |           ^^^^ pattern `&[_, Some(_), .., None, _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "bfca5352353a7c0c6ad724bc0bb3e8d438f5a391", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "patch": "@@ -44,7 +44,7 @@ fn main() {\n     }\n     let vec = vec![0.5f32];\n     let vec: &[f32] = &vec;\n-    match *vec { //~ ERROR non-exhaustive patterns: `[_, _, _, _]` not covered\n+    match *vec { //~ ERROR non-exhaustive patterns: `[_, _, _, _, ..]` not covered\n         [0.1, 0.2, 0.3] => (),\n         [0.1, 0.2] => (),\n         [0.1] => (),"}, {"sha": "577867e4e712294025aaff2a88e562aa05f35538", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "patch": "@@ -66,11 +66,11 @@ LL |     match *vec {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: `[_, _, _, _]` not covered\n+error[E0004]: non-exhaustive patterns: `[_, _, _, _, ..]` not covered\n   --> $DIR/non-exhaustive-match.rs:47:11\n    |\n LL |     match *vec {\n-   |           ^^^^ pattern `[_, _, _, _]` not covered\n+   |           ^^^^ pattern `[_, _, _, _, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "a36c550f530a9a0f90113cb0f112b4db701a1532", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.rs?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "previous_filename": "src/test/ui/pattern/slice-pattern-const-2.rs"}, {"sha": "0c7401269dfc744c3f4ac02dee90ff2b4a4e4f0a", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const-2.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.stderr?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "previous_filename": "src/test/ui/pattern/slice-pattern-const-2.stderr"}, {"sha": "8805c43ba0283bdabe7f46093ee46b6be341470b", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const-3.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.rs?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "previous_filename": "src/test/ui/pattern/slice-pattern-const-3.rs"}, {"sha": "eab4fc3f086dafb847c04efa0293d64d9d3cc36c", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const-3.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.stderr?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "previous_filename": "src/test/ui/pattern/slice-pattern-const-3.stderr"}, {"sha": "f0a04513f91fb71d11cc68154225df0c0ed10176", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const.rs?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "previous_filename": "src/test/ui/pattern/slice-pattern-const.rs"}, {"sha": "2dd10a0478ab995d29a6ad369663cdda6576a03b", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const.stderr?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "previous_filename": "src/test/ui/pattern/slice-pattern-const.stderr"}, {"sha": "86cdf160618bf32bf64f3c64e18a1b5fecdc1ccb", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "patch": "@@ -0,0 +1,75 @@\n+#![feature(slice_patterns)]\n+\n+fn main() {\n+    let s: &[bool] = &[true; 0];\n+    let s1: &[bool; 1] = &[false; 1];\n+    let s2: &[bool; 2] = &[false; 2];\n+    let s3: &[bool; 3] = &[false; 3];\n+\n+    match s1 {\n+        [true, ..] => {}\n+        [.., false] => {}\n+    }\n+    match s2 {\n+    //~^ ERROR `&[false, true]` not covered\n+        [true, ..] => {}\n+        [.., false] => {}\n+    }\n+    match s3 {\n+    //~^ ERROR `&[false, _, true]` not covered\n+        [true, ..] => {}\n+        [.., false] => {}\n+    }\n+    match s {\n+    //~^ ERROR `&[false, .., true]` not covered\n+        [] => {}\n+        [true, ..] => {}\n+        [.., false] => {}\n+    }\n+\n+    match s3 {\n+    //~^ ERROR `&[false, _, _]` not covered\n+        [true, .., true] => {}\n+    }\n+    match s {\n+    //~^ ERROR `&[_, ..]` not covered\n+        [] => {}\n+    }\n+    match s {\n+    //~^ ERROR `&[_, _, ..]` not covered\n+        [] => {}\n+        [_] => {}\n+    }\n+    match s {\n+    //~^ ERROR `&[false, ..]` not covered\n+        [] => {}\n+        [true, ..] => {}\n+    }\n+    match s {\n+    //~^ ERROR `&[false, _, ..]` not covered\n+        [] => {}\n+        [_] => {}\n+        [true, ..] => {}\n+    }\n+    match s {\n+    //~^ ERROR `&[_, .., false]` not covered\n+        [] => {}\n+        [_] => {}\n+        [.., true] => {}\n+    }\n+\n+    match s {\n+    //~^ ERROR `&[_, _, .., true]` not covered\n+        [] => {}\n+        [_] => {}\n+        [_, _] => {}\n+        [.., false] => {}\n+    }\n+    match s {\n+    //~^ ERROR `&[true, _, .., _]` not covered\n+        [] => {}\n+        [_] => {}\n+        [_, _] => {}\n+        [false, .., false] => {}\n+    }\n+}"}, {"sha": "1391b520556dccb114f6ac6c8ec1432f9291eddf", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.stderr", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "patch": "@@ -0,0 +1,91 @@\n+error[E0004]: non-exhaustive patterns: `&[false, true]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:13:11\n+   |\n+LL |     match s2 {\n+   |           ^^ pattern `&[false, true]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[false, _, true]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:18:11\n+   |\n+LL |     match s3 {\n+   |           ^^ pattern `&[false, _, true]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[false, .., true]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:23:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[false, .., true]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[false, _, _]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:30:11\n+   |\n+LL |     match s3 {\n+   |           ^^ pattern `&[false, _, _]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[_, ..]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:34:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[_, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[_, _, ..]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:38:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[_, _, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[false, ..]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:43:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[false, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[false, _, ..]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:48:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[false, _, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[_, .., false]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:54:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[_, .., false]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[_, _, .., true]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:61:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[_, _, .., true]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[true, _, .., _]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:68:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[true, _, .., _]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error: aborting due to 11 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "3b716bae7720942840a4e49fda5c1e7b74d382cb", "filename": "src/test/ui/pattern/usefulness/slice-patterns-irrefutable.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-irrefutable.rs?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "patch": "@@ -0,0 +1,27 @@\n+// check-pass\n+#![feature(slice_patterns)]\n+\n+fn main() {\n+    let s: &[bool] = &[true; 0];\n+    let s0: &[bool; 0] = &[];\n+    let s1: &[bool; 1] = &[false; 1];\n+    let s2: &[bool; 2] = &[false; 2];\n+\n+    let [] = s0;\n+    let [_] = s1;\n+    let [_, _] = s2;\n+\n+    let [..] = s;\n+    let [..] = s0;\n+    let [..] = s1;\n+    let [..] = s2;\n+\n+    let [_, ..] = s1;\n+    let [.., _] = s1;\n+    let [_, ..] = s2;\n+    let [.., _] = s2;\n+\n+    let [_, _, ..] = s2;\n+    let [_, .., _] = s2;\n+    let [.., _, _] = s2;\n+}"}, {"sha": "35d9dc91aee1ce001e1590259aa5bbb38ee31335", "filename": "src/test/ui/pattern/usefulness/slice-patterns-reachability.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-reachability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-reachability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-reachability.rs?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "patch": "@@ -0,0 +1,26 @@\n+#![feature(slice_patterns)]\n+#![deny(unreachable_patterns)]\n+\n+fn main() {\n+    let s: &[bool] = &[true; 0];\n+\n+    match s {\n+        [true, ..] => {}\n+        [true, ..] => {} //~ ERROR unreachable pattern\n+        [true] => {} //~ ERROR unreachable pattern\n+        [..] => {}\n+    }\n+    match s {\n+        [.., true] => {}\n+        [.., true] => {} //~ ERROR unreachable pattern\n+        [true] => {} //~ ERROR unreachable pattern\n+        [..] => {}\n+    }\n+    match s {\n+        [false, .., true] => {}\n+        [false, .., true] => {} //~ ERROR unreachable pattern\n+        [false, true] => {} //~ ERROR unreachable pattern\n+        [false] => {}\n+        [..] => {}\n+    }\n+}"}, {"sha": "333ce170283eaa069a92f44d337e81baa14e8605", "filename": "src/test/ui/pattern/usefulness/slice-patterns-reachability.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-reachability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-reachability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-reachability.stderr?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "patch": "@@ -0,0 +1,44 @@\n+error: unreachable pattern\n+  --> $DIR/slice-patterns-reachability.rs:9:9\n+   |\n+LL |         [true, ..] => {}\n+   |         ^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/slice-patterns-reachability.rs:2:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-patterns-reachability.rs:10:9\n+   |\n+LL |         [true] => {}\n+   |         ^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-patterns-reachability.rs:15:9\n+   |\n+LL |         [.., true] => {}\n+   |         ^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-patterns-reachability.rs:16:9\n+   |\n+LL |         [true] => {}\n+   |         ^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-patterns-reachability.rs:21:9\n+   |\n+LL |         [false, .., true] => {}\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-patterns-reachability.rs:22:9\n+   |\n+LL |         [false, true] => {}\n+   |         ^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "7af6075262c6db9e75b3ec2ea39ef04d0ac86022", "filename": "src/test/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3d998492abd7d61aba12cfa058fce28c998a3ff/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=e3d998492abd7d61aba12cfa058fce28c998a3ff", "patch": "@@ -30,11 +30,11 @@ LL |     let _ = match x {};\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: `&[_]` not covered\n+error[E0004]: non-exhaustive patterns: `&[_, ..]` not covered\n   --> $DIR/uninhabited-matches-feature-gated.rs:21:19\n    |\n LL |     let _ = match x {\n-   |                   ^ pattern `&[_]` not covered\n+   |                   ^ pattern `&[_, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}]}