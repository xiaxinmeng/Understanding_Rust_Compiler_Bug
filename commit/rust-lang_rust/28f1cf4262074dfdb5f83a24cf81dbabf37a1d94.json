{"sha": "28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZjFjZjQyNjIwNzRkZmRiNWY4M2EyNGNmODFkYmFiZjM3YTFkOTQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-11T17:26:13Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T15:07:59Z"}, "message": "rustc_typeck: don't use Result for get_type_parameter_bounds and ensure_super_predicates.", "tree": {"sha": "eb08a6f97fb3ce683172b1af0150cdde4ae1cf23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb08a6f97fb3ce683172b1af0150cdde4ae1cf23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "html_url": "https://github.com/rust-lang/rust/commit/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4649f7387ea334901c78dd48c1e1659ecf80cfcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4649f7387ea334901c78dd48c1e1659ecf80cfcc", "html_url": "https://github.com/rust-lang/rust/commit/4649f7387ea334901c78dd48c1e1659ecf80cfcc"}], "stats": {"total": 561, "additions": 266, "deletions": 295}, "files": [{"sha": "769c08a81efa62cea6c3e761a526d033fc064d32", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -109,6 +109,7 @@ pub enum DepNode<D: Clone + Debug> {\n     // predicates for an item wind up in `ItemSignature`).\n     AssociatedItems(D),\n     ItemSignature(D),\n+    TypeParamPredicates((D, D)),\n     SizedConstraint(D),\n     AssociatedItemDefIds(D),\n     InherentImpls(D),\n@@ -259,6 +260,9 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n             AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n+            TypeParamPredicates((ref item, ref param)) => {\n+                Some(TypeParamPredicates((try_opt!(op(item)), try_opt!(op(param)))))\n+            }\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n             AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),"}, {"sha": "458a774c95645ce1449a5d86e2708e0b7c24abb8", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -1390,6 +1390,23 @@ error. To resolve it, add an `else` block having the same type as the `if`\n block.\n \"##,\n \n+E0391: r##\"\n+This error indicates that some types or traits depend on each other\n+and therefore cannot be constructed.\n+\n+The following example contains a circular dependency between two traits:\n+\n+```compile_fail,E0391\n+trait FirstTrait : SecondTrait {\n+\n+}\n+\n+trait SecondTrait : FirstTrait {\n+\n+}\n+```\n+\"##,\n+\n E0398: r##\"\n In Rust 1.3, the default object lifetime bounds are expected to change, as\n described in RFC #1156 [1]. You are getting a warning because the compiler"}, {"sha": "13b786541c50275bac835cdd36661cb90e1e0cb7", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -437,6 +437,30 @@ impl<'hir> Map<'hir> {\n         self.local_def_id(self.body_owner(id))\n     }\n \n+    pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n+        match self.get(id) {\n+            NodeItem(&Item { node: ItemTrait(..), .. }) => id,\n+            NodeTyParam(_) => self.get_parent_node(id),\n+            _ => {\n+                bug!(\"ty_param_owner: {} not a type parameter\",\n+                    self.node_to_string(id))\n+            }\n+        }\n+    }\n+\n+    pub fn ty_param_name(&self, id: NodeId) -> Name {\n+        match self.get(id) {\n+            NodeItem(&Item { node: ItemTrait(..), .. }) => {\n+                keywords::SelfType.name()\n+            }\n+            NodeTyParam(tp) => tp.name,\n+            _ => {\n+                bug!(\"ty_param_name: {} not a type parameter\",\n+                    self.node_to_string(id))\n+            }\n+        }\n+    }\n+\n     /// Get the attributes on the krate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access."}, {"sha": "60d03ccfe240d9b08fd090c47bda34acaf39fe91", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -39,6 +39,7 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n+#![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n "}, {"sha": "dc87bb43c265de81ae688a6885b4d11d3e579813", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 95, "deletions": 2, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -20,6 +20,7 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use std::cell::RefCell;\n use std::rc::Rc;\n use syntax::attr;\n+use syntax_pos::Span;\n \n trait Key {\n     fn map_crate(&self) -> CrateNum;\n@@ -31,13 +32,105 @@ impl Key for DefId {\n     }\n }\n \n+impl Key for (DefId, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+}\n+\n+trait Value<'tcx>: Sized {\n+    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n+}\n+\n+impl<'tcx, T> Value<'tcx> for T {\n+    default fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> T {\n+        tcx.sess.abort_if_errors();\n+        bug!(\"Value::from_cycle_error called without errors\");\n+    }\n+}\n+\n+impl<'tcx, T: Default> Value<'tcx> for T {\n+    default fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> T {\n+        T::default()\n+    }\n+}\n+\n+impl<'tcx> Value<'tcx> for Ty<'tcx> {\n+    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+        tcx.types.err\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    fn report_cycle(self, span: Span, cycle: &[(Span, Query)]) {\n+        assert!(!cycle.is_empty());\n+\n+        let mut err = struct_span_err!(self.sess, span, E0391,\n+            \"unsupported cyclic reference between types/traits detected\");\n+        err.span_label(span, &format!(\"cyclic reference\"));\n+\n+        err.span_note(cycle[0].0, &format!(\"the cycle begins when {}...\",\n+                                           cycle[0].1.describe(self)));\n+\n+        for &(span, ref query) in &cycle[1..] {\n+            err.span_note(span, &format!(\"...which then requires {}...\",\n+                                         query.describe(self)));\n+        }\n+\n+        err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n+                          cycle[0].1.describe(self)));\n+\n+        err.emit();\n+    }\n+\n+    pub fn cycle_check<F, R>(self, span: Span, query: Query, compute: F) -> R\n+        where F: FnOnce() -> R\n+    {\n+        {\n+            let mut stack = self.maps.query_stack.borrow_mut();\n+            if let Some((i, _)) = stack.iter().enumerate().rev()\n+                                       .find(|&(_, &(_, ref q))| *q == query) {\n+                let cycle = &stack[i..];\n+                self.report_cycle(span, cycle);\n+                return R::from_cycle_error(self.global_tcx());\n+            }\n+            stack.push((span, query));\n+        }\n+\n+        let result = compute();\n+\n+        self.maps.query_stack.borrow_mut().pop();\n+        result\n+    }\n+}\n+\n+impl Query {\n+    fn describe(&self, tcx: TyCtxt) -> String {\n+        match *self {\n+            Query::ty(def_id) => {\n+                format!(\"processing `{}`\", tcx.item_path_str(def_id))\n+            }\n+            Query::super_predicates(def_id) => {\n+                format!(\"computing the supertraits of `{}`\",\n+                        tcx.item_path_str(def_id))\n+            }\n+            Query::type_param_predicates((_, def_id)) => {\n+                let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+                format!(\"computing the bounds for type parameter `{}`\",\n+                        tcx.hir.ty_param_name(id))\n+            }\n+            _ => bug!(\"unexpected `{:?}`\", self)\n+        }\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n        pub $name:ident: $node:ident($K:ty) -> $V:ty),*) => {\n         pub struct Maps<$tcx> {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n-            pub query_stack: RefCell<Vec<Query>>,\n+            pub query_stack: RefCell<Vec<(Span, Query)>>,\n             $($(#[$attr])* pub $name: RefCell<DepTrackingMap<queries::$name<$tcx>>>),*\n         }\n \n@@ -129,7 +222,7 @@ define_maps! { <'tcx>\n \n     /// To avoid cycles within the predicates of a single item we compute\n     /// per-type-parameter predicates for resolving `T::AssocTy`.\n-    pub type_param_predicates: ItemSignature(DefId)\n+    pub type_param_predicates: TypeParamPredicates((DefId, DefId))\n         -> ty::GenericPredicates<'tcx>,\n \n     pub trait_def: ItemSignature(DefId) -> &'tcx ty::TraitDef,"}, {"sha": "9d4e17138a042d537818226507620908246a444f", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -669,7 +669,7 @@ impl Generics {\n }\n \n /// Bounds on generics.\n-#[derive(Clone)]\n+#[derive(Clone, Default)]\n pub struct GenericPredicates<'tcx> {\n     pub parent: Option<DefId>,\n     pub predicates: Vec<Predicate<'tcx>>,"}, {"sha": "ef0dcd4c774dd933ba2a4a24e66ac3439d9f0926", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 20, "deletions": 36, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -64,13 +64,12 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// Ensure that the super-predicates for the trait with the given\n     /// id are available and also for the transitive set of\n     /// super-predicates.\n-    fn ensure_super_predicates(&self, span: Span, id: DefId)\n-                               -> Result<(), ErrorReported>;\n+    fn ensure_super_predicates(&self, span: Span, id: DefId);\n \n     /// Returns the set of bounds in scope for the type parameter with\n     /// the given id.\n-    fn get_type_parameter_bounds(&self, span: Span, def_id: ast::NodeId)\n-                                 -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>;\n+    fn get_type_parameter_bounds(&self, span: Span, def_id: DefId)\n+                                 -> Vec<ty::Predicate<'tcx>>;\n \n     /// Return an (optional) substitution to convert bound type parameters that\n     /// are in scope into free ones. This function should only return Some\n@@ -599,7 +598,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // Otherwise, we have to walk through the supertraits to find\n         // those that do.\n-        self.ensure_super_predicates(binding.span, trait_ref.def_id())?;\n+        self.ensure_super_predicates(binding.span, trait_ref.def_id());\n \n         let candidates =\n             traits::supertraits(tcx, trait_ref.clone())\n@@ -685,10 +684,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             })\n         });\n \n-        // ensure the super predicates and stop if we encountered an error\n-        if self.ensure_super_predicates(span, principal.def_id()).is_err() {\n-            return tcx.types.err;\n-        }\n+        // ensure the super predicates\n+        self.ensure_super_predicates(span, principal.def_id());\n \n         // check that there are no gross object safety violations,\n         // most importantly, that the supertraits don't contain Self,\n@@ -774,29 +771,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     // Search for a bound on a type parameter which includes the associated item\n-    // given by assoc_name. ty_param_node_id is the node id for the type parameter\n-    // (which might be `Self`, but only if it is the `Self` of a trait, not an\n-    // impl). This function will fail if there are no suitable bounds or there is\n+    // given by `assoc_name`. `ty_param_def_id` is the `DefId` for the type parameter\n+    // This function will fail if there are no suitable bounds or there is\n     // any ambiguity.\n     fn find_bound_for_assoc_item(&self,\n-                                 ty_param_node_id: ast::NodeId,\n-                                 ty_param_name: ast::Name,\n+                                 ty_param_def_id: DefId,\n                                  assoc_name: ast::Name,\n                                  span: Span)\n                                  -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n     {\n         let tcx = self.tcx();\n \n-        let bounds = match self.get_type_parameter_bounds(span, ty_param_node_id) {\n-            Ok(v) => v,\n-            Err(ErrorReported) => {\n-                return Err(ErrorReported);\n-            }\n-        };\n+        let bounds: Vec<_> = self.get_type_parameter_bounds(span, ty_param_def_id)\n+            .into_iter().filter_map(|p| p.to_opt_poly_trait_ref()).collect();\n \n-        // Ensure the super predicates and stop if we encountered an error.\n-        if bounds.iter().any(|b| self.ensure_super_predicates(span, b.def_id()).is_err()) {\n-            return Err(ErrorReported);\n+        // Ensure the super predicates.\n+        for b in &bounds {\n+            self.ensure_super_predicates(span, b.def_id());\n         }\n \n         // Check that there is exactly one way to find an associated type with the\n@@ -805,8 +796,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             traits::transitive_bounds(tcx, &bounds)\n             .filter(|b| self.trait_defines_associated_type_named(b.def_id(), assoc_name));\n \n+        let param_node_id = tcx.hir.as_local_node_id(ty_param_def_id).unwrap();\n+        let param_name = tcx.hir.ty_param_name(param_node_id);\n         self.one_bound_for_assoc_type(suitable_bounds,\n-                                      &ty_param_name.as_str(),\n+                                      &param_name.as_str(),\n                                       &assoc_name.as_str(),\n                                       span)\n     }\n@@ -914,9 +907,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     trait_ref\n                 };\n \n-                if self.ensure_super_predicates(span, trait_ref.def_id).is_err() {\n-                    return (tcx.types.err, Def::Err);\n-                }\n+                self.ensure_super_predicates(span, trait_ref.def_id);\n \n                 let candidates =\n                     traits::supertraits(tcx, ty::Binder(trait_ref))\n@@ -933,12 +924,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             (&ty::TyParam(_), Def::SelfTy(Some(param_did), None)) |\n             (&ty::TyParam(_), Def::TyParam(param_did)) => {\n-                let param_node_id = tcx.hir.as_local_node_id(param_did).unwrap();\n-                let param_name = ::ty_param_name(tcx, param_node_id);\n-                match self.find_bound_for_assoc_item(param_node_id,\n-                                                     param_name,\n-                                                     assoc_name,\n-                                                     span) {\n+                match self.find_bound_for_assoc_item(param_did, assoc_name, span) {\n                     Ok(bound) => bound,\n                     Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n@@ -1375,9 +1361,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                existential_predicates);\n \n         if let Some(principal) = existential_predicates.principal() {\n-            if let Err(ErrorReported) = self.ensure_super_predicates(span, principal.def_id()) {\n-                return Some(tcx.mk_region(ty::ReStatic));\n-            }\n+            self.ensure_super_predicates(span, principal.def_id());\n         }\n \n         // No explicit region bound specified. Therefore, examine trait"}, {"sha": "d2cd766fdf0091211a9d917efd7bb22d90976ba1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 28, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -91,7 +91,7 @@ use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n-use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPolyTraitRef};\n+use rustc::ty::{self, Ty, TyCtxt, Visibility};\n use rustc::ty::{MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n@@ -1366,44 +1366,31 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n         self.tcx().lookup_trait_def(id)\n     }\n \n-    fn ensure_super_predicates(&self, _: Span, _: DefId) -> Result<(), ErrorReported> {\n+    fn ensure_super_predicates(&self, _: Span, _: DefId) {\n         // all super predicates are ensured during collect pass\n-        Ok(())\n     }\n \n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n         Some(&self.parameter_environment.free_substs)\n     }\n \n-    fn get_type_parameter_bounds(&self,\n-                                 _: Span,\n-                                 node_id: ast::NodeId)\n-                                 -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>\n+    fn get_type_parameter_bounds(&self, _: Span, def_id: DefId)\n+                                 -> Vec<ty::Predicate<'tcx>>\n     {\n         let tcx = self.tcx;\n-        let item_id = ::ty_param_owner(tcx, node_id);\n+        let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        let item_id = tcx.hir.ty_param_owner(node_id);\n         let item_def_id = tcx.hir.local_def_id(item_id);\n         let generics = tcx.item_generics(item_def_id);\n-        let index = generics.type_param_to_index[&tcx.hir.local_def_id(node_id).index];\n-        let r = self.parameter_environment\n-                                  .caller_bounds\n-                                  .iter()\n-                                  .filter_map(|predicate| {\n-                                      match *predicate {\n-                                          ty::Predicate::Trait(ref data) => {\n-                                              if data.0.self_ty().is_param(index) {\n-                                                  Some(data.to_poly_trait_ref())\n-                                              } else {\n-                                                  None\n-                                              }\n-                                          }\n-                                          _ => {\n-                                              None\n-                                          }\n-                                      }\n-                                  })\n-                                  .collect();\n-        Ok(r)\n+        let index = generics.type_param_to_index[&def_id.index];\n+        self.parameter_environment.caller_bounds.iter().filter(|predicate| {\n+            match **predicate {\n+                ty::Predicate::Trait(ref data) => {\n+                    data.0.self_ty().is_param(index)\n+                }\n+                _ => false\n+            }\n+        }).cloned().collect()\n     }\n \n     fn re_infer(&self, span: Span, def: Option<&ty::RegionParameterDef>)"}, {"sha": "ff9c1cc7d36563661a872e3b31d52482e31ab900", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 76, "deletions": 181, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -70,7 +70,7 @@ use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContai\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n use rustc::dep_graph::DepNode;\n-use util::common::{ErrorReported, MemoizationMap};\n+use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, FxHashMap};\n \n use rustc_const_math::ConstInt;\n@@ -80,7 +80,7 @@ use std::collections::BTreeMap;\n \n use syntax::{abi, ast, attr};\n use syntax::symbol::{Symbol, keywords};\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir::{self, map as hir_map};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -231,91 +231,6 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n     }\n }\n \n-    fn cycle_check<F,R>(tcx: TyCtxt,\n-                        span: Span,\n-                        query: ty::maps::Query,\n-                        code: F)\n-                        -> Result<R,ErrorReported>\n-        where F: FnOnce() -> Result<R,ErrorReported>\n-    {\n-        {\n-            let mut stack = tcx.maps.query_stack.borrow_mut();\n-            if let Some((i, _)) = stack.iter().enumerate().rev().find(|&(_, q)| *q == query) {\n-                let cycle = &stack[i..];\n-                report_cycle(tcx, span, cycle);\n-                return Err(ErrorReported);\n-            }\n-            stack.push(query);\n-        }\n-\n-        let result = code();\n-\n-        tcx.maps.query_stack.borrow_mut().pop();\n-        result\n-    }\n-\n-    fn report_cycle(tcx: TyCtxt,\n-                    span: Span,\n-                    cycle: &[ty::maps::Query])\n-    {\n-        assert!(!cycle.is_empty());\n-\n-        let mut err = struct_span_err!(tcx.sess, span, E0391,\n-            \"unsupported cyclic reference between types/traits detected\");\n-        err.span_label(span, &format!(\"cyclic reference\"));\n-\n-        let describe = |query: ty::maps::Query| {\n-            match query {\n-                ty::maps::Query::ty(def_id) => {\n-                    format!(\"processing `{}`\", tcx.item_path_str(def_id))\n-                }\n-                ty::maps::Query::super_predicates(def_id) => {\n-                    format!(\"computing the supertraits of `{}`\",\n-                            tcx.item_path_str(def_id))\n-                }\n-                ty::maps::Query::type_param_predicates(def_id) => {\n-                    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-                    format!(\"the cycle begins when computing the bounds \\\n-                             for type parameter `{}`\",\n-                            ::ty_param_name(tcx, id))\n-                }\n-                query => span_bug!(span, \"unexpected `{:?}`\", query)\n-            }\n-        };\n-\n-        err.note(&format!(\"the cycle begins when {}...\",\n-                          describe(cycle[0])));\n-\n-        for &query in &cycle[1..] {\n-            err.note(&format!(\"...which then requires {}...\",\n-                              describe(query)));\n-        }\n-\n-        err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n-                          describe(cycle[0])));\n-\n-        err.emit();\n-    }\n-\n-    /// Ensure that the (transitive) super predicates for\n-    /// `trait_def_id` are available. This will report a cycle error\n-    /// if a trait `X` (transitively) extends itself in some form.\n-    fn ensure_super_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                         span: Span,\n-                                         trait_def_id: DefId)\n-                                         -> Result<(), ErrorReported>\n-    {\n-        cycle_check(tcx, span, ty::maps::Query::super_predicates(trait_def_id), || {\n-            let def_ids = ensure_super_predicates_step(tcx, trait_def_id);\n-\n-            for def_id in def_ids {\n-                ensure_super_predicates(tcx, span, def_id)?;\n-            }\n-\n-            Ok(())\n-        })\n-    }\n-\n impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n     fn to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n         AstConv::ast_ty_to_ty(self, ast_ty)\n@@ -334,9 +249,9 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n \n     fn get_item_type(&self, span: Span, id: DefId) -> Ty<'tcx> {\n-        cycle_check(self.tcx, span, ty::maps::Query::ty(id), || {\n-            Ok(type_of_def_id(self.tcx, id))\n-        }).unwrap_or(self.tcx.types.err)\n+        self.tcx.cycle_check(span, ty::maps::Query::ty(id), || {\n+            type_of_def_id(self.tcx, id)\n+        })\n     }\n \n     fn get_trait_def(&self, def_id: DefId) -> &'tcx ty::TraitDef {\n@@ -349,30 +264,36 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Ensure that the (transitive) super predicates for\n+    /// `trait_def_id` are available. This will report a cycle error\n+    /// if a trait `X` (transitively) extends itself in some form.\n     fn ensure_super_predicates(&self,\n                                span: Span,\n-                               trait_def_id: DefId)\n-                               -> Result<(), ErrorReported>\n-    {\n-        debug!(\"ensure_super_predicates(trait_def_id={:?})\",\n-               trait_def_id);\n+                               trait_def_id: DefId) {\n+        if !trait_def_id.is_local() {\n+            // If this trait comes from an external crate, then all of the\n+            // supertraits it may depend on also must come from external\n+            // crates, and hence all of them already have their\n+            // super-predicates \"converted\" (and available from crate\n+            // meta-data), so there is no need to transitively test them.\n+            return;\n+        }\n \n-        ensure_super_predicates(self.tcx, span, trait_def_id)\n+        self.tcx.maps.super_predicates.memoize(trait_def_id, || {\n+            self.tcx.cycle_check(span, ty::maps::Query::super_predicates(trait_def_id), || {\n+                super_predicates(self.tcx, trait_def_id)\n+            })\n+        });\n     }\n \n     fn get_type_parameter_bounds(&self,\n                                  span: Span,\n-                                 node_id: ast::NodeId)\n-                                 -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>\n+                                 def_id: DefId)\n+                                 -> Vec<ty::Predicate<'tcx>>\n     {\n-        let def_id = self.tcx.hir.local_def_id(node_id);\n-        cycle_check(self.tcx, span, ty::maps::Query::type_param_predicates(def_id), || {\n-            let v = get_type_parameter_bounds(self.tcx, self.item_def_id, node_id)\n-                            .into_iter()\n-                            .filter_map(|p| p.to_opt_poly_trait_ref())\n-                            .collect();\n-            Ok(v)\n-        })\n+        self.tcx.cycle_check(span,\n+            ty::maps::Query::type_param_predicates((self.item_def_id, def_id)),\n+            || get_type_parameter_bounds(self.tcx, self.item_def_id, def_id))\n     }\n \n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n@@ -428,7 +349,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n \n     fn get_type_parameter_bounds<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            item_def_id: DefId,\n-                                           param_id: ast::NodeId)\n+                                           def_id: DefId)\n                                            -> Vec<ty::Predicate<'tcx>>\n     {\n         use rustc::hir::map::*;\n@@ -438,10 +359,12 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         // written inline like `<T:Foo>` or in a where clause like\n         // `where T:Foo`.\n \n-        let param_owner_def_id = tcx.hir.local_def_id(::ty_param_owner(tcx, param_id));\n+        let param_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        let param_owner = tcx.hir.ty_param_owner(param_id);\n+        let param_owner_def_id = tcx.hir.local_def_id(param_owner);\n         let generics = generics_of_def_id(tcx, param_owner_def_id);\n-        let index = generics.type_param_to_index[&tcx.hir.local_def_id(param_id).index];\n-        let ty = tcx.mk_param(index, ::ty_param_name(tcx, param_id));\n+        let index = generics.type_param_to_index[&def_id.index];\n+        let ty = tcx.mk_param(index, tcx.hir.ty_param_name(param_id));\n \n         // Don't look for bounds where the type parameter isn't in scope.\n         let parent = if item_def_id == param_owner_def_id {\n@@ -450,8 +373,9 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n             generics_of_def_id(tcx, item_def_id).parent\n         };\n \n-        let mut results = parent.map_or(vec![], |def_id| {\n-            get_type_parameter_bounds(tcx, def_id, param_id)\n+        let mut results = parent.map_or(vec![], |parent| {\n+            let icx = ItemCtxt::new(tcx, parent);\n+            icx.get_type_parameter_bounds(DUMMY_SP, def_id)\n         });\n \n         let item_node_id = tcx.hir.as_local_node_id(item_def_id).unwrap();\n@@ -706,8 +630,7 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) {\n         hir::ItemTrait(..) => {\n             generics_of_def_id(tcx, def_id);\n             trait_def_of_item(tcx, it);\n-            let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n-                ensure_super_predicates(tcx, it.span, def_id);\n+            icx.ensure_super_predicates(it.span, def_id);\n             predicates_of_item(tcx, it);\n         },\n         hir::ItemStruct(ref struct_def, _) |\n@@ -1025,82 +948,54 @@ fn convert_enum_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n /// Ensures that the super-predicates of the trait with def-id\n-/// trait_def_id are converted and stored. This does NOT ensure that\n-/// the transitive super-predicates are converted; that is the job of\n-/// the `ensure_super_predicates()` method in the `AstConv` impl\n-/// above. Returns a list of trait def-ids that must be ensured as\n-/// well to guarantee that the transitive superpredicates are\n-/// converted.\n-fn ensure_super_predicates_step<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                          trait_def_id: DefId)\n-                                          -> Vec<DefId>\n-{\n-    debug!(\"ensure_super_predicates_step(trait_def_id={:?})\", trait_def_id);\n-\n-    let trait_node_id = if let Some(n) = tcx.hir.as_local_node_id(trait_def_id) {\n-        n\n-    } else {\n-        // If this trait comes from an external crate, then all of the\n-        // supertraits it may depend on also must come from external\n-        // crates, and hence all of them already have their\n-        // super-predicates \"converted\" (and available from crate\n-        // meta-data), so there is no need to transitively test them.\n-        return Vec::new();\n+/// trait_def_id are converted and stored. This also ensures that\n+/// the transitive super-predicates are converted;\n+fn super_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              trait_def_id: DefId)\n+                              -> ty::GenericPredicates<'tcx> {\n+    debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n+    let trait_node_id = tcx.hir.as_local_node_id(trait_def_id).unwrap();\n+\n+    let item = match tcx.hir.get(trait_node_id) {\n+        hir_map::NodeItem(item) => item,\n+        _ => bug!(\"trait_node_id {} is not an item\", trait_node_id)\n     };\n \n-    let superpredicates = tcx.maps.super_predicates.borrow().get(&trait_def_id).cloned();\n-    let superpredicates = superpredicates.unwrap_or_else(|| {\n-        let item = match tcx.hir.get(trait_node_id) {\n-            hir_map::NodeItem(item) => item,\n-            _ => bug!(\"trait_node_id {} is not an item\", trait_node_id)\n-        };\n-\n-        let (generics, bounds) = match item.node {\n-            hir::ItemTrait(_, ref generics, ref supertraits, _) => (generics, supertraits),\n-            _ => span_bug!(item.span,\n-                           \"ensure_super_predicates_step invoked on non-trait\"),\n-        };\n-\n-        let icx = ItemCtxt::new(tcx, trait_def_id);\n-\n-        // Convert the bounds that follow the colon, e.g. `Bar+Zed` in `trait Foo : Bar+Zed`.\n-        let self_param_ty = tcx.mk_self_type();\n-        let superbounds1 = compute_bounds(&icx,\n-                                          self_param_ty,\n-                                          bounds,\n-                                          SizedByDefault::No,\n-                                          item.span);\n-\n-        let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n+    let (generics, bounds) = match item.node {\n+        hir::ItemTrait(_, ref generics, ref supertraits, _) => (generics, supertraits),\n+        _ => span_bug!(item.span,\n+                       \"super_predicates invoked on non-trait\"),\n+    };\n \n-        // Convert any explicit superbounds in the where clause,\n-        // e.g. `trait Foo where Self : Bar`:\n-        let superbounds2 = icx.type_parameter_bounds_in_generics(generics, item.id, self_param_ty);\n+    let icx = ItemCtxt::new(tcx, trait_def_id);\n \n-        // Combine the two lists to form the complete set of superbounds:\n-        let superbounds = superbounds1.into_iter().chain(superbounds2).collect();\n-        let superpredicates = ty::GenericPredicates {\n-            parent: None,\n-            predicates: superbounds\n-        };\n-        debug!(\"superpredicates for trait {:?} = {:?}\",\n-               tcx.hir.local_def_id(item.id),\n-               superpredicates);\n+    // Convert the bounds that follow the colon, e.g. `Bar+Zed` in `trait Foo : Bar+Zed`.\n+    let self_param_ty = tcx.mk_self_type();\n+    let superbounds1 = compute_bounds(&icx,\n+                                      self_param_ty,\n+                                      bounds,\n+                                      SizedByDefault::No,\n+                                      item.span);\n \n-        tcx.maps.super_predicates.borrow_mut().insert(trait_def_id, superpredicates.clone());\n+    let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n \n-        superpredicates\n-    });\n+    // Convert any explicit superbounds in the where clause,\n+    // e.g. `trait Foo where Self : Bar`:\n+    let superbounds2 = icx.type_parameter_bounds_in_generics(generics, item.id, self_param_ty);\n \n-    let def_ids: Vec<_> = superpredicates.predicates\n-                                         .iter()\n-                                         .filter_map(|p| p.to_opt_poly_trait_ref())\n-                                         .map(|tr| tr.def_id())\n-                                         .collect();\n+    // Combine the two lists to form the complete set of superbounds:\n+    let superbounds: Vec<_> = superbounds1.into_iter().chain(superbounds2).collect();\n \n-    debug!(\"ensure_super_predicates_step: def_ids={:?}\", def_ids);\n+    // Now require that immediate supertraits are converted,\n+    // which will, in turn, reach indirect supertraits.\n+    for bound in superbounds.iter().filter_map(|p| p.to_opt_poly_trait_ref()) {\n+        icx.ensure_super_predicates(item.span, bound.def_id());\n+    }\n \n-    def_ids\n+    ty::GenericPredicates {\n+        parent: None,\n+        predicates: superbounds\n+    }\n }\n \n fn trait_def_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) -> &'tcx ty::TraitDef {"}, {"sha": "e8cb25cec4f25b707e8b079e3b11b7c5cf0fba5a", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -3417,23 +3417,6 @@ impl Bar for *mut Foo {\n ```\n \"##,\n \n-E0391: r##\"\n-This error indicates that some types or traits depend on each other\n-and therefore cannot be constructed.\n-\n-The following example contains a circular dependency between two traits:\n-\n-```compile_fail,E0391\n-trait FirstTrait : SecondTrait {\n-\n-}\n-\n-trait SecondTrait : FirstTrait {\n-\n-}\n-```\n-\"##,\n-\n E0392: r##\"\n This error indicates that a type or lifetime parameter has been declared\n but not actually used. Here is an example that demonstrates the error:"}, {"sha": "c3c1952415b90aacfc9fd16e541ebfe808fa97fc", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -116,7 +116,6 @@ use util::common::time;\n \n use syntax::ast;\n use syntax::abi::Abi;\n-use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n use std::iter;\n@@ -170,30 +169,6 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-fn ty_param_owner(tcx: TyCtxt, id: ast::NodeId) -> ast::NodeId {\n-    match tcx.hir.get(id) {\n-        hir::map::NodeItem(&hir::Item { node: hir::ItemTrait(..), .. }) => id,\n-        hir::map::NodeTyParam(_) => tcx.hir.get_parent_node(id),\n-        _ => {\n-            bug!(\"ty_param_owner: {} not a type parameter\",\n-                 tcx.hir.node_to_string(id))\n-        }\n-    }\n-}\n-\n-fn ty_param_name(tcx: TyCtxt, id: ast::NodeId) -> ast::Name {\n-    match tcx.hir.get(id) {\n-        hir::map::NodeItem(&hir::Item { node: hir::ItemTrait(..), .. }) => {\n-            keywords::SelfType.name()\n-        }\n-        hir::map::NodeTyParam(tp) => tp.name,\n-        _ => {\n-            bug!(\"ty_param_name: {} not a type parameter\",\n-                 tcx.hir.node_to_string(id))\n-        }\n-    }\n-}\n-\n fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               main_id: ast::NodeId,\n                               main_span: Span) {"}, {"sha": "7af2f11bd281506d11174fb7a3e40e9469961882", "filename": "src/test/compile-fail/cycle-projection-based-on-where-clause.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -26,6 +26,7 @@ struct A<T>\n     where T : Trait,\n           T : Add<T::Item>\n     //~^ ERROR unsupported cyclic reference between types/traits detected\n+    //~| ERROR associated type `Item` not found for `T`\n {\n     data: T\n }"}, {"sha": "905d546e99a066984ee7c0f0c471bd78ada191d1", "filename": "src/test/compile-fail/cycle-trait-supertrait-indirect.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -12,14 +12,16 @@\n // a direct participant in the cycle.\n \n trait A: B {\n-    //~^ ERROR unsupported cyclic reference\n+    //~^ NOTE the cycle begins when computing the supertraits of `B`...\n }\n \n trait B: C {\n-    //~^ ERROR unsupported cyclic reference\n+    //~^ NOTE ...which then requires computing the supertraits of `C`...\n }\n \n trait C: B { }\n     //~^ ERROR unsupported cyclic reference\n+    //~| cyclic reference\n+    //~| NOTE ...which then again requires computing the supertraits of `B`, completing the cycle\n \n fn main() { }"}, {"sha": "0c3073a770141f866a0eef4e883900413993cceb", "filename": "src/test/compile-fail/issue-12511.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Ftest%2Fcompile-fail%2Fissue-12511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Ftest%2Fcompile-fail%2Fissue-12511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12511.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -9,11 +9,14 @@\n // except according to those terms.\n \n trait t1 : t2 {\n-//~^ ERROR: unsupported cyclic reference between types/traits detected\n+//~^ NOTE the cycle begins when computing the supertraits of `t1`...\n+//~| NOTE ...which then requires computing the supertraits of `t2`...\n }\n \n trait t2 : t1 {\n-//~^ ERROR: unsupported cyclic reference between types/traits detected\n+//~^ ERROR unsupported cyclic reference between types/traits detected\n+//~| cyclic reference\n+//~| NOTE ...which then again requires computing the supertraits of `t1`, completing the cycle\n }\n \n fn main() { }"}, {"sha": "7ae4250d4203bac9f6274cd297433762c90c2d0f", "filename": "src/test/compile-fail/issue-20772.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Ftest%2Fcompile-fail%2Fissue-20772.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Ftest%2Fcompile-fail%2Fissue-20772.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20772.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -10,6 +10,7 @@\n \n trait T : Iterator<Item=Self::Item>\n //~^ ERROR unsupported cyclic reference between types/traits detected\n+//~| ERROR associated type `Item` not found for `Self`\n {}\n \n fn main() {}"}, {"sha": "f49b71953835b28ac50d8b058f39901c2d601fb8", "filename": "src/test/compile-fail/issue-21177.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Ftest%2Fcompile-fail%2Fissue-21177.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28f1cf4262074dfdb5f83a24cf81dbabf37a1d94/src%2Ftest%2Fcompile-fail%2Fissue-21177.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21177.rs?ref=28f1cf4262074dfdb5f83a24cf81dbabf37a1d94", "patch": "@@ -14,6 +14,7 @@ trait Trait {\n }\n \n fn foo<T: Trait<A = T::B>>() { }\n-//~^ ERROR: unsupported cyclic reference between types/traits detected\n+//~^ ERROR unsupported cyclic reference between types/traits detected\n+//~| ERROR associated type `B` not found for `T`\n \n fn main() { }"}]}