{"sha": "6b00b8b302ba2e0a0946739ebe279d17f43f589b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMDBiOGIzMDJiYTJlMGEwOTQ2NzM5ZWJlMjc5ZDE3ZjQzZjU4OWI=", "commit": {"author": {"name": "Tibo Delor", "email": "delor.thibault@gmail.com", "date": "2018-06-09T14:25:47Z"}, "committer": {"name": "Tibo Delor", "email": "delor.thibault@gmail.com", "date": "2018-06-09T14:25:47Z"}, "message": "Move newline logic inside the formatting process.\n\nWhy?:\n - Conceptually it sounds right\n - Absolutely all write modes where doing it anyway\n - It was done several times in some in case\n - It greatly simplify the code", "tree": {"sha": "e3100d59a4b6316057a239704970ee34ee01d8d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3100d59a4b6316057a239704970ee34ee01d8d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b00b8b302ba2e0a0946739ebe279d17f43f589b", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEElri4er6EfFqe1VRMLfdMrGi+j80FAlsb420ACgkQLfdMrGi+\nj80GSAf/bT0gtlsBJV3SNxAJToaZJ1/BUj7pT5kHuKUaPj2mAPZvNZ4Db83osX3s\nfZJ2kfOTQo92dqpSsFJWrdBRBXTRHNO/4UfQTT45K1dxSbIIrGY6Djhqrn8I9HMz\nFJNG3JlANgGPVorFxLqtwO77//7mjhPt4sWJKXNcpy1JPZttq547EkRLDt//4H/V\nFU0l7Psi9138iMKzLkdN549vS+6brVNwXpOmaeulv9QNmDvDfFk4orzsE8WaUE10\n/9X9paxvcsBQJL8mLUGJbYkrxFeX5MInmztI1ZInbkKyNCCUN51VCFwnrk0QX2mE\nmuqyVzuFcgUMKFWp4H+GikDiY5z5XQ==\n=Oxd9\n-----END PGP SIGNATURE-----", "payload": "tree e3100d59a4b6316057a239704970ee34ee01d8d7\nparent 8c32a9d909ee7a517b9fb24b85f871a43eb5cbba\nauthor Tibo Delor <delor.thibault@gmail.com> 1528554347 +1000\ncommitter Tibo Delor <delor.thibault@gmail.com> 1528554347 +1000\n\nMove newline logic inside the formatting process.\n\nWhy?:\n - Conceptually it sounds right\n - Absolutely all write modes where doing it anyway\n - It was done several times in some in case\n - It greatly simplify the code\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b00b8b302ba2e0a0946739ebe279d17f43f589b", "html_url": "https://github.com/rust-lang/rust/commit/6b00b8b302ba2e0a0946739ebe279d17f43f589b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b00b8b302ba2e0a0946739ebe279d17f43f589b/comments", "author": {"login": "t-botz", "id": 693797, "node_id": "MDQ6VXNlcjY5Mzc5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/693797?v=4", "gravatar_id": "", "url": "https://api.github.com/users/t-botz", "html_url": "https://github.com/t-botz", "followers_url": "https://api.github.com/users/t-botz/followers", "following_url": "https://api.github.com/users/t-botz/following{/other_user}", "gists_url": "https://api.github.com/users/t-botz/gists{/gist_id}", "starred_url": "https://api.github.com/users/t-botz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/t-botz/subscriptions", "organizations_url": "https://api.github.com/users/t-botz/orgs", "repos_url": "https://api.github.com/users/t-botz/repos", "events_url": "https://api.github.com/users/t-botz/events{/privacy}", "received_events_url": "https://api.github.com/users/t-botz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "t-botz", "id": 693797, "node_id": "MDQ6VXNlcjY5Mzc5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/693797?v=4", "gravatar_id": "", "url": "https://api.github.com/users/t-botz", "html_url": "https://github.com/t-botz", "followers_url": "https://api.github.com/users/t-botz/followers", "following_url": "https://api.github.com/users/t-botz/following{/other_user}", "gists_url": "https://api.github.com/users/t-botz/gists{/gist_id}", "starred_url": "https://api.github.com/users/t-botz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/t-botz/subscriptions", "organizations_url": "https://api.github.com/users/t-botz/orgs", "repos_url": "https://api.github.com/users/t-botz/repos", "events_url": "https://api.github.com/users/t-botz/events{/privacy}", "received_events_url": "https://api.github.com/users/t-botz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c32a9d909ee7a517b9fb24b85f871a43eb5cbba", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c32a9d909ee7a517b9fb24b85f871a43eb5cbba", "html_url": "https://github.com/rust-lang/rust/commit/8c32a9d909ee7a517b9fb24b85f871a43eb5cbba"}], "stats": {"total": 181, "additions": 70, "deletions": 111}, "files": [{"sha": "507e85f2086f9f6a1c30b242f40385eb50ad8243", "filename": "src/filemap.rs", "status": "modified", "additions": 36, "deletions": 101, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/6b00b8b302ba2e0a0946739ebe279d17f43f589b/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b00b8b302ba2e0a0946739ebe279d17f43f589b/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=6b00b8b302ba2e0a0946739ebe279d17f43f589b", "patch": "@@ -10,13 +10,12 @@\n \n // TODO: add tests\n \n-use std::fs::{self, File};\n-use std::io::{self, BufWriter, Read, Write};\n-use std::path::Path;\n+use std::fs;\n+use std::io::{self, Write};\n \n use checkstyle::output_checkstyle_file;\n-use config::{Config, EmitMode, FileName, NewlineStyle, Verbosity};\n-use rustfmt_diff::{make_diff, output_modified, print_diff, Mismatch};\n+use config::{Config, EmitMode, FileName, Verbosity};\n+use rustfmt_diff::{make_diff, output_modified, print_diff};\n \n #[cfg(test)]\n use FileRecord;\n@@ -48,72 +47,15 @@ where\n     Ok(())\n }\n \n-// Prints all newlines either as `\\n` or as `\\r\\n`.\n-pub fn write_system_newlines<T>(writer: T, text: &str, config: &Config) -> Result<(), io::Error>\n-where\n-    T: Write,\n-{\n-    // Buffer output, since we're writing a since char at a time.\n-    let mut writer = BufWriter::new(writer);\n-\n-    let style = if config.newline_style() == NewlineStyle::Native {\n-        if cfg!(windows) {\n-            NewlineStyle::Windows\n-        } else {\n-            NewlineStyle::Unix\n-        }\n-    } else {\n-        config.newline_style()\n-    };\n-\n-    match style {\n-        NewlineStyle::Unix => write!(writer, \"{}\", text),\n-        NewlineStyle::Windows => {\n-            for c in text.chars() {\n-                match c {\n-                    '\\n' => write!(writer, \"\\r\\n\")?,\n-                    '\\r' => continue,\n-                    c => write!(writer, \"{}\", c)?,\n-                }\n-            }\n-            Ok(())\n-        }\n-        NewlineStyle::Native => unreachable!(),\n-    }\n-}\n-\n pub fn write_file<T>(\n-    text: &str,\n+    formatted_text: &str,\n     filename: &FileName,\n     out: &mut T,\n     config: &Config,\n ) -> Result<bool, io::Error>\n where\n     T: Write,\n {\n-    fn source_and_formatted_text(\n-        text: &str,\n-        filename: &Path,\n-        config: &Config,\n-    ) -> Result<(String, String), io::Error> {\n-        let mut f = File::open(filename)?;\n-        let mut ori_text = String::new();\n-        f.read_to_string(&mut ori_text)?;\n-        let mut v = Vec::new();\n-        write_system_newlines(&mut v, text, config)?;\n-        let fmt_text = String::from_utf8(v).unwrap();\n-        Ok((ori_text, fmt_text))\n-    }\n-\n-    fn create_diff(\n-        filename: &Path,\n-        text: &str,\n-        config: &Config,\n-    ) -> Result<Vec<Mismatch>, io::Error> {\n-        let (ori, fmt) = source_and_formatted_text(text, filename, config)?;\n-        Ok(make_diff(&ori, &fmt, 3))\n-    }\n-\n     let filename_to_path = || match *filename {\n         FileName::Real(ref path) => path,\n         _ => panic!(\"cannot format `{}` and emit to files\", filename),\n@@ -122,65 +64,58 @@ where\n     match config.emit_mode() {\n         EmitMode::Files if config.make_backup() => {\n             let filename = filename_to_path();\n-            if let Ok((ori, fmt)) = source_and_formatted_text(text, filename, config) {\n-                if fmt != ori {\n-                    // Do a little dance to make writing safer - write to a temp file\n-                    // rename the original to a .bk, then rename the temp file to the\n-                    // original.\n-                    let tmp_name = filename.with_extension(\"tmp\");\n-                    let bk_name = filename.with_extension(\"bk\");\n-                    {\n-                        // Write text to temp file\n-                        let tmp_file = File::create(&tmp_name)?;\n-                        write_system_newlines(tmp_file, text, config)?;\n-                    }\n-\n-                    fs::rename(filename, bk_name)?;\n-                    fs::rename(tmp_name, filename)?;\n-                }\n+            let ori = fs::read_to_string(filename)?;\n+            if ori != formatted_text {\n+                // Do a little dance to make writing safer - write to a temp file\n+                // rename the original to a .bk, then rename the temp file to the\n+                // original.\n+                let tmp_name = filename.with_extension(\"tmp\");\n+                let bk_name = filename.with_extension(\"bk\");\n+\n+                fs::write(&tmp_name, formatted_text)?;\n+                fs::rename(filename, bk_name)?;\n+                fs::rename(tmp_name, filename)?;\n             }\n         }\n         EmitMode::Files => {\n             // Write text directly over original file if there is a diff.\n             let filename = filename_to_path();\n-            let (source, formatted) = source_and_formatted_text(text, filename, config)?;\n-            if source != formatted {\n-                let file = File::create(filename)?;\n-                write_system_newlines(file, text, config)?;\n+            let ori = fs::read_to_string(filename)?;\n+            if ori != formatted_text {\n+                fs::write(filename, formatted_text)?;\n             }\n         }\n         EmitMode::Stdout | EmitMode::Coverage => {\n             if config.verbose() != Verbosity::Quiet {\n                 println!(\"{}:\\n\", filename);\n             }\n-            write_system_newlines(out, text, config)?;\n+            write!(out, \"{}\", formatted_text)?;\n         }\n         EmitMode::ModifiedLines => {\n             let filename = filename_to_path();\n-            if let Ok((ori, fmt)) = source_and_formatted_text(text, filename, config) {\n-                let mismatch = make_diff(&ori, &fmt, 0);\n-                let has_diff = !mismatch.is_empty();\n-                output_modified(out, mismatch);\n-                return Ok(has_diff);\n-            }\n+            let ori = fs::read_to_string(filename)?;\n+            let mismatch = make_diff(&ori, formatted_text, 0);\n+            let has_diff = !mismatch.is_empty();\n+            output_modified(out, mismatch);\n+            return Ok(has_diff);\n         }\n         EmitMode::Checkstyle => {\n             let filename = filename_to_path();\n-            let diff = create_diff(filename, text, config)?;\n+            let ori = fs::read_to_string(filename)?;\n+            let diff = make_diff(&ori, formatted_text, 3);\n             output_checkstyle_file(out, filename, diff)?;\n         }\n         EmitMode::Diff => {\n             let filename = filename_to_path();\n-            if let Ok((ori, fmt)) = source_and_formatted_text(text, filename, config) {\n-                let mismatch = make_diff(&ori, &fmt, 3);\n-                let has_diff = !mismatch.is_empty();\n-                print_diff(\n-                    mismatch,\n-                    |line_num| format!(\"Diff in {} at line {}:\", filename.display(), line_num),\n-                    config,\n-                );\n-                return Ok(has_diff);\n-            }\n+            let ori = fs::read_to_string(filename)?;\n+            let mismatch = make_diff(&ori, formatted_text, 3);\n+            let has_diff = !mismatch.is_empty();\n+            print_diff(\n+                mismatch,\n+                |line_num| format!(\"Diff in {} at line {}:\", filename.display(), line_num),\n+                config,\n+            );\n+            return Ok(has_diff);\n         }\n     }\n "}, {"sha": "0ea3c60477022233f289b8f93483c0a46b73e170", "filename": "src/lib.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6b00b8b302ba2e0a0946739ebe279d17f43f589b/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b00b8b302ba2e0a0946739ebe279d17f43f589b/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=6b00b8b302ba2e0a0946739ebe279d17f43f589b", "patch": "@@ -60,7 +60,8 @@ use visitor::{FmtVisitor, SnippetProvider};\n pub use checkstyle::{footer as checkstyle_footer, header as checkstyle_header};\n pub use config::summary::Summary;\n pub use config::{\n-    load_config, CliOptions, Color, Config, EmitMode, FileLines, FileName, Range, Verbosity,\n+    load_config, CliOptions, Color, Config, EmitMode, FileLines, FileName, NewlineStyle, Range,\n+    Verbosity,\n };\n \n #[macro_use]\n@@ -877,6 +878,7 @@ fn format_input_inner<T: Write>(\n             filemap::append_newline(file);\n \n             format_lines(file, file_name, skipped_range, config, report);\n+            replace_with_system_newlines(file, config);\n \n             if let Some(ref mut out) = out {\n                 return filemap::write_file(file, file_name, out, config);\n@@ -929,6 +931,34 @@ fn format_input_inner<T: Write>(\n     }\n }\n \n+pub fn replace_with_system_newlines(text: &mut String, config: &Config) -> () {\n+    let style = if config.newline_style() == NewlineStyle::Native {\n+        if cfg!(windows) {\n+            NewlineStyle::Windows\n+        } else {\n+            NewlineStyle::Unix\n+        }\n+    } else {\n+        config.newline_style()\n+    };\n+\n+    match style {\n+        NewlineStyle::Unix => return,\n+        NewlineStyle::Windows => {\n+            let mut transformed = String::with_capacity(text.capacity());\n+            for c in text.chars() {\n+                match c {\n+                    '\\n' => transformed.push_str(\"\\r\\n\"),\n+                    '\\r' => continue,\n+                    c => transformed.push(c),\n+                }\n+            }\n+            *text = transformed;\n+        }\n+        NewlineStyle::Native => unreachable!(),\n+    }\n+}\n+\n /// A single span of changed lines, with 0 or more removed lines\n /// and a vector of 0 or more inserted lines.\n #[derive(Debug, PartialEq, Eq)]"}, {"sha": "fdbe1e6856e66c6856095354a034b4fc77a4efd1", "filename": "src/test/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b00b8b302ba2e0a0946739ebe279d17f43f589b/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b00b8b302ba2e0a0946739ebe279d17f43f589b/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=6b00b8b302ba2e0a0946739ebe279d17f43f589b", "patch": "@@ -22,7 +22,6 @@ use std::str::Chars;\n \n use config::summary::Summary;\n use config::{Color, Config, ReportTactic};\n-use filemap::write_system_newlines;\n use rustfmt_diff::*;\n use *;\n \n@@ -401,14 +400,9 @@ fn idempotent_check(\n     }\n \n     let mut write_result = HashMap::new();\n-    for &(ref filename, ref text) in &file_map {\n-        let mut v = Vec::new();\n-        // Won't panic, as we're not doing any IO.\n-        write_system_newlines(&mut v, text, &config).unwrap();\n-        // Won't panic, we are writing correct utf8.\n-        let one_result = String::from_utf8(v).unwrap();\n-        if let FileName::Real(ref filename) = *filename {\n-            write_result.insert(filename.to_owned(), one_result);\n+    for (filename, text) in file_map {\n+        if let FileName::Real(ref filename) = filename {\n+            write_result.insert(filename.to_owned(), text);\n         }\n     }\n "}]}