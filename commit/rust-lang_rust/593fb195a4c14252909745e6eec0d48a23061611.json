{"sha": "593fb195a4c14252909745e6eec0d48a23061611", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5M2ZiMTk1YTRjMTQyNTI5MDk3NDVlNmVlYzBkNDhhMjMwNjE2MTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-29T22:39:10Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-29T22:39:48Z"}, "message": "rustc: Start threading a purity flag through upcalls", "tree": {"sha": "0bdce53c9e8c8dbfb0ae0077c4056875c2e65b38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bdce53c9e8c8dbfb0ae0077c4056875c2e65b38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/593fb195a4c14252909745e6eec0d48a23061611", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/593fb195a4c14252909745e6eec0d48a23061611", "html_url": "https://github.com/rust-lang/rust/commit/593fb195a4c14252909745e6eec0d48a23061611", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/593fb195a4c14252909745e6eec0d48a23061611/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c11d9f4268bede946b363568b309105d14fe93d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c11d9f4268bede946b363568b309105d14fe93d0", "html_url": "https://github.com/rust-lang/rust/commit/c11d9f4268bede946b363568b309105d14fe93d0"}], "stats": {"total": 46, "additions": 26, "deletions": 20}, "files": [{"sha": "cb6badf44b1c566eea573462ee850dceb831c122", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/593fb195a4c14252909745e6eec0d48a23061611/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593fb195a4c14252909745e6eec0d48a23061611/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=593fb195a4c14252909745e6eec0d48a23061611", "patch": "@@ -1042,7 +1042,8 @@ fn get_simple_extern_fn(&hashmap[str, ValueRef] externs,\n     ret get_extern_fn(externs, llmod, name, lib.llvm.LLVMCCallConv, t);\n }\n \n-fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args) -> result {\n+fn trans_upcall(@block_ctxt cx, str name, vec[ValueRef] args, bool pure)\n+        -> result {\n     auto cxx = cx.fcx.lcx.ccx;\n     auto lltaskptr = cx.build.PtrToInt(cx.fcx.lltaskptr, T_int());\n     auto args2 = vec(lltaskptr) + args;\n@@ -1080,8 +1081,7 @@ fn trans_native_call(builder b, @glue_fns glues, ValueRef lltaskptr,\n }\n \n fn trans_non_gc_free(@block_ctxt cx, ValueRef v) -> result {\n-    ret trans_upcall(cx, \"upcall_free\", vec(vp2i(cx, v),\n-                                            C_int(0)));\n+    ret trans_upcall(cx, \"upcall_free\", vec(vp2i(cx, v), C_int(0)), false);\n }\n \n fn find_scope_cx(@block_ctxt cx) -> @block_ctxt {\n@@ -1503,7 +1503,7 @@ fn trans_raw_malloc(@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize)\n         -> result {\n     // FIXME: need a table to collect tydesc globals.\n     auto tydesc = C_int(0);\n-    auto rslt = trans_upcall(cx, \"upcall_malloc\", vec(llsize, tydesc));\n+    auto rslt = trans_upcall(cx, \"upcall_malloc\", vec(llsize, tydesc), false);\n     rslt = res(rslt.bcx, vi2p(rslt.bcx, rslt.val, llptr_ty));\n     ret rslt;\n }\n@@ -1616,7 +1616,7 @@ fn get_tydesc(&@block_ctxt cx, ty.t t, bool escapes) -> result {\n                                   sz.val,\n                                   align.val,\n                                   C_int((1u + n_params) as int),\n-                                  vp2i(bcx, tydescs)));\n+                                  vp2i(bcx, tydescs)), true);\n \n         ret res(v.bcx, vi2p(v.bcx, v.val,\n                             T_ptr(T_tydesc(cx.fcx.lcx.ccx.tn))));\n@@ -1886,7 +1886,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n         case (ty.ty_port(_)) {\n             fn hit_zero(@block_ctxt cx, ValueRef v) -> result {\n                 ret trans_upcall(cx, \"upcall_del_port\",\n-                                 vec(vp2i(cx, v)));\n+                                 vec(vp2i(cx, v)), true);\n             }\n             auto v = cx.build.Load(v0);\n             rslt = decr_refcnt_and_if_zero(cx, v,\n@@ -1898,7 +1898,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v0, ty.t t) {\n         case (ty.ty_chan(_)) {\n             fn hit_zero(@block_ctxt cx, ValueRef v) -> result {\n                 ret trans_upcall(cx, \"upcall_del_chan\",\n-                                 vec(vp2i(cx, v)));\n+                                 vec(vp2i(cx, v)), true);\n             }\n             auto v = cx.build.Load(v0);\n             rslt = decr_refcnt_and_if_zero(cx, v,\n@@ -4940,7 +4940,8 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n                                  unit_sz.val);\n \n     // FIXME: pass tydesc properly.\n-    auto sub = trans_upcall(bcx, \"upcall_new_vec\", vec(data_sz, C_int(0)));\n+    auto sub = trans_upcall(bcx, \"upcall_new_vec\", vec(data_sz, C_int(0)),\n+                            false);\n     bcx = sub.bcx;\n \n     auto llty = type_of(bcx.fcx.lcx.ccx, t);\n@@ -5301,14 +5302,16 @@ fn trans_log(int lvl, @block_ctxt cx, @ast.expr e) -> result {\n         if (is32bit) {\n             auto uval = trans_upcall(sub.bcx,\n                                      \"upcall_log_float\",\n-                                     vec(C_int(lvl), sub.val));\n+                                     vec(C_int(lvl), sub.val),\n+                                     false);\n             uval.bcx.build.Br(after_cx.llbb);\n         } else {\n             auto tmp = alloca(sub.bcx, tr);\n             sub.bcx.build.Store(sub.val, tmp);\n             auto uval = trans_upcall(sub.bcx,\n                                      \"upcall_log_double\",\n-                                     vec(C_int(lvl), vp2i(sub.bcx, tmp)));\n+                                     vec(C_int(lvl), vp2i(sub.bcx, tmp)),\n+                                     false);\n             uval.bcx.build.Br(after_cx.llbb);\n         }\n     } else {\n@@ -5317,13 +5320,14 @@ fn trans_log(int lvl, @block_ctxt cx, @ast.expr e) -> result {\n                 auto v = vp2i(sub.bcx, sub.val);\n                 trans_upcall(sub.bcx,\n                              \"upcall_log_str\",\n-                             vec(C_int(lvl), v)).bcx.build.Br(after_cx.llbb);\n+                             vec(C_int(lvl), v),\n+                             false).bcx.build.Br(after_cx.llbb);\n             }\n             case (_) {\n                 auto v = vec(C_int(lvl), sub.val);\n                 trans_upcall(sub.bcx,\n                              \"upcall_log_int\",\n-                             v).bcx.build.Br(after_cx.llbb);\n+                             v, false).bcx.build.Br(after_cx.llbb);\n             }\n         }\n     }\n@@ -5364,7 +5368,7 @@ fn trans_fail(@block_ctxt cx, option.t[common.span] sp_opt, str fail_str)\n \n     auto args = vec(V_fail_str, V_filename, C_int(V_line));\n \n-    auto sub = trans_upcall(cx, \"upcall_fail\", args);\n+    auto sub = trans_upcall(cx, \"upcall_fail\", args, false);\n     sub.bcx.build.Unreachable();\n     ret res(sub.bcx, C_nil());\n }\n@@ -5511,7 +5515,7 @@ fn trans_port(@block_ctxt cx, ast.ann ann) -> result {\n     auto bcx = cx;\n     auto unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n-    auto sub = trans_upcall(bcx, \"upcall_new_port\", vec(unit_sz.val));\n+    auto sub = trans_upcall(bcx, \"upcall_new_port\", vec(unit_sz.val), false);\n     bcx = sub.bcx;\n     auto llty = type_of(cx.fcx.lcx.ccx, t);\n     auto port_val = vi2p(bcx, sub.val, llty);\n@@ -5528,7 +5532,7 @@ fn trans_chan(@block_ctxt cx, @ast.expr e, ast.ann ann) -> result {\n     bcx = prt.bcx;\n \n     auto prt_val = vp2i(bcx, prt.val);\n-    auto sub = trans_upcall(bcx, \"upcall_new_chan\", vec(prt_val));\n+    auto sub = trans_upcall(bcx, \"upcall_new_chan\", vec(prt_val), false);\n     bcx = sub.bcx;\n \n     auto chan_ty = node_ann_type(bcx.fcx.lcx.ccx, ann);\n@@ -5571,7 +5575,7 @@ fn trans_send(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n \n     auto sub = trans_upcall(bcx, \"upcall_send\",\n                             vec(vp2i(bcx, chn.val),\n-                                vp2i(bcx, data_alloc.val)));\n+                                vp2i(bcx, data_alloc.val)), false);\n     bcx = sub.bcx;\n \n     ret res(bcx, chn.val);\n@@ -5599,7 +5603,7 @@ fn recv_val(@block_ctxt cx, ValueRef lhs, @ast.expr rhs,\n \n     auto sub = trans_upcall(bcx, \"upcall_recv\",\n                             vec(vp2i(bcx, lhs),\n-                                vp2i(bcx, prt.val)));\n+                                vp2i(bcx, prt.val)), false);\n     bcx = sub.bcx;\n \n     auto data_load = load_if_immediate(bcx, lhs, unit_ty);\n@@ -7109,11 +7113,12 @@ fn declare_intrinsics(ModuleRef llmod) -> hashmap[str,ValueRef] {\n \n \n fn trace_str(@block_ctxt cx, str s) {\n-    trans_upcall(cx, \"upcall_trace_str\", vec(p2i(C_cstr(cx.fcx.lcx.ccx, s))));\n+    trans_upcall(cx, \"upcall_trace_str\", vec(p2i(C_cstr(cx.fcx.lcx.ccx, s))),\n+                 false);\n }\n \n fn trace_word(@block_ctxt cx, ValueRef v) {\n-    trans_upcall(cx, \"upcall_trace_word\", vec(v));\n+    trans_upcall(cx, \"upcall_trace_word\", vec(v), false);\n }\n \n fn trace_ptr(@block_ctxt cx, ValueRef v) {\n@@ -7489,7 +7494,8 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n                      vec(vp2i(bcx, lldst_vec),\n                          vec_fill_adjusted(bcx, llsrc_vec, llskipnull),\n                          vp2i(bcx, llcopy_dst_ptr),\n-                         vp2i(bcx, llvec_tydesc)));\n+                         vp2i(bcx, llvec_tydesc)),\n+                     false);\n \n     bcx = llnew_vec_res.bcx;\n     auto llnew_vec = vi2p(bcx, llnew_vec_res.val,"}]}