{"sha": "79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5Y2Q1YThkNGE0Mjc1NzBjY2ZlNjdkNGI0M2I2YTA5YTMyNmYzZDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-27T22:00:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-27T22:00:15Z"}, "message": "Auto merge of #1489 - RalfJung:tls-alloc-ids, r=oli-obk\n\nAdjust for new rustc alloc ID handling and deallocate thread-local statics\n\nMiri side of https://github.com/rust-lang/rust/pull/74775.\n\nFixes https://github.com/rust-lang/miri/issues/1369\nFixes https://github.com/rust-lang/miri/issues/1488", "tree": {"sha": "66bb6e160db1a444ab6f5c503e10396e5c21ccbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66bb6e160db1a444ab6f5c503e10396e5c21ccbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "html_url": "https://github.com/rust-lang/rust/commit/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "345b033c3fb0c4be917cf405828596a625ead759", "url": "https://api.github.com/repos/rust-lang/rust/commits/345b033c3fb0c4be917cf405828596a625ead759", "html_url": "https://github.com/rust-lang/rust/commit/345b033c3fb0c4be917cf405828596a625ead759"}, {"sha": "cae90b6d293dc0e9bb3275457a94323bd14d51a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/cae90b6d293dc0e9bb3275457a94323bd14d51a1", "html_url": "https://github.com/rust-lang/rust/commit/cae90b6d293dc0e9bb3275457a94323bd14d51a1"}], "stats": {"total": 270, "additions": 131, "deletions": 139}, "files": [{"sha": "3f188639fa3d46a6d900e1c04b38b877e2cf1293", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "patch": "@@ -1 +1 @@\n-13f9aa190957b993a268fd4a046fce76ca8814ee\n+efc02b03d18b0cbaa55b1e421d792f70a39230b2"}, {"sha": "1b41ba441837764dde05b36bc155edeaf9428267", "filename": "src/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "patch": "@@ -94,8 +94,8 @@ pub fn report_error<'tcx, 'mir>(\n             let helps = match e.kind {\n                 Unsupported(UnsupportedOpInfo::NoMirFor(..)) =>\n                     vec![format!(\"make sure to use a Miri sysroot, which you can prepare with `cargo miri setup`\")],\n-                Unsupported(UnsupportedOpInfo::ReadBytesAsPointer) =>\n-                    panic!(\"`ReadBytesAsPointer` cannot be raised by Miri\"),\n+                Unsupported(UnsupportedOpInfo::ReadBytesAsPointer | UnsupportedOpInfo::ThreadLocalStatic(_) | UnsupportedOpInfo::ReadExternStatic(_)) =>\n+                    panic!(\"Error should never be raised by Miri: {:?}\", e.kind),\n                 Unsupported(_) =>\n                     vec![format!(\"this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\")],\n                 UndefinedBehavior(UndefinedBehaviorInfo::AlignmentCheckFailed { .. }) =>\n@@ -162,7 +162,15 @@ fn report_msg<'tcx>(\n     } else {\n         tcx.sess.diagnostic().span_note_diag(span, title)\n     };\n-    err.span_label(span, span_msg);\n+    // Show main message.\n+    if span != DUMMY_SP {\n+        err.span_label(span, span_msg);\n+    } else {\n+        // Make sure we show the message even when it is a dummy span.\n+        err.note(&span_msg);\n+        err.note(\"(no span available)\");\n+    }\n+    // Show help messages.\n     if !helps.is_empty() {\n         // Add visual separator before backtrace.\n         helps.last_mut().unwrap().push_str(\"\\n\");\n@@ -198,7 +206,7 @@ pub fn register_diagnostic(e: NonHaltingDiagnostic) {\n /// after a step was taken.\n pub struct TopFrameInfo<'tcx> {\n     stack_size: usize,\n-    instance: ty::Instance<'tcx>,\n+    instance: Option<ty::Instance<'tcx>>,\n     span: Span,\n }\n \n@@ -209,11 +217,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         DIAGNOSTICS.with(|diagnostics| assert!(diagnostics.borrow().is_empty()));\n \n         let this = self.eval_context_ref();\n+        if this.active_thread_stack().is_empty() {\n+            // Diagnostics can happen even with the empty stack (e.g. deallocation of thread-local statics).\n+            return TopFrameInfo { stack_size: 0, instance: None, span: DUMMY_SP };\n+        }\n         let frame = this.frame();\n \n         TopFrameInfo {\n             stack_size: this.active_thread_stack().len(),\n-            instance: frame.instance,\n+            instance: Some(frame.instance),\n             span: frame.current_source_info().map_or(DUMMY_SP, |si| si.span),\n         }\n     }\n@@ -237,15 +249,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             if stacktrace.len() < info.stack_size {\n                 assert!(stacktrace.len() == info.stack_size-1, \"we should never pop more than one frame at once\");\n                 let frame_info = FrameInfo {\n-                    instance: info.instance,\n+                    instance: info.instance.unwrap(),\n                     span: info.span,\n                     lint_root: None,\n                 };\n                 stacktrace.insert(0, frame_info);\n-            } else {\n+            } else if let Some(instance) = info.instance {\n                 // Adjust topmost frame.\n                 stacktrace[0].span = info.span;\n-                assert_eq!(stacktrace[0].instance, info.instance, \"we should not pop and push a frame in one step\");\n+                assert_eq!(stacktrace[0].instance, instance, \"we should not pop and push a frame in one step\");\n             }\n \n             // Show diagnostics."}, {"sha": "cc5a6eb21fabac1083490440533eda642d9683f7", "filename": "src/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "patch": "@@ -211,11 +211,10 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n     let res: InterpResult<'_, i64> = (|| {\n         // Main loop.\n         loop {\n+            let info = ecx.preprocess_diagnostics();\n             match ecx.schedule()? {\n                 SchedulingAction::ExecuteStep => {\n-                    let info = ecx.preprocess_diagnostics();\n                     assert!(ecx.step()?, \"a terminated thread was scheduled for execution\");\n-                    ecx.process_diagnostics(info);\n                 }\n                 SchedulingAction::ExecuteTimeoutCallback => {\n                     assert!(ecx.machine.communicate,\n@@ -233,6 +232,7 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n                     break;\n                 }\n             }\n+            ecx.process_diagnostics(info);\n         }\n         let return_code = ecx.read_scalar(ret_place.into())?.check_init()?.to_machine_isize(&ecx)?;\n         Ok(return_code)"}, {"sha": "188ff94861bdd194a223f092f5c24149c276b725", "filename": "src/intptrcast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "patch": "@@ -6,7 +6,6 @@ use log::trace;\n use rand::Rng;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_mir::interpret::{AllocCheck, AllocId, InterpResult, Memory, Machine, Pointer, PointerArithmetic};\n use rustc_target::abi::{Size, HasDataLayout};\n \n use crate::*;\n@@ -79,7 +78,7 @@ impl<'mir, 'tcx> GlobalState {\n     ) -> InterpResult<'tcx, u64> {\n         let mut global_state = memory.extra.intptrcast.borrow_mut();\n         let global_state = &mut *global_state;\n-        let id = Evaluator::canonical_alloc_id(memory, ptr.alloc_id);\n+        let id = ptr.alloc_id;\n \n         // There is nothing wrong with a raw pointer being cast to an integer only after\n         // it became dangling.  Hence `MaybeDead`."}, {"sha": "5dfe99627437df5da938d6e9e5971a082bb6c075", "filename": "src/machine.rs", "status": "modified", "additions": 20, "deletions": 34, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "patch": "@@ -64,7 +64,10 @@ pub enum MiriMemoryKind {\n     Global,\n     /// Memory for extern statics.\n     /// This memory may leak.\n-    ExternGlobal,\n+    ExternStatic,\n+    /// Memory for thread-local statics.\n+    /// This memory may leak.\n+    Tls,\n }\n \n impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n@@ -80,7 +83,7 @@ impl MayLeak for MiriMemoryKind {\n         use self::MiriMemoryKind::*;\n         match self {\n             Rust | C | WinHeap | Env => false,\n-            Machine | Global | ExternGlobal => true,\n+            Machine | Global | ExternStatic | Tls => true,\n         }\n     }\n }\n@@ -94,8 +97,9 @@ impl fmt::Display for MiriMemoryKind {\n             WinHeap => write!(f, \"Windows heap\"),\n             Machine => write!(f, \"machine-managed memory\"),\n             Env => write!(f, \"environment variable\"),\n-            Global => write!(f, \"global\"),\n-            ExternGlobal => write!(f, \"extern global\"),\n+            Global => write!(f, \"global (static or const)\"),\n+            ExternStatic => write!(f, \"extern static\"),\n+            Tls =>  write!(f, \"thread-local static\"),\n         }\n     }\n }\n@@ -175,7 +179,7 @@ impl MemoryExtra {\n                 // \"__cxa_thread_atexit_impl\"\n                 // This should be all-zero, pointer-sized.\n                 let layout = this.machine.layouts.usize;\n-                let place = this.allocate(layout, MiriMemoryKind::ExternGlobal.into());\n+                let place = this.allocate(layout, MiriMemoryKind::ExternStatic.into());\n                 this.write_scalar(Scalar::from_machine_usize(0, this), place.into())?;\n                 Self::add_extern_static(this, \"__cxa_thread_atexit_impl\", place.ptr);\n                 // \"environ\"\n@@ -185,7 +189,7 @@ impl MemoryExtra {\n                 // \"_tls_used\"\n                 // This is some obscure hack that is part of the Windows TLS story. It's a `u8`.\n                 let layout = this.machine.layouts.u8;\n-                let place = this.allocate(layout, MiriMemoryKind::ExternGlobal.into());\n+                let place = this.allocate(layout, MiriMemoryKind::ExternStatic.into());\n                 this.write_scalar(Scalar::from_u8(0), place.into())?;\n                 Self::add_extern_static(this, \"_tls_used\", place.ptr);\n             }\n@@ -426,44 +430,26 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    fn thread_local_alloc_id(\n+    fn thread_local_static_alloc_id(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         def_id: DefId,\n     ) -> InterpResult<'tcx, AllocId> {\n         ecx.get_or_create_thread_local_alloc_id(def_id)\n     }\n \n-    fn adjust_global_const(\n-        ecx: &InterpCx<'mir, 'tcx, Self>,\n-        mut val: mir::interpret::ConstValue<'tcx>,\n-    ) -> InterpResult<'tcx, mir::interpret::ConstValue<'tcx>> {\n-        // FIXME: Remove this, do The Right Thing in `thread_local_alloc_id` instead.\n-        ecx.remap_thread_local_alloc_ids(&mut val)?;\n-        Ok(val)\n-    }\n-\n-    fn canonical_alloc_id(mem: &Memory<'mir, 'tcx, Self>, id: AllocId) -> AllocId {\n-        let tcx = mem.tcx;\n-        // Figure out if this is an extern static, and if yes, which one.\n-        let def_id = match tcx.get_global_alloc(id) {\n-            Some(GlobalAlloc::Static(def_id)) if tcx.is_foreign_item(def_id) => def_id,\n-            _ => {\n-                // No need to canonicalize anything.\n-                return id;\n-            }\n-        };\n-        let attrs = tcx.get_attrs(def_id);\n+    fn extern_static_alloc_id(\n+        memory: &Memory<'mir, 'tcx, Self>,\n+        def_id: DefId,\n+    ) -> InterpResult<'tcx, AllocId> {\n+        let attrs = memory.tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n             Some(name) => name,\n-            None => tcx.item_name(def_id),\n+            None => memory.tcx.item_name(def_id),\n         };\n-        // Check if we know this one.\n-        if let Some(canonical_id) = mem.extra.extern_statics.get(&link_name) {\n-            trace!(\"canonical_alloc_id: {:?} ({}) -> {:?}\", id, link_name, canonical_id);\n-            *canonical_id\n+        if let Some(&id) = memory.extra.extern_statics.get(&link_name) {\n+            Ok(id)\n         } else {\n-            // Return original id; `Memory::get_static_alloc` will throw an error.\n-            id\n+            throw_unsup_format!(\"`extern` static {:?} is not supported by Miri\", def_id)\n         }\n     }\n "}, {"sha": "d7474dbf87efc9ba885964ca43adf4d4eb2f87ae", "filename": "src/shims/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "patch": "@@ -383,9 +383,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.memory.deallocate(this.force_ptr(old_vars_ptr)?, None, MiriMemoryKind::Env.into())?;\n         } else {\n             // No `environ` allocated yet, let's do that.\n-            // This is memory backing an extern static, hence `ExternGlobal`, not `Env`.\n+            // This is memory backing an extern static, hence `ExternStatic`, not `Env`.\n             let layout = this.machine.layouts.usize;\n-            let place = this.allocate(layout, MiriMemoryKind::ExternGlobal.into());\n+            let place = this.allocate(layout, MiriMemoryKind::ExternStatic.into());\n             this.machine.env_vars.environ = Some(place);\n         }\n "}, {"sha": "2ba0782f7054f74030259af1741a0c04dcfdc082", "filename": "src/shims/tls.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "patch": "@@ -328,9 +328,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// schedules them one by one each time it is called and reenables the\n     /// thread so that it can be executed normally by the main execution loop.\n     ///\n-    /// FIXME: we do not support yet deallocation of thread local statics.\n-    /// Issue: https://github.com/rust-lang/miri/issues/1369\n-    ///\n     /// Note: we consistently run TLS destructors for all threads, including the\n     /// main thread. However, it is not clear that we should run the TLS\n     /// destructors for the main thread. See issue:\n@@ -351,6 +348,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 return Ok(())\n             }\n         }\n+        // The remaining dtors make some progress each time around the scheduler loop,\n+        // until they return `false` to indicate that they are done.\n+\n         // The macOS thread wide destructor runs \"before any TLS slots get\n         // freed\", so do that first.\n         if this.schedule_macos_tls_dtor()? {\n@@ -367,6 +367,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // All dtors done!\n         this.machine.tls.delete_all_thread_tls(active_thread);\n+        this.thread_terminated()?;\n \n         Ok(())\n     }"}, {"sha": "cefe334574b44206f274d84b763cca88220120ea", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "patch": "@@ -469,10 +469,10 @@ impl Stacks {\n             // `Global` memory can be referenced by global pointers from `tcx`.\n             // Thus we call `global_base_ptr` such that the global pointers get the same tag\n             // as what we use here.\n-            // `ExternGlobal` is used for extern statics, and thus must also be listed here.\n+            // `ExternStatic` is used for extern statics, and thus must also be listed here.\n             // `Env` we list because we can get away with precise tracking there.\n             // The base pointer is not unique, so the base permission is `SharedReadWrite`.\n-            MemoryKind::Machine(MiriMemoryKind::Global | MiriMemoryKind::ExternGlobal | MiriMemoryKind::Env) =>\n+            MemoryKind::Machine(MiriMemoryKind::Global | MiriMemoryKind::ExternStatic | MiriMemoryKind::Tls | MiriMemoryKind::Env) =>\n                 (extra.borrow_mut().global_base_ptr(id), Permission::SharedReadWrite),\n             // Everything else we handle entirely untagged for now.\n             // FIXME: experiment with more precise tracking."}, {"sha": "1e710a25edc995db76bb478f2a3b4826b540b25d", "filename": "src/thread.rs", "status": "modified", "additions": 47, "deletions": 78, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "patch": "@@ -11,11 +11,6 @@ use log::trace;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::{\n-    middle::codegen_fn_attrs::CodegenFnAttrFlags,\n-    mir,\n-    ty::{self, Instance},\n-};\n \n use crate::sync::SynchronizationState;\n use crate::*;\n@@ -415,6 +410,33 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         None\n     }\n \n+    /// Wakes up threads joining on the active one and deallocates thread-local statics.\n+    /// The `AllocId` that can now be freed is returned.\n+    fn thread_terminated(&mut self) -> Vec<AllocId> {\n+        let mut free_tls_statics = Vec::new();\n+        {\n+            let mut thread_local_statics = self.thread_local_alloc_ids.borrow_mut();\n+            thread_local_statics.retain(|&(_def_id, thread), &mut alloc_id| {\n+                if thread != self.active_thread {\n+                    // Keep this static around.\n+                    return true;\n+                }\n+                // Delete this static from the map and from memory.\n+                // We cannot free directly here as we cannot use `?` in this context.\n+                free_tls_statics.push(alloc_id);\n+                return false;\n+            });\n+        }\n+        // Check if we need to unblock any threads.\n+        for (i, thread) in self.threads.iter_enumerated_mut() {\n+            if thread.state == ThreadState::BlockedOnJoin(self.active_thread) {\n+                trace!(\"unblocking {:?} because {:?} terminated\", i, self.active_thread);\n+                thread.state = ThreadState::Enabled;\n+            }\n+        }\n+        return free_tls_statics;\n+    }\n+\n     /// Decide which action to take next and on which thread.\n     ///\n     /// The currently implemented scheduling policy is the one that is commonly\n@@ -426,13 +448,6 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         // checks whether the thread has popped all its stack and if yes, sets\n         // the thread state to terminated).\n         if self.threads[self.active_thread].check_terminated() {\n-            // Check if we need to unblock any threads.\n-            for (i, thread) in self.threads.iter_enumerated_mut() {\n-                if thread.state == ThreadState::BlockedOnJoin(self.active_thread) {\n-                    trace!(\"unblocking {:?} because {:?} terminated\", i, self.active_thread);\n-                    thread.state = ThreadState::Enabled;\n-                }\n-            }\n             return Ok(SchedulingAction::ExecuteDtors);\n         }\n         if self.threads[MAIN_THREAD].state == ThreadState::Terminated {\n@@ -499,48 +514,10 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n // Public interface to thread management.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    /// A workaround for thread-local statics until\n-    /// https://github.com/rust-lang/rust/issues/70685 is fixed: change the\n-    /// thread-local allocation id with a freshly generated allocation id for\n-    /// the currently active thread.\n-    fn remap_thread_local_alloc_ids(\n-        &self,\n-        val: &mut mir::interpret::ConstValue<'tcx>,\n-    ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_ref();\n-        match *val {\n-            mir::interpret::ConstValue::Scalar(Scalar::Ptr(ref mut ptr)) => {\n-                let alloc_id = ptr.alloc_id;\n-                let alloc = this.tcx.get_global_alloc(alloc_id);\n-                let tcx = this.tcx;\n-                let is_thread_local = |def_id| {\n-                    tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n-                };\n-                match alloc {\n-                    Some(GlobalAlloc::Static(def_id)) if is_thread_local(def_id) => {\n-                        ptr.alloc_id = this.get_or_create_thread_local_alloc_id(def_id)?;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {\n-                // FIXME: Handling only `Scalar` seems to work for now, but at\n-                // least in principle thread-locals could be in any constant, so\n-                // we should also consider other cases. However, once\n-                // https://github.com/rust-lang/rust/issues/70685 gets fixed,\n-                // this code will have to be rewritten anyway.\n-            }\n-        }\n-        Ok(())\n-    }\n-\n     /// Get a thread-specific allocation id for the given thread-local static.\n     /// If needed, allocate a new one.\n-    ///\n-    /// FIXME: This method should be replaced as soon as\n-    /// https://github.com/rust-lang/rust/issues/70685 gets fixed.\n-    fn get_or_create_thread_local_alloc_id(&self, def_id: DefId) -> InterpResult<'tcx, AllocId> {\n-        let this = self.eval_context_ref();\n+    fn get_or_create_thread_local_alloc_id(&mut self, def_id: DefId) -> InterpResult<'tcx, AllocId> {\n+        let this = self.eval_context_mut();\n         let tcx = this.tcx;\n         if let Some(new_alloc_id) = this.machine.threads.get_thread_local_alloc_id(def_id) {\n             // We already have a thread-specific allocation id for this\n@@ -549,35 +526,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         } else {\n             // We need to allocate a thread-specific allocation id for this\n             // thread-local static.\n-            //\n-            // At first, we invoke the `const_eval_raw` query and extract the\n-            // allocation from it. Unfortunately, we have to duplicate the code\n-            // from `Memory::get_global_alloc` that does this.\n-            //\n-            // Then we store the retrieved allocation back into the `alloc_map`\n-            // to get a fresh allocation id, which we can use as a\n-            // thread-specific allocation id for the thread-local static.\n+            // First, we compute the initial value for this static.\n             if tcx.is_foreign_item(def_id) {\n                 throw_unsup_format!(\"foreign thread-local statics are not supported\");\n             }\n-            // Invoke the `const_eval_raw` query.\n-            let instance = Instance::mono(tcx.tcx, def_id);\n-            let gid = GlobalId { instance, promoted: None };\n-            let raw_const =\n-                tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n-                    // no need to report anything, the const_eval call takes care of that\n-                    // for statics\n-                    assert!(tcx.is_static(def_id));\n-                    err\n-                })?;\n-            let id = raw_const.alloc_id;\n-            // Extract the allocation from the query result.\n-            let allocation = tcx.global_alloc(id).unwrap_memory();\n-            // Create a new allocation id for the same allocation in this hacky\n-            // way. Internally, `alloc_map` deduplicates allocations, but this\n-            // is fine because Miri will make a copy before a first mutable\n-            // access.\n-            let new_alloc_id = tcx.create_memory_alloc(allocation);\n+            let allocation = interpret::get_static(*tcx, def_id)?;\n+            // Create a fresh allocation with this content.\n+            let new_alloc_id = this.memory.allocate_with(allocation.clone(), MiriMemoryKind::Tls.into()).alloc_id;\n             this.machine.threads.set_thread_local_alloc_id(def_id, new_alloc_id);\n             Ok(new_alloc_id)\n         }\n@@ -717,4 +672,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         this.machine.threads.schedule()\n     }\n+\n+    /// Handles thread termination of the active thread: wakes up threads joining on this one,\n+    /// and deallocated thread-local statics.\n+    ///\n+    /// This is called from `tls.rs` after handling the TLS dtors.\n+    #[inline]\n+    fn thread_terminated(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        for alloc_id in this.machine.threads.thread_terminated() {\n+            let ptr = this.memory.global_base_pointer(alloc_id.into())?;\n+            this.memory.deallocate(ptr, None, MiriMemoryKind::Tls.into())?;\n+        }\n+        Ok(())\n+    }\n }"}, {"sha": "73e4ab596585d6dfe9c1483da7f66d20894701a1", "filename": "tests/compile-fail/concurrency/thread_local_static_dealloc.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/tests%2Fcompile-fail%2Fconcurrency%2Fthread_local_static_dealloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/tests%2Fcompile-fail%2Fconcurrency%2Fthread_local_static_dealloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconcurrency%2Fthread_local_static_dealloc.rs?ref=79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "patch": "@@ -0,0 +1,13 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+//! Ensure that thread-local statics get deallocated when the thread dies.\n+\n+#![feature(thread_local)]\n+\n+#[thread_local]\n+static mut TLS: u8 = 0;\n+\n+fn main() { unsafe {\n+    let dangling_ptr = std::thread::spawn(|| &TLS as *const u8 as usize).join().unwrap();\n+    let _val = *(dangling_ptr as *const u8); //~ ERROR dereferenced after this allocation got freed\n+} }"}, {"sha": "650dfd0ac7878bc5956dd21b82d6fe6b5bc066fe", "filename": "tests/compile-fail/extern_static.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/tests%2Fcompile-fail%2Fextern_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/tests%2Fcompile-fail%2Fextern_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fextern_static.rs?ref=79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "patch": "@@ -0,0 +1,10 @@\n+#![feature(raw_ref_op)]\n+//! Even referencing an unknown `extern static` already triggers an error.\n+\n+extern \"C\" {\n+    static mut FOO: i32;\n+}\n+\n+fn main() {\n+    let _val = unsafe { &raw const FOO }; //~ ERROR is not supported by Miri\n+}"}, {"sha": "46f59ef6204f713ceddbd264523983a0e6c1c10e", "filename": "tests/run-pass/concurrency/tls_lib_drop.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/tests%2Frun-pass%2Fconcurrency%2Ftls_lib_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/tests%2Frun-pass%2Fconcurrency%2Ftls_lib_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Ftls_lib_drop.rs?ref=79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "patch": "@@ -9,7 +9,8 @@ struct TestCell {\n \n impl Drop for TestCell {\n     fn drop(&mut self) {\n-        println!(\"Dropping: {}\", self.value.borrow())\n+        for _ in 0..10 { thread::yield_now(); }\n+        println!(\"Dropping: {} (should be before 'Continue main 1').\", self.value.borrow())\n     }\n }\n \n@@ -28,7 +29,7 @@ fn check_destructors() {\n     })\n     .join()\n     .unwrap();\n-    println!(\"Continue main.\")\n+    println!(\"Continue main 1.\")\n }\n \n struct JoinCell {\n@@ -37,8 +38,9 @@ struct JoinCell {\n \n impl Drop for JoinCell {\n     fn drop(&mut self) {\n+        for _ in 0..10 { thread::yield_now(); }\n         let join_handle = self.value.borrow_mut().take().unwrap();\n-        println!(\"Joining: {}\", join_handle.join().unwrap());\n+        println!(\"Joining: {} (should be before 'Continue main 2').\", join_handle.join().unwrap());\n     }\n }\n "}, {"sha": "484979b04ca777b38450453029b077d85b48f08f", "filename": "tests/run-pass/concurrency/tls_lib_drop.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/tests%2Frun-pass%2Fconcurrency%2Ftls_lib_drop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/tests%2Frun-pass%2Fconcurrency%2Ftls_lib_drop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Ftls_lib_drop.stdout?ref=79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "patch": "@@ -1,4 +1,4 @@\n-Dropping: 5\n-Continue main.\n+Dropping: 5 (should be before 'Continue main 1').\n+Continue main 1.\n+Joining: 7 (should be before 'Continue main 2').\n Continue main 2.\n-Joining: 7"}, {"sha": "811c370d812fe946962f0e682d5069985c75a0b9", "filename": "tests/run-pass/panic/catch_panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/tests%2Frun-pass%2Fpanic%2Fcatch_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2/tests%2Frun-pass%2Fpanic%2Fcatch_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fcatch_panic.rs?ref=79cd5a8d4a427570ccfe67d4b43b6a09a326f3d2", "patch": "@@ -1,4 +1,4 @@\n-// normalize-stderr-test \"[^ ]*libcore/[a-z/]+.rs[0-9:]*\" -> \"$$LOC\"\n+// normalize-stderr-test \"[^ ]*libcore/[a-z_/]+.rs[0-9:]*\" -> \"$$LOC\"\n #![feature(never_type)]\n #![allow(unconditional_panic)]\n "}]}