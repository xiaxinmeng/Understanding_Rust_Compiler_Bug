{"sha": "5cdd8d442ef5a573f4af07e68dce7720ca603aba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjZGQ4ZDQ0MmVmNWE1NzNmNGFmMDdlNjhkY2U3NzIwY2E2MDNhYmE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-28T21:42:44Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-28T21:42:44Z"}, "message": "Cleanup cargo process handling in flycheck", "tree": {"sha": "3e5a759068adf8607cc142144d3ec7d665d7e5f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e5a759068adf8607cc142144d3ec7d665d7e5f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cdd8d442ef5a573f4af07e68dce7720ca603aba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cdd8d442ef5a573f4af07e68dce7720ca603aba", "html_url": "https://github.com/rust-lang/rust/commit/5cdd8d442ef5a573f4af07e68dce7720ca603aba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cdd8d442ef5a573f4af07e68dce7720ca603aba/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32e85a1a89877dc1314ea950bd4cba43d9ad9627", "url": "https://api.github.com/repos/rust-lang/rust/commits/32e85a1a89877dc1314ea950bd4cba43d9ad9627", "html_url": "https://github.com/rust-lang/rust/commit/32e85a1a89877dc1314ea950bd4cba43d9ad9627"}], "stats": {"total": 127, "additions": 66, "deletions": 61}, "files": [{"sha": "1023d3040f99d626ff430c9a51290f88175af586", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 61, "deletions": 60, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/5cdd8d442ef5a573f4af07e68dce7720ca603aba/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cdd8d442ef5a573f4af07e68dce7720ca603aba/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=5cdd8d442ef5a573f4af07e68dce7720ca603aba", "patch": "@@ -85,7 +85,7 @@ pub enum Message {\n pub enum Progress {\n     DidStart,\n     DidCheckCrate(String),\n-    DidFinish,\n+    DidFinish(io::Result<()>),\n     DidCancel,\n }\n \n@@ -100,7 +100,7 @@ struct FlycheckActor {\n     /// doesn't provide a way to read sub-process output without blocking, so we\n     /// have to wrap sub-processes output handling in a thread and pass messages\n     /// back over a channel.\n-    check_process: Option<CargoHandle>,\n+    cargo_handle: Option<CargoHandle>,\n }\n \n enum Event {\n@@ -114,10 +114,10 @@ impl FlycheckActor {\n         config: FlycheckConfig,\n         workspace_root: PathBuf,\n     ) -> FlycheckActor {\n-        FlycheckActor { sender, config, workspace_root, check_process: None }\n+        FlycheckActor { sender, config, workspace_root, cargo_handle: None }\n     }\n     fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n-        let check_chan = self.check_process.as_ref().map(|cargo| &cargo.receiver);\n+        let check_chan = self.cargo_handle.as_ref().map(|cargo| &cargo.receiver);\n         select! {\n             recv(inbox) -> msg => msg.ok().map(Event::Restart),\n             recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n@@ -128,15 +128,22 @@ impl FlycheckActor {\n             match event {\n                 Event::Restart(Restart) => {\n                     while let Ok(Restart) = inbox.recv_timeout(Duration::from_millis(50)) {}\n+\n                     self.cancel_check_process();\n-                    self.check_process = Some(self.start_check_process());\n-                    self.send(Message::Progress(Progress::DidStart));\n+\n+                    let mut command = self.check_command();\n+                    command.stdout(Stdio::piped()).stderr(Stdio::null()).stdin(Stdio::null());\n+                    if let Ok(child) = command.spawn().map(JodChild) {\n+                        self.cargo_handle = Some(CargoHandle::spawn(child));\n+                        self.send(Message::Progress(Progress::DidStart));\n+                    }\n                 }\n                 Event::CheckEvent(None) => {\n                     // Watcher finished, replace it with a never channel to\n                     // avoid busy-waiting.\n-                    assert!(self.check_process.take().is_some());\n-                    self.send(Message::Progress(Progress::DidFinish));\n+                    let cargo_handle = self.cargo_handle.take().unwrap();\n+                    let res = cargo_handle.join();\n+                    self.send(Message::Progress(Progress::DidFinish(res)));\n                 }\n                 Event::CheckEvent(Some(message)) => match message {\n                     cargo_metadata::Message::CompilerArtifact(msg) => {\n@@ -161,11 +168,11 @@ impl FlycheckActor {\n         self.cancel_check_process();\n     }\n     fn cancel_check_process(&mut self) {\n-        if self.check_process.take().is_some() {\n+        if self.cargo_handle.take().is_some() {\n             self.send(Message::Progress(Progress::DidCancel));\n         }\n     }\n-    fn start_check_process(&self) -> CargoHandle {\n+    fn check_command(&self) -> Command {\n         let mut cmd = match &self.config {\n             FlycheckConfig::CargoCommand {\n                 command,\n@@ -197,8 +204,7 @@ impl FlycheckActor {\n             }\n         };\n         cmd.current_dir(&self.workspace_root);\n-\n-        CargoHandle::spawn(cmd)\n+        cmd\n     }\n \n     fn send(&self, check_task: Message) {\n@@ -207,49 +213,62 @@ impl FlycheckActor {\n }\n \n struct CargoHandle {\n-    receiver: Receiver<cargo_metadata::Message>,\n+    child: JodChild,\n     #[allow(unused)]\n-    thread: jod_thread::JoinHandle,\n+    thread: jod_thread::JoinHandle<io::Result<bool>>,\n+    receiver: Receiver<cargo_metadata::Message>,\n }\n \n impl CargoHandle {\n-    fn spawn(command: Command) -> CargoHandle {\n+    fn spawn(mut child: JodChild) -> CargoHandle {\n+        let child_stdout = child.stdout.take().unwrap();\n         let (sender, receiver) = unbounded();\n-        let actor = CargoActor::new(command, sender);\n-        let thread = jod_thread::spawn(move || {\n-            let _ = actor.run();\n-        });\n-        CargoHandle { receiver, thread }\n+        let actor = CargoActor::new(child_stdout, sender);\n+        let thread = jod_thread::spawn(move || actor.run());\n+        CargoHandle { child, thread, receiver }\n+    }\n+    fn join(mut self) -> io::Result<()> {\n+        // It is okay to ignore the result, as it only errors if the process is already dead\n+        let _ = self.child.kill();\n+        let exit_status = self.child.wait()?;\n+        let read_at_least_one_message = self.thread.join()?;\n+        if !exit_status.success() && !read_at_least_one_message {\n+            // FIXME: Read the stderr to display the reason, see `read2()` reference in PR comment:\n+            // https://github.com/rust-analyzer/rust-analyzer/pull/3632#discussion_r395605298\n+            return Err(io::Error::new(\n+                io::ErrorKind::Other,\n+                format!(\n+                    \"Cargo watcher failed,the command produced no valid metadata (exit code: {:?})\",\n+                    exit_status\n+                ),\n+            ));\n+        }\n+        Ok(())\n     }\n }\n \n struct CargoActor {\n-    command: Command,\n+    child_stdout: process::ChildStdout,\n     sender: Sender<cargo_metadata::Message>,\n }\n \n impl CargoActor {\n-    fn new(command: Command, sender: Sender<cargo_metadata::Message>) -> CargoActor {\n-        CargoActor { command, sender }\n+    fn new(\n+        child_stdout: process::ChildStdout,\n+        sender: Sender<cargo_metadata::Message>,\n+    ) -> CargoActor {\n+        CargoActor { child_stdout, sender }\n     }\n-    fn run(mut self) -> io::Result<()> {\n-        let child = self\n-            .command\n-            .stdout(Stdio::piped())\n-            .stderr(Stdio::null())\n-            .stdin(Stdio::null())\n-            .spawn()?;\n-        let mut child = ChildKiller(child);\n-\n+    fn run(self) -> io::Result<bool> {\n         // We manually read a line at a time, instead of using serde's\n         // stream deserializers, because the deserializer cannot recover\n         // from an error, resulting in it getting stuck, because we try to\n-        // be resillient against failures.\n+        // be resilient against failures.\n         //\n         // Because cargo only outputs one JSON object per line, we can\n         // simply skip a line if it doesn't parse, which just ignores any\n         // erroneus output.\n-        let stdout = BufReader::new(child.stdout.take().unwrap());\n+        let stdout = BufReader::new(self.child_stdout);\n         let mut read_at_least_one_message = false;\n         for message in cargo_metadata::Message::parse_stream(stdout) {\n             let message = match message {\n@@ -264,50 +283,32 @@ impl CargoActor {\n \n             // Skip certain kinds of messages to only spend time on what's useful\n             match &message {\n-                cargo_metadata::Message::CompilerArtifact(artifact) if artifact.fresh => continue,\n+                cargo_metadata::Message::CompilerArtifact(artifact) if artifact.fresh => (),\n                 cargo_metadata::Message::BuildScriptExecuted(_)\n-                | cargo_metadata::Message::Unknown => continue,\n-                _ => {\n-                    // if the send channel was closed, we want to shutdown\n-                    if self.sender.send(message).is_err() {\n-                        break;\n-                    }\n-                }\n+                | cargo_metadata::Message::Unknown => (),\n+                _ => self.sender.send(message).unwrap(),\n             }\n         }\n-\n-        // It is okay to ignore the result, as it only errors if the process is already dead\n-        let _ = child.kill();\n-\n-        let exit_status = child.wait()?;\n-        if !exit_status.success() && !read_at_least_one_message {\n-            // FIXME: Read the stderr to display the reason, see `read2()` reference in PR comment:\n-            // https://github.com/rust-analyzer/rust-analyzer/pull/3632#discussion_r395605298\n-\n-            // FIXME: make the `message_send` to be `Sender<Result<CheckEvent, CargoError>>`\n-            // to display user-caused misconfiguration errors instead of just logging them here\n-            log::error!(\"Cargo watcher failed,the command produced no valid metadata (exit code: {:?}): {:?}\", exit_status, self.command);\n-        }\n-        Ok(())\n+        Ok(read_at_least_one_message)\n     }\n }\n \n-struct ChildKiller(process::Child);\n+struct JodChild(process::Child);\n \n-impl ops::Deref for ChildKiller {\n+impl ops::Deref for JodChild {\n     type Target = process::Child;\n     fn deref(&self) -> &process::Child {\n         &self.0\n     }\n }\n \n-impl ops::DerefMut for ChildKiller {\n+impl ops::DerefMut for JodChild {\n     fn deref_mut(&mut self) -> &mut process::Child {\n         &mut self.0\n     }\n }\n \n-impl Drop for ChildKiller {\n+impl Drop for JodChild {\n     fn drop(&mut self) {\n         let _ = self.0.kill();\n     }"}, {"sha": "9fd16ef3b4a3cd619e3c073aafed32cd50faf2fa", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cdd8d442ef5a573f4af07e68dce7720ca603aba/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cdd8d442ef5a573f4af07e68dce7720ca603aba/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=5cdd8d442ef5a573f4af07e68dce7720ca603aba", "patch": "@@ -216,7 +216,11 @@ impl GlobalState {\n                         flycheck::Progress::DidCheckCrate(target) => {\n                             (Progress::Report, Some(target))\n                         }\n-                        flycheck::Progress::DidFinish | flycheck::Progress::DidCancel => {\n+                        flycheck::Progress::DidCancel => (Progress::End, None),\n+                        flycheck::Progress::DidFinish(result) => {\n+                            if let Err(err) = result {\n+                                log::error!(\"cargo check failed: {}\", err)\n+                            }\n                             (Progress::End, None)\n                         }\n                     };"}]}