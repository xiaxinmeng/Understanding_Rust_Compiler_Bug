{"sha": "444e52e519a06e5ac397edf6fa2f4f2e06537e4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NGU1MmU1MTlhMDZlNWFjMzk3ZWRmNmZhMmY0ZjJlMDY1MzdlNGU=", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2019-05-22T16:49:22Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2019-05-23T09:32:47Z"}, "message": "Move NameRef classification logic out of reference_definition", "tree": {"sha": "21f3be8eeb51e97aae3bd848250e395710615937", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21f3be8eeb51e97aae3bd848250e395710615937"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/444e52e519a06e5ac397edf6fa2f4f2e06537e4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/444e52e519a06e5ac397edf6fa2f4f2e06537e4e", "html_url": "https://github.com/rust-lang/rust/commit/444e52e519a06e5ac397edf6fa2f4f2e06537e4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/444e52e519a06e5ac397edf6fa2f4f2e06537e4e/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a25e103e4542637047fe388a926aebddca07b3b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a25e103e4542637047fe388a926aebddca07b3b7", "html_url": "https://github.com/rust-lang/rust/commit/a25e103e4542637047fe388a926aebddca07b3b7"}], "stats": {"total": 241, "additions": 144, "deletions": 97}, "files": [{"sha": "ecea2444e2d59fac069fe920c2535ed6bee78db4", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/444e52e519a06e5ac397edf6fa2f4f2e06537e4e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/444e52e519a06e5ac397edf6fa2f4f2e06537e4e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=444e52e519a06e5ac397edf6fa2f4f2e06537e4e", "patch": "@@ -1089,6 +1089,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\",\n+ \"ra_prof 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "1c694cbc9b0f683caea14dcdd5440606bbb3260a", "filename": "crates/ra_ide_api/src/display/navigation_target.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/444e52e519a06e5ac397edf6fa2f4f2e06537e4e/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444e52e519a06e5ac397edf6fa2f4f2e06537e4e/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=444e52e519a06e5ac397edf6fa2f4f2e06537e4e", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     ast::{self, NameOwner, VisibilityOwner, TypeAscriptionOwner},\n     algo::visit::{visitor, Visitor},\n };\n-use hir::{ModuleSource, FieldSource, ImplItem, Either};\n+use hir::{ModuleSource, FieldSource, ImplItem};\n \n use crate::{FileSymbol, db::RootDatabase};\n \n@@ -77,17 +77,12 @@ impl NavigationTarget {\n     pub(crate) fn from_pat(\n         db: &RootDatabase,\n         file_id: FileId,\n-        pat: Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>,\n+        pat: AstPtr<ast::Pat>,\n     ) -> NavigationTarget {\n         let file = db.parse(file_id);\n-        let (name, full_range) = match pat {\n-            Either::A(pat) => match pat.to_node(file.syntax()).kind() {\n-                ast::PatKind::BindPat(pat) => {\n-                    return NavigationTarget::from_bind_pat(file_id, &pat)\n-                }\n-                _ => (\"_\".into(), pat.syntax_node_ptr().range()),\n-            },\n-            Either::B(slf) => (\"self\".into(), slf.syntax_node_ptr().range()),\n+        let (name, full_range) = match pat.to_node(file.syntax()).kind() {\n+            ast::PatKind::BindPat(pat) => return NavigationTarget::from_bind_pat(file_id, &pat),\n+            _ => (\"_\".into(), pat.syntax_node_ptr().range()),\n         };\n         NavigationTarget {\n             file_id,\n@@ -99,6 +94,21 @@ impl NavigationTarget {\n         }\n     }\n \n+    pub(crate) fn from_self_param(\n+        file_id: FileId,\n+        par: AstPtr<ast::SelfParam>,\n+    ) -> NavigationTarget {\n+        let (name, full_range) = (\"self\".into(), par.syntax_node_ptr().range());\n+        NavigationTarget {\n+            file_id,\n+            name,\n+            full_range,\n+            focus_range: None,\n+            kind: NAME,\n+            container_name: None,\n+        }\n+    }\n+\n     pub(crate) fn from_module(db: &RootDatabase, module: hir::Module) -> NavigationTarget {\n         let (file_id, source) = module.definition_source(db);\n         let file_id = file_id.as_original_file();"}, {"sha": "9c56f17f2cc5891ec8bf08ad0cd77ea8757ea05a", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 25, "deletions": 79, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/444e52e519a06e5ac397edf6fa2f4f2e06537e4e/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444e52e519a06e5ac397edf6fa2f4f2e06537e4e/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=444e52e519a06e5ac397edf6fa2f4f2e06537e4e", "patch": "@@ -1,12 +1,19 @@\n use ra_db::{FileId, SourceDatabase};\n use ra_syntax::{\n     AstNode, ast,\n-    algo::{find_node_at_offset, visit::{visitor, Visitor}},\n+    algo::{\n+        find_node_at_offset,\n+        visit::{visitor, Visitor},\n+    },\n     SyntaxNode,\n };\n-use test_utils::tested_by;\n \n-use crate::{FilePosition, NavigationTarget, db::RootDatabase, RangeInfo};\n+use crate::{\n+    FilePosition, NavigationTarget,\n+    db::RootDatabase,\n+    RangeInfo,\n+    name_ref_kind::{NameRefKind::*, classify_name_ref},\n+};\n \n pub(crate) fn goto_definition(\n     db: &RootDatabase,\n@@ -50,85 +57,24 @@ pub(crate) fn reference_definition(\n \n     let analyzer = hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n \n-    // Special cases:\n-\n-    // Check if it is a method\n-    if let Some(method_call) = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast) {\n-        tested_by!(goto_definition_works_for_methods);\n-        if let Some(func) = analyzer.resolve_method_call(method_call) {\n-            return Exact(NavigationTarget::from_function(db, func));\n-        }\n-    }\n-\n-    //it could be a macro call\n-    if let Some(macro_call) = name_ref\n-        .syntax()\n-        .parent()\n-        .and_then(|node| node.parent())\n-        .and_then(|node| node.parent())\n-        .and_then(ast::MacroCall::cast)\n-    {\n-        tested_by!(goto_definition_works_for_macros);\n-        if let Some(macro_call) = analyzer.resolve_macro_call(macro_call) {\n-            return Exact(NavigationTarget::from_macro_def(db, macro_call));\n-        }\n-    }\n-\n-    // It could also be a field access\n-    if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::FieldExpr::cast) {\n-        tested_by!(goto_definition_works_for_fields);\n-        if let Some(field) = analyzer.resolve_field(field_expr) {\n-            return Exact(NavigationTarget::from_field(db, field));\n-        };\n-    }\n-\n-    // It could also be a named field\n-    if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::NamedField::cast) {\n-        tested_by!(goto_definition_works_for_named_fields);\n-\n-        let struct_lit = field_expr.syntax().ancestors().find_map(ast::StructLit::cast);\n-\n-        if let Some(ty) = struct_lit.and_then(|lit| analyzer.type_of(db, lit.into())) {\n-            if let Some((hir::AdtDef::Struct(s), _)) = ty.as_adt() {\n-                let hir_path = hir::Path::from_name_ref(name_ref);\n-                let hir_name = hir_path.as_ident().unwrap();\n-\n-                if let Some(field) = s.field(db, hir_name) {\n-                    return Exact(NavigationTarget::from_field(db, field));\n-                }\n+    match classify_name_ref(db, &analyzer, name_ref) {\n+        Some(Method(func)) => return Exact(NavigationTarget::from_function(db, func)),\n+        Some(Macro(mac)) => return Exact(NavigationTarget::from_macro_def(db, mac)),\n+        Some(FieldAccess(field)) => return Exact(NavigationTarget::from_field(db, field)),\n+        Some(AssocItem(assoc)) => return Exact(NavigationTarget::from_impl_item(db, assoc)),\n+        Some(Def(def)) => return Exact(NavigationTarget::from_def(db, def)),\n+        Some(SelfType(ty)) => {\n+            if let Some((def_id, _)) = ty.as_adt() {\n+                return Exact(NavigationTarget::from_adt_def(db, def_id));\n             }\n         }\n-    }\n-\n-    // General case, a path or a local:\n-    if let Some(path) = name_ref.syntax().ancestors().find_map(ast::Path::cast) {\n-        if let Some(resolved) = analyzer.resolve_path(db, path) {\n-            match resolved {\n-                hir::PathResolution::Def(def) => return Exact(NavigationTarget::from_def(db, def)),\n-                hir::PathResolution::LocalBinding(pat) => {\n-                    let nav = NavigationTarget::from_pat(db, file_id, pat);\n-                    return Exact(nav);\n-                }\n-                hir::PathResolution::GenericParam(..) => {\n-                    // FIXME: go to the generic param def\n-                }\n-                hir::PathResolution::Macro(def) => {\n-                    let nav = NavigationTarget::from_macro_def(db, def);\n-                    return Exact(nav);\n-                }\n-                hir::PathResolution::SelfType(impl_block) => {\n-                    let ty = impl_block.target_ty(db);\n-\n-                    if let Some((def_id, _)) = ty.as_adt() {\n-                        return Exact(NavigationTarget::from_adt_def(db, def_id));\n-                    }\n-                }\n-                hir::PathResolution::AssocItem(assoc) => {\n-                    return Exact(NavigationTarget::from_impl_item(db, assoc));\n-                }\n-            }\n+        Some(Pat(pat)) => return Exact(NavigationTarget::from_pat(db, file_id, pat)),\n+        Some(SelfParam(par)) => return Exact(NavigationTarget::from_self_param(file_id, par)),\n+        Some(GenericParam(_)) => {\n+            // FIXME: go to the generic param def\n         }\n-    }\n+        None => {}\n+    };\n \n     // Fallback index based approach:\n     let navs = crate::symbol_index::index_resolve(db, name_ref)"}, {"sha": "f78348f7452c070f32f96d29b875821f9522ee38", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/444e52e519a06e5ac397edf6fa2f4f2e06537e4e/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444e52e519a06e5ac397edf6fa2f4f2e06537e4e/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=444e52e519a06e5ac397edf6fa2f4f2e06537e4e", "patch": "@@ -18,6 +18,7 @@ mod change;\n mod status;\n mod completion;\n mod runnables;\n+mod name_ref_kind;\n mod goto_definition;\n mod goto_type_definition;\n mod extend_selection;\n@@ -53,10 +54,7 @@ use ra_db::{\n };\n use relative_path::RelativePathBuf;\n \n-use crate::{\n-    symbol_index::FileSymbol,\n-    db::LineIndexDatabase,\n-};\n+use crate::{symbol_index::FileSymbol, db::LineIndexDatabase};\n \n pub use crate::{\n     change::{AnalysisChange, LibraryData},\n@@ -73,10 +71,7 @@ pub use crate::{\n     display::{FunctionSignature, NavigationTarget, StructureNode, file_structure},\n };\n \n-pub use ra_db::{\n-    Canceled, CrateGraph, CrateId, FileId, FilePosition, FileRange, SourceRootId,\n-    Edition\n-};\n+pub use ra_db::{Canceled, CrateGraph, CrateId, FileId, FilePosition, FileRange, SourceRootId, Edition};\n pub use hir::Documentation;\n \n // We use jemalloc mainly to get heap usage statistics, actual performance"}, {"sha": "b498fe4950014914d44a2e6fa2c177396d7f830b", "filename": "crates/ra_ide_api/src/name_ref_kind.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/444e52e519a06e5ac397edf6fa2f4f2e06537e4e/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/444e52e519a06e5ac397edf6fa2f4f2e06537e4e/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs?ref=444e52e519a06e5ac397edf6fa2f4f2e06537e4e", "patch": "@@ -0,0 +1,95 @@\n+use ra_syntax::{AstNode, AstPtr, ast};\n+use hir::Either;\n+use crate::db::RootDatabase;\n+use test_utils::tested_by;\n+\n+pub enum NameRefKind {\n+    Method(hir::Function),\n+    Macro(hir::MacroByExampleDef),\n+    FieldAccess(hir::StructField),\n+    AssocItem(hir::ImplItem),\n+    Def(hir::ModuleDef),\n+    SelfType(hir::Ty),\n+    Pat(AstPtr<ast::Pat>),\n+    SelfParam(AstPtr<ast::SelfParam>),\n+    GenericParam(u32),\n+}\n+\n+pub(crate) fn classify_name_ref(\n+    db: &RootDatabase,\n+    analyzer: &hir::SourceAnalyzer,\n+    name_ref: &ast::NameRef,\n+) -> Option<NameRefKind> {\n+    use NameRefKind::*;\n+\n+    // Check if it is a method\n+    if let Some(method_call) = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast) {\n+        tested_by!(goto_definition_works_for_methods);\n+        if let Some(func) = analyzer.resolve_method_call(method_call) {\n+            return Some(Method(func));\n+        }\n+    }\n+\n+    // It could be a macro call\n+    if let Some(macro_call) = name_ref\n+        .syntax()\n+        .parent()\n+        .and_then(|node| node.parent())\n+        .and_then(|node| node.parent())\n+        .and_then(ast::MacroCall::cast)\n+    {\n+        tested_by!(goto_definition_works_for_macros);\n+        if let Some(mac) = analyzer.resolve_macro_call(macro_call) {\n+            return Some(Macro(mac));\n+        }\n+    }\n+\n+    // It could also be a field access\n+    if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::FieldExpr::cast) {\n+        tested_by!(goto_definition_works_for_fields);\n+        if let Some(field) = analyzer.resolve_field(field_expr) {\n+            return Some(FieldAccess(field));\n+        };\n+    }\n+\n+    // It could also be a named field\n+    if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::NamedField::cast) {\n+        tested_by!(goto_definition_works_for_named_fields);\n+\n+        let struct_lit = field_expr.syntax().ancestors().find_map(ast::StructLit::cast);\n+\n+        if let Some(ty) = struct_lit.and_then(|lit| analyzer.type_of(db, lit.into())) {\n+            if let Some((hir::AdtDef::Struct(s), _)) = ty.as_adt() {\n+                let hir_path = hir::Path::from_name_ref(name_ref);\n+                let hir_name = hir_path.as_ident().unwrap();\n+\n+                if let Some(field) = s.field(db, hir_name) {\n+                    return Some(FieldAccess(field));\n+                }\n+            }\n+        }\n+    }\n+\n+    // General case, a path or a local:\n+    if let Some(path) = name_ref.syntax().ancestors().find_map(ast::Path::cast) {\n+        if let Some(resolved) = analyzer.resolve_path(db, path) {\n+            return match resolved {\n+                hir::PathResolution::Def(def) => Some(Def(def)),\n+                hir::PathResolution::LocalBinding(Either::A(pat)) => Some(Pat(pat)),\n+                hir::PathResolution::LocalBinding(Either::B(par)) => Some(SelfParam(par)),\n+                hir::PathResolution::GenericParam(par) => {\n+                    // FIXME: get generic param def\n+                    Some(GenericParam(par))\n+                }\n+                hir::PathResolution::Macro(def) => Some(Macro(def)),\n+                hir::PathResolution::SelfType(impl_block) => {\n+                    let ty = impl_block.target_ty(db);\n+                    Some(SelfType(ty))\n+                }\n+                hir::PathResolution::AssocItem(assoc) => Some(AssocItem(assoc)),\n+            };\n+        }\n+    }\n+\n+    None\n+}"}]}