{"sha": "6535da84176bb1a72871a89740b0def9221cc351", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MzVkYTg0MTc2YmIxYTcyODcxYTg5NzQwYjBkZWY5MjIxY2MzNTE=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-18T22:03:46Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-25T19:12:25Z"}, "message": "Tighten pipe exports, and refactor traits.", "tree": {"sha": "453d6dbc8b4ba769fb20560f8d713d71b9e231cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/453d6dbc8b4ba769fb20560f8d713d71b9e231cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6535da84176bb1a72871a89740b0def9221cc351", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6535da84176bb1a72871a89740b0def9221cc351", "html_url": "https://github.com/rust-lang/rust/commit/6535da84176bb1a72871a89740b0def9221cc351", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6535da84176bb1a72871a89740b0def9221cc351/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "729c37f3cc710b3b76cc46b160a52ed38519de7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/729c37f3cc710b3b76cc46b160a52ed38519de7f", "html_url": "https://github.com/rust-lang/rust/commit/729c37f3cc710b3b76cc46b160a52ed38519de7f"}], "stats": {"total": 77, "additions": 50, "deletions": 27}, "files": [{"sha": "a94ed6a54dc15aed917f46e35383cdead803f013", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6535da84176bb1a72871a89740b0def9221cc351/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535da84176bb1a72871a89740b0def9221cc351/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=6535da84176bb1a72871a89740b0def9221cc351", "patch": "@@ -7,7 +7,7 @@ type IMPL_T<A> = dlist::dlist<A>;\n  * e.g. breadth-first search with in-place enqueues), but removing the current\n  * node is forbidden.\n  */\n-fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n+pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n     import dlist::extensions;\n \n     let mut link = self.peek_n();"}, {"sha": "87763b273da65f049f2304e9518501e4a679eb92", "filename": "src/libcore/iter-trait/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6535da84176bb1a72871a89740b0def9221cc351/src%2Flibcore%2Fiter-trait%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535da84176bb1a72871a89740b0def9221cc351/src%2Flibcore%2Fiter-trait%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Foption.rs?ref=6535da84176bb1a72871a89740b0def9221cc351", "patch": "@@ -1,6 +1,6 @@\n type IMPL_T<A> = option<A>;\n \n-fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n+pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n     alt self {\n       none { }\n       some(a) { f(a); }"}, {"sha": "2e463df9e90017aede723a1fa47ccca285aed93f", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6535da84176bb1a72871a89740b0def9221cc351/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6535da84176bb1a72871a89740b0def9221cc351/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=6535da84176bb1a72871a89740b0def9221cc351", "patch": "@@ -5,17 +5,22 @@ import either::{either, left, right};\n import option::unwrap;\n import arc::methods;\n \n-/* Use this after the snapshot\n+// Things used by code generated by the pipe compiler.\n+export entangle;\n+\n+// User-level things\n+export send_packet, recv_packet, send, recv, try_recv, peek;\n+export select, select2, selecti, select2i, selectable;\n+export spawn_service, spawn_service_recv;\n+export stream, port, chan, shared_chan, port_set, channel;\n+\n macro_rules! move {\n     { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n }\n-*/\n \n-fn macros() {\n-    #macro[\n-        [#move(x), { unsafe { let y <- *ptr::addr_of(x); y } }]\n-    ];\n-}\n+// This is to help make sure we only move out of enums in safe\n+// places. Once there is unary move, it can be removed.\n+fn move<T>(-x: T) -> T { x }\n \n enum state {\n     empty,\n@@ -465,6 +470,19 @@ proto! streamp {\n     }\n }\n \n+// It'd be nice to call this send, but it'd conflict with the built in\n+// send kind.\n+trait channel<T: send> {\n+    fn send(+x: T);\n+}\n+\n+trait recv<T: send> {\n+    fn recv() -> T;\n+    fn try_recv() -> option<T>;\n+    // This should perhaps be a new trait\n+    pure fn peek() -> bool;\n+}\n+\n type chan_<T:send> = { mut endp: option<streamp::client::open<T>> };\n \n enum chan<T:send> {\n@@ -483,7 +501,7 @@ fn stream<T:send>() -> (chan<T>, port<T>) {\n     (chan_({ mut endp: some(c) }), port_({ mut endp: some(s) }))\n }\n \n-impl chan<T: send> for chan<T> {\n+impl chan<T: send> of channel<T> for chan<T> {\n     fn send(+x: T) {\n         let mut endp = none;\n         endp <-> self.endp;\n@@ -492,7 +510,7 @@ impl chan<T: send> for chan<T> {\n     }\n }\n \n-impl port<T: send> for port<T> {\n+impl port<T: send> of recv<T> for port<T> {\n     fn recv() -> T {\n         let mut endp = none;\n         endp <-> self.endp;\n@@ -504,10 +522,10 @@ impl port<T: send> for port<T> {\n     fn try_recv() -> option<T> {\n         let mut endp = none;\n         endp <-> self.endp;\n-        alt pipes::try_recv(unwrap(endp)) {\n+        alt move(pipes::try_recv(unwrap(endp))) {\n           some(streamp::data(x, endp)) {\n-            self.endp = some(#move(endp));\n-            some(#move(x))\n+            self.endp = some(move!{endp});\n+            some(move!{x})\n           }\n           none { none }\n         }\n@@ -528,7 +546,7 @@ impl port<T: send> for port<T> {\n }\n \n // Treat a whole bunch of ports as one.\n-class port_set<T: send> {\n+class port_set<T: send> : recv<T> {\n     let mut ports: ~[pipes::port<T>];\n \n     new() { self.ports = ~[]; }\n@@ -540,12 +558,12 @@ class port_set<T: send> {\n     fn try_recv() -> option<T> {\n         let mut result = none;\n         while result == none && self.ports.len() > 0 {\n-            let i = pipes::wait_many(self.ports.map(|p| p.header()));\n+            let i = wait_many(self.ports.map(|p| p.header()));\n             // dereferencing an unsafe pointer nonsense to appease the\n             // borrowchecker.\n-            alt unsafe {(*ptr::addr_of(self.ports[i])).try_recv()} {\n+            alt move(unsafe {(*ptr::addr_of(self.ports[i])).try_recv()}) {\n               some(m) {\n-                result = some(#move(m));\n+                  result = some(move!{m});\n               }\n               none {\n                 // Remove this port.\n@@ -562,10 +580,19 @@ class port_set<T: send> {\n     fn recv() -> T {\n         option::unwrap(self.try_recv())\n     }\n+\n+    pure fn peek() -> bool {\n+        // It'd be nice to use self.port.each, but that version isn't\n+        // pure.\n+        for vec::each(self.ports) |p| {\n+            if p.peek() { ret true }\n+        }\n+        false\n+    }\n }\n \n-impl<T: send> of selectable for pipes::port<T> {\n-    pure fn header() -> *pipes::packet_header unchecked {\n+impl<T: send> of selectable for port<T> {\n+    pure fn header() -> *packet_header unchecked {\n         alt self.endp {\n           some(endp) {\n             endp.header()\n@@ -576,13 +603,9 @@ impl<T: send> of selectable for pipes::port<T> {\n }\n \n \n-type shared_chan<T: send> = arc::exclusive<pipes::chan<T>>;\n-\n-trait send_on_shared_chan<T> {\n-    fn send(+x: T);\n-}\n+type shared_chan<T: send> = arc::exclusive<chan<T>>;\n \n-impl chan<T: send> of send_on_shared_chan<T> for shared_chan<T> {\n+impl chan<T: send> of channel<T> for shared_chan<T> {\n     fn send(+x: T) {\n         let mut xx = some(x);\n         do self.with |_c, chan| {\n@@ -593,6 +616,6 @@ impl chan<T: send> of send_on_shared_chan<T> for shared_chan<T> {\n     }\n }\n \n-fn shared_chan<T:send>(+c: pipes::chan<T>) -> shared_chan<T> {\n+fn shared_chan<T:send>(+c: chan<T>) -> shared_chan<T> {\n     arc::exclusive(c)\n }"}]}