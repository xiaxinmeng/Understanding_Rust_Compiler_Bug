{"sha": "b8b166e674327a1820bc99b0e8d3af020575746b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YjE2NmU2NzQzMjdhMTgyMGJjOTliMGU4ZDNhZjAyMDU3NTc0NmI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-07-18T10:13:03Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-07-18T10:13:03Z"}, "message": "fix: potential bugs when build scripts do not match the current project", "tree": {"sha": "87c6f24aedd8a72e622082a885c84cf8915df6f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87c6f24aedd8a72e622082a885c84cf8915df6f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8b166e674327a1820bc99b0e8d3af020575746b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8b166e674327a1820bc99b0e8d3af020575746b", "html_url": "https://github.com/rust-lang/rust/commit/b8b166e674327a1820bc99b0e8d3af020575746b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8b166e674327a1820bc99b0e8d3af020575746b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "html_url": "https://github.com/rust-lang/rust/commit/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a"}], "stats": {"total": 253, "additions": 173, "deletions": 80}, "files": [{"sha": "67a665a02765b22ffff345fcc44fe911107ca2e4", "filename": "crates/project_model/src/workspace.rs", "status": "modified", "additions": 68, "deletions": 17, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b8b166e674327a1820bc99b0e8d3af020575746b/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b166e674327a1820bc99b0e8d3af020575746b/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fworkspace.rs?ref=b8b166e674327a1820bc99b0e8d3af020575746b", "patch": "@@ -10,6 +10,7 @@ use cfg::{CfgDiff, CfgOptions};\n use paths::{AbsPath, AbsPathBuf};\n use proc_macro_api::ProcMacroClient;\n use rustc_hash::{FxHashMap, FxHashSet};\n+use stdx::always;\n \n use crate::{\n     build_scripts::BuildScriptOutput,\n@@ -39,6 +40,7 @@ pub enum ProjectWorkspace {\n     /// Project workspace was discovered by running `cargo metadata` and `rustc --print sysroot`.\n     Cargo {\n         cargo: CargoWorkspace,\n+        build_scripts: WorkspaceBuildScripts,\n         sysroot: Sysroot,\n         rustc: Option<CargoWorkspace>,\n         /// Holds cfg flags for the current target. We get those by running\n@@ -69,7 +71,14 @@ impl fmt::Debug for ProjectWorkspace {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // Make sure this isn't too verbose.\n         match self {\n-            ProjectWorkspace::Cargo { cargo, sysroot, rustc, rustc_cfg, cfg_overrides } => f\n+            ProjectWorkspace::Cargo {\n+                cargo,\n+                build_scripts: _,\n+                sysroot,\n+                rustc,\n+                rustc_cfg,\n+                cfg_overrides,\n+            } => f\n                 .debug_struct(\"Cargo\")\n                 .field(\"root\", &cargo.workspace_root().file_name())\n                 .field(\"n_packages\", &cargo.packages().len())\n@@ -169,7 +178,14 @@ impl ProjectWorkspace {\n                 let rustc_cfg = rustc_cfg::get(Some(&cargo_toml), config.target.as_deref());\n \n                 let cfg_overrides = config.cfg_overrides();\n-                ProjectWorkspace::Cargo { cargo, sysroot, rustc, rustc_cfg, cfg_overrides }\n+                ProjectWorkspace::Cargo {\n+                    cargo,\n+                    build_scripts: WorkspaceBuildScripts::default(),\n+                    sysroot,\n+                    rustc,\n+                    rustc_cfg,\n+                    cfg_overrides,\n+                }\n             }\n         };\n \n@@ -196,10 +212,34 @@ impl ProjectWorkspace {\n         Ok(ProjectWorkspace::DetachedFiles { files: detached_files, sysroot, rustc_cfg })\n     }\n \n+    pub fn run_build_scripts(\n+        &self,\n+        config: &CargoConfig,\n+        progress: &dyn Fn(String),\n+    ) -> Result<WorkspaceBuildScripts> {\n+        match self {\n+            ProjectWorkspace::Cargo { cargo, .. } => {\n+                WorkspaceBuildScripts::run(config, cargo, progress)\n+            }\n+            ProjectWorkspace::Json { .. } | ProjectWorkspace::DetachedFiles { .. } => {\n+                Ok(WorkspaceBuildScripts::default())\n+            }\n+        }\n+    }\n+\n+    pub fn set_build_scripts(&mut self, bs: WorkspaceBuildScripts) {\n+        match self {\n+            ProjectWorkspace::Cargo { build_scripts, .. } => *build_scripts = bs,\n+            _ => {\n+                always!(bs == WorkspaceBuildScripts::default());\n+            }\n+        }\n+    }\n+\n     /// Returns the roots for the current `ProjectWorkspace`\n     /// The return type contains the path and whether or not\n     /// the root is a member of the current workspace\n-    pub fn to_roots(&self, build_scripts: &WorkspaceBuildScripts) -> Vec<PackageRoot> {\n+    pub fn to_roots(&self) -> Vec<PackageRoot> {\n         match self {\n             ProjectWorkspace::Json { project, sysroot, rustc_cfg: _ } => project\n                 .crates()\n@@ -218,7 +258,14 @@ impl ProjectWorkspace {\n                     })\n                 }))\n                 .collect::<Vec<_>>(),\n-            ProjectWorkspace::Cargo { cargo, sysroot, rustc, rustc_cfg: _, cfg_overrides: _ } => {\n+            ProjectWorkspace::Cargo {\n+                cargo,\n+                sysroot,\n+                rustc,\n+                rustc_cfg: _,\n+                cfg_overrides: _,\n+                build_scripts,\n+            } => {\n                 cargo\n                     .packages()\n                     .map(|pkg| {\n@@ -302,7 +349,6 @@ impl ProjectWorkspace {\n \n     pub fn to_crate_graph(\n         &self,\n-        build_scripts: &WorkspaceBuildScripts,\n         proc_macro_client: Option<&ProcMacroClient>,\n         load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     ) -> CrateGraph {\n@@ -320,18 +366,23 @@ impl ProjectWorkspace {\n                 project,\n                 sysroot,\n             ),\n-            ProjectWorkspace::Cargo { cargo, sysroot, rustc, rustc_cfg, cfg_overrides } => {\n-                cargo_to_crate_graph(\n-                    rustc_cfg.clone(),\n-                    cfg_overrides,\n-                    &proc_macro_loader,\n-                    load,\n-                    cargo,\n-                    build_scripts,\n-                    sysroot,\n-                    rustc,\n-                )\n-            }\n+            ProjectWorkspace::Cargo {\n+                cargo,\n+                sysroot,\n+                rustc,\n+                rustc_cfg,\n+                cfg_overrides,\n+                build_scripts,\n+            } => cargo_to_crate_graph(\n+                rustc_cfg.clone(),\n+                cfg_overrides,\n+                &proc_macro_loader,\n+                load,\n+                cargo,\n+                build_scripts,\n+                sysroot,\n+                rustc,\n+            ),\n             ProjectWorkspace::DetachedFiles { files, sysroot, rustc_cfg } => {\n                 detached_files_to_crate_graph(rustc_cfg.clone(), load, files, sysroot)\n             }"}, {"sha": "9fc45c50220784037d54ad6baa597b52c116c55b", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b8b166e674327a1820bc99b0e8d3af020575746b/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b166e674327a1820bc99b0e8d3af020575746b/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=b8b166e674327a1820bc99b0e8d3af020575746b", "patch": "@@ -36,7 +36,7 @@ pub(crate) fn load_workspace_at(\n }\n \n fn load_workspace(\n-    ws: ProjectWorkspace,\n+    mut ws: ProjectWorkspace,\n     cargo_config: &CargoConfig,\n     load_config: &LoadCargoConfig,\n     progress: &dyn Fn(String),\n@@ -56,22 +56,20 @@ fn load_workspace(\n         None\n     };\n \n-    let build_scripts = match &ws {\n-        ProjectWorkspace::Cargo { cargo, .. } if load_config.load_out_dirs_from_check => {\n-            WorkspaceBuildScripts::run(cargo_config, cargo, progress)?\n-        }\n-        _ => WorkspaceBuildScripts::default(),\n-    };\n+    ws.set_build_scripts(if load_config.load_out_dirs_from_check {\n+        ws.run_build_scripts(cargo_config, progress)?\n+    } else {\n+        WorkspaceBuildScripts::default()\n+    });\n \n-    let crate_graph =\n-        ws.to_crate_graph(&build_scripts, proc_macro_client.as_ref(), &mut |path: &AbsPath| {\n-            let contents = loader.load_sync(path);\n-            let path = vfs::VfsPath::from(path.to_path_buf());\n-            vfs.set_file_contents(path.clone(), contents);\n-            vfs.file_id(&path)\n-        });\n+    let crate_graph = ws.to_crate_graph(proc_macro_client.as_ref(), &mut |path: &AbsPath| {\n+        let contents = loader.load_sync(path);\n+        let path = vfs::VfsPath::from(path.to_path_buf());\n+        vfs.set_file_contents(path.clone(), contents);\n+        vfs.file_id(&path)\n+    });\n \n-    let project_folders = ProjectFolders::new(&[ws], &[build_scripts], &[]);\n+    let project_folders = ProjectFolders::new(&[ws], &[]);\n     loader.set_config(vfs::loader::Config {\n         load: project_folders.load,\n         watch: vec![],"}, {"sha": "853b73b70eff2081136aa5fcecf284d4bd2dd6a9", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b8b166e674327a1820bc99b0e8d3af020575746b/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b166e674327a1820bc99b0e8d3af020575746b/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=b8b166e674327a1820bc99b0e8d3af020575746b", "patch": "@@ -74,18 +74,35 @@ pub(crate) struct GlobalState {\n     pub(crate) vfs_progress_n_total: usize,\n     pub(crate) vfs_progress_n_done: usize,\n \n-    /// For both `workspaces` and `workspace_build_data`, the field stores the\n-    /// data we actually use, while the `OpQueue` stores the result of the last\n-    /// fetch.\n+    /// `workspaces` field stores the data we actually use, while the `OpQueue`\n+    /// stores the result of the last fetch.\n     ///\n-    /// If the fetch (partially) fails, we do not update the values.\n+    /// If the fetch (partially) fails, we do not update the current value.\n     ///\n-    /// Invariant: workspaces.len() == workspace_build_data\n+    /// The handling of build data is subtle. We fetch workspace in two phases:\n+    ///\n+    /// *First*, we run `cargo metadata`, which gives us fast results for\n+    /// initial analysis.\n+    ///\n+    /// *Second*, we run `cargo check` which runs build scripts and compiles\n+    /// proc macros.\n+    ///\n+    /// We need both for the precise analysis, but we want rust-analyzer to be\n+    /// at least partially available just after the first phase. That's because\n+    /// first phase is much faster, and is much less likely to fail.\n+    ///\n+    /// This creates a complication -- by the time the second phase completes,\n+    /// the results of the fist phase could be invalid. That is, while we run\n+    /// `cargo check`, the user edits `Cargo.toml`, we notice this, and the new\n+    /// `cargo metadata` completes before `cargo check`.\n+    ///\n+    /// An additional complication is that we want to avoid needless work. When\n+    /// the user just adds comments or whitespace to Cargo.toml, we do not want\n+    /// to invalidate any salsa caches.\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub(crate) fetch_workspaces_queue: OpQueue<Vec<anyhow::Result<ProjectWorkspace>>>,\n-\n-    pub(crate) workspace_build_data: Vec<WorkspaceBuildScripts>,\n-    pub(crate) fetch_build_data_queue: OpQueue<Vec<anyhow::Result<WorkspaceBuildScripts>>>,\n+    pub(crate) fetch_build_data_queue:\n+        OpQueue<(Arc<Vec<ProjectWorkspace>>, Vec<anyhow::Result<WorkspaceBuildScripts>>)>,\n \n     pub(crate) prime_caches_queue: OpQueue<()>,\n \n@@ -149,7 +166,6 @@ impl GlobalState {\n \n             workspaces: Arc::new(Vec::new()),\n             fetch_workspaces_queue: OpQueue::default(),\n-            workspace_build_data: Vec::new(),\n             prime_caches_queue: OpQueue::default(),\n \n             fetch_build_data_queue: OpQueue::default(),"}, {"sha": "8144554bcab477797d3e4d6ec47c05fa35e92e10", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 67, "deletions": 39, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b8b166e674327a1820bc99b0e8d3af020575746b/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b166e674327a1820bc99b0e8d3af020575746b/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=b8b166e674327a1820bc99b0e8d3af020575746b", "patch": "@@ -1,7 +1,6 @@\n //! Project loading & configuration updates\n use std::{mem, sync::Arc};\n \n-use always_assert::always;\n use flycheck::{FlycheckConfig, FlycheckHandle};\n use hir::db::DefDatabase;\n use ide::Change;\n@@ -27,7 +26,7 @@ pub(crate) enum ProjectWorkspaceProgress {\n pub(crate) enum BuildDataProgress {\n     Begin,\n     Report(String),\n-    End(Vec<anyhow::Result<WorkspaceBuildScripts>>),\n+    End((Arc<Vec<ProjectWorkspace>>, Vec<anyhow::Result<WorkspaceBuildScripts>>)),\n }\n \n impl GlobalState {\n@@ -114,7 +113,7 @@ impl GlobalState {\n             message: None,\n         };\n \n-        if let Some(error) = self.build_data_error() {\n+        if let Some(error) = self.fetch_build_data_error() {\n             status.health = lsp_ext::Health::Warning;\n             status.message = Some(error)\n         }\n@@ -229,6 +228,7 @@ impl GlobalState {\n             };\n             let mut res = Vec::new();\n             for ws in workspaces.iter() {\n+                res.push(ws.run_build_scripts(&config, &progress));\n                 let ws = match ws {\n                     ProjectWorkspace::Cargo { cargo, .. } => cargo,\n                     ProjectWorkspace::DetachedFiles { .. } | ProjectWorkspace::Json { .. } => {\n@@ -238,12 +238,12 @@ impl GlobalState {\n                 };\n                 res.push(WorkspaceBuildScripts::run(&config, ws, &progress))\n             }\n-            sender.send(Task::FetchBuildData(BuildDataProgress::End(res))).unwrap();\n+            sender.send(Task::FetchBuildData(BuildDataProgress::End((workspaces, res)))).unwrap();\n         });\n     }\n     pub(crate) fn fetch_build_data_completed(\n         &mut self,\n-        build_data: Vec<anyhow::Result<WorkspaceBuildScripts>>,\n+        build_data: (Arc<Vec<ProjectWorkspace>>, Vec<anyhow::Result<WorkspaceBuildScripts>>),\n     ) {\n         self.fetch_build_data_queue.op_completed(build_data)\n     }\n@@ -255,11 +255,13 @@ impl GlobalState {\n         if let Some(error_message) = self.fetch_workspace_error() {\n             log::error!(\"failed to switch workspaces: {}\", error_message);\n             if !self.workspaces.is_empty() {\n+                // It only makes sense to switch to a partially broken workspace\n+                // if we don't have any workspace at all yet.\n                 return;\n             }\n         }\n \n-        if let Some(error_message) = self.build_data_error() {\n+        if let Some(error_message) = self.fetch_build_data_error() {\n             log::error!(\"failed to switch build data: {}\", error_message);\n         }\n \n@@ -270,32 +272,67 @@ impl GlobalState {\n             .filter_map(|res| res.as_ref().ok().cloned())\n             .collect::<Vec<_>>();\n \n-        let mut build_scripts = self\n-            .fetch_build_data_queue\n-            .last_op_result()\n-            .iter()\n-            .map(|res| res.as_ref().ok().cloned().unwrap_or_default())\n-            .collect::<Vec<_>>();\n+        fn eq_ignore_build_data<'a>(\n+            left: &'a ProjectWorkspace,\n+            right: &'a ProjectWorkspace,\n+        ) -> bool {\n+            let key = |p: &'a ProjectWorkspace| match p {\n+                ProjectWorkspace::Cargo {\n+                    cargo,\n+                    sysroot,\n+                    rustc,\n+                    rustc_cfg,\n+                    cfg_overrides,\n+\n+                    build_scripts: _,\n+                } => Some((cargo, sysroot, rustc, rustc_cfg, cfg_overrides)),\n+                _ => None,\n+            };\n+            match (key(left), key(right)) {\n+                (Some(lk), Some(rk)) => lk == rk,\n+                _ => left == right,\n+            }\n+        }\n \n-        // FIXME: This is not even remotely correct. I do hope that this is\n-        // eventually consistent though. We need to figure a better way to map\n-        // `cargo metadata` to `cargo check` in the future.\n-        //\n-        // I *think* what we need here is an extra field on `ProjectWorkspace`,\n-        // and a workflow to set it, once build data is ready.\n-        build_scripts.resize_with(workspaces.len(), WorkspaceBuildScripts::default);\n+        let same_workspaces = workspaces.len() == self.workspaces.len()\n+            && workspaces\n+                .iter()\n+                .zip(self.workspaces.iter())\n+                .all(|(l, r)| eq_ignore_build_data(l, r));\n \n-        if *self.workspaces == workspaces && self.workspace_build_data == build_scripts {\n-            return;\n+        if same_workspaces {\n+            let (workspaces, build_scripts) = self.fetch_build_data_queue.last_op_result();\n+            if Arc::ptr_eq(&workspaces, &self.workspaces) {\n+                let workspaces = workspaces\n+                    .iter()\n+                    .cloned()\n+                    .zip(build_scripts)\n+                    .map(|(mut ws, bs)| {\n+                        ws.set_build_scripts(bs.as_ref().ok().cloned().unwrap_or_default());\n+                        ws\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                // Workspaces are the same, but we've updated build data.\n+                self.workspaces = Arc::new(workspaces);\n+            } else {\n+                // Current build scripts do not match the version of the active\n+                // workspace, so there's nothing for us to update.\n+                return;\n+            }\n+        } else {\n+            // Here, we completely changed the workspace (Cargo.toml edit), so\n+            // we don't care about build-script results, they are stale.\n+            self.workspaces = Arc::new(workspaces)\n         }\n \n         if let FilesWatcher::Client = self.config.files().watcher {\n             if self.config.did_change_watched_files_dynamic_registration() {\n                 let registration_options = lsp_types::DidChangeWatchedFilesRegistrationOptions {\n-                    watchers: workspaces\n+                    watchers: self\n+                        .workspaces\n                         .iter()\n-                        .zip(&build_scripts)\n-                        .flat_map(|(ws, bs)| ws.to_roots(bs))\n+                        .flat_map(|ws| ws.to_roots())\n                         .filter(|it| it.is_member)\n                         .flat_map(|root| {\n                             root.include.into_iter().flat_map(|it| {\n@@ -327,8 +364,7 @@ impl GlobalState {\n         let mut change = Change::new();\n \n         let files_config = self.config.files();\n-        let project_folders =\n-            ProjectFolders::new(&workspaces, &build_scripts, &files_config.exclude);\n+        let project_folders = ProjectFolders::new(&self.workspaces, &files_config.exclude);\n \n         if self.proc_macro_client.is_none() {\n             self.proc_macro_client = match self.config.proc_macro_srv() {\n@@ -377,21 +413,15 @@ impl GlobalState {\n                 }\n                 res\n             };\n-            for (ws, bs) in workspaces.iter().zip(&build_scripts) {\n-                crate_graph.extend(ws.to_crate_graph(\n-                    bs,\n-                    self.proc_macro_client.as_ref(),\n-                    &mut load,\n-                ));\n+            for ws in self.workspaces.iter() {\n+                crate_graph.extend(ws.to_crate_graph(self.proc_macro_client.as_ref(), &mut load));\n             }\n \n             crate_graph\n         };\n         change.set_crate_graph(crate_graph);\n \n         self.source_root_config = project_folders.source_root_config;\n-        self.workspaces = Arc::new(workspaces);\n-        self.workspace_build_data = build_scripts;\n \n         self.analysis_host.apply_change(change);\n         self.process_changes();\n@@ -415,10 +445,10 @@ impl GlobalState {\n         Some(buf)\n     }\n \n-    fn build_data_error(&self) -> Option<String> {\n+    fn fetch_build_data_error(&self) -> Option<String> {\n         let mut buf = String::new();\n \n-        for ws in self.fetch_build_data_queue.last_op_result() {\n+        for ws in &self.fetch_build_data_queue.last_op_result().1 {\n             if let Err(err) = ws {\n                 stdx::format_to!(buf, \"rust-analyzer failed to run custom build: {:#}\\n\", err);\n             }\n@@ -481,15 +511,13 @@ pub(crate) struct ProjectFolders {\n impl ProjectFolders {\n     pub(crate) fn new(\n         workspaces: &[ProjectWorkspace],\n-        build_scripts: &[WorkspaceBuildScripts],\n         global_excludes: &[AbsPathBuf],\n     ) -> ProjectFolders {\n-        always!(workspaces.len() == build_scripts.len());\n         let mut res = ProjectFolders::default();\n         let mut fsc = FileSetConfig::builder();\n         let mut local_filesets = vec![];\n \n-        for root in workspaces.iter().zip(build_scripts).flat_map(|(ws, bs)| ws.to_roots(bs)) {\n+        for root in workspaces.iter().flat_map(|ws| ws.to_roots()) {\n             let file_set_roots: Vec<VfsPath> =\n                 root.include.iter().cloned().map(VfsPath::from).collect();\n "}]}