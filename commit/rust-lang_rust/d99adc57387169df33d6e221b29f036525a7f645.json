{"sha": "d99adc57387169df33d6e221b29f036525a7f645", "node_id": "C_kwDOAAsO6NoAKGQ5OWFkYzU3Mzg3MTY5ZGYzM2Q2ZTIyMWIyOWYwMzY1MjVhN2Y2NDU", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-23T15:32:39Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-23T15:32:39Z"}, "message": "Make hover work for intra doc links in macro invocations", "tree": {"sha": "317f25d73f224dde711fc9aba9315f43b465f8f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/317f25d73f224dde711fc9aba9315f43b465f8f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d99adc57387169df33d6e221b29f036525a7f645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d99adc57387169df33d6e221b29f036525a7f645", "html_url": "https://github.com/rust-lang/rust/commit/d99adc57387169df33d6e221b29f036525a7f645", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d99adc57387169df33d6e221b29f036525a7f645/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42eb4efb5b58d1e91787eed0c23cc26157908474", "url": "https://api.github.com/repos/rust-lang/rust/commits/42eb4efb5b58d1e91787eed0c23cc26157908474", "html_url": "https://github.com/rust-lang/rust/commit/42eb4efb5b58d1e91787eed0c23cc26157908474"}], "stats": {"total": 163, "additions": 139, "deletions": 24}, "files": [{"sha": "70fa249a5b08584beb1bf8496446e510f68ee579", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d99adc57387169df33d6e221b29f036525a7f645/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99adc57387169df33d6e221b29f036525a7f645/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=d99adc57387169df33d6e221b29f036525a7f645", "patch": "@@ -17,7 +17,7 @@ use la_arena::ArenaMap;\n use mbe::{syntax_node_to_token_tree, DelimiterKind};\n use smallvec::{smallvec, SmallVec};\n use syntax::{\n-    ast::{self, AstNode, AttrsOwner},\n+    ast::{self, AstNode, AttrsOwner, IsString},\n     match_ast, AstPtr, AstToken, SmolStr, SyntaxNode, TextRange, TextSize,\n };\n use tt::Subtree;\n@@ -610,6 +610,7 @@ pub struct DocsRangeMap {\n }\n \n impl DocsRangeMap {\n+    /// Maps a [`TextRange`] relative to the documentation string back to its AST range\n     pub fn map(&self, range: TextRange) -> Option<InFile<TextRange>> {\n         let found = self.mapping.binary_search_by(|(probe, ..)| probe.ordering(range)).ok()?;\n         let (line_docs_range, idx, original_line_src_range) = self.mapping[found];\n@@ -621,8 +622,15 @@ impl DocsRangeMap {\n \n         let InFile { file_id, value: source } = self.source_map.source_of_id(idx);\n         match source {\n-            Either::Left(_) => None, // FIXME, figure out a nice way to handle doc attributes here\n-            // as well as for whats done in syntax highlight doc injection\n+            Either::Left(attr) => {\n+                let string = get_doc_string_in_attr(&attr)?;\n+                let text_range = string.open_quote_text_range()?;\n+                let range = TextRange::at(\n+                    text_range.end() + original_line_src_range.start() + relative_range.start(),\n+                    string.syntax().text_range().len().min(range.len()),\n+                );\n+                Some(InFile { file_id, value: range })\n+            }\n             Either::Right(comment) => {\n                 let text_range = comment.syntax().text_range();\n                 let range = TextRange::at(\n@@ -638,6 +646,22 @@ impl DocsRangeMap {\n     }\n }\n \n+fn get_doc_string_in_attr(it: &ast::Attr) -> Option<ast::String> {\n+    match it.expr() {\n+        // #[doc = lit]\n+        Some(ast::Expr::Literal(lit)) => match lit.kind() {\n+            ast::LiteralKind::String(it) => Some(it),\n+            _ => None,\n+        },\n+        // #[cfg_attr(..., doc = \"\", ...)]\n+        None => {\n+            // FIXME: See highlight injection for what to do here\n+            None\n+        }\n+        _ => None,\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub(crate) struct AttrId {\n     is_doc_comment: bool,"}, {"sha": "b8b2222a8bd8b780110fe50c14ca91cb315e8d72", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 100, "deletions": 20, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/d99adc57387169df33d6e221b29f036525a7f645/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99adc57387169df33d6e221b29f036525a7f645/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=d99adc57387169df33d6e221b29f036525a7f645", "patch": "@@ -1,4 +1,4 @@\n-use std::iter;\n+use std::{convert::TryFrom, iter};\n \n use either::Either;\n use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo};\n@@ -14,8 +14,12 @@ use ide_db::{\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::{\n-    algo, ast, display::fn_as_proc_macro_label, match_ast, AstNode, Direction, SyntaxKind::*,\n-    SyntaxNode, SyntaxToken, T,\n+    algo,\n+    ast::{self, IsString},\n+    display::fn_as_proc_macro_label,\n+    match_ast, AstNode, AstToken, Direction,\n+    SyntaxKind::*,\n+    SyntaxNode, SyntaxToken, TextSize, T,\n };\n \n use crate::{\n@@ -115,36 +119,53 @@ pub(crate) fn hover(\n     })?;\n \n     let descended = sema.descend_into_macros_many(original_token.clone());\n-\n-    // FIXME handle doc attributes? TokenMap currently doesn't work with comments\n-    if original_token.kind() == COMMENT {\n-        let relative_comment_offset = offset - original_token.text_range().start();\n-        // intra-doc links\n+    // magic intra doc link handling\n+    // FIXME: Lift this out to some other place, goto def wants this as well\n+    let comment_prefix_len = match_ast! {\n+        match original_token {\n+            ast::Comment(comment) => TextSize::try_from(comment.prefix().len()).ok(),\n+            ast::String(string) => original_token.ancestors().find_map(ast::Attr::cast)\n+                .filter(|attr| attr.simple_name().as_deref() == Some(\"doc\")).and_then(|_| string.open_quote_text_range().map(|it| it.len())),\n+            _ => None,\n+        }\n+    };\n+    if let Some(prefix_len) = comment_prefix_len {\n         cov_mark::hit!(no_highlight_on_comment_hover);\n+\n+        // offset relative to the comments contents\n+        let original_start = original_token.text_range().start();\n+        let relative_comment_offset = offset - original_start - prefix_len;\n+\n         return descended.iter().find_map(|t| {\n-            match t.kind() {\n-                COMMENT => (),\n-                TOKEN_TREE => {}\n-                _ => return None,\n-            }\n-            let node = t.parent()?;\n-            let absolute_comment_offset = t.text_range().start() + relative_comment_offset;\n+            let (node, descended_prefix_len) = match_ast! {\n+                match t {\n+                    ast::Comment(comment) => (t.parent()?, TextSize::try_from(comment.prefix().len()).ok()?),\n+                    ast::String(string) => (t.ancestors().skip_while(|n| n.kind() != ATTR).nth(1)?, string.open_quote_text_range()?.len()),\n+                    _ => return None,\n+                }\n+            };\n+            let token_start = t.text_range().start();\n+            let abs_in_expansion_offset = token_start + relative_comment_offset + descended_prefix_len;\n+\n             let (attributes, def) = doc_attributes(sema, &node)?;\n             let (docs, doc_mapping) = attributes.docs_with_rangemap(sema.db)?;\n-            let (idl_range, link, ns) = extract_definitions_from_docs(&docs).into_iter().find_map(\n+            let (in_expansion_range, link, ns) = extract_definitions_from_docs(&docs).into_iter().find_map(\n                 |(range, link, ns)| {\n                     let mapped = doc_mapping.map(range)?;\n-                    (mapped.file_id == file_id.into()\n-                        && mapped.value.contains(absolute_comment_offset))\n-                    .then(|| (mapped.value, link, ns))\n+                    (mapped.value.contains(abs_in_expansion_offset))\n+                        .then(|| (mapped.value, link, ns))\n                 },\n             )?;\n+            // get the relative range to the doc/attribute in the expansion\n+            let in_expansion_relative_range = in_expansion_range - descended_prefix_len - token_start;\n+            // Apply relative range to the original input comment\n+            let absolute_range = in_expansion_relative_range + original_start + prefix_len;\n             let def = match resolve_doc_path_for_def(sema.db, def, &link, ns)? {\n                 Either::Left(it) => Definition::ModuleDef(it),\n                 Either::Right(it) => Definition::Macro(it),\n             };\n             let res = hover_for_definition(sema, file_id, def, &node, config)?;\n-            Some(RangeInfo::new(idl_range, res))\n+            Some(RangeInfo::new(absolute_range, res))\n         });\n     }\n \n@@ -4941,4 +4962,63 @@ fn foo() {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn hover_intra_in_macro() {\n+        check(\n+            r#\"\n+macro_rules! foo_macro {\n+    ($(#[$attr:meta])* $name:ident) => {\n+        $(#[$attr])*\n+        pub struct $name;\n+    }\n+}\n+\n+foo_macro!(\n+    /// Doc comment for [`Foo$0`]\n+    Foo\n+);\n+\"#,\n+            expect![[r#\"\n+                *[`Foo`]*\n+\n+                ```rust\n+                test\n+                ```\n+\n+                ```rust\n+                pub struct Foo\n+                ```\n+\n+                ---\n+\n+                Doc comment for [`Foo`](https://docs.rs/test/*/test/struct.Foo.html)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn hover_intra_in_attr() {\n+        check(\n+            r#\"\n+#[doc = \"Doc comment for [`Foo$0`]\"]\n+pub struct Foo;\n+\"#,\n+            expect![[r#\"\n+                *[`Foo`]*\n+\n+                ```rust\n+                test\n+                ```\n+\n+                ```rust\n+                pub struct Foo\n+                ```\n+\n+                ---\n+\n+                Doc comment for [`Foo`](https://docs.rs/test/*/test/struct.Foo.html)\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "7f68543310994c60bb6fc98818dd3f2d9ef77175", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d99adc57387169df33d6e221b29f036525a7f645/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99adc57387169df33d6e221b29f036525a7f645/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=d99adc57387169df33d6e221b29f036525a7f645", "patch": "@@ -149,7 +149,18 @@ fn convert_tokens<C: TokenConvertor>(conv: &mut C) -> tt::Subtree {\n         let k: SyntaxKind = token.kind();\n         if k == COMMENT {\n             if let Some(tokens) = conv.convert_doc_comment(&token) {\n-                result.extend(tokens);\n+                // FIXME: There has to be a better way to do this\n+                // Add the comments token id to the converted doc string\n+                let id = conv.id_alloc().alloc(range);\n+                result.extend(tokens.into_iter().map(|mut tt| {\n+                    if let tt::TokenTree::Subtree(sub) = &mut tt {\n+                        if let tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) = &mut sub.token_trees[2]\n+                        {\n+                            lit.id = id\n+                        }\n+                    }\n+                    tt\n+                }));\n             }\n             continue;\n         }"}]}