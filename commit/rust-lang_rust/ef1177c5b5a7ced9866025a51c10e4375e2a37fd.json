{"sha": "ef1177c5b5a7ced9866025a51c10e4375e2a37fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMTE3N2M1YjVhN2NlZDk4NjYwMjVhNTFjMTBlNDM3NWUyYTM3ZmQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-12-29T12:19:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-29T12:19:31Z"}, "message": "Merge #7064\n\n7064: Ignore qualifiers when doing autoimport completions lookup r=lnicola a=SomeoneToIgnore\n\nA follow-up of https://github.com/rust-analyzer/rust-analyzer/pull/6918#issuecomment-748511151 and the PR itself.\r\n\r\nTweaks the `import_map` query api to be more flexible with the ways to match against the import path and now fuzzy imports search in names only.\r\nThis had improved the completion speed for me locally in ~5 times for `fuzzy_completion` span time, but please recheck me here.\r\n\r\nIMO we're fast and presice enough now, so I've added the modules back to the fuzzy search output.\r\n\r\nAlso tweaks the the expect tests to display functions explicitly, to avoid confusing \"duplicate\" results.\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "347f2a22132be0106d4703526288665b6d33a136", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/347f2a22132be0106d4703526288665b6d33a136"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef1177c5b5a7ced9866025a51c10e4375e2a37fd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf6x7TCRBK7hj4Ov3rIwAAdHIIAJZ85oRrPqzYn/NT0I0QRQ8U\noHvrlD673jGGdH9OG/rlCX5dLRoIaG8ysonStFsZedmQoF6RMmMOlQ6peGwmb2mP\nhkB39gQ/3Ie+mE/IqwKQNBc9P7goenXFylyGQfvQhY/mj63pKiUZ09akX89xPaz3\npaw8AeLNQdeL2Ej6olScGlFbJbZm/GrFw7PwCGSsCr32UfAKDwaEUsFrtZzQCUrI\nOyJnppz0okp0D3FgYjOY9BKdTdR3DuAa1WFqAJxc3aBzN6ArLw1mNIKOmKC3OhHi\nEpaTBgDjmufeXjsjchuVRENwJ5DS0Tq2BOZYUlm1Tf1Bofk08EruNNre/36E9bA=\n=UZHD\n-----END PGP SIGNATURE-----\n", "payload": "tree 347f2a22132be0106d4703526288665b6d33a136\nparent 7b246a6a14a8170f99dd5992f7d9dd4347722a69\nparent 77b4a1c5ef594ddd78c77dd8bb05fba14b99cc9f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1609244371 +0000\ncommitter GitHub <noreply@github.com> 1609244371 +0000\n\nMerge #7064\n\n7064: Ignore qualifiers when doing autoimport completions lookup r=lnicola a=SomeoneToIgnore\n\nA follow-up of https://github.com/rust-analyzer/rust-analyzer/pull/6918#issuecomment-748511151 and the PR itself.\r\n\r\nTweaks the `import_map` query api to be more flexible with the ways to match against the import path and now fuzzy imports search in names only.\r\nThis had improved the completion speed for me locally in ~5 times for `fuzzy_completion` span time, but please recheck me here.\r\n\r\nIMO we're fast and presice enough now, so I've added the modules back to the fuzzy search output.\r\n\r\nAlso tweaks the the expect tests to display functions explicitly, to avoid confusing \"duplicate\" results.\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef1177c5b5a7ced9866025a51c10e4375e2a37fd", "html_url": "https://github.com/rust-lang/rust/commit/ef1177c5b5a7ced9866025a51c10e4375e2a37fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef1177c5b5a7ced9866025a51c10e4375e2a37fd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b246a6a14a8170f99dd5992f7d9dd4347722a69", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b246a6a14a8170f99dd5992f7d9dd4347722a69", "html_url": "https://github.com/rust-lang/rust/commit/7b246a6a14a8170f99dd5992f7d9dd4347722a69"}, {"sha": "77b4a1c5ef594ddd78c77dd8bb05fba14b99cc9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/77b4a1c5ef594ddd78c77dd8bb05fba14b99cc9f", "html_url": "https://github.com/rust-lang/rust/commit/77b4a1c5ef594ddd78c77dd8bb05fba14b99cc9f"}], "stats": {"total": 237, "additions": 188, "deletions": 49}, "files": [{"sha": "59f950189513cd868407d9537aacd4c970e3aa41", "filename": "crates/completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef1177c5b5a7ced9866025a51c10e4375e2a37fd/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1177c5b5a7ced9866025a51c10e4375e2a37fd/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=ef1177c5b5a7ced9866025a51c10e4375e2a37fd", "patch": "@@ -101,8 +101,9 @@ fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext, ty: &T\n //\n // .Fuzzy search details\n //\n-// To avoid an excessive amount of the results returned, completion input is checked for inclusion in the identifiers only\n-// (i.e. in `HashMap` in the `std::collections::HashMap` path), also not in the module indentifiers.\n+// To avoid an excessive amount of the results returned, completion input is checked for inclusion in the names only\n+// (i.e. in `HashMap` in the `std::collections::HashMap` path).\n+// For the same reasons, avoids searching for any imports for inputs with their length less that 2 symbols.\n //\n // .Merge Behavior\n //\n@@ -126,14 +127,18 @@ fn fuzzy_completion(acc: &mut Completions, ctx: &CompletionContext) -> Option<()\n     let _p = profile::span(\"fuzzy_completion\");\n     let potential_import_name = ctx.token.to_string();\n \n+    if potential_import_name.len() < 2 {\n+        return None;\n+    }\n+\n     let current_module = ctx.scope.module()?;\n     let anchor = ctx.name_ref_syntax.as_ref()?;\n     let import_scope = ImportScope::find_insert_use_container(anchor.syntax(), &ctx.sema)?;\n \n     let mut all_mod_paths = imports_locator::find_similar_imports(\n         &ctx.sema,\n         ctx.krate?,\n-        Some(100),\n+        Some(40),\n         &potential_import_name,\n         true,\n     )"}, {"sha": "fdc681d6ce3692a36f07f77ff85c2e36bfb1f285", "filename": "crates/hir_def/src/import_map.rs", "status": "modified", "additions": 168, "deletions": 39, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/ef1177c5b5a7ced9866025a51c10e4375e2a37fd/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1177c5b5a7ced9866025a51c10e4375e2a37fd/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fimport_map.rs?ref=ef1177c5b5a7ced9866025a51c10e4375e2a37fd", "patch": "@@ -238,11 +238,24 @@ pub enum ImportKind {\n     BuiltinType,\n }\n \n+/// A way to match import map contents against the search query.\n+#[derive(Debug)]\n+pub enum SearchMode {\n+    /// Import map entry should strictly match the query string.\n+    Equals,\n+    /// Import map entry should contain the query string.\n+    Contains,\n+    /// Import map entry should contain all letters from the query string,\n+    /// in the same order, but not necessary adjacent.\n+    Fuzzy,\n+}\n+\n #[derive(Debug)]\n pub struct Query {\n     query: String,\n     lowercased: String,\n-    anchor_end: bool,\n+    name_only: bool,\n+    search_mode: SearchMode,\n     case_sensitive: bool,\n     limit: usize,\n     exclude_import_kinds: FxHashSet<ImportKind>,\n@@ -251,19 +264,26 @@ pub struct Query {\n impl Query {\n     pub fn new(query: &str) -> Self {\n         Self {\n-            lowercased: query.to_lowercase(),\n             query: query.to_string(),\n-            anchor_end: false,\n+            lowercased: query.to_lowercase(),\n+            name_only: false,\n+            search_mode: SearchMode::Contains,\n             case_sensitive: false,\n             limit: usize::max_value(),\n             exclude_import_kinds: FxHashSet::default(),\n         }\n     }\n \n-    /// Only returns items whose paths end with the (case-insensitive) query string as their last\n-    /// segment.\n-    pub fn anchor_end(self) -> Self {\n-        Self { anchor_end: true, ..self }\n+    /// Matches entries' names only, ignoring the rest of\n+    /// the qualifier.\n+    /// Example: for `std::marker::PhantomData`, the name is `PhantomData`.\n+    pub fn name_only(self) -> Self {\n+        Self { name_only: true, ..self }\n+    }\n+\n+    /// Specifies the way to search for the entries using the query.\n+    pub fn search_mode(self, search_mode: SearchMode) -> Self {\n+        Self { search_mode, ..self }\n     }\n \n     /// Limits the returned number of items to `limit`.\n@@ -283,6 +303,40 @@ impl Query {\n     }\n }\n \n+fn contains_query(query: &Query, input_path: &ImportPath, enforce_lowercase: bool) -> bool {\n+    let mut input = if query.name_only {\n+        input_path.segments.last().unwrap().to_string()\n+    } else {\n+        input_path.to_string()\n+    };\n+    if enforce_lowercase || !query.case_sensitive {\n+        input.make_ascii_lowercase();\n+    }\n+\n+    let query_string =\n+        if !enforce_lowercase && query.case_sensitive { &query.query } else { &query.lowercased };\n+\n+    match query.search_mode {\n+        SearchMode::Equals => &input == query_string,\n+        SearchMode::Contains => input.contains(query_string),\n+        SearchMode::Fuzzy => {\n+            let mut unchecked_query_chars = query_string.chars();\n+            let mut mismatching_query_char = unchecked_query_chars.next();\n+\n+            for input_char in input.chars() {\n+                match mismatching_query_char {\n+                    None => return true,\n+                    Some(matching_query_char) if matching_query_char == input_char => {\n+                        mismatching_query_char = unchecked_query_chars.next();\n+                    }\n+                    _ => (),\n+                }\n+            }\n+            mismatching_query_char.is_none()\n+        }\n+    }\n+}\n+\n /// Searches dependencies of `krate` for an importable path matching `query`.\n ///\n /// This returns a list of items that could be imported from dependencies of `krate`.\n@@ -312,39 +366,29 @@ pub fn search_dependencies<'a>(\n             let importables = &import_map.importables[indexed_value.value as usize..];\n \n             // Path shared by the importable items in this group.\n-            let path = &import_map.map[&importables[0]].path;\n-\n-            if query.anchor_end {\n-                // Last segment must match query.\n-                let last = path.segments.last().unwrap().to_string();\n-                if last.to_lowercase() != query.lowercased {\n-                    continue;\n-                }\n+            let common_importables_path = &import_map.map[&importables[0]].path;\n+            if !contains_query(&query, common_importables_path, true) {\n+                continue;\n             }\n \n+            let common_importables_path_fst = fst_path(common_importables_path);\n             // Add the items from this `ModPath` group. Those are all subsequent items in\n             // `importables` whose paths match `path`.\n             let iter = importables\n                 .iter()\n                 .copied()\n                 .take_while(|item| {\n-                    let item_path = &import_map.map[item].path;\n-                    fst_path(item_path) == fst_path(path)\n+                    common_importables_path_fst == fst_path(&import_map.map[item].path)\n                 })\n                 .filter(|&item| match item_import_kind(item) {\n                     Some(import_kind) => !query.exclude_import_kinds.contains(&import_kind),\n                     None => true,\n+                })\n+                .filter(|item| {\n+                    !query.case_sensitive // we've already checked the common importables path case-insensitively\n+                        || contains_query(&query, &import_map.map[item].path, false)\n                 });\n-\n-            if query.case_sensitive {\n-                // FIXME: This does not do a subsequence match.\n-                res.extend(iter.filter(|item| {\n-                    let item_path = &import_map.map[item].path;\n-                    item_path.to_string().contains(&query.query)\n-                }));\n-            } else {\n-                res.extend(iter);\n-            }\n+            res.extend(iter);\n \n             if res.len() >= query.limit {\n                 res.truncate(query.limit);\n@@ -388,7 +432,7 @@ mod tests {\n     use base_db::{fixture::WithFixture, SourceDatabase, Upcast};\n     use expect_test::{expect, Expect};\n \n-    use crate::{test_db::TestDB, AssocContainerId, Lookup};\n+    use crate::{data::FunctionData, test_db::TestDB, AssocContainerId, Lookup};\n \n     use super::*;\n \n@@ -407,14 +451,31 @@ mod tests {\n             .into_iter()\n             .filter_map(|item| {\n                 let mark = match item {\n+                    ItemInNs::Types(ModuleDefId::FunctionId(_))\n+                    | ItemInNs::Values(ModuleDefId::FunctionId(_)) => \"f\",\n                     ItemInNs::Types(_) => \"t\",\n                     ItemInNs::Values(_) => \"v\",\n                     ItemInNs::Macros(_) => \"m\",\n                 };\n-                let item = assoc_to_trait(&db, item);\n                 item.krate(db.upcast()).map(|krate| {\n                     let map = db.import_map(krate);\n-                    let path = map.path_of(item).unwrap();\n+\n+                    let path = match assoc_to_trait(&db, item) {\n+                        Some(trait_) => {\n+                            let mut full_path = map.path_of(trait_).unwrap().to_string();\n+                            if let ItemInNs::Types(ModuleDefId::FunctionId(function_id))\n+                            | ItemInNs::Values(ModuleDefId::FunctionId(function_id)) = item\n+                            {\n+                                full_path += &format!(\n+                                    \"::{}\",\n+                                    FunctionData::fn_data_query(&db, function_id).name\n+                                );\n+                            }\n+                            full_path\n+                        }\n+                        None => map.path_of(item).unwrap().to_string(),\n+                    };\n+\n                     format!(\n                         \"{}::{} ({})\\n\",\n                         crate_graph[krate].display_name.as_ref().unwrap(),\n@@ -427,15 +488,15 @@ mod tests {\n         expect.assert_eq(&actual)\n     }\n \n-    fn assoc_to_trait(db: &dyn DefDatabase, item: ItemInNs) -> ItemInNs {\n+    fn assoc_to_trait(db: &dyn DefDatabase, item: ItemInNs) -> Option<ItemInNs> {\n         let assoc: AssocItemId = match item {\n             ItemInNs::Types(it) | ItemInNs::Values(it) => match it {\n                 ModuleDefId::TypeAliasId(it) => it.into(),\n                 ModuleDefId::FunctionId(it) => it.into(),\n                 ModuleDefId::ConstId(it) => it.into(),\n-                _ => return item,\n+                _ => return None,\n             },\n-            _ => return item,\n+            _ => return None,\n         };\n \n         let container = match assoc {\n@@ -445,8 +506,8 @@ mod tests {\n         };\n \n         match container {\n-            AssocContainerId::TraitId(it) => ItemInNs::Types(it.into()),\n-            _ => item,\n+            AssocContainerId::TraitId(it) => Some(ItemInNs::Types(it.into())),\n+            _ => None,\n         }\n     }\n \n@@ -685,7 +746,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn search() {\n+    fn search_mode() {\n         let ra_fixture = r#\"\n             //- /main.rs crate:main deps:dep\n             //- /dep.rs crate:dep deps:tdep\n@@ -713,28 +774,96 @@ mod tests {\n         check_search(\n             ra_fixture,\n             \"main\",\n-            Query::new(\"fmt\"),\n+            Query::new(\"fmt\").search_mode(SearchMode::Fuzzy),\n             expect![[r#\"\n                 dep::fmt (t)\n                 dep::Fmt (t)\n                 dep::Fmt (v)\n                 dep::Fmt (m)\n                 dep::fmt::Display (t)\n-                dep::format (v)\n+                dep::format (f)\n+                dep::fmt::Display::fmt (f)\n+            \"#]],\n+        );\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\").search_mode(SearchMode::Equals),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::Fmt (t)\n+                dep::Fmt (v)\n+                dep::Fmt (m)\n+                dep::fmt::Display::fmt (f)\n+            \"#]],\n+        );\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\").search_mode(SearchMode::Contains),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::Fmt (t)\n+                dep::Fmt (v)\n+                dep::Fmt (m)\n                 dep::fmt::Display (t)\n+                dep::fmt::Display::fmt (f)\n             \"#]],\n         );\n+    }\n+\n+    #[test]\n+    fn name_only() {\n+        let ra_fixture = r#\"\n+            //- /main.rs crate:main deps:dep\n+            //- /dep.rs crate:dep deps:tdep\n+            use tdep::fmt as fmt_dep;\n+            pub mod fmt {\n+                pub trait Display {\n+                    fn fmt();\n+                }\n+            }\n+            #[macro_export]\n+            macro_rules! Fmt {\n+                () => {};\n+            }\n+            pub struct Fmt;\n+\n+            pub fn format() {}\n+            pub fn no() {}\n+\n+            //- /tdep.rs crate:tdep\n+            pub mod fmt {\n+                pub struct NotImportableFromMain;\n+            }\n+        \"#;\n \n         check_search(\n             ra_fixture,\n             \"main\",\n-            Query::new(\"fmt\").anchor_end(),\n+            Query::new(\"fmt\"),\n             expect![[r#\"\n                 dep::fmt (t)\n                 dep::Fmt (t)\n                 dep::Fmt (v)\n                 dep::Fmt (m)\n                 dep::fmt::Display (t)\n+                dep::fmt::Display::fmt (f)\n+            \"#]],\n+        );\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\").name_only(),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::Fmt (t)\n+                dep::Fmt (v)\n+                dep::Fmt (m)\n+                dep::fmt::Display::fmt (f)\n             \"#]],\n         );\n     }"}, {"sha": "b6355af4bd755dbbd3067e99abb9465c5aac980c", "filename": "crates/ide_db/src/imports_locator.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ef1177c5b5a7ced9866025a51c10e4375e2a37fd/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1177c5b5a7ced9866025a51c10e4375e2a37fd/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports_locator.rs?ref=ef1177c5b5a7ced9866025a51c10e4375e2a37fd", "patch": "@@ -27,25 +27,30 @@ pub fn find_exact_imports<'a>(\n             local_query.limit(40);\n             local_query\n         },\n-        import_map::Query::new(name_to_import).anchor_end().case_sensitive().limit(40),\n+        import_map::Query::new(name_to_import)\n+            .limit(40)\n+            .name_only()\n+            .search_mode(import_map::SearchMode::Equals)\n+            .case_sensitive(),\n     )\n }\n \n pub fn find_similar_imports<'a>(\n     sema: &Semantics<'a, RootDatabase>,\n     krate: Crate,\n     limit: Option<usize>,\n-    name_to_import: &str,\n-    ignore_modules: bool,\n+    fuzzy_search_string: &str,\n+    name_only: bool,\n ) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n     let _p = profile::span(\"find_similar_imports\");\n \n-    let mut external_query = import_map::Query::new(name_to_import);\n-    if ignore_modules {\n-        external_query = external_query.exclude_import_kind(import_map::ImportKind::Module);\n+    let mut external_query =\n+        import_map::Query::new(fuzzy_search_string).search_mode(import_map::SearchMode::Fuzzy);\n+    if name_only {\n+        external_query = external_query.name_only();\n     }\n \n-    let mut local_query = symbol_index::Query::new(name_to_import.to_string());\n+    let mut local_query = symbol_index::Query::new(fuzzy_search_string.to_string());\n \n     if let Some(limit) = limit {\n         local_query.limit(limit);"}]}