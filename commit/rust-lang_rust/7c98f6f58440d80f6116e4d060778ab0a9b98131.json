{"sha": "7c98f6f58440d80f6116e4d060778ab0a9b98131", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjOThmNmY1ODQ0MGQ4MGY2MTE2ZTRkMDYwNzc4YWIwYTliOTgxMzE=", "commit": {"author": {"name": "ishitatsuyuki", "email": "ishitatsuyuki@gmail.com", "date": "2020-09-19T13:00:10Z"}, "committer": {"name": "ishitatsuyuki", "email": "ishitatsuyuki@gmail.com", "date": "2020-09-19T13:00:10Z"}, "message": "Add fast path for match checking", "tree": {"sha": "e6cc3042e85d71ff4781fafecb41d4255a395072", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6cc3042e85d71ff4781fafecb41d4255a395072"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c98f6f58440d80f6116e4d060778ab0a9b98131", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c98f6f58440d80f6116e4d060778ab0a9b98131", "html_url": "https://github.com/rust-lang/rust/commit/7c98f6f58440d80f6116e4d060778ab0a9b98131", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c98f6f58440d80f6116e4d060778ab0a9b98131/comments", "author": {"login": "ishitatsuyuki", "id": 12389383, "node_id": "MDQ6VXNlcjEyMzg5Mzgz", "avatar_url": "https://avatars.githubusercontent.com/u/12389383?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ishitatsuyuki", "html_url": "https://github.com/ishitatsuyuki", "followers_url": "https://api.github.com/users/ishitatsuyuki/followers", "following_url": "https://api.github.com/users/ishitatsuyuki/following{/other_user}", "gists_url": "https://api.github.com/users/ishitatsuyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/ishitatsuyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ishitatsuyuki/subscriptions", "organizations_url": "https://api.github.com/users/ishitatsuyuki/orgs", "repos_url": "https://api.github.com/users/ishitatsuyuki/repos", "events_url": "https://api.github.com/users/ishitatsuyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/ishitatsuyuki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ishitatsuyuki", "id": 12389383, "node_id": "MDQ6VXNlcjEyMzg5Mzgz", "avatar_url": "https://avatars.githubusercontent.com/u/12389383?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ishitatsuyuki", "html_url": "https://github.com/ishitatsuyuki", "followers_url": "https://api.github.com/users/ishitatsuyuki/followers", "following_url": "https://api.github.com/users/ishitatsuyuki/following{/other_user}", "gists_url": "https://api.github.com/users/ishitatsuyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/ishitatsuyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ishitatsuyuki/subscriptions", "organizations_url": "https://api.github.com/users/ishitatsuyuki/orgs", "repos_url": "https://api.github.com/users/ishitatsuyuki/repos", "events_url": "https://api.github.com/users/ishitatsuyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/ishitatsuyuki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e8a8b49ae57233bc196f3529f5184bc208c3034", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e8a8b49ae57233bc196f3529f5184bc208c3034", "html_url": "https://github.com/rust-lang/rust/commit/4e8a8b49ae57233bc196f3529f5184bc208c3034"}], "stats": {"total": 108, "additions": 95, "deletions": 13}, "files": [{"sha": "1cbfc73a9c6dc91e7427913440bf2ccee0d2f521", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 95, "deletions": 13, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7c98f6f58440d80f6116e4d060778ab0a9b98131/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c98f6f58440d80f6116e4d060778ab0a9b98131/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=7c98f6f58440d80f6116e4d060778ab0a9b98131", "patch": "@@ -276,7 +276,7 @@ use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::Idx;\n \n use super::{compare_const_vals, PatternFoldable, PatternFolder};\n@@ -504,13 +504,27 @@ impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n     }\n }\n \n+/// Depending on the match patterns, the specialization process might be able to use a fast path.\n+/// Tracks whether we can use the fast path and the lookup table needed in those cases.\n+#[derive(Clone, Debug)]\n+enum SpecializationCache {\n+    /// Patterns consist of only enum variants.\n+    Variants { lookup: FxHashMap<DefId, SmallVec<[usize; 1]>>, wilds: SmallVec<[usize; 1]> },\n+    /// Does not belong to the cases above, use the slow path.\n+    Incompatible,\n+}\n+\n /// A 2D matrix.\n #[derive(Clone)]\n-crate struct Matrix<'p, 'tcx>(Vec<PatStack<'p, 'tcx>>);\n+crate struct Matrix<'p, 'tcx> {\n+    patterns: Vec<PatStack<'p, 'tcx>>,\n+    cache: SpecializationCache,\n+}\n \n impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     crate fn empty() -> Self {\n-        Matrix(vec![])\n+        // Use SpecializationCache::Incompatible as a placeholder; the initialization is in push().\n+        Matrix { patterns: vec![], cache: SpecializationCache::Incompatible }\n     }\n \n     /// Pushes a new row to the matrix. If the row starts with an or-pattern, this expands it.\n@@ -522,18 +536,65 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n                 self.push(row)\n             }\n         } else {\n-            self.0.push(row);\n+            if self.patterns.is_empty() {\n+                self.cache = if row.is_empty() {\n+                    SpecializationCache::Incompatible\n+                } else {\n+                    match *row.head().kind {\n+                        PatKind::Variant { .. } => SpecializationCache::Variants {\n+                            lookup: FxHashMap::default(),\n+                            wilds: SmallVec::new(),\n+                        },\n+                        // Note: If the first pattern is a wildcard, then all patterns after that is not\n+                        // useful. The check is simple enough so we treat it as the same as unsupported\n+                        // patterns.\n+                        _ => SpecializationCache::Incompatible,\n+                    }\n+                };\n+            }\n+            let idx_to_insert = self.patterns.len();\n+            match &mut self.cache {\n+                SpecializationCache::Variants { ref mut lookup, ref mut wilds } => {\n+                    let head = row.head();\n+                    match *head.kind {\n+                        _ if head.is_wildcard() => {\n+                            for (_, v) in lookup.iter_mut() {\n+                                v.push(idx_to_insert);\n+                            }\n+                            wilds.push(idx_to_insert);\n+                        }\n+                        PatKind::Variant { adt_def, variant_index, .. } => {\n+                            lookup\n+                                .entry(adt_def.variants[variant_index].def_id)\n+                                .or_insert_with(|| wilds.clone())\n+                                .push(idx_to_insert);\n+                        }\n+                        _ => {\n+                            self.cache = SpecializationCache::Incompatible;\n+                        }\n+                    }\n+                }\n+                SpecializationCache::Incompatible => {}\n+            }\n+            self.patterns.push(row);\n         }\n     }\n \n     /// Iterate over the first component of each row\n     fn heads<'a>(&'a self) -> impl Iterator<Item = &'a Pat<'tcx>> + Captures<'p> {\n-        self.0.iter().map(|r| r.head())\n+        self.patterns.iter().map(|r| r.head())\n     }\n \n     /// This computes `D(self)`. See top of the file for explanations.\n     fn specialize_wildcard(&self) -> Self {\n-        self.0.iter().filter_map(|r| r.specialize_wildcard()).collect()\n+        match &self.cache {\n+            SpecializationCache::Variants { wilds, .. } => {\n+                wilds.iter().filter_map(|&i| self.patterns[i].specialize_wildcard()).collect()\n+            }\n+            SpecializationCache::Incompatible => {\n+                self.patterns.iter().filter_map(|r| r.specialize_wildcard()).collect()\n+            }\n+        }\n     }\n \n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n@@ -543,10 +604,31 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         constructor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Matrix<'p, 'tcx> {\n-        self.0\n-            .iter()\n-            .filter_map(|r| r.specialize_constructor(cx, constructor, ctor_wild_subpatterns))\n-            .collect()\n+        match &self.cache {\n+            SpecializationCache::Variants { lookup, wilds } => {\n+                if let Constructor::Variant(id) = constructor {\n+                    lookup\n+                        .get(id)\n+                        .unwrap_or(&wilds)\n+                        .iter()\n+                        .filter_map(|&i| {\n+                            self.patterns[i].specialize_constructor(\n+                                cx,\n+                                constructor,\n+                                ctor_wild_subpatterns,\n+                            )\n+                        })\n+                        .collect()\n+                } else {\n+                    unreachable!()\n+                }\n+            }\n+            SpecializationCache::Incompatible => self\n+                .patterns\n+                .iter()\n+                .filter_map(|r| r.specialize_constructor(cx, constructor, ctor_wild_subpatterns))\n+                .collect(),\n+        }\n     }\n }\n \n@@ -568,7 +650,7 @@ impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"\\n\")?;\n \n-        let &Matrix(ref m) = self;\n+        let Matrix { patterns: m, .. } = self;\n         let pretty_printed_matrix: Vec<Vec<String>> =\n             m.iter().map(|row| row.iter().map(|pat| format!(\"{:?}\", pat)).collect()).collect();\n \n@@ -1824,7 +1906,7 @@ crate fn is_useful<'p, 'tcx>(\n     is_under_guard: bool,\n     is_top_level: bool,\n ) -> Usefulness<'tcx> {\n-    let &Matrix(ref rows) = matrix;\n+    let Matrix { patterns: rows, .. } = matrix;\n     debug!(\"is_useful({:#?}, {:#?})\", matrix, v);\n \n     // The base case. We are pattern-matching on () and the return value is\n@@ -2266,7 +2348,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 // `borders` is the set of borders between equivalence classes: each equivalence\n                 // class lies between 2 borders.\n                 let row_borders = matrix\n-                    .0\n+                    .patterns\n                     .iter()\n                     .flat_map(|row| {\n                         IntRange::from_pat(tcx, param_env, row.head()).map(|r| (r, row.len()))"}]}