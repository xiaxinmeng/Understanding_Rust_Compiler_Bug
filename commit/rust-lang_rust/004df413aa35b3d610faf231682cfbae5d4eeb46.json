{"sha": "004df413aa35b3d610faf231682cfbae5d4eeb46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNGRmNDEzYWEzNWIzZDYxMGZhZjIzMTY4MmNmYmFlNWQ0ZWViNDY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-30T08:09:44Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-24T12:14:16Z"}, "message": "syntax: don't use TraitRef in QPath.", "tree": {"sha": "d78c535eed44d9f6056b7fc8775becf7fd896802", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d78c535eed44d9f6056b7fc8775becf7fd896802"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/004df413aa35b3d610faf231682cfbae5d4eeb46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/004df413aa35b3d610faf231682cfbae5d4eeb46", "html_url": "https://github.com/rust-lang/rust/commit/004df413aa35b3d610faf231682cfbae5d4eeb46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/004df413aa35b3d610faf231682cfbae5d4eeb46/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a817c69297dc2bfac4029410cc055d32022cea95", "url": "https://api.github.com/repos/rust-lang/rust/commits/a817c69297dc2bfac4029410cc055d32022cea95", "html_url": "https://github.com/rust-lang/rust/commit/a817c69297dc2bfac4029410cc055d32022cea95"}], "stats": {"total": 289, "additions": 143, "deletions": 146}, "files": [{"sha": "81fb1c8e913f62ab4fa45d5d1dcfac6f2be76afa", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -717,6 +717,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n         visit::walk_path(self, p);\n     }\n \n+    fn visit_qpath(&mut self, p: &ast::QPath, id: ast::NodeId) {\n+        run_lints!(self, check_qpath, p, id);\n+        visit::walk_qpath(self, p);\n+    }\n+\n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n         run_lints!(self, check_attribute, attr);\n     }"}, {"sha": "1e2ddb7db0bfa768be3b33091b7f787312ff8853", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -157,6 +157,7 @@ pub trait LintPass {\n     fn check_explicit_self(&mut self, _: &Context, _: &ast::ExplicitSelf) { }\n     fn check_mac(&mut self, _: &Context, _: &ast::Mac) { }\n     fn check_path(&mut self, _: &Context, _: &ast::Path, _: ast::NodeId) { }\n+    fn check_qpath(&mut self, _: &Context, _: &ast::QPath, _: ast::NodeId) { }\n     fn check_attribute(&mut self, _: &Context, _: &ast::Attribute) { }\n \n     /// Called when entering a syntax node that can have lint attributes such"}, {"sha": "1a695baf7216bf69791a62625fb39d924ffda8d2", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -1241,9 +1241,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n         }\n-        if let Some(ref ast_trait_ref) = *opt_trait {\n-            let trait_ref = ty::node_id_to_trait_ref(\n-                tcx, ast_trait_ref.ref_id);\n+        if opt_trait.is_some() {\n+            let trait_ref = ty::impl_id_to_trait_ref(tcx, item.id);\n             encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_trait_ref);\n         }\n         encode_path(rbml_w, path.clone());"}, {"sha": "4f9b900a5f8765c6f32eb46025ff7e800f62a89b", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -306,6 +306,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         visit::walk_path(self, path);\n     }\n \n+    fn visit_qpath(&mut self, qpath: &ast::QPath, id: ast::NodeId) {\n+        self.lookup_and_handle_definition(&id);\n+        visit::walk_qpath(self, qpath);\n+    }\n+\n     fn visit_item(&mut self, _: &ast::Item) {\n         // Do not recurse into items. These items will be added to the\n         // worklist and recursed into manually if necessary."}, {"sha": "c4fe3f4df02188d201ef545b7edb0c5da8502af3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -709,7 +709,7 @@ pub struct ctxt<'tcx> {\n \n     pub impl_trait_cache: RefCell<DefIdMap<Option<Rc<ty::TraitRef<'tcx>>>>>,\n \n-    pub trait_refs: RefCell<NodeMap<Rc<TraitRef<'tcx>>>>,\n+    pub impl_trait_refs: RefCell<NodeMap<Rc<TraitRef<'tcx>>>>,\n     pub trait_defs: RefCell<DefIdMap<Rc<TraitDef<'tcx>>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n@@ -2449,7 +2449,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         region_maps: region_maps,\n         node_types: RefCell::new(FnvHashMap()),\n         item_substs: RefCell::new(NodeMap()),\n-        trait_refs: RefCell::new(NodeMap()),\n+        impl_trait_refs: RefCell::new(NodeMap()),\n         trait_defs: RefCell::new(DefIdMap()),\n         predicates: RefCell::new(DefIdMap()),\n         object_cast_map: RefCell::new(NodeMap()),\n@@ -4174,12 +4174,12 @@ pub fn named_element_ty<'tcx>(cx: &ctxt<'tcx>,\n     }\n }\n \n-pub fn node_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n+pub fn impl_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n                                   -> Rc<ty::TraitRef<'tcx>> {\n-    match cx.trait_refs.borrow().get(&id) {\n+    match cx.impl_trait_refs.borrow().get(&id) {\n         Some(ty) => ty.clone(),\n         None => cx.sess.bug(\n-            &format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n+            &format!(\"impl_id_to_trait_ref: no trait ref for impl `{}`\",\n                     cx.map.node_to_string(id)))\n     }\n }\n@@ -5116,25 +5116,19 @@ pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n     memoized(&cx.impl_trait_cache, id, |id: ast::DefId| {\n         if id.krate == ast::LOCAL_CRATE {\n             debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n-            match cx.map.find(id.node) {\n-                Some(ast_map::NodeItem(item)) => {\n-                    match item.node {\n-                        ast::ItemImpl(_, _, _, ref opt_trait, _, _) => {\n-                            match opt_trait {\n-                                &Some(ref t) => {\n-                                    let trait_ref = ty::node_id_to_trait_ref(cx, t.ref_id);\n-                                    Some(trait_ref)\n-                                }\n-                                &None => None\n-                            }\n-                        }\n+            if let Some(ast_map::NodeItem(item)) = cx.map.find(id.node) {\n+                if let ast::ItemImpl(_, _, _, ref opt_trait, _, _) = item.node {\n+                    opt_trait.as_ref().map(|_| {\n+                        ty::impl_id_to_trait_ref(cx, id.node)\n+                    })\n+                } else {\n+                    None\n                         ast::ItemDefaultImpl(_, ref ast_trait_ref) => {\n                             Some(ty::node_id_to_trait_ref(cx, ast_trait_ref.ref_id))\n                         }\n-                        _ => None\n-                    }\n                 }\n-                _ => None\n+            } else {\n+                None\n             }\n         } else {\n             csearch::get_impl_trait(cx, id)"}, {"sha": "af886ed25ab20a8b1b639ce9e1e23fee02fbc3ba", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -194,6 +194,7 @@ mod svh_visitor {\n         SawVariant,\n         SawExplicitSelf,\n         SawPath,\n+        SawQPath,\n         SawOptLifetimeRef,\n         SawBlock,\n         SawPat,\n@@ -485,6 +486,10 @@ mod svh_visitor {\n             SawPath.hash(self.st); visit::walk_path(self, path)\n         }\n \n+        fn visit_qpath(&mut self, qpath: &QPath, _: ast::NodeId) {\n+            SawQPath.hash(self.st); visit::walk_qpath(self, qpath)\n+        }\n+\n         fn visit_block(&mut self, b: &Block) {\n             SawBlock.hash(self.st); visit::walk_block(self, b)\n         }"}, {"sha": "1f8ae3fbbcbb47875c96d1a719475101cd90930f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -1021,6 +1021,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         self.check_path(path.span, id, path.segments.last().unwrap().identifier);\n         visit::walk_path(self, path);\n     }\n+\n+    fn visit_qpath(&mut self, qpath: &ast::QPath, id: ast::NodeId) {\n+        self.check_path(qpath.trait_path.span, id, qpath.item_path.identifier);\n+        visit::walk_qpath(self, qpath);\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "1380e2367256dbdcf1c27808d304840db8ed60ea", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 31, "deletions": 43, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -2875,8 +2875,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     this.resolve_type_parameters(&generics.ty_params);\n                     this.resolve_where_clause(&generics.where_clause);\n \n-                    this.resolve_type_parameter_bounds(item.id, bounds,\n-                                                       TraitDerivation);\n+                    this.resolve_type_parameter_bounds(bounds, TraitDerivation);\n \n                     for trait_item in &(*trait_items) {\n                         // Create a new rib for the trait_item-specific type\n@@ -3141,8 +3140,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               type_parameter: &TyParam) {\n         self.check_if_primitive_type_name(type_parameter.ident.name, type_parameter.span);\n         for bound in &*type_parameter.bounds {\n-            self.resolve_type_parameter_bound(type_parameter.id, bound,\n-                                              TraitBoundingTypeParameter);\n+            self.resolve_type_parameter_bound(bound, TraitBoundingTypeParameter);\n         }\n         match type_parameter.default {\n             Some(ref ty) => self.resolve_type(&**ty),\n@@ -3151,41 +3149,33 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn resolve_type_parameter_bounds(&mut self,\n-                                     id: NodeId,\n                                      type_parameter_bounds: &OwnedSlice<TyParamBound>,\n                                      reference_type: TraitReferenceType) {\n         for type_parameter_bound in &**type_parameter_bounds {\n-            self.resolve_type_parameter_bound(id, type_parameter_bound,\n-                                              reference_type);\n+            self.resolve_type_parameter_bound(type_parameter_bound, reference_type);\n         }\n     }\n \n     fn resolve_type_parameter_bound(&mut self,\n-                                    id: NodeId,\n                                     type_parameter_bound: &TyParamBound,\n                                     reference_type: TraitReferenceType) {\n         match *type_parameter_bound {\n             TraitTyParamBound(ref tref, _) => {\n-                self.resolve_poly_trait_reference(id, tref, reference_type)\n+                self.resolve_trait_reference(tref.trait_ref.ref_id,\n+                                             &tref.trait_ref.path,\n+                                             reference_type)\n             }\n             RegionTyParamBound(..) => {}\n         }\n     }\n \n-    fn resolve_poly_trait_reference(&mut self,\n-                                    id: NodeId,\n-                                    poly_trait_reference: &PolyTraitRef,\n-                                    reference_type: TraitReferenceType) {\n-        self.resolve_trait_reference(id, &poly_trait_reference.trait_ref, reference_type)\n-    }\n-\n     fn resolve_trait_reference(&mut self,\n                                id: NodeId,\n-                               trait_reference: &TraitRef,\n+                               trait_path: &Path,\n                                reference_type: TraitReferenceType) {\n-        match self.resolve_path(id, &trait_reference.path, TypeNS, true) {\n+        match self.resolve_path(id, trait_path, TypeNS, true) {\n             None => {\n-                let path_str = self.path_names_to_string(&trait_reference.path);\n+                let path_str = self.path_names_to_string(trait_path);\n                 let usage_str = match reference_type {\n                     TraitBoundingTypeParameter => \"bound type parameter with\",\n                     TraitImplementation        => \"implement\",\n@@ -3195,26 +3185,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n-                self.resolve_error(trait_reference.path.span, &msg[..]);\n+                self.resolve_error(trait_path.span, &msg[..]);\n             }\n             Some(def) => {\n                 match def {\n                     (DefTrait(_), _) => {\n                         debug!(\"(resolving trait) found trait def: {:?}\", def);\n-                        self.record_def(trait_reference.ref_id, def);\n+                        self.record_def(id, def);\n                     }\n                     (def, _) => {\n-                        self.resolve_error(trait_reference.path.span,\n-                                           &format!(\"`{}` is not a trait\",\n-                                                   self.path_names_to_string(\n-                                                       &trait_reference.path)));\n+                        self.resolve_error(trait_path.span,\n+                            &format!(\"`{}` is not a trait\",\n+                                     self.path_names_to_string(trait_path)));\n \n                         // If it's a typedef, give a note\n                         if let DefTy(..) = def {\n-                            self.session.span_note(\n-                                trait_reference.path.span,\n-                                &format!(\"`type` aliases cannot be used for traits\")\n-                                );\n+                            self.session.span_note(trait_path.span,\n+                                &format!(\"`type` aliases cannot be used for traits\"));\n                         }\n                     }\n                 }\n@@ -3229,8 +3216,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     self.resolve_type(&*bound_pred.bounded_ty);\n \n                     for bound in &*bound_pred.bounds {\n-                        self.resolve_type_parameter_bound(bound_pred.bounded_ty.id, bound,\n-                                                          TraitBoundingTypeParameter);\n+                        self.resolve_type_parameter_bound(bound, TraitBoundingTypeParameter);\n                     }\n                 }\n                 &ast::WherePredicate::RegionPredicate(_) => {}\n@@ -3303,14 +3289,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         result\n     }\n \n-    fn with_optional_trait_ref<T, F>(&mut self, id: NodeId,\n+    fn with_optional_trait_ref<T, F>(&mut self,\n                                      opt_trait_ref: &Option<TraitRef>,\n                                      f: F) -> T where\n         F: FnOnce(&mut Resolver) -> T,\n     {\n         let new_val = match *opt_trait_ref {\n             Some(ref trait_ref) => {\n-                self.resolve_trait_reference(id, trait_ref, TraitImplementation);\n+                self.resolve_trait_reference(trait_ref.ref_id,\n+                                             &trait_ref.path,\n+                                             TraitImplementation);\n \n                 match self.def_map.borrow().get(&trait_ref.ref_id) {\n                     Some(def) => {\n@@ -3345,7 +3333,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             this.resolve_where_clause(&generics.where_clause);\n \n             // Resolve the trait reference, if necessary.\n-            this.with_optional_trait_ref(id, opt_trait_reference, |this| {\n+            this.with_optional_trait_ref(opt_trait_reference, |this| {\n                 // Resolve the self type.\n                 this.resolve_type(self_type);\n \n@@ -3630,13 +3618,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             TyObjectSum(ref ty, ref bound_vec) => {\n                 self.resolve_type(&**ty);\n-                self.resolve_type_parameter_bounds(ty.id, bound_vec,\n-                                                       TraitBoundingTypeParameter);\n+                self.resolve_type_parameter_bounds(bound_vec, TraitBoundingTypeParameter);\n             }\n \n             TyQPath(ref qpath) => {\n                 self.resolve_type(&*qpath.self_type);\n-                self.resolve_trait_reference(ty.id, &*qpath.trait_ref, TraitQPath);\n+                self.resolve_trait_reference(ty.id, &qpath.trait_path, TraitQPath);\n                 for ty in qpath.item_path.parameters.types() {\n                     self.resolve_type(&**ty);\n                 }\n@@ -3646,10 +3633,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             TyPolyTraitRef(ref bounds) => {\n-                self.resolve_type_parameter_bounds(\n-                    ty.id,\n-                    bounds,\n-                    TraitObject);\n+                self.resolve_type_parameter_bounds(bounds, TraitObject);\n                 visit::walk_ty(self, ty);\n             }\n             _ => {\n@@ -4439,8 +4423,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     ExprPath(ref path) => path,\n                     ExprQPath(ref qpath) => {\n                         self.resolve_type(&*qpath.self_type);\n-                        self.resolve_trait_reference(expr.id, &*qpath.trait_ref, TraitQPath);\n-                        path_from_qpath = qpath.trait_ref.path.clone();\n+\n+                        // Just make sure the trait is valid, don't record a def.\n+                        self.resolve_trait_reference(expr.id, &qpath.trait_path, TraitQPath);\n+                        self.def_map.borrow_mut().remove(&expr.id);\n+\n+                        path_from_qpath = qpath.trait_path.clone();\n                         path_from_qpath.segments.push(qpath.item_path.clone());\n                         &path_from_qpath\n                     }"}, {"sha": "c92886651289270786fa1e75b2ff5a4cef13555a", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -1340,10 +1340,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 visit::walk_path(self, path);\n             }\n             ast::ExprQPath(ref qpath) => {\n-                let mut path = qpath.trait_ref.path.clone();\n+                let mut path = qpath.trait_path.clone();\n                 path.segments.push(qpath.item_path.clone());\n                 self.process_path(ex.id, ex.span, &path, None);\n-                visit::walk_qpath(self, ex.span, &**qpath);\n+                visit::walk_qpath(self, &**qpath);\n             }\n             ast::ExprStruct(ref path, ref fields, ref base) =>\n                 self.process_struct_lit(ex, path, fields, base),"}, {"sha": "3c4af12c1f994dc1f0396121833d64687aaed7dc", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -574,9 +574,10 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n     // lifetimes. Oh well, not there yet.\n     let shifted_rscope = ShiftedRscope::new(rscope);\n \n-    let trait_ref =\n-        instantiate_trait_ref(this, &shifted_rscope, &ast_trait_ref.trait_ref,\n-                              self_ty, Some(&mut projections));\n+    let trait_ref = instantiate_trait_ref(this, &shifted_rscope,\n+                                          &ast_trait_ref.trait_ref.path,\n+                                          ast_trait_ref.trait_ref.ref_id,\n+                                          None, self_ty, Some(&mut projections));\n \n     for projection in projections {\n         poly_projections.push(ty::Binder(projection));\n@@ -594,26 +595,29 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n pub fn instantiate_trait_ref<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n-    ast_trait_ref: &ast::TraitRef,\n+    path: &ast::Path,\n+    path_id: ast::NodeId,\n+    impl_id: Option<ast::NodeId>,\n     self_ty: Option<Ty<'tcx>>,\n     projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n     -> Rc<ty::TraitRef<'tcx>>\n {\n-    match ::lookup_def_tcx(this.tcx(), ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n+    match ::lookup_def_tcx(this.tcx(), path.span, path_id) {\n         def::DefTrait(trait_def_id) => {\n             let trait_ref = ast_path_to_trait_ref(this,\n                                                   rscope,\n                                                   trait_def_id,\n                                                   self_ty,\n-                                                  &ast_trait_ref.path,\n+                                                  path,\n                                                   projections);\n-            this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id, trait_ref.clone());\n+            if let Some(id) = impl_id {\n+                this.tcx().impl_trait_refs.borrow_mut().insert(id, trait_ref.clone());\n+            }\n             trait_ref\n         }\n         _ => {\n-            span_fatal!(this.tcx().sess, ast_trait_ref.path.span, E0245,\n-                \"`{}` is not a trait\",\n-                        ast_trait_ref.path.user_string(this.tcx()));\n+            span_fatal!(this.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n+                        path.user_string(this.tcx()));\n         }\n     }\n }\n@@ -1056,7 +1060,9 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     let trait_ref = instantiate_trait_ref(this,\n                                           rscope,\n-                                          &*qpath.trait_ref,\n+                                          &qpath.trait_path,\n+                                          ast_ty.id,\n+                                          None,\n                                           Some(self_type),\n                                           None);\n "}, {"sha": "b6003071f8c725c218b81bcfec8c198259f8e953", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -3611,13 +3611,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           constrain_path_type_parameters(fcx, expr);\n       }\n       ast::ExprQPath(ref qpath) => {\n-          // Require explicit type params for the trait.\n           let self_ty = fcx.to_ty(&*qpath.self_type);\n-          astconv::instantiate_trait_ref(fcx, fcx, &*qpath.trait_ref, Some(self_ty), None);\n-\n           let defn = lookup_def(fcx, expr.span, id);\n           let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx, expr.span, defn);\n-          let mut path = qpath.trait_ref.path.clone();\n+          let mut path = qpath.trait_path.clone();\n           path.segments.push(qpath.item_path.clone());\n           instantiate_path(fcx, &path, scheme, &predicates, Some(self_ty),\n                            defn, expr.span, expr.id);\n@@ -4829,7 +4826,8 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // to add defaults. If the user provided *too many* types, that's\n     // a problem.\n     for &space in &ParamSpace::all() {\n-        adjust_type_parameters(fcx, span, space, type_defs, &mut substs);\n+        adjust_type_parameters(fcx, span, space, type_defs,\n+                               opt_self_ty.is_some(), &mut substs);\n         assert_eq!(substs.types.len(space), type_defs.len(space));\n \n         adjust_region_parameters(fcx, span, space, region_defs, &mut substs);\n@@ -5007,6 +5005,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         span: Span,\n         space: ParamSpace,\n         defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n+        require_type_space: bool,\n         substs: &mut Substs<'tcx>)\n     {\n         let provided_len = substs.types.len(space);\n@@ -5029,9 +5028,8 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         // Nothing specified at all: supply inference variables for\n         // everything.\n-        if provided_len == 0 {\n-            substs.types.replace(space,\n-                                 fcx.infcx().next_ty_vars(desired.len()));\n+        if provided_len == 0 && !(require_type_space && space == subst::TypeSpace) {\n+            substs.types.replace(space, fcx.infcx().next_ty_vars(desired.len()));\n             return;\n         }\n "}, {"sha": "e024526d0016f7756c18baa0e2036f2379b0a213", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -81,8 +81,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             ast::ItemImpl(_, ast::ImplPolarity::Positive, _, _, _, _) => {\n                 self.check_impl(item);\n             }\n-            ast::ItemImpl(_, ast::ImplPolarity::Negative, _, Some(ref tref), _, _) => {\n-                let trait_ref = ty::node_id_to_trait_ref(ccx.tcx, tref.ref_id);\n+            ast::ItemImpl(_, ast::ImplPolarity::Negative, _, Some(_), _, _) => {\n+                let trait_ref = ty::impl_id_to_trait_ref(ccx.tcx, item.id);\n                 ty::populate_implementations_for_trait_if_necessary(ccx.tcx, trait_ref.def_id);\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}"}, {"sha": "e89c96b36e1a23887e2b52631945d2a2c99985dd", "filename": "src/librustc_typeck/coherence/impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -28,8 +28,8 @@ struct ImplsChecker<'cx, 'tcx:'cx> {\n impl<'cx, 'tcx,'v> visit::Visitor<'v> for ImplsChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v ast::Item) {\n         match item.node {\n-            ast::ItemImpl(_, _, _, Some(ref opt_trait), _, _) => {\n-                let trait_ref = ty::node_id_to_trait_ref(self.tcx, opt_trait.ref_id);\n+            ast::ItemImpl(_, _, _, Some(_), _, _) => {\n+                let trait_ref = ty::impl_id_to_trait_ref(self.tcx, item.id);\n                 if let Some(_) = self.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     match trait_ref.self_ty().sty {\n                         ty::ty_struct(..) | ty::ty_enum(..) => {}"}, {"sha": "1913b55f1d8e69d03da3fc0b368345b055522ed5", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -106,19 +106,9 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx> {\n \n         //debug!(\"(checking coherence) item '{}'\", token::get_ident(item.ident));\n \n-        match item.node {\n-            ItemImpl(_, _, _, ref opt_trait, _, _) => {\n-                match opt_trait.clone() {\n-                    Some(opt_trait) => {\n-                        self.cc.check_implementation(item, &[opt_trait]);\n-                    }\n-                    None => self.cc.check_implementation(item, &[])\n-                }\n-            }\n-            _ => {\n-                // Nothing to do.\n-            }\n-        };\n+        if let ItemImpl(_, _, _, ref opt_trait, _, _) = item.node {\n+            self.cc.check_implementation(item, opt_trait.as_ref())\n+        }\n \n         visit::walk_item(self, item);\n     }\n@@ -155,9 +145,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         self.check_implementations_of_copy();\n     }\n \n-    fn check_implementation(&self,\n-                            item: &Item,\n-                            associated_traits: &[TraitRef]) {\n+    fn check_implementation(&self, item: &Item, opt_trait: Option<&TraitRef>) {\n         let tcx = self.crate_context.tcx;\n         let impl_did = local_def(item.id);\n         let self_type = ty::lookup_item_type(tcx, impl_did);\n@@ -167,9 +155,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         let impl_items = self.create_impl_from_item(item);\n \n-        for associated_trait in associated_traits {\n-            let trait_ref = ty::node_id_to_trait_ref(self.crate_context.tcx,\n-                                                     associated_trait.ref_id);\n+        if opt_trait.is_some() {\n+            let trait_ref = ty::impl_id_to_trait_ref(self.crate_context.tcx, item.id);\n             debug!(\"(checking implementation) adding impl for trait '{}', item '{}'\",\n                    trait_ref.repr(self.crate_context.tcx),\n                    token::get_ident(item.ident));\n@@ -191,7 +178,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n             Some(base_type_def_id) => {\n                 // FIXME: Gather up default methods?\n-                if associated_traits.len() == 0 {\n+                if opt_trait.is_none() {\n                     self.add_inherent_impl(base_type_def_id, impl_did);\n                 }\n             }\n@@ -289,7 +276,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     // Converts an implementation in the AST to a vector of items.\n     fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> {\n         match item.node {\n-            ItemImpl(_, _, _, ref trait_refs, _, ref ast_items) => {\n+            ItemImpl(_, _, _, ref opt_trait, _, ref ast_items) => {\n                 let mut items: Vec<ImplOrTraitItemId> =\n                         ast_items.iter()\n                                  .map(|ast_item| {\n@@ -304,13 +291,12 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                             }\n                         }).collect();\n \n-                if let Some(ref trait_ref) = *trait_refs {\n-                    let ty_trait_ref = ty::node_id_to_trait_ref(\n-                        self.crate_context.tcx,\n-                        trait_ref.ref_id);\n+                if opt_trait.is_some() {\n+                    let trait_ref = ty::impl_id_to_trait_ref(self.crate_context.tcx,\n+                                                             item.id);\n \n                     self.instantiate_default_methods(local_def(item.id),\n-                                                     &*ty_trait_ref,\n+                                                     &*trait_ref,\n                                                      &mut items);\n                 }\n "}, {"sha": "65c1d7adf48769f7b25d523d6ec799dd1869890a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -740,7 +740,9 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n             if let Some(ref trait_ref) = *opt_trait_ref {\n                 astconv::instantiate_trait_ref(ccx,\n                                                &ExplicitRscope,\n-                                               trait_ref,\n+                                               &trait_ref.path,\n+                                               trait_ref.ref_id,\n+                                               Some(it.id),\n                                                Some(selfty),\n                                                None);\n             }"}, {"sha": "8e08c5278d004609a6ea0931d969766cec88aca7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -1629,7 +1629,7 @@ impl Clean<Type> for ast::QPath {\n         Type::QPath {\n             name: self.item_path.identifier.clean(cx),\n             self_type: box self.self_type.clean(cx),\n-            trait_: box self.trait_ref.clean(cx)\n+            trait_: box resolve_type(cx, self.trait_path.clean(cx), 0)\n         }\n     }\n }"}, {"sha": "5f9776425c3ff641f15a02d888669c390bf6b993", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -782,11 +782,11 @@ pub enum Expr_ {\n ///\n ///     <Vec<T> as SomeTrait>::SomeAssociatedItem\n ///      ^~~~~     ^~~~~~~~~   ^~~~~~~~~~~~~~~~~~\n-///      self_type  trait_name  item_path\n+///      self_type  trait_path  item_path\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct QPath {\n     pub self_type: P<Ty>,\n-    pub trait_ref: P<TraitRef>,\n+    pub trait_path: Path,\n     pub item_path: PathSegment,\n }\n \n@@ -1258,12 +1258,12 @@ pub enum Ty_ {\n     ///\n     /// Type parameters are stored in the Path itself\n     TyPath(Path),\n+    /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`\n+    TyQPath(P<QPath>),\n     /// Something like `A+B`. Note that `B` must always be a path.\n     TyObjectSum(P<Ty>, TyParamBounds),\n     /// A type like `for<'a> Foo<&'a Bar>`\n     TyPolyTraitRef(TyParamBounds),\n-    /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`\n-    TyQPath(P<QPath>),\n     /// No-op; kept solely so that we can pretty-print faithfully\n     TyParen(P<Ty>),\n     /// Unused for now"}, {"sha": "f207efc5b6c3410a2d4bca85d10c5b65a5517796", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -561,13 +561,18 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         visit::walk_trait_item(self, tm);\n     }\n \n-    fn visit_lifetime_ref(&mut self, lifetime: &'v Lifetime) {\n+    fn visit_lifetime_ref(&mut self, lifetime: &Lifetime) {\n         self.operation.visit_id(lifetime.id);\n     }\n \n-    fn visit_lifetime_def(&mut self, def: &'v LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, def: &LifetimeDef) {\n         self.visit_lifetime_ref(&def.lifetime);\n     }\n+\n+    fn visit_trait_ref(&mut self, trait_ref: &TraitRef) {\n+        self.operation.visit_id(trait_ref.ref_id);\n+        visit::walk_trait_ref(self, trait_ref);\n+    }\n }\n \n pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &InlinedItem,"}, {"sha": "c0421fb6f1cf2050dfb551aca1e0c92c95d99375", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -429,13 +429,13 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n             TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n             TyParen(ty) => TyParen(fld.fold_ty(ty)),\n             TyPath(path) => TyPath(fld.fold_path(path)),\n+            TyQPath(qpath) => {\n+                TyQPath(fld.fold_qpath(qpath))\n+            }\n             TyObjectSum(ty, bounds) => {\n                 TyObjectSum(fld.fold_ty(ty),\n                             fld.fold_bounds(bounds))\n             }\n-            TyQPath(qpath) => {\n-                TyQPath(fld.fold_qpath(qpath))\n-            }\n             TyFixedLengthVec(ty, e) => {\n                 TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n             }\n@@ -454,7 +454,7 @@ pub fn noop_fold_qpath<T: Folder>(qpath: P<QPath>, fld: &mut T) -> P<QPath> {\n     qpath.map(|qpath| {\n         QPath {\n             self_type: fld.fold_ty(qpath.self_type),\n-            trait_ref: qpath.trait_ref.map(|tr| fld.fold_trait_ref(tr)),\n+            trait_path: fld.fold_path(qpath.trait_path),\n             item_path: PathSegment {\n                 identifier: fld.fold_ident(qpath.item_path.identifier),\n                 parameters: fld.fold_path_parameters(qpath.item_path.parameters),"}, {"sha": "b2f597258558d18e8a26f5b7248f05d7be2af0e8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -1525,13 +1525,13 @@ impl<'a> Parser<'a> {\n             // QUALIFIED PATH `<TYPE as TRAIT_REF>::item`\n             let self_type = self.parse_ty_sum();\n             self.expect_keyword(keywords::As);\n-            let trait_ref = self.parse_trait_ref();\n+            let trait_path = self.parse_path(LifetimeAndTypesWithoutColons);\n             self.expect(&token::Gt);\n             self.expect(&token::ModSep);\n             let item_name = self.parse_ident();\n             TyQPath(P(QPath {\n                 self_type: self_type,\n-                trait_ref: P(trait_ref),\n+                trait_path: trait_path,\n                 item_path: ast::PathSegment {\n                     identifier: item_name,\n                     parameters: ast::PathParameters::none()\n@@ -2220,7 +2220,7 @@ impl<'a> Parser<'a> {\n                     // QUALIFIED PATH `<TYPE as TRAIT_REF>::item::<'a, T>`\n                     let self_type = self.parse_ty_sum();\n                     self.expect_keyword(keywords::As);\n-                    let trait_ref = self.parse_trait_ref();\n+                    let trait_path = self.parse_path(LifetimeAndTypesWithoutColons);\n                     self.expect(&token::Gt);\n                     self.expect(&token::ModSep);\n                     let item_name = self.parse_ident();\n@@ -2240,7 +2240,7 @@ impl<'a> Parser<'a> {\n                     let hi = self.span.hi;\n                     return self.mk_expr(lo, hi, ExprQPath(P(QPath {\n                         self_type: self_type,\n-                        trait_ref: P(trait_ref),\n+                        trait_path: trait_path,\n                         item_path: ast::PathSegment {\n                             identifier: item_name,\n                             parameters: parameters"}, {"sha": "3cfb90a3e68182259ee8e09486aac5020af71ef7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -2047,7 +2047,7 @@ impl<'a> State<'a> {\n         try!(self.print_type(&*qpath.self_type));\n         try!(space(&mut self.s));\n         try!(self.word_space(\"as\"));\n-        try!(self.print_trait_ref(&*qpath.trait_ref));\n+        try!(self.print_path(&qpath.trait_path, false));\n         try!(word(&mut self.s, \">\"));\n         try!(word(&mut self.s, \"::\"));\n         try!(self.print_ident(qpath.item_path.identifier));"}, {"sha": "4e90adea90c6211a4771446a3851a876cc589736", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -125,8 +125,8 @@ pub trait Visitor<'v> : Sized {\n     fn visit_path(&mut self, path: &'v Path, _id: ast::NodeId) {\n         walk_path(self, path)\n     }\n-    fn visit_qpath(&mut self, qpath_span: Span, qpath: &'v QPath) {\n-        walk_qpath(self, qpath_span, qpath)\n+    fn visit_qpath(&mut self, qpath: &'v QPath, _id: ast::NodeId) {\n+        walk_qpath(self, qpath)\n     }\n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment) {\n         walk_path_segment(self, path_span, path_segment)\n@@ -402,13 +402,13 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyPath(ref path) => {\n             visitor.visit_path(path, typ.id);\n         }\n+        TyQPath(ref qpath) => {\n+            visitor.visit_qpath(&**qpath, typ.id);\n+        }\n         TyObjectSum(ref ty, ref bounds) => {\n             visitor.visit_ty(&**ty);\n             walk_ty_param_bounds_helper(visitor, bounds);\n         }\n-        TyQPath(ref qpath) => {\n-            visitor.visit_qpath(typ.span, &**qpath);\n-        }\n         TyFixedLengthVec(ref ty, ref expression) => {\n             visitor.visit_ty(&**ty);\n             visitor.visit_expr(&**expression)\n@@ -436,12 +436,10 @@ pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n     }\n }\n \n-pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                      qpath_span: Span,\n-                                      qpath: &'v QPath) {\n+pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath) {\n     visitor.visit_ty(&*qpath.self_type);\n-    visitor.visit_trait_ref(&*qpath.trait_ref);\n-    visitor.visit_path_segment(qpath_span, &qpath.item_path);\n+    walk_path(visitor, &qpath.trait_path);\n+    visitor.visit_path_segment(qpath.trait_path.span, &qpath.item_path);\n }\n \n pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n@@ -873,7 +871,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_path(path, expression.id)\n         }\n         ExprQPath(ref qpath) => {\n-            visitor.visit_qpath(expression.span, &**qpath)\n+            visitor.visit_qpath(&**qpath, expression.id)\n         }\n         ExprBreak(_) | ExprAgain(_) => {}\n         ExprRet(ref optional_expression) => {"}, {"sha": "b3fe178dc455e83b0d8c40f7092b57cbee1090fd", "filename": "src/test/compile-fail/ufcs-qpath-missing-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/004df413aa35b3d610faf231682cfbae5d4eeb46/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-qpath-missing-params.rs?ref=004df413aa35b3d610faf231682cfbae5d4eeb46", "patch": "@@ -12,5 +12,5 @@ use std::borrow::IntoCow;\n \n fn main() {\n     <String as IntoCow>::into_cow(\"foo\".to_string());\n-    //~^ ERROR wrong number of type arguments: expected 1, found 0\n+    //~^ ERROR too few type parameters provided: expected 1 parameter(s)\n }"}]}