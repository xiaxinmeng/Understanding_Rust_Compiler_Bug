{"sha": "9cca96545faf2cfc972cc67b83deae2a78935c43", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljY2E5NjU0NWZhZjJjZmM5NzJjYzY3YjgzZGVhZTJhNzg5MzVjNDM=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2015-09-07T22:36:29Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2015-09-07T22:36:29Z"}, "message": "some more clippy-based improvements", "tree": {"sha": "ef675da82a1ce1b23173921957f6a6a167ad8db8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef675da82a1ce1b23173921957f6a6a167ad8db8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cca96545faf2cfc972cc67b83deae2a78935c43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cca96545faf2cfc972cc67b83deae2a78935c43", "html_url": "https://github.com/rust-lang/rust/commit/9cca96545faf2cfc972cc67b83deae2a78935c43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cca96545faf2cfc972cc67b83deae2a78935c43/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bf626a68045be1d1a4fac9a635113bb7775b6bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bf626a68045be1d1a4fac9a635113bb7775b6bb", "html_url": "https://github.com/rust-lang/rust/commit/7bf626a68045be1d1a4fac9a635113bb7775b6bb"}], "stats": {"total": 526, "additions": 253, "deletions": 273}, "files": [{"sha": "f48443e52b3e9350ffb6263693af807c79c2324f", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -220,7 +220,7 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n         *self.copy_head.borrow_mut() =\n             chunk((new_min_chunk_size + 1).next_power_of_two(), true);\n \n-        return self.alloc_copy_inner(n_bytes, align);\n+        self.alloc_copy_inner(n_bytes, align)\n     }\n \n     #[inline]\n@@ -247,7 +247,7 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n                                             mem::align_of::<T>());\n             let ptr = ptr as *mut T;\n             ptr::write(&mut (*ptr), op());\n-            return &mut *ptr;\n+            &mut *ptr\n         }\n     }\n \n@@ -261,7 +261,7 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n         *self.head.borrow_mut() =\n             chunk((new_min_chunk_size + 1).next_power_of_two(), false);\n \n-        return self.alloc_noncopy_inner(n_bytes, align);\n+        self.alloc_noncopy_inner(n_bytes, align)\n     }\n \n     #[inline]\n@@ -290,7 +290,7 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n \n         unsafe {\n             let buf = head.as_ptr();\n-            return (buf.offset(tydesc_start as isize), buf.offset(start as isize));\n+            (buf.offset(tydesc_start as isize), buf.offset(start as isize))\n         }\n     }\n \n@@ -312,7 +312,7 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n             // the object is there.\n             *ty_ptr = bitpack_tydesc_ptr(tydesc, true);\n \n-            return &mut *ptr;\n+            &mut *ptr\n         }\n     }\n \n@@ -486,14 +486,12 @@ impl<T> TypedArena<T> {\n             self.grow()\n         }\n \n-        let ptr: &mut T = unsafe {\n+        unsafe {\n             let ptr: &mut T = &mut *(self.ptr.get() as *mut T);\n             ptr::write(ptr, object);\n             self.ptr.set(self.ptr.get().offset(1));\n             ptr\n-        };\n-\n-        ptr\n+        }\n     }\n \n     /// Grows the arena."}, {"sha": "694d93b75ca4161c7860b732722578e9fc0a812b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -1558,10 +1558,10 @@ impl StrExt for str {\n             if w > 2 { val = utf8_acc_cont_byte(val, s.as_bytes()[i + 2]); }\n             if w > 3 { val = utf8_acc_cont_byte(val, s.as_bytes()[i + 3]); }\n \n-            return CharRange {ch: unsafe { char::from_u32_unchecked(val) }, next: i};\n+            CharRange {ch: unsafe { char::from_u32_unchecked(val) }, next: i}\n         }\n \n-        return multibyte_char_range_at_reverse(self, prev);\n+        multibyte_char_range_at_reverse(self, prev)\n     }\n \n     #[inline]\n@@ -1683,7 +1683,7 @@ fn char_range_at_raw(bytes: &[u8], i: usize) -> (u32, usize) {\n         if w > 2 { val = utf8_acc_cont_byte(val, bytes[i + 2]); }\n         if w > 3 { val = utf8_acc_cont_byte(val, bytes[i + 3]); }\n \n-        return (val, i + w as usize);\n+        (val, i + w as usize)\n     }\n \n     multibyte_char_range_at(bytes, i)"}, {"sha": "ab34f2e48ca4abcd813fe5826399d9bf06890e56", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -229,14 +229,14 @@ impl Name {\n         if nm.len() == 1 {\n             Short(nm.char_at(0))\n         } else {\n-            Long(nm.to_string())\n+            Long(nm.to_owned())\n         }\n     }\n \n     fn to_string(&self) -> String {\n         match *self {\n             Short(ch) => ch.to_string(),\n-            Long(ref s) => s.to_string()\n+            Long(ref s) => s.to_owned()\n         }\n     }\n }\n@@ -375,7 +375,7 @@ impl Matches {\n         } else {\n             match vals[0] {\n                 Val(ref s) => Some((*s).clone()),\n-                _ => Some(def.to_string())\n+                _ => Some(def.to_owned())\n             }\n         }\n     }\n@@ -414,10 +414,10 @@ pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptG\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_string(),\n-        long_name: long_name.to_string(),\n-        hint: hint.to_string(),\n-        desc: desc.to_string(),\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: hint.to_owned(),\n+        desc: desc.to_owned(),\n         hasarg: Yes,\n         occur: Req\n     }\n@@ -434,10 +434,10 @@ pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptG\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_string(),\n-        long_name: long_name.to_string(),\n-        hint: hint.to_string(),\n-        desc: desc.to_string(),\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: hint.to_owned(),\n+        desc: desc.to_owned(),\n         hasarg: Yes,\n         occur: Optional\n     }\n@@ -452,10 +452,10 @@ pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_string(),\n-        long_name: long_name.to_string(),\n-        hint: \"\".to_string(),\n-        desc: desc.to_string(),\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: \"\".to_owned(),\n+        desc: desc.to_owned(),\n         hasarg: No,\n         occur: Optional\n     }\n@@ -471,10 +471,10 @@ pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_string(),\n-        long_name: long_name.to_string(),\n-        hint: \"\".to_string(),\n-        desc: desc.to_string(),\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: \"\".to_owned(),\n+        desc: desc.to_owned(),\n         hasarg: No,\n         occur: Multi\n     }\n@@ -491,10 +491,10 @@ pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) ->\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_string(),\n-        long_name: long_name.to_string(),\n-        hint: hint.to_string(),\n-        desc: desc.to_string(),\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: hint.to_owned(),\n+        desc: desc.to_owned(),\n         hasarg: Maybe,\n         occur: Optional\n     }\n@@ -512,10 +512,10 @@ pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> Op\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_string(),\n-        long_name: long_name.to_string(),\n-        hint: hint.to_string(),\n-        desc: desc.to_string(),\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: hint.to_owned(),\n+        desc: desc.to_owned(),\n         hasarg: Yes,\n         occur: Multi\n     }\n@@ -531,10 +531,10 @@ pub fn opt(short_name: &str,\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_string(),\n-        long_name: long_name.to_string(),\n-        hint: hint.to_string(),\n-        desc: desc.to_string(),\n+        short_name: short_name.to_owned(),\n+        long_name: long_name.to_owned(),\n+        hint: hint.to_owned(),\n+        desc: desc.to_owned(),\n         hasarg: hasarg,\n         occur: occur\n     }\n@@ -574,7 +574,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     let opts: Vec<Opt> = optgrps.iter().map(|x| x.long_to_short()).collect();\n     let n_opts = opts.len();\n \n-    fn f(_x: usize) -> Vec<Optval> { return Vec::new(); }\n+    fn f(_x: usize) -> Vec<Optval> { Vec::new() }\n \n     let mut vals: Vec<_> = (0..n_opts).map(f).collect();\n     let mut free: Vec<String> = Vec::new();\n@@ -596,11 +596,11 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                 let tail = &cur[2..curlen];\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n-                    names = vec!(Long(tail.to_string()));\n+                    names = vec!(Long(tail.to_owned()));\n                 } else {\n                     names =\n-                        vec!(Long(tail_eq[0].to_string()));\n-                    i_arg = Some(tail_eq[1].to_string());\n+                        vec!(Long(tail_eq[0].to_owned()));\n+                    i_arg = Some(tail_eq[1].to_owned());\n                 }\n             } else {\n                 let mut j = 1;\n@@ -630,7 +630,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n \n                     let next = j + ch.len_utf8();\n                     if arg_follows && next < curlen {\n-                        i_arg = Some((&cur[next..curlen]).to_string());\n+                        i_arg = Some((&cur[next..curlen]).to_owned());\n                         break;\n                     }\n \n@@ -769,7 +769,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n         // FIXME: #5516 should be graphemes not codepoints\n         let mut desc_rows = Vec::new();\n         each_split_within(&desc_normalized_whitespace[..], 54, |substr| {\n-            desc_rows.push(substr.to_string());\n+            desc_rows.push(substr.to_owned());\n             true\n         });\n \n@@ -936,7 +936,7 @@ fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool where\n         machine(&mut cont, (fake_i, ' '));\n         fake_i += 1;\n     }\n-    return cont;\n+    cont\n }\n \n #[test]"}, {"sha": "362303869d78ddcbb17d03c0ab870130d88499e1", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -74,12 +74,12 @@ pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<String>) {\n             }\n         };\n         dirs.push(LogDirective {\n-            name: name.map(|s| s.to_string()),\n+            name: name.map(str::to_owned),\n             level: log_level,\n         });\n     }});\n \n-    (dirs, filter.map(|s| s.to_string()))\n+    (dirs, filter.map(str::to_owned))\n }\n \n #[cfg(test)]\n@@ -90,13 +90,13 @@ mod tests {\n     fn parse_logging_spec_valid() {\n         let (dirs, filter) = parse_logging_spec(\"crate1::mod1=1,crate1::mod2,crate2=4\");\n         assert_eq!(dirs.len(), 3);\n-        assert_eq!(dirs[0].name, Some(\"crate1::mod1\".to_string()));\n+        assert_eq!(dirs[0].name, Some(\"crate1::mod1\".to_owned()));\n         assert_eq!(dirs[0].level, 1);\n \n-        assert_eq!(dirs[1].name, Some(\"crate1::mod2\".to_string()));\n+        assert_eq!(dirs[1].name, Some(\"crate1::mod2\".to_owned()));\n         assert_eq!(dirs[1].level, ::MAX_LOG_LEVEL);\n \n-        assert_eq!(dirs[2].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[2].name, Some(\"crate2\".to_owned()));\n         assert_eq!(dirs[2].level, 4);\n         assert!(filter.is_none());\n     }\n@@ -106,7 +106,7 @@ mod tests {\n         // test parse_logging_spec with multiple = in specification\n         let (dirs, filter) = parse_logging_spec(\"crate1::mod1=1=2,crate2=4\");\n         assert_eq!(dirs.len(), 1);\n-        assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_owned()));\n         assert_eq!(dirs[0].level, 4);\n         assert!(filter.is_none());\n     }\n@@ -116,7 +116,7 @@ mod tests {\n         // test parse_logging_spec with 'noNumber' as log level\n         let (dirs, filter) = parse_logging_spec(\"crate1::mod1=noNumber,crate2=4\");\n         assert_eq!(dirs.len(), 1);\n-        assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_owned()));\n         assert_eq!(dirs[0].level, 4);\n         assert!(filter.is_none());\n     }\n@@ -126,7 +126,7 @@ mod tests {\n         // test parse_logging_spec with 'warn' as log level\n         let (dirs, filter) = parse_logging_spec(\"crate1::mod1=wrong,crate2=warn\");\n         assert_eq!(dirs.len(), 1);\n-        assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_owned()));\n         assert_eq!(dirs[0].level, ::WARN);\n         assert!(filter.is_none());\n     }\n@@ -136,7 +136,7 @@ mod tests {\n         // test parse_logging_spec with '' as log level\n         let (dirs, filter) = parse_logging_spec(\"crate1::mod1=wrong,crate2=\");\n         assert_eq!(dirs.len(), 1);\n-        assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_owned()));\n         assert_eq!(dirs[0].level, ::MAX_LOG_LEVEL);\n         assert!(filter.is_none());\n     }\n@@ -148,7 +148,7 @@ mod tests {\n         assert_eq!(dirs.len(), 2);\n         assert_eq!(dirs[0].name, None);\n         assert_eq!(dirs[0].level, 2);\n-        assert_eq!(dirs[1].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[1].name, Some(\"crate2\".to_owned()));\n         assert_eq!(dirs[1].level, 4);\n         assert!(filter.is_none());\n     }\n@@ -157,32 +157,32 @@ mod tests {\n     fn parse_logging_spec_valid_filter() {\n         let (dirs, filter) = parse_logging_spec(\"crate1::mod1=1,crate1::mod2,crate2=4/abc\");\n         assert_eq!(dirs.len(), 3);\n-        assert_eq!(dirs[0].name, Some(\"crate1::mod1\".to_string()));\n+        assert_eq!(dirs[0].name, Some(\"crate1::mod1\".to_owned()));\n         assert_eq!(dirs[0].level, 1);\n \n-        assert_eq!(dirs[1].name, Some(\"crate1::mod2\".to_string()));\n+        assert_eq!(dirs[1].name, Some(\"crate1::mod2\".to_owned()));\n         assert_eq!(dirs[1].level, ::MAX_LOG_LEVEL);\n \n-        assert_eq!(dirs[2].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[2].name, Some(\"crate2\".to_owned()));\n         assert_eq!(dirs[2].level, 4);\n-        assert!(filter.is_some() && filter.unwrap().to_string() == \"abc\");\n+        assert!(filter.is_some() && filter.unwrap().to_owned() == \"abc\");\n     }\n \n     #[test]\n     fn parse_logging_spec_invalid_crate_filter() {\n         let (dirs, filter) = parse_logging_spec(\"crate1::mod1=1=2,crate2=4/a.c\");\n         assert_eq!(dirs.len(), 1);\n-        assert_eq!(dirs[0].name, Some(\"crate2\".to_string()));\n+        assert_eq!(dirs[0].name, Some(\"crate2\".to_owned()));\n         assert_eq!(dirs[0].level, 4);\n-        assert!(filter.is_some() && filter.unwrap().to_string() == \"a.c\");\n+        assert!(filter.is_some() && filter.unwrap().to_owned() == \"a.c\");\n     }\n \n     #[test]\n     fn parse_logging_spec_empty_with_filter() {\n         let (dirs, filter) = parse_logging_spec(\"crate1/a*c\");\n         assert_eq!(dirs.len(), 1);\n-        assert_eq!(dirs[0].name, Some(\"crate1\".to_string()));\n+        assert_eq!(dirs[0].name, Some(\"crate1\".to_owned()));\n         assert_eq!(dirs[0].level, ::MAX_LOG_LEVEL);\n-        assert!(filter.is_some() && filter.unwrap().to_string() == \"a*c\");\n+        assert!(filter.is_some() && filter.unwrap().to_owned() == \"a*c\");\n     }\n }"}, {"sha": "050b1a3bc1645d46f262fb80ae70efc1aa1da8d3", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -1039,8 +1039,8 @@ impl Json {\n      /// If the Json value is an Object, returns the value associated with the provided key.\n     /// Otherwise, returns None.\n     pub fn find<'a>(&'a self, key: &str) -> Option<&'a Json>{\n-        match self {\n-            &Json::Object(ref map) => map.get(key),\n+        match *self {\n+            Json::Object(ref map) => map.get(key),\n             _ => None\n         }\n     }\n@@ -1083,41 +1083,41 @@ impl Json {\n     }\n \n     /// Returns true if the Json value is an Object. Returns false otherwise.\n-    pub fn is_object<'a>(&'a self) -> bool {\n+    pub fn is_object(&self) -> bool {\n         self.as_object().is_some()\n     }\n \n     /// If the Json value is an Object, returns the associated BTreeMap.\n     /// Returns None otherwise.\n-    pub fn as_object<'a>(&'a self) -> Option<&'a Object> {\n-        match self {\n-            &Json::Object(ref map) => Some(map),\n+    pub fn as_object(&self) -> Option<&Object> {\n+        match *self {\n+            Json::Object(ref map) => Some(map),\n             _ => None\n         }\n     }\n \n     /// Returns true if the Json value is an Array. Returns false otherwise.\n-    pub fn is_array<'a>(&'a self) -> bool {\n+    pub fn is_array(&self) -> bool {\n         self.as_array().is_some()\n     }\n \n     /// If the Json value is an Array, returns the associated vector.\n     /// Returns None otherwise.\n-    pub fn as_array<'a>(&'a self) -> Option<&'a Array> {\n-        match self {\n-            &Json::Array(ref array) => Some(&*array),\n+    pub fn as_array(&self) -> Option<&Array> {\n+        match *self {\n+            Json::Array(ref array) => Some(&*array),\n             _ => None\n         }\n     }\n \n     /// Returns true if the Json value is a String. Returns false otherwise.\n-    pub fn is_string<'a>(&'a self) -> bool {\n+    pub fn is_string(&self) -> bool {\n         self.as_string().is_some()\n     }\n \n     /// If the Json value is a String, returns the associated str.\n     /// Returns None otherwise.\n-    pub fn as_string<'a>(&'a self) -> Option<&'a str> {\n+    pub fn as_string(&self) -> Option<&str> {\n         match *self {\n             Json::String(ref s) => Some(&s[..]),\n             _ => None\n@@ -1195,8 +1195,8 @@ impl Json {\n     /// If the Json value is a Boolean, returns the associated bool.\n     /// Returns None otherwise.\n     pub fn as_boolean(&self) -> Option<bool> {\n-        match self {\n-            &Json::Boolean(b) => Some(b),\n+        match *self {\n+            Json::Boolean(b) => Some(b),\n             _ => None\n         }\n     }\n@@ -1209,8 +1209,8 @@ impl Json {\n     /// If the Json value is a Null, returns ().\n     /// Returns None otherwise.\n     pub fn as_null(&self) -> Option<()> {\n-        match self {\n-            &Json::Null => Some(()),\n+        match *self {\n+            Json::Null => Some(()),\n             _ => None\n         }\n     }\n@@ -1228,8 +1228,8 @@ impl Index<usize> for Json {\n     type Output = Json;\n \n     fn index<'a>(&'a self, idx: usize) -> &'a Json {\n-        match self {\n-            &Json::Array(ref v) => &v[idx],\n+        match *self {\n+            Json::Array(ref v) => &v[idx],\n             _ => panic!(\"can only index Json with usize if it is an array\")\n         }\n     }\n@@ -1323,36 +1323,36 @@ impl Stack {\n     /// Compares this stack with an array of StackElements.\n     pub fn is_equal_to(&self, rhs: &[StackElement]) -> bool {\n         if self.stack.len() != rhs.len() { return false; }\n-        for i in 0..rhs.len() {\n-            if self.get(i) != rhs[i] { return false; }\n+        for (i, r) in rhs.iter().enumerate() {\n+            if &self.get(i) != r { return false; }\n         }\n-        return true;\n+        true\n     }\n \n     /// Returns true if the bottom-most elements of this stack are the same as\n     /// the ones passed as parameter.\n     pub fn starts_with(&self, rhs: &[StackElement]) -> bool {\n         if self.stack.len() < rhs.len() { return false; }\n-        for i in 0..rhs.len() {\n-            if self.get(i) != rhs[i] { return false; }\n+        for (i, r) in rhs.iter().enumerate() {\n+            if &self.get(i) != r { return false; }\n         }\n-        return true;\n+        true\n     }\n \n     /// Returns true if the top-most elements of this stack are the same as\n     /// the ones passed as parameter.\n     pub fn ends_with(&self, rhs: &[StackElement]) -> bool {\n         if self.stack.len() < rhs.len() { return false; }\n         let offset = self.stack.len() - rhs.len();\n-        for i in 0..rhs.len() {\n-            if self.get(i + offset) != rhs[i] { return false; }\n+        for (i, r) in rhs.iter().enumerate() {\n+            if &self.get(i + offset) != r { return false; }\n         }\n-        return true;\n+        true\n     }\n \n     /// Returns the top-most element (if any).\n     pub fn top<'l>(&'l self) -> Option<StackElement<'l>> {\n-        return match self.stack.last() {\n+        match self.stack.last() {\n             None => None,\n             Some(&InternalIndex(i)) => Some(StackElement::Index(i)),\n             Some(&InternalKey(start, size)) => {\n@@ -1442,7 +1442,7 @@ impl<T: Iterator<Item=char>> Iterator for Parser<T> {\n             }\n         }\n \n-        return Some(self.parse());\n+        Some(self.parse())\n     }\n }\n \n@@ -1458,13 +1458,13 @@ impl<T: Iterator<Item=char>> Parser<T> {\n             state: ParseStart,\n         };\n         p.bump();\n-        return p;\n+        p\n     }\n \n     /// Provides access to the current position in the logical structure of the\n     /// JSON stream.\n     pub fn stack<'l>(&'l self) -> &'l Stack {\n-        return &self.stack;\n+        &self.stack\n     }\n \n     fn eof(&self) -> bool { self.ch.is_none() }\n@@ -1559,9 +1559,8 @@ impl<T: Iterator<Item=char>> Parser<T> {\n                 self.bump();\n \n                 // A leading '0' must be the only digit before the decimal point.\n-                match self.ch_or_null() {\n-                    '0' ... '9' => return self.error(InvalidNumber),\n-                    _ => ()\n+                if let '0' ... '9' = self.ch_or_null() {\n+                    return self.error(InvalidNumber)\n                 }\n             },\n             '1' ... '9' => {\n@@ -1798,7 +1797,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n             ObjectStart => ParseObject(true),\n             _ => ParseBeforeFinish,\n         };\n-        return val;\n+        val\n     }\n \n     fn parse_array(&mut self, first: bool) -> JsonEvent {\n@@ -1905,7 +1904,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n             ObjectStart => ParseObject(true),\n             _ => ParseObjectComma,\n         };\n-        return val;\n+        val\n     }\n \n     fn parse_object_end(&mut self) -> JsonEvent {\n@@ -1994,7 +1993,7 @@ impl<T: Iterator<Item=char>> Builder<T> {\n     }\n \n     fn build_value(&mut self) -> Result<Json, BuilderError> {\n-        return match self.token {\n+        match self.token {\n             Some(NullValue) => Ok(Json::Null),\n             Some(I64Value(n)) => Ok(Json::I64(n)),\n             Some(U64Value(n)) => Ok(Json::U64(n)),\n@@ -2043,7 +2042,7 @@ impl<T: Iterator<Item=char>> Builder<T> {\n                 _ => {}\n             }\n             let key = match self.parser.stack().top() {\n-                Some(StackElement::Key(k)) => { k.to_string() }\n+                Some(StackElement::Key(k)) => { k.to_owned() }\n                 _ => { panic!(\"invalid state\"); }\n             };\n             match self.build_value() {\n@@ -2052,7 +2051,7 @@ impl<T: Iterator<Item=char>> Builder<T> {\n             }\n             self.bump();\n         }\n-        return self.parser.error(EOFWhileParsingObject);\n+        self.parser.error(EOFWhileParsingObject)\n     }\n }\n \n@@ -2099,15 +2098,15 @@ macro_rules! expect {\n     ($e:expr, Null) => ({\n         match $e {\n             Json::Null => Ok(()),\n-            other => Err(ExpectedError(\"Null\".to_string(),\n+            other => Err(ExpectedError(\"Null\".to_owned(),\n                                        format!(\"{}\", other)))\n         }\n     });\n     ($e:expr, $t:ident) => ({\n         match $e {\n             Json::$t(v) => Ok(v),\n             other => {\n-                Err(ExpectedError(stringify!($t).to_string(),\n+                Err(ExpectedError(stringify!($t).to_owned(),\n                                   format!(\"{}\", other)))\n             }\n         }\n@@ -2120,14 +2119,14 @@ macro_rules! read_primitive {\n             match self.pop() {\n                 Json::I64(f) => Ok(f as $ty),\n                 Json::U64(f) => Ok(f as $ty),\n-                Json::F64(f) => Err(ExpectedError(\"Integer\".to_string(), format!(\"{}\", f))),\n+                Json::F64(f) => Err(ExpectedError(\"Integer\".to_owned(), format!(\"{}\", f))),\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<usize, V> etc)\n                 // is going to have a string here, as per JSON spec.\n                 Json::String(s) => match s.parse().ok() {\n                     Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_string(), s)),\n+                    None => Err(ExpectedError(\"Number\".to_owned(), s)),\n                 },\n-                value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value))),\n+                value => Err(ExpectedError(\"Number\".to_owned(), format!(\"{}\", value))),\n             }\n         }\n     }\n@@ -2163,11 +2162,11 @@ impl ::Decoder for Decoder {\n                 // is going to have a string here, as per JSON spec.\n                 match s.parse().ok() {\n                     Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_string(), s)),\n+                    None => Err(ExpectedError(\"Number\".to_owned(), s)),\n                 }\n             },\n             Json::Null => Ok(f64::NAN),\n-            value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value)))\n+            value => Err(ExpectedError(\"Number\".to_owned(), format!(\"{}\", value)))\n         }\n     }\n \n@@ -2185,7 +2184,7 @@ impl ::Decoder for Decoder {\n                 _ => ()\n             }\n         }\n-        Err(ExpectedError(\"single character string\".to_string(), format!(\"{}\", s)))\n+        Err(ExpectedError(\"single character string\".to_owned(), format!(\"{}\", s)))\n     }\n \n     fn read_str(&mut self) -> DecodeResult<string::String> {\n@@ -2205,13 +2204,13 @@ impl ::Decoder for Decoder {\n         let name = match self.pop() {\n             Json::String(s) => s,\n             Json::Object(mut o) => {\n-                let n = match o.remove(&\"variant\".to_string()) {\n+                let n = match o.remove(&\"variant\".to_owned()) {\n                     Some(Json::String(s)) => s,\n                     Some(val) => {\n-                        return Err(ExpectedError(\"String\".to_string(), format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"String\".to_owned(), format!(\"{}\", val)))\n                     }\n                     None => {\n-                        return Err(MissingFieldError(\"variant\".to_string()))\n+                        return Err(MissingFieldError(\"variant\".to_owned()))\n                     }\n                 };\n                 match o.remove(&\"fields\".to_string()) {\n@@ -2221,16 +2220,16 @@ impl ::Decoder for Decoder {\n                         }\n                     },\n                     Some(val) => {\n-                        return Err(ExpectedError(\"Array\".to_string(), format!(\"{}\", val)))\n+                        return Err(ExpectedError(\"Array\".to_owned(), format!(\"{}\", val)))\n                     }\n                     None => {\n-                        return Err(MissingFieldError(\"fields\".to_string()))\n+                        return Err(MissingFieldError(\"fields\".to_owned()))\n                     }\n                 }\n                 n\n             }\n             json => {\n-                return Err(ExpectedError(\"String or Object\".to_string(), format!(\"{}\", json)))\n+                return Err(ExpectedError(\"String or Object\".to_owned(), format!(\"{}\", json)))\n             }\n         };\n         let idx = match names.iter().position(|n| *n == &name[..]) {"}, {"sha": "23888bed259736cc2f9c1854417cbdfb593369a8", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -515,7 +515,7 @@ macro_rules! tuple {\n                                                        |d| -> Result<$name,D::Error> {\n                         Decodable::decode(d)\n                     })),)*);\n-                    return Ok(ret);\n+                    Ok(ret)\n                 })\n             }\n         }"}, {"sha": "7801662ff25f924a8df2069ecd7216b772ceb96a", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -231,7 +231,7 @@ mod dl {\n                 Ok(result)\n             } else {\n                 let s = CStr::from_ptr(last_error).to_bytes();\n-                Err(str::from_utf8(s).unwrap().to_string())\n+                Err(str::from_utf8(s).unwrap().to_owned())\n             };\n \n             ret"}, {"sha": "576d9b92156b8c35c2d7f04011b3d8c8e7da5058", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -277,11 +277,11 @@ impl Error {\n \n impl fmt::Debug for Repr {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match self {\n-            &Repr::Os(ref code) =>\n+        match *self {\n+            Repr::Os(ref code) =>\n                 fmt.debug_struct(\"Os\").field(\"code\", code)\n                    .field(\"message\", &sys::os::error_string(*code)).finish(),\n-            &Repr::Custom(ref c) => fmt.debug_tuple(\"Custom\").field(c).finish(),\n+            Repr::Custom(ref c) => fmt.debug_tuple(\"Custom\").field(c).finish(),\n         }\n     }\n }"}, {"sha": "5424fec81104b1a372897809d93e247a23edb15e", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -62,6 +62,6 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n         if registered.is_ok() {\n             self.ptr.set(Box::into_raw(Box::new(ret.clone())));\n         }\n-        return ret\n+        ret\n     }\n }"}, {"sha": "f0b35bbc38811d8251ca46476bd141241e6a1da0", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -262,8 +262,8 @@ impl<'a> Parser<'a> {\n     }\n \n     fn read_ip_addr(&mut self) -> Option<IpAddr> {\n-        let ipv4_addr = |p: &mut Parser| p.read_ipv4_addr().map(|v4| IpAddr::V4(v4));\n-        let ipv6_addr = |p: &mut Parser| p.read_ipv6_addr().map(|v6| IpAddr::V6(v6));\n+        let ipv4_addr = |p: &mut Parser| p.read_ipv4_addr().map(IpAddr::V4);\n+        let ipv6_addr = |p: &mut Parser| p.read_ipv6_addr().map(IpAddr::V6);\n         self.read_or(&mut [Box::new(ipv4_addr), Box::new(ipv6_addr)])\n     }\n "}, {"sha": "7a1215bf382b298bb7aed3c23980701474cb6acc", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -42,7 +42,7 @@ unsafe fn init() -> bool {\n         return false\n     }\n \n-    return true\n+    true\n }\n \n pub fn cleanup() {\n@@ -78,5 +78,5 @@ pub fn push(f: Box<FnBox()>) -> bool {\n         }\n         LOCK.unlock();\n     }\n-    return ret\n+    ret\n }"}, {"sha": "f4799703d996d32528d72351fa949d24e03eee03", "filename": "src/libstd/rt/dwarf/eh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Frt%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Frt%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fdwarf%2Feh.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -104,7 +104,7 @@ pub unsafe fn find_landing_pad(lsda: *const u8, context: &EHContext)\n     // IP range not found: gcc's C++ personality calls terminate() here,\n     // however the rest of the languages treat this the same as cs_lpad == 0.\n     // We follow this suit.\n-    return None;\n+    None\n }\n \n #[inline]"}, {"sha": "95cba132201332dae0cebe76937b9f1da1b43aef", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -73,7 +73,7 @@ fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n         // created. Note that this isn't necessary in general for new threads,\n         // but we just do this to name the main thread and to give it correct\n         // info about the stack bounds.\n-        let thread: Thread = NewThread::new(Some(\"<main>\".to_string()));\n+        let thread: Thread = NewThread::new(Some(\"<main>\".to_owned()));\n         thread_info::set(main_guard, thread);\n \n         // By default, some platforms will send a *signal* when a EPIPE error"}, {"sha": "23a3c3e38c467f3e9bedd06f9ccd99b48723492e", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -27,7 +27,7 @@ pub fn min_stack() -> usize {\n     // 0 is our sentinel value, so ensure that we'll never see 0 after\n     // initialization has run\n     MIN.store(amt + 1, Ordering::SeqCst);\n-    return amt;\n+    amt\n }\n \n // Indicates whether we should perform expensive sanity checks, including rtassert!"}, {"sha": "8c5cec969a6aa27af880a99e6563a1d8d0f58fe6", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -397,7 +397,7 @@ enum Flavor<T> {\n \n #[doc(hidden)]\n trait UnsafeFlavor<T> {\n-    fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>>;\n+    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>>;\n     unsafe fn inner_mut<'a>(&'a self) -> &'a mut Flavor<T> {\n         &mut *self.inner_unsafe().get()\n     }\n@@ -406,12 +406,12 @@ trait UnsafeFlavor<T> {\n     }\n }\n impl<T> UnsafeFlavor<T> for Sender<T> {\n-    fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>> {\n+    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>> {\n         &self.inner\n     }\n }\n impl<T> UnsafeFlavor<T> for Receiver<T> {\n-    fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>> {\n+    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>> {\n         &self.inner\n     }\n }\n@@ -677,7 +677,7 @@ impl<T> SyncSender<T> {\n impl<T> Clone for SyncSender<T> {\n     fn clone(&self) -> SyncSender<T> {\n         unsafe { (*self.inner.get()).clone_chan(); }\n-        return SyncSender::new(self.inner.clone());\n+        SyncSender::new(self.inner.clone())\n     }\n }\n "}, {"sha": "ffd33f8518f682720c9cd3ba45fc755b2cc23aee", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -196,7 +196,7 @@ impl<T> Queue<T> {\n                     let _: Box<Node<T>> = Box::from_raw(tail);\n                 }\n             }\n-            return ret;\n+            ret\n         }\n     }\n \n@@ -207,14 +207,13 @@ impl<T> Queue<T> {\n     /// The reference returned is invalid if it is not used before the consumer\n     /// pops the value off the queue. If the producer then pushes another value\n     /// onto the queue, it will overwrite the value pointed to by the reference.\n-    pub fn peek<'a>(&'a self) -> Option<&'a mut T> {\n+    pub fn peek(&self) -> Option<&mut T> {\n         // This is essentially the same as above with all the popping bits\n         // stripped out.\n         unsafe {\n             let tail = *self.tail.get();\n             let next = (*tail).next.load(Ordering::Acquire);\n-            if next.is_null() { return None }\n-            return (*next).value.as_mut();\n+            if next.is_null() { None } else { (*next).value.as_mut() }\n         }\n     }\n }"}, {"sha": "e8012ca470b02190c03a9b96766e1591cf5424c4", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -307,12 +307,7 @@ impl<T> Packet<T> {\n                             steals, DISCONNECTED, Ordering::SeqCst);\n             cnt != DISCONNECTED && cnt != steals\n         } {\n-            loop {\n-                match self.queue.pop() {\n-                    Some(..) => { steals += 1; }\n-                    None => break\n-                }\n-            }\n+            while let Some(_) = self.queue.pop() { steals += 1; }\n         }\n \n         // At this point in time, we have gated all future senders from sending,\n@@ -378,7 +373,7 @@ impl<T> Packet<T> {\n                 // previous value is positive because we're not going to sleep\n                 let prev = self.bump(1);\n                 assert!(prev == DISCONNECTED || prev >= 0);\n-                return ret;\n+                ret\n             }\n         }\n     }"}, {"sha": "b98fc2859afcc43a09e189ac3ca3b9af53271507", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -254,7 +254,7 @@ impl<T> Packet<T> {\n         assert!(guard.buf.size() > 0);\n         let ret = guard.buf.dequeue();\n         self.wakeup_senders(waited, guard);\n-        return Ok(ret);\n+        Ok(ret)\n     }\n \n     pub fn try_recv(&self) -> Result<T, Failure> {\n@@ -267,8 +267,7 @@ impl<T> Packet<T> {\n         // Be sure to wake up neighbors\n         let ret = Ok(guard.buf.dequeue());\n         self.wakeup_senders(false, guard);\n-\n-        return ret;\n+        ret\n     }\n \n     // Wake up pending senders after some data has been received\n@@ -356,12 +355,7 @@ impl<T> Packet<T> {\n         };\n         mem::drop(guard);\n \n-        loop {\n-            match queue.dequeue() {\n-                Some(token) => { token.signal(); }\n-                None => break,\n-            }\n-        }\n+        while let Some(token) = queue.dequeue() { token.signal(); }\n         waiter.map(|t| t.signal());\n     }\n "}, {"sha": "846a97b547dc6d09e8909a7330c898516c26e2cc", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -334,13 +334,14 @@ impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n impl<'mutex, T: ?Sized> Deref for MutexGuard<'mutex, T> {\n     type Target = T;\n \n-    fn deref<'a>(&'a self) -> &'a T {\n+    fn deref(&self) -> &T {\n         unsafe { &*self.__data.get() }\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'mutex, T: ?Sized> DerefMut for MutexGuard<'mutex, T> {\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+    fn deref_mut(&mut self) -> &mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }"}, {"sha": "3b846fd462ed35ad58e524f53746721b724fdaa5", "filename": "src/libstd/sys/common/gnu/libbacktrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Flibbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Flibbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Flibbacktrace.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -151,7 +151,7 @@ pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n         };\n         STATE = backtrace_create_state(filename, 0, error_cb,\n                                        ptr::null_mut());\n-        return STATE\n+        STATE\n     }\n \n     ////////////////////////////////////////////////////////////////////////"}, {"sha": "37379596251de34bd832b1ad2b5d91917a4d5158", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -161,7 +161,7 @@ pub fn lookup_addr(addr: &IpAddr) -> io::Result<String> {\n     };\n \n     match from_utf8(data.to_bytes()) {\n-        Ok(name) => Ok(name.to_string()),\n+        Ok(name) => Ok(name.to_owned()),\n         Err(_) => Err(io::Error::new(io::ErrorKind::Other,\n                                      \"failed to lookup address information\"))\n     }"}, {"sha": "f3f21e47a14066d76c37c1f0342b8a601f10faf7", "filename": "src/libstd/sys/common/remutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -67,7 +67,7 @@ impl<T> ReentrantMutex<T> {\n                 data: t,\n             };\n             mutex.inner.init();\n-            return mutex\n+            mutex\n         }\n     }\n \n@@ -145,7 +145,7 @@ impl<'mutex, T> ReentrantMutexGuard<'mutex, T> {\n impl<'mutex, T> Deref for ReentrantMutexGuard<'mutex, T> {\n     type Target = T;\n \n-    fn deref<'a>(&'a self) -> &'a T {\n+    fn deref(&self) -> &T {\n         &self.__lock.data\n     }\n }"}, {"sha": "633e7d78a9aebfbd9d62a8b7ee6de8d3cb377ea1", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -282,19 +282,13 @@ impl Wtf8Buf {\n     /// like concatenating ill-formed UTF-16 strings effectively would.\n     #[inline]\n     pub fn push(&mut self, code_point: CodePoint) {\n-        match code_point.to_u32() {\n-            trail @ 0xDC00...0xDFFF => {\n-                match (&*self).final_lead_surrogate() {\n-                    Some(lead) => {\n-                        let len_without_lead_surrogate = self.len() - 3;\n-                        self.bytes.truncate(len_without_lead_surrogate);\n-                        self.push_char(decode_surrogate_pair(lead, trail as u16));\n-                        return\n-                    }\n-                    _ => {}\n-                }\n+        if let trail @ 0xDC00...0xDFFF = code_point.to_u32() {\n+            if let Some(lead) = (&*self).final_lead_surrogate() {\n+                let len_without_lead_surrogate = self.len() - 3;\n+                self.bytes.truncate(len_without_lead_surrogate);\n+                self.push_char(decode_surrogate_pair(lead, trail as u16));\n+                return\n             }\n-            _ => {}\n         }\n \n         // No newly paired surrogates at the boundary."}, {"sha": "8b32b5ec040024ad15b3c1b203d6d2a2a8722810", "filename": "src/libstd/sys/unix/backtrace/tracing/gcc_s.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -99,7 +99,7 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n         }\n \n         // keep going\n-        return uw::_URC_NO_REASON\n+        uw::_URC_NO_REASON\n     }\n }\n "}, {"sha": "6d65cb838f67ae4a35df007a1980a0b07cb2f36e", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -35,7 +35,7 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n \n     let detail = unsafe {\n         str::from_utf8(CStr::from_ptr(c::gai_strerror(err)).to_bytes()).unwrap()\n-            .to_string()\n+            .to_owned()\n     };\n     Err(io::Error::new(io::ErrorKind::Other,\n                        &format!(\"failed to lookup address information: {}\","}, {"sha": "af0d8da05f49ab364d1d5364abc6c96299eef720", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -88,7 +88,7 @@ pub fn error_string(errno: i32) -> String {\n         }\n \n         let p = p as *const _;\n-        str::from_utf8(CStr::from_ptr(p).to_bytes()).unwrap().to_string()\n+        str::from_utf8(CStr::from_ptr(p).to_bytes()).unwrap().to_owned()\n     }\n }\n \n@@ -134,15 +134,15 @@ pub struct SplitPaths<'a> {\n                     fn(&'a [u8]) -> PathBuf>,\n }\n \n-pub fn split_paths<'a>(unparsed: &'a OsStr) -> SplitPaths<'a> {\n+pub fn split_paths(unparsed: &OsStr) -> SplitPaths {\n     fn bytes_to_path(b: &[u8]) -> PathBuf {\n         PathBuf::from(<OsStr as OsStrExt>::from_bytes(b))\n     }\n     fn is_colon(b: &u8) -> bool { *b == b':' }\n     let unparsed = unparsed.as_bytes();\n     SplitPaths {\n         iter: unparsed.split(is_colon as fn(&u8) -> bool)\n-                      .map(bytes_to_path as fn(&'a [u8]) -> PathBuf)\n+                      .map(bytes_to_path as fn(&[u8]) -> PathBuf)\n     }\n }\n "}, {"sha": "ccbb14677c7e404143cf7bc31d6f6870133ec9cc", "filename": "src/libstd/sys/unix/stdio.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -23,7 +23,7 @@ impl Stdin {\n         let fd = FileDesc::new(libc::STDIN_FILENO);\n         let ret = fd.read(data);\n         fd.into_raw();\n-        return ret;\n+        ret\n     }\n }\n \n@@ -34,7 +34,7 @@ impl Stdout {\n         let fd = FileDesc::new(libc::STDOUT_FILENO);\n         let ret = fd.write(data);\n         fd.into_raw();\n-        return ret;\n+        ret\n     }\n }\n \n@@ -45,7 +45,7 @@ impl Stderr {\n         let fd = FileDesc::new(libc::STDERR_FILENO);\n         let ret = fd.write(data);\n         fd.into_raw();\n-        return ret;\n+        ret\n     }\n }\n "}, {"sha": "268ec7fe3568718f2470c0da1d3df1de8383280a", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -310,7 +310,7 @@ pub mod guard {\n             ret = Some(stackaddr as usize + guardsize as usize);\n         }\n         assert_eq!(pthread_attr_destroy(&mut attr), 0);\n-        return ret\n+        ret\n     }\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]"}, {"sha": "e697417675d7707f0179f22cedb78af6bd936916", "filename": "src/libstd/sys/unix/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -18,7 +18,7 @@ pub type Key = pthread_key_t;\n pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n     let mut key = 0;\n     assert_eq!(pthread_key_create(&mut key, dtor), 0);\n-    return key;\n+    key\n }\n \n #[inline]"}, {"sha": "ffe896b93a7181950a55a0d5f13ae7cce8b3936e", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -151,7 +151,7 @@ impl<T: Write+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n                 cap = self.ti.strings.get(\"op\");\n             }\n         }\n-        let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_string()), |op| {\n+        let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_owned()), |op| {\n             expand(op, &[], &mut Variables::new())\n         });\n         if s.is_ok() {\n@@ -211,9 +211,9 @@ impl<T: Write+Send+'static> TerminfoTerminal<T> {\n                      inf.numbers.get(\"colors\").map_or(0, |&n| n)\n                  } else { 0 };\n \n-        return Some(box TerminfoTerminal {out: out,\n-                                          ti: inf,\n-                                          num_colors: nc});\n+        Some(box TerminfoTerminal {out: out,\n+                                   ti: inf,\n+                                   num_colors: nc})\n     }\n \n     fn dim_if_necessary(&self, color: color::Color) -> color::Color {"}, {"sha": "9110be33907b0fee0b6f25f5d686173824d2ae6d", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -133,9 +133,9 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                                     c as u8\n                                 })\n                             }\n-                            _       => return Err(\"a non-char was used with %c\".to_string())\n+                            _       => return Err(\"a non-char was used with %c\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     'p' => state = PushParam,\n                     'P' => state = SetVar,\n                     'g' => state = GetVar,\n@@ -144,112 +144,112 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     'l' => if !stack.is_empty() {\n                         match stack.pop().unwrap() {\n                             Words(s) => stack.push(Number(s.len() as isize)),\n-                            _        => return Err(\"a non-str was used with %l\".to_string())\n+                            _        => return Err(\"a non-str was used with %l\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '+' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x + y)),\n-                            _ => return Err(\"non-numbers on stack with +\".to_string())\n+                            _ => return Err(\"non-numbers on stack with +\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '-' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x - y)),\n-                            _ => return Err(\"non-numbers on stack with -\".to_string())\n+                            _ => return Err(\"non-numbers on stack with -\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '*' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x * y)),\n-                            _ => return Err(\"non-numbers on stack with *\".to_string())\n+                            _ => return Err(\"non-numbers on stack with *\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '/' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x / y)),\n-                            _ => return Err(\"non-numbers on stack with /\".to_string())\n+                            _ => return Err(\"non-numbers on stack with /\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     'm' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x % y)),\n-                            _ => return Err(\"non-numbers on stack with %\".to_string())\n+                            _ => return Err(\"non-numbers on stack with %\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '&' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x & y)),\n-                            _ => return Err(\"non-numbers on stack with &\".to_string())\n+                            _ => return Err(\"non-numbers on stack with &\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '|' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x | y)),\n-                            _ => return Err(\"non-numbers on stack with |\".to_string())\n+                            _ => return Err(\"non-numbers on stack with |\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '^' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x ^ y)),\n-                            _ => return Err(\"non-numbers on stack with ^\".to_string())\n+                            _ => return Err(\"non-numbers on stack with ^\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '=' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x == y { 1 }\n                                                                         else { 0 })),\n-                            _ => return Err(\"non-numbers on stack with =\".to_string())\n+                            _ => return Err(\"non-numbers on stack with =\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '>' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x > y { 1 }\n                                                                         else { 0 })),\n-                            _ => return Err(\"non-numbers on stack with >\".to_string())\n+                            _ => return Err(\"non-numbers on stack with >\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '<' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x < y { 1 }\n                                                                         else { 0 })),\n-                            _ => return Err(\"non-numbers on stack with <\".to_string())\n+                            _ => return Err(\"non-numbers on stack with <\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     'A' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(0), Number(_)) => stack.push(Number(0)),\n                             (Number(_), Number(0)) => stack.push(Number(0)),\n                             (Number(_), Number(_)) => stack.push(Number(1)),\n-                            _ => return Err(\"non-numbers on stack with logical and\".to_string())\n+                            _ => return Err(\"non-numbers on stack with logical and\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     'O' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(0), Number(0)) => stack.push(Number(0)),\n                             (Number(_), Number(_)) => stack.push(Number(1)),\n-                            _ => return Err(\"non-numbers on stack with logical or\".to_string())\n+                            _ => return Err(\"non-numbers on stack with logical or\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '!' => if !stack.is_empty() {\n                         match stack.pop().unwrap() {\n                             Number(0) => stack.push(Number(1)),\n                             Number(_) => stack.push(Number(0)),\n-                            _ => return Err(\"non-number on stack with logical not\".to_string())\n+                            _ => return Err(\"non-number on stack with logical not\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     '~' => if !stack.is_empty() {\n                         match stack.pop().unwrap() {\n                             Number(x) => stack.push(Number(!x)),\n-                            _         => return Err(\"non-number on stack with %~\".to_string())\n+                            _         => return Err(\"non-number on stack with %~\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     'i' => match (mparams[0].clone(), mparams[1].clone()) {\n                         (Number(x), Number(y)) => {\n                             mparams[0] = Number(x+1);\n                             mparams[1] = Number(y+1);\n                         },\n-                        (_, _) => return Err(\"first two params not numbers with %i\".to_string())\n+                        (_, _) => return Err(\"first two params not numbers with %i\".to_owned())\n                     },\n \n                     // printf-style support for %doxXs\n@@ -258,7 +258,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), flags);\n                         if res.is_err() { return res }\n                         output.push_all(&res.unwrap())\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     ':'|'#'|' '|'.'|'0'...'9' => {\n                         let mut flags = Flags::new();\n                         let mut fstate = FormatStateFlags;\n@@ -283,9 +283,9 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                             Number(0) => state = SeekIfElse(0),\n                             Number(_) => (),\n                             _         => return Err(\"non-number on stack \\\n-                                                    with conditional\".to_string())\n+                                                    with conditional\".to_owned())\n                         }\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     'e' => state = SeekIfEnd(0),\n                     ';' => (),\n \n@@ -298,22 +298,22 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                 // params are 1-indexed\n                 stack.push(mparams[match cur.to_digit(10) {\n                     Some(d) => d as usize - 1,\n-                    None => return Err(\"bad param number\".to_string())\n+                    None => return Err(\"bad param number\".to_owned())\n                 }].clone());\n             },\n             SetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n                     if !stack.is_empty() {\n                         let idx = (cur as u8) - b'A';\n                         vars.sta[idx as usize] = stack.pop().unwrap();\n-                    } else { return Err(\"stack is empty\".to_string()) }\n+                    } else { return Err(\"stack is empty\".to_owned()) }\n                 } else if cur >= 'a' && cur <= 'z' {\n                     if !stack.is_empty() {\n                         let idx = (cur as u8) - b'a';\n                         vars.dyn[idx as usize] = stack.pop().unwrap();\n-                    } else { return Err(\"stack is empty\".to_string()) }\n+                    } else { return Err(\"stack is empty\".to_owned()) }\n                 } else {\n-                    return Err(\"bad variable name in %P\".to_string());\n+                    return Err(\"bad variable name in %P\".to_owned());\n                 }\n             },\n             GetVar => {\n@@ -324,7 +324,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     let idx = (cur as u8) - b'a';\n                     stack.push(vars.dyn[idx as usize].clone());\n                 } else {\n-                    return Err(\"bad variable name in %g\".to_string());\n+                    return Err(\"bad variable name in %g\".to_owned());\n                 }\n             },\n             CharConstant => {\n@@ -333,7 +333,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             },\n             CharClose => {\n                 if cur != '\\'' {\n-                    return Err(\"malformed character constant\".to_string());\n+                    return Err(\"malformed character constant\".to_owned());\n                 }\n             },\n             IntConstant(i) => {\n@@ -346,7 +346,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         state = IntConstant(i*10 + (cur as isize - '0' as isize));\n                         old_state = Nothing;\n                     }\n-                    _ => return Err(\"bad isize constant\".to_string())\n+                    _ => return Err(\"bad isize constant\".to_owned())\n                 }\n             }\n             FormatPattern(ref mut flags, ref mut fstate) => {\n@@ -358,7 +358,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         output.push_all(&res.unwrap());\n                         // will cause state to go to Nothing\n                         old_state = FormatPattern(*flags, *fstate);\n-                    } else { return Err(\"stack is empty\".to_string()) },\n+                    } else { return Err(\"stack is empty\".to_owned()) },\n                     (FormatStateFlags,'#') => {\n                         flags.alternate = true;\n                     }\n@@ -381,7 +381,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     (FormatStateWidth,'0'...'9') => {\n                         let old = flags.width;\n                         flags.width = flags.width * 10 + (cur as usize - '0' as usize);\n-                        if flags.width < old { return Err(\"format width overflow\".to_string()) }\n+                        if flags.width < old { return Err(\"format width overflow\".to_owned()) }\n                     }\n                     (FormatStateWidth,'.') => {\n                         *fstate = FormatStatePrecision;\n@@ -390,10 +390,10 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         let old = flags.precision;\n                         flags.precision = flags.precision * 10 + (cur as usize - '0' as usize);\n                         if flags.precision < old {\n-                            return Err(\"format precision overflow\".to_string())\n+                            return Err(\"format precision overflow\".to_owned())\n                         }\n                     }\n-                    _ => return Err(\"invalid format specifier\".to_string())\n+                    _ => return Err(\"invalid format specifier\".to_owned())\n                 }\n             }\n             SeekIfElse(level) => {\n@@ -502,7 +502,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                 (FormatHex, _)       => format!(\"{:x}\", d).into_bytes(),\n                 (FormatHEX, _)       => format!(\"{:X}\", d).into_bytes(),\n                 (FormatString, _)    => {\n-                    return Err(\"non-number on stack with %s\".to_string())\n+                    return Err(\"non-number on stack with %s\".to_owned())\n                 }\n             };\n             let mut s: Vec<u8> = s.into_iter().collect();\n@@ -692,7 +692,7 @@ mod tests {\n                             Words(\"f\".to_string()),\n                             Words(\"foo\".to_string())], vars),\n                    Ok(\"foofoo ffo\".bytes().collect::<Vec<_>>()));\n-        assert_eq!(expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_string())], vars),\n+        assert_eq!(expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_owned())], vars),\n                    Ok(\"fo  \".bytes().collect::<Vec<_>>()));\n \n         assert_eq!(expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", &[Number(1)], vars),"}, {"sha": "d29042ae5e7624f30cc73207eb610b8438dc2476", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -205,28 +205,28 @@ pub fn parse(file: &mut Read, longnames: bool)\n \n     if (bools_bytes as usize) > boolnames.len() {\n         return Err(\"incompatible file: more booleans than \\\n-                    expected\".to_string());\n+                    expected\".to_owned());\n     }\n \n     if (numbers_count as usize) > numnames.len() {\n         return Err(\"incompatible file: more numbers than \\\n-                    expected\".to_string());\n+                    expected\".to_owned());\n     }\n \n     if (string_offsets_count as usize) > stringnames.len() {\n         return Err(\"incompatible file: more string offsets than \\\n-                    expected\".to_string());\n+                    expected\".to_owned());\n     }\n \n     // don't read NUL\n     let bytes = try!(read_exact(file, names_bytes as usize - 1));\n     let names_str = match String::from_utf8(bytes) {\n         Ok(s)  => s,\n-        Err(_) => return Err(\"input not utf-8\".to_string()),\n+        Err(_) => return Err(\"input not utf-8\".to_owned()),\n     };\n \n     let term_names: Vec<String> = names_str.split('|')\n-                                           .map(|s| s.to_string())\n+                                           .map(str::to_owned)\n                                            .collect();\n \n     try!(read_byte(file)); // consume NUL\n@@ -236,7 +236,7 @@ pub fn parse(file: &mut Read, longnames: bool)\n         for i in 0..bools_bytes {\n             let b = try!(read_byte(file));\n             if b == 1 {\n-                bools_map.insert(bnames[i as usize].to_string(), true);\n+                bools_map.insert(bnames[i as usize].to_owned(), true);\n             }\n         }\n     }\n@@ -250,7 +250,7 @@ pub fn parse(file: &mut Read, longnames: bool)\n         for i in 0..numbers_count {\n             let n = try!(read_le_u16(file));\n             if n != 0xFFFF {\n-                numbers_map.insert(nnames[i as usize].to_string(), n);\n+                numbers_map.insert(nnames[i as usize].to_owned(), n);\n             }\n         }\n     }\n@@ -267,7 +267,7 @@ pub fn parse(file: &mut Read, longnames: bool)\n \n         if string_table.len() != string_table_bytes as usize {\n             return Err(\"error: hit EOF before end of string \\\n-                        table\".to_string());\n+                        table\".to_owned());\n         }\n \n         for (i, v) in string_offsets.iter().enumerate() {\n@@ -285,7 +285,7 @@ pub fn parse(file: &mut Read, longnames: bool)\n             if offset == 0xFFFE {\n                 // undocumented: FFFE indicates cap@, which means the capability is not present\n                 // unsure if the handling for this is correct\n-                string_map.insert(name.to_string(), Vec::new());\n+                string_map.insert(name.to_owned(), Vec::new());\n                 continue;\n             }\n \n@@ -301,7 +301,7 @@ pub fn parse(file: &mut Read, longnames: bool)\n                 },\n                 None => {\n                     return Err(\"invalid file: missing NUL in \\\n-                                string_table\".to_string());\n+                                string_table\".to_owned());\n                 }\n             };\n         }\n@@ -338,12 +338,12 @@ fn read_exact<R: Read + ?Sized>(r: &mut R, sz: usize) -> io::Result<Vec<u8>> {\n /// Create a dummy TermInfo struct for msys terminals\n pub fn msys_terminfo() -> Box<TermInfo> {\n     let mut strings = HashMap::new();\n-    strings.insert(\"sgr0\".to_string(), b\"\\x1B[0m\".to_vec());\n-    strings.insert(\"bold\".to_string(), b\"\\x1B[1m\".to_vec());\n-    strings.insert(\"setaf\".to_string(), b\"\\x1B[3%p1%dm\".to_vec());\n-    strings.insert(\"setab\".to_string(), b\"\\x1B[4%p1%dm\".to_vec());\n+    strings.insert(\"sgr0\".to_owned(), b\"\\x1B[0m\".to_vec());\n+    strings.insert(\"bold\".to_owned(), b\"\\x1B[1m\".to_vec());\n+    strings.insert(\"setaf\".to_owned(), b\"\\x1B[3%p1%dm\".to_vec());\n+    strings.insert(\"setab\".to_owned(), b\"\\x1B[4%p1%dm\".to_vec());\n     box TermInfo {\n-        names: vec!(\"cygwin\".to_string()), // msys is a fork of an older cygwin version\n+        names: vec!(\"cygwin\".to_owned()), // msys is a fork of an older cygwin version\n         bools: HashMap::new(),\n         numbers: HashMap::new(),\n         strings: strings"}, {"sha": "ad00bb667330861aef91c614e43fbcb84b095fef", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -103,7 +103,7 @@ pub enum TestName {\n     DynTestName(String)\n }\n impl TestName {\n-    fn as_slice<'a>(&'a self) -> &'a str {\n+    fn as_slice(&self) -> &str {\n         match *self {\n             StaticTestName(s) => s,\n             DynTestName(ref s) => s\n@@ -157,13 +157,13 @@ pub enum TestFn {\n \n impl TestFn {\n     fn padding(&self) -> NamePadding {\n-        match self {\n-            &StaticTestFn(..)   => PadNone,\n-            &StaticBenchFn(..)  => PadOnRight,\n-            &StaticMetricFn(..) => PadOnRight,\n-            &DynTestFn(..)      => PadNone,\n-            &DynMetricFn(..)    => PadOnRight,\n-            &DynBenchFn(..)     => PadOnRight,\n+        match *self {\n+            StaticTestFn(..)   => PadNone,\n+            StaticBenchFn(..)  => PadOnRight,\n+            StaticMetricFn(..) => PadOnRight,\n+            DynTestFn(..)      => PadNone,\n+            DynMetricFn(..)    => PadOnRight,\n+            DynBenchFn(..)     => PadOnRight,\n         }\n     }\n }\n@@ -564,9 +564,9 @@ impl<T: Write> ConsoleTestState<T> {\n             None => Ok(()),\n             Some(ref mut o) => {\n                 let s = format!(\"{} {}\\n\", match *result {\n-                        TrOk => \"ok\".to_string(),\n-                        TrFailed => \"failed\".to_string(),\n-                        TrIgnored => \"ignored\".to_string(),\n+                        TrOk => \"ok\".to_owned(),\n+                        TrFailed => \"failed\".to_owned(),\n+                        TrIgnored => \"ignored\".to_owned(),\n                         TrMetrics(ref mm) => mm.fmt_metrics(),\n                         TrBench(ref bs) => fmt_bench_samples(bs)\n                     }, test.name);\n@@ -925,7 +925,7 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n                 None\n             }\n         };\n-        filtered.into_iter().filter_map(|x| filter(x)).collect()\n+        filtered.into_iter().filter_map(filter).collect()\n     };\n \n     // Sort the tests alphabetically\n@@ -978,8 +978,8 @@ pub fn run_test(opts: &TestOpts,\n             let data = Arc::new(Mutex::new(Vec::new()));\n             let data2 = data.clone();\n             let cfg = thread::Builder::new().name(match desc.name {\n-                DynTestName(ref name) => name.clone().to_string(),\n-                StaticTestName(name) => name.to_string(),\n+                DynTestName(ref name) => name.clone(),\n+                StaticTestName(name) => name.to_owned(),\n             });\n \n             let result_guard = cfg.spawn(move || {\n@@ -1020,7 +1020,7 @@ pub fn run_test(opts: &TestOpts,\n         }\n         DynTestFn(f) => run_test_inner(desc, monitor_ch, opts.nocapture, f),\n         StaticTestFn(f) => run_test_inner(desc, monitor_ch, opts.nocapture,\n-                                          Box::new(move|| f()))\n+                                          Box::new(f))\n     }\n }\n \n@@ -1063,7 +1063,7 @@ impl MetricMap {\n             noise: noise\n         };\n         let MetricMap(ref mut map) = *self;\n-        map.insert(name.to_string(), m);\n+        map.insert(name.to_owned(), m);\n     }\n \n     pub fn fmt_metrics(&self) -> String {"}, {"sha": "332d06bf46563dc8b1b3a3ee67671d6c408f6406", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cca96545faf2cfc972cc67b83deae2a78935c43/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=9cca96545faf2cfc972cc67b83deae2a78935c43", "patch": "@@ -168,7 +168,7 @@ impl Stats for [f64] {\n             let mut j = 0;\n             // This inner loop applies `hi`/`lo` summation to each\n             // partial so that the list of partial sums remains exact.\n-            for i in 0..partials.len() {\n+            for mut y in &mut partials {\n                 let mut y: f64 = partials[i];\n                 if x.abs() < y.abs() {\n                     mem::swap(&mut x, &mut y);"}]}