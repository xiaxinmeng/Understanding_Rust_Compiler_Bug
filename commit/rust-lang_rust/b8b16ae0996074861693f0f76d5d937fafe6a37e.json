{"sha": "b8b16ae0996074861693f0f76d5d937fafe6a37e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YjE2YWUwOTk2MDc0ODYxNjkzZjBmNzZkNWQ5MzdmYWZlNmEzN2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-11T03:16:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-11T03:16:19Z"}, "message": "auto merge of #10791 : pcwalton/rust/decelling, r=pcwalton\n\n34 uses of `Cell` remain.\r\n\r\nr? @alexcrichton", "tree": {"sha": "03f3fadcb4558ec1ddda3d61669636c1fcad1264", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03f3fadcb4558ec1ddda3d61669636c1fcad1264"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8b16ae0996074861693f0f76d5d937fafe6a37e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8b16ae0996074861693f0f76d5d937fafe6a37e", "html_url": "https://github.com/rust-lang/rust/commit/b8b16ae0996074861693f0f76d5d937fafe6a37e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8b16ae0996074861693f0f76d5d937fafe6a37e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac4dd9efee9248f4c3235460f3c93acc9932eb5a", "html_url": "https://github.com/rust-lang/rust/commit/ac4dd9efee9248f4c3235460f3c93acc9932eb5a"}, {"sha": "fd7a513bef7fe3c6f5128cc53135facca37f23e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd7a513bef7fe3c6f5128cc53135facca37f23e5", "html_url": "https://github.com/rust-lang/rust/commit/fd7a513bef7fe3c6f5128cc53135facca37f23e5"}], "stats": {"total": 1843, "additions": 876, "deletions": 967}, "files": [{"sha": "0fb75b7c8e0c0ccc2f8b49baa001bf3954c4cf1f", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -325,19 +325,17 @@ pub fn make_test_name(config: &config, testfile: &Path) -> test::TestName {\n }\n \n pub fn make_test_closure(config: &config, testfile: &Path) -> test::TestFn {\n-    use std::cell::Cell;\n-    let config = Cell::new((*config).clone());\n+    let config = (*config).clone();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let testfile = Cell::new(testfile.as_str().unwrap().to_owned());\n-    test::DynTestFn(proc() { runtest::run(config.take(), testfile.take()) })\n+    let testfile = testfile.as_str().unwrap().to_owned();\n+    test::DynTestFn(proc() { runtest::run(config, testfile) })\n }\n \n pub fn make_metrics_test_closure(config: &config, testfile: &Path) -> test::TestFn {\n-    use std::cell::Cell;\n-    let config = Cell::new((*config).clone());\n+    let config = (*config).clone();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let testfile = Cell::new(testfile.as_str().unwrap().to_owned());\n+    let testfile = testfile.as_str().unwrap().to_owned();\n     test::DynMetricFn(proc(mm) {\n-        runtest::run_metrics(config.take(), testfile.take(), mm)\n+        runtest::run_metrics(config, testfile, mm)\n     })\n }"}, {"sha": "005328c6934700de3744b9779c51da667f752913", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -597,7 +597,6 @@ mod tests {\n \n     use arc::*;\n \n-    use std::cell::Cell;\n     use std::comm;\n     use std::task;\n \n@@ -628,18 +627,18 @@ mod tests {\n         let arc = ~MutexArc::new(false);\n         let arc2 = ~arc.clone();\n         let (p,c) = comm::oneshot();\n-        let (c,p) = (Cell::new(c), Cell::new(p));\n-        do task::spawn || {\n+        do task::spawn {\n             // wait until parent gets in\n-            p.take().recv();\n+            p.recv();\n             arc2.access_cond(|state, cond| {\n                 *state = true;\n                 cond.signal();\n             })\n         }\n \n+        let mut c = Some(c);\n         arc.access_cond(|state, cond| {\n-            c.take().send(());\n+            c.take_unwrap().send(());\n             assert!(!*state);\n             while !*state {\n                 cond.wait();"}, {"sha": "1a2ac39813270db92ff252e213a470e9f55660c1", "filename": "src/libextra/future.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -25,7 +25,6 @@\n \n #[allow(missing_doc)];\n \n-use std::cell::Cell;\n use std::comm::{PortOne, oneshot};\n use std::util::replace;\n \n@@ -113,9 +112,8 @@ impl<A:Send> Future<A> {\n          * waiting for the result to be received on the port.\n          */\n \n-        let port = Cell::new(port);\n         do Future::from_fn {\n-            port.take().recv()\n+            port.recv()\n         }\n     }\n \n@@ -141,7 +139,6 @@ impl<A:Send> Future<A> {\n mod test {\n     use future::Future;\n \n-    use std::cell::Cell;\n     use std::comm::oneshot;\n     use std::task;\n \n@@ -199,9 +196,9 @@ mod test {\n     #[test]\n     fn test_sendable_future() {\n         let expected = \"schlorf\";\n-        let f = Cell::new(do Future::spawn { expected });\n+        let f = do Future::spawn { expected };\n         do task::spawn {\n-            let mut f = f.take();\n+            let mut f = f;\n             let actual = f.get();\n             assert_eq!(actual, expected);\n         }"}, {"sha": "88207bfbae45304ca4b1342257a7214426522691", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -676,7 +676,6 @@ mod tests {\n     use sync::*;\n \n     use std::cast;\n-    use std::cell::Cell;\n     use std::comm;\n     use std::result;\n     use std::task;\n@@ -762,9 +761,9 @@ mod tests {\n             let s = Semaphore::new(1);\n             let s2 = s.clone();\n             let (p, c) = comm::stream();\n-            let child_data = Cell::new((s2, c));\n+            let mut child_data = Some((s2, c));\n             s.access(|| {\n-                let (s2, c) = child_data.take();\n+                let (s2, c) = child_data.take_unwrap();\n                 do task::spawn {\n                     c.send(());\n                     s2.access(|| { });\n@@ -947,13 +946,13 @@ mod tests {\n             let mut sibling_convos = ~[];\n             2.times(|| {\n                 let (p, c) = comm::stream();\n-                let c = Cell::new(c);\n                 sibling_convos.push(p);\n                 let mi = m2.clone();\n                 // spawn sibling task\n                 do task::spawn { // linked\n+                    let mut c = Some(c);\n                     mi.lock_cond(|cond| {\n-                        let c = c.take();\n+                        let c = c.take_unwrap();\n                         c.send(()); // tell sibling to go ahead\n                         (|| {\n                             cond.wait(); // block forever"}, {"sha": "1bda69360c22edd8cb368dfe0ae078481827beb0", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -872,15 +872,14 @@ pub fn run_test(force_ignore: bool,\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: SharedChan<MonitorMsg>,\n                       testfn: proc()) {\n-        let testfn_cell = ::std::cell::Cell::new(testfn);\n         do task::spawn {\n             let mut task = task::task();\n             task.name(match desc.name {\n                 DynTestName(ref name) => SendStrOwned(name.clone()),\n                 StaticTestName(name) => SendStrStatic(name),\n             });\n             let result_future = task.future_result();\n-            task.spawn(testfn_cell.take());\n+            task.spawn(testfn);\n \n             let task_result = result_future.recv();\n             let test_result = calc_result(&desc, task_result.is_ok());"}, {"sha": "1487cee75cc870fb6da392080840ae84aa15f707", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -15,7 +15,6 @@ use json::ToJson;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n use arc::{Arc,RWArc};\n use treemap::TreeMap;\n-use std::cell::Cell;\n use std::comm::{PortOne, oneshot};\n use std::{str, task};\n use std::io;\n@@ -430,15 +429,13 @@ impl<'self> Prep<'self> {\n                 debug!(\"Cache miss!\");\n                 let (port, chan) = oneshot();\n                 let blk = bo.take_unwrap();\n-                let chan = Cell::new(chan);\n \n                 // XXX: What happens if the task fails?\n                 do task::spawn {\n                     let mut exe = Exec {\n                         discovered_inputs: WorkMap::new(),\n                         discovered_outputs: WorkMap::new(),\n                     };\n-                    let chan = chan.take();\n                     let v = blk(&mut exe);\n                     chan.send((exe, v));\n                 }"}, {"sha": "39f68ae59e844692c48b8452fe6f22571749a0e2", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -33,7 +33,6 @@\n //! These tasks are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n-use std::cell::Cell;\n use std::comm::{SharedPort, SharedChan};\n use std::comm;\n use std::fmt;\n@@ -46,7 +45,6 @@ use std::io::File;\n use std::os;\n use std::str;\n use std::task;\n-use std::unstable::finally::Finally;\n use std::vec;\n \n use extra::arc::RWArc;\n@@ -642,6 +640,22 @@ impl<'self> Cache {\n     }\n }\n \n+enum Progress {\n+    JobNew,\n+    JobDone,\n+}\n+\n+/// A helper object to unconditionally send a value on a chanel.\n+struct ChannelGuard {\n+    channel: SharedChan<Progress>,\n+}\n+\n+impl Drop for ChannelGuard {\n+    fn drop(&mut self) {\n+        self.channel.send(JobDone)\n+    }\n+}\n+\n impl Context {\n     /// Recurse in the directory structure and change the \"root path\" to make\n     /// sure it always points to the top (relatively)\n@@ -674,8 +688,6 @@ impl Context {\n             Die,\n             Process(Context, clean::Item),\n         }\n-        enum Progress { JobNew, JobDone }\n-\n         let workers = match os::getenv(\"RUSTDOC_WORKERS\") {\n             Some(s) => {\n                 match from_str::<uint>(s) {\n@@ -725,16 +737,15 @@ impl Context {\n                     match port.recv() {\n                         Process(cx, item) => {\n                             let mut cx = cx;\n-                            let item = Cell::new(item);\n-                            (|| {\n-                                cx.item(item.take(), |cx, item| {\n-                                    prog_chan.send(JobNew);\n-                                    chan.send(Process(cx.clone(), item));\n-                                })\n-                            }).finally(|| {\n-                                // If we fail, everything else should still get\n-                                // completed\n-                                prog_chan.send(JobDone);\n+\n+                            // If we fail, everything else should still get\n+                            // completed.\n+                            let _guard = ChannelGuard {\n+                                channel: prog_chan.clone(),\n+                            };\n+                            cx.item(item, |cx, item| {\n+                                prog_chan.send(JobNew);\n+                                chan.send(Process(cx.clone(), item));\n                             })\n                         }\n                         Die => break,\n@@ -802,9 +813,9 @@ impl Context {\n             // recurse into the items of the module as well.\n             clean::ModuleItem(..) => {\n                 let name = item.name.get_ref().to_owned();\n-                let item = Cell::new(item);\n+                let mut item = Some(item);\n                 self.recurse(name, |this| {\n-                    let item = item.take();\n+                    let item = item.take_unwrap();\n                     let dst = this.dst.join(\"index.html\");\n                     render(File::create(&dst).unwrap(), this, &item, false);\n "}, {"sha": "3e7b7cdfac9b9f740aac57546ccc2197702813cd", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -26,7 +26,6 @@ extern mod syntax;\n extern mod rustc;\n extern mod extra;\n \n-use std::cell::Cell;\n use std::local_data;\n use std::io;\n use std::io::File;\n@@ -196,13 +195,13 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     let mut plugins = matches.opt_strs(\"plugins\");\n \n     // First, parse the crate and extract all relevant information.\n-    let libs = Cell::new(matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice())));\n-    let cfgs = Cell::new(matches.opt_strs(\"cfg\"));\n-    let cr = Cell::new(Path::new(cratefile));\n+    let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice()));\n+    let cfgs = matches.opt_strs(\"cfg\");\n+    let cr = Path::new(cratefile);\n     info!(\"starting to run rustc\");\n     let (crate, analysis) = do std::task::try {\n-        let cr = cr.take();\n-        core::run_core(libs.take().move_iter().collect(), cfgs.take(), &cr)\n+        let cr = cr;\n+        core::run_core(libs.move_iter().collect(), cfgs, &cr)\n     }.unwrap();\n     info!(\"finished with rustc\");\n     local_data::set(analysiskey, analysis);"}, {"sha": "1ca9fb1e98ccd860a3f9f8f265afe276318e8299", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::num;\n-use std::cell::Cell;\n-use std::uint;\n use std::hashmap::HashSet;\n use std::local_data;\n-\n+use std::num;\n+use std::uint;\n use syntax::ast;\n \n use clean;\n@@ -56,11 +54,10 @@ pub fn strip_hidden(crate: clean::Crate) -> plugins::PluginResult {\n pub fn strip_private(crate: clean::Crate) -> plugins::PluginResult {\n     // This stripper collects all *retained* nodes.\n     let mut retained = HashSet::new();\n-    let crate = Cell::new(crate);\n     let exported_items = local_data::get(super::analysiskey, |analysis| {\n         analysis.unwrap().exported_items.clone()\n     });\n-    let mut crate = crate.take();\n+    let mut crate = crate;\n \n     // strip all private items\n     {"}, {"sha": "48c25a53682098fbb8cf9a8197ceb9a67a83f496", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -19,7 +19,10 @@ use std::io::fs;\n pub fn list_installed_packages(f: |&PkgId| -> bool) -> bool  {\n     let workspaces = rust_path();\n     for p in workspaces.iter() {\n-        let binfiles = io::ignore_io_error(|| fs::readdir(&p.join(\"bin\")));\n+        let binfiles = {\n+            let _guard = io::ignore_io_error();\n+            fs::readdir(&p.join(\"bin\"))\n+        };\n         for exec in binfiles.iter() {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             match exec.filestem_str() {\n@@ -31,7 +34,10 @@ pub fn list_installed_packages(f: |&PkgId| -> bool) -> bool  {\n                 }\n             }\n         }\n-        let libfiles = io::ignore_io_error(|| fs::readdir(&p.join(\"lib\")));\n+        let libfiles = {\n+            let _guard = io::ignore_io_error();\n+            fs::readdir(&p.join(\"lib\"))\n+        };\n         for lib in libfiles.iter() {\n             debug!(\"Full name: {}\", lib.display());\n             match has_library(lib) {\n@@ -55,7 +61,10 @@ pub fn list_installed_packages(f: |&PkgId| -> bool) -> bool  {\n }\n \n pub fn has_library(p: &Path) -> Option<~str> {\n-    let files = io::ignore_io_error(|| fs::readdir(p));\n+    let files = {\n+        let _guard = io::ignore_io_error();\n+        fs::readdir(p)\n+    };\n     for path in files.iter() {\n         if path.extension_str() == Some(os::consts::DLL_EXTENSION) {\n             let stuff : &str = path.filestem_str().expect(\"has_library: weird path\");"}, {"sha": "7a17d3626256c52a42a0be2d6c58ec42d775b4c6", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -217,7 +217,10 @@ pub fn system_library(sysroot: &Path, lib_name: &str) -> Option<Path> {\n \n fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Option<Path> {\n     debug!(\"Listing directory {}\", dir_to_search.display());\n-    let dir_contents = io::ignore_io_error(|| fs::readdir(dir_to_search));\n+    let dir_contents = {\n+        let _guard = io::ignore_io_error();\n+        fs::readdir(dir_to_search)\n+    };\n     debug!(\"dir has {:?} entries\", dir_contents.len());\n \n     let lib_prefix = format!(\"{}{}\", os::consts::DLL_PREFIX, short_name);"}, {"sha": "5a0db8313fb5cdf939c5110bc146863f7c9bcc31", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -125,7 +125,6 @@ impl Drop for AsyncWatcher {\n \n #[cfg(test)]\n mod test_remote {\n-    use std::cell::Cell;\n     use std::rt::rtio::Callback;\n     use std::rt::thread::Thread;\n     use std::rt::tube::Tube;\n@@ -150,10 +149,11 @@ mod test_remote {\n \n         let mut tube = Tube::new();\n         let cb = ~MyCallback(Some(tube.clone()));\n-        let watcher = Cell::new(AsyncWatcher::new(local_loop(), cb as ~Callback));\n+        let watcher = AsyncWatcher::new(local_loop(), cb as ~Callback);\n \n         let thread = do Thread::start {\n-            watcher.take().fire();\n+            let mut watcher = watcher;\n+            watcher.fire();\n         };\n \n         assert_eq!(tube.recv(), 1);"}, {"sha": "241db9900cd4c7bb008f07a91b21cfd994ce2041", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -164,16 +164,20 @@ pub struct ForbidSwitch {\n \n impl ForbidSwitch {\n     fn new(s: &'static str) -> ForbidSwitch {\n+        let mut sched = Local::borrow(None::<Scheduler>);\n         ForbidSwitch {\n-            msg: s, sched: Local::borrow(|s: &mut Scheduler| s.sched_id())\n+            msg: s,\n+            sched: sched.get().sched_id(),\n         }\n     }\n }\n \n impl Drop for ForbidSwitch {\n     fn drop(&mut self) {\n-        assert!(self.sched == Local::borrow(|s: &mut Scheduler| s.sched_id()),\n-                \"didnt want a scheduler switch: {}\", self.msg);\n+        let mut sched = Local::borrow(None::<Scheduler>);\n+        assert!(self.sched == sched.get().sched_id(),\n+                \"didnt want a scheduler switch: {}\",\n+                self.msg);\n     }\n }\n \n@@ -391,15 +395,12 @@ pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n #[cfg(test)]\n fn local_loop() -> &'static mut Loop {\n     unsafe {\n-        cast::transmute(Local::borrow(|sched: &mut Scheduler| {\n-            let mut io = None;\n-            sched.event_loop.io(|i| {\n-                let (_vtable, uvio): (uint, &'static mut uvio::UvIoFactory) =\n-                    cast::transmute(i);\n-                io = Some(uvio);\n-            });\n-            io.unwrap()\n-        }).uv_loop())\n+        cast::transmute({\n+            let mut sched = Local::borrow(None::<Scheduler>);\n+            let (_vtable, uvio): (uint, &'static mut uvio::UvIoFactory) =\n+                cast::transmute(sched.get().event_loop.io().unwrap());\n+            uvio\n+        }.uv_loop())\n     }\n }\n "}, {"sha": "a63dcc6de3105c97f7a196b7024cfc2d13735288", "filename": "src/librustuv/macros.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fmacros.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -29,7 +29,10 @@ macro_rules! uvdebug (\n \n // get a handle for the current scheduler\n macro_rules! get_handle_to_current_scheduler(\n-    () => (Local::borrow(|sched: &mut Scheduler| sched.make_handle()))\n+    () => ({\n+        let mut sched = Local::borrow(None::<Scheduler>);\n+        sched.get().make_handle()\n+    })\n )\n \n pub fn dumb_println(args: &fmt::Arguments) {"}, {"sha": "c09383c2d8f5dbb99f4889e1805c4cf3388e3190", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 41, "deletions": 61, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -646,7 +646,6 @@ impl Drop for UdpWatcher {\n \n #[cfg(test)]\n mod test {\n-    use std::cell::Cell;\n     use std::comm::oneshot;\n     use std::rt::test::*;\n     use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioTcpAcceptor,\n@@ -691,7 +690,6 @@ mod test {\n     #[test]\n     fn listen_ip4() {\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n         let addr = next_test_ip4();\n \n         do spawn {\n@@ -701,7 +699,7 @@ mod test {\n             let mut w = match w.listen() {\n                 Ok(w) => w, Err(e) => fail!(\"{:?}\", e),\n             };\n-            chan.take().send(());\n+            chan.send(());\n             match w.accept() {\n                 Ok(mut stream) => {\n                     let mut buf = [0u8, ..10];\n@@ -728,7 +726,6 @@ mod test {\n     #[test]\n     fn listen_ip6() {\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n         let addr = next_test_ip6();\n \n         do spawn {\n@@ -738,7 +735,7 @@ mod test {\n             let mut w = match w.listen() {\n                 Ok(w) => w, Err(e) => fail!(\"{:?}\", e),\n             };\n-            chan.take().send(());\n+            chan.send(());\n             match w.accept() {\n                 Ok(mut stream) => {\n                     let mut buf = [0u8, ..10];\n@@ -765,14 +762,13 @@ mod test {\n     #[test]\n     fn udp_recv_ip4() {\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n         let client = next_test_ip4();\n         let server = next_test_ip4();\n \n         do spawn {\n             match UdpWatcher::bind(local_loop(), server) {\n                 Ok(mut w) => {\n-                    chan.take().send(());\n+                    chan.send(());\n                     let mut buf = [0u8, ..10];\n                     match w.recvfrom(buf) {\n                         Ok((10, addr)) => assert_eq!(addr, client),\n@@ -798,14 +794,13 @@ mod test {\n     #[test]\n     fn udp_recv_ip6() {\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n         let client = next_test_ip6();\n         let server = next_test_ip6();\n \n         do spawn {\n             match UdpWatcher::bind(local_loop(), server) {\n                 Ok(mut w) => {\n-                    chan.take().send(());\n+                    chan.send(());\n                     let mut buf = [0u8, ..10];\n                     match w.recvfrom(buf) {\n                         Ok((10, addr)) => assert_eq!(addr, client),\n@@ -834,13 +829,11 @@ mod test {\n         let addr = next_test_ip4();\n         static MAX: uint = 5000;\n         let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n \n         do spawn {\n             let listener = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut acceptor = listener.listen().unwrap();\n-            chan.take().send(());\n+            chan.send(());\n             let mut stream = acceptor.accept().unwrap();\n             let buf = [1, .. 2048];\n             let mut total_bytes_written = 0;\n@@ -852,7 +845,7 @@ mod test {\n         }\n \n         do spawn {\n-            port.take().recv();\n+            port.recv();\n             let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n             let mut buf = [0, .. 2048];\n             let mut total_bytes_read = 0;\n@@ -873,18 +866,16 @@ mod test {\n         let server_addr = next_test_ip4();\n         let client_addr = next_test_ip4();\n         let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n \n         do spawn {\n             let mut client = UdpWatcher::bind(local_loop(), client_addr).unwrap();\n-            port.take().recv();\n+            port.recv();\n             assert!(client.sendto([1], server_addr).is_ok());\n             assert!(client.sendto([2], server_addr).is_ok());\n         }\n \n         let mut server = UdpWatcher::bind(local_loop(), server_addr).unwrap();\n-        chan.take().send(());\n+        chan.send(());\n         let mut buf1 = [0];\n         let mut buf2 = [0];\n         let (nread1, src1) = server.recvfrom(buf1).unwrap();\n@@ -908,14 +899,11 @@ mod test {\n         let (p1, c1) = oneshot();\n         let (p2, c2) = oneshot();\n \n-        let first = Cell::new((p1, c2));\n-        let second = Cell::new((p2, c1));\n-\n         do spawn {\n             let l = local_loop();\n             let mut server_out = UdpWatcher::bind(l, server_out_addr).unwrap();\n             let mut server_in = UdpWatcher::bind(l, server_in_addr).unwrap();\n-            let (port, chan) = first.take();\n+            let (port, chan) = (p1, c2);\n             chan.send(());\n             port.recv();\n             let msg = [1, .. 2048];\n@@ -939,7 +927,7 @@ mod test {\n             let l = local_loop();\n             let mut client_out = UdpWatcher::bind(l, client_out_addr).unwrap();\n             let mut client_in = UdpWatcher::bind(l, client_in_addr).unwrap();\n-            let (port, chan) = second.take();\n+            let (port, chan) = (p2, c1);\n             port.recv();\n             chan.send(());\n             let mut total_bytes_recv = 0;\n@@ -966,14 +954,12 @@ mod test {\n     fn test_read_and_block() {\n         let addr = next_test_ip4();\n         let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n \n         do spawn {\n             let listener = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut acceptor = listener.listen().unwrap();\n             let (port2, chan2) = stream();\n-            chan.take().send(port2);\n+            chan.send(port2);\n             let mut stream = acceptor.accept().unwrap();\n             let mut buf = [0, .. 2048];\n \n@@ -998,7 +984,7 @@ mod test {\n         }\n \n         do spawn {\n-            let port2 = port.take().recv();\n+            let port2 = port.recv();\n             let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -1041,18 +1027,14 @@ mod test {\n     #[test]\n     fn test_homing_closes_correctly() {\n         let (port, chan) = oneshot();\n-        let port = Cell::new(port);\n-        let chan = Cell::new(chan);\n \n         do task::spawn_sched(task::SingleThreaded) {\n-            let chan = Cell::new(chan.take());\n             let listener = UdpWatcher::bind(local_loop(), next_test_ip4()).unwrap();\n-            chan.take().send(listener);\n+            chan.send(listener);\n         }\n \n         do task::spawn_sched(task::SingleThreaded) {\n-            let port = Cell::new(port.take());\n-            port.take().recv();\n+            port.recv();\n         }\n     }\n \n@@ -1086,22 +1068,22 @@ mod test {\n             let mut sched2 = ~Scheduler::new(loop2, worker2, queues.clone(),\n                                              sleepers.clone());\n \n-            let handle1 = Cell::new(sched1.make_handle());\n-            let handle2 = Cell::new(sched2.make_handle());\n-            let tasksFriendHandle = Cell::new(sched2.make_handle());\n+            let handle1 = sched1.make_handle();\n+            let handle2 = sched2.make_handle();\n+            let tasksFriendHandle = sched2.make_handle();\n \n             let on_exit: proc(UnwindResult) = proc(exit_status) {\n-                handle1.take().send(Shutdown);\n-                handle2.take().send(Shutdown);\n+                let mut handle1 = handle1;\n+                let mut handle2 = handle2;\n+                handle1.send(Shutdown);\n+                handle2.send(Shutdown);\n                 assert!(exit_status.is_success());\n             };\n \n             unsafe fn local_io() -> &'static mut IoFactory {\n-                Local::borrow(|sched: &mut Scheduler| {\n-                    let mut io = None;\n-                    sched.event_loop.io(|i| io = Some(i));\n-                    cast::transmute(io.unwrap())\n-                })\n+                let mut sched = Local::borrow(None::<Scheduler>);\n+                let io = sched.get().event_loop.io();\n+                cast::transmute(io.unwrap())\n             }\n \n             let test_function: proc() = proc() {\n@@ -1113,11 +1095,13 @@ mod test {\n \n                 // block self on sched1\n                 let scheduler: ~Scheduler = Local::take();\n+                let mut tasksFriendHandle = Some(tasksFriendHandle);\n                 scheduler.deschedule_running_task_and_then(|_, task| {\n                     // unblock task\n                     task.wake().map(|task| {\n                         // send self to sched2\n-                        tasksFriendHandle.take().send(TaskFromFriend(task));\n+                        tasksFriendHandle.take_unwrap()\n+                                         .send(TaskFromFriend(task));\n                     });\n                     // sched1 should now sleep since it has nothing else to do\n                 })\n@@ -1133,19 +1117,20 @@ mod test {\n             let mut main_task = ~Task::new_root(&mut sched1.stack_pool, None,\n                                                 test_function);\n             main_task.death.on_exit = Some(on_exit);\n-            let main_task = Cell::new(main_task);\n-\n-            let null_task = Cell::new(~do Task::new_root(&mut sched2.stack_pool,\n-                                                         None) || {});\n \n-            let sched1 = Cell::new(sched1);\n-            let sched2 = Cell::new(sched2);\n+            let null_task = ~do Task::new_root(&mut sched2.stack_pool, None) {\n+                // nothing\n+            };\n \n+            let main_task = main_task;\n+            let sched1 = sched1;\n             let thread1 = do Thread::start {\n-                sched1.take().bootstrap(main_task.take());\n+                sched1.bootstrap(main_task);\n             };\n+\n+            let sched2 = sched2;\n             let thread2 = do Thread::start {\n-                sched2.take().bootstrap(null_task.take());\n+                sched2.bootstrap(null_task);\n             };\n \n             thread1.join();\n@@ -1164,13 +1149,12 @@ mod test {\n     #[should_fail] #[test]\n     fn tcp_stream_fail_cleanup() {\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n         let addr = next_test_ip4();\n \n         do spawn {\n             let w = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut w = w.listen().unwrap();\n-            chan.take().send(());\n+            chan.send(());\n             w.accept();\n         }\n         port.recv();\n@@ -1189,14 +1173,13 @@ mod test {\n     fn udp_fail_other_task() {\n         let addr = next_test_ip4();\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n \n         // force the handle to be created on a different scheduler, failure in\n         // the original task will force a homing operation back to this\n         // scheduler.\n         do task::spawn_sched(task::SingleThreaded) {\n             let w = UdpWatcher::bind(local_loop(), addr).unwrap();\n-            chan.take().send(w);\n+            chan.send(w);\n         }\n \n         let _w = port.recv();\n@@ -1208,13 +1191,12 @@ mod test {\n     #[ignore(reason = \"linked failure\")]\n     fn linked_failure1() {\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n         let addr = next_test_ip4();\n \n         do spawn {\n             let w = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut w = w.listen().unwrap();\n-            chan.take().send(());\n+            chan.send(());\n             w.accept();\n         }\n \n@@ -1227,13 +1209,12 @@ mod test {\n     #[ignore(reason = \"linked failure\")]\n     fn linked_failure2() {\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n         let addr = next_test_ip4();\n \n         do spawn {\n             let w = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut w = w.listen().unwrap();\n-            chan.take().send(());\n+            chan.send(());\n             let mut buf = [0];\n             w.accept().unwrap().read(buf);\n         }\n@@ -1249,11 +1230,10 @@ mod test {\n     #[ignore(reason = \"linked failure\")]\n     fn linked_failure3() {\n         let (port, chan) = stream();\n-        let chan = Cell::new(chan);\n         let addr = next_test_ip4();\n \n         do spawn {\n-            let chan = chan.take();\n+            let chan = chan;\n             let w = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut w = w.listen().unwrap();\n             chan.send(());"}, {"sha": "86ebae45f19530960ee4c88bf3c5fbcc62728535", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -231,7 +231,6 @@ impl HomingIO for PipeAcceptor {\n \n #[cfg(test)]\n mod tests {\n-    use std::cell::Cell;\n     use std::comm::oneshot;\n     use std::rt::rtio::{RtioUnixListener, RtioUnixAcceptor, RtioPipe};\n     use std::rt::test::next_test_unix;\n@@ -276,12 +275,11 @@ mod tests {\n         let path = next_test_unix();\n         let path2 = path.clone();\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n \n         do spawn {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n             let mut p = p.listen().unwrap();\n-            chan.take().send(());\n+            chan.send(());\n             let mut client = p.accept().unwrap();\n             let mut buf = [0];\n             assert!(client.read(buf).unwrap() == 1);\n@@ -301,12 +299,11 @@ mod tests {\n         let path = next_test_unix();\n         let path2 = path.clone();\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n \n         do spawn {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n             let mut p = p.listen().unwrap();\n-            chan.take().send(());\n+            chan.send(());\n             p.accept();\n         }\n         port.recv();"}, {"sha": "db698f80e38c1b7cc330719c0ed689808f1c7a9d", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -76,7 +76,6 @@ impl Drop for SignalWatcher {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use std::cell::Cell;\n     use super::super::local_loop;\n     use std::io::signal;\n     use std::comm::{SharedChan, stream};\n@@ -89,9 +88,8 @@ mod test {\n         let _signal = SignalWatcher::new(local_loop(), signal::Interrupt,\n                                          chan);\n \n-        let port = Cell::new(port);\n         do spawn {\n-            port.take().try_recv();\n+            port.try_recv();\n         }\n \n         // when we drop the SignalWatcher we're going to destroy the channel,"}, {"sha": "a229c000066d8b3f34d837b363b39aaed4edf97e", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -163,7 +163,6 @@ impl Drop for TimerWatcher {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use std::cell::Cell;\n     use std::rt::rtio::RtioTimer;\n     use super::super::local_loop;\n \n@@ -229,10 +228,10 @@ mod test {\n     fn closing_channel_during_drop_doesnt_kill_everything() {\n         // see issue #10375\n         let mut timer = TimerWatcher::new(local_loop());\n-        let timer_port = Cell::new(timer.period(1000));\n+        let timer_port = timer.period(1000);\n \n         do spawn {\n-            timer_port.take().try_recv();\n+            timer_port.try_recv();\n         }\n \n         // when we drop the TimerWatcher we're going to destroy the channel,\n@@ -243,10 +242,10 @@ mod test {\n     fn reset_doesnt_switch_tasks() {\n         // similar test to the one above.\n         let mut timer = TimerWatcher::new(local_loop());\n-        let timer_port = Cell::new(timer.period(1000));\n+        let timer_port = timer.period(1000);\n \n         do spawn {\n-            timer_port.take().try_recv();\n+            timer_port.try_recv();\n         }\n \n         timer.oneshot(1);\n@@ -255,10 +254,10 @@ mod test {\n     fn reset_doesnt_switch_tasks2() {\n         // similar test to the one above.\n         let mut timer = TimerWatcher::new(local_loop());\n-        let timer_port = Cell::new(timer.period(1000));\n+        let timer_port = timer.period(1000);\n \n         do spawn {\n-            timer_port.take().try_recv();\n+            timer_port.try_recv();\n         }\n \n         timer.sleep(1);"}, {"sha": "e0011398aa104c1a2b6e647d5034e5038bd58c8b", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -45,9 +45,10 @@ pub trait HomingIO {\n \n         let _f = ForbidUnwind::new(\"going home\");\n \n-        let current_sched_id = Local::borrow(|sched: &mut Scheduler| {\n-            sched.sched_id()\n-        });\n+        let current_sched_id = {\n+            let mut sched = Local::borrow(None::<Scheduler>);\n+            sched.get().sched_id()\n+        };\n \n         // Only need to invoke a context switch if we're not on the right\n         // scheduler.\n@@ -59,9 +60,10 @@ pub trait HomingIO {\n                 });\n             })\n         }\n-        let current_sched_id = Local::borrow(|sched: &mut Scheduler| {\n-            sched.sched_id()\n-        });\n+        let current_sched_id = {\n+            let mut sched = Local::borrow(None::<Scheduler>);\n+            sched.get().sched_id()\n+        };\n         assert!(current_sched_id == self.home().sched_id);\n \n         self.home().sched_id\n@@ -96,7 +98,8 @@ struct HomingMissile {\n \n impl HomingMissile {\n     pub fn check(&self, msg: &'static str) {\n-        let local_id = Local::borrow(|sched: &mut Scheduler| sched.sched_id());\n+        let mut sched = Local::borrow(None::<Scheduler>);\n+        let local_id = sched.get().sched_id();\n         assert!(local_id == self.io_home, \"{}\", msg);\n     }\n }\n@@ -158,8 +161,9 @@ impl EventLoop for UvEventLoop {\n         ~AsyncWatcher::new(self.uvio.uv_loop(), f) as ~RemoteCallback\n     }\n \n-    fn io<'a>(&'a mut self, f: |&'a mut IoFactory|) {\n-        f(&mut self.uvio as &mut IoFactory)\n+    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory> {\n+        let factory = &mut self.uvio as &mut IoFactory;\n+        Some(factory)\n     }\n }\n "}, {"sha": "2b64c5c83fbda276edf76392023491f4292a5c02", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -169,6 +169,7 @@ pub mod raw {\n     use at_vec::capacity;\n     use cast;\n     use cast::{transmute, transmute_copy};\n+    use option::None;\n     use ptr;\n     use mem;\n     use uint;\n@@ -259,9 +260,8 @@ pub mod raw {\n             use rt::local::Local;\n             use rt::task::Task;\n \n-            Local::borrow(|task: &mut Task| {\n-                task.heap.realloc(ptr as *mut Box<()>, size) as *()\n-            })\n+            let mut task = Local::borrow(None::<Task>);\n+            task.get().heap.realloc(ptr as *mut Box<()>, size) as *()\n         }\n     }\n "}, {"sha": "280c79f1fd4c6bd0ba810a53ff5df0d9546fb6e6", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -14,66 +14,6 @@ use prelude::*;\n use cast;\n use util::NonCopyable;\n \n-\n-/*\n-A dynamic, mutable location.\n-\n-Similar to a mutable option type, but friendlier.\n-*/\n-\n-#[no_freeze]\n-#[deriving(Clone, DeepClone, Eq)]\n-#[allow(missing_doc)]\n-pub struct Cell<T> {\n-    priv value: Option<T>\n-}\n-\n-impl<T> Cell<T> {\n-    /// Creates a new full cell with the given value.\n-    pub fn new(value: T) -> Cell<T> {\n-        Cell { value: Some(value) }\n-    }\n-\n-    /// Yields the value, failing if the cell is empty.\n-    pub fn take(&self) -> T {\n-        let this = unsafe { cast::transmute_mut(self) };\n-        if this.is_empty() {\n-            fail!(\"attempt to take an empty cell\");\n-        }\n-\n-        this.value.take_unwrap()\n-    }\n-\n-    /// Yields the value if the cell is full, or `None` if it is empty.\n-    pub fn take_opt(&self) -> Option<T> {\n-        let this = unsafe { cast::transmute_mut(self) };\n-        this.value.take()\n-    }\n-\n-    /// Returns true if the cell is empty and false if the cell is full.\n-    pub fn is_empty(&self) -> bool {\n-        self.value.is_none()\n-    }\n-}\n-\n-#[test]\n-fn test_basic() {\n-    let value_cell = Cell::new(~10);\n-    assert!(!value_cell.is_empty());\n-    let value = value_cell.take();\n-    assert!(value == ~10);\n-    assert!(value_cell.is_empty());\n-}\n-\n-#[test]\n-#[should_fail]\n-fn test_take_empty() {\n-    let value_cell: Cell<~int> = Cell::new(~0);\n-    value_cell.take();\n-    value_cell.take();\n-}\n-\n-\n /// A mutable memory location with dynamically checked borrow rules\n #[no_freeze]\n pub struct RefCell<T> {"}, {"sha": "c5d6ce2f3dfd2cb55a98a8c0047b634765d21067", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -162,7 +162,7 @@ impl<T, U> Condition<T, U> {\n ///\n /// Normally this object is not dealt with directly, but rather it's directly\n /// used after being returned from `trap`\n-struct Trap<'self, T, U> {\n+pub struct Trap<'self, T, U> {\n     priv cond: &'self Condition<T, U>,\n     priv handler: @Handler<T, U>\n }\n@@ -187,10 +187,24 @@ impl<'self, T, U> Trap<'self, T, U> {\n         local_data::set(self.cond.key, self.handler);\n         inner()\n     }\n+\n+    /// Returns a guard that will automatically reset the condition upon\n+    /// exit of the scope. This is useful if you want to use conditions with\n+    /// an RAII pattern.\n+    pub fn guard(&self) -> Guard<'self,T,U> {\n+        let guard = Guard {\n+            cond: self.cond\n+        };\n+        debug!(\"Guard: pushing handler to TLS\");\n+        local_data::set(self.cond.key, self.handler);\n+        guard\n+    }\n }\n \n-#[doc(hidden)]\n-struct Guard<'self, T, U> {\n+/// A guard that will automatically reset the condition handler upon exit of\n+/// the scope. This is useful if you want to use conditions with an RAII\n+/// pattern.\n+pub struct Guard<'self, T, U> {\n     priv cond: &'self Condition<T, U>\n }\n "}, {"sha": "5bfdf685bea7ab4ef110c83496c4274435956d98", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -51,7 +51,7 @@ use iter::Iterator;\n use super::{Reader, Writer, Seek};\n use super::{SeekStyle, Read, Write, Open, IoError, Truncate,\n             FileMode, FileAccess, FileStat, io_error, FilePermission};\n-use rt::rtio::{RtioFileStream, IoFactory, with_local_io};\n+use rt::rtio::{RtioFileStream, IoFactory, LocalIo};\n use io;\n use option::{Some, None, Option};\n use result::{Ok, Err, Result};\n@@ -76,15 +76,14 @@ pub struct File {\n }\n \n fn io_raise<T>(f: |io: &mut IoFactory| -> Result<T, IoError>) -> Option<T> {\n-    with_local_io(|io| {\n-        match f(io) {\n-            Ok(t) => Some(t),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n+    let mut io = LocalIo::borrow();\n+    match f(io.get()) {\n+        Ok(t) => Some(t),\n+        Err(ioerr) => {\n+            io_error::cond.raise(ioerr);\n+            None\n         }\n-    })\n+    }\n }\n \n impl File {\n@@ -132,19 +131,18 @@ impl File {\n     pub fn open_mode(path: &Path,\n                      mode: FileMode,\n                      access: FileAccess) -> Option<File> {\n-        with_local_io(|io| {\n-            match io.fs_open(&path.to_c_str(), mode, access) {\n-                Ok(fd) => Some(File {\n-                    path: path.clone(),\n-                    fd: fd,\n-                    last_nread: -1\n-                }),\n-                Err(ioerr) => {\n-                    io_error::cond.raise(ioerr);\n-                    None\n-                }\n+        let mut io = LocalIo::borrow();\n+        match io.get().fs_open(&path.to_c_str(), mode, access) {\n+            Ok(fd) => Some(File {\n+                path: path.clone(),\n+                fd: fd,\n+                last_nread: -1\n+            }),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n             }\n-        })\n+        }\n     }\n \n     /// Attempts to open a file in read-only mode. This function is equivalent to"}, {"sha": "d5e216e24267652394ef658fdec515566b948890", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -241,6 +241,7 @@ Out of scope\n #[allow(missing_doc)];\n \n use cast;\n+use condition::Guard;\n use container::Container;\n use int;\n use iter::Iterator;\n@@ -394,12 +395,12 @@ condition! {\n \n /// Helper for wrapper calls where you want to\n /// ignore any io_errors that might be raised\n-pub fn ignore_io_error<T>(cb: || -> T) -> T {\n+pub fn ignore_io_error() -> Guard<'static,IoError,()> {\n     io_error::cond.trap(|_| {\n         // just swallow the error.. downstream users\n         // who can make a decision based on a None result\n         // won't care\n-    }).inside(|| cb())\n+    }).guard()\n }\n \n /// Helper for catching an I/O error and wrapping it in a Result object. The"}, {"sha": "d9dccc84f1c45de294c73b7f137e6c0047406500", "filename": "src/libstd/io/native/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fnative%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fnative%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Fmod.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -223,3 +223,6 @@ impl rtio::IoFactory for IoFactory {\n         Err(unimpl())\n     }\n }\n+\n+pub static mut NATIVE_IO_FACTORY: IoFactory = IoFactory;\n+"}, {"sha": "7df4fdd22667647b671c7e141cfa4b7eba34dedc", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -21,7 +21,7 @@ use option::{Option, Some, None};\n use result::{Ok, Err};\n use io::{io_error};\n use io::net::ip::{SocketAddr, IpAddr};\n-use rt::rtio::{IoFactory, with_local_io};\n+use rt::rtio::{IoFactory, LocalIo};\n use vec::ImmutableVector;\n \n /// Hints to the types of sockets that are desired when looking up hosts\n@@ -95,17 +95,16 @@ pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n ///\n /// XXX: this is not public because the `Hint` structure is not ready for public\n ///      consumption just yet.\n-fn lookup(hostname: Option<&str>, servname: Option<&str>,\n-          hint: Option<Hint>) -> Option<~[Info]> {\n-    with_local_io(|io| {\n-        match io.get_host_addresses(hostname, servname, hint) {\n-            Ok(i) => Some(i),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n+fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n+          -> Option<~[Info]> {\n+    let mut io = LocalIo::borrow();\n+    match io.get().get_host_addresses(hostname, servname, hint) {\n+        Ok(i) => Some(i),\n+        Err(ioerr) => {\n+            io_error::cond.raise(ioerr);\n+            None\n         }\n-    })\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "3c7582db7b85df03d3fd9a5e12479d6eb9bbb706", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 49, "deletions": 79, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -13,8 +13,8 @@ use result::{Ok, Err};\n use io::net::ip::SocketAddr;\n use io::{Reader, Writer, Listener, Acceptor};\n use io::{io_error, EndOfFile};\n-use rt::rtio::{IoFactory, with_local_io,\n-               RtioSocket, RtioTcpListener, RtioTcpAcceptor, RtioTcpStream};\n+use rt::rtio::{IoFactory, LocalIo, RtioSocket, RtioTcpListener};\n+use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n \n pub struct TcpStream {\n     priv obj: ~RtioTcpStream\n@@ -26,15 +26,17 @@ impl TcpStream {\n     }\n \n     pub fn connect(addr: SocketAddr) -> Option<TcpStream> {\n-        with_local_io(|io| {\n-            match io.tcp_connect(addr) {\n-                Ok(s) => Some(TcpStream::new(s)),\n-                Err(ioerr) => {\n-                    io_error::cond.raise(ioerr);\n-                    None\n-                }\n+        let result = {\n+            let mut io = LocalIo::borrow();\n+            io.get().tcp_connect(addr)\n+        };\n+        match result {\n+            Ok(s) => Some(TcpStream::new(s)),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n             }\n-        })\n+        }\n     }\n \n     pub fn peer_name(&mut self) -> Option<SocketAddr> {\n@@ -92,15 +94,14 @@ pub struct TcpListener {\n \n impl TcpListener {\n     pub fn bind(addr: SocketAddr) -> Option<TcpListener> {\n-        with_local_io(|io| {\n-            match io.tcp_bind(addr) {\n-                Ok(l) => Some(TcpListener { obj: l }),\n-                Err(ioerr) => {\n-                    io_error::cond.raise(ioerr);\n-                    None\n-                }\n+        let mut io = LocalIo::borrow();\n+        match io.get().tcp_bind(addr) {\n+            Ok(l) => Some(TcpListener { obj: l }),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n             }\n-        })\n+        }\n     }\n \n     pub fn socket_name(&mut self) -> Option<SocketAddr> {\n@@ -146,7 +147,6 @@ impl Acceptor<TcpStream> for TcpAcceptor {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use cell::Cell;\n     use rt::test::*;\n     use io::net::ip::{Ipv4Addr, SocketAddr};\n     use io::*;\n@@ -196,20 +196,18 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 stream.read(buf);\n                 assert!(buf[0] == 99);\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]);\n             }\n@@ -221,20 +219,18 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 stream.read(buf);\n                 assert!(buf[0] == 99);\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]);\n             }\n@@ -246,20 +242,18 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n                 assert!(nread.is_none());\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -271,20 +265,18 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n                 assert!(nread.is_none());\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -296,12 +288,10 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n@@ -319,7 +309,7 @@ mod test {\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -331,12 +321,10 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n@@ -354,7 +342,7 @@ mod test {\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -366,12 +354,10 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip4();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let buf = [0];\n                 loop {\n@@ -392,7 +378,7 @@ mod test {\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -404,12 +390,10 @@ mod test {\n         do run_in_mt_newsched_task {\n             let addr = next_test_ip6();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 let mut stream = acceptor.accept();\n                 let buf = [0];\n                 loop {\n@@ -430,7 +414,7 @@ mod test {\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let _stream = TcpStream::connect(addr);\n                 // Close\n             }\n@@ -443,12 +427,10 @@ mod test {\n             let addr = next_test_ip4();\n             let max = 10;\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 for ref mut stream in acceptor.incoming().take(max) {\n                     let mut buf = [0];\n                     stream.read(buf);\n@@ -457,7 +439,7 @@ mod test {\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 max.times(|| {\n                     let mut stream = TcpStream::connect(addr);\n                     stream.write([99]);\n@@ -472,12 +454,10 @@ mod test {\n             let addr = next_test_ip6();\n             let max = 10;\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 for ref mut stream in acceptor.incoming().take(max) {\n                     let mut buf = [0];\n                     stream.read(buf);\n@@ -486,7 +466,7 @@ mod test {\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 max.times(|| {\n                     let mut stream = TcpStream::connect(addr);\n                     stream.write([99]);\n@@ -501,16 +481,14 @@ mod test {\n             let addr = next_test_ip4();\n             static MAX: int = 10;\n             let (port, chan) = oneshot();\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n-                    let stream = Cell::new(stream);\n                     // Start another task to handle the connection\n                     do spawntask {\n-                        let mut stream = stream.take();\n+                        let mut stream = stream;\n                         let mut buf = [0];\n                         stream.read(buf);\n                         assert!(buf[0] == i as u8);\n@@ -543,16 +521,14 @@ mod test {\n             let addr = next_test_ip6();\n             static MAX: int = 10;\n             let (port, chan) = oneshot();\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n-                    let stream = Cell::new(stream);\n                     // Start another task to handle the connection\n                     do spawntask {\n-                        let mut stream = stream.take();\n+                        let mut stream = stream;\n                         let mut buf = [0];\n                         stream.read(buf);\n                         assert!(buf[0] == i as u8);\n@@ -585,16 +561,14 @@ mod test {\n             let addr = next_test_ip4();\n             static MAX: int = 10;\n             let (port, chan) = oneshot();\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 for stream in acceptor.incoming().take(MAX as uint) {\n-                    let stream = Cell::new(stream);\n                     // Start another task to handle the connection\n                     do spawntask_later {\n-                        let mut stream = stream.take();\n+                        let mut stream = stream;\n                         let mut buf = [0];\n                         stream.read(buf);\n                         assert!(buf[0] == 99);\n@@ -626,16 +600,14 @@ mod test {\n             let addr = next_test_ip6();\n             static MAX: int = 10;\n             let (port, chan) = oneshot();\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 for stream in acceptor.incoming().take(MAX as uint) {\n-                    let stream = Cell::new(stream);\n                     // Start another task to handle the connection\n                     do spawntask_later {\n-                        let mut stream = stream.take();\n+                        let mut stream = stream;\n                         let mut buf = [0];\n                         stream.read(buf);\n                         assert!(buf[0] == 99);\n@@ -682,18 +654,16 @@ mod test {\n     fn peer_name(addr: SocketAddr) {\n         do run_in_mt_newsched_task {\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.take().send(());\n+                chan.send(());\n \n                 acceptor.accept();\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 let stream = TcpStream::connect(addr);\n \n                 assert!(stream.is_some());"}, {"sha": "87cf59aba3bf773036918c6e80be7dba12f7601c", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -13,23 +13,22 @@ use result::{Ok, Err};\n use io::net::ip::SocketAddr;\n use io::{Reader, Writer};\n use io::{io_error, EndOfFile};\n-use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, with_local_io};\n+use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, LocalIo};\n \n pub struct UdpSocket {\n     priv obj: ~RtioUdpSocket\n }\n \n impl UdpSocket {\n     pub fn bind(addr: SocketAddr) -> Option<UdpSocket> {\n-        with_local_io(|io| {\n-            match io.udp_bind(addr) {\n-                Ok(s) => Some(UdpSocket { obj: s }),\n-                Err(ioerr) => {\n-                    io_error::cond.raise(ioerr);\n-                    None\n-                }\n+        let mut io = LocalIo::borrow();\n+        match io.get().udp_bind(addr) {\n+            Ok(s) => Some(UdpSocket { obj: s }),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n             }\n-        })\n+        }\n     }\n \n     pub fn recvfrom(&mut self, buf: &mut [u8]) -> Option<(uint, SocketAddr)> {\n@@ -110,7 +109,6 @@ mod test {\n     use io::*;\n     use option::{Some, None};\n     use rt::comm::oneshot;\n-    use cell::Cell;\n \n     #[test]  #[ignore]\n     fn bind_error() {\n@@ -134,13 +132,11 @@ mod test {\n             let server_ip = next_test_ip4();\n             let client_ip = next_test_ip4();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n                     Some(ref mut server) => {\n-                        chan.take().send(());\n+                        chan.send(());\n                         let mut buf = [0];\n                         match server.recvfrom(buf) {\n                             Some((nread, src)) => {\n@@ -158,7 +154,7 @@ mod test {\n             do spawntask {\n                 match UdpSocket::bind(client_ip) {\n                     Some(ref mut client) => {\n-                        port.take().recv();\n+                        port.recv();\n                         client.sendto([99], server_ip)\n                     }\n                     None => fail!()\n@@ -173,13 +169,11 @@ mod test {\n             let server_ip = next_test_ip6();\n             let client_ip = next_test_ip6();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n                     Some(ref mut server) => {\n-                        chan.take().send(());\n+                        chan.send(());\n                         let mut buf = [0];\n                         match server.recvfrom(buf) {\n                             Some((nread, src)) => {\n@@ -197,7 +191,7 @@ mod test {\n             do spawntask {\n                 match UdpSocket::bind(client_ip) {\n                     Some(ref mut client) => {\n-                        port.take().recv();\n+                        port.recv();\n                         client.sendto([99], server_ip)\n                     }\n                     None => fail!()\n@@ -212,15 +206,13 @@ mod test {\n             let server_ip = next_test_ip4();\n             let client_ip = next_test_ip4();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n                     Some(server) => {\n                         let server = ~server;\n                         let mut stream = server.connect(client_ip);\n-                        chan.take().send(());\n+                        chan.send(());\n                         let mut buf = [0];\n                         match stream.read(buf) {\n                             Some(nread) => {\n@@ -239,7 +231,7 @@ mod test {\n                     Some(client) => {\n                         let client = ~client;\n                         let mut stream = client.connect(server_ip);\n-                        port.take().recv();\n+                        port.recv();\n                         stream.write([99]);\n                     }\n                     None => fail!()\n@@ -254,15 +246,13 @@ mod test {\n             let server_ip = next_test_ip6();\n             let client_ip = next_test_ip6();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 match UdpSocket::bind(server_ip) {\n                     Some(server) => {\n                         let server = ~server;\n                         let mut stream = server.connect(client_ip);\n-                        chan.take().send(());\n+                        chan.send(());\n                         let mut buf = [0];\n                         match stream.read(buf) {\n                             Some(nread) => {\n@@ -281,7 +271,7 @@ mod test {\n                     Some(client) => {\n                         let client = ~client;\n                         let mut stream = client.connect(server_ip);\n-                        port.take().recv();\n+                        port.recv();\n                         stream.write([99]);\n                     }\n                     None => fail!()"}, {"sha": "c1f75465d9ceb23f1e52312fb5ade0f14a98b320", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -25,7 +25,7 @@ instances as clients.\n use prelude::*;\n \n use c_str::ToCStr;\n-use rt::rtio::{IoFactory, RtioUnixListener, with_local_io};\n+use rt::rtio::{IoFactory, LocalIo, RtioUnixListener};\n use rt::rtio::{RtioUnixAcceptor, RtioPipe};\n use io::pipe::PipeStream;\n use io::{io_error, Listener, Acceptor, Reader, Writer};\n@@ -59,15 +59,14 @@ impl UnixStream {\n     ///     stream.write([1, 2, 3]);\n     ///\n     pub fn connect<P: ToCStr>(path: &P) -> Option<UnixStream> {\n-        with_local_io(|io| {\n-            match io.unix_connect(&path.to_c_str()) {\n-                Ok(s) => Some(UnixStream::new(s)),\n-                Err(ioerr) => {\n-                    io_error::cond.raise(ioerr);\n-                    None\n-                }\n+        let mut io = LocalIo::borrow();\n+        match io.get().unix_connect(&path.to_c_str()) {\n+            Ok(s) => Some(UnixStream::new(s)),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n             }\n-        })\n+        }\n     }\n }\n \n@@ -108,15 +107,14 @@ impl UnixListener {\n     ///     }\n     ///\n     pub fn bind<P: ToCStr>(path: &P) -> Option<UnixListener> {\n-        with_local_io(|io| {\n-            match io.unix_bind(&path.to_c_str()) {\n-                Ok(s) => Some(UnixListener{ obj: s }),\n-                Err(ioerr) => {\n-                    io_error::cond.raise(ioerr);\n-                    None\n-                }\n+        let mut io = LocalIo::borrow();\n+        match io.get().unix_bind(&path.to_c_str()) {\n+            Ok(s) => Some(UnixListener{ obj: s }),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n             }\n-        })\n+        }\n     }\n }\n \n@@ -152,32 +150,26 @@ impl Acceptor<UnixStream> for UnixAcceptor {\n mod tests {\n     use prelude::*;\n     use super::*;\n-    use cell::Cell;\n     use rt::test::*;\n     use io::*;\n     use rt::comm::oneshot;\n \n     fn smalltest(server: proc(UnixStream), client: proc(UnixStream)) {\n-        let server = Cell::new(server);\n-        let client = Cell::new(client);\n         do run_in_mt_newsched_task {\n-            let server = Cell::new(server.take());\n-            let client = Cell::new(client.take());\n             let path1 = next_test_unix();\n             let path2 = path1.clone();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n+            let (client, server) = (client, server);\n \n             do spawntask {\n                 let mut acceptor = UnixListener::bind(&path1).listen();\n-                chan.take().send(());\n-                server.take()(acceptor.accept().unwrap());\n+                chan.send(());\n+                server(acceptor.accept().unwrap());\n             }\n \n             do spawntask {\n-                port.take().recv();\n-                client.take()(UnixStream::connect(&path2).unwrap());\n+                port.recv();\n+                client(UnixStream::connect(&path2).unwrap());\n             }\n         }\n     }\n@@ -260,12 +252,10 @@ mod tests {\n             let path1 = next_test_unix();\n             let path2 = path1.clone();\n             let (port, chan) = oneshot();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             do spawntask {\n                 let mut acceptor = UnixListener::bind(&path1).listen();\n-                chan.take().send(());\n+                chan.send(());\n                 times.times(|| {\n                     let mut client = acceptor.accept();\n                     let mut buf = [0];\n@@ -275,7 +265,7 @@ mod tests {\n             }\n \n             do spawntask {\n-                port.take().recv();\n+                port.recv();\n                 times.times(|| {\n                     let mut stream = UnixStream::connect(&path2);\n                     stream.write([100]);"}, {"sha": "252575ee4454f59e760e776c943994c5a5f0a2ab", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -17,7 +17,7 @@ use prelude::*;\n use super::{Reader, Writer};\n use io::{io_error, EndOfFile};\n use io::native::file;\n-use rt::rtio::{RtioPipe, with_local_io};\n+use rt::rtio::{LocalIo, RtioPipe};\n \n pub struct PipeStream {\n     priv obj: ~RtioPipe,\n@@ -44,15 +44,14 @@ impl PipeStream {\n     /// If the pipe cannot be created, an error will be raised on the\n     /// `io_error` condition.\n     pub fn open(fd: file::fd_t) -> Option<PipeStream> {\n-        with_local_io(|io| {\n-            match io.pipe_open(fd) {\n-                Ok(obj) => Some(PipeStream { obj: obj }),\n-                Err(e) => {\n-                    io_error::cond.raise(e);\n-                    None\n-                }\n+        let mut io = LocalIo::borrow();\n+        match io.get().pipe_open(fd) {\n+            Ok(obj) => Some(PipeStream { obj: obj }),\n+            Err(e) => {\n+                io_error::cond.raise(e);\n+                None\n             }\n-        })\n+        }\n     }\n \n     pub fn new(inner: ~RtioPipe) -> PipeStream {"}, {"sha": "1c86ac84bbb0a2b56675bed21d5edf2a591288bc", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -11,12 +11,11 @@\n //! Bindings for executing child processes\n \n use prelude::*;\n-use cell::Cell;\n \n use libc;\n use io;\n use io::io_error;\n-use rt::rtio::{RtioProcess, IoFactory, with_local_io};\n+use rt::rtio::{RtioProcess, IoFactory, LocalIo};\n \n use fmt;\n \n@@ -120,21 +119,19 @@ impl Process {\n     /// Creates a new pipe initialized, but not bound to any particular\n     /// source/destination\n     pub fn new(config: ProcessConfig) -> Option<Process> {\n-        let config = Cell::new(config);\n-        with_local_io(|io| {\n-            match io.spawn(config.take()) {\n-                Ok((p, io)) => Some(Process{\n-                    handle: p,\n-                    io: io.move_iter().map(|p|\n-                        p.map(|p| io::PipeStream::new(p))\n-                    ).collect()\n-                }),\n-                Err(ioerr) => {\n-                    io_error::cond.raise(ioerr);\n-                    None\n-                }\n+        let mut io = LocalIo::borrow();\n+        match io.get().spawn(config) {\n+            Ok((p, io)) => Some(Process{\n+                handle: p,\n+                io: io.move_iter().map(|p|\n+                    p.map(|p| io::PipeStream::new(p))\n+                ).collect()\n+            }),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n             }\n-        })\n+        }\n     }\n \n     /// Returns the process id of this child process"}, {"sha": "43659d24c35139f9fd383b72b3ae4f34dcd062ff", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -24,9 +24,8 @@ use comm::{Port, SharedChan, stream};\n use container::{Map, MutableMap};\n use hashmap;\n use io::io_error;\n-use option::{Some, None};\n use result::{Err, Ok};\n-use rt::rtio::{IoFactory, RtioSignal, with_local_io};\n+use rt::rtio::{IoFactory, LocalIo, RtioSignal};\n \n #[repr(int)]\n #[deriving(Eq, IterBytes)]\n@@ -123,18 +122,17 @@ impl Listener {\n         if self.handles.contains_key(&signum) {\n             return true; // self is already listening to signum, so succeed\n         }\n-        with_local_io(|io| {\n-            match io.signal(signum, self.chan.clone()) {\n-                Ok(w) => {\n-                    self.handles.insert(signum, w);\n-                    Some(())\n-                },\n-                Err(ioerr) => {\n-                    io_error::cond.raise(ioerr);\n-                    None\n-                }\n+        let mut io = LocalIo::borrow();\n+        match io.get().signal(signum, self.chan.clone()) {\n+            Ok(w) => {\n+                self.handles.insert(signum, w);\n+                true\n+            },\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                false\n             }\n-        }).is_some()\n+        }\n     }\n \n     /// Unregisters a signal. If this listener currently had a handler"}, {"sha": "41337075aa9b96f28952e37b322464d1d5ba0980", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -31,7 +31,7 @@ use libc;\n use option::{Option, Some, None};\n use result::{Ok, Err};\n use io::buffered::LineBufferedWriter;\n-use rt::rtio::{IoFactory, RtioTTY, RtioFileStream, with_local_io, DontClose};\n+use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n use super::{Reader, Writer, io_error, IoError, OtherIoError,\n             standard_error, EndOfFile};\n \n@@ -69,12 +69,19 @@ enum StdSource {\n }\n \n fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n-    with_local_io(|io| {\n-        match io.tty_open(fd, readable) {\n-            Ok(tty) => Some(f(TTY(tty))),\n-            Err(_) => Some(f(File(io.fs_from_raw_fd(fd, DontClose)))),\n+    let mut io = LocalIo::borrow();\n+    match io.get().tty_open(fd, readable) {\n+        Ok(tty) => f(TTY(tty)),\n+        Err(_) => {\n+            // It's not really that desirable if these handles are closed\n+            // synchronously, and because they're squirreled away in a task\n+            // structure the destructors will be run when the task is\n+            // attempted to get destroyed. This means that if we run a\n+            // synchronous destructor we'll attempt to do some scheduling\n+            // operations which will just result in sadness.\n+            f(File(io.get().fs_from_raw_fd(fd, DontClose)))\n         }\n-    }).unwrap()\n+    }\n }\n \n /// Creates a new non-blocking handle to the stdin of the current process."}, {"sha": "202e02d55d0e689f7c3012dcfe1d830ccfab3dd9", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -42,7 +42,7 @@ use comm::{Port, PortOne};\n use option::{Option, Some, None};\n use result::{Ok, Err};\n use io::io_error;\n-use rt::rtio::{IoFactory, RtioTimer, with_local_io};\n+use rt::rtio::{IoFactory, LocalIo, RtioTimer};\n \n pub struct Timer {\n     priv obj: ~RtioTimer\n@@ -60,17 +60,15 @@ impl Timer {\n     /// for a number of milliseconds, or to possibly create channels which will\n     /// get notified after an amount of time has passed.\n     pub fn new() -> Option<Timer> {\n-        with_local_io(|io| {\n-            match io.timer_init() {\n-                Ok(t) => Some(Timer { obj: t }),\n-                Err(ioerr) => {\n-                    debug!(\"Timer::init: failed to init: {:?}\", ioerr);\n-                    io_error::cond.raise(ioerr);\n-                    None\n-                }\n+        let mut io = LocalIo::borrow();\n+        match io.get().timer_init() {\n+            Ok(t) => Some(Timer { obj: t }),\n+            Err(ioerr) => {\n+                debug!(\"Timer::init: failed to init: {:?}\", ioerr);\n+                io_error::cond.raise(ioerr);\n+                None\n             }\n-\n-        })\n+        }\n     }\n \n     /// Blocks the current task for `msecs` milliseconds."}, {"sha": "bcd353bab7af189235616c6ffd8c3f42cd96cb79", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -1477,7 +1477,9 @@ mod tests {\n             assert!(*chunk.data == 0xbe);\n             close(fd);\n         }\n-        io::ignore_io_error(|| fs::unlink(&path));\n+\n+        let _guard = io::ignore_io_error();\n+        fs::unlink(&path);\n     }\n \n     // More recursive_mkdir tests are in extra::tempfile"}, {"sha": "fa47ceb1c045385b54517cf897f65597b41b348b", "filename": "src/libstd/rt/basic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbasic.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -159,8 +159,9 @@ impl EventLoop for BasicLoop {\n         ~BasicRemote::new(self.messages.clone(), id) as ~RemoteCallback\n     }\n \n-    fn io<'a>(&'a mut self, f: |&'a mut IoFactory|) {\n-        f(self.io)\n+    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory> {\n+        let factory: &mut IoFactory = self.io;\n+        Some(factory)\n     }\n }\n "}, {"sha": "82f92bdb803e4c46271493ba687dacc8b933db85", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use cell::Cell;\n use c_str::{ToCStr, CString};\n use libc::{c_char, size_t};\n use option::{Option, None, Some};\n@@ -35,7 +34,8 @@ pub struct BorrowRecord {\n }\n \n fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {\n-    Local::borrow(|task: &mut Task| task.borrow_list.take())\n+    let mut task = Local::borrow(None::<Task>);\n+    task.get().borrow_list.take()\n }\n \n fn swap_task_borrow_list(f: |~[BorrowRecord]| -> ~[BorrowRecord]) {\n@@ -44,8 +44,9 @@ fn swap_task_borrow_list(f: |~[BorrowRecord]| -> ~[BorrowRecord]) {\n         None => ~[]\n     };\n     let borrows = f(borrows);\n-    let borrows = Cell::new(borrows);\n-    Local::borrow(|task: &mut Task| task.borrow_list = Some(borrows.take()))\n+\n+    let mut task = Local::borrow(None::<Task>);\n+    task.get().borrow_list = Some(borrows)\n }\n \n pub fn clear_task_borrow_list() {"}, {"sha": "2b1e7865a735fe899102237848e2512d86a79075", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 29, "deletions": 54, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -25,7 +25,7 @@ use unstable::sync::UnsafeArc;\n use util;\n use util::Void;\n use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable, SendDeferred};\n-use cell::{Cell, RefCell};\n+use cell::RefCell;\n use clone::Clone;\n use tuple::ImmutableTuple;\n \n@@ -169,10 +169,8 @@ impl<T: Send> ChanOne<T> {\n                             Scheduler::run_task(woken_task);\n                         });\n                     } else {\n-                        let recvr = Cell::new(recvr);\n-                        Local::borrow(|sched: &mut Scheduler| {\n-                            sched.enqueue_blocked_task(recvr.take());\n-                        })\n+                        let mut sched = Local::borrow(None::<Scheduler>);\n+                        sched.get().enqueue_blocked_task(recvr);\n                     }\n                 }\n             }\n@@ -230,9 +228,8 @@ impl<T: Send> SelectInner for PortOne<T> {\n         // The optimistic check is never necessary for correctness. For testing\n         // purposes, making it randomly return false simulates a racing sender.\n         use rand::{Rand};\n-        let actually_check = Local::borrow(|sched: &mut Scheduler| {\n-            Rand::rand(&mut sched.rng)\n-        });\n+        let mut sched = Local::borrow(None::<Scheduler>);\n+        let actually_check = Rand::rand(&mut sched.get().rng);\n         if actually_check {\n             unsafe { (*self.packet()).state.load(Acquire) == STATE_ONE }\n         } else {\n@@ -568,7 +565,7 @@ impl<'self, T: Send> SelectPortInner<T> for &'self Port<T> {\n impl<'self, T: Send> SelectPort<T> for &'self Port<T> { }\n \n pub struct SharedChan<T> {\n-    // Just like Chan, but a shared AtomicOption instead of Cell\n+    // Just like Chan, but a shared AtomicOption\n     priv next: UnsafeArc<AtomicOption<StreamChanOne<T>>>\n }\n \n@@ -719,7 +716,6 @@ mod test {\n     use super::*;\n     use option::*;\n     use rt::test::*;\n-    use cell::Cell;\n     use num::Times;\n     use rt::util;\n \n@@ -843,9 +839,8 @@ mod test {\n     fn oneshot_multi_task_recv_then_send() {\n         do run_in_newsched_task {\n             let (port, chan) = oneshot::<~int>();\n-            let port_cell = Cell::new(port);\n             do spawntask {\n-                assert!(port_cell.take().recv() == ~10);\n+                assert!(port.recv() == ~10);\n             }\n \n             chan.send(~10);\n@@ -856,13 +851,11 @@ mod test {\n     fn oneshot_multi_task_recv_then_close() {\n         do run_in_newsched_task {\n             let (port, chan) = oneshot::<~int>();\n-            let port_cell = Cell::new(port);\n-            let chan_cell = Cell::new(chan);\n             do spawntask_later {\n-                let _cell = chan_cell.take();\n+                let _ = chan;\n             }\n             let res = do spawntask_try {\n-                assert!(port_cell.take().recv() == ~10);\n+                assert!(port.recv() == ~10);\n             };\n             assert!(res.is_err());\n         }\n@@ -874,9 +867,8 @@ mod test {\n         stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<int>();\n-                let port_cell = Cell::new(port);\n                 let thread = do spawntask_thread {\n-                    let _p = port_cell.take();\n+                    let _ = port;\n                 };\n                 let _chan = chan;\n                 thread.join();\n@@ -890,14 +882,11 @@ mod test {\n         stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<int>();\n-                let chan_cell = Cell::new(chan);\n-                let port_cell = Cell::new(port);\n                 let thread1 = do spawntask_thread {\n-                    let _p = port_cell.take();\n+                    let _ = port;\n                 };\n                 let thread2 = do spawntask_thread {\n-                    let c = chan_cell.take();\n-                    c.send(1);\n+                    chan.send(1);\n                 };\n                 thread1.join();\n                 thread2.join();\n@@ -911,19 +900,17 @@ mod test {\n         stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<int>();\n-                let chan_cell = Cell::new(chan);\n-                let port_cell = Cell::new(port);\n                 let thread1 = do spawntask_thread {\n-                    let port_cell = Cell::new(port_cell.take());\n+                    let port = port;\n                     let res = do spawntask_try {\n-                        port_cell.take().recv();\n+                        port.recv();\n                     };\n                     assert!(res.is_err());\n                 };\n                 let thread2 = do spawntask_thread {\n-                    let chan_cell = Cell::new(chan_cell.take());\n+                    let chan = chan;\n                     do spawntask {\n-                        chan_cell.take();\n+                        let _ = chan;\n                     }\n                 };\n                 thread1.join();\n@@ -938,13 +925,11 @@ mod test {\n         stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<~int>();\n-                let chan_cell = Cell::new(chan);\n-                let port_cell = Cell::new(port);\n                 let thread1 = do spawntask_thread {\n-                    chan_cell.take().send(~10);\n+                    chan.send(~10);\n                 };\n                 let thread2 = do spawntask_thread {\n-                    assert!(port_cell.take().recv() == ~10);\n+                    assert!(port.recv() == ~10);\n                 };\n                 thread1.join();\n                 thread2.join();\n@@ -965,9 +950,7 @@ mod test {\n                 fn send(chan: Chan<~int>, i: int) {\n                     if i == 10 { return }\n \n-                    let chan_cell = Cell::new(chan);\n                     do spawntask_random {\n-                        let chan = chan_cell.take();\n                         chan.send(~i);\n                         send(chan, i + 1);\n                     }\n@@ -976,9 +959,7 @@ mod test {\n                 fn recv(port: Port<~int>, i: int) {\n                     if i == 10 { return }\n \n-                    let port_cell = Cell::new(port);\n                     do spawntask_random {\n-                        let port = port_cell.take();\n                         assert!(port.recv() == ~i);\n                         recv(port, i + 1);\n                     };\n@@ -1131,7 +1112,7 @@ mod test {\n \n     #[test]\n     fn send_deferred() {\n-        use unstable::sync::atomically;\n+        use unstable::sync::atomic;\n \n         // Tests no-rescheduling of send_deferred on all types of channels.\n         do run_in_newsched_task {\n@@ -1141,24 +1122,18 @@ mod test {\n             let cshared = SharedChan::new(cshared);\n             let mp = megapipe();\n \n-            let pone = Cell::new(pone);\n-            do spawntask { pone.take().recv(); }\n-            let pstream = Cell::new(pstream);\n-            do spawntask { pstream.take().recv(); }\n-            let pshared = Cell::new(pshared);\n-            do spawntask { pshared.take().recv(); }\n-            let p_mp = Cell::new(mp.clone());\n-            do spawntask { p_mp.take().recv(); }\n+            do spawntask { pone.recv(); }\n+            do spawntask { pstream.recv(); }\n+            do spawntask { pshared.recv(); }\n+            let p_mp = mp.clone();\n+            do spawntask { p_mp.recv(); }\n \n-            let cs = Cell::new((cone, cstream, cshared, mp));\n             unsafe {\n-                atomically(|| {\n-                    let (cone, cstream, cshared, mp) = cs.take();\n-                    cone.send_deferred(());\n-                    cstream.send_deferred(());\n-                    cshared.send_deferred(());\n-                    mp.send_deferred(());\n-                })\n+                let _guard = atomic();\n+                cone.send_deferred(());\n+                cstream.send_deferred(());\n+                cshared.send_deferred(());\n+                mp.send_deferred(());\n             }\n         }\n     }"}, {"sha": "44672984b64baf5bb00e96fc7d4df418c857e0b7", "filename": "src/libstd/rt/deque.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fdeque.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -163,10 +163,9 @@ impl<T: Send> BufferPool<T> {\n \n     fn free(&mut self, buf: ~Buffer<T>) {\n         unsafe {\n-            use cell::Cell;\n-            let buf = Cell::new(buf);\n+            let mut buf = Some(buf);\n             self.pool.with(|pool| {\n-                let buf = buf.take();\n+                let buf = buf.take_unwrap();\n                 match pool.iter().position(|v| v.size() > buf.size()) {\n                     Some(i) => pool.insert(i, buf),\n                     None => pool.push(buf),"}, {"sha": "e3f9cd09632b39cd43172e1393b9e5e72e76f471", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -151,7 +151,6 @@ There are two known issues with the current scheme for exit code propagation.\n */\n \n use cast;\n-use cell::Cell;\n use option::{Option, Some, None};\n use prelude::*;\n use rt::task::Task;\n@@ -256,8 +255,10 @@ impl Death {\n \n     /// Collect failure exit codes from children and propagate them to a parent.\n     pub fn collect_failure(&mut self, result: UnwindResult) {\n-        let result = Cell::new(result);\n-        self.on_exit.take().map(|on_exit| on_exit(result.take()));\n+        match self.on_exit.take() {\n+            None => {}\n+            Some(on_exit) => on_exit(result),\n+        }\n     }\n \n     /// Enter a possibly-nested \"atomic\" section of code. Just for assertions."}, {"sha": "d73ad98a25b37ead1637d8d0b9b8343abb51672c", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -12,36 +12,28 @@ use option::{Option, Some, None};\n use rt::sched::Scheduler;\n use rt::task::Task;\n use rt::local_ptr;\n-use cell::Cell;\n \n-pub trait Local {\n+/// Encapsulates some task-local data.\n+pub trait Local<Borrowed> {\n     fn put(value: ~Self);\n     fn take() -> ~Self;\n     fn exists(unused_value: Option<Self>) -> bool;\n-    fn borrow<T>(f: |&mut Self| -> T) -> T;\n+    fn borrow(unused_value: Option<Self>) -> Borrowed;\n     unsafe fn unsafe_take() -> ~Self;\n     unsafe fn unsafe_borrow() -> *mut Self;\n     unsafe fn try_unsafe_borrow() -> Option<*mut Self>;\n }\n \n-impl Local for Task {\n+impl Local<local_ptr::Borrowed<Task>> for Task {\n     #[inline]\n     fn put(value: ~Task) { unsafe { local_ptr::put(value) } }\n     #[inline]\n     fn take() -> ~Task { unsafe { local_ptr::take() } }\n     fn exists(_: Option<Task>) -> bool { local_ptr::exists() }\n-    fn borrow<T>(f: |&mut Task| -> T) -> T {\n-        let mut res: Option<T> = None;\n-        let res_ptr: *mut Option<T> = &mut res;\n+    #[inline]\n+    fn borrow(_: Option<Task>) -> local_ptr::Borrowed<Task> {\n         unsafe {\n-            local_ptr::borrow(|task| {\n-                let result = f(task);\n-                *res_ptr = Some(result);\n-            })\n-        }\n-        match res {\n-            Some(r) => { r }\n-            None => { rtabort!(\"function failed in local_borrow\") }\n+            local_ptr::borrow::<Task>()\n         }\n     }\n     #[inline]\n@@ -54,13 +46,35 @@ impl Local for Task {\n     }\n }\n \n-impl Local for Scheduler {\n+/// Encapsulates a temporarily-borrowed scheduler.\n+pub struct BorrowedScheduler {\n+    priv task: local_ptr::Borrowed<Task>,\n+}\n+\n+impl BorrowedScheduler {\n+    fn new(mut task: local_ptr::Borrowed<Task>) -> BorrowedScheduler {\n+        if task.get().sched.is_none() {\n+            rtabort!(\"no scheduler\")\n+        } else {\n+            BorrowedScheduler {\n+                task: task,\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn get<'a>(&'a mut self) -> &'a mut ~Scheduler {\n+        match self.task.get().sched {\n+            None => rtabort!(\"no scheduler\"),\n+            Some(ref mut sched) => sched,\n+        }\n+    }\n+}\n+\n+impl Local<BorrowedScheduler> for Scheduler {\n     fn put(value: ~Scheduler) {\n-        let value = Cell::new(value);\n-        Local::borrow(|task: &mut Task| {\n-            let task = task;\n-            task.sched = Some(value.take());\n-        });\n+        let mut task = Local::borrow(None::<Task>);\n+        task.get().sched = Some(value);\n     }\n     #[inline]\n     fn take() -> ~Scheduler {\n@@ -71,24 +85,12 @@ impl Local for Scheduler {\n         }\n     }\n     fn exists(_: Option<Scheduler>) -> bool {\n-        Local::borrow(|task: &mut Task| {\n-            match task.sched {\n-                Some(ref _task) => true,\n-                None => false\n-            }\n-        })\n+        let mut task = Local::borrow(None::<Task>);\n+        task.get().sched.is_some()\n     }\n-    fn borrow<T>(f: |&mut Scheduler| -> T) -> T {\n-        Local::borrow(|task: &mut Task| {\n-            match task.sched {\n-                Some(~ref mut task) => {\n-                    f(task)\n-                }\n-                None => {\n-                    rtabort!(\"no scheduler\")\n-                }\n-            }\n-        })\n+    #[inline]\n+    fn borrow(_: Option<Scheduler>) -> BorrowedScheduler {\n+        BorrowedScheduler::new(Local::borrow(None::<Task>))\n     }\n     unsafe fn unsafe_take() -> ~Scheduler { rtabort!(\"unimpl\") }\n     unsafe fn unsafe_borrow() -> *mut Scheduler {\n@@ -182,11 +184,11 @@ mod test {\n             let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n             Local::put(task);\n \n-            let res = Local::borrow(|_task: &mut Task| {\n-                true\n-            });\n-            assert!(res)\n-                let task: ~Task = Local::take();\n+            {\n+                let _ = Local::borrow(None::<Task>);\n+            }\n+\n+            let task: ~Task = Local::take();\n             cleanup_task(task);\n         }\n     }"}, {"sha": "e364137de4572ad5dda80efb3fe4cd7036319a41", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -304,7 +304,8 @@ pub unsafe fn local_free(ptr: *libc::c_char) {\n }\n \n pub fn live_allocs() -> *mut Box {\n-    Local::borrow(|task: &mut Task| task.heap.live_allocs)\n+    let mut task = Local::borrow(None::<Task>);\n+    task.get().heap.live_allocs\n }\n \n #[cfg(test)]"}, {"sha": "66fe9742121ff49d2feee0a55aa4d930858cc7dc", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -18,8 +18,7 @@\n #[allow(dead_code)];\n \n use cast;\n-use cell::Cell;\n-use unstable::finally::Finally;\n+use ops::Drop;\n \n #[cfg(windows)]               // mingw-w32 doesn't like thread_local things\n #[cfg(target_os = \"android\")] // see #10686\n@@ -28,20 +27,48 @@ pub use self::native::*;\n #[cfg(not(windows), not(target_os = \"android\"))]\n pub use self::compiled::*;\n \n+/// Encapsulates a borrowed value. When this value goes out of scope, the\n+/// pointer is returned.\n+pub struct Borrowed<T> {\n+    priv val: *(),\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for Borrowed<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            if self.val.is_null() {\n+                rtabort!(\"Aiee, returning null borrowed object!\");\n+            }\n+            let val: ~T = cast::transmute(self.val);\n+            put::<T>(val);\n+            assert!(exists());\n+        }\n+    }\n+}\n+\n+impl<T> Borrowed<T> {\n+    pub fn get<'a>(&'a mut self) -> &'a mut T {\n+        unsafe {\n+            let val_ptr: &mut ~T = cast::transmute(&mut self.val);\n+            let val_ptr: &'a mut T = *val_ptr;\n+            val_ptr\n+        }\n+    }\n+}\n+\n /// Borrow the thread-local value from thread-local storage.\n /// While the value is borrowed it is not available in TLS.\n ///\n /// # Safety note\n ///\n /// Does not validate the pointer type.\n-pub unsafe fn borrow<T>(f: |&mut T|) {\n-    let mut value = take();\n-\n-    // XXX: Need a different abstraction from 'finally' here to avoid unsafety\n-    let unsafe_ptr = cast::transmute_mut_region(&mut *value);\n-    let value_cell = Cell::new(value);\n-\n-    (|| f(unsafe_ptr)).finally(|| put(value_cell.take()));\n+#[inline]\n+pub unsafe fn borrow<T>() -> Borrowed<T> {\n+    let val: *() = cast::transmute(take::<T>());\n+    Borrowed {\n+        val: val,\n+    }\n }\n \n /// Compiled implementation of accessing the runtime local pointer. This is"}, {"sha": "ce8d1ab1983a1fdf0c3b8f1d6b32b5d28465a2bf", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -57,7 +57,6 @@ Several modules in `core` are clients of `rt`:\n // XXX: this should not be here.\n #[allow(missing_doc)];\n \n-use cell::Cell;\n use clone::Clone;\n use container::Container;\n use iter::Iterator;\n@@ -274,7 +273,7 @@ fn run_(main: proc(), use_main_sched: bool) -> int {\n \n     let nscheds = util::default_sched_threads();\n \n-    let main = Cell::new(main);\n+    let mut main = Some(main);\n \n     // The shared list of sleeping schedulers.\n     let sleepers = SleeperList::new();\n@@ -376,34 +375,33 @@ fn run_(main: proc(), use_main_sched: bool) -> int {\n     };\n \n     let mut threads = ~[];\n-\n-    let on_exit = Cell::new(on_exit);\n+    let mut on_exit = Some(on_exit);\n \n     if !use_main_sched {\n \n         // In the case where we do not use a main_thread scheduler we\n         // run the main task in one of our threads.\n \n-        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool, None, main.take());\n+        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n+                                            None,\n+                                            ::util::replace(&mut main,\n+                                                            None).unwrap());\n         main_task.name = Some(SendStrStatic(\"<main>\"));\n-        main_task.death.on_exit = Some(on_exit.take());\n-        let main_task_cell = Cell::new(main_task);\n+        main_task.death.on_exit = ::util::replace(&mut on_exit, None);\n \n         let sched = scheds.pop();\n-        let sched_cell = Cell::new(sched);\n+        let main_task = main_task;\n         let thread = do Thread::start {\n-            let sched = sched_cell.take();\n-            sched.bootstrap(main_task_cell.take());\n+            sched.bootstrap(main_task);\n         };\n         threads.push(thread);\n     }\n \n     // Run each remaining scheduler in a thread.\n     for sched in scheds.move_rev_iter() {\n         rtdebug!(\"creating regular schedulers\");\n-        let sched_cell = Cell::new(sched);\n         let thread = do Thread::start {\n-            let mut sched = sched_cell.take();\n+            let mut sched = sched;\n             let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool, None) || {\n                 rtdebug!(\"boostraping a non-primary scheduler\");\n             };\n@@ -415,16 +413,19 @@ fn run_(main: proc(), use_main_sched: bool) -> int {\n     // If we do have a main thread scheduler, run it now.\n \n     if use_main_sched {\n-\n         rtdebug!(\"about to create the main scheduler task\");\n \n         let mut main_sched = main_sched.unwrap();\n \n         let home = Sched(main_sched.make_handle());\n-        let mut main_task = ~Task::new_root_homed(&mut main_sched.stack_pool, None,\n-                                                  home, main.take());\n+        let mut main_task = ~Task::new_root_homed(&mut main_sched.stack_pool,\n+                                                  None,\n+                                                  home,\n+                                                  ::util::replace(&mut main,\n+                                                                  None).\n+                                                                  unwrap());\n         main_task.name = Some(SendStrStatic(\"<main>\"));\n-        main_task.death.on_exit = Some(on_exit.take());\n+        main_task.death.on_exit = ::util::replace(&mut on_exit, None);\n         rtdebug!(\"bootstrapping main_task\");\n \n         main_sched.bootstrap(main_task);"}, {"sha": "05cc051a23e643758cd270b0214be41fa71f1657", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 55, "deletions": 23, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -9,15 +9,19 @@\n // except according to those terms.\n \n use c_str::CString;\n+use cast;\n use comm::{SharedChan, PortOne, Port};\n use libc::c_int;\n use libc;\n+use ops::Drop;\n use option::*;\n use path::Path;\n use result::*;\n \n use ai = io::net::addrinfo;\n use io::IoError;\n+use io::native::NATIVE_IO_FACTORY;\n+use io::native;\n use io::net::ip::{IpAddr, SocketAddr};\n use io::process::{ProcessConfig, ProcessExit};\n use io::signal::Signum;\n@@ -34,9 +38,8 @@ pub trait EventLoop {\n     fn pausible_idle_callback(&mut self, ~Callback) -> ~PausibleIdleCallback;\n     fn remote_callback(&mut self, ~Callback) -> ~RemoteCallback;\n \n-    /// The asynchronous I/O services. Not all event loops may provide one\n-    // FIXME(#9382) this is an awful interface\n-    fn io<'a>(&'a mut self, f: |&'a mut IoFactory|);\n+    /// The asynchronous I/O services. Not all event loops may provide one.\n+    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory>;\n }\n \n pub trait RemoteCallback {\n@@ -75,31 +78,60 @@ pub enum CloseBehavior {\n     CloseAsynchronously,\n }\n \n-pub fn with_local_io<T>(f: |&mut IoFactory| -> Option<T>) -> Option<T> {\n-    use rt::sched::Scheduler;\n-    use rt::local::Local;\n-    use io::native;\n-\n-    unsafe {\n-        // First, attempt to use the local scheduler's I/O services\n-        let sched: Option<*mut Scheduler> = Local::try_unsafe_borrow();\n-        match sched {\n-            Some(sched) => {\n-                let mut io = None;\n-                (*sched).event_loop.io(|i| io = Some(i));\n-                match io {\n-                    Some(io) => return f(io),\n-                    None => {}\n+pub struct LocalIo<'a> {\n+    priv factory: &'a mut IoFactory,\n+}\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for LocalIo<'a> {\n+    fn drop(&mut self) {\n+        // XXX(pcwalton): Do nothing here for now, but eventually we may want\n+        // something. For now this serves to make `LocalIo` noncopyable.\n+    }\n+}\n+\n+impl<'a> LocalIo<'a> {\n+    /// Returns the local I/O: either the local scheduler's I/O services or\n+    /// the native I/O services.\n+    pub fn borrow() -> LocalIo {\n+        use rt::sched::Scheduler;\n+        use rt::local::Local;\n+\n+        unsafe {\n+            // First, attempt to use the local scheduler's I/O services\n+            let sched: Option<*mut Scheduler> = Local::try_unsafe_borrow();\n+            match sched {\n+                Some(sched) => {\n+                    match (*sched).event_loop.io() {\n+                        Some(factory) => {\n+                            return LocalIo {\n+                                factory: factory,\n+                            }\n+                        }\n+                        None => {}\n+                    }\n                 }\n+                None => {}\n+            }\n+            // If we don't have a scheduler or the scheduler doesn't have I/O\n+            // services, then fall back to the native I/O services.\n+            let native_io: &'static mut native::IoFactory =\n+                &mut NATIVE_IO_FACTORY;\n+            LocalIo {\n+                factory: native_io as &mut IoFactory:'static\n             }\n-            None => {}\n         }\n     }\n \n-    // If we don't have a scheduler or the scheduler doesn't have I/O services,\n-    // then fall back to the native I/O services.\n-    let mut io = native::IoFactory;\n-    f(&mut io as &mut IoFactory)\n+    /// Returns the underlying I/O factory as a trait reference.\n+    #[inline]\n+    pub fn get<'a>(&'a mut self) -> &'a mut IoFactory {\n+        // XXX(pcwalton): I think this is actually sound? Could borrow check\n+        // allow this safely?\n+        unsafe {\n+            cast::transmute_copy(&self.factory)\n+        }\n+    }\n }\n \n pub trait IoFactory {"}, {"sha": "eefed4124663a1466ba54b2ef91780db7f31579f", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 29, "deletions": 47, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -24,7 +24,6 @@ use rt::local_ptr;\n use rt::local::Local;\n use rt::rtio::{RemoteCallback, PausibleIdleCallback, Callback};\n use borrow::{to_uint};\n-use cell::Cell;\n use rand::{XorShiftRng, Rng, Rand};\n use iter::range;\n use unstable::mutex::Mutex;\n@@ -235,12 +234,12 @@ impl Scheduler {\n         unsafe {\n             let event_loop: *mut ~EventLoop = &mut self.event_loop;\n \n-            // Our scheduler must be in the task before the event loop\n-            // is started.\n-            let self_sched = Cell::new(self);\n-            Local::borrow(|stask: &mut Task| {\n-                stask.sched = Some(self_sched.take());\n-            });\n+            {\n+                // Our scheduler must be in the task before the event loop\n+                // is started.\n+                let mut stask = Local::borrow(None::<Task>);\n+                stask.get().sched = Some(self);\n+            }\n \n             (*event_loop).run();\n         }\n@@ -751,10 +750,8 @@ impl Scheduler {\n     }\n \n     pub fn run_task_later(next_task: ~Task) {\n-        let next_task = Cell::new(next_task);\n-        Local::borrow(|sched: &mut Scheduler| {\n-            sched.enqueue_task(next_task.take());\n-        });\n+        let mut sched = Local::borrow(None::<Scheduler>);\n+        sched.get().enqueue_task(next_task);\n     }\n \n     /// Yield control to the scheduler, executing another task. This is guaranteed\n@@ -922,7 +919,6 @@ mod test {\n     use unstable::run_in_bare_thread;\n     use borrow::to_uint;\n     use rt::sched::{Scheduler};\n-    use cell::Cell;\n     use rt::deque::BufferPool;\n     use rt::thread::Thread;\n     use rt::task::{Task, Sched};\n@@ -1048,7 +1044,7 @@ mod test {\n                 queues.clone(),\n                 sleepers.clone());\n \n-            let normal_handle = Cell::new(normal_sched.make_handle());\n+            let normal_handle = normal_sched.make_handle();\n \n             let friend_handle = normal_sched.make_handle();\n \n@@ -1061,7 +1057,7 @@ mod test {\n                 false,\n                 Some(friend_handle));\n \n-            let special_handle = Cell::new(special_sched.make_handle());\n+            let special_handle = special_sched.make_handle();\n \n             let t1_handle = special_sched.make_handle();\n             let t4_handle = special_sched.make_handle();\n@@ -1092,54 +1088,44 @@ mod test {\n             };\n             rtdebug!(\"task4 id: **{}**\", borrow::to_uint(task4));\n \n-            let task1 = Cell::new(task1);\n-            let task2 = Cell::new(task2);\n-            let task3 = Cell::new(task3);\n-            let task4 = Cell::new(task4);\n-\n             // Signal from the special task that we are done.\n             let (port, chan) = oneshot::<()>();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             let normal_task = ~do Task::new_root(&mut normal_sched.stack_pool, None) {\n                 rtdebug!(\"*about to submit task2*\");\n-                Scheduler::run_task(task2.take());\n+                Scheduler::run_task(task2);\n                 rtdebug!(\"*about to submit task4*\");\n-                Scheduler::run_task(task4.take());\n+                Scheduler::run_task(task4);\n                 rtdebug!(\"*normal_task done*\");\n-                port.take().recv();\n-                let mut nh = normal_handle.take();\n+                port.recv();\n+                let mut nh = normal_handle;\n                 nh.send(Shutdown);\n-                let mut sh = special_handle.take();\n+                let mut sh = special_handle;\n                 sh.send(Shutdown);\n             };\n \n             rtdebug!(\"normal task: {}\", borrow::to_uint(normal_task));\n \n             let special_task = ~do Task::new_root(&mut special_sched.stack_pool, None) {\n                 rtdebug!(\"*about to submit task1*\");\n-                Scheduler::run_task(task1.take());\n+                Scheduler::run_task(task1);\n                 rtdebug!(\"*about to submit task3*\");\n-                Scheduler::run_task(task3.take());\n+                Scheduler::run_task(task3);\n                 rtdebug!(\"*done with special_task*\");\n-                chan.take().send(());\n+                chan.send(());\n             };\n \n             rtdebug!(\"special task: {}\", borrow::to_uint(special_task));\n \n-            let special_sched = Cell::new(special_sched);\n-            let normal_sched = Cell::new(normal_sched);\n-            let special_task = Cell::new(special_task);\n-            let normal_task = Cell::new(normal_task);\n-\n+            let normal_sched = normal_sched;\n             let normal_thread = do Thread::start {\n-                normal_sched.take().bootstrap(normal_task.take());\n+                normal_sched.bootstrap(normal_task);\n                 rtdebug!(\"finished with normal_thread\");\n             };\n \n+            let special_sched = special_sched;\n             let special_thread = do Thread::start {\n-                special_sched.take().bootstrap(special_task.take());\n+                special_sched.bootstrap(special_task);\n                 rtdebug!(\"finished with special_sched\");\n             };\n \n@@ -1178,20 +1164,18 @@ mod test {\n \n         do run_in_bare_thread {\n             let (port, chan) = oneshot::<()>();\n-            let port = Cell::new(port);\n-            let chan = Cell::new(chan);\n \n             let thread_one = do Thread::start {\n-                let chan = Cell::new(chan.take());\n+                let chan = chan;\n                 do run_in_newsched_task_core {\n-                    chan.take().send(());\n+                    chan.send(());\n                 }\n             };\n \n             let thread_two = do Thread::start {\n-                let port = Cell::new(port.take());\n+                let port = port;\n                 do run_in_newsched_task_core {\n-                    port.take().recv();\n+                    port.recv();\n                 }\n             };\n \n@@ -1222,10 +1206,9 @@ mod test {\n \n                 let mut handle = sched.make_handle();\n \n-                let sched = Cell::new(sched);\n-\n+                let sched = sched;\n                 let thread = do Thread::start {\n-                    let mut sched = sched.take();\n+                    let mut sched = sched;\n                     let bootstrap_task =\n                         ~Task::new_root(&mut sched.stack_pool,\n                                         None,\n@@ -1256,9 +1239,8 @@ mod test {\n             let mut ports = ~[];\n             10.times(|| {\n                 let (port, chan) = oneshot();\n-                let chan_cell = Cell::new(chan);\n                 do spawntask_later {\n-                    chan_cell.take().send(());\n+                    chan.send(());\n                 }\n                 ports.push(port);\n             });"}, {"sha": "86cc895eb27dbd1a16b023ececd93af3eb5edd0d", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 54, "deletions": 57, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -19,7 +19,6 @@ use prelude::*;\n \n use borrow;\n use cast::transmute;\n-use cell::Cell;\n use cleanup;\n use libc::{c_void, uintptr_t, c_char, size_t};\n use local_data;\n@@ -144,17 +143,15 @@ impl Task {\n                              f: proc(),\n                              home: SchedHome)\n                              -> ~Task {\n-        let f = Cell::new(f);\n-        let home = Cell::new(home);\n-        Local::borrow(|running_task: &mut Task| {\n-            let mut sched = running_task.sched.take_unwrap();\n-            let new_task = ~running_task.new_child_homed(&mut sched.stack_pool,\n-                                                         stack_size,\n-                                                         home.take(),\n-                                                         f.take());\n-            running_task.sched = Some(sched);\n-            new_task\n-        })\n+        let mut running_task = Local::borrow(None::<Task>);\n+        let mut sched = running_task.get().sched.take_unwrap();\n+        let new_task = ~running_task.get()\n+                                    .new_child_homed(&mut sched.stack_pool,\n+                                                     stack_size,\n+                                                     home,\n+                                                     f);\n+        running_task.get().sched = Some(sched);\n+        new_task\n     }\n \n     pub fn build_child(stack_size: Option<uint>, f: proc()) -> ~Task {\n@@ -165,17 +162,14 @@ impl Task {\n                             f: proc(),\n                             home: SchedHome)\n                             -> ~Task {\n-        let f = Cell::new(f);\n-        let home = Cell::new(home);\n-        Local::borrow(|running_task: &mut Task| {\n-            let mut sched = running_task.sched.take_unwrap();\n-            let new_task = ~Task::new_root_homed(&mut sched.stack_pool,\n-                                                 stack_size,\n-                                                 home.take(),\n-                                                 f.take());\n-            running_task.sched = Some(sched);\n-            new_task\n-        })\n+        let mut running_task = Local::borrow(None::<Task>);\n+        let mut sched = running_task.get().sched.take_unwrap();\n+        let new_task = ~Task::new_root_homed(&mut sched.stack_pool,\n+                                             stack_size,\n+                                             home,\n+                                             f);\n+        running_task.get().sched = Some(sched);\n+        new_task\n     }\n \n     pub fn build_root(stack_size: Option<uint>, f: proc()) -> ~Task {\n@@ -371,26 +365,25 @@ impl Task {\n     // Grab both the scheduler and the task from TLS and check if the\n     // task is executing on an appropriate scheduler.\n     pub fn on_appropriate_sched() -> bool {\n-        Local::borrow(|task: &mut Task| {\n-            let sched_id = task.sched.get_ref().sched_id();\n-            let sched_run_anything = task.sched.get_ref().run_anything;\n-            match task.task_type {\n-                GreenTask(Some(AnySched)) => {\n-                    rtdebug!(\"anysched task in sched check ****\");\n-                    sched_run_anything\n-                }\n-                GreenTask(Some(Sched(SchedHandle { sched_id: ref id, ..}))) => {\n-                    rtdebug!(\"homed task in sched check ****\");\n-                    *id == sched_id\n-                }\n-                GreenTask(None) => {\n-                    rtabort!(\"task without home\");\n-                }\n-                SchedTask => {\n-                    rtabort!(\"type error: expected: GreenTask, found: SchedTask\");\n-                }\n+        let mut task = Local::borrow(None::<Task>);\n+        let sched_id = task.get().sched.get_ref().sched_id();\n+        let sched_run_anything = task.get().sched.get_ref().run_anything;\n+        match task.get().task_type {\n+            GreenTask(Some(AnySched)) => {\n+                rtdebug!(\"anysched task in sched check ****\");\n+                sched_run_anything\n+            }\n+            GreenTask(Some(Sched(SchedHandle { sched_id: ref id, ..}))) => {\n+                rtdebug!(\"homed task in sched check ****\");\n+                *id == sched_id\n+            }\n+            GreenTask(None) => {\n+                rtabort!(\"task without home\");\n             }\n-        })\n+            SchedTask => {\n+                rtabort!(\"type error: expected: GreenTask, found: SchedTask\");\n+            }\n+        }\n     }\n }\n \n@@ -433,16 +426,16 @@ impl Coroutine {\n     }\n \n     fn build_start_wrapper(start: proc()) -> proc() {\n-        let start_cell = Cell::new(start);\n         let wrapper: proc() = proc() {\n             // First code after swap to this new context. Run our\n             // cleanup job.\n             unsafe {\n \n                 // Again - might work while safe, or it might not.\n-                Local::borrow(|sched: &mut Scheduler| {\n-                    sched.run_cleanup_job();\n-                });\n+                {\n+                    let mut sched = Local::borrow(None::<Scheduler>);\n+                    sched.get().run_cleanup_job();\n+                }\n \n                 // To call the run method on a task we need a direct\n                 // reference to it. The task is in TLS, so we can\n@@ -451,6 +444,7 @@ impl Coroutine {\n                 // need to unsafe_borrow.\n                 let task: *mut Task = Local::unsafe_borrow();\n \n+                let mut start_cell = Some(start);\n                 (*task).run(|| {\n                     // N.B. Removing `start` from the start wrapper\n                     // closure by emptying a cell is critical for\n@@ -462,7 +456,7 @@ impl Coroutine {\n                     // be in task context. By moving `start` out of\n                     // the closure, all the user code goes our of\n                     // scope while the task is still running.\n-                    let start = start_cell.take();\n+                    let start = start_cell.take_unwrap();\n                     start();\n                 });\n             }\n@@ -594,16 +588,19 @@ pub extern \"C\" fn rust_stack_exhausted() {\n         //  #2361 - possible implementation of not using landing pads\n \n         if in_green_task_context() {\n-            Local::borrow(|task: &mut Task| {\n-                let n = task.name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n-\n-                // See the message below for why this is not emitted to the\n-                // task's logger. This has the additional conundrum of the\n-                // logger may not be initialized just yet, meaning that an FFI\n-                // call would happen to initialized it (calling out to libuv),\n-                // and the FFI call needs 2MB of stack when we just ran out.\n-                rterrln!(\"task '{}' has overflowed its stack\", n);\n-            })\n+            let mut task = Local::borrow(None::<Task>);\n+            let n = task.get()\n+                        .name\n+                        .as_ref()\n+                        .map(|n| n.as_slice())\n+                        .unwrap_or(\"<unnamed>\");\n+\n+            // See the message below for why this is not emitted to the\n+            // task's logger. This has the additional conundrum of the\n+            // logger may not be initialized just yet, meaning that an FFI\n+            // call would happen to initialized it (calling out to libuv),\n+            // and the FFI call needs 2MB of stack when we just ran out.\n+            rterrln!(\"task '{}' has overflowed its stack\", n);\n         } else {\n             rterrln!(\"stack overflow in non-task context\");\n         }"}, {"sha": "96b80d1112915cf0484578aae1bc991f3dbac4bd", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -10,7 +10,6 @@\n \n use io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n \n-use cell::Cell;\n use clone::Clone;\n use container::Container;\n use iter::{Iterator, range};\n@@ -65,16 +64,14 @@ pub fn new_test_sched() -> Scheduler {\n }\n \n pub fn run_in_uv_task(f: proc()) {\n-    let f = Cell::new(f);\n     do run_in_bare_thread {\n-        run_in_uv_task_core(f.take());\n+        run_in_uv_task_core(f);\n     }\n }\n \n pub fn run_in_newsched_task(f: proc()) {\n-    let f = Cell::new(f);\n     do run_in_bare_thread {\n-        run_in_newsched_task_core(f.take());\n+        run_in_newsched_task_core(f);\n     }\n }\n \n@@ -206,8 +203,6 @@ pub fn run_in_mt_newsched_task(f: proc()) {\n     // see comment in other function (raising fd limits)\n     prepare_for_lots_of_tests();\n \n-    let f = Cell::new(f);\n-\n     do run_in_bare_thread {\n         let nthreads = match os::getenv(\"RUST_RT_TEST_THREADS\") {\n             Some(nstr) => FromStr::from_str(nstr).unwrap(),\n@@ -254,18 +249,18 @@ pub fn run_in_mt_newsched_task(f: proc()) {\n \n             rtassert!(exit_status.is_success());\n         };\n-        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool, None, f.take());\n+        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n+                                            None,\n+                                            f);\n         main_task.death.on_exit = Some(on_exit);\n \n         let mut threads = ~[];\n-        let main_task = Cell::new(main_task);\n \n         let main_thread = {\n             let sched = scheds.pop();\n-            let sched_cell = Cell::new(sched);\n+            let main_task = main_task;\n             do Thread::start {\n-                let sched = sched_cell.take();\n-                sched.bootstrap(main_task.take());\n+                sched.bootstrap(main_task);\n             }\n         };\n         threads.push(main_thread);\n@@ -275,11 +270,9 @@ pub fn run_in_mt_newsched_task(f: proc()) {\n             let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool, None) || {\n                 rtdebug!(\"bootstrapping non-primary scheduler\");\n             };\n-            let bootstrap_task_cell = Cell::new(bootstrap_task);\n-            let sched_cell = Cell::new(sched);\n+            let sched = sched;\n             let thread = do Thread::start {\n-                let sched = sched_cell.take();\n-                sched.bootstrap(bootstrap_task_cell.take());\n+                sched.bootstrap(bootstrap_task);\n             };\n \n             threads.push(thread);\n@@ -335,11 +328,8 @@ pub fn spawntask_try(f: proc()) -> Result<(),()> {\n \n /// Spawn a new task in a new scheduler and return a thread handle.\n pub fn spawntask_thread(f: proc()) -> Thread<()> {\n-\n-    let f = Cell::new(f);\n-\n     let thread = do Thread::start {\n-        run_in_newsched_task_core(f.take());\n+        run_in_newsched_task_core(f);\n     };\n \n     return thread;"}, {"sha": "5e867bcdfbac6655649f871650f2d777365ea082", "filename": "src/libstd/rt/tube.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftube.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -88,7 +88,6 @@ impl<T> Clone for Tube<T> {\n \n #[cfg(test)]\n mod test {\n-    use cell::Cell;\n     use rt::test::*;\n     use rt::rtio::EventLoop;\n     use rt::sched::Scheduler;\n@@ -100,11 +99,10 @@ mod test {\n     fn simple_test() {\n         do run_in_newsched_task {\n             let mut tube: Tube<int> = Tube::new();\n-            let tube_clone = tube.clone();\n-            let tube_clone_cell = Cell::new(tube_clone);\n+            let mut tube_clone = Some(tube.clone());\n             let sched: ~Scheduler = Local::take();\n             sched.deschedule_running_task_and_then(|sched, task| {\n-                let mut tube_clone = tube_clone_cell.take();\n+                let mut tube_clone = tube_clone.take_unwrap();\n                 tube_clone.send(1);\n                 sched.enqueue_blocked_task(task);\n             });\n@@ -117,13 +115,12 @@ mod test {\n     fn blocking_test() {\n         do run_in_newsched_task {\n             let mut tube: Tube<int> = Tube::new();\n-            let tube_clone = tube.clone();\n-            let tube_clone = Cell::new(tube_clone);\n+            let mut tube_clone = Some(tube.clone());\n             let sched: ~Scheduler = Local::take();\n             sched.deschedule_running_task_and_then(|sched, task| {\n-                let tube_clone = Cell::new(tube_clone.take());\n+                let tube_clone = tube_clone.take_unwrap();\n                 do sched.event_loop.callback {\n-                    let mut tube_clone = tube_clone.take();\n+                    let mut tube_clone = tube_clone;\n                     // The task should be blocked on this now and\n                     // sending will wake it up.\n                     tube_clone.send(1);\n@@ -141,26 +138,24 @@ mod test {\n \n         do run_in_newsched_task {\n             let mut tube: Tube<int> = Tube::new();\n-            let tube_clone = tube.clone();\n-            let tube_clone = Cell::new(tube_clone);\n+            let mut tube_clone = Some(tube.clone());\n             let sched: ~Scheduler = Local::take();\n             sched.deschedule_running_task_and_then(|sched, task| {\n-                callback_send(tube_clone.take(), 0);\n+                callback_send(tube_clone.take_unwrap(), 0);\n \n                 fn callback_send(tube: Tube<int>, i: int) {\n-                    if i == 100 { return; }\n-\n-                    let tube = Cell::new(Cell::new(tube));\n-                    Local::borrow(|sched: &mut Scheduler| {\n-                        let tube = tube.take();\n-                        do sched.event_loop.callback {\n-                            let mut tube = tube.take();\n-                            // The task should be blocked on this now and\n-                            // sending will wake it up.\n-                            tube.send(i);\n-                            callback_send(tube, i + 1);\n-                        }\n-                    })\n+                    if i == 100 {\n+                        return\n+                    }\n+\n+                    let mut sched = Local::borrow(None::<Scheduler>);\n+                    do sched.get().event_loop.callback {\n+                        let mut tube = tube;\n+                        // The task should be blocked on this now and\n+                        // sending will wake it up.\n+                        tube.send(i);\n+                        callback_send(tube, i + 1);\n+                    }\n                 }\n \n                 sched.enqueue_blocked_task(task);"}, {"sha": "f4c6cdbd934ab0bea48bdb49e8b65139b289a54d", "filename": "src/libstd/run.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -12,7 +12,6 @@\n \n #[allow(missing_doc)];\n \n-use cell::Cell;\n use comm::{stream, SharedChan};\n use io::Reader;\n use io::process::ProcessExit;\n@@ -212,8 +211,8 @@ impl Process {\n      */\n     pub fn finish_with_output(&mut self) -> ProcessOutput {\n         self.close_input();\n-        let output = Cell::new(self.inner.io[1].take());\n-        let error = Cell::new(self.inner.io[2].take());\n+        let output = self.inner.io[1].take();\n+        let error = self.inner.io[2].take();\n \n         // Spawn two entire schedulers to read both stdout and sterr\n         // in parallel so we don't deadlock while blocking on one\n@@ -224,20 +223,20 @@ impl Process {\n         let ch_clone = ch.clone();\n \n         do spawn {\n-            io::ignore_io_error(|| {\n-                match error.take() {\n-                    Some(ref mut e) => ch.send((2, e.read_to_end())),\n-                    None => ch.send((2, ~[]))\n-                }\n-            })\n+            let _guard = io::ignore_io_error();\n+            let mut error = error;\n+            match error {\n+                Some(ref mut e) => ch.send((2, e.read_to_end())),\n+                None => ch.send((2, ~[]))\n+            }\n         }\n         do spawn {\n-            io::ignore_io_error(|| {\n-                match output.take() {\n-                    Some(ref mut e) => ch_clone.send((1, e.read_to_end())),\n-                    None => ch_clone.send((1, ~[]))\n-                }\n-            })\n+            let _guard = io::ignore_io_error();\n+            let mut output = output;\n+            match output {\n+                Some(ref mut e) => ch_clone.send((1, e.read_to_end())),\n+                None => ch_clone.send((1, ~[]))\n+            }\n         }\n \n         let status = self.finish();"}, {"sha": "01b953051dbd33156c3260d3557682efc58afc2d", "filename": "src/libstd/select.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -10,18 +10,16 @@\n \n #[allow(missing_doc)];\n \n-use cell::Cell;\n use comm;\n use container::Container;\n use iter::{Iterator, DoubleEndedIterator};\n+use kinds::Send;\n+use ops::Drop;\n use option::*;\n-// use either::{Either, Left, Right};\n-// use rt::kill::BlockedTask;\n use rt::local::Local;\n use rt::rtio::EventLoop;\n use rt::sched::Scheduler;\n use rt::shouldnt_be_public::{SelectInner, SelectPortInner};\n-use unstable::finally::Finally;\n use vec::{OwnedVector, MutableVector};\n \n /// Trait for message-passing primitives that can be select()ed on.\n@@ -32,6 +30,18 @@ pub trait Select : SelectInner { }\n // that implement Select on different types to use select().)\n pub trait SelectPort<T> : SelectPortInner<T> { }\n \n+/// A helper type that throws away a value on a port.\n+struct PortGuard<T> {\n+    port: Option<comm::PortOne<T>>,\n+}\n+\n+#[unsafe_destructor]\n+impl<T:Send> Drop for PortGuard<T> {\n+    fn drop(&mut self) {\n+        let _ = self.port.take_unwrap().recv();\n+    }\n+}\n+\n /// Receive a message from any one of many ports at once. Returns the index of the\n /// port whose data is ready. (If multiple are ready, returns the lowest index.)\n pub fn select<A: Select>(ports: &mut [A]) -> uint {\n@@ -56,11 +66,13 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n     // after letting the task get woken up. The and_then closure needs to delay\n     // the task from resuming until all ports have become blocked_on.\n     let (p,c) = comm::oneshot();\n-    let p = Cell::new(p);\n-    let c = Cell::new(c);\n \n-    (|| {\n-        let c = Cell::new(c.take());\n+    {\n+        let _guard = PortGuard {\n+            port: Some(p),\n+        };\n+\n+        let mut c = Some(c);\n         let sched: ~Scheduler = Local::take();\n         sched.deschedule_running_task_and_then(|sched, task| {\n             let task_handles = task.make_selectable(ports.len());\n@@ -74,15 +86,12 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n                 }\n             }\n \n-            let c = Cell::new(c.take());\n-            do sched.event_loop.callback { c.take().send_deferred(()) }\n+            let c = c.take_unwrap();\n+            do sched.event_loop.callback {\n+                c.send_deferred(())\n+            }\n         })\n-    }).finally(|| {\n-        // Unkillable is necessary not because getting killed is dangerous here,\n-        // but to force the recv not to use the same kill-flag that we used for\n-        // selecting. Otherwise a user-sender could spuriously wakeup us here.\n-        p.take().recv();\n-    });\n+    }\n \n     // Task resumes. Now unblock ourselves from all the ports we blocked on.\n     // If the success index wasn't reset, 'take' will just take all of them.\n@@ -133,7 +142,6 @@ mod test {\n     use vec::*;\n     use comm::GenericChan;\n     use task;\n-    use cell::Cell;\n     use iter::{Iterator, range};\n \n     #[test] #[should_fail]\n@@ -246,9 +254,7 @@ mod test {\n             let (p3,c3) = oneshot();\n             let (p4,c4) = oneshot();\n \n-            let x = Cell::new((c2, p3, c4));\n             do task::spawn {\n-                let (c2, p3, c4) = x.take();\n                 p3.recv();   // handshake parent\n                 c4.send(()); // normal receive\n                 task::deschedule();\n@@ -284,10 +290,9 @@ mod test {\n                             let (p,c) = oneshot();\n                             ports.push(p);\n                             if send_on_chans.contains(&i) {\n-                                let c = Cell::new(c);\n                                 do spawntask_random {\n                                     task::deschedule();\n-                                    c.take().send(());\n+                                    c.send(());\n                                 }\n                             }\n                         }"}, {"sha": "24a24f2481887f600067e4af6cd947744a617538", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -55,7 +55,6 @@\n \n use prelude::*;\n \n-use cell::Cell;\n use comm::{stream, Chan, GenericChan, GenericPort, Port, Peekable};\n use result::{Result, Ok, Err};\n use rt::in_green_task_context;\n@@ -284,10 +283,8 @@ impl TaskBuilder {\n                 f\n             }\n         };\n-        let prev_gen_body = Cell::new(prev_gen_body);\n         let next_gen_body = {\n             let f: proc(proc()) -> proc() = proc(body) {\n-                let prev_gen_body = prev_gen_body.take();\n                 wrapper(prev_gen_body(body))\n             };\n             f\n@@ -432,12 +429,11 @@ pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n     use rt::task::Task;\n \n     if in_green_task_context() {\n-        Local::borrow(|task: &mut Task| {\n-            match task.name {\n-                Some(ref name) => blk(Some(name.as_slice())),\n-                None => blk(None)\n-            }\n-        })\n+        let mut task = Local::borrow(None::<Task>);\n+        match task.get().name {\n+            Some(ref name) => blk(Some(name.as_slice())),\n+            None => blk(None)\n+        }\n     } else {\n         fail!(\"no task name exists in non-green task context\")\n     }\n@@ -459,7 +455,8 @@ pub fn failing() -> bool {\n \n     use rt::task::Task;\n \n-    Local::borrow(|local: &mut Task| local.unwinder.unwinding)\n+    let mut local = Local::borrow(None::<Task>);\n+    local.get().unwinder.unwinding\n }\n \n // The following 8 tests test the following 2^3 combinations:\n@@ -548,11 +545,9 @@ struct Wrapper {\n fn test_add_wrapper() {\n     let (po, ch) = stream::<()>();\n     let mut b0 = task();\n-    let ch = Cell::new(ch);\n     do b0.add_wrapper |body| {\n-        let ch = Cell::new(ch.take());\n+        let ch = ch;\n         let result: proc() = proc() {\n-            let ch = ch.take();\n             body();\n             ch.send(());\n         };\n@@ -606,9 +601,9 @@ fn test_try_fail() {\n \n #[cfg(test)]\n fn get_sched_id() -> int {\n-    Local::borrow(|sched: &mut ::rt::sched::Scheduler| {\n-        sched.sched_id() as int\n-    })\n+    use rt::sched::Scheduler;\n+    let mut sched = Local::borrow(None::<Scheduler>);\n+    sched.get().sched_id() as int\n }\n \n #[test]\n@@ -642,12 +637,10 @@ fn test_spawn_sched_childs_on_default_sched() {\n     // Assuming tests run on the default scheduler\n     let default_id = get_sched_id();\n \n-    let ch = Cell::new(ch);\n     do spawn_sched(SingleThreaded) {\n         let parent_sched_id = get_sched_id();\n-        let ch = Cell::new(ch.take());\n+        let ch = ch;\n         do spawn {\n-            let ch = ch.take();\n             let child_sched_id = get_sched_id();\n             assert!(parent_sched_id != child_sched_id);\n             assert_eq!(child_sched_id, default_id);\n@@ -671,10 +664,10 @@ fn test_spawn_sched_blocking() {\n             let (fin_po, fin_ch) = stream();\n \n             let mut lock = Mutex::new();\n-            let lock2 = Cell::new(lock.clone());\n+            let lock2 = lock.clone();\n \n             do spawn_sched(SingleThreaded) {\n-                let mut lock = lock2.take();\n+                let mut lock = lock2;\n                 lock.lock();\n \n                 start_ch.send(());"}, {"sha": "4ab7b74d300687b647ee5b9aa0abdd4f6f14a738", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -77,7 +77,6 @@\n \n use prelude::*;\n \n-use cell::Cell;\n use comm::{GenericChan, oneshot};\n use rt::local::Local;\n use rt::sched::{Scheduler, Shutdown, TaskFromFriend};\n@@ -134,23 +133,19 @@ pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n             // Create a task that will later be used to join with the new scheduler\n             // thread when it is ready to terminate\n             let (thread_port, thread_chan) = oneshot();\n-            let thread_port_cell = Cell::new(thread_port);\n             let join_task = do Task::build_child(None) {\n                 debug!(\"running join task\");\n-                let thread_port = thread_port_cell.take();\n                 let thread: Thread<()> = thread_port.recv();\n                 thread.join();\n             };\n \n             // Put the scheduler into another thread\n-            let new_sched_cell = Cell::new(new_sched);\n-            let orig_sched_handle_cell = Cell::new((*sched).make_handle());\n-            let join_task_cell = Cell::new(join_task);\n+            let orig_sched_handle = (*sched).make_handle();\n \n+            let new_sched = new_sched;\n             let thread = do Thread::start {\n-                let mut new_sched = new_sched_cell.take();\n-                let mut orig_sched_handle = orig_sched_handle_cell.take();\n-                let join_task = join_task_cell.take();\n+                let mut new_sched = new_sched;\n+                let mut orig_sched_handle = orig_sched_handle;\n \n                 let bootstrap_task = ~do Task::new_root(&mut new_sched.stack_pool, None) || {\n                     debug!(\"boostrapping a 1:1 scheduler\");\n@@ -178,9 +173,8 @@ pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n \n     if opts.notify_chan.is_some() {\n         let notify_chan = opts.notify_chan.take_unwrap();\n-        let notify_chan = Cell::new(notify_chan);\n         let on_exit: proc(UnwindResult) = proc(task_result) {\n-            notify_chan.take().send(task_result)\n+            notify_chan.send(task_result)\n         };\n         task.death.on_exit = Some(on_exit);\n     }"}, {"sha": "42a696eaf7ea7a88883857853b8a23a8e3737428", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -140,7 +140,7 @@ pub mod dl {\n     use path;\n     use ptr;\n     use str;\n-    use unstable::sync::atomically;\n+    use unstable::sync::atomic;\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n@@ -158,25 +158,24 @@ pub mod dl {\n         static mut lock: Mutex = MUTEX_INIT;\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n-            // sequence. `atomically` asserts that we don't do anything that\n+            // sequence. `atomic` asserts that we don't do anything that\n             // would cause this task to be descheduled, which could deadlock\n             // the scheduler if it happens while the lock is held.\n             // FIXME #9105 use a Rust mutex instead of C++ mutexes.\n-            atomically(|| {\n-                lock.lock();\n-                let _old_error = dlerror();\n-\n-                let result = f();\n-\n-                let last_error = dlerror();\n-                let ret = if ptr::null() == last_error {\n-                    Ok(result)\n-                } else {\n-                    Err(str::raw::from_c_str(last_error))\n-                };\n-                lock.unlock();\n-                ret\n-            })\n+            let _guard = atomic();\n+            lock.lock();\n+            let _old_error = dlerror();\n+\n+            let result = f();\n+\n+            let last_error = dlerror();\n+            let ret = if ptr::null() == last_error {\n+                Ok(result)\n+            } else {\n+                Err(str::raw::from_c_str(last_error))\n+            };\n+            lock.unlock();\n+            ret\n         }\n     }\n \n@@ -209,7 +208,7 @@ pub mod dl {\n     use libc;\n     use path;\n     use ptr;\n-    use unstable::sync::atomically;\n+    use unstable::sync::atomic;\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n@@ -226,18 +225,17 @@ pub mod dl {\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {\n         unsafe {\n-            atomically(|| {\n-                SetLastError(0);\n+            let _guard = atomic();\n+            SetLastError(0);\n \n-                let result = f();\n+            let result = f();\n \n-                let error = os::errno();\n-                if 0 == error {\n-                    Ok(result)\n-                } else {\n-                    Err(format!(\"Error code {}\", error))\n-                }\n-            })\n+            let error = os::errno();\n+            if 0 == error {\n+                Ok(result)\n+            } else {\n+                Err(format!(\"Error code {}\", error))\n+            }\n         }\n     }\n "}, {"sha": "f8e2ea54f44f943d7f849218d342ad100b973aee", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -37,15 +37,13 @@ The executing thread has no access to a task pointer and will be using\n a normal large stack.\n */\n pub fn run_in_bare_thread(f: proc()) {\n-    use cell::Cell;\n     use rt::thread::Thread;\n \n-    let f_cell = Cell::new(f);\n     let (port, chan) = comm::stream();\n     // FIXME #4525: Unfortunate that this creates an extra scheduler but it's\n     // necessary since rust_raw_thread_join is blocking\n     do task::spawn_sched(task::SingleThreaded) {\n-        Thread::start(f_cell.take()).join();\n+        Thread::start(f).join();\n         chan.send(());\n     }\n     port.recv();"}, {"sha": "2dd5515bdbc8e75ada0505975f7a0b721b7ed5d4", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 87, "deletions": 42, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -9,13 +9,11 @@\n // except according to those terms.\n \n use cast;\n-use cell::Cell;\n use comm;\n use ptr;\n use option::{Option,Some,None};\n use task;\n use unstable::atomics::{AtomicOption,AtomicUint,Acquire,Release,Relaxed,SeqCst};\n-use unstable::finally::Finally;\n use unstable::mutex::Mutex;\n use ops::Drop;\n use clone::Clone;\n@@ -70,6 +68,35 @@ unsafe fn new_inner<T: Send>(data: T, refcount: uint) -> *mut ArcData<T> {\n     cast::transmute(data)\n }\n \n+/// A helper object used by `UnsafeArc::unwrap`.\n+struct ChannelAndDataGuard<T> {\n+    channel: Option<comm::ChanOne<bool>>,\n+    data: Option<~ArcData<T>>,\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for ChannelAndDataGuard<T> {\n+    fn drop(&mut self) {\n+        if task::failing() {\n+            // Killed during wait. Because this might happen while\n+            // someone else still holds a reference, we can't free\n+            // the data now; the \"other\" last refcount will free it.\n+            unsafe {\n+                let channel = self.channel.take_unwrap();\n+                let data = self.data.take_unwrap();\n+                channel.send(false);\n+                cast::forget(data);\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> ChannelAndDataGuard<T> {\n+    fn unwrap(mut self) -> (comm::ChanOne<bool>, ~ArcData<T>) {\n+        (self.channel.take_unwrap(), self.data.take_unwrap())\n+    }\n+}\n+\n impl<T: Send> UnsafeArc<T> {\n     pub fn new(data: T) -> UnsafeArc<T> {\n         unsafe { UnsafeArc { data: new_inner(data, 1) } }\n@@ -160,32 +187,19 @@ impl<T: Send> UnsafeArc<T> {\n                     data.data.take_unwrap()\n                 } else {\n                     // The *next* person who sees the refcount hit 0 will wake us.\n-                    let p1 = Cell::new(p1); // argh\n-                    // Unlike the above one, this cell is necessary. It will get\n-                    // taken either in the do block or in the finally block.\n-                    let c2_and_data = Cell::new((c2,data));\n-                    (|| {\n-                        p1.take().recv();\n-                        // Got here. Back in the 'unkillable' without getting killed.\n-                        let (c2, data) = c2_and_data.take();\n-                        c2.send(true);\n-                        // FIXME(#3224): it should be like this\n-                        // let ~ArcData { data: user_data, _ } = data;\n-                        // user_data\n-                        let mut data = data;\n-                        data.data.take_unwrap()\n-                    }).finally(|| {\n-                        if task::failing() {\n-                            // Killed during wait. Because this might happen while\n-                            // someone else still holds a reference, we can't free\n-                            // the data now; the \"other\" last refcount will free it.\n-                            let (c2, data) = c2_and_data.take();\n-                            c2.send(false);\n-                            cast::forget(data);\n-                        } else {\n-                            assert!(c2_and_data.is_empty());\n-                        }\n-                    })\n+                    let c2_and_data = ChannelAndDataGuard {\n+                        channel: Some(c2),\n+                        data: Some(data),\n+                    };\n+                    p1.recv();\n+                    // Got here. Back in the 'unkillable' without getting killed.\n+                    let (c2, data) = c2_and_data.unwrap();\n+                    c2.send(true);\n+                    // FIXME(#3224): it should be like this\n+                    // let ~ArcData { data: user_data, _ } = data;\n+                    // user_data\n+                    let mut data = data;\n+                    data.data.take_unwrap()\n                 }\n             } else {\n                 // If 'put' returns the server end back to us, we were rejected;\n@@ -280,17 +294,44 @@ impl<T> Drop for UnsafeArc<T>{\n \n /****************************************************************************/\n \n+pub struct AtomicGuard {\n+    on: bool,\n+}\n+\n+impl Drop for AtomicGuard {\n+    fn drop(&mut self) {\n+        use rt::task::{Task, GreenTask, SchedTask};\n+        use rt::local::Local;\n+\n+        if self.on {\n+            unsafe {\n+                let task_opt: Option<*mut Task> = Local::try_unsafe_borrow();\n+                match task_opt {\n+                    Some(t) => {\n+                        match (*t).task_type {\n+                            GreenTask(_) => (*t).death.allow_deschedule(),\n+                            SchedTask => {}\n+                        }\n+                    }\n+                    None => {}\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /**\n- * Enables a runtime assertion that no operation in the argument closure shall\n- * use scheduler operations (deschedule, recv, spawn, etc). This is for use with\n- * pthread mutexes, which may block the entire scheduler thread, rather than\n- * just one task, and is hence prone to deadlocks if mixed with descheduling.\n+ * Enables a runtime assertion that no operation while the returned guard is\n+ * live uses scheduler operations (deschedule, recv, spawn, etc). This is for\n+ * use with pthread mutexes, which may block the entire scheduler thread,\n+ * rather than just one task, and is hence prone to deadlocks if mixed with\n+ * descheduling.\n  *\n  * NOTE: THIS DOES NOT PROVIDE LOCKING, or any sort of critical-section\n  * synchronization whatsoever. It only makes sense to use for CPU-local issues.\n  */\n // FIXME(#8140) should not be pub\n-pub unsafe fn atomically<U>(f: || -> U) -> U {\n+pub unsafe fn atomic() -> AtomicGuard {\n     use rt::task::{Task, GreenTask, SchedTask};\n     use rt::local::Local;\n \n@@ -299,15 +340,19 @@ pub unsafe fn atomically<U>(f: || -> U) -> U {\n         Some(t) => {\n             match (*t).task_type {\n                 GreenTask(_) => {\n-                    (|| {\n-                        (*t).death.inhibit_deschedule();\n-                        f()\n-                    }).finally(|| (*t).death.allow_deschedule())\n+                    (*t).death.inhibit_deschedule();\n+                    return AtomicGuard {\n+                        on: true,\n+                    };\n                 }\n-                SchedTask => f()\n+                SchedTask => {}\n             }\n         }\n-        None => f()\n+        None => {}\n+    }\n+\n+    AtomicGuard {\n+        on: false,\n     }\n }\n \n@@ -466,7 +511,7 @@ mod tests {\n     use comm;\n     use option::*;\n     use prelude::*;\n-    use super::{Exclusive, UnsafeArc, atomically};\n+    use super::{Exclusive, UnsafeArc, atomic};\n     use task;\n     use mem::size_of;\n \n@@ -478,10 +523,10 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_atomically() {\n+    fn test_atomic() {\n         // NB. The whole runtime will abort on an 'atomic-sleep' violation,\n         // so we can't really test for the converse behaviour.\n-        unsafe { atomically(|| ()) } task::deschedule(); // oughtn't fail\n+        unsafe { let _ = atomic(); } // oughtn't fail\n     }\n \n     #[test]"}, {"sha": "b148df248334d3329d7278aabd4ccaf33e85ee04", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -20,7 +20,6 @@ extern mod extra;\n use extra::arc;\n use extra::future::Future;\n use extra::time;\n-use std::cell::Cell;\n use std::os;\n use std::uint;\n \n@@ -91,12 +90,9 @@ fn main() {\n     for i in range(1u, num_tasks) {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n-        let num_chan2 = Cell::new(num_chan);\n-        let num_port = Cell::new(num_port);\n+        let num_chan_2 = num_chan.clone();\n         let new_future = do Future::spawn() {\n-            let num_chan = num_chan2.take();\n-            let num_port1 = num_port.take();\n-            thread_ring(i, msg_per_task, num_chan, num_port1)\n+            thread_ring(i, msg_per_task, num_chan_2, num_port)\n         };\n         futures.push(new_future);\n         num_chan = new_chan;"}, {"sha": "ea241d267c7ce57edee404a7ee5aa5a5ae95d9c1", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -20,7 +20,6 @@ extern mod extra;\n use extra::arc;\n use extra::future::Future;\n use extra::time;\n-use std::cell::Cell;\n use std::os;\n use std::uint;\n \n@@ -87,12 +86,9 @@ fn main() {\n     for i in range(1u, num_tasks) {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n-        let num_chan2 = Cell::new(num_chan);\n-        let num_port = Cell::new(num_port);\n+        let num_chan_2 = num_chan.clone();\n         let new_future = do Future::spawn {\n-            let num_chan = num_chan2.take();\n-            let num_port1 = num_port.take();\n-            thread_ring(i, msg_per_task, num_chan, num_port1)\n+            thread_ring(i, msg_per_task, num_chan_2, num_port)\n         };\n         futures.push(new_future);\n         num_chan = new_chan;"}, {"sha": "8fa26b42e852714defedc6321aa687bdce37907e", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -13,7 +13,6 @@ extern mod extra;\n use std::os;\n use std::uint;\n use std::rt::test::spawntask_later;\n-use std::cell::Cell;\n \n // This is a simple bench that creates M pairs of of tasks. These\n // tasks ping-pong back and forth over a pair of streams. This is a\n@@ -24,28 +23,23 @@ fn ping_pong_bench(n: uint, m: uint) {\n \n     // Create pairs of tasks that pingpong back and forth.\n     fn run_pair(n: uint) {\n-            // Create a stream A->B\n-            let (pa,ca) = stream::<()>();\n-            // Create a stream B->A\n-            let (pb,cb) = stream::<()>();\n-\n-            let pa = Cell::new(pa);\n-            let ca = Cell::new(ca);\n-            let pb = Cell::new(pb);\n-            let cb = Cell::new(cb);\n+        // Create a stream A->B\n+        let (pa,ca) = stream::<()>();\n+        // Create a stream B->A\n+        let (pb,cb) = stream::<()>();\n \n         do spawntask_later() || {\n-            let chan = ca.take();\n-            let port = pb.take();\n+            let chan = ca;\n+            let port = pb;\n             n.times(|| {\n                 chan.send(());\n                 port.recv();\n             })\n         }\n \n         do spawntask_later() || {\n-            let chan = cb.take();\n-            let port = pa.take();\n+            let chan = cb;\n+            let port = pa;\n             n.times(|| {\n                 port.recv();\n                 chan.send(());"}, {"sha": "e6519a7885629d7166ec94f8600e2bef4371fa0c", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -13,7 +13,6 @@ extern mod extra;\n use std::os;\n use std::uint;\n use std::rt::test::spawntask_later;\n-use std::cell::Cell;\n use std::comm::oneshot;\n \n // A simple implementation of parfib. One subtree is found in a new\n@@ -26,9 +25,8 @@ fn parfib(n: uint) -> uint {\n     }\n \n     let (port,chan) = oneshot::<uint>();\n-    let chan = Cell::new(chan);\n     do spawntask_later {\n-        chan.take().send(parfib(n-1));\n+        chan.send(parfib(n-1));\n     };\n     let m2 = parfib(n-2);\n     return (port.recv() + m2);"}, {"sha": "464bc664fb5b2b09a99fd218dc567c6e34181217", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -12,7 +12,6 @@\n \n extern mod extra;\n \n-use std::cell::Cell;\n use std::comm::{stream, SharedChan};\n use std::option;\n use std::os;\n@@ -156,9 +155,11 @@ fn rendezvous(nn: uint, set: ~[color]) {\n             let to_rendezvous = to_rendezvous.clone();\n             let to_rendezvous_log = to_rendezvous_log.clone();\n             let (from_rendezvous, to_creature) = stream();\n-            let from_rendezvous = Cell::new(from_rendezvous);\n-            do task::spawn || {\n-                creature(ii, col, from_rendezvous.take(), to_rendezvous.clone(),\n+            do task::spawn {\n+                creature(ii,\n+                         col,\n+                         from_rendezvous,\n+                         to_rendezvous.clone(),\n                          to_rendezvous_log.clone());\n             }\n             to_creature"}, {"sha": "ac2b1958f93984dd49275b11aba345707878bad7", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -189,8 +189,12 @@ fn main() {\n    let mut proc_mode = false;\n \n    loop {\n-       let line = match io::ignore_io_error(|| rdr.read_line()) {\n-           Some(ln) => ln, None => break,\n+       let line = {\n+           let _guard = io::ignore_io_error();\n+           match rdr.read_line() {\n+               Some(ln) => ln,\n+               None => break,\n+           }\n        };\n        let line = line.trim().to_owned();\n "}, {"sha": "8e7b48040cdf12909d55e25a1a7930bfc2cca8e2", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -17,7 +17,6 @@\n //\n // The filename is a song reference; google it in quotes.\n \n-use std::cell::Cell;\n use std::comm;\n use std::os;\n use std::task;\n@@ -27,9 +26,7 @@ fn child_generation(gens_left: uint, c: comm::Chan<()>) {\n     // This used to be O(n^2) in the number of generations that ever existed.\n     // With this code, only as many generations are alive at a time as tasks\n     // alive at a time,\n-    let c = Cell::new(c);\n     do spawn {\n-        let c = c.take();\n         if gens_left & 1 == 1 {\n             task::deschedule(); // shake things up a bit\n         }"}, {"sha": "87173d779240f9c4f55f9eb348b1400d076c6319", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -10,7 +10,6 @@\n \n #[feature(managed_boxes)];\n \n-use std::cell::Cell;\n use std::task;\n \n struct Port<T>(@T);\n@@ -31,10 +30,10 @@ fn main() {\n         }\n     }\n \n-    let x = Cell::new(foo(Port(@())));\n+    let x = foo(Port(@()));\n \n     do task::spawn {\n-        let y = x.take();   //~ ERROR does not fulfill `Send`\n+        let y = x;   //~ ERROR does not fulfill `Send`\n         error!(\"{:?}\", y);\n     }\n }"}, {"sha": "dbf5d0fb3f98b1c1475aea70b7035cb99ae8fe3d", "filename": "src/test/compile-fail/no_freeze-rc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fcompile-fail%2Fno_freeze-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Fcompile-fail%2Fno_freeze-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_freeze-rc.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n use std::rc::Rc;\n-use std::cell::Cell;\n+use std::cell::RefCell;\n \n fn bar<T: Freeze>(_: T) {}\n \n fn main() {\n-    let x = Rc::from_send(Cell::new(5));\n-    bar(x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<std::cell::Cell<int>>`, which does not fulfill `Freeze`\n+    let x = Rc::from_send(RefCell::new(5));\n+    bar(x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<std::cell::RefCell<int>>`, which does not fulfill `Freeze`\n }"}, {"sha": "2c18361fd46fcf685615f3eac3032db80bea1061", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -313,8 +313,6 @@ pub fn main() {\n //    Commented out because of option::get error\n \n     let (client_, server_) = pingpong::init();\n-    let client_ = Cell::new(client_);\n-    let server_ = Cell::new(server_);\n \n     task::spawn {|client_|\n         let client__ = client_.take();"}, {"sha": "a39907d5c7ede0890c3f33b67443aba19e27e089", "filename": "src/test/run-pass/sendfn-spawn-with-fn-arg.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-spawn-with-fn-arg.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell::Cell;\n use std::task;\n \n pub fn main() { test05(); }\n@@ -23,8 +22,7 @@ fn test05() {\n         error!(\"{}\", *three + n); // will copy x into the closure\n         assert_eq!(*three, 3);\n     };\n-    let fn_to_send = Cell::new(fn_to_send);\n     task::spawn(proc() {\n-        test05_start(fn_to_send.take());\n+        test05_start(fn_to_send);\n     });\n }"}, {"sha": "a490cc6020fda5b6501e4112fa5335e4f6685725", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -13,7 +13,6 @@\n // A port of task-killjoin to use a class with a dtor to manage\n // the join.\n \n-use std::cell::Cell;\n use std::comm::*;\n use std::ptr;\n use std::task;\n@@ -55,9 +54,8 @@ fn joinable(f: proc()) -> Port<bool> {\n         *b = true;\n     }\n     let (p, c) = stream();\n-    let c = Cell::new(c);\n     do task::spawn_unlinked {\n-        let ccc = c.take();\n+        let ccc = c;\n         wrapper(ccc, f)\n     }\n     p"}, {"sha": "663eafe1700154752f0c08a2d06ee08b4358f5bf", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -22,11 +22,10 @@\n extern mod extra;\n \n use extra::tempfile::TempDir;\n+use std::io::fs;\n+use std::io;\n use std::os;\n use std::task;\n-use std::cell::Cell;\n-use std::io;\n-use std::io::fs;\n \n fn test_tempdir() {\n     let path = {\n@@ -51,9 +50,8 @@ fn test_rm_tempdir() {\n \n     let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n     let path = tmp.path().clone();\n-    let cell = Cell::new(tmp);\n     let f: proc() = proc() {\n-        let _tmp = cell.take();\n+        let _tmp = tmp;\n         fail!(\"fail to unwind past `tmp`\");\n     };\n     task::try(f);"}, {"sha": "abd9ea1733f49f863d4dc85d8ec43c72c5164dc5", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b16ae0996074861693f0f76d5d937fafe6a37e/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=b8b16ae0996074861693f0f76d5d937fafe6a37e", "patch": "@@ -16,10 +16,10 @@\n // xfail-fast\n \n extern mod extra;\n+\n use extra::arc;\n use std::comm;\n use std::task;\n-use std::cell;\n \n trait Pet {\n     fn name(&self, blk: |&str|);\n@@ -71,14 +71,14 @@ fn main() {\n                          ~fishe  as ~Pet:Freeze+Send,\n                          ~dogge2 as ~Pet:Freeze+Send]);\n     let (p1,c1) = comm::stream();\n-    let arc1 = cell::Cell::new(arc.clone());\n-    do task::spawn { check_legs(arc1.take()); c1.send(()); }\n+    let arc1 = arc.clone();\n+    do task::spawn { check_legs(arc1); c1.send(()); }\n     let (p2,c2) = comm::stream();\n-    let arc2 = cell::Cell::new(arc.clone());\n-    do task::spawn { check_names(arc2.take()); c2.send(()); }\n+    let arc2 = arc.clone();\n+    do task::spawn { check_names(arc2); c2.send(()); }\n     let (p3,c3) = comm::stream();\n-    let arc3 = cell::Cell::new(arc.clone());\n-    do task::spawn { check_pedigree(arc3.take()); c3.send(()); }\n+    let arc3 = arc.clone();\n+    do task::spawn { check_pedigree(arc3); c3.send(()); }\n     p1.recv();\n     p2.recv();\n     p3.recv();"}]}