{"sha": "1698773263f89c9f3507eddef032f76ae065e0da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2OTg3NzMyNjNmODljOWYzNTA3ZWRkZWYwMzJmNzZhZTA2NWUwZGE=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-12-13T02:05:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-13T02:05:22Z"}, "message": "Rollup merge of #79360 - wchargin:wchargin-doc-iter-by-reference, r=m-ou-se\n\nstd::iter: document iteration over `&T` and `&mut T`\n\nA colleague of mine is new to Rust, and mentioned that it was \u201cslightly\nconfusing\u201d to figure out what `&mut` does in iterating over `&mut foo`:\n\n```rust\nfor value in &mut self.my_vec {\n    // ...\n}\n```\n\nMy colleague had read the `std::iter` docs and not found the answer\nthere. There is a brief section at the top about \u201cthe three forms of\niteration\u201d, which mentions `iter_mut`, but it doesn\u2019t cover the purpose\nof `&mut coll` for a collection `coll`. This patch adds an explanatory\nsection to the docs. I opted to create a new section so that it can\nappear after the note that `impl<I: Iterator> IntoIterator for I`, and\nit\u2019s nice for the existing \u201cthree forms of iteration\u201d to appear near the\ntop.\n\nTest Plan:\nRan `./x.py doc library/core`, and the result looked good, including\nlinks. Manually copy-pasted the two doctests into the playground and ran\nthem.\n\nwchargin-branch: doc-iter-by-reference", "tree": {"sha": "9dfc1446ddd9f3e757107a6aabb0ff985865270c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9dfc1446ddd9f3e757107a6aabb0ff985865270c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1698773263f89c9f3507eddef032f76ae065e0da", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf1XbiCRBK7hj4Ov3rIwAAdHIIABZgZ0mERQTLHEOzBdol7ngK\n2xqG7z05VyoCzAa0pm0fpJi1Sbv+61HhcRZxXJe9ciGONsiR7YLMIPAmErzv8W8f\nFUvmnZGNGSaqslmWOW8ZiYI50ofNYmfVNrRX5ewhir+Eq8yGBp28jO1SPfdjTIel\nSQmZXc3LG1mY5auSFRoGnXGPwgaag+72DRjvCbsBVYikE7N5mBxOhxKoNl4JjRf8\nKZ/hsdOse2UMswxrwpspnRvxvxPLBg2iXI54p21/Bt/sXUgGE+agck5KmPY6gO0/\nHc1O2y57dK0E5xDzaRWn/3BCjl+b4Zvcj6A1DZFVlpyhhCnda/SI4r29jzNegJ0=\n=nCzS\n-----END PGP SIGNATURE-----\n", "payload": "tree 9dfc1446ddd9f3e757107a6aabb0ff985865270c\nparent f61e5cab760e21d61d8ba3d58badb20c54ebb1c4\nparent 6edc90a3e21a786bfe1e0a6bca28e8e687064554\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1607825122 +0900\ncommitter GitHub <noreply@github.com> 1607825122 +0900\n\nRollup merge of #79360 - wchargin:wchargin-doc-iter-by-reference, r=m-ou-se\n\nstd::iter: document iteration over `&T` and `&mut T`\n\nA colleague of mine is new to Rust, and mentioned that it was \u201cslightly\nconfusing\u201d to figure out what `&mut` does in iterating over `&mut foo`:\n\n```rust\nfor value in &mut self.my_vec {\n    // ...\n}\n```\n\nMy colleague had read the `std::iter` docs and not found the answer\nthere. There is a brief section at the top about \u201cthe three forms of\niteration\u201d, which mentions `iter_mut`, but it doesn\u2019t cover the purpose\nof `&mut coll` for a collection `coll`. This patch adds an explanatory\nsection to the docs. I opted to create a new section so that it can\nappear after the note that `impl<I: Iterator> IntoIterator for I`, and\nit\u2019s nice for the existing \u201cthree forms of iteration\u201d to appear near the\ntop.\n\nTest Plan:\nRan `./x.py doc library/core`, and the result looked good, including\nlinks. Manually copy-pasted the two doctests into the playground and ran\nthem.\n\nwchargin-branch: doc-iter-by-reference\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1698773263f89c9f3507eddef032f76ae065e0da", "html_url": "https://github.com/rust-lang/rust/commit/1698773263f89c9f3507eddef032f76ae065e0da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1698773263f89c9f3507eddef032f76ae065e0da/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f61e5cab760e21d61d8ba3d58badb20c54ebb1c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f61e5cab760e21d61d8ba3d58badb20c54ebb1c4", "html_url": "https://github.com/rust-lang/rust/commit/f61e5cab760e21d61d8ba3d58badb20c54ebb1c4"}, {"sha": "6edc90a3e21a786bfe1e0a6bca28e8e687064554", "url": "https://api.github.com/repos/rust-lang/rust/commits/6edc90a3e21a786bfe1e0a6bca28e8e687064554", "html_url": "https://github.com/rust-lang/rust/commit/6edc90a3e21a786bfe1e0a6bca28e8e687064554"}], "stats": {"total": 45, "additions": 45, "deletions": 0}, "files": [{"sha": "3e74637b49f1cafef7cfe569ca1e5a4fd9ce10c8", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1698773263f89c9f3507eddef032f76ae065e0da/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1698773263f89c9f3507eddef032f76ae065e0da/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=1698773263f89c9f3507eddef032f76ae065e0da", "patch": "@@ -206,6 +206,51 @@\n //! 2. If you're creating a collection, implementing [`IntoIterator`] for it\n //!    will allow your collection to be used with the `for` loop.\n //!\n+//! # Iterating by reference\n+//!\n+//! Since [`into_iter()`] takes `self` by value, using a `for` loop to iterate\n+//! over a collection consumes that collection. Often, you may want to iterate\n+//! over a collection without consuming it. Many collections offer methods that\n+//! provide iterators over references, conventionally called `iter()` and\n+//! `iter_mut()` respectively:\n+//!\n+//! ```\n+//! let mut values = vec![41];\n+//! for x in values.iter_mut() {\n+//!     *x += 1;\n+//! }\n+//! for x in values.iter() {\n+//!     assert_eq!(*x, 42);\n+//! }\n+//! assert_eq!(values.len(), 1); // `values` is still owned by this function.\n+//! ```\n+//!\n+//! If a collection type `C` provides `iter()`, it usually also implements\n+//! `IntoIterator` for `&C`, with an implementation that just calls `iter()`.\n+//! Likewise, a collection `C` that provides `iter_mut()` generally implements\n+//! `IntoIterator` for `&mut C` by delegating to `iter_mut()`. This enables a\n+//! convenient shorthand:\n+//!\n+//! ```\n+//! let mut values = vec![41];\n+//! for x in &mut values { // same as `values.iter_mut()`\n+//!     *x += 1;\n+//! }\n+//! for x in &values { // same as `values.iter()`\n+//!     assert_eq!(*x, 42);\n+//! }\n+//! assert_eq!(values.len(), 1);\n+//! ```\n+//!\n+//! While many collections offer `iter()`, not all offer `iter_mut()`. For\n+//! example, mutating the keys of a [`HashSet<T>`] or [`HashMap<K, V>`] could\n+//! put the collection into an inconsistent state if the key hashes change, so\n+//! these collections only offer `iter()`.\n+//!\n+//! [`into_iter()`]: IntoIterator::into_iter\n+//! [`HashSet<T>`]: ../../std/collections/struct.HashSet.html\n+//! [`HashMap<K, V>`]: ../../std/collections/struct.HashMap.html\n+//!\n //! # Adapters\n //!\n //! Functions which take an [`Iterator`] and return another [`Iterator`] are"}]}