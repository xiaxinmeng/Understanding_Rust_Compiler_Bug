{"sha": "4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlODI2MTAwOTk0OGVkMWNmYmJkYWY0ZWNjM2ZhZGVmNzk1YjI3Yjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-15T14:38:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-15T14:38:07Z"}, "message": "auto merge of #6487 : recrack/rust/vec_len, r=thestinger\n\nRename vec::len(var) to var.len()\r\n\r\n```\r\nlibcore, libfuzzer, librustc, librustdoc, libstd, libsyntax\r\ntest/auxiliary\r\ntest/bench\r\ntest/run-pass\r\n```", "tree": {"sha": "4eb235105de5e0b361a7a661ca347530f51e8283", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eb235105de5e0b361a7a661ca347530f51e8283"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "html_url": "https://github.com/rust-lang/rust/commit/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "803c12d85fa898950d9efa9078b64519a1b78ab6", "url": "https://api.github.com/repos/rust-lang/rust/commits/803c12d85fa898950d9efa9078b64519a1b78ab6", "html_url": "https://github.com/rust-lang/rust/commit/803c12d85fa898950d9efa9078b64519a1b78ab6"}, {"sha": "a2a8596c3dd963e7b51f11998cffc46033bf6d63", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2a8596c3dd963e7b51f11998cffc46033bf6d63", "html_url": "https://github.com/rust-lang/rust/commit/a2a8596c3dd963e7b51f11998cffc46033bf6d63"}], "stats": {"total": 262, "additions": 128, "deletions": 134}, "files": [{"sha": "89f7479da33151987cc73f04a49464fb3bd39866", "filename": ".swo", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/.swo", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/.swo", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.swo?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7"}, {"sha": "d58c2e596bd759a35da6f958fe8affa207b42fe5", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -264,7 +264,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n         fatal(~\"gdb failed to execute\");\n     }\n \n-    let num_check_lines = vec::len(check_lines);\n+    let num_check_lines = check_lines.len();\n     if num_check_lines > 0 {\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n@@ -303,7 +303,7 @@ fn check_error_patterns(props: &TestProps,\n         if str::contains(line, *next_err_pat) {\n             debug!(\"found error pattern %s\", *next_err_pat);\n             next_err_idx += 1u;\n-            if next_err_idx == vec::len(props.error_patterns) {\n+            if next_err_idx == props.error_patterns.len() {\n                 debug!(\"found all error patterns\");\n                 done = true;\n                 break;\n@@ -315,8 +315,8 @@ fn check_error_patterns(props: &TestProps,\n \n     let missing_patterns =\n         vec::slice(props.error_patterns, next_err_idx,\n-                   vec::len(props.error_patterns));\n-    if vec::len(missing_patterns) == 1u {\n+                   props.error_patterns.len());\n+    if missing_patterns.len() == 1u {\n         fatal_ProcRes(fmt!(\"error pattern '%s' not found!\",\n                            missing_patterns[0]), ProcRes);\n     } else {\n@@ -333,7 +333,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n \n     // true if we found the error in question\n     let mut found_flags = vec::from_elem(\n-        vec::len(expected_errors), false);\n+        expected_errors.len(), false);\n \n     if ProcRes.status == 0 {\n         fatal(~\"process did not return an error status\");\n@@ -377,7 +377,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         }\n     }\n \n-    for uint::range(0u, vec::len(found_flags)) |i| {\n+    for uint::range(0u, found_flags.len()) |i| {\n         if !found_flags[i] {\n             let ee = &expected_errors[i];\n             fatal_ProcRes(fmt!(\"expected %s on line %u not found: %s\","}, {"sha": "8c16f5c64824f5804d7b780fc86858a0dd392f3c", "filename": "src/libcore/either.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -201,14 +201,14 @@ fn test_lefts() {\n fn test_lefts_none() {\n     let input: ~[Either<int, int>] = ~[Right(10), Right(10)];\n     let result = lefts(input);\n-    assert_eq!(vec::len(result), 0u);\n+    assert_eq!(result.len(), 0u);\n }\n \n #[test]\n fn test_lefts_empty() {\n     let input: ~[Either<int, int>] = ~[];\n     let result = lefts(input);\n-    assert_eq!(vec::len(result), 0u);\n+    assert_eq!(result.len(), 0u);\n }\n \n #[test]\n@@ -222,14 +222,14 @@ fn test_rights() {\n fn test_rights_none() {\n     let input: ~[Either<int, int>] = ~[Left(10), Left(10)];\n     let result = rights(input);\n-    assert_eq!(vec::len(result), 0u);\n+    assert_eq!(result.len(), 0u);\n }\n \n #[test]\n fn test_rights_empty() {\n     let input: ~[Either<int, int>] = ~[];\n     let result = rights(input);\n-    assert_eq!(vec::len(result), 0u);\n+    assert_eq!(result.len(), 0u);\n }\n \n #[test]\n@@ -247,22 +247,22 @@ fn test_partition() {\n fn test_partition_no_lefts() {\n     let input: ~[Either<int, int>] = ~[Right(10), Right(11)];\n     let (lefts, rights) = partition(input);\n-    assert_eq!(vec::len(lefts), 0u);\n-    assert_eq!(vec::len(rights), 2u);\n+    assert_eq!(lefts.len(), 0u);\n+    assert_eq!(rights.len(), 2u);\n }\n \n #[test]\n fn test_partition_no_rights() {\n     let input: ~[Either<int, int>] = ~[Left(10), Left(11)];\n     let (lefts, rights) = partition(input);\n-    assert_eq!(vec::len(lefts), 2u);\n-    assert_eq!(vec::len(rights), 0u);\n+    assert_eq!(lefts.len(), 2u);\n+    assert_eq!(rights.len(), 0u);\n }\n \n #[test]\n fn test_partition_empty() {\n     let input: ~[Either<int, int>] = ~[];\n     let (lefts, rights) = partition(input);\n-    assert_eq!(vec::len(lefts), 0u);\n-    assert_eq!(vec::len(rights), 0u);\n+    assert_eq!(lefts.len(), 0u);\n+    assert_eq!(rights.len(), 0u);\n }"}, {"sha": "7b7d278380f1aff8b4c4066247feae4c4fe1fe4d", "filename": "src/libcore/io.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -673,10 +673,10 @@ impl<T:Reader> ReaderUtil for T {\n \n     fn read_char(&self) -> char {\n         let c = self.read_chars(1);\n-        if vec::len(c) == 0 {\n+        if c.len() == 0 {\n             return -1 as char; // FIXME will this stay valid? // #2004\n         }\n-        assert!((vec::len(c) == 1));\n+        assert!(c.len() == 1);\n         return c[0];\n     }\n \n@@ -1802,7 +1802,7 @@ mod tests {\n     fn test_readchars_empty() {\n         do io::with_str_reader(~\"\") |inp| {\n             let res : ~[char] = inp.read_chars(128);\n-            assert!((vec::len(res) == 0));\n+            assert!(res.len() == 0);\n         }\n     }\n \n@@ -1841,10 +1841,10 @@ mod tests {\n         fn check_read_ln(len : uint, s: &str, ivals: &[int]) {\n             do io::with_str_reader(s) |inp| {\n                 let res : ~[char] = inp.read_chars(len);\n-                if (len <= vec::len(ivals)) {\n-                    assert!((vec::len(res) == len));\n+                if len <= ivals.len() {\n+                    assert!(res.len() == len);\n                 }\n-                assert!(vec::slice(ivals, 0u, vec::len(res)) ==\n+                assert!(vec::slice(ivals, 0u, res.len()) ==\n                              vec::map(res, |x| *x as int));\n             }\n         }"}, {"sha": "daad9cee0fc2ef04bdd57156024999cb502118b1", "filename": "src/libcore/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -410,7 +410,7 @@ pub fn self_exe_path() -> Option<Path> {\n                            KERN_PROC as c_int,\n                            KERN_PROC_PATHNAME as c_int, -1 as c_int];\n                 let mut sz = sz;\n-                sysctl(vec::raw::to_ptr(mib), vec::len(mib) as ::libc::c_uint,\n+                sysctl(vec::raw::to_ptr(mib), mib.len() as ::libc::c_uint,\n                        buf as *mut c_void, &mut sz, ptr::null(),\n                        0u as size_t) == (0 as c_int)\n             }\n@@ -1490,7 +1490,7 @@ mod tests {\n     #[ignore]\n     fn test_env_getenv() {\n         let e = env();\n-        assert!(vec::len(e) > 0u);\n+        assert!(e.len() > 0u);\n         for e.each |p| {\n             let (n, v) = copy *p;\n             debug!(copy n);\n@@ -1581,7 +1581,7 @@ mod tests {\n     fn list_dir() {\n         let dirs = os::list_dir(&Path(\".\"));\n         // Just assuming that we've got some contents in the current directory\n-        assert!((vec::len(dirs) > 0u));\n+        assert!(dirs.len() > 0u);\n \n         for dirs.each |dir| {\n             debug!(copy *dir);"}, {"sha": "e116dc01943109ce9d8185ab21d6987fa14973b9", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -441,7 +441,7 @@ pub mod ptr_tests {\n             let arr_ptr = &arr[0];\n             let mut ctr = 0;\n             let mut iteration_count = 0;\n-            array_each_with_len(arr_ptr, vec::len(arr),\n+            array_each_with_len(arr_ptr, arr.len(),\n                                 |e| {\n                                          let actual = str::raw::from_c_str(e);\n                                          let expected = copy expected_arr[ctr];"}, {"sha": "0d298bde6b50875d04d565f66af17f2670707805", "filename": "src/libcore/rt/uvll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibcore%2Frt%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibcore%2Frt%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvll.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -221,7 +221,7 @@ pub unsafe fn accept(server: *c_void, client: *c_void) -> c_int {\n \n pub unsafe fn write<T>(req: *uv_write_t, stream: *T, buf_in: &[uv_buf_t], cb: *u8) -> c_int {\n     let buf_ptr = vec::raw::to_ptr(buf_in);\n-    let buf_cnt = vec::len(buf_in) as i32;\n+    let buf_cnt = buf_in.len() as i32;\n     return rust_uv_write(req as *c_void, stream as *c_void, buf_ptr, buf_cnt, cb);\n }\n pub unsafe fn read_start(stream: *uv_stream_t, on_alloc: *u8, on_read: *u8) -> c_int {"}, {"sha": "ec7177e52114e24f61f08c8dd1c7afd8d7deb339", "filename": "src/libcore/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -2059,7 +2059,7 @@ pub fn is_utf8(v: &const [u8]) -> bool {\n \n /// Determines if a vector of `u16` contains valid UTF-16\n pub fn is_utf16(v: &[u16]) -> bool {\n-    let len = vec::len(v);\n+    let len = v.len();\n     let mut i = 0u;\n     while (i < len) {\n         let u = v[i];\n@@ -2103,7 +2103,7 @@ pub fn to_utf16(s: &str) -> ~[u16] {\n }\n \n pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n-    let len = vec::len(v);\n+    let len = v.len();\n     let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n         let u = v[i];\n@@ -2128,7 +2128,7 @@ pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n \n pub fn from_utf16(v: &[u16]) -> ~str {\n     let mut buf = ~\"\";\n-    reserve(&mut buf, vec::len(v));\n+    reserve(&mut buf, v.len());\n     utf16_chars(v, |ch| push_char(&mut buf, ch));\n     buf\n }\n@@ -2398,7 +2398,7 @@ static tag_six_b: uint = 252u;\n  * # Example\n  *\n  * ~~~\n- * let i = str::as_bytes(\"Hello World\") { |bytes| vec::len(bytes) };\n+ * let i = str::as_bytes(\"Hello World\") { |bytes| bytes.len() };\n  * ~~~\n  */\n #[inline]"}, {"sha": "2502830250dbec7863e2cc662362c1a903377892", "filename": "src/libfuzzer/ast_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibfuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibfuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fast_match.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -15,8 +15,8 @@ fn vec_equal<T>(v: ~[T],\n                 u: ~[T],\n                 element_equality_test: @fn(&&T, &&T) -> bool) ->\n    bool {\n-    let Lv = vec::len(v);\n-    if Lv != vec::len(u) { return false; }\n+    let Lv = v.len();\n+    if Lv != u.len() { return false; }\n     let i = 0u;\n     while i < Lv {\n         if !element_equality_test(v[i], u[i]) { return false; }"}, {"sha": "a6434d64cdc38d62cbe1f8f910d3d06a9e1d3a9c", "filename": "src/libfuzzer/cycles.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibfuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibfuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fcycles.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -19,7 +19,7 @@ fn under(r : rand::rng, n : uint) -> uint {\n \n // random choice from a vec\n fn choice<T:copy>(r : rand::rng, v : ~[const T]) -> T {\n-    assert!(vec::len(v) != 0u); v[under(r, vec::len(v))]\n+    assert!(v.len() != 0u); v[under(r, v.len())]\n }\n \n // k in n chance of being true"}, {"sha": "c239e8ab9332e79d206aed4cb1d1fe6ce6e543fa", "filename": "src/libfuzzer/rand_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibfuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibfuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Frand_util.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -18,15 +18,15 @@ fn under(r : rand::rng, n : uint) -> uint {\n \n // random choice from a vec\n fn choice<T:copy>(r : rand::rng, v : ~[T]) -> T {\n-    assert!(vec::len(v) != 0u); v[under(r, vec::len(v))]\n+    assert!(v.len() != 0u); v[under(r, v.len())]\n }\n \n // 1 in n chance of being true\n fn unlikely(r : rand::rng, n : uint) -> bool { under(r, n) == 0u }\n \n // shuffle a vec in place\n fn shuffle<T>(r : rand::rng, &v : ~[T]) {\n-    let i = vec::len(v);\n+    let i = v.len();\n     while i >= 2u {\n         // Loop invariant: elements with index >= i have been locked in place.\n         i -= 1u;\n@@ -49,7 +49,7 @@ fn shuffled<T:copy>(r : rand::rng, v : ~[T]) -> ~[T] {\n // * weighted_vec is O(total weight) space\n type weighted<T> = { weight: uint, item: T };\n fn weighted_choice<T:copy>(r : rand::rng, v : ~[weighted<T>]) -> T {\n-    assert!(vec::len(v) != 0u);\n+    assert!(v.len() != 0u);\n     let total = 0u;\n     for {weight: weight, item: _} in v {\n         total += weight;"}, {"sha": "37a025cd8205b7222830340d2d2d374418f8fa57", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -137,8 +137,8 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n            abs1.to_str(), abs2.to_str());\n     let split1: &[~str] = abs1.components;\n     let split2: &[~str] = abs2.components;\n-    let len1 = vec::len(split1);\n-    let len2 = vec::len(split2);\n+    let len1 = split1.len();\n+    let len2 = split2.len();\n     assert!(len1 > 0);\n     assert!(len2 > 0);\n "}, {"sha": "0e37653e5c482f61e7226b220ae3db9df7b00133", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -905,7 +905,6 @@ mod test {\n     use driver::driver::{build_configuration, build_session};\n     use driver::driver::{build_session_options, optgroups, str_input};\n \n-    use core::vec;\n     use std::getopts::groups::getopts;\n     use std::getopts;\n     use syntax::attr;\n@@ -942,6 +941,6 @@ mod test {\n         let sess = build_session(sessopts, diagnostic::emit);\n         let cfg = build_configuration(sess, @~\"whatever\", &str_input(~\"\"));\n         let test_items = attr::find_meta_items_by_name(cfg, ~\"test\");\n-        assert!((vec::len(test_items) == 1u));\n+        assert!(test_items.len() == 1u);\n     }\n }"}, {"sha": "be03ed99ad77b4137183130747cbc8bc18759c49", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -206,7 +206,7 @@ fn is_bench_fn(i: @ast::item) -> bool {\n     fn has_test_signature(i: @ast::item) -> bool {\n         match i.node {\n             ast::item_fn(ref decl, _, _, ref generics, _) => {\n-                let input_cnt = vec::len(decl.inputs);\n+                let input_cnt = decl.inputs.len();\n                 let no_output = match decl.output.node {\n                     ast::ty_nil => true,\n                     _ => false"}, {"sha": "2592875cd575371c00cb00de1a1a878f0416c7bd", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -1063,7 +1063,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n-            assert!((vec::len(meta_items) == 1u));\n+            assert!(meta_items.len() == 1u);\n             let meta_item = meta_items[0];\n             attrs.push(\n                 codemap::spanned {"}, {"sha": "cfb2bd4b837fac1394b11833da2f175ca9bc17f9", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -171,7 +171,7 @@ pub fn metadata_matches(extern_metas: &[@ast::meta_item],\n                         local_metas: &[@ast::meta_item]) -> bool {\n \n     debug!(\"matching %u metadata requirements against %u items\",\n-           vec::len(local_metas), vec::len(extern_metas));\n+           local_metas.len(), extern_metas.len());\n \n     for local_metas.each |needed| {\n         if !attr::contains(extern_metas, *needed) {"}, {"sha": "151ccad88eafda1925a95e6f948def463f729afc", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -507,7 +507,7 @@ fn parse_sig(st: @mut PState, conv: conv_did) -> ty::FnSig {\n // Rust metadata parsing\n pub fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     let mut colon_idx = 0u;\n-    let len = vec::len(buf);\n+    let len = buf.len();\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n     if colon_idx == len {\n         error!(\"didn't find ':' when parsing def id\");"}, {"sha": "a891e8d3b7f8310c23372dc40f5fc0095d83b3f3", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -360,7 +360,7 @@ fn is_nullary_variant(cx: Context, ex: @expr) -> bool {\n       expr_path(_) => {\n         match cx.tcx.def_map.get_copy(&ex.id) {\n           def_variant(edid, vdid) => {\n-            vec::len(ty::enum_variant_with_id(cx.tcx, edid, vdid).args) == 0u\n+              vec::len(ty::enum_variant_with_id(cx.tcx, edid, vdid).args) == 0u\n           }\n           _ => false\n         }"}, {"sha": "27b6273879399ab73dc89d72856a94d371afa204", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -283,8 +283,8 @@ pub impl RegionMaps {\n \n         let a_ancestors = ancestors_of(self, scope_a);\n         let b_ancestors = ancestors_of(self, scope_b);\n-        let mut a_index = vec::len(a_ancestors) - 1u;\n-        let mut b_index = vec::len(b_ancestors) - 1u;\n+        let mut a_index = a_ancestors.len() - 1u;\n+        let mut b_index = b_ancestors.len() - 1u;\n \n         // Here, ~[ab]_ancestors is a vector going from narrow to broad.\n         // The end of each vector will be the item where the scope is"}, {"sha": "9b864bd0ef224aabecf26fe9783873cd39889539", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -4706,7 +4706,7 @@ pub impl Resolver {\n             }\n         }\n \n-        if vec::len(values) > 0 &&\n+        if values.len() > 0 &&\n             values[smallest] != uint::max_value &&\n             values[smallest] < str::len(name) + 2 &&\n             values[smallest] <= max_distance &&"}, {"sha": "a404dcf7249b2b2ba49071d9dccfdb5ad4616be0", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -4720,7 +4720,7 @@ pub impl Resolver {\n             }\n         }\n \n-        if vec::len(values) > 0 &&\n+        if values.len() > 0 &&\n             values[smallest] != uint::max_value &&\n             values[smallest] < str::len(name) + 2 &&\n             values[smallest] <= max_distance &&"}, {"sha": "e103bbc5de7a8b8af1c2868c480a33e3ad2a2e24", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -65,7 +65,7 @@ pub impl FnType {\n \n         let mut llargvals = ~[];\n         let mut i = 0u;\n-        let n = vec::len(arg_tys);\n+        let n = arg_tys.len();\n \n         if self.sret {\n             let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n@@ -113,7 +113,7 @@ pub impl FnType {\n         if self.sret || !ret_def {\n             return;\n         }\n-        let n = vec::len(arg_tys);\n+        let n = arg_tys.len();\n         // R** llretptr = &args->r;\n         let llretptr = GEPi(bcx, llargbundle, [0u, n]);\n         // R* llretloc = *llretptr; /* (args->r) */\n@@ -149,7 +149,7 @@ pub impl FnType {\n         };\n \n         let mut i = 0u;\n-        let n = vec::len(atys);\n+        let n = atys.len();\n         while i < n {\n             let mut argval = get_param(llwrapfn, i + j);\n             if attrs[i].is_some() {"}, {"sha": "a44f203c7ab7d812542d5af8184a8df14e2eabb1", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -50,7 +50,7 @@ fn is_sse(c: x86_64_reg_class) -> bool {\n }\n \n fn is_ymm(cls: &[x86_64_reg_class]) -> bool {\n-    let len = vec::len(cls);\n+    let len = cls.len();\n     return (len > 2u &&\n          is_sse(cls[0]) &&\n          cls[1] == sseup_class &&\n@@ -223,8 +223,8 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n         unsafe {\n             let mut i = 0u;\n             let llty = llvm::LLVMGetTypeKind(ty) as int;\n-            let e = vec::len(cls);\n-            if vec::len(cls) > 2u &&\n+            let e = cls.len();\n+            if cls.len() > 2u &&\n                (llty == 10 /* struct */ ||\n                 llty == 11 /* array */) {\n                 if is_sse(cls[i]) {\n@@ -295,7 +295,7 @@ fn llreg_ty(cls: &[x86_64_reg_class]) -> TypeRef {\n     unsafe {\n         let mut tys = ~[];\n         let mut i = 0u;\n-        let e = vec::len(cls);\n+        let e = cls.len();\n         while i < e {\n             match cls[i] {\n                 integer_class => {"}, {"sha": "5b1cae473f7400fdf9126e66543ad4e4d365a3b0", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -509,7 +509,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n                       llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::wrap::build_args\");\n             let ccx = bcx.ccx();\n-            let n = vec::len(tys.llsig.llarg_tys);\n+            let n = tys.llsig.llarg_tys.len();\n             let implicit_args = first_real_arg; // return + env\n             for uint::range(0, n) |i| {\n                 let mut llargval = get_param(llwrapfn, i + implicit_args);"}, {"sha": "1141e0c007feec03eb40ae7dfc7599e1fafe388d", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -93,7 +93,7 @@ pub impl Reflector {\n         let mth_ty =\n             ty::mk_bare_fn(tcx, copy self.visitor_methods[mth_idx].fty);\n         let v = self.visitor_val;\n-        debug!(\"passing %u args:\", vec::len(args));\n+        debug!(\"passing %u args:\", args.len());\n         let bcx = self.bcx;\n         for args.eachi |i, a| {\n             debug!(\"arg %u: %s\", i, val_str(bcx.ccx().tn, *a));\n@@ -224,7 +224,7 @@ pub impl Reflector {\n             let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n             let extra = ~[self.c_uint(pureval),\n                           self.c_uint(sigilval),\n-                          self.c_uint(vec::len(fty.sig.inputs)),\n+                          self.c_uint(fty.sig.inputs.len()),\n                           self.c_uint(retval)];\n             self.visit(~\"enter_fn\", copy extra);    // XXX: Bad copy.\n             self.visit_sig(retval, &fty.sig);\n@@ -239,7 +239,7 @@ pub impl Reflector {\n             let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n             let extra = ~[self.c_uint(pureval),\n                           self.c_uint(sigilval),\n-                          self.c_uint(vec::len(fty.sig.inputs)),\n+                          self.c_uint(fty.sig.inputs.len()),\n                           self.c_uint(retval)];\n             self.visit(~\"enter_fn\", copy extra);    // XXX: Bad copy.\n             self.visit_sig(retval, &fty.sig);\n@@ -304,13 +304,13 @@ pub impl Reflector {\n                 llfdecl\n             };\n \n-            let enum_args = ~[self.c_uint(vec::len(variants)), make_get_disr()]\n+            let enum_args = ~[self.c_uint(variants.len()), make_get_disr()]\n                 + self.c_size_and_align(t);\n             do self.bracketed(~\"enum\", enum_args) |this| {\n                 for variants.eachi |i, v| {\n                     let variant_args = ~[this.c_uint(i),\n                                          this.c_int(v.disr_val),\n-                                         this.c_uint(vec::len(v.args)),\n+                                         this.c_uint(v.args.len()),\n                                          this.c_slice(ccx.sess.str_of(v.name))];\n                     do this.bracketed(~\"enum_variant\", variant_args) |this| {\n                         for v.args.eachi |j, a| {"}, {"sha": "31de1280741105437963962af4ac53d1cbd767d0", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -18,7 +18,6 @@ use middle::trans::common::*;\n use middle::trans;\n \n use core::str;\n-use core::vec;\n \n pub struct Ctxt {\n     next_tag_id: u16,\n@@ -71,6 +70,6 @@ pub fn add_u16(dest: &mut ~[u8], val: u16) {\n }\n \n pub fn add_substr(dest: &mut ~[u8], src: ~[u8]) {\n-    add_u16(&mut *dest, vec::len(src) as u16);\n+    add_u16(&mut *dest, src.len() as u16);\n     *dest += src;\n }"}, {"sha": "4ee2c5b01006f5999a720dd215efc7ac3e62edb2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -2634,7 +2634,7 @@ pub fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n \n       ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n-        if vec::len(*variants) == 1u && vec::len(variants[0].args) == 1u {\n+        if (*variants).len() == 1u && variants[0].args.len() == 1u {\n             let v_t = subst(cx, substs, variants[0].args[0]);\n             Some(mt {ty: v_t, mutbl: ast::m_imm})\n         } else {"}, {"sha": "548b9e454ce9560502ff1ce64398c4b87a6825c8", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -3276,7 +3276,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n     debug!(\">>> instantiate_path\");\n \n     let ty_param_count = tpt.generics.type_param_defs.len();\n-    let ty_substs_len = vec::len(pth.types);\n+    let ty_substs_len = pth.types.len();\n \n     debug!(\"ty_param_count=%? ty_substs_len=%?\",\n            ty_param_count,"}, {"sha": "4773e637c3521e1078b290af8c146989051f550f", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -499,15 +499,15 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         return;\n     }\n \n-    if vec::len(impl_m.fty.sig.inputs) != vec::len(trait_m.fty.sig.inputs) {\n+    if impl_m.fty.sig.inputs.len() != trait_m.fty.sig.inputs.len() {\n         tcx.sess.span_err(\n             cm.span,\n             fmt!(\"method `%s` has %u parameter%s \\\n                   but the trait has %u\",\n                  *tcx.sess.str_of(trait_m.ident),\n-                 vec::len(impl_m.fty.sig.inputs),\n-                 if vec::len(impl_m.fty.sig.inputs) == 1 { \"\" } else { \"s\" },\n-                 vec::len(trait_m.fty.sig.inputs)));\n+                 impl_m.fty.sig.inputs.len(),\n+                 if impl_m.fty.sig.inputs.len() == 1 { \"\" } else { \"s\" },\n+                 trait_m.fty.sig.inputs.len()));\n         return;\n     }\n "}, {"sha": "0dec0fc937b159c84ccca48b92a150b26318796a", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -310,7 +310,7 @@ fn check_main_fn_ty(ccx: @mut CrateCtxt,\n                 _ => ()\n             }\n             let mut ok = ty::type_is_nil(fn_ty.sig.output);\n-            let num_args = vec::len(fn_ty.sig.inputs);\n+            let num_args = fn_ty.sig.inputs.len();\n             ok &= num_args == 0u;\n             if !ok {\n                 tcx.sess.span_err("}, {"sha": "13a2f376c069463d3030f8f1677228cd0e11295a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -470,7 +470,7 @@ pub fn parameterized(cx: ctxt,\n       }\n     };\n \n-    if vec::len(tps) > 0u {\n+    if tps.len() > 0u {\n         let strs = vec::map(tps, |t| ty_to_str(cx, *t));\n         fmt!(\"%s%s<%s>\", base, r_str, str::connect(strs, \",\"))\n     } else {"}, {"sha": "12689466c8c326778e114a54a7e76eda9afb7d2f", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -405,7 +405,7 @@ mod test {\n     #[test]\n     fn should_not_add_impl_trait_types_if_none() {\n         let doc = mk_doc(~\"impl int { fn a() { } }\");\n-        assert!(vec::len(doc.cratemod().impls()[0].trait_types) == 0);\n+        assert!(doc.cratemod().impls()[0].trait_types.len() == 0);\n     }\n \n     #[test]"}, {"sha": "07c1c226d1f63068bfdb6208ceb6abcc70b34652", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -628,7 +628,6 @@ pub mod writer {\n \n     use core::io;\n     use core::str;\n-    use core::vec;\n \n     // ebml writing\n     pub struct Encoder {\n@@ -707,7 +706,7 @@ pub mod writer {\n \n         fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) {\n             write_vuint(self.writer, tag_id);\n-            write_vuint(self.writer, vec::len(b));\n+            write_vuint(self.writer, b.len());\n             self.writer.write(b);\n         }\n \n@@ -760,7 +759,7 @@ pub mod writer {\n         }\n \n         fn wr_bytes(&mut self, b: &[u8]) {\n-            debug!(\"Write %u bytes\", vec::len(b));\n+            debug!(\"Write %u bytes\", b.len());\n             self.writer.write(b);\n         }\n "}, {"sha": "84561256cd1dd81f1559d9e4acf8d35ccbd40343", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -23,7 +23,7 @@ pub fn md4(msg: &[u8]) -> Quad {\n     // subtle: if orig_len is merely uint, then the code below\n     // which performs shifts by 32 bits or more has undefined\n     // results.\n-    let orig_len: u64 = (vec::len(msg) * 8u) as u64;\n+    let orig_len: u64 = (msg.len() * 8u) as u64;\n \n     // pad message\n     let mut msg = vec::append(vec::to_owned(msg), ~[0x80u8]);\n@@ -51,7 +51,7 @@ pub fn md4(msg: &[u8]) -> Quad {\n     }\n \n     let mut i = 0u;\n-    let e = vec::len(msg);\n+    let e = msg.len();\n     let mut x = vec::from_elem(16u, 0u32);\n     while i < e {\n         let aa = a, bb = b, cc = c, dd = d;"}, {"sha": "cc4e7ee02046d2365e8cf059f93ae993368b79bf", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -15,7 +15,6 @@ use core::comm::{stream, SharedChan};\n use core::ptr;\n use core::result;\n use core::str;\n-use core::vec;\n \n use iotask = uv::iotask::IoTask;\n use interact = uv::iotask::interact;\n@@ -340,7 +339,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t,\n                     }\n                 }\n                 debug!(\"successful process addrinfo result, len: %?\",\n-                                vec::len(out_vec));\n+                                out_vec.len());\n                 output_ch.send(result::Ok(out_vec));\n             }\n             else {\n@@ -424,7 +423,7 @@ mod test {\n         // this.. mostly just wanting to see it work, atm.\n         let results = result::unwrap(ga_result);\n         debug!(\"test_get_addr: Number of results for %s: %?\",\n-                        localhost_name, vec::len(results));\n+                        localhost_name, results.len());\n         for results.each |r| {\n             let ipv_prefix = match *r {\n               Ipv4(_) => ~\"IPv4\","}, {"sha": "37578e42baff4a94750ef9b8d2a0b9dbaa6f9099", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -1802,15 +1802,15 @@ mod test {\n         debug!(\"BUF_WRITE: val len %?\", str::len(val));\n         do str::byte_slice(val) |b_slice| {\n             debug!(\"BUF_WRITE: b_slice len %?\",\n-                            vec::len(b_slice));\n+                            b_slice.len());\n             w.write(b_slice)\n         }\n     }\n \n     fn buf_read<R:io::Reader>(r: &R, len: uint) -> ~str {\n         let new_bytes = (*r).read_bytes(len);\n         debug!(\"in buf_read.. new_bytes len: %?\",\n-                        vec::len(new_bytes));\n+                        new_bytes.len());\n         str::from_bytes(new_bytes)\n     }\n \n@@ -1863,7 +1863,7 @@ mod test {\n                           result::Ok(data) => {\n                             debug!(\"SERVER: got REQ str::from_bytes..\");\n                             debug!(\"SERVER: REQ data len: %?\",\n-                                            vec::len(data));\n+                                            data.len());\n                             server_ch.send(\n                                 str::from_bytes(data));\n                             debug!(\"SERVER: before write\");"}, {"sha": "d1af484cb22bc40afe29b8df36eac1f0ced30e0a", "filename": "src/libstd/par.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -58,9 +58,8 @@ fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n                         info!(\"pre-slice: %?\", (base, slice));\n                         let slice : &[A] =\n                             cast::transmute(slice);\n-                        info!(\"slice: %?\",\n-                                       (base, vec::len(slice), end - base));\n-                        assert!((vec::len(slice) == end - base));\n+                        info!(\"slice: %?\", (base, slice.len(), end - base));\n+                        assert!(slice.len() == end - base);\n                         f(base, slice)\n                     }\n                 };"}, {"sha": "9afa7262ce47336c05a67b7f431ddf92c51ea58b", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -164,7 +164,7 @@ pub fn append_rope(left: Rope, right: Rope) -> Rope {\n  */\n pub fn concat(v: ~[Rope]) -> Rope {\n     //Copy `v` into a mut vector\n-    let mut len = vec::len(v);\n+    let mut len = v.len();\n     if len == 0u { return node::Empty; }\n     let mut ropes = vec::from_elem(len, v[0]);\n     for uint::range(1u, len) |i| {\n@@ -770,7 +770,7 @@ pub mod node {\n      */\n     pub fn tree_from_forest_destructive(forest: &mut [@Node]) -> @Node {\n         let mut i;\n-        let mut len = vec::len(forest);\n+        let mut len = forest.len();\n         while len > 1u {\n             i = 0u;\n             while i < len - 1u {//Concat nodes 0 with 1, 2 with 3 etc."}, {"sha": "6d8bf20d837caedc1368419672e6db98d4aad963", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -90,8 +90,8 @@ pub fn sha1() -> @Sha1 {\n         }\n     }\n     fn process_msg_block(st: &mut Sha1State) {\n-        assert!((vec::len(st.h) == digest_buf_len));\n-        assert!((vec::uniq_len(st.work_buf) == work_buf_len));\n+        assert!(st.h.len() == digest_buf_len);\n+        assert!(vec::uniq_len(st.work_buf) == work_buf_len);\n         let mut t: int; // Loop counter\n         let w = st.work_buf;\n \n@@ -230,7 +230,7 @@ pub fn sha1() -> @Sha1 {\n \n     impl Sha1 for Sha1State {\n         fn reset(&mut self) {\n-            assert!((vec::len(self.h) == digest_buf_len));\n+            assert!(self.h.len() == digest_buf_len);\n             self.len_low = 0u32;\n             self.len_high = 0u32;\n             self.msg_block_idx = 0u;"}, {"sha": "449edacad32bd3f6cf7101948bc4b1fa380da467", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -19,7 +19,6 @@ use core::unstable::sync::{Exclusive, exclusive};\n use core::ptr;\n use core::task;\n use core::util;\n-use core::vec;\n \n /****************************************************************************\n  * Internals\n@@ -220,7 +219,7 @@ pub impl<'self> Condvar<'self> {\n             do task::unkillable {\n                 // Release lock, 'atomically' enqueuing ourselves in so doing.\n                 do (**self.sem).with |state| {\n-                    if condvar_id < vec::len(state.blocked) {\n+                    if condvar_id < state.blocked.len() {\n                         // Drop the lock.\n                         state.count += 1;\n                         if state.count <= 0 {\n@@ -230,7 +229,7 @@ pub impl<'self> Condvar<'self> {\n                         let SignalEnd = SignalEnd.swap_unwrap();\n                         state.blocked[condvar_id].tail.send(SignalEnd);\n                     } else {\n-                        out_of_bounds = Some(vec::len(state.blocked));\n+                        out_of_bounds = Some(state.blocked.len());\n                     }\n                 }\n \n@@ -285,10 +284,10 @@ pub impl<'self> Condvar<'self> {\n         let mut out_of_bounds = None;\n         let mut result = false;\n         do (**self.sem).with |state| {\n-            if condvar_id < vec::len(state.blocked) {\n+            if condvar_id < state.blocked.len() {\n                 result = signal_waitqueue(&state.blocked[condvar_id]);\n             } else {\n-                out_of_bounds = Some(vec::len(state.blocked));\n+                out_of_bounds = Some(state.blocked.len());\n             }\n         }\n         do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n@@ -304,14 +303,14 @@ pub impl<'self> Condvar<'self> {\n         let mut out_of_bounds = None;\n         let mut queue = None;\n         do (**self.sem).with |state| {\n-            if condvar_id < vec::len(state.blocked) {\n+            if condvar_id < state.blocked.len() {\n                 // To avoid :broadcast_heavy, we make a new waitqueue,\n                 // swap it out with the old one, and broadcast on the\n                 // old one outside of the little-lock.\n                 queue = Some(util::replace(&mut state.blocked[condvar_id],\n                                            new_waitqueue()));\n             } else {\n-                out_of_bounds = Some(vec::len(state.blocked));\n+                out_of_bounds = Some(state.blocked.len());\n             }\n         }\n         do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {"}, {"sha": "b2f73df316da3c4ba10c862cd76b734b678bd97d", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -144,7 +144,7 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n         };\n \n     let filter =\n-        if vec::len(matches.free) > 0 {\n+        if matches.free.len() > 0 {\n             option::Some(copy (matches).free[0])\n         } else { option::None };\n \n@@ -901,7 +901,7 @@ mod tests {\n         ];\n         let filtered = filter_tests(&opts, tests);\n \n-        assert!((vec::len(filtered) == 1));\n+        assert!(filtered.len() == 1);\n         assert!((filtered[0].desc.name.to_str() == ~\"1\"));\n         assert!((filtered[0].desc.ignore == false));\n     }"}, {"sha": "37052f7d1b7fac5dc3e6fd5abfeacc2ef66b780a", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -1358,7 +1358,7 @@ mod test {\n             let req_msg_ptr: *u8 = vec::raw::to_ptr(req_str_bytes);\n             debug!(\"req_msg ptr: %u\", req_msg_ptr as uint);\n             let req_msg = ~[\n-                buf_init(req_msg_ptr, vec::len(req_str_bytes))\n+                buf_init(req_msg_ptr, req_str_bytes.len())\n             ];\n             // this is the enclosing record, we'll pass a ptr to\n             // this to C.."}, {"sha": "993fa612a27096627bee40059adc6137e8f8c317", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -232,7 +232,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n     let max_lines = 6u;\n     let mut elided = false;\n     let mut display_lines = /* FIXME (#2543) */ copy lines.lines;\n-    if vec::len(display_lines) > max_lines {\n+    if display_lines.len() > max_lines {\n         display_lines = vec::slice(display_lines, 0u, max_lines).to_vec();\n         elided = true;\n     }\n@@ -243,7 +243,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n         io::stderr().write_str(s);\n     }\n     if elided {\n-        let last_line = display_lines[vec::len(display_lines) - 1u];\n+        let last_line = display_lines[display_lines.len() - 1u];\n         let s = fmt!(\"%s:%u \", fm.name, last_line + 1u);\n         let mut indent = str::len(s);\n         let mut out = ~\"\";\n@@ -254,7 +254,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n \n     // FIXME (#3260)\n     // If there's one line at fault we can easily point to the problem\n-    if vec::len(lines.lines) == 1u {\n+    if lines.lines.len() == 1u {\n         let lo = cm.lookup_char_pos(sp.lo);\n         let mut digits = 0u;\n         let mut num = (lines.lines[0] + 1u) / 10u;"}, {"sha": "5c306aefc6ad2105ecad959df3103a8b4487a03e", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -824,7 +824,7 @@ fn mk_struct_ser_impl(\n         cx.ident_of(\"emit_struct\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(ident)),\n-            cx.lit_uint(span, vec::len(fields)),\n+            cx.lit_uint(span, fields.len()),\n             cx.lambda_stmts_1(span, fields, cx.ident_of(\"__s\")),\n         ]\n     );\n@@ -886,7 +886,7 @@ fn mk_struct_deser_impl(\n         cx.ident_of(\"read_struct\"),\n         ~[\n             cx.lit_str(span, @cx.str_of(ident)),\n-            cx.lit_uint(span, vec::len(fields)),\n+            cx.lit_uint(span, fields.len()),\n             cx.lambda_expr_1(\n                 cx.expr(\n                     span,"}, {"sha": "30470d2ebe758076bc15c10a3365e9d2478ca1aa", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -351,7 +351,7 @@ pub fn expr_to_ident(cx: @ext_ctxt,\n                      err_msg: &str) -> ast::ident {\n     match expr.node {\n       ast::expr_path(p) => {\n-        if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {\n+        if p.types.len() > 0u || p.idents.len() != 1u {\n             cx.span_fatal(expr.span, err_msg);\n         }\n         return p.idents[0];"}, {"sha": "89873b2793566852ae98d4278701003fef5c3088", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -276,7 +276,7 @@ fn read_block_comment(rdr: @mut StringReader,\n \n     let mut style = if code_to_the_left { trailing } else { isolated };\n     consume_non_eol_whitespace(rdr);\n-    if !is_eof(rdr) && rdr.curr != '\\n' && vec::len(lines) == 1u {\n+    if !is_eof(rdr) && rdr.curr != '\\n' && lines.len() == 1u {\n         style = mixed;\n     }\n     debug!(\"<<< block comment\");"}, {"sha": "b76098858cb3d165afeb7eb6ee4568c54e895e88", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -2471,7 +2471,7 @@ pub impl Parser {\n                                   }\n                               },\n                               _ => {\n-                                  if vec::len(enum_path.idents)==1u {\n+                                  if enum_path.idents.len()==1u {\n                                       // it could still be either an enum\n                                       // or an identifier pattern, resolve\n                                       // will sort it out:\n@@ -4337,7 +4337,7 @@ pub impl Parser {\n           }\n           _ => ()\n         }\n-        let last = path[vec::len(path) - 1u];\n+        let last = path[path.len() - 1u];\n         let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n                                 global: false,\n                                 idents: path,"}, {"sha": "38c58612f43a74ec5587baf95b32ec2cfc588a9d", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -110,8 +110,8 @@ pub fn tok_str(t: token) -> ~str {\n \n pub fn buf_str(toks: ~[token], szs: ~[int], left: uint, right: uint,\n                lim: uint) -> ~str {\n-    let n = vec::len(toks);\n-    assert!(n == vec::len(szs));\n+    let n = toks.len();\n+    assert!(n == szs.len());\n     let mut i = left;\n     let mut L = lim;\n     let mut s = ~\"[\";"}, {"sha": "ea1682978a463be219864e14011c3db501b33ca9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -1798,7 +1798,7 @@ pub fn print_meta_item(s: @ps, item: @ast::meta_item) {\n pub fn print_view_path(s: @ps, vp: @ast::view_path) {\n     match vp.node {\n       ast::view_path_simple(ident, path, _) => {\n-        if path.idents[vec::len(path.idents)-1u] != ident {\n+        if path.idents[path.idents.len()-1u] != ident {\n             print_ident(s, ident);\n             space(s.s);\n             word_space(s, ~\"=\");\n@@ -2067,7 +2067,7 @@ pub fn maybe_print_comment(s: @ps, pos: BytePos) {\n pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n     match cmnt.style {\n       comments::mixed => {\n-        assert!((vec::len(cmnt.lines) == 1u));\n+        assert!(cmnt.lines.len() == 1u);\n         zerobreak(s.s);\n         word(s.s, cmnt.lines[0]);\n         zerobreak(s.s);\n@@ -2083,7 +2083,7 @@ pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n       }\n       comments::trailing => {\n         word(s.s, ~\" \");\n-        if vec::len(cmnt.lines) == 1u {\n+        if cmnt.lines.len() == 1u {\n             word(s.s, cmnt.lines[0]);\n             hardbreak(s.s);\n         } else {"}, {"sha": "a264c7d238f523ef20374e22d68075c497d88ed4", "filename": "src/test/auxiliary/cci_iter_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -13,7 +13,7 @@\n #[inline]\n pub fn iter<T>(v: &[T], f: &fn(&T)) {\n     let mut i = 0u;\n-    let n = vec::len(v);\n+    let n = v.len();\n     while i < n {\n         f(&v[i]);\n         i += 1u;"}, {"sha": "fbdb7806b5e6775f578b2ca2687f4e928121e90a", "filename": "src/test/auxiliary/cci_no_inline_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -13,7 +13,7 @@\n // same as cci_iter_lib, more-or-less, but not marked inline\n pub fn iter(v: ~[uint], f: &fn(uint)) {\n     let mut i = 0u;\n-    let n = vec::len(v);\n+    let n = v.len();\n     while i < n {\n         f(v[i]);\n         i += 1u;"}, {"sha": "ddf6f4bfc55cf57d7135ebac3907ee351c23a6e9", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -126,7 +126,7 @@ fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {\n  */\n fn bfs(graph: graph, key: node_id) -> bfs_result {\n     let mut marks : ~[node_id]\n-        = vec::from_elem(vec::len(graph), -1i64);\n+        = vec::from_elem(graph.len(), -1i64);\n \n     let mut q = Deque::new();\n \n@@ -429,7 +429,7 @@ fn main() {\n     let stop = time::precise_time_s();\n \n     io::stdout().write_line(fmt!(\"Generated %? edges in %? seconds.\",\n-                                 vec::len(edges), stop - start));\n+                                 edges.len(), stop - start));\n \n     let start = time::precise_time_s();\n     let graph = make_graph(1 << scale, copy edges);"}, {"sha": "3c32ec338b7ec6ebf844aaf78b3e81e795153b00", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -95,7 +95,7 @@ fn windows_with_carry(bb: &[u8], nn: uint,\n                       it: &fn(window: &[u8])) -> ~[u8] {\n    let mut ii = 0u;\n \n-   let len = vec::len(bb);\n+   let len = bb.len();\n    while ii < len - (nn - 1u) {\n       it(vec::slice(bb, ii, ii+nn));\n       ii += 1u;"}, {"sha": "c18c1eaedd6134b16915a764dd4715e627706767", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -70,7 +70,7 @@ pub impl Sudoku {\n             let line = reader.read_line();\n             let mut comps = ~[];\n             for str::each_split_char(line.trim(), ',') |s| { comps.push(s.to_owned()) }\n-            if vec::len(comps) == 3u {\n+            if comps.len() == 3u {\n                 let row     = uint::from_str(comps[0]).get() as u8;\n                 let col     = uint::from_str(comps[1]).get() as u8;\n                 g[row][col] = uint::from_str(comps[2]).get() as u8;\n@@ -103,7 +103,7 @@ pub impl Sudoku {\n         }\n \n         let mut ptr = 0u;\n-        let end = vec::len(work);\n+        let end = work.len();\n         while (ptr < end) {\n             let (row, col) = work[ptr];\n             // is there another color to try?\n@@ -265,7 +265,7 @@ fn check_default_sudoku_solution() {\n \n fn main() {\n     let args        = os::args();\n-    let use_default = vec::len(args) == 1u;\n+    let use_default = args.len() == 1u;\n     let mut sudoku = if use_default {\n         Sudoku::from_vec(&default_sudoku)\n     } else {"}, {"sha": "b21213bb221b6bfda78eb7c297e459fd112ac512", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -39,15 +39,15 @@ pub fn main() {\n     // Call a method\n     for x.iterate() |y| { assert!(x[*y] == *y); }\n     // Call a parameterized function\n-    assert!(length(x.clone()) == vec::len(x));\n+    assert!(length(x.clone()) == x.len());\n     // Call a parameterized function, with type arguments that require\n     // a borrow\n-    assert!(length::<int, &[int]>(x) == vec::len(x));\n+    assert!(length::<int, &[int]>(x) == x.len());\n \n     // Now try it with a type that *needs* to be borrowed\n     let z = [0,1,2,3];\n     // Call a method\n     for z.iterate() |y| { assert!(z[*y] == *y); }\n     // Call a parameterized function\n-    assert!(length::<int, &[int]>(z) == vec::len(z));\n+    assert!(length::<int, &[int]>(z) == z.len());\n }"}, {"sha": "61dfcfed7bdfdeace7eabcc730d0674cc6a09ad0", "filename": "src/test/run-pass/class-implements-multiple-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -103,7 +103,7 @@ fn annoy_neighbors<T:noisy>(critter: T) {\n \n fn bite_everything<T:bitey>(critter: T) -> bool {\n   let mut left : ~[body_part] = ~[finger, toe, nose, ear];\n-  while vec::len(left) > 0u {\n+  while left.len() > 0u {\n     let part = critter.bite();\n     debug!(\"%? %?\", left, part);\n     if vec_includes(left, part) {"}, {"sha": "c6ae2047147b11d45eeaaeb90836b8552316ad41", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -71,7 +71,7 @@ mod map_reduce {\n \n         start_mappers(ctrl_chan, inputs.clone());\n \n-        let mut num_mappers = vec::len(inputs) as int;\n+        let mut num_mappers = inputs.len() as int;\n \n         while num_mappers > 0 {\n             match ctrl_port.recv() {"}, {"sha": "7507a78378e8fc729f3e98f61c7e6227f50b2629", "filename": "src/test/run-pass/vec-self-append.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Frun-pass%2Fvec-self-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8261009948ed1cfbbdaf4ecc3fadef795b27b7/src%2Ftest%2Frun-pass%2Fvec-self-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-self-append.rs?ref=4e8261009948ed1cfbbdaf4ecc3fadef795b27b7", "patch": "@@ -14,7 +14,7 @@ fn test_heap_to_heap() {\n     // a spills onto the heap\n     let mut a = ~[0, 1, 2, 3, 4];\n     a = a + a; // FIXME(#3387)---can't write a += a\n-    assert!((vec::len(a) == 10u));\n+    assert!(a.len() == 10u);\n     assert!((a[0] == 0));\n     assert!((a[1] == 1));\n     assert!((a[2] == 2));\n@@ -32,7 +32,7 @@ fn test_stack_to_heap() {\n     let mut a = ~[0, 1, 2];\n     // a spills to the heap\n     a = a + a; // FIXME(#3387)---can't write a += a\n-    assert!((vec::len(a) == 6u));\n+    assert!(a.len() == 6u);\n     assert!((a[0] == 0));\n     assert!((a[1] == 1));\n     assert!((a[2] == 2));\n@@ -47,8 +47,8 @@ fn test_loop() {\n     let mut i = 20;\n     let mut expected_len = 1u;\n     while i > 0 {\n-        error!(vec::len(a));\n-        assert!((vec::len(a) == expected_len));\n+        error!(a.len());\n+        assert!(a.len() == expected_len);\n         a = a + a; // FIXME(#3387)---can't write a += a\n         i -= 1;\n         expected_len *= 2u;"}]}