{"sha": "2e35f954ada0f0c777844dc4fa66684efe90a035", "node_id": "C_kwDOAAsO6NoAKDJlMzVmOTU0YWRhMGYwYzc3Nzg0NGRjNGZhNjY2ODRlZmU5MGEwMzU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-01T19:31:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-01T19:31:14Z"}, "message": "Auto merge of #98960 - cjgillot:entry-kind, r=estebank\n\nRemove EntryKind from metadata.\n\nThis PR continues the refactor of metadata emission to be more systematic, iterating on definitions and filtering based on each definition's `DefKind`. This allows to remove the large `EntryKind` enum, replaced by linear tables in metadata.", "tree": {"sha": "0f32b8fa31fd411df68e3ae880872823dce5d13a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f32b8fa31fd411df68e3ae880872823dce5d13a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e35f954ada0f0c777844dc4fa66684efe90a035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e35f954ada0f0c777844dc4fa66684efe90a035", "html_url": "https://github.com/rust-lang/rust/commit/2e35f954ada0f0c777844dc4fa66684efe90a035", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e35f954ada0f0c777844dc4fa66684efe90a035/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9af618b62e91b45d61f41548f24ba60b834e362b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9af618b62e91b45d61f41548f24ba60b834e362b", "html_url": "https://github.com/rust-lang/rust/commit/9af618b62e91b45d61f41548f24ba60b834e362b"}, {"sha": "60a052f4d308b4b7e3b6132fd4bb2a48082b066c", "url": "https://api.github.com/repos/rust-lang/rust/commits/60a052f4d308b4b7e3b6132fd4bb2a48082b066c", "html_url": "https://github.com/rust-lang/rust/commit/60a052f4d308b4b7e3b6132fd4bb2a48082b066c"}], "stats": {"total": 607, "additions": 252, "deletions": 355}, "files": [{"sha": "6f026678170b7af312fbde3ba26f97d40ebf3982", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 50, "deletions": 68, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/2e35f954ada0f0c777844dc4fa66684efe90a035/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e35f954ada0f0c777844dc4fa66684efe90a035/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=2e35f954ada0f0c777844dc4fa66684efe90a035", "patch": "@@ -4,7 +4,6 @@ use crate::creader::{CStore, CrateMetadataRef};\n use crate::rmeta::*;\n \n use rustc_ast as ast;\n-use rustc_ast::ptr::P;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n@@ -33,7 +32,7 @@ use rustc_session::cstore::{\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnIndex, MacroKind};\n use rustc_span::source_map::{respan, Spanned};\n-use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{self, BytePos, ExpnId, Pos, Span, SyntaxContext, DUMMY_SP};\n \n use proc_macro::bridge::client::ProcMacro;\n@@ -785,26 +784,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.opt_item_ident(item_index, sess).expect(\"no encoded ident for item\")\n     }\n \n-    fn maybe_kind(self, item_id: DefIndex) -> Option<EntryKind> {\n-        self.root.tables.kind.get(self, item_id).map(|k| k.decode(self))\n-    }\n-\n     #[inline]\n     pub(super) fn map_encoded_cnum_to_current(self, cnum: CrateNum) -> CrateNum {\n         if cnum == LOCAL_CRATE { self.cnum } else { self.cnum_map[cnum] }\n     }\n \n-    fn kind(self, item_id: DefIndex) -> EntryKind {\n-        self.maybe_kind(item_id).unwrap_or_else(|| {\n-            bug!(\n-                \"CrateMetadata::kind({:?}): id not found, in crate {:?} with number {}\",\n-                item_id,\n-                self.root.name,\n-                self.cnum,\n-            )\n-        })\n-    }\n-\n     fn def_kind(self, item_id: DefIndex) -> DefKind {\n         self.root.tables.opt_def_kind.get(self, item_id).unwrap_or_else(|| {\n             bug!(\n@@ -856,21 +840,16 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         )\n     }\n \n-    fn get_variant(self, kind: &EntryKind, index: DefIndex, parent_did: DefId) -> ty::VariantDef {\n-        let data = match kind {\n-            EntryKind::Variant(data) | EntryKind::Struct(data) | EntryKind::Union(data) => {\n-                data.decode(self)\n-            }\n-            _ => bug!(),\n-        };\n-\n+    fn get_variant(self, kind: &DefKind, index: DefIndex, parent_did: DefId) -> ty::VariantDef {\n         let adt_kind = match kind {\n-            EntryKind::Variant(_) => ty::AdtKind::Enum,\n-            EntryKind::Struct(..) => ty::AdtKind::Struct,\n-            EntryKind::Union(..) => ty::AdtKind::Union,\n+            DefKind::Variant => ty::AdtKind::Enum,\n+            DefKind::Struct => ty::AdtKind::Struct,\n+            DefKind::Union => ty::AdtKind::Union,\n             _ => bug!(),\n         };\n \n+        let data = self.root.tables.variant_data.get(self, index).unwrap().decode(self);\n+\n         let variant_did =\n             if adt_kind == ty::AdtKind::Enum { Some(self.local_def_id(index)) } else { None };\n         let ctor_did = data.ctor.map(|index| self.local_def_id(index));\n@@ -901,13 +880,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_adt_def(self, item_id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::AdtDef<'tcx> {\n-        let kind = self.kind(item_id);\n+        let kind = self.def_kind(item_id);\n         let did = self.local_def_id(item_id);\n \n         let adt_kind = match kind {\n-            EntryKind::Enum => ty::AdtKind::Enum,\n-            EntryKind::Struct(_) => ty::AdtKind::Struct,\n-            EntryKind::Union(_) => ty::AdtKind::Union,\n+            DefKind::Enum => ty::AdtKind::Enum,\n+            DefKind::Struct => ty::AdtKind::Struct,\n+            DefKind::Union => ty::AdtKind::Union,\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n         let repr = self.root.tables.repr_options.get(self, item_id).unwrap().decode(self);\n@@ -919,7 +898,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .get(self, item_id)\n                 .unwrap_or_else(LazyArray::empty)\n                 .decode(self)\n-                .map(|index| self.get_variant(&self.kind(index), index, did))\n+                .map(|index| self.get_variant(&self.def_kind(index), index, did))\n                 .collect()\n         } else {\n             std::iter::once(self.get_variant(&kind, item_id, did)).collect()\n@@ -1029,10 +1008,9 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 let vis = self.get_visibility(child_index);\n                 let span = self.get_span(child_index, sess);\n                 let macro_rules = match kind {\n-                    DefKind::Macro(..) => match self.kind(child_index) {\n-                        EntryKind::MacroDef(_, macro_rules) => macro_rules,\n-                        _ => unreachable!(),\n-                    },\n+                    DefKind::Macro(..) => {\n+                        self.root.tables.macro_rules.get(self, child_index).is_some()\n+                    }\n                     _ => false,\n                 };\n \n@@ -1086,14 +1064,10 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             }\n         }\n \n-        match self.kind(id) {\n-            EntryKind::Mod(exports) => {\n-                for exp in exports.decode((self, sess)) {\n-                    callback(exp);\n-                }\n+        if let Some(exports) = self.root.tables.module_reexports.get(self, id) {\n+            for exp in exports.decode((self, sess)) {\n+                callback(exp);\n             }\n-            EntryKind::Enum | EntryKind::Trait => {}\n-            _ => bug!(\"`for_each_module_child` is called on a non-module: {:?}\", self.def_kind(id)),\n         }\n     }\n \n@@ -1106,19 +1080,21 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn module_expansion(self, id: DefIndex, sess: &Session) -> ExpnId {\n-        match self.kind(id) {\n-            EntryKind::Mod(_) | EntryKind::Enum | EntryKind::Trait => {\n-                self.get_expn_that_defined(id, sess)\n-            }\n+        match self.def_kind(id) {\n+            DefKind::Mod | DefKind::Enum | DefKind::Trait => self.get_expn_that_defined(id, sess),\n             _ => panic!(\"Expected module, found {:?}\", self.local_def_id(id)),\n         }\n     }\n \n-    fn get_fn_has_self_parameter(self, id: DefIndex) -> bool {\n-        match self.kind(id) {\n-            EntryKind::AssocFn { has_self, .. } => has_self,\n-            _ => false,\n-        }\n+    fn get_fn_has_self_parameter(self, id: DefIndex, sess: &'a Session) -> bool {\n+        self.root\n+            .tables\n+            .fn_arg_names\n+            .get(self, id)\n+            .unwrap_or_else(LazyArray::empty)\n+            .decode((self, sess))\n+            .nth(0)\n+            .map_or(false, |ident| ident.name == kw::SelfLower)\n     }\n \n     fn get_associated_item_def_ids(\n@@ -1135,15 +1111,17 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .map(move |child_index| self.local_def_id(child_index))\n     }\n \n-    fn get_associated_item(self, id: DefIndex) -> ty::AssocItem {\n+    fn get_associated_item(self, id: DefIndex, sess: &'a Session) -> ty::AssocItem {\n         let name = self.item_name(id);\n \n-        let (kind, container, has_self) = match self.kind(id) {\n-            EntryKind::AssocConst(container) => (ty::AssocKind::Const, container, false),\n-            EntryKind::AssocFn { container, has_self } => (ty::AssocKind::Fn, container, has_self),\n-            EntryKind::AssocType(container) => (ty::AssocKind::Type, container, false),\n-            _ => bug!(\"cannot get associated-item of `{:?}`\", id),\n+        let kind = match self.def_kind(id) {\n+            DefKind::AssocConst => ty::AssocKind::Const,\n+            DefKind::AssocFn => ty::AssocKind::Fn,\n+            DefKind::AssocTy => ty::AssocKind::Type,\n+            _ => bug!(\"cannot get associated-item of `{:?}`\", self.def_key(id)),\n         };\n+        let has_self = self.get_fn_has_self_parameter(id, sess);\n+        let container = self.root.tables.assoc_container.get(self, id).unwrap();\n \n         ty::AssocItem {\n             name,\n@@ -1156,9 +1134,9 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_ctor_def_id_and_kind(self, node_id: DefIndex) -> Option<(DefId, CtorKind)> {\n-        match self.kind(node_id) {\n-            EntryKind::Struct(data) | EntryKind::Variant(data) => {\n-                let vdata = data.decode(self);\n+        match self.def_kind(node_id) {\n+            DefKind::Struct | DefKind::Variant => {\n+                let vdata = self.root.tables.variant_data.get(self, node_id).unwrap().decode(self);\n                 vdata.ctor.map(|index| (self.local_def_id(index), vdata.ctor_kind))\n             }\n             _ => None,\n@@ -1346,18 +1324,22 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_macro(self, id: DefIndex, sess: &Session) -> ast::MacroDef {\n-        match self.kind(id) {\n-            EntryKind::MacroDef(mac_args, macro_rules) => {\n-                ast::MacroDef { body: P(mac_args.decode((self, sess))), macro_rules }\n+        match self.def_kind(id) {\n+            DefKind::Macro(_) => {\n+                let macro_rules = self.root.tables.macro_rules.get(self, id).is_some();\n+                let body =\n+                    self.root.tables.macro_definition.get(self, id).unwrap().decode((self, sess));\n+                ast::MacroDef { macro_rules, body: ast::ptr::P(body) }\n             }\n             _ => bug!(),\n         }\n     }\n \n     fn is_foreign_item(self, id: DefIndex) -> bool {\n-        match self.kind(id) {\n-            EntryKind::ForeignStatic | EntryKind::ForeignFn => true,\n-            _ => false,\n+        if let Some(parent) = self.def_key(id).parent {\n+            matches!(self.def_kind(parent), DefKind::ForeignMod)\n+        } else {\n+            false\n         }\n     }\n "}, {"sha": "6b447ebd99910ae21f348d34728e24b00095168f", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e35f954ada0f0c777844dc4fa66684efe90a035/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e35f954ada0f0c777844dc4fa66684efe90a035/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=2e35f954ada0f0c777844dc4fa66684efe90a035", "patch": "@@ -233,7 +233,7 @@ provide! { tcx, def_id, other, cdata,\n     associated_item_def_ids => {\n         tcx.arena.alloc_from_iter(cdata.get_associated_item_def_ids(def_id.index, tcx.sess))\n     }\n-    associated_item => { cdata.get_associated_item(def_id.index) }\n+    associated_item => { cdata.get_associated_item(def_id.index, tcx.sess) }\n     inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n     item_attrs => { tcx.arena.alloc_from_iter(cdata.get_item_attrs(def_id.index, tcx.sess)) }\n@@ -535,8 +535,8 @@ impl CStore {\n         )\n     }\n \n-    pub fn fn_has_self_parameter_untracked(&self, def: DefId) -> bool {\n-        self.get_crate_data(def.krate).get_fn_has_self_parameter(def.index)\n+    pub fn fn_has_self_parameter_untracked(&self, def: DefId, sess: &Session) -> bool {\n+        self.get_crate_data(def.krate).get_fn_has_self_parameter(def.index, sess)\n     }\n \n     pub fn crate_source_untracked(&self, cnum: CrateNum) -> Lrc<CrateSource> {"}, {"sha": "4be4d4b7872aeeaa7d745d034cf2daf247ac3e4e", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 174, "deletions": 247, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/2e35f954ada0f0c777844dc4fa66684efe90a035/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e35f954ada0f0c777844dc4fa66684efe90a035/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=2e35f954ada0f0c777844dc4fa66684efe90a035", "patch": "@@ -16,7 +16,6 @@ use rustc_hir::def_id::{\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::lang_items;\n-use rustc_hir::{AnonConst, GenericParamKind};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::{\n@@ -1019,6 +1018,89 @@ fn should_encode_generics(def_kind: DefKind) -> bool {\n     }\n }\n \n+fn should_encode_type(tcx: TyCtxt<'_>, def_id: LocalDefId, def_kind: DefKind) -> bool {\n+    match def_kind {\n+        DefKind::Struct\n+        | DefKind::Union\n+        | DefKind::Enum\n+        | DefKind::Variant\n+        | DefKind::Ctor(..)\n+        | DefKind::Field\n+        | DefKind::Fn\n+        | DefKind::Const\n+        | DefKind::Static(..)\n+        | DefKind::TyAlias\n+        | DefKind::OpaqueTy\n+        | DefKind::ForeignTy\n+        | DefKind::Impl\n+        | DefKind::AssocFn\n+        | DefKind::AssocConst\n+        | DefKind::Closure\n+        | DefKind::Generator\n+        | DefKind::ConstParam\n+        | DefKind::AnonConst\n+        | DefKind::InlineConst => true,\n+\n+        DefKind::AssocTy => {\n+            let assoc_item = tcx.associated_item(def_id);\n+            match assoc_item.container {\n+                ty::AssocItemContainer::ImplContainer => true,\n+                ty::AssocItemContainer::TraitContainer => assoc_item.defaultness(tcx).has_value(),\n+            }\n+        }\n+        DefKind::TyParam => {\n+            let hir::Node::GenericParam(param) = tcx.hir().get_by_def_id(def_id) else { bug!() };\n+            let hir::GenericParamKind::Type { default, .. } = param.kind else { bug!() };\n+            default.is_some()\n+        }\n+\n+        DefKind::Trait\n+        | DefKind::TraitAlias\n+        | DefKind::Mod\n+        | DefKind::ForeignMod\n+        | DefKind::Macro(..)\n+        | DefKind::Use\n+        | DefKind::LifetimeParam\n+        | DefKind::GlobalAsm\n+        | DefKind::ExternCrate => false,\n+    }\n+}\n+\n+fn should_encode_const(def_kind: DefKind) -> bool {\n+    match def_kind {\n+        DefKind::Const | DefKind::AssocConst | DefKind::AnonConst => true,\n+\n+        DefKind::Struct\n+        | DefKind::Union\n+        | DefKind::Enum\n+        | DefKind::Variant\n+        | DefKind::Ctor(..)\n+        | DefKind::Field\n+        | DefKind::Fn\n+        | DefKind::Static(..)\n+        | DefKind::TyAlias\n+        | DefKind::OpaqueTy\n+        | DefKind::ForeignTy\n+        | DefKind::Impl\n+        | DefKind::AssocFn\n+        | DefKind::Closure\n+        | DefKind::Generator\n+        | DefKind::ConstParam\n+        | DefKind::InlineConst\n+        | DefKind::AssocTy\n+        | DefKind::TyParam\n+        | DefKind::Trait\n+        | DefKind::TraitAlias\n+        | DefKind::Mod\n+        | DefKind::ForeignMod\n+        | DefKind::Macro(..)\n+        | DefKind::Use\n+        | DefKind::LifetimeParam\n+        | DefKind::GlobalAsm\n+        | DefKind::ExternCrate => false,\n+    }\n+}\n+\n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_attrs(&mut self, def_id: LocalDefId) {\n         let mut attrs = self\n@@ -1044,7 +1126,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let def_kind = tcx.opt_def_kind(local_id);\n             let Some(def_kind) = def_kind else { continue };\n             self.tables.opt_def_kind.set(def_id.index, def_kind);\n-            record!(self.tables.def_span[def_id] <- tcx.def_span(def_id));\n+            let def_span = tcx.def_span(local_id);\n+            record!(self.tables.def_span[def_id] <- def_span);\n             self.encode_attrs(local_id);\n             record!(self.tables.expn_that_defined[def_id] <- self.tcx.expn_that_defined(def_id));\n             if let Some(ident_span) = tcx.def_ident_span(def_id) {\n@@ -1075,6 +1158,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     record_array!(self.tables.inferred_outlives_of[def_id] <- inferred_outlives);\n                 }\n             }\n+            if should_encode_type(tcx, local_id, def_kind) {\n+                record!(self.tables.type_of[def_id] <- self.tcx.type_of(def_id));\n+            }\n             if let DefKind::TyParam | DefKind::ConstParam = def_kind {\n                 if let Some(default) = self.tcx.object_lifetime_default(def_id) {\n                     record!(self.tables.object_lifetime_default[def_id] <- default);\n@@ -1096,11 +1182,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_item_type(&mut self, def_id: DefId) {\n-        debug!(\"EncodeContext::encode_item_type({:?})\", def_id);\n-        record!(self.tables.type_of[def_id] <- self.tcx.type_of(def_id));\n-    }\n-\n     fn encode_enum_variant_info(&mut self, def: ty::AdtDef<'tcx>, index: VariantIdx) {\n         let tcx = self.tcx;\n         let variant = &def.variant(index);\n@@ -1114,13 +1195,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n-        record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n+        record!(self.tables.variant_data[def_id] <- data);\n         self.tables.constness.set(def_id.index, hir::Constness::Const);\n         record_array!(self.tables.children[def_id] <- variant.fields.iter().map(|f| {\n             assert!(f.did.is_local());\n             f.did.index\n         }));\n-        self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n             // FIXME(eddyb) encode signature only in `encode_enum_variant_ctor`.\n             if let Some(ctor_def_id) = variant.ctor_def_id {\n@@ -1143,9 +1223,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n-        record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n+        record!(self.tables.variant_data[def_id] <- data);\n         self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }\n@@ -1162,15 +1241,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // code uses it). However, we skip encoding anything relating to child\n         // items - we encode information about proc-macros later on.\n         let reexports = if !self.is_proc_macro {\n-            match tcx.module_reexports(local_def_id) {\n-                Some(exports) => self.lazy_array(exports),\n-                _ => LazyArray::empty(),\n-            }\n+            tcx.module_reexports(local_def_id).unwrap_or(&[])\n         } else {\n-            LazyArray::empty()\n+            &[]\n         };\n \n-        record!(self.tables.kind[def_id] <- EntryKind::Mod(reexports));\n+        record_array!(self.tables.module_reexports[def_id] <- reexports);\n         if self.is_proc_macro {\n             // Encode this here because we don't do it in encode_def_ids.\n             record!(self.tables.expn_that_defined[def_id] <- tcx.expn_that_defined(local_def_id));\n@@ -1198,22 +1274,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_field(\n-        &mut self,\n-        adt_def: ty::AdtDef<'tcx>,\n-        variant_index: VariantIdx,\n-        field_index: usize,\n-    ) {\n-        let variant = &adt_def.variant(variant_index);\n-        let field = &variant.fields[field_index];\n-\n-        let def_id = field.did;\n-        debug!(\"EncodeContext::encode_field({:?})\", def_id);\n-\n-        record!(self.tables.kind[def_id] <- EntryKind::Field);\n-        self.encode_item_type(def_id);\n-    }\n-\n     fn encode_struct_ctor(&mut self, adt_def: ty::AdtDef<'tcx>, def_id: DefId) {\n         debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -1227,9 +1287,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.repr_options[def_id] <- adt_def.repr());\n+        record!(self.tables.variant_data[def_id] <- data);\n         self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        record!(self.tables.kind[def_id] <- EntryKind::Struct(self.lazy(data)));\n-        self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }\n@@ -1250,18 +1309,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let ast_item = tcx.hir().expect_trait_item(def_id.expect_local());\n         self.tables.impl_defaultness.set(def_id.index, ast_item.defaultness);\n         let trait_item = tcx.associated_item(def_id);\n+        self.tables.assoc_container.set(def_id.index, trait_item.container);\n \n         match trait_item.kind {\n-            ty::AssocKind::Const => {\n-                let rendered = rustc_hir_pretty::to_string(\n-                    &(&self.tcx.hir() as &dyn intravisit::Map<'_>),\n-                    |s| s.print_trait_item(ast_item),\n-                );\n-\n-                record!(self.tables.kind[def_id] <- EntryKind::AssocConst(ty::AssocItemContainer::TraitContainer));\n-                record!(self.tables.mir_const_qualif[def_id] <- mir::ConstQualifs::default());\n-                record!(self.tables.rendered_const[def_id] <- rendered);\n-            }\n+            ty::AssocKind::Const => {}\n             ty::AssocKind::Fn => {\n                 let hir::TraitItemKind::Fn(m_sig, m) = &ast_item.kind else { bug!() };\n                 match *m {\n@@ -1274,24 +1325,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 };\n                 self.tables.asyncness.set(def_id.index, m_sig.header.asyncness);\n                 self.tables.constness.set(def_id.index, hir::Constness::NotConst);\n-                record!(self.tables.kind[def_id] <- EntryKind::AssocFn {\n-                    container: ty::AssocItemContainer::TraitContainer,\n-                    has_self: trait_item.fn_has_self_parameter,\n-                });\n             }\n             ty::AssocKind::Type => {\n                 self.encode_explicit_item_bounds(def_id);\n-                record!(self.tables.kind[def_id] <- EntryKind::AssocType(ty::AssocItemContainer::TraitContainer));\n-            }\n-        }\n-        match trait_item.kind {\n-            ty::AssocKind::Const | ty::AssocKind::Fn => {\n-                self.encode_item_type(def_id);\n-            }\n-            ty::AssocKind::Type => {\n-                if ast_item.defaultness.has_value() {\n-                    self.encode_item_type(def_id);\n-                }\n             }\n         }\n         if trait_item.kind == ty::AssocKind::Fn {\n@@ -1306,20 +1342,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let ast_item = self.tcx.hir().expect_impl_item(def_id.expect_local());\n         self.tables.impl_defaultness.set(def_id.index, ast_item.defaultness);\n         let impl_item = self.tcx.associated_item(def_id);\n+        self.tables.assoc_container.set(def_id.index, impl_item.container);\n \n         match impl_item.kind {\n-            ty::AssocKind::Const => {\n-                if let hir::ImplItemKind::Const(_, body_id) = ast_item.kind {\n-                    let qualifs = self.tcx.at(ast_item.span).mir_const_qualif(def_id);\n-                    let const_data = self.encode_rendered_const_for_body(body_id);\n-\n-                    record!(self.tables.kind[def_id] <- EntryKind::AssocConst(ty::AssocItemContainer::ImplContainer));\n-                    record!(self.tables.mir_const_qualif[def_id] <- qualifs);\n-                    record!(self.tables.rendered_const[def_id] <- const_data);\n-                } else {\n-                    bug!()\n-                }\n-            }\n             ty::AssocKind::Fn => {\n                 let hir::ImplItemKind::Fn(ref sig, body) = ast_item.kind else { bug!() };\n                 self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n@@ -1331,16 +1356,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     hir::Constness::NotConst\n                 };\n                 self.tables.constness.set(def_id.index, constness);\n-                record!(self.tables.kind[def_id] <- EntryKind::AssocFn {\n-                    container: ty::AssocItemContainer::ImplContainer,\n-                    has_self: impl_item.fn_has_self_parameter,\n-                });\n-            }\n-            ty::AssocKind::Type => {\n-                record!(self.tables.kind[def_id] <- EntryKind::AssocType(ty::AssocItemContainer::ImplContainer));\n             }\n+            ty::AssocKind::Const | ty::AssocKind::Type => {}\n         }\n-        self.encode_item_type(def_id);\n         if let Some(trait_item_def_id) = impl_item.trait_item_def_id {\n             self.tables.trait_item_def_id.set(def_id.index, trait_item_def_id.into());\n         }\n@@ -1357,12 +1375,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             return;\n         }\n \n-        let keys_and_jobs = self\n-            .tcx\n+        let tcx = self.tcx;\n+\n+        let keys_and_jobs = tcx\n             .mir_keys(())\n             .iter()\n             .filter_map(|&def_id| {\n-                let (encode_const, encode_opt) = should_encode_mir(self.tcx, def_id);\n+                let (encode_const, encode_opt) = should_encode_mir(tcx, def_id);\n                 if encode_const || encode_opt {\n                     Some((def_id, encode_const, encode_opt))\n                 } else {\n@@ -1375,22 +1394,32 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n             if encode_opt {\n-                record!(self.tables.optimized_mir[def_id.to_def_id()] <- self.tcx.optimized_mir(def_id));\n+                record!(self.tables.optimized_mir[def_id.to_def_id()] <- tcx.optimized_mir(def_id));\n             }\n             if encode_const {\n-                record!(self.tables.mir_for_ctfe[def_id.to_def_id()] <- self.tcx.mir_for_ctfe(def_id));\n+                record!(self.tables.mir_for_ctfe[def_id.to_def_id()] <- tcx.mir_for_ctfe(def_id));\n \n                 // FIXME(generic_const_exprs): this feels wrong to have in `encode_mir`\n-                let abstract_const = self.tcx.thir_abstract_const(def_id);\n+                let abstract_const = tcx.thir_abstract_const(def_id);\n                 if let Ok(Some(abstract_const)) = abstract_const {\n                     record!(self.tables.thir_abstract_const[def_id.to_def_id()] <- abstract_const);\n                 }\n+\n+                if should_encode_const(tcx.def_kind(def_id)) {\n+                    let qualifs = tcx.mir_const_qualif(def_id);\n+                    record!(self.tables.mir_const_qualif[def_id.to_def_id()] <- qualifs);\n+                    let body_id = tcx.hir().maybe_body_owned_by(def_id);\n+                    if let Some(body_id) = body_id {\n+                        let const_data = self.encode_rendered_const_for_body(body_id);\n+                        record!(self.tables.rendered_const[def_id.to_def_id()] <- const_data);\n+                    }\n+                }\n             }\n-            record!(self.tables.promoted_mir[def_id.to_def_id()] <- self.tcx.promoted_mir(def_id));\n+            record!(self.tables.promoted_mir[def_id.to_def_id()] <- tcx.promoted_mir(def_id));\n \n             let instance =\n                 ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id.to_def_id()));\n-            let unused = self.tcx.unused_generic_params(instance);\n+            let unused = tcx.unused_generic_params(instance);\n             if !unused.is_empty() {\n                 record!(self.tables.unused_generic_params[def_id.to_def_id()] <- unused);\n             }\n@@ -1453,38 +1482,27 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n-        let entry_kind = match item.kind {\n-            hir::ItemKind::Static(..) => EntryKind::Static,\n-            hir::ItemKind::Const(_, body_id) => {\n-                let qualifs = self.tcx.at(item.span).mir_const_qualif(def_id);\n-                let const_data = self.encode_rendered_const_for_body(body_id);\n-                record!(self.tables.mir_const_qualif[def_id] <- qualifs);\n-                record!(self.tables.rendered_const[def_id] <- const_data);\n-                EntryKind::Const\n-            }\n+        match item.kind {\n             hir::ItemKind::Fn(ref sig, .., body) => {\n                 self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n                 self.tables.constness.set(def_id.index, sig.header.constness);\n-                EntryKind::Fn\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n-                EntryKind::MacroDef(self.lazy(&*macro_def.body), macro_def.macro_rules)\n+                if macro_def.macro_rules {\n+                    self.tables.macro_rules.set(def_id.index, ());\n+                }\n+                record!(self.tables.macro_definition[def_id] <- &*macro_def.body);\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 return self.encode_info_for_mod(item.def_id, m);\n             }\n-            hir::ItemKind::ForeignMod { .. } => EntryKind::ForeignMod,\n-            hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n-            hir::ItemKind::TyAlias(..) => EntryKind::Type,\n             hir::ItemKind::OpaqueTy(..) => {\n                 self.encode_explicit_item_bounds(def_id);\n-                EntryKind::OpaqueTy\n             }\n             hir::ItemKind::Enum(..) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n                 record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-                EntryKind::Enum\n             }\n             hir::ItemKind::Struct(ref struct_def, _) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n@@ -1499,24 +1517,24 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     .map(|ctor_hir_id| self.tcx.hir().local_def_id(ctor_hir_id).local_def_index);\n \n                 let variant = adt_def.non_enum_variant();\n-                EntryKind::Struct(self.lazy(VariantData {\n+                record!(self.tables.variant_data[def_id] <- VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor,\n                     is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                }))\n+                });\n             }\n             hir::ItemKind::Union(..) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n                 record!(self.tables.repr_options[def_id] <- adt_def.repr());\n \n                 let variant = adt_def.non_enum_variant();\n-                EntryKind::Union(self.lazy(VariantData {\n+                record!(self.tables.variant_data[def_id] <- VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor: None,\n                     is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                }))\n+                });\n             }\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n                 self.tables.impl_defaultness.set(def_id.index, *defaultness);\n@@ -1542,26 +1560,24 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 let polarity = self.tcx.impl_polarity(def_id);\n                 self.tables.impl_polarity.set(def_id.index, polarity);\n-\n-                EntryKind::Impl\n             }\n             hir::ItemKind::Trait(..) => {\n                 let trait_def = self.tcx.trait_def(def_id);\n                 record!(self.tables.trait_def[def_id] <- trait_def);\n-\n-                EntryKind::Trait\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 let trait_def = self.tcx.trait_def(def_id);\n                 record!(self.tables.trait_def[def_id] <- trait_def);\n-\n-                EntryKind::TraitAlias\n             }\n             hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {\n                 bug!(\"cannot encode info for item {:?}\", item)\n             }\n+            hir::ItemKind::Static(..)\n+            | hir::ItemKind::Const(..)\n+            | hir::ItemKind::ForeignMod { .. }\n+            | hir::ItemKind::GlobalAsm(..)\n+            | hir::ItemKind::TyAlias(..) => {}\n         };\n-        record!(self.tables.kind[def_id] <- entry_kind);\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n             hir::ItemKind::Enum(..) => record_array!(self.tables.children[def_id] <-\n@@ -1589,18 +1605,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             _ => {}\n         }\n-        match item.kind {\n-            hir::ItemKind::Static(..)\n-            | hir::ItemKind::Const(..)\n-            | hir::ItemKind::Fn(..)\n-            | hir::ItemKind::TyAlias(..)\n-            | hir::ItemKind::OpaqueTy(..)\n-            | hir::ItemKind::Enum(..)\n-            | hir::ItemKind::Struct(..)\n-            | hir::ItemKind::Union(..)\n-            | hir::ItemKind::Impl { .. } => self.encode_item_type(def_id),\n-            _ => {}\n-        }\n         if let hir::ItemKind::Fn(..) = item.kind {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             if tcx.is_intrinsic(def_id) {\n@@ -1612,12 +1616,43 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.impl_trait_ref[def_id] <- trait_ref);\n             }\n         }\n-    }\n+        // In some cases, along with the item itself, we also\n+        // encode some sub-items. Usually we want some info from the item\n+        // so it's easier to do that here then to wait until we would encounter\n+        // normally in the visitor walk.\n+        match item.kind {\n+            hir::ItemKind::Enum(..) => {\n+                let def = self.tcx.adt_def(item.def_id.to_def_id());\n+                for (i, variant) in def.variants().iter_enumerated() {\n+                    self.encode_enum_variant_info(def, i);\n \n-    fn encode_info_for_generic_param(&mut self, def_id: DefId, kind: EntryKind, encode_type: bool) {\n-        record!(self.tables.kind[def_id] <- kind);\n-        if encode_type {\n-            self.encode_item_type(def_id);\n+                    if let Some(_ctor_def_id) = variant.ctor_def_id {\n+                        self.encode_enum_variant_ctor(def, i);\n+                    }\n+                }\n+            }\n+            hir::ItemKind::Struct(ref struct_def, _) => {\n+                let def = self.tcx.adt_def(item.def_id.to_def_id());\n+                // If the struct has a constructor, encode it.\n+                if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n+                    let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n+                    self.encode_struct_ctor(def, ctor_def_id.to_def_id());\n+                }\n+            }\n+            hir::ItemKind::Impl { .. } => {\n+                for &trait_item_def_id in\n+                    self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n+                {\n+                    self.encode_info_for_impl_item(trait_item_def_id);\n+                }\n+            }\n+            hir::ItemKind::Trait(..) => {\n+                for &item_def_id in self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n+                {\n+                    self.encode_info_for_trait_item(item_def_id);\n+                }\n+            }\n+            _ => {}\n         }\n     }\n \n@@ -1632,34 +1667,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             ty::Generator(..) => {\n                 let data = self.tcx.generator_kind(def_id).unwrap();\n                 let generator_diagnostic_data = typeck_result.get_generator_diagnostic_data();\n-                record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::Generator);\n                 record!(self.tables.generator_kind[def_id.to_def_id()] <- data);\n                 record!(self.tables.generator_diagnostic_data[def_id.to_def_id()]  <- generator_diagnostic_data);\n             }\n \n-            ty::Closure(..) => {\n-                record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::Closure);\n+            ty::Closure(_, substs) => {\n+                record!(self.tables.fn_sig[def_id.to_def_id()] <- substs.as_closure().sig());\n             }\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n         }\n-        self.encode_item_type(def_id.to_def_id());\n-        if let ty::Closure(def_id, substs) = *ty.kind() {\n-            record!(self.tables.fn_sig[def_id] <- substs.as_closure().sig());\n-        }\n-    }\n-\n-    fn encode_info_for_anon_const(&mut self, id: hir::HirId) {\n-        let def_id = self.tcx.hir().local_def_id(id);\n-        debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n-        let body_id = self.tcx.hir().body_owned_by(def_id);\n-        let const_data = self.encode_rendered_const_for_body(body_id);\n-        let qualifs = self.tcx.mir_const_qualif(def_id);\n-\n-        record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::AnonConst);\n-        record!(self.tables.mir_const_qualif[def_id.to_def_id()] <- qualifs);\n-        record!(self.tables.rendered_const[def_id.to_def_id()] <- const_data);\n-        self.encode_item_type(def_id.to_def_id());\n     }\n \n     fn encode_native_libraries(&mut self) -> LazyArray<NativeLib> {\n@@ -1757,7 +1774,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 let def_id = id.to_def_id();\n                 self.tables.opt_def_kind.set(def_id.index, DefKind::Macro(macro_kind));\n-                record!(self.tables.kind[def_id] <- EntryKind::ProcMacro(macro_kind));\n+                self.tables.proc_macro.set(def_id.index, macro_kind);\n                 self.encode_attrs(id);\n                 record!(self.tables.def_keys[def_id] <- def_key);\n                 record!(self.tables.def_ident_span[def_id] <- span);\n@@ -1995,18 +2012,11 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     hir::Constness::NotConst\n                 };\n                 self.tables.constness.set(def_id.index, constness);\n-                record!(self.tables.kind[def_id] <- EntryKind::ForeignFn);\n-            }\n-            hir::ForeignItemKind::Static(..) => {\n-                record!(self.tables.kind[def_id] <- EntryKind::ForeignStatic);\n-            }\n-            hir::ForeignItemKind::Type => {\n-                record!(self.tables.kind[def_id] <- EntryKind::ForeignType);\n+                record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             }\n+            hir::ForeignItemKind::Static(..) | hir::ForeignItemKind::Type => {}\n         }\n-        self.encode_item_type(def_id);\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n-            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             if tcx.is_intrinsic(def_id) {\n                 self.tables.is_intrinsic.set(def_id.index, ());\n             }\n@@ -2025,17 +2035,12 @@ impl<'a, 'tcx> Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n         intravisit::walk_expr(self, ex);\n         self.encode_info_for_expr(ex);\n     }\n-    fn visit_anon_const(&mut self, c: &'tcx AnonConst) {\n-        intravisit::walk_anon_const(self, c);\n-        self.encode_info_for_anon_const(c.hir_id);\n-    }\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         intravisit::walk_item(self, item);\n         match item.kind {\n             hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {} // ignore these\n             _ => self.encode_info_for_item(item.def_id.to_def_id(), item),\n         }\n-        self.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem<'tcx>) {\n         intravisit::walk_foreign_item(self, ni);\n@@ -2048,29 +2053,13 @@ impl<'a, 'tcx> Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn encode_fields(&mut self, adt_def: ty::AdtDef<'tcx>) {\n-        for (variant_index, variant) in adt_def.variants().iter_enumerated() {\n-            for (field_index, _field) in variant.fields.iter().enumerate() {\n-                self.encode_field(adt_def, variant_index, field_index);\n-            }\n-        }\n-    }\n-\n     fn encode_info_for_generics(&mut self, generics: &hir::Generics<'tcx>) {\n         for param in generics.params {\n             let def_id = self.tcx.hir().local_def_id(param.hir_id);\n             match param.kind {\n-                GenericParamKind::Lifetime { .. } => continue,\n-                GenericParamKind::Type { default, .. } => {\n-                    self.encode_info_for_generic_param(\n-                        def_id.to_def_id(),\n-                        EntryKind::TypeParam,\n-                        default.is_some(),\n-                    );\n-                }\n-                GenericParamKind::Const { ref default, .. } => {\n+                hir::GenericParamKind::Lifetime { .. } | hir::GenericParamKind::Type { .. } => {}\n+                hir::GenericParamKind::Const { ref default, .. } => {\n                     let def_id = def_id.to_def_id();\n-                    self.encode_info_for_generic_param(def_id, EntryKind::ConstParam, true);\n                     if default.is_some() {\n                         record!(self.tables.const_param_default[def_id] <- self.tcx.const_param_default(def_id))\n                     }\n@@ -2084,68 +2073,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             self.encode_info_for_closure(expr.hir_id);\n         }\n     }\n-\n-    /// In some cases, along with the item itself, we also\n-    /// encode some sub-items. Usually we want some info from the item\n-    /// so it's easier to do that here then to wait until we would encounter\n-    /// normally in the visitor walk.\n-    fn encode_addl_info_for_item(&mut self, item: &hir::Item<'_>) {\n-        match item.kind {\n-            hir::ItemKind::Static(..)\n-            | hir::ItemKind::Const(..)\n-            | hir::ItemKind::Fn(..)\n-            | hir::ItemKind::Macro(..)\n-            | hir::ItemKind::Mod(..)\n-            | hir::ItemKind::ForeignMod { .. }\n-            | hir::ItemKind::GlobalAsm(..)\n-            | hir::ItemKind::ExternCrate(..)\n-            | hir::ItemKind::Use(..)\n-            | hir::ItemKind::TyAlias(..)\n-            | hir::ItemKind::OpaqueTy(..)\n-            | hir::ItemKind::TraitAlias(..) => {\n-                // no sub-item recording needed in these cases\n-            }\n-            hir::ItemKind::Enum(..) => {\n-                let def = self.tcx.adt_def(item.def_id.to_def_id());\n-                self.encode_fields(def);\n-\n-                for (i, variant) in def.variants().iter_enumerated() {\n-                    self.encode_enum_variant_info(def, i);\n-\n-                    if let Some(_ctor_def_id) = variant.ctor_def_id {\n-                        self.encode_enum_variant_ctor(def, i);\n-                    }\n-                }\n-            }\n-            hir::ItemKind::Struct(ref struct_def, _) => {\n-                let def = self.tcx.adt_def(item.def_id.to_def_id());\n-                self.encode_fields(def);\n-\n-                // If the struct has a constructor, encode it.\n-                if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n-                    let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n-                    self.encode_struct_ctor(def, ctor_def_id.to_def_id());\n-                }\n-            }\n-            hir::ItemKind::Union(..) => {\n-                let def = self.tcx.adt_def(item.def_id.to_def_id());\n-                self.encode_fields(def);\n-            }\n-            hir::ItemKind::Impl { .. } => {\n-                for &trait_item_def_id in\n-                    self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n-                {\n-                    self.encode_info_for_impl_item(trait_item_def_id);\n-                }\n-            }\n-            hir::ItemKind::Trait(..) => {\n-                for &item_def_id in self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n-                {\n-                    self.encode_info_for_trait_item(item_def_id);\n-                }\n-            }\n-        }\n-    }\n }\n \n /// Used to prefetch queries which will be needed later by metadata encoding."}, {"sha": "6f849a58580e679550216f06ff690d75e11a8a8f", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 7, "deletions": 35, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2e35f954ada0f0c777844dc4fa66684efe90a035/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e35f954ada0f0c777844dc4fa66684efe90a035/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=2e35f954ada0f0c777844dc4fa66684efe90a035", "patch": "@@ -334,7 +334,6 @@ macro_rules! define_tables {\n }\n \n define_tables! {\n-    kind: Table<DefIndex, LazyValue<EntryKind>>,\n     attributes: Table<DefIndex, LazyArray<ast::Attribute>>,\n     children: Table<DefIndex, LazyArray<DefIndex>>,\n \n@@ -393,39 +392,13 @@ define_tables! {\n     proc_macro_quoted_spans: Table<usize, LazyValue<Span>>,\n     generator_diagnostic_data: Table<DefIndex, LazyValue<GeneratorDiagnosticData<'static>>>,\n     may_have_doc_links: Table<DefIndex, ()>,\n-}\n-\n-#[derive(Copy, Clone, MetadataEncodable, MetadataDecodable)]\n-enum EntryKind {\n-    AnonConst,\n-    Const,\n-    Static,\n-    ForeignStatic,\n-    ForeignMod,\n-    ForeignType,\n-    GlobalAsm,\n-    Type,\n-    TypeParam,\n-    ConstParam,\n-    OpaqueTy,\n-    Enum,\n-    Field,\n-    Variant(LazyValue<VariantData>),\n-    Struct(LazyValue<VariantData>),\n-    Union(LazyValue<VariantData>),\n-    Fn,\n-    ForeignFn,\n-    Mod(LazyArray<ModChild>),\n-    MacroDef(LazyValue<ast::MacArgs>, /*macro_rules*/ bool),\n-    ProcMacro(MacroKind),\n-    Closure,\n-    Generator,\n-    Trait,\n-    Impl,\n-    AssocFn { container: ty::AssocItemContainer, has_self: bool },\n-    AssocType(ty::AssocItemContainer),\n-    AssocConst(ty::AssocItemContainer),\n-    TraitAlias,\n+    variant_data: Table<DefIndex, LazyValue<VariantData>>,\n+    assoc_container: Table<DefIndex, ty::AssocItemContainer>,\n+    // Slot is full when macro is macro_rules.\n+    macro_rules: Table<DefIndex, ()>,\n+    macro_definition: Table<DefIndex, LazyValue<ast::MacArgs>>,\n+    proc_macro: Table<DefIndex, MacroKind>,\n+    module_reexports: Table<DefIndex, LazyArray<ModChild>>,\n }\n \n #[derive(TyEncodable, TyDecodable)]\n@@ -459,7 +432,6 @@ pub fn provide(providers: &mut Providers) {\n \n trivially_parameterized_over_tcx! {\n     VariantData,\n-    EntryKind,\n     RawDefId,\n     TraitImpls,\n     IncoherentImpls,"}, {"sha": "d5f151f0ed8e50a4116de32d27be14044bf589eb", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2e35f954ada0f0c777844dc4fa66684efe90a035/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e35f954ada0f0c777844dc4fa66684efe90a035/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=2e35f954ada0f0c777844dc4fa66684efe90a035", "patch": "@@ -50,7 +50,7 @@ macro_rules! fixed_size_enum {\n                 }\n                 match b[0] - 1 {\n                     $(${index()} => Some($($pat)*),)*\n-                    _ => panic!(\"Unexpected ImplPolarity code: {:?}\", b[0]),\n+                    _ => panic!(\"Unexpected {} code: {:?}\", stringify!($ty), b[0]),\n                 }\n             }\n \n@@ -140,6 +140,21 @@ fixed_size_enum! {\n     }\n }\n \n+fixed_size_enum! {\n+    ty::AssocItemContainer {\n+        ( TraitContainer )\n+        ( ImplContainer  )\n+    }\n+}\n+\n+fixed_size_enum! {\n+    MacroKind {\n+        ( Attr   )\n+        ( Bang   )\n+        ( Derive )\n+    }\n+}\n+\n // We directly encode `DefPathHash` because a `LazyValue` would incur a 25% cost.\n impl FixedSizeEncoding for Option<DefPathHash> {\n     type ByteArray = [u8; 16];"}, {"sha": "ca24c0d1ce386fc5801be18526395b68e3589677", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e35f954ada0f0c777844dc4fa66684efe90a035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e35f954ada0f0c777844dc4fa66684efe90a035/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=2e35f954ada0f0c777844dc4fa66684efe90a035", "patch": "@@ -55,6 +55,7 @@ trivially_parameterized_over_tcx! {\n     crate::middle::exported_symbols::SymbolExportInfo,\n     crate::middle::resolve_lifetime::ObjectLifetimeDefault,\n     crate::mir::ConstQualifs,\n+    ty::AssocItemContainer,\n     ty::Generics,\n     ty::ImplPolarity,\n     ty::ReprOptions,"}, {"sha": "51e8c24b9c25a51066088753bf4ec5b00a261798", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e35f954ada0f0c777844dc4fa66684efe90a035/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e35f954ada0f0c777844dc4fa66684efe90a035/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=2e35f954ada0f0c777844dc4fa66684efe90a035", "patch": "@@ -1029,7 +1029,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.insert_field_names(def_id, field_names);\n             }\n             Res::Def(DefKind::AssocFn, def_id) => {\n-                if cstore.fn_has_self_parameter_untracked(def_id) {\n+                if cstore.fn_has_self_parameter_untracked(def_id, self.r.session) {\n                     self.r.has_self.insert(def_id);\n                 }\n             }"}]}