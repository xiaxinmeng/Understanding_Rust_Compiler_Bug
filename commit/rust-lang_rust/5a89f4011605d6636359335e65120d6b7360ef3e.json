{"sha": "5a89f4011605d6636359335e65120d6b7360ef3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhODlmNDAxMTYwNWQ2NjM2MzU5MzM1ZTY1MTIwZDZiNzM2MGVmM2U=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-24T10:45:36Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-24T11:04:47Z"}, "message": "Handle methods", "tree": {"sha": "b26abdc898308bbb1e41973b56bb5dd011249c89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b26abdc898308bbb1e41973b56bb5dd011249c89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a89f4011605d6636359335e65120d6b7360ef3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a89f4011605d6636359335e65120d6b7360ef3e", "html_url": "https://github.com/rust-lang/rust/commit/5a89f4011605d6636359335e65120d6b7360ef3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a89f4011605d6636359335e65120d6b7360ef3e/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0e76772720f825b751965b4ff22b843c89c4062", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0e76772720f825b751965b4ff22b843c89c4062", "html_url": "https://github.com/rust-lang/rust/commit/f0e76772720f825b751965b4ff22b843c89c4062"}], "stats": {"total": 95, "additions": 76, "deletions": 19}, "files": [{"sha": "fdd54ba8e826a820f32f5471542d13da0bdf69ea", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 76, "deletions": 19, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/5a89f4011605d6636359335e65120d6b7360ef3e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a89f4011605d6636359335e65120d6b7360ef3e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5a89f4011605d6636359335e65120d6b7360ef3e", "patch": "@@ -659,7 +659,8 @@ pub struct Attributes {\n     pub other_attrs: Vec<ast::Attribute>,\n     pub cfg: Option<Rc<Cfg>>,\n     pub span: Option<syntax_pos::Span>,\n-    pub links: Vec<(String, DefId)>,\n+    /// map from Rust paths to resolved defs and potential URL fragments\n+    pub links: Vec<(String, DefId, Option<String>)>,\n }\n \n impl Attributes {\n@@ -820,8 +821,12 @@ impl Attributes {\n     /// Cache must be populated before call\n     pub fn links(&self) -> Vec<(String, String)> {\n         use html::format::href;\n-        self.links.iter().filter_map(|&(ref s, did)| {\n-            if let Some((href, ..)) = href(did) {\n+        self.links.iter().filter_map(|&(ref s, did, ref fragment)| {\n+            if let Some((mut href, ..)) = href(did) {\n+                if let Some(ref fragment) = *fragment {\n+                    href.push_str(\"#\");\n+                    href.push_str(fragment);\n+                }\n                 Some((s.clone(), href))\n             } else {\n                 None\n@@ -893,16 +898,67 @@ fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n }\n \n /// Resolve a given string as a path, along with whether or not it is\n-/// in the value namespace\n-fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<Def, ()> {\n+/// in the value namespace. Also returns an optional URL fragment in the case\n+/// of variants and methods\n+fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option<String>), ()> {\n     // In case we're in a module, try to resolve the relative\n     // path\n     if let Some(id) = cx.mod_ids.borrow().last() {\n-        cx.resolver.borrow_mut()\n-                   .with_scope(*id, |resolver| {\n-                        resolver.resolve_str_path_error(DUMMY_SP,\n-                                                        &path_str, is_val)\n-                    }).map(|path| path.def)\n+        let result = cx.resolver.borrow_mut()\n+                                .with_scope(*id,\n+            |resolver| {\n+                resolver.resolve_str_path_error(DUMMY_SP,\n+                                                &path_str, is_val)\n+        });\n+\n+        if result.is_ok() {\n+            return result.map(|path| (path.def, None));\n+        }\n+\n+        // Try looking for methods and other associated items\n+        let mut split = path_str.rsplitn(2, \"::\");\n+        let mut item_name = if let Some(first) = split.next() {\n+            first\n+        } else {\n+            return Err(())\n+        };\n+\n+        let mut path = if let Some(second) = split.next() {\n+            second\n+        } else {\n+            return Err(())\n+        };\n+\n+        let ty = cx.resolver.borrow_mut()\n+                            .with_scope(*id,\n+            |resolver| {\n+                resolver.resolve_str_path_error(DUMMY_SP,\n+                                                &path, false)\n+        })?;\n+\n+\n+        match ty.def {\n+            Def::Struct(did) | Def::Union(did) | Def::Enum(did) | Def::TyAlias(did) => {\n+                let item = cx.tcx.inherent_impls(did).iter()\n+                                 .flat_map(|imp| cx.tcx.associated_items(*imp))\n+                                 .find(|item| item.name == item_name);\n+                if let Some(item) = item {\n+                    if item.kind == ty::AssociatedKind::Method && is_val {\n+                        Ok((ty.def, Some(format!(\"method.{}\", item_name))))\n+                    } else {\n+                        Err(())\n+                    }\n+                } else {\n+                    Err(())\n+                }\n+            }\n+            Def::Trait(_) => {\n+                // XXXManishearth todo\n+                Err(())\n+            }\n+            _ => Err(())\n+        }\n+\n     } else {\n         Err(())\n     }\n@@ -953,7 +1009,7 @@ impl Clean<Attributes> for [ast::Attribute] {\n         if UnstableFeatures::from_environment().is_nightly_build() {\n             let dox = attrs.collapsed_doc_value().unwrap_or_else(String::new);\n             for link in markdown_links(&dox, cx.render_type) {\n-                let def = {\n+                let (def, fragment)  = {\n                     let mut kind = PathKind::Unknown;\n                     let path_str = if let Some(prefix) =\n                         [\"struct@\", \"enum@\", \"type@\",\n@@ -963,7 +1019,8 @@ impl Clean<Attributes> for [ast::Attribute] {\n                         link.trim_left_matches(prefix)\n                     } else if let Some(prefix) =\n                         [\"const@\", \"static@\",\n-                         \"value@\", \"function@\", \"mod@\", \"fn@\", \"module@\"]\n+                         \"value@\", \"function@\", \"mod@\",\n+                         \"fn@\", \"module@\", \"method@\"]\n                             .iter().find(|p| link.starts_with(**p)) {\n                         kind = PathKind::Value;\n                         link.trim_left_matches(prefix)\n@@ -1013,31 +1070,31 @@ impl Clean<Attributes> for [ast::Attribute] {\n                             if let Some(macro_def) = macro_resolve(cx, path_str) {\n                                 if let Ok(type_def) = resolve(cx, path_str, false) {\n                                     let (type_kind, article, type_disambig)\n-                                        = type_ns_kind(type_def, path_str);\n+                                        = type_ns_kind(type_def.0, path_str);\n                                     ambiguity_error(cx, &attrs, path_str,\n                                                     article, type_kind, &type_disambig,\n                                                     \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n                                     continue;\n                                 } else if let Ok(value_def) = resolve(cx, path_str, true) {\n                                     let (value_kind, value_disambig)\n-                                        = value_ns_kind(value_def, path_str)\n+                                        = value_ns_kind(value_def.0, path_str)\n                                             .expect(\"struct and mod cases should have been \\\n                                                      caught in previous branch\");\n                                     ambiguity_error(cx, &attrs, path_str,\n                                                     \"a\", value_kind, &value_disambig,\n                                                     \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n                                 }\n-                                macro_def\n+                                (macro_def, None)\n                             } else if let Ok(type_def) = resolve(cx, path_str, false) {\n                                 // It is imperative we search for not-a-value first\n                                 // Otherwise we will find struct ctors for when we are looking\n                                 // for structs, and the link won't work.\n                                 // if there is something in both namespaces\n                                 if let Ok(value_def) = resolve(cx, path_str, true) {\n-                                    let kind = value_ns_kind(value_def, path_str);\n+                                    let kind = value_ns_kind(value_def.0, path_str);\n                                     if let Some((value_kind, value_disambig)) = kind {\n                                         let (type_kind, article, type_disambig)\n-                                            = type_ns_kind(type_def, path_str);\n+                                            = type_ns_kind(type_def.0, path_str);\n                                         ambiguity_error(cx, &attrs, path_str,\n                                                         article, type_kind, &type_disambig,\n                                                         \"a\", value_kind, &value_disambig);\n@@ -1054,7 +1111,7 @@ impl Clean<Attributes> for [ast::Attribute] {\n                         }\n                         PathKind::Macro => {\n                             if let Some(def) = macro_resolve(cx, path_str) {\n-                                def\n+                                (def, None)\n                             } else {\n                                 continue\n                             }\n@@ -1064,7 +1121,7 @@ impl Clean<Attributes> for [ast::Attribute] {\n \n \n                 let id = register_def(cx, def);\n-                attrs.links.push((link, id));\n+                attrs.links.push((link, id, fragment));\n             }\n \n             cx.sess().abort_if_errors();"}]}