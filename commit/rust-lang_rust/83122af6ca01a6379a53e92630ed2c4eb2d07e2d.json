{"sha": "83122af6ca01a6379a53e92630ed2c4eb2d07e2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzMTIyYWY2Y2EwMWE2Mzc5YTUzZTkyNjMwZWQyYzRlYjJkMDdlMmQ=", "commit": {"author": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-07-10T03:09:57Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-07-10T03:11:40Z"}, "message": "librustc: Translate input for transmute directly into dest.", "tree": {"sha": "f798fd0d3670eb8351256a78153ba527eb0e1ab6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f798fd0d3670eb8351256a78153ba527eb0e1ab6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83122af6ca01a6379a53e92630ed2c4eb2d07e2d", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83122af6ca01a6379a53e92630ed2c4eb2d07e2d", "html_url": "https://github.com/rust-lang/rust/commit/83122af6ca01a6379a53e92630ed2c4eb2d07e2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83122af6ca01a6379a53e92630ed2c4eb2d07e2d/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fa30065aa08503b4365abec62f56ce4f492ab57", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fa30065aa08503b4365abec62f56ce4f492ab57", "html_url": "https://github.com/rust-lang/rust/commit/8fa30065aa08503b4365abec62f56ce4f492ab57"}], "stats": {"total": 100, "additions": 42, "deletions": 58}, "files": [{"sha": "309c700bfe89942fa86dd035c224a74cf79b8823", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 42, "deletions": 58, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/83122af6ca01a6379a53e92630ed2c4eb2d07e2d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83122af6ca01a6379a53e92630ed2c4eb2d07e2d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=83122af6ca01a6379a53e92630ed2c4eb2d07e2d", "patch": "@@ -10,8 +10,7 @@\n \n #![allow(non_uppercase_pattern_statics)]\n \n-use lib::llvm::{SequentiallyConsistent, Acquire, Release, Xchg};\n-use lib::llvm::{ValueRef, Pointer, Array, Struct};\n+use lib::llvm::{SequentiallyConsistent, Acquire, Release, Xchg, ValueRef};\n use lib;\n use middle::subst;\n use middle::subst::FnSpace;\n@@ -137,6 +136,47 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n         _ => fail!(\"expected bare_fn in trans_intrinsic_call\")\n     };\n     let llret_ty = type_of::type_of(ccx, ret_ty);\n+    let foreign_item = tcx.map.expect_foreign_item(node);\n+    let name = token::get_ident(foreign_item.ident);\n+\n+    // For `transmute` we can just trans the input expr directly into dest\n+    if name.get() == \"transmute\" {\n+        match args {\n+            callee::ArgExprs(arg_exprs) => {\n+                assert_eq!(arg_exprs.len(), 1);\n+\n+                let (in_type, out_type) = (*substs.types.get(FnSpace, 0),\n+                                           *substs.types.get(FnSpace, 1));\n+                let llintype = type_of::type_of(ccx, in_type);\n+                let llouttype = type_of::type_of(ccx, out_type);\n+\n+                let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n+                let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n+\n+                // This should be caught by the intrinsicck pass\n+                assert_eq!(in_type_size, out_type_size);\n+\n+                // We need to cast the dest so the types work out\n+                let dest = match dest {\n+                    expr::SaveIn(d) => expr::SaveIn(PointerCast(bcx, d, llintype.ptr_to())),\n+                    expr::Ignore => expr::Ignore\n+                };\n+                bcx = expr::trans_into(bcx, &*arg_exprs[0], dest);\n+\n+                fcx.pop_custom_cleanup_scope(cleanup_scope);\n+\n+                return match dest {\n+                    expr::SaveIn(d) => Result::new(bcx, d),\n+                    expr::Ignore => Result::new(bcx, C_undef(llret_ty.ptr_to()))\n+                };\n+\n+            }\n+\n+            _ => {\n+                ccx.sess().bug(\"expected expr as argument for transmute\");\n+            }\n+        }\n+    }\n \n     // Get location to store the result. If the user does\n     // not care about the result, just make a stack slot\n@@ -158,8 +198,6 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n \n     fcx.pop_custom_cleanup_scope(cleanup_scope);\n \n-    let foreign_item = tcx.map.expect_foreign_item(node);\n-    let name = token::get_ident(foreign_item.ident);\n     let simple = get_simple_intrinsic(ccx, &*foreign_item);\n \n     let llval = match (simple, name.get()) {\n@@ -240,60 +278,6 @@ pub fn trans_intrinsic_call<'a>(mut bcx: &'a Block<'a>, node: ast::NodeId,\n         (_, \"uninit\") | (_, \"forget\") => {\n             C_nil(ccx)\n         }\n-        (_, \"transmute\") => {\n-            let (in_type, out_type) = (*substs.types.get(FnSpace, 0),\n-                                       *substs.types.get(FnSpace, 1));\n-            let llintype = type_of::type_of(ccx, in_type);\n-            let llouttype = type_of::type_of(ccx, out_type);\n-\n-            let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n-            let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n-\n-            // This should be caught by the intrinsicck pass\n-            assert_eq!(in_type_size, out_type_size);\n-\n-            if !return_type_is_void(ccx, out_type) {\n-                let llsrcval = *llargs.get(0);\n-                if type_is_immediate(ccx, in_type) {\n-                    if type_is_immediate(ccx, out_type) {\n-                        Store(bcx, llsrcval, PointerCast(bcx, llresult, llintype.ptr_to()));\n-                        C_nil(ccx)\n-                    } else {\n-                        match (llintype.kind(), llouttype.kind()) {\n-                            (Pointer, other) | (other, Pointer) if other != Pointer => {\n-                                let tmp = Alloca(bcx, llouttype, \"\");\n-                                Store(bcx, llsrcval, PointerCast(bcx, tmp, llintype.ptr_to()));\n-                                Load(bcx, tmp)\n-                            }\n-                            (Array, _) | (_, Array) | (Struct, _) | (_, Struct) => {\n-                                let tmp = Alloca(bcx, llouttype, \"\");\n-                                Store(bcx, llsrcval, PointerCast(bcx, tmp, llintype.ptr_to()));\n-                                Load(bcx, tmp)\n-                            }\n-                            _ => {\n-                                BitCast(bcx, llsrcval, llouttype)\n-                            }\n-                        }\n-                    }\n-                } else if type_is_immediate(ccx, out_type) {\n-                    Load(bcx, PointerCast(bcx, llsrcval, llouttype.ptr_to()))\n-                } else {\n-                    // NB: Do not use a Load and Store here. This causes massive\n-                    // code bloat when `transmute` is used on large structural\n-                    // types.\n-                    let lldestptr = llresult;\n-                    let lldestptr = PointerCast(bcx, lldestptr, Type::i8p(ccx));\n-                    let llsrcptr = PointerCast(bcx, llsrcval, Type::i8p(ccx));\n-\n-                    let llsize = llsize_of(ccx, llintype);\n-                    call_memcpy(bcx, lldestptr, llsrcptr, llsize, 1);\n-\n-                    C_nil(ccx)\n-                }\n-            } else {\n-                C_nil(ccx)\n-            }\n-        }\n         (_, \"needs_drop\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             C_bool(ccx, ty::type_needs_drop(ccx.tcx(), tp_ty))"}]}