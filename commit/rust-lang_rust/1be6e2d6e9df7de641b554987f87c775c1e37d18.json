{"sha": "1be6e2d6e9df7de641b554987f87c775c1e37d18", "node_id": "C_kwDOAAsO6NoAKDFiZTZlMmQ2ZTlkZjdkZTY0MWI1NTQ5ODdmODdjNzc1YzFlMzdkMTg", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-01-08T11:22:06Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-01-08T19:45:59Z"}, "message": "Link impl items to corresponding trait items in late resolver.", "tree": {"sha": "27a4a252c72db3aa1ac682bacab35afc8de7b18c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27a4a252c72db3aa1ac682bacab35afc8de7b18c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1be6e2d6e9df7de641b554987f87c775c1e37d18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1be6e2d6e9df7de641b554987f87c775c1e37d18", "html_url": "https://github.com/rust-lang/rust/commit/1be6e2d6e9df7de641b554987f87c775c1e37d18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1be6e2d6e9df7de641b554987f87c775c1e37d18/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "488acf86a75c56d30b16822e953c505a9e4901a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/488acf86a75c56d30b16822e953c505a9e4901a7", "html_url": "https://github.com/rust-lang/rust/commit/488acf86a75c56d30b16822e953c505a9e4901a7"}], "stats": {"total": 270, "additions": 111, "deletions": 159}, "files": [{"sha": "39a8cd405de33a81f765fcdd1bc295f4d242eed9", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1be6e2d6e9df7de641b554987f87c775c1e37d18/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be6e2d6e9df7de641b554987f87c775c1e37d18/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=1be6e2d6e9df7de641b554987f87c775c1e37d18", "patch": "@@ -335,7 +335,8 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_impl_item_ref(&mut self, ii: &'hir ImplItemRef) {\n         // Do not visit the duplicate information in ImplItemRef. We want to\n         // map the actual nodes, not the duplicate ones in the *Ref.\n-        let ImplItemRef { id, ident: _, kind: _, span: _, defaultness: _ } = *ii;\n+        let ImplItemRef { id, ident: _, kind: _, span: _, defaultness: _, trait_item_def_id: _ } =\n+            *ii;\n \n         self.visit_nested_impl_item(id);\n     }"}, {"sha": "ed3abbd5b4d3dfce4874811252bc5c2cacfa70e1", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1be6e2d6e9df7de641b554987f87c775c1e37d18/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be6e2d6e9df7de641b554987f87c775c1e37d18/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=1be6e2d6e9df7de641b554987f87c775c1e37d18", "patch": "@@ -925,6 +925,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 AssocItemKind::MacCall(..) => unimplemented!(),\n             },\n+            trait_item_def_id: self.resolver.get_partial_res(i.id).map(|r| r.base_res().def_id()),\n         }\n     }\n "}, {"sha": "bcf677bbafd495220b7a9fb47219edc0d5d88100", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1be6e2d6e9df7de641b554987f87c775c1e37d18/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be6e2d6e9df7de641b554987f87c775c1e37d18/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=1be6e2d6e9df7de641b554987f87c775c1e37d18", "patch": "@@ -2885,6 +2885,8 @@ pub struct ImplItemRef {\n     pub kind: AssocItemKind,\n     pub span: Span,\n     pub defaultness: Defaultness,\n+    /// When we are in a trait impl, link to the trait-item's id.\n+    pub trait_item_def_id: Option<DefId>,\n }\n \n #[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]"}, {"sha": "7c77930193c0b2818ac1e097abd56d756443f68a", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1be6e2d6e9df7de641b554987f87c775c1e37d18/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be6e2d6e9df7de641b554987f87c775c1e37d18/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=1be6e2d6e9df7de641b554987f87c775c1e37d18", "patch": "@@ -1088,7 +1088,8 @@ pub fn walk_foreign_item_ref<'v, V: Visitor<'v>>(\n \n pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'v ImplItemRef) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n-    let ImplItemRef { id, ident, ref kind, span: _, ref defaultness } = *impl_item_ref;\n+    let ImplItemRef { id, ident, ref kind, span: _, ref defaultness, trait_item_def_id: _ } =\n+        *impl_item_ref;\n     visitor.visit_nested_impl_item(id);\n     visitor.visit_ident(ident);\n     visitor.visit_associated_item_kind(kind);"}, {"sha": "8563bac0bbf8740b7e268f9e4582a519e4eba19a", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1be6e2d6e9df7de641b554987f87c775c1e37d18/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be6e2d6e9df7de641b554987f87c775c1e37d18/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=1be6e2d6e9df7de641b554987f87c775c1e37d18", "patch": "@@ -139,21 +139,6 @@ impl<'tcx> AssocItems<'tcx> {\n         self.items.get_by_key(name).copied()\n     }\n \n-    /// Returns an iterator over all associated items with the given name.\n-    ///\n-    /// Multiple items may have the same name if they are in different `Namespace`s. For example,\n-    /// an associated type can have the same name as a method. Use one of the `find_by_name_and_*`\n-    /// methods below if you know which item you are looking for.\n-    pub fn filter_by_name<'a>(\n-        &'a self,\n-        tcx: TyCtxt<'a>,\n-        ident: Ident,\n-        parent_def_id: DefId,\n-    ) -> impl 'a + Iterator<Item = &'a ty::AssocItem> {\n-        self.filter_by_name_unhygienic(ident.name)\n-            .filter(move |item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n-    }\n-\n     /// Returns the associated item with the given name and `AssocKind`, if one exists.\n     pub fn find_by_name_and_kind(\n         &self,"}, {"sha": "24ff04b8853d4660a6931fdcdf7790a9d68dc96a", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 88, "deletions": 16, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/1be6e2d6e9df7de641b554987f87c775c1e37d18/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be6e2d6e9df7de641b554987f87c775c1e37d18/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=1be6e2d6e9df7de641b554987f87c775c1e37d18", "patch": "@@ -1317,6 +1317,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                             // If this is a trait impl, ensure the const\n                                             // exists in trait\n                                             this.check_trait_item(\n+                                                item.id,\n                                                 item.ident,\n                                                 &item.kind,\n                                                 ValueNS,\n@@ -1352,6 +1353,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                                     // If this is a trait impl, ensure the method\n                                                     // exists in trait\n                                                     this.check_trait_item(\n+                                                        item.id,\n                                                         item.ident,\n                                                         &item.kind,\n                                                         ValueNS,\n@@ -1379,6 +1381,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                                     // If this is a trait impl, ensure the type\n                                                     // exists in trait\n                                                     this.check_trait_item(\n+                                                        item.id,\n                                                         item.ident,\n                                                         &item.kind,\n                                                         TypeNS,\n@@ -1409,6 +1412,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n     fn check_trait_item<F>(\n         &mut self,\n+        id: NodeId,\n         ident: Ident,\n         kind: &AssocItemKind,\n         ns: Namespace,\n@@ -1417,26 +1421,94 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     ) where\n         F: FnOnce(Ident, &str, Option<Symbol>) -> ResolutionError<'_>,\n     {\n-        // If there is a TraitRef in scope for an impl, then the method must be in the\n-        // trait.\n-        if let Some((module, _)) = self.current_trait_ref {\n-            if self\n-                .r\n-                .resolve_ident_in_module(\n-                    ModuleOrUniformRoot::Module(module),\n+        // If there is a TraitRef in scope for an impl, then the method must be in the trait.\n+        let Some((module, _)) = &self.current_trait_ref else { return; };\n+        let mut binding = self.r.resolve_ident_in_module(\n+            ModuleOrUniformRoot::Module(module),\n+            ident,\n+            ns,\n+            &self.parent_scope,\n+            false,\n+            span,\n+        );\n+        if binding.is_err() {\n+            // We could not find the trait item in the correct namespace.\n+            // Check the other namespace to report an error.\n+            let ns = match ns {\n+                ValueNS => TypeNS,\n+                TypeNS => ValueNS,\n+                _ => ns,\n+            };\n+            binding = self.r.resolve_ident_in_module(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                &self.parent_scope,\n+                false,\n+                span,\n+            );\n+        }\n+        let Ok(binding) = binding else {\n+            // We could not find the method: report an error.\n+            let candidate = self.find_similarly_named_assoc_item(ident.name, kind);\n+            let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n+            self.report_error(span, err(ident, &path_names_to_string(path), candidate));\n+            return;\n+        };\n+\n+        let res = binding.res();\n+        let Res::Def(def_kind, _) = res else { bug!() };\n+        match (def_kind, kind) {\n+            (DefKind::AssocTy, AssocItemKind::TyAlias(..))\n+            | (DefKind::AssocFn, AssocItemKind::Fn(..))\n+            | (DefKind::AssocConst, AssocItemKind::Const(..)) => {\n+                self.r.record_partial_res(id, PartialRes::new(res));\n+                return;\n+            }\n+            _ => {}\n+        }\n+\n+        // The method kind does not correspond to what appeared in the trait, report.\n+        let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n+        let path = &path_names_to_string(path);\n+        let mut err = match kind {\n+            AssocItemKind::Const(..) => {\n+                rustc_errors::struct_span_err!(\n+                    self.r.session,\n+                    span,\n+                    E0323,\n+                    \"item `{}` is an associated const, which doesn't match its trait `{}`\",\n                     ident,\n-                    ns,\n-                    &self.parent_scope,\n-                    false,\n+                    path,\n+                )\n+            }\n+            AssocItemKind::Fn(..) => {\n+                rustc_errors::struct_span_err!(\n+                    self.r.session,\n                     span,\n+                    E0324,\n+                    \"item `{}` is an associated method, which doesn't match its trait `{}`\",\n+                    ident,\n+                    path,\n                 )\n-                .is_err()\n-            {\n-                let candidate = self.find_similarly_named_assoc_item(ident.name, kind);\n-                let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n-                self.report_error(span, err(ident, &path_names_to_string(path), candidate));\n             }\n-        }\n+            AssocItemKind::TyAlias(..) => {\n+                rustc_errors::struct_span_err!(\n+                    self.r.session,\n+                    span,\n+                    E0325,\n+                    \"item `{}` is an associated type, which doesn't match its trait `{}`\",\n+                    ident,\n+                    path,\n+                )\n+            }\n+            AssocItemKind::MacCall(..) => {\n+                span_bug!(span, \"macros should have been expanded\")\n+            }\n+        };\n+        err.span_label(span, \"does not match trait\");\n+        err.span_label(binding.span, \"item in trait\");\n+        err.emit();\n     }\n \n     fn resolve_params(&mut self, params: &'ast [Param]) {"}, {"sha": "6e2ef27f10817621bedf80f197b35d1ef712762e", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 2, "deletions": 104, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1be6e2d6e9df7de641b554987f87c775c1e37d18/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be6e2d6e9df7de641b554987f87c775c1e37d18/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=1be6e2d6e9df7de641b554987f87c775c1e37d18", "patch": "@@ -1,8 +1,7 @@\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, TyCtxt};\n \n pub fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n@@ -125,115 +124,14 @@ fn associated_item_from_impl_item_ref(\n         hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n     };\n \n-    let trait_item_def_id = impl_item_base_id(tcx, parent_def_id, impl_item_ref);\n-\n     ty::AssocItem {\n         ident: impl_item_ref.ident,\n         kind,\n         vis: tcx.visibility(def_id),\n         defaultness: impl_item_ref.defaultness,\n         def_id: def_id.to_def_id(),\n-        trait_item_def_id,\n+        trait_item_def_id: impl_item_ref.trait_item_def_id,\n         container: ty::ImplContainer(parent_def_id.to_def_id()),\n         fn_has_self_parameter: has_self,\n     }\n }\n-\n-fn impl_item_base_id<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    parent_def_id: LocalDefId,\n-    impl_item: &hir::ImplItemRef,\n-) -> Option<DefId> {\n-    let impl_trait_ref = tcx.impl_trait_ref(parent_def_id)?;\n-\n-    // If the trait reference itself is erroneous (so the compilation is going\n-    // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n-    // isn't populated for such impls.\n-    if impl_trait_ref.references_error() {\n-        return None;\n-    }\n-\n-    // Locate trait items\n-    let associated_items = tcx.associated_items(impl_trait_ref.def_id);\n-\n-    // Match item against trait\n-    let mut items = associated_items.filter_by_name(tcx, impl_item.ident, impl_trait_ref.def_id);\n-\n-    let mut trait_item = items.next()?;\n-\n-    let is_compatible = |ty: &&ty::AssocItem| match (ty.kind, &impl_item.kind) {\n-        (ty::AssocKind::Const, hir::AssocItemKind::Const) => true,\n-        (ty::AssocKind::Fn, hir::AssocItemKind::Fn { .. }) => true,\n-        (ty::AssocKind::Type, hir::AssocItemKind::Type) => true,\n-        _ => false,\n-    };\n-\n-    // If we don't have a compatible item, we'll use the first one whose name matches\n-    // to report an error.\n-    let mut compatible_kind = is_compatible(&trait_item);\n-\n-    if !compatible_kind {\n-        if let Some(ty_trait_item) = items.find(is_compatible) {\n-            compatible_kind = true;\n-            trait_item = ty_trait_item;\n-        }\n-    }\n-\n-    if compatible_kind {\n-        Some(trait_item.def_id)\n-    } else {\n-        report_mismatch_error(tcx, trait_item.def_id, impl_trait_ref, impl_item);\n-        None\n-    }\n-}\n-\n-#[inline(never)]\n-#[cold]\n-fn report_mismatch_error<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_item_def_id: DefId,\n-    impl_trait_ref: ty::TraitRef<'tcx>,\n-    impl_item: &hir::ImplItemRef,\n-) {\n-    let mut err = match impl_item.kind {\n-        hir::AssocItemKind::Const => {\n-            // Find associated const definition.\n-            struct_span_err!(\n-                tcx.sess,\n-                impl_item.span,\n-                E0323,\n-                \"item `{}` is an associated const, which doesn't match its trait `{}`\",\n-                impl_item.ident,\n-                impl_trait_ref.print_only_trait_path()\n-            )\n-        }\n-\n-        hir::AssocItemKind::Fn { .. } => {\n-            struct_span_err!(\n-                tcx.sess,\n-                impl_item.span,\n-                E0324,\n-                \"item `{}` is an associated method, which doesn't match its trait `{}`\",\n-                impl_item.ident,\n-                impl_trait_ref.print_only_trait_path()\n-            )\n-        }\n-\n-        hir::AssocItemKind::Type => {\n-            struct_span_err!(\n-                tcx.sess,\n-                impl_item.span,\n-                E0325,\n-                \"item `{}` is an associated type, which doesn't match its trait `{}`\",\n-                impl_item.ident,\n-                impl_trait_ref.print_only_trait_path()\n-            )\n-        }\n-    };\n-\n-    err.span_label(impl_item.span, \"does not match trait\");\n-    if let Some(trait_span) = tcx.hir().span_if_local(trait_item_def_id) {\n-        err.span_label(trait_span, \"item in trait\");\n-    }\n-    err.emit();\n-}"}, {"sha": "bf335868643ca25b03b5862f43689eaf1d74c4d1", "filename": "src/test/ui/span/impl-wrong-item-for-trait.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1be6e2d6e9df7de641b554987f87c775c1e37d18/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be6e2d6e9df7de641b554987f87c775c1e37d18/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.rs?ref=1be6e2d6e9df7de641b554987f87c775c1e37d18", "patch": "@@ -29,12 +29,10 @@ impl Foo for FooTypeForMethod {\n     //~^ ERROR E0046\n     type bar = u64;\n     //~^ ERROR E0325\n-    //~| ERROR E0437\n     const MY_CONST: u32 = 1;\n }\n \n-impl Debug for FooTypeForMethod {\n-}\n-//~^^ ERROR E0046\n+impl Debug for FooTypeForMethod {}\n+//~^ ERROR E0046\n \n-fn main () {}\n+fn main() {}"}, {"sha": "82ef13f3362d461a9eeee3f3c542059a2e9f4921", "filename": "src/test/ui/span/impl-wrong-item-for-trait.stderr", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1be6e2d6e9df7de641b554987f87c775c1e37d18/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1be6e2d6e9df7de641b554987f87c775c1e37d18/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr?ref=1be6e2d6e9df7de641b554987f87c775c1e37d18", "patch": "@@ -1,8 +1,11 @@\n-error[E0437]: type `bar` is not a member of trait `Foo`\n-  --> $DIR/impl-wrong-item-for-trait.rs:30:5\n+error[E0323]: item `bar` is an associated const, which doesn't match its trait `Foo`\n+  --> $DIR/impl-wrong-item-for-trait.rs:12:5\n    |\n-LL |     type bar = u64;\n-   |     ^^^^^^^^^^^^^^^ not a member of trait `Foo`\n+LL |     fn bar(&self);\n+   |     -------------- item in trait\n+...\n+LL |     const bar: u64 = 1;\n+   |     ^^^^^^^^^^^^^^^^^^^ does not match trait\n \n error[E0324]: item `MY_CONST` is an associated method, which doesn't match its trait `Foo`\n   --> $DIR/impl-wrong-item-for-trait.rs:22:5\n@@ -13,15 +16,6 @@ LL |     const MY_CONST: u32;\n LL |     fn MY_CONST() {}\n    |     ^^^^^^^^^^^^^^^^ does not match trait\n \n-error[E0323]: item `bar` is an associated const, which doesn't match its trait `Foo`\n-  --> $DIR/impl-wrong-item-for-trait.rs:12:5\n-   |\n-LL |     fn bar(&self);\n-   |     -------------- item in trait\n-...\n-LL |     const bar: u64 = 1;\n-   |     ^^^^^^^^^^^^^^^^^^^ does not match trait\n-\n error[E0325]: item `bar` is an associated type, which doesn't match its trait `Foo`\n   --> $DIR/impl-wrong-item-for-trait.rs:30:5\n    |\n@@ -59,14 +53,14 @@ LL | impl Foo for FooTypeForMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `bar` in implementation\n \n error[E0046]: not all trait items implemented, missing: `fmt`\n-  --> $DIR/impl-wrong-item-for-trait.rs:36:1\n+  --> $DIR/impl-wrong-item-for-trait.rs:35:1\n    |\n-LL | impl Debug for FooTypeForMethod {\n+LL | impl Debug for FooTypeForMethod {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `fmt` in implementation\n    |\n    = help: implement the missing item: `fn fmt(&self, _: &mut Formatter<'_>) -> Result<(), std::fmt::Error> { todo!() }`\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 7 previous errors\n \n-Some errors have detailed explanations: E0046, E0323, E0324, E0325, E0437.\n+Some errors have detailed explanations: E0046, E0323, E0324, E0325.\n For more information about an error, try `rustc --explain E0046`."}]}