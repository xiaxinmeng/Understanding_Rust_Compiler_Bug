{"sha": "52c7b8ec1115d0f8ce989af779be5c2f872266c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYzdiOGVjMTExNWQwZjhjZTk4OWFmNzc5YmU1YzJmODcyMjY2YzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-08T13:25:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-08T13:25:25Z"}, "message": "Auto merge of #1502 - RalfJung:isolation, r=RalfJung\n\nfs: move isolation handling to inside trait", "tree": {"sha": "ff37f227f95e93fd1f7fab6f5e66956fe29b8b04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff37f227f95e93fd1f7fab6f5e66956fe29b8b04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52c7b8ec1115d0f8ce989af779be5c2f872266c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52c7b8ec1115d0f8ce989af779be5c2f872266c6", "html_url": "https://github.com/rust-lang/rust/commit/52c7b8ec1115d0f8ce989af779be5c2f872266c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52c7b8ec1115d0f8ce989af779be5c2f872266c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaf5d32ac732e704d59748a6f56c17989fbd2bac", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaf5d32ac732e704d59748a6f56c17989fbd2bac", "html_url": "https://github.com/rust-lang/rust/commit/eaf5d32ac732e704d59748a6f56c17989fbd2bac"}, {"sha": "5657f08bea978ddd9114c5a25a07e115ee609425", "url": "https://api.github.com/repos/rust-lang/rust/commits/5657f08bea978ddd9114c5a25a07e115ee609425", "html_url": "https://github.com/rust-lang/rust/commit/5657f08bea978ddd9114c5a25a07e115ee609425"}], "stats": {"total": 79, "additions": 52, "deletions": 27}, "files": [{"sha": "0426115773d9e6099595f0dd5fa41910d8259bdb", "filename": "src/helpers.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/52c7b8ec1115d0f8ce989af779be5c2f872266c6/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c7b8ec1115d0f8ce989af779be5c2f872266c6/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=52c7b8ec1115d0f8ce989af779be5c2f872266c6", "patch": "@@ -376,13 +376,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// case.\n     fn check_no_isolation(&self, name: &str) -> InterpResult<'tcx> {\n         if !self.eval_context_ref().machine.communicate {\n-            throw_machine_stop!(TerminationInfo::UnsupportedInIsolation(format!(\n-                \"`{}` not available when isolation is enabled\",\n-                name,\n-            )))\n+            isolation_error(name)?;\n         }\n         Ok(())\n     }\n+\n     /// Helper function used inside the shims of foreign functions to assert that the target OS\n     /// is `target_os`. It panics showing a message with the `name` of the foreign function\n     /// if this is not the case.\n@@ -509,6 +507,13 @@ pub fn check_arg_count<'a, 'tcx, const N: usize>(args: &'a [OpTy<'tcx, Tag>]) ->\n     throw_ub_format!(\"incorrect number of arguments: got {}, expected {}\", args.len(), N)\n }\n \n+pub fn isolation_error(name: &str) -> InterpResult<'static> {\n+    throw_machine_stop!(TerminationInfo::UnsupportedInIsolation(format!(\n+        \"`{}` not available when isolation is enabled\",\n+        name,\n+    )))\n+}\n+\n pub fn immty_from_int_checked<'tcx>(\n     int: impl Into<i128>,\n     layout: TyAndLayout<'tcx>,"}, {"sha": "cf050b7086945eb2cfb88a049a4f2d194c79b35c", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/52c7b8ec1115d0f8ce989af779be5c2f872266c6/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c7b8ec1115d0f8ce989af779be5c2f872266c6/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=52c7b8ec1115d0f8ce989af779be5c2f872266c6", "patch": "@@ -25,25 +25,28 @@ struct FileHandle {\n trait FileDescriptor<'tcx> : std::fmt::Debug {\n     fn as_file_handle(&self) -> InterpResult<'tcx, &FileHandle>;\n \n-    fn read(&mut self, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>>;\n-    fn write(&mut self, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>>;\n-    fn seek(&mut self, offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>>;\n+    fn read(&mut self, communicate_allowed: bool, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>>;\n+    fn write(&mut self, communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>>;\n+    fn seek(&mut self, communicate_allowed: bool, offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>>;\n }\n \n impl<'tcx> FileDescriptor<'tcx> for FileHandle {\n     fn as_file_handle(&self) -> InterpResult<'tcx, &FileHandle> {\n         Ok(&self)\n     }\n \n-    fn read(&mut self, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn read(&mut self, communicate_allowed: bool, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        assert!(communicate_allowed, \"isolation should have prevented even opening a file\");\n         Ok(self.file.read(bytes))\n     }\n \n-    fn write(&mut self, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn write(&mut self, communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        assert!(communicate_allowed, \"isolation should have prevented even opening a file\");\n         Ok(self.file.write(bytes))\n     }\n \n-    fn seek(&mut self, offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+    fn seek(&mut self, communicate_allowed: bool, offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+        assert!(communicate_allowed, \"isolation should have prevented even opening a file\");\n         Ok(self.file.seek(offset))\n     }\n }\n@@ -53,15 +56,19 @@ impl<'tcx> FileDescriptor<'tcx> for io::Stdin {\n         throw_unsup_format!(\"stdin cannot be used as FileHandle\");\n     }\n \n-    fn read(&mut self, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn read(&mut self, communicate_allowed: bool, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        if !communicate_allowed {\n+            // We want isolation mode to be deterministic, so we have to disallow all reads, even stdin.\n+            helpers::isolation_error(\"read\")?;\n+        }\n         Ok(Read::read(self, bytes))\n     }\n \n-    fn write(&mut self, _bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn write(&mut self, _communicate_allowed: bool, _bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n         throw_unsup_format!(\"cannot write to stdin\");\n     }\n \n-    fn seek(&mut self, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+    fn seek(&mut self, _communicate_allowed: bool, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n         throw_unsup_format!(\"cannot seek on stdin\");\n     }\n }\n@@ -71,11 +78,12 @@ impl<'tcx> FileDescriptor<'tcx> for io::Stdout {\n         throw_unsup_format!(\"stdout cannot be used as FileHandle\");\n     }\n \n-    fn read(&mut self, _bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn read(&mut self, _communicate_allowed: bool, _bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n         throw_unsup_format!(\"cannot read from stdout\");\n     }\n \n-    fn write(&mut self, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn write(&mut self, _communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        // We allow writing to stderr even with isolation enabled.\n         let result = Write::write(self, bytes);\n         // Stdout is buffered, flush to make sure it appears on the\n         // screen.  This is the write() syscall of the interpreted\n@@ -87,7 +95,7 @@ impl<'tcx> FileDescriptor<'tcx> for io::Stdout {\n         Ok(result)\n     }\n \n-    fn seek(&mut self, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+    fn seek(&mut self, _communicate_allowed: bool, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n         throw_unsup_format!(\"cannot seek on stdout\");\n     }\n }\n@@ -97,15 +105,16 @@ impl<'tcx> FileDescriptor<'tcx> for io::Stderr {\n         throw_unsup_format!(\"stdout cannot be used as FileHandle\");\n     }\n \n-    fn read(&mut self, _bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn read(&mut self, _communicate_allowed: bool, _bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n         throw_unsup_format!(\"cannot read from stderr\");\n     }\n \n-    fn write(&mut self, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn write(&mut self, _communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+        // We allow writing to stderr even with isolation enabled.\n         Ok(Write::write(self, bytes))\n     }\n \n-    fn seek(&mut self, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+    fn seek(&mut self, _communicate_allowed: bool, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n         throw_unsup_format!(\"cannot seek on stderr\");\n     }\n }\n@@ -553,7 +562,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"read\")?;\n+        // Isolation check is done via `FileDescriptor` trait.\n \n         trace!(\"Reading from FD {}, size {}\", fd, count);\n \n@@ -577,7 +586,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // `File::read` never returns a value larger than `count`,\n             // so this cannot fail.\n             let result = file_descriptor\n-                .read(&mut bytes)?\n+                .read(this.machine.communicate, &mut bytes)?\n                 .map(|c| i64::try_from(c).unwrap());\n \n             match result {\n@@ -605,9 +614,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n-        if fd >= 3 {\n-            this.check_no_isolation(\"write\")?;\n-        }\n+        // Isolation check is done via `FileDescriptor` trait.\n \n         // Check that the *entire* buffer is actually valid memory.\n         this.memory.check_ptr_access(\n@@ -623,7 +630,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n             let bytes = this.memory.read_bytes(buf, Size::from_bytes(count))?;\n             let result = file_descriptor\n-                .write(&bytes)?\n+                .write(this.machine.communicate, &bytes)?\n                 .map(|c| i64::try_from(c).unwrap());\n             this.try_unwrap_io_result(result)\n         } else {\n@@ -639,7 +646,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n-        this.check_no_isolation(\"lseek64\")?;\n+        // Isolation check is done via `FileDescriptor` trait.\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n         let offset = this.read_scalar(offset_op)?.to_i64()?;\n@@ -659,7 +666,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n             let result = file_descriptor\n-                .seek(seek_from)?\n+                .seek(this.machine.communicate, seek_from)?\n                 .map(|offset| i64::try_from(offset).unwrap());\n             this.try_unwrap_io_result(result)\n         } else {"}, {"sha": "6c467a2d1f141a9268b38a33b5cd2ca7d2275b40", "filename": "tests/compile-fail/fs/isolated_stdin.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/52c7b8ec1115d0f8ce989af779be5c2f872266c6/tests%2Fcompile-fail%2Ffs%2Fisolated_stdin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52c7b8ec1115d0f8ce989af779be5c2f872266c6/tests%2Fcompile-fail%2Ffs%2Fisolated_stdin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffs%2Fisolated_stdin.rs?ref=52c7b8ec1115d0f8ce989af779be5c2f872266c6", "patch": "@@ -0,0 +1,13 @@\n+// ignore-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() -> std::io::Result<()> {\n+    let mut bytes = [0u8; 512];\n+    unsafe {\n+        libc::read(0, bytes.as_mut_ptr() as *mut libc::c_void, 512); //~ ERROR `read` not available when isolation is enabled\n+    }\n+    Ok(())\n+}"}]}