{"sha": "5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "node_id": "C_kwDOAAsO6NoAKDUxNjBmOGY4NDNlMWRiZDQzY2YzNDFjYzhhYTVkOTE3ZDIyYzk4Yjk", "commit": {"author": {"name": "Yuri Astrakhan", "email": "YuriAstrakhan@gmail.com", "date": "2022-03-30T19:14:15Z"}, "committer": {"name": "Yuri Astrakhan", "email": "YuriAstrakhan@gmail.com", "date": "2022-03-30T19:14:15Z"}, "message": "Spellchecking compiler comments\n\nThis PR cleans up the rest of the spelling mistakes in the compiler comments. This PR does not change any literal or code spelling issues.", "tree": {"sha": "98f378da3bf249dd192f6b9048a81c86238b6e91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98f378da3bf249dd192f6b9048a81c86238b6e91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "html_url": "https://github.com/rust-lang/rust/commit/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/comments", "author": {"login": "nyurik", "id": 1641515, "node_id": "MDQ6VXNlcjE2NDE1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1641515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nyurik", "html_url": "https://github.com/nyurik", "followers_url": "https://api.github.com/users/nyurik/followers", "following_url": "https://api.github.com/users/nyurik/following{/other_user}", "gists_url": "https://api.github.com/users/nyurik/gists{/gist_id}", "starred_url": "https://api.github.com/users/nyurik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nyurik/subscriptions", "organizations_url": "https://api.github.com/users/nyurik/orgs", "repos_url": "https://api.github.com/users/nyurik/repos", "events_url": "https://api.github.com/users/nyurik/events{/privacy}", "received_events_url": "https://api.github.com/users/nyurik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nyurik", "id": 1641515, "node_id": "MDQ6VXNlcjE2NDE1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1641515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nyurik", "html_url": "https://github.com/nyurik", "followers_url": "https://api.github.com/users/nyurik/followers", "following_url": "https://api.github.com/users/nyurik/following{/other_user}", "gists_url": "https://api.github.com/users/nyurik/gists{/gist_id}", "starred_url": "https://api.github.com/users/nyurik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nyurik/subscriptions", "organizations_url": "https://api.github.com/users/nyurik/orgs", "repos_url": "https://api.github.com/users/nyurik/repos", "events_url": "https://api.github.com/users/nyurik/events{/privacy}", "received_events_url": "https://api.github.com/users/nyurik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e7514670db841a7f0d7656f3b13b1c8b2c11599", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e7514670db841a7f0d7656f3b13b1c8b2c11599", "html_url": "https://github.com/rust-lang/rust/commit/3e7514670db841a7f0d7656f3b13b1c8b2c11599"}], "stats": {"total": 342, "additions": 171, "deletions": 171}, "files": [{"sha": "193f3145dc14709630f01d643f1fea62e6070ae9", "filename": "compiler/rustc_apfloat/src/ieee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -2646,7 +2646,7 @@ mod sig {\n \n         // Convert the result having \"2 * precision\" significant-bits back to the one\n         // having \"precision\" significant-bits. First, move the radix point from\n-        // poision \"2*precision - 1\" to \"precision - 1\". The exponent need to be\n+        // position \"2*precision - 1\" to \"precision - 1\". The exponent need to be\n         // adjusted by \"2*precision - 1\" - \"precision - 1\" = \"precision\".\n         *exp -= precision as ExpInt + 1;\n "}, {"sha": "affb4289cb1b5a4f229a79cdaba90b1d7008f7c3", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -295,7 +295,7 @@ impl AttrAnnotatedTokenStream {\n ///\n /// For example, `#[cfg(FALSE)] struct Foo {}` would\n /// have an `attrs` field containing the `#[cfg(FALSE)]` attr,\n-/// and a `tokens` field storing the (unparesd) tokens `struct Foo {}`\n+/// and a `tokens` field storing the (unparsed) tokens `struct Foo {}`\n #[derive(Clone, Debug, Encodable, Decodable)]\n pub struct AttributesData {\n     /// Attributes, both outer and inner."}, {"sha": "f0106630797d33d91f4cf771d22759a272c80d77", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -158,7 +158,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n                         .infcx\n                         .handle_opaque_type(a, b, a_is_expected, &cause, param_env)?\n                         .obligations,\n-                    // These fields are filled in during exectuion of the operation\n+                    // These fields are filled in during execution of the operation\n                     base_universe: None,\n                     region_constraints: None,\n                 },"}, {"sha": "90024c5921a9543cf98281a748ceb5b1bfc03454", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -23,7 +23,7 @@\n //!     ss2 = explicit_slot 8 ; _4: (&&[u16],) size=8 align=8,8\n //!     sig0 = (i64, i64, i64) system_v\n //!     sig1 = (i64, i64, i64) system_v\n-//!     fn0 = colocated u0:6 sig1 ; Instance { def: Item(DefId(0/0:31 ~ example[8787]::{{impl}}[1]::call_mut[0])), substs: [ReErased, ReErased] }\n+//!     fn0 = collocated u0:6 sig1 ; Instance { def: Item(DefId(0/0:31 ~ example[8787]::{{impl}}[1]::call_mut[0])), substs: [ReErased, ReErased] }\n //!\n //! block0(v0: i64, v1: i64, v2: i64):\n //!     v3 = stack_addr.i64 ss0"}, {"sha": "d4eaf6389dfe9949518005548cc9f4253b3da32e", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -779,7 +779,7 @@ pub fn compute_per_cgu_lto_type(\n     // we'll encounter later.\n     let is_allocator = module_kind == ModuleKind::Allocator;\n \n-    // We ignore a request for full crate grath LTO if the cate type\n+    // We ignore a request for full crate graph LTO if the crate type\n     // is only an rlib, as there is no full crate graph to process,\n     // that'll happen later.\n     //"}, {"sha": "508108df001ec588f36938a09d61702ded26de5d", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -35,7 +35,7 @@ enum Frame {\n impl Frame {\n     /// Construct a new frame around the delimited set of tokens.\n     fn new(mut tts: Vec<mbe::TokenTree>) -> Frame {\n-        // Need to add empty delimeters.\n+        // Need to add empty delimiters.\n         let open_tt = mbe::TokenTree::token(token::OpenDelim(token::NoDelim), DUMMY_SP);\n         let close_tt = mbe::TokenTree::token(token::CloseDelim(token::NoDelim), DUMMY_SP);\n         tts.insert(0, open_tt);\n@@ -210,7 +210,7 @@ pub(super) fn transcribe<'a>(\n                                 ));\n                             }\n                         } else {\n-                            // 0 is the initial counter (we have done 0 repretitions so far). `len`\n+                            // 0 is the initial counter (we have done 0 repetitions so far). `len`\n                             // is the total number of repetitions we should generate.\n                             repeats.push((0, len));\n "}, {"sha": "cdc05095e685111a983d32dc24e9ae2b92699992", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -1717,7 +1717,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         if let Some(Some(row)) = self.rows.get(row) { Some(row) } else { None }\n     }\n \n-    /// Interescts `row` with `set`. `set` can be either `BitSet` or\n+    /// Intersects `row` with `set`. `set` can be either `BitSet` or\n     /// `HybridBitSet`. Has no effect if `row` does not exist.\n     ///\n     /// Returns true if the row was changed."}, {"sha": "5671711397a2ce9452165adba73666108b8ffc30", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -2,7 +2,7 @@\n //! in particular to extract out the resulting region obligations and\n //! encode them therein.\n //!\n-//! For an overview of what canonicaliation is and how it fits into\n+//! For an overview of what canonicalization is and how it fits into\n //! rustc, check out the [chapter in the rustc dev guide][c].\n //!\n //! [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html"}, {"sha": "9b2fc07e9cbe4e930dcf8e1eb91dd89e98748c1d", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -1164,7 +1164,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let len = sub1.len() - common_default_params;\n                     let consts_offset = len - sub1.consts().count();\n \n-                    // Only draw `<...>` if there're lifetime/type arguments.\n+                    // Only draw `<...>` if there are lifetime/type arguments.\n                     if len > 0 {\n                         values.0.push_normal(\"<\");\n                         values.1.push_normal(\"<\");\n@@ -1245,7 +1245,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n \n                     // Close the type argument bracket.\n-                    // Only draw `<...>` if there're lifetime/type arguments.\n+                    // Only draw `<...>` if there are lifetime/type arguments.\n                     if len > 0 {\n                         values.0.push_normal(\">\");\n                         values.1.push_normal(\">\");\n@@ -1857,7 +1857,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     })\n                     .transpose();\n                 if output.is_some() {\n-                    // We don't account for multiple `Future::Output = Ty` contraints.\n+                    // We don't account for multiple `Future::Output = Ty` constraints.\n                     return output;\n                 }\n             }"}, {"sha": "1e3293efad649be1d3e490353ed7b37fe19d979a", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -83,7 +83,7 @@ where\n         // But if we did in reverse order, we would create a `v <:\n         // LHS` (or vice versa) constraint and then instantiate\n         // `v`. This would require further processing to achieve same\n-        // end-result; in partiular, this screws up some of the logic\n+        // end-result; in particular, this screws up some of the logic\n         // in coercion, which expects LUB to figure out that the LHS\n         // is (e.g.) `Box<i32>`. A more obvious solution might be to\n         // iterate on the subtype obligations that are returned, but I"}, {"sha": "a9b4451e77b08ce0d6d5adac91a98e50572d3d21", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -343,7 +343,7 @@ pub struct InferCtxt<'a, 'tcx> {\n \n     /// Track how many errors were reported when this infcx is created.\n     /// If the number of errors increases, that's also a sign (line\n-    /// `tained_by_errors`) to avoid reporting certain kinds of errors.\n+    /// `tainted_by_errors`) to avoid reporting certain kinds of errors.\n     // FIXME(matthewjasper) Merge into `tainted_by_errors_flag`\n     err_count_on_creation: usize,\n "}, {"sha": "94a795f613e9dbfa08da38aae9ed373a92376dcd", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -550,7 +550,7 @@ where\n         }\n \n         if a == b {\n-            // Subtle: if a or b has a bound variable that we are lazilly\n+            // Subtle: if a or b has a bound variable that we are lazily\n             // substituting, then even if a == b, it could be that the values we\n             // will substitute for those bound variables are *not* the same, and\n             // hence returning `Ok(a)` is incorrect."}, {"sha": "78e6f3a05be66c58c46c54a29f59ee3a63ab264d", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -306,7 +306,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// # Constrain regions, not the hidden concrete type\n     ///\n     /// Note that generating constraints on each region `Rc` is *not*\n-    /// the same as generating an outlives constraint on `Tc` iself.\n+    /// the same as generating an outlives constraint on `Tc` itself.\n     /// For example, if we had a function like this:\n     ///\n     /// ```rust"}, {"sha": "291362a61809ea63b33c1270b3f6620b382095c9", "filename": "compiler/rustc_infer/src/infer/outlives/components.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -125,7 +125,7 @@ fn compute_components<'tcx>(\n             // regionck more ways to prove that it holds. However,\n             // regionck is not (at least currently) prepared to deal with\n             // higher-ranked regions that may appear in the\n-            // trait-ref. Therefore, if we see any higher-ranke regions,\n+            // trait-ref. Therefore, if we see any higher-rank regions,\n             // we simply fallback to the most restrictive rule, which\n             // requires that `Pi: 'a` for all `i`.\n             ty::Projection(ref data) => {"}, {"sha": "97e219ab61de936b1e8dd5e9d67d0ad004a58694", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -93,7 +93,7 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n         &self.region_bound_pairs_map\n     }\n \n-    /// This is a hack to support the old-skool regionck, which\n+    /// This is a hack to support the old-school regionck, which\n     /// processes region constraints from the main function and the\n     /// closure together. In that context, when we enter a closure, we\n     /// want to be able to \"save\" the state of the surrounding a"}, {"sha": "e3312e6c6e14680c2f33736be429396d50768daf", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -365,7 +365,7 @@ where\n         debug!(\"projection_must_outlive: approx_env_bounds={:?}\", approx_env_bounds);\n \n         // Remove outlives bounds that we get from the environment but\n-        // which are also deducable from the trait. This arises (cc\n+        // which are also deducible from the trait. This arises (cc\n         // #55756) in cases where you have e.g., `<T as Foo<'a>>::Item:\n         // 'a` in the environment but `trait Foo<'b> { type Item: 'b\n         // }` in the trait definition."}, {"sha": "9ba527862590a682be1a17c75426a72dc20b4290", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -33,7 +33,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     /// not entirely true. In particular, in the future, we may extend the\n     /// environment with implied bounds or other info about how placeholders\n     /// relate to regions in outer universes. In that case, `P1: R` for example\n-    /// might become solveable.\n+    /// might become solvable.\n     ///\n     /// # Summary of the implementation\n     ///\n@@ -210,7 +210,7 @@ impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n         // * `scc_placeholder[scc1]` stores the placeholder that `scc1` must\n         //   be equal to (if any)\n         //\n-        // For each succssor `scc2` where `scc1: scc2`:\n+        // For each successor `scc2` where `scc1: scc2`:\n         //\n         // * `scc_placeholder[scc2]` stores some placeholder `P` where\n         //   `scc2: P` (if any)\n@@ -243,7 +243,7 @@ impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n             // Update minimum universe of scc1.\n             self.scc_universes[scc1] = scc1_universe;\n \n-            // At this point, `scc_placholder[scc1]` stores the placeholder that\n+            // At this point, `scc_placeholder[scc1]` stores the placeholder that\n             // `scc1` must be equal to, if any.\n             if let Some(scc1_placeholder) = self.scc_placeholders[scc1] {\n                 debug!("}, {"sha": "4ea1c3f76c8ad415e392d44a779de1e6a443af5c", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -46,7 +46,7 @@ pub struct RegionConstraintStorage<'tcx> {\n     /// exist). This prevents us from making many such regions.\n     glbs: CombineMap<'tcx>,\n \n-    /// When we add a R1 == R2 constriant, we currently add (a) edges\n+    /// When we add a R1 == R2 constraint, we currently add (a) edges\n     /// R1 <= R2 and R2 <= R1 and (b) we unify the two regions in this\n     /// table. You can then call `opportunistic_resolve_var` early\n     /// which will map R1 and R2 to some common region (i.e., either"}, {"sha": "cf9345142afa79631818eab1876ffe764113e5b4", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n \n /// The opportunistic region resolver opportunistically resolves regions\n /// variables to the variable with the least variable id. It is used when\n-/// normlizing projections to avoid hitting the recursion limit by creating\n+/// normalizing projections to avoid hitting the recursion limit by creating\n /// many versions of a predicate for types that in the end have to unify.\n ///\n /// If you want to resolve type and const variables as well, call"}, {"sha": "ea4955e9a549a0bf51f315e7a16ba65b16d9ff07", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -929,7 +929,7 @@ fn analysis(tcx: TyCtxt<'_>, (): ()) -> Result<()> {\n                 });\n             },\n             {\n-                // We force these querie to run,\n+                // We force these queries to run,\n                 // since they might not otherwise get called.\n                 // This marks the corresponding crate-level attributes\n                 // as used, and ensures that their values are valid."}, {"sha": "675bee738a672a313c78580618e10f5ba6ea33eb", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n         let substs = cx.typeck_results().node_substs(expr.hir_id);\n         if substs.needs_subst() {\n             // We can't resolve on types that require monomorphization, so we don't handle them if\n-            // we need to perfom substitution.\n+            // we need to perform substitution.\n             return;\n         }\n         let param_env = cx.tcx.param_env(trait_id);"}, {"sha": "5704c6ed3b25d7653e7d0a25e7bad400ae1a759e", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -2254,7 +2254,7 @@ declare_lint! {\n declare_lint! {\n     /// The `nontrivial_structural_match` lint detects constants that are used in patterns,\n     /// whose type is not structural-match and whose initializer body actually uses values\n-    /// that are not structural-match. So `Option<NotStruturalMatch>` is ok if the constant\n+    /// that are not structural-match. So `Option<NotStructuralMatch>` is ok if the constant\n     /// is just `None`.\n     ///\n     /// ### Example\n@@ -2276,7 +2276,7 @@ declare_lint! {\n     ///\n     /// ### Explanation\n     ///\n-    /// Previous versions of Rust accepted constants in patterns, even if those constants's types\n+    /// Previous versions of Rust accepted constants in patterns, even if those constants' types\n     /// did not have `PartialEq` derived. Thus the compiler falls back to runtime execution of\n     /// `PartialEq`, which can report that two constants are not equal even if they are\n     /// bit-equivalent.\n@@ -3626,7 +3626,7 @@ declare_lint! {\n     /// The `deref_into_dyn_supertrait` lint is output whenever there is a use of the\n     /// `Deref` implementation with a `dyn SuperTrait` type as `Output`.\n     ///\n-    /// These implementations will become shadowed when the `trait_upcasting` feature is stablized.\n+    /// These implementations will become shadowed when the `trait_upcasting` feature is stabilized.\n     /// The `deref` functions will no longer be called implicitly, so there might be behavior change.\n     ///\n     /// ### Example"}, {"sha": "4423a5cac89fda2aa0ca72ee33b30a3f63c63937", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -580,7 +580,7 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n         //\n         // Suppose that we're currently compiling crate A, and start deserializing\n         // metadata from crate B. When we deserialize a Span from crate B's metadata,\n-        // there are two posibilites:\n+        // there are two possibilities:\n         //\n         // 1. The span references a file from crate B. This makes it a 'local' span,\n         // which means that we can use crate B's serialized source map information."}, {"sha": "611f76b9dde873b1ba761d4138832e50215e0352", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -271,7 +271,7 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n         // from. We use `TAG_VALID_SPAN_FOREIGN` to indicate that a `CrateNum` should\n         // be deserialized after the rest of the span data, which tells the deserializer\n         // which crate contains the source map information.\n-        // 2. This span comes from our own crate. No special hamdling is needed - we just\n+        // 2. This span comes from our own crate. No special handling is needed - we just\n         // write `TAG_VALID_SPAN_LOCAL` to let the deserializer know that it should use\n         // our own source map information.\n         //"}, {"sha": "1f407b8f6367134a3ccdfddf8a29b03ddeeb2dcb", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -218,7 +218,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn iter_local_def_id(self) -> impl Iterator<Item = LocalDefId> + 'hir {\n-        // Create a dependency to the crate to be sure we reexcute this when the amount of\n+        // Create a dependency to the crate to be sure we re-execute this when the amount of\n         // definitions change.\n         self.tcx.ensure().hir_crate(());\n         self.tcx.untracked_resolutions.definitions.iter_local_def_id()"}, {"sha": "6b7ac883f5cebbc5a6b4abbc0da4b8ddd166a69b", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -220,7 +220,7 @@ pub enum Certainty {\n     /// distinguish the two (e.g., due to our preference for where\n     /// clauses over impls).\n     ///\n-    /// After some unifiations and things have been done, it makes\n+    /// After some unification and things have been done, it makes\n     /// sense to try and prove again -- of course, at that point, the\n     /// canonical form will be different, making this a distinct\n     /// query."}, {"sha": "002d25ab7705d289f77f8e1b10b3d6a222afc466", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -340,7 +340,7 @@ pub fn struct_lint_level<'s, 'd>(\n             (Level::Expect(expect_id), _) => {\n                 // This case is special as we actually allow the lint itself in this context, but\n                 // we can't return early like in the case for `Level::Allow` because we still\n-                // need the lint diagnostic to be emitted to `rustc_error::HanderInner`.\n+                // need the lint diagnostic to be emitted to `rustc_error::HandlerInner`.\n                 //\n                 // We can also not mark the lint expectation as fulfilled here right away, as it\n                 // can still be cancelled in the decorate function. All of this means that we simply"}, {"sha": "22c5eadf8875afb250df63a86c035aab980ffc89", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -234,7 +234,7 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     },\n     /// Something was divided by 0 (x / 0).\n     DivisionByZero,\n-    /// Something was \"remainded\" by 0 (x % 0).\n+    /// Something was \"remaineded\" by 0 (x % 0).\n     RemainderByZero,\n     /// Signed division overflowed (INT_MIN / -1).\n     DivisionOverflow,"}, {"sha": "0a4f84558fee410f229daca537a941b5972c71cc", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -2840,7 +2840,7 @@ impl<'tcx> UserTypeProjections {\n \n /// Encodes the effect of a user-supplied type annotation on the\n /// subcomponents of a pattern. The effect is determined by applying the\n-/// given list of proejctions to some underlying base type. Often,\n+/// given list of projections to some underlying base type. Often,\n /// the projection element list `projs` is empty, in which case this\n /// directly encodes a type in `base`. But in the case of complex patterns with\n /// subpatterns and bindings, we want to apply only a *part* of the type to a variable,"}, {"sha": "cee510a42413abbf63457fc6cce2452201deb8f7", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -126,7 +126,7 @@ pub enum UnusedUnsafe {\n     /// > ``\u2026 because it's nested under this `unsafe fn` ``\n     ///\n     /// the second HirId here indicates the first usage of the `unsafe` block,\n-    /// which allows retrival of the LintLevelSource for why that operation would\n+    /// which allows retrieval of the LintLevelSource for why that operation would\n     /// have been permitted without the block\n     InUnsafeFn(hir::HirId, hir::HirId),\n }"}, {"sha": "d08bede1d733447900eece1c22e6952a98f13d57", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -5,7 +5,7 @@ use super::*;\n /// Preorder traversal of a graph.\n ///\n /// Preorder traversal is when each node is visited after at least one of its predecessors. If you\n-/// are familar with some basic graph theory, then this performs a depth first search and returns\n+/// are familiar with some basic graph theory, then this performs a depth first search and returns\n /// nodes in order of discovery time.\n ///\n /// ```text"}, {"sha": "b31cc17a9594dec915eff548c8b8a679836ed3c0", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -656,7 +656,7 @@ pub enum PatKind<'tcx> {\n     /// One of the following:\n     /// * `&str`, which will be handled as a string pattern and thus exhaustiveness\n     ///   checking will detect if you use the same string twice in different patterns.\n-    /// * integer, bool, char or float, which will be handled by exhaustivenes to cover exactly\n+    /// * integer, bool, char or float, which will be handled by exhaustiveness to cover exactly\n     ///   its own value, similar to `&str`, but these values are much simpler.\n     /// * Opaque constants, that must not be matched structurally. So anything that does not derive\n     ///   `PartialEq` and `Eq`."}, {"sha": "3d0a0d2a58e1f907b07e0c9c4d1c55f4532847ef", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -524,7 +524,7 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n ///     // Case A: ImplSource points at a specific impl. Only possible when\n ///     // type is concretely known. If the impl itself has bounded\n ///     // type parameters, ImplSource will carry resolutions for those as well:\n-///     concrete.clone(); // ImpleSource(Impl_1, [ImplSource(Impl_2, [ImplSource(Impl_3)])])\n+///     concrete.clone(); // ImplSource(Impl_1, [ImplSource(Impl_2, [ImplSource(Impl_3)])])\n ///\n ///     // Case A: ImplSource points at a specific impl. Only possible when\n ///     // type is concretely known. If the impl itself has bounded"}, {"sha": "8ce428c9799f5c150d3dc7f3d2d99568477a05b4", "filename": "compiler/rustc_middle/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Futil.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -4,7 +4,7 @@ use crate::ty::{PolyTraitRef, TyCtxt};\n \n /// Given a PolyTraitRef, get the PolyTraitRefs of the trait's (transitive) supertraits.\n ///\n-/// A simplfied version of the same function at `rustc_infer::traits::util::supertraits`.\n+/// A simplified version of the same function at `rustc_infer::traits::util::supertraits`.\n pub fn supertraits<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: PolyTraitRef<'tcx>,"}, {"sha": "ee4ba49410010c9677d135a2b82ddd09c227ddd0", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -139,7 +139,7 @@ pub fn suggest_arbitrary_trait_bound(\n         (Some(_), \"Self\") => return false,\n         _ => {}\n     }\n-    // Suggest a where clause bound for a non-type paremeter.\n+    // Suggest a where clause bound for a non-type parameter.\n     let (action, prefix) = if generics.where_clause.predicates.is_empty() {\n         (\"introducing a\", \" where \")\n     } else {"}, {"sha": "0c1ab67cc4ac778c21a5a463f36865788d32ada1", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -2718,7 +2718,7 @@ impl<'tcx> ty::Instance<'tcx> {\n /// stack-based unwinding (the exact mechanism of which varies\n /// platform-by-platform).\n ///\n-/// Rust functions are classfied whether or not they can unwind based on the\n+/// Rust functions are classified whether or not they can unwind based on the\n /// active \"panic strategy\". In other words Rust functions are considered to\n /// unwind in `-Cpanic=unwind` mode and cannot unwind in `-Cpanic=abort` mode.\n /// Note that Rust supports intermingling panic=abort and panic=unwind code, but\n@@ -2773,7 +2773,7 @@ pub fn fn_can_unwind<'tcx>(\n     // To fix this UB rustc would like to change in the future to catch unwinds\n     // from function calls that may unwind within a Rust-defined `extern \"C\"`\n     // function and forcibly abort the process, thereby respecting the\n-    // `nounwind` attribut emitted for `extern \"C\"`. This behavior change isn't\n+    // `nounwind` attribute emitted for `extern \"C\"`. This behavior change isn't\n     // ready to roll out, so determining whether or not the `C` family of ABIs\n     // unwinds is conditional not only on their definition but also whether the\n     // `#![feature(c_unwind)]` feature gate is active."}, {"sha": "2a7ed6c6d7a88c02bcc3ea5f89f379d0896970f7", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -5,7 +5,7 @@\n //! - [`rustc_middle::ty::Ty`], used to represent the semantics of a type.\n //! - [`rustc_middle::ty::TyCtxt`], the central data structure in the compiler.\n //!\n-//! For more information, see [\"The `ty` module: representing types\"] in the ructc-dev-guide.\n+//! For more information, see [\"The `ty` module: representing types\"] in the rustc-dev-guide.\n //!\n //! [\"The `ty` module: representing types\"]: https://rustc-dev-guide.rust-lang.org/ty.html\n \n@@ -1263,7 +1263,7 @@ pub type PlaceholderConst<'tcx> = Placeholder<BoundConst<'tcx>>;\n /// aren't allowed to call that query: it is equal to `type_of(const_param)` which is\n /// trivial to compute.\n ///\n-/// If we now want to use that constant in a place which potentionally needs its type\n+/// If we now want to use that constant in a place which potentially needs its type\n /// we also pass the type of its `const_param`. This is the point of `WithOptConstParam`,\n /// except that instead of a `Ty` we bundle the `DefId` of the const parameter.\n /// Meaning that we need to use `type_of(const_param_did)` if `const_param_did` is `Some`"}, {"sha": "6b3bce7dec50719f0b4144dffd04bbd57f242be9", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -431,7 +431,7 @@ pub trait PrettyPrinter<'tcx>:\n             // For example, take `std::os::unix::process::CommandExt`, this trait is actually\n             // defined at `std::sys::unix::ext::process::CommandExt` (at time of writing).\n             //\n-            // `std::os::unix` rexports the contents of `std::sys::unix::ext`. `std::sys` is\n+            // `std::os::unix` reexports the contents of `std::sys::unix::ext`. `std::sys` is\n             // private so the \"true\" path to `CommandExt` isn't accessible.\n             //\n             // In this case, the `visible_parent_map` will look something like this:\n@@ -1036,7 +1036,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                 let mut resugared = false;\n \n-                // Special-case `Fn(...) -> ...` and resugar it.\n+                // Special-case `Fn(...) -> ...` and re-sugar it.\n                 let fn_trait_kind = cx.tcx().fn_trait_kind_from_lang_item(principal.def_id);\n                 if !cx.tcx().sess.verbose() && fn_trait_kind.is_some() {\n                     if let ty::Tuple(tys) = principal.substs.type_at(0).kind() {\n@@ -2171,7 +2171,7 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n         define_scoped_cx!(self);\n \n         let mut region_index = self.region_index;\n-        // If we want to print verbosly, then print *all* binders, even if they\n+        // If we want to print verbosely, then print *all* binders, even if they\n         // aren't named. Eventually, we might just want this as the default, but\n         // this is not *quite* right and changes the ordering of some output\n         // anyways."}, {"sha": "dd1ccd4e4ef0705704f979b5fd5a944782d05f48", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -284,7 +284,7 @@ static_assert_size!(TyKind<'_>, 32);\n /// - 'l0...'li and T0...Tj are the generic parameters\n ///   in scope on the function that defined the closure,\n /// - CK represents the *closure kind* (Fn vs FnMut vs FnOnce). This\n-///   is rather hackily encoded via a scalar type. See\n+///   is rather hacky encoded via a scalar type. See\n ///   `Ty::to_opt_closure_kind` for details.\n /// - CS represents the *closure signature*, representing as a `fn()`\n ///   type. For example, `fn(u32, u32) -> u32` would mean that the closure"}, {"sha": "310fdf77b6fc75d71d9661979e736f63e86259af", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -444,7 +444,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // we lower the guard.\n             let target_block = self.cfg.start_new_block();\n             let mut schedule_drops = true;\n-            // We keep a stack of all of the bindings and type asciptions\n+            // We keep a stack of all of the bindings and type descriptions\n             // from the parent candidates that we visit, that also need to\n             // be bound for each candidate.\n             traverse_candidate("}, {"sha": "4b880876d3f6366a832c3fa24bee25107c83b71a", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -234,7 +234,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     };\n                     TerminatorKind::if_(self.tcx, Operand::Copy(place), true_bb, false_bb)\n                 } else {\n-                    // The switch may be inexhaustive so we have a catch all block\n+                    // The switch may be inexhaustible so we have a catch all block\n                     debug_assert_eq!(options.len() + 1, target_blocks.len());\n                     let otherwise_block = *target_blocks.last().unwrap();\n                     let switch_targets = SwitchTargets::new("}, {"sha": "d96534fe3e0a879e6f7287dbf19ec36ee9478b03", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -567,7 +567,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let tcx = self.tcx;\n         if let LintLevel::Explicit(current_hir_id) = lint_level {\n             // Use `maybe_lint_level_root_bounded` with `root_lint_level` as a bound\n-            // to avoid adding Hir dependences on our parents.\n+            // to avoid adding Hir dependencies on our parents.\n             // We estimate the true lint roots here to avoid creating a lot of source scopes.\n \n             let parent_root = tcx.maybe_lint_level_root_bounded(\n@@ -965,7 +965,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// However, `_X` is still registered to be dropped, and so if we\n     /// do nothing else, we would generate a `DROP(_X)` that occurs\n     /// after the call. This will later be optimized out by the\n-    /// drop-elaboation code, but in the meantime it can lead to\n+    /// drop-elaboration code, but in the meantime it can lead to\n     /// spurious borrow-check errors -- the problem, ironically, is\n     /// not the `DROP(_X)` itself, but the (spurious) unwind pathways\n     /// that it creates. See #64391 for an example."}, {"sha": "8aa422252be7ebd90be679d7edf37e3c535bf430", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -1007,7 +1007,7 @@ impl<'tcx> SplitWildcard<'tcx> {\n             {\n                 // `usize`/`isize` are not allowed to be matched exhaustively unless the\n                 // `precise_pointer_size_matching` feature is enabled. So we treat those types like\n-                // `#[non_exhaustive]` enums by returning a special unmatcheable constructor.\n+                // `#[non_exhaustive]` enums by returning a special unmatchable constructor.\n                 smallvec![NonExhaustive]\n             }\n             &ty::Int(ity) => {\n@@ -1650,7 +1650,7 @@ impl<'p, 'tcx> fmt::Debug for DeconstructedPat<'p, 'tcx> {\n                     }\n \n                     // Without `cx`, we can't know which field corresponds to which, so we can't\n-                    // get the names of the fields. Instead we just display everything as a suple\n+                    // get the names of the fields. Instead we just display everything as a simple\n                     // struct, which should be good enough.\n                     write!(f, \"(\")?;\n                     for p in self.iter_fields() {"}, {"sha": "15bb5adf8ba19a2768836a0a11ce5f8397cc9f82", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -62,7 +62,7 @@\n //!\n //! Note: we will often abbreviate \"constructor\" as \"ctor\".\n //!\n-//! The idea that powers everything that is done in this file is the following: a (matcheable)\n+//! The idea that powers everything that is done in this file is the following: a (matchable)\n //! value is made from a constructor applied to a number of subvalues. Examples of constructors are\n //! `Some`, `None`, `(,)` (the 2-tuple constructor), `Foo {..}` (the constructor for a struct\n //! `Foo`), and `2` (the constructor for the number `2`). This is natural when we think of\n@@ -71,7 +71,7 @@\n //! Some of the ctors listed above might feel weird: `None` and `2` don't take any arguments.\n //! That's ok: those are ctors that take a list of 0 arguments; they are the simplest case of\n //! ctors. We treat `2` as a ctor because `u64` and other number types behave exactly like a huge\n-//! `enum`, with one variant for each number. This allows us to see any matcheable value as made up\n+//! `enum`, with one variant for each number. This allows us to see any matchable value as made up\n //! from a tree of ctors, each having a set number of children. For example: `Foo { bar: None,\n //! baz: Ok(0) }` is made from 4 different ctors, namely `Foo{..}`, `None`, `Ok` and `0`.\n //!\n@@ -342,7 +342,7 @@ pub(super) struct PatCtxt<'a, 'p, 'tcx> {\n     /// Whether the current pattern is the whole pattern as found in a match arm, or if it's a\n     /// subpattern.\n     pub(super) is_top_level: bool,\n-    /// Wether the current pattern is from a `non_exhaustive` enum.\n+    /// Whether the current pattern is from a `non_exhaustive` enum.\n     pub(super) is_non_exhaustive: bool,\n }\n "}, {"sha": "f568121b2192c71bb779bbc2c58003db7fdff335", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -860,7 +860,7 @@ where\n             // and this is ok because `open_drop` here can only be reached\n             // within that own generator's resume function.\n             // This should only happen for the self argument on the resume function.\n-            // It effetively only contains upvars until the generator transformation runs.\n+            // It effectively only contains upvars until the generator transformation runs.\n             // See librustc_body/transform/generator.rs for more details.\n             ty::Generator(_, substs, _) => {\n                 let tys: Vec<_> = substs.as_generator().upvar_tys().collect();"}, {"sha": "602ccec76a68cb7daa5471c78f4e0401fa63c9c6", "filename": "compiler/rustc_mir_dataflow/src/impls/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -40,7 +40,7 @@ use crate::{AnalysisDomain, Backward, CallReturnPlaces, GenKill, GenKillAnalysis\n ///\n /// This makes `MaybeLiveLocals` unsuitable for certain classes of optimization normally associated\n /// with a live variables analysis, notably dead-store elimination. It's a dirty hack, but it works\n-/// okay for the generator state transform (currently the main consumuer of this analysis).\n+/// okay for the generator state transform (currently the main consumer of this analysis).\n ///\n /// [`MaybeBorrowedLocals`]: super::MaybeBorrowedLocals\n /// [flow-test]: https://github.com/rust-lang/rust/blob/a08c47310c7d49cbdc5d7afb38408ba519967ecd/src/test/ui/mir-dataflow/liveness-ptr.rs"}, {"sha": "d90ead3228c2dc7b7a804b6b25f4b0af03b9eb9b", "filename": "compiler/rustc_mir_dataflow/src/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -428,7 +428,7 @@ impl<'tcx> AnalysisDomain<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n \n     // sets on_entry bits for Arg places\n     fn initialize_start_block(&self, _: &mir::Body<'tcx>, state: &mut Self::Domain) {\n-        // set all bits to 1 (uninit) before gathering counterevidence\n+        // set all bits to 1 (uninit) before gathering counter-evidence\n         state.insert_all();\n \n         drop_flag_effects_for_function_entry(self.tcx, self.body, self.mdpe, |path, s| {"}, {"sha": "f5d82315c4e38db79274477a6bb5494bcc66b3bd", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -149,7 +149,7 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n             self.check_mut_borrowing_layout_constrained_field(*place, context.is_mutating_use());\n         }\n \n-        // Some checks below need the extra metainfo of the local declaration.\n+        // Some checks below need the extra meta info of the local declaration.\n         let decl = &self.body.local_decls[place.local];\n \n         // Check the base local: it might be an unsafe-to-access static. We only check derefs of the"}, {"sha": "e1dbf90b5b9e7d0d10b3edc28b8f0801d1e8be20", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -634,7 +634,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    // Attempt to use albegraic identities to eliminate constant expressions\n+    // Attempt to use algebraic identities to eliminate constant expressions\n     fn eval_rvalue_with_identities(\n         &mut self,\n         rvalue: &Rvalue<'tcx>,"}, {"sha": "9d02f58ae65ee71578003a8621350b707a157534", "filename": "compiler/rustc_mir_transform/src/coverage/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fquery.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -66,7 +66,7 @@ impl CoverageVisitor {\n                 // The operand ID is outside the known range of counter IDs and also outside the\n                 // known range of expression IDs. In either case, the result of a missing operand\n                 // (if and when used in an expression) will be zero, so from a computation\n-                // perspective, it doesn't matter whether it is interepretted as a counter or an\n+                // perspective, it doesn't matter whether it is interpreted as a counter or an\n                 // expression.\n                 //\n                 // However, the `num_counters` and `num_expressions` query results are used to"}, {"sha": "5e366d7fb7dde9c953e423a5b3531f3773e32473", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -694,7 +694,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     /// If prev.span() was split off to the right of a closure, prev.span().lo() will be\n     /// greater than prev_original_span.lo(). The actual span of `prev_original_span` is\n     /// not as important as knowing that `prev()` **used to have the same span** as `curr(),\n-    /// which means their sort order is still meaningful for determinating the dominator\n+    /// which means their sort order is still meaningful for determining the dominator\n     /// relationship.\n     ///\n     /// When two `CoverageSpan`s have the same `Span`, dominated spans can be discarded; but if\n@@ -726,7 +726,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                 self.prev()\n             );\n             self.cutoff_prev_at_overlapping_curr();\n-        // If one span dominates the other, assocate the span with the code from the dominated\n+        // If one span dominates the other, associate the span with the code from the dominated\n         // block only (`curr`), and discard the overlapping portion of the `prev` span. (Note\n         // that if `prev.span` is wider than `prev_original_span`, a `CoverageSpan` will still\n         // be created for `prev`s block, for the non-overlapping portion, left of `curr.span`.)"}, {"sha": "5bde0c01412ac3106ff9009af281b1d20b158786", "filename": "compiler/rustc_mir_transform/src/early_otherwise_branch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -260,7 +260,7 @@ fn may_hoist<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, place: Place<'tcx>) ->\n     for (place, proj) in place.iter_projections() {\n         match proj {\n             // Dereferencing in the computation of `place` might cause issues from one of two\n-            // cateogires. First, the referrent might be invalid. We protect against this by\n+            // categories. First, the referent might be invalid. We protect against this by\n             // dereferencing references only (not pointers). Second, the use of a reference may\n             // invalidate other references that are used later (for aliasing reasons). Consider\n             // where such an invalidated reference may appear:"}, {"sha": "04b5c4e0919588480d5d31f8770a84c8b1ea4585", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -500,7 +500,7 @@ fn locals_live_across_suspend_points<'tcx>(\n                 // The `liveness` variable contains the liveness of MIR locals ignoring borrows.\n                 // This is correct for movable generators since borrows cannot live across\n                 // suspension points. However for immovable generators we need to account for\n-                // borrows, so we conseratively assume that all borrowed locals are live until\n+                // borrows, so we conservatively assume that all borrowed locals are live until\n                 // we find a StorageDead statement referencing the locals.\n                 // To do this we just union our `liveness` result with `borrowed_locals`, which\n                 // contains all the locals which has been borrowed before this suspension point."}, {"sha": "f9ca4a00c989ce85f2b2ba5d41c7ab7a2b9acf2e", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -698,7 +698,7 @@ impl<'tcx> Inliner<'tcx> {\n             // The `closure_ref` in our example above.\n             let closure_ref_arg = iter::once(self_);\n \n-            // The `tmp0`, `tmp1`, and `tmp2` in our example abonve.\n+            // The `tmp0`, `tmp1`, and `tmp2` in our example above.\n             let tuple_tmp_args = tuple_tys.iter().enumerate().map(|(i, ty)| {\n                 // This is e.g., `tuple_tmp.0` in our example above.\n                 let tuple_field = Operand::Move(tcx.mk_place_field(tuple, Field::new(i), ty));"}, {"sha": "ea1ec6249bca49bf9ee418c9f0f1b21fda25a05b", "filename": "compiler/rustc_mir_transform/src/inline/cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::ty::{self, subst::SubstsRef, InstanceDef, TyCtxt};\n use rustc_session::Limit;\n \n // FIXME: check whether it is cheaper to precompute the entire call graph instead of invoking\n-// this query riddiculously often.\n+// this query ridiculously often.\n #[instrument(level = \"debug\", skip(tcx, root, target))]\n crate fn mir_callgraph_reachable<'tcx>(\n     tcx: TyCtxt<'tcx>,"}, {"sha": "444b4126e88fc15960b16025e0451a7339161a1b", "filename": "compiler/rustc_mir_transform/src/nrvo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> MirPass<'tcx> for RenameReturnPlace {\n         let (renamed_decl, ret_decl) =\n             body.local_decls.pick2_mut(returned_local, mir::RETURN_PLACE);\n \n-        // Sometimes, the return place is assigned a local of a different but coercable type, for\n+        // Sometimes, the return place is assigned a local of a different but coercible type, for\n         // example `&mut T` instead of `&T`. Overwriting the `LocalInfo` for the return place means\n         // its type may no longer match the return type of its function. This doesn't cause a\n         // problem in codegen because these two types are layout-compatible, but may be unexpected."}, {"sha": "03b9ecc959695f126e77db8a5b28c52d817b65ac", "filename": "compiler/rustc_mir_transform/src/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_noop_landing_pads.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -36,7 +36,7 @@ impl RemoveNoopLandingPads {\n                 | StatementKind::AscribeUserType(..)\n                 | StatementKind::Coverage(..)\n                 | StatementKind::Nop => {\n-                    // These are all nops in a landing pad\n+                    // These are all noops in a landing pad\n                 }\n \n                 StatementKind::Assign(box (place, Rvalue::Use(_) | Rvalue::Discriminant(_))) => {"}, {"sha": "efa45883eab4b13155443b41880227cc89d40e1c", "filename": "compiler/rustc_mir_transform/src/remove_uninit_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -12,7 +12,7 @@ use crate::MirPass;\n /// that point.\n ///\n /// This is redundant with drop elaboration, but we need to do it prior to const-checking, and\n-/// running const-checking after drop elaboration makes it opimization dependent, causing issues\n+/// running const-checking after drop elaboration makes it optimization dependent, causing issues\n /// like [#90770].\n ///\n /// [#90770]: https://github.com/rust-lang/rust/issues/90770"}, {"sha": "921a11a3a06d2d660c89ec7f7c825855c8983e23", "filename": "compiler/rustc_mir_transform/src/remove_unneeded_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_unneeded_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_unneeded_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_unneeded_drops.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -2,7 +2,7 @@\n //!\n //! When the MIR is built, we check `needs_drop` before emitting a `Drop` for a place. This pass is\n //! useful because (unlike MIR building) it runs after type checking, so it can make use of\n-//! `Reveal::All` to provide more precies type information.\n+//! `Reveal::All` to provide more precise type information.\n \n use crate::MirPass;\n use rustc_middle::mir::*;"}, {"sha": "70e2e8d75e8188d291cd624934661df54758da79", "filename": "compiler/rustc_mir_transform/src/simplify_try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -72,7 +72,7 @@ struct ArmIdentityInfo<'tcx> {\n     /// (StorageLive index,, StorageDead index, Local)\n     storage_stmts: Vec<(usize, usize, Local)>,\n \n-    /// The statements that should be removed (turned into nops)\n+    /// The statements that should be removed (turned into noops)\n     stmts_to_remove: Vec<usize>,\n \n     /// Indices of debug variables that need to be adjusted to point to"}, {"sha": "c4ffb19f87a91a6595a193c858b0c4fdbd47496b", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -501,7 +501,7 @@ fn mono_item_visibility<'tcx>(\n         // * First is weak lang items. These are basically mechanisms for\n         //   libcore to forward-reference symbols defined later in crates like\n         //   the standard library or `#[panic_handler]` definitions. The\n-        //   definition of these weak lang items needs to be referenceable by\n+        //   definition of these weak lang items needs to be referencable by\n         //   libcore, so we're no longer a candidate for internalization.\n         //   Removal of these functions can't be done by LLVM but rather must be\n         //   done by the linker as it's a non-local decision."}, {"sha": "8ddfdc632f73c49885a211e4a938359f09145349", "filename": "compiler/rustc_monomorphize/src/polymorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -65,7 +65,7 @@ fn unused_generic_params<'tcx>(\n     mark_used_by_default_parameters(tcx, def_id, generics, &mut unused_parameters);\n     debug!(?unused_parameters, \"(after default)\");\n \n-    // Visit MIR and accumululate used generic parameters.\n+    // Visit MIR and accumulate used generic parameters.\n     let body = match tcx.hir().body_const_context(def_id.expect_local()) {\n         // Const functions are actually called and should thus be considered for polymorphization\n         // via their runtime MIR."}, {"sha": "8f64d6d732fab357640c4af025fa79118676c8e8", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -203,7 +203,7 @@ impl<'a> Parser<'a> {\n         &self.sess.span_diagnostic\n     }\n \n-    /// Relace `self` with `snapshot.parser` and extend `unclosed_delims` with `snapshot.unclosed_delims`.\n+    /// Replace `self` with `snapshot.parser` and extend `unclosed_delims` with `snapshot.unclosed_delims`.\n     /// This is to avoid losing unclosed delims errors `create_snapshot_for_diagnostic` clears.\n     pub(super) fn restore_snapshot(&mut self, snapshot: SnapshotParser<'a>) {\n         *self = snapshot.parser;"}, {"sha": "abcf9ab204759d25ce524533884f43a9422c5bd4", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -276,7 +276,7 @@ impl<'a> Parser<'a> {\n                 lhs = self.parse_assoc_op_ascribe(lhs, lhs_span)?;\n                 continue;\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n-                // If we didn\u2019t have to handle `x..`/`x..=`, it would be pretty easy to\n+                // If we did not have to handle `x..`/`x..=`, it would be pretty easy to\n                 // generalise it to the Fixity::None code.\n                 lhs = self.parse_range_expr(prec, lhs, op, cur_op_span)?;\n                 break;"}, {"sha": "b242c1e050dc0a97be01cc0a428a1aba584462c8", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -150,7 +150,7 @@ pub struct Parser<'a> {\n     pub current_closure: Option<ClosureSpans>,\n }\n \n-/// Stores span informations about a closure.\n+/// Stores span information about a closure.\n #[derive(Clone)]\n pub struct ClosureSpans {\n     pub whole_closure: Span,"}, {"sha": "00bac26a16a98bd3fa17cfc86e1d1b14fab0c690", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -729,7 +729,7 @@ impl<'a> Parser<'a> {\n \n /// Finds the indices of all characters that have been processed and differ between the actual\n /// written code (code snippet) and the `InternedString` that gets processed in the `Parser`\n-/// in order to properly synthethise the intra-string `Span`s for error diagnostics.\n+/// in order to properly synthesise the intra-string `Span`s for error diagnostics.\n fn find_skips_from_snippet(\n     snippet: Option<string::String>,\n     str_style: Option<usize>,"}, {"sha": "9e352fa5cc6736f066c0df47cbb83266a3fd015a", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -99,7 +99,7 @@ impl<'tcx> hir::itemlikevisit::ItemLikeVisitor<'tcx> for CheckConstTraitVisitor<\n                         } = *trait_item\n                         {\n                             // we can ignore functions that do not have default bodies:\n-                            // if those are unimplemented it will be catched by typeck.\n+                            // if those are unimplemented it will be caught by typeck.\n                             if !defaultness.has_value()\n                                 || self\n                                     .tcx"}, {"sha": "36c1739ebc56cb3640e1fd8ce72717e18165efaf", "filename": "compiler/rustc_passes/src/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fregion.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -291,7 +291,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n     // like AddAssign is implemented).\n \n     // For primitive types (which, despite having a trait impl, don't actually\n-    // end up calling it), the evluation order is right-to-left. For example,\n+    // end up calling it), the evaluation order is right-to-left. For example,\n     // the following code snippet:\n     //\n     //    let y = &mut 0;"}, {"sha": "170972e0e7d267a62cd16c4df5c5b1332ebc5601", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         }\n \n         if !self.tcx.features().staged_api {\n-            // Propagate unstability.  This can happen even for non-staged-api crates in case\n+            // Propagate instability.  This can happen even for non-staged-api crates in case\n             // -Zforce-unstable-if-unmarked is set.\n             if let Some(stab) = self.parent_stab {\n                 if inherit_deprecation.yes() && stab.level.is_unstable() {\n@@ -344,7 +344,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         match i.kind {\n             // Inherent impls and foreign modules serve only as containers for other items,\n             // they don't have their own stability. They still can be annotated as unstable\n-            // and propagate this unstability to children, but this annotation is completely\n+            // and propagate this instability to children, but this annotation is completely\n             // optional. They inherit stability from their parents when unannotated.\n             hir::ItemKind::Impl(hir::Impl { of_trait: None, .. })\n             | hir::ItemKind::ForeignMod { .. } => {\n@@ -557,7 +557,7 @@ impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n     fn visit_item(&mut self, i: &'tcx Item<'tcx>) {\n         // Inherent impls and foreign modules serve only as containers for other items,\n         // they don't have their own stability. They still can be annotated as unstable\n-        // and propagate this unstability to children, but this annotation is completely\n+        // and propagate this instability to children, but this annotation is completely\n         // optional. They inherit stability from their parents when unannotated.\n         if !matches!(\n             i.kind,"}, {"sha": "cc64dd2af2c3c969baaea62afece4456992ac5ac", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -559,9 +559,9 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n                 }\n             }\n \n-            // Hygine isn't really implemented for `macro_rules!` macros at the\n+            // Hygiene isn't really implemented for `macro_rules!` macros at the\n             // moment. Accordingly, marking them as reachable is unwise. `macro` macros\n-            // have normal  hygine, so we can treat them like other items without type\n+            // have normal hygiene, so we can treat them like other items without type\n             // privacy and mark them reachable.\n             DefKind::Macro(_) => {\n                 let item = self.tcx.hir().expect_item(def_id);\n@@ -1539,7 +1539,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                             // 3. mentioned in the associated types of the impl\n                             //\n                             // Those in 1. can only occur if the trait is in\n-                            // this crate and will've been warned about on the\n+                            // this crate and will have been warned about on the\n                             // trait definition (there's no need to warn twice\n                             // so we don't check the methods).\n                             //\n@@ -1999,7 +1999,7 @@ fn visibility(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Visibility {\n                 }\n                 // - AST lowering may clone `use` items and the clones don't\n                 //   get their entries in the resolver's visibility table.\n-                // - AST lowering also creates opaque type items with inherited visibilies.\n+                // - AST lowering also creates opaque type items with inherited visibilities.\n                 //   Visibility on them should have no effect, but to avoid the visibility\n                 //   query failing on some items, we provide it for opaque types as well.\n                 Node::Item(hir::Item {"}, {"sha": "1f8d87a7e913fc3ced081d5b717174b3ac14ef7a", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -7,7 +7,7 @@\n //! The serialisation is performed on-demand when each node is emitted. Using this\n //! scheme, we do not need to keep the current graph in memory.\n //!\n-//! The deserisalisation is performed manually, in order to convert from the stored\n+//! The deserialization is performed manually, in order to convert from the stored\n //! sequence of NodeInfos to the different arrays in SerializedDepGraph.  Since the\n //! node and edge count are stored at the end of the file, all the arrays can be\n //! pre-allocated with the right length."}, {"sha": "6c7d4afea67ee240578fc85d272bf1494a58d641", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -1603,7 +1603,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 // Remove the `removal_span`.\n                 corrections.push((removal_span, \"\".to_string()));\n \n-                // Find the span after the crate name and if it has nested imports immediatately\n+                // Find the span after the crate name and if it has nested imports immediately\n                 // after the crate name already.\n                 //   ie. `use a::b::{c, d};`\n                 //               ^^^^^^^^^"}, {"sha": "253b604bd232e9ee9e7237d021ac86c421230442", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -74,7 +74,7 @@ crate struct Import<'a> {\n     /// In the case where the `Import` was expanded from a \"nested\" use tree,\n     /// this id is the ID of the leaf tree. For example:\n     ///\n-    /// ```ignore (pacify the mercilous tidy)\n+    /// ```ignore (pacify the merciless tidy)\n     /// use foo::bar::{a, b}\n     /// ```\n     ///"}, {"sha": "b05ec6549976e8a8a18aa6c5da6e77e5e57b8526", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -2151,7 +2151,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                             // but if we make a mistake elsewhere, mainly by keeping something in\n                             // `missing_named_lifetime_spots` that we shouldn't, like associated\n                             // `const`s or making a mistake in the AST lowering we would provide\n-                            // non-sensical suggestions. Guard against that by skipping these.\n+                            // nonsensical suggestions. Guard against that by skipping these.\n                             // (#74264)\n                             continue;\n                         }"}, {"sha": "afb19d7df9fce035b0e1730829f643a364a335ef", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -261,7 +261,7 @@ enum Scope<'a> {\n         s: ScopeRef<'a>,\n     },\n \n-    /// When we have nested trait refs, we concanetate late bound vars for inner\n+    /// When we have nested trait refs, we concatenate late bound vars for inner\n     /// trait refs from outer ones. But we also need to include any HRTB\n     /// lifetimes encountered when identifying the trait that an associated type\n     /// is declared on.\n@@ -282,8 +282,8 @@ enum BinderScopeType {\n     /// Any non-concatenating binder scopes.\n     Normal,\n     /// Within a syntactic trait ref, there may be multiple poly trait refs that\n-    /// are nested (under the `associcated_type_bounds` feature). The binders of\n-    /// the innner poly trait refs are extended from the outer poly trait refs\n+    /// are nested (under the `associated_type_bounds` feature). The binders of\n+    /// the inner poly trait refs are extended from the outer poly trait refs\n     /// and don't increase the late bound depth. If you had\n     /// `T: for<'a>  Foo<Bar: for<'b> Baz<'a, 'b>>`, then the `for<'b>` scope\n     /// would be `Concatenating`. This also used in trait refs in where clauses\n@@ -2930,7 +2930,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 path_span: Span,\n                 generic_args: &'v hir::GenericArgs<'v>,\n             ) {\n-                // parenthesized args enter a new elison scope\n+                // parenthesized args enter a new elision scope\n                 if generic_args.parenthesized {\n                     return;\n                 }"}, {"sha": "48675fa88270adf3ec06b2f80a825c97138a213e", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -506,7 +506,7 @@ impl ModuleKind {\n /// program) if all but one of them come from glob imports.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n struct BindingKey {\n-    /// The identifier for the binding, aways the `normalize_to_macros_2_0` version of the\n+    /// The identifier for the binding, always the `normalize_to_macros_2_0` version of the\n     /// identifier.\n     ident: Ident,\n     ns: Namespace,"}, {"sha": "3a90908c0df0ac387898fb83564c09f45b46e031", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -69,7 +69,7 @@ pub enum MacroRulesScope<'a> {\n /// The reason is that we update scopes with value `MacroRulesScope::Invocation(invoc_id)`\n /// in-place after `invoc_id` gets expanded.\n /// This helps to avoid uncontrollable growth of `macro_rules!` scope chains,\n-/// which usually grow lineraly with the number of macro invocations\n+/// which usually grow linearly with the number of macro invocations\n /// in a module (including derives) and hurt performance.\n pub(crate) type MacroRulesScopeRef<'a> = Interned<'a, Cell<MacroRulesScope<'a>>>;\n "}, {"sha": "1eb575e0db2a606dfdba520f48ce3563c4172700", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -1437,7 +1437,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n         self.process_macro_use(l.span);\n         self.process_var_decl(&l.pat);\n \n-        // Just walk the initialiser and type (don't want to walk the pattern again).\n+        // Just walk the initializer and type (don't want to walk the pattern again).\n         walk_list!(self, visit_ty, &l.ty);\n         walk_list!(self, visit_expr, &l.init);\n     }"}, {"sha": "937e0cf045ad25d61aba2936baa364f4f1cf1edf", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -1177,7 +1177,7 @@ pub struct HygieneEncodeContext {\n     /// that we don't accidentally try to encode any more `SyntaxContexts`\n     serialized_ctxts: Lock<FxHashSet<SyntaxContext>>,\n     /// The `SyntaxContexts` that we have serialized (e.g. as a result of encoding `Spans`)\n-    /// in the most recent 'round' of serializnig. Serializing `SyntaxContextData`\n+    /// in the most recent 'round' of serializing. Serializing `SyntaxContextData`\n     /// may cause us to serialize more `SyntaxContext`s, so serialize in a loop\n     /// until we reach a fixed point.\n     latest_ctxts: Lock<FxHashSet<SyntaxContext>>,"}, {"sha": "f66c3ab15b04aa48dac2452f2b66c04bc163c00f", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -1637,7 +1637,7 @@ impl fmt::Display for Ident {\n /// hygiene data, most importantly name of the crate it refers to.\n /// As a result we print `$crate` as `crate` if it refers to the local crate\n /// and as `::other_crate_name` if it refers to some other crate.\n-/// Note, that this is only done if the ident token is printed from inside of AST pretty-pringing,\n+/// Note, that this is only done if the ident token is printed from inside of AST pretty-printing,\n /// but not otherwise. Pretty-printing is the only way for proc macros to discover token contents,\n /// so we should not perform this lossy conversion if the top level call to the pretty-printer was\n /// done for a token stream or a single token.\n@@ -1812,7 +1812,7 @@ pub(crate) struct Interner(Lock<InternerInner>);\n // revisited after further improvements to `indexmap`.\n //\n // This type is private to prevent accidentally constructing more than one\n-// `Interner` on the same thread, which makes it easy to mixup `Symbol`s\n+// `Interner` on the same thread, which makes it easy to mix up `Symbol`s\n // between `Interner`s.\n #[derive(Default)]\n struct InternerInner {"}, {"sha": "72709d31021b2238c4313741d228b7b6cacb1e02", "filename": "compiler/rustc_target/src/abi/call/sparc64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -159,7 +159,7 @@ where\n             // Unions and are always treated as a series of 64-bit integer chunks\n         }\n         abi::FieldsShape::Arbitrary { .. } => {\n-            // Stuctures with floating point numbers need special care.\n+            // Structures with floating point numbers need special care.\n \n             let mut data = parse_structure(\n                 cx,"}, {"sha": "cc3c31538a46e01f8229777b0016978109f08194", "filename": "compiler/rustc_target/src/spec/i686_unknown_uefi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_uefi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_uefi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_unknown_uefi.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -49,7 +49,7 @@ pub fn target() -> Target {\n     //        setLibcallCallingConv(RTLIB::UREM_I64, CallingConv::X86_StdCall);\n     //        setLibcallCallingConv(RTLIB::MUL_I64, CallingConv::X86_StdCall);\n     //      }\n-    //   The compiler intrisics should be implemented by compiler-builtins.\n+    //   The compiler intrinsics should be implemented by compiler-builtins.\n     //   Unfortunately, compiler-builtins has not provided those intrinsics yet. Such as:\n     //      i386/divdi3.S\n     //      i386/lshrdi3.S\n@@ -64,7 +64,7 @@ pub fn target() -> Target {\n     //   2. Implement Intrinsics.\n     //   We evaluated all options.\n     //   #2 is hard because we need implement the intrinsics (_aulldiv) generated\n-    //   from the other intrinscis (__udivdi3) implementation with the same\n+    //   from the other intrinsics (__udivdi3) implementation with the same\n     //   functionality (udivmod_inner). If we let _aulldiv() call udivmod_inner!(),\n     //   then we are in loop. We may have to find another way to implement udivmod_inner!().\n     //   #1.2 may break the existing usage.\n@@ -73,7 +73,7 @@ pub fn target() -> Target {\n     //   It uses cdecl, EAX/ECX/EDX as volatile register, and EAX/EDX as return value.\n     //   We also checked the LLVM X86TargetLowering, the differences between -gnu and -msvc\n     //   is fmodf(f32), longjmp() and TLS. None of them impacts the UEFI code.\n-    // As a result, we choose -gnu for i686 version before those intrisics are implemented in\n+    // As a result, we choose -gnu for i686 version before those intrinsics are implemented in\n     // compiler-builtins. After compiler-builtins implements all required intrinsics, we may\n     // remove -gnu and use the default one.\n     Target {"}, {"sha": "61e234251ec31b717ebc67127b714c133cde7ad6", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -1147,7 +1147,7 @@ pub struct TargetOptions {\n     /// Linker arguments used in addition to `late_link_args` if at least one\n     /// Rust dependency is dynamically linked.\n     pub late_link_args_dynamic: LinkArgs,\n-    /// Linker arguments used in addition to `late_link_args` if aall Rust\n+    /// Linker arguments used in addition to `late_link_args` if all Rust\n     /// dependencies are statically linked.\n     pub late_link_args_static: LinkArgs,\n     /// Linker arguments that are unconditionally passed *after* any\n@@ -1255,7 +1255,7 @@ pub struct TargetOptions {\n     /// handling COFF object files with more than 2<sup>15</sup> sections. Since each weak\n     /// symbol needs its own COMDAT section, weak linkage implies a large\n     /// number sections that easily exceeds the given limit for larger\n-    /// codebases. Consequently we want a way to disallow weak linkage on some\n+    /// codebase. Consequently we want a way to disallow weak linkage on some\n     /// platforms.\n     pub allows_weak_linkage: bool,\n     /// Whether the linker support rpaths or not. Defaults to false."}, {"sha": "e1a23b213f0f8a9fd609a4c6b3220b5ed8bd93b4", "filename": "compiler/rustc_target/src/spec/wasm_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm_base.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -109,7 +109,7 @@ pub fn options() -> TargetOptions {\n         crt_objects_fallback: Some(CrtObjectsFallback::Wasm),\n \n         // This has no effect in LLVM 8 or prior, but in LLVM 9 and later when\n-        // PIC code is implemented this has quite a drastric effect if it stays\n+        // PIC code is implemented this has quite a drastic effect if it stays\n         // at the default, `pic`. In an effort to keep wasm binaries as minimal\n         // as possible we're defaulting to `static` for now, but the hope is\n         // that eventually we can ship a `pic`-compatible standard library which"}, {"sha": "4b949ff8b95de3710ffd4fcd18fdf40d68f7122f", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n         match *r {\n             // Ignore bound regions and `'static` regions that appear in the\n             // type, we only need to remap regions that reference lifetimes\n-            // from the function declaraion.\n+            // from the function declaration.\n             // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n             ty::ReLateBound(..) | ty::ReStatic => return r,\n "}, {"sha": "249205f8b12b4a26f9322528b0e591e1513712e4", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -46,8 +46,8 @@ pub fn codegen_fulfill_obligation<'tcx>(\n             Ok(Some(selection)) => selection,\n             Ok(None) => {\n                 // Ambiguity can happen when monomorphizing during trans\n-                // expands to some humongo type that never occurred\n-                // statically -- this humongo type can then overflow,\n+                // expands to some humongous type that never occurred\n+                // statically -- this humongous type can then overflow,\n                 // leading to an ambiguous result. So report this as an\n                 // overflow bug, since I believe this is the only case\n                 // where ambiguity can result."}, {"sha": "40c3f4047ae6efc1732354fa2bb795b13e12fc61", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -114,7 +114,7 @@ where\n     }\n \n     // In the case where we detect an error, run the check again, but\n-    // this time tracking intercrate ambuiguity causes for better\n+    // this time tracking intercrate ambiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n     tcx.infer_ctxt().enter(|infcx| {\n         let selcx = &mut SelectionContext::intercrate(&infcx);\n@@ -762,7 +762,7 @@ fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n         ty::Foreign(did) => def_id_is_local(did, in_crate),\n         ty::Opaque(..) => {\n             // This merits some explanation.\n-            // Normally, opaque types are not involed when performing\n+            // Normally, opaque types are not involved when performing\n             // coherence checking, since it is illegal to directly\n             // implement a trait on an opaque type. However, we might\n             // end up looking at an opaque type during coherence checking"}, {"sha": "2b9cc75f1b7531e840e351cdac73af183e31e00f", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -408,7 +408,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n     }\n \n     /// Builds the abstract const by walking the thir and bailing out when\n-    /// encountering an unspported operation.\n+    /// encountering an unsupported operation.\n     fn build(mut self) -> Result<&'tcx [Node<'tcx>], ErrorGuaranteed> {\n         debug!(\"Abstractconstbuilder::build: body={:?}\", &*self.body);\n         self.recurse_build(self.body_id)?;\n@@ -701,7 +701,7 @@ struct ConstUnifyCtxt<'tcx> {\n \n impl<'tcx> ConstUnifyCtxt<'tcx> {\n     // Substitutes generics repeatedly to allow AbstractConsts to unify where a\n-    // ConstKind::Unevalated could be turned into an AbstractConst that would unify e.g.\n+    // ConstKind::Unevaluated could be turned into an AbstractConst that would unify e.g.\n     // Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n     #[inline]\n     #[instrument(skip(self), level = \"debug\")]"}, {"sha": "505d78d800a3a388a5db1e528a2e16e13ecc008d", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -230,7 +230,7 @@ fn suggest_restriction<'tcx>(\n     {\n         // We know we have an `impl Trait` that doesn't satisfy a required projection.\n \n-        // Find all of the ocurrences of `impl Trait` for `Trait` in the function arguments'\n+        // Find all of the occurrences of `impl Trait` for `Trait` in the function arguments'\n         // types. There should be at least one, but there might be *more* than one. In that\n         // case we could just ignore it and try to identify which one needs the restriction,\n         // but instead we choose to suggest replacing all instances of `impl Trait` with `T`"}, {"sha": "c004848c6c86f1ac913e25b9ea2ce7278dcaa381", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -61,7 +61,7 @@ pub struct FulfillmentContext<'tcx> {\n     // Should this fulfillment context register type-lives-for-region\n     // obligations on its parent infcx? In some cases, region\n     // obligations are either already known to hold (normalization) or\n-    // hopefully verifed elsewhere (type-impls-bound), and therefore\n+    // hopefully verified elsewhere (type-impls-bound), and therefore\n     // should not be checked.\n     //\n     // Note that if we are normalizing a type that we already"}, {"sha": "8240f5c542a617fb1f325679d01140de108e746d", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -539,7 +539,7 @@ fn prepare_vtable_segments<'tcx, T>(\n     // the main traversal loop:\n     // basically we want to cut the inheritance directed graph into a few non-overlapping slices of nodes\n     // that each node is emitted after all its descendents have been emitted.\n-    // so we convert the directed graph into a tree by skipping all previously visted nodes using a visited set.\n+    // so we convert the directed graph into a tree by skipping all previously visited nodes using a visited set.\n     // this is done on the fly.\n     // Each loop run emits a slice - it starts by find a \"childless\" unvisited node, backtracking upwards, and it\n     // stops after it finds a node that has a next-sibling node."}, {"sha": "6bba6b19b90ae8e6173478e07bd2c7832d992427", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -1566,7 +1566,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // fn bar<T:SomeTrait<Foo=usize>>(...) { ... }\n                 // ```\n                 //\n-                // Doesn't the `T : Sometrait<Foo=usize>` predicate help\n+                // Doesn't the `T : SomeTrait<Foo=usize>` predicate help\n                 // resolve `T::Foo`? And of course it does, but in fact\n                 // that single predicate is desugared into two predicates\n                 // in the compiler: a trait predicate (`T : SomeTrait`) and a\n@@ -1989,7 +1989,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n // Get obligations corresponding to the predicates from the where-clause of the\n // associated type itself.\n // Note: `feature(generic_associated_types)` is required to write such\n-// predicates, even for non-generic associcated types.\n+// predicates, even for non-generic associated types.\n fn assoc_ty_own_obligations<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,"}, {"sha": "25cc6e9f9f2f178d127653fc104c3133a9b61a0b", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -58,7 +58,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n             return InferOk { value: kinds, obligations };\n         }\n \n-        // Errors and ambiuity in dropck occur in two cases:\n+        // Errors and ambiguity in dropck occur in two cases:\n         // - unresolved inference variables at the end of typeck\n         // - non well-formed types where projections cannot be resolved\n         // Either of these should have created an error before."}, {"sha": "56bdeafeecae4d1d875d769a855c9d9a8797d2cc", "filename": "compiler/rustc_trait_selection/src/traits/relationships.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -23,7 +23,7 @@ pub(crate) fn update<'tcx, T>(\n             ..tpred.trait_ref\n         };\n \n-        // Then contstruct a new obligation with Self = () added\n+        // Then construct a new obligation with Self = () added\n         // to the ParamEnv, and see if it holds.\n         let o = rustc_infer::traits::Obligation::new(\n             ObligationCause::dummy(),"}, {"sha": "1271b679d5cec0577f9608ead0ceef12403014b6", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -562,7 +562,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 {\n                                     // If the result is something that we can cache, then mark this\n                                     // entry as 'complete'. This will allow us to skip evaluating the\n-                                    // suboligations at all the next time we evaluate the projection\n+                                    // subobligations at all the next time we evaluate the projection\n                                     // predicate.\n                                     self.infcx\n                                         .inner\n@@ -751,7 +751,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // provisional caches entries and inserting them into the evaluation cache\n                     //\n                     // This ensures that when a query reads this entry from the evaluation cache,\n-                    // it will end up (transitively) dependening on all of the incr-comp dependencies\n+                    // it will end up (transitively) depending on all of the incr-comp dependencies\n                     // created during the evaluation of this trait. For example, evaluating a trait\n                     // will usually require us to invoke `type_of(field_def_id)` to determine the\n                     // constituent types, and we want any queries reading from this evaluation\n@@ -1475,7 +1475,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// `No` if it does not. Return `Ambiguous` in the case that the projection type is a GAT,\n     /// and applying this env_predicate constrains any of the obligation's GAT substitutions.\n     ///\n-    /// This behavior is a somewhat of a hack to prevent overconstraining inference variables\n+    /// This behavior is a somewhat of a hack to prevent over-constraining inference variables\n     /// in cases like #91762.\n     pub(super) fn match_projection_projections(\n         &mut self,\n@@ -1729,7 +1729,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             // marker trait impls.\n                             //\n                             // Without this restriction, we could end up accidentally\n-                            // constrainting inference variables based on an arbitrarily\n+                            // constraining inference variables based on an arbitrarily\n                             // chosen trait impl.\n                             //\n                             // Imagine we have the following code:\n@@ -1758,7 +1758,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             // some other means (e.g. type-checking of a function). We will\n                             // then be in a position to drop marker trait candidates\n                             // without constraining inference variables (since there are\n-                            // none left to constrin)\n+                            // none left to constrain)\n                             // 2) Be left with some unconstrained inference variables. We\n                             // will then correctly report an inference error, since the\n                             // existence of multiple marker trait impls tells us nothing\n@@ -2518,7 +2518,7 @@ struct ProvisionalEvaluationCache<'tcx> {\n     /// - `A B C` and we add a cache for the result of C (DFN 2)\n     /// - Then we have a stack `A B D` where `D` has DFN 3\n     /// - We try to solve D by evaluating E: `A B D E` (DFN 4)\n-    /// - `E` generates various cache entries which have cyclic dependices on `B`\n+    /// - `E` generates various cache entries which have cyclic dependencies on `B`\n     ///   - `A B D E F` and so forth\n     ///   - the DFN of `F` for example would be 5\n     /// - then we determine that `E` is in error -- we will then clear"}, {"sha": "1a10b07cc2706fa28038dc04960ebfab847c212c", "filename": "compiler/rustc_typeck/src/astconv/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -345,7 +345,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             if potential_assoc_types.len() == assoc_items.len() {\n                 // Only suggest when the amount of missing associated types equals the number of\n                 // extra type arguments present, as that gives us a relatively high confidence\n-                // that the user forgot to give the associtated type's name. The canonical\n+                // that the user forgot to give the associated type's name. The canonical\n                 // example would be trying to use `Iterator<isize>` instead of\n                 // `Iterator<Item = isize>`.\n                 for (potential, item) in iter::zip(&potential_assoc_types, assoc_items) {"}, {"sha": "46e8d3f71d0bbe536e2e9614e1015b6eec34b225", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -290,7 +290,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// Given the type/lifetime/const arguments provided to some path (along with\n     /// an implicit `Self`, if this is a trait reference), returns the complete\n     /// set of substitutions. This may involve applying defaulted type parameters.\n-    /// Constraints on associated typess are created from `create_assoc_bindings_for_generic_args`.\n+    /// Constraints on associated types are created from `create_assoc_bindings_for_generic_args`.\n     ///\n     /// Example:\n     ///\n@@ -1435,7 +1435,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         // If the projection output contains `Self`, force the user to\n                         // elaborate it explicitly to avoid a lot of complexity.\n                         //\n-                        // The \"classicaly useful\" case is the following:\n+                        // The \"classically useful\" case is the following:\n                         // ```\n                         //     trait MyTrait: FnMut() -> <Self as MyTrait>::MyOutput {\n                         //         type MyOutput;\n@@ -1768,7 +1768,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     // Will fail except for `T::A` and `Self::A`; i.e., if `qself_ty`/`qself_def` are not a type\n     // parameter or `Self`.\n     // NOTE: When this function starts resolving `Trait::AssocTy` successfully\n-    // it should also start reportint the `BARE_TRAIT_OBJECTS` lint.\n+    // it should also start reporting the `BARE_TRAIT_OBJECTS` lint.\n     pub fn associated_path_to_ty(\n         &self,\n         hir_ref_id: hir::HirId,"}, {"sha": "320be9b44d4410df41d770523ff6364fae58e2e9", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -721,7 +721,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return None;\n         }\n \n-        // The `Future` trait has only one associted item, `Output`,\n+        // The `Future` trait has only one associated item, `Output`,\n         // so check that this is what we see.\n         let output_assoc_item = self.tcx.associated_item_def_ids(future_trait)[0];\n         if output_assoc_item != predicate.projection_ty.item_def_id {"}, {"sha": "34fc177de6de0d31841b3df893f49649ba7e7e5b", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -18,7 +18,7 @@\n //!\n //! ## Subtle note\n //!\n-//! When infering the generic arguments of functions, the argument\n+//! When inferring the generic arguments of functions, the argument\n //! order is relevant, which can lead to the following edge case:\n //!\n //! ```rust"}, {"sha": "82641a489f66a949267e103c1a53319aef73cde9", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -590,7 +590,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let opt_coerce_to = {\n                     // We should release `enclosing_breakables` before the `check_expr_with_hint`\n                     // below, so can't move this block of code to the enclosing scope and share\n-                    // `ctxt` with the second `encloding_breakables` borrow below.\n+                    // `ctxt` with the second `enclosing_breakables` borrow below.\n                     let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n                     match enclosing_breakables.opt_find_breakable(target_id) {\n                         Some(ctxt) => ctxt.coerce.as_ref().map(|coerce| coerce.expected_ty()),\n@@ -793,7 +793,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx.types.never\n     }\n \n-    /// `explicit_return` is `true` if we're checkng an explicit `return expr`,\n+    /// `explicit_return` is `true` if we're checking an explicit `return expr`,\n     /// and `false` if we're checking a trailing expression.\n     pub(super) fn check_return_expr(\n         &self,\n@@ -1126,7 +1126,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let method = match self.lookup_method(rcvr_t, segment, span, expr, rcvr, args) {\n             Ok(method) => {\n                 // We could add a \"consider `foo::<params>`\" suggestion here, but I wasn't able to\n-                // trigger this codepath causing `structuraly_resolved_type` to emit an error.\n+                // trigger this codepath causing `structurally_resolved_type` to emit an error.\n \n                 self.write_method_call(expr.hir_id, method);\n                 Ok(method)"}, {"sha": "4d3fdea1fc373959e96c71496fd8f0129ff3689c", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -158,7 +158,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 _ => {\n                     // Otherwise, there's a mismatch, so clear out what we're expecting, and set\n-                    // our input typs to err_args so we don't blow up the error messages\n+                    // our input types to err_args so we don't blow up the error messages\n                     struct_span_err!(\n                         tcx.sess,\n                         call_span,"}, {"sha": "800232d9549b8e46eb4a1ed05eb5d5ed236e5484", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -206,7 +206,7 @@ struct DropRangesBuilder {\n     /// NodeInfo struct for more details, but this information includes things\n     /// such as the set of control-flow successors, which variables are dropped\n     /// or reinitialized, and whether each variable has been inferred to be\n-    /// known-dropped or potentially reintiialized at each point.\n+    /// known-dropped or potentially reinitialized at each point.\n     nodes: IndexVec<PostOrderId, NodeInfo>,\n     /// We refer to values whose drop state we are tracking by the HirId of\n     /// where they are defined. Within a NodeInfo, however, we store the"}, {"sha": "75a8ad8a159b52c658f829c03ab4030a11316e10", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -50,7 +50,7 @@ pub(super) fn build_control_flow_graph<'tcx>(\n ///\n /// 1. Moving a variable `a` counts as a move of the whole variable.\n /// 2. Moving a partial path like `a.b.c` is ignored.\n-/// 3. Reinitializing through a field (e.g. `a.b.c = 5`) counds as a reinitialization of all of\n+/// 3. Reinitializing through a field (e.g. `a.b.c = 5`) counts as a reinitialization of all of\n ///    `a`.\n ///\n /// Some examples:"}, {"sha": "e3782fe5911df50cd2f383c1bf4d94ef41d16388", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -713,7 +713,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // FIXME Postponing the normalization of the return type likely only hides a deeper bug,\n             // which might be caused by the `param_env` itself. The clauses of the `param_env`\n             // maybe shouldn't include `Param`s, but rather fresh variables or be canonicalized,\n-            // see isssue #89650\n+            // see issue #89650\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n             let selcx = &mut traits::SelectionContext::new(self.fcx);\n             let traits::Normalized { value: xform_self_ty, obligations } =\n@@ -1658,7 +1658,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     /// Similarly to `probe_for_return_type`, this method attempts to find the best matching\n-    /// candidate method where the method name may have been misspelt. Similarly to other\n+    /// candidate method where the method name may have been misspelled. Similarly to other\n     /// Levenshtein based suggestions, we provide at most one such suggestion.\n     fn probe_for_lev_candidate(&mut self) -> Result<Option<ty::AssocItem>, MethodError<'tcx>> {\n         debug!(\"probing for method names similar to {:?}\", self.method_name);"}, {"sha": "b05f0e4d3c38934204b367851bca6c12282a65a1", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -270,7 +270,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         (None, true) => \"variant\",\n                     }\n                 };\n-                // FIXME(eddyb) this intendation is probably unnecessary.\n+                // FIXME(eddyb) this indentation is probably unnecessary.\n                 let mut err = {\n                     // Suggest clamping down the type if the method that is being attempted to\n                     // be used exists at all, and the type is an ambiguous numeric type\n@@ -279,7 +279,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .into_iter()\n                         .filter_map(|info| self.associated_value(info.def_id, item_name));\n                     // There are methods that are defined on the primitive types and won't be\n-                    // found when exploring `all_traits`, but we also need them to be acurate on\n+                    // found when exploring `all_traits`, but we also need them to be accurate on\n                     // our suggestions (#47759).\n                     let found_assoc = |ty: Ty<'tcx>| {\n                         simplify_type(tcx, ty, TreatParams::AsPlaceholders)"}, {"sha": "bf0bf2ed59b5b616a2b9f3d08086547b26643c0c", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -665,7 +665,7 @@ fn missing_items_must_implement_one_of_err(\n     err.emit();\n }\n \n-/// Resugar `ty::GenericPredicates` in a way suitable to be used in structured suggestions.\n+/// Re-sugar `ty::GenericPredicates` in a way suitable to be used in structured suggestions.\n fn bounds_from_generic_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicates: ty::GenericPredicates<'tcx>,"}, {"sha": "811833bca803143c606d07afed124be1d015d00a", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -852,7 +852,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n }\n \n // Binary operator categories. These categories summarize the behavior\n-// with respect to the builtin operationrs supported.\n+// with respect to the builtin operations supported.\n enum BinOpCategory {\n     /// &&, || -- cannot be overridden\n     Shortcircuit,"}, {"sha": "464a2cd9524839df7175bf37b1d6e492238b1f26", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -308,7 +308,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // In the `ValueNS`, we have `SelfCtor(..) | Ctor(_, Const), _)` remaining which\n                 // could successfully compile. The former being `Self` requires a unit struct.\n                 // In either case, and unlike constants, the pattern itself cannot be\n-                // a reference type wherefore peeling doesn't give up any expressivity.\n+                // a reference type wherefore peeling doesn't give up any expressiveness.\n                 _ => AdjustMode::Peel,\n             },\n             // When encountering a `& mut? pat` pattern, reset to \"by value\".\n@@ -460,7 +460,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // The early check here is not for correctness, but rather better\n                 // diagnostics (e.g. when `&str` is being matched, `expected` will\n                 // be peeled to `str` while ty here is still `&str`, if we don't\n-                // err ealy here, a rather confusing unification error will be\n+                // err early here, a rather confusing unification error will be\n                 // emitted instead).\n                 let fail =\n                     !(ty.is_numeric() || ty.is_char() || ty.is_ty_var() || ty.references_error());\n@@ -1343,7 +1343,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match (inexistent_fields_err, unmentioned_err) {\n             (Some(mut i), Some(mut u)) => {\n                 if let Some(mut e) = self.error_tuple_variant_as_struct_pat(pat, fields, variant) {\n-                    // We don't want to show the inexistent fields error when this was\n+                    // We don't want to show the nonexistent fields error when this was\n                     // `Foo { a, b }` when it should have been `Foo(a, b)`.\n                     i.delay_as_bug();\n                     u.delay_as_bug();"}, {"sha": "0b343a5f905c467bbef1c2366bc097a307aac262", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -304,7 +304,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         // Build a tuple (U0..Un) of the final upvar types U0..Un\n-        // and unify the upvar tupe type in the closure with it:\n+        // and unify the upvar tuple type in the closure with it:\n         let final_tupled_upvars_type = self.tcx.mk_tup(final_upvar_tys.iter());\n         self.demand_suptype(span, substs.tupled_upvars_ty(), final_tupled_upvars_type);\n \n@@ -545,7 +545,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // capture information.\n             //\n             // - if descendant is found, remove it from the list, and update the current place's\n-            // capture information to account for the descendants's capture kind.\n+            // capture information to account for the descendant's capture kind.\n             //\n             // We can never be in a case where the list contains both an ancestor and a descendant\n             // Also there can only be ancestor but in case of descendants there might be\n@@ -661,7 +661,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Now that we have the minimized list of captures, sort the captures by field id.\n         // This causes the closure to capture the upvars in the same order as the fields are\n         // declared which is also the drop order. Thus, in situations where we capture all the\n-        // fields of some type, the obserable drop order will remain the same as it previously\n+        // fields of some type, the observable drop order will remain the same as it previously\n         // was even though we're dropping each capture individually.\n         // See https://github.com/rust-lang/project-rfc-2229/issues/42 and\n         // `src/test/ui/closures/2229_closure_analysis/preserve_field_drop_order.rs`.\n@@ -1396,7 +1396,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Observations:\n             // - `captured_by_move_projs` is not empty. Therefore we can call\n             //   `captured_by_move_projs.first().unwrap()` safely.\n-            // - All entries in `captured_by_move_projs` have atleast one projection.\n+            // - All entries in `captured_by_move_projs` have at least one projection.\n             //   Therefore we can call `captured_by_move_projs.first().unwrap().first().unwrap()` safely.\n \n             // We don't capture derefs in case of move captures, which would have be applied to\n@@ -1612,7 +1612,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // We don't capture derefs of raw ptrs\n                 ty::RawPtr(_) => unreachable!(),\n \n-                // Derefencing a mut-ref allows us to mut the Place if we don't deref\n+                // Dereferencing a mut-ref allows us to mut the Place if we don't deref\n                 // an immut-ref after on top of this.\n                 ty::Ref(.., hir::Mutability::Mut) => is_mutbl = hir::Mutability::Mut,\n \n@@ -1873,7 +1873,7 @@ fn restrict_precision_for_unsafe<'tcx>(\n         }\n \n         if proj.ty.is_union() {\n-            // Don't capture preicse fields of a union.\n+            // Don't capture precise fields of a union.\n             truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, i + 1);\n             break;\n         }\n@@ -1885,7 +1885,7 @@ fn restrict_precision_for_unsafe<'tcx>(\n /// Truncate projections so that following rules are obeyed by the captured `place`:\n /// - No Index projections are captured, since arrays are captured completely.\n /// - No unsafe block is required to capture `place`\n-/// Returns the truncated place and updated cature mode.\n+/// Returns the truncated place and updated capture mode.\n fn restrict_capture_precision<'tcx>(\n     place: Place<'tcx>,\n     curr_mode: ty::UpvarCapture,\n@@ -2059,7 +2059,7 @@ fn migration_suggestion_for_2229(\n /// It is the caller's duty to figure out which path_expr_id to use.\n ///\n /// If both the CaptureKind and Expression are considered to be equivalent,\n-/// then `CaptureInfo` A is preferred. This can be useful in cases where we want to priortize\n+/// then `CaptureInfo` A is preferred. This can be useful in cases where we want to prioritize\n /// expressions reported back to the user as part of diagnostics based on which appears earlier\n /// in the closure. This can be achieved simply by calling\n /// `determine_capture_info(existing_info, current_info)`. This works out because the"}, {"sha": "5b3aee7428829ea6259156a485f10c87372d3fe8", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -510,7 +510,7 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n \n     for (region_a, region_a_idx) in &regions {\n         // Ignore `'static` lifetimes for the purpose of this lint: it's\n-        // because we know it outlives everything and so doesn't give meaninful\n+        // because we know it outlives everything and so doesn't give meaningful\n         // clues\n         if let ty::ReStatic = **region_a {\n             continue;\n@@ -677,9 +677,9 @@ fn resolve_regions_with_wf_tys<'tcx>(\n struct GATSubstCollector<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     gat: DefId,\n-    // Which region appears and which parameter index its subsituted for\n+    // Which region appears and which parameter index its substituted for\n     regions: FxHashSet<(ty::Region<'tcx>, usize)>,\n-    // Which params appears and which parameter index its subsituted for\n+    // Which params appears and which parameter index its substituted for\n     types: FxHashSet<(Ty<'tcx>, usize)>,\n }\n "}, {"sha": "9d5c8d5ec3b2101370642454a64509555ecb1611", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -209,7 +209,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             if let Some(ty::Ref(_, base_ty, _)) = base_ty {\n                 let index_ty = typeck_results.expr_ty_adjusted_opt(index).unwrap_or_else(|| {\n                     // When encountering `return [0][0]` outside of a `fn` body we would attempt\n-                    // to access an unexistend index. We assume that more relevant errors will\n+                    // to access an nonexistent index. We assume that more relevant errors will\n                     // already have been emitted, so we only gate on this with an ICE if no\n                     // error has been emitted. (#64638)\n                     self.fcx.tcx.ty_error_with_message("}, {"sha": "93b74027ba3176597a9284bcb49b2c3a52e7c80c", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -2928,7 +2928,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                     // The `#[target_feature]` attribute is allowed on\n                     // WebAssembly targets on all functions, including safe\n                     // ones. Other targets require that `#[target_feature]` is\n-                    // only applied to unsafe funtions (pending the\n+                    // only applied to unsafe functions (pending the\n                     // `target_feature_11` feature) because on most targets\n                     // execution of instructions that are not supported is\n                     // considered undefined behavior. For WebAssembly which is a"}, {"sha": "cb32e88588af2578e120f324bda8e199af18dc94", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -43,7 +43,7 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n         // In the above code we would call this query with the def_id of 3 and\n         // the parent_node we match on would be the hir node for Self::Assoc<3>\n         //\n-        // `Self::Assoc<3>` cant be resolved without typchecking here as we\n+        // `Self::Assoc<3>` cant be resolved without typechecking here as we\n         // didnt write <Self as Foo>::Assoc<3>. If we did then another match\n         // arm would handle this.\n         //"}, {"sha": "b4b438a561a21266c3308786de770270ac9f85a6", "filename": "compiler/rustc_typeck/src/hir_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -173,7 +173,7 @@ struct EraseAllBoundRegions<'tcx> {\n // `ItemCtxt::to_ty`. To make things simpler, we just erase all\n // of them, regardless of depth. At worse, this will give\n // us an inaccurate span for an error message, but cannot\n-// lead to unsoundess (we call `delay_span_bug` at the start\n+// lead to unsoundness (we call `delay_span_bug` at the start\n // of `diagnostic_hir_wf_check`).\n impl<'tcx> TypeFolder<'tcx> for EraseAllBoundRegions<'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {"}, {"sha": "8b376e26dee9759417939c737c77737a5468a368", "filename": "compiler/rustc_typeck/src/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -187,7 +187,7 @@ fn enforce_impl_params_are_constrained(\n \n     // (*) This is a horrible concession to reality. I think it'd be\n     // better to just ban unconstrained lifetimes outright, but in\n-    // practice people do non-hygenic macros like:\n+    // practice people do non-hygienic macros like:\n     //\n     // ```\n     // macro_rules! __impl_slice_eq1 {"}, {"sha": "a117ed68ff7d019d829cc1b71f3a00ef646ffe6a", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160f8f843e1dbd43cf341cc8aa5d917d22c98b9/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=5160f8f843e1dbd43cf341cc8aa5d917d22c98b9", "patch": "@@ -484,7 +484,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         let msg = format!(\"add missing {} argument{}\", self.kind(), pluralize!(num_missing_args));\n \n         // we first try to get lifetime name suggestions from scope or elision information. If none is\n-        // available we use the parameter defintions\n+        // available we use the parameter definitions\n         let suggested_args = if let Some(hir_id) = self.path_segment.hir_id {\n             if let Some(lifetimes_in_scope) = self.tcx.lifetime_scope(hir_id) {\n                 match lifetimes_in_scope {\n@@ -587,7 +587,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n                     (gen_args_span.shrink_to_lo(), true)\n                 } else {\n                     let arg_span = self.gen_args.args[sugg_offset - 1].span();\n-                    // If we came here then inferred lifetimes's spans can only point\n+                    // If we came here then inferred lifetime's spans can only point\n                     // to either the opening bracket or to the space right after.\n                     // Both of these spans have an `hi` lower than or equal to the span\n                     // of the generics excluding the brackets."}]}