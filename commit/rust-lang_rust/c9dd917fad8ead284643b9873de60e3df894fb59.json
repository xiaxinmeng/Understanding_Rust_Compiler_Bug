{"sha": "c9dd917fad8ead284643b9873de60e3df894fb59", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ZGQ5MTdmYWQ4ZWFkMjg0NjQzYjk4NzNkZTYwZTNkZjg5NGZiNTk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-02-26T18:02:36Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-02-26T18:02:36Z"}, "message": "doc: Remove references to mut fields. rs=demuting", "tree": {"sha": "6722e7ca5ce29d2abf19869475220d7ee1b282b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6722e7ca5ce29d2abf19869475220d7ee1b282b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9dd917fad8ead284643b9873de60e3df894fb59", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9dd917fad8ead284643b9873de60e3df894fb59", "html_url": "https://github.com/rust-lang/rust/commit/c9dd917fad8ead284643b9873de60e3df894fb59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9dd917fad8ead284643b9873de60e3df894fb59/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a9d4aa52e70eba52dad0719ed6e1eca95f1a2cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a9d4aa52e70eba52dad0719ed6e1eca95f1a2cc", "html_url": "https://github.com/rust-lang/rust/commit/4a9d4aa52e70eba52dad0719ed6e1eca95f1a2cc"}], "stats": {"total": 206, "additions": 25, "deletions": 181}, "files": [{"sha": "9a3d087f3d7234ab8dcb2a19f13f43a9d47ce7b0", "filename": "doc/rust.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd917fad8ead284643b9873de60e3df894fb59/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd917fad8ead284643b9873de60e3df894fb59/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=c9dd917fad8ead284643b9873de60e3df894fb59", "patch": "@@ -1610,11 +1610,11 @@ The following are examples of structure expressions:\n ~~~~\n # struct Point { x: float, y: float }\n # struct TuplePoint(float, float);\n-# mod game { pub struct User { name: &str, age: uint, mut score: uint } }\n+# mod game { pub struct User { name: &str, age: uint, score: uint } }\n # use game;\n Point {x: 10f, y: 20f};\n TuplePoint(10f, 20f);\n-let u = game::User {name: \"Joe\", age: 35u, mut score: 100_000};\n+let u = game::User {name: \"Joe\", age: 35u, score: 100_000};\n ~~~~\n \n A structure expression forms a new value of the named structure type."}, {"sha": "0c1624706bfeb4df708bba26e4a0e94ce5423f8c", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 4, "deletions": 157, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd917fad8ead284643b9873de60e3df894fb59/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd917fad8ead284643b9873de60e3df894fb59/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=c9dd917fad8ead284643b9873de60e3df894fb59", "patch": "@@ -348,12 +348,12 @@ mutations:\n ~~~ {.xfail-test}\n fn example3() -> int {\n     struct R { g: int }\n-    struct S { mut f: ~R }\n+    struct S { f: ~R }\n \n-    let mut x = ~S {mut f: ~R {g: 3}};\n+    let mut x = ~S {f: ~R {g: 3}};\n     let y = &x.f.g;\n-    x = ~S {mut f: ~R {g: 4}}; // Error reported here.\n-    x.f = ~R {g: 5};           // Error reported here.\n+    x = ~S {f: ~R {g: 4}};  // Error reported here.\n+    x.f = ~R {g: 5};        // Error reported here.\n     *y\n }\n ~~~\n@@ -362,91 +362,6 @@ In this case, two errors are reported, one when the variable `x` is\n modified and another when `x.f` is modified. Either modification would\n invalidate the pointer `y`.\n \n-Things get trickier when the unique box is not uniquely owned by the\n-stack frame, or when there is no way for the compiler to determine the\n-box's owner. Consider a program like this:\n-\n-~~~ {.xfail-test}\n-struct R { g: int }\n-struct S { mut f: ~R }\n-fn example5a(x: @S, callback: @fn()) -> int {\n-    let y = &x.f.g;   // Error reported here.\n-    ...\n-    callback();\n-    ...\n-#   return 0;\n-}\n-~~~\n-\n-Here the heap looks something like:\n-\n-~~~ {.notrust}\n-     Stack            Managed Heap       Exchange Heap\n-\n-  x +------+        +-------------+       +------+\n-    | @... | ---->  | mut f: ~... | --+-> | g: 3 |\n-  y +------+        +-------------+   |   +------+\n-    | &int | -------------------------+\n-    +------+\n-~~~\n-\n-In this case, the owning reference to the value being borrowed is\n-`x.f`. Moreover, `x.f` is both mutable and *aliasable*. Aliasable\n-means that there may be other pointers to that same managed box, so\n-even if the compiler were to prove an absence of mutations to `x.f`,\n-code could mutate `x.f` indirectly by changing an alias of\n-`x`. Therefore, to be safe, the compiler only accepts *pure* actions\n-during the lifetime of `y`. We define what \"pure\" means in the section\n-on [purity](#purity).\n-\n-Besides ensuring purity, the only way to borrow the interior of a\n-unique found in aliasable memory is to ensure that the borrowed field\n-itself is also unique, as in the following example:\n-\n-~~~\n-struct R { g: int }\n-struct S { f: ~R }\n-fn example5b(x: @S) -> int {\n-    let y = &x.f.g;\n-    ...\n-# return 0;\n-}\n-~~~\n-\n-Here, the field `f` is not declared as mutable. But that is enough for\n-the compiler to know that, even if aliases to `x` exist, the field `f`\n-cannot be changed and hence the unique box `g` will remain valid.\n-\n-If you do have a unique box in a mutable field, and you wish to borrow\n-it, one option is to use the swap operator to move that unique box\n-onto your stack:\n-\n-~~~\n-struct R { g: int }\n-struct S { mut f: ~R }\n-fn example5c(x: @S) -> int {\n-    let mut v = ~R {g: 0};\n-    v <-> x.f;         // Swap v and x.f\n-    { // Block constrains the scope of `y`:\n-        let y = &v.g;\n-        ...\n-    }\n-    x.f = v;          // Replace x.f\n-    ...\n-# return 0;\n-}\n-~~~\n-\n-Of course, this has the side effect of modifying your managed box for\n-the duration of the borrow, so it only works when you know that you\n-won't be accessing that same box for the duration of the loan. Also,\n-it is sometimes necessary to introduce additional blocks to constrain\n-the scope of the loan.  In this example, the borrowed pointer `y`\n-would still be in scope when you moved the value `v` back into `x.f`,\n-and hence moving `v` would be considered illegal.  You cannot move\n-values if they are the targets of valid outstanding loans. Introducing\n-the block restricts the scope of `y`, making the move legal.\n-\n # Borrowing and enums\n \n The previous example showed that the type system forbids any borrowing\n@@ -558,11 +473,6 @@ permit `ref` bindings into data owned by the stack frame even if the\n data are mutable, but otherwise it requires that the data reside in\n immutable memory.\n \n-> ***Note:*** Right now, pattern bindings not explicitly annotated\n-> with `ref` or `copy` use a special mode of \"implicit by reference\".\n-> This is changing as soon as we finish updating all the existing code\n-> in the compiler that relies on the current settings.\n-\n # Returning borrowed pointers\n \n So far, all of the examples we've looked at use borrowed pointers in a\n@@ -745,69 +655,6 @@ fn select<T>(shape: &Shape, threshold: float,\n \n This is equivalent to the previous definition.\n \n-# Purity\n-\n-As mentioned before, the Rust compiler offers a kind of escape hatch\n-that permits borrowing of any data, as long as the actions that occur\n-during the lifetime of the borrow are pure. Pure actions are those\n-that only modify data owned by the current stack frame. The compiler\n-can therefore permit arbitrary pointers into the heap, secure in the\n-knowledge that no pure action will ever cause them to become\n-invalidated (the compiler must still track data on the stack which is\n-borrowed and enforce those rules normally, of course). A pure function\n-in Rust is referentially transparent: it returns the same results\n-given the same (observably equivalent) inputs. That is because while\n-pure functions are allowed to modify data, they may only modify\n-*stack-local* data, which cannot be observed outside the scope of the\n-function itself. (Using an `unsafe` block invalidates this guarantee.)\n-\n-Let\u2019s revisit a previous example and show how purity can affect\n-typechecking. Here is `example5a()`, which borrows the interior of a\n-unique box found in an aliasable, mutable location, only now we\u2019ve\n-replaced the `...` with some specific code:\n-\n-~~~\n-struct R { g: int }\n-struct S { mut f: ~R }\n-fn example5a(x: @S ...) -> int {\n-    let y = &x.f.g;   // Unsafe\n-    *y + 1        \n-}\n-~~~\n-\n-The new code simply returns an incremented version of `y`. This code\n-clearly doesn't mutate the heap, so the compiler is satisfied.\n-\n-But suppose we wanted to pull the increment code into a helper, like\n-this:\n-\n-~~~\n-fn add_one(x: &int) -> int { *x + 1 }\n-~~~\n-\n-We can now update `example5a()` to use `add_one()`:\n-\n-~~~\n-# struct R { g: int }\n-# struct S { mut f: ~R }\n-# pure fn add_one(x: &int) -> int { *x + 1 }\n-fn example5a(x: @S ...) -> int {\n-    let y = &x.f.g;\n-    add_one(y)        // Error reported here\n-}\n-~~~\n-\n-But now the compiler will report an error again. The reason is that it\n-only considers one function at a time (like most typecheckers), and\n-so it does not know that `add_one()` consists of pure code. We can\n-help the compiler by labeling `add_one()` as pure:\n-\n-~~~\n-pure fn add_one(x: &int) -> int { *x + 1 }\n-~~~\n-\n-With this change, the modified version of `example5a()` will again compile.\n-\n # Conclusion\n \n So there you have it: a (relatively) brief tour of the borrowed pointer"}, {"sha": "b7659376ed65cddbf25bd8cc5dc007e8a456789f", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd917fad8ead284643b9873de60e3df894fb59/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd917fad8ead284643b9873de60e3df894fb59/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=c9dd917fad8ead284643b9873de60e3df894fb59", "patch": "@@ -220,21 +220,21 @@ extern mod std;\n use libc::c_ulonglong;\n \n struct timeval {\n-    mut tv_sec: c_ulonglong,\n-    mut tv_usec: c_ulonglong\n+    tv_sec: c_ulonglong,\n+    tv_usec: c_ulonglong\n }\n \n #[nolink]\n extern mod lib_c {\n-    fn gettimeofday(tv: *timeval, tz: *()) -> i32;\n+    fn gettimeofday(tv: *mut timeval, tz: *()) -> i32;\n }\n fn unix_time_in_microseconds() -> u64 {\n     unsafe {\n-        let x = timeval {\n-            mut tv_sec: 0 as c_ulonglong,\n-            mut tv_usec: 0 as c_ulonglong\n+        let mut x = timeval {\n+            tv_sec: 0 as c_ulonglong,\n+            tv_usec: 0 as c_ulonglong\n         };\n-        lib_c::gettimeofday(ptr::addr_of(&x), ptr::null());\n+        lib_c::gettimeofday(&mut x, ptr::null());\n         return (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n     }\n }"}, {"sha": "909bad9e2f40b2ef570746a718695876ab55fd4b", "filename": "doc/tutorial.md", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c9dd917fad8ead284643b9873de60e3df894fb59/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/c9dd917fad8ead284643b9873de60e3df894fb59/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=c9dd917fad8ead284643b9873de60e3df894fb59", "patch": "@@ -583,19 +583,16 @@ Inherited mutability means that any field of a struct may be mutable, if the\n struct is in a mutable slot (or a field of a struct in a mutable slot, and\n so forth).\n \n-A struct that is not mutable due to inherited mutability may declare some\n-of its fields nevertheless mutable, using the `mut` keyword.\n-\n ~~~~\n struct Stack {\n     content: ~[int],\n-    mut head: uint\n+    head: uint\n }\n ~~~~\n \n-With a value of such a type, you can do `mystack.head += 1`. If `mut` were\n-omitted from the type, such an assignment to a struct without inherited\n-mutability would result in a type error.\n+With a value (say, `mystack`) of such a type in a mutable location, you can do\n+`mystack.head += 1`. But in an immutable location, such an assignment to a\n+struct without inherited mutability would result in a type error.\n \n `match` patterns destructure structs. The basic syntax is\n `Name { fieldname: pattern, ... }`:\n@@ -938,19 +935,19 @@ type that contains managed boxes or other managed types.\n ~~~\n // A linked list node\n struct Node {\n-    mut next: MaybeNode,\n-    mut prev: MaybeNode,\n+    next: MaybeNode,\n+    prev: MaybeNode,\n     payload: int\n }\n \n enum MaybeNode {\n-    SomeNode(@Node),\n+    SomeNode(@mut Node),\n     NoNode\n }\n \n-let node1 = @Node { next: NoNode, prev: NoNode, payload: 1 };\n-let node2 = @Node { next: NoNode, prev: NoNode, payload: 2 };\n-let node3 = @Node { next: NoNode, prev: NoNode, payload: 3 };\n+let node1 = @mut Node { next: NoNode, prev: NoNode, payload: 1 };\n+let node2 = @mut Node { next: NoNode, prev: NoNode, payload: 2 };\n+let node3 = @mut Node { next: NoNode, prev: NoNode, payload: 3 };\n \n // Link the three list nodes together\n node1.next = SomeNode(node2);\n@@ -2300,8 +2297,8 @@ mod farm {\n # impl Human { fn rest(&self) { } }\n # pub fn make_me_a_farm() -> farm::Farm { farm::Farm { chickens: ~[], cows: ~[], farmer: Human(0) } }\n     pub struct Farm {\n-        priv mut chickens: ~[Chicken],\n-        priv mut cows: ~[Cow],\n+        priv chickens: ~[Chicken],\n+        priv cows: ~[Cow],\n         farmer: Human\n     }\n "}]}