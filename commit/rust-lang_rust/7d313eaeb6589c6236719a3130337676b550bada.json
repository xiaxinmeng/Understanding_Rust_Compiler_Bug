{"sha": "7d313eaeb6589c6236719a3130337676b550bada", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMzEzZWFlYjY1ODljNjIzNjcxOWEzMTMwMzM3Njc2YjU1MGJhZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-20T09:30:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-20T09:30:02Z"}, "message": "Auto merge of #51638 - spastorino:diagnostic-suggest-drop-in-reverse, r=nikomatsakis\n\nDiagnostic suggest drop in reverse\n\nCloses #51195", "tree": {"sha": "e69014525bb0097d0a6ab7240e21ecf0f3de7fcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e69014525bb0097d0a6ab7240e21ecf0f3de7fcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d313eaeb6589c6236719a3130337676b550bada", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d313eaeb6589c6236719a3130337676b550bada", "html_url": "https://github.com/rust-lang/rust/commit/7d313eaeb6589c6236719a3130337676b550bada", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d313eaeb6589c6236719a3130337676b550bada/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cca43a7f977963ee497ca091fbdf3cea95abdf47", "url": "https://api.github.com/repos/rust-lang/rust/commits/cca43a7f977963ee497ca091fbdf3cea95abdf47", "html_url": "https://github.com/rust-lang/rust/commit/cca43a7f977963ee497ca091fbdf3cea95abdf47"}, {"sha": "d3defcaf3ba057f3dd9e37bbc4f0be73c7e9fafd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3defcaf3ba057f3dd9e37bbc4f0be73c7e9fafd", "html_url": "https://github.com/rust-lang/rust/commit/d3defcaf3ba057f3dd9e37bbc4f0be73c7e9fafd"}], "stats": {"total": 1238, "additions": 784, "deletions": 454}, "files": [{"sha": "87fb0a6b70ace31e42352020b9097e26520dc754", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 611, "deletions": 350, "changes": 961, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -13,44 +13,44 @@\n //! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/mir.html\n \n use graphviz::IntoCow;\n-use middle::region;\n-use rustc_data_structures::sync::{Lrc};\n-use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n-use rustc_data_structures::control_flow_graph::dominators::{Dominators, dominators};\n-use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccessors};\n-use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n-use rustc_data_structures::small_vec::SmallVec;\n-use rustc_serialize as serialize;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n-use mir::visit::MirVisitable;\n-use mir::interpret::{Value, Scalar, EvalErrorKind};\n-use ty::subst::{Subst, Substs};\n-use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt};\n-use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use util::ppaux;\n-use std::slice;\n use hir::{self, InlineAsm};\n-use std::borrow::{Cow};\n+use middle::region;\n+use mir::interpret::{EvalErrorKind, Scalar, Value};\n+use mir::visit::MirVisitable;\n+use rustc_apfloat::ieee::{Double, Single};\n+use rustc_apfloat::Float;\n+use rustc_data_structures::control_flow_graph::dominators::{dominators, Dominators};\n+use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n+use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccessors};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::small_vec::SmallVec;\n+use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::sync::ReadGuard;\n+use rustc_serialize as serialize;\n+use std::borrow::Cow;\n use std::fmt::{self, Debug, Formatter, Write};\n-use std::{iter, mem, option, u32};\n use std::ops::{Index, IndexMut};\n+use std::slice;\n use std::vec::IntoIter;\n+use std::{iter, mem, option, u32};\n use syntax::ast::{self, Name};\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n-use rustc_apfloat::ieee::{Single, Double};\n-use rustc_apfloat::Float;\n+use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use ty::subst::{Subst, Substs};\n+use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt};\n+use util::ppaux;\n \n pub use mir::interpret::AssertMessage;\n \n mod cache;\n-pub mod tcx;\n-pub mod visit;\n-pub mod traversal;\n pub mod interpret;\n pub mod mono;\n+pub mod tcx;\n+pub mod traversal;\n+pub mod visit;\n \n /// Types for locals\n type LocalDecls<'tcx> = IndexVec<Local, LocalDecl<'tcx>>;\n@@ -129,27 +129,31 @@ pub struct Mir<'tcx> {\n     pub span: Span,\n \n     /// A cache for various calculations\n-    cache: cache::Cache\n+    cache: cache::Cache,\n }\n \n /// where execution begins\n pub const START_BLOCK: BasicBlock = BasicBlock(0);\n \n impl<'tcx> Mir<'tcx> {\n-    pub fn new(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n-               source_scopes: IndexVec<SourceScope, SourceScopeData>,\n-               source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope,\n-                                                                 SourceScopeLocalData>>,\n-               promoted: IndexVec<Promoted, Mir<'tcx>>,\n-               yield_ty: Option<Ty<'tcx>>,\n-               local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n-               arg_count: usize,\n-               upvar_decls: Vec<UpvarDecl>,\n-               span: Span) -> Self\n-    {\n+    pub fn new(\n+        basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+        source_scopes: IndexVec<SourceScope, SourceScopeData>,\n+        source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n+        promoted: IndexVec<Promoted, Mir<'tcx>>,\n+        yield_ty: Option<Ty<'tcx>>,\n+        local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+        arg_count: usize,\n+        upvar_decls: Vec<UpvarDecl>,\n+        span: Span,\n+    ) -> Self {\n         // We need `arg_count` locals, and one for the return place\n-        assert!(local_decls.len() >= arg_count + 1,\n-            \"expected at least {} locals, got {}\", arg_count + 1, local_decls.len());\n+        assert!(\n+            local_decls.len() >= arg_count + 1,\n+            \"expected at least {} locals, got {}\",\n+            arg_count + 1,\n+            local_decls.len()\n+        );\n \n         Mir {\n             basic_blocks,\n@@ -164,7 +168,7 @@ impl<'tcx> Mir<'tcx> {\n             upvar_decls,\n             spread_arg: None,\n             span,\n-            cache: cache::Cache::new()\n+            cache: cache::Cache::new(),\n         }\n     }\n \n@@ -180,7 +184,9 @@ impl<'tcx> Mir<'tcx> {\n     }\n \n     #[inline]\n-    pub fn basic_blocks_and_local_decls_mut(&mut self) -> (\n+    pub fn basic_blocks_and_local_decls_mut(\n+        &mut self,\n+    ) -> (\n         &mut IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n         &mut LocalDecls<'tcx>,\n     ) {\n@@ -207,26 +213,30 @@ impl<'tcx> Mir<'tcx> {\n     pub fn local_kind(&self, local: Local) -> LocalKind {\n         let index = local.0 as usize;\n         if index == 0 {\n-            debug_assert!(self.local_decls[local].mutability == Mutability::Mut,\n-                          \"return place should be mutable\");\n+            debug_assert!(\n+                self.local_decls[local].mutability == Mutability::Mut,\n+                \"return place should be mutable\"\n+            );\n \n             LocalKind::ReturnPointer\n         } else if index < self.arg_count + 1 {\n             LocalKind::Arg\n         } else if self.local_decls[local].name.is_some() {\n             LocalKind::Var\n         } else {\n-            debug_assert!(self.local_decls[local].mutability == Mutability::Mut,\n-                          \"temp should be mutable\");\n+            debug_assert!(\n+                self.local_decls[local].mutability == Mutability::Mut,\n+                \"temp should be mutable\"\n+            );\n \n             LocalKind::Temp\n         }\n     }\n \n     /// Returns an iterator over all temporaries.\n     #[inline]\n-    pub fn temps_iter<'a>(&'a self) -> impl Iterator<Item=Local> + 'a {\n-        (self.arg_count+1..self.local_decls.len()).filter_map(move |index| {\n+    pub fn temps_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n+        (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n             if self.local_decls[local].is_user_variable.is_some() {\n                 None\n@@ -238,8 +248,8 @@ impl<'tcx> Mir<'tcx> {\n \n     /// Returns an iterator over all user-declared locals.\n     #[inline]\n-    pub fn vars_iter<'a>(&'a self) -> impl Iterator<Item=Local> + 'a {\n-        (self.arg_count+1..self.local_decls.len()).filter_map(move |index| {\n+    pub fn vars_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n+        (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n             if self.local_decls[local].is_user_variable.is_some() {\n                 Some(local)\n@@ -251,12 +261,12 @@ impl<'tcx> Mir<'tcx> {\n \n     /// Returns an iterator over all user-declared mutable arguments and locals.\n     #[inline]\n-    pub fn mut_vars_and_args_iter<'a>(&'a self) -> impl Iterator<Item=Local> + 'a {\n+    pub fn mut_vars_and_args_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n         (1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n             let decl = &self.local_decls[local];\n             if (decl.is_user_variable.is_some() || index < self.arg_count + 1)\n-               && decl.mutability == Mutability::Mut\n+                && decl.mutability == Mutability::Mut\n             {\n                 Some(local)\n             } else {\n@@ -267,18 +277,18 @@ impl<'tcx> Mir<'tcx> {\n \n     /// Returns an iterator over all function arguments.\n     #[inline]\n-    pub fn args_iter(&self) -> impl Iterator<Item=Local> {\n+    pub fn args_iter(&self) -> impl Iterator<Item = Local> {\n         let arg_count = self.arg_count;\n-        (1..arg_count+1).map(Local::new)\n+        (1..arg_count + 1).map(Local::new)\n     }\n \n     /// Returns an iterator over all user-defined variables and compiler-generated temporaries (all\n     /// locals that are neither arguments nor the return place).\n     #[inline]\n-    pub fn vars_and_temps_iter(&self) -> impl Iterator<Item=Local> {\n+    pub fn vars_and_temps_iter(&self) -> impl Iterator<Item = Local> {\n         let arg_count = self.arg_count;\n         let local_count = self.local_decls.len();\n-        (arg_count+1..local_count).map(Local::new)\n+        (arg_count + 1..local_count).map(Local::new)\n     }\n \n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n@@ -302,6 +312,19 @@ impl<'tcx> Mir<'tcx> {\n         }\n     }\n \n+    /// Check if `sub` is a sub scope of `sup`\n+    pub fn is_sub_scope(&self, mut sub: SourceScope, sup: SourceScope) -> bool {\n+        loop {\n+            if sub == sup {\n+                return true;\n+            }\n+            match self.source_scopes[sub].parent_scope {\n+                None => return false,\n+                Some(p) => sub = p,\n+            }\n+        }\n+    }\n+\n     /// Return the return type, it always return first element from `local_decls` array\n     pub fn return_ty(&self) -> Ty<'tcx> {\n         self.local_decls[RETURN_PLACE].ty\n@@ -316,7 +339,7 @@ pub enum Safety {\n     /// Unsafe because of an unsafe fn\n     FnUnsafe,\n     /// Unsafe because of an `unsafe` block\n-    ExplicitUnsafe(ast::NodeId)\n+    ExplicitUnsafe(ast::NodeId),\n }\n \n impl_stable_hash_for!(struct Mir<'tcx> {\n@@ -354,7 +377,7 @@ impl<'tcx> IndexMut<BasicBlock> for Mir<'tcx> {\n #[derive(Copy, Clone, Debug)]\n pub enum ClearCrossCrate<T> {\n     Clear,\n-    Set(T)\n+    Set(T),\n }\n \n impl<T: serialize::Encodable> serialize::UseSpecializedEncodable for ClearCrossCrate<T> {}\n@@ -370,7 +393,7 @@ pub struct SourceInfo {\n \n     /// The source scope, keeping track of which bindings can be\n     /// seen by debuginfo, active lint levels, `unsafe {...}`, etc.\n-    pub scope: SourceScope\n+    pub scope: SourceScope,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -391,7 +414,6 @@ impl From<Mutability> for hir::Mutability {\n     }\n }\n \n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n@@ -438,15 +460,17 @@ pub enum BorrowKind {\n     Mut {\n         /// True if this borrow arose from method-call auto-ref\n         /// (i.e. `adjustment::Adjust::Borrow`)\n-        allow_two_phase_borrow: bool\n-    }\n+        allow_two_phase_borrow: bool,\n+    },\n }\n \n impl BorrowKind {\n     pub fn allows_two_phase_borrow(&self) -> bool {\n         match *self {\n             BorrowKind::Shared | BorrowKind::Unique => false,\n-            BorrowKind::Mut { allow_two_phase_borrow } => allow_two_phase_borrow,\n+            BorrowKind::Mut {\n+                allow_two_phase_borrow,\n+            } => allow_two_phase_borrow,\n         }\n     }\n }\n@@ -641,8 +665,7 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// - `fn foo(x: Type) { ... }`,\n     /// - `let x = ...`,\n     /// - or `match ... { C(x) => ... }`\n-    pub fn can_be_made_mutable(&self) -> bool\n-    {\n+    pub fn can_be_made_mutable(&self) -> bool {\n         match self.is_user_variable {\n             Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n@@ -660,8 +683,7 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// Returns true if local is definitely not a `ref ident` or\n     /// `ref mut ident` binding. (Such bindings cannot be made into\n     /// mutable bindings, but the inverse does not necessarily hold).\n-    pub fn is_nonref_binding(&self) -> bool\n-    {\n+    pub fn is_nonref_binding(&self) -> bool {\n         match self.is_user_variable {\n             Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n@@ -683,7 +705,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             name: None,\n             source_info: SourceInfo {\n                 span,\n-                scope: OUTERMOST_SOURCE_SCOPE\n+                scope: OUTERMOST_SOURCE_SCOPE,\n             },\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal: false,\n@@ -700,7 +722,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             name: None,\n             source_info: SourceInfo {\n                 span,\n-                scope: OUTERMOST_SOURCE_SCOPE\n+                scope: OUTERMOST_SOURCE_SCOPE,\n             },\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal: true,\n@@ -718,11 +740,11 @@ impl<'tcx> LocalDecl<'tcx> {\n             ty: return_ty,\n             source_info: SourceInfo {\n                 span,\n-                scope: OUTERMOST_SOURCE_SCOPE\n+                scope: OUTERMOST_SOURCE_SCOPE,\n             },\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal: false,\n-            name: None,     // FIXME maybe we do want some name here?\n+            name: None, // FIXME maybe we do want some name here?\n             is_user_variable: None,\n         }\n     }\n@@ -781,15 +803,13 @@ pub struct BasicBlockData<'tcx> {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Terminator<'tcx> {\n     pub source_info: SourceInfo,\n-    pub kind: TerminatorKind<'tcx>\n+    pub kind: TerminatorKind<'tcx>,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum TerminatorKind<'tcx> {\n     /// block should have one successor in the graph; we jump there\n-    Goto {\n-        target: BasicBlock,\n-    },\n+    Goto { target: BasicBlock },\n \n     /// operand evaluates to an integer; jump depending on its value\n     /// to one of the targets, and otherwise fallback to `otherwise`\n@@ -837,7 +857,7 @@ pub enum TerminatorKind<'tcx> {\n     Drop {\n         location: Place<'tcx>,\n         target: BasicBlock,\n-        unwind: Option<BasicBlock>\n+        unwind: Option<BasicBlock>,\n     },\n \n     /// Drop the Place and assign the new value over it. This ensures\n@@ -885,7 +905,7 @@ pub enum TerminatorKind<'tcx> {\n         /// Destination for the return value. If some, the call is converging.\n         destination: Option<(Place<'tcx>, BasicBlock)>,\n         /// Cleanups to be done if the call unwinds.\n-        cleanup: Option<BasicBlock>\n+        cleanup: Option<BasicBlock>,\n     },\n \n     /// Jump to the target if the condition has the expected value,\n@@ -895,7 +915,7 @@ pub enum TerminatorKind<'tcx> {\n         expected: bool,\n         msg: AssertMessage<'tcx>,\n         target: BasicBlock,\n-        cleanup: Option<BasicBlock>\n+        cleanup: Option<BasicBlock>,\n     },\n \n     /// A suspend point\n@@ -956,8 +976,12 @@ impl<'tcx> Terminator<'tcx> {\n }\n \n impl<'tcx> TerminatorKind<'tcx> {\n-    pub fn if_<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>, cond: Operand<'tcx>,\n-                         t: BasicBlock, f: BasicBlock) -> TerminatorKind<'tcx> {\n+    pub fn if_<'a, 'gcx>(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        cond: Operand<'tcx>,\n+        t: BasicBlock,\n+        f: BasicBlock,\n+    ) -> TerminatorKind<'tcx> {\n         static BOOL_SWITCH_FALSE: &'static [u128] = &[0];\n         TerminatorKind::SwitchInt {\n             discr: cond,\n@@ -970,91 +994,199 @@ impl<'tcx> TerminatorKind<'tcx> {\n     pub fn successors(&self) -> Successors {\n         use self::TerminatorKind::*;\n         match *self {\n-            Resume | Abort | GeneratorDrop | Return | Unreachable |\n-            Call { destination: None, cleanup: None, .. } => {\n-                None.into_iter().chain(&[])\n+            Resume\n+            | Abort\n+            | GeneratorDrop\n+            | Return\n+            | Unreachable\n+            | Call {\n+                destination: None,\n+                cleanup: None,\n+                ..\n+            } => None.into_iter().chain(&[]),\n+            Goto { target: ref t }\n+            | Call {\n+                destination: None,\n+                cleanup: Some(ref t),\n+                ..\n+            }\n+            | Call {\n+                destination: Some((_, ref t)),\n+                cleanup: None,\n+                ..\n+            }\n+            | Yield {\n+                resume: ref t,\n+                drop: None,\n+                ..\n+            }\n+            | DropAndReplace {\n+                target: ref t,\n+                unwind: None,\n+                ..\n             }\n-            Goto { target: ref t } |\n-            Call { destination: None, cleanup: Some(ref t), .. } |\n-            Call { destination: Some((_, ref t)), cleanup: None, .. } |\n-            Yield { resume: ref t, drop: None, .. } |\n-            DropAndReplace { target: ref t, unwind: None, .. } |\n-            Drop { target: ref t, unwind: None, .. } |\n-            Assert { target: ref t, cleanup: None, .. } |\n-            FalseUnwind { real_target: ref t, unwind: None } => {\n-                Some(t).into_iter().chain(&[])\n+            | Drop {\n+                target: ref t,\n+                unwind: None,\n+                ..\n             }\n-            Call { destination: Some((_, ref t)), cleanup: Some(ref u), .. } |\n-            Yield { resume: ref t, drop: Some(ref u), .. } |\n-            DropAndReplace { target: ref t, unwind: Some(ref u), .. } |\n-            Drop { target: ref t, unwind: Some(ref u), .. } |\n-            Assert { target: ref t, cleanup: Some(ref u), .. } |\n-            FalseUnwind { real_target: ref t, unwind: Some(ref u) } => {\n-                Some(t).into_iter().chain(slice::from_ref(u))\n+            | Assert {\n+                target: ref t,\n+                cleanup: None,\n+                ..\n             }\n-            SwitchInt { ref targets, .. } => {\n-                None.into_iter().chain(&targets[..])\n+            | FalseUnwind {\n+                real_target: ref t,\n+                unwind: None,\n+            } => Some(t).into_iter().chain(&[]),\n+            Call {\n+                destination: Some((_, ref t)),\n+                cleanup: Some(ref u),\n+                ..\n             }\n-            FalseEdges { ref real_target, ref imaginary_targets } => {\n-                Some(real_target).into_iter().chain(&imaginary_targets[..])\n+            | Yield {\n+                resume: ref t,\n+                drop: Some(ref u),\n+                ..\n             }\n+            | DropAndReplace {\n+                target: ref t,\n+                unwind: Some(ref u),\n+                ..\n+            }\n+            | Drop {\n+                target: ref t,\n+                unwind: Some(ref u),\n+                ..\n+            }\n+            | Assert {\n+                target: ref t,\n+                cleanup: Some(ref u),\n+                ..\n+            }\n+            | FalseUnwind {\n+                real_target: ref t,\n+                unwind: Some(ref u),\n+            } => Some(t).into_iter().chain(slice::from_ref(u)),\n+            SwitchInt { ref targets, .. } => None.into_iter().chain(&targets[..]),\n+            FalseEdges {\n+                ref real_target,\n+                ref imaginary_targets,\n+            } => Some(real_target).into_iter().chain(&imaginary_targets[..]),\n         }\n     }\n \n     pub fn successors_mut(&mut self) -> SuccessorsMut {\n         use self::TerminatorKind::*;\n         match *self {\n-            Resume | Abort | GeneratorDrop | Return | Unreachable |\n-            Call { destination: None, cleanup: None, .. } => {\n-                None.into_iter().chain(&mut [])\n+            Resume\n+            | Abort\n+            | GeneratorDrop\n+            | Return\n+            | Unreachable\n+            | Call {\n+                destination: None,\n+                cleanup: None,\n+                ..\n+            } => None.into_iter().chain(&mut []),\n+            Goto { target: ref mut t }\n+            | Call {\n+                destination: None,\n+                cleanup: Some(ref mut t),\n+                ..\n+            }\n+            | Call {\n+                destination: Some((_, ref mut t)),\n+                cleanup: None,\n+                ..\n+            }\n+            | Yield {\n+                resume: ref mut t,\n+                drop: None,\n+                ..\n+            }\n+            | DropAndReplace {\n+                target: ref mut t,\n+                unwind: None,\n+                ..\n+            }\n+            | Drop {\n+                target: ref mut t,\n+                unwind: None,\n+                ..\n+            }\n+            | Assert {\n+                target: ref mut t,\n+                cleanup: None,\n+                ..\n+            }\n+            | FalseUnwind {\n+                real_target: ref mut t,\n+                unwind: None,\n+            } => Some(t).into_iter().chain(&mut []),\n+            Call {\n+                destination: Some((_, ref mut t)),\n+                cleanup: Some(ref mut u),\n+                ..\n             }\n-            Goto { target: ref mut t } |\n-            Call { destination: None, cleanup: Some(ref mut t), .. } |\n-            Call { destination: Some((_, ref mut t)), cleanup: None, .. } |\n-            Yield { resume: ref mut t, drop: None, .. } |\n-            DropAndReplace { target: ref mut t, unwind: None, .. } |\n-            Drop { target: ref mut t, unwind: None, .. } |\n-            Assert { target: ref mut t, cleanup: None, .. } |\n-            FalseUnwind { real_target: ref mut t, unwind: None } => {\n-                Some(t).into_iter().chain(&mut [])\n+            | Yield {\n+                resume: ref mut t,\n+                drop: Some(ref mut u),\n+                ..\n             }\n-            Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut u), .. } |\n-            Yield { resume: ref mut t, drop: Some(ref mut u), .. } |\n-            DropAndReplace { target: ref mut t, unwind: Some(ref mut u), .. } |\n-            Drop { target: ref mut t, unwind: Some(ref mut u), .. } |\n-            Assert { target: ref mut t, cleanup: Some(ref mut u), .. } |\n-            FalseUnwind { real_target: ref mut t, unwind: Some(ref mut u) } => {\n-                Some(t).into_iter().chain(slice::from_mut(u))\n+            | DropAndReplace {\n+                target: ref mut t,\n+                unwind: Some(ref mut u),\n+                ..\n             }\n-            SwitchInt { ref mut targets, .. } => {\n-                None.into_iter().chain(&mut targets[..])\n+            | Drop {\n+                target: ref mut t,\n+                unwind: Some(ref mut u),\n+                ..\n             }\n-            FalseEdges { ref mut real_target, ref mut imaginary_targets } => {\n-                Some(real_target).into_iter().chain(&mut imaginary_targets[..])\n+            | Assert {\n+                target: ref mut t,\n+                cleanup: Some(ref mut u),\n+                ..\n             }\n+            | FalseUnwind {\n+                real_target: ref mut t,\n+                unwind: Some(ref mut u),\n+            } => Some(t).into_iter().chain(slice::from_mut(u)),\n+            SwitchInt {\n+                ref mut targets, ..\n+            } => None.into_iter().chain(&mut targets[..]),\n+            FalseEdges {\n+                ref mut real_target,\n+                ref mut imaginary_targets,\n+            } => Some(real_target)\n+                .into_iter()\n+                .chain(&mut imaginary_targets[..]),\n         }\n     }\n \n     pub fn unwind_mut(&mut self) -> Option<&mut Option<BasicBlock>> {\n         match *self {\n-            TerminatorKind::Goto { .. } |\n-            TerminatorKind::Resume |\n-            TerminatorKind::Abort |\n-            TerminatorKind::Return |\n-            TerminatorKind::Unreachable |\n-            TerminatorKind::GeneratorDrop |\n-            TerminatorKind::Yield { .. } |\n-            TerminatorKind::SwitchInt { .. } |\n-            TerminatorKind::FalseEdges { .. } => {\n-                None\n-            },\n-            TerminatorKind::Call { cleanup: ref mut unwind, .. } |\n-            TerminatorKind::Assert { cleanup: ref mut unwind, .. } |\n-            TerminatorKind::DropAndReplace { ref mut unwind, .. } |\n-            TerminatorKind::Drop { ref mut unwind, .. } |\n-            TerminatorKind::FalseUnwind { ref mut unwind, .. } => {\n-                Some(unwind)\n+            TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Yield { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::FalseEdges { .. } => None,\n+            TerminatorKind::Call {\n+                cleanup: ref mut unwind,\n+                ..\n             }\n+            | TerminatorKind::Assert {\n+                cleanup: ref mut unwind,\n+                ..\n+            }\n+            | TerminatorKind::DropAndReplace { ref mut unwind, .. }\n+            | TerminatorKind::Drop { ref mut unwind, .. }\n+            | TerminatorKind::FalseUnwind { ref mut unwind, .. } => Some(unwind),\n         }\n     }\n }\n@@ -1080,7 +1212,10 @@ impl<'tcx> BasicBlockData<'tcx> {\n         self.terminator.as_mut().expect(\"invalid terminator state\")\n     }\n \n-    pub fn retain_statements<F>(&mut self, mut f: F) where F: FnMut(&mut Statement) -> bool {\n+    pub fn retain_statements<F>(&mut self, mut f: F)\n+    where\n+        F: FnMut(&mut Statement) -> bool,\n+    {\n         for s in &mut self.statements {\n             if !f(s) {\n                 s.make_nop();\n@@ -1089,8 +1224,9 @@ impl<'tcx> BasicBlockData<'tcx> {\n     }\n \n     pub fn expand_statements<F, I>(&mut self, mut f: F)\n-        where F: FnMut(&mut Statement<'tcx>) -> Option<I>,\n-              I: iter::TrustedLen<Item = Statement<'tcx>>\n+    where\n+        F: FnMut(&mut Statement<'tcx>) -> Option<I>,\n+        I: iter::TrustedLen<Item = Statement<'tcx>>,\n     {\n         // Gather all the iterators we'll need to splice in, and their positions.\n         let mut splices: Vec<(usize, I)> = vec![];\n@@ -1119,14 +1255,17 @@ impl<'tcx> BasicBlockData<'tcx> {\n         // splicing adding new elements to the end of that gap and moving\n         // existing elements from before the gap to the end of the gap.\n         // For now, this is safe code, emulating a gap but initializing it.\n-        let mut gap = self.statements.len()..self.statements.len()+extra_stmts;\n-        self.statements.resize(gap.end, Statement {\n-            source_info: SourceInfo {\n-                span: DUMMY_SP,\n-                scope: OUTERMOST_SOURCE_SCOPE\n+        let mut gap = self.statements.len()..self.statements.len() + extra_stmts;\n+        self.statements.resize(\n+            gap.end,\n+            Statement {\n+                source_info: SourceInfo {\n+                    span: DUMMY_SP,\n+                    scope: OUTERMOST_SOURCE_SCOPE,\n+                },\n+                kind: StatementKind::Nop,\n             },\n-            kind: StatementKind::Nop\n-        });\n+        );\n         for (splice_start, new_stmts) in splices.into_iter().rev() {\n             let splice_end = splice_start + new_stmts.size_hint().0;\n             while gap.end > splice_end {\n@@ -1170,7 +1309,6 @@ impl<'tcx> Debug for TerminatorKind<'tcx> {\n                 }\n                 write!(fmt, \"]\")\n             }\n-\n         }\n     }\n }\n@@ -1183,17 +1321,27 @@ impl<'tcx> TerminatorKind<'tcx> {\n         use self::TerminatorKind::*;\n         match *self {\n             Goto { .. } => write!(fmt, \"goto\"),\n-            SwitchInt { discr: ref place, .. } => write!(fmt, \"switchInt({:?})\", place),\n+            SwitchInt {\n+                discr: ref place, ..\n+            } => write!(fmt, \"switchInt({:?})\", place),\n             Return => write!(fmt, \"return\"),\n             GeneratorDrop => write!(fmt, \"generator_drop\"),\n             Resume => write!(fmt, \"resume\"),\n             Abort => write!(fmt, \"abort\"),\n             Yield { ref value, .. } => write!(fmt, \"_1 = suspend({:?})\", value),\n             Unreachable => write!(fmt, \"unreachable\"),\n             Drop { ref location, .. } => write!(fmt, \"drop({:?})\", location),\n-            DropAndReplace { ref location, ref value, .. } =>\n-                write!(fmt, \"replace({:?} <- {:?})\", location, value),\n-            Call { ref func, ref args, ref destination, .. } => {\n+            DropAndReplace {\n+                ref location,\n+                ref value,\n+                ..\n+            } => write!(fmt, \"replace({:?} <- {:?})\", location, value),\n+            Call {\n+                ref func,\n+                ref args,\n+                ref destination,\n+                ..\n+            } => {\n                 if let Some((ref destination, _)) = *destination {\n                     write!(fmt, \"{:?} = \", destination)?;\n                 }\n@@ -1206,13 +1354,18 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 }\n                 write!(fmt, \")\")\n             }\n-            Assert { ref cond, expected, ref msg, .. } => {\n+            Assert {\n+                ref cond,\n+                expected,\n+                ref msg,\n+                ..\n+            } => {\n                 write!(fmt, \"assert(\")?;\n                 if !expected {\n                     write!(fmt, \"!\")?;\n                 }\n                 write!(fmt, \"{:?}, \\\"{:?}\\\")\", cond, msg)\n-            },\n+            }\n             FalseEdges { .. } => write!(fmt, \"falseEdges\"),\n             FalseUnwind { .. } => write!(fmt, \"falseUnwind\"),\n         }\n@@ -1224,48 +1377,77 @@ impl<'tcx> TerminatorKind<'tcx> {\n         match *self {\n             Return | Resume | Abort | Unreachable | GeneratorDrop => vec![],\n             Goto { .. } => vec![\"\".into()],\n-            SwitchInt { ref values, switch_ty, .. } => {\n+            SwitchInt {\n+                ref values,\n+                switch_ty,\n+                ..\n+            } => {\n                 let size = ty::tls::with(|tcx| {\n                     let param_env = ty::ParamEnv::empty();\n                     let switch_ty = tcx.lift_to_global(&switch_ty).unwrap();\n                     tcx.layout_of(param_env.and(switch_ty)).unwrap().size\n                 });\n-                values.iter()\n-                      .map(|&u| {\n-                          let mut s = String::new();\n-                          print_miri_value(\n-                              Value::Scalar(Scalar::Bits { bits: u, defined: size.bits() as u8 }),\n-                              switch_ty,\n-                              &mut s,\n-                          ).unwrap();\n-                          s.into()\n-                      })\n-                      .chain(iter::once(String::from(\"otherwise\").into()))\n-                      .collect()\n+                values\n+                    .iter()\n+                    .map(|&u| {\n+                        let mut s = String::new();\n+                        print_miri_value(\n+                            Value::Scalar(Scalar::Bits {\n+                                bits: u,\n+                                defined: size.bits() as u8,\n+                            }),\n+                            switch_ty,\n+                            &mut s,\n+                        ).unwrap();\n+                        s.into()\n+                    })\n+                    .chain(iter::once(String::from(\"otherwise\").into()))\n+                    .collect()\n             }\n-            Call { destination: Some(_), cleanup: Some(_), .. } =>\n-                vec![\"return\".into_cow(), \"unwind\".into_cow()],\n-            Call { destination: Some(_), cleanup: None, .. } => vec![\"return\".into_cow()],\n-            Call { destination: None, cleanup: Some(_), .. } => vec![\"unwind\".into_cow()],\n-            Call { destination: None, cleanup: None, .. } => vec![],\n-            Yield { drop: Some(_), .. } =>\n-                vec![\"resume\".into_cow(), \"drop\".into_cow()],\n+            Call {\n+                destination: Some(_),\n+                cleanup: Some(_),\n+                ..\n+            } => vec![\"return\".into_cow(), \"unwind\".into_cow()],\n+            Call {\n+                destination: Some(_),\n+                cleanup: None,\n+                ..\n+            } => vec![\"return\".into_cow()],\n+            Call {\n+                destination: None,\n+                cleanup: Some(_),\n+                ..\n+            } => vec![\"unwind\".into_cow()],\n+            Call {\n+                destination: None,\n+                cleanup: None,\n+                ..\n+            } => vec![],\n+            Yield { drop: Some(_), .. } => vec![\"resume\".into_cow(), \"drop\".into_cow()],\n             Yield { drop: None, .. } => vec![\"resume\".into_cow()],\n-            DropAndReplace { unwind: None, .. } |\n-            Drop { unwind: None, .. } => vec![\"return\".into_cow()],\n-            DropAndReplace { unwind: Some(_), .. } |\n-            Drop { unwind: Some(_), .. } => {\n-                vec![\"return\".into_cow(), \"unwind\".into_cow()]\n+            DropAndReplace { unwind: None, .. } | Drop { unwind: None, .. } => {\n+                vec![\"return\".into_cow()]\n+            }\n+            DropAndReplace {\n+                unwind: Some(_), ..\n             }\n+            | Drop {\n+                unwind: Some(_), ..\n+            } => vec![\"return\".into_cow(), \"unwind\".into_cow()],\n             Assert { cleanup: None, .. } => vec![\"\".into()],\n-            Assert { .. } =>\n-                vec![\"success\".into_cow(), \"unwind\".into_cow()],\n-            FalseEdges { ref imaginary_targets, .. } => {\n+            Assert { .. } => vec![\"success\".into_cow(), \"unwind\".into_cow()],\n+            FalseEdges {\n+                ref imaginary_targets,\n+                ..\n+            } => {\n                 let mut l = vec![\"real\".into()];\n                 l.resize(imaginary_targets.len() + 1, \"imaginary\".into());\n                 l\n             }\n-            FalseUnwind { unwind: Some(_), .. } => vec![\"real\".into(), \"cleanup\".into()],\n+            FalseUnwind {\n+                unwind: Some(_), ..\n+            } => vec![\"real\".into(), \"cleanup\".into()],\n             FalseUnwind { unwind: None, .. } => vec![\"real\".into()],\n         }\n     }\n@@ -1291,7 +1473,7 @@ impl<'tcx> Statement<'tcx> {\n     pub fn replace_nop(&mut self) -> Self {\n         Statement {\n             source_info: self.source_info,\n-            kind: mem::replace(&mut self.kind, StatementKind::Nop)\n+            kind: mem::replace(&mut self.kind, StatementKind::Nop),\n         }\n     }\n }\n@@ -1306,7 +1488,10 @@ pub enum StatementKind<'tcx> {\n     ReadForMatch(Place<'tcx>),\n \n     /// Write the discriminant for a variant to the enum Place.\n-    SetDiscriminant { place: Place<'tcx>, variant_index: usize },\n+    SetDiscriminant {\n+        place: Place<'tcx>,\n+        variant_index: usize,\n+    },\n \n     /// Start a live range for the storage of the local.\n     StorageLive(Local),\n@@ -1318,7 +1503,7 @@ pub enum StatementKind<'tcx> {\n     InlineAsm {\n         asm: Box<InlineAsm>,\n         outputs: Vec<Place<'tcx>>,\n-        inputs: Vec<Operand<'tcx>>\n+        inputs: Vec<Operand<'tcx>>,\n     },\n \n     /// Assert the given places to be valid inhabitants of their type.  These statements are\n@@ -1413,14 +1598,18 @@ impl<'tcx> Debug for Statement<'tcx> {\n             Validate(ref op, ref places) => write!(fmt, \"Validate({:?}, {:?})\", op, places),\n             StorageLive(ref place) => write!(fmt, \"StorageLive({:?})\", place),\n             StorageDead(ref place) => write!(fmt, \"StorageDead({:?})\", place),\n-            SetDiscriminant { ref place, variant_index } => {\n-                write!(fmt, \"discriminant({:?}) = {:?}\", place, variant_index)\n-            },\n-            InlineAsm { ref asm, ref outputs, ref inputs } => {\n-                write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm, outputs, inputs)\n-            },\n-            UserAssertTy(ref c_ty, ref local) => write!(fmt, \"UserAssertTy({:?}, {:?})\",\n-                                                        c_ty, local),\n+            SetDiscriminant {\n+                ref place,\n+                variant_index,\n+            } => write!(fmt, \"discriminant({:?}) = {:?}\", place, variant_index),\n+            InlineAsm {\n+                ref asm,\n+                ref outputs,\n+                ref inputs,\n+            } => write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm, outputs, inputs),\n+            UserAssertTy(ref c_ty, ref local) => {\n+                write!(fmt, \"UserAssertTy({:?}, {:?})\", c_ty, local)\n+            }\n             Nop => write!(fmt, \"nop\"),\n         }\n     }\n@@ -1532,10 +1721,7 @@ impl<'tcx> Place<'tcx> {\n     }\n \n     pub fn elem(self, elem: PlaceElem<'tcx>) -> Place<'tcx> {\n-        Place::Projection(Box::new(PlaceProjection {\n-            base: self,\n-            elem,\n-        }))\n+        Place::Projection(Box::new(PlaceProjection { base: self, elem }))\n     }\n }\n \n@@ -1545,31 +1731,41 @@ impl<'tcx> Debug for Place<'tcx> {\n \n         match *self {\n             Local(id) => write!(fmt, \"{:?}\", id),\n-            Static(box self::Static { def_id, ty }) =>\n-                write!(fmt, \"({}: {:?})\", ty::tls::with(|tcx| tcx.item_path_str(def_id)), ty),\n-            Projection(ref data) =>\n-                match data.elem {\n-                    ProjectionElem::Downcast(ref adt_def, index) =>\n-                        write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].name),\n-                    ProjectionElem::Deref =>\n-                        write!(fmt, \"(*{:?})\", data.base),\n-                    ProjectionElem::Field(field, ty) =>\n-                        write!(fmt, \"({:?}.{:?}: {:?})\", data.base, field.index(), ty),\n-                    ProjectionElem::Index(ref index) =>\n-                        write!(fmt, \"{:?}[{:?}]\", data.base, index),\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } =>\n-                        write!(fmt, \"{:?}[{:?} of {:?}]\", data.base, offset, min_length),\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n-                        write!(fmt, \"{:?}[-{:?} of {:?}]\", data.base, offset, min_length),\n-                    ProjectionElem::Subslice { from, to } if to == 0 =>\n-                        write!(fmt, \"{:?}[{:?}:]\", data.base, from),\n-                    ProjectionElem::Subslice { from, to } if from == 0 =>\n-                        write!(fmt, \"{:?}[:-{:?}]\", data.base, to),\n-                    ProjectionElem::Subslice { from, to } =>\n-                        write!(fmt, \"{:?}[{:?}:-{:?}]\", data.base,\n-                               from, to),\n-\n-                },\n+            Static(box self::Static { def_id, ty }) => write!(\n+                fmt,\n+                \"({}: {:?})\",\n+                ty::tls::with(|tcx| tcx.item_path_str(def_id)),\n+                ty\n+            ),\n+            Projection(ref data) => match data.elem {\n+                ProjectionElem::Downcast(ref adt_def, index) => {\n+                    write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].name)\n+                }\n+                ProjectionElem::Deref => write!(fmt, \"(*{:?})\", data.base),\n+                ProjectionElem::Field(field, ty) => {\n+                    write!(fmt, \"({:?}.{:?}: {:?})\", data.base, field.index(), ty)\n+                }\n+                ProjectionElem::Index(ref index) => write!(fmt, \"{:?}[{:?}]\", data.base, index),\n+                ProjectionElem::ConstantIndex {\n+                    offset,\n+                    min_length,\n+                    from_end: false,\n+                } => write!(fmt, \"{:?}[{:?} of {:?}]\", data.base, offset, min_length),\n+                ProjectionElem::ConstantIndex {\n+                    offset,\n+                    min_length,\n+                    from_end: true,\n+                } => write!(fmt, \"{:?}[-{:?} of {:?}]\", data.base, offset, min_length),\n+                ProjectionElem::Subslice { from, to } if to == 0 => {\n+                    write!(fmt, \"{:?}[{:?}:]\", data.base, from)\n+                }\n+                ProjectionElem::Subslice { from, to } if from == 0 => {\n+                    write!(fmt, \"{:?}[:-{:?}]\", data.base, to)\n+                }\n+                ProjectionElem::Subslice { from, to } => {\n+                    write!(fmt, \"{:?}[{:?}:-{:?}]\", data.base, from, to)\n+                }\n+            },\n         }\n     }\n }\n@@ -1650,7 +1846,7 @@ impl<'tcx> Operand<'tcx> {\n     pub fn to_copy(&self) -> Self {\n         match *self {\n             Operand::Copy(_) | Operand::Constant(_) => self.clone(),\n-            Operand::Move(ref place) => Operand::Copy(place.clone())\n+            Operand::Move(ref place) => Operand::Copy(place.clone()),\n         }\n     }\n }\n@@ -1775,7 +1971,7 @@ impl BinOp {\n         use self::BinOp::*;\n         match self {\n             Add | Sub | Mul | Shl | Shr => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n }\n@@ -1823,7 +2019,9 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                 // When printing regions, add trailing space if necessary.\n                 let region = if ppaux::verbose() || ppaux::identify_regions() {\n                     let mut region = format!(\"{}\", region);\n-                    if region.len() > 0 { region.push(' '); }\n+                    if region.len() > 0 {\n+                        region.push(' ');\n+                    }\n                     region\n                 } else {\n                     // Do not even print 'static\n@@ -1844,13 +2042,11 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                 match **kind {\n                     AggregateKind::Array(_) => write!(fmt, \"{:?}\", places),\n \n-                    AggregateKind::Tuple => {\n-                        match places.len() {\n-                            0 => write!(fmt, \"()\"),\n-                            1 => write!(fmt, \"({:?},)\", places[0]),\n-                            _ => fmt_tuple(fmt, places),\n-                        }\n-                    }\n+                    AggregateKind::Tuple => match places.len() {\n+                        0 => write!(fmt, \"()\"),\n+                        1 => write!(fmt, \"({:?},)\", places[0]),\n+                        _ => fmt_tuple(fmt, places),\n+                    },\n \n                     AggregateKind::Adt(adt_def, variant, substs, _) => {\n                         let variant_def = &adt_def.variants[variant];\n@@ -1904,8 +2100,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                                 }\n                                 struct_fmt.field(\"$state\", &places[freevars.len()]);\n                                 for i in (freevars.len() + 1)..places.len() {\n-                                    struct_fmt.field(&format!(\"${}\", i - freevars.len() - 1),\n-                                                     &places[i]);\n+                                    struct_fmt\n+                                        .field(&format!(\"${}\", i - freevars.len() - 1), &places[i]);\n                                 }\n                             });\n \n@@ -1936,15 +2132,14 @@ pub struct Constant<'tcx> {\n \n newtype_index!(Promoted { DEBUG_FORMAT = \"promoted[{}]\" });\n \n-\n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {\n     Value {\n         value: &'tcx ty::Const<'tcx>,\n     },\n     Promoted {\n         // Index into the `promoted` vector of `Mir`.\n-        index: Promoted\n+        index: Promoted,\n     },\n }\n \n@@ -1962,9 +2157,7 @@ impl<'tcx> Debug for Literal<'tcx> {\n                 write!(fmt, \"const \")?;\n                 fmt_const_val(fmt, value)\n             }\n-            Promoted { index } => {\n-                write!(fmt, \"{:?}\", index)\n-            }\n+            Promoted { index } => write!(fmt, \"{:?}\", index),\n         }\n     }\n }\n@@ -1980,7 +2173,7 @@ pub fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Resul\n             } else {\n                 write!(fmt, \"{:?}:{}\", val, const_val.ty)\n             }\n-        },\n+        }\n     }\n }\n \n@@ -1989,38 +2182,40 @@ pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Resul\n     match (value, &ty.sty) {\n         (Value::Scalar(Scalar::Bits { bits: 0, .. }), &TyBool) => write!(f, \"false\"),\n         (Value::Scalar(Scalar::Bits { bits: 1, .. }), &TyBool) => write!(f, \"true\"),\n-        (Value::Scalar(Scalar::Bits { bits, .. }), &TyFloat(ast::FloatTy::F32)) =>\n-            write!(f, \"{}f32\", Single::from_bits(bits)),\n-        (Value::Scalar(Scalar::Bits { bits, .. }), &TyFloat(ast::FloatTy::F64)) =>\n-            write!(f, \"{}f64\", Double::from_bits(bits)),\n+        (Value::Scalar(Scalar::Bits { bits, .. }), &TyFloat(ast::FloatTy::F32)) => {\n+            write!(f, \"{}f32\", Single::from_bits(bits))\n+        }\n+        (Value::Scalar(Scalar::Bits { bits, .. }), &TyFloat(ast::FloatTy::F64)) => {\n+            write!(f, \"{}f64\", Double::from_bits(bits))\n+        }\n         (Value::Scalar(Scalar::Bits { bits, .. }), &TyUint(ui)) => write!(f, \"{:?}{}\", bits, ui),\n         (Value::Scalar(Scalar::Bits { bits, .. }), &TyInt(i)) => {\n             let bit_width = ty::tls::with(|tcx| {\n-                 let ty = tcx.lift_to_global(&ty).unwrap();\n-                 tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size.bits()\n+                let ty = tcx.lift_to_global(&ty).unwrap();\n+                tcx.layout_of(ty::ParamEnv::empty().and(ty))\n+                    .unwrap()\n+                    .size\n+                    .bits()\n             });\n             let shift = 128 - bit_width;\n             write!(f, \"{:?}{}\", ((bits as i128) << shift) >> shift, i)\n-        },\n-        (Value::Scalar(Scalar::Bits { bits, .. }), &TyChar) =>\n-            write!(f, \"{:?}\", ::std::char::from_u32(bits as u32).unwrap()),\n-        (_, &TyFnDef(did, _)) =>\n-            write!(f, \"{}\", item_path_str(did)),\n-        (Value::ScalarPair(Scalar::Ptr(ptr), Scalar::Bits { bits: len, .. }),\n-         &TyRef(_, &ty::TyS { sty: TyStr, .. }, _)) => {\n-            ty::tls::with(|tcx| {\n-                match tcx.alloc_map.lock().get(ptr.alloc_id) {\n-                    Some(interpret::AllocType::Memory(alloc)) => {\n-                        assert_eq!(len as usize as u128, len);\n-                        let slice = &alloc.bytes[(ptr.offset.bytes() as usize)..][..(len as usize)];\n-                        let s = ::std::str::from_utf8(slice)\n-                            .expect(\"non utf8 str from miri\");\n-                        write!(f, \"{:?}\", s)\n-                    }\n-                    _ => write!(f, \"pointer to erroneous constant {:?}, {:?}\", ptr, len),\n-                }\n-            })\n-        },\n+        }\n+        (Value::Scalar(Scalar::Bits { bits, .. }), &TyChar) => {\n+            write!(f, \"{:?}\", ::std::char::from_u32(bits as u32).unwrap())\n+        }\n+        (_, &TyFnDef(did, _)) => write!(f, \"{}\", item_path_str(did)),\n+        (\n+            Value::ScalarPair(Scalar::Ptr(ptr), Scalar::Bits { bits: len, .. }),\n+            &TyRef(_, &ty::TyS { sty: TyStr, .. }, _),\n+        ) => ty::tls::with(|tcx| match tcx.alloc_map.lock().get(ptr.alloc_id) {\n+            Some(interpret::AllocType::Memory(alloc)) => {\n+                assert_eq!(len as usize as u128, len);\n+                let slice = &alloc.bytes[(ptr.offset.bytes() as usize)..][..(len as usize)];\n+                let s = ::std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n+                write!(f, \"{:?}\", s)\n+            }\n+            _ => write!(f, \"pointer to erroneous constant {:?}, {:?}\", ptr, len),\n+        }),\n         _ => write!(f, \"{:?}:{}\", value, ty),\n     }\n }\n@@ -2030,21 +2225,26 @@ fn item_path_str(def_id: DefId) -> String {\n }\n \n impl<'tcx> ControlFlowGraph for Mir<'tcx> {\n-\n     type Node = BasicBlock;\n \n-    fn num_nodes(&self) -> usize { self.basic_blocks.len() }\n+    fn num_nodes(&self) -> usize {\n+        self.basic_blocks.len()\n+    }\n \n-    fn start_node(&self) -> Self::Node { START_BLOCK }\n+    fn start_node(&self) -> Self::Node {\n+        START_BLOCK\n+    }\n \n-    fn predecessors<'graph>(&'graph self, node: Self::Node)\n-                            -> <Self as GraphPredecessors<'graph>>::Iter\n-    {\n+    fn predecessors<'graph>(\n+        &'graph self,\n+        node: Self::Node,\n+    ) -> <Self as GraphPredecessors<'graph>>::Iter {\n         self.predecessors_for(node).clone().into_iter()\n     }\n-    fn successors<'graph>(&'graph self, node: Self::Node)\n-                          -> <Self as GraphSuccessors<'graph>>::Iter\n-    {\n+    fn successors<'graph>(\n+        &'graph self,\n+        node: Self::Node,\n+    ) -> <Self as GraphSuccessors<'graph>>::Iter {\n         self.basic_blocks[node].terminator().successors().cloned()\n     }\n }\n@@ -2054,7 +2254,7 @@ impl<'a, 'b> GraphPredecessors<'b> for Mir<'a> {\n     type Iter = IntoIter<BasicBlock>;\n }\n \n-impl<'a, 'b>  GraphSuccessors<'b> for Mir<'a> {\n+impl<'a, 'b> GraphSuccessors<'b> for Mir<'a> {\n     type Item = BasicBlock;\n     type Iter = iter::Cloned<Successors<'b>>;\n }\n@@ -2086,7 +2286,10 @@ impl Location {\n     /// Note that if this location represents a terminator, then the\n     /// resulting location would be out of bounds and invalid.\n     pub fn successor_within_block(&self) -> Location {\n-        Location { block: self.block, statement_index: self.statement_index + 1 }\n+        Location {\n+            block: self.block,\n+            statement_index: self.statement_index + 1,\n+        }\n     }\n \n     pub fn dominates(&self, other: Location, dominators: &Dominators<BasicBlock>) -> bool {\n@@ -2326,41 +2529,70 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n \n         let kind = match self.kind {\n             Goto { target } => Goto { target: target },\n-            SwitchInt { ref discr, switch_ty, ref values, ref targets } => SwitchInt {\n+            SwitchInt {\n+                ref discr,\n+                switch_ty,\n+                ref values,\n+                ref targets,\n+            } => SwitchInt {\n                 discr: discr.fold_with(folder),\n                 switch_ty: switch_ty.fold_with(folder),\n                 values: values.clone(),\n-                targets: targets.clone()\n+                targets: targets.clone(),\n             },\n-            Drop { ref location, target, unwind } => Drop {\n+            Drop {\n+                ref location,\n+                target,\n+                unwind,\n+            } => Drop {\n                 location: location.fold_with(folder),\n                 target,\n                 unwind,\n             },\n-            DropAndReplace { ref location, ref value, target, unwind } => DropAndReplace {\n+            DropAndReplace {\n+                ref location,\n+                ref value,\n+                target,\n+                unwind,\n+            } => DropAndReplace {\n                 location: location.fold_with(folder),\n                 value: value.fold_with(folder),\n                 target,\n                 unwind,\n             },\n-            Yield { ref value, resume, drop } => Yield {\n+            Yield {\n+                ref value,\n+                resume,\n+                drop,\n+            } => Yield {\n                 value: value.fold_with(folder),\n                 resume: resume,\n                 drop: drop,\n             },\n-            Call { ref func, ref args, ref destination, cleanup } => {\n-                let dest = destination.as_ref().map(|&(ref loc, dest)| {\n-                    (loc.fold_with(folder), dest)\n-                });\n+            Call {\n+                ref func,\n+                ref args,\n+                ref destination,\n+                cleanup,\n+            } => {\n+                let dest = destination\n+                    .as_ref()\n+                    .map(|&(ref loc, dest)| (loc.fold_with(folder), dest));\n \n                 Call {\n                     func: func.fold_with(folder),\n                     args: args.fold_with(folder),\n                     destination: dest,\n                     cleanup,\n                 }\n-            },\n-            Assert { ref cond, expected, ref msg, target, cleanup } => {\n+            }\n+            Assert {\n+                ref cond,\n+                expected,\n+                ref msg,\n+                target,\n+                cleanup,\n+            } => {\n                 let msg = if let EvalErrorKind::BoundsCheck { ref len, ref index } = *msg {\n                     EvalErrorKind::BoundsCheck {\n                         len: len.fold_with(folder),\n@@ -2376,15 +2608,26 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                     target,\n                     cleanup,\n                 }\n-            },\n+            }\n             GeneratorDrop => GeneratorDrop,\n             Resume => Resume,\n             Abort => Abort,\n             Return => Return,\n             Unreachable => Unreachable,\n-            FalseEdges { real_target, ref imaginary_targets } =>\n-                FalseEdges { real_target, imaginary_targets: imaginary_targets.clone() },\n-            FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n+            FalseEdges {\n+                real_target,\n+                ref imaginary_targets,\n+            } => FalseEdges {\n+                real_target,\n+                imaginary_targets: imaginary_targets.clone(),\n+            },\n+            FalseUnwind {\n+                real_target,\n+                unwind,\n+            } => FalseUnwind {\n+                real_target,\n+                unwind,\n+            },\n         };\n         Terminator {\n             source_info: self.source_info,\n@@ -2396,20 +2639,34 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n         use mir::TerminatorKind::*;\n \n         match self.kind {\n-            SwitchInt { ref discr, switch_ty, .. } =>\n-                discr.visit_with(visitor) || switch_ty.visit_with(visitor),\n-            Drop { ref location, ..} => location.visit_with(visitor),\n-            DropAndReplace { ref location, ref value, ..} =>\n-                location.visit_with(visitor) || value.visit_with(visitor),\n-            Yield { ref value, ..} =>\n-                value.visit_with(visitor),\n-            Call { ref func, ref args, ref destination, .. } => {\n+            SwitchInt {\n+                ref discr,\n+                switch_ty,\n+                ..\n+            } => discr.visit_with(visitor) || switch_ty.visit_with(visitor),\n+            Drop { ref location, .. } => location.visit_with(visitor),\n+            DropAndReplace {\n+                ref location,\n+                ref value,\n+                ..\n+            } => location.visit_with(visitor) || value.visit_with(visitor),\n+            Yield { ref value, .. } => value.visit_with(visitor),\n+            Call {\n+                ref func,\n+                ref args,\n+                ref destination,\n+                ..\n+            } => {\n                 let dest = if let Some((ref loc, _)) = *destination {\n                     loc.visit_with(visitor)\n-                } else { false };\n+                } else {\n+                    false\n+                };\n                 dest || func.visit_with(visitor) || args.visit_with(visitor)\n-            },\n-            Assert { ref cond, ref msg, .. } => {\n+            }\n+            Assert {\n+                ref cond, ref msg, ..\n+            } => {\n                 if cond.visit_with(visitor) {\n                     if let EvalErrorKind::BoundsCheck { ref len, ref index } = *msg {\n                         len.visit_with(visitor) || index.visit_with(visitor)\n@@ -2419,15 +2676,15 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 } else {\n                     false\n                 }\n-            },\n-            Goto { .. } |\n-            Resume |\n-            Abort |\n-            Return |\n-            GeneratorDrop |\n-            Unreachable |\n-            FalseEdges { .. } |\n-            FalseUnwind { .. } => false\n+            }\n+            Goto { .. }\n+            | Resume\n+            | Abort\n+            | Return\n+            | GeneratorDrop\n+            | Unreachable\n+            | FalseEdges { .. }\n+            | FalseUnwind { .. } => false,\n         }\n     }\n }\n@@ -2436,7 +2693,7 @@ impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match self {\n             &Place::Projection(ref p) => Place::Projection(p.fold_with(folder)),\n-            _ => self.clone()\n+            _ => self.clone(),\n         }\n     }\n \n@@ -2455,27 +2712,33 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n         match *self {\n             Use(ref op) => Use(op.fold_with(folder)),\n             Repeat(ref op, len) => Repeat(op.fold_with(folder), len),\n-            Ref(region, bk, ref place) =>\n-                Ref(region.fold_with(folder), bk, place.fold_with(folder)),\n+            Ref(region, bk, ref place) => {\n+                Ref(region.fold_with(folder), bk, place.fold_with(folder))\n+            }\n             Len(ref place) => Len(place.fold_with(folder)),\n             Cast(kind, ref op, ty) => Cast(kind, op.fold_with(folder), ty.fold_with(folder)),\n-            BinaryOp(op, ref rhs, ref lhs) =>\n-                BinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder)),\n-            CheckedBinaryOp(op, ref rhs, ref lhs) =>\n-                CheckedBinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder)),\n+            BinaryOp(op, ref rhs, ref lhs) => {\n+                BinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n+            }\n+            CheckedBinaryOp(op, ref rhs, ref lhs) => {\n+                CheckedBinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n+            }\n             UnaryOp(op, ref val) => UnaryOp(op, val.fold_with(folder)),\n             Discriminant(ref place) => Discriminant(place.fold_with(folder)),\n             NullaryOp(op, ty) => NullaryOp(op, ty.fold_with(folder)),\n             Aggregate(ref kind, ref fields) => {\n                 let kind = box match **kind {\n                     AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)),\n                     AggregateKind::Tuple => AggregateKind::Tuple,\n-                    AggregateKind::Adt(def, v, substs, n) =>\n-                        AggregateKind::Adt(def, v, substs.fold_with(folder), n),\n-                    AggregateKind::Closure(id, substs) =>\n-                        AggregateKind::Closure(id, substs.fold_with(folder)),\n-                    AggregateKind::Generator(id, substs, movablity) =>\n-                        AggregateKind::Generator(id, substs.fold_with(folder), movablity),\n+                    AggregateKind::Adt(def, v, substs, n) => {\n+                        AggregateKind::Adt(def, v, substs.fold_with(folder), n)\n+                    }\n+                    AggregateKind::Closure(id, substs) => {\n+                        AggregateKind::Closure(id, substs.fold_with(folder))\n+                    }\n+                    AggregateKind::Generator(id, substs, movablity) => {\n+                        AggregateKind::Generator(id, substs.fold_with(folder), movablity)\n+                    }\n                 };\n                 Aggregate(kind, fields.fold_with(folder))\n             }\n@@ -2490,9 +2753,9 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n             Ref(region, _, ref place) => region.visit_with(visitor) || place.visit_with(visitor),\n             Len(ref place) => place.visit_with(visitor),\n             Cast(_, ref op, ty) => op.visit_with(visitor) || ty.visit_with(visitor),\n-            BinaryOp(_, ref rhs, ref lhs) |\n-            CheckedBinaryOp(_, ref rhs, ref lhs) =>\n-                rhs.visit_with(visitor) || lhs.visit_with(visitor),\n+            BinaryOp(_, ref rhs, ref lhs) | CheckedBinaryOp(_, ref rhs, ref lhs) => {\n+                rhs.visit_with(visitor) || lhs.visit_with(visitor)\n+            }\n             UnaryOp(_, ref val) => val.visit_with(visitor),\n             Discriminant(ref place) => place.visit_with(visitor),\n             NullaryOp(_, ty) => ty.visit_with(visitor),\n@@ -2520,15 +2783,17 @@ impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            Operand::Copy(ref place) |\n-            Operand::Move(ref place) => place.visit_with(visitor),\n-            Operand::Constant(ref c) => c.visit_with(visitor)\n+            Operand::Copy(ref place) | Operand::Move(ref place) => place.visit_with(visitor),\n+            Operand::Constant(ref c) => c.visit_with(visitor),\n         }\n     }\n }\n \n impl<'tcx, B, V, T> TypeFoldable<'tcx> for Projection<'tcx, B, V, T>\n-    where B: TypeFoldable<'tcx>, V: TypeFoldable<'tcx>, T: TypeFoldable<'tcx>\n+where\n+    B: TypeFoldable<'tcx>,\n+    V: TypeFoldable<'tcx>,\n+    T: TypeFoldable<'tcx>,\n {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         use mir::ProjectionElem::*;\n@@ -2538,24 +2803,20 @@ impl<'tcx, B, V, T> TypeFoldable<'tcx> for Projection<'tcx, B, V, T>\n             Deref => Deref,\n             Field(f, ref ty) => Field(f, ty.fold_with(folder)),\n             Index(ref v) => Index(v.fold_with(folder)),\n-            ref elem => elem.clone()\n+            ref elem => elem.clone(),\n         };\n \n-        Projection {\n-            base,\n-            elem,\n-        }\n+        Projection { base, elem }\n     }\n \n     fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n         use mir::ProjectionElem::*;\n \n-        self.base.visit_with(visitor) ||\n-            match self.elem {\n-                Field(_, ref ty) => ty.visit_with(visitor),\n-                Index(ref v) => v.visit_with(visitor),\n-                _ => false\n-            }\n+        self.base.visit_with(visitor) || match self.elem {\n+            Field(_, ref ty) => ty.visit_with(visitor),\n+            Index(ref v) => v.visit_with(visitor),\n+            _ => false,\n+        }\n     }\n }\n \n@@ -2573,7 +2834,7 @@ impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n         Constant {\n             span: self.span.clone(),\n             ty: self.ty.fold_with(folder),\n-            literal: self.literal.fold_with(folder)\n+            literal: self.literal.fold_with(folder),\n         }\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n@@ -2585,15 +2846,15 @@ impl<'tcx> TypeFoldable<'tcx> for Literal<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             Literal::Value { value } => Literal::Value {\n-                value: value.fold_with(folder)\n+                value: value.fold_with(folder),\n             },\n-            Literal::Promoted { index } => Literal::Promoted { index }\n+            Literal::Promoted { index } => Literal::Promoted { index },\n         }\n     }\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n             Literal::Value { value } => value.visit_with(visitor),\n-            Literal::Promoted { .. } => false\n+            Literal::Promoted { .. } => false,\n         }\n     }\n }"}, {"sha": "320b933c23e0d372f44e4826394ee87e2d0c75e3", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -8,20 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax_pos::Span;\n+use borrow_check::WriteKind;\n use rustc::middle::region::ScopeTree;\n use rustc::mir::{BorrowKind, Field, Local, LocalKind, Location, Operand};\n use rustc::mir::{Place, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::ty::{self, RegionKind};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::sync::Lrc;\n+use syntax_pos::Span;\n \n+use super::borrow_set::BorrowData;\n use super::{Context, MirBorrowckCtxt};\n use super::{InitializationRequiringAction, PrefixSet};\n-use super::borrow_set::BorrowData;\n \n-use dataflow::{FlowAtLocation, MovingOutStatements};\n use dataflow::move_paths::MovePathIndex;\n+use dataflow::{FlowAtLocation, MovingOutStatements};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n@@ -39,22 +40,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             .collect::<Vec<_>>();\n \n         if mois.is_empty() {\n-            let root_place = self.prefixes(&place, PrefixSet::All)\n-                .last()\n-                .unwrap();\n+            let root_place = self.prefixes(&place, PrefixSet::All).last().unwrap();\n \n-            if self.moved_error_reported\n-                .contains(&root_place.clone())\n-            {\n+            if self.moved_error_reported.contains(&root_place.clone()) {\n                 debug!(\n                     \"report_use_of_moved_or_uninitialized place: error about {:?} suppressed\",\n                     root_place\n                 );\n                 return;\n             }\n \n-            self.moved_error_reported\n-                .insert(root_place.clone());\n+            self.moved_error_reported.insert(root_place.clone());\n \n             let item_msg = match self.describe_place(place) {\n                 Some(name) => format!(\"`{}`\", name),\n@@ -162,7 +158,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             format!(\"borrow of {} occurs here\", borrow_msg),\n         );\n         err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n-        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n+        self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n         err.emit();\n     }\n \n@@ -177,12 +173,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             self.retrieve_borrow_span(borrow),\n-            &self.describe_place(&borrow.borrowed_place)\n+            &self\n+                .describe_place(&borrow.borrowed_place)\n                 .unwrap_or(\"_\".to_owned()),\n             Origin::Mir,\n         );\n \n-        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n+        self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n \n         err.emit();\n     }\n@@ -286,8 +283,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"mutable\",\n         ) {\n             (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt)\n-            | (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => {\n-                tcx.cannot_reborrow_already_borrowed(\n+            | (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => tcx\n+                .cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n                     \"\",\n@@ -298,30 +295,27 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     \"\",\n                     None,\n                     Origin::Mir,\n-                )\n-            }\n+                ),\n \n-            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => {\n-                tcx.cannot_mutably_borrow_multiply(\n+            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => tcx\n+                .cannot_mutably_borrow_multiply(\n                     span,\n                     &desc_place,\n                     \"\",\n                     issued_span,\n                     \"\",\n                     None,\n                     Origin::Mir,\n-                )\n-            }\n+                ),\n \n-            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => {\n-                tcx.cannot_uniquely_borrow_by_two_closures(\n+            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => tcx\n+                .cannot_uniquely_borrow_by_two_closures(\n                     span,\n                     &desc_place,\n                     issued_span,\n                     None,\n                     Origin::Mir,\n-                )\n-            }\n+                ),\n \n             (BorrowKind::Unique, _, _, _, _, _) => tcx.cannot_uniquely_borrow_by_one_closure(\n                 span,\n@@ -334,8 +328,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 Origin::Mir,\n             ),\n \n-            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => {\n-                tcx.cannot_reborrow_already_uniquely_borrowed(\n+            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => tcx\n+                .cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     &desc_place,\n                     \"\",\n@@ -344,11 +338,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     \"\",\n                     None,\n                     Origin::Mir,\n-                )\n-            }\n+                ),\n \n-            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => {\n-                tcx.cannot_reborrow_already_uniquely_borrowed(\n+            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => tcx\n+                .cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     &desc_place,\n                     \"\",\n@@ -357,8 +350,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     \"\",\n                     None,\n                     Origin::Mir,\n-                )\n-            }\n+                ),\n \n             (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _) => unreachable!(),\n         };\n@@ -380,7 +372,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             );\n         }\n \n-        self.explain_why_borrow_contains_point(context, issued_borrow, &mut err);\n+        self.explain_why_borrow_contains_point(context, issued_borrow, None, &mut err);\n \n         err.emit();\n     }\n@@ -389,10 +381,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n-        drop_span: Span,\n+        place_span: (&Place<'tcx>, Span),\n+        kind: Option<WriteKind>,\n     ) {\n+        let drop_span = place_span.1;\n         let scope_tree = self.tcx.region_scope_tree(self.mir_def_id);\n-        let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n+        let root_place = self\n+            .prefixes(&borrow.borrowed_place, PrefixSet::All)\n             .last()\n             .unwrap();\n \n@@ -402,7 +397,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             _ => drop_span,\n         };\n \n-        if self.access_place_error_reported\n+        if self\n+            .access_place_error_reported\n             .contains(&(root_place.clone(), borrow_span))\n         {\n             debug!(\n@@ -450,6 +446,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     drop_span,\n                     borrow_span,\n                     proper_span,\n+                    kind.map(|k| (k, place_span.0)),\n                 );\n             }\n             (RegionKind::ReEarlyBound(_), None)\n@@ -471,8 +468,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             | (RegionKind::ReClosureBound(_), _)\n             | (RegionKind::ReCanonical(_), _)\n             | (RegionKind::ReErased, _) => {\n-                span_bug!(drop_span, \"region {:?} does not make sense in this context\",\n-                          borrow.region);\n+                span_bug!(\n+                    drop_span,\n+                    \"region {:?} does not make sense in this context\",\n+                    borrow.region\n+                );\n             }\n         }\n     }\n@@ -495,7 +495,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             drop_span,\n             format!(\"`{}` dropped here while still borrowed\", name),\n         );\n-        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n+        self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n         err.emit();\n     }\n \n@@ -517,7 +517,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"temporary value dropped here while still borrowed\",\n         );\n         err.note(\"consider using a `let` binding to increase its lifetime\");\n-        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n+        self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n         err.emit();\n     }\n \n@@ -530,6 +530,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         drop_span: Span,\n         borrow_span: Span,\n         _proper_span: Span,\n+        kind_place: Option<(WriteKind, &Place<'tcx>)>,\n     ) {\n         debug!(\n             \"report_unscoped_local_value_does_not_live_long_enough(\\\n@@ -544,7 +545,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.span_label(borrow_span, \"borrowed value does not live long enough\");\n         err.span_label(drop_span, \"borrowed value only lives until here\");\n \n-        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n+        self.explain_why_borrow_contains_point(context, borrow, kind_place, &mut err);\n         err.emit();\n     }\n \n@@ -570,7 +571,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.span_label(proper_span, \"temporary value does not live long enough\");\n         err.span_label(drop_span, \"temporary value only lives until here\");\n \n-        self.explain_why_borrow_contains_point(context, borrow, &mut err);\n+        self.explain_why_borrow_contains_point(context, borrow, None, &mut err);\n         err.emit();\n     }\n \n@@ -588,7 +589,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Origin::Mir,\n         );\n \n-        self.explain_why_borrow_contains_point(context, loan, &mut err);\n+        self.explain_why_borrow_contains_point(context, loan, None, &mut err);\n \n         err.emit();\n     }\n@@ -759,9 +760,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Static(ref static_) => self.describe_field_from_ty(&static_.ty, field),\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Deref => self.describe_field(&proj.base, field),\n-                ProjectionElem::Downcast(def, variant_index) => {\n-                    format!(\"{}\", def.variants[variant_index].fields[field.index()].ident)\n-                }\n+                ProjectionElem::Downcast(def, variant_index) => format!(\n+                    \"{}\",\n+                    def.variants[variant_index].fields[field.index()].ident\n+                ),\n                 ProjectionElem::Field(_, field_type) => {\n                     self.describe_field_from_ty(&field_type, field)\n                 }"}, {"sha": "3d3275a6b171485ae18cbd47e75ef9a69f16b782", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -1050,7 +1050,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             this.report_borrowed_value_does_not_live_long_enough(\n                                 context,\n                                 borrow,\n-                                place_span.1,\n+                                place_span,\n+                                Some(kind),\n                             );\n                         }\n                         WriteKind::Mutate => {\n@@ -1328,7 +1329,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             self.report_borrowed_value_does_not_live_long_enough(\n                 context,\n                 borrow,\n-                span,\n+                (place, span),\n+                None,\n             )\n         }\n     }"}, {"sha": "4f37b338e92b66e08323649868f901fb2b48b552", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 71, "deletions": 54, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::region_infer::{Cause, RegionInferenceContext};\n-use borrow_check::{Context, MirBorrowckCtxt};\n use borrow_check::borrow_set::BorrowData;\n+use borrow_check::nll::region_infer::{Cause, RegionInferenceContext};\n+use borrow_check::{Context, MirBorrowckCtxt, WriteKind};\n use rustc::mir::visit::{MirVisitable, PlaceContext, Visitor};\n-use rustc::mir::{Local, Location, Mir};\n+use rustc::mir::{Local, Location, Mir, Place};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::DiagnosticBuilder;\n use util::liveness::{self, DefUse, LivenessMode};\n@@ -22,11 +22,21 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// point from `context`. This is key for the \"3-point errors\"\n     /// [described in the NLL RFC][d].\n     ///\n+    /// # Parameters\n+    ///\n+    /// - `borrow`: the borrow in question\n+    /// - `context`: where the borrow occurs\n+    /// - `kind_place`: if Some, this describes the statement that triggered the error.\n+    ///   - first half is the kind of write, if any, being performed\n+    ///   - second half is the place being accessed\n+    /// - `err`: where the error annotations are going to be added\n+    ///\n     /// [d]: https://rust-lang.github.io/rfcs/2094-nll.html#leveraging-intuition-framing-errors-in-terms-of-points\n     pub(in borrow_check) fn explain_why_borrow_contains_point(\n         &mut self,\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n+        kind_place: Option<(WriteKind, &Place<'tcx>)>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n         let regioncx = &&self.nonlexical_regioncx;\n@@ -35,58 +45,68 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let borrow_region_vid = regioncx.to_region_vid(borrow.region);\n         if let Some(cause) = regioncx.why_region_contains_point(borrow_region_vid, context.loc) {\n             match cause {\n-                Cause::LiveVar(local, location) => {\n-                    match find_regular_use(mir, regioncx, borrow, location, local) {\n-                        Some(p) => {\n+                Cause::LiveVar(local, location) => match find_regular_use(\n+                    mir, regioncx, borrow, location, local,\n+                ) {\n+                    Some(p) => {\n+                        err.span_label(mir.source_info(p).span, format!(\"borrow later used here\"));\n+                    }\n+\n+                    None => {\n+                        span_bug!(\n+                            mir.source_info(context.loc).span,\n+                            \"Cause should end in a LiveVar\"\n+                        );\n+                    }\n+                },\n+\n+                Cause::DropVar(local, location) => match find_drop_use(\n+                    mir, regioncx, borrow, location, local,\n+                ) {\n+                    Some(p) => match &mir.local_decls[local].name {\n+                        Some(local_name) => {\n                             err.span_label(\n                                 mir.source_info(p).span,\n-                                format!(\"borrow later used here\"),\n+                                format!(\"borrow later used here, when `{}` is dropped\", local_name),\n                             );\n-                        }\n \n+                            if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n+                                if let Place::Local(borrowed_local) = place {\n+                                    let dropped_local_scope =\n+                                        mir.local_decls[local].visibility_scope;\n+                                    let borrowed_local_scope =\n+                                        mir.local_decls[*borrowed_local].visibility_scope;\n+\n+                                    if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope) {\n+                                        err.note(\n+                                            \"values in a scope are dropped \\\n+                                             in the opposite order they are defined\",\n+                                        );\n+                                    }\n+                                }\n+                            }\n+                        }\n                         None => {\n-                            span_bug!(\n-                                mir.source_info(context.loc).span,\n-                                \"Cause should end in a LiveVar\"\n+                            err.span_label(\n+                                mir.local_decls[local].source_info.span,\n+                                \"borrow may end up in a temporary, created here\",\n                             );\n-                        }\n-                    }\n-                }\n \n-                Cause::DropVar(local, location) => {\n-                    match find_drop_use(mir, regioncx, borrow, location, local) {\n-                        Some(p) => match &mir.local_decls[local].name {\n-                            Some(local_name) => {\n-                                err.span_label(\n-                                    mir.source_info(p).span,\n-                                    format!(\n-                                        \"borrow later used here, when `{}` is dropped\",\n-                                        local_name\n-                                    ),\n-                                );\n-                            }\n-                            None => {\n-                                err.span_label(\n-                                    mir.local_decls[local].source_info.span,\n-                                    \"borrow may end up in a temporary, created here\",\n-                                );\n-\n-                                err.span_label(\n-                                    mir.source_info(p).span,\n-                                    \"temporary later dropped here, \\\n-                                     potentially using the reference\",\n-                                );\n-                            }\n-                        },\n-\n-                        None => {\n-                            span_bug!(\n-                                mir.source_info(context.loc).span,\n-                                \"Cause should end in a DropVar\"\n+                            err.span_label(\n+                                mir.source_info(p).span,\n+                                \"temporary later dropped here, \\\n+                                 potentially using the reference\",\n                             );\n                         }\n+                    },\n+\n+                    None => {\n+                        span_bug!(\n+                            mir.source_info(context.loc).span,\n+                            \"Cause should end in a DropVar\"\n+                        );\n                     }\n-                }\n+                },\n \n                 Cause::UniversalRegion(region_vid) => {\n                     if let Some(region) = regioncx.to_error_region(region_vid) {\n@@ -185,15 +205,12 @@ impl<'gcx, 'tcx> UseFinder<'gcx, 'tcx> {\n                         ..p\n                     });\n                 } else {\n-                    stack.extend(\n-                        block_data\n-                            .terminator()\n-                            .successors()\n-                            .map(|&basic_block| Location {\n-                                statement_index: 0,\n-                                block: basic_block,\n-                            }),\n-                    );\n+                    stack.extend(block_data.terminator().successors().map(|&basic_block| {\n+                        Location {\n+                            statement_index: 0,\n+                            block: basic_block,\n+                        }\n+                    }));\n                 }\n             }\n         }"}, {"sha": "730ace7858bd19c572b902e4ad4ee259c1de57e7", "filename": "src/test/ui/dropck/dropck-eyepatch-extern-crate.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-extern-crate.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-extern-crate.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-extern-crate.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `dt` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n "}, {"sha": "f0df7109ba4b6bce70d48a4c5cd1958c6974a371", "filename": "src/test/ui/dropck/dropck-eyepatch-reorder.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-reorder.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-reorder.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-reorder.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `dt` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n "}, {"sha": "2072bc6a756c9f32f0045e5464172fa3e0a5a218", "filename": "src/test/ui/dropck/dropck-eyepatch.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `dt` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n "}, {"sha": "172db9ced82f9ef706d3d147f374c0574f4f0cf8", "filename": "src/test/ui/error-codes/E0597.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Ferror-codes%2FE0597.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Ferror-codes%2FE0597.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0597.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `x` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n "}, {"sha": "01a53cdd6dd4a21f9f6c696a38bc27addb0e4adc", "filename": "src/test/ui/generator/dropck.nll.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fgenerator%2Fdropck.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fgenerator%2Fdropck.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdropck.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `gen` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `ref_` does not live long enough\n   --> $DIR/dropck.rs:22:11\n@@ -26,6 +28,8 @@ LL |   }\n    |   |\n    |   borrowed value only lives until here\n    |   borrow later used here, when `gen` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b268f6e3ab014ea0c6b368b5384e4465d822b56b", "filename": "src/test/ui/span/dropck-object-cycle.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fdropck-object-cycle.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fdropck-object-cycle.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdropck-object-cycle.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `m` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n "}, {"sha": "86a4f0e13b512b07312eb58c389e10b8d4ce59ee", "filename": "src/test/ui/span/dropck_direct_cycle_with_drop.nll.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fdropck_direct_cycle_with_drop.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fdropck_direct_cycle_with_drop.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdropck_direct_cycle_with_drop.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `d1` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `d2` does not live long enough\n   --> $DIR/dropck_direct_cycle_with_drop.rs:46:19\n@@ -21,6 +23,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `d1` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0eb84e4a7d0b23394a4106bfcf2760787abc0b86", "filename": "src/test/ui/span/dropck_misc_variants.nll.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fdropck_misc_variants.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fdropck_misc_variants.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdropck_misc_variants.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -8,6 +8,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `_w` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `v` does not live long enough\n   --> $DIR/dropck_misc_variants.rs:41:27\n@@ -20,6 +22,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `_w` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ec1df8aeca15a312d1b6c4f9f6c90d7e014dd29a", "filename": "src/test/ui/span/issue-24805-dropck-child-has-items-via-parent.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue-24805-dropck-child-has-items-via-parent.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue-24805-dropck-child-has-items-via-parent.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24805-dropck-child-has-items-via-parent.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `_d` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n "}, {"sha": "288c196b27b2df2413bf402aaa644ceacc0722f8", "filename": "src/test/ui/span/issue-24805-dropck-trait-has-items.nll.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue-24805-dropck-trait-has-items.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue-24805-dropck-trait-has-items.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24805-dropck-trait-has-items.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -8,6 +8,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `_d` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `d1` does not live long enough\n   --> $DIR/issue-24805-dropck-trait-has-items.rs:53:33\n@@ -19,6 +21,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `_d` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `d1` does not live long enough\n   --> $DIR/issue-24805-dropck-trait-has-items.rs:59:20\n@@ -30,6 +34,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `_d` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to 3 previous errors\n "}, {"sha": "c89e68bcd0ae06f0ef10d18f705dbcb17b898133", "filename": "src/test/ui/span/issue-24895-copy-clone-dropck.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue-24895-copy-clone-dropck.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue-24895-copy-clone-dropck.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24895-copy-clone-dropck.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -8,6 +8,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `d2` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n "}, {"sha": "bea6dc6b3f6a06d4a46af3c71b755bb1eab14301", "filename": "src/test/ui/span/issue-26656.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue-26656.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue-26656.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-26656.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -8,6 +8,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `zook` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n "}, {"sha": "3ed13f2653ccd769a884f130c206acfe0de6fb32", "filename": "src/test/ui/span/issue28498-reject-ex1.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-ex1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-ex1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-ex1.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `foo` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n "}, {"sha": "ce9e75b44831874efa2cb710545b4d6490ffc134", "filename": "src/test/ui/span/issue28498-reject-lifetime-param.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-lifetime-param.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-lifetime-param.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-lifetime-param.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `foo1` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n "}, {"sha": "fcdc1c3f9452de27eb491f269f1328bde8f90180", "filename": "src/test/ui/span/issue28498-reject-passed-to-fn.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-passed-to-fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-passed-to-fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-passed-to-fn.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `foo1` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n "}, {"sha": "6300bb3eacd643821b1c92e8c773964651ac3bdc", "filename": "src/test/ui/span/issue28498-reject-trait-bound.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-trait-bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-trait-bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue28498-reject-trait-bound.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `foo1` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to previous error\n "}, {"sha": "6ebbf3e1ec4d22017d985637808dbe699648179d", "filename": "src/test/ui/span/send-is-not-static-std-sync.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-std-sync.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-std-sync.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-std-sync.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -63,6 +63,8 @@ LL |     }\n ...\n LL | }\n    | - borrow later used here, when `tx` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to 6 previous errors\n "}, {"sha": "9d89fac08ffe2eb0a8c7c5596065e27897c34470", "filename": "src/test/ui/span/vec_refs_data_with_early_death.nll.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fvec_refs_data_with_early_death.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d313eaeb6589c6236719a3130337676b550bada/src%2Ftest%2Fui%2Fspan%2Fvec_refs_data_with_early_death.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fvec_refs_data_with_early_death.nll.stderr?ref=7d313eaeb6589c6236719a3130337676b550bada", "patch": "@@ -9,6 +9,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `v` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error[E0597]: `x` does not live long enough\n   --> $DIR/vec_refs_data_with_early_death.rs:27:12\n@@ -21,6 +23,8 @@ LL | }\n    | |\n    | borrowed value only lives until here\n    | borrow later used here, when `v` is dropped\n+   |\n+   = note: values in a scope are dropped in the opposite order they are defined\n \n error: aborting due to 2 previous errors\n "}]}