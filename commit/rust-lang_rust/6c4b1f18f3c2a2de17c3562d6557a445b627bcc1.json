{"sha": "6c4b1f18f3c2a2de17c3562d6557a445b627bcc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNGIxZjE4ZjNjMmEyZGUxN2MzNTYyZDY1NTdhNDQ1YjYyN2JjYzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-21T03:13:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-21T03:13:49Z"}, "message": "Auto merge of #32302 - sfackler:unix-socket, r=alexcrichton\n\nAdd unix socket support to the standard library\n\nr? @alexcrichton", "tree": {"sha": "13c1f428c6c41b4a59c9836c3862d0304834e0ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13c1f428c6c41b4a59c9836c3862d0304834e0ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1", "html_url": "https://github.com/rust-lang/rust/commit/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f5c568e0ad7014eda43798fd66fb7f2b8069ff2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f5c568e0ad7014eda43798fd66fb7f2b8069ff2", "html_url": "https://github.com/rust-lang/rust/commit/7f5c568e0ad7014eda43798fd66fb7f2b8069ff2"}, {"sha": "c0d989ed6b4b840a290a80ec0cdbc8edbce2ee57", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0d989ed6b4b840a290a80ec0cdbc8edbce2ee57", "html_url": "https://github.com/rust-lang/rust/commit/c0d989ed6b4b840a290a80ec0cdbc8edbce2ee57"}], "stats": {"total": 1196, "additions": 1141, "deletions": 55}, "files": [{"sha": "96534f817f80e3f2e1c9ab0bf2259650aed8897c", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 3, "deletions": 34, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=6c4b1f18f3c2a2de17c3562d6557a445b627bcc1", "patch": "@@ -1457,12 +1457,12 @@ mod tests {\n     use prelude::v1::*;\n     use io::prelude::*;\n \n-    use env;\n     use fs::{self, File, OpenOptions};\n     use io::{ErrorKind, SeekFrom};\n-    use path::{Path, PathBuf};\n-    use rand::{self, StdRng, Rng};\n+    use path::Path;\n+    use rand::{StdRng, Rng};\n     use str;\n+    use sys_common::io::test::{TempDir, tmpdir};\n \n     #[cfg(windows)]\n     use os::windows::fs::{symlink_dir, symlink_file};\n@@ -1490,37 +1490,6 @@ mod tests {\n         }\n     ) }\n \n-    pub struct TempDir(PathBuf);\n-\n-    impl TempDir {\n-        fn join(&self, path: &str) -> PathBuf {\n-            let TempDir(ref p) = *self;\n-            p.join(path)\n-        }\n-\n-        fn path<'a>(&'a self) -> &'a Path {\n-            let TempDir(ref p) = *self;\n-            p\n-        }\n-    }\n-\n-    impl Drop for TempDir {\n-        fn drop(&mut self) {\n-            // Gee, seeing how we're testing the fs module I sure hope that we\n-            // at least implement this correctly!\n-            let TempDir(ref p) = *self;\n-            check!(fs::remove_dir_all(p));\n-        }\n-    }\n-\n-    pub fn tmpdir() -> TempDir {\n-        let p = env::temp_dir();\n-        let mut r = rand::thread_rng();\n-        let ret = p.join(&format!(\"rust-{}\", r.next_u32()));\n-        check!(fs::create_dir(&ret));\n-        TempDir(ret)\n-    }\n-\n     // Several test fail on windows if the user does not have permission to\n     // create symlinks (the `SeCreateSymbolicLinkPrivilege`). Instead of\n     // disabling these test on Windows, use this function to test whether we"}, {"sha": "7b08852ba51d1fbfa8fa5d451bffcd6f851204df", "filename": "src/libstd/sys/common/io.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs?ref=6c4b1f18f3c2a2de17c3562d6557a445b627bcc1", "patch": "@@ -51,14 +51,53 @@ pub unsafe fn read_to_end_uninitialized(r: &mut Read, buf: &mut Vec<u8>) -> io::\n     }\n }\n \n+#[cfg(test)]\n+pub mod test {\n+    use prelude::v1::*;\n+    use path::{Path, PathBuf};\n+    use env;\n+    use rand::{self, Rng};\n+    use fs;\n+\n+    pub struct TempDir(PathBuf);\n+\n+    impl TempDir {\n+        pub fn join(&self, path: &str) -> PathBuf {\n+            let TempDir(ref p) = *self;\n+            p.join(path)\n+        }\n+\n+        pub fn path<'a>(&'a self) -> &'a Path {\n+            let TempDir(ref p) = *self;\n+            p\n+        }\n+    }\n+\n+    impl Drop for TempDir {\n+        fn drop(&mut self) {\n+            // Gee, seeing how we're testing the fs module I sure hope that we\n+            // at least implement this correctly!\n+            let TempDir(ref p) = *self;\n+            fs::remove_dir_all(p).unwrap();\n+        }\n+    }\n+\n+    pub fn tmpdir() -> TempDir {\n+        let p = env::temp_dir();\n+        let mut r = rand::thread_rng();\n+        let ret = p.join(&format!(\"rust-{}\", r.next_u32()));\n+        fs::create_dir(&ret).unwrap();\n+        TempDir(ret)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n     use io::prelude::*;\n     use super::*;\n     use io;\n     use io::{ErrorKind, Take, Repeat, repeat};\n-    use test;\n     use slice::from_raw_parts;\n \n     struct ErrorRepeat {\n@@ -129,7 +168,7 @@ mod tests {\n     }\n \n     #[bench]\n-    fn bench_uninitialized(b: &mut test::Bencher) {\n+    fn bench_uninitialized(b: &mut ::test::Bencher) {\n         b.iter(|| {\n             let mut lr = repeat(1).take(10000000);\n             let mut vec = Vec::with_capacity(1024);"}, {"sha": "3fa70d0ce4be6b9a0e32233ca5468d0b63f7a550", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=6c4b1f18f3c2a2de17c3562d6557a445b627bcc1", "patch": "@@ -257,12 +257,7 @@ impl TcpStream {\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        let raw: c_int = try!(getsockopt(&self.inner, c::SOL_SOCKET, c::SO_ERROR));\n-        if raw == 0 {\n-            Ok(None)\n-        } else {\n-            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n-        }\n+        self.inner.take_error()\n     }\n \n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n@@ -367,12 +362,7 @@ impl TcpListener {\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        let raw: c_int = try!(getsockopt(&self.inner, c::SOL_SOCKET, c::SO_ERROR));\n-        if raw == 0 {\n-            Ok(None)\n-        } else {\n-            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n-        }\n+        self.inner.take_error()\n     }\n \n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n@@ -564,12 +554,7 @@ impl UdpSocket {\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        let raw: c_int = try!(getsockopt(&self.inner, c::SOL_SOCKET, c::SO_ERROR));\n-        if raw == 0 {\n-            Ok(None)\n-        } else {\n-            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n-        }\n+        self.inner.take_error()\n     }\n \n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {"}, {"sha": "4d8f12c2d7c42f2bf0f3d2c38f2cb444d0a21bd3", "filename": "src/libstd/sys/unix/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs?ref=6c4b1f18f3c2a2de17c3562d6557a445b627bcc1", "patch": "@@ -35,6 +35,7 @@ pub mod fs;\n pub mod process;\n pub mod raw;\n pub mod thread;\n+pub mod net;\n \n /// A prelude for conveniently writing platform-specific code.\n ///"}, {"sha": "2ee825f1ec2908c5af429f70eb297ee7d759d632", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "added", "additions": 1042, "deletions": 0, "changes": 1042, "blob_url": "https://github.com/rust-lang/rust/blob/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=6c4b1f18f3c2a2de17c3562d6557a445b627bcc1", "patch": "@@ -0,0 +1,1042 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![unstable(feature = \"unix_socket\", reason = \"newly added\", issue = \"32312\")]\n+\n+//! Unix-specific networking functionality\n+\n+use libc;\n+\n+use prelude::v1::*;\n+use ascii;\n+use ffi::OsStr;\n+use fmt;\n+use io;\n+use mem;\n+use net::Shutdown;\n+use os::unix::ffi::OsStrExt;\n+use os::unix::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n+use path::Path;\n+use time::Duration;\n+use sys::cvt;\n+use sys::net::Socket;\n+use sys_common::{AsInner, FromInner, IntoInner};\n+\n+fn sun_path_offset() -> usize {\n+    unsafe {\n+        // Work with an actual instance of the type since using a null pointer is UB\n+        let addr: libc::sockaddr_un = mem::uninitialized();\n+        let base = &addr as *const _ as usize;\n+        let path = &addr.sun_path as *const _ as usize;\n+        path - base\n+    }\n+}\n+\n+unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::socklen_t)> {\n+    let mut addr: libc::sockaddr_un = mem::zeroed();\n+    addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n+\n+    let bytes = path.as_os_str().as_bytes();\n+\n+    if bytes.contains(&0) {\n+        return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                  \"paths may not contain interior null bytes\"));\n+    }\n+\n+    if bytes.len() >= addr.sun_path.len() {\n+        return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                  \"path must be shorter than SUN_LEN\"));\n+    }\n+    for (dst, src) in addr.sun_path.iter_mut().zip(bytes.iter()) {\n+        *dst = *src as libc::c_char;\n+    }\n+    // null byte for pathname addresses is already there because we zeroed the\n+    // struct\n+\n+    let mut len = sun_path_offset() + bytes.len();\n+    match bytes.get(0) {\n+        Some(&0) | None => {}\n+        Some(_) => len += 1,\n+    }\n+    Ok((addr, len as libc::socklen_t))\n+}\n+\n+enum AddressKind<'a> {\n+    Unnamed,\n+    Pathname(&'a Path),\n+    Abstract(&'a [u8]),\n+}\n+\n+/// An address associated with a Unix socket.\n+#[derive(Clone)]\n+pub struct SocketAddr {\n+    addr: libc::sockaddr_un,\n+    len: libc::socklen_t,\n+}\n+\n+impl SocketAddr {\n+    fn new<F>(f: F) -> io::Result<SocketAddr>\n+        where F: FnOnce(*mut libc::sockaddr, *mut libc::socklen_t) -> libc::c_int\n+    {\n+        unsafe {\n+            let mut addr: libc::sockaddr_un = mem::zeroed();\n+            let mut len = mem::size_of::<libc::sockaddr_un>() as libc::socklen_t;\n+            try!(cvt(f(&mut addr as *mut _ as *mut _, &mut len)));\n+            SocketAddr::from_parts(addr, len)\n+        }\n+    }\n+\n+    fn from_parts(addr: libc::sockaddr_un, mut len: libc::socklen_t) -> io::Result<SocketAddr> {\n+        if len == 0 {\n+            // When there is a datagram from unnamed unix socket\n+            // linux returns zero bytes of address\n+            len = sun_path_offset() as libc::socklen_t;  // i.e. zero-length address\n+        } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n+            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                      \"file descriptor did not correspond to a Unix socket\"));\n+        }\n+\n+        Ok(SocketAddr {\n+            addr: addr,\n+            len: len,\n+        })\n+    }\n+\n+    /// Returns true iff the address is unnamed.\n+    pub fn is_unnamed(&self) -> bool {\n+        if let AddressKind::Unnamed = self.address() {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Returns the contents of this address if it is a `pathname` address.\n+    pub fn as_pathname(&self) -> Option<&Path> {\n+        if let AddressKind::Pathname(path) = self.address() {\n+            Some(path)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn address<'a>(&'a self) -> AddressKind<'a> {\n+        let len = self.len as usize - sun_path_offset();\n+        let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n+\n+        // OSX seems to return a len of 16 and a zeroed sun_path for unnamed addresses\n+        if len == 0 || (cfg!(not(target_os = \"linux\")) && self.addr.sun_path[0] == 0) {\n+            AddressKind::Unnamed\n+        } else if self.addr.sun_path[0] == 0 {\n+            AddressKind::Abstract(&path[1..len])\n+        } else {\n+            AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for SocketAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match self.address() {\n+            AddressKind::Unnamed => write!(fmt, \"(unnamed)\"),\n+            AddressKind::Abstract(name) => write!(fmt, \"{} (abstract)\", AsciiEscaped(name)),\n+            AddressKind::Pathname(path) => write!(fmt, \"{:?} (pathname)\", path),\n+        }\n+    }\n+}\n+\n+struct AsciiEscaped<'a>(&'a [u8]);\n+\n+impl<'a> fmt::Display for AsciiEscaped<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(fmt, \"\\\"\"));\n+        for byte in self.0.iter().cloned().flat_map(ascii::escape_default) {\n+            try!(write!(fmt, \"{}\", byte as char));\n+        }\n+        write!(fmt, \"\\\"\")\n+    }\n+}\n+\n+/// A Unix stream socket.\n+///\n+/// # Examples\n+///\n+/// ```rust,no_run\n+/// #![feature(unix_socket)]\n+///\n+/// use std::os::unix::net::UnixStream;\n+/// use std::io::prelude::*;\n+///\n+/// let mut stream = UnixStream::connect(\"/path/to/my/socket\").unwrap();\n+/// stream.write_all(b\"hello world\").unwrap();\n+/// let mut response = String::new();\n+/// stream.read_to_string(&mut response).unwrap();\n+/// println!(\"{}\", response);\n+/// ```\n+pub struct UnixStream(Socket);\n+\n+impl fmt::Debug for UnixStream {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixStream\");\n+        builder.field(\"fd\", self.0.as_inner());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        if let Ok(addr) = self.peer_addr() {\n+            builder.field(\"peer\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixStream {\n+    /// Connects to the socket named by `path`.\n+    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n+        fn inner(path: &Path) -> io::Result<UnixStream> {\n+            unsafe {\n+                let inner = try!(Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM));\n+                let (addr, len) = try!(sockaddr_un(path));\n+\n+                try!(cvt(libc::connect(*inner.as_inner(), &addr as *const _ as *const _, len)));\n+                Ok(UnixStream(inner))\n+            }\n+        }\n+        inner(path.as_ref())\n+    }\n+\n+    /// Creates an unnamed pair of connected sockets.\n+    ///\n+    /// Returns two `UnixStream`s which are connected to each other.\n+    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n+        let (i1, i2) = try!(Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM));\n+        Ok((UnixStream(i1), UnixStream(i2)))\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixStream` is a reference to the same stream that this\n+    /// object references. Both handles will read and write the same stream of\n+    /// data, and options set on one stream will be propogated to the other\n+    /// stream.\n+    pub fn try_clone(&self) -> io::Result<UnixStream> {\n+        self.0.duplicate().map(UnixStream)\n+    }\n+\n+    /// Returns the socket address of the local half of this connection.\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Returns the socket address of the remote half of this connection.\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Sets the read timeout for the socket.\n+    ///\n+    /// If the provided value is `None`, then `read` calls will block\n+    /// indefinitely. It is an error to pass the zero `Duration` to this\n+    /// method.\n+    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Sets the write timeout for the socket.\n+    ///\n+    /// If the provided value is `None`, then `write` calls will block\n+    /// indefinitely. It is an error to pass the zero `Duration` to this\n+    /// method.\n+    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Returns the read timeout of this socket.\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Returns the write timeout of this socket.\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Shuts down the read, write, or both halves of this connection.\n+    ///\n+    /// This function will cause all pending and future I/O calls on the\n+    /// specified portions to immediately return with an appropriate value\n+    /// (see the documentation of `Shutdown`).\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        self.0.shutdown(how)\n+    }\n+}\n+\n+impl io::Read for UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        io::Read::read(&mut &*self, buf)\n+    }\n+\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        io::Read::read_to_end(&mut &*self, buf)\n+    }\n+}\n+\n+impl<'a> io::Read for &'a UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        self.0.read_to_end(buf)\n+    }\n+}\n+\n+impl io::Write for UnixStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        io::Write::write(&mut &*self, buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        io::Write::flush(&mut &*self)\n+    }\n+}\n+\n+impl<'a> io::Write for &'a UnixStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl AsRawFd for UnixStream {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.0.as_inner()\n+    }\n+}\n+\n+impl FromRawFd for UnixStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n+        UnixStream(Socket::from_inner(fd))\n+    }\n+}\n+\n+impl IntoRawFd for UnixStream {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_inner()\n+    }\n+}\n+\n+/// A structure representing a Unix domain socket server.\n+///\n+/// # Examples\n+///\n+/// ```rust,no_run\n+/// #![feature(unix_socket)]\n+///\n+/// use std::thread;\n+/// use std::os::unix::net::{UnixStream, UnixListener};\n+///\n+/// fn handle_client(stream: UnixStream) {\n+///     // ...\n+/// }\n+///\n+/// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n+///\n+/// // accept connections and process them, spawning a new thread for each one\n+/// for stream in listener.incoming() {\n+///     match stream {\n+///         Ok(stream) => {\n+///             /* connection succeeded */\n+///             thread::spawn(|| handle_client(stream));\n+///         }\n+///         Err(err) => {\n+///             /* connection failed */\n+///             break;\n+///         }\n+///     }\n+/// }\n+///\n+/// // close the listener socket\n+/// drop(listener);\n+/// ```\n+pub struct UnixListener(Socket);\n+\n+impl fmt::Debug for UnixListener {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixListener\");\n+        builder.field(\"fd\", self.0.as_inner());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixListener {\n+    /// Creates a new `UnixListener` bound to the specified socket.\n+    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n+        fn inner(path: &Path) -> io::Result<UnixListener> {\n+            unsafe {\n+                let inner = try!(Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM));\n+                let (addr, len) = try!(sockaddr_un(path));\n+\n+                try!(cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len)));\n+                try!(cvt(libc::listen(*inner.as_inner(), 128)));\n+\n+                Ok(UnixListener(inner))\n+            }\n+        }\n+        inner(path.as_ref())\n+    }\n+\n+    /// Accepts a new incoming connection to this listener.\n+    ///\n+    /// This function will block the calling thread until a new Unix connection\n+    /// is established. When established, the corersponding `UnixStream` and\n+    /// the remote peer's address will be returned.\n+    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n+        let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n+        let mut len = mem::size_of_val(&storage) as libc::socklen_t;\n+        let sock = try!(self.0.accept(&mut storage as *mut _ as *mut _, &mut len));\n+        let addr = try!(SocketAddr::from_parts(storage, len));\n+        Ok((UnixStream(sock), addr))\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixListener` is a reference to the same socket that this\n+    /// object references. Both handles can be used to accept incoming\n+    /// connections and options set on one listener will affect the other.\n+    pub fn try_clone(&self) -> io::Result<UnixListener> {\n+        self.0.duplicate().map(UnixListener)\n+    }\n+\n+    /// Returns the local socket address of this listener.\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Returns an iterator over incoming connections.\n+    ///\n+    /// The iterator will never return `None` and will also not yield the\n+    /// peer's `SocketAddr` structure.\n+    pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n+        Incoming { listener: self }\n+    }\n+}\n+\n+impl AsRawFd for UnixListener {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.0.as_inner()\n+    }\n+}\n+\n+impl FromRawFd for UnixListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n+        UnixListener(Socket::from_inner(fd))\n+    }\n+}\n+\n+impl IntoRawFd for UnixListener {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_inner()\n+    }\n+}\n+\n+impl<'a> IntoIterator for &'a UnixListener {\n+    type Item = io::Result<UnixStream>;\n+    type IntoIter = Incoming<'a>;\n+\n+    fn into_iter(self) -> Incoming<'a> {\n+        self.incoming()\n+    }\n+}\n+\n+/// An iterator over incoming connections to a `UnixListener`.\n+///\n+/// It will never return `None`.\n+#[derive(Debug)]\n+pub struct Incoming<'a> {\n+    listener: &'a UnixListener,\n+}\n+\n+impl<'a> Iterator for Incoming<'a> {\n+    type Item = io::Result<UnixStream>;\n+\n+    fn next(&mut self) -> Option<io::Result<UnixStream>> {\n+        Some(self.listener.accept().map(|s| s.0))\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::max_value(), None)\n+    }\n+}\n+\n+/// A Unix datagram socket.\n+///\n+/// # Examples\n+///\n+/// ```rust,no_run\n+/// #![feature(unix_socket)]\n+///\n+/// use std::os::unix::net::UnixDatagram;\n+///\n+/// let socket = UnixDatagram::bind(\"/path/to/my/socket\").unwrap();\n+/// socket.send_to(b\"hello world\", \"/path/to/other/socket\").unwrap();\n+/// let mut buf = [0; 100];\n+/// let (count, address) = socket.recv_from(&mut buf).unwrap();\n+/// println!(\"socket {:?} sent {:?}\", address, &buf[..count]);\n+/// ```\n+pub struct UnixDatagram(Socket);\n+\n+impl fmt::Debug for UnixDatagram {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixDatagram\");\n+        builder.field(\"fd\", self.0.as_inner());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        if let Ok(addr) = self.peer_addr() {\n+            builder.field(\"peer\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixDatagram {\n+    /// Creates a Unix datagram socket bound to the given path.\n+    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> {\n+        fn inner(path: &Path) -> io::Result<UnixDatagram> {\n+            unsafe {\n+                let socket = try!(UnixDatagram::unbound());\n+                let (addr, len) = try!(sockaddr_un(path));\n+\n+                try!(cvt(libc::bind(*socket.0.as_inner(), &addr as *const _ as *const _, len)));\n+\n+                Ok(socket)\n+            }\n+        }\n+        inner(path.as_ref())\n+    }\n+\n+    /// Creates a Unix Datagram socket which is not bound to any address.\n+    pub fn unbound() -> io::Result<UnixDatagram> {\n+        let inner = try!(Socket::new_raw(libc::AF_UNIX, libc::SOCK_DGRAM));\n+        Ok(UnixDatagram(inner))\n+    }\n+\n+    /// Create an unnamed pair of connected sockets.\n+    ///\n+    /// Returns two `UnixDatagrams`s which are connected to each other.\n+    pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> {\n+        let (i1, i2) = try!(Socket::new_pair(libc::AF_UNIX, libc::SOCK_DGRAM));\n+        Ok((UnixDatagram(i1), UnixDatagram(i2)))\n+    }\n+\n+    /// Connects the socket to the specified address.\n+    ///\n+    /// The `send` method may be used to send data to the specified address.\n+    /// `recv` and `recv_from` will only receive data from that address.\n+    pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n+        fn inner(d: &UnixDatagram, path: &Path) -> io::Result<()> {\n+            unsafe {\n+                let (addr, len) = try!(sockaddr_un(path));\n+\n+                try!(cvt(libc::connect(*d.0.as_inner(), &addr as *const _ as *const _, len)));\n+\n+                Ok(())\n+            }\n+        }\n+        inner(self, path.as_ref())\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixListener` is a reference to the same socket that this\n+    /// object references. Both handles can be used to accept incoming\n+    /// connections and options set on one listener will affect the other.\n+    pub fn try_clone(&self) -> io::Result<UnixDatagram> {\n+        self.0.duplicate().map(UnixDatagram)\n+    }\n+\n+    /// Returns the address of this socket.\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Returns the address of this socket's peer.\n+    ///\n+    /// The `connect` method will connect the socket to a peer.\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Receives data from the socket.\n+    ///\n+    /// On success, returns the number of bytes read and the address from\n+    /// whence the data came.\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        let mut count = 0;\n+        let addr = try!(SocketAddr::new(|addr, len| {\n+            unsafe {\n+                count = libc::recvfrom(*self.0.as_inner(),\n+                                       buf.as_mut_ptr() as *mut _,\n+                                       buf.len(),\n+                                       0,\n+                                       addr,\n+                                       len);\n+                if count > 0 {\n+                    1\n+                } else if count == 0 {\n+                    0\n+                } else {\n+                    -1\n+                }\n+            }\n+        }));\n+\n+        Ok((count as usize, addr))\n+    }\n+\n+    /// Receives data from the socket.\n+    ///\n+    /// On success, returns the number of bytes read.\n+    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    /// Sends data on the socket to the specified address.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> {\n+        fn inner(d: &UnixDatagram, buf: &[u8], path: &Path) -> io::Result<usize> {\n+            unsafe {\n+                let (addr, len) = try!(sockaddr_un(path));\n+\n+                let count = try!(cvt(libc::sendto(*d.0.as_inner(),\n+                                                  buf.as_ptr() as *const _,\n+                                                  buf.len(),\n+                                                  0,\n+                                                  &addr as *const _ as *const _,\n+                                                  len)));\n+                Ok(count as usize)\n+            }\n+        }\n+        inner(self, buf, path.as_ref())\n+    }\n+\n+    /// Sends data on the socket to the socket's peer.\n+    ///\n+    /// The peer address may be set by the `connect` method, and this method\n+    /// will return an error if the socket has not already been connected.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    /// Sets the read timeout for the socket.\n+    ///\n+    /// If the provided value is `None`, then `recv` and `recv_from` calls will\n+    /// block indefinitely. It is an error to pass the zero `Duration` to this\n+    /// method.\n+    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Sets the write timeout for the socket.\n+    ///\n+    /// If the provided value is `None`, then `send` and `send_to` calls will\n+    /// block indefinitely. It is an error to pass the zero `Duration` to this\n+    /// method.\n+    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Returns the read timeout of this socket.\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Returns the write timeout of this socket.\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Shut down the read, write, or both halves of this connection.\n+    ///\n+    /// This function will cause all pending and future I/O calls on the\n+    /// specified portions to immediately return with an appropriate value\n+    /// (see the documentation of `Shutdown`).\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        self.0.shutdown(how)\n+    }\n+}\n+\n+impl AsRawFd for UnixDatagram {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.0.as_inner()\n+    }\n+}\n+\n+impl FromRawFd for UnixDatagram {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixDatagram {\n+        UnixDatagram(Socket::from_inner(fd))\n+    }\n+}\n+\n+impl IntoRawFd for UnixDatagram {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_inner()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::v1::*;\n+    use thread;\n+    use io;\n+    use io::prelude::*;\n+    use time::Duration;\n+    use sys_common::io::test::tmpdir;\n+\n+    use super::*;\n+\n+    macro_rules! or_panic {\n+        ($e:expr) => {\n+            match $e {\n+                Ok(e) => e,\n+                Err(e) => panic!(\"{}\", e),\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn basic() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path().join(\"sock\");\n+        let msg1 = b\"hello\";\n+        let msg2 = b\"world!\";\n+\n+        let listener = or_panic!(UnixListener::bind(&socket_path));\n+        let thread = thread::spawn(move || {\n+            let mut stream = or_panic!(listener.accept()).0;\n+            let mut buf = [0; 5];\n+            or_panic!(stream.read(&mut buf));\n+            assert_eq!(&msg1[..], &buf[..]);\n+            or_panic!(stream.write_all(msg2));\n+        });\n+\n+        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n+        assert_eq!(Some(&*socket_path),\n+                   stream.peer_addr().unwrap().as_pathname());\n+        or_panic!(stream.write_all(msg1));\n+        let mut buf = vec![];\n+        or_panic!(stream.read_to_end(&mut buf));\n+        assert_eq!(&msg2[..], &buf[..]);\n+        drop(stream);\n+\n+        thread.join().unwrap();\n+    }\n+\n+    #[test]\n+    fn pair() {\n+        let msg1 = b\"hello\";\n+        let msg2 = b\"world!\";\n+\n+        let (mut s1, mut s2) = or_panic!(UnixStream::pair());\n+        let thread = thread::spawn(move || {\n+            // s1 must be moved in or the test will hang!\n+            let mut buf = [0; 5];\n+            or_panic!(s1.read(&mut buf));\n+            assert_eq!(&msg1[..], &buf[..]);\n+            or_panic!(s1.write_all(msg2));\n+        });\n+\n+        or_panic!(s2.write_all(msg1));\n+        let mut buf = vec![];\n+        or_panic!(s2.read_to_end(&mut buf));\n+        assert_eq!(&msg2[..], &buf[..]);\n+        drop(s2);\n+\n+        thread.join().unwrap();\n+    }\n+\n+    #[test]\n+    fn try_clone() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path().join(\"sock\");\n+        let msg1 = b\"hello\";\n+        let msg2 = b\"world\";\n+\n+        let listener = or_panic!(UnixListener::bind(&socket_path));\n+        let thread = thread::spawn(move || {\n+            let mut stream = or_panic!(listener.accept()).0;\n+            or_panic!(stream.write_all(msg1));\n+            or_panic!(stream.write_all(msg2));\n+        });\n+\n+        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n+        let mut stream2 = or_panic!(stream.try_clone());\n+\n+        let mut buf = [0; 5];\n+        or_panic!(stream.read(&mut buf));\n+        assert_eq!(&msg1[..], &buf[..]);\n+        or_panic!(stream2.read(&mut buf));\n+        assert_eq!(&msg2[..], &buf[..]);\n+\n+        thread.join().unwrap();\n+    }\n+\n+    #[test]\n+    fn iter() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path().join(\"sock\");\n+\n+        let listener = or_panic!(UnixListener::bind(&socket_path));\n+        let thread = thread::spawn(move || {\n+            for stream in listener.incoming().take(2) {\n+                let mut stream = or_panic!(stream);\n+                let mut buf = [0];\n+                or_panic!(stream.read(&mut buf));\n+            }\n+        });\n+\n+        for _ in 0..2 {\n+            let mut stream = or_panic!(UnixStream::connect(&socket_path));\n+            or_panic!(stream.write_all(&[0]));\n+        }\n+\n+        thread.join().unwrap();\n+    }\n+\n+    #[test]\n+    fn long_path() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path()\n+                             .join(\"asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfa\\\n+                                    sasdfasdfasdasdfasdfasdfadfasdfasdfasdfasdfasdf\");\n+        match UnixStream::connect(&socket_path) {\n+            Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n+            Err(e) => panic!(\"unexpected error {}\", e),\n+            Ok(_) => panic!(\"unexpected success\"),\n+        }\n+\n+        match UnixListener::bind(&socket_path) {\n+            Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n+            Err(e) => panic!(\"unexpected error {}\", e),\n+            Ok(_) => panic!(\"unexpected success\"),\n+        }\n+\n+        match UnixDatagram::bind(&socket_path) {\n+            Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n+            Err(e) => panic!(\"unexpected error {}\", e),\n+            Ok(_) => panic!(\"unexpected success\"),\n+        }\n+    }\n+\n+    #[test]\n+    fn timeouts() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path().join(\"sock\");\n+\n+        let _listener = or_panic!(UnixListener::bind(&socket_path));\n+\n+        let stream = or_panic!(UnixStream::connect(&socket_path));\n+        let dur = Duration::new(15410, 0);\n+\n+        assert_eq!(None, or_panic!(stream.read_timeout()));\n+\n+        or_panic!(stream.set_read_timeout(Some(dur)));\n+        assert_eq!(Some(dur), or_panic!(stream.read_timeout()));\n+\n+        assert_eq!(None, or_panic!(stream.write_timeout()));\n+\n+        or_panic!(stream.set_write_timeout(Some(dur)));\n+        assert_eq!(Some(dur), or_panic!(stream.write_timeout()));\n+\n+        or_panic!(stream.set_read_timeout(None));\n+        assert_eq!(None, or_panic!(stream.read_timeout()));\n+\n+        or_panic!(stream.set_write_timeout(None));\n+        assert_eq!(None, or_panic!(stream.write_timeout()));\n+    }\n+\n+    #[test]\n+    fn test_read_timeout() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path().join(\"sock\");\n+\n+        let _listener = or_panic!(UnixListener::bind(&socket_path));\n+\n+        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n+        or_panic!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n+\n+        let mut buf = [0; 10];\n+        let kind = stream.read(&mut buf).err().expect(\"expected error\").kind();\n+        assert!(kind == io::ErrorKind::WouldBlock || kind == io::ErrorKind::TimedOut);\n+    }\n+\n+    #[test]\n+    fn test_read_with_timeout() {\n+        let dir = tmpdir();\n+        let socket_path = dir.path().join(\"sock\");\n+\n+        let listener = or_panic!(UnixListener::bind(&socket_path));\n+\n+        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n+        or_panic!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n+\n+        let mut other_end = or_panic!(listener.accept()).0;\n+        or_panic!(other_end.write_all(b\"hello world\"));\n+\n+        let mut buf = [0; 11];\n+        or_panic!(stream.read(&mut buf));\n+        assert_eq!(b\"hello world\", &buf[..]);\n+\n+        let kind = stream.read(&mut buf).err().expect(\"expected error\").kind();\n+        assert!(kind == io::ErrorKind::WouldBlock || kind == io::ErrorKind::TimedOut);\n+    }\n+\n+    #[test]\n+    fn test_unix_datagram() {\n+        let dir = tmpdir();\n+        let path1 = dir.path().join(\"sock1\");\n+        let path2 = dir.path().join(\"sock2\");\n+\n+        let sock1 = or_panic!(UnixDatagram::bind(&path1));\n+        let sock2 = or_panic!(UnixDatagram::bind(&path2));\n+\n+        let msg = b\"hello world\";\n+        or_panic!(sock1.send_to(msg, &path2));\n+        let mut buf = [0; 11];\n+        or_panic!(sock2.recv_from(&mut buf));\n+        assert_eq!(msg, &buf[..]);\n+    }\n+\n+    #[test]\n+    fn test_unnamed_unix_datagram() {\n+        let dir = tmpdir();\n+        let path1 = dir.path().join(\"sock1\");\n+\n+        let sock1 = or_panic!(UnixDatagram::bind(&path1));\n+        let sock2 = or_panic!(UnixDatagram::unbound());\n+\n+        let msg = b\"hello world\";\n+        or_panic!(sock2.send_to(msg, &path1));\n+        let mut buf = [0; 11];\n+        let (usize, addr) = or_panic!(sock1.recv_from(&mut buf));\n+        assert_eq!(usize, 11);\n+        assert!(addr.is_unnamed());\n+        assert_eq!(msg, &buf[..]);\n+    }\n+\n+    #[test]\n+    fn test_connect_unix_datagram() {\n+        let dir = tmpdir();\n+        let path1 = dir.path().join(\"sock1\");\n+        let path2 = dir.path().join(\"sock2\");\n+\n+        let bsock1 = or_panic!(UnixDatagram::bind(&path1));\n+        let bsock2 = or_panic!(UnixDatagram::bind(&path2));\n+        let sock = or_panic!(UnixDatagram::unbound());\n+        or_panic!(sock.connect(&path1));\n+\n+        // Check send()\n+        let msg = b\"hello there\";\n+        or_panic!(sock.send(msg));\n+        let mut buf = [0; 11];\n+        let (usize, addr) = or_panic!(bsock1.recv_from(&mut buf));\n+        assert_eq!(usize, 11);\n+        assert!(addr.is_unnamed());\n+        assert_eq!(msg, &buf[..]);\n+\n+        // Changing default socket works too\n+        or_panic!(sock.connect(&path2));\n+        or_panic!(sock.send(msg));\n+        or_panic!(bsock2.recv_from(&mut buf));\n+    }\n+\n+    #[test]\n+    fn test_unix_datagram_recv() {\n+        let dir = tmpdir();\n+        let path1 = dir.path().join(\"sock1\");\n+\n+        let sock1 = or_panic!(UnixDatagram::bind(&path1));\n+        let sock2 = or_panic!(UnixDatagram::unbound());\n+        or_panic!(sock2.connect(&path1));\n+\n+        let msg = b\"hello world\";\n+        or_panic!(sock2.send(msg));\n+        let mut buf = [0; 11];\n+        let size = or_panic!(sock1.recv(&mut buf));\n+        assert_eq!(size, 11);\n+        assert_eq!(msg, &buf[..]);\n+    }\n+\n+    #[test]\n+    fn datagram_pair() {\n+        let msg1 = b\"hello\";\n+        let msg2 = b\"world!\";\n+\n+        let (s1, s2) = or_panic!(UnixDatagram::pair());\n+        let thread = thread::spawn(move || {\n+            // s1 must be moved in or the test will hang!\n+            let mut buf = [0; 5];\n+            or_panic!(s1.recv(&mut buf));\n+            assert_eq!(&msg1[..], &buf[..]);\n+            or_panic!(s1.send(msg2));\n+        });\n+\n+        or_panic!(s2.send(msg1));\n+        let mut buf = [0; 6];\n+        or_panic!(s2.recv(&mut buf));\n+        assert_eq!(&msg2[..], &buf[..]);\n+        drop(s2);\n+\n+        thread.join().unwrap();\n+    }\n+\n+    #[test]\n+    fn abstract_namespace_not_allowed() {\n+        assert!(UnixStream::connect(\"\\0asdf\").is_err());\n+    }\n+}"}, {"sha": "d7b353c9b2aab70fe8164e4d1051f6fa08d905c2", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=6c4b1f18f3c2a2de17c3562d6557a445b627bcc1", "patch": "@@ -57,13 +57,17 @@ impl Socket {\n             SocketAddr::V4(..) => libc::AF_INET,\n             SocketAddr::V6(..) => libc::AF_INET6,\n         };\n+        Socket::new_raw(fam, ty)\n+    }\n+\n+    pub fn new_raw(fam: c_int, ty: c_int) -> io::Result<Socket> {\n         unsafe {\n             // On linux we first attempt to pass the SOCK_CLOEXEC flag to\n             // atomically create the socket and set it as CLOEXEC. Support for\n             // this option, however, was added in 2.6.27, and we still support\n             // 2.6.18 as a kernel, so if the returned error is EINVAL we\n             // fallthrough to the fallback.\n-            if cfg!(target_os = \"linux\") {\n+            if cfg!(linux) {\n                 match cvt(libc::socket(fam, ty | SOCK_CLOEXEC, 0)) {\n                     Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n                     Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {}\n@@ -78,6 +82,30 @@ impl Socket {\n         }\n     }\n \n+    pub fn new_pair(fam: c_int, ty: c_int) -> io::Result<(Socket, Socket)> {\n+        unsafe {\n+            let mut fds = [0, 0];\n+\n+            // Like above, see if we can set cloexec atomically\n+            if cfg!(linux) {\n+                match cvt(libc::socketpair(fam, ty | SOCK_CLOEXEC, 0, fds.as_mut_ptr())) {\n+                    Ok(_) => {\n+                        return Ok((Socket(FileDesc::new(fds[0])), Socket(FileDesc::new(fds[1]))));\n+                    }\n+                    Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {},\n+                    Err(e) => return Err(e),\n+                }\n+            }\n+\n+            try!(cvt(libc::socketpair(fam, ty, 0, fds.as_mut_ptr())));\n+            let a = FileDesc::new(fds[0]);\n+            a.set_cloexec();\n+            let b = FileDesc::new(fds[1]);\n+            b.set_cloexec();\n+            Ok((Socket(a), Socket(b)))\n+        }\n+    }\n+\n     pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t)\n                   -> io::Result<Socket> {\n         // Unfortunately the only known way right now to accept a socket and\n@@ -120,6 +148,10 @@ impl Socket {\n         self.0.read_to_end(buf)\n     }\n \n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n     pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> {\n         let timeout = match dur {\n             Some(dur) => {\n@@ -186,6 +218,15 @@ impl Socket {\n         let mut nonblocking = nonblocking as libc::c_ulong;\n         cvt(unsafe { libc::ioctl(*self.as_inner(), libc::FIONBIO, &mut nonblocking) }).map(|_| ())\n     }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        let raw: c_int = try!(getsockopt(self, libc::SOL_SOCKET, libc::SO_ERROR));\n+        if raw == 0 {\n+            Ok(None)\n+        } else {\n+            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n+        }\n+    }\n }\n \n impl AsInner<c_int> for Socket {"}, {"sha": "3a2f06418cf8df646b24f447e4536de92c958b5a", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c4b1f18f3c2a2de17c3562d6557a445b627bcc1/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=6c4b1f18f3c2a2de17c3562d6557a445b627bcc1", "patch": "@@ -214,6 +214,15 @@ impl Socket {\n         let raw: c::BYTE = try!(net::getsockopt(self, c::IPPROTO_TCP, c::TCP_NODELAY));\n         Ok(raw != 0)\n     }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        let raw: c_int = try!(net::getsockopt(self, c::SOL_SOCKET, c::SO_ERROR));\n+        if raw == 0 {\n+            Ok(None)\n+        } else {\n+            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n+        }\n+    }\n }\n \n #[unstable(reason = \"not public\", issue = \"0\", feature = \"fd_read\")]"}]}