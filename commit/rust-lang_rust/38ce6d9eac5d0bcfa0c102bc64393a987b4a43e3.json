{"sha": "38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4Y2U2ZDllYWM1ZDBiY2ZhMGMxMDJiYzY0MzkzYTk4N2I0YTQzZTM=", "commit": {"author": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-10-06T22:00:56Z"}, "committer": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-11-05T22:06:01Z"}, "message": "Use `TokenTree`s in lhs of macros", "tree": {"sha": "bb4ef126b0b854cdfa89696cb5597b0df1320e53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb4ef126b0b854cdfa89696cb5597b0df1320e53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "html_url": "https://github.com/rust-lang/rust/commit/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/comments", "author": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c1fd5f8b7351085765217b198c6d5a8c0026b74", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c1fd5f8b7351085765217b198c6d5a8c0026b74", "html_url": "https://github.com/rust-lang/rust/commit/5c1fd5f8b7351085765217b198c6d5a8c0026b74"}], "stats": {"total": 636, "additions": 387, "deletions": 249}, "files": [{"sha": "ff50636a8d982f14309713774b07dd5f43b3a59d", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "patch": "@@ -163,7 +163,8 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n \n             token::Lifetime(..) => \"lifetime\",\n             token::DocComment(..) => \"doccomment\",\n-            token::Underscore | token::Eof | token::Interpolated(..) => \"\",\n+            token::Underscore | token::Eof | token::Interpolated(..) |\n+                token::MatchNt(..) | token::SubstNt(..) => \"\",\n         };\n \n         // as mentioned above, use the original source code instead of"}, {"sha": "6c71f6d08d245eca0b8ac5f0e03cfa64c02b60fe", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 41, "deletions": 9, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "patch": "@@ -10,7 +10,7 @@\n \n // The Rust abstract syntax tree.\n \n-use codemap::{Span, Spanned, DUMMY_SP, ExpnId};\n+use codemap::{Span, Spanned, DUMMY_SP, ExpnId, respan};\n use abi::Abi;\n use ast_util;\n use owned_slice::OwnedSlice;\n@@ -657,23 +657,55 @@ pub enum TokenTree {\n     /// A delimited sequence of token trees\n     TtDelimited(Span, Rc<Delimited>),\n \n-    // These only make sense for right-hand-sides of MBE macros:\n+    // This only makes sense for right-hand-sides of MBE macros:\n \n     /// A Kleene-style repetition sequence with an optional separator.\n     // FIXME(eddyb) #6308 Use Rc<[TokenTree]> after DST.\n-    TtSequence(Span, Rc<Vec<TokenTree>>, Option<token::Token>, KleeneOp),\n-    /// A syntactic variable that will be filled in by macro expansion.\n-    TtNonterminal(Span, Ident)\n+    TtSequence(Span, Rc<Vec<TokenTree>>, Option<::parse::token::Token>, KleeneOp, uint),\n }\n \n impl TokenTree {\n+    pub fn expand_into_tts(self) -> Rc<Vec<TokenTree>> {\n+        match self {\n+            TtToken(sp, token::DocComment(name)) => {\n+                let doc = MetaNameValue(token::intern_and_get_ident(\"doc\"),\n+                                        respan(sp, LitStr(token::get_name(name), CookedStr)));\n+                let doc = token::NtMeta(P(respan(sp, doc)));\n+                let delimed = Delimited {\n+                    delim: token::Bracket,\n+                    open_span: sp,\n+                    tts: vec![TtToken(sp, token::Interpolated(doc))],\n+                    close_span: sp,\n+                };\n+                Rc::new(vec![TtToken(sp, token::Pound),\n+                             TtDelimited(sp, Rc::new(delimed))])\n+            }\n+            TtDelimited(_, ref delimed) => {\n+                let mut tts = Vec::with_capacity(1 + delimed.tts.len() + 1);\n+                tts.push(delimed.open_tt());\n+                tts.extend(delimed.tts.iter().map(|tt| tt.clone()));\n+                tts.push(delimed.close_tt());\n+                Rc::new(tts)\n+            }\n+            TtToken(sp, token::SubstNt(name, namep)) => {\n+                Rc::new(vec![TtToken(sp, token::Dollar),\n+                             TtToken(sp, token::Ident(name, namep))])\n+            }\n+            TtToken(sp, token::MatchNt(name, kind, namep, kindp)) => {\n+                Rc::new(vec![TtToken(sp, token::SubstNt(name, namep)),\n+                             TtToken(sp, token::Colon),\n+                             TtToken(sp, token::Ident(kind, kindp))])\n+            }\n+            _ => panic!(\"Cannot expand a token\")\n+        }\n+    }\n+\n     /// Returns the `Span` corresponding to this token tree.\n     pub fn get_span(&self) -> Span {\n         match *self {\n-            TtToken(span, _)           => span,\n-            TtDelimited(span, _)       => span,\n-            TtSequence(span, _, _, _)  => span,\n-            TtNonterminal(span, _)     => span,\n+            TtToken(span, _)              => span,\n+            TtDelimited(span, _)          => span,\n+            TtSequence(span, _, _, _, _)  => span,\n         }\n     }\n }"}, {"sha": "db6be89e6e9efb918452d88ab980545857e87868", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "patch": "@@ -616,6 +616,20 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n                                 vec!(mk_name(cx, sp, ident.ident())));\n         }\n \n+        token::MatchNt(name, kind, name_style, kind_style) => {\n+            return cx.expr_call(sp,\n+                                mk_token_path(cx, sp, \"MatchNt\"),\n+                                vec![mk_ident(cx, sp, name),\n+                                     mk_ident(cx, sp, kind),\n+                                     match name_style {\n+                                         ModName => mk_token_path(cx, sp, \"ModName\"),\n+                                         Plain   => mk_token_path(cx, sp, \"Plain\"),\n+                                     },\n+                                     match kind_style {\n+                                         ModName => mk_token_path(cx, sp, \"ModName\"),\n+                                         Plain   => mk_token_path(cx, sp, \"Plain\"),\n+                                     }]);\n+        }\n         token::Interpolated(_) => panic!(\"quote! with interpolated token\"),\n \n         _ => ()\n@@ -654,6 +668,25 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n \n fn mk_tt(cx: &ExtCtxt, _: Span, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n     match *tt {\n+        ast::TtToken(sp, SubstNt(ident, _)) => {\n+            // tt.extend($ident.to_tokens(ext_cx).into_iter())\n+\n+            let e_to_toks =\n+                cx.expr_method_call(sp,\n+                                    cx.expr_ident(sp, ident),\n+                                    id_ext(\"to_tokens\"),\n+                                    vec!(cx.expr_ident(sp, id_ext(\"ext_cx\"))));\n+            let e_to_toks =\n+                cx.expr_method_call(sp, e_to_toks, id_ext(\"into_iter\"), vec![]);\n+\n+            let e_push =\n+                cx.expr_method_call(sp,\n+                                    cx.expr_ident(sp, id_ext(\"tt\")),\n+                                    id_ext(\"extend\"),\n+                                    vec!(e_to_toks));\n+\n+            vec!(cx.stmt_expr(e_push))\n+        }\n         ast::TtToken(sp, ref tok) => {\n             let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n             let e_tok = cx.expr_call(sp,\n@@ -673,25 +706,6 @@ fn mk_tt(cx: &ExtCtxt, _: Span, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n                 .collect()\n         },\n         ast::TtSequence(..) => panic!(\"TtSequence in quote!\"),\n-        ast::TtNonterminal(sp, ident) => {\n-            // tt.extend($ident.to_tokens(ext_cx).into_iter())\n-\n-            let e_to_toks =\n-                cx.expr_method_call(sp,\n-                                    cx.expr_ident(sp, ident),\n-                                    id_ext(\"to_tokens\"),\n-                                    vec!(cx.expr_ident(sp, id_ext(\"ext_cx\"))));\n-            let e_to_toks =\n-                cx.expr_method_call(sp, e_to_toks, id_ext(\"into_iter\"), vec![]);\n-\n-            let e_push =\n-                cx.expr_method_call(sp,\n-                                    cx.expr_ident(sp, id_ext(\"tt\")),\n-                                    id_ext(\"extend\"),\n-                                    vec!(e_to_toks));\n-\n-            vec!(cx.stmt_expr(e_push))\n-        },\n     }\n }\n "}, {"sha": "022e3a56677e2f6f5d95b6d9b169bff72503ba83", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 167, "deletions": 116, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "patch": "@@ -78,69 +78,80 @@\n \n \n use ast;\n-use ast::{Matcher, MatchTok, MatchSeq, MatchNonterminal, Ident};\n+use ast::{Matcher, TokenTree, Ident};\n+use ast::{TtDelimited, TtSequence, TtToken};\n use codemap::{BytePos, mk_sp};\n use codemap;\n use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n use parse::attr::ParserAttr;\n use parse::parser::{LifetimeAndTypesWithoutColons, Parser};\n+use parse::token::{Eof, DocComment, MatchNt, SubstNt};\n use parse::token::{Token, Nonterminal};\n use parse::token;\n use print::pprust;\n use ptr::P;\n \n+use std::mem;\n use std::rc::Rc;\n use std::collections::HashMap;\n+use std::collections::hash_map::{Vacant, Occupied};\n \n /* to avoid costly uniqueness checks, we require that `MatchSeq` always has a\n nonempty body. */\n \n \n+/// an unzipping of `TokenTree`s\n+#[deriving(Clone)]\n+struct MatcherTtFrame {\n+    elts: Rc<Vec<ast::TokenTree>>,\n+    idx: uint,\n+}\n+\n #[deriving(Clone)]\n pub struct MatcherPos {\n-    elts: Vec<ast::Matcher> , // maybe should be <'>? Need to understand regions.\n+    stack: Vec<MatcherTtFrame>,\n+    elts: Rc<Vec<ast::TokenTree>>,\n     sep: Option<Token>,\n     idx: uint,\n     up: Option<Box<MatcherPos>>,\n     matches: Vec<Vec<Rc<NamedMatch>>>,\n-    match_lo: uint, match_hi: uint,\n+    match_lo: uint,\n+    match_cur: uint,\n+    match_hi: uint,\n     sp_lo: BytePos,\n }\n \n-pub fn count_names(ms: &[Matcher]) -> uint {\n-    ms.iter().fold(0, |ct, m| {\n-        ct + match m.node {\n-            MatchTok(_) => 0u,\n-            MatchSeq(ref more_ms, _, _, _, _) => {\n-                count_names(more_ms.as_slice())\n+pub fn count_names(ms: &[TokenTree]) -> uint {\n+    ms.iter().fold(0, |count, elt| {\n+        count + match elt {\n+            &TtSequence(_, _, _, _, advance_by) => {\n+                advance_by\n             }\n-            MatchNonterminal(_, _, _) => 1u\n-        }})\n-}\n-\n-pub fn initial_matcher_pos(ms: Vec<Matcher> , sep: Option<Token>, lo: BytePos)\n-                           -> Box<MatcherPos> {\n-    let mut match_idx_hi = 0u;\n-    for elt in ms.iter() {\n-        match elt.node {\n-            MatchTok(_) => (),\n-            MatchSeq(_,_,_,_,hi) => {\n-                match_idx_hi = hi;       // it is monotonic...\n+            &TtDelimited(_, ref delim) => {\n+                count_names(delim.tts.as_slice())\n             }\n-            MatchNonterminal(_,_,pos) => {\n-                match_idx_hi = pos+1u;  // ...so latest is highest\n+            &TtToken(_, MatchNt(..)) => {\n+                1\n             }\n+            &TtToken(_, _) => 0,\n         }\n-    }\n-    let matches = Vec::from_fn(count_names(ms.as_slice()), |_i| Vec::new());\n+    })\n+}\n+\n+pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: BytePos)\n+                           -> Box<MatcherPos> {\n+    let match_idx_hi = count_names(ms.as_slice());\n+    let matches = Vec::from_fn(match_idx_hi, |_i| Vec::new());\n     box MatcherPos {\n+        stack: vec![],\n         elts: ms,\n         sep: sep,\n         idx: 0u,\n         up: None,\n         matches: matches,\n         match_lo: 0u,\n+        match_cur: 0u,\n         match_hi: match_idx_hi,\n         sp_lo: lo\n     }\n@@ -152,11 +163,9 @@ pub fn initial_matcher_pos(ms: Vec<Matcher> , sep: Option<Token>, lo: BytePos)\n /// (expr, item, etc). All the leaves in a single NamedMatch correspond to a\n /// single matcher_nonterminal in the ast::Matcher that produced it.\n ///\n-/// It should probably be renamed, it has more or less exact correspondence to\n-/// ast::match nodes, and the in-memory structure of a particular NamedMatch\n-/// represents the match that occurred when a particular subset of an\n-/// ast::match -- those ast::Matcher nodes leading to a single\n-/// MatchNonterminal -- was applied to a particular token tree.\n+/// The in-memory structure of a particular NamedMatch represents the match\n+/// that occurred when a particular subset of a matcher was applied to a\n+/// particular token tree.\n ///\n /// The width of each MatchedSeq in the NamedMatch, and the identity of the\n /// MatchedNonterminal's, will depend on the token tree it was applied to: each\n@@ -170,34 +179,43 @@ pub enum NamedMatch {\n     MatchedNonterminal(Nonterminal)\n }\n \n-pub fn nameize(p_s: &ParseSess, ms: &[Matcher], res: &[Rc<NamedMatch>])\n+pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n             -> HashMap<Ident, Rc<NamedMatch>> {\n-    fn n_rec(p_s: &ParseSess, m: &Matcher, res: &[Rc<NamedMatch>],\n-             ret_val: &mut HashMap<Ident, Rc<NamedMatch>>) {\n-        match *m {\n-          codemap::Spanned {node: MatchTok(_), .. } => (),\n-          codemap::Spanned {node: MatchSeq(ref more_ms, _, _, _, _), .. } => {\n-            for next_m in more_ms.iter() {\n-                n_rec(p_s, next_m, res, ret_val)\n-            };\n-          }\n-          codemap::Spanned {\n-                node: MatchNonterminal(bind_name, _, idx),\n-                span\n-          } => {\n-            if ret_val.contains_key(&bind_name) {\n-                let string = token::get_ident(bind_name);\n-                p_s.span_diagnostic\n-                   .span_fatal(span,\n-                               format!(\"duplicated bind name: {}\",\n-                                       string.get()).as_slice())\n+    fn n_rec(p_s: &ParseSess, m: &TokenTree, res: &[Rc<NamedMatch>],\n+             ret_val: &mut HashMap<Ident, Rc<NamedMatch>>, idx: &mut uint) {\n+        match m {\n+            &TtSequence(_, ref more_ms, _, _, _) => {\n+                for next_m in more_ms.iter() {\n+                    n_rec(p_s, next_m, res, ret_val, idx)\n+                }\n+            }\n+            &TtDelimited(_, ref delim) => {\n+                for next_m in delim.tts.iter() {\n+                    n_rec(p_s, next_m, res, ret_val, idx)\n+                }\n+            }\n+            &TtToken(sp, MatchNt(bind_name, _, _, _)) => {\n+                match ret_val.entry(bind_name) {\n+                    Vacant(spot) => {\n+                        spot.set(res[*idx].clone());\n+                        *idx += 1;\n+                    }\n+                    Occupied(..) => {\n+                        let string = token::get_ident(bind_name);\n+                        p_s.span_diagnostic\n+                           .span_fatal(sp,\n+                                       format!(\"duplicated bind name: {}\",\n+                                               string.get()).as_slice())\n+                    }\n+                }\n             }\n-            ret_val.insert(bind_name, res[idx].clone());\n-          }\n+            &TtToken(_, SubstNt(..)) => panic!(\"Cannot fill in a NT\"),\n+            &TtToken(_, _) => (),\n         }\n     }\n     let mut ret_val = HashMap::new();\n-    for m in ms.iter() { n_rec(p_s, m, res, &mut ret_val) }\n+    let mut idx = 0u;\n+    for m in ms.iter() { n_rec(p_s, m, res, &mut ret_val, &mut idx) }\n     ret_val\n }\n \n@@ -210,7 +228,7 @@ pub enum ParseResult {\n pub fn parse_or_else(sess: &ParseSess,\n                      cfg: ast::CrateConfig,\n                      rdr: TtReader,\n-                     ms: Vec<Matcher> )\n+                     ms: Vec<TokenTree> )\n                      -> HashMap<Ident, Rc<NamedMatch>> {\n     match parse(sess, cfg, rdr, ms.as_slice()) {\n         Success(m) => m,\n@@ -237,12 +255,12 @@ pub fn token_name_eq(t1 : &Token, t2 : &Token) -> bool {\n pub fn parse(sess: &ParseSess,\n              cfg: ast::CrateConfig,\n              mut rdr: TtReader,\n-             ms: &[Matcher])\n+             ms: &[TokenTree])\n              -> ParseResult {\n     let mut cur_eis = Vec::new();\n-    cur_eis.push(initial_matcher_pos(ms.iter()\n-                                       .map(|x| (*x).clone())\n-                                       .collect(),\n+    cur_eis.push(initial_matcher_pos(Rc::new(ms.iter()\n+                                                .map(|x| (*x).clone())\n+                                                .collect()),\n                                      None,\n                                      rdr.peek().sp.lo));\n \n@@ -255,11 +273,22 @@ pub fn parse(sess: &ParseSess,\n \n         /* we append new items to this while we go */\n         loop {\n-            let ei = match cur_eis.pop() {\n+            let mut ei = match cur_eis.pop() {\n                 None => break, /* for each Earley Item */\n                 Some(ei) => ei,\n             };\n \n+            // When unzipped trees end, remove them\n+            while ei.idx >= ei.elts.len() {\n+                match ei.stack.pop() {\n+                    Some(MatcherTtFrame { elts, idx }) => {\n+                        ei.elts = elts;\n+                        ei.idx = idx + 1;\n+                    }\n+                    None => break\n+                }\n+            }\n+\n             let idx = ei.idx;\n             let len = ei.elts.len();\n \n@@ -293,6 +322,7 @@ pub fn parse(sess: &ParseSess,\n                                                                        sp.hi))));\n                         }\n \n+                        new_pos.match_cur = ei.match_hi;\n                         new_pos.idx += 1;\n                         cur_eis.push(new_pos);\n                     }\n@@ -301,69 +331,88 @@ pub fn parse(sess: &ParseSess,\n \n                     // the *_t vars are workarounds for the lack of unary move\n                     match ei.sep {\n-                      Some(ref t) if idx == len => { // we need a separator\n-                        // i'm conflicted about whether this should be hygienic....\n-                        // though in this case, if the separators are never legal\n-                        // idents, it shouldn't matter.\n-                        if token_name_eq(&tok, t) { //pass the separator\n-                            let mut ei_t = ei.clone();\n-                            ei_t.idx += 1;\n-                            next_eis.push(ei_t);\n+                        Some(ref t) if idx == len => { // we need a separator\n+                            // i'm conflicted about whether this should be hygienic....\n+                            // though in this case, if the separators are never legal\n+                            // idents, it shouldn't matter.\n+                            if token_name_eq(&tok, t) { //pass the separator\n+                                let mut ei_t = ei.clone();\n+                                // ei_t.match_cur = ei_t.match_lo;\n+                                ei_t.idx += 1;\n+                                next_eis.push(ei_t);\n+                            }\n+                        }\n+                        _ => { // we don't need a separator\n+                            let mut ei_t = ei;\n+                            ei_t.match_cur = ei_t.match_lo;\n+                            ei_t.idx = 0;\n+                            cur_eis.push(ei_t);\n                         }\n-                      }\n-                      _ => { // we don't need a separator\n-                        let mut ei_t = ei;\n-                        ei_t.idx = 0;\n-                        cur_eis.push(ei_t);\n-                      }\n                     }\n                 } else {\n                     eof_eis.push(ei);\n                 }\n             } else {\n-                match ei.elts[idx].node.clone() {\n-                  /* need to descend into sequence */\n-                  MatchSeq(ref matchers, ref sep, kleene_op,\n-                           match_idx_lo, match_idx_hi) => {\n-                    if kleene_op == ast::ZeroOrMore {\n-                        let mut new_ei = ei.clone();\n-                        new_ei.idx += 1u;\n-                        //we specifically matched zero repeats.\n-                        for idx in range(match_idx_lo, match_idx_hi) {\n-                            new_ei.matches[idx]\n-                                  .push(Rc::new(MatchedSeq(Vec::new(), sp)));\n+                match (*ei.elts)[idx].clone() {\n+                    /* need to descend into sequence */\n+                    TtSequence(_, ref matchers, ref sep, kleene_op, match_num) => {\n+                        if kleene_op == ast::ZeroOrMore {\n+                            let mut new_ei = ei.clone();\n+                            new_ei.match_cur += match_num;\n+                            new_ei.idx += 1u;\n+                            //we specifically matched zero repeats.\n+                            for idx in range(ei.match_cur, ei.match_cur + match_num) {\n+                                new_ei.matches[idx]\n+                                      .push(Rc::new(MatchedSeq(Vec::new(), sp)));\n+                            }\n+\n+                            cur_eis.push(new_ei);\n                         }\n \n-                        cur_eis.push(new_ei);\n+                        let matches = Vec::from_elem(ei.matches.len(), Vec::new());\n+                        let ei_t = ei;\n+                        cur_eis.push(box MatcherPos {\n+                            stack: vec![],\n+                            elts: matchers.clone(),\n+                            sep: (*sep).clone(),\n+                            idx: 0u,\n+                            matches: matches,\n+                            match_lo: ei_t.match_cur,\n+                            match_cur: ei_t.match_cur,\n+                            match_hi: ei_t.match_cur + match_num,\n+                            up: Some(ei_t),\n+                            sp_lo: sp.lo\n+                        });\n                     }\n-\n-                    let matches = Vec::from_elem(ei.matches.len(), Vec::new());\n-                    let ei_t = ei;\n-                    cur_eis.push(box MatcherPos {\n-                        elts: (*matchers).clone(),\n-                        sep: (*sep).clone(),\n-                        idx: 0u,\n-                        up: Some(ei_t),\n-                        matches: matches,\n-                        match_lo: match_idx_lo, match_hi: match_idx_hi,\n-                        sp_lo: sp.lo\n-                    });\n-                  }\n-                  MatchNonterminal(_,_,_) => {\n-                    // Built-in nonterminals never start with these tokens,\n-                    // so we can eliminate them from consideration.\n-                    match tok {\n-                        token::CloseDelim(_) => {},\n-                        _ => bb_eis.push(ei),\n+                    TtToken(_, MatchNt(..)) => {\n+                        // Built-in nonterminals never start with these tokens,\n+                        // so we can eliminate them from consideration.\n+                        match tok {\n+                            token::CloseDelim(_) => {},\n+                            _ => bb_eis.push(ei),\n+                        }\n                     }\n-                  }\n-                  MatchTok(ref t) => {\n-                    let mut ei_t = ei.clone();\n-                    if token_name_eq(t,&tok) {\n-                        ei_t.idx += 1;\n-                        next_eis.push(ei_t);\n+                    TtToken(sp, SubstNt(..)) => {\n+                        return Error(sp, \"Cannot transcribe in macro LHS\".into_string())\n+                    }\n+                    seq @ TtDelimited(..) | seq @ TtToken(_, DocComment(..)) => {\n+                        let tts = seq.expand_into_tts();\n+                        let elts = mem::replace(&mut ei.elts, tts);\n+                        let idx = ei.idx;\n+                        ei.stack.push(MatcherTtFrame {\n+                            elts: elts,\n+                            idx: idx,\n+                        });\n+                        ei.idx = 0;\n+                        cur_eis.push(ei);\n+                    }\n+                    TtToken(_, ref t) => {\n+                        let mut ei_t = ei.clone();\n+                        if token_name_eq(t,&tok) {\n+                            ei_t.idx += 1;\n+                            next_eis.push(ei_t);\n+                        }\n                     }\n-                  }\n                 }\n             }\n         }\n@@ -385,8 +434,8 @@ pub fn parse(sess: &ParseSess,\n             if (bb_eis.len() > 0u && next_eis.len() > 0u)\n                 || bb_eis.len() > 1u {\n                 let nts = bb_eis.iter().map(|ei| {\n-                    match ei.elts[ei.idx].node {\n-                      MatchNonterminal(bind, name, _) => {\n+                    match (*ei.elts)[ei.idx] {\n+                      TtToken(_, MatchNt(bind, name, _, _)) => {\n                         (format!(\"{} ('{}')\",\n                                 token::get_ident(name),\n                                 token::get_ident(bind))).to_string()\n@@ -410,12 +459,14 @@ pub fn parse(sess: &ParseSess,\n                 let mut rust_parser = Parser::new(sess, cfg.clone(), box rdr.clone());\n \n                 let mut ei = bb_eis.pop().unwrap();\n-                match ei.elts[ei.idx].node {\n-                  MatchNonterminal(_, name, idx) => {\n+                match (*ei.elts)[ei.idx] {\n+                  TtToken(_, MatchNt(_, name, _, _)) => {\n                     let name_string = token::get_ident(name);\n-                    ei.matches[idx].push(Rc::new(MatchedNonterminal(\n+                    let match_cur = ei.match_cur;\n+                    ei.matches[match_cur].push(Rc::new(MatchedNonterminal(\n                         parse_nt(&mut rust_parser, name_string.get()))));\n                     ei.idx += 1u;\n+                    ei.match_cur += 1;\n                   }\n                   _ => panic!()\n                 }"}, {"sha": "cbf34ba5eb320036018615a456d5a76df0d18385", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "patch": "@@ -9,8 +9,9 @@\n // except according to those terms.\n \n use ast::{Ident, Matcher_, Matcher, MatchTok, MatchNonterminal, MatchSeq, TtDelimited};\n+use ast::{TtSequence, TtToken};\n use ast;\n-use codemap::{Span, Spanned, DUMMY_SP};\n+use codemap::{Span, DUMMY_SP};\n use ext::base::{ExtCtxt, MacResult, MacroDef};\n use ext::base::{NormalTT, TTMacroExpander};\n use ext::tt::macro_parser::{Success, Error, Failure};\n@@ -20,7 +21,7 @@ use parse::lexer::new_tt_reader;\n use parse::parser::Parser;\n use parse::attr::ParserAttr;\n use parse::token::{special_idents, gensym_ident};\n-use parse::token::{NtMatchers, NtTT};\n+use parse::token::{MatchNt, NtMatchers, NtTT};\n use parse::token;\n use print;\n use ptr::P;\n@@ -158,14 +159,18 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n \n     for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n         match **lhs {\n-          MatchedNonterminal(NtMatchers(ref mtcs)) => {\n+          MatchedNonterminal(NtTT(ref lhs_tt)) => {\n+            let lhs_tt = match **lhs_tt {\n+                TtDelimited(_, ref delim) => delim.tts.as_slice(),\n+                _ => cx.span_fatal(sp, \"malformed macro lhs\")\n+            };\n             // `None` is because we're not interpolating\n             let arg_rdr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n                                         None,\n                                         arg.iter()\n                                            .map(|x| (*x).clone())\n                                            .collect());\n-            match parse(cx.parse_sess(), cx.cfg(), arg_rdr, mtcs.as_slice()) {\n+            match parse(cx.parse_sess(), cx.cfg(), arg_rdr, lhs_tt) {\n               Success(named_matches) => {\n                 let rhs = match *rhses[i] {\n                     // okay, what's your transcriber?\n@@ -210,31 +215,33 @@ pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n                               name: Ident,\n                               arg: Vec<ast::TokenTree> )\n                               -> Box<MacResult+'cx> {\n-    // these spans won't matter, anyways\n-    fn ms(m: Matcher_) -> Matcher {\n-        Spanned {\n-            node: m.clone(),\n-            span: DUMMY_SP\n-        }\n-    }\n \n     let lhs_nm =  gensym_ident(\"lhs\");\n     let rhs_nm =  gensym_ident(\"rhs\");\n \n     // The pattern that macro_rules matches.\n     // The grammar for macro_rules! is:\n-    // $( $lhs:mtcs => $rhs:tt );+\n+    // $( $lhs:tt => $rhs:tt );+\n     // ...quasiquoting this would be nice.\n+    // These spans won't matter, anyways\n+    let match_lhs_tok = MatchNt(lhs_nm, special_idents::tt, token::Plain, token::Plain);\n+    let match_rhs_tok = MatchNt(rhs_nm, special_idents::tt, token::Plain, token::Plain);\n     let argument_gram = vec!(\n-        ms(MatchSeq(vec!(\n-            ms(MatchNonterminal(lhs_nm, special_idents::matchers, 0u)),\n-            ms(MatchTok(token::FatArrow)),\n-            ms(MatchNonterminal(rhs_nm, special_idents::tt, 1u))),\n-                                Some(token::Semi), ast::OneOrMore, 0u, 2u)),\n+        TtSequence(DUMMY_SP,\n+                   Rc::new(vec![\n+                       TtToken(DUMMY_SP, match_lhs),\n+                       TtToken(DUMMY_SP, token::FatArrow),\n+                       TtToken(DUMMY_SP, match_rhs)]),\n+                   Some(token::Semi),\n+                   ast::OneOrMore,\n+                   2),\n         //to phase into semicolon-termination instead of\n         //semicolon-separation\n-        ms(MatchSeq(vec!(ms(MatchTok(token::Semi))), None,\n-                            ast::ZeroOrMore, 2u, 2u)));\n+        TtSequence(DUMMY_SP,\n+                   Rc::new(vec![TtToken(DUMMY_SP, token::Semi)]),\n+                   None,\n+                   ast::ZeroOrMore,\n+                   0));\n \n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):"}, {"sha": "e8a2d9a243362bb15458b79b335ae592445bbdbf", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 73, "deletions": 64, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "patch": "@@ -9,10 +9,11 @@\n // except according to those terms.\n \n use ast;\n-use ast::{TokenTree, TtDelimited, TtToken, TtSequence, TtNonterminal, Ident};\n+use ast::{TokenTree, TtDelimited, TtToken, TtSequence, Ident};\n use codemap::{Span, DUMMY_SP};\n use diagnostic::SpanHandler;\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n+use parse::token::{Eof, DocComment, Interpolated, MatchNt, SubstNt};\n use parse::token::{Token, NtIdent};\n use parse::token;\n use parse::lexer::TokenAndSpan;\n@@ -85,17 +86,9 @@ fn lookup_cur_matched_by_matched(r: &TtReader, start: Rc<NamedMatch>) -> Rc<Name\n     })\n }\n \n-fn lookup_cur_matched(r: &TtReader, name: Ident) -> Rc<NamedMatch> {\n+fn lookup_cur_matched(r: &TtReader, name: Ident) -> Option<Rc<NamedMatch>> {\n     let matched_opt = r.interpolations.find_copy(&name);\n-    match matched_opt {\n-        Some(s) => lookup_cur_matched_by_matched(r, s),\n-        None => {\n-            r.sp_diag\n-             .span_fatal(r.cur_span,\n-                         format!(\"unknown macro variable `{}`\",\n-                                 token::get_ident(name)).as_slice());\n-        }\n-    }\n+    matched_opt.map(|s| lookup_cur_matched_by_matched(r, s))\n }\n \n #[deriving(Clone)]\n@@ -133,16 +126,20 @@ fn lockstep_iter_size(t: &TokenTree, r: &TtReader) -> LockstepIterSize {\n                 size + lockstep_iter_size(tt, r)\n             })\n         },\n-        TtSequence(_, ref tts, _, _) => {\n+        TtSequence(_, ref tts, _, _, _) => {\n             tts.iter().fold(LisUnconstrained, |size, tt| {\n                 size + lockstep_iter_size(tt, r)\n             })\n         },\n+        TtToken(_, SubstNt(name, _)) | TtToken(_, MatchNt(name, _, _, _)) =>\n+            match lookup_cur_matched(r, name) {\n+                Some(matched) => match *matched {\n+                    MatchedNonterminal(_) => LisUnconstrained,\n+                    MatchedSeq(ref ads, _) => LisConstraint(ads.len(), name),\n+                },\n+                _ => LisUnconstrained\n+            },\n         TtToken(..) => LisUnconstrained,\n-        TtNonterminal(_, name) => match *lookup_cur_matched(r, name) {\n-            MatchedNonterminal(_) => LisUnconstrained,\n-            MatchedSeq(ref ads, _) => LisConstraint(ads.len(), name)\n-        },\n     }\n }\n \n@@ -205,40 +202,21 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n             (*frame.forest)[frame.idx].clone()\n         };\n         match t {\n-            TtDelimited(_, ref delimed) => {\n-                let mut tts = Vec::with_capacity(1 + delimed.tts.len() + 1);\n-                tts.push(delimed.open_tt());\n-                tts.extend(delimed.tts.iter().map(|tt| tt.clone()));\n-                tts.push(delimed.close_tt());\n-\n-                r.stack.push(TtFrame {\n-                    forest: Rc::new(tts),\n-                    idx: 0,\n-                    dotdotdoted: false,\n-                    sep: None\n-                });\n-                // if this could be 0-length, we'd need to potentially recur here\n-            }\n-            TtToken(sp, tok) => {\n-                r.cur_span = sp;\n-                r.cur_tok = tok;\n-                r.stack.last_mut().unwrap().idx += 1;\n-                return ret_val;\n-            }\n-            TtSequence(sp, tts, sep, kleene_op) => {\n+            TtSequence(sp, tts, sep, kleene_op, n) => {\n                 // FIXME(pcwalton): Bad copy.\n-                match lockstep_iter_size(&TtSequence(sp, tts.clone(), sep.clone(), kleene_op), r) {\n+                match lockstep_iter_size(&TtSequence(sp, tts.clone(), sep.clone(), kleene_op, n),\n+                                         r) {\n                     LisUnconstrained => {\n                         r.sp_diag.span_fatal(\n                             sp.clone(), /* blame macro writer */\n                             \"attempted to repeat an expression \\\n                              containing no syntax \\\n                              variables matched as repeating at this depth\");\n-                        }\n-                        LisContradiction(ref msg) => {\n-                            // FIXME #2887 blame macro invoker instead\n-                            r.sp_diag.span_fatal(sp.clone(), msg.as_slice());\n-                        }\n+                    }\n+                    LisContradiction(ref msg) => {\n+                        // FIXME #2887 blame macro invoker instead\n+                        r.sp_diag.span_fatal(sp.clone(), msg.as_slice());\n+                    }\n                     LisConstraint(len, _) => {\n                         if len == 0 {\n                             if kleene_op == ast::OneOrMore {\n@@ -262,31 +240,62 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 }\n             }\n             // FIXME #2887: think about span stuff here\n-            TtNonterminal(sp, ident) => {\n-                r.stack.last_mut().unwrap().idx += 1;\n-                match *lookup_cur_matched(r, ident) {\n-                    /* sidestep the interpolation tricks for ident because\n-                       (a) idents can be in lots of places, so it'd be a pain\n-                       (b) we actually can, since it's a token. */\n-                    MatchedNonterminal(NtIdent(box sn, b)) => {\n-                        r.cur_span = sp;\n-                        r.cur_tok = token::Ident(sn,b);\n-                        return ret_val;\n-                    }\n-                    MatchedNonterminal(ref other_whole_nt) => {\n-                        // FIXME(pcwalton): Bad copy.\n-                        r.cur_span = sp;\n-                        r.cur_tok = token::Interpolated((*other_whole_nt).clone());\n-                        return ret_val;\n+            TtToken(sp, SubstNt(ident, namep)) => {\n+                match lookup_cur_matched(r, ident) {\n+                    None => {\n+                        r.stack.push(TtFrame {\n+                            forest: TtToken(sp, SubstNt(ident, namep)).expand_into_tts(),\n+                            idx: 0,\n+                            dotdotdoted: false,\n+                            sep: None\n+                        });\n+                        // this can't be 0 length, just like TtDelimited\n                     }\n-                    MatchedSeq(..) => {\n-                        r.sp_diag.span_fatal(\n-                            r.cur_span, /* blame the macro writer */\n-                            format!(\"variable '{}' is still repeating at this depth\",\n-                                    token::get_ident(ident)).as_slice());\n+                    Some(cur_matched) => {\n+                        r.stack.last_mut().unwrap().idx += 1;\n+                        match *cur_matched {\n+                            // sidestep the interpolation tricks for ident because\n+                            // (a) idents can be in lots of places, so it'd be a pain\n+                            // (b) we actually can, since it's a token.\n+                            MatchedNonterminal(NtIdent(box sn, b)) => {\n+                                r.cur_span = sp;\n+                                r.cur_tok = token::Ident(sn, b);\n+                                return ret_val;\n+                            }\n+                            MatchedNonterminal(ref other_whole_nt) => {\n+                                // FIXME(pcwalton): Bad copy.\n+                                r.cur_span = sp;\n+                                r.cur_tok = token::Interpolated((*other_whole_nt).clone());\n+                                return ret_val;\n+                            }\n+                            MatchedSeq(..) => {\n+                                r.sp_diag.span_fatal(\n+                                    r.cur_span, /* blame the macro writer */\n+                                    format!(\"variable '{}' is still repeating at this depth\",\n+                                            token::get_ident(ident)).as_slice());\n+                            }\n+                        }\n                     }\n                 }\n             }\n+            // TtDelimited or any token that can be unzipped\n+            seq @ TtDelimited(..) | seq @ TtToken(_, DocComment(..))\n+            | seq @ TtToken(_, MatchNt(..)) => {\n+                // do not advance the idx yet\n+                r.stack.push(TtFrame {\n+                   forest: seq.expand_into_tts(),\n+                   idx: 0,\n+                   dotdotdoted: false,\n+                   sep: None\n+                });\n+                // if this could be 0-length, we'd need to potentially recur here\n+            }\n+            TtToken(sp, tok) => {\n+                r.cur_span = sp;\n+                r.cur_tok = tok;\n+                r.stack.last_mut().unwrap().idx += 1;\n+                return ret_val;\n+            }\n         }\n     }\n }"}, {"sha": "75fbdb8d8b6b0fe810f48431e0461d73fdf4bae9", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "patch": "@@ -581,13 +581,12 @@ pub fn noop_fold_tt<T: Folder>(tt: &TokenTree, fld: &mut T) -> TokenTree {\n                             }\n                         ))\n         },\n-        TtSequence(span, ref pattern, ref sep, is_optional) =>\n+        TtSequence(span, ref pattern, ref sep, is_optional, advance_by) =>\n             TtSequence(span,\n                        Rc::new(fld.fold_tts(pattern.as_slice())),\n                        sep.clone().map(|tok| fld.fold_token(tok)),\n-                       is_optional),\n-        TtNonterminal(sp,ref ident) =>\n-            TtNonterminal(sp,fld.fold_ident(*ident))\n+                       is_optional,\n+                       advance_by),\n     }\n }\n \n@@ -603,6 +602,12 @@ pub fn noop_fold_token<T: Folder>(t: token::Token, fld: &mut T) -> token::Token\n         }\n         token::Lifetime(id) => token::Lifetime(fld.fold_ident(id)),\n         token::Interpolated(nt) => token::Interpolated(fld.fold_interpolated(nt)),\n+        token::SubstNt(ident, namep) => {\n+            token::SubstNt(fld.fold_ident(ident), namep)\n+        }\n+        token::MatchNt(name, kind, namep, kindp) => {\n+            token::MatchNt(fld.fold_ident(name), fld.fold_ident(kind), namep, kindp)\n+        }\n         _ => t\n     }\n }"}, {"sha": "741014fec896250b468e08a010b5942787a0c247", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "patch": "@@ -49,7 +49,7 @@ use ast::{StructVariantKind, BiSub};\n use ast::StrStyle;\n use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, TokenTree, TraitItem, TraitRef, TtDelimited, TtSequence, TtToken};\n-use ast::{TtNonterminal, TupleVariantKind, Ty, Ty_, TyBot};\n+use ast::{TupleVariantKind, Ty, Ty_, TyBot};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPtr, TyQPath};\n@@ -65,6 +65,7 @@ use ast_util::{as_prec, ident_to_path, operator_prec};\n use ast_util;\n use codemap::{Span, BytePos, Spanned, spanned, mk_sp};\n use codemap;\n+use ext::tt::macro_parser;\n use parse;\n use parse::attr::ParserAttr;\n use parse::classify;\n@@ -73,7 +74,7 @@ use parse::common::{seq_sep_trailing_allowed};\n use parse::lexer::Reader;\n use parse::lexer::TokenAndSpan;\n use parse::obsolete::*;\n-use parse::token::InternedString;\n+use parse::token::{MatchNt, SubstNt, InternedString};\n use parse::token::{keywords, special_idents};\n use parse::token;\n use parse::{new_sub_parser_from_file, ParseSess};\n@@ -2508,7 +2509,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_token_tree(&mut self) -> TokenTree {\n         // FIXME #6994: currently, this is too eager. It\n         // parses token trees but also identifies TtSequence's\n-        // and TtNonterminal's; it's too early to know yet\n+        // and token::SubstNt's; it's too early to know yet\n         // whether something will be a nonterminal or a seq\n         // yet.\n         maybe_whole!(deref self, NtTT);\n@@ -2549,9 +2550,21 @@ impl<'a> Parser<'a> {\n                     let seq = match seq {\n                         Spanned { node, .. } => node,\n                     };\n-                    TtSequence(mk_sp(sp.lo, p.span.hi), Rc::new(seq), sep, repeat)\n+                    let name_num = macro_parser::count_names(seq.as_slice());\n+                    TtSequence(mk_sp(sp.lo, p.span.hi), Rc::new(seq), sep, repeat, name_num)\n                 } else {\n-                    TtNonterminal(sp, p.parse_ident())\n+                    // A nonterminal that matches or not\n+                    let namep = match p.token { token::Ident(_, p) => p, _ => token::Plain };\n+                    let name = p.parse_ident();\n+                    if p.token == token::Colon && p.look_ahead(1, |t| t.is_ident()) {\n+                        p.bump();\n+                        let kindp = match p.token { token::Ident(_, p) => p, _ => token::Plain };\n+                        let nt_kind = p.parse_ident();\n+                        let m = TtToken(sp, MatchNt(name, nt_kind, namep, kindp));\n+                        m\n+                    } else {\n+                        TtToken(sp, SubstNt(name, namep))\n+                    }\n                 }\n               }\n               _ => {"}, {"sha": "8dd2f8b840f92b45f912b59d0ff0e81e6033c62a", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "patch": "@@ -108,7 +108,15 @@ pub enum Token {\n \n     /* For interpolation */\n     Interpolated(Nonterminal),\n+    // Can be expanded into several tokens.\n+    /// Doc comment\n     DocComment(ast::Name),\n+    // In left-hand-sides of MBE macros:\n+    /// Parse a nonterminal (name to bind, name of NT, styles of their idents)\n+    MatchNt(ast::Ident, ast::Ident, IdentStyle, IdentStyle),\n+    // In right-hand-sides of MBE macros:\n+    /// A syntactic variable that will be filled in by macro expansion.\n+    SubstNt(ast::Ident, IdentStyle),\n \n     // Junk. These carry no data because we don't really care about the data\n     // they *would* carry, and don't really want to allocate a new ident for"}, {"sha": "12ce81eedca8c77f13c715959d759d989a3c5e01", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=38ce6d9eac5d0bcfa0c102bc64393a987b4a43e3", "patch": "@@ -254,6 +254,8 @@ pub fn token_to_string(tok: &Token) -> String {\n \n         /* Other */\n         token::DocComment(s)        => s.as_str().into_string(),\n+        token::SubstNt(s, _)        => format!(\"${}\", s),\n+        token::MatchNt(s, t, _, _)  => format!(\"${}:{}\", s, t),\n         token::Eof                  => \"<eof>\".into_string(),\n         token::Whitespace           => \" \".into_string(),\n         token::Comment              => \"/* */\".into_string(),\n@@ -1120,13 +1122,6 @@ impl<'a> State<'a> {\n     /// expression arguments as expressions). It can be done! I think.\n     pub fn print_tt(&mut self, tt: &ast::TokenTree) -> IoResult<()> {\n         match *tt {\n-            ast::TtDelimited(_, ref delimed) => {\n-                try!(word(&mut self.s, token_to_string(&delimed.open_token()).as_slice()));\n-                try!(space(&mut self.s));\n-                try!(self.print_tts(delimed.tts.as_slice()));\n-                try!(space(&mut self.s));\n-                word(&mut self.s, token_to_string(&delimed.close_token()).as_slice())\n-            },\n             ast::TtToken(_, ref tk) => {\n                 try!(word(&mut self.s, token_to_string(tk).as_slice()));\n                 match *tk {\n@@ -1136,7 +1131,14 @@ impl<'a> State<'a> {\n                     _ => Ok(())\n                 }\n             }\n-            ast::TtSequence(_, ref tts, ref separator, kleene_op) => {\n+            ast::TtDelimited(_, ref delimed) => {\n+                try!(word(&mut self.s, token_to_string(&delimed.open_token()).as_slice()));\n+                try!(space(&mut self.s));\n+                try!(self.print_tts(delimed.tts.as_slice()));\n+                try!(space(&mut self.s));\n+                word(&mut self.s, token_to_string(&delimed.close_token()).as_slice())\n+            },\n+            ast::TtSequence(_, ref tts, ref separator, kleene_op, _) => {\n                 try!(word(&mut self.s, \"$(\"));\n                 for tt_elt in (*tts).iter() {\n                     try!(self.print_tt(tt_elt));\n@@ -1153,10 +1155,6 @@ impl<'a> State<'a> {\n                     ast::OneOrMore => word(&mut self.s, \"+\"),\n                 }\n             }\n-            ast::TtNonterminal(_, name) => {\n-                try!(word(&mut self.s, \"$\"));\n-                self.print_ident(name)\n-            }\n         }\n     }\n "}]}