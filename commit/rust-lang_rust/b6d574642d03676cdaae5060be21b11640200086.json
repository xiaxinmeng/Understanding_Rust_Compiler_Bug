{"sha": "b6d574642d03676cdaae5060be21b11640200086", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2ZDU3NDY0MmQwMzY3NmNkYWFlNTA2MGJlMjFiMTE2NDAyMDAwODY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-05T00:54:06Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-05T00:54:06Z"}, "message": "extract_type_alias extracts generics correctly", "tree": {"sha": "f908646a7061df775531dc9192f22525101ae74f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f908646a7061df775531dc9192f22525101ae74f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6d574642d03676cdaae5060be21b11640200086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6d574642d03676cdaae5060be21b11640200086", "html_url": "https://github.com/rust-lang/rust/commit/b6d574642d03676cdaae5060be21b11640200086", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6d574642d03676cdaae5060be21b11640200086/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01413dd7d4d04ba3c1324bb149ad25b68d93dd98", "url": "https://api.github.com/repos/rust-lang/rust/commits/01413dd7d4d04ba3c1324bb149ad25b68d93dd98", "html_url": "https://github.com/rust-lang/rust/commit/01413dd7d4d04ba3c1324bb149ad25b68d93dd98"}], "stats": {"total": 192, "additions": 175, "deletions": 17}, "files": [{"sha": "4913ac1e08ea8f413f78d1f4c5e26842efdf6922", "filename": "crates/ide_assists/src/handlers/extract_type_alias.rs", "status": "modified", "additions": 156, "deletions": 16, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/b6d574642d03676cdaae5060be21b11640200086/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6d574642d03676cdaae5060be21b11640200086/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs?ref=b6d574642d03676cdaae5060be21b11640200086", "patch": "@@ -1,5 +1,7 @@\n+use either::Either;\n+use itertools::Itertools;\n use syntax::{\n-    ast::{self, edit::IndentLevel, AstNode},\n+    ast::{self, edit::IndentLevel, AstNode, GenericParamsOwner, NameOwner},\n     match_ast,\n };\n \n@@ -27,41 +29,158 @@ pub(crate) fn extract_type_alias(acc: &mut Assists, ctx: &AssistContext) -> Opti\n         return None;\n     }\n \n-    let node = ctx.find_node_at_range::<ast::Type>()?;\n-    let item = ctx.find_node_at_offset::<ast::Item>()?;\n-    let insert = match_ast! {\n-        match (item.syntax().parent()?) {\n-            ast::AssocItemList(it) => it.syntax().parent()?,\n-            _ => item.syntax().clone(),\n+    let ty = ctx.find_node_at_range::<ast::Type>()?;\n+    let item = ty.syntax().ancestors().find_map(ast::Item::cast)?;\n+    let assoc_owner = item.syntax().ancestors().nth(2).and_then(|it| {\n+        match_ast! {\n+            match it {\n+                ast::Trait(tr) => Some(Either::Left(tr)),\n+                ast::Impl(impl_) => Some(Either::Right(impl_)),\n+                _ => None,\n+            }\n         }\n-    };\n-    let indent = IndentLevel::from_node(&insert);\n-    let insert = insert.text_range().start();\n-    let target = node.syntax().text_range();\n+    });\n+    let node = assoc_owner.as_ref().map_or_else(\n+        || item.syntax(),\n+        |impl_| impl_.as_ref().either(AstNode::syntax, AstNode::syntax),\n+    );\n+    let insert_pos = node.text_range().start();\n+    let target = ty.syntax().text_range();\n \n     acc.add(\n         AssistId(\"extract_type_alias\", AssistKind::RefactorExtract),\n         \"Extract type as type alias\",\n         target,\n         |builder| {\n-            builder.edit_file(ctx.frange.file_id);\n-            builder.replace(target, \"Type\");\n+            let mut known_generics = match item.generic_param_list() {\n+                Some(it) => it.generic_params().collect(),\n+                None => Vec::new(),\n+            };\n+            if let Some(it) = assoc_owner.as_ref().and_then(|it| match it {\n+                Either::Left(it) => it.generic_param_list(),\n+                Either::Right(it) => it.generic_param_list(),\n+            }) {\n+                known_generics.extend(it.generic_params());\n+            }\n+            let generics = collect_used_generics(&ty, &known_generics);\n+\n+            let replacement = if !generics.is_empty() {\n+                format!(\n+                    \"Type<{}>\",\n+                    generics.iter().format_with(\", \", |generic, f| {\n+                        match generic {\n+                            ast::GenericParam::ConstParam(cp) => f(&cp.name().unwrap()),\n+                            ast::GenericParam::LifetimeParam(lp) => f(&lp.lifetime().unwrap()),\n+                            ast::GenericParam::TypeParam(tp) => f(&tp.name().unwrap()),\n+                        }\n+                    })\n+                )\n+            } else {\n+                String::from(\"Type\")\n+            };\n+            builder.replace(target, replacement);\n+\n+            let indent = IndentLevel::from_node(node);\n+            let generics = if !generics.is_empty() {\n+                format!(\"<{}>\", generics.iter().format(\", \"))\n+            } else {\n+                String::new()\n+            };\n             match ctx.config.snippet_cap {\n                 Some(cap) => {\n                     builder.insert_snippet(\n                         cap,\n-                        insert,\n-                        format!(\"type $0Type = {};\\n\\n{}\", node, indent),\n+                        insert_pos,\n+                        format!(\"type $0Type{} = {};\\n\\n{}\", generics, ty, indent),\n                     );\n                 }\n                 None => {\n-                    builder.insert(insert, format!(\"type Type = {};\\n\\n{}\", node, indent));\n+                    builder.insert(\n+                        insert_pos,\n+                        format!(\"type Type{} = {};\\n\\n{}\", generics, ty, indent),\n+                    );\n                 }\n             }\n         },\n     )\n }\n \n+fn collect_used_generics<'gp>(\n+    ty: &ast::Type,\n+    known_generics: &'gp [ast::GenericParam],\n+) -> Vec<&'gp ast::GenericParam> {\n+    // can't use a closure -> closure here cause lifetime inference fails for that\n+    fn find_lifetime(text: &str) -> impl Fn(&&ast::GenericParam) -> bool + '_ {\n+        move |gp: &&ast::GenericParam| match gp {\n+            ast::GenericParam::LifetimeParam(lp) => {\n+                lp.lifetime().map_or(false, |lt| lt.text() == text)\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    let mut generics = Vec::new();\n+    ty.walk(&mut |ty| match ty {\n+        ast::Type::PathType(ty) => {\n+            if let Some(path) = ty.path() {\n+                if let Some(name_ref) = path.as_single_name_ref() {\n+                    if let Some(param) = known_generics.iter().find(|gp| {\n+                        match gp {\n+                            ast::GenericParam::ConstParam(cp) => cp.name(),\n+                            ast::GenericParam::TypeParam(tp) => tp.name(),\n+                            _ => None,\n+                        }\n+                        .map_or(false, |n| n.text() == name_ref.text())\n+                    }) {\n+                        generics.push(param);\n+                    }\n+                }\n+                generics.extend(\n+                    path.segments()\n+                        .filter_map(|seg| seg.generic_arg_list())\n+                        .flat_map(|it| it.generic_args())\n+                        .filter_map(|it| match it {\n+                            ast::GenericArg::LifetimeArg(lt) => {\n+                                let lt = lt.lifetime()?;\n+                                known_generics.iter().find(find_lifetime(&lt.text()))\n+                            }\n+                            _ => None,\n+                        }),\n+                );\n+            }\n+        }\n+        ast::Type::ImplTraitType(impl_ty) => {\n+            if let Some(it) = impl_ty.type_bound_list() {\n+                generics.extend(\n+                    it.bounds()\n+                        .filter_map(|it| it.lifetime())\n+                        .filter_map(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n+                );\n+            }\n+        }\n+        ast::Type::DynTraitType(dyn_ty) => {\n+            if let Some(it) = dyn_ty.type_bound_list() {\n+                generics.extend(\n+                    it.bounds()\n+                        .filter_map(|it| it.lifetime())\n+                        .filter_map(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n+                );\n+            }\n+        }\n+        ast::Type::RefType(ref_) => generics.extend(\n+            ref_.lifetime().and_then(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n+        ),\n+        _ => (),\n+    });\n+    // stable resort to lifetime, type, const\n+    generics.sort_by_key(|gp| match gp {\n+        ast::GenericParam::ConstParam(_) => 2,\n+        ast::GenericParam::LifetimeParam(_) => 0,\n+        ast::GenericParam::TypeParam(_) => 1,\n+    });\n+    generics\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -216,4 +335,25 @@ mod m {\n             \"#,\n         );\n     }\n+\n+    #[test]\n+    fn generics() {\n+        check_assist(\n+            extract_type_alias,\n+            r#\"\n+struct Struct<const C: usize>;\n+impl<'outer, Outer, const OUTER: usize> () {\n+    fn func<'inner, Inner, const INNER: usize>(_: $0&(Struct<INNER>, Struct<OUTER>, Outer, &'inner (), Inner, &'outer ())$0) {}\n+}\n+\"#,\n+            r#\"\n+struct Struct<const C: usize>;\n+type $0Type<'inner, 'outer, Outer, Inner, const INNER: usize, const OUTER: usize> = &(Struct<INNER>, Struct<OUTER>, Outer, &'inner (), Inner, &'outer ());\n+\n+impl<'outer, Outer, const OUTER: usize> () {\n+    fn func<'inner, Inner, const INNER: usize>(_: Type<'inner, 'outer, Outer, Inner, INNER, OUTER>) {}\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "3030c881209c7c2edb13a61e6fcec385a5f31f3e", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b6d574642d03676cdaae5060be21b11640200086/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6d574642d03676cdaae5060be21b11640200086/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=b6d574642d03676cdaae5060be21b11640200086", "patch": "@@ -8,7 +8,10 @@ use parser::SyntaxKind;\n use rowan::{GreenNodeData, GreenTokenData, WalkEvent};\n \n use crate::{\n-    ast::{self, support, AstChildren, AstNode, AstToken, AttrsOwner, NameOwner, SyntaxNode},\n+    ast::{\n+        self, support, AstChildren, AstNode, AstToken, AttrsOwner, GenericParamsOwner, NameOwner,\n+        SyntaxNode,\n+    },\n     NodeOrToken, SmolStr, SyntaxElement, SyntaxToken, TokenText, T,\n };\n \n@@ -593,6 +596,21 @@ impl ast::Variant {\n     }\n }\n \n+impl ast::Item {\n+    pub fn generic_param_list(&self) -> Option<ast::GenericParamList> {\n+        match self {\n+            ast::Item::Enum(it) => it.generic_param_list(),\n+            ast::Item::Fn(it) => it.generic_param_list(),\n+            ast::Item::Impl(it) => it.generic_param_list(),\n+            ast::Item::Struct(it) => it.generic_param_list(),\n+            ast::Item::Trait(it) => it.generic_param_list(),\n+            ast::Item::TypeAlias(it) => it.generic_param_list(),\n+            ast::Item::Union(it) => it.generic_param_list(),\n+            _ => None,\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum FieldKind {\n     Name(ast::NameRef),"}]}