{"sha": "1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiOTA4YmU5YTBkN2FhZjhmMTg4NTRkYjFmZmVmN2I4ZGYxMGRmZWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-03T20:10:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-03T20:10:42Z"}, "message": "Auto merge of #28200 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #28164, #28170, #28184, #28186, #28187, #28188, #28191, #28193, #28194, #28195\n- Failed merges:", "tree": {"sha": "506e5b6cd2f56abd94c525bfbb34240e1466ed47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/506e5b6cd2f56abd94c525bfbb34240e1466ed47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "html_url": "https://github.com/rust-lang/rust/commit/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0762f58c1143b4ff0ae5d0cdda9cdd8249512e77", "url": "https://api.github.com/repos/rust-lang/rust/commits/0762f58c1143b4ff0ae5d0cdda9cdd8249512e77", "html_url": "https://github.com/rust-lang/rust/commit/0762f58c1143b4ff0ae5d0cdda9cdd8249512e77"}, {"sha": "e6e175b828a86defa5637cdc5980ba94fbddf449", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6e175b828a86defa5637cdc5980ba94fbddf449", "html_url": "https://github.com/rust-lang/rust/commit/e6e175b828a86defa5637cdc5980ba94fbddf449"}], "stats": {"total": 353, "additions": 212, "deletions": 141}, "files": [{"sha": "8dd2e365aa82ca46a29bf037f63989c9752f9730", "filename": "src/doc/trpl/rust-inside-other-languages.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Fdoc%2Ftrpl%2Frust-inside-other-languages.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Fdoc%2Ftrpl%2Frust-inside-other-languages.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Frust-inside-other-languages.md?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -217,6 +217,17 @@ And finally, we can try running it:\n \n ```bash\n $ ruby embed.rb\n+Thread finished with count=5000000\n+Thread finished with count=5000000\n+Thread finished with count=5000000\n+Thread finished with count=5000000\n+Thread finished with count=5000000\n+Thread finished with count=5000000\n+Thread finished with count=5000000\n+Thread finished with count=5000000\n+Thread finished with count=5000000\n+Thread finished with count=5000000\n+done!\n done!\n $\n ```"}, {"sha": "0870a6ef3414739aba63930b1f8269a6f0a7e07d", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -390,7 +390,7 @@ fn normal<T: ConvertTo<i64>>(x: &T) -> i64 {\n \n // can be called with T == i64\n fn inverse<T>() -> T\n-        // this is using ConvertTo as if it were \"ConvertFrom<i32>\"\n+        // this is using ConvertTo as if it were \"ConvertTo<i64>\"\n         where i32: ConvertTo<T> {\n     42.convert()\n }"}, {"sha": "d8f8ca6eae59c84e3daef5e4db8eae1ee4297ccf", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -296,7 +296,7 @@ impl<K, V> Drop for Node<K, V> {\n             self.destroy();\n         }\n \n-        self.keys = unsafe { Unique::new(0 as *mut K) };\n+        self.keys = unsafe { Unique::new(ptr::null_mut()) };\n     }\n }\n "}, {"sha": "bb752b07abeb8a93d5189bca629e66fd42b5b08a", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -1135,7 +1135,7 @@ impl<T> ops::Deref for Vec<T> {\n     fn deref(&self) -> &[T] {\n         unsafe {\n             let p = self.buf.ptr();\n-            assume(p != 0 as *mut T);\n+            assume(!p.is_null());\n             slice::from_raw_parts(p, self.len)\n         }\n     }"}, {"sha": "d37f5169af1dff7d7b8e14e60e77660a790f7e27", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -231,7 +231,7 @@ impl<T:Copy> Cell<T> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"as_unsafe_cell\", issue = \"27708\")]\n-    pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n+    pub unsafe fn as_unsafe_cell(&self) -> &UnsafeCell<T> {\n         &self.value\n     }\n }\n@@ -387,7 +387,7 @@ impl<T: ?Sized> RefCell<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n+    pub fn borrow(&self) -> Ref<T> {\n         match BorrowRef::new(&self.borrow) {\n             Some(b) => Ref {\n                 _value: unsafe { &*self.value.get() },\n@@ -433,7 +433,7 @@ impl<T: ?Sized> RefCell<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n+    pub fn borrow_mut(&self) -> RefMut<T> {\n         match BorrowRefMut::new(&self.borrow) {\n             Some(b) => RefMut {\n                 _value: unsafe { &mut *self.value.get() },\n@@ -450,7 +450,7 @@ impl<T: ?Sized> RefCell<T> {\n     /// This function is `unsafe` because `UnsafeCell`'s field is public.\n     #[inline]\n     #[unstable(feature = \"as_unsafe_cell\", issue = \"27708\")]\n-    pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n+    pub unsafe fn as_unsafe_cell(&self) -> &UnsafeCell<T> {\n         &self.value\n     }\n }\n@@ -541,7 +541,7 @@ impl<'b, T: ?Sized> Deref for Ref<'b, T> {\n     type Target = T;\n \n     #[inline]\n-    fn deref<'a>(&'a self) -> &'a T {\n+    fn deref(&self) -> &T {\n         self._value\n     }\n }\n@@ -750,15 +750,15 @@ impl<'b, T: ?Sized> Deref for RefMut<'b, T> {\n     type Target = T;\n \n     #[inline]\n-    fn deref<'a>(&'a self) -> &'a T {\n+    fn deref(&self) -> &T {\n         self._value\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T: ?Sized> DerefMut for RefMut<'b, T> {\n     #[inline]\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+    fn deref_mut(&mut self) -> &mut T {\n         self._value\n     }\n }"}, {"sha": "97dcb2475a3cf3dfc95927d6c4cf930a8c8da582", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -1513,7 +1513,7 @@ impl<A, B> Iterator for Chain<A, B> where\n     fn next(&mut self) -> Option<A::Item> {\n         match self.state {\n             ChainState::Both => match self.a.next() {\n-                elt @ Some(..) => return elt,\n+                elt @ Some(..) => elt,\n                 None => {\n                     self.state = ChainState::Back;\n                     self.b.next()\n@@ -1590,7 +1590,7 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n     fn next_back(&mut self) -> Option<A::Item> {\n         match self.state {\n             ChainState::Both => match self.b.next_back() {\n-                elt @ Some(..) => return elt,\n+                elt @ Some(..) => elt,\n                 None => {\n                     self.state = ChainState::Front;\n                     self.a.next_back()\n@@ -1683,7 +1683,7 @@ impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n \n     #[inline]\n     fn next(&mut self) -> Option<B> {\n-        self.iter.next().map(|a| (self.f)(a))\n+        self.iter.next().map(&mut self.f)\n     }\n \n     #[inline]\n@@ -1698,7 +1698,7 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n-        self.iter.next_back().map(|a| (self.f)(a))\n+        self.iter.next_back().map(&mut self.f)\n     }\n }\n \n@@ -2210,7 +2210,7 @@ impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n                     return Some(x)\n                 }\n             }\n-            match self.iter.next().map(|x| (self.f)(x)) {\n+            match self.iter.next().map(&mut self.f) {\n                 None => return self.backiter.as_mut().and_then(|it| it.next()),\n                 next => self.frontiter = next.map(IntoIterator::into_iter),\n             }\n@@ -2243,7 +2243,7 @@ impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> wher\n                     return Some(y)\n                 }\n             }\n-            match self.iter.next_back().map(|x| (self.f)(x)) {\n+            match self.iter.next_back().map(&mut self.f) {\n                 None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n                 next => self.backiter = next.map(IntoIterator::into_iter),\n             }"}, {"sha": "c945e4e066159e9a558bf6ba2f0f0c4ba4777632", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -51,7 +51,7 @@ impl<T: Zeroable> Deref for NonZero<T> {\n     type Target = T;\n \n     #[inline]\n-    fn deref<'a>(&'a self) -> &'a T {\n+    fn deref(&self) -> &T {\n         let NonZero(ref inner) = *self;\n         inner\n     }"}, {"sha": "091e9c889da47ecdf93334aab837526b3e26ff7f", "filename": "src/libcore/num/flt2dec/bignum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -211,7 +211,7 @@ macro_rules! define_bignum {\n                 self\n             }\n \n-            pub fn add_small<'a>(&'a mut self, other: $ty) -> &'a mut $name {\n+            pub fn add_small(&mut self, other: $ty) -> &mut $name {\n                 use num::flt2dec::bignum::FullOps;\n \n                 let (mut carry, v) = self.base[0].full_add(other, false);\n@@ -248,7 +248,7 @@ macro_rules! define_bignum {\n \n             /// Multiplies itself by a digit-sized `other` and returns its own\n             /// mutable reference.\n-            pub fn mul_small<'a>(&'a mut self, other: $ty) -> &'a mut $name {\n+            pub fn mul_small(&mut self, other: $ty) -> &mut $name {\n                 use num::flt2dec::bignum::FullOps;\n \n                 let mut sz = self.size;\n@@ -267,7 +267,7 @@ macro_rules! define_bignum {\n             }\n \n             /// Multiplies itself by `2^bits` and returns its own mutable reference.\n-            pub fn mul_pow2<'a>(&'a mut self, bits: usize) -> &'a mut $name {\n+            pub fn mul_pow2(&mut self, bits: usize) -> &mut $name {\n                 use mem;\n \n                 let digitbits = mem::size_of::<$ty>() * 8;\n@@ -308,7 +308,7 @@ macro_rules! define_bignum {\n             }\n \n             /// Multiplies itself by `5^e` and returns its own mutable reference.\n-            pub fn mul_pow5<'a>(&'a mut self, mut e: usize) -> &'a mut $name {\n+            pub fn mul_pow5(&mut self, mut e: usize) -> &mut $name {\n                 use mem;\n                 use num::flt2dec::bignum::SMALL_POW5;\n \n@@ -377,7 +377,7 @@ macro_rules! define_bignum {\n \n             /// Divides itself by a digit-sized `other` and returns its own\n             /// mutable reference *and* the remainder.\n-            pub fn div_rem_small<'a>(&'a mut self, other: $ty) -> (&'a mut $name, $ty) {\n+            pub fn div_rem_small(&mut self, other: $ty) -> (&mut $name, $ty) {\n                 use num::flt2dec::bignum::FullOps;\n \n                 assert!(other > 0);"}, {"sha": "40aa2a527dbc5607d4ead32b4a97fb8bbf6984c9", "filename": "src/libcore/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -42,7 +42,7 @@ static POW10TO256: [Digit; 27] =\n      0xcc5573c0, 0x65f9ef17, 0x55bc28f2, 0x80dcc7f7, 0xf46eeddc, 0x5fdcefce, 0x553f7];\n \n #[doc(hidden)]\n-pub fn mul_pow10<'a>(x: &'a mut Big, n: usize) -> &'a mut Big {\n+pub fn mul_pow10(x: &mut Big, n: usize) -> &mut Big {\n     debug_assert!(n < 512);\n     if n &   7 != 0 { x.mul_small(POW10[n & 7]); }\n     if n &   8 != 0 { x.mul_small(POW10[8]); }\n@@ -54,7 +54,7 @@ pub fn mul_pow10<'a>(x: &'a mut Big, n: usize) -> &'a mut Big {\n     x\n }\n \n-fn div_2pow10<'a>(x: &'a mut Big, mut n: usize) -> &'a mut Big {\n+fn div_2pow10(x: &mut Big, mut n: usize) -> &mut Big {\n     let largest = POW10.len() - 1;\n     while n > largest {\n         x.div_rem_small(POW10[largest]);"}, {"sha": "07de4d0761baadf7db47c3bddb3f82199fc80bcf", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -965,7 +965,7 @@ pub trait Index<Idx: ?Sized> {\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn index<'a>(&'a self, index: Idx) -> &'a Self::Output;\n+    fn index(&self, index: Idx) -> &Self::Output;\n }\n \n /// The `IndexMut` trait is used to specify the functionality of indexing\n@@ -1008,7 +1008,7 @@ pub trait Index<Idx: ?Sized> {\n pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n     /// The method for the indexing (`Foo[Bar]`) operation\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn index_mut<'a>(&'a mut self, index: Idx) -> &'a mut Self::Output;\n+    fn index_mut(&mut self, index: Idx) -> &mut Self::Output;\n }\n \n /// An unbounded range.\n@@ -1119,7 +1119,7 @@ pub trait Deref {\n \n     /// The method called to dereference a value\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn deref<'a>(&'a self) -> &'a Self::Target;\n+    fn deref(&self) -> &Self::Target;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1180,7 +1180,7 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n pub trait DerefMut: Deref {\n     /// The method called to mutably dereference a value\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn deref_mut<'a>(&'a mut self) -> &'a mut Self::Target;\n+    fn deref_mut(&mut self) -> &mut Self::Target;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "1434617baddce5cf0eeccf3b5248ed229c225394", "filename": "src/libcore/option.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -241,7 +241,7 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn as_ref<'r>(&'r self) -> Option<&'r T> {\n+    pub fn as_ref(&self) -> Option<&T> {\n         match *self {\n             Some(ref x) => Some(x),\n             None => None,\n@@ -262,7 +262,7 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {\n+    pub fn as_mut(&mut self) -> Option<&mut T> {\n         match *self {\n             Some(ref mut x) => Some(x),\n             None => None,\n@@ -289,7 +289,7 @@ impl<T> Option<T> {\n     #[unstable(feature = \"as_slice\",\n                reason = \"waiting for mut conventions\",\n                issue = \"27776\")]\n-    pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n+    pub fn as_mut_slice(&mut self) -> &mut [T] {\n         match *self {\n             Some(ref mut x) => {\n                 let result: &mut [T] = slice::mut_ref_slice(x);\n@@ -692,7 +692,7 @@ impl<T> Option<T> {\n     #[inline]\n     #[unstable(feature = \"as_slice\", since = \"unsure of the utility here\",\n                issue = \"27776\")]\n-    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n+    pub fn as_slice(&self) -> &[T] {\n         match *self {\n             Some(ref x) => slice::ref_slice(x),\n             None => {"}, {"sha": "83bdaf0923e809b6912e41990482e7713dc7c96e", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -51,7 +51,7 @@ pub use intrinsics::write_bytes;\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn null<T>() -> *const T { 0 as *const T }\n+pub const fn null<T>() -> *const T { 0 as *const T }\n \n /// Creates a null mutable raw pointer.\n ///\n@@ -65,7 +65,7 @@ pub fn null<T>() -> *const T { 0 as *const T }\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n+pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n /// Swaps the values at two mutable locations of the same type, without\n /// deinitialising either. They may overlap, unlike `mem::swap` which is\n@@ -163,7 +163,7 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_null(self) -> bool where T: Sized {\n-        self == 0 as *const T\n+        self == null()\n     }\n \n     /// Returns `None` if the pointer is null, or else returns a reference to\n@@ -212,7 +212,7 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_null(self) -> bool where T: Sized {\n-        self == 0 as *mut T\n+        self == null_mut()\n     }\n \n     /// Returns `None` if the pointer is null, or else returns a reference to\n@@ -468,7 +468,7 @@ impl<T:?Sized> Deref for Unique<T> {\n     type Target = *mut T;\n \n     #[inline]\n-    fn deref<'a>(&'a self) -> &'a *mut T {\n+    fn deref(&self) -> &*mut T {\n         unsafe { mem::transmute(&*self.pointer) }\n     }\n }"}, {"sha": "cf605f507bca66db2b25854e0cae188f17cea6f5", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -69,48 +69,48 @@ use raw::Slice as RawSlice;\n pub trait SliceExt {\n     type Item;\n \n-    fn split_at<'a>(&'a self, mid: usize) -> (&'a [Self::Item], &'a [Self::Item]);\n-    fn iter<'a>(&'a self) -> Iter<'a, Self::Item>;\n-    fn split<'a, P>(&'a self, pred: P) -> Split<'a, Self::Item, P>\n+    fn split_at(&self, mid: usize) -> (&[Self::Item], &[Self::Item]);\n+    fn iter(&self) -> Iter<Self::Item>;\n+    fn split<P>(&self, pred: P) -> Split<Self::Item, P>\n                     where P: FnMut(&Self::Item) -> bool;\n-    fn splitn<'a, P>(&'a self, n: usize, pred: P) -> SplitN<'a, Self::Item, P>\n+    fn splitn<P>(&self, n: usize, pred: P) -> SplitN<Self::Item, P>\n                      where P: FnMut(&Self::Item) -> bool;\n-    fn rsplitn<'a, P>(&'a self,  n: usize, pred: P) -> RSplitN<'a, Self::Item, P>\n+    fn rsplitn<P>(&self,  n: usize, pred: P) -> RSplitN<Self::Item, P>\n                       where P: FnMut(&Self::Item) -> bool;\n-    fn windows<'a>(&'a self, size: usize) -> Windows<'a, Self::Item>;\n-    fn chunks<'a>(&'a self, size: usize) -> Chunks<'a, Self::Item>;\n-    fn get<'a>(&'a self, index: usize) -> Option<&'a Self::Item>;\n-    fn first<'a>(&'a self) -> Option<&'a Self::Item>;\n-    fn tail<'a>(&'a self) -> &'a [Self::Item];\n-    fn init<'a>(&'a self) -> &'a [Self::Item];\n-    fn split_first<'a>(&'a self) -> Option<(&'a Self::Item, &'a [Self::Item])>;\n-    fn split_last<'a>(&'a self) -> Option<(&'a Self::Item, &'a [Self::Item])>;\n-    fn last<'a>(&'a self) -> Option<&'a Self::Item>;\n-    unsafe fn get_unchecked<'a>(&'a self, index: usize) -> &'a Self::Item;\n+    fn windows(&self, size: usize) -> Windows<Self::Item>;\n+    fn chunks(&self, size: usize) -> Chunks<Self::Item>;\n+    fn get(&self, index: usize) -> Option<&Self::Item>;\n+    fn first(&self) -> Option<&Self::Item>;\n+    fn tail(&self) -> &[Self::Item];\n+    fn init(&self) -> &[Self::Item];\n+    fn split_first(&self) -> Option<(&Self::Item, &[Self::Item])>;\n+    fn split_last(&self) -> Option<(&Self::Item, &[Self::Item])>;\n+    fn last(&self) -> Option<&Self::Item>;\n+    unsafe fn get_unchecked(&self, index: usize) -> &Self::Item;\n     fn as_ptr(&self) -> *const Self::Item;\n     fn binary_search_by<F>(&self, f: F) -> Result<usize, usize> where\n         F: FnMut(&Self::Item) -> Ordering;\n     fn len(&self) -> usize;\n     fn is_empty(&self) -> bool { self.len() == 0 }\n-    fn get_mut<'a>(&'a mut self, index: usize) -> Option<&'a mut Self::Item>;\n-    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, Self::Item>;\n-    fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n-    fn tail_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n-    fn init_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n-    fn split_first_mut<'a>(&'a mut self) -> Option<(&'a mut Self::Item, &'a mut [Self::Item])>;\n-    fn split_last_mut<'a>(&'a mut self) -> Option<(&'a mut Self::Item, &'a mut [Self::Item])>;\n-    fn last_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n-    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, Self::Item, P>\n+    fn get_mut(&mut self, index: usize) -> Option<&mut Self::Item>;\n+    fn iter_mut(&mut self) -> IterMut<Self::Item>;\n+    fn first_mut(&mut self) -> Option<&mut Self::Item>;\n+    fn tail_mut(&mut self) -> &mut [Self::Item];\n+    fn init_mut(&mut self) -> &mut [Self::Item];\n+    fn split_first_mut(&mut self) -> Option<(&mut Self::Item, &mut [Self::Item])>;\n+    fn split_last_mut(&mut self) -> Option<(&mut Self::Item, &mut [Self::Item])>;\n+    fn last_mut(&mut self) -> Option<&mut Self::Item>;\n+    fn split_mut<P>(&mut self, pred: P) -> SplitMut<Self::Item, P>\n                         where P: FnMut(&Self::Item) -> bool;\n     fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<Self::Item, P>\n                      where P: FnMut(&Self::Item) -> bool;\n     fn rsplitn_mut<P>(&mut self,  n: usize, pred: P) -> RSplitNMut<Self::Item, P>\n                       where P: FnMut(&Self::Item) -> bool;\n-    fn chunks_mut<'a>(&'a mut self, chunk_size: usize) -> ChunksMut<'a, Self::Item>;\n+    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<Self::Item>;\n     fn swap(&mut self, a: usize, b: usize);\n-    fn split_at_mut<'a>(&'a mut self, mid: usize) -> (&'a mut [Self::Item], &'a mut [Self::Item]);\n+    fn split_at_mut(&mut self, mid: usize) -> (&mut [Self::Item], &mut [Self::Item]);\n     fn reverse(&mut self);\n-    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: usize) -> &'a mut Self::Item;\n+    unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut Self::Item;\n     fn as_mut_ptr(&mut self) -> *mut Self::Item;\n \n     fn position_elem(&self, t: &Self::Item) -> Option<usize> where Self::Item: PartialEq;\n@@ -163,7 +163,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn iter<'a>(&'a self) -> Iter<'a, T> {\n+    fn iter(&self) -> Iter<T> {\n         unsafe {\n             let p = if mem::size_of::<T>() == 0 {\n                 1 as *const _\n@@ -182,7 +182,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn split<'a, P>(&'a self, pred: P) -> Split<'a, T, P> where P: FnMut(&T) -> bool {\n+    fn split<P>(&self, pred: P) -> Split<T, P> where P: FnMut(&T) -> bool {\n         Split {\n             v: self,\n             pred: pred,\n@@ -191,7 +191,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn splitn<'a, P>(&'a self, n: usize, pred: P) -> SplitN<'a, T, P> where\n+    fn splitn<P>(&self, n: usize, pred: P) -> SplitN<T, P> where\n         P: FnMut(&T) -> bool,\n     {\n         SplitN {\n@@ -204,7 +204,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn rsplitn<'a, P>(&'a self, n: usize, pred: P) -> RSplitN<'a, T, P> where\n+    fn rsplitn<P>(&self, n: usize, pred: P) -> RSplitN<T, P> where\n         P: FnMut(&T) -> bool,\n     {\n         RSplitN {\n@@ -311,7 +311,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n+    fn iter_mut(&mut self) -> IterMut<T> {\n         unsafe {\n             let p = if mem::size_of::<T>() == 0 {\n                 1 as *mut _\n@@ -368,12 +368,12 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    fn split_mut<P>(&mut self, pred: P) -> SplitMut<T, P> where P: FnMut(&T) -> bool {\n         SplitMut { v: self, pred: pred, finished: false }\n     }\n \n     #[inline]\n-    fn splitn_mut<'a, P>(&'a mut self, n: usize, pred: P) -> SplitNMut<'a, T, P> where\n+    fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<T, P> where\n         P: FnMut(&T) -> bool\n     {\n         SplitNMut {\n@@ -386,7 +386,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn rsplitn_mut<'a, P>(&'a mut self, n: usize, pred: P) -> RSplitNMut<'a, T, P> where\n+    fn rsplitn_mut<P>(&mut self, n: usize, pred: P) -> RSplitNMut<T, P> where\n         P: FnMut(&T) -> bool,\n     {\n         RSplitNMut {\n@@ -1410,15 +1410,15 @@ impl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n #[unstable(feature = \"ref_slice\", issue = \"27774\")]\n-pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n+pub fn ref_slice<A>(s: &A) -> &[A] {\n     unsafe {\n         from_raw_parts(s, 1)\n     }\n }\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n #[unstable(feature = \"ref_slice\", issue = \"27774\")]\n-pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n+pub fn mut_ref_slice<A>(s: &mut A) -> &mut [A] {\n     unsafe {\n         from_raw_parts_mut(s, 1)\n     }"}, {"sha": "4612fc8900861f0b5e5918ecbd6c2a7b2852bf52", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -142,7 +142,7 @@ pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n /// that the string contains valid UTF-8.\n #[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n+pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n     mem::transmute(v)\n }\n \n@@ -1270,9 +1270,9 @@ pub trait StrExt {\n \n     fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n     fn contains_char<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n-    fn chars<'a>(&'a self) -> Chars<'a>;\n-    fn bytes<'a>(&'a self) -> Bytes<'a>;\n-    fn char_indices<'a>(&'a self) -> CharIndices<'a>;\n+    fn chars(&self) -> Chars;\n+    fn bytes(&self) -> Bytes;\n+    fn char_indices(&self) -> CharIndices;\n     fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P>;\n     fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n         where P::Searcher: ReverseSearcher<'a>;\n@@ -1288,12 +1288,12 @@ pub trait StrExt {\n     fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P>;\n     fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n         where P::Searcher: ReverseSearcher<'a>;\n-    fn lines<'a>(&'a self) -> Lines<'a>;\n-    fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n+    fn lines(&self) -> Lines;\n+    fn lines_any(&self) -> LinesAny;\n     fn char_len(&self) -> usize;\n-    fn slice_chars<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n-    unsafe fn slice_unchecked<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n-    unsafe fn slice_mut_unchecked<'a>(&'a mut self, begin: usize, end: usize) -> &'a mut str;\n+    fn slice_chars(&self, begin: usize, end: usize) -> &str;\n+    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str;\n+    unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str;\n     fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n     fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n         where P::Searcher: ReverseSearcher<'a>;\n@@ -1307,14 +1307,14 @@ pub trait StrExt {\n     fn char_range_at_reverse(&self, start: usize) -> CharRange;\n     fn char_at(&self, i: usize) -> char;\n     fn char_at_reverse(&self, i: usize) -> char;\n-    fn as_bytes<'a>(&'a self) -> &'a [u8];\n+    fn as_bytes(&self) -> &[u8];\n     fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;\n     fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n         where P::Searcher: ReverseSearcher<'a>;\n     fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;\n     fn split_at(&self, mid: usize) -> (&str, &str);\n     fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str);\n-    fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;\n+    fn slice_shift_char(&self) -> Option<(char, &str)>;\n     fn subslice_offset(&self, inner: &str) -> usize;\n     fn as_ptr(&self) -> *const u8;\n     fn len(&self) -> usize;"}, {"sha": "4517c2f915773a78b86267277188734874df8457", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -184,6 +184,7 @@ use std::io::{self, Stderr};\n use std::io::prelude::*;\n use std::mem;\n use std::env;\n+use std::ptr;\n use std::rt;\n use std::slice;\n use std::sync::{Once, StaticMutex};\n@@ -209,11 +210,10 @@ static LOCK: StaticMutex = StaticMutex::new();\n /// logging statement should be run.\n static mut LOG_LEVEL: u32 = MAX_LOG_LEVEL;\n \n-static mut DIRECTIVES: *mut Vec<directive::LogDirective> =\n-    0 as *mut Vec<directive::LogDirective>;\n+static mut DIRECTIVES: *mut Vec<directive::LogDirective> = ptr::null_mut();\n \n /// Optional filter.\n-static mut FILTER: *mut String = 0 as *mut _;\n+static mut FILTER: *mut String = ptr::null_mut();\n \n /// Debug log level\n pub const DEBUG: u32 = 4;"}, {"sha": "215368754c999b9e3bf2d7edaac5a24ecf233343", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -344,7 +344,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n \n     // Step 3: Mark all destructors as reachable.\n     //\n-    // FIXME(pcwalton): This is a conservative overapproximation, but fixing\n+    // FIXME #10732: This is a conservative overapproximation, but fixing\n     // this properly would result in the necessity of computing *type*\n     // reachability, which might result in a compile time loss.\n     fn mark_destructors_reachable(&mut self) {"}, {"sha": "76bbce00f19dc3be0b91ea2f401801461b873162", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -18,6 +18,7 @@ use std::io;\n use std::mem;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Output, Stdio};\n+use std::ptr;\n use std::str;\n \n use libc;\n@@ -449,7 +450,7 @@ impl<'a> ArchiveBuilder<'a> {\n                     }\n \n                     let name = try!(CString::new(child_name));\n-                    members.push(llvm::LLVMRustArchiveMemberNew(0 as *const _,\n+                    members.push(llvm::LLVMRustArchiveMemberNew(ptr::null(),\n                                                                 name.as_ptr(),\n                                                                 child.raw()));\n                     strings.push(name);\n@@ -462,7 +463,7 @@ impl<'a> ArchiveBuilder<'a> {\n                         let name = try!(CString::new(name_in_archive));\n                         members.push(llvm::LLVMRustArchiveMemberNew(path.as_ptr(),\n                                                                     name.as_ptr(),\n-                                                                    0 as *mut _));\n+                                                                    ptr::null_mut()));\n                         strings.push(path);\n                         strings.push(name);\n                     }\n@@ -472,7 +473,7 @@ impl<'a> ArchiveBuilder<'a> {\n                             if skip(child_name) { continue }\n \n                             let name = try!(CString::new(child_name));\n-                            let m = llvm::LLVMRustArchiveMemberNew(0 as *const _,\n+                            let m = llvm::LLVMRustArchiveMemberNew(ptr::null(),\n                                                                    name.as_ptr(),\n                                                                    child.raw());\n                             members.push(m);"}, {"sha": "d178565e18f592b18132dea1add2f256d58b0cda", "filename": "src/librustc_trans/back/msvc/registry.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -12,6 +12,7 @@ use std::io;\n use std::ffi::{OsString, OsStr};\n use std::os::windows::prelude::*;\n use std::ops::RangeFrom;\n+use std::ptr;\n use libc::{DWORD, LPCWSTR, LONG, LPDWORD, LPBYTE, ERROR_SUCCESS};\n use libc::c_void;\n \n@@ -88,7 +89,7 @@ impl RegistryKey {\n \n     pub fn open(&self, key: &OsStr) -> io::Result<RegistryKey> {\n         let key = key.encode_wide().chain(Some(0)).collect::<Vec<_>>();\n-        let mut ret = 0 as *mut _;\n+        let mut ret = ptr::null_mut();\n         let err = unsafe {\n             RegOpenKeyExW(self.raw(), key.as_ptr(), 0,\n                           KEY_READ | KEY_WOW64_32KEY, &mut ret)\n@@ -110,8 +111,8 @@ impl RegistryKey {\n         let mut len = 0;\n         let mut kind = 0;\n         unsafe {\n-            let err = RegQueryValueExW(self.raw(), name.as_ptr(), 0 as *mut _,\n-                                       &mut kind, 0 as *mut _, &mut len);\n+            let err = RegQueryValueExW(self.raw(), name.as_ptr(), ptr::null_mut(),\n+                                       &mut kind, ptr::null_mut(), &mut len);\n             if err != ERROR_SUCCESS {\n                 return Err(io::Error::from_raw_os_error(err as i32))\n             }\n@@ -124,8 +125,8 @@ impl RegistryKey {\n             // characters so we need to be sure to halve it for the capacity\n             // passed in.\n             let mut v = Vec::with_capacity(len as usize / 2);\n-            let err = RegQueryValueExW(self.raw(), name.as_ptr(), 0 as *mut _,\n-                                       0 as *mut _, v.as_mut_ptr() as *mut _,\n+            let err = RegQueryValueExW(self.raw(), name.as_ptr(), ptr::null_mut(),\n+                                       ptr::null_mut(), v.as_mut_ptr() as *mut _,\n                                        &mut len);\n             if err != ERROR_SUCCESS {\n                 return Err(io::Error::from_raw_os_error(err as i32))\n@@ -156,8 +157,8 @@ impl<'a> Iterator for Iter<'a> {\n             let mut v = Vec::with_capacity(256);\n             let mut len = v.capacity() as DWORD;\n             let ret = RegEnumKeyExW(self.key.raw(), i, v.as_mut_ptr(), &mut len,\n-                                    0 as *mut _, 0 as *mut _, 0 as *mut _,\n-                                    0 as *mut _);\n+                                    ptr::null_mut(), ptr::null_mut(), ptr::null_mut(),\n+                                    ptr::null_mut());\n             if ret == ERROR_NO_MORE_ITEMS as LONG {\n                 None\n             } else if ret != ERROR_SUCCESS {"}, {"sha": "dfce7a9c31584e3b501c46737a2101dad860c38d", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -2299,6 +2299,21 @@ extern \"rust-intrinsic\" {\n ```\n \"##,\n \n+E0214: r##\"\n+A generic type was described using parentheses rather than angle brackets. For\n+example:\n+\n+```\n+fn main() {\n+    let v: Vec(&str) = vec![\"foo\"];\n+}\n+```\n+\n+This is not currently supported: `v` should be defined as `Vec<&str>`.\n+Parentheses are currently only used with generic types when defining parameters\n+for `Fn`-family traits.\n+\"##,\n+\n E0220: r##\"\n You used an associated type which isn't defined in the trait.\n Erroneous code example:\n@@ -2705,6 +2720,37 @@ fn main() {\n ```\n \"##,\n \n+E0329: r##\"\n+An attempt was made to access an associated constant through either a generic\n+type parameter or `Self`. This is not supported yet. An example causing this\n+error is shown below:\n+\n+```\n+trait Foo {\n+    const BAR: f64;\n+}\n+\n+struct MyStruct;\n+\n+impl Foo for MyStruct {\n+    const BAR: f64 = 0f64;\n+}\n+\n+fn get_bar_bad<F: Foo>(t: F) -> f64 {\n+    F::BAR\n+}\n+```\n+\n+Currently, the value of `BAR` for a particular type can only be accessed through\n+a concrete type, as shown below:\n+\n+```\n+fn get_bar_good() -> f64 {\n+    <MyStruct as Foo>::BAR\n+}\n+```\n+\"##,\n+\n E0366: r##\"\n An attempt was made to implement `Drop` on a concrete specialization of a\n generic type. An example is shown below:\n@@ -3219,7 +3265,6 @@ register_diagnostics! {\n //  E0209, // builtin traits can only be implemented on structs or enums\n     E0212, // cannot extract an associated type from a higher-ranked trait bound\n //  E0213, // associated types are not accepted in this context\n-    E0214, // parenthesized parameters may only be used with a trait\n //  E0215, // angle-bracket notation is not stable with `Fn`\n //  E0216, // parenthetical notation is only stable with `Fn`\n //  E0217, // ambiguous associated type, defined in multiple supertraits\n@@ -3251,7 +3296,6 @@ register_diagnostics! {\n     E0320, // recursive overflow during dropck\n     E0321, // extended coherence rules for defaulted traits violated\n     E0328, // cannot implement Unsize explicitly\n-    E0329, // associated const depends on type parameter or Self.\n     E0374, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with one field being coerced, none found\n     E0375, // the trait `CoerceUnsized` may only be implemented for a coercion"}, {"sha": "ad17a650336c56a3f901fd3d96a719e33d983982", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -11,6 +11,7 @@\n use prelude::v1::*;\n \n use cell::Cell;\n+use ptr;\n use rt;\n use sync::{StaticMutex, Arc};\n \n@@ -26,7 +27,7 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n     pub const fn new(init: fn() -> Arc<T>) -> Lazy<T> {\n         Lazy {\n             lock: StaticMutex::new(),\n-            ptr: Cell::new(0 as *mut _),\n+            ptr: Cell::new(ptr::null_mut()),\n             init: init\n         }\n     }"}, {"sha": "1df9642d3bb744eda3df83f656fb935680d065c5", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -185,6 +185,7 @@ mod imp {\n \n     use io;\n     use mem;\n+    use ptr;\n     use rand::Rng;\n     use libc::{c_int, size_t};\n \n@@ -207,7 +208,7 @@ mod imp {\n     enum SecRandom {}\n \n     #[allow(non_upper_case_globals)]\n-    const kSecRandomDefault: *const SecRandom = 0 as *const SecRandom;\n+    const kSecRandomDefault: *const SecRandom = ptr::null();\n \n     #[link(name = \"Security\", kind = \"framework\")]\n     extern \"C\" {"}, {"sha": "54e5b499e537acf9bfa234549178be50bbf4516c", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -18,6 +18,7 @@\n \n use alloc::boxed::FnBox;\n use boxed::Box;\n+use ptr;\n use sys_common::mutex::Mutex;\n use vec::Vec;\n \n@@ -28,7 +29,7 @@ type Queue = Vec<Box<FnBox()>>;\n // the thread infrastructure to be in place (useful on the borders of\n // initialization/destruction).\n static LOCK: Mutex = Mutex::new();\n-static mut QUEUE: *mut Queue = 0 as *mut Queue;\n+static mut QUEUE: *mut Queue = ptr::null_mut();\n \n // The maximum number of times the cleanup routines will be run. While running\n // the at_exit closures new ones may be registered, and this count is the number"}, {"sha": "8c7937581665bd19b700f4fcbc00ceda8cb2eec5", "filename": "src/libstd/rt/unwind/seh.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Frt%2Funwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Frt%2Funwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fseh.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -53,6 +53,7 @@ use prelude::v1::*;\n \n use any::Any;\n use libc::{c_ulong, DWORD, c_void};\n+use ptr;\n use sys_common::thread_local::StaticKey;\n \n //                        0x R U S T\n@@ -98,7 +99,7 @@ pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n     rtassert!(PANIC_DATA.get().is_null());\n     PANIC_DATA.set(Box::into_raw(exception) as *mut u8);\n \n-    RaiseException(RUST_PANIC, 0, 0, 0 as *const _);\n+    RaiseException(RUST_PANIC, 0, 0, ptr::null());\n     rtabort!(\"could not unwind stack\");\n }\n \n@@ -108,7 +109,7 @@ pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send + 'static> {\n     rtassert!(ptr as DWORD == RUST_PANIC);\n \n     let data = PANIC_DATA.get() as *mut Box<Any + Send + 'static>;\n-    PANIC_DATA.set(0 as *mut u8);\n+    PANIC_DATA.set(ptr::null_mut());\n     rtassert!(!data.is_null());\n \n     *Box::from_raw(data)"}, {"sha": "4fb3134eac99c79638b360f90197e4bce0beb585", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -16,6 +16,7 @@ use io::{self, Error, ErrorKind};\n use libc::{self, c_int, c_char, c_void, socklen_t};\n use mem;\n use net::{SocketAddr, Shutdown, IpAddr};\n+use ptr;\n use str::from_utf8;\n use sys::c;\n use sys::net::{cvt, cvt_r, cvt_gai, Socket, init, wrlen_t};\n@@ -123,9 +124,9 @@ pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     init();\n \n     let c_host = try!(CString::new(host));\n-    let mut res = 0 as *mut _;\n+    let mut res = ptr::null_mut();\n     unsafe {\n-        try!(cvt_gai(getaddrinfo(c_host.as_ptr(), 0 as *const _, 0 as *const _,\n+        try!(cvt_gai(getaddrinfo(c_host.as_ptr(), ptr::null(), ptr::null(),\n                                  &mut res)));\n         Ok(LookupHost { original: res, cur: res })\n     }\n@@ -154,7 +155,7 @@ pub fn lookup_addr(addr: &IpAddr) -> io::Result<String> {\n     let data = unsafe {\n         try!(cvt_gai(getnameinfo(inner, len,\n                                  hostbuf.as_mut_ptr(), NI_MAXHOST as libc::size_t,\n-                                 0 as *mut _, 0, 0)));\n+                                 ptr::null_mut(), 0, 0)));\n \n         CStr::from_ptr(hostbuf.as_ptr())\n     };"}, {"sha": "5640eb81f2ae350177da3864a10787928b89410d", "filename": "src/libstd/sys/unix/backtrace/printing/libbacktrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Flibbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Flibbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Flibbacktrace.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -123,7 +123,7 @@ pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n     // FIXME: We also call self_exe_name() on DragonFly BSD. I haven't\n     //        tested if this is required or not.\n     unsafe fn init_state() -> *mut backtrace_state {\n-        static mut STATE: *mut backtrace_state = 0 as *mut backtrace_state;\n+        static mut STATE: *mut backtrace_state = ptr::null_mut();\n         static mut LAST_FILENAME: [libc::c_char; 256] = [0; 256];\n         if !STATE.is_null() { return STATE }\n         let selfname = if cfg!(target_os = \"freebsd\") ||"}, {"sha": "70be04b631ad5d7d56275efe00d9d695dd134306", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -291,7 +291,7 @@ pub fn args() -> Args {\n     };\n     Args {\n         iter: vec.into_iter(),\n-        _dont_send_or_sync_me: 0 as *mut (),\n+        _dont_send_or_sync_me: ptr::null_mut(),\n     }\n }\n \n@@ -347,7 +347,7 @@ pub fn args() -> Args {\n         }\n     }\n \n-    Args { iter: res.into_iter(), _dont_send_or_sync_me: 0 as *mut _ }\n+    Args { iter: res.into_iter(), _dont_send_or_sync_me: ptr::null_mut() }\n }\n \n #[cfg(any(target_os = \"linux\",\n@@ -363,7 +363,7 @@ pub fn args() -> Args {\n     let v: Vec<OsString> = bytes.into_iter().map(|v| {\n         OsStringExt::from_vec(v)\n     }).collect();\n-    Args { iter: v.into_iter(), _dont_send_or_sync_me: 0 as *mut _ }\n+    Args { iter: v.into_iter(), _dont_send_or_sync_me: ptr::null_mut() }\n }\n \n pub struct Env {\n@@ -403,7 +403,7 @@ pub fn env() -> Env {\n             result.push(parse(CStr::from_ptr(*environ).to_bytes()));\n             environ = environ.offset(1);\n         }\n-        Env { iter: result.into_iter(), _dont_send_or_sync_me: 0 as *mut _ }\n+        Env { iter: result.into_iter(), _dont_send_or_sync_me: ptr::null_mut() }\n     };\n \n     fn parse(input: &[u8]) -> (OsString, OsString) {\n@@ -481,7 +481,7 @@ pub fn home_dir() -> Option<PathBuf> {\n         loop {\n             let mut buf = Vec::with_capacity(amt);\n             let mut passwd: c::passwd = mem::zeroed();\n-            let mut result = 0 as *mut _;\n+            let mut result = ptr::null_mut();\n             match c::getpwuid_r(me, &mut passwd, buf.as_mut_ptr(),\n                                 buf.capacity() as libc::size_t,\n                                 &mut result) {"}, {"sha": "12ca31ce5e1e40383efd076cb33f705ed16637a9", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -405,7 +405,7 @@ fn make_envp(env: Option<&HashMap<OsString, OsString>>)\n \n         (ptrs.as_ptr() as *const _, tmps, ptrs)\n     } else {\n-        (0 as *const _, Vec::new(), Vec::new())\n+        (ptr::null(), Vec::new(), Vec::new())\n     }\n }\n "}, {"sha": "de9e8cf97e68f6f79b658deb31f9f65f1892066a", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -93,7 +93,7 @@ mod imp {\n         // See comment above for why this function returns.\n     }\n \n-    static mut MAIN_ALTSTACK: *mut libc::c_void = 0 as *mut libc::c_void;\n+    static mut MAIN_ALTSTACK: *mut libc::c_void = ptr::null_mut();\n \n     pub unsafe fn init() {\n         PAGE_SIZE = ::sys::os::page_size();\n@@ -146,7 +146,7 @@ mod imp {\n               target_os = \"netbsd\",\n               target_os = \"openbsd\")))]\n mod imp {\n-    use libc;\n+    use ptr;\n \n     pub unsafe fn init() {\n     }\n@@ -155,7 +155,7 @@ mod imp {\n     }\n \n     pub unsafe fn make_handler() -> super::Handler {\n-        super::Handler { _data: 0 as *mut libc::c_void }\n+        super::Handler { _data: ptr::null_mut() }\n     }\n \n     pub unsafe fn drop_handler(_handler: &mut super::Handler) {"}, {"sha": "4e49b6473c94b0c764d84a02c94f0524ee80bdfe", "filename": "src/libstd/sys/unix/sync.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fsync.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -59,15 +59,16 @@ extern {\n           target_os = \"openbsd\"))]\n mod os {\n     use libc;\n+    use ptr;\n \n     pub type pthread_mutex_t = *mut libc::c_void;\n     pub type pthread_mutexattr_t = *mut libc::c_void;\n     pub type pthread_cond_t = *mut libc::c_void;\n     pub type pthread_rwlock_t = *mut libc::c_void;\n \n-    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = 0 as *mut _;\n-    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = 0 as *mut _;\n-    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = 0 as *mut _;\n+    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = ptr::null_mut();\n+    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = ptr::null_mut();\n+    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = ptr::null_mut();\n     pub const PTHREAD_MUTEX_RECURSIVE: libc::c_int = 2;\n }\n \n@@ -213,6 +214,7 @@ mod os {\n #[cfg(target_os = \"android\")]\n mod os {\n     use libc;\n+    use ptr;\n \n     #[repr(C)]\n     pub struct pthread_mutex_t { value: libc::c_int }\n@@ -243,7 +245,7 @@ mod os {\n         writerThreadId: 0,\n         pendingReaders: 0,\n         pendingWriters: 0,\n-        reserved: [0 as *mut _; 4],\n+        reserved: [ptr::null_mut(); 4],\n     };\n     pub const PTHREAD_MUTEX_RECURSIVE: libc::c_int = 1;\n }"}, {"sha": "5a551e2b3f33fd79c6ffeffd18d46ee749de7322", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -72,7 +72,7 @@ impl Thread {\n \n         extern fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n             unsafe { start_thread(main); }\n-            0 as *mut _\n+            ptr::null_mut()\n         }\n     }\n "}, {"sha": "30c7e5a52b7c776e688e183d5ec21a88014e4d52", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -16,6 +16,7 @@ use libc;\n use libc::{c_uint, c_ulong};\n use libc::{DWORD, BOOL, BOOLEAN, ERROR_CALL_NOT_IMPLEMENTED, LPVOID, HANDLE};\n use libc::{LPCWSTR, LONG};\n+use ptr;\n \n pub use self::GET_FILEEX_INFO_LEVELS::*;\n pub use self::FILE_INFO_BY_HANDLE_CLASS::*;\n@@ -294,9 +295,9 @@ pub struct CRITICAL_SECTION {\n }\n \n pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE {\n-    ptr: 0 as *mut _,\n+    ptr: ptr::null_mut(),\n };\n-pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: 0 as *mut _ };\n+pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: ptr::null_mut() };\n \n #[repr(C)]\n pub struct LUID {"}, {"sha": "e9d98b36a43f8e9089b059b1b4b653d37a3aeddd", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -328,12 +328,12 @@ impl File {\n             try!(cvt({\n                 c::DeviceIoControl(self.handle.raw(),\n                                    c::FSCTL_GET_REPARSE_POINT,\n-                                   0 as *mut _,\n+                                   ptr::null_mut(),\n                                    0,\n                                    space.as_mut_ptr() as *mut _,\n                                    space.len() as libc::DWORD,\n                                    &mut bytes,\n-                                   0 as *mut _)\n+                                   ptr::null_mut())\n             }));\n             Ok((bytes, &*(space.as_ptr() as *const c::REPARSE_DATA_BUFFER)))\n         }\n@@ -680,15 +680,15 @@ fn directory_junctions_are_directories() {\n                                    c::FSCTL_SET_REPARSE_POINT,\n                                    data.as_ptr() as *mut _,\n                                    (*db).ReparseDataLength + 8,\n-                                   0 as *mut _, 0,\n+                                   ptr::null_mut(), 0,\n                                    &mut ret,\n-                                   0 as *mut _)).map(|_| ())\n+                                   ptr::null_mut())).map(|_| ())\n         }\n     }\n \n     fn opendir(p: &Path, write: bool) -> io::Result<File> {\n         unsafe {\n-            let mut token = 0 as *mut _;\n+            let mut token = ptr::null_mut();\n             let mut tp: c::TOKEN_PRIVILEGES = mem::zeroed();\n             try!(cvt(c::OpenProcessToken(c::GetCurrentProcess(),\n                                          c::TOKEN_ADJUST_PRIVILEGES,\n@@ -699,14 +699,14 @@ fn directory_junctions_are_directories() {\n                 \"SeBackupPrivilege\".as_ref()\n             };\n             let name = name.encode_wide().chain(Some(0)).collect::<Vec<_>>();\n-            try!(cvt(c::LookupPrivilegeValueW(0 as *const _,\n+            try!(cvt(c::LookupPrivilegeValueW(ptr::null(),\n                                               name.as_ptr(),\n                                               &mut tp.Privileges[0].Luid)));\n             tp.PrivilegeCount = 1;\n             tp.Privileges[0].Attributes = c::SE_PRIVILEGE_ENABLED;\n             let size = mem::size_of::<c::TOKEN_PRIVILEGES>() as libc::DWORD;\n             try!(cvt(c::AdjustTokenPrivileges(token, libc::FALSE, &mut tp, size,\n-                                              0 as *mut _, 0 as *mut _)));\n+                                              ptr::null_mut(), ptr::null_mut())));\n             try!(cvt(libc::CloseHandle(token)));\n \n             File::open_reparse_point(p, write)\n@@ -726,9 +726,9 @@ fn directory_junctions_are_directories() {\n                                    c::FSCTL_DELETE_REPARSE_POINT,\n                                    data.as_ptr() as *mut _,\n                                    (*db).ReparseDataLength + 8,\n-                                   0 as *mut _, 0,\n+                                   ptr::null_mut(), 0,\n                                    &mut bytes,\n-                                   0 as *mut _)).map(|_| ())\n+                                   ptr::null_mut())).map(|_| ())\n         }\n     }\n }"}, {"sha": "e62b2d8cb18ffc01870e43028668f73c0d060f37", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -15,6 +15,7 @@ use mem;\n use net::SocketAddr;\n use num::One;\n use ops::Neg;\n+use ptr;\n use rt;\n use sync::Once;\n use sys;\n@@ -80,7 +81,7 @@ impl Socket {\n             SocketAddr::V6(..) => libc::AF_INET6,\n         };\n         let socket = try!(unsafe {\n-            match c::WSASocketW(fam, ty, 0, 0 as *mut _, 0,\n+            match c::WSASocketW(fam, ty, 0, ptr::null_mut(), 0,\n                                 c::WSA_FLAG_OVERLAPPED) {\n                 INVALID_SOCKET => Err(last_error()),\n                 n => Ok(Socket(n)),"}, {"sha": "3e2f442f073f6566f1f9d004bf916a9d2adf5570", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -10,6 +10,7 @@\n \n use io;\n use libc;\n+use ptr;\n use sys::cvt;\n use sys::c;\n use sys::handle::Handle;\n@@ -26,7 +27,7 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n     let mut reader = libc::INVALID_HANDLE_VALUE;\n     let mut writer = libc::INVALID_HANDLE_VALUE;\n     try!(cvt(unsafe {\n-        c::CreatePipe(&mut reader, &mut writer, 0 as *mut _, 0)\n+        c::CreatePipe(&mut reader, &mut writer, ptr::null_mut(), 0)\n     }));\n     let reader = Handle::new(reader);\n     let writer = Handle::new(writer);"}, {"sha": "17bc7ee8876935f077e198e4cd2c3b74c064955a", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -58,7 +58,7 @@ pub type Dtor = unsafe extern fn(*mut u8);\n // the thread infrastructure to be in place (useful on the borders of\n // initialization/destruction).\n static DTOR_LOCK: Mutex = Mutex::new();\n-static mut DTORS: *mut Vec<(Key, Dtor)> = 0 as *mut _;\n+static mut DTORS: *mut Vec<(Key, Dtor)> = ptr::null_mut();\n \n // -------------------------------------------------------------------------\n // Native bindings"}, {"sha": "87f58b4c84910c969816da518786843f2b25ea8a", "filename": "src/libstd/thread/scoped_tls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fscoped_tls.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -226,14 +226,15 @@ impl<T> ScopedKey<T> {\n #[doc(hidden)]\n mod imp {\n     use cell::Cell;\n+    use ptr;\n \n     pub struct KeyInner<T> { inner: Cell<*mut T> }\n \n     unsafe impl<T> ::marker::Sync for KeyInner<T> { }\n \n     impl<T> KeyInner<T> {\n         pub const fn new() -> KeyInner<T> {\n-            KeyInner { inner: Cell::new(0 as *mut _) }\n+            KeyInner { inner: Cell::new(ptr::null_mut()) }\n         }\n         pub unsafe fn set(&self, ptr: *mut T) { self.inner.set(ptr); }\n         pub unsafe fn get(&self) -> *mut T { self.inner.get() }"}, {"sha": "35bfc0c7d4fa5497076270ea6e5b8068081e55eb", "filename": "src/test/compile-fail/allocator-dylib-is-system.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Ftest%2Fcompile-fail%2Fallocator-dylib-is-system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Ftest%2Fcompile-fail%2Fallocator-dylib-is-system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator-dylib-is-system.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-msvc everything is the system allocator on msvc\n // ignore-musl no dylibs on musl yet\n+// ignore-bitrig no jemalloc on bitrig\n // aux-build:allocator-dylib.rs\n // no-prefer-dynamic\n // error-pattern: cannot link together two allocators"}, {"sha": "23f9efa2e6446681e9165a4b791c0dadf3318ab2", "filename": "src/test/compile-fail/allocator-rust-dylib-is-jemalloc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Ftest%2Fcompile-fail%2Fallocator-rust-dylib-is-jemalloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Ftest%2Fcompile-fail%2Fallocator-rust-dylib-is-jemalloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator-rust-dylib-is-jemalloc.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -10,6 +10,7 @@\n \n // ignore-msvc everything is the system allocator on msvc\n // ignore-musl no dylibs on musl right now\n+// ignore-bitrig no jemalloc on bitrig\n // aux-build:allocator-dylib2.rs\n // error-pattern: cannot link together two allocators\n "}, {"sha": "1dbdc5e4a5004d8bf49744ebf2c218eebe9b90a5", "filename": "src/test/run-pass/allocator-default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Ftest%2Frun-pass%2Fallocator-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Ftest%2Frun-pass%2Fallocator-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator-default.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -10,9 +10,9 @@\n \n #![feature(alloc_jemalloc, alloc_system)]\n \n-#[cfg(not(target_env = \"msvc\"))]\n+#[cfg(not(any(target_env = \"msvc\", target_os = \"bitrig\")))]\n extern crate alloc_jemalloc;\n-#[cfg(target_env = \"msvc\")]\n+#[cfg(any(target_env = \"msvc\", target_os = \"bitrig\"))]\n extern crate alloc_system;\n \n fn main() {"}, {"sha": "780c5e5884fae207ce9882f71a3c7c7990e860f1", "filename": "src/test/run-pass/allocator-jemalloc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Ftest%2Frun-pass%2Fallocator-jemalloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb/src%2Ftest%2Frun-pass%2Fallocator-jemalloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator-jemalloc.rs?ref=1b908be9a0d7aaf8f18854db1ffef7b8df10dfeb", "patch": "@@ -10,6 +10,7 @@\n \n // no-prefer-dynamic\n // ignore-msvc no jemalloc on msvc\n+// ignore-bitrig no jemalloc on bitrig either\n \n #![feature(alloc_jemalloc)]\n "}]}