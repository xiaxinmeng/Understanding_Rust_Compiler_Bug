{"sha": "1f874ded52acaecd47b39e90e93d7d7a31c90dae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmODc0ZGVkNTJhY2FlY2Q0N2IzOWU5MGU5M2Q3ZDdhMzFjOTBkYWU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-08T20:57:01Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-10T11:34:45Z"}, "message": "rustc: do not depend on infcx.tables in MemCategorizationContext.", "tree": {"sha": "13ccd5df830dcee9516b0a0c1e5f00fb88b7284b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13ccd5df830dcee9516b0a0c1e5f00fb88b7284b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f874ded52acaecd47b39e90e93d7d7a31c90dae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f874ded52acaecd47b39e90e93d7d7a31c90dae", "html_url": "https://github.com/rust-lang/rust/commit/1f874ded52acaecd47b39e90e93d7d7a31c90dae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f874ded52acaecd47b39e90e93d7d7a31c90dae/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5175bc18b5ece1f66a7bfca09202a97728f1d920", "url": "https://api.github.com/repos/rust-lang/rust/commits/5175bc18b5ece1f66a7bfca09202a97728f1d920", "html_url": "https://github.com/rust-lang/rust/commit/5175bc18b5ece1f66a7bfca09202a97728f1d920"}], "stats": {"total": 386, "additions": 146, "deletions": 240}, "files": [{"sha": "3e2d26aa518adc76b46ad35d5f785b030277a70b", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 15, "deletions": 128, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=1f874ded52acaecd47b39e90e93d7d7a31c90dae", "patch": "@@ -19,11 +19,8 @@ pub use self::freshen::TypeFreshener;\n pub use self::region_inference::{GenericKind, VerifyBound};\n \n use hir::def_id::DefId;\n-use hir;\n use middle::free_region::{FreeRegionMap, RegionRelations};\n use middle::region::RegionMaps;\n-use middle::mem_categorization as mc;\n-use middle::mem_categorization::McResult;\n use middle::lang_items;\n use mir::tcx::LvalueTy;\n use ty::subst::{Kind, Subst, Substs};\n@@ -36,7 +33,6 @@ use traits::{self, ObligationCause, PredicateObligations, Reveal};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::fmt;\n-use std::ops::Deref;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::{self, Span, DUMMY_SP};\n@@ -80,55 +76,23 @@ pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n /// `InProgress` (during typeck) or `Interned` (result of typeck).\n /// Only the `InProgress` version supports `borrow_mut`.\n #[derive(Copy, Clone)]\n-pub enum InferTables<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    Interned(&'a ty::TypeckTables<'gcx>),\n+pub enum InferTables<'a, 'tcx: 'a> {\n     InProgress(&'a RefCell<ty::TypeckTables<'tcx>>),\n     Missing\n }\n \n-pub enum InferTablesRef<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    Interned(&'a ty::TypeckTables<'gcx>),\n-    InProgress(Ref<'a, ty::TypeckTables<'tcx>>)\n-}\n-\n-impl<'a, 'gcx, 'tcx> Deref for InferTablesRef<'a, 'gcx, 'tcx> {\n-    type Target = ty::TypeckTables<'tcx>;\n-    fn deref(&self) -> &Self::Target {\n-        match *self {\n-            InferTablesRef::Interned(tables) => tables,\n-            InferTablesRef::InProgress(ref tables) => tables\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> InferTables<'a, 'gcx, 'tcx> {\n-    pub fn borrow(self) -> InferTablesRef<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> InferTables<'a, 'tcx> {\n+    pub fn borrow(self) -> Ref<'a, ty::TypeckTables<'tcx>> {\n         match self {\n-            InferTables::Interned(tables) => InferTablesRef::Interned(tables),\n-            InferTables::InProgress(tables) => InferTablesRef::InProgress(tables.borrow()),\n+            InferTables::InProgress(tables) => tables.borrow(),\n             InferTables::Missing => {\n                 bug!(\"InferTables: infcx.tables.borrow() with no tables\")\n             }\n         }\n     }\n \n-    pub fn expect_interned(self) -> &'a ty::TypeckTables<'gcx> {\n-        match self {\n-            InferTables::Interned(tables) => tables,\n-            InferTables::InProgress(_) => {\n-                bug!(\"InferTables: infcx.tables.expect_interned() during type-checking\");\n-            }\n-            InferTables::Missing => {\n-                bug!(\"InferTables: infcx.tables.expect_interned() with no tables\")\n-            }\n-        }\n-    }\n-\n     pub fn borrow_mut(self) -> RefMut<'a, ty::TypeckTables<'tcx>> {\n         match self {\n-            InferTables::Interned(_) => {\n-                bug!(\"InferTables: infcx.tables.borrow_mut() outside of type-checking\");\n-            }\n             InferTables::InProgress(tables) => tables.borrow_mut(),\n             InferTables::Missing => {\n                 bug!(\"InferTables: infcx.tables.borrow_mut() with no tables\")\n@@ -140,7 +104,7 @@ impl<'a, 'gcx, 'tcx> InferTables<'a, 'gcx, 'tcx> {\n pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n-    pub tables: InferTables<'a, 'gcx, 'tcx>,\n+    pub tables: InferTables<'a, 'tcx>,\n \n     // Cache for projections. This cache is snapshotted along with the\n     // infcx.\n@@ -397,41 +361,18 @@ impl fmt::Display for FixupError {\n }\n \n pub trait InferEnv<'a, 'tcx> {\n-    fn to_parts(self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>);\n+    fn fresh_tables(self) -> Option<ty::TypeckTables<'tcx>>;\n }\n \n impl<'a, 'tcx> InferEnv<'a, 'tcx> for () {\n-    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n-                -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>) {\n-        (None, None)\n-    }\n-}\n-\n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for &'a ty::TypeckTables<'tcx> {\n-    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n-                -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>) {\n-        (Some(self), None)\n+    fn fresh_tables(self) -> Option<ty::TypeckTables<'tcx>> {\n+        None\n     }\n }\n \n impl<'a, 'tcx> InferEnv<'a, 'tcx> for ty::TypeckTables<'tcx> {\n-    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n-                -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>) {\n-        (None, Some(self))\n-    }\n-}\n-\n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for hir::BodyId {\n-    fn to_parts(self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>) {\n-        let def_id = tcx.hir.body_owner_def_id(self);\n-        (Some(tcx.typeck_tables_of(def_id)), None)\n+    fn fresh_tables(self) -> Option<ty::TypeckTables<'tcx>> {\n+        Some(self)\n     }\n }\n \n@@ -442,29 +383,24 @@ pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     arena: DroplessArena,\n     fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n-    tables: Option<&'a ty::TypeckTables<'gcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n     pub fn infer_ctxt<E: InferEnv<'a, 'gcx>>(self, env: E) -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n-        let (tables, fresh_tables) = env.to_parts(self);\n         InferCtxtBuilder {\n             global_tcx: self,\n             arena: DroplessArena::new(),\n-            fresh_tables: fresh_tables.map(RefCell::new),\n-            tables: tables,\n+            fresh_tables: env.fresh_tables().map(RefCell::new),\n         }\n     }\n \n     /// Fake InferCtxt with the global tcx. Used by pre-MIR borrowck\n     /// for MemCategorizationContext/ExprUseVisitor.\n     /// If any inference functionality is used, ICEs will occur.\n-    pub fn borrowck_fake_infer_ctxt(self, body: hir::BodyId)\n-                                    -> InferCtxt<'a, 'gcx, 'gcx> {\n-        let (tables, _) = body.to_parts(self);\n+    pub fn borrowck_fake_infer_ctxt(self) -> InferCtxt<'a, 'gcx, 'gcx> {\n         InferCtxt {\n             tcx: self,\n-            tables: InferTables::Interned(tables.unwrap()),\n+            tables: InferTables::Missing,\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n@@ -488,11 +424,9 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             global_tcx,\n             ref arena,\n             ref fresh_tables,\n-            tables,\n         } = *self;\n-        let tables = tables.map(InferTables::Interned).unwrap_or_else(|| {\n-            fresh_tables.as_ref().map_or(InferTables::Missing, InferTables::InProgress)\n-        });\n+        let tables = fresh_tables.as_ref()\n+            .map_or(InferTables::Missing, InferTables::InProgress);\n         global_tcx.enter_local(arena, |tcx| f(InferCtxt {\n             tcx: tcx,\n             tables: tables,\n@@ -1190,28 +1124,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tainted_by_errors_flag.set(true)\n     }\n \n-    pub fn node_type(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        match self.tables.borrow().node_types.get(&id) {\n-            Some(&t) => t,\n-            // FIXME\n-            None if self.is_tainted_by_errors() =>\n-                self.tcx.types.err,\n-            None => {\n-                bug!(\"no type for node {}: {} in fcx\",\n-                     id, self.tcx.hir.node_to_string(id));\n-            }\n-        }\n-    }\n-\n-    pub fn expr_ty(&self, ex: &hir::Expr) -> Ty<'tcx> {\n-        match self.tables.borrow().node_types.get(&ex.id) {\n-            Some(&t) => t,\n-            None => {\n-                bug!(\"no type for expr in fcx\");\n-            }\n-        }\n-    }\n-\n     pub fn resolve_regions_and_report_errors(&self,\n                                              region_context: DefId,\n                                              region_map: &RegionMaps,\n@@ -1310,21 +1222,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         value.fold_with(&mut r)\n     }\n \n-    /// Resolves all type variables in `t` and then, if any were left\n-    /// unresolved, substitutes an error type. This is used after the\n-    /// main checking when doing a second pass before writeback. The\n-    /// justification is that writeback will produce an error for\n-    /// these unconstrained type variables.\n-    fn resolve_type_vars_or_error(&self, t: &Ty<'tcx>) -> mc::McResult<Ty<'tcx>> {\n-        let ty = self.resolve_type_vars_if_possible(t);\n-        if ty.references_error() || ty.is_ty_var() {\n-            debug!(\"resolve_type_vars_or_error: error from {:?}\", ty);\n-            Err(())\n-        } else {\n-            Ok(ty)\n-        }\n-    }\n-\n     pub fn fully_resolve<T:TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {\n         /*!\n          * Attempts to resolve all type/region variables in\n@@ -1484,16 +1381,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.region_vars.verify_generic_bound(origin, kind, a, bound);\n     }\n \n-    pub fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n-        let ty = self.node_type(id);\n-        self.resolve_type_vars_or_error(&ty)\n-    }\n-\n-    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        let ty = self.tables.borrow().expr_ty_adjusted(expr);\n-        self.resolve_type_vars_or_error(&ty)\n-    }\n-\n     pub fn type_moves_by_default(&self,\n                                  param_env: ty::ParamEnv<'tcx>,\n                                  ty: Ty<'tcx>,"}, {"sha": "b24b2a616b06a99cea8d18e471c9bab53d0ac773", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=1f874ded52acaecd47b39e90e93d7d7a31c90dae", "patch": "@@ -235,17 +235,14 @@ impl OverloadedCallType {\n ///////////////////////////////////////////////////////////////////////////\n // The ExprUseVisitor type\n //\n-// This is the code that actually walks the tree. Like\n-// mem_categorization, it requires a TYPER, which is a type that\n-// supplies types from the tree. After type checking is complete, you\n-// can just use the tcx as the typer.\n+// This is the code that actually walks the tree.\n pub struct ExprUseVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     mc: mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n     delegate: &'a mut Delegate<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n-// If the TYPER results in an error, it's because the type check\n+// If the MC results in an error, it's because the type check\n // failed (or will fail, when the error is uncovered and reported\n // during writeback). In this case, we just ignore this part of the\n // code.\n@@ -266,13 +263,14 @@ macro_rules! return_if_err {\n \n impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n-               region_maps: &'a RegionMaps,\n                infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-               param_env: ty::ParamEnv<'tcx>)\n+               param_env: ty::ParamEnv<'tcx>,\n+               region_maps: &'a RegionMaps,\n+               tables: &'a ty::TypeckTables<'tcx>)\n                -> Self\n     {\n         ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::new(infcx, region_maps),\n+            mc: mc::MemCategorizationContext::new(infcx, region_maps, tables),\n             delegate,\n             param_env,\n         }\n@@ -282,7 +280,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"consume_body(body={:?})\", body);\n \n         for arg in &body.arguments {\n-            let arg_ty = return_if_err!(self.mc.infcx.node_ty(arg.pat.id));\n+            let arg_ty = return_if_err!(self.mc.node_ty(arg.pat.id));\n \n             let fn_body_scope_r = self.tcx().node_scope_region(body.value.id);\n             let arg_cmt = self.mc.cat_rvalue(\n@@ -427,7 +425,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             hir::ExprAddrOf(m, ref base) => {   // &base\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n-                let expr_ty = return_if_err!(self.mc.infcx.node_ty(expr.id));\n+                let expr_ty = return_if_err!(self.mc.expr_ty(expr));\n                 if let ty::TyRef(r, _) = expr_ty.sty {\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.borrow_expr(&base, r, bk, AddrOf);\n@@ -491,7 +489,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n \n             hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n-                if self.mc.infcx.tables.borrow().is_method_call(expr) {\n+                if self.mc.tables.is_method_call(expr) {\n                     self.consume_expr(lhs);\n                 } else {\n                     self.mutate_expr(expr, &lhs, MutateMode::WriteAndRead);\n@@ -514,7 +512,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn walk_callee(&mut self, call: &hir::Expr, callee: &hir::Expr) {\n-        let callee_ty = return_if_err!(self.mc.infcx.expr_ty_adjusted(callee));\n+        let callee_ty = return_if_err!(self.mc.expr_ty_adjusted(callee));\n         debug!(\"walk_callee: callee={:?} callee_ty={:?}\",\n                callee, callee_ty);\n         match callee_ty.sty {\n@@ -523,7 +521,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n             ty::TyError => { }\n             _ => {\n-                let def_id = self.mc.infcx.tables.borrow().type_dependent_defs[&call.id].def_id();\n+                let def_id = self.mc.tables.type_dependent_defs[&call.id].def_id();\n                 match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n                     FnMutOverloadedCall => {\n                         let call_scope_r = self.tcx().node_scope_region(call.id);\n@@ -664,8 +662,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     // consumed or borrowed as part of the automatic adjustment\n     // process.\n     fn walk_adjustment(&mut self, expr: &hir::Expr) {\n-        let tables = self.mc.infcx.tables.borrow();\n-        let adjustments = tables.expr_adjustments(expr);\n+        let adjustments = self.mc.tables.expr_adjustments(expr);\n         let mut cmt = return_if_err!(self.mc.cat_expr_unadjusted(expr));\n         for adjustment in adjustments {\n             debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n@@ -782,7 +779,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                mode: &mut TrackMatchMode) {\n         debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr,\n                pat);\n-        return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n+        return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n             match pat.node {\n                 PatKind::Binding(hir::BindByRef(..), ..) =>\n                     mode.lub(BorrowingMatch),\n@@ -806,12 +803,12 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n         let infcx = self.mc.infcx;\n         let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n-        return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n+        return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n             if let PatKind::Binding(bmode, def_id, ..) = pat.node {\n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n-                let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n+                let pat_ty = return_if_err!(mc.node_ty(pat.id));\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n@@ -841,14 +838,14 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // the interior nodes (enum variants and structs), as opposed\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n-        return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n+        return_if_err!(mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n             let qpath = match pat.node {\n                 PatKind::Path(ref qpath) |\n                 PatKind::TupleStruct(ref qpath, ..) |\n                 PatKind::Struct(ref qpath, ..) => qpath,\n                 _ => return\n             };\n-            let def = infcx.tables.borrow().qpath_def(qpath, pat.id);\n+            let def = mc.tables.qpath_def(qpath, pat.id);\n             match def {\n                 Def::Variant(variant_did) |\n                 Def::VariantCtor(variant_did, ..) => {\n@@ -882,7 +879,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 let id_var = self.tcx().hir.as_local_node_id(def_id).unwrap();\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n                                              closure_expr_id: closure_expr.id };\n-                let upvar_capture = self.mc.infcx.tables.borrow().upvar_capture(upvar_id);\n+                let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n                 let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n                                                                    fn_decl_span,\n                                                                    freevar.def));\n@@ -915,7 +912,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n         let var_id = self.tcx().hir.as_local_node_id(upvar_def.def_id()).unwrap();\n-        let var_ty = self.mc.infcx.node_ty(var_id)?;\n+        let var_ty = self.mc.node_ty(var_id)?;\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }\n }"}, {"sha": "66de8bc58032a56c816d71d27e58fa789a4b7118", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 60, "deletions": 34, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1f874ded52acaecd47b39e90e93d7d7a31c90dae", "patch": "@@ -76,6 +76,7 @@ use infer::InferCtxt;\n use hir::def::{Def, CtorKind};\n use ty::adjustment;\n use ty::{self, Ty, TyCtxt};\n+use ty::fold::TypeFoldable;\n \n use hir::{MutImmutable, MutMutable, PatKind};\n use hir::pat_util::EnumerateAndAdjustIterator;\n@@ -283,6 +284,7 @@ impl ast_node for hir::Pat {\n pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     pub region_maps: &'a RegionMaps,\n+    pub tables: &'a ty::TypeckTables<'tcx>,\n }\n \n pub type McResult<T> = Result<T, ()>;\n@@ -386,35 +388,63 @@ impl MutabilityCategory {\n impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     /// Context should be the `DefId` we use to fetch region-maps.\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-               region_maps: &'a RegionMaps)\n+               region_maps: &'a RegionMaps,\n+               tables: &'a ty::TypeckTables<'tcx>)\n                -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n-        MemCategorizationContext { infcx, region_maps }\n+        MemCategorizationContext { infcx, region_maps, tables }\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        match self.infcx.node_ty(expr.id) {\n-            Ok(t) => Ok(t),\n-            Err(()) => {\n-                debug!(\"expr_ty({:?}) yielded Err\", expr);\n-                Err(())\n+    fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n+        where T: TypeFoldable<'tcx>\n+    {\n+        self.infcx.resolve_type_vars_if_possible(value)\n+    }\n+\n+    fn is_tainted_by_errors(&self) -> bool {\n+        self.infcx.is_tainted_by_errors()\n+    }\n+\n+    fn resolve_type_vars_or_error(&self,\n+                                  id: ast::NodeId,\n+                                  ty: Option<Ty<'tcx>>)\n+                                  -> McResult<Ty<'tcx>> {\n+        match ty {\n+            Some(ty) => {\n+                let ty = self.resolve_type_vars_if_possible(&ty);\n+                if ty.references_error() || ty.is_ty_var() {\n+                    debug!(\"resolve_type_vars_or_error: error from {:?}\", ty);\n+                    Err(())\n+                } else {\n+                    Ok(ty)\n+                }\n+            }\n+            // FIXME\n+            None if self.is_tainted_by_errors() => Err(()),\n+            None => {\n+                bug!(\"no type for node {}: {} in mem_categorization\",\n+                     id, self.tcx().hir.node_to_string(id));\n             }\n         }\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        self.infcx.expr_ty_adjusted(expr)\n+    pub fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n+        self.resolve_type_vars_or_error(id, self.tables.node_id_to_type_opt(id))\n+    }\n+\n+    pub fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n+        self.resolve_type_vars_or_error(expr.id, self.tables.expr_ty_opt(expr))\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n-        self.infcx.node_ty(id)\n+    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n+        self.resolve_type_vars_or_error(expr.id, self.tables.expr_ty_adjusted_opt(expr))\n     }\n \n     fn pat_ty(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n-        let base_ty = self.infcx.node_ty(pat.id)?;\n+        let base_ty = self.node_ty(pat.id)?;\n         // FIXME (Issue #18207): This code detects whether we are\n         // looking at a `ref x`, and if so, figures out what the type\n         // *being borrowed* is.  But ideally we would put in a more\n@@ -454,7 +484,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        helper(self, expr, self.infcx.tables.borrow().expr_adjustments(expr))\n+        helper(self, expr, self.tables.expr_adjustments(expr))\n     }\n \n     pub fn cat_expr_adjusted(&self, expr: &hir::Expr,\n@@ -471,7 +501,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         where F: FnOnce() -> McResult<cmt<'tcx>>\n     {\n         debug!(\"cat_expr_adjusted_with({:?}): {:?}\", adjustment, expr);\n-        let target = self.infcx.resolve_type_vars_if_possible(&adjustment.target);\n+        let target = self.resolve_type_vars_if_possible(&adjustment.target);\n         match adjustment.kind {\n             adjustment::Adjust::Deref(overloaded) => {\n                 // Equivalent to *expr or something similar.\n@@ -506,7 +536,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let expr_ty = self.expr_ty(expr)?;\n         match expr.node {\n           hir::ExprUnary(hir::UnDeref, ref e_base) => {\n-            if self.infcx.tables.borrow().is_method_call(expr) {\n+            if self.tables.is_method_call(expr) {\n                 self.cat_overloaded_lvalue(expr, e_base, false)\n             } else {\n                 let base_cmt = self.cat_expr(&e_base)?;\n@@ -529,7 +559,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           hir::ExprIndex(ref base, _) => {\n-            if self.infcx.tables.borrow().is_method_call(expr) {\n+            if self.tables.is_method_call(expr) {\n                 // If this is an index implemented by a method call, then it\n                 // will include an implicit deref of the result.\n                 // The call to index() returns a `&T` value, which\n@@ -543,7 +573,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           hir::ExprPath(ref qpath) => {\n-            let def = self.infcx.tables.borrow().qpath_def(qpath, expr.id);\n+            let def = self.tables.qpath_def(qpath, expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -595,15 +625,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n           Def::Upvar(def_id, _, fn_node_id) => {\n               let var_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-              let closure_id = self.tcx().hir.local_def_id(fn_node_id);\n-              match self.infcx.closure_kind(closure_id) {\n-                Some(kind) => {\n-                    self.cat_upvar(id, span, var_id, fn_node_id, kind)\n-                }\n-                None => {\n-                    span_bug!(span, \"No closure kind for {:?}\", closure_id);\n-                }\n-              }\n+              self.cat_upvar(id, span, var_id, fn_node_id)\n           }\n \n           Def::Local(def_id) => {\n@@ -628,8 +650,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                  id: ast::NodeId,\n                  span: Span,\n                  var_id: ast::NodeId,\n-                 fn_node_id: ast::NodeId,\n-                 kind: ty::ClosureKind)\n+                 fn_node_id: ast::NodeId)\n                  -> McResult<cmt<'tcx>>\n     {\n         // An upvar can have up to 3 components. We translate first to a\n@@ -655,6 +676,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n         // FnOnce         | copied               | upvar -> &'up bk\n \n+        let kind = match self.tables.closure_kinds.get(&fn_node_id) {\n+            Some(&(kind, _)) => kind,\n+            None => span_bug!(span, \"missing closure kind\")\n+        };\n+\n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n         let var_ty = self.node_ty(var_id)?;\n@@ -694,7 +720,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // for that.\n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n-        let upvar_capture = self.infcx.tables.borrow().upvar_capture(upvar_id);\n+        let upvar_capture = self.tables.upvar_capture(upvar_id);\n         let cmt_result = match upvar_capture {\n             ty::UpvarCapture::ByValue => {\n                 cmt_result\n@@ -1000,14 +1026,14 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, mut op: F) -> McResult<()>\n-        where F: FnMut(&MemCategorizationContext<'a, 'gcx, 'tcx>, cmt<'tcx>, &hir::Pat),\n+        where F: FnMut(cmt<'tcx>, &hir::Pat),\n     {\n         self.cat_pattern_(cmt, pat, &mut op)\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n     fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F) -> McResult<()>\n-        where F : FnMut(&MemCategorizationContext<'a, 'gcx, 'tcx>, cmt<'tcx>, &hir::Pat)\n+        where F : FnMut(cmt<'tcx>, &hir::Pat)\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n@@ -1056,7 +1082,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"cat_pattern: {:?} cmt={:?}\", pat, cmt);\n \n-        op(self, cmt.clone(), pat);\n+        op(cmt.clone(), pat);\n \n         // Note: This goes up here (rather than within the PatKind::TupleStruct arm\n         // alone) because PatKind::Struct can also refer to variants.\n@@ -1087,7 +1113,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         match pat.node {\n           PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n-            let def = self.infcx.tables.borrow().qpath_def(qpath, pat.id);\n+            let def = self.tables.qpath_def(qpath, pat.id);\n             let expected_len = match def {\n                 Def::VariantCtor(def_id, CtorKind::Fn) => {\n                     let enum_def = self.tcx().parent_def_id(def_id).unwrap();"}, {"sha": "74bfd9771488ec8d728beacab8fbe7363d6d4c88", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=1f874ded52acaecd47b39e90e93d7d7a31c90dae", "patch": "@@ -29,7 +29,7 @@ use hir::{self, intravisit, Local, Pat, Body};\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::map::NodeExpr;\n use hir::def_id::DefId;\n-use infer::{self, InferCtxt, InferTables, InferTablesRef};\n+use infer::{self, InferCtxt, InferTables};\n use infer::type_variable::TypeVariableOrigin;\n use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use std::fmt;\n@@ -652,18 +652,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             obligation.cause.span,\n                             format!(\"the requirement to implement `{}` derives from here\", kind));\n \n-                        let infer_tables = match self.tables {\n-                            InferTables::Interned(tables) =>\n-                                Some(InferTablesRef::Interned(tables)),\n-                            InferTables::InProgress(tables) =>\n-                                Some(InferTablesRef::InProgress(tables.borrow())),\n-                            InferTables::Missing => None,\n-                        };\n-\n                         // Additional context information explaining why the closure only implements\n                         // a particular trait.\n-                        if let Some(tables) = infer_tables {\n-                            match tables.closure_kinds.get(&node_id) {\n+                        if let InferTables::InProgress(tables) = self.tables {\n+                            match tables.borrow().closure_kinds.get(&node_id) {\n                                 Some(&(ty::ClosureKind::FnOnce, Some((span, name)))) => {\n                                     err.span_note(span, &format!(\n                                         \"closure is `FnOnce` because it moves the \\"}, {"sha": "a47ec35d265bfe9750e1f3d0d92c4d9368aa1597", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=1f874ded52acaecd47b39e90e93d7d7a31c90dae", "patch": "@@ -192,7 +192,6 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     debug!(\"check_loans(body id={})\", body.value.id);\n \n     let def_id = bccx.tcx.hir.body_owner_def_id(body.id());\n-    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(body.id());\n     let param_env = bccx.tcx.param_env(def_id);\n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,\n@@ -201,7 +200,9 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         all_loans: all_loans,\n         param_env,\n     };\n-    euv::ExprUseVisitor::new(&mut clcx, &bccx.region_maps, &infcx, param_env).consume_body(body);\n+    let infcx = bccx.tcx.borrowck_fake_infer_ctxt();\n+    euv::ExprUseVisitor::new(&mut clcx, &infcx, param_env, &bccx.region_maps, bccx.tables)\n+        .consume_body(body);\n }\n \n #[derive(PartialEq)]"}, {"sha": "ae68fb651f61f014479d52be3410bd92cfb44b9e", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=1f874ded52acaecd47b39e90e93d7d7a31c90dae", "patch": "@@ -18,7 +18,6 @@\n \n use borrowck::*;\n use borrowck::move_data::MoveData;\n-use rustc::infer::InferCtxt;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n@@ -40,19 +39,19 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     body: hir::BodyId)\n                                     -> (Vec<Loan<'tcx>>, move_data::MoveData<'tcx>) {\n     let def_id = bccx.tcx.hir.body_owner_def_id(body);\n-    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(body);\n     let param_env = bccx.tcx.param_env(def_id);\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n-        infcx: &infcx,\n         all_loans: Vec::new(),\n         item_ub: region::CodeExtent::Misc(body.node_id),\n         move_data: MoveData::new(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n     let body = glcx.bccx.tcx.hir.body(body);\n-    euv::ExprUseVisitor::new(&mut glcx, &bccx.region_maps, &infcx, param_env).consume_body(body);\n+    let infcx = bccx.tcx.borrowck_fake_infer_ctxt();\n+    euv::ExprUseVisitor::new(&mut glcx, &infcx, param_env, &bccx.region_maps, bccx.tables)\n+        .consume_body(body);\n \n     glcx.report_potential_errors();\n     let GatherLoanCtxt { all_loans, move_data, .. } = glcx;\n@@ -61,7 +60,6 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n struct GatherLoanCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    infcx: &'a InferCtxt<'a, 'tcx, 'tcx>,\n     move_data: move_data::MoveData<'tcx>,\n     move_error_collector: move_error::MoveErrorCollector<'tcx>,\n     all_loans: Vec<Loan<'tcx>>,\n@@ -158,7 +156,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     fn decl_without_init(&mut self, id: ast::NodeId, _span: Span) {\n-        let ty = self.infcx.tables.borrow().node_id_to_type(id);\n+        let ty = self.bccx.tables.node_id_to_type(id);\n         gather_moves::gather_decl(self.bccx, &self.move_data, id, ty);\n     }\n }"}, {"sha": "17cb60792c69eb354ac179a92599173b39e01322", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=1f874ded52acaecd47b39e90e93d7d7a31c90dae", "patch": "@@ -493,11 +493,12 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n ///\n /// FIXME: this should be done by borrowck.\n fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n-    cx.tcx.infer_ctxt(cx.tables).enter(|infcx| {\n+    cx.tcx.infer_ctxt(()).enter(|infcx| {\n         let mut checker = MutationChecker {\n             cx: cx,\n         };\n-        ExprUseVisitor::new(&mut checker, cx.region_maps, &infcx, cx.param_env).walk_expr(guard);\n+        ExprUseVisitor::new(&mut checker, &infcx, cx.param_env, cx.region_maps, cx.tables)\n+            .walk_expr(guard);\n     });\n }\n "}, {"sha": "8d549154e11db8e3901c0b6fd47953f696614f12", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=1f874ded52acaecd47b39e90e93d7d7a31c90dae", "patch": "@@ -83,7 +83,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n     };\n \n     let src = MirSource::from_node(tcx, id);\n-    tcx.infer_ctxt(body_id).enter(|infcx| {\n+    tcx.infer_ctxt(()).enter(|infcx| {\n         let cx = Cx::new(&infcx, src);\n         let mut mir = if cx.tables().tainted_by_errors {\n             build::construct_error(cx, body_id)"}, {"sha": "2bb6b39966a82021fda4658c87ef462863f80167", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=1f874ded52acaecd47b39e90e93d7d7a31c90dae", "patch": "@@ -37,6 +37,7 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub region_maps: Rc<RegionMaps>,\n+    pub tables: &'a ty::TypeckTables<'gcx>,\n \n     /// This is `Constness::Const` if we are compiling a `static`,\n     /// `const`, or the body of a `const fn`.\n@@ -67,6 +68,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n         let param_env = tcx.param_env(src_def_id);\n         let region_maps = tcx.region_maps(src_def_id);\n+        let tables = tcx.typeck_tables_of(src_def_id);\n \n         let attrs = tcx.hir.attrs(src_id);\n \n@@ -82,7 +84,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Constants and const fn's always need overflow checks.\n         check_overflow |= constness == hir::Constness::Const;\n \n-        Cx { tcx, infcx, param_env, region_maps, constness, src, check_overflow }\n+        Cx { tcx, infcx, param_env, region_maps, tables, constness, src, check_overflow }\n     }\n }\n \n@@ -184,7 +186,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn tables(&self) -> &'a ty::TypeckTables<'gcx> {\n-        self.infcx.tables.expect_interned()\n+        self.tables\n     }\n \n     pub fn check_overflow(&self) -> bool {"}, {"sha": "f7889385688306d974516f3a719c6302f2ca4592", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=1f874ded52acaecd47b39e90e93d7d7a31c90dae", "patch": "@@ -138,11 +138,12 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n             self.check_const_eval(&body.value);\n         }\n \n-        let outer_penv = self.tcx.infer_ctxt(body_id).enter(|infcx| {\n+        let outer_penv = self.tcx.infer_ctxt(()).enter(|infcx| {\n             let param_env = self.tcx.param_env(item_def_id);\n             let outer_penv = mem::replace(&mut self.param_env, param_env);\n             let region_maps = &self.tcx.region_maps(item_def_id);\n-            euv::ExprUseVisitor::new(self, region_maps, &infcx, param_env).consume_body(body);\n+            euv::ExprUseVisitor::new(self, &infcx, param_env, region_maps, self.tables)\n+                .consume_body(body);\n             outer_penv\n         });\n "}, {"sha": "f2fdc59762b1251aaec93e2500e575b598ed7e15", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1f874ded52acaecd47b39e90e93d7d7a31c90dae", "patch": "@@ -4186,7 +4186,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::StmtSemi(ref e, _) => e,\n             _ => return,\n         };\n-        let last_expr_ty = self.expr_ty(last_expr);\n+        let last_expr_ty = self.node_ty(last_expr.id);\n         if self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err() {\n             return;\n         }"}, {"sha": "616de1fc41229106b1d3964b8fbee3c63dd4ef05", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=1f874ded52acaecd47b39e90e93d7d7a31c90dae", "patch": "@@ -824,15 +824,21 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Create a temporary `MemCategorizationContext` and pass it to the closure.\n+    fn with_mc<F, R>(&self, f: F) -> R\n+        where F: for<'b> FnOnce(mc::MemCategorizationContext<'b, 'gcx, 'tcx>) -> R\n+    {\n+        f(mc::MemCategorizationContext::new(&self.infcx,\n+                                            &self.region_maps,\n+                                            &self.tables.borrow()))\n+    }\n+\n     /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n     /// dereferenced, the lifetime of the pointer includes the deref expr.\n     fn constrain_adjustments(&mut self, expr: &hir::Expr) -> mc::McResult<mc::cmt<'tcx>> {\n         debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n-        let mut cmt = {\n-            let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-            mc.cat_expr_unadjusted(expr)?\n-        };\n+        let mut cmt = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n \n         let tables = self.tables.borrow();\n         let adjustments = tables.expr_adjustments(&expr);\n@@ -886,10 +892,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                                                expr.id, expr_region);\n             }\n \n-            {\n-                let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-                cmt = mc.cat_expr_adjusted(expr, cmt, &adjustment)?;\n-            }\n+            cmt = self.with_mc(|mc| mc.cat_expr_adjusted(expr, cmt, &adjustment))?;\n \n             if let Categorization::Deref(_, mc::BorrowedPtr(_, r_ptr)) = cmt.cat {\n                 self.mk_subregion_due_to_dereference(expr.span,\n@@ -981,10 +984,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     mutability: hir::Mutability, base: &hir::Expr) {\n         debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n \n-        let cmt = {\n-            let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-            ignore_err!(mc.cat_expr(base))\n-        };\n+        let cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(base)));\n \n         debug!(\"link_addr_of: cmt={:?}\", cmt);\n \n@@ -1000,22 +1000,20 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             None => { return; }\n             Some(ref expr) => &**expr,\n         };\n-        let mc = &mc::MemCategorizationContext::new(self, &self.region_maps);\n-        let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n-        self.link_pattern(mc, discr_cmt, &local.pat);\n+        let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(init_expr)));\n+        self.link_pattern(discr_cmt, &local.pat);\n     }\n \n     /// Computes the guarantors for any ref bindings in a match and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of its guarantor (if any).\n     fn link_match(&self, discr: &hir::Expr, arms: &[hir::Arm]) {\n         debug!(\"regionck::for_match()\");\n-        let mc = &mc::MemCategorizationContext::new(self, &self.region_maps);\n-        let discr_cmt = ignore_err!(mc.cat_expr(discr));\n+        let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(discr)));\n         debug!(\"discr_cmt={:?}\", discr_cmt);\n         for arm in arms {\n             for root_pat in &arm.pats {\n-                self.link_pattern(mc, discr_cmt.clone(), &root_pat);\n+                self.link_pattern(discr_cmt.clone(), &root_pat);\n             }\n         }\n     }\n@@ -1025,30 +1023,28 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// linked to the lifetime of its guarantor (if any).\n     fn link_fn_args(&self, body_scope: CodeExtent, args: &[hir::Arg]) {\n         debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n-        let mc = &mc::MemCategorizationContext::new(self, &self.region_maps);\n         for arg in args {\n             let arg_ty = self.node_ty(arg.id);\n             let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n-            let arg_cmt = mc.cat_rvalue(\n-                arg.id, arg.pat.span, re_scope, arg_ty);\n+            let arg_cmt = self.with_mc(|mc| {\n+                mc.cat_rvalue(arg.id, arg.pat.span, re_scope, arg_ty)\n+            });\n             debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n                    arg_ty,\n                    arg_cmt,\n                    arg);\n-            self.link_pattern(mc, arg_cmt, &arg.pat);\n+            self.link_pattern(arg_cmt, &arg.pat);\n         }\n     }\n \n     /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n     /// in the discriminant, if needed.\n-    fn link_pattern<'t>(&self,\n-                        mc: &mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n-                        discr_cmt: mc::cmt<'tcx>,\n-                        root_pat: &hir::Pat) {\n+    fn link_pattern(&self, discr_cmt: mc::cmt<'tcx>, root_pat: &hir::Pat) {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n                discr_cmt,\n                root_pat);\n-        let _ = mc.cat_pattern(discr_cmt, root_pat, |_, sub_cmt, sub_pat| {\n+        let _ = self.with_mc(|mc| {\n+            mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, sub_pat| {\n                 match sub_pat.node {\n                     // `ref x` pattern\n                     PatKind::Binding(hir::BindByRef(mutbl), ..) => {\n@@ -1057,7 +1053,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     _ => {}\n                 }\n-            });\n+            })\n+        });\n     }\n \n     /// Link lifetime of borrowed pointer resulting from autoref to lifetimes in the value being"}, {"sha": "400ca59e1438576e62306d6429473b8ca866aec8", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f874ded52acaecd47b39e90e93d7d7a31c90dae/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=1f874ded52acaecd47b39e90e93d7d7a31c90dae", "patch": "@@ -142,7 +142,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 adjust_closure_kinds: NodeMap(),\n                 adjust_upvar_captures: ty::UpvarCaptureMap::default(),\n             };\n-            euv::ExprUseVisitor::new(&mut delegate, region_maps, self, self.param_env)\n+            euv::ExprUseVisitor::new(&mut delegate,\n+                                     &self.infcx,\n+                                     self.param_env,\n+                                     region_maps,\n+                                     &self.tables.borrow())\n                 .consume_body(body);\n \n             // Write the adjusted values back into the main tables."}]}