{"sha": "f67bfe97389a256fc95216c29a2b8a066ee16a2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2N2JmZTk3Mzg5YTI1NmZjOTUyMTZjMjlhMmI4YTA2NmVlMTZhMmM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-13T03:32:48Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-14T23:18:29Z"}, "message": "Add types for character position and byte position in the codemap", "tree": {"sha": "a638c4c480ceb60138a39a05c5b04967ac814eb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a638c4c480ceb60138a39a05c5b04967ac814eb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f67bfe97389a256fc95216c29a2b8a066ee16a2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f67bfe97389a256fc95216c29a2b8a066ee16a2c", "html_url": "https://github.com/rust-lang/rust/commit/f67bfe97389a256fc95216c29a2b8a066ee16a2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f67bfe97389a256fc95216c29a2b8a066ee16a2c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ecf86343a136c71cbb2bb8da9bfd1734fec37f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ecf86343a136c71cbb2bb8da9bfd1734fec37f4", "html_url": "https://github.com/rust-lang/rust/commit/9ecf86343a136c71cbb2bb8da9bfd1734fec37f4"}], "stats": {"total": 446, "additions": 285, "deletions": 161}, "files": [{"sha": "15f8b18a9f53a20028dcbeec1c712f240b74c235", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -8,7 +8,7 @@ use trans::build::B;\n use middle::ty;\n use syntax::{ast, codemap, ast_util, ast_map};\n use syntax::parse::token::ident_interner;\n-use codemap::span;\n+use codemap::{span, CharPos};\n use ast::Ty;\n use pat_util::*;\n use util::ppaux::ty_to_str;\n@@ -112,7 +112,7 @@ type compile_unit_md = {name: ~str};\n type subprogram_md = {id: ast::node_id};\n type local_var_md = {id: ast::node_id};\n type tydesc_md = {hash: uint};\n-type block_md = {start: codemap::Loc, end: codemap::Loc};\n+type block_md = {start: codemap::Loc<CharPos>, end: codemap::Loc<CharPos>};\n type argument_md = {id: ast::node_id};\n type retval_md = {id: ast::node_id};\n \n@@ -266,8 +266,8 @@ fn create_block(cx: block) -> @metadata<block_md> {\n     };\n     let lldata = ~[lltag(tg),\n                   parent,\n-                  lli32(start.line as int),\n-                  lli32(start.col as int),\n+                  lli32(start.line.to_int()),\n+                  lli32(start.col.to_int()),\n                   file_node.node,\n                   lli32(unique_id)\n                  ];\n@@ -713,8 +713,8 @@ fn update_source_pos(cx: block, s: span) {\n     let cm = cx.sess().codemap;\n     let blockmd = create_block(cx);\n     let loc = cm.lookup_char_pos(s.lo);\n-    let scopedata = ~[lli32(loc.line as int),\n-                     lli32(loc.col as int),\n+    let scopedata = ~[lli32(loc.line.to_int()),\n+                     lli32(loc.col.to_int()),\n                      blockmd.node,\n                      llnull()];\n     let dbgscope = llmdnode(scopedata);"}, {"sha": "198b26c4ecc691057887c072e6d539f615353dc5", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -106,7 +106,8 @@ fn explain_region_and_span(cx: ctxt, region: ty::Region)\n         -> (~str, Option<span>)\n     {\n         let lo = cx.sess.codemap.lookup_char_pos_adj(span.lo);\n-        (fmt!(\"the %s at %u:%u\", heading, lo.line, lo.col), Some(span))\n+        (fmt!(\"the %s at %u:%u\", heading,\n+              lo.line, lo.col.to_uint()), Some(span))\n     }\n }\n "}, {"sha": "6abcef5c7080820e37391f8c28a940f44b169d9a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -1,7 +1,7 @@\n-use codemap::span;\n+use codemap::{span, CharPos};\n use ast::*;\n \n-pure fn spanned<T>(lo: uint, hi: uint, +t: T) -> spanned<T> {\n+pure fn spanned<T>(+lo: CharPos, +hi: CharPos, +t: T) -> spanned<T> {\n     respan(mk_sp(lo, hi), move t)\n }\n \n@@ -14,12 +14,12 @@ pure fn dummy_spanned<T>(+t: T) -> spanned<T> {\n }\n \n /* assuming that we're not in macro expansion */\n-pure fn mk_sp(lo: uint, hi: uint) -> span {\n+pure fn mk_sp(+lo: CharPos, +hi: CharPos) -> span {\n     span {lo: lo, hi: hi, expn_info: None}\n }\n \n // make this a const, once the compiler supports it\n-pure fn dummy_sp() -> span { return mk_sp(0u, 0u); }\n+pure fn dummy_sp() -> span { return mk_sp(CharPos(0), CharPos(0)); }\n \n \n "}, {"sha": "3b6bae64104663dd6cae6f420943ffda4b30a377", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -6,6 +6,7 @@ use either::Either;\n use diagnostic::span_handler;\n use ast_util::{spanned, dummy_spanned};\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n+use codemap::CharPos;\n \n // Constructors\n export mk_name_value_item_str;\n@@ -74,7 +75,8 @@ fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n                        is_sugared_doc: false});\n }\n \n-fn mk_sugared_doc_attr(text: ~str, lo: uint, hi: uint) -> ast::attribute {\n+fn mk_sugared_doc_attr(text: ~str,\n+                       +lo: CharPos, +hi: CharPos) -> ast::attribute {\n     let lit = spanned(lo, hi, ast::lit_str(@text));\n     let attr = {\n         style: doc_comment_style(text),"}, {"sha": "8333849b21ddac17fdc00ef2df00fcc7c910740e", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 157, "deletions": 35, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -10,8 +10,109 @@ use std::serialization::{Serializable,\n                          Serializer,\n                          Deserializer};\n \n-pub type BytePos = uint;\n-pub type CharPos = uint;\n+trait Pos {\n+    static pure fn from_uint(n: uint) -> self;\n+    pure fn to_uint(&self) -> uint;\n+}\n+\n+pub enum BytePos = uint;\n+pub enum CharPos = uint;\n+\n+impl BytePos: Pos {\n+    static pure fn from_uint(n: uint) -> BytePos { BytePos(n) }\n+    pure fn to_uint(&self) -> uint { **self }\n+}\n+\n+impl BytePos: cmp::Eq {\n+    pure fn eq(other: &BytePos) -> bool {\n+        *self == **other\n+    }\n+    pure fn ne(other: &BytePos) -> bool { !self.eq(other) }\n+}\n+\n+impl BytePos: cmp::Ord {\n+    pure fn lt(other: &BytePos) -> bool { *self < **other }\n+    pure fn le(other: &BytePos) -> bool { *self <= **other }\n+    pure fn ge(other: &BytePos) -> bool { *self >= **other }\n+    pure fn gt(other: &BytePos) -> bool { *self > **other }\n+}\n+\n+impl BytePos: Num {\n+    pure fn add(other: &BytePos) -> BytePos {\n+        BytePos(*self + **other)\n+    }\n+    pure fn sub(other: &BytePos) -> BytePos {\n+        BytePos(*self - **other)\n+    }\n+    pure fn mul(other: &BytePos) -> BytePos {\n+        BytePos(*self * (**other))\n+    }\n+    pure fn div(other: &BytePos) -> BytePos {\n+        BytePos(*self / **other)\n+    }\n+    pure fn modulo(other: &BytePos) -> BytePos {\n+        BytePos(*self % **other)\n+    }\n+    pure fn neg() -> BytePos {\n+        BytePos(-*self)\n+    }\n+    pure fn to_int() -> int { *self as int }\n+    static pure fn from_int(+n: int) -> BytePos { BytePos(n as uint) }\n+}\n+\n+impl BytePos: to_bytes::IterBytes {\n+    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n+        (*self).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+impl CharPos: Pos {\n+    static pure fn from_uint(n: uint) -> CharPos { CharPos(n) }\n+    pure fn to_uint(&self) -> uint { **self }\n+}\n+\n+impl CharPos: cmp::Eq {\n+    pure fn eq(other: &CharPos) -> bool {\n+        *self == **other\n+    }\n+    pure fn ne(other: &CharPos) -> bool { !self.eq(other) }\n+}\n+\n+impl CharPos: cmp::Ord {\n+    pure fn lt(other: &CharPos) -> bool { *self < **other }\n+    pure fn le(other: &CharPos) -> bool { *self <= **other }\n+    pure fn ge(other: &CharPos) -> bool { *self >= **other }\n+    pure fn gt(other: &CharPos) -> bool { *self > **other }\n+}\n+\n+impl CharPos: Num {\n+    pure fn add(other: &CharPos) -> CharPos {\n+        CharPos(*self + **other)\n+    }\n+    pure fn sub(other: &CharPos) -> CharPos {\n+        CharPos(*self - **other)\n+    }\n+    pure fn mul(other: &CharPos) -> CharPos {\n+        CharPos(*self * (**other))\n+    }\n+    pure fn div(other: &CharPos) -> CharPos {\n+        CharPos(*self / **other)\n+    }\n+    pure fn modulo(other: &CharPos) -> CharPos {\n+        CharPos(*self % **other)\n+    }\n+    pure fn neg() -> CharPos {\n+        CharPos(-*self)\n+    }\n+    pure fn to_int() -> int { *self as int }\n+    static pure fn from_int(+n: int) -> CharPos { CharPos(n as uint) }\n+}\n+\n+impl CharPos: to_bytes::IterBytes {\n+    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n+        (*self).iter_bytes(lsb0, f)\n+    }\n+}\n \n pub struct span {\n     lo: CharPos,\n@@ -37,8 +138,8 @@ impl<D: Deserializer> span: Deserializable<D> {\n     }\n }\n \n-pub struct Loc {\n-    file: @FileMap, line: uint, col: uint\n+pub struct Loc<A: Pos> {\n+    file: @FileMap, line: uint, col: A\n }\n \n pub struct FilePos {\n@@ -69,7 +170,7 @@ pub struct FileLines {\n pub enum FileSubstr {\n     pub FssNone,\n     pub FssInternal(span),\n-    pub FssExternal({filename: ~str, line: uint, col: uint})\n+    pub FssExternal({filename: ~str, line: uint, col: CharPos})\n }\n \n pub struct FileMap {\n@@ -83,7 +184,7 @@ pub struct FileMap {\n pub impl FileMap {\n     static fn new_w_substr(+filename: FileName, +substr: FileSubstr,\n                            src: @~str,\n-                           start_pos_ch: uint, start_pos_byte: uint)\n+                           +start_pos_ch: CharPos, +start_pos_byte: BytePos)\n         -> FileMap {\n         return FileMap {\n             name: filename, substr: substr, src: src,\n@@ -93,18 +194,22 @@ pub impl FileMap {\n     }\n \n     static fn new(+filename: FileName, src: @~str,\n-                  start_pos_ch: CharPos, start_pos_byte: BytePos)\n+                  +start_pos_ch: CharPos, +start_pos_byte: BytePos)\n         -> FileMap {\n         return FileMap::new_w_substr(filename, FssNone, src,\n                                      start_pos_ch, start_pos_byte);\n     }\n \n-    fn next_line(@self, chpos: CharPos, byte_pos: BytePos) {\n-        self.lines.push(FilePos {ch: chpos, byte: byte_pos + self.start_pos.byte});\n+    fn next_line(@self, +chpos: CharPos, +byte_pos: BytePos) {\n+        self.lines.push(FilePos {\n+            ch: chpos,\n+            byte: byte_pos + self.start_pos.byte\n+        });\n     }\n \n     pub fn get_line(@self, line: int) -> ~str unsafe {\n-        let begin: uint = self.lines[line].byte - self.start_pos.byte;\n+        let begin: BytePos = self.lines[line].byte - self.start_pos.byte;\n+        let begin = begin.to_uint();\n         let end = match str::find_char_from(*self.src, '\\n', begin) {\n             Some(e) => e,\n             None => str::len(*self.src)\n@@ -127,21 +232,22 @@ pub impl CodeMap {\n \n     pub fn mk_substr_filename(@self, sp: span) -> ~str {\n         let pos = self.lookup_char_pos(sp.lo);\n-        return fmt!(\"<%s:%u:%u>\", pos.file.name, pos.line, pos.col);\n+        return fmt!(\"<%s:%u:%u>\", pos.file.name,\n+                    pos.line, pos.col.to_uint());\n     }\n \n-    pub fn lookup_char_pos(@self, pos: CharPos) -> Loc {\n-        pure fn lookup(pos: FilePos) -> uint { return pos.ch; }\n+    pub fn lookup_char_pos(@self, +pos: CharPos) -> Loc<CharPos> {\n+        pure fn lookup(pos: FilePos) -> uint { return pos.ch.to_uint(); }\n         return self.lookup_pos(pos, lookup);\n     }\n \n-    pub fn lookup_byte_pos(@self, pos: BytePos) -> Loc {\n-        pure fn lookup(pos: FilePos) -> uint { return pos.byte; }\n+    pub fn lookup_byte_pos(@self, +pos: BytePos) -> Loc<BytePos> {\n+        pure fn lookup(pos: FilePos) -> uint { return pos.byte.to_uint(); }\n         return self.lookup_pos(pos, lookup);\n     }\n \n-    pub fn lookup_char_pos_adj(@self, pos: CharPos)\n-        -> {filename: ~str, line: uint, col: uint, file: Option<@FileMap>}\n+    pub fn lookup_char_pos_adj(@self, +pos: CharPos)\n+        -> {filename: ~str, line: uint, col: CharPos, file: Option<@FileMap>}\n     {\n         let loc = self.lookup_char_pos(pos);\n         match (loc.file.substr) {\n@@ -152,7 +258,8 @@ pub impl CodeMap {\n                  file: Some(loc.file)}\n             }\n             FssInternal(sp) => {\n-                self.lookup_char_pos_adj(sp.lo + (pos - loc.file.start_pos.ch))\n+                self.lookup_char_pos_adj(\n+                    sp.lo + (pos - loc.file.start_pos.ch))\n             }\n             FssExternal(eloc) => {\n                 {filename: /* FIXME (#2543) */ copy eloc.filename,\n@@ -164,14 +271,17 @@ pub impl CodeMap {\n     }\n \n     pub fn adjust_span(@self, sp: span) -> span {\n-        pure fn lookup(pos: FilePos) -> uint { return pos.ch; }\n+        pure fn lookup(pos: FilePos) -> uint { return pos.ch.to_uint(); }\n         let line = self.lookup_line(sp.lo, lookup);\n         match (line.fm.substr) {\n             FssNone => sp,\n             FssInternal(s) => {\n-                self.adjust_span(span {lo: s.lo + (sp.lo - line.fm.start_pos.ch),\n-                                       hi: s.lo + (sp.hi - line.fm.start_pos.ch),\n-                                       expn_info: sp.expn_info})}\n+                self.adjust_span(span {\n+                    lo: s.lo + (sp.lo - line.fm.start_pos.ch),\n+                    hi: s.lo + (sp.hi - line.fm.start_pos.ch),\n+                    expn_info: sp.expn_info\n+                })\n+            }\n             FssExternal(_) => sp\n         }\n     }\n@@ -180,7 +290,7 @@ pub impl CodeMap {\n         let lo = self.lookup_char_pos_adj(sp.lo);\n         let hi = self.lookup_char_pos_adj(sp.hi);\n         return fmt!(\"%s:%u:%u: %u:%u\", lo.filename,\n-                    lo.line, lo.col, hi.line, hi.col)\n+                    lo.line, lo.col.to_uint(), hi.line, hi.col.to_uint())\n     }\n \n     pub fn span_to_filename(@self, sp: span) -> FileName {\n@@ -198,21 +308,24 @@ pub impl CodeMap {\n         return @FileLines {file: lo.file, lines: lines};\n     }\n \n-    fn lookup_byte_offset(@self, chpos: CharPos)\n+    fn lookup_byte_offset(@self, +chpos: CharPos)\n         -> {fm: @FileMap, pos: BytePos} {\n-        pure fn lookup(pos: FilePos) -> uint { return pos.ch; }\n+        pure fn lookup(pos: FilePos) -> uint { return pos.ch.to_uint(); }\n         let {fm, line} = self.lookup_line(chpos, lookup);\n         let line_offset = fm.lines[line].byte - fm.start_pos.byte;\n         let col = chpos - fm.lines[line].ch;\n-        let col_offset = str::count_bytes(*fm.src, line_offset, col);\n-        {fm: fm, pos: line_offset + col_offset}\n+        let col_offset = str::count_bytes(*fm.src,\n+                                          line_offset.to_uint(),\n+                                          col.to_uint());\n+        {fm: fm, pos: line_offset + BytePos(col_offset)}\n     }\n \n     pub fn span_to_snippet(@self, sp: span) -> ~str {\n         let begin = self.lookup_byte_offset(sp.lo);\n         let end = self.lookup_byte_offset(sp.hi);\n         assert begin.fm.start_pos == end.fm.start_pos;\n-        return str::slice(*begin.fm.src, begin.pos, end.pos);\n+        return str::slice(*begin.fm.src,\n+                          begin.pos.to_uint(), end.pos.to_uint());\n     }\n \n     pub fn get_filemap(@self, filename: ~str) -> @FileMap {\n@@ -225,39 +338,48 @@ pub impl CodeMap {\n }\n \n priv impl CodeMap {\n-    fn lookup_line(@self, pos: uint, lookup: LookupFn)\n+    fn lookup_line<A: Pos>(@self, pos: A, lookup: LookupFn)\n         -> {fm: @FileMap, line: uint}\n     {\n         let len = self.files.len();\n         let mut a = 0u;\n         let mut b = len;\n         while b - a > 1u {\n             let m = (a + b) / 2u;\n-            if lookup(self.files[m].start_pos) > pos { b = m; } else { a = m; }\n+            if lookup(self.files[m].start_pos) > pos.to_uint() {\n+                b = m;\n+            } else {\n+                a = m;\n+            }\n         }\n         if (a >= len) {\n-            fail fmt!(\"position %u does not resolve to a source location\", pos)\n+            fail fmt!(\"position %u does not resolve to a source location\",\n+                      pos.to_uint())\n         }\n         let f = self.files[a];\n         a = 0u;\n         b = vec::len(f.lines);\n         while b - a > 1u {\n             let m = (a + b) / 2u;\n-            if lookup(f.lines[m]) > pos { b = m; } else { a = m; }\n+            if lookup(f.lines[m]) > pos.to_uint() { b = m; } else { a = m; }\n         }\n         return {fm: f, line: a};\n     }\n \n-    fn lookup_pos(@self, pos: uint, lookup: LookupFn) -> Loc {\n+    fn lookup_pos<A: Pos Num>(@self, pos: A, lookup: LookupFn) -> Loc<A> {\n         let {fm: f, line: a} = self.lookup_line(pos, lookup);\n-        return Loc {file: f, line: a + 1u, col: pos - lookup(f.lines[a])};\n+        return Loc {\n+            file: f,\n+            line: a + 1u,\n+            col: pos - from_uint(lookup(f.lines[a]))\n+        };\n     }\n \n     fn span_to_str_no_adj(@self, sp: span) -> ~str {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n         return fmt!(\"%s:%u:%u: %u:%u\", lo.file.name,\n-                    lo.line, lo.col, hi.line, hi.col)\n+                    lo.line, lo.col.to_uint(), hi.line, hi.col.to_uint())\n     }\n }\n "}, {"sha": "007100856ebc416366b037e2c898856093c03d4c", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -245,15 +245,15 @@ fn highlight_lines(cm: @codemap::CodeMap, sp: span,\n         while num > 0u { num /= 10u; digits += 1u; }\n \n         // indent past |name:## | and the 0-offset column location\n-        let mut left = str::len(fm.name) + digits + lo.col + 3u;\n+        let mut left = str::len(fm.name) + digits + lo.col.to_uint() + 3u;\n         let mut s = ~\"\";\n         while left > 0u { str::push_char(&mut s, ' '); left -= 1u; }\n \n         s += ~\"^\";\n         let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n-            let mut width = hi.col - lo.col - 1u;\n+            let mut width = hi.col.to_uint() - lo.col.to_uint() - 1u;\n             while width > 0u { str::push_char(&mut s, '~'); width -= 1u; }\n         }\n         io::stderr().write_str(s + ~\"\\n\");"}, {"sha": "66ef3bec2a747aa7c6c498a5a08f8664c2101c75", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -178,7 +178,9 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n         }\n         fn bt_pop() {\n             match self.backtrace {\n-              Some(@ExpandedFrom({call_site: span {expn_info: prev, _}, _})) => {\n+              Some(@ExpandedFrom({\n+                  call_site: span {expn_info: prev, _}, _\n+              })) => {\n                 self.backtrace = prev\n               }\n               _ => self.bug(~\"tried to pop without a push\")"}, {"sha": "652ad5533c4c793373144c0c26538e37573aed75", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -4,7 +4,7 @@\n // something smarter.\n \n use ast::{ident, node_id};\n-use ast_util::{ident_to_path, respan};\n+use ast_util::{ident_to_path, respan, dummy_sp};\n use codemap::span;\n use ext::base::mk_ctxt;\n \n@@ -23,10 +23,6 @@ fn path(ids: ~[ident], span: span) -> @ast::path {\n       types: ~[]}\n }\n \n-fn empty_span() -> span {\n-    span {lo: 0, hi: 0, expn_info: None}\n-}\n-\n trait append_types {\n     fn add_ty(ty: @ast::Ty) -> @ast::path;\n     fn add_tys(+tys: ~[@ast::Ty]) -> @ast::path;\n@@ -83,26 +79,21 @@ trait ext_ctxt_ast_builder {\n     fn stmt_let(ident: ident, e: @ast::expr) -> @ast::stmt;\n     fn stmt_expr(e: @ast::expr) -> @ast::stmt;\n     fn block_expr(b: ast::blk) -> @ast::expr;\n-    fn empty_span() -> span;\n     fn ty_option(ty: @ast::Ty) -> @ast::Ty;\n }\n \n impl ext_ctxt: ext_ctxt_ast_builder {\n     fn ty_option(ty: @ast::Ty) -> @ast::Ty {\n         self.ty_path_ast_builder(path(~[self.ident_of(~\"Option\")],\n-                                      self.empty_span())\n+                                      dummy_sp())\n                                  .add_ty(ty))\n     }\n \n-    fn empty_span() -> span {\n-        span {lo: 0, hi: 0, expn_info: self.backtrace()}\n-    }\n-\n     fn block_expr(b: ast::blk) -> @ast::expr {\n         @{id: self.next_id(),\n           callee_id: self.next_id(),\n           node: ast::expr_block(b),\n-          span: self.empty_span()}\n+          span: dummy_sp()}\n     }\n \n     fn move_expr(e: @ast::expr) -> @ast::expr {\n@@ -114,7 +105,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n \n     fn stmt_expr(e: @ast::expr) -> @ast::stmt {\n         @{node: ast::stmt_expr(e, self.next_id()),\n-          span: self.empty_span()}\n+          span: dummy_sp()}\n     }\n \n     fn stmt_let(ident: ident, e: @ast::expr) -> @ast::stmt {\n@@ -130,43 +121,43 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n                      pat: @{id: self.next_id(),\n                             node: ast::pat_ident(ast::bind_by_implicit_ref,\n                                                  path(~[ident],\n-                                                      self.empty_span()),\n+                                                      dummy_sp()),\n                                                  None),\n-                            span: self.empty_span()},\n+                            span: dummy_sp()},\n                      init: Some(self.move_expr(e)),\n                      id: self.next_id()},\n-              span: self.empty_span()}]),\n-                               span: self.empty_span()}, self.next_id()),\n-         span: self.empty_span()}\n+              span: dummy_sp()}]),\n+                               span: dummy_sp()}, self.next_id()),\n+         span: dummy_sp()}\n     }\n \n     fn field_imm(name: ident, e: @ast::expr) -> ast::field {\n         {node: {mutbl: ast::m_imm, ident: name, expr: e},\n-         span: self.empty_span()}\n+         span: dummy_sp()}\n     }\n \n     fn rec(+fields: ~[ast::field]) -> @ast::expr {\n         @{id: self.next_id(),\n           callee_id: self.next_id(),\n           node: ast::expr_rec(fields, None),\n-          span: self.empty_span()}\n+          span: dummy_sp()}\n     }\n \n     fn ty_field_imm(name: ident, ty: @ast::Ty) -> ast::ty_field {\n         {node: {ident: name, mt: { ty: ty, mutbl: ast::m_imm } },\n-          span: self.empty_span()}\n+          span: dummy_sp()}\n     }\n \n     fn ty_rec(+fields: ~[ast::ty_field]) -> @ast::Ty {\n         @{id: self.next_id(),\n           node: ast::ty_rec(fields),\n-          span: self.empty_span()}\n+          span: dummy_sp()}\n     }\n \n     fn ty_infer() -> @ast::Ty {\n         @{id: self.next_id(),\n           node: ast::ty_infer,\n-          span: self.empty_span()}\n+          span: dummy_sp()}\n     }\n \n     fn ty_param(id: ast::ident, +bounds: ~[ast::ty_param_bound])\n@@ -181,9 +172,9 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n          pat: @{id: self.next_id(),\n                 node: ast::pat_ident(\n                     ast::bind_by_value,\n-                    ast_util::ident_to_path(self.empty_span(), name),\n+                    ast_util::ident_to_path(dummy_sp(), name),\n                     None),\n-                span: self.empty_span()},\n+                span: dummy_sp()},\n          id: self.next_id()}\n     }\n \n@@ -195,7 +186,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n                    rules: ast::default_blk};\n \n         {node: blk,\n-         span: self.empty_span()}\n+         span: dummy_sp()}\n     }\n \n     fn expr_block(e: @ast::expr) -> ast::blk {\n@@ -215,11 +206,11 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n \n         // XXX: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n-        let non_camel_case_attribute = respan(self.empty_span(), {\n+        let non_camel_case_attribute = respan(dummy_sp(), {\n             style: ast::attr_outer,\n-            value: respan(self.empty_span(),\n+            value: respan(dummy_sp(),\n                           ast::meta_list(~\"allow\", ~[\n-                              @respan(self.empty_span(),\n+                              @respan(dummy_sp(),\n                                       ast::meta_word(~\"non_camel_case_types\"))\n                           ])),\n             is_sugared_doc: false\n@@ -239,7 +230,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n                     +ty_params: ~[ast::ty_param],\n                     +body: ast::blk) -> @ast::item {\n         self.item(name,\n-                  self.empty_span(),\n+                  dummy_sp(),\n                   ast::item_fn(self.fn_decl(inputs, output),\n                                ast::impure_fn,\n                                ty_params,\n@@ -298,7 +289,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     fn ty_nil_ast_builder() -> @ast::Ty {\n         @{id: self.next_id(),\n           node: ast::ty_nil,\n-          span: self.empty_span()}\n+          span: dummy_sp()}\n     }\n \n     fn item_ty_poly(name: ident,\n@@ -314,6 +305,6 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n \n     fn ty_vars(+ty_params: ~[ast::ty_param]) -> ~[@ast::Ty] {\n         ty_params.map(|p| self.ty_path_ast_builder(\n-            path(~[p.ident], self.empty_span())))\n+            path(~[p.ident], dummy_sp())))\n     }\n }"}, {"sha": "a90b679f6974c9530963e1dbb8cc2ad351c06fff", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -22,7 +22,6 @@ that.\n use ext::base::ext_ctxt;\n \n use proto::{state, protocol, next_state};\n-use ast_builder::empty_span;\n \n impl ext_ctxt: proto::visitor<(), (), ()>  {\n     fn visit_proto(_proto: protocol,"}, {"sha": "e86b3f0ea59e49cb5b708a22cd876e9c90f9b06b", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -29,8 +29,6 @@ updating the states using rule (2) until there are no changes.\n \n use std::bitv::{Bitv};\n \n-use ast_builder::empty_span;\n-\n fn analyze(proto: protocol, _cx: ext_ctxt) {\n     debug!(\"initializing colive analysis\");\n     let num_states = proto.num_states();"}, {"sha": "d03a0fde66c97f61d9ebb7091fd16a23c7e694ff", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -5,14 +5,15 @@ use to_str::ToStr;\n use dvec::DVec;\n \n use ast::ident;\n+use ast_util::dummy_sp;\n use util::interner;\n use print::pprust;\n use pprust::{item_to_str, ty_to_str};\n use ext::base::{mk_ctxt, ext_ctxt};\n use parse::*;\n use proto::*;\n \n-use ast_builder::{append_types, path, empty_span};\n+use ast_builder::{append_types, path};\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -256,11 +257,11 @@ impl state: to_type_decls {\n                     cx.ty_path_ast_builder(\n                         path(~[cx.ident_of(~\"pipes\"),\n                                cx.ident_of(dir.to_str() + ~\"Packet\")],\n-                             empty_span())\n+                             dummy_sp())\n                         .add_ty(cx.ty_path_ast_builder(\n                             path(~[cx.ident_of(self.proto.name),\n                                    self.data_name()],\n-                                 empty_span())\n+                                 dummy_sp())\n                             .add_tys(cx.ty_vars(self.ty_params))))),\n                     self.ty_params));\n         }\n@@ -273,11 +274,11 @@ impl state: to_type_decls {\n                         path(~[cx.ident_of(~\"pipes\"),\n                                cx.ident_of(dir.to_str()\n                                            + ~\"PacketBuffered\")],\n-                             empty_span())\n+                             dummy_sp())\n                         .add_tys(~[cx.ty_path_ast_builder(\n                             path(~[cx.ident_of(self.proto.name),\n                                    self.data_name()],\n-                                 empty_span())\n+                                 dummy_sp())\n                             .add_tys(cx.ty_vars(self.ty_params))),\n                                    self.proto.buffer_ty_path(cx)])),\n                     self.ty_params));\n@@ -394,7 +395,7 @@ impl protocol: gen_init {\n \n         cx.item_ty_poly(\n             cx.ident_of(~\"__Buffer\"),\n-            cx.empty_span(),\n+            dummy_sp(),\n             cx.ty_rec(fields),\n             params)\n     }"}, {"sha": "50d1e0033e276470659caad7e8916df9edf73db0", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -4,6 +4,7 @@ use parse::parser;\n use parse::parser::{Parser, parse_from_source_str};\n use dvec::DVec;\n use parse::token::ident_interner;\n+use codemap::CharPos;\n \n use fold::*;\n use visit::*;\n@@ -15,13 +16,13 @@ use io::*;\n use codemap::span;\n \n struct gather_item {\n-    lo: uint,\n-    hi: uint,\n+    lo: CharPos,\n+    hi: CharPos,\n     e: @ast::expr,\n     constr: ~str\n }\n \n-type aq_ctxt = @{lo: uint, gather: DVec<gather_item>};\n+type aq_ctxt = @{lo: CharPos, gather: DVec<gather_item>};\n enum fragment {\n     from_expr(@ast::expr),\n     from_ty(@ast::Ty)\n@@ -114,7 +115,7 @@ impl @ast::pat: qq_helper {\n     fn get_fold_fn() -> ~str {~\"fold_pat\"}\n }\n \n-fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n+fn gather_anti_quotes<N: qq_helper>(lo: CharPos, node: N) -> aq_ctxt\n {\n     let v = @{visit_expr: |node, &&cx, v| visit_aq(node, ~\"from_expr\", cx, v),\n               visit_ty: |node, &&cx, v| visit_aq(node, ~\"from_ty\", cx, v),\n@@ -226,7 +227,8 @@ fn finish<T: qq_helper>\n     let mut str2 = ~\"\";\n     enum state {active, skip(uint), blank};\n     let mut state = active;\n-    let mut i = 0u, j = 0u;\n+    let mut i = CharPos(0u);\n+    let mut j = 0u;\n     let g_len = cx.gather.len();\n     for str::chars_each(*str) |ch| {\n         if (j < g_len && i == cx.gather[j].lo) {\n@@ -242,7 +244,7 @@ fn finish<T: qq_helper>\n           blank if is_space(ch) => str::push_char(&mut str2, ch),\n           blank => str::push_char(&mut str2, ' ')\n         }\n-        i += 1u;\n+        i += CharPos(1u);\n         if (j < g_len && i == cx.gather[j].hi) {\n             assert ch == ')';\n             state = active;\n@@ -270,7 +272,7 @@ fn finish<T: qq_helper>\n                                  ~\"qquote\", ~\"mk_file_substr\"]),\n                                 ~[mk_uniq_str(cx,sp, loc.file.name),\n                                  mk_uint(cx,sp, loc.line),\n-                                 mk_uint(cx,sp, loc.col)]),\n+                                 mk_uint(cx,sp, loc.col.to_uint())]),\n                         mk_unary(cx,sp, ast::box(ast::m_imm),\n                                  mk_uniq_str(cx,sp, str2)),\n                         cfg_call(),\n@@ -346,7 +348,7 @@ fn replace_ty(repls: ~[fragment],\n \n fn mk_file_substr(fname: ~str, line: uint, col: uint) ->\n     codemap::FileSubstr {\n-    codemap::FssExternal({filename: fname, line: line, col: col})\n+    codemap::FssExternal({filename: fname, line: line, col: CharPos(col)})\n }\n \n // Local Variables:"}, {"sha": "3fed340904a7a298f0f4cf27e52ea4d3a3e5acf3", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -25,7 +25,7 @@ fn expand_col(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n               _body: ast::mac_body) -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"col\");\n     let loc = cx.codemap().lookup_char_pos(sp.lo);\n-    return mk_uint(cx, sp, loc.col);\n+    return mk_uint(cx, sp, loc.col.to_uint());\n }\n \n /* file!(): expands to the current filename */"}, {"sha": "2f371e1f8c58193404d2a680c44dc3d1a3c6b219", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -11,6 +11,7 @@ use dvec::DVec;\n use ast::{matcher, match_tok, match_seq, match_nonterminal, ident};\n use ast_util::mk_sp;\n use std::map::HashMap;\n+use codemap::CharPos;\n \n /* This is an Earley-like parser, without support for in-grammar nonterminals,\n only by calling out to the main rust parser for named nonterminals (which it\n@@ -102,7 +103,7 @@ type matcher_pos = ~{\n     mut up: matcher_pos_up, // mutable for swapping only\n     matches: ~[DVec<@named_match>],\n     match_lo: uint, match_hi: uint,\n-    sp_lo: uint,\n+    sp_lo: CharPos,\n };\n \n fn copy_up(&& mpu: matcher_pos_up) -> matcher_pos {\n@@ -122,7 +123,7 @@ fn count_names(ms: &[matcher]) -> uint {\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: uint)\n+fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: CharPos)\n     -> matcher_pos {\n     let mut match_idx_hi = 0u;\n     for ms.each() |elt| {"}, {"sha": "78f0e4fc8f8bf763cfd90d67e8acc2c2d7671952", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -53,7 +53,7 @@ fn new_tt_reader(sp_diag: span_handler, itr: @ident_interner,\n               mut repeat_len: ~[],\n               /* dummy values, never read: */\n               mut cur_tok: EOF,\n-              mut cur_span: ast_util::mk_sp(0u,0u)\n+              mut cur_span: ast_util::dummy_sp()\n              };\n     tt_next_token(r); /* get cur_tok and cur_span set up */\n     return r;"}, {"sha": "27338b86bea9e417df2ea5e520befc9f6d722a19", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -20,16 +20,16 @@ use util::interner;\n use diagnostic::{span_handler, mk_span_handler, mk_handler, emitter};\n use lexer::{reader, string_reader};\n use parse::token::{ident_interner, mk_ident_interner};\n-use codemap::{CodeMap, FileMap};\n+use codemap::{CodeMap, FileMap, CharPos, BytePos};\n \n type parse_sess = @{\n     cm: @codemap::CodeMap,\n     mut next_id: node_id,\n     span_diagnostic: span_handler,\n     interner: @ident_interner,\n     // these two must be kept up to date\n-    mut chpos: uint,\n-    mut byte_pos: uint\n+    mut chpos: CharPos,\n+    mut byte_pos: BytePos\n };\n \n fn new_parse_sess(demitter: Option<emitter>) -> parse_sess {\n@@ -38,7 +38,7 @@ fn new_parse_sess(demitter: Option<emitter>) -> parse_sess {\n              mut next_id: 1,\n              span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n              interner: mk_ident_interner(),\n-             mut chpos: 0u, mut byte_pos: 0u};\n+             mut chpos: CharPos(0u), mut byte_pos: BytePos(0u)};\n }\n \n fn new_parse_sess_special_handler(sh: span_handler, cm: @codemap::CodeMap)\n@@ -47,7 +47,7 @@ fn new_parse_sess_special_handler(sh: span_handler, cm: @codemap::CodeMap)\n              mut next_id: 1,\n              span_diagnostic: sh,\n              interner: mk_ident_interner(),\n-             mut chpos: 0u, mut byte_pos: 0u};\n+             mut chpos: CharPos(0u), mut byte_pos: BytePos(0u)};\n }\n \n fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,"}, {"sha": "31528c10fe1aadfd8a4d8fb938aa42f63eefa92b", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -14,7 +14,7 @@ trait parser_attr {\n         -> attr_or_ext;\n     fn parse_outer_attributes() -> ~[ast::attribute];\n     fn parse_attribute(style: ast::attr_style) -> ast::attribute;\n-    fn parse_attribute_naked(style: ast::attr_style, lo: uint) ->\n+    fn parse_attribute_naked(style: ast::attr_style, lo: CharPos) ->\n         ast::attribute;\n     fn parse_inner_attrs_and_next() ->\n         {inner: ~[ast::attribute], next: ~[ast::attribute]};\n@@ -85,7 +85,7 @@ impl Parser: parser_attr {\n         return self.parse_attribute_naked(style, lo);\n     }\n \n-    fn parse_attribute_naked(style: ast::attr_style, lo: uint) ->\n+    fn parse_attribute_naked(style: ast::attr_style, lo: CharPos) ->\n         ast::attribute {\n         self.expect(token::LBRACKET);\n         let meta_item = self.parse_meta_item();"}, {"sha": "06b042a468a94b336169758bb9c3fcdbf159f35b", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -3,7 +3,7 @@ use io::ReaderUtil;\n use util::interner;\n use lexer::{string_reader, bump, is_eof, nextch,\n                is_whitespace, get_str_from, reader};\n-use codemap::FileMap;\n+use codemap::{FileMap, CharPos};\n \n export cmnt;\n export lit;\n@@ -28,7 +28,7 @@ impl cmnt_style : cmp::Eq {\n     }\n }\n \n-type cmnt = {style: cmnt_style, lines: ~[~str], pos: uint};\n+type cmnt = {style: cmnt_style, lines: ~[~str], pos: CharPos};\n \n fn is_doc_comment(s: ~str) -> bool {\n     s.starts_with(~\"///\") ||\n@@ -137,7 +137,7 @@ fn push_blank_line_comment(rdr: string_reader, comments: &mut ~[cmnt]) {\n fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n                                            comments: &mut ~[cmnt]) {\n     while is_whitespace(rdr.curr) && !is_eof(rdr) {\n-        if rdr.col == 0u && rdr.curr == '\\n' {\n+        if rdr.col == CharPos(0u) && rdr.curr == '\\n' {\n             push_blank_line_comment(rdr, comments);\n         }\n         bump(rdr);\n@@ -181,6 +181,8 @@ fn read_line_comments(rdr: string_reader, code_to_the_left: bool,\n     }\n }\n \n+// FIXME #3961: This is not the right way to convert string byte\n+// offsets to characters.\n fn all_whitespace(s: ~str, begin: uint, end: uint) -> bool {\n     let mut i: uint = begin;\n     while i != end {\n@@ -190,9 +192,11 @@ fn all_whitespace(s: ~str, begin: uint, end: uint) -> bool {\n }\n \n fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n-                                        s: ~str, col: uint) {\n+                                        s: ~str, col: CharPos) {\n     let mut s1;\n     let len = str::len(s);\n+    // FIXME #3961: Doing bytewise comparison and slicing with CharPos\n+    let col = col.to_uint();\n     if all_whitespace(s, 0u, uint::min(len, col)) {\n         if col < len {\n             s1 = str::slice(s, col, len);\n@@ -207,7 +211,7 @@ fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n     debug!(\">>> block comment\");\n     let p = rdr.chpos;\n     let mut lines: ~[~str] = ~[];\n-    let mut col: uint = rdr.col;\n+    let mut col: CharPos = rdr.col;\n     bump(rdr);\n     bump(rdr);\n \n@@ -280,7 +284,7 @@ fn consume_comment(rdr: string_reader, code_to_the_left: bool,\n     debug!(\"<<< consume comment\");\n }\n \n-type lit = {lit: ~str, pos: uint};\n+type lit = {lit: ~str, pos: CharPos};\n \n fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n                                 path: ~str,\n@@ -289,7 +293,8 @@ fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n     let src = @str::from_bytes(srdr.read_whole_stream());\n     let itr = parse::token::mk_fake_ident_interner();\n     let rdr = lexer::new_low_level_string_reader\n-        (span_diagnostic, @FileMap::new(path, src, 0u, 0u), itr);\n+        (span_diagnostic, @FileMap::new(path, src,\n+                                        CharPos(0u), BytePos(0u)), itr);\n \n     let mut comments: ~[cmnt] = ~[];\n     let mut literals: ~[lit] = ~[];"}, {"sha": "66930009eb896c63098f11669e10db39520d0011", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -205,7 +205,7 @@ impl Parser: parser_common {\n         if self.token == token::GT {\n             self.bump();\n         } else if self.token == token::BINOP(token::SHR) {\n-            self.swap(token::GT, self.span.lo + 1u, self.span.hi);\n+            self.swap(token::GT, self.span.lo + CharPos(1u), self.span.hi);\n         } else {\n             let mut s: ~str = ~\"expected `\";\n             s += token_to_str(self.reader, token::GT);"}, {"sha": "dbeaff286252618e76ba049afe18585847833699", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -1,5 +1,5 @@\n use diagnostic::span_handler;\n-use codemap::{span, CodeMap};\n+use codemap::{span, CodeMap, CharPos, BytePos};\n use ext::tt::transcribe::{tt_reader,  new_tt_reader, dup_tt_reader,\n                              tt_next_token};\n \n@@ -21,10 +21,10 @@ trait reader {\n type string_reader = @{\n     span_diagnostic: span_handler,\n     src: @~str,\n-    mut col: uint,\n-    mut pos: uint,\n+    mut col: CharPos,\n+    mut pos: BytePos,\n     mut curr: char,\n-    mut chpos: uint,\n+    mut chpos: CharPos,\n     filemap: @codemap::FileMap,\n     interner: @token::ident_interner,\n     /* cached: */\n@@ -46,15 +46,15 @@ fn new_low_level_string_reader(span_diagnostic: span_handler,\n                                itr: @token::ident_interner)\n     -> string_reader {\n     let r = @{span_diagnostic: span_diagnostic, src: filemap.src,\n-              mut col: 0u, mut pos: 0u, mut curr: -1 as char,\n+              mut col: CharPos(0), mut pos: BytePos(0), mut curr: -1 as char,\n               mut chpos: filemap.start_pos.ch,\n               filemap: filemap, interner: itr,\n               /* dummy values; not read */\n               mut peek_tok: token::EOF,\n-              mut peek_span: ast_util::mk_sp(0u,0u)};\n-    if r.pos < (*filemap.src).len() {\n-        let next = str::char_range_at(*r.src, r.pos);\n-        r.pos = next.next;\n+              mut peek_span: ast_util::dummy_sp()};\n+    if r.pos.to_uint() < (*filemap.src).len() {\n+        let next = str::char_range_at(*r.src, r.pos.to_uint());\n+        r.pos = BytePos(next.next);\n         r.curr = next.ch;\n     }\n     return r;\n@@ -124,27 +124,27 @@ fn string_advance_token(&&r: string_reader) {\n \n }\n \n-fn get_str_from(rdr: string_reader, start: uint) -> ~str unsafe {\n+fn get_str_from(rdr: string_reader, start: BytePos) -> ~str unsafe {\n     // I'm pretty skeptical about this subtraction. What if there's a\n     // multi-byte character before the mark?\n-    return str::slice(*rdr.src, start - 1u, rdr.pos - 1u);\n+    return str::slice(*rdr.src, start.to_uint() - 1u, rdr.pos.to_uint() - 1u);\n }\n \n fn bump(rdr: string_reader) {\n-    if rdr.pos < (*rdr.src).len() {\n-        rdr.col += 1u;\n-        rdr.chpos += 1u;\n+    if rdr.pos.to_uint() < (*rdr.src).len() {\n+        rdr.col += CharPos(1u);\n+        rdr.chpos += CharPos(1u);\n         if rdr.curr == '\\n' {\n             rdr.filemap.next_line(rdr.chpos, rdr.pos);\n-            rdr.col = 0u;\n+            rdr.col = CharPos(0u);\n         }\n-        let next = str::char_range_at(*rdr.src, rdr.pos);\n-        rdr.pos = next.next;\n+        let next = str::char_range_at(*rdr.src, rdr.pos.to_uint());\n+        rdr.pos = BytePos(next.next);\n         rdr.curr = next.ch;\n     } else {\n         if (rdr.curr != -1 as char) {\n-            rdr.col += 1u;\n-            rdr.chpos += 1u;\n+            rdr.col += CharPos(1u);\n+            rdr.chpos += CharPos(1u);\n             rdr.curr = -1 as char;\n         }\n     }\n@@ -153,8 +153,8 @@ fn is_eof(rdr: string_reader) -> bool {\n     rdr.curr == -1 as char\n }\n fn nextch(rdr: string_reader) -> char {\n-    if rdr.pos < (*rdr.src).len() {\n-        return str::char_at(*rdr.src, rdr.pos);\n+    if rdr.pos.to_uint() < (*rdr.src).len() {\n+        return str::char_at(*rdr.src, rdr.pos.to_uint());\n     } else { return -1 as char; }\n }\n \n@@ -211,7 +211,7 @@ fn consume_any_line_comment(rdr: string_reader)\n             bump(rdr);\n             // line comments starting with \"///\" or \"//!\" are doc-comments\n             if rdr.curr == '/' || rdr.curr == '!' {\n-                let start_chpos = rdr.chpos - 2u;\n+                let start_chpos = rdr.chpos - CharPos(2u);\n                 let mut acc = ~\"//\";\n                 while rdr.curr != '\\n' && !is_eof(rdr) {\n                     str::push_char(&mut acc, rdr.curr);\n@@ -235,7 +235,7 @@ fn consume_any_line_comment(rdr: string_reader)\n             let cmap = @CodeMap::new();\n             (*cmap).files.push(rdr.filemap);\n             let loc = cmap.lookup_char_pos_adj(rdr.chpos);\n-            if loc.line == 1u && loc.col == 0u {\n+            if loc.line == 1u && loc.col == CharPos(0u) {\n                 while rdr.curr != '\\n' && !is_eof(rdr) { bump(rdr); }\n                 return consume_whitespace_and_comments(rdr);\n             }\n@@ -250,7 +250,7 @@ fn consume_block_comment(rdr: string_reader)\n \n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n     if rdr.curr == '*' || rdr.curr == '!' {\n-        let start_chpos = rdr.chpos - 2u;\n+        let start_chpos = rdr.chpos - CharPos(2u);\n         let mut acc = ~\"/*\";\n         while !(rdr.curr == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n             str::push_char(&mut acc, rdr.curr);\n@@ -584,7 +584,7 @@ fn next_token_inner(rdr: string_reader) -> token::Token {\n         return token::LIT_INT(c2 as i64, ast::ty_char);\n       }\n       '\"' => {\n-        let n = rdr.chpos;\n+        let n = rdr.pos;\n         bump(rdr);\n         while rdr.curr != '\"' {\n             if is_eof(rdr) {"}, {"sha": "bd314d6bcaf5dae733f735d2c93b20043e47f917", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -5,7 +5,7 @@ use either::{Either, Left, Right};\n use std::map::HashMap;\n use token::{can_begin_expr, is_ident, is_ident_or_path, is_plain_ident,\n             INTERPOLATED, special_idents};\n-use codemap::{span,FssNone};\n+use codemap::{span,FssNone, CharPos};\n use util::interner::Interner;\n use ast_util::{spanned, respan, mk_sp, ident_to_path, operator_prec};\n use lexer::reader;\n@@ -244,7 +244,7 @@ impl Parser {\n         self.token = next.tok;\n         self.span = next.sp;\n     }\n-    fn swap(next: token::Token, lo: uint, hi: uint) {\n+    fn swap(next: token::Token, +lo: CharPos, +hi: CharPos) {\n         self.token = next;\n         self.span = mk_sp(lo, hi);\n     }\n@@ -904,12 +904,12 @@ impl Parser {\n         return spanned(lo, e.span.hi, {mutbl: m, ident: i, expr: e});\n     }\n \n-    fn mk_expr(lo: uint, hi: uint, +node: expr_) -> @expr {\n+    fn mk_expr(+lo: CharPos, +hi: CharPos, +node: expr_) -> @expr {\n         return @{id: self.get_id(), callee_id: self.get_id(),\n               node: node, span: mk_sp(lo, hi)};\n     }\n \n-    fn mk_mac_expr(lo: uint, hi: uint, m: mac_) -> @expr {\n+    fn mk_mac_expr(+lo: CharPos, +hi: CharPos, m: mac_) -> @expr {\n         return @{id: self.get_id(),\n               callee_id: self.get_id(),\n               node: expr_mac({node: m, span: mk_sp(lo, hi)}),\n@@ -1134,7 +1134,7 @@ impl Parser {\n         return self.mk_expr(lo, hi, ex);\n     }\n \n-    fn parse_block_expr(lo: uint, blk_mode: blk_check_mode) -> @expr {\n+    fn parse_block_expr(lo: CharPos, blk_mode: blk_check_mode) -> @expr {\n         self.expect(token::LBRACE);\n         let blk = self.parse_block_tail(lo, blk_mode);\n         return self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n@@ -1146,7 +1146,7 @@ impl Parser {\n         return self.parse_syntax_ext_naked(lo);\n     }\n \n-    fn parse_syntax_ext_naked(lo: uint) -> @expr {\n+    fn parse_syntax_ext_naked(lo: CharPos) -> @expr {\n         match self.token {\n           token::IDENT(_, _) => (),\n           _ => self.fatal(~\"expected a syntax expander name\")\n@@ -2279,11 +2279,11 @@ impl Parser {\n     // I guess that also means \"already parsed the 'impure'\" if\n     // necessary, and this should take a qualifier.\n     // some blocks start with \"#{\"...\n-    fn parse_block_tail(lo: uint, s: blk_check_mode) -> blk {\n+    fn parse_block_tail(lo: CharPos, s: blk_check_mode) -> blk {\n         self.parse_block_tail_(lo, s, ~[])\n     }\n \n-    fn parse_block_tail_(lo: uint, s: blk_check_mode,\n+    fn parse_block_tail_(lo: CharPos, s: blk_check_mode,\n                          +first_item_attrs: ~[attribute]) -> blk {\n         let mut stmts = ~[];\n         let mut expr = None;\n@@ -2581,7 +2581,7 @@ impl Parser {\n         return {ident: id, tps: ty_params};\n     }\n \n-    fn mk_item(lo: uint, hi: uint, +ident: ident,\n+    fn mk_item(+lo: CharPos, +hi: CharPos, +ident: ident,\n                +node: item_, vis: visibility,\n                +attrs: ~[attribute]) -> @item {\n         return @{ident: ident,\n@@ -3037,7 +3037,7 @@ impl Parser {\n             items: items};\n     }\n \n-    fn parse_item_foreign_mod(lo: uint,\n+    fn parse_item_foreign_mod(lo: CharPos,\n                               visibility: visibility,\n                               attrs: ~[attribute],\n                               items_allowed: bool)\n@@ -3092,7 +3092,7 @@ impl Parser {\n         });\n     }\n \n-    fn parse_type_decl() -> {lo: uint, ident: ident} {\n+    fn parse_type_decl() -> {lo: CharPos, ident: ident} {\n         let lo = self.last_span.lo;\n         let id = self.parse_ident();\n         return {lo: lo, ident: id};"}, {"sha": "910cb89ec75700d7d7f0398f481a338c532f3459", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f67bfe97389a256fc95216c29a2b8a066ee16a2c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f67bfe97389a256fc95216c29a2b8a066ee16a2c", "patch": "@@ -1,5 +1,5 @@\n use parse::{comments, lexer, token};\n-use codemap::CodeMap;\n+use codemap::{CodeMap, CharPos};\n use pp::{break_offset, word, printer, space, zerobreak, hardbreak, breaks};\n use pp::{consistent, inconsistent, eof};\n use ast::{required, provided};\n@@ -631,7 +631,7 @@ fn print_variants(s: ps, variants: ~[ast::variant], span: ast::span) {\n         print_variant(s, *v);\n         word(s.s, ~\",\");\n         end(s);\n-        maybe_print_trailing_comment(s, v.span, None::<uint>);\n+        maybe_print_trailing_comment(s, v.span, None);\n     }\n     bclose(s, span);\n }\n@@ -886,7 +886,7 @@ fn print_stmt(s: ps, st: ast::stmt) {\n       }\n     }\n     if parse::classify::stmt_ends_with_semi(st) { word(s.s, ~\";\"); }\n-    maybe_print_trailing_comment(s, st.span, None::<uint>);\n+    maybe_print_trailing_comment(s, st.span, None);\n }\n \n fn print_block(s: ps, blk: ast::blk) {\n@@ -1898,15 +1898,15 @@ fn print_ty_fn(s: ps,\n }\n \n fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n-                                next_pos: Option<uint>) {\n+                                next_pos: Option<CharPos>) {\n     let mut cm;\n     match s.cm { Some(ccm) => cm = ccm, _ => return }\n     match next_comment(s) {\n       Some(cmnt) => {\n         if cmnt.style != comments::trailing { return; }\n         let span_line = cm.lookup_char_pos(span.hi);\n         let comment_line = cm.lookup_char_pos(cmnt.pos);\n-        let mut next = cmnt.pos + 1u;\n+        let mut next = cmnt.pos + CharPos(1u);\n         match next_pos { None => (), Some(p) => next = p }\n         if span.hi < cmnt.pos && cmnt.pos < next &&\n                span_line.line == comment_line.line {\n@@ -1981,7 +1981,7 @@ fn lit_to_str(l: @ast::lit) -> ~str {\n     return to_str(l, print_literal, parse::token::mk_fake_ident_interner());\n }\n \n-fn next_lit(s: ps, pos: uint) -> Option<comments::lit> {\n+fn next_lit(s: ps, pos: CharPos) -> Option<comments::lit> {\n     match s.literals {\n       Some(lits) => {\n         while s.cur_lit < vec::len(lits) {\n@@ -1996,7 +1996,7 @@ fn next_lit(s: ps, pos: uint) -> Option<comments::lit> {\n     }\n }\n \n-fn maybe_print_comment(s: ps, pos: uint) {\n+fn maybe_print_comment(s: ps, pos: CharPos) {\n     loop {\n         match next_comment(s) {\n           Some(cmnt) => {"}]}