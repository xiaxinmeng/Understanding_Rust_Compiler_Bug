{"sha": "36c49d703a429ff2d324453b11a2f243491fb444", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2YzQ5ZDcwM2E0MjlmZjJkMzI0NDUzYjExYTJmMjQzNDkxZmI0NDQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-05-01T22:28:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-05-01T22:28:46Z"}, "message": "Merge pull request #2666 from topecongiro/issue-2634\n\nAvoid flip-flopping impl items when reordering them", "tree": {"sha": "15e7b86eb93d5bc53dcf3528d2c9588590c82afc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15e7b86eb93d5bc53dcf3528d2c9588590c82afc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36c49d703a429ff2d324453b11a2f243491fb444", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJa6OoeCRBK7hj4Ov3rIwAAdHIIAK6LaU1NmESMb9y20PWrYqpB\nYmEV8qjKVPTZkdcdThEdn4CpXuh0+rqTEPcyLFqGpurFDk2du89w6tRU993Ny6Ju\nBd3JMqrcB82ZM6mcc+0/WlyEwlV43IbuJ+MAmSKfpnlXgeLlE8VfFJQ7a9/Rb5Qt\nNJU4rh/98OscOa70nPiD+epQHBoDT4xL1qbd4Vb7oN0MAUHfYskBrvPfEQ/SJq7m\nCDINHnvgCIvcKH7Jwa62F3r2XlQ6YLH0cGtkvjUaz4gA74obIqntN5kn5boeycAu\nQ/erbKnU+n/mbSVi6L1oSQNZUit6sc9DPBlxYDduFPYwJThkCEipcMeCoLptfSk=\n=iGcg\n-----END PGP SIGNATURE-----\n", "payload": "tree 15e7b86eb93d5bc53dcf3528d2c9588590c82afc\nparent c3bdd3aa90c1ce27175501b52c4248294a8f2a15\nparent 43df7dcb0e9aaf33ec041a079f3e9117b7f592cb\nauthor Nick Cameron <nrc@ncameron.org> 1525213726 +1200\ncommitter GitHub <noreply@github.com> 1525213726 +1200\n\nMerge pull request #2666 from topecongiro/issue-2634\n\nAvoid flip-flopping impl items when reordering them"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36c49d703a429ff2d324453b11a2f243491fb444", "html_url": "https://github.com/rust-lang/rust/commit/36c49d703a429ff2d324453b11a2f243491fb444", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36c49d703a429ff2d324453b11a2f243491fb444/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3bdd3aa90c1ce27175501b52c4248294a8f2a15", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3bdd3aa90c1ce27175501b52c4248294a8f2a15", "html_url": "https://github.com/rust-lang/rust/commit/c3bdd3aa90c1ce27175501b52c4248294a8f2a15"}, {"sha": "43df7dcb0e9aaf33ec041a079f3e9117b7f592cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/43df7dcb0e9aaf33ec041a079f3e9117b7f592cb", "html_url": "https://github.com/rust-lang/rust/commit/43df7dcb0e9aaf33ec041a079f3e9117b7f592cb"}], "stats": {"total": 131, "additions": 86, "deletions": 45}, "files": [{"sha": "4a0abc2b099ed8e3372af3acf7bc51d23dbf66ab", "filename": "src/comment.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36c49d703a429ff2d324453b11a2f243491fb444/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c49d703a429ff2d324453b11a2f243491fb444/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=36c49d703a429ff2d324453b11a2f243491fb444", "patch": "@@ -1139,6 +1139,7 @@ impl<'a> CommentReducer<'a> {\n \n impl<'a> Iterator for CommentReducer<'a> {\n     type Item = char;\n+\n     fn next(&mut self) -> Option<Self::Item> {\n         loop {\n             let mut c = self.iter.next()?;"}, {"sha": "7bd3a51a9b49ad85162456698ca31395c6e574b5", "filename": "src/config/options.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36c49d703a429ff2d324453b11a2f243491fb444/src%2Fconfig%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c49d703a429ff2d324453b11a2f243491fb444/src%2Fconfig%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Foptions.rs?ref=36c49d703a429ff2d324453b11a2f243491fb444", "patch": "@@ -239,6 +239,7 @@ impl WidthHeuristics {\n             single_line_if_else_max_width: 0,\n         }\n     }\n+\n     // scale the default WidthHeuristics according to max_width\n     pub fn scaled(max_width: usize) -> WidthHeuristics {\n         let mut max_width_ratio: f32 = max_width as f32 / 100.0; // 100 is the default width -> default ratio is 1"}, {"sha": "669cf795bc74a566cf4fff3e82b8eefc0015dfc1", "filename": "src/imports.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/36c49d703a429ff2d324453b11a2f243491fb444/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c49d703a429ff2d324453b11a2f243491fb444/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=36c49d703a429ff2d324453b11a2f243491fb444", "patch": "@@ -799,9 +799,11 @@ mod test {\n             fn bump(&mut self) {\n                 self.input.next().unwrap();\n             }\n+\n             fn eat(&mut self, c: char) {\n                 assert!(self.input.next().unwrap() == c);\n             }\n+\n             fn push_segment(\n                 result: &mut Vec<UseSegment>,\n                 buf: &mut String,\n@@ -825,6 +827,7 @@ mod test {\n                     }\n                 }\n             }\n+\n             fn parse_in_list(&mut self) -> UseTree {\n                 let mut result = vec![];\n                 let mut buf = String::new();"}, {"sha": "08bdfe0295f729d6dc1419e937292d58dd9a4037", "filename": "src/items.rs", "status": "modified", "additions": 50, "deletions": 45, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/36c49d703a429ff2d324453b11a2f243491fb444/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c49d703a429ff2d324453b11a2f243491fb444/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=36c49d703a429ff2d324453b11a2f243491fb444", "patch": "@@ -578,6 +578,55 @@ impl<'a> FmtVisitor<'a> {\n \n         combine_strs_with_missing_comments(&context, &attrs_str, &variant_body, span, shape, false)\n     }\n+\n+    fn visit_impl_items(&mut self, items: &[ast::ImplItem]) {\n+        if self.get_context().config.reorder_impl_items() {\n+            // Create visitor for each items, then reorder them.\n+            let mut buffer = vec![];\n+            for item in items {\n+                self.visit_impl_item(item);\n+                buffer.push((self.buffer.clone(), item.clone()));\n+                self.buffer.clear();\n+            }\n+            // type -> const -> macro -> method\n+            use ast::ImplItemKind::*;\n+            fn need_empty_line(a: &ast::ImplItemKind, b: &ast::ImplItemKind) -> bool {\n+                match (a, b) {\n+                    (Type(..), Type(..)) | (Const(..), Const(..)) => false,\n+                    _ => true,\n+                }\n+            }\n+\n+            buffer.sort_by(|(_, a), (_, b)| match (&a.node, &b.node) {\n+                (Type(..), _) => Ordering::Less,\n+                (_, Type(..)) => Ordering::Greater,\n+                (Const(..), _) => Ordering::Less,\n+                (_, Const(..)) => Ordering::Greater,\n+                (Macro(..), _) => Ordering::Less,\n+                (_, Macro(..)) => Ordering::Greater,\n+                _ => a.span.lo().cmp(&b.span.lo()),\n+            });\n+            let mut prev_kind = None;\n+            for (buf, item) in buffer {\n+                // Make sure that there are at least a single empty line between\n+                // different impl items.\n+                if prev_kind\n+                    .as_ref()\n+                    .map_or(false, |prev_kind| need_empty_line(prev_kind, &item.node))\n+                {\n+                    self.push_str(\"\\n\");\n+                }\n+                let indent_str = self.block_indent.to_string_with_newline(self.config);\n+                self.push_str(&indent_str);\n+                self.push_str(buf.trim());\n+                prev_kind = Some(item.node.clone());\n+            }\n+        } else {\n+            for item in items {\n+                self.visit_impl_item(item);\n+            }\n+        }\n+    }\n }\n \n pub fn format_impl(\n@@ -672,51 +721,7 @@ pub fn format_impl(\n             visitor.last_pos = item.span.lo() + BytePos(open_pos as u32);\n \n             visitor.visit_attrs(&item.attrs, ast::AttrStyle::Inner);\n-            if context.config.reorder_impl_items() {\n-                // Create visitor for each items, then reorder them.\n-                let mut buffer = vec![];\n-                for item in items {\n-                    visitor.visit_impl_item(item);\n-                    buffer.push((visitor.buffer.clone(), item.clone()));\n-                    visitor.buffer.clear();\n-                }\n-                // type -> const -> macro -> method\n-                use ast::ImplItemKind::*;\n-                fn need_empty_line(a: &ast::ImplItemKind, b: &ast::ImplItemKind) -> bool {\n-                    match (a, b) {\n-                        (Type(..), Type(..)) | (Const(..), Const(..)) => false,\n-                        _ => true,\n-                    }\n-                }\n-\n-                buffer.sort_by(|(_, a), (_, b)| match (&a.node, &b.node) {\n-                    (Type(..), _) => Ordering::Less,\n-                    (_, Type(..)) => Ordering::Greater,\n-                    (Const(..), _) => Ordering::Less,\n-                    (_, Const(..)) => Ordering::Greater,\n-                    (Macro(..), _) => Ordering::Less,\n-                    (_, Macro(..)) => Ordering::Greater,\n-                    _ => Ordering::Less,\n-                });\n-                let mut prev_kind = None;\n-                for (buf, item) in buffer {\n-                    // Make sure that there are at least a single empty line between\n-                    // different impl items.\n-                    if prev_kind\n-                        .as_ref()\n-                        .map_or(false, |prev_kind| need_empty_line(prev_kind, &item.node))\n-                    {\n-                        visitor.push_str(\"\\n\");\n-                    }\n-                    visitor.push_str(&item_indent.to_string_with_newline(context.config));\n-                    visitor.push_str(buf.trim());\n-                    prev_kind = Some(item.node.clone());\n-                }\n-            } else {\n-                for item in items {\n-                    visitor.visit_impl_item(item);\n-                }\n-            }\n+            visitor.visit_impl_items(items);\n \n             visitor.format_missing(item.span.hi() - BytePos(1));\n "}, {"sha": "4a02bf73e1a7353d8904eab25f23b7c96c7c1f39", "filename": "src/test/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36c49d703a429ff2d324453b11a2f243491fb444/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c49d703a429ff2d324453b11a2f243491fb444/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=36c49d703a429ff2d324453b11a2f243491fb444", "patch": "@@ -568,6 +568,7 @@ struct CharsIgnoreNewlineRepr<'a>(Peekable<Chars<'a>>);\n \n impl<'a> Iterator for CharsIgnoreNewlineRepr<'a> {\n     type Item = char;\n+\n     fn next(&mut self) -> Option<char> {\n         self.0.next().map(|c| {\n             if c == '\\r' {"}, {"sha": "ab008b89d22aceecc9d2cc2c823e90aa5b7449ec", "filename": "tests/source/reorder-impl-items.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36c49d703a429ff2d324453b11a2f243491fb444/tests%2Fsource%2Freorder-impl-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c49d703a429ff2d324453b11a2f243491fb444/tests%2Fsource%2Freorder-impl-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Freorder-impl-items.rs?ref=36c49d703a429ff2d324453b11a2f243491fb444", "patch": "@@ -0,0 +1,15 @@\n+// rustfmt-reorder_impl_items: true\n+\n+// The ordering of the folllowing impl items should be idempotent.\n+impl<'a> Command<'a> {\n+    pub fn send_to(&self, w: &mut io::Write) -> io::Result<()> {\n+        match self {\n+            &Command::Data(ref c) => c.send_to(w),\n+            &Command::Vrfy(ref c) => c.send_to(w),\n+        }\n+    }\n+\n+    pub fn parse(arg: &[u8]) -> Result<Command, ParseError> {\n+        nom_to_result(command(arg))\n+    }\n+}"}, {"sha": "ab008b89d22aceecc9d2cc2c823e90aa5b7449ec", "filename": "tests/target/reorder-impl-items.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36c49d703a429ff2d324453b11a2f243491fb444/tests%2Ftarget%2Freorder-impl-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c49d703a429ff2d324453b11a2f243491fb444/tests%2Ftarget%2Freorder-impl-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Freorder-impl-items.rs?ref=36c49d703a429ff2d324453b11a2f243491fb444", "patch": "@@ -0,0 +1,15 @@\n+// rustfmt-reorder_impl_items: true\n+\n+// The ordering of the folllowing impl items should be idempotent.\n+impl<'a> Command<'a> {\n+    pub fn send_to(&self, w: &mut io::Write) -> io::Result<()> {\n+        match self {\n+            &Command::Data(ref c) => c.send_to(w),\n+            &Command::Vrfy(ref c) => c.send_to(w),\n+        }\n+    }\n+\n+    pub fn parse(arg: &[u8]) -> Result<Command, ParseError> {\n+        nom_to_result(command(arg))\n+    }\n+}"}]}