{"sha": "9475277c235d2297dc446155325b0b3fcfdbf722", "node_id": "C_kwDOAAsO6NoAKDk0NzUyNzdjMjM1ZDIyOTdkYzQ0NjE1NTMyNWIwYjNmY2ZkYmY3MjI", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-01-13T10:46:54Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-01-13T10:46:54Z"}, "message": "Merge from rustc", "tree": {"sha": "bf243b402462c46038a1692d4ab52a7148b75d52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf243b402462c46038a1692d4ab52a7148b75d52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9475277c235d2297dc446155325b0b3fcfdbf722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9475277c235d2297dc446155325b0b3fcfdbf722", "html_url": "https://github.com/rust-lang/rust/commit/9475277c235d2297dc446155325b0b3fcfdbf722", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9475277c235d2297dc446155325b0b3fcfdbf722/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9742679ebed966c62bf457df8353b9a5c6c22d29", "url": "https://api.github.com/repos/rust-lang/rust/commits/9742679ebed966c62bf457df8353b9a5c6c22d29", "html_url": "https://github.com/rust-lang/rust/commit/9742679ebed966c62bf457df8353b9a5c6c22d29"}, {"sha": "7d59c0ccaa3aeb528a66ae3d2fec6a5ebbe44bc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d59c0ccaa3aeb528a66ae3d2fec6a5ebbe44bc2", "html_url": "https://github.com/rust-lang/rust/commit/7d59c0ccaa3aeb528a66ae3d2fec6a5ebbe44bc2"}], "stats": {"total": 42361, "additions": 28915, "deletions": 13446}, "files": [{"sha": "71adf9b009110cd6687199e289b482e0bc8a6593", "filename": ".git-blame-ignore-revs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/.git-blame-ignore-revs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/.git-blame-ignore-revs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.git-blame-ignore-revs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -6,3 +6,5 @@ a06baa56b95674fc626b3c3fd680d6a65357fe60\n 971c549ca334b7b7406e61e958efcca9c4152822\n # refactor infcx building\n 283abbf0e7d20176f76006825b5c52e9a4234e4c\n+# format libstd/sys\n+c34fbfaad38cf5829ef5cfe780dc9d58480adeaa"}, {"sha": "82048f800d0e889e3318e59f48043e6e515f529f", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -342,7 +342,7 @@ jobs:\n             os: macos-12-xl\n           - name: x86_64-apple-1\n             env:\n-              SCRIPT: \"./x.py --stage 2 test --exclude src/test/ui --exclude src/test/rustdoc --exclude src/test/run-make-fulldeps\"\n+              SCRIPT: \"./x.py --stage 2 test --exclude tests/ui --exclude tests/rustdoc --exclude tests/run-make-fulldeps\"\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.8\n@@ -353,7 +353,7 @@ jobs:\n             os: macos-12-xl\n           - name: x86_64-apple-2\n             env:\n-              SCRIPT: \"./x.py --stage 2 test src/test/ui src/test/rustdoc src/test/run-make-fulldeps\"\n+              SCRIPT: \"./x.py --stage 2 test tests/ui tests/rustdoc tests/run-make-fulldeps\"\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.8"}, {"sha": "e5ca3e503130f63c8fb35475b0658dd4316a31b5", "filename": ".gitignore", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -26,7 +26,7 @@ Session.vim\n .valgrindrc\n .cargo\n # Included because it is part of the test case\n-!/src/test/run-make/thumb-none-qemu/example/.cargo\n+!/tests/run-make/thumb-none-qemu/example/.cargo\n \n ## Configuration\n /config.toml\n@@ -74,6 +74,6 @@ package-lock.json\n package.json\n \n ## Rustdoc GUI tests\n-src/test/rustdoc-gui/src/**.lock\n+tests/rustdoc-gui/src/**.lock\n \n # Before adding new lines, see the comment at the top."}, {"sha": "4bea3af7f3bfa111809d367b6a651d37d2e51910", "filename": "Cargo.lock", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -203,6 +203,12 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"349a06037c7bf932dd7e7d1f653678b2038b9ad46a74102f1fc7bd7872678cce\"\n \n+[[package]]\n+name = \"base64\"\n+version = \"0.13.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8\"\n+\n [[package]]\n name = \"base64ct\"\n version = \"1.5.3\"\n@@ -328,6 +334,7 @@ name = \"cargo\"\n version = \"0.69.0\"\n dependencies = [\n  \"anyhow\",\n+ \"base64\",\n  \"bytesize\",\n  \"cargo-platform 0.1.2\",\n  \"cargo-test-macro\",\n@@ -345,6 +352,7 @@ dependencies = [\n  \"git2-curl\",\n  \"glob\",\n  \"hex 0.4.2\",\n+ \"hmac\",\n  \"home\",\n  \"http-auth\",\n  \"humantime 2.0.1\",\n@@ -375,6 +383,7 @@ dependencies = [\n  \"serde-value\",\n  \"serde_ignored\",\n  \"serde_json\",\n+ \"sha1\",\n  \"shell-escape\",\n  \"snapbox\",\n  \"strip-ansi-escapes\",\n@@ -1778,9 +1787,9 @@ dependencies = [\n \n [[package]]\n name = \"git2\"\n-version = \"0.15.0\"\n+version = \"0.16.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2994bee4a3a6a51eb90c218523be382fd7ea09b16380b9312e9dbe955ff7c7d1\"\n+checksum = \"be36bc9e0546df253c0cc41fd0af34f5e92845ad8509462ec76672fac6997f5b\"\n dependencies = [\n  \"bitflags\",\n  \"libc\",\n@@ -1793,9 +1802,9 @@ dependencies = [\n \n [[package]]\n name = \"git2-curl\"\n-version = \"0.16.0\"\n+version = \"0.17.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ed817a00721e2f8037ba722e60358d4956dae9cca10315fc982f967907d3b0cd\"\n+checksum = \"7577f4e6341ba7c90d883511130a45b956c274ba5f4d205d9f9da990f654cd33\"\n dependencies = [\n  \"curl\",\n  \"git2\",\n@@ -2335,9 +2344,9 @@ dependencies = [\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.14.0+1.5.0\"\n+version = \"0.14.1+1.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"47a00859c70c8a4f7218e6d1cc32875c4b55f6799445b842b0d8ed5e4c3d959b\"\n+checksum = \"4a07fb2692bc3593bda59de45a502bb3071659f2c515e28c71e728306b038e17\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -5025,18 +5034,18 @@ checksum = \"1ef965a420fe14fdac7dd018862966a4c14094f900e1650bbc71ddd7d580c8af\"\n \n [[package]]\n name = \"semver\"\n-version = \"1.0.14\"\n+version = \"1.0.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e25dfac463d778e353db5be2449d1cce89bd6fd23c9f1ea21310ce6e5a1b29c4\"\n+checksum = \"a2333e6df6d6598f2b1974829f853c2b4c5f4a6e503c10af918081aa6f8564e1\"\n dependencies = [\n  \"serde\",\n ]\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.152\"\n+version = \"1.0.147\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bb7d1f0d3021d347a83e556fc4683dea2ea09d87bccdf88ff5c12545d89d5efb\"\n+checksum = \"d193d69bae983fc11a79df82342761dfbf28a99fc8d203dca4c3c1b590948965\"\n dependencies = [\n  \"serde_derive\",\n ]\n@@ -5053,9 +5062,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.152\"\n+version = \"1.0.147\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"af487d118eecd09402d70a5d72551860e788df87b464af30e5ea6a38c75c541e\"\n+checksum = \"4f1d362ca8fc9c3e3a7484440752472d68a6caa98f1ab81d99b5dfe517cec852\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -5073,9 +5082,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.91\"\n+version = \"1.0.85\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"877c235533714907a8c2464236f5c4b2a17262ef1bd71f38f35ea592c8da6883\"\n+checksum = \"e55a28e3aaef9d5ce0506d0a14dbba8054ddc7e499ef522dd8b26859ec9d4a44\"\n dependencies = [\n  \"indexmap\",\n  \"itoa\",\n@@ -5094,6 +5103,17 @@ dependencies = [\n  \"digest\",\n ]\n \n+[[package]]\n+name = \"sha1\"\n+version = \"0.10.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f04293dc80c3993519f2d7f6f511707ee7094fe0c6d3406feb330cdb3540eba3\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"cpufeatures\",\n+ \"digest\",\n+]\n+\n [[package]]\n name = \"sha2\"\n version = \"0.10.6\"\n@@ -5380,9 +5400,9 @@ checksum = \"6bdef32e8150c2a081110b42772ffe7d7c9032b606bc226c8260fd97e0976601\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.107\"\n+version = \"1.0.102\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1f4064b5b16e03ae50984a5a8ed5d4f8803e6bc1fd170a3cda91a1be4b18e3f5\"\n+checksum = \"3fcd952facd492f9be3ef0d0b7032a6e442ee9b361d4acc2b1d0c4aaa5f613a1\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -5556,7 +5576,6 @@ dependencies = [\n  \"lazy_static\",\n  \"miropt-test-tools\",\n  \"regex\",\n- \"semver\",\n  \"termcolor\",\n  \"walkdir\",\n ]"}, {"sha": "15cbb2659c9b335ea3f1bb9b77af86f3b74bd8fc", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -51,7 +51,7 @@ exclude = [\n   \"compiler/rustc_codegen_cranelift\",\n   \"compiler/rustc_codegen_gcc\",\n   \"src/bootstrap\",\n-  \"src/test/rustdoc-gui\",\n+  \"tests/rustdoc-gui\",\n   # HACK(eddyb) This hardcodes the fact that our CI uses `/checkout/obj`.\n   \"obj\",\n   # The `x` binary is a thin wrapper that calls `x.py`, which initializes"}, {"sha": "2901bfcc3e3e9f3612e6ebd48375bd8ca4707744", "filename": "RELEASES.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,3 +1,8 @@\n+Version 1.66.1 (2023-01-10)\n+===========================\n+\n+- Added validation of SSH host keys for git URLs in Cargo ([CVE-2022-46176](https://www.cve.org/CVERecord?id=CVE-2022-46176))\n+\n Version 1.66.0 (2022-12-15)\n ==========================\n "}, {"sha": "accdb6da782d8b5fc35f354676fd714849473385", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1263,8 +1263,8 @@ pub enum Variants<V: Idx> {\n \n     /// Enum-likes with more than one inhabited variant: each variant comes with\n     /// a *discriminant* (usually the same as the variant index but the user can\n-    /// assign explicit discriminant values).  That discriminant is encoded\n-    /// as a *tag* on the machine.  The layout of each variant is\n+    /// assign explicit discriminant values). That discriminant is encoded\n+    /// as a *tag* on the machine. The layout of each variant is\n     /// a struct, and they all have space reserved for the tag.\n     /// For enums, the tag is the sole field of the layout.\n     Multiple {"}, {"sha": "7de594719ddc44568872ea3ee2516da728a96ada", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1307,6 +1307,7 @@ impl Expr {\n pub struct Closure {\n     pub binder: ClosureBinder,\n     pub capture_clause: CaptureBy,\n+    pub constness: Const,\n     pub asyncness: Async,\n     pub movability: Movability,\n     pub fn_decl: P<FnDecl>,"}, {"sha": "77f342d1eb322efe2a35deb211006e6408a243b5", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1362,6 +1362,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n         ExprKind::Closure(box Closure {\n             binder,\n             capture_clause: _,\n+            constness,\n             asyncness,\n             movability: _,\n             fn_decl,\n@@ -1370,6 +1371,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             fn_arg_span: _,\n         }) => {\n             vis.visit_closure_binder(binder);\n+            visit_constness(constness, vis);\n             vis.visit_asyncness(asyncness);\n             vis.visit_fn_decl(fn_decl);\n             vis.visit_expr(body);"}, {"sha": "4f7099c7be8a6561492a22b210643768b9db4a2a", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -304,7 +304,7 @@ impl ExprPrecedence {\n             | ExprPrecedence::Yeet => PREC_JUMP,\n \n             // `Range` claims to have higher precedence than `Assign`, but `x .. x = x` fails to\n-            // parse, instead of parsing as `(x .. x) = x`.  Giving `Range` a lower precedence\n+            // parse, instead of parsing as `(x .. x) = x`. Giving `Range` a lower precedence\n             // ensures that `pprust` will add parentheses in the right places to get the desired\n             // parse.\n             ExprPrecedence::Range => PREC_RANGE,"}, {"sha": "e8823eff83afe1bab63061dd862a7ed40af53575", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -836,6 +836,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             binder,\n             capture_clause: _,\n             asyncness: _,\n+            constness: _,\n             movability: _,\n             fn_decl,\n             body,"}, {"sha": "c3611b2f522babd789e589285b1e6359e1f11b18", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -209,6 +209,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::Closure(box Closure {\n                     binder,\n                     capture_clause,\n+                    constness,\n                     asyncness,\n                     movability,\n                     fn_decl,\n@@ -233,6 +234,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             binder,\n                             *capture_clause,\n                             e.id,\n+                            *constness,\n                             *movability,\n                             fn_decl,\n                             body,\n@@ -651,6 +653,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 fn_decl_span: self.lower_span(span),\n                 fn_arg_span: None,\n                 movability: Some(hir::Movability::Static),\n+                constness: hir::Constness::NotConst,\n             });\n \n             hir::ExprKind::Closure(c)\n@@ -689,8 +692,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // call (like the identity function), as otherwise type and lifetime\n         // inference have a hard time figuring things out.\n         // Without this, we would get:\n-        // E0720 in src/test/ui/impl-trait/in-trait/default-body-with-rpit.rs\n-        // E0700 in src/test/ui/self/self_lifetime-async.rs\n+        // E0720 in tests/ui/impl-trait/in-trait/default-body-with-rpit.rs\n+        // E0700 in tests/ui/self/self_lifetime-async.rs\n \n         // `future::identity_future`:\n         let identity_future =\n@@ -890,6 +893,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         binder: &ClosureBinder,\n         capture_clause: CaptureBy,\n         closure_id: NodeId,\n+        constness: Const,\n         movability: Movability,\n         decl: &FnDecl,\n         body: &Expr,\n@@ -927,6 +931,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             fn_decl_span: self.lower_span(fn_decl_span),\n             fn_arg_span: Some(self.lower_span(fn_arg_span)),\n             movability: generator_option,\n+            constness: self.lower_constness(constness),\n         });\n \n         hir::ExprKind::Closure(c)\n@@ -1041,6 +1046,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             fn_decl_span: self.lower_span(fn_decl_span),\n             fn_arg_span: Some(self.lower_span(fn_arg_span)),\n             movability: None,\n+            constness: hir::Constness::NotConst,\n         });\n         hir::ExprKind::Closure(c)\n     }"}, {"sha": "63033085bec674de5bbc4159cf980c8f5a5ed289", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -38,7 +38,7 @@ pub(super) fn index_hir<'hir>(\n ) -> (IndexVec<ItemLocalId, Option<ParentedNode<'hir>>>, FxHashMap<LocalDefId, ItemLocalId>) {\n     let mut nodes = IndexVec::new();\n     // This node's parent should never be accessed: the owner's parent is computed by the\n-    // hir_owner_parent query.  Make it invalid (= ItemLocalId::MAX) to force an ICE whenever it is\n+    // hir_owner_parent query. Make it invalid (= ItemLocalId::MAX) to force an ICE whenever it is\n     // used.\n     nodes.push(Some(ParentedNode { parent: ItemLocalId::INVALID, node: item.into() }));\n     let mut collector = NodeCollector {"}, {"sha": "5d2589cb2b2f7817a8603a1319eed39a727fd597", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -523,7 +523,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 //\n                 // The first two are produced by recursively invoking\n                 // `lower_use_tree` (and indeed there may be things\n-                // like `use foo::{a::{b, c}}` and so forth).  They\n+                // like `use foo::{a::{b, c}}` and so forth). They\n                 // wind up being directly added to\n                 // `self.items`. However, the structure of this\n                 // function also requires us to return one item, and\n@@ -1239,7 +1239,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn lower_constness(&mut self, c: Const) -> hir::Constness {\n+    pub(super) fn lower_constness(&mut self, c: Const) -> hir::Constness {\n         match c {\n             Const::Yes(_) => hir::Constness::Const,\n             Const::No => hir::Constness::NotConst,"}, {"sha": "1f3473dcf2290d8e44548670ac1b68dfaec94e4d", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -663,7 +663,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.arena.alloc(hir::OwnerInfo { nodes, parenting, attrs, trait_map })\n     }\n \n-    /// Hash the HIR node twice, one deep and one shallow hash.  This allows to differentiate\n+    /// Hash the HIR node twice, one deep and one shallow hash. This allows to differentiate\n     /// queries which depend on the full HIR tree and those which only depend on the item signature.\n     fn hash_owner(\n         &mut self,\n@@ -1194,7 +1194,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         itctx: &ImplTraitContext,\n     ) -> hir::Ty<'hir> {\n         // Check whether we should interpret this as a bare trait object.\n-        // This check mirrors the one in late resolution.  We only introduce this special case in\n+        // This check mirrors the one in late resolution. We only introduce this special case in\n         // the rare occurrence we need to lower `Fresh` anonymous lifetimes.\n         // The other cases when a qpath should be opportunistically made a trait object are handled\n         // by `ty_path`.\n@@ -1919,7 +1919,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             this.with_remapping(new_remapping, |this| {\n                 // We have to be careful to get elision right here. The\n                 // idea is that we create a lifetime parameter for each\n-                // lifetime in the return type.  So, given a return type\n+                // lifetime in the return type. So, given a return type\n                 // like `async fn foo(..) -> &[&u32]`, we lower to `impl\n                 // Future<Output = &'1 [ &'2 u32 ]>`.\n                 //\n@@ -2013,7 +2013,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         // Create the `Foo<...>` reference itself. Note that the `type\n         // Foo = impl Trait` is, internally, created as a child of the\n-        // async fn, so the *type parameters* are inherited.  It's\n+        // async fn, so the *type parameters* are inherited. It's\n         // only the lifetime parameters that we must supply.\n         let opaque_ty_ref = hir::TyKind::OpaqueDef(\n             hir::ItemId { owner_id: hir::OwnerId { def_id: opaque_ty_def_id } },"}, {"sha": "89ba6f936d14448b32d201026259d1e999fec6b7", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -385,6 +385,14 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ExprKind::TryBlock(_) => {\n                 gate_feature_post!(&self, try_blocks, e.span, \"`try` expression is experimental\");\n             }\n+            ast::ExprKind::Closure(box ast::Closure { constness: ast::Const::Yes(_), .. }) => {\n+                gate_feature_post!(\n+                    &self,\n+                    const_closures,\n+                    e.span,\n+                    \"const closures are experimental\"\n+                );\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e)"}, {"sha": "2a18e5164a309bbb360ccae43d46565b4e83f9ff", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -399,6 +399,7 @@ impl<'a> State<'a> {\n             ast::ExprKind::Closure(box ast::Closure {\n                 binder,\n                 capture_clause,\n+                constness,\n                 asyncness,\n                 movability,\n                 fn_decl,\n@@ -407,6 +408,7 @@ impl<'a> State<'a> {\n                 fn_arg_span: _,\n             }) => {\n                 self.print_closure_binder(binder);\n+                self.print_constness(*constness);\n                 self.print_movability(*movability);\n                 self.print_asyncness(*asyncness);\n                 self.print_capture_clause(*capture_clause);\n@@ -471,10 +473,10 @@ impl<'a> State<'a> {\n                 self.word(\"]\");\n             }\n             ast::ExprKind::Range(start, end, limits) => {\n-                // Special case for `Range`.  `AssocOp` claims that `Range` has higher precedence\n+                // Special case for `Range`. `AssocOp` claims that `Range` has higher precedence\n                 // than `Assign`, but `x .. x = x` gives a parse error instead of `x .. (x = x)`.\n                 // Here we use a fake precedence value so that any child with lower precedence than\n-                // a \"normal\" binop gets parenthesized.  (`LOr` is the lowest-precedence binop.)\n+                // a \"normal\" binop gets parenthesized. (`LOr` is the lowest-precedence binop.)\n                 let fake_prec = AssocOp::LOr.precedence() as i8;\n                 if let Some(e) = start {\n                     self.print_expr_maybe_paren(e, fake_prec);"}, {"sha": "055b281bc2e70fb587aa5a48b2b09b8f4e70080f", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -25,7 +25,7 @@ pub use super::{\n ///     can, for example, happen when requesting a body of a `const` function\n ///     because they are evaluated during typechecking. The panic can be avoided\n ///     by overriding the `mir_borrowck` query. You can find a complete example\n-///     that shows how to do this at `src/test/run-make/obtain-borrowck/`.\n+///     that shows how to do this at `tests/run-make/obtain-borrowck/`.\n ///\n /// *   Polonius is highly unstable, so expect regular changes in its signature or other details.\n pub fn get_body_with_borrowck_facts("}, {"sha": "6658ee89ad6f1bd0c86c011afc14e83be2413d0b", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -156,7 +156,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 err.span_note(\n                     MultiSpan::from_spans(reinit_spans),\n                     &if reinits <= 3 {\n-                        format!(\"these {} reinitializations might get skipped\", reinits)\n+                        format!(\"these {reinits} reinitializations might get skipped\")\n                     } else {\n                         format!(\n                             \"these 3 reinitializations and {} other{} might get skipped\",\n@@ -225,9 +225,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 err.span_label(\n                     span,\n                     format!(\n-                        \"value {} here after {}move\",\n+                        \"value {} here after {partial_str}move\",\n                         desired_action.as_verb_in_past_tense(),\n-                        partial_str\n                     ),\n                 );\n             }\n@@ -257,7 +256,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         &format!(\n                             \"consider creating a fresh reborrow of {} here\",\n                             self.describe_place(moved_place)\n-                                .map(|n| format!(\"`{}`\", n))\n+                                .map(|n| format!(\"`{n}`\"))\n                                 .unwrap_or_else(|| \"the mutable reference\".to_string()),\n                         ),\n                         \"&mut *\",\n@@ -271,7 +270,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 DescribePlaceOpt { including_downcast: true, including_tuple_field: true },\n             );\n             let note_msg = match opt_name {\n-                Some(name) => format!(\"`{}`\", name),\n+                Some(name) => format!(\"`{name}`\"),\n                 None => \"value\".to_owned(),\n             };\n             if self.suggest_borrow_fn_like(&mut err, ty, &move_site_vec, &note_msg) {\n@@ -297,9 +296,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } = use_spans\n             {\n                 err.note(&format!(\n-                    \"{} occurs due to deref coercion to `{}`\",\n+                    \"{} occurs due to deref coercion to `{deref_target_ty}`\",\n                     desired_action.as_noun(),\n-                    deref_target_ty\n                 ));\n \n                 // Check first whether the source is accessible (issue #87060)\n@@ -1739,7 +1737,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 /// We check that there's a single level of block nesting to ensure always correct\n                 /// suggestions. If we don't, then we only provide a free-form message to avoid\n-                /// misleading users in cases like `src/test/ui/nll/borrowed-temporary-error.rs`.\n+                /// misleading users in cases like `tests/ui/nll/borrowed-temporary-error.rs`.\n                 /// We could expand the analysis to suggest hoising all of the relevant parts of\n                 /// the users' code to make the code compile, but that could be too much.\n                 struct NestedStatementVisitor {"}, {"sha": "2095747097b7660870ecdff8b32fc8820525652b", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -77,7 +77,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                     if borrow_span.map(|sp| !sp.overlaps(var_or_use_span)).unwrap_or(true) {\n                         err.span_label(\n                             var_or_use_span,\n-                            format!(\"{}borrow later {}\", borrow_desc, message),\n+                            format!(\"{borrow_desc}borrow later {message}\"),\n                         );\n                     }\n                 } else {\n@@ -90,7 +90,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                         let capture_kind_label = message;\n                         err.span_label(\n                             var_or_use_span,\n-                            format!(\"{}borrow later {}\", borrow_desc, capture_kind_label),\n+                            format!(\"{borrow_desc}borrow later {capture_kind_label}\"),\n                         );\n                         err.span_label(path_span, path_label);\n                     }\n@@ -110,7 +110,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                 };\n                 // We can use `var_or_use_span` if either `path_span` is not present, or both spans are the same\n                 if path_span.map(|path_span| path_span == var_or_use_span).unwrap_or(true) {\n-                    err.span_label(var_or_use_span, format!(\"{}{}\", borrow_desc, message));\n+                    err.span_label(var_or_use_span, format!(\"{borrow_desc}{message}\"));\n                 } else {\n                     // path_span must be `Some` as otherwise the if condition is true\n                     let path_span = path_span.unwrap();\n@@ -121,7 +121,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                         let capture_kind_label = message;\n                         err.span_label(\n                             var_or_use_span,\n-                            format!(\"{}borrow later {}\", borrow_desc, capture_kind_label),\n+                            format!(\"{borrow_desc}borrow later {capture_kind_label}\"),\n                         );\n                         err.span_label(path_span, path_label);\n                     }\n@@ -160,12 +160,8 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                 match local_names[dropped_local] {\n                     Some(local_name) if !local_decl.from_compiler_desugaring() => {\n                         let message = format!(\n-                            \"{B}borrow might be used here, when `{LOC}` is dropped \\\n-                             and runs the {DTOR} for {TYPE}\",\n-                            B = borrow_desc,\n-                            LOC = local_name,\n-                            TYPE = type_desc,\n-                            DTOR = dtor_desc\n+                            \"{borrow_desc}borrow might be used here, when `{local_name}` is dropped \\\n+                             and runs the {dtor_desc} for {type_desc}\",\n                         );\n                         err.span_label(body.source_info(drop_loc).span, message);\n \n@@ -180,18 +176,14 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                         err.span_label(\n                             local_decl.source_info.span,\n                             format!(\n-                                \"a temporary with access to the {B}borrow \\\n+                                \"a temporary with access to the {borrow_desc}borrow \\\n                                  is created here ...\",\n-                                B = borrow_desc\n                             ),\n                         );\n                         let message = format!(\n-                            \"... and the {B}borrow might be used here, \\\n+                            \"... and the {borrow_desc}borrow might be used here, \\\n                              when that temporary is dropped \\\n-                             and runs the {DTOR} for {TYPE}\",\n-                            B = borrow_desc,\n-                            TYPE = type_desc,\n-                            DTOR = dtor_desc\n+                             and runs the {dtor_desc} for {type_desc}\",\n                         );\n                         err.span_label(body.source_info(drop_loc).span, message);\n \n@@ -249,20 +241,16 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                     err.span_label(\n                         span,\n                         format!(\n-                            \"{}requires that `{}` is borrowed for `{}`\",\n+                            \"{}requires that `{desc}` is borrowed for `{region_name}`\",\n                             category.description(),\n-                            desc,\n-                            region_name,\n                         ),\n                     );\n                 } else {\n                     err.span_label(\n                         span,\n                         format!(\n-                            \"{}requires that {}borrow lasts for `{}`\",\n+                            \"{}requires that {borrow_desc}borrow lasts for `{region_name}`\",\n                             category.description(),\n-                            borrow_desc,\n-                            region_name,\n                         ),\n                     );\n                 };\n@@ -296,15 +284,14 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                 if region_name.was_named() { region_name.name } else { kw::UnderscoreLifetime };\n \n             let msg = format!(\n-                \"you can add a bound to the {}to make it last less than `'static` and match `{}`\",\n+                \"you can add a bound to the {}to make it last less than `'static` and match `{region_name}`\",\n                 category.description(),\n-                region_name,\n             );\n \n             err.span_suggestion_verbose(\n                 span.shrink_to_hi(),\n                 &msg,\n-                format!(\" + {}\", suggestable_name),\n+                format!(\" + {suggestable_name}\"),\n                 Applicability::Unspecified,\n             );\n         }"}, {"sha": "1b40b7143cbb6b671ba2faec06326c362a669de8", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -403,8 +403,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         move_prefix: &str,\n     ) {\n         let message = format!(\n-            \"{}move occurs because {} has type `{}`, which does not implement the `Copy` trait\",\n-            move_prefix, place_desc, ty,\n+            \"{move_prefix}move occurs because {place_desc} has type `{ty}`, which does not implement the `Copy` trait\",\n         );\n         if let Some(span) = span {\n             err.span_label(span, message);\n@@ -739,11 +738,11 @@ impl<'tcx> BorrowedContentSource<'tcx> {\n             BorrowedContentSource::OverloadedDeref(ty) => ty\n                 .ty_adt_def()\n                 .and_then(|adt| match tcx.get_diagnostic_name(adt.did())? {\n-                    name @ (sym::Rc | sym::Arc) => Some(format!(\"an `{}`\", name)),\n+                    name @ (sym::Rc | sym::Arc) => Some(format!(\"an `{name}`\")),\n                     _ => None,\n                 })\n-                .unwrap_or_else(|| format!(\"dereference of `{}`\", ty)),\n-            BorrowedContentSource::OverloadedIndex(ty) => format!(\"index of `{}`\", ty),\n+                .unwrap_or_else(|| format!(\"dereference of `{ty}`\")),\n+            BorrowedContentSource::OverloadedIndex(ty) => format!(\"index of `{ty}`\"),\n         }\n     }\n \n@@ -769,11 +768,11 @@ impl<'tcx> BorrowedContentSource<'tcx> {\n             BorrowedContentSource::OverloadedDeref(ty) => ty\n                 .ty_adt_def()\n                 .and_then(|adt| match tcx.get_diagnostic_name(adt.did())? {\n-                    name @ (sym::Rc | sym::Arc) => Some(format!(\"an `{}`\", name)),\n+                    name @ (sym::Rc | sym::Arc) => Some(format!(\"an `{name}`\")),\n                     _ => None,\n                 })\n-                .unwrap_or_else(|| format!(\"dereference of `{}`\", ty)),\n-            BorrowedContentSource::OverloadedIndex(ty) => format!(\"an index of `{}`\", ty),\n+                .unwrap_or_else(|| format!(\"dereference of `{ty}`\")),\n+            BorrowedContentSource::OverloadedIndex(ty) => format!(\"an index of `{ty}`\"),\n         }\n     }\n \n@@ -1033,7 +1032,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let UseSpans::FnSelfUse { var_span, fn_call_span, fn_span, kind } = move_spans {\n             let place_name = self\n                 .describe_place(moved_place.as_ref())\n-                .map(|n| format!(\"`{}`\", n))\n+                .map(|n| format!(\"`{n}`\"))\n                 .unwrap_or_else(|| \"value\".to_owned());\n             match kind {\n                 CallKind::FnCall { fn_trait_id, .. }\n@@ -1042,8 +1041,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     err.span_label(\n                         fn_call_span,\n                         &format!(\n-                            \"{} {}moved due to this call{}\",\n-                            place_name, partially_str, loop_message\n+                            \"{place_name} {partially_str}moved due to this call{loop_message}\",\n                         ),\n                     );\n                     err.span_note(\n@@ -1056,8 +1054,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     err.span_label(\n                         fn_call_span,\n                         &format!(\n-                            \"{} {}moved due to usage in operator{}\",\n-                            place_name, partially_str, loop_message\n+                            \"{place_name} {partially_str}moved due to usage in operator{loop_message}\",\n                         ),\n                     );\n                     if self.fn_self_span_reported.insert(fn_span) {\n@@ -1089,9 +1086,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             err.span_suggestion_verbose(\n                                 move_span.shrink_to_lo(),\n                                 &format!(\n-                                    \"consider iterating over a slice of the `{}`'s content to \\\n+                                    \"consider iterating over a slice of the `{ty}`'s content to \\\n                                      avoid moving into the `for` loop\",\n-                                    ty,\n                                 ),\n                                 \"&\",\n                                 Applicability::MaybeIncorrect,\n@@ -1101,8 +1097,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         err.span_label(\n                             fn_call_span,\n                             &format!(\n-                                \"{} {}moved due to this implicit call to `.into_iter()`{}\",\n-                                place_name, partially_str, loop_message\n+                                \"{place_name} {partially_str}moved due to this implicit call to `.into_iter()`{loop_message}\",\n                             ),\n                         );\n                         // If the moved place was a `&mut` ref, then we can\n@@ -1118,7 +1113,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     &format!(\n                                         \"consider creating a fresh reborrow of {} here\",\n                                         self.describe_place(moved_place.as_ref())\n-                                            .map(|n| format!(\"`{}`\", n))\n+                                            .map(|n| format!(\"`{n}`\"))\n                                             .unwrap_or_else(|| \"the mutable reference\".to_string()),\n                                     ),\n                                     \"&mut *\",\n@@ -1130,8 +1125,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         err.span_label(\n                             fn_call_span,\n                             &format!(\n-                                \"{} {}moved due to this method call{}\",\n-                                place_name, partially_str, loop_message\n+                                \"{place_name} {partially_str}moved due to this method call{loop_message}\",\n                             ),\n                         );\n                         let infcx = tcx.infer_ctxt().build();\n@@ -1206,15 +1200,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if move_span != span || !loop_message.is_empty() {\n                 err.span_label(\n                     move_span,\n-                    format!(\"value {}moved{} here{}\", partially_str, move_msg, loop_message),\n+                    format!(\"value {partially_str}moved{move_msg} here{loop_message}\"),\n                 );\n             }\n             // If the move error occurs due to a loop, don't show\n             // another message for the same span\n             if loop_message.is_empty() {\n                 move_spans.var_span_label(\n                     err,\n-                    format!(\"variable {}moved due to use{}\", partially_str, move_spans.describe()),\n+                    format!(\"variable {partially_str}moved due to use{}\", move_spans.describe()),\n                     \"moved\",\n                 );\n             }"}, {"sha": "b9cfc7e69610e5d83aed21b6198f245e122757a6", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -264,7 +264,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         ProjectionElem::Deref,\n                     ],\n             } => {\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_label(span, format!(\"cannot {act}\"));\n \n                 if let Some(span) = get_mut_span_in_struct_field(\n                     self.infcx.tcx,\n@@ -290,7 +290,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     .unwrap_or(false) =>\n             {\n                 let decl = &self.body.local_decls[local];\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_label(span, format!(\"cannot {act}\"));\n                 if let Some(mir::Statement {\n                     source_info,\n                     kind:\n@@ -639,7 +639,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             PlaceRef { local: _, projection: [.., ProjectionElem::Deref] } => {\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_label(span, format!(\"cannot {act}\"));\n \n                 match opt_source {\n                     Some(BorrowedContentSource::OverloadedDeref(ty)) => {\n@@ -1212,7 +1212,7 @@ fn suggest_ampmut<'tcx>(\n     {\n         let lt_name = &src[1..ws_pos];\n         let ty = &src[ws_pos..];\n-        return (true, highlight_span, format!(\"&{} mut{}\", lt_name, ty));\n+        return (true, highlight_span, format!(\"&{lt_name} mut{ty}\"));\n     }\n \n     let ty_mut = local_decl.ty.builtin_deref(true).unwrap();"}, {"sha": "1eaf0a2f15ce8ffe2468e25a387ec111cd2fe84a", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -209,14 +209,14 @@ impl OutlivesSuggestionBuilder {\n         let mut diag = if suggested.len() == 1 {\n             mbcx.infcx.tcx.sess.diagnostic().struct_help(&match suggested.last().unwrap() {\n                 SuggestedConstraint::Outlives(a, bs) => {\n-                    let bs: SmallVec<[String; 2]> = bs.iter().map(|r| format!(\"{}\", r)).collect();\n-                    format!(\"add bound `{}: {}`\", a, bs.join(\" + \"))\n+                    let bs: SmallVec<[String; 2]> = bs.iter().map(|r| r.to_string()).collect();\n+                    format!(\"add bound `{a}: {}`\", bs.join(\" + \"))\n                 }\n \n                 SuggestedConstraint::Equal(a, b) => {\n-                    format!(\"`{}` and `{}` must be the same: replace one with the other\", a, b)\n+                    format!(\"`{a}` and `{b}` must be the same: replace one with the other\")\n                 }\n-                SuggestedConstraint::Static(a) => format!(\"replace `{}` with `'static`\", a),\n+                SuggestedConstraint::Static(a) => format!(\"replace `{a}` with `'static`\"),\n             })\n         } else {\n             // Create a new diagnostic.\n@@ -231,18 +231,16 @@ impl OutlivesSuggestionBuilder {\n             for constraint in suggested {\n                 match constraint {\n                     SuggestedConstraint::Outlives(a, bs) => {\n-                        let bs: SmallVec<[String; 2]> =\n-                            bs.iter().map(|r| format!(\"{}\", r)).collect();\n-                        diag.help(&format!(\"add bound `{}: {}`\", a, bs.join(\" + \")));\n+                        let bs: SmallVec<[String; 2]> = bs.iter().map(|r| r.to_string()).collect();\n+                        diag.help(&format!(\"add bound `{a}: {}`\", bs.join(\" + \")));\n                     }\n                     SuggestedConstraint::Equal(a, b) => {\n                         diag.help(&format!(\n-                            \"`{}` and `{}` must be the same: replace one with the other\",\n-                            a, b\n+                            \"`{a}` and `{b}` must be the same: replace one with the other\",\n                         ));\n                     }\n                     SuggestedConstraint::Static(a) => {\n-                        diag.help(&format!(\"replace `{}` with `'static`\", a));\n+                        diag.help(&format!(\"replace `{a}` with `'static`\"));\n                     }\n                 }\n             }"}, {"sha": "e8a4d1c37c1877296151a84dd9e3cd5513716b2b", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -422,7 +422,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         );\n                         (desc, note)\n                     }\n-                    _ => panic!(\"Unexpected type {:?}\", ty),\n+                    _ => panic!(\"Unexpected type {ty:?}\"),\n                 };\n                 diag.note(&format!(\"requirement occurs because of {desc}\",));\n                 diag.note(&note);\n@@ -725,10 +725,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             let lifetime = if f.has_name() { fr_name.name } else { kw::UnderscoreLifetime };\n \n             let arg = match param.param.pat.simple_ident() {\n-                Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n+                Some(simple_ident) => format!(\"argument `{simple_ident}`\"),\n                 None => \"the argument\".to_string(),\n             };\n-            let captures = format!(\"captures data from {}\", arg);\n+            let captures = format!(\"captures data from {arg}\");\n \n             return nice_region_error::suggest_new_region_bound(\n                 self.infcx.tcx,"}, {"sha": "9233287cf3a75fde48da92820c9c4d52bed5e132", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -202,7 +202,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// This is _not_ idempotent. Call `give_region_a_name` when possible.\n     pub(crate) fn synthesize_region_name(&self) -> Symbol {\n         let c = self.next_region_name.replace_with(|counter| *counter + 1);\n-        Symbol::intern(&format!(\"'{:?}\", c))\n+        Symbol::intern(&format!(\"'{c:?}\"))\n     }\n \n     /// Maps from an internal MIR region vid to something that we can\n@@ -619,7 +619,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                     // programs, so we need to use delay_span_bug here. See #82126.\n                     self.infcx.tcx.sess.delay_span_bug(\n                         hir_arg.span(),\n-                        &format!(\"unmatched subst and hir arg: found {:?} vs {:?}\", kind, hir_arg),\n+                        &format!(\"unmatched subst and hir arg: found {kind:?} vs {hir_arg:?}\"),\n                     );\n                 }\n             }\n@@ -783,8 +783,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         } else {\n             span_bug!(\n                 hir_ty.span,\n-                \"bounds from lowered return type of async fn did not match expected format: {:?}\",\n-                opaque_ty\n+                \"bounds from lowered return type of async fn did not match expected format: {opaque_ty:?}\",\n             );\n         }\n     }"}, {"sha": "ada3310d8071b776215d5ce4c5c5d037d353df93", "filename": "compiler/rustc_borrowck/src/diagnostics/var_name.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -18,7 +18,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         upvars: &[Upvar<'tcx>],\n         fr: RegionVid,\n     ) -> Option<(Option<Symbol>, Span)> {\n-        debug!(\"get_var_name_and_span_for_region(fr={:?})\", fr);\n+        debug!(\"get_var_name_and_span_for_region(fr={fr:?})\");\n         assert!(self.universal_regions().is_universal_region(fr));\n \n         debug!(\"get_var_name_and_span_for_region: attempting upvar\");\n@@ -44,19 +44,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<usize> {\n         let upvar_index =\n             self.universal_regions().defining_ty.upvar_tys().position(|upvar_ty| {\n-                debug!(\"get_upvar_index_for_region: upvar_ty={:?}\", upvar_ty);\n+                debug!(\"get_upvar_index_for_region: upvar_ty={upvar_ty:?}\");\n                 tcx.any_free_region_meets(&upvar_ty, |r| {\n                     let r = r.to_region_vid();\n-                    debug!(\"get_upvar_index_for_region: r={:?} fr={:?}\", r, fr);\n+                    debug!(\"get_upvar_index_for_region: r={r:?} fr={fr:?}\");\n                     r == fr\n                 })\n             })?;\n \n         let upvar_ty = self.universal_regions().defining_ty.upvar_tys().nth(upvar_index);\n \n         debug!(\n-            \"get_upvar_index_for_region: found {:?} in upvar {} which has type {:?}\",\n-            fr, upvar_index, upvar_ty,\n+            \"get_upvar_index_for_region: found {fr:?} in upvar {upvar_index} which has type {upvar_ty:?}\",\n         );\n \n         Some(upvar_index)\n@@ -71,13 +70,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         upvar_index: usize,\n     ) -> (Symbol, Span) {\n         let upvar_hir_id = upvars[upvar_index].place.get_root_variable();\n-        debug!(\"get_upvar_name_and_span_for_region: upvar_hir_id={:?}\", upvar_hir_id);\n+        debug!(\"get_upvar_name_and_span_for_region: upvar_hir_id={upvar_hir_id:?}\");\n \n         let upvar_name = tcx.hir().name(upvar_hir_id);\n         let upvar_span = tcx.hir().span(upvar_hir_id);\n         debug!(\n-            \"get_upvar_name_and_span_for_region: upvar_name={:?} upvar_span={:?}\",\n-            upvar_name, upvar_span\n+            \"get_upvar_name_and_span_for_region: upvar_name={upvar_name:?} upvar_span={upvar_span:?}\",\n         );\n \n         (upvar_name, upvar_span)\n@@ -97,15 +95,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let argument_index =\n             self.universal_regions().unnormalized_input_tys.iter().skip(implicit_inputs).position(\n                 |arg_ty| {\n-                    debug!(\"get_argument_index_for_region: arg_ty = {:?}\", arg_ty);\n+                    debug!(\"get_argument_index_for_region: arg_ty = {arg_ty:?}\");\n                     tcx.any_free_region_meets(arg_ty, |r| r.to_region_vid() == fr)\n                 },\n             )?;\n \n         debug!(\n-            \"get_argument_index_for_region: found {:?} in argument {} which has type {:?}\",\n-            fr,\n-            argument_index,\n+            \"get_argument_index_for_region: found {fr:?} in argument {argument_index} which has type {:?}\",\n             self.universal_regions().unnormalized_input_tys[argument_index],\n         );\n \n@@ -122,13 +118,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> (Option<Symbol>, Span) {\n         let implicit_inputs = self.universal_regions().defining_ty.implicit_inputs();\n         let argument_local = Local::new(implicit_inputs + argument_index + 1);\n-        debug!(\"get_argument_name_and_span_for_region: argument_local={:?}\", argument_local);\n+        debug!(\"get_argument_name_and_span_for_region: argument_local={argument_local:?}\");\n \n         let argument_name = local_names[argument_local];\n         let argument_span = body.local_decls[argument_local].source_info.span;\n         debug!(\n-            \"get_argument_name_and_span_for_region: argument_name={:?} argument_span={:?}\",\n-            argument_name, argument_span\n+            \"get_argument_name_and_span_for_region: argument_name={argument_name:?} argument_span={argument_span:?}\",\n         );\n \n         (argument_name, argument_span)"}, {"sha": "02ffb51fbb7e3a3fb440a497e558702fefc5ba41", "filename": "compiler/rustc_borrowck/src/facts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -192,7 +192,7 @@ fn write_row(\n ) -> Result<(), Box<dyn Error>> {\n     for (index, c) in columns.iter().enumerate() {\n         let tail = if index == columns.len() - 1 { \"\\n\" } else { \"\\t\" };\n-        write!(out, \"{:?}{}\", c.to_string(location_table), tail)?;\n+        write!(out, \"{:?}{tail}\", c.to_string(location_table))?;\n     }\n     Ok(())\n }"}, {"sha": "2384f851a662d60c945d4c8d5b668e6886129231", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -2173,7 +2173,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     // `self.foo` -- we want to double\n                                     // check that the location `*self`\n                                     // is mutable (i.e., this is not a\n-                                    // `Fn` closure).  But if that\n+                                    // `Fn` closure). But if that\n                                     // check succeeds, we want to\n                                     // *blame* the mutability on\n                                     // `place` (that is,"}, {"sha": "4af324f740aef686c98d68bd329660555744bae2", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -109,7 +109,7 @@ where\n     R1: Copy + Hash + Eq,\n {\n     /// Remap the \"member region\" key using `map_fn`, producing a new\n-    /// member constraint set.  This is used in the NLL code to map from\n+    /// member constraint set. This is used in the NLL code to map from\n     /// the original `RegionVid` to an scc index. In some cases, we\n     /// may have multiple `R1` values mapping to the same `R2` key -- that\n     /// is ok, the two sets will be merged.\n@@ -158,7 +158,7 @@ where\n     }\n \n     /// Iterate down the constraint indices associated with a given\n-    /// peek-region.  You can then use `choice_regions` and other\n+    /// peek-region. You can then use `choice_regions` and other\n     /// methods to access data.\n     pub(crate) fn indices(\n         &self,"}, {"sha": "b2d92d0dba7a4de1cb38292dc7e9cb545f880d86", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -385,7 +385,7 @@ pub(super) fn dump_annotation<'tcx>(\n \n     // When the enclosing function is tagged with `#[rustc_regions]`,\n     // we dump out various bits of state as warnings. This is useful\n-    // for verifying that the compiler is behaving as expected.  These\n+    // for verifying that the compiler is behaving as expected. These\n     // warnings focus on the closure region requirements -- for\n     // viewing the intraprocedural state, the -Zdump-mir output is\n     // better."}, {"sha": "85d207b2fc9a7530afd0724e001c6881d6389eab", "filename": "compiler/rustc_borrowck/src/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -63,7 +63,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                     ty::RawPtr(..) | ty::Ref(_, _, hir::Mutability::Not) => {\n                         // For both derefs of raw pointers and `&T`\n                         // references, the original path is `Copy` and\n-                        // therefore not significant.  In particular,\n+                        // therefore not significant. In particular,\n                         // there is nothing the user can do to the\n                         // original path that would invalidate the\n                         // newly created reference -- and if there"}, {"sha": "89788c16cbb0fb30653acb6307d0d8ee233bdea6", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -680,7 +680,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// enforce the constraint).\n     ///\n     /// The current value of `scc` at the time the method is invoked\n-    /// is considered a *lower bound*.  If possible, we will modify\n+    /// is considered a *lower bound*. If possible, we will modify\n     /// the constraint to set it equal to one of the option regions.\n     /// If we make any changes, returns true, else false.\n     #[instrument(skip(self, member_constraint_index), level = \"debug\")]\n@@ -959,7 +959,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             //\n             // This is needed because -- particularly in the case\n             // where `ur` is a local bound -- we are sometimes in a\n-            // position to prove things that our caller cannot.  See\n+            // position to prove things that our caller cannot. See\n             // #53570 for an example.\n             if self.eval_verify_bound(infcx, param_env, generic_ty, ur, &type_test.verify_bound) {\n                 continue;\n@@ -2035,7 +2035,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         //    '5: '6 ('6 is the target)\n         //\n         // Some of those regions are unified with `'6` (in the same\n-        // SCC).  We want to screen those out. After that point, the\n+        // SCC). We want to screen those out. After that point, the\n         // \"closest\" constraint we have to the end is going to be the\n         // most likely to be the point where the value escapes -- but\n         // we still want to screen for an \"interesting\" point to"}, {"sha": "767f9fe39c68b7162092c6b53e2cb00383373a84", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -262,7 +262,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             return self.tcx.ty_error();\n         }\n \n-        // Only check this for TAIT. RPIT already supports `src/test/ui/impl-trait/nested-return-type2.rs`\n+        // Only check this for TAIT. RPIT already supports `tests/ui/impl-trait/nested-return-type2.rs`\n         // on stable and we'd break that.\n         let OpaqueTyOrigin::TyAlias = origin else {\n             return definition_ty;\n@@ -318,7 +318,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n \n         // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n         // tests to pass\n-        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+        let _ = infcx.take_opaque_types();\n \n         if errors.is_empty() {\n             definition_ty"}, {"sha": "02222c0a03cb350f9dcfdebc2b963db3f1edfcd5", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 74, "deletions": 4, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,13 +1,13 @@\n use std::fmt;\n \n-use rustc_infer::infer::canonical::Canonical;\n-use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::infer::{canonical::Canonical, InferOk};\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::ty::{self, ToPredicate, TypeFoldable};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TypeFoldable};\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op::{self, TypeOpOutput};\n-use rustc_trait_selection::traits::query::Fallible;\n+use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n+use rustc_trait_selection::traits::{ObligationCause, ObligationCtxt};\n \n use crate::diagnostics::{ToUniverseInfo, UniverseInfo};\n \n@@ -177,4 +177,74 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             value\n         })\n     }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub(super) fn ascribe_user_type(\n+        &mut self,\n+        mir_ty: Ty<'tcx>,\n+        user_ty: ty::UserType<'tcx>,\n+        span: Span,\n+    ) {\n+        // FIXME: Ideally MIR types are normalized, but this is not always true.\n+        let mir_ty = self.normalize(mir_ty, Locations::All(span));\n+\n+        self.fully_perform_op(\n+            Locations::All(span),\n+            ConstraintCategory::Boring,\n+            self.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(mir_ty, user_ty)),\n+        )\n+        .unwrap_or_else(|err| {\n+            span_mirbug!(\n+                self,\n+                span,\n+                \"ascribe_user_type `{mir_ty:?}=={user_ty:?}` failed with `{err:?}`\",\n+            );\n+        });\n+    }\n+\n+    /// *Incorrectly* skips the WF checks we normally do in `ascribe_user_type`.\n+    ///\n+    /// FIXME(#104478, #104477): This is a hack for backward-compatibility.\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub(super) fn ascribe_user_type_skip_wf(\n+        &mut self,\n+        mir_ty: Ty<'tcx>,\n+        user_ty: ty::UserType<'tcx>,\n+        span: Span,\n+    ) {\n+        let ty::UserType::Ty(user_ty) = user_ty else { bug!() };\n+\n+        // A fast path for a common case with closure input/output types.\n+        if let ty::Infer(_) = user_ty.kind() {\n+            self.eq_types(user_ty, mir_ty, Locations::All(span), ConstraintCategory::Boring)\n+                .unwrap();\n+            return;\n+        }\n+\n+        let mir_ty = self.normalize(mir_ty, Locations::All(span));\n+        let cause = ObligationCause::dummy_with_span(span);\n+        let param_env = self.param_env;\n+        let op = |infcx: &'_ _| {\n+            let ocx = ObligationCtxt::new_in_snapshot(infcx);\n+            let user_ty = ocx.normalize(&cause, param_env, user_ty);\n+            ocx.eq(&cause, param_env, user_ty, mir_ty)?;\n+            if !ocx.select_all_or_error().is_empty() {\n+                return Err(NoSolution);\n+            }\n+            Ok(InferOk { value: (), obligations: vec![] })\n+        };\n+\n+        self.fully_perform_op(\n+            Locations::All(span),\n+            ConstraintCategory::Boring,\n+            type_op::custom::CustomTypeOp::new(op, || \"ascribe_user_type_skip_wf\".to_string()),\n+        )\n+        .unwrap_or_else(|err| {\n+            span_mirbug!(\n+                self,\n+                span,\n+                \"ascribe_user_type_skip_wf `{mir_ty:?}=={user_ty:?}` failed with `{err:?}`\",\n+            );\n+        });\n+    }\n }"}, {"sha": "e15d1b99ad205229e2d7b901e101da1bcc5614b5", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         closure_substs: ty::SubstsRef<'tcx>,\n     ) {\n         // Extract the values of the free regions in `closure_substs`\n-        // into a vector.  These are the regions that we will be\n+        // into a vector. These are the regions that we will be\n         // relating to one another.\n         let closure_mapping = &UniversalRegions::closure_mapping(\n             self.tcx,"}, {"sha": "a125600899063e6023426431233bc98192c1688d", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -98,7 +98,7 @@ impl UniversalRegionRelations<'_> {\n         let upper_bounds = self.non_local_upper_bounds(fr);\n \n         // In case we find more than one, reduce to one for\n-        // convenience.  This is to prevent us from generating more\n+        // convenience. This is to prevent us from generating more\n         // complex constraints, but it will cause spurious errors.\n         let post_dom = self.inverse_outlives.mutual_immediate_postdominator(upper_bounds);\n \n@@ -128,7 +128,7 @@ impl UniversalRegionRelations<'_> {\n         let lower_bounds = self.non_local_bounds(&self.outlives, fr);\n \n         // In case we find more than one, reduce to one for\n-        // convenience.  This is to prevent us from generating more\n+        // convenience. This is to prevent us from generating more\n         // complex constraints, but it will cause spurious errors.\n         let post_dom = self.outlives.mutual_immediate_postdominator(lower_bounds);\n "}, {"sha": "fa9ea769a14f79607e86c7d69dafbec2216b5c1a", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 47, "deletions": 79, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -10,14 +10,60 @@\n use rustc_index::vec::Idx;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::Ty;\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n \n use crate::universal_regions::UniversalRegions;\n \n use super::{Locations, TypeChecker};\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n+    /// Check explicit closure signature annotation,\n+    /// e.g., `|x: FxHashMap<_, &'static u32>| ...`.\n+    #[instrument(skip(self, body), level = \"debug\")]\n+    pub(super) fn check_signature_annotation(&mut self, body: &Body<'tcx>) {\n+        let mir_def_id = body.source.def_id().expect_local();\n+        if !self.tcx().is_closure(mir_def_id.to_def_id()) {\n+            return;\n+        }\n+        let Some(user_provided_poly_sig) =\n+            self.tcx().typeck(mir_def_id).user_provided_sigs.get(&mir_def_id)\n+        else {\n+            return;\n+        };\n+\n+        // Instantiate the canonicalized variables from user-provided signature\n+        // (e.g., the `_` in the code above) with fresh variables.\n+        // Then replace the bound items in the fn sig with fresh variables,\n+        // so that they represent the view from \"inside\" the closure.\n+        let user_provided_sig = self\n+            .instantiate_canonical_with_fresh_inference_vars(body.span, &user_provided_poly_sig);\n+        let user_provided_sig = self.infcx.replace_bound_vars_with_fresh_vars(\n+            body.span,\n+            LateBoundRegionConversionTime::FnCall,\n+            user_provided_sig,\n+        );\n+\n+        for (&user_ty, arg_decl) in user_provided_sig.inputs().iter().zip(\n+            // In MIR, closure args begin with an implicit `self`. Skip it!\n+            body.args_iter().skip(1).map(|local| &body.local_decls[local]),\n+        ) {\n+            self.ascribe_user_type_skip_wf(\n+                arg_decl.ty,\n+                ty::UserType::Ty(user_ty),\n+                arg_decl.source_info.span,\n+            );\n+        }\n+\n+        // If the user explicitly annotated the output type, enforce it.\n+        let output_decl = &body.local_decls[RETURN_PLACE];\n+        self.ascribe_user_type_skip_wf(\n+            output_decl.ty,\n+            ty::UserType::Ty(user_provided_sig.output()),\n+            output_decl.source_info.span,\n+        );\n+    }\n+\n     #[instrument(skip(self, body, universal_regions), level = \"debug\")]\n     pub(super) fn equate_inputs_and_outputs(\n         &mut self,\n@@ -31,39 +77,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         debug!(?normalized_output_ty);\n         debug!(?normalized_input_tys);\n \n-        let mir_def_id = body.source.def_id().expect_local();\n-\n-        // If the user explicitly annotated the input types, extract\n-        // those.\n-        //\n-        // e.g., `|x: FxHashMap<_, &'static u32>| ...`\n-        let user_provided_sig = if !self.tcx().is_closure(mir_def_id.to_def_id()) {\n-            None\n-        } else {\n-            let typeck_results = self.tcx().typeck(mir_def_id);\n-\n-            typeck_results.user_provided_sigs.get(&mir_def_id).map(|user_provided_poly_sig| {\n-                // Instantiate the canonicalized variables from\n-                // user-provided signature (e.g., the `_` in the code\n-                // above) with fresh variables.\n-                let poly_sig = self.instantiate_canonical_with_fresh_inference_vars(\n-                    body.span,\n-                    &user_provided_poly_sig,\n-                );\n-\n-                // Replace the bound items in the fn sig with fresh\n-                // variables, so that they represent the view from\n-                // \"inside\" the closure.\n-                self.infcx.replace_bound_vars_with_fresh_vars(\n-                    body.span,\n-                    LateBoundRegionConversionTime::FnCall,\n-                    poly_sig,\n-                )\n-            })\n-        };\n-\n-        debug!(?normalized_input_tys, ?body.local_decls);\n-\n         // Equate expected input tys with those in the MIR.\n         for (argument_index, &normalized_input_ty) in normalized_input_tys.iter().enumerate() {\n             if argument_index + 1 >= body.local_decls.len() {\n@@ -86,28 +99,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             );\n         }\n \n-        if let Some(user_provided_sig) = user_provided_sig {\n-            for (argument_index, &user_provided_input_ty) in\n-                user_provided_sig.inputs().iter().enumerate()\n-            {\n-                // In MIR, closures begin an implicit `self`, so\n-                // argument N is stored in local N+2.\n-                let local = Local::new(argument_index + 2);\n-                let mir_input_ty = body.local_decls[local].ty;\n-                let mir_input_span = body.local_decls[local].source_info.span;\n-\n-                // If the user explicitly annotated the input types, enforce those.\n-                let user_provided_input_ty =\n-                    self.normalize(user_provided_input_ty, Locations::All(mir_input_span));\n-\n-                self.equate_normalized_input_or_output(\n-                    user_provided_input_ty,\n-                    mir_input_ty,\n-                    mir_input_span,\n-                );\n-            }\n-        }\n-\n         debug!(\n             \"equate_inputs_and_outputs: body.yield_ty {:?}, universal_regions.yield_ty {:?}\",\n             body.yield_ty(),\n@@ -153,29 +144,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 terr\n             );\n         };\n-\n-        // If the user explicitly annotated the output types, enforce those.\n-        // Note that this only happens for closures.\n-        if let Some(user_provided_sig) = user_provided_sig {\n-            let user_provided_output_ty = user_provided_sig.output();\n-            let user_provided_output_ty =\n-                self.normalize(user_provided_output_ty, Locations::All(output_span));\n-            if let Err(err) = self.eq_types(\n-                user_provided_output_ty,\n-                mir_output_ty,\n-                Locations::All(output_span),\n-                ConstraintCategory::BoringNoLocation,\n-            ) {\n-                span_mirbug!(\n-                    self,\n-                    Location::START,\n-                    \"equate_inputs_and_outputs: `{:?}=={:?}` failed with `{:?}`\",\n-                    mir_output_ty,\n-                    user_provided_output_ty,\n-                    err\n-                );\n-            }\n-        }\n     }\n \n     #[instrument(skip(self), level = \"debug\")]"}, {"sha": "3ff5d188a3d35233cf381cfb460655ee6b62c3ca", "filename": "compiler/rustc_borrowck/src/type_check/liveness/trace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -328,7 +328,7 @@ impl<'me, 'typeck, 'flow, 'tcx> LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         debug_assert!(self.drop_live_at.contains(term_point));\n \n         // Otherwise, scan backwards through the statements in the\n-        // block.  One of them may be either a definition or use\n+        // block. One of them may be either a definition or use\n         // live point.\n         let term_location = self.cx.elements.to_location(term_point);\n         debug_assert_eq!(self.cx.body.terminator_loc(term_location.block), term_location,);"}, {"sha": "81bd4c2a783e906b30a4d1999bbea53b62522998", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 11, "deletions": 69, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -38,7 +38,6 @@ use rustc_middle::ty::{\n use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n-use rustc_trait_selection::traits::query::type_op;\n use rustc_trait_selection::traits::query::type_op::custom::scrape_region_constraints;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n use rustc_trait_selection::traits::query::type_op::{TypeOp, TypeOpOutput};\n@@ -197,6 +196,8 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     }\n \n     checker.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n+    checker.check_signature_annotation(&body);\n+\n     liveness::generate(\n         &mut checker,\n         body,\n@@ -208,7 +209,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     );\n \n     translate_outlives_facts(&mut checker);\n-    let opaque_type_values = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+    let opaque_type_values = infcx.take_opaque_types();\n \n     let opaque_type_values = opaque_type_values\n         .into_iter()\n@@ -391,23 +392,14 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                         check_err(self, promoted_body, ty, promoted_ty);\n                     }\n                 } else {\n-                    if let Err(terr) = self.cx.fully_perform_op(\n-                        locations,\n-                        ConstraintCategory::Boring,\n-                        self.cx.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n-                            constant.literal.ty(),\n+                    self.cx.ascribe_user_type(\n+                        constant.literal.ty(),\n+                        UserType::TypeOf(\n                             uv.def.did,\n                             UserSubsts { substs: uv.substs, user_self_ty: None },\n-                        )),\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n-                            constant,\n-                            \"bad constant type {:?} ({:?})\",\n-                            constant,\n-                            terr\n-                        );\n-                    }\n+                        ),\n+                        locations.span(&self.cx.body),\n+                    );\n                 }\n             } else if let Some(static_def_id) = constant.check_static_ptr(tcx) {\n                 let unnormalized_ty = tcx.type_of(static_def_id);\n@@ -1041,58 +1033,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         debug!(?self.user_type_annotations);\n         for user_annotation in self.user_type_annotations {\n             let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n-            let inferred_ty = self.normalize(inferred_ty, Locations::All(span));\n             let annotation = self.instantiate_canonical_with_fresh_inference_vars(span, user_ty);\n-            debug!(?annotation);\n-            match annotation {\n-                UserType::Ty(mut ty) => {\n-                    ty = self.normalize(ty, Locations::All(span));\n-\n-                    if let Err(terr) = self.eq_types(\n-                        ty,\n-                        inferred_ty,\n-                        Locations::All(span),\n-                        ConstraintCategory::BoringNoLocation,\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n-                            user_annotation,\n-                            \"bad user type ({:?} = {:?}): {:?}\",\n-                            ty,\n-                            inferred_ty,\n-                            terr\n-                        );\n-                    }\n-\n-                    self.prove_predicate(\n-                        ty::Binder::dummy(ty::PredicateKind::WellFormed(inferred_ty.into())),\n-                        Locations::All(span),\n-                        ConstraintCategory::TypeAnnotation,\n-                    );\n-                }\n-                UserType::TypeOf(def_id, user_substs) => {\n-                    if let Err(terr) = self.fully_perform_op(\n-                        Locations::All(span),\n-                        ConstraintCategory::BoringNoLocation,\n-                        self.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n-                            inferred_ty,\n-                            def_id,\n-                            user_substs,\n-                        )),\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n-                            user_annotation,\n-                            \"bad user type AscribeUserType({:?}, {:?} {:?}, type_of={:?}): {:?}\",\n-                            inferred_ty,\n-                            def_id,\n-                            user_substs,\n-                            self.tcx().type_of(def_id),\n-                            terr,\n-                        );\n-                    }\n-                }\n-            }\n+            self.ascribe_user_type(inferred_ty, annotation, span);\n         }\n     }\n \n@@ -1723,7 +1665,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn ensure_place_sized(&mut self, ty: Ty<'tcx>, span: Span) {\n         let tcx = self.tcx();\n \n-        // Erase the regions from `ty` to get a global type.  The\n+        // Erase the regions from `ty` to get a global type. The\n         // `Sized` bound in no way depends on precise regions, so this\n         // shouldn't affect `is_sized`.\n         let erased_ty = tcx.erase_regions(ty);"}, {"sha": "5b4d99682d98633a632e6974eba70f73c2a35c25", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -637,7 +637,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 let closure_ty = tcx.closure_env_ty(def_id, substs, env_region).unwrap();\n \n                 // The \"inputs\" of the closure in the\n-                // signature appear as a tuple.  The MIR side\n+                // signature appear as a tuple. The MIR side\n                 // flattens this tuple.\n                 let (&output, tuplized_inputs) =\n                     inputs_and_output.skip_binder().split_last().unwrap();"}, {"sha": "3f174e2d9014a84c7360bb169bdf18e09d2f411d", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -20,7 +20,7 @@ pub fn expand_deriving_clone(\n     // some additional `AssertParamIsClone` assertions.\n     //\n     // We can use the simple form if either of the following are true.\n-    // - The type derives Copy and there are no generic parameters.  (If we\n+    // - The type derives Copy and there are no generic parameters. (If we\n     //   used the simple form with generics, we'd have to bound the generics\n     //   with Clone + Copy, and then there'd be no Clone impl at all if the\n     //   user fills in something that is Clone but not Copy. After"}, {"sha": "e5a5e606930f00e213c7bca7c893889955598892", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,4 +1,4 @@\n-// The compiler code necessary to support the env! extension.  Eventually this\n+// The compiler code necessary to support the env! extension. Eventually this\n // should all get sucked into either the compiler syntax extension plugin\n // interface.\n //"}, {"sha": "9f4bbbc62c819e516273c409c89eeec3fc72877a", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -583,7 +583,7 @@ fn report_missing_placeholders(\n     if detect_foreign_fmt {\n         use super::format_foreign as foreign;\n \n-        // The set of foreign substitutions we've explained.  This prevents spamming the user\n+        // The set of foreign substitutions we've explained. This prevents spamming the user\n         // with `%d should be written as {}` over and over again.\n         let mut explained = FxHashSet::default();\n "}, {"sha": "bd9e903b6ba297cdda9ce8de7efa4404e6c4325d", "filename": "compiler/rustc_builtin_macros/src/format_foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -253,7 +253,7 @@ pub(crate) mod printf {\n     #[derive(Copy, Clone, PartialEq, Debug)]\n     pub enum Num {\n         // The range of these values is technically bounded by `NL_ARGMAX`... but, at least for GNU\n-        // libc, it apparently has no real fixed limit.  A `u16` is used here on the basis that it\n+        // libc, it apparently has no real fixed limit. A `u16` is used here on the basis that it\n         // is *vanishingly* unlikely that *anyone* is going to try formatting something wider, or\n         // with more precision, than 32 thousand positions which is so wide it couldn't possibly fit\n         // on a screen."}, {"sha": "12ecb8cf4e17d6473d36610183c6e5224d196db9", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -10,118 +10,118 @@ pushd rust\n \n command -v rg >/dev/null 2>&1 || cargo install ripgrep\n \n-rm -r src/test/ui/{extern/,unsized-locals/,lto/,linkage*} || true\n-for test in $(rg --files-with-matches \"lto|// needs-asm-support|// needs-unwind\" src/test/{ui,incremental}); do\n+rm -r tests/ui/{extern/,unsized-locals/,lto/,linkage*} || true\n+for test in $(rg --files-with-matches \"lto|// needs-asm-support|// needs-unwind\" tests/{ui,incremental}); do\n   rm $test\n done\n \n-for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~[^\\|]*\\s*ERR|// error-pattern:|// build-fail|// run-fail|-Cllvm-args\" src/test/ui); do\n+for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~[^\\|]*\\s*ERR|// error-pattern:|// build-fail|// run-fail|-Cllvm-args\" tests/ui); do\n   rm $test\n done\n \n-git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n-git checkout -- src/test/ui/proc-macro/pretty-print-hack/\n+git checkout -- tests/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n+git checkout -- tests/ui/proc-macro/pretty-print-hack/\n \n # missing features\n # ================\n \n # requires stack unwinding\n-rm src/test/incremental/change_crate_dep_kind.rs\n-rm src/test/incremental/issue-80691-bad-eval-cache.rs # -Cpanic=abort causes abort instead of exit(101)\n+rm tests/incremental/change_crate_dep_kind.rs\n+rm tests/incremental/issue-80691-bad-eval-cache.rs # -Cpanic=abort causes abort instead of exit(101)\n \n # requires compiling with -Cpanic=unwind\n-rm -r src/test/ui/macros/rfc-2011-nicer-assert-messages/\n-rm -r src/test/run-make/test-benches\n+rm -r tests/ui/macros/rfc-2011-nicer-assert-messages/\n+rm -r tests/run-make/test-benches\n \n # vendor intrinsics\n-rm src/test/ui/sse2.rs # cpuid not supported, so sse2 not detected\n-rm src/test/ui/intrinsics/const-eval-select-x86_64.rs # requires x86_64 vendor intrinsics\n-rm src/test/ui/simd/array-type.rs # \"Index argument for `simd_insert` is not a constant\"\n-rm src/test/ui/simd/intrinsic/generic-bitmask-pass.rs # simd_bitmask unimplemented\n-rm src/test/ui/simd/intrinsic/generic-as.rs # simd_as unimplemented\n-rm src/test/ui/simd/intrinsic/generic-arithmetic-saturating-pass.rs # simd_saturating_add unimplemented\n-rm src/test/ui/simd/intrinsic/float-math-pass.rs # simd_fcos unimplemented\n-rm src/test/ui/simd/intrinsic/generic-gather-pass.rs # simd_gather unimplemented\n-rm src/test/ui/simd/intrinsic/generic-select-pass.rs # simd_select_bitmask unimplemented\n-rm src/test/ui/simd/issue-85915-simd-ptrs.rs # simd_gather unimplemented\n-rm src/test/ui/simd/issue-89193.rs # simd_gather unimplemented\n-rm src/test/ui/simd/simd-bitmask.rs # simd_bitmask unimplemented\n+rm tests/ui/sse2.rs # cpuid not supported, so sse2 not detected\n+rm tests/ui/intrinsics/const-eval-select-x86_64.rs # requires x86_64 vendor intrinsics\n+rm tests/ui/simd/array-type.rs # \"Index argument for `simd_insert` is not a constant\"\n+rm tests/ui/simd/intrinsic/generic-bitmask-pass.rs # simd_bitmask unimplemented\n+rm tests/ui/simd/intrinsic/generic-as.rs # simd_as unimplemented\n+rm tests/ui/simd/intrinsic/generic-arithmetic-saturating-pass.rs # simd_saturating_add unimplemented\n+rm tests/ui/simd/intrinsic/float-math-pass.rs # simd_fcos unimplemented\n+rm tests/ui/simd/intrinsic/generic-gather-pass.rs # simd_gather unimplemented\n+rm tests/ui/simd/intrinsic/generic-select-pass.rs # simd_select_bitmask unimplemented\n+rm tests/ui/simd/issue-85915-simd-ptrs.rs # simd_gather unimplemented\n+rm tests/ui/simd/issue-89193.rs # simd_gather unimplemented\n+rm tests/ui/simd/simd-bitmask.rs # simd_bitmask unimplemented\n \n # exotic linkages\n-rm src/test/ui/issues/issue-33992.rs # unsupported linkages\n-rm src/test/incremental/hashes/function_interfaces.rs # same\n-rm src/test/incremental/hashes/statics.rs # same\n+rm tests/ui/issues/issue-33992.rs # unsupported linkages\n+rm tests/incremental/hashes/function_interfaces.rs # same\n+rm tests/incremental/hashes/statics.rs # same\n \n # variadic arguments\n-rm src/test/ui/abi/mir/mir_codegen_calls_variadic.rs # requires float varargs\n-rm src/test/ui/abi/variadic-ffi.rs # requires callee side vararg support\n+rm tests/ui/abi/mir/mir_codegen_calls_variadic.rs # requires float varargs\n+rm tests/ui/abi/variadic-ffi.rs # requires callee side vararg support\n \n # unsized locals\n-rm -r src/test/run-pass-valgrind/unsized-locals\n+rm -r tests/run-pass-valgrind/unsized-locals\n \n # misc unimplemented things\n-rm src/test/ui/intrinsics/intrinsic-nearby.rs # unimplemented nearbyintf32 and nearbyintf64 intrinsics\n-rm src/test/ui/target-feature/missing-plusminus.rs # error not implemented\n-rm src/test/ui/fn/dyn-fn-alignment.rs # wants a 256 byte alignment\n-rm -r src/test/run-make/emit-named-files # requires full --emit support\n-rm src/test/ui/abi/stack-probes.rs # stack probes not yet implemented\n-rm src/test/ui/simd/intrinsic/ptr-cast.rs # simd_expose_addr intrinsic unimplemented\n-rm -r src/test/run-make/repr128-dwarf # debuginfo test\n-rm src/test/codegen-units/item-collection/asm-sym.rs # requires support for sym in asm!()\n+rm tests/ui/intrinsics/intrinsic-nearby.rs # unimplemented nearbyintf32 and nearbyintf64 intrinsics\n+rm tests/ui/target-feature/missing-plusminus.rs # error not implemented\n+rm tests/ui/fn/dyn-fn-alignment.rs # wants a 256 byte alignment\n+rm -r tests/run-make/emit-named-files # requires full --emit support\n+rm tests/ui/abi/stack-probes.rs # stack probes not yet implemented\n+rm tests/ui/simd/intrinsic/ptr-cast.rs # simd_expose_addr intrinsic unimplemented\n+rm -r tests/run-make/repr128-dwarf # debuginfo test\n+rm tests/codegen-units/item-collection/asm-sym.rs # requires support for sym in asm!()\n \n # optimization tests\n # ==================\n-rm src/test/ui/codegen/issue-28950.rs # depends on stack size optimizations\n-rm src/test/ui/codegen/init-large-type.rs # same\n-rm src/test/ui/issues/issue-40883.rs # same\n-rm -r src/test/run-make/fmt-write-bloat/ # tests an optimization\n+rm tests/ui/codegen/issue-28950.rs # depends on stack size optimizations\n+rm tests/ui/codegen/init-large-type.rs # same\n+rm tests/ui/issues/issue-40883.rs # same\n+rm -r tests/run-make/fmt-write-bloat/ # tests an optimization\n \n # backend specific tests\n # ======================\n-rm src/test/incremental/thinlto/cgu_invalidated_when_import_{added,removed}.rs # requires LLVM\n-rm src/test/ui/abi/stack-protector.rs # requires stack protector support\n+rm tests/incremental/thinlto/cgu_invalidated_when_import_{added,removed}.rs # requires LLVM\n+rm tests/ui/abi/stack-protector.rs # requires stack protector support\n \n # giving different but possibly correct results\n # =============================================\n-rm src/test/ui/mir/mir_misc_casts.rs # depends on deduplication of constants\n-rm src/test/ui/mir/mir_raw_fat_ptr.rs # same\n-rm src/test/ui/consts/issue-33537.rs # same\n-rm src/test/ui/layout/valid_range_oob.rs # different ICE message\n+rm tests/ui/mir/mir_misc_casts.rs # depends on deduplication of constants\n+rm tests/ui/mir/mir_raw_fat_ptr.rs # same\n+rm tests/ui/consts/issue-33537.rs # same\n+rm tests/ui/layout/valid_range_oob.rs # different ICE message\n \n # doesn't work due to the way the rustc test suite is invoked.\n # should work when using ./x.py test the way it is intended\n # ============================================================\n-rm -r src/test/run-make/emit-shared-files # requires the rustdoc executable in dist/bin/\n-rm -r src/test/run-make/unstable-flag-required # same\n-rm -r src/test/run-make/rustdoc-* # same\n-rm -r src/test/run-make/issue-88756-default-output # same\n-rm -r src/test/run-make/remap-path-prefix-dwarf # requires llvm-dwarfdump\n-rm -r src/test/ui/consts/missing_span_in_backtrace.rs # expects sysroot source to be elsewhere\n+rm -r tests/run-make/emit-shared-files # requires the rustdoc executable in dist/bin/\n+rm -r tests/run-make/unstable-flag-required # same\n+rm -r tests/run-make/rustdoc-* # same\n+rm -r tests/run-make/issue-88756-default-output # same\n+rm -r tests/run-make/remap-path-prefix-dwarf # requires llvm-dwarfdump\n+rm -r tests/ui/consts/missing_span_in_backtrace.rs # expects sysroot source to be elsewhere\n \n # genuine bugs\n # ============\n-rm src/test/incremental/spike-neg1.rs # errors out for some reason\n-rm src/test/incremental/spike-neg2.rs # same\n-rm src/test/ui/issues/issue-74564-if-expr-stack-overflow.rs # gives a stackoverflow before the backend runs\n-rm src/test/ui/mir/ssa-analysis-regression-50041.rs # produces ICE\n-rm src/test/ui/type-alias-impl-trait/assoc-projection-ice.rs # produces ICE\n+rm tests/incremental/spike-neg1.rs # errors out for some reason\n+rm tests/incremental/spike-neg2.rs # same\n+rm tests/ui/issues/issue-74564-if-expr-stack-overflow.rs # gives a stackoverflow before the backend runs\n+rm tests/ui/mir/ssa-analysis-regression-50041.rs # produces ICE\n+rm tests/ui/type-alias-impl-trait/assoc-projection-ice.rs # produces ICE\n \n-rm src/test/ui/simd/intrinsic/generic-reduction-pass.rs # simd_reduce_add_unordered doesn't accept an accumulator for integer vectors\n+rm tests/ui/simd/intrinsic/generic-reduction-pass.rs # simd_reduce_add_unordered doesn't accept an accumulator for integer vectors\n \n-rm src/test/ui/runtime/out-of-stack.rs # SIGSEGV instead of SIGABRT for some reason (#1301)\n+rm tests/ui/runtime/out-of-stack.rs # SIGSEGV instead of SIGABRT for some reason (#1301)\n \n # bugs in the test suite\n # ======================\n-rm src/test/ui/backtrace.rs # TODO warning\n-rm src/test/ui/simple_global_asm.rs # TODO add needs-asm-support\n-rm src/test/ui/test-attrs/test-type.rs # TODO panic message on stderr. correct stdout\n+rm tests/ui/backtrace.rs # TODO warning\n+rm tests/ui/simple_global_asm.rs # TODO add needs-asm-support\n+rm tests/ui/test-attrs/test-type.rs # TODO panic message on stderr. correct stdout\n # not sure if this is actually a bug in the test suite, but the symbol list shows the function without leading _ for some reason\n-rm -r src/test/run-make/native-link-modifier-bundle\n-rm src/test/ui/process/nofile-limit.rs # TODO some AArch64 linking issue\n-rm src/test/ui/dyn-star/dispatch-on-pin-mut.rs # TODO failed assertion in vtable::get_ptr_and_method_ref\n+rm -r tests/run-make/native-link-modifier-bundle\n+rm tests/ui/process/nofile-limit.rs # TODO some AArch64 linking issue\n+rm tests/ui/dyn-star/dispatch-on-pin-mut.rs # TODO failed assertion in vtable::get_ptr_and_method_ref\n \n-rm src/test/ui/stdio-is-blocking.rs # really slow with unoptimized libstd\n+rm tests/ui/stdio-is-blocking.rs # really slow with unoptimized libstd\n \n echo \"[TEST] rustc test suite\"\n-RUST_TEST_NOCAPTURE=1 COMPILETEST_FORCE_STAGE0=1 ./x.py test --stage 0 src/test/{codegen-units,run-make,run-pass-valgrind,ui,incremental}\n+RUST_TEST_NOCAPTURE=1 COMPILETEST_FORCE_STAGE0=1 ./x.py test --stage 0 tests/{codegen-units,run-make,run-pass-valgrind,ui,incremental}\n popd"}, {"sha": "51450897bfc11278afe11293a8c2e92de48ef52e", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -304,7 +304,7 @@ fn data_id_for_static(\n \n         // Comment copied from https://github.com/rust-lang/rust/blob/45060c2a66dfd667f88bd8b94261b28a58d85bd5/src/librustc_codegen_llvm/consts.rs#L141\n         // Declare an internal global `extern_with_linkage_foo` which\n-        // is initialized with the address of `foo`.  If `foo` is\n+        // is initialized with the address of `foo`. If `foo` is\n         // discarded during linking (for example, if `foo` has weak\n         // linkage and there are no definitions), then\n         // `extern_with_linkage_foo` will instead be initialized to"}, {"sha": "c5ffb763673d291c30391612140cec68cbc6bc34", "filename": "compiler/rustc_codegen_gcc/test.sh", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_gcc%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_gcc%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftest.sh?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -253,25 +253,25 @@ rustc = \"$HOME/.rustup/toolchains/$rust_toolchain-$TARGET_TRIPLE/bin/rustc\"\n EOF\n \n     rustc -V | cut -d' ' -f3 | tr -d '('\n-    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(') src/test\n+    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(') tests\n \n-    for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~|// error-pattern:|// build-fail|// run-fail|-Cllvm-args\" src/test/ui); do\n+    for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~|// error-pattern:|// build-fail|// run-fail|-Cllvm-args\" tests/ui); do\n       rm $test\n     done\n \n-    git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n+    git checkout -- tests/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n \n-    rm -r src/test/ui/{abi*,extern/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,test*,*lto*.rs} || true\n-    for test in $(rg --files-with-matches \"catch_unwind|should_panic|thread|lto\" src/test/ui); do\n+    rm -r tests/ui/{abi*,extern/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,test*,*lto*.rs} || true\n+    for test in $(rg --files-with-matches \"catch_unwind|should_panic|thread|lto\" tests/ui); do\n       rm $test\n     done\n-    git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice.rs\n-    git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice2.rs\n+    git checkout tests/ui/type-alias-impl-trait/auxiliary/cross_crate_ice.rs\n+    git checkout tests/ui/type-alias-impl-trait/auxiliary/cross_crate_ice2.rs\n \n     RUSTC_ARGS=\"-Zpanic-abort-tests -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n \n     echo \"[TEST] rustc test suite\"\n-    COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 src/test/ui/ --rustc-args \"$RUSTC_ARGS\"\n+    COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 tests/ui/ --rustc-args \"$RUSTC_ARGS\"\n }\n \n function clean_ui_tests() {"}, {"sha": "28be6d033f8bf3d82c3731d60f7837e7d8760df1", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -221,7 +221,7 @@ impl<'ll, 'tcx> ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 bx.store(val, cast_dst, self.layout.align.abi);\n             } else {\n                 // The actual return type is a struct, but the ABI\n-                // adaptation code has cast it into some scalar type.  The\n+                // adaptation code has cast it into some scalar type. The\n                 // code that follows is the only reliable way I have\n                 // found to do a transform like i64 -> {i32,i32}.\n                 // Basically we dump the data onto the stack then memcpy it."}, {"sha": "52c8b51796c0bf7712e38ddfb44bca2f64c4bdb5", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -445,7 +445,7 @@ pub(crate) fn inline_asm_call<'ll>(\n             };\n \n             // Store mark in a metadata node so we can map LLVM errors\n-            // back to source locations.  See #17552.\n+            // back to source locations. See #17552.\n             let key = \"srcloc\";\n             let kind = llvm::LLVMGetMDKindIDInContext(\n                 bx.llcx,"}, {"sha": "426f57c0608009dd437c508b1944f3a2305fc518", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -145,7 +145,7 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n             // The binutils linker used on -windows-gnu targets cannot read the import\n             // libraries generated by LLVM: in our attempts, the linker produced an .EXE\n             // that loaded but crashed with an AV upon calling one of the imported\n-            // functions.  Therefore, use binutils to create the import library instead,\n+            // functions. Therefore, use binutils to create the import library instead,\n             // by writing a .DEF file to the temp dir and calling binutils's dlltool.\n             let def_file_path =\n                 tmpdir.join(format!(\"{}{}\", lib_name, name_suffix)).with_extension(\"def\");\n@@ -219,7 +219,7 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n \n             // All import names are Rust identifiers and therefore cannot contain \\0 characters.\n             // FIXME: when support for #[link_name] is implemented, ensure that the import names\n-            // still don't contain any \\0 characters.  Also need to check that the names don't\n+            // still don't contain any \\0 characters. Also need to check that the names don't\n             // contain substrings like \" @\" or \"NONAME\" that are keywords or otherwise reserved\n             // in definition files.\n             let cstring_import_name_and_ordinal_vector: Vec<(CString, Option<u16>)> =\n@@ -433,7 +433,7 @@ fn find_binutils_dlltool(sess: &Session) -> OsString {\n     }\n \n     // The user didn't specify the location of the dlltool binary, and we weren't able\n-    // to find the appropriate one on the PATH.  Just return the name of the tool\n+    // to find the appropriate one on the PATH. Just return the name of the tool\n     // and let the invocation fail with a hopefully useful error message.\n     tool_name\n }"}, {"sha": "b2af9f31e4494175aad3d4140b32b7dd232247a5", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -909,7 +909,7 @@ unsafe fn embed_bitcode(\n \n // Create a `__imp_<symbol> = &symbol` global for every public static `symbol`.\n // This is required to satisfy `dllimport` references to static data in .rlibs\n-// when using MSVC linker.  We do this only for data, as linker can fix up\n+// when using MSVC linker. We do this only for data, as linker can fix up\n // code references on its own.\n // See #26591, #27438\n fn create_msvc_imps("}, {"sha": "f1d01a4602a5e313e06ff3ef816f42c2423a42a2", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -49,8 +49,8 @@ pub fn get_fn<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) ->\n         let llptrty = fn_abi.ptr_to_llvm_type(cx);\n \n         // This is subtle and surprising, but sometimes we have to bitcast\n-        // the resulting fn pointer.  The reason has to do with external\n-        // functions.  If you have two crates that both bind the same C\n+        // the resulting fn pointer. The reason has to do with external\n+        // functions. If you have two crates that both bind the same C\n         // library, they may not use precisely the same types: for\n         // example, they will probably each declare their own structs,\n         // which are distinct types from LLVM's point of view (nominal"}, {"sha": "16467b614feafd3015d192b3734244dee1a6058a", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -140,7 +140,7 @@ pub fn codegen_static_initializer<'ll, 'tcx>(\n fn set_global_alignment<'ll>(cx: &CodegenCx<'ll, '_>, gv: &'ll Value, mut align: Align) {\n     // The target may require greater alignment for globals than the type does.\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n-    // which can force it to be smaller.  Rust doesn't support this yet.\n+    // which can force it to be smaller. Rust doesn't support this yet.\n     if let Some(min) = cx.sess().target.min_global_align {\n         match Align::from_bits(min) {\n             Ok(min) => align = align.max(min),\n@@ -171,7 +171,7 @@ fn check_and_apply_linkage<'ll, 'tcx>(\n             llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n \n             // Declare an internal global `extern_with_linkage_foo` which\n-            // is initialized with the address of `foo`.  If `foo` is\n+            // is initialized with the address of `foo`. If `foo` is\n             // discarded during linking (for example, if `foo` has weak\n             // linkage and there are no definitions), then\n             // `extern_with_linkage_foo` will instead be initialized to"}, {"sha": "a6a75eff9a36d24e0c331aa3e171f09b3f839ebc", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -654,7 +654,7 @@ fn codegen_gnu_try<'ll>(\n         // Type indicator for the exception being thrown.\n         //\n         // The first value in this tuple is a pointer to the exception object\n-        // being thrown.  The second value is a \"selector\" indicating which of\n+        // being thrown. The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n         // rust_try ignores the selector.\n         bx.switch_to_block(catch);\n@@ -718,7 +718,7 @@ fn codegen_emcc_try<'ll>(\n         // Type indicator for the exception being thrown.\n         //\n         // The first value in this tuple is a pointer to the exception object\n-        // being thrown.  The second value is a \"selector\" indicating which of\n+        // being thrown. The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n         bx.switch_to_block(catch);\n         let tydesc = bx.eh_catch_typeinfo();"}, {"sha": "75cd5df972316366807d06a8d5cfa4d6a399ff0a", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -352,10 +352,10 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n         let scalar = [a, b][index];\n \n         // Make sure to return the same type `immediate_llvm_type` would when\n-        // dealing with an immediate pair.  This means that `(bool, bool)` is\n+        // dealing with an immediate pair. This means that `(bool, bool)` is\n         // effectively represented as `{i8, i8}` in memory and two `i1`s as an\n         // immediate, just like `bool` is typically `i8` in memory and only `i1`\n-        // when immediate.  We need to load/store `bool` as `i8` to avoid\n+        // when immediate. We need to load/store `bool` as `i8` to avoid\n         // crippling LLVM optimizations or triggering other LLVM bugs with `i1`.\n         if immediate && scalar.is_bool() {\n             return cx.type_i1();"}, {"sha": "c79dcb0f65e44edbf791e64deef509bef4123387", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -445,7 +445,7 @@ fn link_rlib<'a>(\n /// Extract all symbols defined in raw-dylib libraries, collated by library name.\n ///\n /// If we have multiple extern blocks that specify symbols defined in the same raw-dylib library,\n-/// then the CodegenResults value contains one NativeLib instance for each block.  However, the\n+/// then the CodegenResults value contains one NativeLib instance for each block. However, the\n /// linker appears to expect only a single import library for each library used, so we need to\n /// collate the symbols together by library name before generating the import libraries.\n fn collate_raw_dylibs<'a, 'b>(\n@@ -1197,7 +1197,7 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                         if cfg!(any(target_os = \"solaris\", target_os = \"illumos\")) {\n                             // On historical Solaris systems, \"cc\" may have\n                             // been Sun Studio, which is not flag-compatible\n-                            // with \"gcc\".  This history casts a long shadow,\n+                            // with \"gcc\". This history casts a long shadow,\n                             // and many modern illumos distributions today\n                             // ship GCC as \"gcc\" without also making it\n                             // available as \"cc\"."}, {"sha": "eaf1e9817c2038a7934948e9b5fffb50fafa48ce", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -544,7 +544,7 @@ impl<'a> Linker for GccLinker<'a> {\n         // link times negatively.\n         //\n         // -dead_strip can't be part of the pre_link_args because it's also used\n-        // for partial linking when using multiple codegen units (-r).  So we\n+        // for partial linking when using multiple codegen units (-r). So we\n         // insert it here.\n         if self.sess.target.is_like_osx {\n             self.linker_arg(\"-dead_strip\");"}, {"sha": "9f1614af7b16c9a232546c56ab9f5d5016c22472", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -105,7 +105,7 @@ pub struct ModuleConfig {\n     pub emit_thin_lto: bool,\n     pub bc_cmdline: String,\n \n-    // Miscellaneous flags.  These are mostly copied from command-line\n+    // Miscellaneous flags. These are mostly copied from command-line\n     // options.\n     pub verify_llvm_ir: bool,\n     pub no_prepopulate_passes: bool,\n@@ -538,7 +538,7 @@ fn produce_final_output_artifacts(\n \n     let copy_if_one_unit = |output_type: OutputType, keep_numbered: bool| {\n         if compiled_modules.modules.len() == 1 {\n-            // 1) Only one codegen unit.  In this case it's no difficulty\n+            // 1) Only one codegen unit. In this case it's no difficulty\n             //    to copy `foo.0.x` to `foo.x`.\n             let module_name = Some(&compiled_modules.modules[0].name[..]);\n             let path = crate_output.temp_path(output_type, module_name);\n@@ -557,15 +557,15 @@ fn produce_final_output_artifacts(\n                 .to_owned();\n \n             if crate_output.outputs.contains_key(&output_type) {\n-                // 2) Multiple codegen units, with `--emit foo=some_name`.  We have\n+                // 2) Multiple codegen units, with `--emit foo=some_name`. We have\n                 //    no good solution for this case, so warn the user.\n                 sess.emit_warning(errors::IgnoringEmitPath { extension });\n             } else if crate_output.single_output_file.is_some() {\n-                // 3) Multiple codegen units, with `-o some_name`.  We have\n+                // 3) Multiple codegen units, with `-o some_name`. We have\n                 //    no good solution for this case, so warn the user.\n                 sess.emit_warning(errors::IgnoringOutput { extension });\n             } else {\n-                // 4) Multiple codegen units, but no explicit name.  We\n+                // 4) Multiple codegen units, but no explicit name. We\n                 //    just leave the `foo.0.x` files in place.\n                 // (We don't have to do any work in this case.)\n             }\n@@ -579,7 +579,7 @@ fn produce_final_output_artifacts(\n         match *output_type {\n             OutputType::Bitcode => {\n                 user_wants_bitcode = true;\n-                // Copy to .bc, but always keep the .0.bc.  There is a later\n+                // Copy to .bc, but always keep the .0.bc. There is a later\n                 // check to figure out if we should delete .0.bc files, or keep\n                 // them for making an rlib.\n                 copy_if_one_unit(OutputType::Bitcode, true);\n@@ -611,7 +611,7 @@ fn produce_final_output_artifacts(\n     // `-C save-temps` or `--emit=` flags).\n \n     if !sess.opts.cg.save_temps {\n-        // Remove the temporary .#module-name#.o objects.  If the user didn't\n+        // Remove the temporary .#module-name#.o objects. If the user didn't\n         // explicitly request bitcode (with --emit=bc), and the bitcode is not\n         // needed for building an rlib, then we must remove .#module-name#.bc as\n         // well.\n@@ -1098,7 +1098,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     // There are a few environmental pre-conditions that shape how the system\n     // is set up:\n     //\n-    // - Error reporting only can happen on the main thread because that's the\n+    // - Error reporting can only happen on the main thread because that's the\n     //   only place where we have access to the compiler `Session`.\n     // - LLVM work can be done on any thread.\n     // - Codegen can only happen on the main thread.\n@@ -1110,16 +1110,16 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     // Error Reporting\n     // ===============\n     // The error reporting restriction is handled separately from the rest: We\n-    // set up a `SharedEmitter` the holds an open channel to the main thread.\n+    // set up a `SharedEmitter` that holds an open channel to the main thread.\n     // When an error occurs on any thread, the shared emitter will send the\n     // error message to the receiver main thread (`SharedEmitterMain`). The\n     // main thread will periodically query this error message queue and emit\n     // any error messages it has received. It might even abort compilation if\n-    // has received a fatal error. In this case we rely on all other threads\n+    // it has received a fatal error. In this case we rely on all other threads\n     // being torn down automatically with the main thread.\n     // Since the main thread will often be busy doing codegen work, error\n     // reporting will be somewhat delayed, since the message queue can only be\n-    // checked in between to work packages.\n+    // checked in between two work packages.\n     //\n     // Work Processing Infrastructure\n     // ==============================\n@@ -1133,7 +1133,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     // thread about what work to do when, and it will spawn off LLVM worker\n     // threads as open LLVM WorkItems become available.\n     //\n-    // The job of the main thread is to codegen CGUs into LLVM work package\n+    // The job of the main thread is to codegen CGUs into LLVM work packages\n     // (since the main thread is the only thread that can do this). The main\n     // thread will block until it receives a message from the coordinator, upon\n     // which it will codegen one CGU, send it to the coordinator and block\n@@ -1142,10 +1142,10 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     //\n     // The coordinator keeps a queue of LLVM WorkItems, and when a `Token` is\n     // available, it will spawn off a new LLVM worker thread and let it process\n-    // that a WorkItem. When a LLVM worker thread is done with its WorkItem,\n+    // a WorkItem. When a LLVM worker thread is done with its WorkItem,\n     // it will just shut down, which also frees all resources associated with\n     // the given LLVM module, and sends a message to the coordinator that the\n-    // has been completed.\n+    // WorkItem has been completed.\n     //\n     // Work Scheduling\n     // ===============\n@@ -1165,7 +1165,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     //\n     // Doing LLVM Work on the Main Thread\n     // ----------------------------------\n-    // Since the main thread owns the compiler processes implicit `Token`, it is\n+    // Since the main thread owns the compiler process's implicit `Token`, it is\n     // wasteful to keep it blocked without doing any work. Therefore, what we do\n     // in this case is: We spawn off an additional LLVM worker thread that helps\n     // reduce the queue. The work it is doing corresponds to the implicit\n@@ -1216,7 +1216,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     // ------------------------------\n     //\n     // The final job the coordinator thread is responsible for is managing LTO\n-    // and how that works. When LTO is requested what we'll to is collect all\n+    // and how that works. When LTO is requested what we'll do is collect all\n     // optimized LLVM modules into a local vector on the coordinator. Once all\n     // modules have been codegened and optimized we hand this to the `lto`\n     // module for further optimization. The `lto` module will return back a list"}, {"sha": "f7312f6fcdafdc6d0d90539fa70042a9fbd7f7c8", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -153,9 +153,7 @@ pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         (\n             &ty::Dynamic(ref data_a, _, src_dyn_kind),\n             &ty::Dynamic(ref data_b, _, target_dyn_kind),\n-        ) => {\n-            assert_eq!(src_dyn_kind, target_dyn_kind);\n-\n+        ) if src_dyn_kind == target_dyn_kind => {\n             let old_info =\n                 old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n             if data_a.principal_def_id() == data_b.principal_def_id() {"}, {"sha": "8808ad2dcd135ab3c009656beb2bd6f9cf9f67d9", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -658,13 +658,13 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n         sole_meta_list\n     {\n         // According to the table at https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#import-header,\n-        // the ordinal must fit into 16 bits.  Similarly, the Ordinal field in COFFShortExport (defined\n+        // the ordinal must fit into 16 bits. Similarly, the Ordinal field in COFFShortExport (defined\n         // in llvm/include/llvm/Object/COFFImportFile.h), which we use to communicate import information\n         // to LLVM for `#[link(kind = \"raw-dylib\"_])`, is also defined to be uint16_t.\n         //\n         // FIXME: should we allow an ordinal of 0?  The MSVC toolchain has inconsistent support for this:\n         // both LINK.EXE and LIB.EXE signal errors and abort when given a .DEF file that specifies\n-        // a zero ordinal.  However, llvm-dlltool is perfectly happy to generate an import library\n+        // a zero ordinal. However, llvm-dlltool is perfectly happy to generate an import library\n         // for such a .DEF file, and MSVC's LINK.EXE is also perfectly happy to consume an import\n         // library produced by LLVM with an ordinal of 0, and it generates an .EXE.  (I don't know yet\n         // if the resulting EXE runs, as I haven't yet built the necessary DLL -- see earlier comment"}, {"sha": "dd1ac2c74aed4fe2d628ffc17958f407a3a0a461", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -261,6 +261,9 @@ impl CleanupKind {\n     }\n }\n \n+/// MSVC requires unwinding code to be split to a tree of *funclets*, where each funclet can only\n+/// branch to itself or to its parent. Luckily, the code we generates matches this pattern.\n+/// Recover that structure in an analyze pass.\n pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKind> {\n     fn discover_masters<'tcx>(\n         result: &mut IndexVec<mir::BasicBlock, CleanupKind>,"}, {"sha": "e9bc40c33107706b6167373a5ace60f8b8ac6a2b", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -57,9 +57,9 @@ pub struct DebugScope<S, L> {\n }\n \n impl<'tcx, S: Copy, L: Copy> DebugScope<S, L> {\n-    /// DILocations inherit source file name from the parent DIScope.  Due to macro expansions\n+    /// DILocations inherit source file name from the parent DIScope. Due to macro expansions\n     /// it may so happen that the current span belongs to a different file than the DIScope\n-    /// corresponding to span's containing source scope.  If so, we need to create a DIScope\n+    /// corresponding to span's containing source scope. If so, we need to create a DIScope\n     /// \"extension\" into that file.\n     pub fn adjust_dbg_scope_for_span<Cx: CodegenMethods<'tcx, DIScope = S, DILocation = L>>(\n         &self,"}, {"sha": "739963fffd132b217c25d6f083805563aa99c2b7", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -187,7 +187,7 @@ const X86_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"bmi2\", None),\n     (\"cmpxchg16b\", Some(sym::cmpxchg16b_target_feature)),\n     (\"ermsb\", Some(sym::ermsb_target_feature)),\n-    (\"f16c\", Some(sym::f16c_target_feature)),\n+    (\"f16c\", None),\n     (\"fma\", None),\n     (\"fxsr\", None),\n     (\"gfni\", Some(sym::avx512_target_feature)),\n@@ -396,7 +396,6 @@ pub fn from_target_feature(\n                 Some(sym::cmpxchg16b_target_feature) => rust_features.cmpxchg16b_target_feature,\n                 Some(sym::movbe_target_feature) => rust_features.movbe_target_feature,\n                 Some(sym::rtm_target_feature) => rust_features.rtm_target_feature,\n-                Some(sym::f16c_target_feature) => rust_features.f16c_target_feature,\n                 Some(sym::ermsb_target_feature) => rust_features.ermsb_target_feature,\n                 Some(sym::bpf_target_feature) => rust_features.bpf_target_feature,\n                 Some(sym::aarch64_ver_target_feature) => rust_features.aarch64_ver_target_feature,"}, {"sha": "351c701305adc022b1c24dcf59ecf2e4ff2c8764", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -41,6 +41,7 @@ fn constness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Constness {\n             };\n             if is_const { hir::Constness::Const } else { hir::Constness::NotConst }\n         }\n+        hir::Node::Expr(e) if let hir::ExprKind::Closure(c) = e.kind => c.constness,\n         _ => {\n             if let Some(fn_kind) = node.fn_kind() {\n                 if fn_kind.constness() == hir::Constness::Const {"}, {"sha": "4f7c1fc96f13f1e770235f0cdbb369447efa3029", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -408,7 +408,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         // Only check non-glue functions\n         if let ty::InstanceDef::Item(def) = instance.def {\n             // Execution might have wandered off into other crates, so we cannot do a stability-\n-            // sensitive check here.  But we can at least rule out functions that are not const\n+            // sensitive check here. But we can at least rule out functions that are not const\n             // at all.\n             if !ecx.tcx.is_const_fn_raw(def.did) {\n                 // allow calling functions inside a trait marked with #[const_trait]."}, {"sha": "d13fed7a9c2631fa366200f8686433831c9d558b", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -196,7 +196,7 @@ impl<'tcx, Prov: Provenance + 'static> LocalState<'tcx, Prov> {\n         }\n     }\n \n-    /// Overwrite the local.  If the local can be overwritten in place, return a reference\n+    /// Overwrite the local. If the local can be overwritten in place, return a reference\n     /// to do so; otherwise return the `MemPlace` to consult instead.\n     ///\n     /// Note: This may only be invoked from the `Machine::access_local_mut` hook and not from\n@@ -592,7 +592,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 );\n \n                 // Recurse to get the size of the dynamically sized field (must be\n-                // the last field).  Can't have foreign types here, how would we\n+                // the last field). Can't have foreign types here, how would we\n                 // adjust alignment and size for them?\n                 let field = layout.field(self, layout.fields.count() - 1);\n                 let Some((unsized_size, mut unsized_align)) = self.size_and_align_of(metadata, &field)? else {"}, {"sha": "54528b1dbf4a0e252fe90929b9c1945ae43ca3a5", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -59,7 +59,7 @@ struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_ev\n \n #[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n enum InternMode {\n-    /// A static and its current mutability.  Below shared references inside a `static mut`,\n+    /// A static and its current mutability. Below shared references inside a `static mut`,\n     /// this is *immutable*, and below mutable references inside an `UnsafeCell`, this\n     /// is *mutable*.\n     Static(hir::Mutability),\n@@ -296,7 +296,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n                         }\n                     }\n                     InternMode::Const => {\n-                        // Ignore `UnsafeCell`, everything is immutable.  Validity does some sanity\n+                        // Ignore `UnsafeCell`, everything is immutable. Validity does some sanity\n                         // checking for mutable references that we encounter -- they must all be\n                         // ZST.\n                         InternMode::Const\n@@ -330,7 +330,7 @@ pub enum InternKind {\n \n /// Intern `ret` and everything it references.\n ///\n-/// This *cannot raise an interpreter error*.  Doing so is left to validation, which\n+/// This *cannot raise an interpreter error*. Doing so is left to validation, which\n /// tracks where in the value we are and thus can show much better error messages.\n #[instrument(level = \"debug\", skip(ecx))]\n pub fn intern_const_alloc_recursive<\n@@ -379,7 +379,7 @@ pub fn intern_const_alloc_recursive<\n             inside_unsafe_cell: false,\n         }\n         .visit_value(&mplace);\n-        // We deliberately *ignore* interpreter errors here.  When there is a problem, the remaining\n+        // We deliberately *ignore* interpreter errors here. When there is a problem, the remaining\n         // references are \"leftover\"-interned, and later validation will show a proper error\n         // and point at the right part of the value causing the problem.\n         match res {\n@@ -454,7 +454,7 @@ pub fn intern_const_alloc_recursive<\n             return Err(reported);\n         } else if ecx.tcx.try_get_global_alloc(alloc_id).is_none() {\n             // We have hit an `AllocId` that is neither in local or global memory and isn't\n-            // marked as dangling by local memory.  That should be impossible.\n+            // marked as dangling by local memory. That should be impossible.\n             span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);\n         }\n     }"}, {"sha": "248953de8672828a7889da54697268517eddd90e", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -180,7 +180,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>>;\n \n-    /// Execute `fn_val`.  It is the hook's responsibility to advance the instruction\n+    /// Execute `fn_val`. It is the hook's responsibility to advance the instruction\n     /// pointer as appropriate.\n     fn call_extra_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n@@ -439,7 +439,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n }\n \n /// A lot of the flexibility above is just needed for `Miri`, but all \"compile-time\" machines\n-/// (CTFE and ConstProp) use the same instance.  Here, we share that code.\n+/// (CTFE and ConstProp) use the same instance. Here, we share that code.\n pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     type Provenance = AllocId;\n     type ProvenanceExtra = ();"}, {"sha": "2f31bfc91005ef3302571ab0137a503f71c3d2bf", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -146,7 +146,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Call this to turn untagged \"global\" pointers (obtained via `tcx`) into\n-    /// the machine pointer to the allocation.  Must never be used\n+    /// the machine pointer to the allocation. Must never be used\n     /// for any other pointers, nor for TLS statics.\n     ///\n     /// Using the resulting pointer represents a *direct* access to that memory\n@@ -536,7 +536,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &Allocation<M::Provenance, M::AllocExtra>> {\n-        // The error type of the inner closure here is somewhat funny.  We have two\n+        // The error type of the inner closure here is somewhat funny. We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n         // `get_global_alloc` that we can actually use directly without inserting anything anywhere.\n         // So the error type is `InterpResult<'tcx, &Allocation<M::Provenance>>`."}, {"sha": "7e93f1b8ef51f7ee128f8f86f5c150125a32bc97", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -488,7 +488,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(OpTy { op, layout: place.layout, align: Some(place.align) })\n     }\n \n-    /// Evaluate a place with the goal of reading from it.  This lets us sometimes\n+    /// Evaluate a place with the goal of reading from it. This lets us sometimes\n     /// avoid allocations.\n     pub fn eval_place_to_op(\n         &self,"}, {"sha": "274af61ee7c1d5899b1d2d8b3a2700c912d9a0fa", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -233,7 +233,7 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n                 _ => bug!(\"len not supported on unsized type {:?}\", self.layout.ty),\n             }\n         } else {\n-            // Go through the layout.  There are lots of types that support a length,\n+            // Go through the layout. There are lots of types that support a length,\n             // e.g., SIMD types. (But not all repr(simd) types even have FieldsShape::Array!)\n             match self.layout.fields {\n                 abi::FieldsShape::Array { count, .. } => Ok(count),\n@@ -294,7 +294,7 @@ where\n     M: Machine<'mir, 'tcx, Provenance = Prov>,\n {\n     /// Take a value, which represents a (thin or wide) reference, and make it a place.\n-    /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n+    /// Alignment is just based on the type. This is the inverse of `MemPlace::to_ref()`.\n     ///\n     /// Only call this if you are sure the place is \"valid\" (aligned and inbounds), or do not\n     /// want to ever use the place for memory access!\n@@ -703,7 +703,7 @@ where\n                     &mut Operand::Immediate(local_val) => {\n                         // We need to make an allocation.\n \n-                        // We need the layout of the local.  We can NOT use the layout we got,\n+                        // We need the layout of the local. We can NOT use the layout we got,\n                         // that might e.g., be an inner field of a struct with `Scalar` layout,\n                         // that has different alignment than the outer field.\n                         let local_layout ="}, {"sha": "da320cd1cd5f0c6444b1ce8a8d56fffe2e776c78", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -446,7 +446,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // they go to.\n \n                     // For where they come from: If the ABI is RustCall, we untuple the\n-                    // last incoming argument.  These two iterators do not have the same type,\n+                    // last incoming argument. These two iterators do not have the same type,\n                     // so to keep the code paths uniform we accept an allocation\n                     // (for RustCall ABI only).\n                     let caller_args: Cow<'_, [OpTy<'tcx, M::Provenance>]> =\n@@ -481,7 +481,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         .filter(|arg_and_abi| !matches!(arg_and_abi.1.mode, PassMode::Ignore));\n \n                     // Now we have to spread them out across the callee's locals,\n-                    // taking into account the `spread_arg`.  If we could write\n+                    // taking into account the `spread_arg`. If we could write\n                     // this is a single iterator (that handles `spread_arg`), then\n                     // `pass_argument` would be the loop body. It takes care to\n                     // not advance `caller_iter` for ZSTs.\n@@ -648,8 +648,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"drop_in_place: {:?},\\n  {:?}, {:?}\", *place, place.layout.ty, instance);\n-        // We take the address of the object.  This may well be unaligned, which is fine\n-        // for us here.  However, unaligned accesses will probably make the actual drop\n+        // We take the address of the object. This may well be unaligned, which is fine\n+        // for us here. However, unaligned accesses will probably make the actual drop\n         // implementation fail -- a problem shared by rustc.\n         let place = self.force_allocation(place)?;\n "}, {"sha": "a61d3ab40a5ca1c0efa4c9d1339ef95bf38be99b", "filename": "compiler/rustc_const_eval/src/interpret/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -40,12 +40,11 @@ where\n                         let index = index\n                             .try_into()\n                             .expect(\"more generic parameters than can fit into a `u32`\");\n-                        let is_used = unused_params.contains(index).map_or(true, |unused| !unused);\n                         // Only recurse when generic parameters in fns, closures and generators\n                         // are used and require substitution.\n                         // Just in case there are closures or generators within this subst,\n                         // recurse.\n-                        if is_used && subst.needs_subst() {\n+                        if unused_params.is_used(index) && subst.needs_subst() {\n                             return subst.visit_with(self);\n                         }\n                     }"}, {"sha": "43bea23b651e90472d3420af05c6991b600f43d1", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -175,7 +175,7 @@ fn write_path(out: &mut String, path: &[PathElem]) {\n             TupleElem(idx) => write!(out, \".{}\", idx),\n             ArrayElem(idx) => write!(out, \"[{}]\", idx),\n             // `.<deref>` does not match Rust syntax, but it is more readable for long paths -- and\n-            // some of the other items here also are not Rust syntax.  Actually we can't\n+            // some of the other items here also are not Rust syntax. Actually we can't\n             // even use the usual syntax because we are just showing the projections,\n             // not the root.\n             Deref => write!(out, \".<deref>\"),\n@@ -484,7 +484,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     }\n \n     /// Check if this is a value of primitive type, and if yes check the validity of the value\n-    /// at that type.  Return `true` if the type is indeed primitive.\n+    /// at that type. Return `true` if the type is indeed primitive.\n     fn try_visit_primitive(\n         &mut self,\n         value: &OpTy<'tcx, M::Provenance>,\n@@ -623,7 +623,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // Can only happen during CTFE.\n                 // We support 2 kinds of ranges here: full range, and excluding zero.\n                 if start == 1 && end == max_value {\n-                    // Only null is the niche.  So make sure the ptr is NOT null.\n+                    // Only null is the niche. So make sure the ptr is NOT null.\n                     if self.ecx.scalar_may_be_null(scalar)? {\n                         throw_validation_failure!(self.path,\n                             { \"a potentially null pointer\" }\n@@ -759,7 +759,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // Recursively walk the value at its type.\n         self.walk_value(op)?;\n \n-        // *After* all of this, check the ABI.  We need to check the ABI to handle\n+        // *After* all of this, check the ABI. We need to check the ABI to handle\n         // types like `NonNull` where the `Scalar` info is more restrictive than what\n         // the fields say (`rustc_layout_scalar_valid_range_start`).\n         // But in most cases, this will just propagate what the fields say,\n@@ -857,10 +857,10 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // Optimization: we just check the entire range at once.\n                 // NOTE: Keep this in sync with the handling of integer and float\n                 // types above, in `visit_primitive`.\n-                // In run-time mode, we accept pointers in here.  This is actually more\n+                // In run-time mode, we accept pointers in here. This is actually more\n                 // permissive than a per-element check would be, e.g., we accept\n                 // a &[u8] that contains a pointer even though bytewise checking would\n-                // reject it.  However, that's good: We don't inherently want\n+                // reject it. However, that's good: We don't inherently want\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n                 // We also accept uninit, for consistency with the slow path."}, {"sha": "46e7b09a55e109c61f24eabb844437a13dcd1d1d", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -20,6 +20,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(trusted_step)]\n #![feature(try_blocks)]\n #![feature(yeet_expr)]\n+#![feature(if_let_guard)]\n #![feature(is_some_and)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "d4c75cd55ce1e4fe89170c96bffe7fcc8b7d88b8", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -242,7 +242,7 @@ impl<'mir, 'tcx> Checker<'mir, 'tcx> {\n             // impl trait is gone in MIR, so check the return type of a const fn by its signature\n             // instead of the type of the return place.\n             self.span = body.local_decls[RETURN_PLACE].source_info.span;\n-            let return_ty = tcx.fn_sig(def_id).output();\n+            let return_ty = self.ccx.fn_sig().output();\n             self.check_local_or_return_ty(return_ty.skip_binder(), RETURN_PLACE);\n         }\n \n@@ -730,6 +730,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                             substs,\n                             span: *fn_span,\n                             from_hir_call: *from_hir_call,\n+                            feature: Some(sym::const_trait_impl),\n                         });\n                         return;\n                     }\n@@ -782,6 +783,20 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                             );\n                             return;\n                         }\n+                        Ok(Some(ImplSource::Closure(data))) => {\n+                            if !tcx.is_const_fn_raw(data.closure_def_id) {\n+                                self.check_op(ops::FnCallNonConst {\n+                                    caller,\n+                                    callee,\n+                                    substs,\n+                                    span: *fn_span,\n+                                    from_hir_call: *from_hir_call,\n+                                    feature: None,\n+                                });\n+\n+                                return;\n+                            }\n+                        }\n                         Ok(Some(ImplSource::UserDefined(data))) => {\n                             let callee_name = tcx.item_name(callee);\n                             if let Some(&did) = tcx\n@@ -802,6 +817,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                                     substs,\n                                     span: *fn_span,\n                                     from_hir_call: *from_hir_call,\n+                                    feature: None,\n                                 });\n                                 return;\n                             }\n@@ -844,6 +860,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                                     substs,\n                                     span: *fn_span,\n                                     from_hir_call: *from_hir_call,\n+                                    feature: None,\n                                 });\n                                 return;\n                             }\n@@ -903,6 +920,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                             substs,\n                             span: *fn_span,\n                             from_hir_call: *from_hir_call,\n+                            feature: None,\n                         });\n                         return;\n                     }"}, {"sha": "54868e418c4b3f5bb5ff91c1851778598450a135", "filename": "compiler/rustc_const_eval/src/transform/check_consts/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -8,7 +8,7 @@ use rustc_attr as attr;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::mir;\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::{self, PolyFnSig, TyCtxt};\n use rustc_span::Symbol;\n \n pub use self::qualifs::Qualif;\n@@ -64,6 +64,17 @@ impl<'mir, 'tcx> ConstCx<'mir, 'tcx> {\n     fn is_async(&self) -> bool {\n         self.tcx.asyncness(self.def_id()).is_async()\n     }\n+\n+    pub fn fn_sig(&self) -> PolyFnSig<'tcx> {\n+        let did = self.def_id().to_def_id();\n+        if self.tcx.is_closure(did) {\n+            let ty = self.tcx.type_of(did);\n+            let ty::Closure(_, substs) = ty.kind() else { bug!(\"type_of closure not ty::Closure\") };\n+            substs.as_closure().sig()\n+        } else {\n+            self.tcx.fn_sig(did)\n+        }\n+    }\n }\n \n pub fn rustc_allow_const_fn_unstable("}, {"sha": "0cb5d2ff8c7193f21db958018b5732df9a26957c", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -111,6 +111,7 @@ pub struct FnCallNonConst<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n     pub span: Span,\n     pub from_hir_call: bool,\n+    pub feature: Option<Symbol>,\n }\n \n impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n@@ -119,7 +120,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n         ccx: &ConstCx<'_, 'tcx>,\n         _: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let FnCallNonConst { caller, callee, substs, span, from_hir_call } = *self;\n+        let FnCallNonConst { caller, callee, substs, span, from_hir_call, feature } = *self;\n         let ConstCx { tcx, param_env, .. } = *ccx;\n \n         let diag_trait = |err, self_ty: Ty<'_>, trait_id| {\n@@ -318,6 +319,13 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n             ccx.const_kind(),\n         ));\n \n+        if let Some(feature) = feature && ccx.tcx.sess.is_nightly_build() {\n+            err.help(&format!(\n+                \"add `#![feature({})]` to the crate attributes to enable\",\n+                feature,\n+            ));\n+        }\n+\n         if let ConstContext::Static(_) = ccx.const_kind() {\n             err.note(\"consider wrapping this expression in `Lazy::new(|| ...)` from the `once_cell` crate: https://crates.io/crates/once_cell\");\n         }"}, {"sha": "cf4e875c91f0b57b12abcf2ad4dee083e10fbd77", "filename": "compiler/rustc_const_eval/src/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -95,7 +95,7 @@ impl<'tcx> Visitor<'tcx> for CheckLiveDrops<'_, 'tcx> {\n                 }\n \n                 // Drop elaboration is not precise enough to accept code like\n-                // `src/test/ui/consts/control-flow/drop-pass.rs`; e.g., when an `Option<Vec<T>>` is\n+                // `tests/ui/consts/control-flow/drop-pass.rs`; e.g., when an `Option<Vec<T>>` is\n                 // initialized with `None` and never changed, it still emits drop glue.\n                 // Hence we additionally check the qualifs here to allow more code to pass.\n                 if self.qualifs.needs_non_const_drop(self.ccx, dropped_place.local, location) {"}, {"sha": "f5f3d5de6b5a2f15088c28e0399ac5a3ca324d8e", "filename": "compiler/rustc_const_eval/src/util/compare_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -58,6 +58,6 @@ pub fn is_subtype<'tcx>(\n     // even if they're constrained in our current function.\n     //\n     // It seems very unlikely that this hides any bugs.\n-    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+    let _ = infcx.take_opaque_types();\n     errors.is_empty()\n }"}, {"sha": "73190574667f32135a490a3f717a777c72037793", "filename": "compiler/rustc_data_structures/src/frozen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_data_structures%2Fsrc%2Ffrozen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_data_structures%2Fsrc%2Ffrozen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffrozen.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -36,7 +36,7 @@\n //! ```\n //!\n //! `Frozen` impls `Deref`, so we can ergonomically call methods on `Bar`, but it doesn't `impl\n-//! DerefMut`.  Now calling `foo.compute.mutate()` will result in a compile-time error stating that\n+//! DerefMut`. Now calling `foo.compute.mutate()` will result in a compile-time error stating that\n //! `mutate` requires a mutable reference but we don't have one.\n //!\n //! # Caveats"}, {"sha": "820a70fc8e446c8094763ee5ad25db9f3e9c6cc9", "filename": "compiler/rustc_data_structures/src/graph/scc/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -84,7 +84,7 @@ fn test_find_state_2() {\n     // 0 -> 1 -> 2 -> 1\n     //\n     // and at this point detect a cycle. The state of 2 will thus be\n-    // `InCycleWith { 1 }`.  We will then visit the 1 -> 3 edge, which\n+    // `InCycleWith { 1 }`. We will then visit the 1 -> 3 edge, which\n     // will attempt to visit 0 as well, thus going to the state\n     // `InCycleWith { 0 }`. Finally, node 1 will complete; the lowest\n     // depth of any successor was 3 which had depth 0, and thus it"}, {"sha": "9a0fd52677d13ff10e50e6f73c0e8b3f964f76ca", "filename": "compiler/rustc_data_structures/src/steal.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_data_structures%2Fsrc%2Fsteal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_data_structures%2Fsrc%2Fsteal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsteal.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -40,6 +40,11 @@ impl<T> Steal<T> {\n         ReadGuard::map(borrow, |opt| opt.as_ref().unwrap())\n     }\n \n+    #[track_caller]\n+    pub fn get_mut(&mut self) -> &mut T {\n+        self.value.get_mut().as_mut().expect(\"attempt to read from stolen value\")\n+    }\n+\n     #[track_caller]\n     pub fn steal(&self) -> T {\n         let value_ref = &mut *self.value.try_write().expect(\"stealing value which is locked\");"}, {"sha": "cd391fe357a6f0b76f9975649bd6898fe547bf43", "filename": "compiler/rustc_data_structures/src/transitive_relation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -250,7 +250,7 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n             // values. So here is what we do:\n             //\n             // 1. Find the vector `[X | a < X && b < X]` of all values\n-            //    `X` where `a < X` and `b < X`.  In terms of the\n+            //    `X` where `a < X` and `b < X`. In terms of the\n             //    graph, this means all values reachable from both `a`\n             //    and `b`. Note that this vector is also a set, but we\n             //    use the term vector because the order matters"}, {"sha": "6d7fba36fb3d071f182ab20a105e485a0f2efc47", "filename": "compiler/rustc_driver/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_driver%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_driver%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FREADME.md?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,5 +1,5 @@\n The `driver` crate is effectively the \"main\" function for the rust\n-compiler.  It orchestrates the compilation process and \"knits together\"\n+compiler. It orchestrates the compilation process and \"knits together\"\n the code from the other crates within rustc. This crate itself does\n not contain any of the \"main logic\" of the compiler (though it does\n have some code related to pretty printing or other minor compiler"}, {"sha": "16f64235562f119d3f020e487e51a5f5b3c046fd", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -309,8 +309,8 @@ fn run_compiler(\n \n             if let Some(ppm) = &sess.opts.pretty {\n                 if ppm.needs_ast_map() {\n-                    let expanded_crate = queries.expansion()?.peek().0.clone();\n-                    queries.global_ctxt()?.peek_mut().enter(|tcx| {\n+                    let expanded_crate = queries.expansion()?.borrow().0.clone();\n+                    queries.global_ctxt()?.enter(|tcx| {\n                         pretty::print_after_hir_lowering(\n                             tcx,\n                             compiler.input(),\n@@ -321,7 +321,7 @@ fn run_compiler(\n                         Ok(())\n                     })?;\n                 } else {\n-                    let krate = queries.parse()?.take();\n+                    let krate = queries.parse()?.steal();\n                     pretty::print_after_parsing(\n                         sess,\n                         compiler.input(),\n@@ -343,7 +343,8 @@ fn run_compiler(\n             }\n \n             {\n-                let (_, lint_store) = &*queries.register_plugins()?.peek();\n+                let plugins = queries.register_plugins()?;\n+                let (_, lint_store) = &*plugins.borrow();\n \n                 // Lint plugins are registered; now we can process command line flags.\n                 if sess.opts.describe_lints {\n@@ -371,7 +372,7 @@ fn run_compiler(\n                 return early_exit();\n             }\n \n-            queries.global_ctxt()?.peek_mut().enter(|tcx| {\n+            queries.global_ctxt()?.enter(|tcx| {\n                 let result = tcx.analysis(());\n                 if sess.opts.unstable_opts.save_analysis {\n                     let crate_name = tcx.crate_name(LOCAL_CRATE);\n@@ -1196,8 +1197,8 @@ static DEFAULT_HOOK: LazyLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send +\n             };\n \n             // Invoke the default handler, which prints the actual panic message and optionally a backtrace\n-            // Don't do this for `GoodPathBug`, which already emits its own more useful backtrace.\n-            if !info.payload().is::<rustc_errors::GoodPathBug>() {\n+            // Don't do this for delayed bugs, which already emit their own more useful backtrace.\n+            if !info.payload().is::<rustc_errors::DelayedBugPanic>() {\n                 (*DEFAULT_HOOK)(info);\n \n                 // Separate the output with an empty line\n@@ -1235,7 +1236,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     // a .span_bug or .bug call has already printed what\n     // it wants to print.\n     if !info.payload().is::<rustc_errors::ExplicitBug>()\n-        && !info.payload().is::<rustc_errors::GoodPathBug>()\n+        && !info.payload().is::<rustc_errors::DelayedBugPanic>()\n     {\n         let mut d = rustc_errors::Diagnostic::new(rustc_errors::Level::Bug, \"unexpected panic\");\n         handler.emit_diagnostic(&mut d);"}, {"sha": "2746396b75abdfa7062f0d44cb207aa83399fd14", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,5 +1,5 @@\n-// Error messages for EXXXX errors.  Each message should start and end with a\n-// new line, and be wrapped to 80 characters.  In vim you can `:set tw=80` and\n+// Error messages for EXXXX errors. Each message should start and end with a\n+// new line, and be wrapped to 80 characters. In vim you can `:set tw=80` and\n // use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n //\n // /!\\ IMPORTANT /!\\\n@@ -110,6 +110,7 @@ E0204: include_str!(\"./error_codes/E0204.md\"),\n E0205: include_str!(\"./error_codes/E0205.md\"),\n E0206: include_str!(\"./error_codes/E0206.md\"),\n E0207: include_str!(\"./error_codes/E0207.md\"),\n+E0208: include_str!(\"./error_codes/E0208.md\"),\n E0210: include_str!(\"./error_codes/E0210.md\"),\n E0211: include_str!(\"./error_codes/E0211.md\"),\n E0212: include_str!(\"./error_codes/E0212.md\"),\n@@ -387,6 +388,7 @@ E0636: include_str!(\"./error_codes/E0636.md\"),\n E0637: include_str!(\"./error_codes/E0637.md\"),\n E0638: include_str!(\"./error_codes/E0638.md\"),\n E0639: include_str!(\"./error_codes/E0639.md\"),\n+E0640: include_str!(\"./error_codes/E0640.md\"),\n E0641: include_str!(\"./error_codes/E0641.md\"),\n E0642: include_str!(\"./error_codes/E0642.md\"),\n E0643: include_str!(\"./error_codes/E0643.md\"),\n@@ -434,6 +436,8 @@ E0713: include_str!(\"./error_codes/E0713.md\"),\n E0714: include_str!(\"./error_codes/E0714.md\"),\n E0715: include_str!(\"./error_codes/E0715.md\"),\n E0716: include_str!(\"./error_codes/E0716.md\"),\n+E0711: include_str!(\"./error_codes/E0711.md\"),\n+E0717: include_str!(\"./error_codes/E0717.md\"),\n E0718: include_str!(\"./error_codes/E0718.md\"),\n E0719: include_str!(\"./error_codes/E0719.md\"),\n E0720: include_str!(\"./error_codes/E0720.md\"),\n@@ -540,7 +544,6 @@ E0791: include_str!(\"./error_codes/E0791.md\"),\n //  E0190, // deprecated: can only cast a &-pointer to an &-object\n //  E0194, // merged into E0403\n //  E0196, // cannot determine a type for this closure\n-    E0208, // internal error code\n //  E0209, // builtin traits can only be implemented on structs or enums\n //  E0213, // associated types are not accepted in this context\n //  E0215, // angle-bracket notation is not stable with `Fn`\n@@ -571,7 +574,7 @@ E0791: include_str!(\"./error_codes/E0791.md\"),\n //  E0274, // on_unimplemented #2\n //  E0278, // requirement is not satisfied\n //  E0279,\n-    E0280, // requirement is not satisfied\n+//  E0280, // changed to ICE\n //  E0285, // overflow evaluation builtin bounds\n //  E0296, // replaced with a generic attribute input check\n //  E0298, // cannot compare constants\n@@ -615,7 +618,7 @@ E0791: include_str!(\"./error_codes/E0791.md\"),\n //  E0487, // unsafe use of destructor: destructor might be called while...\n //  E0488, // lifetime of variable does not enclose its declaration\n //  E0489, // type/lifetime parameter not in scope here\n-    E0490, // a value of type `..` is borrowed for too long\n+//  E0490, // removed: unreachable\n     E0523, // two dependencies have same (crate-name, disambiguator) but different SVH\n //  E0526, // shuffle indices are not constant\n //  E0540, // multiple rustc_deprecated attributes\n@@ -633,14 +636,11 @@ E0791: include_str!(\"./error_codes/E0791.md\"),\n //  E0629, // missing 'feature' (rustc_const_unstable)\n //  E0630, // rustc_const_unstable attribute must be paired with stable/unstable\n            // attribute\n-    E0640, // infer outlives requirements, internal error code\n //  E0645, // trait aliases not finished\n //  E0694, // an unknown tool name found in scoped attributes\n //  E0702, // replaced with a generic attribute input check\n //  E0707, // multiple elided lifetimes used in arguments of `async fn`\n //  E0709, // multiple different lifetimes used in arguments of `async fn`\n-    E0711, // a feature has been declared with conflicting stability attributes, internal error code\n-    E0717, // rustc_promotable without stability attribute, internal error code\n //  E0721, // `await` keyword\n //  E0723, // unstable feature in `const` context\n //  E0738, // Removed; errored on `#[track_caller] fn`s in `extern \"Rust\" { ... }`."}, {"sha": "7edd93e56a945e4e9096efee47c07e9f14b1a410", "filename": "compiler/rustc_error_codes/src/error_codes/E0208.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0208.md", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0208.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0208.md?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -0,0 +1 @@\n+#### This error code is internal to the compiler and will not be emitted with normal Rust code."}, {"sha": "1c62d410efe4799503ce55a0087140ed15a1ed59", "filename": "compiler/rustc_error_codes/src/error_codes/E0387.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0387.md", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0387.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0387.md?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -17,7 +17,7 @@ fn mutable() {\n     foo(|| x = 2);\n }\n \n-// Attempts to take a mutable reference to closed-over data.  Error message\n+// Attempts to take a mutable reference to closed-over data. Error message\n // reads: `cannot borrow data mutably in a captured outer variable...`\n fn mut_addr() {\n     let mut x = 0u32;"}, {"sha": "7edd93e56a945e4e9096efee47c07e9f14b1a410", "filename": "compiler/rustc_error_codes/src/error_codes/E0640.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0640.md", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0640.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0640.md?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -0,0 +1 @@\n+#### This error code is internal to the compiler and will not be emitted with normal Rust code."}, {"sha": "a2150037f7856d53644d9192b25ae3c7cc311960", "filename": "compiler/rustc_error_codes/src/error_codes/E0711.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0711.md", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0711.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0711.md?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -0,0 +1,30 @@\n+#### This error code is internal to the compiler and will not be emitted with normal Rust code.\n+\n+Feature declared with conflicting stability requirements.\n+\n+```compile_fail,E0711\n+// NOTE: this attribute is perma-unstable and should *never* be used outside of\n+//       stdlib and the compiler.\n+#![feature(staged_api)]\n+\n+#![stable(feature = \"...\", since = \"1.0.0\")]\n+\n+#[stable(feature = \"foo\", since = \"1.0.0\")]\n+fn foo_stable_1_0_0() {}\n+\n+// error: feature `foo` is declared stable since 1.29.0\n+#[stable(feature = \"foo\", since = \"1.29.0\")]\n+fn foo_stable_1_29_0() {}\n+\n+// error: feature `foo` is declared unstable\n+#[unstable(feature = \"foo\", issue = \"none\")]\n+fn foo_unstable() {}\n+```\n+\n+In the above example, the `foo` feature is first defined to be stable since\n+1.0.0, but is then re-declared stable since 1.29.0. This discrepancy in\n+versions causes an error. Furthermore, `foo` is then re-declared as unstable,\n+again the conflict causes an error.\n+\n+This error can be fixed by splitting the feature, this allows any\n+stability requirements and removes any possibility of conflict."}, {"sha": "a7b9bbeb122f70fcbc03c15dd4f33ad4b4d52ab2", "filename": "compiler/rustc_error_codes/src/error_codes/E0713.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0713.md", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0713.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0713.md?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -22,7 +22,7 @@ gets called when they go out of scope. This destructor gets exclusive\n access to the fields of the struct when it runs.\n \n This means that when `s` reaches the end of `demo`, its destructor\n-gets exclusive access to its `&mut`-borrowed string data.  allowing\n+gets exclusive access to its `&mut`-borrowed string data. allowing\n another borrow of that string data (`p`), to exist across the drop of\n `s` would be a violation of the principle that `&mut`-borrows have\n exclusive, unaliased access to their referenced data."}, {"sha": "b75735d602e053677ebcdc2efb7c6338a1d87910", "filename": "compiler/rustc_error_codes/src/error_codes/E0714.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0714.md", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0714.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0714.md?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -15,5 +15,5 @@ fn main() {}\n ```\n \n The items of marker traits cannot be overridden, so there's no need to have them\n-when they cannot be changed per-type anyway.  If you wanted them for ergonomic\n+when they cannot be changed per-type anyway. If you wanted them for ergonomic\n reasons, consider making an extension trait instead."}, {"sha": "7edd93e56a945e4e9096efee47c07e9f14b1a410", "filename": "compiler/rustc_error_codes/src/error_codes/E0717.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0717.md", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0717.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0717.md?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -0,0 +1 @@\n+#### This error code is internal to the compiler and will not be emitted with normal Rust code."}, {"sha": "41f458f6c1785e31a83dec0c9de3efc6cc00bb60", "filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -120,3 +120,7 @@ hir_analysis_self_in_impl_self =\n \n hir_analysis_linkage_type =\n     invalid type for variable with `#[linkage]` attribute\n+\n+hir_analysis_auto_deref_reached_recursion_limit = reached the recursion limit while auto-dereferencing `{$ty}`\n+    .label = deref recursion limit reached\n+    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)"}, {"sha": "ae0091b03736f3b6c78343ae5d7487ab7b12606a", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -101,7 +101,6 @@ infer_subtype_2 = ...so that {$requirement ->\n infer_reborrow = ...so that reference does not outlive borrowed content\n infer_reborrow_upvar = ...so that closure can access `{$name}`\n infer_relate_object_bound = ...so that it can be closed over into an object\n-infer_data_borrowed = ...so that the type `{$name}` is not borrowed for too long\n infer_reference_outlives_referent = ...so that the reference type `{$name}` does not outlive the data it points at\n infer_relate_param_bound = ...so that the type `{$name}` will meet its required lifetime bounds{$continues ->\n     [true] ..."}, {"sha": "d63ff77d8e2558bd5decf85363d07b90258c6bef", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -15,6 +15,43 @@ lint_enum_intrinsics_mem_variant =\n \n lint_expectation = this lint expectation is unfulfilled\n     .note = the `unfulfilled_lint_expectations` lint can't be expected and will always produce this message\n+    .rationale = {$rationale}\n+\n+lint_for_loops_over_fallibles =\n+    for loop over {$article} `{$ty}`. This is more readably written as an `if let` statement\n+    .suggestion = consider using `if let` to clear intent\n+    .remove_next = to iterate over `{$recv_snip}` remove the call to `next`\n+    .use_while_let = to check pattern in a loop use `while let`\n+    .use_question_mark = consider unwrapping the `Result` with `?` to iterate over its contents\n+\n+lint_non_binding_let_on_sync_lock =\n+    non-binding let on a synchronization lock\n+\n+lint_non_binding_let_on_drop_type =\n+    non-binding let on a type that implements `Drop`\n+\n+lint_non_binding_let_suggestion =\n+    consider binding to an unused variable to avoid immediately dropping the value\n+\n+lint_non_binding_let_multi_suggestion =\n+    consider immediately dropping the value\n+\n+lint_deprecated_lint_name =\n+    lint name `{$name}` is deprecated and may not have an effect in the future.\n+    .suggestion = change it to\n+\n+lint_renamed_or_removed_lint = {$msg}\n+    .suggestion = use the new name\n+\n+lint_unknown_lint =\n+    unknown lint: `{$name}`\n+    .suggestion = did you mean\n+\n+lint_ignored_unless_crate_specified = {$level}({$name}) is ignored unless specified at crate level\n+\n+lint_unknown_gated_lint =\n+    unknown lint: `{$name}`\n+    .note = the `{$name}` lint is unstable\n \n lint_hidden_unicode_codepoints = unicode codepoint changing visible direction of text present in {$label}\n     .label = this {$label} contains {$count ->\n@@ -55,6 +92,8 @@ lint_diag_out_of_impl =\n \n lint_untranslatable_diag = diagnostics should be created using translatable messages\n \n+lint_bad_opt_access = {$msg}\n+\n lint_cstring_ptr = getting the inner pointer of a temporary `CString`\n     .as_ptr_label = this pointer will be invalid\n     .unwrap_label = this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\n@@ -331,6 +370,8 @@ lint_builtin_anonymous_params = anonymous parameters are deprecated and will be\n     .suggestion = try naming the parameter or explicitly ignoring it\n \n lint_builtin_deprecated_attr_link = use of deprecated attribute `{$name}`: {$reason}. See {$link}\n+    .msg_suggestion = {$msg}\n+    .default_suggestion = remove this attribute\n lint_builtin_deprecated_attr_used = use of deprecated attribute `{$name}`: no longer used.\n lint_builtin_deprecated_attr_default_suggestion = remove this attribute\n \n@@ -391,10 +432,16 @@ lint_builtin_incomplete_features = the feature `{$name}` is incomplete and may n\n     .note = see issue #{$n} <https://github.com/rust-lang/rust/issues/{$n}> for more information\n     .help = consider using `min_{$name}` instead, which is more stable and complete\n \n-lint_builtin_clashing_extern_same_name = `{$this_fi}` redeclared with a different signature\n+lint_builtin_unpermitted_type_init_zeroed = the type `{$ty}` does not permit zero-initialization\n+lint_builtin_unpermitted_type_init_unint = the type `{$ty}` does not permit being left uninitialized\n+\n+lint_builtin_unpermitted_type_init_label = this code causes undefined behavior when executed\n+lint_builtin_unpermitted_type_init_label_suggestion = help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+\n+lint_builtin_clashing_extern_same_name = `{$this}` redeclared with a different signature\n     .previous_decl_label = `{$orig}` previously declared here\n     .mismatch_label = this signature doesn't match the previous declaration\n-lint_builtin_clashing_extern_diff_name = `{$this_fi}` redeclares `{$orig}` with a different signature\n+lint_builtin_clashing_extern_diff_name = `{$this}` redeclares `{$orig}` with a different signature\n     .previous_decl_label = `{$orig}` previously declared here\n     .mismatch_label = this signature doesn't match the previous declaration\n \n@@ -403,6 +450,16 @@ lint_builtin_deref_nullptr = dereferencing a null pointer\n \n lint_builtin_asm_labels = avoid using named labels in inline assembly\n \n+lint_builtin_special_module_name_used_lib = found module declaration for lib.rs\n+    .note = lib.rs is the root of this crate's library target\n+    .help = to refer to it from other targets, use the library's name as the path\n+\n+lint_builtin_special_module_name_used_main = found module declaration for main.rs\n+    .note = a binary crate cannot be used as library\n+\n+lint_supertrait_as_deref_target = `{$t}` implements `Deref` with supertrait `{$target_principal}` as target\n+    .label = target type is set here\n+\n lint_overruled_attribute = {$lint_level}({$lint_source}) incompatible with previous forbid\n     .label = overruled by previous forbid\n "}, {"sha": "a082c0b61fa7ed293b873b9e054f7f9e1481957e", "filename": "compiler/rustc_error_messages/locales/en-US/mir_build.ftl", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -206,6 +206,10 @@ mir_build_lower_range_bound_must_be_less_than_or_equal_to_upper =\n     .label = lower bound larger than upper bound\n     .teach_note = When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.\n \n+mir_build_literal_in_range_out_of_bounds =\n+    literal out of range for `{$ty}`\n+    .label = this value doesn't fit in `{$ty}` whose maximum value is `{$max}`\n+\n mir_build_lower_range_bound_must_be_less_than_upper = lower range bound must be less than upper\n \n mir_build_leading_irrefutable_let_patterns = leading irrefutable {$count ->\n@@ -299,3 +303,64 @@ mir_build_multiple_mut_borrows = cannot borrow value as mutable more than once a\n     .mutable_borrow = another mutable borrow, by `{$name_mut}`, occurs here\n     .immutable_borrow = also borrowed as immutable, by `{$name_immut}`, here\n     .moved = also moved into `{$name_moved}` here\n+\n+mir_build_union_pattern = cannot use unions in constant patterns\n+\n+mir_build_type_not_structural =\n+     to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+mir_build_unsized_pattern = cannot use unsized non-slice type `{$non_sm_ty}` in constant patterns\n+\n+mir_build_invalid_pattern = `{$non_sm_ty}` cannot be used in patterns\n+\n+mir_build_float_pattern = floating-point types cannot be used in patterns\n+\n+mir_build_pointer_pattern = function pointers and unsized pointers in patterns behave unpredictably and should not be relied upon. See https://github.com/rust-lang/rust/issues/70861 for details.\n+\n+mir_build_indirect_structural_match =\n+    to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+mir_build_nontrivial_structural_match =\n+    to use a constant of type `{$non_sm_ty}` in a pattern, the constant's initializer must be trivial or `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n+\n+mir_build_overlapping_range_endpoints = multiple patterns overlap on their endpoints\n+    .range = ... with this range\n+    .note = you likely meant to write mutually exclusive ranges\n+\n+mir_build_non_exhaustive_omitted_pattern = some variants are not matched explicitly\n+    .help = ensure that all variants are matched explicitly by adding the suggested match arms\n+    .note = the matched value is of type `{$scrut_ty}` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+mir_build_uncovered = {$count ->\n+        [1] pattern `{$witness_1}`\n+        [2] patterns `{$witness_1}` and `{$witness_2}`\n+        [3] patterns `{$witness_1}`, `{$witness_2}` and `{$witness_3}`\n+        *[other] patterns `{$witness_1}`, `{$witness_2}`, `{$witness_3}` and {$remainder} more\n+    } not covered\n+\n+mir_build_pattern_not_covered = refutable pattern in {$origin}\n+    .pattern_ty = the matched value is of type `{$pattern_ty}`\n+\n+mir_build_inform_irrefutable = `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+\n+mir_build_more_information = for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+\n+mir_build_res_defined_here = {$res} defined here\n+\n+mir_build_adt_defined_here = `{$ty}` defined here\n+\n+mir_build_variant_defined_here = not covered\n+\n+mir_build_interpreted_as_const = introduce a variable instead\n+\n+mir_build_confused = missing patterns are not covered because `{$variable}` is interpreted as {$article} {$res} pattern, not a new variable\n+\n+mir_build_suggest_if_let = you might want to use `if let` to ignore the {$count ->\n+        [one] variant that isn't\n+        *[other] variants that aren't\n+    } matched\n+\n+mir_build_suggest_let_else = you might want to use `let else` to handle the {$count ->\n+        [one] variant that isn't\n+        *[other] variants that aren't\n+    } matched"}, {"sha": "8f063f5082c9541c249b722fc2f9090ad4046d7b", "filename": "compiler/rustc_error_messages/locales/en-US/parse.ftl", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -2,6 +2,10 @@ parse_struct_literal_body_without_path =\n     struct literal body without path\n     .suggestion = you might have forgotten to add the struct literal inside the block\n \n+parse_struct_literal_needing_parens =\n+    invalid struct literal\n+    .suggestion = you might need to surround the struct literal in parentheses\n+\n parse_maybe_report_ambiguous_plus =\n     ambiguous `+` in a type\n     .suggestion = use parentheses to disambiguate\n@@ -368,3 +372,9 @@ parse_maybe_fn_typo_with_impl = you might have meant to write `impl` instead of\n \n parse_expected_fn_path_found_fn_keyword = expected identifier, found keyword `fn`\n     .suggestion = use `Fn` to refer to the trait\n+\n+parse_where_clause_before_tuple_struct_body = where clauses are not allowed before tuple struct bodies\n+    .label = unexpected where clause\n+    .name_label = while parsing this tuple struct\n+    .body_label = the struct body\n+    .suggestion = move the body before the where clause"}, {"sha": "14eb4a5502d5c2f2df139f117eba5e09f5793cf9", "filename": "compiler/rustc_error_messages/locales/en-US/trait_selection.ftl", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftrait_selection.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftrait_selection.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftrait_selection.ftl?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -2,10 +2,6 @@ trait_selection_dump_vtable_entries = vtable entries for `{$trait_ref}`: {$entri\n \n trait_selection_unable_to_construct_constant_value = unable to construct a constant value for the unevaluated constant {$unevaluated}\n \n-trait_selection_auto_deref_reached_recursion_limit = reached the recursion limit while auto-dereferencing `{$ty}`\n-    .label = deref recursion limit reached\n-    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n-\n trait_selection_empty_on_clause_in_rustc_on_unimplemented = empty `on`-clause in `#[rustc_on_unimplemented]`\n     .label = empty on-clause here\n "}, {"sha": "51b2ff6a003812c01fb5f7e3762539cfa5d10c63", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -114,9 +114,9 @@ pub struct Diagnostic {\n     pub suggestions: Result<Vec<CodeSuggestion>, SuggestionsDisabled>,\n     args: FxHashMap<DiagnosticArgName<'static>, DiagnosticArgValue<'static>>,\n \n-    /// This is not used for highlighting or rendering any error message.  Rather, it can be used\n-    /// as a sort key to sort a buffer of diagnostics.  By default, it is the primary span of\n-    /// `span` if there is one.  Otherwise, it is `DUMMY_SP`.\n+    /// This is not used for highlighting or rendering any error message. Rather, it can be used\n+    /// as a sort key to sort a buffer of diagnostics. By default, it is the primary span of\n+    /// `span` if there is one. Otherwise, it is `DUMMY_SP`.\n     pub sort_span: Span,\n \n     /// If diagnostic is from Lint, custom hash function ignores notes"}, {"sha": "dad5e98aac021b250e9ee1c48f32d937666a9e54", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -179,16 +179,7 @@ impl IntoDiagnosticArg for type_ir::FloatTy {\n \n impl IntoDiagnosticArg for Level {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Borrowed(match self {\n-            Level::Allow => \"-A\",\n-            Level::Warn => \"-W\",\n-            Level::ForceWarn(_) => \"--force-warn\",\n-            Level::Deny => \"-D\",\n-            Level::Forbid => \"-F\",\n-            Level::Expect(_) => {\n-                unreachable!(\"lints with the level of `expect` should not run this code\");\n-            }\n-        }))\n+        DiagnosticArgValue::Str(Cow::Borrowed(self.to_cmd_flag()))\n     }\n }\n "}, {"sha": "628e199992152937392392452603f05f8662ff62", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -28,6 +28,7 @@ use rustc_error_messages::{FluentArgs, SpanLabel};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use std::borrow::Cow;\n use std::cmp::{max, min, Reverse};\n+use std::error::Report;\n use std::io::prelude::*;\n use std::io::{self, IsTerminal};\n use std::iter;\n@@ -250,7 +251,7 @@ pub trait Emitter: Translate {\n         let mut primary_span = diag.span.clone();\n         let suggestions = diag.suggestions.as_deref().unwrap_or(&[]);\n         if let Some((sugg, rest)) = suggestions.split_first() {\n-            let msg = self.translate_message(&sugg.msg, fluent_args);\n+            let msg = self.translate_message(&sugg.msg, fluent_args).map_err(Report::new).unwrap();\n             if rest.is_empty() &&\n                // ^ if there is only one suggestion\n                // don't display multi-suggestions as labels\n@@ -1325,7 +1326,7 @@ impl EmitterWriter {\n         //                very *weird* formats\n         //                see?\n         for (text, style) in msg.iter() {\n-            let text = self.translate_message(text, args);\n+            let text = self.translate_message(text, args).map_err(Report::new).unwrap();\n             let lines = text.split('\\n').collect::<Vec<_>>();\n             if lines.len() > 1 {\n                 for (i, line) in lines.iter().enumerate() {\n@@ -1387,7 +1388,7 @@ impl EmitterWriter {\n                 label_width += 2;\n             }\n             for (text, _) in msg.iter() {\n-                let text = self.translate_message(text, args);\n+                let text = self.translate_message(text, args).map_err(Report::new).unwrap();\n                 // Account for newlines to align output to its label.\n                 for (line, text) in normalize_whitespace(&text).lines().enumerate() {\n                     buffer.append(\n@@ -1790,7 +1791,7 @@ impl EmitterWriter {\n \n             if let Some(span) = span.primary_span() {\n                 // Compare the primary span of the diagnostic with the span of the suggestion\n-                // being emitted.  If they belong to the same file, we don't *need* to show the\n+                // being emitted. If they belong to the same file, we don't *need* to show the\n                 // file name, saving in verbosity, but if it *isn't* we do need it, otherwise we're\n                 // telling users to make a change but not clarifying *where*.\n                 let loc = sm.lookup_char_pos(parts[0].span.lo());\n@@ -2301,7 +2302,9 @@ impl FileWithAnnotatedLines {\n                     hi.col_display += 1;\n                 }\n \n-                let label = label.as_ref().map(|m| emitter.translate_message(m, args).to_string());\n+                let label = label.as_ref().map(|m| {\n+                    emitter.translate_message(m, args).map_err(Report::new).unwrap().to_string()\n+                });\n \n                 if lo.line != hi.line {\n                     let ml = MultilineAnnotation {\n@@ -2526,11 +2529,11 @@ fn emit_to_destination(\n     //\n     // On Unix systems, we write into a buffered terminal rather than directly to a terminal. When\n     // the .flush() is called we take the buffer created from the buffered writes and write it at\n-    // one shot.  Because the Unix systems use ANSI for the colors, which is a text-based styling\n+    // one shot. Because the Unix systems use ANSI for the colors, which is a text-based styling\n     // scheme, this buffered approach works and maintains the styling.\n     //\n     // On Windows, styling happens through calls to a terminal API. This prevents us from using the\n-    // same buffering approach.  Instead, we use a global Windows mutex, which we acquire long\n+    // same buffering approach. Instead, we use a global Windows mutex, which we acquire long\n     // enough to output the full error message, then we release.\n     let _buffer_lock = lock::acquire_global_lock(\"rustc_errors\");\n     for (pos, line) in rendered_buffer.iter().enumerate() {"}, {"sha": "ec0a2fe8cd8d010bf0d1fc5a4c32a88bf15aa32c", "filename": "compiler/rustc_errors/src/error.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ferror.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -0,0 +1,137 @@\n+use rustc_error_messages::{\n+    fluent_bundle::resolver::errors::{ReferenceKind, ResolverError},\n+    FluentArgs, FluentError,\n+};\n+use std::borrow::Cow;\n+use std::error::Error;\n+use std::fmt;\n+\n+#[derive(Debug)]\n+pub enum TranslateError<'args> {\n+    One {\n+        id: &'args Cow<'args, str>,\n+        args: &'args FluentArgs<'args>,\n+        kind: TranslateErrorKind<'args>,\n+    },\n+    Two {\n+        primary: Box<TranslateError<'args>>,\n+        fallback: Box<TranslateError<'args>>,\n+    },\n+}\n+\n+impl<'args> TranslateError<'args> {\n+    pub fn message(id: &'args Cow<'args, str>, args: &'args FluentArgs<'args>) -> Self {\n+        Self::One { id, args, kind: TranslateErrorKind::MessageMissing }\n+    }\n+    pub fn primary(id: &'args Cow<'args, str>, args: &'args FluentArgs<'args>) -> Self {\n+        Self::One { id, args, kind: TranslateErrorKind::PrimaryBundleMissing }\n+    }\n+    pub fn attribute(\n+        id: &'args Cow<'args, str>,\n+        args: &'args FluentArgs<'args>,\n+        attr: &'args str,\n+    ) -> Self {\n+        Self::One { id, args, kind: TranslateErrorKind::AttributeMissing { attr } }\n+    }\n+    pub fn value(id: &'args Cow<'args, str>, args: &'args FluentArgs<'args>) -> Self {\n+        Self::One { id, args, kind: TranslateErrorKind::ValueMissing }\n+    }\n+\n+    pub fn fluent(\n+        id: &'args Cow<'args, str>,\n+        args: &'args FluentArgs<'args>,\n+        errs: Vec<FluentError>,\n+    ) -> Self {\n+        Self::One { id, args, kind: TranslateErrorKind::Fluent { errs } }\n+    }\n+\n+    pub fn and(self, fallback: TranslateError<'args>) -> TranslateError<'args> {\n+        Self::Two { primary: Box::new(self), fallback: Box::new(fallback) }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum TranslateErrorKind<'args> {\n+    MessageMissing,\n+    PrimaryBundleMissing,\n+    AttributeMissing { attr: &'args str },\n+    ValueMissing,\n+    Fluent { errs: Vec<FluentError> },\n+}\n+\n+impl fmt::Display for TranslateError<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use TranslateErrorKind::*;\n+\n+        match self {\n+            Self::One { id, args, kind } => {\n+                writeln!(f, \"failed while formatting fluent string `{id}`: \")?;\n+                match kind {\n+                    MessageMissing => writeln!(f, \"message was missing\")?,\n+                    PrimaryBundleMissing => writeln!(f, \"the primary bundle was missing\")?,\n+                    AttributeMissing { attr } => {\n+                        writeln!(f, \"the attribute `{attr}` was missing\")?;\n+                        writeln!(f, \"help: add `.{attr} = <message>`\")?;\n+                    }\n+                    ValueMissing => writeln!(f, \"the value was missing\")?,\n+                    Fluent { errs } => {\n+                        for err in errs {\n+                            match err {\n+                                FluentError::ResolverError(ResolverError::Reference(\n+                                    ReferenceKind::Message { id, .. }\n+                                    | ReferenceKind::Variable { id, .. },\n+                                )) => {\n+                                    if args.iter().any(|(arg_id, _)| arg_id == id) {\n+                                        writeln!(\n+                                            f,\n+                                            \"argument `{id}` exists but was not referenced correctly\"\n+                                        )?;\n+                                        writeln!(f, \"help: try using `{{${id}}}` instead\")?;\n+                                    } else {\n+                                        writeln!(\n+                                            f,\n+                                            \"the fluent string has an argument `{id}` that was not found.\"\n+                                        )?;\n+                                        let vars: Vec<&str> =\n+                                            args.iter().map(|(a, _v)| a).collect();\n+                                        match &*vars {\n+                                            [] => writeln!(f, \"help: no arguments are available\")?,\n+                                            [one] => writeln!(\n+                                                f,\n+                                                \"help: the argument `{one}` is available\"\n+                                            )?,\n+                                            [first, middle @ .., last] => {\n+                                                write!(f, \"help: the arguments `{first}`\")?;\n+                                                for a in middle {\n+                                                    write!(f, \", `{a}`\")?;\n+                                                }\n+                                                writeln!(f, \" and `{last}` are available\")?;\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                _ => writeln!(f, \"{err}\")?,\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            // If someone cares about primary bundles, they'll probably notice it's missing\n+            // regardless or will be using `debug_assertions`\n+            // so we skip the arm below this one to avoid confusing the regular user.\n+            Self::Two { primary: box Self::One { kind: PrimaryBundleMissing, .. }, fallback } => {\n+                fmt::Display::fmt(fallback, f)?;\n+            }\n+            Self::Two { primary, fallback } => {\n+                writeln!(\n+                    f,\n+                    \"first, fluent formatting using the primary bundle failed:\\n {primary}\\n \\\n+                    while attempting to recover by using the fallback bundle instead, another error occurred:\\n{fallback}\"\n+                )?;\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl Error for TranslateError<'_> {}"}, {"sha": "dc38b8725ad1e94ef2d29e94b82a0cd19a8357a2", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -24,6 +24,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_error_messages::FluentArgs;\n use rustc_span::hygiene::ExpnData;\n use rustc_span::Span;\n+use std::error::Report;\n use std::io::{self, Write};\n use std::path::Path;\n use std::sync::{Arc, Mutex};\n@@ -321,7 +322,8 @@ impl Diagnostic {\n     fn from_errors_diagnostic(diag: &crate::Diagnostic, je: &JsonEmitter) -> Diagnostic {\n         let args = to_fluent_args(diag.args());\n         let sugg = diag.suggestions.iter().flatten().map(|sugg| {\n-            let translated_message = je.translate_message(&sugg.msg, &args);\n+            let translated_message =\n+                je.translate_message(&sugg.msg, &args).map_err(Report::new).unwrap();\n             Diagnostic {\n                 message: translated_message.to_string(),\n                 code: None,\n@@ -411,7 +413,10 @@ impl DiagnosticSpan {\n         Self::from_span_etc(\n             span.span,\n             span.is_primary,\n-            span.label.as_ref().map(|m| je.translate_message(m, args)).map(|m| m.to_string()),\n+            span.label\n+                .as_ref()\n+                .map(|m| je.translate_message(m, args).unwrap())\n+                .map(|m| m.to_string()),\n             suggestion,\n             je,\n         )"}, {"sha": "535812fb0e228f7e413c219293395bdbde4ad7f7", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -11,6 +11,10 @@\n #![feature(never_type)]\n #![feature(result_option_inspect)]\n #![feature(rustc_attrs)]\n+#![feature(yeet_expr)]\n+#![feature(try_blocks)]\n+#![feature(box_patterns)]\n+#![feature(error_reporter)]\n #![allow(incomplete_features)]\n \n #[macro_use]\n@@ -40,8 +44,8 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::HashStableContext;\n use rustc_span::{Loc, Span};\n \n-use std::any::Any;\n use std::borrow::Cow;\n+use std::error::Report;\n use std::fmt;\n use std::hash::Hash;\n use std::num::NonZeroUsize;\n@@ -55,11 +59,14 @@ mod diagnostic;\n mod diagnostic_builder;\n mod diagnostic_impls;\n pub mod emitter;\n+pub mod error;\n pub mod json;\n mod lock;\n pub mod registry;\n mod snippet;\n mod styled_buffer;\n+#[cfg(test)]\n+mod tests;\n pub mod translation;\n \n pub use diagnostic_builder::IntoDiagnostic;\n@@ -364,9 +371,9 @@ pub use rustc_span::fatal_error::{FatalError, FatalErrorMarker};\n /// or `.span_bug` rather than a failed assertion, etc.\n pub struct ExplicitBug;\n \n-/// Signifies that the compiler died with an explicit call to `.delay_good_path_bug`\n+/// Signifies that the compiler died with an explicit call to `.delay_*_bug`\n /// rather than a failed assertion, etc.\n-pub struct GoodPathBug;\n+pub struct DelayedBugPanic;\n \n pub use diagnostic::{\n     AddToDiagnostic, DecorateLint, Diagnostic, DiagnosticArg, DiagnosticArgValue, DiagnosticId,\n@@ -399,7 +406,7 @@ struct HandlerInner {\n     warn_count: usize,\n     deduplicated_err_count: usize,\n     emitter: Box<dyn Emitter + sync::Send>,\n-    delayed_span_bugs: Vec<Diagnostic>,\n+    delayed_span_bugs: Vec<DelayedDiagnostic>,\n     delayed_good_path_bugs: Vec<DelayedDiagnostic>,\n     /// This flag indicates that an expected diagnostic was emitted and suppressed.\n     /// This is used for the `delayed_good_path_bugs` check.\n@@ -505,11 +512,7 @@ impl Drop for HandlerInner {\n \n         if !self.has_errors() {\n             let bugs = std::mem::replace(&mut self.delayed_span_bugs, Vec::new());\n-            self.flush_delayed(\n-                bugs,\n-                \"no errors encountered even though `delay_span_bug` issued\",\n-                ExplicitBug,\n-            );\n+            self.flush_delayed(bugs, \"no errors encountered even though `delay_span_bug` issued\");\n         }\n \n         // FIXME(eddyb) this explains what `delayed_good_path_bugs` are!\n@@ -520,9 +523,8 @@ impl Drop for HandlerInner {\n         if !self.has_any_message() && !self.suppressed_expected_diag {\n             let bugs = std::mem::replace(&mut self.delayed_good_path_bugs, Vec::new());\n             self.flush_delayed(\n-                bugs.into_iter().map(DelayedDiagnostic::decorate),\n+                bugs,\n                 \"no warnings or errors encountered even though `delayed_good_path_bugs` issued\",\n-                GoodPathBug,\n             );\n         }\n \n@@ -622,7 +624,14 @@ impl Handler {\n     ) -> SubdiagnosticMessage {\n         let inner = self.inner.borrow();\n         let args = crate::translation::to_fluent_args(args);\n-        SubdiagnosticMessage::Eager(inner.emitter.translate_message(&message, &args).to_string())\n+        SubdiagnosticMessage::Eager(\n+            inner\n+                .emitter\n+                .translate_message(&message, &args)\n+                .map_err(Report::new)\n+                .unwrap()\n+                .to_string(),\n+        )\n     }\n \n     // This is here to not allow mutation of flags;\n@@ -1223,11 +1232,7 @@ impl Handler {\n     pub fn flush_delayed(&self) {\n         let mut inner = self.inner.lock();\n         let bugs = std::mem::replace(&mut inner.delayed_span_bugs, Vec::new());\n-        inner.flush_delayed(\n-            bugs,\n-            \"no errors encountered even though `delay_span_bug` issued\",\n-            ExplicitBug,\n-        );\n+        inner.flush_delayed(bugs, \"no errors encountered even though `delay_span_bug` issued\");\n     }\n }\n \n@@ -1287,7 +1292,9 @@ impl HandlerInner {\n             // once *any* errors were emitted (and truncate `delayed_span_bugs`\n             // when an error is first emitted, also), but maybe there's a case\n             // in which that's not sound? otherwise this is really inefficient.\n-            self.delayed_span_bugs.push(diagnostic.clone());\n+            let backtrace = std::backtrace::Backtrace::force_capture();\n+            self.delayed_span_bugs\n+                .push(DelayedDiagnostic::with_backtrace(diagnostic.clone(), backtrace));\n \n             if !self.flags.report_delayed_bugs {\n                 return Some(ErrorGuaranteed::unchecked_claim_error_was_emitted());\n@@ -1562,7 +1569,6 @@ impl HandlerInner {\n         }\n         let mut diagnostic = Diagnostic::new(Level::DelayedBug, msg);\n         diagnostic.set_span(sp.into());\n-        diagnostic.note(&format!(\"delayed at {}\", std::panic::Location::caller()));\n         self.emit_diagnostic(&mut diagnostic).unwrap()\n     }\n \n@@ -1605,12 +1611,13 @@ impl HandlerInner {\n \n     fn flush_delayed(\n         &mut self,\n-        bugs: impl IntoIterator<Item = Diagnostic>,\n+        bugs: impl IntoIterator<Item = DelayedDiagnostic>,\n         explanation: impl Into<DiagnosticMessage> + Copy,\n-        panic_with: impl Any + Send + 'static,\n     ) {\n         let mut no_bugs = true;\n-        for mut bug in bugs {\n+        for bug in bugs {\n+            let mut bug = bug.decorate();\n+\n             if no_bugs {\n                 // Put the overall explanation before the `DelayedBug`s, to\n                 // frame them better (e.g. separate warnings from them).\n@@ -1633,9 +1640,9 @@ impl HandlerInner {\n             self.emit_diagnostic(&mut bug);\n         }\n \n-        // Panic with `ExplicitBug` to avoid \"unexpected panic\" messages.\n+        // Panic with `DelayedBugPanic` to avoid \"unexpected panic\" messages.\n         if !no_bugs {\n-            panic::panic_any(panic_with);\n+            panic::panic_any(DelayedBugPanic);\n         }\n     }\n "}, {"sha": "52103e4609770b50f3ae767ffb8ac754c8439059", "filename": "compiler/rustc_errors/src/tests.rs", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftests.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -0,0 +1,188 @@\n+use crate::error::{TranslateError, TranslateErrorKind};\n+use crate::fluent_bundle::*;\n+use crate::translation::Translate;\n+use crate::FluentBundle;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_error_messages::fluent_bundle::resolver::errors::{ReferenceKind, ResolverError};\n+use rustc_error_messages::langid;\n+use rustc_error_messages::DiagnosticMessage;\n+\n+struct Dummy {\n+    bundle: FluentBundle,\n+}\n+\n+impl Translate for Dummy {\n+    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n+        None\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &FluentBundle {\n+        &self.bundle\n+    }\n+}\n+\n+fn make_dummy(ftl: &'static str) -> Dummy {\n+    let resource = FluentResource::try_new(ftl.into()).expect(\"Failed to parse an FTL string.\");\n+\n+    let langid_en = langid!(\"en-US\");\n+\n+    #[cfg(parallel_compiler)]\n+    let mut bundle = FluentBundle::new_concurrent(vec![langid_en]);\n+\n+    #[cfg(not(parallel_compiler))]\n+    let mut bundle = FluentBundle::new(vec![langid_en]);\n+\n+    bundle.add_resource(resource).expect(\"Failed to add FTL resources to the bundle.\");\n+\n+    Dummy { bundle }\n+}\n+\n+#[test]\n+fn wellformed_fluent() {\n+    let dummy = make_dummy(\"mir_build_borrow_of_moved_value = borrow of moved value\n+    .label = value moved into `{$name}` here\n+    .occurs_because_label = move occurs because `{$name}` has type `{$ty}` which does not implement the `Copy` trait\n+    .value_borrowed_label = value borrowed here after move\n+    .suggestion = borrow this binding in the pattern to avoid moving the value\");\n+\n+    let mut args = FluentArgs::new();\n+    args.set(\"name\", \"Foo\");\n+    args.set(\"ty\", \"std::string::String\");\n+    {\n+        let message = DiagnosticMessage::FluentIdentifier(\n+            \"mir_build_borrow_of_moved_value\".into(),\n+            Some(\"suggestion\".into()),\n+        );\n+\n+        assert_eq!(\n+            dummy.translate_message(&message, &args).unwrap(),\n+            \"borrow this binding in the pattern to avoid moving the value\"\n+        );\n+    }\n+\n+    {\n+        let message = DiagnosticMessage::FluentIdentifier(\n+            \"mir_build_borrow_of_moved_value\".into(),\n+            Some(\"value_borrowed_label\".into()),\n+        );\n+\n+        assert_eq!(\n+            dummy.translate_message(&message, &args).unwrap(),\n+            \"value borrowed here after move\"\n+        );\n+    }\n+\n+    {\n+        let message = DiagnosticMessage::FluentIdentifier(\n+            \"mir_build_borrow_of_moved_value\".into(),\n+            Some(\"occurs_because_label\".into()),\n+        );\n+\n+        assert_eq!(\n+            dummy.translate_message(&message, &args).unwrap(),\n+            \"move occurs because `\\u{2068}Foo\\u{2069}` has type `\\u{2068}std::string::String\\u{2069}` which does not implement the `Copy` trait\"\n+        );\n+\n+        {\n+            let message = DiagnosticMessage::FluentIdentifier(\n+                \"mir_build_borrow_of_moved_value\".into(),\n+                Some(\"label\".into()),\n+            );\n+\n+            assert_eq!(\n+                dummy.translate_message(&message, &args).unwrap(),\n+                \"value moved into `\\u{2068}Foo\\u{2069}` here\"\n+            );\n+        }\n+    }\n+}\n+\n+#[test]\n+fn misformed_fluent() {\n+    let dummy = make_dummy(\"mir_build_borrow_of_moved_value = borrow of moved value\n+    .label = value moved into `{name}` here\n+    .occurs_because_label = move occurs because `{$oops}` has type `{$ty}` which does not implement the `Copy` trait\n+    .suggestion = borrow this binding in the pattern to avoid moving the value\");\n+\n+    let mut args = FluentArgs::new();\n+    args.set(\"name\", \"Foo\");\n+    args.set(\"ty\", \"std::string::String\");\n+    {\n+        let message = DiagnosticMessage::FluentIdentifier(\n+            \"mir_build_borrow_of_moved_value\".into(),\n+            Some(\"value_borrowed_label\".into()),\n+        );\n+\n+        let err = dummy.translate_message(&message, &args).unwrap_err();\n+        assert!(\n+            matches!(\n+                &err,\n+                TranslateError::Two {\n+                    primary: box TranslateError::One {\n+                        kind: TranslateErrorKind::PrimaryBundleMissing,\n+                        ..\n+                    },\n+                    fallback: box TranslateError::One {\n+                        kind: TranslateErrorKind::AttributeMissing { attr: \"value_borrowed_label\" },\n+                        ..\n+                    }\n+                }\n+            ),\n+            \"{err:#?}\"\n+        );\n+        assert_eq!(\n+            format!(\"{err}\"),\n+            \"failed while formatting fluent string `mir_build_borrow_of_moved_value`: \\nthe attribute `value_borrowed_label` was missing\\nhelp: add `.value_borrowed_label = <message>`\\n\"\n+        );\n+    }\n+\n+    {\n+        let message = DiagnosticMessage::FluentIdentifier(\n+            \"mir_build_borrow_of_moved_value\".into(),\n+            Some(\"label\".into()),\n+        );\n+\n+        let err = dummy.translate_message(&message, &args).unwrap_err();\n+        if let TranslateError::Two {\n+            primary: box TranslateError::One { kind: TranslateErrorKind::PrimaryBundleMissing, .. },\n+            fallback: box TranslateError::One { kind: TranslateErrorKind::Fluent { errs }, .. },\n+        } = &err\n+            && let [FluentError::ResolverError(ResolverError::Reference(\n+                ReferenceKind::Message { id, .. }\n+                    | ReferenceKind::Variable { id, .. },\n+            ))] = &**errs\n+            && id == \"name\"\n+        {} else {\n+            panic!(\"{err:#?}\")\n+        };\n+        assert_eq!(\n+            format!(\"{err}\"),\n+            \"failed while formatting fluent string `mir_build_borrow_of_moved_value`: \\nargument `name` exists but was not referenced correctly\\nhelp: try using `{$name}` instead\\n\"\n+        );\n+    }\n+\n+    {\n+        let message = DiagnosticMessage::FluentIdentifier(\n+            \"mir_build_borrow_of_moved_value\".into(),\n+            Some(\"occurs_because_label\".into()),\n+        );\n+\n+        let err = dummy.translate_message(&message, &args).unwrap_err();\n+        if let TranslateError::Two {\n+            primary: box TranslateError::One { kind: TranslateErrorKind::PrimaryBundleMissing, .. },\n+            fallback: box TranslateError::One { kind: TranslateErrorKind::Fluent { errs }, .. },\n+        } = &err\n+            && let [FluentError::ResolverError(ResolverError::Reference(\n+                ReferenceKind::Message { id, .. }\n+                    | ReferenceKind::Variable { id, .. },\n+            ))] = &**errs\n+            && id == \"oops\"\n+        {} else {\n+            panic!(\"{err:#?}\")\n+        };\n+        assert_eq!(\n+            format!(\"{err}\"),\n+            \"failed while formatting fluent string `mir_build_borrow_of_moved_value`: \\nthe fluent string has an argument `oops` that was not found.\\nhelp: the arguments `name` and `ty` are available\\n\"\n+        );\n+    }\n+}"}, {"sha": "addfc9726ca445372aadeeae6f2a64aa0676d05c", "filename": "compiler/rustc_errors/src/translation.rs", "status": "modified", "additions": 46, "deletions": 71, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,11 +1,10 @@\n+use crate::error::TranslateError;\n use crate::snippet::Style;\n use crate::{DiagnosticArg, DiagnosticMessage, FluentBundle};\n use rustc_data_structures::sync::Lrc;\n-use rustc_error_messages::{\n-    fluent_bundle::resolver::errors::{ReferenceKind, ResolverError},\n-    FluentArgs, FluentError,\n-};\n+use rustc_error_messages::FluentArgs;\n use std::borrow::Cow;\n+use std::error::Report;\n \n /// Convert diagnostic arguments (a rustc internal type that exists to implement\n /// `Encodable`/`Decodable`) into `FluentArgs` which is necessary to perform translation.\n@@ -46,7 +45,10 @@ pub trait Translate {\n         args: &FluentArgs<'_>,\n     ) -> Cow<'_, str> {\n         Cow::Owned(\n-            messages.iter().map(|(m, _)| self.translate_message(m, args)).collect::<String>(),\n+            messages\n+                .iter()\n+                .map(|(m, _)| self.translate_message(m, args).map_err(Report::new).unwrap())\n+                .collect::<String>(),\n         )\n     }\n \n@@ -55,83 +57,56 @@ pub trait Translate {\n         &'a self,\n         message: &'a DiagnosticMessage,\n         args: &'a FluentArgs<'_>,\n-    ) -> Cow<'_, str> {\n+    ) -> Result<Cow<'_, str>, TranslateError<'_>> {\n         trace!(?message, ?args);\n         let (identifier, attr) = match message {\n             DiagnosticMessage::Str(msg) | DiagnosticMessage::Eager(msg) => {\n-                return Cow::Borrowed(msg);\n+                return Ok(Cow::Borrowed(msg));\n             }\n             DiagnosticMessage::FluentIdentifier(identifier, attr) => (identifier, attr),\n         };\n+        let translate_with_bundle =\n+            |bundle: &'a FluentBundle| -> Result<Cow<'_, str>, TranslateError<'_>> {\n+                let message = bundle\n+                    .get_message(identifier)\n+                    .ok_or(TranslateError::message(identifier, args))?;\n+                let value = match attr {\n+                    Some(attr) => message\n+                        .get_attribute(attr)\n+                        .ok_or(TranslateError::attribute(identifier, args, attr))?\n+                        .value(),\n+                    None => message.value().ok_or(TranslateError::value(identifier, args))?,\n+                };\n+                debug!(?message, ?value);\n \n-        let translate_with_bundle = |bundle: &'a FluentBundle| -> Option<(Cow<'_, str>, Vec<_>)> {\n-            let message = bundle.get_message(identifier)?;\n-            let value = match attr {\n-                Some(attr) => message.get_attribute(attr)?.value(),\n-                None => message.value()?,\n+                let mut errs = vec![];\n+                let translated = bundle.format_pattern(value, Some(args), &mut errs);\n+                debug!(?translated, ?errs);\n+                if errs.is_empty() {\n+                    Ok(translated)\n+                } else {\n+                    Err(TranslateError::fluent(identifier, args, errs))\n+                }\n             };\n-            debug!(?message, ?value);\n-\n-            let mut errs = vec![];\n-            let translated = bundle.format_pattern(value, Some(args), &mut errs);\n-            debug!(?translated, ?errs);\n-            Some((translated, errs))\n-        };\n \n-        self.fluent_bundle()\n-            .and_then(|bundle| translate_with_bundle(bundle))\n-            // If `translate_with_bundle` returns `None` with the primary bundle, this is likely\n-            // just that the primary bundle doesn't contain the message being translated, so\n-            // proceed to the fallback bundle.\n-            //\n-            // However, when errors are produced from translation, then that means the translation\n-            // is broken (e.g. `{$foo}` exists in a translation but `foo` isn't provided).\n-            //\n-            // In debug builds, assert so that compiler devs can spot the broken translation and\n-            // fix it..\n-            .inspect(|(_, errs)| {\n-                debug_assert!(\n-                    errs.is_empty(),\n-                    \"identifier: {:?}, attr: {:?}, args: {:?}, errors: {:?}\",\n-                    identifier,\n-                    attr,\n-                    args,\n-                    errs\n-                );\n-            })\n-            // ..otherwise, for end users, an error about this wouldn't be useful or actionable, so\n-            // just hide it and try with the fallback bundle.\n-            .filter(|(_, errs)| errs.is_empty())\n-            .or_else(|| translate_with_bundle(self.fallback_fluent_bundle()))\n-            .map(|(translated, errs)| {\n-                // Always bail out for errors with the fallback bundle.\n+        try {\n+            match self.fluent_bundle().map(|b| translate_with_bundle(b)) {\n+                // The primary bundle was present and translation succeeded\n+                Some(Ok(t)) => t,\n \n-                let mut help_messages = vec![];\n+                // Always yeet out for errors on debug\n+                Some(Err(primary)) if cfg!(debug_assertions) => do yeet primary,\n \n-                if !errs.is_empty() {\n-                    for error in &errs {\n-                        match error {\n-                            FluentError::ResolverError(ResolverError::Reference(\n-                                ReferenceKind::Message { id, .. },\n-                            )) if args.iter().any(|(arg_id, _)| arg_id == id) => {\n-                                help_messages.push(format!(\"Argument `{id}` exists but was not referenced correctly. Try using `{{${id}}}` instead\"));\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n+                // If `translate_with_bundle` returns `Err` with the primary bundle, this is likely\n+                // just that the primary bundle doesn't contain the message being translated or\n+                // something else went wrong) so proceed to the fallback bundle.\n+                Some(Err(primary)) => translate_with_bundle(self.fallback_fluent_bundle())\n+                    .map_err(|fallback| primary.and(fallback))?,\n \n-                    panic!(\n-                        \"Encountered errors while formatting message for `{identifier}`\\n\\\n-                        help: {}\\n\\\n-                        attr: `{attr:?}`\\n\\\n-                        args: `{args:?}`\\n\\\n-                        errors: `{errs:?}`\",\n-                        help_messages.join(\"\\nhelp: \")\n-                    );\n-                }\n-\n-                translated\n-            })\n-            .expect(\"failed to find message in primary or fallback fluent bundles\")\n+                // The primary bundle is missing, proceed to the fallback bundle\n+                None => translate_with_bundle(self.fallback_fluent_bundle())\n+                    .map_err(|fallback| TranslateError::primary(identifier, args).and(fallback))?,\n+            }\n+        }\n     }\n }"}, {"sha": "9b16e79d49a9e951042e6978f33e92d712195430", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -533,6 +533,7 @@ impl<'a> ExtCtxt<'a> {\n             ast::ExprKind::Closure(Box::new(ast::Closure {\n                 binder: ast::ClosureBinder::NotPresent,\n                 capture_clause: ast::CaptureBy::Ref,\n+                constness: ast::Const::No,\n                 asyncness: ast::Async::No,\n                 movability: ast::Movability::Movable,\n                 fn_decl,"}, {"sha": "bc298b0ad2b1e37f8d78faa0d3433edbe7bea88a", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -171,7 +171,7 @@ fn parse_tree(\n                     } else {\n                         match delim {\n                             Delimiter::Brace => {\n-                                // The delimiter is `{`.  This indicates the beginning\n+                                // The delimiter is `{`. This indicates the beginning\n                                 // of a meta-variable expression (e.g. `${count(ident)}`).\n                                 // Try to parse the meta-variable expression.\n                                 match MetaVarExpr::parse(&tts, delim_span.entire(), sess) {\n@@ -200,7 +200,7 @@ fn parse_tree(\n                         }\n                     }\n                     // If we didn't find a metavar expression above, then we must have a\n-                    // repetition sequence in the macro (e.g. `$(pat)*`).  Parse the\n+                    // repetition sequence in the macro (e.g. `$(pat)*`). Parse the\n                     // contents of the sequence itself\n                     let sequence = parse(tts, parsing_patterns, sess, node_id, features, edition);\n                     // Get the Kleene operator and optional separator"}, {"sha": "af38077b08060b43d350994a2be5e158a220f113", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -230,7 +230,7 @@ impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)> for Vec<TokenTree<TokenStre\n                     let stream = TokenStream::from_nonterminal_ast(&nt);\n                     // A hack used to pass AST fragments to attribute and derive\n                     // macros as a single nonterminal token instead of a token\n-                    // stream.  Such token needs to be \"unwrapped\" and not\n+                    // stream. Such token needs to be \"unwrapped\" and not\n                     // represented as a delimited group.\n                     // FIXME: It needs to be removed, but there are some\n                     // compatibility issues (see #73345)."}, {"sha": "aab4b604fad4204ef349334682bbea79686d5392", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -48,6 +48,8 @@ declare_features! (\n \n     /// Allows `#[target_feature(...)]` on aarch64 platforms\n     (accepted, aarch64_target_feature, \"1.61.0\", Some(44839), None),\n+    /// Allows using the `efiapi` ABI.\n+    (accepted, abi_efiapi, \"CURRENT_RUSTC_VERSION\", Some(65815), None),\n     /// Allows the sysV64 ABI to be specified on all platforms\n     /// instead of just the platforms on which it is the C ABI.\n     (accepted, abi_sysv64, \"1.24.0\", Some(36167), None),\n@@ -161,6 +163,8 @@ declare_features! (\n     (accepted, extern_crate_self, \"1.34.0\", Some(56409), None),\n     /// Allows access to crate names passed via `--extern` through prelude.\n     (accepted, extern_prelude, \"1.30.0\", Some(44660), None),\n+    /// Allows using F16C intrinsics from `core::arch::{x86, x86_64}`.\n+    (accepted, f16c_target_feature, \"CURRENT_RUSTC_VERSION\", Some(44839), None),\n     /// Allows field shorthands (`x` meaning `x: x`) in struct literal expressions.\n     (accepted, field_init_shorthand, \"1.17.0\", Some(37340), None),\n     /// Allows `#[must_use]` on functions, and introduces must-use operators (RFC 1940)."}, {"sha": "196c31302a0d2a91d9c59aa153cb7e3d78ea2b5f", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -254,7 +254,6 @@ declare_features! (\n     (active, bpf_target_feature, \"1.54.0\", Some(44839), None),\n     (active, cmpxchg16b_target_feature, \"1.32.0\", Some(44839), None),\n     (active, ermsb_target_feature, \"1.49.0\", Some(44839), None),\n-    (active, f16c_target_feature, \"1.36.0\", Some(44839), None),\n     (active, hexagon_target_feature, \"1.27.0\", Some(44839), None),\n     (active, mips_target_feature, \"1.27.0\", Some(44839), None),\n     (active, movbe_target_feature, \"1.34.0\", Some(44839), None),\n@@ -282,8 +281,6 @@ declare_features! (\n     (active, abi_avr_interrupt, \"1.45.0\", Some(69664), None),\n     /// Allows `extern \"C-cmse-nonsecure-call\" fn()`.\n     (active, abi_c_cmse_nonsecure_call, \"1.51.0\", Some(81391), None),\n-    /// Allows using the `efiapi` ABI.\n-    (active, abi_efiapi, \"1.40.0\", Some(65815), None),\n     /// Allows `extern \"msp430-interrupt\" fn()`.\n     (active, abi_msp430_interrupt, \"1.16.0\", Some(38487), None),\n     /// Allows `extern \"ptx-*\" fn()`.\n@@ -342,7 +339,9 @@ declare_features! (\n     (active, collapse_debuginfo, \"1.65.0\", Some(100758), None),\n     /// Allows `async {}` expressions in const contexts.\n     (active, const_async_blocks, \"1.53.0\", Some(85368), None),\n-    // Allows limiting the evaluation steps of const expressions\n+    /// Allows `const || {}` closures in const contexts.\n+    (incomplete, const_closures, \"CURRENT_RUSTC_VERSION\", Some(106003), None),\n+    /// Allows limiting the evaluation steps of const expressions\n     (active, const_eval_limit, \"1.43.0\", Some(67217), None),\n     /// Allows the definition of `const extern fn` and `const unsafe extern fn`.\n     (active, const_extern_fn, \"1.40.0\", Some(64926), None),\n@@ -374,6 +373,8 @@ declare_features! (\n     (active, deprecated_safe, \"1.61.0\", Some(94978), None),\n     /// Allows having using `suggestion` in the `#[deprecated]` attribute.\n     (active, deprecated_suggestion, \"1.61.0\", Some(94785), None),\n+    /// Controls errors in trait implementations.\n+    (active, do_not_recommend, \"1.67.0\", Some(51992), None),\n     /// Tells rustdoc to automatically generate `#[doc(cfg(...))]`.\n     (active, doc_auto_cfg, \"1.58.0\", Some(43781), None),\n     /// Allows `#[doc(cfg(...))]`."}, {"sha": "af56a0b245987059426e27e8919856d7b2e36563", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -487,6 +487,9 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         experimental!(collapse_debuginfo)\n     ),\n \n+    // RFC 2397\n+    gated!(do_not_recommend, Normal, template!(Word), WarnFollowing, experimental!(do_not_recommend)),\n+\n     // ==========================================================================\n     // Internal attributes: Stability, deprecation, and unsafe:\n     // =========================================================================="}, {"sha": "cca5ead0f83951c19594d3704afb0264164245c6", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -751,7 +751,7 @@ pub enum LifetimeRes {\n         binder: NodeId,\n     },\n     /// This variant is used for anonymous lifetimes that we did not resolve during\n-    /// late resolution.  Those lifetimes will be inferred by typechecking.\n+    /// late resolution. Those lifetimes will be inferred by typechecking.\n     Infer,\n     /// Explicit `'static` lifetime.\n     Static,"}, {"sha": "56f0e0b3e7df6a9350d5fe29de95cdd1a03ea311", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -94,7 +94,7 @@ pub enum LifetimeName {\n     /// Implicit lifetime in a context like `dyn Foo`. This is\n     /// distinguished from implicit lifetimes elsewhere because the\n     /// lifetime that they default to must appear elsewhere within the\n-    /// enclosing type.  This means that, in an `impl Trait` context, we\n+    /// enclosing type. This means that, in an `impl Trait` context, we\n     /// don't have to create a parameter for them. That is, `impl\n     /// Trait<Item = &u32>` expands to an opaque type like `type\n     /// Foo<'a> = impl Trait<Item = &'a u32>`, but `impl Trait<item =\n@@ -826,7 +826,7 @@ pub struct OwnerNodes<'tcx> {\n     pub hash_without_bodies: Fingerprint,\n     /// Full HIR for the current owner.\n     // The zeroth node's parent should never be accessed: the owner's parent is computed by the\n-    // hir_owner_parent query.  It is set to `ItemLocalId::INVALID` to force an ICE if accidentally\n+    // hir_owner_parent query. It is set to `ItemLocalId::INVALID` to force an ICE if accidentally\n     // used.\n     pub nodes: IndexVec<ItemLocalId, Option<ParentedNode<'tcx>>>,\n     /// Content of local bodies.\n@@ -938,6 +938,7 @@ pub struct Crate<'hir> {\n pub struct Closure<'hir> {\n     pub def_id: LocalDefId,\n     pub binder: ClosureBinder,\n+    pub constness: Constness,\n     pub capture_clause: CaptureBy,\n     pub bound_generic_params: &'hir [GenericParam<'hir>],\n     pub fn_decl: &'hir FnDecl<'hir>,"}, {"sha": "404abe2b068cbee561421d5b69f7dfc82ccbb70e", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -148,7 +148,7 @@ rustc_index::newtype_index! {\n     /// that is, within a `hir::Item`, `hir::TraitItem`, or `hir::ImplItem`. There is no\n     /// guarantee that the numerical value of a given `ItemLocalId` corresponds to\n     /// the node's position within the owning item in any way, but there is a\n-    /// guarantee that the `LocalItemId`s within an owner occupy a dense range of\n+    /// guarantee that the `ItemLocalId`s within an owner occupy a dense range of\n     /// integers starting at zero, so a mapping that maps all or most nodes within\n     /// an \"item-like\" to something else can be implemented by a `Vec` instead of a\n     /// tree or hash map.\n@@ -161,7 +161,7 @@ impl ItemLocalId {\n     pub const INVALID: ItemLocalId = ItemLocalId::MAX;\n }\n \n-// Safety: Ord is implement as just comparing the LocalItemId's numerical\n+// Safety: Ord is implement as just comparing the ItemLocalId's numerical\n // values and these are not changed by (de-)serialization.\n unsafe impl StableOrd for ItemLocalId {}\n "}, {"sha": "02641b7cf8fb5e037599f4d46e4c63eb3dcb9d29", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -742,6 +742,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n             fn_decl_span: _,\n             fn_arg_span: _,\n             movability: _,\n+            constness: _,\n         }) => {\n             walk_list!(visitor, visit_generic_param, bound_generic_params);\n             visitor.visit_fn(FnKind::Closure, fn_decl, body, expression.span, expression.hir_id)"}, {"sha": "232ef2079d6bb9eb3c37e95a0547ed2772c4ada9", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -267,7 +267,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // segments, even though `trait_ref.path.segments` is of length `1`. Work\n                 // around that bug here, even though it should be fixed elsewhere.\n                 // This would otherwise cause an invalid suggestion. For an example, look at\n-                // `src/test/ui/issues/issue-28344.rs` where instead of the following:\n+                // `tests/ui/issues/issue-28344.rs` where instead of the following:\n                 //\n                 //   error[E0191]: the value of the associated type `Output`\n                 //                 (from trait `std::ops::BitXor`) must be specified\n@@ -331,7 +331,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             if potential_assoc_types.len() == assoc_items.len() {\n                 // When the amount of missing associated types equals the number of\n-                // extra type arguments present.  A suggesting to replace the generic args with\n+                // extra type arguments present. A suggesting to replace the generic args with\n                 // associated types is already emitted.\n                 already_has_generics_args_suggestion = true;\n             } else if let (Ok(snippet), false) ="}, {"sha": "7a499327dbf240f1f08e9874a417a24e3e31ee82", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 558, "deletions": 576, "changes": 1134, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,6 +1,6 @@\n use super::IsMethodCall;\n use crate::astconv::{\n-    AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n+    CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n     GenericArgCountResult, GenericArgPosition,\n };\n use crate::errors::AssocTypeBindingNotAllowed;\n@@ -18,642 +18,624 @@ use rustc_session::lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS;\n use rustc_span::{symbol::kw, Span};\n use smallvec::SmallVec;\n \n-impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n-    /// Report an error that a generic argument did not match the generic parameter that was\n-    /// expected.\n-    fn generic_arg_mismatch_err(\n-        tcx: TyCtxt<'_>,\n-        arg: &GenericArg<'_>,\n-        param: &GenericParamDef,\n-        possible_ordering_error: bool,\n-        help: Option<&str>,\n-    ) {\n-        let sess = tcx.sess;\n-        let mut err = struct_span_err!(\n-            sess,\n-            arg.span(),\n-            E0747,\n-            \"{} provided when a {} was expected\",\n-            arg.descr(),\n-            param.kind.descr(),\n-        );\n-\n-        if let GenericParamDefKind::Const { .. } = param.kind {\n-            if matches!(arg, GenericArg::Type(hir::Ty { kind: hir::TyKind::Infer, .. })) {\n-                err.help(\"const arguments cannot yet be inferred with `_`\");\n-                if sess.is_nightly_build() {\n-                    err.help(\n-                        \"add `#![feature(generic_arg_infer)]` to the crate attributes to enable\",\n-                    );\n-                }\n+/// Report an error that a generic argument did not match the generic parameter that was\n+/// expected.\n+fn generic_arg_mismatch_err(\n+    tcx: TyCtxt<'_>,\n+    arg: &GenericArg<'_>,\n+    param: &GenericParamDef,\n+    possible_ordering_error: bool,\n+    help: Option<&str>,\n+) {\n+    let sess = tcx.sess;\n+    let mut err = struct_span_err!(\n+        sess,\n+        arg.span(),\n+        E0747,\n+        \"{} provided when a {} was expected\",\n+        arg.descr(),\n+        param.kind.descr(),\n+    );\n+\n+    if let GenericParamDefKind::Const { .. } = param.kind {\n+        if matches!(arg, GenericArg::Type(hir::Ty { kind: hir::TyKind::Infer, .. })) {\n+            err.help(\"const arguments cannot yet be inferred with `_`\");\n+            if sess.is_nightly_build() {\n+                err.help(\"add `#![feature(generic_arg_infer)]` to the crate attributes to enable\");\n             }\n         }\n+    }\n \n-        let add_braces_suggestion = |arg: &GenericArg<'_>, err: &mut Diagnostic| {\n-            let suggestions = vec![\n-                (arg.span().shrink_to_lo(), String::from(\"{ \")),\n-                (arg.span().shrink_to_hi(), String::from(\" }\")),\n-            ];\n-            err.multipart_suggestion(\n-                \"if this generic argument was intended as a const parameter, \\\n+    let add_braces_suggestion = |arg: &GenericArg<'_>, err: &mut Diagnostic| {\n+        let suggestions = vec![\n+            (arg.span().shrink_to_lo(), String::from(\"{ \")),\n+            (arg.span().shrink_to_hi(), String::from(\" }\")),\n+        ];\n+        err.multipart_suggestion(\n+            \"if this generic argument was intended as a const parameter, \\\n                  surround it with braces\",\n-                suggestions,\n-                Applicability::MaybeIncorrect,\n-            );\n-        };\n-\n-        // Specific suggestion set for diagnostics\n-        match (arg, &param.kind) {\n-            (\n-                GenericArg::Type(hir::Ty {\n-                    kind: hir::TyKind::Path(rustc_hir::QPath::Resolved(_, path)),\n-                    ..\n-                }),\n-                GenericParamDefKind::Const { .. },\n-            ) => match path.res {\n-                Res::Err => {\n-                    add_braces_suggestion(arg, &mut err);\n-                    err.set_primary_message(\n-                        \"unresolved item provided when a constant was expected\",\n-                    )\n+            suggestions,\n+            Applicability::MaybeIncorrect,\n+        );\n+    };\n+\n+    // Specific suggestion set for diagnostics\n+    match (arg, &param.kind) {\n+        (\n+            GenericArg::Type(hir::Ty {\n+                kind: hir::TyKind::Path(rustc_hir::QPath::Resolved(_, path)),\n+                ..\n+            }),\n+            GenericParamDefKind::Const { .. },\n+        ) => match path.res {\n+            Res::Err => {\n+                add_braces_suggestion(arg, &mut err);\n+                err.set_primary_message(\"unresolved item provided when a constant was expected\")\n                     .emit();\n-                    return;\n-                }\n-                Res::Def(DefKind::TyParam, src_def_id) => {\n-                    if let Some(param_local_id) = param.def_id.as_local() {\n-                        let param_name = tcx.hir().ty_param_name(param_local_id);\n-                        let param_type = tcx.type_of(param.def_id);\n-                        if param_type.is_suggestable(tcx, false) {\n-                            err.span_suggestion(\n-                                tcx.def_span(src_def_id),\n-                                \"consider changing this type parameter to be a `const` generic\",\n-                                format!(\"const {}: {}\", param_name, param_type),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        };\n-                    }\n-                }\n-                _ => add_braces_suggestion(arg, &mut err),\n-            },\n-            (\n-                GenericArg::Type(hir::Ty { kind: hir::TyKind::Path(_), .. }),\n-                GenericParamDefKind::Const { .. },\n-            ) => add_braces_suggestion(arg, &mut err),\n-            (\n-                GenericArg::Type(hir::Ty { kind: hir::TyKind::Array(_, len), .. }),\n-                GenericParamDefKind::Const { .. },\n-            ) if tcx.type_of(param.def_id) == tcx.types.usize => {\n-                let snippet = sess.source_map().span_to_snippet(tcx.hir().span(len.hir_id()));\n-                if let Ok(snippet) = snippet {\n-                    err.span_suggestion(\n-                        arg.span(),\n-                        \"array type provided where a `usize` was expected, try\",\n-                        format!(\"{{ {} }}\", snippet),\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                return;\n+            }\n+            Res::Def(DefKind::TyParam, src_def_id) => {\n+                if let Some(param_local_id) = param.def_id.as_local() {\n+                    let param_name = tcx.hir().ty_param_name(param_local_id);\n+                    let param_type = tcx.type_of(param.def_id);\n+                    if param_type.is_suggestable(tcx, false) {\n+                        err.span_suggestion(\n+                            tcx.def_span(src_def_id),\n+                            \"consider changing this type parameter to be a `const` generic\",\n+                            format!(\"const {}: {}\", param_name, param_type),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    };\n                 }\n             }\n-            (GenericArg::Const(cnst), GenericParamDefKind::Type { .. }) => {\n-                let body = tcx.hir().body(cnst.value.body);\n-                if let rustc_hir::ExprKind::Path(rustc_hir::QPath::Resolved(_, path)) =\n-                    body.value.kind\n-                {\n-                    if let Res::Def(DefKind::Fn { .. }, id) = path.res {\n-                        err.help(&format!(\n-                            \"`{}` is a function item, not a type\",\n-                            tcx.item_name(id)\n-                        ));\n-                        err.help(\"function item types cannot be named directly\");\n-                    }\n+            _ => add_braces_suggestion(arg, &mut err),\n+        },\n+        (\n+            GenericArg::Type(hir::Ty { kind: hir::TyKind::Path(_), .. }),\n+            GenericParamDefKind::Const { .. },\n+        ) => add_braces_suggestion(arg, &mut err),\n+        (\n+            GenericArg::Type(hir::Ty { kind: hir::TyKind::Array(_, len), .. }),\n+            GenericParamDefKind::Const { .. },\n+        ) if tcx.type_of(param.def_id) == tcx.types.usize => {\n+            let snippet = sess.source_map().span_to_snippet(tcx.hir().span(len.hir_id()));\n+            if let Ok(snippet) = snippet {\n+                err.span_suggestion(\n+                    arg.span(),\n+                    \"array type provided where a `usize` was expected, try\",\n+                    format!(\"{{ {} }}\", snippet),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+        (GenericArg::Const(cnst), GenericParamDefKind::Type { .. }) => {\n+            let body = tcx.hir().body(cnst.value.body);\n+            if let rustc_hir::ExprKind::Path(rustc_hir::QPath::Resolved(_, path)) = body.value.kind\n+            {\n+                if let Res::Def(DefKind::Fn { .. }, id) = path.res {\n+                    err.help(&format!(\"`{}` is a function item, not a type\", tcx.item_name(id)));\n+                    err.help(\"function item types cannot be named directly\");\n                 }\n             }\n-            _ => {}\n         }\n+        _ => {}\n+    }\n \n-        let kind_ord = param.kind.to_ord();\n-        let arg_ord = arg.to_ord();\n+    let kind_ord = param.kind.to_ord();\n+    let arg_ord = arg.to_ord();\n \n-        // This note is only true when generic parameters are strictly ordered by their kind.\n-        if possible_ordering_error && kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n-            let (first, last) = if kind_ord < arg_ord {\n-                (param.kind.descr(), arg.descr())\n-            } else {\n-                (arg.descr(), param.kind.descr())\n-            };\n-            err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n-            if let Some(help) = help {\n-                err.help(help);\n-            }\n+    // This note is only true when generic parameters are strictly ordered by their kind.\n+    if possible_ordering_error && kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n+        let (first, last) = if kind_ord < arg_ord {\n+            (param.kind.descr(), arg.descr())\n+        } else {\n+            (arg.descr(), param.kind.descr())\n+        };\n+        err.note(&format!(\"{} arguments must be provided before {} arguments\", first, last));\n+        if let Some(help) = help {\n+            err.help(help);\n         }\n+    }\n+\n+    err.emit();\n+}\n \n-        err.emit();\n+/// Creates the relevant generic argument substitutions\n+/// corresponding to a set of generic parameters. This is a\n+/// rather complex function. Let us try to explain the role\n+/// of each of its parameters:\n+///\n+/// To start, we are given the `def_id` of the thing we are\n+/// creating the substitutions for, and a partial set of\n+/// substitutions `parent_substs`. In general, the substitutions\n+/// for an item begin with substitutions for all the \"parents\" of\n+/// that item -- e.g., for a method it might include the\n+/// parameters from the impl.\n+///\n+/// Therefore, the method begins by walking down these parents,\n+/// starting with the outermost parent and proceed inwards until\n+/// it reaches `def_id`. For each parent `P`, it will check `parent_substs`\n+/// first to see if the parent's substitutions are listed in there. If so,\n+/// we can append those and move on. Otherwise, it invokes the\n+/// three callback functions:\n+///\n+/// - `args_for_def_id`: given the `DefId` `P`, supplies back the\n+///   generic arguments that were given to that parent from within\n+///   the path; so e.g., if you have `<T as Foo>::Bar`, the `DefId`\n+///   might refer to the trait `Foo`, and the arguments might be\n+///   `[T]`. The boolean value indicates whether to infer values\n+///   for arguments whose values were not explicitly provided.\n+/// - `provided_kind`: given the generic parameter and the value from `args_for_def_id`,\n+///   instantiate a `GenericArg`.\n+/// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n+///   creates a suitable inference variable.\n+pub fn create_substs_for_generic_args<'tcx, 'a>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    parent_substs: &[subst::GenericArg<'tcx>],\n+    has_self: bool,\n+    self_ty: Option<Ty<'tcx>>,\n+    arg_count: &GenericArgCountResult,\n+    ctx: &mut impl CreateSubstsForGenericArgsCtxt<'a, 'tcx>,\n+) -> SubstsRef<'tcx> {\n+    // Collect the segments of the path; we need to substitute arguments\n+    // for parameters throughout the entire path (wherever there are\n+    // generic parameters).\n+    let mut parent_defs = tcx.generics_of(def_id);\n+    let count = parent_defs.count();\n+    let mut stack = vec![(def_id, parent_defs)];\n+    while let Some(def_id) = parent_defs.parent {\n+        parent_defs = tcx.generics_of(def_id);\n+        stack.push((def_id, parent_defs));\n     }\n \n-    /// Creates the relevant generic argument substitutions\n-    /// corresponding to a set of generic parameters. This is a\n-    /// rather complex function. Let us try to explain the role\n-    /// of each of its parameters:\n-    ///\n-    /// To start, we are given the `def_id` of the thing we are\n-    /// creating the substitutions for, and a partial set of\n-    /// substitutions `parent_substs`. In general, the substitutions\n-    /// for an item begin with substitutions for all the \"parents\" of\n-    /// that item -- e.g., for a method it might include the\n-    /// parameters from the impl.\n-    ///\n-    /// Therefore, the method begins by walking down these parents,\n-    /// starting with the outermost parent and proceed inwards until\n-    /// it reaches `def_id`. For each parent `P`, it will check `parent_substs`\n-    /// first to see if the parent's substitutions are listed in there. If so,\n-    /// we can append those and move on. Otherwise, it invokes the\n-    /// three callback functions:\n-    ///\n-    /// - `args_for_def_id`: given the `DefId` `P`, supplies back the\n-    ///   generic arguments that were given to that parent from within\n-    ///   the path; so e.g., if you have `<T as Foo>::Bar`, the `DefId`\n-    ///   might refer to the trait `Foo`, and the arguments might be\n-    ///   `[T]`. The boolean value indicates whether to infer values\n-    ///   for arguments whose values were not explicitly provided.\n-    /// - `provided_kind`: given the generic parameter and the value from `args_for_def_id`,\n-    ///   instantiate a `GenericArg`.\n-    /// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n-    ///   creates a suitable inference variable.\n-    pub fn create_substs_for_generic_args<'a>(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        parent_substs: &[subst::GenericArg<'tcx>],\n-        has_self: bool,\n-        self_ty: Option<Ty<'tcx>>,\n-        arg_count: &GenericArgCountResult,\n-        ctx: &mut impl CreateSubstsForGenericArgsCtxt<'a, 'tcx>,\n-    ) -> SubstsRef<'tcx> {\n-        // Collect the segments of the path; we need to substitute arguments\n-        // for parameters throughout the entire path (wherever there are\n-        // generic parameters).\n-        let mut parent_defs = tcx.generics_of(def_id);\n-        let count = parent_defs.count();\n-        let mut stack = vec![(def_id, parent_defs)];\n-        while let Some(def_id) = parent_defs.parent {\n-            parent_defs = tcx.generics_of(def_id);\n-            stack.push((def_id, parent_defs));\n+    // We manually build up the substitution, rather than using convenience\n+    // methods in `subst.rs`, so that we can iterate over the arguments and\n+    // parameters in lock-step linearly, instead of trying to match each pair.\n+    let mut substs: SmallVec<[subst::GenericArg<'tcx>; 8]> = SmallVec::with_capacity(count);\n+    // Iterate over each segment of the path.\n+    while let Some((def_id, defs)) = stack.pop() {\n+        let mut params = defs.params.iter().peekable();\n+\n+        // If we have already computed substitutions for parents, we can use those directly.\n+        while let Some(&param) = params.peek() {\n+            if let Some(&kind) = parent_substs.get(param.index as usize) {\n+                substs.push(kind);\n+                params.next();\n+            } else {\n+                break;\n+            }\n         }\n \n-        // We manually build up the substitution, rather than using convenience\n-        // methods in `subst.rs`, so that we can iterate over the arguments and\n-        // parameters in lock-step linearly, instead of trying to match each pair.\n-        let mut substs: SmallVec<[subst::GenericArg<'tcx>; 8]> = SmallVec::with_capacity(count);\n-        // Iterate over each segment of the path.\n-        while let Some((def_id, defs)) = stack.pop() {\n-            let mut params = defs.params.iter().peekable();\n-\n-            // If we have already computed substitutions for parents, we can use those directly.\n-            while let Some(&param) = params.peek() {\n-                if let Some(&kind) = parent_substs.get(param.index as usize) {\n-                    substs.push(kind);\n-                    params.next();\n-                } else {\n-                    break;\n+        // `Self` is handled first, unless it's been handled in `parent_substs`.\n+        if has_self {\n+            if let Some(&param) = params.peek() {\n+                if param.index == 0 {\n+                    if let GenericParamDefKind::Type { .. } = param.kind {\n+                        substs.push(\n+                            self_ty\n+                                .map(|ty| ty.into())\n+                                .unwrap_or_else(|| ctx.inferred_kind(None, param, true)),\n+                        );\n+                        params.next();\n+                    }\n                 }\n             }\n+        }\n \n-            // `Self` is handled first, unless it's been handled in `parent_substs`.\n-            if has_self {\n-                if let Some(&param) = params.peek() {\n-                    if param.index == 0 {\n-                        if let GenericParamDefKind::Type { .. } = param.kind {\n-                            substs.push(\n-                                self_ty\n-                                    .map(|ty| ty.into())\n-                                    .unwrap_or_else(|| ctx.inferred_kind(None, param, true)),\n-                            );\n+        // Check whether this segment takes generic arguments and the user has provided any.\n+        let (generic_args, infer_args) = ctx.args_for_def_id(def_id);\n+\n+        let args_iter = generic_args.iter().flat_map(|generic_args| generic_args.args.iter());\n+        let mut args = args_iter.clone().peekable();\n+\n+        // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.\n+        // If we later encounter a lifetime, we know that the arguments were provided in the\n+        // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be\n+        // inferred, so we can use it for diagnostics later.\n+        let mut force_infer_lt = None;\n+\n+        loop {\n+            // We're going to iterate through the generic arguments that the user\n+            // provided, matching them with the generic parameters we expect.\n+            // Mismatches can occur as a result of elided lifetimes, or for malformed\n+            // input. We try to handle both sensibly.\n+            match (args.peek(), params.peek()) {\n+                (Some(&arg), Some(&param)) => {\n+                    match (arg, &param.kind, arg_count.explicit_late_bound) {\n+                        (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n+                        | (\n+                            GenericArg::Type(_) | GenericArg::Infer(_),\n+                            GenericParamDefKind::Type { .. },\n+                            _,\n+                        )\n+                        | (\n+                            GenericArg::Const(_) | GenericArg::Infer(_),\n+                            GenericParamDefKind::Const { .. },\n+                            _,\n+                        ) => {\n+                            substs.push(ctx.provided_kind(param, arg));\n+                            args.next();\n                             params.next();\n                         }\n-                    }\n-                }\n-            }\n-\n-            // Check whether this segment takes generic arguments and the user has provided any.\n-            let (generic_args, infer_args) = ctx.args_for_def_id(def_id);\n-\n-            let args_iter = generic_args.iter().flat_map(|generic_args| generic_args.args.iter());\n-            let mut args = args_iter.clone().peekable();\n-\n-            // If we encounter a type or const when we expect a lifetime, we infer the lifetimes.\n-            // If we later encounter a lifetime, we know that the arguments were provided in the\n-            // wrong order. `force_infer_lt` records the type or const that forced lifetimes to be\n-            // inferred, so we can use it for diagnostics later.\n-            let mut force_infer_lt = None;\n-\n-            loop {\n-                // We're going to iterate through the generic arguments that the user\n-                // provided, matching them with the generic parameters we expect.\n-                // Mismatches can occur as a result of elided lifetimes, or for malformed\n-                // input. We try to handle both sensibly.\n-                match (args.peek(), params.peek()) {\n-                    (Some(&arg), Some(&param)) => {\n-                        match (arg, &param.kind, arg_count.explicit_late_bound) {\n-                            (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime, _)\n-                            | (\n-                                GenericArg::Type(_) | GenericArg::Infer(_),\n-                                GenericParamDefKind::Type { .. },\n-                                _,\n-                            )\n-                            | (\n-                                GenericArg::Const(_) | GenericArg::Infer(_),\n-                                GenericParamDefKind::Const { .. },\n-                                _,\n-                            ) => {\n-                                substs.push(ctx.provided_kind(param, arg));\n-                                args.next();\n-                                params.next();\n-                            }\n-                            (\n-                                GenericArg::Infer(_) | GenericArg::Type(_) | GenericArg::Const(_),\n-                                GenericParamDefKind::Lifetime,\n-                                _,\n-                            ) => {\n-                                // We expected a lifetime argument, but got a type or const\n-                                // argument. That means we're inferring the lifetimes.\n-                                substs.push(ctx.inferred_kind(None, param, infer_args));\n-                                force_infer_lt = Some((arg, param));\n-                                params.next();\n-                            }\n-                            (GenericArg::Lifetime(_), _, ExplicitLateBound::Yes) => {\n-                                // We've come across a lifetime when we expected something else in\n-                                // the presence of explicit late bounds. This is most likely\n-                                // due to the presence of the explicit bound so we're just going to\n-                                // ignore it.\n-                                args.next();\n-                            }\n-                            (_, _, _) => {\n-                                // We expected one kind of parameter, but the user provided\n-                                // another. This is an error. However, if we already know that\n-                                // the arguments don't match up with the parameters, we won't issue\n-                                // an additional error, as the user already knows what's wrong.\n-                                if arg_count.correct.is_ok() {\n-                                    // We're going to iterate over the parameters to sort them out, and\n-                                    // show that order to the user as a possible order for the parameters\n-                                    let mut param_types_present = defs\n-                                        .params\n-                                        .iter()\n-                                        .map(|param| (param.kind.to_ord(), param.clone()))\n-                                        .collect::<Vec<(ParamKindOrd, GenericParamDef)>>();\n-                                    param_types_present.sort_by_key(|(ord, _)| *ord);\n-                                    let (mut param_types_present, ordered_params): (\n-                                        Vec<ParamKindOrd>,\n-                                        Vec<GenericParamDef>,\n-                                    ) = param_types_present.into_iter().unzip();\n-                                    param_types_present.dedup();\n-\n-                                    Self::generic_arg_mismatch_err(\n-                                        tcx,\n-                                        arg,\n-                                        param,\n-                                        !args_iter.clone().is_sorted_by_key(|arg| arg.to_ord()),\n-                                        Some(&format!(\n-                                            \"reorder the arguments: {}: `<{}>`\",\n-                                            param_types_present\n-                                                .into_iter()\n-                                                .map(|ord| format!(\"{}s\", ord))\n-                                                .collect::<Vec<String>>()\n-                                                .join(\", then \"),\n-                                            ordered_params\n-                                                .into_iter()\n-                                                .filter_map(|param| {\n-                                                    if param.name == kw::SelfUpper {\n-                                                        None\n-                                                    } else {\n-                                                        Some(param.name.to_string())\n-                                                    }\n-                                                })\n-                                                .collect::<Vec<String>>()\n-                                                .join(\", \")\n-                                        )),\n-                                    );\n-                                }\n-\n-                                // We've reported the error, but we want to make sure that this\n-                                // problem doesn't bubble down and create additional, irrelevant\n-                                // errors. In this case, we're simply going to ignore the argument\n-                                // and any following arguments. The rest of the parameters will be\n-                                // inferred.\n-                                while args.next().is_some() {}\n-                            }\n+                        (\n+                            GenericArg::Infer(_) | GenericArg::Type(_) | GenericArg::Const(_),\n+                            GenericParamDefKind::Lifetime,\n+                            _,\n+                        ) => {\n+                            // We expected a lifetime argument, but got a type or const\n+                            // argument. That means we're inferring the lifetimes.\n+                            substs.push(ctx.inferred_kind(None, param, infer_args));\n+                            force_infer_lt = Some((arg, param));\n+                            params.next();\n                         }\n-                    }\n-\n-                    (Some(&arg), None) => {\n-                        // We should never be able to reach this point with well-formed input.\n-                        // There are three situations in which we can encounter this issue.\n-                        //\n-                        //  1.  The number of arguments is incorrect. In this case, an error\n-                        //      will already have been emitted, and we can ignore it.\n-                        //  2.  There are late-bound lifetime parameters present, yet the\n-                        //      lifetime arguments have also been explicitly specified by the\n-                        //      user.\n-                        //  3.  We've inferred some lifetimes, which have been provided later (i.e.\n-                        //      after a type or const). We want to throw an error in this case.\n-\n-                        if arg_count.correct.is_ok()\n-                            && arg_count.explicit_late_bound == ExplicitLateBound::No\n-                        {\n-                            let kind = arg.descr();\n-                            assert_eq!(kind, \"lifetime\");\n-                            let (provided_arg, param) =\n-                                force_infer_lt.expect(\"lifetimes ought to have been inferred\");\n-                            Self::generic_arg_mismatch_err(tcx, provided_arg, param, false, None);\n+                        (GenericArg::Lifetime(_), _, ExplicitLateBound::Yes) => {\n+                            // We've come across a lifetime when we expected something else in\n+                            // the presence of explicit late bounds. This is most likely\n+                            // due to the presence of the explicit bound so we're just going to\n+                            // ignore it.\n+                            args.next();\n                         }\n+                        (_, _, _) => {\n+                            // We expected one kind of parameter, but the user provided\n+                            // another. This is an error. However, if we already know that\n+                            // the arguments don't match up with the parameters, we won't issue\n+                            // an additional error, as the user already knows what's wrong.\n+                            if arg_count.correct.is_ok() {\n+                                // We're going to iterate over the parameters to sort them out, and\n+                                // show that order to the user as a possible order for the parameters\n+                                let mut param_types_present = defs\n+                                    .params\n+                                    .iter()\n+                                    .map(|param| (param.kind.to_ord(), param.clone()))\n+                                    .collect::<Vec<(ParamKindOrd, GenericParamDef)>>();\n+                                param_types_present.sort_by_key(|(ord, _)| *ord);\n+                                let (mut param_types_present, ordered_params): (\n+                                    Vec<ParamKindOrd>,\n+                                    Vec<GenericParamDef>,\n+                                ) = param_types_present.into_iter().unzip();\n+                                param_types_present.dedup();\n+\n+                                generic_arg_mismatch_err(\n+                                    tcx,\n+                                    arg,\n+                                    param,\n+                                    !args_iter.clone().is_sorted_by_key(|arg| arg.to_ord()),\n+                                    Some(&format!(\n+                                        \"reorder the arguments: {}: `<{}>`\",\n+                                        param_types_present\n+                                            .into_iter()\n+                                            .map(|ord| format!(\"{}s\", ord))\n+                                            .collect::<Vec<String>>()\n+                                            .join(\", then \"),\n+                                        ordered_params\n+                                            .into_iter()\n+                                            .filter_map(|param| {\n+                                                if param.name == kw::SelfUpper {\n+                                                    None\n+                                                } else {\n+                                                    Some(param.name.to_string())\n+                                                }\n+                                            })\n+                                            .collect::<Vec<String>>()\n+                                            .join(\", \")\n+                                    )),\n+                                );\n+                            }\n \n-                        break;\n+                            // We've reported the error, but we want to make sure that this\n+                            // problem doesn't bubble down and create additional, irrelevant\n+                            // errors. In this case, we're simply going to ignore the argument\n+                            // and any following arguments. The rest of the parameters will be\n+                            // inferred.\n+                            while args.next().is_some() {}\n+                        }\n                     }\n+                }\n \n-                    (None, Some(&param)) => {\n-                        // If there are fewer arguments than parameters, it means\n-                        // we're inferring the remaining arguments.\n-                        substs.push(ctx.inferred_kind(Some(&substs), param, infer_args));\n-                        params.next();\n+                (Some(&arg), None) => {\n+                    // We should never be able to reach this point with well-formed input.\n+                    // There are three situations in which we can encounter this issue.\n+                    //\n+                    //  1. The number of arguments is incorrect. In this case, an error\n+                    //     will already have been emitted, and we can ignore it.\n+                    //  2. There are late-bound lifetime parameters present, yet the\n+                    //     lifetime arguments have also been explicitly specified by the\n+                    //     user.\n+                    //  3. We've inferred some lifetimes, which have been provided later (i.e.\n+                    //     after a type or const). We want to throw an error in this case.\n+\n+                    if arg_count.correct.is_ok()\n+                        && arg_count.explicit_late_bound == ExplicitLateBound::No\n+                    {\n+                        let kind = arg.descr();\n+                        assert_eq!(kind, \"lifetime\");\n+                        let (provided_arg, param) =\n+                            force_infer_lt.expect(\"lifetimes ought to have been inferred\");\n+                        generic_arg_mismatch_err(tcx, provided_arg, param, false, None);\n                     }\n \n-                    (None, None) => break,\n+                    break;\n+                }\n+\n+                (None, Some(&param)) => {\n+                    // If there are fewer arguments than parameters, it means\n+                    // we're inferring the remaining arguments.\n+                    substs.push(ctx.inferred_kind(Some(&substs), param, infer_args));\n+                    params.next();\n                 }\n+\n+                (None, None) => break,\n             }\n         }\n-\n-        tcx.intern_substs(&substs)\n     }\n \n-    /// Checks that the correct number of generic arguments have been provided.\n-    /// Used specifically for function calls.\n-    pub fn check_generic_arg_count_for_call(\n-        tcx: TyCtxt<'_>,\n-        span: Span,\n-        def_id: DefId,\n-        generics: &ty::Generics,\n-        seg: &hir::PathSegment<'_>,\n-        is_method_call: IsMethodCall,\n-    ) -> GenericArgCountResult {\n-        let empty_args = hir::GenericArgs::none();\n-        let gen_args = seg.args.unwrap_or(&empty_args);\n-        let gen_pos = if is_method_call == IsMethodCall::Yes {\n-            GenericArgPosition::MethodCall\n+    tcx.intern_substs(&substs)\n+}\n+\n+/// Checks that the correct number of generic arguments have been provided.\n+/// Used specifically for function calls.\n+pub fn check_generic_arg_count_for_call(\n+    tcx: TyCtxt<'_>,\n+    span: Span,\n+    def_id: DefId,\n+    generics: &ty::Generics,\n+    seg: &hir::PathSegment<'_>,\n+    is_method_call: IsMethodCall,\n+) -> GenericArgCountResult {\n+    let empty_args = hir::GenericArgs::none();\n+    let gen_args = seg.args.unwrap_or(&empty_args);\n+    let gen_pos = if is_method_call == IsMethodCall::Yes {\n+        GenericArgPosition::MethodCall\n+    } else {\n+        GenericArgPosition::Value\n+    };\n+    let has_self = generics.parent.is_none() && generics.has_self;\n+\n+    check_generic_arg_count(\n+        tcx,\n+        span,\n+        def_id,\n+        seg,\n+        generics,\n+        gen_args,\n+        gen_pos,\n+        has_self,\n+        seg.infer_args,\n+    )\n+}\n+\n+/// Checks that the correct number of generic arguments have been provided.\n+/// This is used both for datatypes and function calls.\n+#[instrument(skip(tcx, gen_pos), level = \"debug\")]\n+pub(crate) fn check_generic_arg_count(\n+    tcx: TyCtxt<'_>,\n+    span: Span,\n+    def_id: DefId,\n+    seg: &hir::PathSegment<'_>,\n+    gen_params: &ty::Generics,\n+    gen_args: &hir::GenericArgs<'_>,\n+    gen_pos: GenericArgPosition,\n+    has_self: bool,\n+    infer_args: bool,\n+) -> GenericArgCountResult {\n+    let default_counts = gen_params.own_defaults();\n+    let param_counts = gen_params.own_counts();\n+\n+    // Subtracting from param count to ensure type params synthesized from `impl Trait`\n+    // cannot be explicitly specified.\n+    let synth_type_param_count = gen_params\n+        .params\n+        .iter()\n+        .filter(|param| matches!(param.kind, ty::GenericParamDefKind::Type { synthetic: true, .. }))\n+        .count();\n+    let named_type_param_count = param_counts.types - has_self as usize - synth_type_param_count;\n+    let infer_lifetimes =\n+        (gen_pos != GenericArgPosition::Type || infer_args) && !gen_args.has_lifetime_params();\n+\n+    if gen_pos != GenericArgPosition::Type && let Some(b) = gen_args.bindings.first() {\n+            prohibit_assoc_ty_binding(tcx, b.span);\n+        }\n+\n+    let explicit_late_bound =\n+        prohibit_explicit_late_bound_lifetimes(tcx, gen_params, gen_args, gen_pos);\n+\n+    let mut invalid_args = vec![];\n+\n+    let mut check_lifetime_args = |min_expected_args: usize,\n+                                   max_expected_args: usize,\n+                                   provided_args: usize,\n+                                   late_bounds_ignore: bool| {\n+        if (min_expected_args..=max_expected_args).contains(&provided_args) {\n+            return Ok(());\n+        }\n+\n+        if late_bounds_ignore {\n+            return Ok(());\n+        }\n+\n+        if provided_args > max_expected_args {\n+            invalid_args.extend(\n+                gen_args.args[max_expected_args..provided_args].iter().map(|arg| arg.span()),\n+            );\n+        };\n+\n+        let gen_args_info = if provided_args > min_expected_args {\n+            invalid_args.extend(\n+                gen_args.args[min_expected_args..provided_args].iter().map(|arg| arg.span()),\n+            );\n+            let num_redundant_args = provided_args - min_expected_args;\n+            GenericArgsInfo::ExcessLifetimes { num_redundant_args }\n         } else {\n-            GenericArgPosition::Value\n+            let num_missing_args = min_expected_args - provided_args;\n+            GenericArgsInfo::MissingLifetimes { num_missing_args }\n         };\n-        let has_self = generics.parent.is_none() && generics.has_self;\n \n-        Self::check_generic_arg_count(\n+        let reported = WrongNumberOfGenericArgs::new(\n             tcx,\n-            span,\n-            def_id,\n+            gen_args_info,\n             seg,\n-            generics,\n+            gen_params,\n+            has_self as usize,\n             gen_args,\n-            gen_pos,\n-            has_self,\n-            seg.infer_args,\n+            def_id,\n         )\n-    }\n-\n-    /// Checks that the correct number of generic arguments have been provided.\n-    /// This is used both for datatypes and function calls.\n-    #[instrument(skip(tcx, gen_pos), level = \"debug\")]\n-    pub(crate) fn check_generic_arg_count(\n-        tcx: TyCtxt<'_>,\n-        span: Span,\n-        def_id: DefId,\n-        seg: &hir::PathSegment<'_>,\n-        gen_params: &ty::Generics,\n-        gen_args: &hir::GenericArgs<'_>,\n-        gen_pos: GenericArgPosition,\n-        has_self: bool,\n-        infer_args: bool,\n-    ) -> GenericArgCountResult {\n-        let default_counts = gen_params.own_defaults();\n-        let param_counts = gen_params.own_counts();\n-\n-        // Subtracting from param count to ensure type params synthesized from `impl Trait`\n-        // cannot be explicitly specified.\n-        let synth_type_param_count = gen_params\n-            .params\n-            .iter()\n-            .filter(|param| {\n-                matches!(param.kind, ty::GenericParamDefKind::Type { synthetic: true, .. })\n-            })\n-            .count();\n-        let named_type_param_count =\n-            param_counts.types - has_self as usize - synth_type_param_count;\n-        let infer_lifetimes =\n-            (gen_pos != GenericArgPosition::Type || infer_args) && !gen_args.has_lifetime_params();\n-\n-        if gen_pos != GenericArgPosition::Type && let Some(b) = gen_args.bindings.first() {\n-            Self::prohibit_assoc_ty_binding(tcx, b.span);\n+        .diagnostic()\n+        .emit();\n+\n+        Err(reported)\n+    };\n+\n+    let min_expected_lifetime_args = if infer_lifetimes { 0 } else { param_counts.lifetimes };\n+    let max_expected_lifetime_args = param_counts.lifetimes;\n+    let num_provided_lifetime_args = gen_args.num_lifetime_params();\n+\n+    let lifetimes_correct = check_lifetime_args(\n+        min_expected_lifetime_args,\n+        max_expected_lifetime_args,\n+        num_provided_lifetime_args,\n+        explicit_late_bound == ExplicitLateBound::Yes,\n+    );\n+\n+    let mut check_types_and_consts = |expected_min,\n+                                      expected_max,\n+                                      expected_max_with_synth,\n+                                      provided,\n+                                      params_offset,\n+                                      args_offset| {\n+        debug!(\n+            ?expected_min,\n+            ?expected_max,\n+            ?provided,\n+            ?params_offset,\n+            ?args_offset,\n+            \"check_types_and_consts\"\n+        );\n+        if (expected_min..=expected_max).contains(&provided) {\n+            return Ok(());\n         }\n \n-        let explicit_late_bound =\n-            Self::prohibit_explicit_late_bound_lifetimes(tcx, gen_params, gen_args, gen_pos);\n-\n-        let mut invalid_args = vec![];\n+        let num_default_params = expected_max - expected_min;\n \n-        let mut check_lifetime_args =\n-            |min_expected_args: usize,\n-             max_expected_args: usize,\n-             provided_args: usize,\n-             late_bounds_ignore: bool| {\n-                if (min_expected_args..=max_expected_args).contains(&provided_args) {\n-                    return Ok(());\n-                }\n-\n-                if late_bounds_ignore {\n-                    return Ok(());\n-                }\n+        let gen_args_info = if provided > expected_max {\n+            invalid_args.extend(\n+                gen_args.args[args_offset + expected_max..args_offset + provided]\n+                    .iter()\n+                    .map(|arg| arg.span()),\n+            );\n+            let num_redundant_args = provided - expected_max;\n \n-                if provided_args > max_expected_args {\n-                    invalid_args.extend(\n-                        gen_args.args[max_expected_args..provided_args]\n-                            .iter()\n-                            .map(|arg| arg.span()),\n-                    );\n-                };\n-\n-                let gen_args_info = if provided_args > min_expected_args {\n-                    invalid_args.extend(\n-                        gen_args.args[min_expected_args..provided_args]\n-                            .iter()\n-                            .map(|arg| arg.span()),\n-                    );\n-                    let num_redundant_args = provided_args - min_expected_args;\n-                    GenericArgsInfo::ExcessLifetimes { num_redundant_args }\n-                } else {\n-                    let num_missing_args = min_expected_args - provided_args;\n-                    GenericArgsInfo::MissingLifetimes { num_missing_args }\n-                };\n-\n-                let reported = WrongNumberOfGenericArgs::new(\n-                    tcx,\n-                    gen_args_info,\n-                    seg,\n-                    gen_params,\n-                    has_self as usize,\n-                    gen_args,\n-                    def_id,\n-                )\n-                .diagnostic()\n-                .emit();\n-\n-                Err(reported)\n-            };\n-\n-        let min_expected_lifetime_args = if infer_lifetimes { 0 } else { param_counts.lifetimes };\n-        let max_expected_lifetime_args = param_counts.lifetimes;\n-        let num_provided_lifetime_args = gen_args.num_lifetime_params();\n-\n-        let lifetimes_correct = check_lifetime_args(\n-            min_expected_lifetime_args,\n-            max_expected_lifetime_args,\n-            num_provided_lifetime_args,\n-            explicit_late_bound == ExplicitLateBound::Yes,\n-        );\n+            // Provide extra note if synthetic arguments like `impl Trait` are specified.\n+            let synth_provided = provided <= expected_max_with_synth;\n \n-        let mut check_types_and_consts = |expected_min,\n-                                          expected_max,\n-                                          expected_max_with_synth,\n-                                          provided,\n-                                          params_offset,\n-                                          args_offset| {\n-            debug!(\n-                ?expected_min,\n-                ?expected_max,\n-                ?provided,\n-                ?params_offset,\n-                ?args_offset,\n-                \"check_types_and_consts\"\n-            );\n-            if (expected_min..=expected_max).contains(&provided) {\n-                return Ok(());\n+            GenericArgsInfo::ExcessTypesOrConsts {\n+                num_redundant_args,\n+                num_default_params,\n+                args_offset,\n+                synth_provided,\n             }\n+        } else {\n+            let num_missing_args = expected_max - provided;\n \n-            let num_default_params = expected_max - expected_min;\n-\n-            let gen_args_info = if provided > expected_max {\n-                invalid_args.extend(\n-                    gen_args.args[args_offset + expected_max..args_offset + provided]\n-                        .iter()\n-                        .map(|arg| arg.span()),\n-                );\n-                let num_redundant_args = provided - expected_max;\n+            GenericArgsInfo::MissingTypesOrConsts {\n+                num_missing_args,\n+                num_default_params,\n+                args_offset,\n+            }\n+        };\n \n-                // Provide extra note if synthetic arguments like `impl Trait` are specified.\n-                let synth_provided = provided <= expected_max_with_synth;\n+        debug!(?gen_args_info);\n \n-                GenericArgsInfo::ExcessTypesOrConsts {\n-                    num_redundant_args,\n-                    num_default_params,\n-                    args_offset,\n-                    synth_provided,\n-                }\n-            } else {\n-                let num_missing_args = expected_max - provided;\n+        let reported = WrongNumberOfGenericArgs::new(\n+            tcx,\n+            gen_args_info,\n+            seg,\n+            gen_params,\n+            params_offset,\n+            gen_args,\n+            def_id,\n+        )\n+        .diagnostic()\n+        .emit_unless(gen_args.has_err());\n \n-                GenericArgsInfo::MissingTypesOrConsts {\n-                    num_missing_args,\n-                    num_default_params,\n-                    args_offset,\n-                }\n-            };\n-\n-            debug!(?gen_args_info);\n-\n-            let reported = WrongNumberOfGenericArgs::new(\n-                tcx,\n-                gen_args_info,\n-                seg,\n-                gen_params,\n-                params_offset,\n-                gen_args,\n-                def_id,\n-            )\n-            .diagnostic()\n-            .emit_unless(gen_args.has_err());\n-\n-            Err(reported)\n-        };\n+        Err(reported)\n+    };\n \n-        let args_correct = {\n-            let expected_min = if infer_args {\n-                0\n-            } else {\n-                param_counts.consts + named_type_param_count\n-                    - default_counts.types\n-                    - default_counts.consts\n-            };\n-            debug!(?expected_min);\n-            debug!(arg_counts.lifetimes=?gen_args.num_lifetime_params());\n-\n-            check_types_and_consts(\n-                expected_min,\n-                param_counts.consts + named_type_param_count,\n-                param_counts.consts + named_type_param_count + synth_type_param_count,\n-                gen_args.num_generic_params(),\n-                param_counts.lifetimes + has_self as usize,\n-                gen_args.num_lifetime_params(),\n-            )\n+    let args_correct = {\n+        let expected_min = if infer_args {\n+            0\n+        } else {\n+            param_counts.consts + named_type_param_count\n+                - default_counts.types\n+                - default_counts.consts\n         };\n+        debug!(?expected_min);\n+        debug!(arg_counts.lifetimes=?gen_args.num_lifetime_params());\n+\n+        check_types_and_consts(\n+            expected_min,\n+            param_counts.consts + named_type_param_count,\n+            param_counts.consts + named_type_param_count + synth_type_param_count,\n+            gen_args.num_generic_params(),\n+            param_counts.lifetimes + has_self as usize,\n+            gen_args.num_lifetime_params(),\n+        )\n+    };\n \n-        GenericArgCountResult {\n-            explicit_late_bound,\n-            correct: lifetimes_correct.and(args_correct).map_err(|reported| {\n-                GenericArgCountMismatch { reported: Some(reported), invalid_args }\n-            }),\n-        }\n+    GenericArgCountResult {\n+        explicit_late_bound,\n+        correct: lifetimes_correct\n+            .and(args_correct)\n+            .map_err(|reported| GenericArgCountMismatch { reported: Some(reported), invalid_args }),\n     }\n+}\n \n-    /// Emits an error regarding forbidden type binding associations\n-    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n-        tcx.sess.emit_err(AssocTypeBindingNotAllowed { span });\n-    }\n+/// Emits an error regarding forbidden type binding associations\n+pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n+    tcx.sess.emit_err(AssocTypeBindingNotAllowed { span });\n+}\n \n-    /// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n-    /// are present. This is used both for datatypes and function calls.\n-    pub(crate) fn prohibit_explicit_late_bound_lifetimes(\n-        tcx: TyCtxt<'_>,\n-        def: &ty::Generics,\n-        args: &hir::GenericArgs<'_>,\n-        position: GenericArgPosition,\n-    ) -> ExplicitLateBound {\n-        let param_counts = def.own_counts();\n-        let infer_lifetimes = position != GenericArgPosition::Type && !args.has_lifetime_params();\n-\n-        if infer_lifetimes {\n-            return ExplicitLateBound::No;\n-        }\n+/// Prohibits explicit lifetime arguments if late-bound lifetime parameters\n+/// are present. This is used both for datatypes and function calls.\n+pub(crate) fn prohibit_explicit_late_bound_lifetimes(\n+    tcx: TyCtxt<'_>,\n+    def: &ty::Generics,\n+    args: &hir::GenericArgs<'_>,\n+    position: GenericArgPosition,\n+) -> ExplicitLateBound {\n+    let param_counts = def.own_counts();\n+    let infer_lifetimes = position != GenericArgPosition::Type && !args.has_lifetime_params();\n+\n+    if infer_lifetimes {\n+        return ExplicitLateBound::No;\n+    }\n \n-        if let Some(span_late) = def.has_late_bound_regions {\n-            let msg = \"cannot specify lifetime arguments explicitly \\\n+    if let Some(span_late) = def.has_late_bound_regions {\n+        let msg = \"cannot specify lifetime arguments explicitly \\\n                        if late bound lifetime parameters are present\";\n-            let note = \"the late bound lifetime parameter is introduced here\";\n-            let span = args.args[0].span();\n-\n-            if position == GenericArgPosition::Value\n-                && args.num_lifetime_params() != param_counts.lifetimes\n-            {\n-                let mut err = tcx.sess.struct_span_err(span, msg);\n-                err.span_note(span_late, note);\n-                err.emit();\n-            } else {\n-                let mut multispan = MultiSpan::from_span(span);\n-                multispan.push_span_label(span_late, note);\n-                tcx.struct_span_lint_hir(\n-                    LATE_BOUND_LIFETIME_ARGUMENTS,\n-                    args.args[0].hir_id(),\n-                    multispan,\n-                    msg,\n-                    |lint| lint,\n-                );\n-            }\n-\n-            ExplicitLateBound::Yes\n+        let note = \"the late bound lifetime parameter is introduced here\";\n+        let span = args.args[0].span();\n+\n+        if position == GenericArgPosition::Value\n+            && args.num_lifetime_params() != param_counts.lifetimes\n+        {\n+            let mut err = tcx.sess.struct_span_err(span, msg);\n+            err.span_note(span_late, note);\n+            err.emit();\n         } else {\n-            ExplicitLateBound::No\n+            let mut multispan = MultiSpan::from_span(span);\n+            multispan.push_span_label(span_late, note);\n+            tcx.struct_span_lint_hir(\n+                LATE_BOUND_LIFETIME_ARGUMENTS,\n+                args.args[0].hir_id(),\n+                multispan,\n+                msg,\n+                |lint| lint,\n+            );\n         }\n+\n+        ExplicitLateBound::Yes\n+    } else {\n+        ExplicitLateBound::No\n     }\n }"}, {"sha": "6a673e8ae4e3bef5709923d777b90814ea27c6ef", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 43, "deletions": 38, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -3,8 +3,11 @@\n //! instance of `AstConv`.\n \n mod errors;\n-mod generics;\n+pub mod generics;\n \n+use crate::astconv::generics::{\n+    check_generic_arg_count, create_substs_for_generic_args, prohibit_assoc_ty_binding,\n+};\n use crate::bounds::Bounds;\n use crate::collect::HirPlaceholderCollector;\n use crate::errors::{\n@@ -106,11 +109,12 @@ pub trait AstConv<'tcx> {\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx>;\n \n-    /// Normalize an associated type coming from the user.\n-    ///\n-    /// This should only be used by astconv. Use `FnCtxt::normalize`\n-    /// or `ObligationCtxt::normalize` in downstream crates.\n-    fn normalize_ty(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx>;\n+    /// Returns `AdtDef` if `ty` is an ADT.\n+    /// Note that `ty` might be a projection type that needs normalization.\n+    /// This used to get the enum variants in scope of the type.\n+    /// For example, `Self::A` could refer to an associated type\n+    /// or to an enum variant depending on the result of this function.\n+    fn probe_adt(&self, span: Span, ty: Ty<'tcx>) -> Option<ty::AdtDef<'tcx>>;\n \n     /// Invoked when we encounter an error from some prior pass\n     /// (e.g., resolve) that is translated into a ty-error. This is\n@@ -119,6 +123,13 @@ pub trait AstConv<'tcx> {\n     fn set_tainted_by_errors(&self, e: ErrorGuaranteed);\n \n     fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, span: Span);\n+\n+    fn astconv(&self) -> &dyn AstConv<'tcx>\n+    where\n+        Self: Sized,\n+    {\n+        self\n+    }\n }\n \n #[derive(Debug)]\n@@ -278,7 +289,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty::BoundConstness::NotConst,\n         );\n         if let Some(b) = item_segment.args().bindings.first() {\n-            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n \n         substs\n@@ -348,7 +359,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             assert!(self_ty.is_none());\n         }\n \n-        let arg_count = Self::check_generic_arg_count(\n+        let arg_count = check_generic_arg_count(\n             tcx,\n             span,\n             def_id,\n@@ -485,14 +496,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 // Avoid ICE #86756 when type error recovery goes awry.\n                                 return tcx.ty_error().into();\n                             }\n-                            self.astconv\n-                                .normalize_ty(\n-                                    self.span,\n-                                    tcx.at(self.span)\n-                                        .bound_type_of(param.def_id)\n-                                        .subst(tcx, substs),\n-                                )\n-                                .into()\n+                            tcx.at(self.span).bound_type_of(param.def_id).subst(tcx, substs).into()\n                         } else if infer_args {\n                             self.astconv.ty_infer(Some(param), self.span).into()\n                         } else {\n@@ -530,7 +534,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             inferred_params: vec![],\n             infer_args,\n         };\n-        let substs = Self::create_substs_for_generic_args(\n+        let substs = create_substs_for_generic_args(\n             tcx,\n             def_id,\n             parent_substs,\n@@ -616,7 +620,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         );\n \n         if let Some(b) = item_segment.args().bindings.first() {\n-            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n \n         args\n@@ -810,7 +814,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             constness,\n         );\n         if let Some(b) = trait_segment.args().bindings.first() {\n-            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+            prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n         self.tcx().mk_trait_ref(trait_def_id, substs)\n     }\n@@ -989,7 +993,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// ```\n     ///\n     /// The `sized_by_default` parameter indicates if, in this context, the `param_ty` should be\n-    /// considered `Sized` unless there is an explicit `?Sized` bound.  This would be true in the\n+    /// considered `Sized` unless there is an explicit `?Sized` bound. This would be true in the\n     /// example above, but is not true in supertrait listings like `trait Foo: Bar + Baz`.\n     ///\n     /// `span` should be the declaration size of the parameter.\n@@ -1267,7 +1271,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         item_segment: &hir::PathSegment<'_>,\n     ) -> Ty<'tcx> {\n         let substs = self.ast_path_substs_for_ty(span, did, item_segment);\n-        self.normalize_ty(span, self.tcx().at(span).bound_type_of(did).subst(self.tcx(), substs))\n+        self.tcx().at(span).bound_type_of(did).subst(self.tcx(), substs)\n     }\n \n     fn conv_object_ty_poly_trait_ref(\n@@ -1494,7 +1498,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             i.trait_ref().map_bound(|trait_ref: ty::TraitRef<'tcx>| {\n                 assert_eq!(trait_ref.self_ty(), dummy_self);\n \n-                // Verify that `dummy_self` did not leak inside default type parameters.  This\n+                // Verify that `dummy_self` did not leak inside default type parameters. This\n                 // could not be done at path creation, since we need to see through trait aliases.\n                 let mut missing_type_params = vec![];\n                 let mut references_self = false;\n@@ -1832,7 +1836,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Ok(bound)\n     }\n \n-    // Create a type from a path to an associated type.\n+    // Create a type from a path to an associated type or to an enum variant.\n     // For a path `A::B::C::D`, `qself_ty` and `qself_def` are the type and def for `A::B::C`\n     // and item_segment is the path segment for `D`. We return a type and a def for\n     // the whole path.\n@@ -1860,7 +1864,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // Check if we have an enum variant.\n         let mut variant_resolution = None;\n-        if let ty::Adt(adt_def, adt_substs) = qself_ty.kind() {\n+        if let Some(adt_def) = self.probe_adt(span, qself_ty) {\n             if adt_def.is_enum() {\n                 let variant_def = adt_def\n                     .variants()\n@@ -1962,14 +1966,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let Some(assoc_ty_did) = self.lookup_assoc_ty(assoc_ident, hir_ref_id, span, impl_) else {\n                     continue;\n                 };\n+                let ty::Adt(_, adt_substs) = qself_ty.kind() else {\n+                    // FIXME(inherent_associated_types)\n+                    bug!(\"unimplemented: non-adt self of inherent assoc ty\");\n+                };\n                 let item_substs = self.create_substs_for_associated_item(\n                     span,\n                     assoc_ty_did,\n                     assoc_segment,\n                     adt_substs,\n                 );\n                 let ty = tcx.bound_type_of(assoc_ty_did).subst(tcx, item_substs);\n-                let ty = self.normalize_ty(span, ty);\n                 return Ok((ty, DefKind::AssocTy, assoc_ty_did));\n             }\n         }\n@@ -2066,7 +2073,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         };\n \n         let ty = self.projected_ty_from_poly_trait_ref(span, assoc_ty_did, assoc_segment, bound);\n-        let ty = self.normalize_ty(span, ty);\n \n         if let Some(variant_def_id) = variant_resolution {\n             tcx.struct_span_lint_hir(\n@@ -2202,7 +2208,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"qpath_to_ty: trait_ref={:?}\", trait_ref);\n \n-        self.normalize_ty(span, tcx.mk_projection(item_def_id, item_substs))\n+        tcx.mk_projection(item_def_id, item_substs)\n     }\n \n     pub fn prohibit_generics<'a>(\n@@ -2305,7 +2311,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         for segment in segments {\n             // Only emit the first error to avoid overloading the user with error messages.\n             if let Some(b) = segment.args().bindings.first() {\n-                Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n+                prohibit_assoc_ty_binding(self.tcx(), b.span);\n                 return true;\n             }\n         }\n@@ -2319,6 +2325,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Option<Ty<'tcx>>,\n         kind: DefKind,\n         def_id: DefId,\n+        span: Span,\n     ) -> Vec<PathSeg> {\n         // We need to extract the type parameters supplied by the user in\n         // the path `path`. Due to the current setup, this is a bit of a\n@@ -2386,8 +2393,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             // Case 2. Reference to a variant constructor.\n             DefKind::Ctor(CtorOf::Variant, ..) | DefKind::Variant => {\n-                let adt_def = self_ty.map(|t| t.ty_adt_def().unwrap());\n-                let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n+                let (generics_def_id, index) = if let Some(self_ty) = self_ty {\n+                    let adt_def = self.probe_adt(span, self_ty).unwrap();\n                     debug_assert!(adt_def.is_enum());\n                     (adt_def.did(), last)\n                 } else if last >= 1 && segments[last - 1].args.is_some() {\n@@ -2463,7 +2470,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     err.note(\"`impl Trait` types can't have type parameters\");\n                 });\n                 let substs = self.ast_path_substs_for_ty(span, did, item_segment.0);\n-                self.normalize_ty(span, tcx.mk_opaque(did, substs))\n+                tcx.mk_opaque(did, substs)\n             }\n             Res::Def(\n                 DefKind::Enum\n@@ -2483,7 +2490,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 assert_eq!(opt_self_ty, None);\n \n                 let path_segs =\n-                    self.def_ids_for_value_path_segments(path.segments, None, kind, def_id);\n+                    self.def_ids_for_value_path_segments(path.segments, None, kind, def_id, span);\n                 let generic_segs: FxHashSet<_> =\n                     path_segs.iter().map(|PathSeg(_, index)| index).collect();\n                 self.prohibit_generics(\n@@ -2623,7 +2630,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                     tcx.ty_error_with_guaranteed(err.emit())\n                 } else {\n-                    self.normalize_ty(span, ty)\n+                    ty\n                 }\n             }\n             Res::Def(DefKind::AssocTy, def_id) => {\n@@ -2687,7 +2694,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     /// Parses the programmer's textual representation of a type into our\n-    /// internal notion of a type.  This is meant to be used within a path.\n+    /// internal notion of a type. This is meant to be used within a path.\n     pub fn ast_ty_to_ty_in_path(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n         self.ast_ty_to_ty_inner(ast_ty, false, true)\n     }\n@@ -2766,8 +2773,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     None,\n                     ty::BoundConstness::NotConst,\n                 );\n-                EarlyBinder(self.normalize_ty(span, tcx.at(span).type_of(def_id)))\n-                    .subst(tcx, substs)\n+                EarlyBinder(tcx.at(span).type_of(def_id)).subst(tcx, substs)\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n                 let length = match length {\n@@ -2777,8 +2783,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 };\n \n-                let array_ty = tcx.mk_ty(ty::Array(self.ast_ty_to_ty(ty), length));\n-                self.normalize_ty(ast_ty.span, array_ty)\n+                tcx.mk_ty(ty::Array(self.ast_ty_to_ty(ty), length))\n             }\n             hir::TyKind::Typeof(ref e) => {\n                 let ty_erased = tcx.type_of(e.def_id);"}, {"sha": "730560cc6868627e593dad15649f951df8075093", "filename": "compiler/rustc_hir_analysis/src/autoderef.rs", "status": "renamed", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -178,6 +178,10 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n         self.state.obligations\n     }\n \n+    pub fn current_obligations(&self) -> Vec<traits::PredicateObligation<'tcx>> {\n+        self.state.obligations.clone()\n+    }\n+\n     pub fn steps(&self) -> &[(Ty<'tcx>, AutoderefKind)] {\n         &self.state.steps\n     }", "previous_filename": "compiler/rustc_trait_selection/src/autoderef.rs"}, {"sha": "43795cfba3fd81edc85efcd69526445e26c82a54", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -468,14 +468,14 @@ fn check_opaque_meets_bounds<'tcx>(\n         // Can have different predicates to their defining use\n         hir::OpaqueTyOrigin::TyAlias => {\n             let outlives_environment = OutlivesEnvironment::new(param_env);\n-            let _ = infcx.check_region_obligations_and_report_errors(\n+            let _ = infcx.err_ctxt().check_region_obligations_and_report_errors(\n                 defining_use_anchor,\n                 &outlives_environment,\n             );\n         }\n     }\n     // Clean up after ourselves\n-    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+    let _ = infcx.take_opaque_types();\n }\n \n fn is_enum_of_nonnullable_ptr<'tcx>("}, {"sha": "b193e7b4d4cd2629b95ee961ba2fceac3958c2cb", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -136,7 +136,7 @@ pub(super) fn compare_impl_method<'tcx>(\n ///     <'a> fn(t: &'i0 U0, m: &'a) -> Foo\n ///\n /// This type is also the same but the name of the bound region (`'a`\n-/// vs `'b`).  However, the normal subtyping rules on fn types handle\n+/// vs `'b`). However, the normal subtyping rules on fn types handle\n /// this kind of equivalency just fine.\n ///\n /// We now use these substitutions to ensure that all declared bounds are\n@@ -424,7 +424,7 @@ fn compare_asyncness<'tcx>(\n             ty::Alias(ty::Opaque, ..) => {\n                 // allow both `async fn foo()` and `fn foo() -> impl Future`\n             }\n-            ty::Error(rustc_errors::ErrorGuaranteed { .. }) => {\n+            ty::Error(_) => {\n                 // We don't know if it's ok, but at least it's already an error.\n             }\n             _ => {\n@@ -615,7 +615,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n         Some(infcx),\n         infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n     );\n-    infcx.check_region_obligations_and_report_errors(\n+    infcx.err_ctxt().check_region_obligations_and_report_errors(\n         impl_m.def_id.expect_local(),\n         &outlives_environment,\n     )?;\n@@ -625,7 +625,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n         match infcx.fully_resolve(ty) {\n             Ok(ty) => {\n                 // `ty` contains free regions that we created earlier while liberating the\n-                // trait fn signature.  However, projection normalization expects `ty` to\n+                // trait fn signature. However, projection normalization expects `ty` to\n                 // contains `def_id`'s early-bound regions.\n                 let id_substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 debug!(?id_substs, ?substs);\n@@ -883,7 +883,7 @@ fn check_region_bounds_on_impl_item<'tcx>(\n \n     // Must have same number of early-bound lifetime parameters.\n     // Unfortunately, if the user screws up the bounds, then this\n-    // will change classification between early and late.  E.g.,\n+    // will change classification between early and late. E.g.,\n     // if in trait we have `<'a,'b:'a>`, and in impl we just have\n     // `<'a,'b>`, then we have 2 early-bound lifetime parameters\n     // in trait but 0 in the impl. But if we report \"expected 2\n@@ -994,9 +994,9 @@ fn compare_self_type<'tcx>(\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n     // Try to give more informative error messages about self typing\n-    // mismatches.  Note that any mismatch will also be detected\n+    // mismatches. Note that any mismatch will also be detected\n     // below, where we construct a canonical function type that\n-    // includes the self parameter as a normal parameter.  It's just\n+    // includes the self parameter as a normal parameter. It's just\n     // that the error messages you get out of this code are a bit more\n     // inscrutable, particularly for cases where one method has no\n     // self.\n@@ -1643,8 +1643,9 @@ pub(super) fn compare_impl_const_raw(\n     }\n \n     let outlives_environment = OutlivesEnvironment::new(param_env);\n-    infcx.check_region_obligations_and_report_errors(impl_const_item_def, &outlives_environment)?;\n-\n+    infcx\n+        .err_ctxt()\n+        .check_region_obligations_and_report_errors(impl_const_item_def, &outlives_environment)?;\n     Ok(())\n }\n \n@@ -1752,7 +1753,7 @@ fn compare_type_predicate_entailment<'tcx>(\n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n     let outlives_environment = OutlivesEnvironment::new(param_env);\n-    infcx.check_region_obligations_and_report_errors(\n+    infcx.err_ctxt().check_region_obligations_and_report_errors(\n         impl_ty.def_id.expect_local(),\n         &outlives_environment,\n     )?;\n@@ -1966,27 +1967,11 @@ pub(super) fn check_type_bounds<'tcx>(\n     let outlives_environment =\n         OutlivesEnvironment::with_bounds(param_env, Some(&infcx), implied_bounds);\n \n-    infcx.check_region_obligations_and_report_errors(\n+    infcx.err_ctxt().check_region_obligations_and_report_errors(\n         impl_ty.def_id.expect_local(),\n         &outlives_environment,\n     )?;\n \n-    let constraints = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-    for (key, value) in constraints {\n-        infcx\n-            .err_ctxt()\n-            .report_mismatched_types(\n-                &ObligationCause::misc(\n-                    value.hidden_type.span,\n-                    tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local()),\n-                ),\n-                tcx.mk_opaque(key.def_id.to_def_id(), key.substs),\n-                value.hidden_type.ty,\n-                TypeError::Mismatch,\n-            )\n-            .emit();\n-    }\n-\n     Ok(())\n }\n "}, {"sha": "64fd61c1359b599edbd2ae97bb5baae89e6e41b0", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -46,7 +46,7 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n             )\n         }\n         _ => {\n-            // Destructors only work on nominal types.  This was\n+            // Destructors only work on nominal types. This was\n             // already checked by coherence, but compilation may\n             // not have been terminated.\n             let span = tcx.def_span(drop_impl_did);"}, {"sha": "14bca34b77bea005d5057b464da32dbeb7606ef4", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -14,32 +14,32 @@ can be broken down into several distinct phases:\n \n - main: the main pass does the lion's share of the work: it\n   determines the types of all expressions, resolves\n-  methods, checks for most invalid conditions, and so forth.  In\n+  methods, checks for most invalid conditions, and so forth. In\n   some cases, where a type is unknown, it may create a type or region\n   variable and use that as the type of an expression.\n \n   In the process of checking, various constraints will be placed on\n   these type variables through the subtyping relationships requested\n-  through the `demand` module.  The `infer` module is in charge\n+  through the `demand` module. The `infer` module is in charge\n   of resolving those constraints.\n \n - regionck: after main is complete, the regionck pass goes over all\n   types looking for regions and making sure that they did not escape\n-  into places where they are not in scope.  This may also influence the\n+  into places where they are not in scope. This may also influence the\n   final assignments of the various region variables if there is some\n   flexibility.\n \n - writeback: writes the final types within a function body, replacing\n-  type variables with their final inferred types.  These final types\n+  type variables with their final inferred types. These final types\n   are written into the `tcx.node_types` table, which should *never* contain\n   any reference to a type variable.\n \n ## Intermediate types\n \n While type checking a function, the intermediate types for the\n expressions, blocks, and so forth contained within the function are\n-stored in `fcx.node_types` and `fcx.node_substs`.  These types\n-may contain unresolved type variables.  After type checking is\n+stored in `fcx.node_types` and `fcx.node_substs`. These types\n+may contain unresolved type variables. After type checking is\n complete, the functions in the writeback module are used to take the\n types from this table, resolve them, and then write them into their\n permanent home in the type context `tcx`.\n@@ -51,12 +51,12 @@ nodes within the function.\n The types of top-level items, which never contain unbound type\n variables, are stored directly into the `tcx` typeck_results.\n \n-N.B., a type variable is not the same thing as a type parameter.  A\n+N.B., a type variable is not the same thing as a type parameter. A\n type variable is an instance of a type parameter. That is,\n given a generic function `fn foo<T>(t: T)`, while checking the\n function `foo`, the type `ty_param(0)` refers to the type `T`, which\n is treated in abstract. However, when `foo()` is called, `T` will be\n-substituted for a fresh type variable `N`.  This variable will\n+substituted for a fresh type variable `N`. This variable will\n eventually be resolved to some concrete type (which might itself be\n a type parameter).\n \n@@ -441,7 +441,7 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n         ty::AssocKind::Fn => {\n             // We skip the binder here because the binder would deanonymize all\n             // late-bound regions, and we don't want method signatures to show up\n-            // `as for<'r> fn(&'r MyType)`.  Pretty-printing handles late-bound\n+            // `as for<'r> fn(&'r MyType)`. Pretty-printing handles late-bound\n             // regions just fine, showing `fn(&MyType)`.\n             fn_sig_suggestion(\n                 tcx,"}, {"sha": "479a10d6000a0ae10d0f63ee67368b7b7f400c3a", "filename": "compiler/rustc_hir_analysis/src/check/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -325,7 +325,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n                 // The idea is that call.callee_id represents *the time when\n                 // the invoked function is actually running* and call.id\n                 // represents *the time to prepare the arguments and make the\n-                // call*.  See the section \"Borrows in Calls\" borrowck/README.md\n+                // call*. See the section \"Borrows in Calls\" borrowck/README.md\n                 // for an extended explanation of why this distinction is\n                 // important.\n                 //"}, {"sha": "d1f4dbc8d84549c3f991ff59bf1d4d51c7b125e9", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,4 +1,6 @@\n+use crate::autoderef::Autoderef;\n use crate::constrained_generic_params::{identify_constrained_generic_params, Parameter};\n+\n use hir::def::DefKind;\n use rustc_ast as ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n@@ -22,7 +24,6 @@ use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::autoderef::Autoderef;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -116,7 +117,9 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n     let outlives_environment =\n         OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n \n-    let _ = infcx.check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n+    let _ = infcx\n+        .err_ctxt()\n+        .check_region_obligations_and_report_errors(body_def_id, &outlives_environment);\n }\n \n fn check_well_formed(tcx: TyCtxt<'_>, def_id: hir::OwnerId) {"}, {"sha": "ebb78213a63a13dd052f0b3b4e7c48f5c5acc451", "filename": "compiler/rustc_hir_analysis/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -50,7 +50,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     let lint = lint::builtin::UNUSED_EXTERN_CRATES;\n \n-    // Collect first the crates that are completely unused.  These we\n+    // Collect first the crates that are completely unused. These we\n     // can always suggest removing (no matter which edition we are\n     // in).\n     let unused_extern_crates: FxHashMap<LocalDefId, Span> = tcx"}, {"sha": "74179a2bc68c934051b699aaf78ee5afd1726101", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -325,7 +325,9 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n \n                 // Finally, resolve all regions.\n                 let outlives_env = OutlivesEnvironment::new(param_env);\n-                let _ = infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+                let _ = infcx\n+                    .err_ctxt()\n+                    .check_region_obligations_and_report_errors(impl_did, &outlives_env);\n             }\n         }\n         _ => {\n@@ -436,7 +438,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n             // when this coercion occurs, we would be changing the\n             // field `ptr` from a thin pointer of type `*mut [i32;\n             // 3]` to a fat pointer of type `*mut [i32]` (with\n-            // extra data `3`).  **The purpose of this check is to\n+            // extra data `3`). **The purpose of this check is to\n             // make sure that we know how to do this conversion.**\n             //\n             // To check if this impl is legal, we would walk down\n@@ -565,7 +567,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n \n     // Finally, resolve all regions.\n     let outlives_env = OutlivesEnvironment::new(param_env);\n-    let _ = infcx.check_region_obligations_and_report_errors(impl_did, &outlives_env);\n+    let _ = infcx.err_ctxt().check_region_obligations_and_report_errors(impl_did, &outlives_env);\n \n     CoerceUnsizedInfo { custom_kind: kind }\n }"}, {"sha": "ba347851af880871f567a9aa238a0d92cf64b76d", "filename": "compiler/rustc_hir_analysis/src/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -171,7 +171,7 @@ fn check_object_overlap<'tcx>(\n         for component_def_id in component_def_ids {\n             if !tcx.is_object_safe(component_def_id) {\n                 // Without the 'object_safe_for_dispatch' feature this is an error\n-                // which will be reported by wfcheck.  Ignore it here.\n+                // which will be reported by wfcheck. Ignore it here.\n                 // This is tested by `coherence-impl-trait-for-trait-object-safe.rs`.\n                 // With the feature enabled, the trait is not implemented automatically,\n                 // so this is valid."}, {"sha": "cd745ee8cab69929e714c78fa546108a30b8ca1e", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -351,7 +351,7 @@ impl<'tcx> ItemCtxt<'tcx> {\n     }\n \n     pub fn to_ty(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n-        <dyn AstConv<'_>>::ast_ty_to_ty(self, ast_ty)\n+        self.astconv().ast_ty_to_ty(ast_ty)\n     }\n \n     pub fn hir_id(&self) -> hir::HirId {\n@@ -413,8 +413,7 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx> {\n         if let Some(trait_ref) = poly_trait_ref.no_bound_vars() {\n-            let item_substs = <dyn AstConv<'tcx>>::create_substs_for_associated_item(\n-                self,\n+            let item_substs = self.astconv().create_substs_for_associated_item(\n                 span,\n                 item_def_id,\n                 item_segment,\n@@ -505,9 +504,9 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n         }\n     }\n \n-    fn normalize_ty(&self, _span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        // Types in item signatures are not normalized to avoid undue dependencies.\n-        ty\n+    fn probe_adt(&self, _span: Span, ty: Ty<'tcx>) -> Option<ty::AdtDef<'tcx>> {\n+        // FIXME(#103640): Should we handle the case where `ty` is a projection?\n+        ty.ty_adt_def()\n     }\n \n     fn set_tainted_by_errors(&self, _: ErrorGuaranteed) {\n@@ -1112,8 +1111,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                 tcx.hir().get_parent(hir_id)\n                 && i.of_trait.is_some()\n             {\n-                <dyn AstConv<'_>>::ty_of_fn(\n-                    &icx,\n+                icx.astconv().ty_of_fn(\n                     hir_id,\n                     sig.header.unsafety,\n                     sig.header.abi,\n@@ -1130,15 +1128,9 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             kind: TraitItemKind::Fn(FnSig { header, decl, span: _ }, _),\n             generics,\n             ..\n-        }) => <dyn AstConv<'_>>::ty_of_fn(\n-            &icx,\n-            hir_id,\n-            header.unsafety,\n-            header.abi,\n-            decl,\n-            Some(generics),\n-            None,\n-        ),\n+        }) => {\n+            icx.astconv().ty_of_fn(hir_id, header.unsafety, header.abi, decl, Some(generics), None)\n+        }\n \n         ForeignItem(&hir::ForeignItem { kind: ForeignItemKind::Fn(fn_decl, _, _), .. }) => {\n             let abi = tcx.hir().get_foreign_abi(hir_id);\n@@ -1244,8 +1236,7 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n \n             ty::Binder::dummy(fn_sig)\n         }\n-        None => <dyn AstConv<'_>>::ty_of_fn(\n-            icx,\n+        None => icx.astconv().ty_of_fn(\n             hir_id,\n             sig.header.unsafety,\n             sig.header.abi,\n@@ -1354,8 +1345,7 @@ fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     match item.kind {\n         hir::ItemKind::Impl(ref impl_) => impl_.of_trait.as_ref().map(|ast_trait_ref| {\n             let selfty = tcx.type_of(def_id);\n-            <dyn AstConv<'_>>::instantiate_mono_trait_ref(\n-                &icx,\n+            icx.astconv().instantiate_mono_trait_ref(\n                 ast_trait_ref,\n                 selfty,\n                 check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n@@ -1485,15 +1475,8 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n         hir::Unsafety::Unsafe\n     };\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-    let fty = <dyn AstConv<'_>>::ty_of_fn(\n-        &ItemCtxt::new(tcx, def_id),\n-        hir_id,\n-        unsafety,\n-        abi,\n-        decl,\n-        None,\n-        None,\n-    );\n+    let fty =\n+        ItemCtxt::new(tcx, def_id).astconv().ty_of_fn(hir_id, unsafety, abi, decl, None, None);\n \n     // Feature gate SIMD types in FFI, since I am not sure that the\n     // ABIs are handled at all correctly. -huonw"}, {"sha": "9a5f447c260f54d8a835ac20fe791f244eb1624e", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -4,6 +4,7 @@ use hir::{\n     GenericParamKind, HirId, Node,\n };\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint;\n@@ -142,7 +143,20 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             Some(tcx.typeck_root_def_id(def_id))\n         }\n         Node::Item(item) => match item.kind {\n-            ItemKind::OpaqueTy(hir::OpaqueTy { .. }) => {\n+            ItemKind::OpaqueTy(hir::OpaqueTy {\n+                origin:\n+                    hir::OpaqueTyOrigin::FnReturn(fn_def_id) | hir::OpaqueTyOrigin::AsyncFn(fn_def_id),\n+                in_trait,\n+                ..\n+            }) => {\n+                if in_trait {\n+                    assert!(matches!(tcx.def_kind(fn_def_id), DefKind::AssocFn))\n+                } else {\n+                    assert!(matches!(tcx.def_kind(fn_def_id), DefKind::AssocFn | DefKind::Fn))\n+                }\n+                Some(fn_def_id.to_def_id())\n+            }\n+            ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::TyAlias, .. }) => {\n                 let parent_id = tcx.hir().get_parent_item(hir_id);\n                 assert_ne!(parent_id, hir::CRATE_OWNER_ID);\n                 debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);"}, {"sha": "62eef710ba48f0542079996933b500f5b5643304", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -26,9 +26,9 @@ fn associated_type_bounds<'tcx>(\n     );\n \n     let icx = ItemCtxt::new(tcx, assoc_item_def_id);\n-    let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, ast_bounds);\n+    let mut bounds = icx.astconv().compute_bounds(item_ty, ast_bounds);\n     // Associated types are implicitly sized unless a `?Sized` bound is found\n-    <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, item_ty, ast_bounds, None, span);\n+    icx.astconv().add_implicitly_sized(&mut bounds, item_ty, ast_bounds, None, span);\n \n     let trait_def_id = tcx.parent(assoc_item_def_id);\n     let trait_predicates = tcx.trait_explicit_predicates_and_bounds(trait_def_id.expect_local());\n@@ -70,9 +70,9 @@ fn opaque_type_bounds<'tcx>(\n         };\n \n         let icx = ItemCtxt::new(tcx, opaque_def_id);\n-        let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, ast_bounds);\n+        let mut bounds = icx.astconv().compute_bounds(item_ty, ast_bounds);\n         // Opaque types are implicitly sized unless a `?Sized` bound is found\n-        <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, item_ty, ast_bounds, None, span);\n+        icx.astconv().add_implicitly_sized(&mut bounds, item_ty, ast_bounds, None, span);\n         debug!(?bounds);\n \n         tcx.arena.alloc_from_iter(bounds.predicates())"}, {"sha": "9435022ddf0e1cb65dc122e627483696e8129651", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,9 +1,9 @@\n //! Resolution of early vs late bound lifetimes.\n //!\n-//! Name resolution for lifetimes is performed on the AST and embedded into HIR.  From this\n+//! Name resolution for lifetimes is performed on the AST and embedded into HIR. From this\n //! information, typechecking needs to transform the lifetime parameters into bound lifetimes.\n-//! Lifetimes can be early-bound or late-bound.  Construction of typechecking terms needs to visit\n-//! the types in HIR to identify late-bound lifetimes and assign their Debruijn indices.  This file\n+//! Lifetimes can be early-bound or late-bound. Construction of typechecking terms needs to visit\n+//! the types in HIR to identify late-bound lifetimes and assign their Debruijn indices. This file\n //! is also responsible for assigning their semantics to implicit lifetimes in trait objects.\n \n use rustc_ast::walk_list;\n@@ -70,7 +70,7 @@ impl RegionExt for Region {\n /// that it corresponds to.\n ///\n /// FIXME. This struct gets converted to a `ResolveLifetimes` for\n-/// actual use. It has the same data, but indexed by `LocalDefId`.  This\n+/// actual use. It has the same data, but indexed by `LocalDefId`. This\n /// is silly.\n #[derive(Debug, Default)]\n struct NamedRegionMap {\n@@ -1283,7 +1283,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         // We may fail to resolve higher-ranked lifetimes that are mentioned by APIT.\n         // AST-based resolution does not care for impl-trait desugaring, which are the\n-        // responibility of lowering.  This may create a mismatch between the resolution\n+        // responibility of lowering. This may create a mismatch between the resolution\n         // AST found (`region_def_id`) which points to HRTB, and what HIR allows.\n         // ```\n         // fn foo(x: impl for<'a> Trait<'a, Assoc = impl Copy + 'a>) {}\n@@ -1434,7 +1434,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         DefKind::ConstParam => Some(ObjectLifetimeDefault::Empty),\n                         DefKind::TyParam => Some(self.tcx.object_lifetime_default(param.def_id)),\n                         // We may also get a `Trait` or `TraitAlias` because of how generics `Self` parameter\n-                        // works.  Ignore it because it can't have a meaningful lifetime default.\n+                        // works. Ignore it because it can't have a meaningful lifetime default.\n                         DefKind::LifetimeParam | DefKind::Trait | DefKind::TraitAlias => None,\n                         dk => bug!(\"unexpected def_kind {:?}\", dk),\n                     }"}, {"sha": "d43a2d72ceccf50999dc1ffd8e022f1ecba0c3be", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -162,8 +162,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n \n                 let mut bounds = Bounds::default();\n                 // Params are implicitly sized unless a `?Sized` bound is found\n-                <dyn AstConv<'_>>::add_implicitly_sized(\n-                    &icx,\n+                icx.astconv().add_implicitly_sized(\n                     &mut bounds,\n                     param_ty,\n                     &[],\n@@ -211,22 +210,16 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 }\n \n                 let mut bounds = Bounds::default();\n-                <dyn AstConv<'_>>::add_bounds(\n-                    &icx,\n-                    ty,\n-                    bound_pred.bounds.iter(),\n-                    &mut bounds,\n-                    bound_vars,\n-                );\n+                icx.astconv().add_bounds(ty, bound_pred.bounds.iter(), &mut bounds, bound_vars);\n                 predicates.extend(bounds.predicates());\n             }\n \n             hir::WherePredicate::RegionPredicate(region_pred) => {\n-                let r1 = <dyn AstConv<'_>>::ast_region_to_region(&icx, &region_pred.lifetime, None);\n+                let r1 = icx.astconv().ast_region_to_region(&region_pred.lifetime, None);\n                 predicates.extend(region_pred.bounds.iter().map(|bound| {\n                     let (r2, span) = match bound {\n                         hir::GenericBound::Outlives(lt) => {\n-                            (<dyn AstConv<'_>>::ast_region_to_region(&icx, lt, None), lt.ident.span)\n+                            (icx.astconv().ast_region_to_region(lt, None), lt.ident.span)\n                         }\n                         _ => bug!(),\n                     };\n@@ -253,7 +246,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n \n     // Subtle: before we store the predicates into the tcx, we\n     // sort them so that predicates like `T: Foo<Item=U>` come\n-    // before uses of `U`.  This avoids false ambiguity errors\n+    // before uses of `U`. This avoids false ambiguity errors\n     // in trait checking. See `setup_constraining_predicates`\n     // for details.\n     if let Node::Item(&Item { kind: ItemKind::Impl { .. }, .. }) = node {\n@@ -279,7 +272,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n         debug!(?lifetimes);\n         for (arg, duplicate) in std::iter::zip(lifetimes, ast_generics.params) {\n             let hir::GenericArg::Lifetime(arg) = arg else { bug!() };\n-            let orig_region = <dyn AstConv<'_>>::ast_region_to_region(&icx, &arg, None);\n+            let orig_region = icx.astconv().ast_region_to_region(&arg, None);\n             if !matches!(orig_region.kind(), ty::ReEarlyBound(..)) {\n                 // Only early-bound regions can point to the original generic parameter.\n                 continue;\n@@ -527,14 +520,9 @@ pub(super) fn super_predicates_that_define_assoc_type(\n         // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n         let self_param_ty = tcx.types.self_param;\n         let superbounds1 = if let Some(assoc_name) = assoc_name {\n-            <dyn AstConv<'_>>::compute_bounds_that_match_assoc_type(\n-                &icx,\n-                self_param_ty,\n-                bounds,\n-                assoc_name,\n-            )\n+            icx.astconv().compute_bounds_that_match_assoc_type(self_param_ty, bounds, assoc_name)\n         } else {\n-            <dyn AstConv<'_>>::compute_bounds(&icx, self_param_ty, bounds)\n+            icx.astconv().compute_bounds(self_param_ty, bounds)\n         };\n \n         let superbounds1 = superbounds1.predicates();"}, {"sha": "04f5f3f62765a7f5eea5c46ab69bb6bdeb514d41", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -300,3 +300,15 @@ pub(crate) struct LinkageType {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[help]\n+#[diag(hir_analysis_auto_deref_reached_recursion_limit, code = \"E0055\")]\n+pub struct AutoDerefReachedRecursionLimit<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub ty: Ty<'a>,\n+    pub suggested_limit: rustc_session::Limit,\n+    pub crate_name: Symbol,\n+}"}, {"sha": "8b9034d9620e2c3debfefc0081b6f3fdcf4217c9", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -181,7 +181,8 @@ fn get_impl_substs(\n \n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_hir_id, assumed_wf_types);\n     let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n-    let _ = infcx.check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n+    let _ =\n+        infcx.err_ctxt().check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n         let span = tcx.def_span(impl1_def_id);\n         tcx.sess.emit_err(SubstsOnOverriddenImpl { span });"}, {"sha": "9f8da463650fdaa69d30f8d69ce7ea84a0b1853e", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -22,7 +22,7 @@ several major phases:\n 4. Finally, the check phase then checks function bodies and so forth.\n    Within the check phase, we check each function body one at a time\n    (bodies of function expressions are checked as part of the\n-   containing function).  Inference is used to supply types wherever\n+   containing function). Inference is used to supply types wherever\n    they are unknown. The actual checking of a function itself has\n    several phases (check, regionck, writeback), as discussed in the\n    documentation for the [`check`] module.\n@@ -46,7 +46,7 @@ independently:\n   local variables, type parameters, etc as necessary.\n \n - infer: finds the types to use for each type variable such that\n-  all subtyping and assignment constraints are met.  In essence, the check\n+  all subtyping and assignment constraints are met. In essence, the check\n   module specifies the constraints, and the infer module solves them.\n \n ## Note\n@@ -84,6 +84,7 @@ extern crate rustc_middle;\n pub mod check;\n \n pub mod astconv;\n+pub mod autoderef;\n mod bounds;\n mod check_unused;\n mod coherence;\n@@ -541,10 +542,10 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorGuaranteed> {\n pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n-    // scope.  This is derived from the enclosing item-like thing.\n+    // scope. This is derived from the enclosing item-like thing.\n     let env_def_id = tcx.hir().get_parent_item(hir_ty.hir_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n-    <dyn AstConv<'_>>::ast_ty_to_ty(&item_cx, hir_ty)\n+    item_cx.astconv().ast_ty_to_ty(hir_ty)\n }\n \n pub fn hir_trait_to_predicates<'tcx>(\n@@ -554,12 +555,11 @@ pub fn hir_trait_to_predicates<'tcx>(\n ) -> Bounds<'tcx> {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n-    // scope.  This is derived from the enclosing item-like thing.\n+    // scope. This is derived from the enclosing item-like thing.\n     let env_def_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n     let mut bounds = Bounds::default();\n-    let _ = <dyn AstConv<'_>>::instantiate_poly_trait_ref(\n-        &item_cx,\n+    let _ = &item_cx.astconv().instantiate_poly_trait_ref(\n         hir_trait,\n         DUMMY_SP,\n         ty::BoundConstness::NotConst,"}, {"sha": "925042436dec150821c957051f7f13283069b84e", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -139,7 +139,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 if let Some(unsubstituted_predicates) = global_inferred_outlives.get(&def.did()) {\n                     for (unsubstituted_predicate, &span) in &unsubstituted_predicates.0 {\n                         // `unsubstituted_predicate` is `U: 'b` in the\n-                        // example above.  So apply the substitution to\n+                        // example above. So apply the substitution to\n                         // get `T: 'a` (or `predicate`):\n                         let predicate = unsubstituted_predicates\n                             .rebind(*unsubstituted_predicate)"}, {"sha": "c930b921b75c9bd59e91a3e3ee3f870c96b12a34", "filename": "compiler/rustc_hir_analysis/src/outlives/utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -48,7 +48,7 @@ pub(crate) fn insert_outlives_predicate<'tcx>(\n                         // ```\n                         //\n                         // Here `outlived_region = 'a` and `kind = &'b\n-                        // u32`.  Decomposing `&'b u32` into\n+                        // u32`. Decomposing `&'b u32` into\n                         // components would yield `'b`, and we add the\n                         // where clause that `'b: 'a`.\n                         insert_outlives_predicate(\n@@ -71,7 +71,7 @@ pub(crate) fn insert_outlives_predicate<'tcx>(\n                         // ```\n                         //\n                         // Here `outlived_region = 'a` and `kind =\n-                        // Vec<U>`.  Decomposing `Vec<U>` into\n+                        // Vec<U>`. Decomposing `Vec<U>` into\n                         // components would yield `U`, and we add the\n                         // where clause that `U: 'a`.\n                         let ty: Ty<'tcx> = param_ty.to_ty(tcx);\n@@ -115,7 +115,7 @@ pub(crate) fn insert_outlives_predicate<'tcx>(\n \n                     Component::EscapingProjection(_) => {\n                         // As above, but the projection involves\n-                        // late-bound regions.  Therefore, the WF\n+                        // late-bound regions. Therefore, the WF\n                         // requirement is not checked in type definition\n                         // but at fn call site, so ignore it.\n                         //\n@@ -175,7 +175,7 @@ fn is_free_region(region: Region<'_>) -> bool {\n         //     }\n         //\n         // The type above might generate a `T: 'b` bound, but we can\n-        // ignore it.  We can't put it on the struct header anyway.\n+        // ignore it. We can't put it on the struct header anyway.\n         ty::ReLateBound(..) => false,\n \n         // These regions don't appear in types from type declarations:"}, {"sha": "c9b59d35704b2846b25833245d6588d44735ed05", "filename": "compiler/rustc_hir_analysis/src/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -44,7 +44,7 @@ pub fn solve_constraints<'tcx>(\n \n impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n     fn solve(&mut self) {\n-        // Propagate constraints until a fixed point is reached.  Note\n+        // Propagate constraints until a fixed point is reached. Note\n         // that the maximum number of iterations is 2C where C is the\n         // number of constraints (each variable can change values at most\n         // twice). Since number of constraints is linear in size of the"}, {"sha": "f74c551a45b66ef7778555b5e301a359dac2c049", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1464,6 +1464,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprKind::Closure(&hir::Closure {\n                 binder,\n+                constness,\n                 capture_clause,\n                 bound_generic_params,\n                 fn_decl,\n@@ -1474,6 +1475,7 @@ impl<'a> State<'a> {\n                 def_id: _,\n             }) => {\n                 self.print_closure_binder(binder, bound_generic_params);\n+                self.print_constness(constness);\n                 self.print_capture_clause(capture_clause);\n \n                 self.print_closure_params(fn_decl, body);\n@@ -2272,10 +2274,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_header_info(&mut self, header: hir::FnHeader) {\n-        match header.constness {\n-            hir::Constness::NotConst => {}\n-            hir::Constness::Const => self.word_nbsp(\"const\"),\n-        }\n+        self.print_constness(header.constness);\n \n         match header.asyncness {\n             hir::IsAsync::NotAsync => {}\n@@ -2292,6 +2291,13 @@ impl<'a> State<'a> {\n         self.word(\"fn\")\n     }\n \n+    pub fn print_constness(&mut self, s: hir::Constness) {\n+        match s {\n+            hir::Constness::NotConst => {}\n+            hir::Constness::Const => self.word_nbsp(\"const\"),\n+        }\n+    }\n+\n     pub fn print_unsafety(&mut self, s: hir::Unsafety) {\n         match s {\n             hir::Unsafety::Normal => {}"}, {"sha": "7873257c4e3d1c46343920842db11bcd62c01314", "filename": "compiler/rustc_hir_typeck/src/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -2,11 +2,11 @@\n use super::method::MethodCallee;\n use super::{FnCtxt, PlaceOp};\n \n+use rustc_hir_analysis::autoderef::{Autoderef, AutoderefKind};\n use rustc_infer::infer::InferOk;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n-use rustc_trait_selection::autoderef::{Autoderef, AutoderefKind};\n \n use std::iter;\n "}, {"sha": "8d417290407ed033049bbe2d48afb48b99d94c2a", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,4 +1,4 @@\n-use super::method::probe::{IsSuggestion, Mode, ProbeScope};\n+use super::method::probe::ProbeScope;\n use super::method::MethodCallee;\n use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n \n@@ -8,6 +8,7 @@ use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed,\n use rustc_hir as hir;\n use rustc_hir::def::{self, CtorKind, Namespace, Res};\n use rustc_hir::def_id::DefId;\n+use rustc_hir_analysis::autoderef::Autoderef;\n use rustc_infer::{\n     infer,\n     traits::{self, Obligation},\n@@ -25,7 +26,6 @@ use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n-use rustc_trait_selection::autoderef::Autoderef;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::DefIdOrName;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -496,15 +496,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // any strange errors. If it's successful, then we'll do a true\n             // method lookup.\n             let Ok(pick) = self\n-            .probe_for_name(\n-                Mode::MethodCall,\n+            .lookup_probe_for_diagnostic(\n                 segment.ident,\n-                IsSuggestion(true),\n                 callee_ty,\n-                call_expr.hir_id,\n+                call_expr,\n                 // We didn't record the in scope traits during late resolution\n                 // so we need to probe AllTraits unfortunately\n                 ProbeScope::AllTraits,\n+                expected.only_has_type(self),\n             ) else {\n                 return None;\n             };"}, {"sha": "26e8dd654c13f57d823a9263437d04f96be79f4f", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -524,7 +524,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // FIXME(#45727): As discussed in [this comment][c1], naively\n         // forcing equality here actually results in suboptimal error\n-        // messages in some cases.  For now, if there would have been\n+        // messages in some cases. For now, if there would have been\n         // an obvious error, we fallback to declaring the type of the\n         // closure to be the one the user gave, which allows other\n         // error message code to trigger.\n@@ -647,14 +647,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ),\n             bound_vars,\n         );\n-        // Astconv can't normalize inputs or outputs with escaping bound vars,\n-        // so normalize them here, after we've wrapped them in a binder.\n-        let result = self.normalize(self.tcx.hir().span(hir_id), result);\n \n         let c_result = self.inh.infcx.canonicalize_response(result);\n         self.typeck_results.borrow_mut().user_provided_sigs.insert(expr_def_id, c_result);\n \n-        result\n+        // Normalize only after registering in `user_provided_sigs`.\n+        self.normalize(self.tcx.hir().span(hir_id), result)\n     }\n \n     /// Invoked when we are translating the generator that results"}, {"sha": "bbf7b81a2cc66ca82ccff36b50b0947c99710b77", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -13,7 +13,7 @@\n //! useful for freezing mut things (that is, when the expected type is &T\n //! but you have &mut T) and also for avoiding the linearity\n //! of mut things (when the expected is &mut T and you have &mut T). See\n-//! the various `src/test/ui/coerce/*.rs` tests for\n+//! the various `tests/ui/coerce/*.rs` tests for\n //! examples of where this is useful.\n //!\n //! ## Subtle note\n@@ -313,7 +313,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // If we have a parameter of type `&M T_a` and the value\n         // provided is `expr`, we will be adding an implicit borrow,\n-        // meaning that we convert `f(expr)` to `f(&M *expr)`.  Therefore,\n+        // meaning that we convert `f(expr)` to `f(&M *expr)`. Therefore,\n         // to type check, we will construct the type that `&M*expr` would\n         // yield.\n \n@@ -340,7 +340,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 continue;\n             }\n \n-            // At this point, we have deref'd `a` to `referent_ty`.  So\n+            // At this point, we have deref'd `a` to `referent_ty`. So\n             // imagine we are coercing from `&'a mut Vec<T>` to `&'b mut [T]`.\n             // In the autoderef loop for `&'a mut Vec<T>`, we would get\n             // three callbacks:\n@@ -371,7 +371,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // - if in sub mode, that means we want to use `'b` (the\n             //   region from the target reference) for both\n             //   pointers [2]. This is because sub mode (somewhat\n-            //   arbitrarily) returns the subtype region.  In the case\n+            //   arbitrarily) returns the subtype region. In the case\n             //   where we are coercing to a target type, we know we\n             //   want to use that target type region (`'b`) because --\n             //   for the program to type-check -- it must be the\n@@ -383,7 +383,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             //     annotate the region of a borrow), and regionck has\n             //     code that adds edges from the region of a borrow\n             //     (`'b`, here) into the regions in the borrowed\n-            //     expression (`*x`, here).  (Search for \"link\".)\n+            //     expression (`*x`, here). (Search for \"link\".)\n             // - if in lub mode, things can get fairly complicated. The\n             //   easiest thing is just to make a fresh\n             //   region variable [4], which effectively means we defer\n@@ -457,7 +457,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         if ty == a && mt_a.mutbl.is_not() && autoderef.step_count() == 1 {\n             // As a special case, if we would produce `&'a *x`, that's\n             // a total no-op. We end up with the type `&'a T` just as\n-            // we started with.  In that case, just skip it\n+            // we started with. In that case, just skip it\n             // altogether. This is just an optimization.\n             //\n             // Note that for `&mut`, we DO want to reborrow --\n@@ -1476,7 +1476,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             //     if let Some(x) = ... { }\n             //\n             // we wind up with a second match arm that is like `_ =>\n-            // ()`.  That is the case we are considering here. We take\n+            // ()`. That is the case we are considering here. We take\n             // a different path to get the right \"expected, found\"\n             // message and so forth (and because we know that\n             // `expression_ty` will be unit).\n@@ -1807,7 +1807,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             // Get the return type.\n             && let hir::TyKind::OpaqueDef(..) = ty.kind\n         {\n-            let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty);\n+            let ty = fcx.astconv().ast_ty_to_ty( ty);\n             // Get the `impl Trait`'s `DefId`.\n             if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = ty.kind()\n                 // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n@@ -1866,7 +1866,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     fn is_return_ty_unsized<'a>(&self, fcx: &FnCtxt<'a, 'tcx>, blk_id: hir::HirId) -> bool {\n         if let Some((fn_decl, _)) = fcx.get_fn_decl(blk_id)\n             && let hir::FnRetTy::Return(ty) = fn_decl.output\n-            && let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty)\n+            && let ty = fcx.astconv().ast_ty_to_ty( ty)\n             && let ty::Dynamic(..) = ty.kind()\n         {\n             return true;"}, {"sha": "6c128d0aa1a658ffa149a45c995d75d0c3b3c555", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -303,11 +303,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Get the evaluated type *after* calling the method call, so that the influence\n                 // of the arguments can be reflected in the receiver type. The receiver\n                 // expression has the type *before* theis analysis is done.\n-                let ty = match self.lookup_probe(\n+                let ty = match self.lookup_probe_for_diagnostic(\n                     segment.ident,\n                     rcvr_ty,\n                     expr,\n                     probe::ProbeScope::TraitsInScope,\n+                    None,\n                 ) {\n                     Ok(pick) => pick.self_ty,\n                     Err(_) => rcvr_ty,\n@@ -557,19 +558,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let Some(self_ty) = self.typeck_results.borrow().expr_ty_adjusted_opt(base) else { return; };\n \n         let Ok(pick) = self\n-            .probe_for_name(\n-                probe::Mode::MethodCall,\n+            .lookup_probe_for_diagnostic(\n                 path.ident,\n-                probe::IsSuggestion(true),\n                 self_ty,\n-                deref.hir_id,\n+                deref,\n                 probe::ProbeScope::TraitsInScope,\n+                None,\n             ) else {\n                 return;\n             };\n         let in_scope_methods = self.probe_for_name_many(\n             probe::Mode::MethodCall,\n             path.ident,\n+            Some(expected),\n             probe::IsSuggestion(true),\n             self_ty,\n             deref.hir_id,\n@@ -581,6 +582,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let all_methods = self.probe_for_name_many(\n             probe::Mode::MethodCall,\n             path.ident,\n+            Some(expected),\n             probe::IsSuggestion(true),\n             self_ty,\n             deref.hir_id,\n@@ -1832,7 +1834,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_for_range_as_method_call(\n         &self,\n         err: &mut Diagnostic,\n-        expr: &hir::Expr<'_>,\n+        expr: &hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n     ) {\n@@ -1850,10 +1852,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n         let mut expr = end.expr;\n+        let mut expectation = Some(expected_ty);\n         while let hir::ExprKind::MethodCall(_, rcvr, ..) = expr.kind {\n             // Getting to the root receiver and asserting it is a fn call let's us ignore cases in\n-            // `src/test/ui/methods/issues/issue-90315.stderr`.\n+            // `tests/ui/methods/issues/issue-90315.stderr`.\n             expr = rcvr;\n+            // If we have more than one layer of calls, then the expected ty\n+            // cannot guide the method probe.\n+            expectation = None;\n         }\n         let hir::ExprKind::Call(method_name, _) = expr.kind else { return; };\n         let ty::Adt(adt, _) = checked_ty.kind() else { return; };\n@@ -1869,13 +1875,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let hir::ExprKind::Path(hir::QPath::Resolved(None, p)) = method_name.kind else { return; };\n         let [hir::PathSegment { ident, .. }] = p.segments else { return; };\n         let self_ty = self.typeck_results.borrow().expr_ty(start.expr);\n-        let Ok(_pick) = self.probe_for_name(\n-            probe::Mode::MethodCall,\n+        let Ok(_pick) = self.lookup_probe_for_diagnostic(\n             *ident,\n-            probe::IsSuggestion(true),\n             self_ty,\n-            expr.hir_id,\n+            expr,\n             probe::ProbeScope::AllTraits,\n+            expectation,\n         ) else { return; };\n         let mut sugg = \".\";\n         let mut span = start.expr.span.between(end.expr.span);"}, {"sha": "bc7474cdfcf3de1023b1b2af40ab46d7a82cb52b", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -351,7 +351,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Struct(qpath, fields, ref base_expr) => {\n                 self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n             }\n-            ExprKind::Field(base, field) => self.check_field(expr, &base, field),\n+            ExprKind::Field(base, field) => self.check_field(expr, &base, field, expected),\n             ExprKind::Index(base, idx) => self.check_expr_index(base, idx, expr),\n             ExprKind::Yield(value, ref src) => self.check_expr_yield(value, expr, src),\n             hir::ExprKind::Err => tcx.ty_error(),\n@@ -459,9 +459,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             hir::BorrowKind::Ref => {\n                 // Note: at this point, we cannot say what the best lifetime\n-                // is to use for resulting pointer.  We want to use the\n+                // is to use for resulting pointer. We want to use the\n                 // shortest lifetime possible so as to avoid spurious borrowck\n-                // errors.  Moreover, the longest lifetime will depend on the\n+                // errors. Moreover, the longest lifetime will depend on the\n                 // precise details of the value whose address is being taken\n                 // (and how long it is valid), which we don't know yet until\n                 // type inference is complete.\n@@ -687,7 +687,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             } else {\n                 // If `ctxt.coerce` is `None`, we can just ignore\n-                // the type of the expression.  This is because\n+                // the type of the expression. This is because\n                 // either this was a break *without* a value, in\n                 // which case it is always a legal type (`()`), or\n                 // else an error would have been flagged by the\n@@ -1244,6 +1244,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         SelfSource::MethodCall(rcvr),\n                         error,\n                         Some((rcvr, args)),\n+                        expected,\n                     ) {\n                         err.emit();\n                     }\n@@ -2186,6 +2187,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr<'tcx>,\n         base: &'tcx hir::Expr<'tcx>,\n         field: Ident,\n+        expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         debug!(\"check_field(expr: {:?}, base: {:?}, field: {:?})\", expr, base, field);\n         let base_ty = self.check_expr(base);\n@@ -2244,12 +2246,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // (#90483) apply adjustments to avoid ExprUseVisitor from\n             // creating erroneous projection.\n             self.apply_adjustments(base, adjustments);\n-            self.ban_private_field_access(expr, base_ty, field, did);\n+            self.ban_private_field_access(expr, base_ty, field, did, expected.only_has_type(self));\n             return self.tcx().ty_error();\n         }\n \n         if field.name == kw::Empty {\n-        } else if self.method_exists(field, base_ty, expr.hir_id, true) {\n+        } else if self.method_exists(\n+            field,\n+            base_ty,\n+            expr.hir_id,\n+            true,\n+            expected.only_has_type(self),\n+        ) {\n             self.ban_take_value_of_method(expr, base_ty, field);\n         } else if !base_ty.is_primitive_ty() {\n             self.ban_nonexisting_field(field, base, expr, base_ty);\n@@ -2423,10 +2431,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn ban_private_field_access(\n         &self,\n-        expr: &hir::Expr<'_>,\n+        expr: &hir::Expr<'tcx>,\n         expr_t: Ty<'tcx>,\n         field: Ident,\n         base_did: DefId,\n+        return_ty: Option<Ty<'tcx>>,\n     ) {\n         let struct_path = self.tcx().def_path_str(base_did);\n         let kind_name = self.tcx().def_kind(base_did).descr(base_did);\n@@ -2438,7 +2447,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         err.span_label(field.span, \"private field\");\n         // Also check if an accessible method exists, which is often what is meant.\n-        if self.method_exists(field, expr_t, expr.hir_id, false) && !self.expr_in_place(expr.hir_id)\n+        if self.method_exists(field, expr_t, expr.hir_id, false, return_ty)\n+            && !self.expr_in_place(expr.hir_id)\n         {\n             self.suggest_method_call(\n                 &mut err,\n@@ -2452,7 +2462,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn ban_take_value_of_method(&self, expr: &hir::Expr<'_>, expr_t: Ty<'tcx>, field: Ident) {\n+    fn ban_take_value_of_method(&self, expr: &hir::Expr<'tcx>, expr_t: Ty<'tcx>, field: Ident) {\n         let mut err = type_error_struct!(\n             self.tcx().sess,\n             field.span,"}, {"sha": "dde8797804f04bb44fa7737865b044c496b3abff", "filename": "compiler/rustc_hir_typeck/src/fallback.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // We now see if we can make progress. This might cause us to\n         // unify inference variables for opaque types, since we may\n         // have unified some other type variables during the first\n-        // phase of fallback.  This means that we only replace\n+        // phase of fallback. This means that we only replace\n         // inference variables with their underlying opaque types as a\n         // last resort.\n         //\n@@ -76,7 +76,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     //   (and the setting of `#![feature(never_type_fallback)]`).\n     //\n     // Fallback becomes very dubious if we have encountered\n-    // type-checking errors.  In that case, fallback to Error.\n+    // type-checking errors. In that case, fallback to Error.\n     //\n     // Sets `FnCtxt::fallback_has_occurred` if fallback is performed\n     // during this call.\n@@ -136,7 +136,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     /// constrained to have some other type).\n     ///\n     /// However, the fallback used to be `()` (before the `!` type was\n-    /// added).  Moreover, there are cases where the `!` type 'leaks\n+    /// added). Moreover, there are cases where the `!` type 'leaks\n     /// out' from dead code into type variables that affect live\n     /// code. The most common case is something like this:\n     ///\n@@ -149,7 +149,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     /// ```\n     ///\n     /// Here, coercing the type `!` into `?M` will create a diverging\n-    /// type variable `?X` where `?X <: ?M`.  We also have that `?D <:\n+    /// type variable `?X` where `?X <: ?M`. We also have that `?D <:\n     /// ?M`. If `?M` winds up unconstrained, then `?X` will\n     /// fallback. If it falls back to `!`, then all the type variables\n     /// will wind up equal to `!` -- this includes the type `?D`\n@@ -185,7 +185,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     ///\n     /// The algorithm we use:\n     /// * Identify all variables that are coerced *into* by a\n-    ///   diverging variable.  Do this by iterating over each\n+    ///   diverging variable. Do this by iterating over each\n     ///   diverging, unsolved variable and finding all variables\n     ///   reachable from there. Call that set `D`.\n     /// * Walk over all unsolved, non-diverging variables, and find\n@@ -308,7 +308,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n \n             if relationship.self_in_trait && relationship.output {\n                 // This case falls back to () to ensure that the code pattern in\n-                // src/test/ui/never_type/fallback-closure-ret.rs continues to\n+                // tests/ui/never_type/fallback-closure-ret.rs continues to\n                 // compile when never_type_fallback is enabled.\n                 //\n                 // This rule is not readily explainable from first principles,"}, {"sha": "8570715b41e59060d6ad2cbbb6e6aec20162c267", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 74, "deletions": 85, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,7 +1,7 @@\n use crate::callee::{self, DeferredCallResolution};\n use crate::method::{self, MethodCallee, SelfSource};\n use crate::rvalue_scopes;\n-use crate::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy};\n+use crate::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy, RawTy};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n@@ -10,6 +10,9 @@ use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, GenericArg, Node, QPath};\n+use rustc_hir_analysis::astconv::generics::{\n+    check_generic_arg_count_for_call, create_substs_for_generic_args,\n+};\n use rustc_hir_analysis::astconv::{\n     AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n     GenericArgCountResult, IsMethodCall, PathSeg,\n@@ -24,7 +27,7 @@ use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n     self, AdtKind, CanonicalUserType, DefIdTree, GenericParamDefKind, Ty, UserType,\n };\n-use rustc_middle::ty::{GenericArgKind, InternalSubsts, SubstsRef, UserSelfTy, UserSubsts};\n+use rustc_middle::ty::{GenericArgKind, SubstsRef, UserSelfTy, UserSubsts};\n use rustc_session::lint;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n@@ -161,47 +164,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn write_method_call(&self, hir_id: hir::HirId, method: MethodCallee<'tcx>) {\n         self.write_resolution(hir_id, Ok((DefKind::AssocFn, method.def_id)));\n         self.write_substs(hir_id, method.substs);\n-\n-        // When the method is confirmed, the `method.substs` includes\n-        // parameters from not just the method, but also the impl of\n-        // the method -- in particular, the `Self` type will be fully\n-        // resolved. However, those are not something that the \"user\n-        // specified\" -- i.e., those types come from the inferred type\n-        // of the receiver, not something the user wrote. So when we\n-        // create the user-substs, we want to replace those earlier\n-        // types with just the types that the user actually wrote --\n-        // that is, those that appear on the *method itself*.\n-        //\n-        // As an example, if the user wrote something like\n-        // `foo.bar::<u32>(...)` -- the `Self` type here will be the\n-        // type of `foo` (possibly adjusted), but we don't want to\n-        // include that. We want just the `[_, u32]` part.\n-        if !method.substs.is_empty() {\n-            let method_generics = self.tcx.generics_of(method.def_id);\n-            if !method_generics.params.is_empty() {\n-                let user_type_annotation = self.probe(|_| {\n-                    let user_substs = UserSubsts {\n-                        substs: InternalSubsts::for_item(self.tcx, method.def_id, |param, _| {\n-                            let i = param.index as usize;\n-                            if i < method_generics.parent_count {\n-                                self.var_for_def(DUMMY_SP, param)\n-                            } else {\n-                                method.substs[i]\n-                            }\n-                        }),\n-                        user_self_ty: None, // not relevant here\n-                    };\n-\n-                    self.canonicalize_user_type_annotation(UserType::TypeOf(\n-                        method.def_id,\n-                        user_substs,\n-                    ))\n-                });\n-\n-                debug!(\"write_method_call: user_type_annotation={:?}\", user_type_annotation);\n-                self.write_user_type_annotation(hir_id, user_type_annotation);\n-            }\n-        }\n     }\n \n     pub fn write_substs(&self, node_id: hir::HirId, substs: SubstsRef<'tcx>) {\n@@ -410,23 +372,38 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn to_ty(&self, ast_t: &hir::Ty<'_>) -> Ty<'tcx> {\n-        let t = <dyn AstConv<'_>>::ast_ty_to_ty(self, ast_t);\n+    pub fn handle_raw_ty(&self, span: Span, ty: Ty<'tcx>) -> RawTy<'tcx> {\n+        RawTy { raw: ty, normalized: self.normalize(span, ty) }\n+    }\n+\n+    pub fn to_ty(&self, ast_t: &hir::Ty<'_>) -> RawTy<'tcx> {\n+        let t = self.astconv().ast_ty_to_ty(ast_t);\n         self.register_wf_obligation(t.into(), ast_t.span, traits::WellFormed(None));\n-        t\n+        self.handle_raw_ty(ast_t.span, t)\n     }\n \n     pub fn to_ty_saving_user_provided_ty(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n         let ty = self.to_ty(ast_ty);\n         debug!(\"to_ty_saving_user_provided_ty: ty={:?}\", ty);\n \n-        if Self::can_contain_user_lifetime_bounds(ty) {\n-            let c_ty = self.canonicalize_response(UserType::Ty(ty));\n+        if Self::can_contain_user_lifetime_bounds(ty.raw) {\n+            let c_ty = self.canonicalize_response(UserType::Ty(ty.raw));\n             debug!(\"to_ty_saving_user_provided_ty: c_ty={:?}\", c_ty);\n             self.typeck_results.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n         }\n \n-        ty\n+        ty.normalized\n+    }\n+\n+    pub(super) fn user_substs_for_adt(ty: RawTy<'tcx>) -> UserSubsts<'tcx> {\n+        match (ty.raw.kind(), ty.normalized.kind()) {\n+            (ty::Adt(_, substs), _) => UserSubsts { substs, user_self_ty: None },\n+            (_, ty::Adt(adt, substs)) => UserSubsts {\n+                substs,\n+                user_self_ty: Some(UserSelfTy { impl_def_id: adt.did(), self_ty: ty.raw }),\n+            },\n+            _ => bug!(\"non-adt type {:?}\", ty),\n+        }\n     }\n \n     pub fn array_length_to_const(&self, length: &hir::ArrayLen) -> ty::Const<'tcx> {\n@@ -696,8 +673,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Note: this check is pessimistic, as the inference type could be matched with something other\n         // than the opaque type, but then we need a new `TypeRelation` just for this specific case and\n         // can't re-use `sup` below.\n-        // See src/test/ui/impl-trait/hidden-type-is-opaque.rs and\n-        // src/test/ui/impl-trait/hidden-type-is-opaque-2.rs for examples that hit this path.\n+        // See tests/ui/impl-trait/hidden-type-is-opaque.rs and\n+        // tests/ui/impl-trait/hidden-type-is-opaque-2.rs for examples that hit this path.\n         if formal_ret.has_infer_types() {\n             for ty in ret_ty.walk() {\n                 if let ty::subst::GenericArgKind::Type(ty) = ty.unpack()\n@@ -780,7 +757,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         qpath: &'tcx QPath<'tcx>,\n         hir_id: hir::HirId,\n         span: Span,\n-    ) -> (Res, Option<Ty<'tcx>>, &'tcx [hir::PathSegment<'tcx>]) {\n+    ) -> (Res, Option<RawTy<'tcx>>, &'tcx [hir::PathSegment<'tcx>]) {\n         debug!(\n             \"resolve_ty_and_res_fully_qualified_call: qpath={:?} hir_id={:?} span={:?}\",\n             qpath, hir_id, span\n@@ -803,23 +780,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // to be object-safe.\n                 // We manually call `register_wf_obligation` in the success path\n                 // below.\n-                (<dyn AstConv<'_>>::ast_ty_to_ty_in_path(self, qself), qself, segment)\n+                let ty = self.astconv().ast_ty_to_ty_in_path(qself);\n+                (self.handle_raw_ty(span, ty), qself, segment)\n             }\n             QPath::LangItem(..) => {\n                 bug!(\"`resolve_ty_and_res_fully_qualified_call` called on `LangItem`\")\n             }\n         };\n         if let Some(&cached_result) = self.typeck_results.borrow().type_dependent_defs().get(hir_id)\n         {\n-            self.register_wf_obligation(ty.into(), qself.span, traits::WellFormed(None));\n+            self.register_wf_obligation(ty.raw.into(), qself.span, traits::WellFormed(None));\n             // Return directly on cache hit. This is useful to avoid doubly reporting\n             // errors with default match binding modes. See #44614.\n             let def = cached_result.map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id));\n             return (def, Some(ty), slice::from_ref(&**item_segment));\n         }\n         let item_name = item_segment.ident;\n         let result = self\n-            .resolve_fully_qualified_call(span, item_name, ty, qself.span, hir_id)\n+            .resolve_fully_qualified_call(span, item_name, ty.normalized, qself.span, hir_id)\n             .or_else(|error| {\n                 let result = match error {\n                     method::MethodError::PrivateMatch(kind, def_id, _) => Ok((kind, def_id)),\n@@ -830,17 +808,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // a WF obligation for `dyn MyTrait` when method lookup fails. Otherwise,\n                 // register a WF obligation so that we can detect any additional\n                 // errors in the self type.\n-                if !(matches!(error, method::MethodError::NoMatch(_)) && ty.is_trait()) {\n-                    self.register_wf_obligation(ty.into(), qself.span, traits::WellFormed(None));\n+                if !(matches!(error, method::MethodError::NoMatch(_)) && ty.normalized.is_trait()) {\n+                    self.register_wf_obligation(\n+                        ty.raw.into(),\n+                        qself.span,\n+                        traits::WellFormed(None),\n+                    );\n                 }\n                 if item_name.name != kw::Empty {\n                     if let Some(mut e) = self.report_method_error(\n                         span,\n-                        ty,\n+                        ty.normalized,\n                         item_name,\n                         SelfSource::QPath(qself),\n                         error,\n                         None,\n+                        Expectation::NoExpectation,\n                     ) {\n                         e.emit();\n                     }\n@@ -849,7 +832,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             });\n \n         if result.is_ok() {\n-            self.register_wf_obligation(ty.into(), qself.span, traits::WellFormed(None));\n+            self.register_wf_obligation(ty.raw.into(), qself.span, traits::WellFormed(None));\n         }\n \n         // Write back the new resolution.\n@@ -986,7 +969,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn instantiate_value_path(\n         &self,\n         segments: &[hir::PathSegment<'_>],\n-        self_ty: Option<Ty<'tcx>>,\n+        self_ty: Option<RawTy<'tcx>>,\n         res: Res,\n         span: Span,\n         hir_id: hir::HirId,\n@@ -995,8 +978,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let path_segs = match res {\n             Res::Local(_) | Res::SelfCtor(_) => vec![],\n-            Res::Def(kind, def_id) => <dyn AstConv<'_>>::def_ids_for_value_path_segments(\n-                self, segments, self_ty, kind, def_id,\n+            Res::Def(kind, def_id) => self.astconv().def_ids_for_value_path_segments(\n+                segments,\n+                self_ty.map(|ty| ty.raw),\n+                kind,\n+                def_id,\n+                span,\n             ),\n             _ => bug!(\"instantiate_value_path on {:?}\", res),\n         };\n@@ -1007,8 +994,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Res::Def(DefKind::Ctor(CtorOf::Variant, _), _)\n                 if let Some(self_ty) = self_ty =>\n             {\n-                let adt_def = self_ty.ty_adt_def().unwrap();\n-                user_self_ty = Some(UserSelfTy { impl_def_id: adt_def.did(), self_ty });\n+                let adt_def = self_ty.normalized.ty_adt_def().unwrap();\n+                user_self_ty = Some(UserSelfTy { impl_def_id: adt_def.did(), self_ty: self_ty.raw });\n                 is_alias_variant_ctor = true;\n             }\n             Res::Def(DefKind::AssocFn | DefKind::AssocConst, def_id) => {\n@@ -1027,7 +1014,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // inherent impl, we need to record the\n                             // `T` for posterity (see `UserSelfTy` for\n                             // details).\n-                            let self_ty = self_ty.expect(\"UFCS sugared assoc missing Self\");\n+                            let self_ty = self_ty.expect(\"UFCS sugared assoc missing Self\").raw;\n                             user_self_ty = Some(UserSelfTy { impl_def_id: container_id, self_ty });\n                         }\n                     }\n@@ -1042,8 +1029,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // errors if type parameters are provided in an inappropriate place.\n \n         let generic_segs: FxHashSet<_> = path_segs.iter().map(|PathSeg(_, index)| index).collect();\n-        let generics_has_err = <dyn AstConv<'_>>::prohibit_generics(\n-            self,\n+        let generics_has_err = self.astconv().prohibit_generics(\n             segments.iter().enumerate().filter_map(|(index, seg)| {\n                 if !generic_segs.contains(&index) || is_alias_variant_ctor {\n                     Some(seg)\n@@ -1084,7 +1070,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // parameter internally, but we don't allow users to specify the\n             // parameter's value explicitly, so we have to do some error-\n             // checking here.\n-            let arg_count = <dyn AstConv<'_>>::check_generic_arg_count_for_call(\n+            let arg_count = check_generic_arg_count_for_call(\n                 tcx,\n                 span,\n                 def_id,\n@@ -1109,19 +1095,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .unwrap_or(false);\n \n         let (res, self_ctor_substs) = if let Res::SelfCtor(impl_def_id) = res {\n-            let ty = self.normalize_ty(span, tcx.at(span).type_of(impl_def_id));\n-            match *ty.kind() {\n-                ty::Adt(adt_def, substs) if adt_def.has_ctor() => {\n-                    let variant = adt_def.non_enum_variant();\n-                    let (ctor_kind, ctor_def_id) = variant.ctor.unwrap();\n-                    (Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id), Some(substs))\n+            let ty = self.handle_raw_ty(span, tcx.at(span).type_of(impl_def_id));\n+            match ty.normalized.ty_adt_def() {\n+                Some(adt_def) if adt_def.has_ctor() => {\n+                    let (ctor_kind, ctor_def_id) = adt_def.non_enum_variant().ctor.unwrap();\n+                    let new_res = Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n+                    let user_substs = Self::user_substs_for_adt(ty);\n+                    user_self_ty = user_substs.user_self_ty;\n+                    (new_res, Some(user_substs.substs))\n                 }\n                 _ => {\n                     let mut err = tcx.sess.struct_span_err(\n                         span,\n                         \"the `Self` constructor can only be used with tuple or unit structs\",\n                     );\n-                    if let Some(adt_def) = ty.ty_adt_def() {\n+                    if let Some(adt_def) = ty.normalized.ty_adt_def() {\n                         match adt_def.adt_kind() {\n                             AdtKind::Enum => {\n                                 err.help(\"did you mean to use one of the enum's variants?\");\n@@ -1190,10 +1178,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ) -> ty::GenericArg<'tcx> {\n                 match (&param.kind, arg) {\n                     (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n-                        <dyn AstConv<'_>>::ast_region_to_region(self.fcx, lt, Some(param)).into()\n+                        self.fcx.astconv().ast_region_to_region(lt, Some(param)).into()\n                     }\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n-                        self.fcx.to_ty(ty).into()\n+                        self.fcx.to_ty(ty).raw.into()\n                     }\n                     (GenericParamDefKind::Const { .. }, GenericArg::Const(ct)) => {\n                         self.fcx.const_arg_to_const(&ct.value, param.def_id).into()\n@@ -1225,10 +1213,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // If we have a default, then we it doesn't matter that we're not\n                             // inferring the type arguments: we provide the default where any\n                             // is missing.\n-                            let default = tcx.bound_type_of(param.def_id);\n-                            self.fcx\n-                                .normalize_ty(self.span, default.subst(tcx, substs.unwrap()))\n-                                .into()\n+                            tcx.bound_type_of(param.def_id).subst(tcx, substs.unwrap()).into()\n                         } else {\n                             // If no type arguments were provided, we have to infer them.\n                             // This case also occurs as a result of some malformed input, e.g.\n@@ -1250,13 +1235,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let substs = self_ctor_substs.unwrap_or_else(|| {\n-            <dyn AstConv<'_>>::create_substs_for_generic_args(\n+        let substs_raw = self_ctor_substs.unwrap_or_else(|| {\n+            create_substs_for_generic_args(\n                 tcx,\n                 def_id,\n                 &[],\n                 has_self,\n-                self_ty,\n+                self_ty.map(|s| s.raw),\n                 &arg_count,\n                 &mut CreateCtorSubstsContext {\n                     fcx: self,\n@@ -1269,7 +1254,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         });\n \n         // First, store the \"user substs\" for later.\n-        self.write_user_type_annotation_from_substs(hir_id, def_id, substs, user_self_ty);\n+        self.write_user_type_annotation_from_substs(hir_id, def_id, substs_raw, user_self_ty);\n+\n+        // Normalize only after registering type annotations.\n+        let substs = self.normalize(span, substs_raw);\n \n         self.add_required_obligations_for_hir(span, def_id, &substs, hir_id);\n \n@@ -1287,6 +1275,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // with the substituted impl type.\n             // This also occurs for an enum variant on a type alias.\n             let impl_ty = self.normalize(span, tcx.bound_type_of(impl_def_id).subst(tcx, substs));\n+            let self_ty = self.normalize(span, self_ty);\n             match self.at(&self.misc(span), self.param_env).eq(impl_ty, self_ty) {\n                 Ok(ok) => self.register_infer_ok_obligations(ok),\n                 Err(_) => {"}, {"sha": "b9e13fd20092421554e9d9d3ce9899334f100d74", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -5,11 +5,11 @@ use crate::method::MethodCallee;\n use crate::Expectation::*;\n use crate::TupleArgumentsFlag::*;\n use crate::{\n-    struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy, Needs,\n+    struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy, Needs, RawTy,\n     TupleArgumentsFlag,\n };\n use rustc_ast as ast;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{pluralize, Applicability, Diagnostic, DiagnosticId, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n@@ -1231,31 +1231,35 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n                 return None;\n             }\n-            Res::Def(DefKind::Variant, _) => match ty.kind() {\n-                ty::Adt(adt, substs) => Some((adt.variant_of_res(def), adt.did(), substs)),\n-                _ => bug!(\"unexpected type: {:?}\", ty),\n+            Res::Def(DefKind::Variant, _) => match ty.normalized.ty_adt_def() {\n+                Some(adt) => {\n+                    Some((adt.variant_of_res(def), adt.did(), Self::user_substs_for_adt(ty)))\n+                }\n+                _ => bug!(\"unexpected type: {:?}\", ty.normalized),\n             },\n             Res::Def(DefKind::Struct | DefKind::Union | DefKind::TyAlias | DefKind::AssocTy, _)\n             | Res::SelfTyParam { .. }\n-            | Res::SelfTyAlias { .. } => match ty.kind() {\n-                ty::Adt(adt, substs) if !adt.is_enum() => {\n-                    Some((adt.non_enum_variant(), adt.did(), substs))\n+            | Res::SelfTyAlias { .. } => match ty.normalized.ty_adt_def() {\n+                Some(adt) if !adt.is_enum() => {\n+                    Some((adt.non_enum_variant(), adt.did(), Self::user_substs_for_adt(ty)))\n                 }\n                 _ => None,\n             },\n             _ => bug!(\"unexpected definition: {:?}\", def),\n         };\n \n-        if let Some((variant, did, substs)) = variant {\n+        if let Some((variant, did, ty::UserSubsts { substs, user_self_ty })) = variant {\n             debug!(\"check_struct_path: did={:?} substs={:?}\", did, substs);\n-            self.write_user_type_annotation_from_substs(hir_id, did, substs, None);\n+\n+            // Register type annotation.\n+            self.write_user_type_annotation_from_substs(hir_id, did, substs, user_self_ty);\n \n             // Check bounds on type arguments used in the path.\n             self.add_required_obligations_for_hir(path_span, did, substs, hir_id);\n \n-            Some((variant, ty))\n+            Some((variant, ty.normalized))\n         } else {\n-            match ty.kind() {\n+            match ty.normalized.kind() {\n                 ty::Error(_) => {\n                     // E0071 might be caused by a spelling error, which will have\n                     // already caused an error message and probably a suggestion\n@@ -1268,7 +1272,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         path_span,\n                         E0071,\n                         \"expected struct, variant or union type, found {}\",\n-                        ty.sort_string(self.tcx)\n+                        ty.normalized.sort_string(self.tcx)\n                     )\n                     .span_label(path_span, \"not a struct\")\n                     .emit();\n@@ -1656,20 +1660,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         qpath: &QPath<'_>,\n         path_span: Span,\n         hir_id: hir::HirId,\n-    ) -> (Res, Ty<'tcx>) {\n+    ) -> (Res, RawTy<'tcx>) {\n         match *qpath {\n             QPath::Resolved(ref maybe_qself, ref path) => {\n-                let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n-                let ty = <dyn AstConv<'_>>::res_to_ty(self, self_ty, path, true);\n-                (path.res, ty)\n+                let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself).raw);\n+                let ty = self.astconv().res_to_ty(self_ty, path, true);\n+                (path.res, self.handle_raw_ty(path_span, ty))\n             }\n             QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n-                let result = <dyn AstConv<'_>>::associated_path_to_ty(\n-                    self, hir_id, path_span, ty, qself, segment, true,\n-                );\n+                let result = self\n+                    .astconv()\n+                    .associated_path_to_ty(hir_id, path_span, ty.raw, qself, segment, true);\n                 let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n+                let ty = self.handle_raw_ty(path_span, ty);\n                 let result = result.map(|(_, kind, def_id)| (kind, def_id));\n \n                 // Write back the new resolution.\n@@ -1678,7 +1683,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (result.map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)), ty)\n             }\n             QPath::LangItem(lang_item, span, id) => {\n-                self.resolve_lang_item_path(lang_item, span, hir_id, id)\n+                let (res, ty) = self.resolve_lang_item_path(lang_item, span, hir_id, id);\n+                (res, self.handle_raw_ty(path_span, ty))\n             }\n         }\n     }\n@@ -1698,7 +1704,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // even if their `ObligationCauseCode` isn't an `Expr*Obligation` kind.\n         // This is important since if we adjust one span but not the other, then\n         // we will have \"duplicated\" the error on the UI side.\n-        let mut remap_cause = FxHashSet::default();\n+        let mut remap_cause = FxIndexSet::default();\n         let mut not_adjusted = vec![];\n \n         for error in errors {\n@@ -1726,6 +1732,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n+        // Adjust any other errors that come from other cause codes, when these\n+        // errors are of the same predicate as one we successfully adjusted, and\n+        // when their spans overlap (suggesting they're due to the same root cause).\n+        //\n+        // This is because due to normalization, we often register duplicate\n+        // obligations with misc obligations that are basically impossible to\n+        // line back up with a useful ExprBindingObligation.\n         for error in not_adjusted {\n             for (span, predicate, cause) in &remap_cause {\n                 if *predicate == error.obligation.predicate"}, {"sha": "428fde642bc0901bff4a7fb92c8c6cb6c589c100", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -17,11 +17,10 @@ use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Const, Ty, TyCtxt, TypeVisitable};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n-use rustc_span::{self, Span};\n+use rustc_span::{self, Span, DUMMY_SP};\n use rustc_trait_selection::traits::{ObligationCause, ObligationCauseCode, ObligationCtxt};\n \n use std::cell::{Cell, RefCell};\n@@ -176,6 +175,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     fn_sig\n                 })\n             }),\n+            autoderef_steps: Box::new(|ty| {\n+                let mut autoderef = self.autoderef(DUMMY_SP, ty).silence_errors();\n+                let mut steps = vec![];\n+                while let Some((ty, _)) = autoderef.next() {\n+                    steps.push((ty, autoderef.current_obligations()));\n+                }\n+                steps\n+            }),\n         }\n     }\n \n@@ -287,8 +294,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n             poly_trait_ref,\n         );\n \n-        let item_substs = <dyn AstConv<'tcx>>::create_substs_for_associated_item(\n-            self,\n+        let item_substs = self.astconv().create_substs_for_associated_item(\n             span,\n             item_def_id,\n             item_segment,\n@@ -298,19 +304,36 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         self.tcx().mk_projection(item_def_id, item_substs)\n     }\n \n-    fn normalize_ty(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if ty.has_escaping_bound_vars() {\n-            ty // FIXME: normalization and escaping regions\n-        } else {\n-            self.normalize(span, ty)\n+    fn probe_adt(&self, span: Span, ty: Ty<'tcx>) -> Option<ty::AdtDef<'tcx>> {\n+        match ty.kind() {\n+            ty::Adt(adt_def, _) => Some(*adt_def),\n+            // FIXME(#104767): Should we handle bound regions here?\n+            ty::Alias(ty::Projection, _) if !ty.has_escaping_bound_vars() => {\n+                self.normalize(span, ty).ty_adt_def()\n+            }\n+            _ => None,\n         }\n     }\n \n     fn set_tainted_by_errors(&self, e: ErrorGuaranteed) {\n         self.infcx.set_tainted_by_errors(e)\n     }\n \n-    fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, _span: Span) {\n+    fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, span: Span) {\n+        // FIXME: normalization and escaping regions\n+        let ty = if !ty.has_escaping_bound_vars() { self.normalize(span, ty) } else { ty };\n         self.write_ty(hir_id, ty)\n     }\n }\n+\n+/// Represents a user-provided type in the raw form (never normalized).\n+///\n+/// This is a bridge between the interface of `AstConv`, which outputs a raw `Ty`,\n+/// and the API in this module, which expect `Ty` to be fully normalized.\n+#[derive(Clone, Copy, Debug)]\n+pub struct RawTy<'tcx> {\n+    pub raw: Ty<'tcx>,\n+\n+    /// The normalized form of `raw`, stored here for efficiency.\n+    pub normalized: Ty<'tcx>,\n+}"}, {"sha": "156c02149e7c869e5144a1ac8de8797cdb973741", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -5,7 +5,7 @@ use crate::method::probe::{IsSuggestion, Mode, ProbeScope};\n use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorOf, DefKind};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{\n     Expr, ExprKind, GenericBound, Node, Path, QPath, Stmt, StmtKind, TyKind, WherePredicate,\n@@ -417,10 +417,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else if self.suggest_else_fn_with_closure(err, expr, found, expected) {\n             return true;\n         } else if self.suggest_fn_call(err, expr, found, |output| self.can_coerce(output, expected))\n-            && let ty::FnDef(def_id, ..) = &found.kind()\n-            && let Some(sp) = self.tcx.hir().span_if_local(*def_id)\n+            && let ty::FnDef(def_id, ..) = *found.kind()\n+            && let Some(sp) = self.tcx.hir().span_if_local(def_id)\n         {\n-            err.span_label(sp, format!(\"{found} defined here\"));\n+            let name = self.tcx.item_name(def_id);\n+            let kind = self.tcx.def_kind(def_id);\n+            if let DefKind::Ctor(of, CtorKind::Fn) = kind {\n+                err.span_label(sp, format!(\"`{name}` defines {} constructor here, which should be called\", match of {\n+                    CtorOf::Struct => \"a struct\",\n+                    CtorOf::Variant => \"an enum variant\",\n+                }));\n+            } else {\n+                let descr = kind.descr(def_id);\n+                err.span_label(sp, format!(\"{descr} `{name}` defined here\"));\n+            }\n             return true;\n         } else if self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n             return true;\n@@ -442,7 +452,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             && method_call_list.contains(&conversion_method.name)\n                             // If receiver is `.clone()` and found type has one of those methods,\n                             // we guess that the user wants to convert from a slice type (`&[]` or `&str`)\n-                            // to an owned type (`Vec` or `String`).  These conversions clone internally,\n+                            // to an owned type (`Vec` or `String`). These conversions clone internally,\n                             // so we remove the user's `clone` call.\n                         {\n                             vec![(\n@@ -639,7 +649,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             ty::Adt(def, _) if def.is_box() && self.can_coerce(box_found, expected) => {\n-                // Check if the parent expression is a call to Pin::new.  If it\n+                // Check if the parent expression is a call to Pin::new. If it\n                 // is and we were expecting a Box, ergo Pin<Box<expected>>, we\n                 // can suggest Box::pin.\n                 let parent = self.tcx.hir().parent_id(expr.hir_id);\n@@ -783,7 +793,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // are not, the expectation must have been caused by something else.\n                 debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.kind);\n                 let span = ty.span;\n-                let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n+                let ty = self.astconv().ast_ty_to_ty(ty);\n                 debug!(\"suggest_missing_return_type: return type {:?}\", ty);\n                 debug!(\"suggest_missing_return_type: expected type {:?}\", ty);\n                 let bound_vars = self.tcx.late_bound_vars(fn_id);\n@@ -854,7 +864,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ..\n                 }) => {\n                     // FIXME: Maybe these calls to `ast_ty_to_ty` can be removed (and the ones below)\n-                    let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, bounded_ty);\n+                    let ty = self.astconv().ast_ty_to_ty(bounded_ty);\n                     Some((ty, bounds))\n                 }\n                 _ => None,\n@@ -892,7 +902,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let all_bounds_str = all_matching_bounds_strs.join(\" + \");\n \n         let ty_param_used_in_fn_params = fn_parameters.iter().any(|param| {\n-                let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, param);\n+                let ty = self.astconv().ast_ty_to_ty( param);\n                 matches!(ty.kind(), ty::Param(fn_param_ty_param) if expected_ty_as_param == fn_param_ty_param)\n             });\n \n@@ -946,7 +956,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let hir::FnRetTy::Return(ty) = fn_decl.output {\n-            let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n+            let ty = self.astconv().ast_ty_to_ty(ty);\n             let bound_vars = self.tcx.late_bound_vars(fn_id);\n             let ty = self.tcx.erase_late_bound_regions(Binder::bind_with_vars(ty, bound_vars));\n             let ty = match self.tcx.asyncness(fn_id.owner) {\n@@ -1339,10 +1349,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::Path { segments: [segment], .. },\n             ))\n             | hir::ExprKind::Path(QPath::TypeRelative(ty, segment)) => {\n-                let self_ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n+                let self_ty = self.astconv().ast_ty_to_ty(ty);\n                 if let Ok(pick) = self.probe_for_name(\n                     Mode::Path,\n                     Ident::new(capitalized_name, segment.ident.span),\n+                    Some(expected_ty),\n                     IsSuggestion(true),\n                     self_ty,\n                     expr.hir_id,"}, {"sha": "15dd3412c34093e062eb5b74aa36a77fd5a3010a", "filename": "compiler/rustc_hir_typeck/src/gather_locals.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -77,15 +77,16 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n             Some(ref ty) => {\n                 let o_ty = self.fcx.to_ty(&ty);\n \n-                let c_ty = self.fcx.inh.infcx.canonicalize_user_type_annotation(UserType::Ty(o_ty));\n+                let c_ty =\n+                    self.fcx.inh.infcx.canonicalize_user_type_annotation(UserType::Ty(o_ty.raw));\n                 debug!(\"visit_local: ty.hir_id={:?} o_ty={:?} c_ty={:?}\", ty.hir_id, o_ty, c_ty);\n                 self.fcx\n                     .typeck_results\n                     .borrow_mut()\n                     .user_provided_types_mut()\n                     .insert(ty.hir_id, c_ty);\n \n-                Some(LocalTy { decl_ty: o_ty, revealed_ty: o_ty })\n+                Some(LocalTy { decl_ty: o_ty.normalized, revealed_ty: o_ty.normalized })\n             }\n             None => None,\n         };"}, {"sha": "ed3d890315704cefd1f2932e62b3f3e30a6c47e8", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -116,7 +116,7 @@ impl<'tcx> ExprUseDelegate<'tcx> {\n         // where the `identity(...)` (the rvalue) produces a return type\n         // of `&'rv mut A`, where `'a: 'rv`. We then assign this result to\n         // `'y`, resulting in (transitively) `'a: 'y` (i.e., while `y` is in use,\n-        // `a` will be considered borrowed).  Other parts of the code will ensure\n+        // `a` will be considered borrowed). Other parts of the code will ensure\n         // that if `y` is live over a yield, `&'y mut A` appears in the generator\n         // state. If `'y` is live, then any sound region analysis must conclude\n         // that `'a` is also live. So if this causes a bug, blame some other"}, {"sha": "7990d95310be59489989d8d4753c74b39aaa7eb1", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -448,7 +448,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         // the yield, even if it's not borrowed or referenced after the yield. Ideally this would\n         // *only* happen for types with observable drop, not all types which wrap them, but that\n         // doesn't match the behavior of MIR borrowck and causes ICEs. See the FIXME comment in\n-        // src/test/ui/generator/drop-tracking-parent-expression.rs.\n+        // tests/ui/generator/drop-tracking-parent-expression.rs.\n         let scope = if self.drop_ranges.is_borrowed_temporary(expr)\n             || ty.map_or(true, |ty| {\n                 // Avoid ICEs in needs_drop."}, {"sha": "7ddf9eaa4d8995463fa730d5ad653c536b174d2b", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -205,7 +205,7 @@ fn typeck_with_fallback<'tcx>(\n \n         if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n             let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {\n-                <dyn AstConv<'_>>::ty_of_fn(&fcx, id, header.unsafety, header.abi, decl, None, None)\n+                fcx.astconv().ty_of_fn(id, header.unsafety, header.abi, decl, None, None)\n             } else {\n                 tcx.fn_sig(def_id)\n             };\n@@ -220,7 +220,7 @@ fn typeck_with_fallback<'tcx>(\n         } else {\n             let expected_type = body_ty\n                 .and_then(|ty| match ty.kind {\n-                    hir::TyKind::Infer => Some(<dyn AstConv<'_>>::ast_ty_to_ty(&fcx, ty)),\n+                    hir::TyKind::Infer => Some(fcx.astconv().ast_ty_to_ty(ty)),\n                     _ => None,\n                 })\n                 .unwrap_or_else(|| match tcx.hir().get(id) {\n@@ -297,7 +297,7 @@ fn typeck_with_fallback<'tcx>(\n         fcx.resolve_generator_interiors(def_id.to_def_id());\n \n         for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n-            let ty = fcx.normalize_ty(span, ty);\n+            let ty = fcx.normalize(span, ty);\n             fcx.require_type_is_sized(ty, span, code);\n         }\n "}, {"sha": "48c75cde9a5fc544948e231ea4077a86ad698f9d", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -736,7 +736,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             }\n \n             PatKind::Box(ref subpat) | PatKind::Ref(ref subpat, _) => {\n-                // box p1, &p1, &mut p1.  we can ignore the mutability of\n+                // box p1, &p1, &mut p1. we can ignore the mutability of\n                 // PatKind::Ref since that information is already contained\n                 // in the type.\n                 let subplace = self.cat_deref(pat, place_with_id)?;"}, {"sha": "4a33a791e1b7f3b12db9c6e54ca541ab93b5c0fa", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -4,6 +4,9 @@ use crate::{callee, FnCtxt};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::GenericArg;\n+use rustc_hir_analysis::astconv::generics::{\n+    check_generic_arg_count_for_call, create_substs_for_generic_args,\n+};\n use rustc_hir_analysis::astconv::{AstConv, CreateSubstsForGenericArgsCtxt, IsMethodCall};\n use rustc_infer::infer::{self, InferOk};\n use rustc_middle::traits::{ObligationCauseCode, UnifyReceiverContext};\n@@ -12,7 +15,8 @@ use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutabili\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{self, SubstsRef};\n use rustc_middle::ty::{self, GenericParamDefKind, Ty};\n-use rustc_span::Span;\n+use rustc_middle::ty::{InternalSubsts, UserSubsts, UserType};\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::traits;\n \n use std::iter;\n@@ -89,7 +93,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // If there is a `Self: Sized` bound and `Self` is a trait object, it is possible that\n         // something which derefs to `Self` actually implements the trait and the caller\n         // wanted to make a static dispatch on it but forgot to import the trait.\n-        // See test `src/test/ui/issue-35976.rs`.\n+        // See test `tests/ui/issue-35976.rs`.\n         //\n         // In that case, we'll error anyway, but we'll also re-run the search with all traits\n         // in scope, and if we find another method which can be used, we'll output an\n@@ -330,7 +334,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // variables.\n         let generics = self.tcx.generics_of(pick.item.def_id);\n \n-        let arg_count_correct = <dyn AstConv<'_>>::check_generic_arg_count_for_call(\n+        let arg_count_correct = check_generic_arg_count_for_call(\n             self.tcx,\n             self.span,\n             pick.item.def_id,\n@@ -368,11 +372,10 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             ) -> subst::GenericArg<'tcx> {\n                 match (&param.kind, arg) {\n                     (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n-                        <dyn AstConv<'_>>::ast_region_to_region(self.cfcx.fcx, lt, Some(param))\n-                            .into()\n+                        self.cfcx.fcx.astconv().ast_region_to_region(lt, Some(param)).into()\n                     }\n                     (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => {\n-                        self.cfcx.to_ty(ty).into()\n+                        self.cfcx.to_ty(ty).raw.into()\n                     }\n                     (GenericParamDefKind::Const { .. }, GenericArg::Const(ct)) => {\n                         self.cfcx.const_arg_to_const(&ct.value, param.def_id).into()\n@@ -397,15 +400,56 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 self.cfcx.var_for_def(self.cfcx.span, param)\n             }\n         }\n-        <dyn AstConv<'_>>::create_substs_for_generic_args(\n+\n+        let substs = create_substs_for_generic_args(\n             self.tcx,\n             pick.item.def_id,\n             parent_substs,\n             false,\n             None,\n             &arg_count_correct,\n             &mut MethodSubstsCtxt { cfcx: self, pick, seg },\n-        )\n+        );\n+\n+        // When the method is confirmed, the `substs` includes\n+        // parameters from not just the method, but also the impl of\n+        // the method -- in particular, the `Self` type will be fully\n+        // resolved. However, those are not something that the \"user\n+        // specified\" -- i.e., those types come from the inferred type\n+        // of the receiver, not something the user wrote. So when we\n+        // create the user-substs, we want to replace those earlier\n+        // types with just the types that the user actually wrote --\n+        // that is, those that appear on the *method itself*.\n+        //\n+        // As an example, if the user wrote something like\n+        // `foo.bar::<u32>(...)` -- the `Self` type here will be the\n+        // type of `foo` (possibly adjusted), but we don't want to\n+        // include that. We want just the `[_, u32]` part.\n+        if !substs.is_empty() && !generics.params.is_empty() {\n+            let user_type_annotation = self.probe(|_| {\n+                let user_substs = UserSubsts {\n+                    substs: InternalSubsts::for_item(self.tcx, pick.item.def_id, |param, _| {\n+                        let i = param.index as usize;\n+                        if i < generics.parent_count {\n+                            self.fcx.var_for_def(DUMMY_SP, param)\n+                        } else {\n+                            substs[i]\n+                        }\n+                    }),\n+                    user_self_ty: None, // not relevant here\n+                };\n+\n+                self.fcx.canonicalize_user_type_annotation(UserType::TypeOf(\n+                    pick.item.def_id,\n+                    user_substs,\n+                ))\n+            });\n+\n+            debug!(\"instantiate_method_substs: user_type_annotation={:?}\", user_type_annotation);\n+            self.fcx.write_user_type_annotation(self.call_expr.hir_id, user_type_annotation);\n+        }\n+\n+        self.normalize(self.span, substs)\n     }\n \n     fn unify_receivers("}, {"sha": "b810a967a2451192f670bab6edf6fb6f451c8329", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 55, "deletions": 27, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -97,10 +97,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_ty: Ty<'tcx>,\n         call_expr_id: hir::HirId,\n         allow_private: bool,\n+        return_type: Option<Ty<'tcx>>,\n     ) -> bool {\n         match self.probe_for_name(\n             probe::Mode::MethodCall,\n             method_name,\n+            return_type,\n             IsSuggestion(false),\n             self_ty,\n             call_expr_id,\n@@ -118,7 +120,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(Ambiguity(..)) => true,\n             Err(PrivateMatch(..)) => allow_private,\n             Err(IllegalSizedBound { .. }) => true,\n-            Err(BadReturnType) => bug!(\"no return type expectations but got BadReturnType\"),\n+            Err(BadReturnType) => false,\n         }\n     }\n \n@@ -130,17 +132,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         msg: &str,\n         method_name: Ident,\n         self_ty: Ty<'tcx>,\n-        call_expr: &hir::Expr<'_>,\n+        call_expr: &hir::Expr<'tcx>,\n         span: Option<Span>,\n     ) {\n         let params = self\n-            .probe_for_name(\n-                probe::Mode::MethodCall,\n+            .lookup_probe_for_diagnostic(\n                 method_name,\n-                IsSuggestion(true),\n                 self_ty,\n-                call_expr.hir_id,\n+                call_expr,\n                 ProbeScope::TraitsInScope,\n+                None,\n             )\n             .map(|pick| {\n                 let sig = self.tcx.fn_sig(pick.item.def_id);\n@@ -221,25 +222,30 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             // We probe again, taking all traits into account (not only those in scope).\n-            let candidates =\n-                match self.lookup_probe(segment.ident, self_ty, call_expr, ProbeScope::AllTraits) {\n-                    // If we find a different result the caller probably forgot to import a trait.\n-                    Ok(ref new_pick) if pick.differs_from(new_pick) => {\n-                        vec![new_pick.item.container_id(self.tcx)]\n-                    }\n-                    Err(Ambiguity(ref sources)) => sources\n-                        .iter()\n-                        .filter_map(|source| {\n-                            match *source {\n-                                // Note: this cannot come from an inherent impl,\n-                                // because the first probing succeeded.\n-                                CandidateSource::Impl(def) => self.tcx.trait_id_of_impl(def),\n-                                CandidateSource::Trait(_) => None,\n-                            }\n-                        })\n-                        .collect(),\n-                    _ => Vec::new(),\n-                };\n+            let candidates = match self.lookup_probe_for_diagnostic(\n+                segment.ident,\n+                self_ty,\n+                call_expr,\n+                ProbeScope::AllTraits,\n+                None,\n+            ) {\n+                // If we find a different result the caller probably forgot to import a trait.\n+                Ok(ref new_pick) if pick.differs_from(new_pick) => {\n+                    vec![new_pick.item.container_id(self.tcx)]\n+                }\n+                Err(Ambiguity(ref sources)) => sources\n+                    .iter()\n+                    .filter_map(|source| {\n+                        match *source {\n+                            // Note: this cannot come from an inherent impl,\n+                            // because the first probing succeeded.\n+                            CandidateSource::Impl(def) => self.tcx.trait_id_of_impl(def),\n+                            CandidateSource::Trait(_) => None,\n+                        }\n+                    })\n+                    .collect(),\n+                _ => Vec::new(),\n+            };\n \n             return Err(IllegalSizedBound { candidates, needs_mut, bound_span: span, self_expr });\n         }\n@@ -252,12 +258,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         method_name: Ident,\n         self_ty: Ty<'tcx>,\n-        call_expr: &'tcx hir::Expr<'tcx>,\n+        call_expr: &hir::Expr<'_>,\n         scope: ProbeScope,\n     ) -> probe::PickResult<'tcx> {\n         let pick = self.probe_for_name(\n             probe::Mode::MethodCall,\n             method_name,\n+            None,\n             IsSuggestion(false),\n             self_ty,\n             call_expr.hir_id,\n@@ -267,6 +274,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Ok(pick)\n     }\n \n+    pub fn lookup_probe_for_diagnostic(\n+        &self,\n+        method_name: Ident,\n+        self_ty: Ty<'tcx>,\n+        call_expr: &hir::Expr<'_>,\n+        scope: ProbeScope,\n+        return_type: Option<Ty<'tcx>>,\n+    ) -> probe::PickResult<'tcx> {\n+        let pick = self.probe_for_name(\n+            probe::Mode::MethodCall,\n+            method_name,\n+            return_type,\n+            IsSuggestion(true),\n+            self_ty,\n+            call_expr.hir_id,\n+            scope,\n+        )?;\n+        Ok(pick)\n+    }\n+\n     pub(super) fn obligation_for_method(\n         &self,\n         cause: ObligationCause<'tcx>,\n@@ -386,7 +413,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Register obligations for the parameters. This will include the\n         // `Self` parameter, which in turn has a bound of the main trait,\n-        // so this also effectively registers `obligation` as well.  (We\n+        // so this also effectively registers `obligation` as well. (We\n         // used to register `obligation` explicitly, but that resulted in\n         // double error messages being reported.)\n         //\n@@ -484,6 +511,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let pick = self.probe_for_name(\n             probe::Mode::Path,\n             method_name,\n+            None,\n             IsSuggestion(false),\n             self_ty,\n             expr_id,"}, {"sha": "dd827777df94e68c03c031b98af1594b06e72793", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 65, "deletions": 21, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -9,6 +9,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n+use rustc_hir_analysis::autoderef::{self, Autoderef};\n use rustc_infer::infer::canonical::OriginalQueryValues;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -29,7 +30,6 @@ use rustc_span::lev_distance::{\n };\n use rustc_span::symbol::sym;\n use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n-use rustc_trait_selection::autoderef::{self, Autoderef};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::query::method_autoderef::MethodAutoderefBadTy;\n use rustc_trait_selection::traits::query::method_autoderef::{\n@@ -304,6 +304,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         mode: Mode,\n         item_name: Ident,\n+        return_type: Option<Ty<'tcx>>,\n         is_suggestion: IsSuggestion,\n         self_ty: Ty<'tcx>,\n         scope_expr_id: hir::HirId,\n@@ -313,7 +314,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             item_name.span,\n             mode,\n             Some(item_name),\n-            None,\n+            return_type,\n             is_suggestion,\n             self_ty,\n             scope_expr_id,\n@@ -327,6 +328,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         mode: Mode,\n         item_name: Ident,\n+        return_type: Option<Ty<'tcx>>,\n         is_suggestion: IsSuggestion,\n         self_ty: Ty<'tcx>,\n         scope_expr_id: hir::HirId,\n@@ -336,7 +338,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             item_name.span,\n             mode,\n             Some(item_name),\n-            None,\n+            return_type,\n             is_suggestion,\n             self_ty,\n             scope_expr_id,\n@@ -1540,7 +1542,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     let InferOk {\n                         value: normalized_xform_ret_ty,\n                         obligations: normalization_obligations,\n-                    } = self.fcx.at(&cause, self.param_env).normalize(probe.xform_ret_ty);\n+                    } = self.fcx.at(&cause, self.param_env).normalize(xform_ret_ty);\n                     xform_ret_ty = normalized_xform_ret_ty;\n                     debug!(\"xform_ret_ty after normalization: {:?}\", xform_ret_ty);\n \n@@ -1554,7 +1556,23 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n                     // Convert the bounds into obligations.\n                     let impl_obligations = traits::predicates_for_generics(\n-                        move |_, _| cause.clone(),\n+                        |_idx, span| {\n+                            let misc = traits::ObligationCause::misc(span, self.body_id);\n+                            let parent_trait_pred = ty::Binder::dummy(ty::TraitPredicate {\n+                                trait_ref: ty::TraitRef::from_method(self.tcx, impl_def_id, substs),\n+                                constness: ty::BoundConstness::NotConst,\n+                                polarity: ty::ImplPolarity::Positive,\n+                            });\n+                            misc.derived_cause(parent_trait_pred, |derived| {\n+                                traits::ImplDerivedObligation(Box::new(\n+                                    traits::ImplDerivedObligationCause {\n+                                        derived,\n+                                        impl_def_id,\n+                                        span,\n+                                    },\n+                                ))\n+                            })\n+                        },\n                         self.param_env,\n                         impl_bounds,\n                     );\n@@ -1597,7 +1615,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         ty::Binder::dummy(trait_ref).without_const().to_predicate(self.tcx);\n                     parent_pred = Some(predicate);\n                     let obligation =\n-                        traits::Obligation::new(self.tcx, cause, self.param_env, predicate);\n+                        traits::Obligation::new(self.tcx, cause.clone(), self.param_env, predicate);\n                     if !self.predicate_may_hold(&obligation) {\n                         result = ProbeResult::NoMatch;\n                         if self.probe(|_| {\n@@ -1656,22 +1674,48 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 }\n             }\n \n-            if let ProbeResult::Match = result {\n-                if let (Some(return_ty), Some(xform_ret_ty)) = (self.return_type, xform_ret_ty) {\n-                    let xform_ret_ty = self.resolve_vars_if_possible(xform_ret_ty);\n-                    debug!(\n-                        \"comparing return_ty {:?} with xform ret ty {:?}\",\n-                        return_ty, probe.xform_ret_ty\n-                    );\n-                    if self\n-                        .at(&ObligationCause::dummy(), self.param_env)\n-                        .define_opaque_types(false)\n-                        .sup(return_ty, xform_ret_ty)\n-                        .is_err()\n-                    {\n-                        return ProbeResult::BadReturnType;\n+            if let ProbeResult::Match = result\n+                && let Some(return_ty) = self.return_type\n+                && let Some(mut xform_ret_ty) = xform_ret_ty\n+            {\n+                // `xform_ret_ty` has only been normalized for `InherentImplCandidate`.\n+                // We don't normalize the other candidates for perf/backwards-compat reasons...\n+                // but `self.return_type` is only set on the diagnostic-path, so we\n+                // should be okay doing it here.\n+                if !matches!(probe.kind, InherentImplCandidate(..)) {\n+                    let InferOk {\n+                        value: normalized_xform_ret_ty,\n+                        obligations: normalization_obligations,\n+                    } = self.fcx.at(&cause, self.param_env).normalize(xform_ret_ty);\n+                    xform_ret_ty = normalized_xform_ret_ty;\n+                    debug!(\"xform_ret_ty after normalization: {:?}\", xform_ret_ty);\n+                    // Evaluate those obligations to see if they might possibly hold.\n+                    for o in normalization_obligations {\n+                        let o = self.resolve_vars_if_possible(o);\n+                        if !self.predicate_may_hold(&o) {\n+                            result = ProbeResult::NoMatch;\n+                            possibly_unsatisfied_predicates.push((\n+                                o.predicate,\n+                                None,\n+                                Some(o.cause),\n+                            ));\n+                        }\n                     }\n                 }\n+\n+                debug!(\n+                    \"comparing return_ty {:?} with xform ret ty {:?}\",\n+                    return_ty, xform_ret_ty\n+                );\n+                if let ProbeResult::Match = result\n+                    && self\n+                    .at(&ObligationCause::dummy(), self.param_env)\n+                    .define_opaque_types(false)\n+                    .sup(return_ty, xform_ret_ty)\n+                    .is_err()\n+                {\n+                    result = ProbeResult::BadReturnType;\n+                }\n             }\n \n             result\n@@ -1685,7 +1729,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     /// probe. This will result in a pending obligation so when more type-info is available we can\n     /// make the final decision.\n     ///\n-    /// Example (`src/test/ui/method-two-trait-defer-resolution-1.rs`):\n+    /// Example (`tests/ui/method-two-trait-defer-resolution-1.rs`):\n     ///\n     /// ```ignore (illustrative)\n     /// trait Foo { ... }"}, {"sha": "8166eb8299041136a089eb92866cf4fea044dd0b", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 98, "deletions": 52, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -2,6 +2,7 @@\n //! found or is otherwise invalid.\n \n use crate::errors;\n+use crate::Expectation;\n use crate::FnCtxt;\n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -100,6 +101,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.autoderef(span, ty).any(|(ty, _)| matches!(ty.kind(), ty::Slice(..) | ty::Array(..)))\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub fn report_method_error(\n         &self,\n         span: Span,\n@@ -108,6 +110,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         source: SelfSource<'tcx>,\n         error: MethodError<'tcx>,\n         args: Option<(&'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>])>,\n+        expected: Expectation<'tcx>,\n     ) -> Option<DiagnosticBuilder<'_, ErrorGuaranteed>> {\n         // Avoid suggestions when we don't know what's going on.\n         if rcvr_ty.references_error() {\n@@ -131,6 +134,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     args,\n                     sugg_span,\n                     &mut no_match_data,\n+                    expected,\n                 );\n             }\n \n@@ -250,6 +254,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         args: Option<(&'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>])>,\n         sugg_span: Span,\n         no_match_data: &mut NoMatchData<'tcx>,\n+        expected: Expectation<'tcx>,\n     ) -> Option<DiagnosticBuilder<'_, ErrorGuaranteed>> {\n         let mode = no_match_data.mode;\n         let tcx = self.tcx;\n@@ -320,7 +325,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n             self.suggest_await_before_method(\n-                &mut err, item_name, rcvr_ty, cal, span,\n+                &mut err, item_name, rcvr_ty, cal, span, expected.only_has_type(self),\n             );\n         }\n         if let Some(span) =\n@@ -366,8 +371,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.suggest_fn_call(&mut err, rcvr_expr, rcvr_ty, |output_ty| {\n                 let call_expr =\n                     self.tcx.hir().expect_expr(self.tcx.hir().parent_id(rcvr_expr.hir_id));\n-                let probe =\n-                    self.lookup_probe(item_name, output_ty, call_expr, ProbeScope::AllTraits);\n+                let probe = self.lookup_probe_for_diagnostic(\n+                    item_name,\n+                    output_ty,\n+                    call_expr,\n+                    ProbeScope::AllTraits,\n+                    expected.only_has_type(self),\n+                );\n                 probe.is_ok()\n             });\n         }\n@@ -577,22 +587,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Find all the requirements that come from a local `impl` block.\n             let mut skip_list: FxHashSet<_> = Default::default();\n-            let mut spanned_predicates: FxHashMap<MultiSpan, _> = Default::default();\n-            for (data, p, parent_p, impl_def_id, cause) in unsatisfied_predicates\n+            let mut spanned_predicates = FxHashMap::default();\n+            for (p, parent_p, impl_def_id, cause) in unsatisfied_predicates\n                 .iter()\n                 .filter_map(|(p, parent, c)| c.as_ref().map(|c| (p, parent, c)))\n                 .filter_map(|(p, parent, c)| match c.code() {\n-                    ObligationCauseCode::ImplDerivedObligation(data) => {\n-                        Some((&data.derived, p, parent, data.impl_def_id, data))\n+                    ObligationCauseCode::ImplDerivedObligation(data)\n+                        if matches!(p.kind().skip_binder(), ty::PredicateKind::Clause(_)) =>\n+                    {\n+                        Some((p, parent, data.impl_def_id, data))\n                     }\n                     _ => None,\n                 })\n             {\n-                let parent_trait_ref = data.parent_trait_pred;\n-                let path = parent_trait_ref.print_modifiers_and_trait_path();\n-                let tr_self_ty = parent_trait_ref.skip_binder().self_ty();\n-                let unsatisfied_msg = \"unsatisfied trait bound introduced here\";\n-                let derive_msg = \"unsatisfied trait bound introduced in this `derive` macro\";\n                 match self.tcx.hir().get_if_local(impl_def_id) {\n                     // Unmet obligation comes from a `derive` macro, point at it once to\n                     // avoid multiple span labels pointing at the same place.\n@@ -608,10 +615,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ) =>\n                     {\n                         let span = self_ty.span.ctxt().outer_expn_data().call_site;\n-                        let mut spans: MultiSpan = span.into();\n-                        spans.push_span_label(span, derive_msg);\n-                        let entry = spanned_predicates.entry(spans);\n-                        entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n+                        let entry = spanned_predicates.entry(span);\n+                        let entry = entry.or_insert_with(|| {\n+                            (FxHashSet::default(), FxHashSet::default(), Vec::new())\n+                        });\n+                        entry.0.insert(span);\n+                        entry.1.insert((\n+                            span,\n+                            \"unsatisfied trait bound introduced in this `derive` macro\",\n+                        ));\n+                        entry.2.push(p);\n+                        skip_list.insert(p);\n                     }\n \n                     // Unmet obligation coming from an `impl`.\n@@ -638,8 +652,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 };\n                                 err.span_suggestion_verbose(\n                                     sp,\n-                                    \"consider relaxing the type parameter's implicit \\\n-                                     `Sized` bound\",\n+                                    \"consider relaxing the type parameter's implicit `Sized` bound\",\n                                     sugg,\n                                     Applicability::MachineApplicable,\n                                 );\n@@ -650,25 +663,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let _ = format_pred(*pred);\n                         }\n                         skip_list.insert(p);\n-                        let mut spans = if cause.span != *item_span {\n-                            let mut spans: MultiSpan = cause.span.into();\n-                            spans.push_span_label(cause.span, unsatisfied_msg);\n-                            spans\n+                        let entry = spanned_predicates.entry(self_ty.span);\n+                        let entry = entry.or_insert_with(|| {\n+                            (FxHashSet::default(), FxHashSet::default(), Vec::new())\n+                        });\n+                        entry.2.push(p);\n+                        if cause.span != *item_span {\n+                            entry.0.insert(cause.span);\n+                            entry.1.insert((cause.span, \"unsatisfied trait bound introduced here\"));\n                         } else {\n-                            let mut spans = Vec::with_capacity(2);\n                             if let Some(trait_ref) = of_trait {\n-                                spans.push(trait_ref.path.span);\n+                                entry.0.insert(trait_ref.path.span);\n                             }\n-                            spans.push(self_ty.span);\n-                            spans.into()\n+                            entry.0.insert(self_ty.span);\n                         };\n                         if let Some(trait_ref) = of_trait {\n-                            spans.push_span_label(trait_ref.path.span, \"\");\n+                            entry.1.insert((trait_ref.path.span, \"\"));\n                         }\n-                        spans.push_span_label(self_ty.span, \"\");\n-\n-                        let entry = spanned_predicates.entry(spans);\n-                        entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n+                        entry.1.insert((self_ty.span, \"\"));\n                     }\n                     Some(Node::Item(hir::Item {\n                         kind: hir::ItemKind::Trait(rustc_ast::ast::IsAuto::Yes, ..),\n@@ -685,11 +697,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             let mut spanned_predicates: Vec<_> = spanned_predicates.into_iter().collect();\n-            spanned_predicates.sort_by_key(|(span, (_, _, _))| span.primary_span());\n-            for (span, (_path, _self_ty, preds)) in spanned_predicates {\n-                let mut preds: Vec<_> = preds\n-                    .into_iter()\n-                    .filter_map(|pred| format_pred(*pred))\n+            spanned_predicates.sort_by_key(|(span, _)| *span);\n+            for (_, (primary_spans, span_labels, predicates)) in spanned_predicates {\n+                let mut preds: Vec<_> = predicates\n+                    .iter()\n+                    .filter_map(|pred| format_pred(**pred))\n                     .map(|(p, _)| format!(\"`{}`\", p))\n                     .collect();\n                 preds.sort();\n@@ -699,6 +711,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 } else {\n                     format!(\"the following trait bounds were not satisfied:\\n{}\", preds.join(\"\\n\"),)\n                 };\n+                let mut span: MultiSpan = primary_spans.into_iter().collect::<Vec<_>>().into();\n+                for (sp, label) in span_labels {\n+                    span.push_span_label(sp, label);\n+                }\n                 err.span_note(span, &msg);\n                 unsatisfied_bounds = true;\n             }\n@@ -898,7 +914,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Don't suggest (for example) `expr.field.clone()` if `expr.clone()`\n         // can't be called due to `typeof(expr): Clone` not holding.\n         if unsatisfied_predicates.is_empty() {\n-            self.suggest_calling_method_on_field(&mut err, source, span, rcvr_ty, item_name);\n+            self.suggest_calling_method_on_field(\n+                &mut err,\n+                source,\n+                span,\n+                rcvr_ty,\n+                item_name,\n+                expected.only_has_type(self),\n+            );\n         }\n \n         self.check_for_inner_self(&mut err, source, rcvr_ty, item_name);\n@@ -922,6 +945,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 &unsatisfied_predicates,\n                 &static_candidates,\n                 unsatisfied_bounds,\n+                expected.only_has_type(self),\n             );\n         }\n \n@@ -987,7 +1011,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        self.check_for_deref_method(&mut err, source, rcvr_ty, item_name);\n+        self.check_for_deref_method(&mut err, source, rcvr_ty, item_name, expected);\n         return Some(err);\n     }\n \n@@ -1374,13 +1398,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let range_ty =\n                         self.tcx.bound_type_of(range_def_id).subst(self.tcx, &[actual.into()]);\n \n-                    let pick = self.probe_for_name(\n-                        Mode::MethodCall,\n+                    let pick = self.lookup_probe_for_diagnostic(\n                         item_name,\n-                        IsSuggestion(true),\n                         range_ty,\n-                        expr.hir_id,\n+                        expr,\n                         ProbeScope::AllTraits,\n+                        None,\n                     );\n                     if pick.is_ok() {\n                         let range_span = parent_expr.span.with_hi(expr.span.hi());\n@@ -1560,11 +1583,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             && let Some(expr) = visitor.result\n             && let Some(self_ty) = self.node_ty_opt(expr.hir_id)\n         {\n-            let probe = self.lookup_probe(\n+            let probe = self.lookup_probe_for_diagnostic(\n                 seg2.ident,\n                 self_ty,\n                 call_expr,\n                 ProbeScope::TraitsInScope,\n+                None,\n             );\n             if probe.is_ok() {\n                 let sm = self.infcx.tcx.sess.source_map();\n@@ -1587,6 +1611,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         actual: Ty<'tcx>,\n         item_name: Ident,\n+        return_type: Option<Ty<'tcx>>,\n     ) {\n         if let SelfSource::MethodCall(expr) = source\n         && let mod_id = self.tcx.parent_module(expr.hir_id).to_def_id()\n@@ -1610,11 +1635,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.check_for_nested_field_satisfying(\n                         span,\n                         &|_, field_ty| {\n-                            self.lookup_probe(\n+                            self.lookup_probe_for_diagnostic(\n                                 item_name,\n                                 field_ty,\n                                 call_expr,\n                                 ProbeScope::TraitsInScope,\n+                                return_type,\n                             )\n                             .map_or(false, |pick| {\n                                 !never_mention_traits\n@@ -1680,9 +1706,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             return None;\n                         }\n \n-                        self.lookup_probe(item_name, field_ty, call_expr, ProbeScope::TraitsInScope)\n-                            .ok()\n-                            .map(|pick| (variant, field, pick))\n+                        self.lookup_probe_for_diagnostic(\n+                            item_name,\n+                            field_ty,\n+                            call_expr,\n+                            ProbeScope::TraitsInScope,\n+                            None,\n+                        )\n+                        .ok()\n+                        .map(|pick| (variant, field, pick))\n                     })\n                     .collect();\n \n@@ -1746,11 +1778,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::AdtKind::Struct | ty::AdtKind::Union => {\n                 let [first] = ***substs else { return; };\n                 let ty::GenericArgKind::Type(ty) = first.unpack() else { return; };\n-                let Ok(pick) = self.lookup_probe(\n+                let Ok(pick) = self.lookup_probe_for_diagnostic(\n                     item_name,\n                     ty,\n                     call_expr,\n                     ProbeScope::TraitsInScope,\n+                    None,\n                 )  else { return; };\n \n                 let name = self.ty_to_value_string(actual);\n@@ -2010,12 +2043,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_source: SelfSource<'tcx>,\n         rcvr_ty: Ty<'tcx>,\n         item_name: Ident,\n+        expected: Expectation<'tcx>,\n     ) {\n         let SelfSource::QPath(ty) = self_source else { return; };\n         for (deref_ty, _) in self.autoderef(rustc_span::DUMMY_SP, rcvr_ty).skip(1) {\n             if let Ok(pick) = self.probe_for_name(\n                 Mode::Path,\n                 item_name,\n+                expected.only_has_type(self),\n                 IsSuggestion(true),\n                 deref_ty,\n                 ty.hir_id,\n@@ -2080,12 +2115,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         call: &hir::Expr<'_>,\n         span: Span,\n+        return_type: Option<Ty<'tcx>>,\n     ) {\n         let output_ty = match self.get_impl_future_output_ty(ty) {\n             Some(output_ty) => self.resolve_vars_if_possible(output_ty),\n             _ => return,\n         };\n-        let method_exists = self.method_exists(item_name, output_ty, call.hir_id, true);\n+        let method_exists =\n+            self.method_exists(item_name, output_ty, call.hir_id, true, return_type);\n         debug!(\"suggest_await_before_method: is_method_exist={}\", method_exists);\n         if method_exists {\n             err.span_suggestion_verbose(\n@@ -2199,6 +2236,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )],\n         static_candidates: &[CandidateSource],\n         unsatisfied_bounds: bool,\n+        return_type: Option<Ty<'tcx>>,\n     ) {\n         let mut alt_rcvr_sugg = false;\n         if let (SelfSource::MethodCall(rcvr), false) = (source, unsatisfied_bounds) {\n@@ -2221,7 +2259,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (self.tcx.mk_mut_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&mut \"),\n                 (self.tcx.mk_imm_ref(self.tcx.lifetimes.re_erased, rcvr_ty), \"&\"),\n             ] {\n-                match self.lookup_probe(item_name, *rcvr_ty, rcvr, ProbeScope::AllTraits) {\n+                match self.lookup_probe_for_diagnostic(\n+                    item_name,\n+                    *rcvr_ty,\n+                    rcvr,\n+                    ProbeScope::AllTraits,\n+                    return_type,\n+                ) {\n                     Ok(pick) => {\n                         // If the method is defined for the receiver we have, it likely wasn't `use`d.\n                         // We point at the method, but we just skip the rest of the check for arbitrary\n@@ -2254,11 +2298,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Rc), \"Rc::new\"),\n                 ] {\n                     if let Some(new_rcvr_t) = *rcvr_ty\n-                        && let Ok(pick) = self.lookup_probe(\n+                        && let Ok(pick) = self.lookup_probe_for_diagnostic(\n                             item_name,\n                             new_rcvr_t,\n                             rcvr,\n                             ProbeScope::AllTraits,\n+                            return_type,\n                         )\n                     {\n                         debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n@@ -2637,11 +2682,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 name: Symbol::intern(&format!(\"{}_else\", method_name.as_str())),\n                 span: method_name.span,\n             };\n-            let probe = self.lookup_probe(\n+            let probe = self.lookup_probe_for_diagnostic(\n                 new_name,\n                 self_ty,\n                 self_expr,\n                 ProbeScope::TraitsInScope,\n+                Some(expected),\n             );\n \n             // check the method arguments number"}, {"sha": "46799245222dc45599c6fbcbb71f9c9040109b15", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,4 +1,4 @@\n-use crate::FnCtxt;\n+use crate::{FnCtxt, RawTy};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{\n@@ -761,6 +761,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         err.span_note(sp, format!(\"{msg}: `{sugg}`\"));\n                     }\n                 }\n+                hir::Node::Pat(pt) if let PatKind::TupleStruct(_, pat_arr, _) = pt.kind => {\n+                    for i in pat_arr.iter() {\n+                        if let PatKind::Ref(the_ref, _) = i.kind\n+                        && let PatKind::Binding(mt, _, ident, _) = the_ref.kind {\n+                            let hir::BindingAnnotation(_, mtblty) = mt;\n+                            err.span_suggestion_verbose(\n+                                i.span,\n+                                format!(\"consider removing `&{mutability}` from the pattern\"),\n+                                mtblty.prefix_str().to_string() + &ident.name.to_string(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                    if let Some((sp, msg, sugg)) = mut_var_suggestion {\n+                        err.span_note(sp, format!(\"{msg}: `{sugg}`\"));\n+                    }\n+                }\n                 hir::Node::Param(_) | hir::Node::Arm(_) | hir::Node::Pat(_) => {\n                     // rely on match ergonomics or it might be nested `&&pat`\n                     err.span_suggestion_verbose(\n@@ -842,7 +859,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         pat: &Pat<'tcx>,\n         qpath: &hir::QPath<'_>,\n-        path_resolution: (Res, Option<Ty<'tcx>>, &'tcx [hir::PathSegment<'tcx>]),\n+        path_resolution: (Res, Option<RawTy<'tcx>>, &'tcx [hir::PathSegment<'tcx>]),\n         expected: Ty<'tcx>,\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {"}, {"sha": "ae0df5aa8f1cf0c89b385653455f9734395569cf", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -3,14 +3,14 @@ use crate::{has_expected_num_generic_args, FnCtxt, PlaceOp};\n use rustc_ast as ast;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_hir_analysis::autoderef::Autoderef;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::InferOk;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref, PointerCast};\n use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n-use rustc_trait_selection::autoderef::Autoderef;\n use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {"}, {"sha": "e12a575d5acde1278a19d7b36ee036b8b3a3695d", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -663,7 +663,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // fields of some type, the observable drop order will remain the same as it previously\n         // was even though we're dropping each capture individually.\n         // See https://github.com/rust-lang/project-rfc-2229/issues/42 and\n-        // `src/test/ui/closures/2229_closure_analysis/preserve_field_drop_order.rs`.\n+        // `tests/ui/closures/2229_closure_analysis/preserve_field_drop_order.rs`.\n         for (_, captures) in &mut root_var_min_capture_list {\n             captures.sort_by(|capture1, capture2| {\n                 for (p1, p2) in capture1.place.projections.iter().zip(&capture2.place.projections) {"}, {"sha": "8c24b6006444a8dc26d21d57b009768b05a0ad82", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -534,8 +534,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_opaque_types(&mut self) {\n-        let opaque_types =\n-            self.fcx.infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+        let opaque_types = self.fcx.infcx.take_opaque_types();\n         for (opaque_type_key, decl) in opaque_types {\n             let hidden_type = self.resolve(decl.hidden_type, &decl.hidden_type.span);\n             let opaque_type_key = self.resolve(opaque_type_key, &decl.hidden_type.span);"}, {"sha": "33a9a0cabb9d5067266f1d9025e4d04bc8cf324a", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -368,7 +368,7 @@ fn walk_between<'q>(\n ) -> FxHashSet<DepKind> {\n     // This is a bit tricky. We want to include a node only if it is:\n     // (a) reachable from a source and (b) will reach a target. And we\n-    // have to be careful about cycles etc.  Luckily efficiency is not\n+    // have to be careful about cycles etc. Luckily efficiency is not\n     // a big concern!\n \n     #[derive(Copy, Clone, PartialEq)]"}, {"sha": "ed7b272b13d178087c969aa3bda7f25da0bdec9a", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,4 +1,4 @@\n-//! Debugging code to test fingerprints computed for query results.  For each node marked with\n+//! Debugging code to test fingerprints computed for query results. For each node marked with\n //! `#[rustc_clean]` we will compare the fingerprint from the current and from the previous\n //! compilation session as appropriate:\n //!"}, {"sha": "091635e6c73c0b1c18cbac1a16c83b3bb85b537a", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -6,8 +6,7 @@\n //! [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html\n \n use crate::infer::canonical::{\n-    Canonical, CanonicalTyVarKind, CanonicalVarInfo, CanonicalVarKind, Canonicalized,\n-    OriginalQueryValues,\n+    Canonical, CanonicalTyVarKind, CanonicalVarInfo, CanonicalVarKind, OriginalQueryValues,\n };\n use crate::infer::InferCtxt;\n use rustc_middle::ty::flags::FlagComputation;\n@@ -40,7 +39,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         &self,\n         value: V,\n         query_state: &mut OriginalQueryValues<'tcx>,\n-    ) -> Canonicalized<'tcx, V>\n+    ) -> Canonical<'tcx, V>\n     where\n         V: TypeFoldable<'tcx>,\n     {\n@@ -59,7 +58,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         &self,\n         value: V,\n         query_state: &mut OriginalQueryValues<'tcx>,\n-    ) -> Canonicalized<'tcx, V>\n+    ) -> Canonical<'tcx, V>\n     where\n         V: TypeFoldable<'tcx>,\n     {\n@@ -99,7 +98,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// out the [chapter in the rustc dev guide][c].\n     ///\n     /// [c]: https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html#canonicalizing-the-query-result\n-    pub fn canonicalize_response<V>(&self, value: V) -> Canonicalized<'tcx, V>\n+    pub fn canonicalize_response<V>(&self, value: V) -> Canonical<'tcx, V>\n     where\n         V: TypeFoldable<'tcx>,\n     {\n@@ -113,7 +112,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         )\n     }\n \n-    pub fn canonicalize_user_type_annotation<V>(&self, value: V) -> Canonicalized<'tcx, V>\n+    pub fn canonicalize_user_type_annotation<V>(&self, value: V) -> Canonical<'tcx, V>\n     where\n         V: TypeFoldable<'tcx>,\n     {\n@@ -135,7 +134,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         &self,\n         value: V,\n         query_state: &mut OriginalQueryValues<'tcx>,\n-    ) -> Canonicalized<'tcx, V>\n+    ) -> Canonical<'tcx, V>\n     where\n         V: TypeFoldable<'tcx>,\n     {\n@@ -524,7 +523,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         canonicalize_region_mode: &dyn CanonicalizeMode,\n         query_state: &mut OriginalQueryValues<'tcx>,\n-    ) -> Canonicalized<'tcx, V>\n+    ) -> Canonical<'tcx, V>\n     where\n         V: TypeFoldable<'tcx>,\n     {"}, {"sha": "3d49182f0b8172d1edd7bb371b743ef0989e8243", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -9,7 +9,7 @@\n \n use crate::infer::canonical::substitute::{substitute_value, CanonicalExt};\n use crate::infer::canonical::{\n-    Canonical, CanonicalVarValues, CanonicalizedQueryResponse, Certainty, OriginalQueryValues,\n+    Canonical, CanonicalQueryResponse, CanonicalVarValues, Certainty, OriginalQueryValues,\n     QueryOutlivesConstraint, QueryRegionConstraints, QueryResponse,\n };\n use crate::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n@@ -57,7 +57,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         inference_vars: CanonicalVarValues<'tcx>,\n         answer: T,\n         fulfill_cx: &mut dyn TraitEngine<'tcx>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, T>>\n+    ) -> Fallible<CanonicalQueryResponse<'tcx, T>>\n     where\n         T: Debug + TypeFoldable<'tcx>,\n         Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable<'tcx>,\n@@ -156,10 +156,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// As the new solver does canonicalization slightly differently, this is also used there\n     /// for now. This should hopefully change fairly soon.\n     pub fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n-        self.inner\n-            .borrow_mut()\n-            .opaque_type_storage\n-            .take_opaque_types()\n+        std::mem::take(&mut self.inner.borrow_mut().opaque_type_storage.opaque_types)\n             .into_iter()\n             .map(|(k, v)| (self.tcx.mk_opaque(k.def_id.to_def_id(), k.substs), v.hidden_type.ty))\n             .collect()"}, {"sha": "72676b718fabe61853a9820a3282e271b8aed203", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -219,7 +219,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     ///\n     /// As `3 + 4` contains `N` in its substs, this must not succeed.\n     ///\n-    /// See `src/test/ui/const-generics/occurs-check/` for more examples where this is relevant.\n+    /// See `tests/ui/const-generics/occurs-check/` for more examples where this is relevant.\n     #[instrument(level = \"debug\", skip(self))]\n     fn unify_const_variable(\n         &self,\n@@ -331,7 +331,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         debug_assert!(self.infcx.inner.borrow_mut().type_variables().probe(b_vid).is_unknown());\n \n         // Generalize type of `a_ty` appropriately depending on the\n-        // direction.  As an example, assume:\n+        // direction. As an example, assume:\n         //\n         // - `a_ty == &'x ?1`, where `'x` is some free region and `?1` is an\n         //   inference variable,"}, {"sha": "080ae6b94669fdf2af1c76dc6fc1431209ae939e", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 85, "deletions": 20, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -55,6 +55,7 @@ use crate::infer::ExpectedFound;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n+    PredicateObligation,\n };\n \n use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n@@ -91,8 +92,12 @@ pub mod nice_region_error;\n pub struct TypeErrCtxt<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'tcx>,\n     pub typeck_results: Option<std::cell::Ref<'a, ty::TypeckResults<'tcx>>>,\n-    pub normalize_fn_sig: Box<dyn Fn(ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx> + 'a>,\n     pub fallback_has_occurred: bool,\n+\n+    pub normalize_fn_sig: Box<dyn Fn(ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx> + 'a>,\n+\n+    pub autoderef_steps:\n+        Box<dyn Fn(Ty<'tcx>) -> Vec<(Ty<'tcx>, Vec<PredicateObligation<'tcx>>)> + 'a>,\n }\n \n impl TypeErrCtxt<'_, '_> {\n@@ -310,7 +315,7 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n             // Ugh. This is a painful case: the hidden region is not one\n             // that we can easily summarize or explain. This can happen\n             // in a case like\n-            // `src/test/ui/multiple-lifetimes/ordinary-bounds-unsuited.rs`:\n+            // `tests/ui/multiple-lifetimes/ordinary-bounds-unsuited.rs`:\n             //\n             // ```\n             // fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> {\n@@ -1395,7 +1400,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     /// `swap_secondary_and_primary` is used to make projection errors in particular nicer by using\n     /// the message in `secondary_span` as the primary label, and apply the message that would\n     /// otherwise be used for the primary label on the `secondary_span` `Span`. This applies on\n-    /// E0271, like `src/test/ui/issues/issue-39970.stderr`.\n+    /// E0271, like `tests/ui/issues/issue-39970.stderr`.\n     #[instrument(\n         level = \"debug\",\n         skip(self, diag, secondary_span, swap_secondary_and_primary, prefer_label)\n@@ -2144,18 +2149,21 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         // suggest adding an explicit lifetime bound to it.\n         let generics = self.tcx.generics_of(generic_param_scope);\n         // type_param_span is (span, has_bounds)\n+        let mut is_synthetic = false;\n+        let mut ast_generics = None;\n         let type_param_span = match bound_kind {\n             GenericKind::Param(ref param) => {\n                 // Account for the case where `param` corresponds to `Self`,\n                 // which doesn't have the expected type argument.\n                 if !(generics.has_self && param.index == 0) {\n                     let type_param = generics.type_param(param, self.tcx);\n+                    is_synthetic = type_param.kind.is_synthetic();\n                     type_param.def_id.as_local().map(|def_id| {\n                         // Get the `hir::Param` to verify whether it already has any bounds.\n                         // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                         // instead we suggest `T: 'a + 'b` in that case.\n                         let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                        let ast_generics = self.tcx.hir().get_generics(hir_id.owner.def_id);\n+                        ast_generics = self.tcx.hir().get_generics(hir_id.owner.def_id);\n                         let bounds =\n                             ast_generics.and_then(|g| g.bounds_span_for_suggestions(def_id));\n                         // `sp` only covers `T`, change it so that it covers\n@@ -2187,11 +2195,64 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 .unwrap_or(\"'lt\".to_string())\n         };\n \n-        let add_lt_sugg = generics\n-            .params\n-            .first()\n-            .and_then(|param| param.def_id.as_local())\n-            .map(|def_id| (self.tcx.def_span(def_id).shrink_to_lo(), format!(\"{}, \", new_lt)));\n+        let mut add_lt_suggs: Vec<Option<_>> = vec![];\n+        if is_synthetic {\n+            if let Some(ast_generics) = ast_generics {\n+                let named_lifetime_param_exist = ast_generics.params.iter().any(|p| {\n+                    matches!(\n+                        p.kind,\n+                        hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Explicit }\n+                    )\n+                });\n+                if named_lifetime_param_exist && let [param, ..] = ast_generics.params\n+                {\n+                    add_lt_suggs.push(Some((\n+                        self.tcx.def_span(param.def_id).shrink_to_lo(),\n+                        format!(\"{new_lt}, \"),\n+                    )));\n+                } else {\n+                    add_lt_suggs\n+                        .push(Some((ast_generics.span.shrink_to_hi(), format!(\"<{new_lt}>\"))));\n+                }\n+            }\n+        } else {\n+            if let [param, ..] = &generics.params[..] && let Some(def_id) = param.def_id.as_local()\n+            {\n+                add_lt_suggs\n+                    .push(Some((self.tcx.def_span(def_id).shrink_to_lo(), format!(\"{new_lt}, \"))));\n+            }\n+        }\n+\n+        if let Some(ast_generics) = ast_generics {\n+            for p in ast_generics.params {\n+                if p.is_elided_lifetime() {\n+                    if self\n+                        .tcx\n+                        .sess\n+                        .source_map()\n+                        .span_to_prev_source(p.span.shrink_to_hi())\n+                        .ok()\n+                        .map_or(false, |s| *s.as_bytes().last().unwrap() == b'&')\n+                    {\n+                        add_lt_suggs\n+                            .push(Some(\n+                                (\n+                                    p.span.shrink_to_hi(),\n+                                    if let Ok(snip) = self.tcx.sess.source_map().span_to_next_source(p.span)\n+                                        && snip.starts_with(' ')\n+                                    {\n+                                        format!(\"{new_lt}\")\n+                                    } else {\n+                                        format!(\"{new_lt} \")\n+                                    }\n+                                )\n+                            ));\n+                    } else {\n+                        add_lt_suggs.push(Some((p.span.shrink_to_hi(), format!(\"<{new_lt}>\"))));\n+                    }\n+                }\n+            }\n+        }\n \n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n@@ -2215,20 +2276,22 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             );\n         }\n \n-        fn binding_suggestion<S: fmt::Display>(\n+        fn binding_suggestion<'tcx, S: fmt::Display>(\n             err: &mut Diagnostic,\n             type_param_span: Option<(Span, bool)>,\n-            bound_kind: GenericKind<'_>,\n+            bound_kind: GenericKind<'tcx>,\n             sub: S,\n-            add_lt_sugg: Option<(Span, String)>,\n+            add_lt_suggs: Vec<Option<(Span, String)>>,\n         ) {\n             let msg = \"consider adding an explicit lifetime bound\";\n             if let Some((sp, has_lifetimes)) = type_param_span {\n                 let suggestion =\n                     if has_lifetimes { format!(\" + {}\", sub) } else { format!(\": {}\", sub) };\n                 let mut suggestions = vec![(sp, suggestion)];\n-                if let Some(add_lt_sugg) = add_lt_sugg {\n-                    suggestions.push(add_lt_sugg);\n+                for add_lt_sugg in add_lt_suggs {\n+                    if let Some(add_lt_sugg) = add_lt_sugg {\n+                        suggestions.push(add_lt_sugg);\n+                    }\n                 }\n                 err.multipart_suggestion_verbose(\n                     format!(\"{msg}...\"),\n@@ -2252,9 +2315,11 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     };\n                     let mut sugg =\n                         vec![(sp, suggestion), (span.shrink_to_hi(), format!(\" + {}\", new_lt))];\n-                    if let Some(lt) = add_lt_sugg.clone() {\n-                        sugg.push(lt);\n-                        sugg.rotate_right(1);\n+                    for add_lt_sugg in add_lt_suggs.clone() {\n+                        if let Some(lt) = add_lt_sugg {\n+                            sugg.push(lt);\n+                            sugg.rotate_right(1);\n+                        }\n                     }\n                     // `MaybeIncorrect` due to issue #41966.\n                     err.multipart_suggestion(msg, sugg, Applicability::MaybeIncorrect);\n@@ -2358,7 +2423,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 // for the bound is not suitable for suggestions when `-Zverbose` is set because it\n                 // uses `Debug` output, so we handle it specially here so that suggestions are\n                 // always correct.\n-                binding_suggestion(&mut err, type_param_span, bound_kind, name, None);\n+                binding_suggestion(&mut err, type_param_span, bound_kind, name, vec![]);\n                 err\n             }\n \n@@ -2371,7 +2436,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     \"{} may not live long enough\",\n                     labeled_user_string\n                 );\n-                binding_suggestion(&mut err, type_param_span, bound_kind, \"'static\", None);\n+                binding_suggestion(&mut err, type_param_span, bound_kind, \"'static\", vec![]);\n                 err\n             }\n \n@@ -2410,7 +2475,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                                 type_param_span,\n                                 bound_kind,\n                                 new_lt,\n-                                add_lt_sugg,\n+                                add_lt_suggs,\n                             );\n                         }\n                     }"}, {"sha": "99431567edac413f4aef86a04e49516ddf932599", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -370,7 +370,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         //   in the types are about to print\n         // - Meanwhile, the `maybe_highlighting_region` calls set up\n         //   highlights so that, if they do appear, we will replace\n-        //   them `'0` and whatever.  (This replacement takes place\n+        //   them `'0` and whatever. (This replacement takes place\n         //   inside the closure given to `maybe_highlighting_region`.)\n         //\n         // There is some duplication between the calls -- i.e., the"}, {"sha": "7504ed094a3d4160715436ac3981b6f1729e45e3", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -29,15 +29,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 RegionOriginNote::Plain { span, msg: fluent::infer_relate_object_bound }\n                     .add_to_diagnostic(err);\n             }\n-            infer::DataBorrowed(ty, span) => {\n-                RegionOriginNote::WithName {\n-                    span,\n-                    msg: fluent::infer_data_borrowed,\n-                    name: &self.ty_to_string(ty),\n-                    continues: false,\n-                }\n-                .add_to_diagnostic(err);\n-            }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 RegionOriginNote::WithName {\n                     span,\n@@ -227,32 +218,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 );\n                 err\n             }\n-            infer::DataBorrowed(ty, span) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0490,\n-                    \"a value of type `{}` is borrowed for too long\",\n-                    self.ty_to_string(ty)\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"the type is valid for \",\n-                    sub,\n-                    \"\",\n-                    None,\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    &mut err,\n-                    \"but the borrow lasts for \",\n-                    sup,\n-                    \"\",\n-                    None,\n-                );\n-                err\n-            }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,"}, {"sha": "4dbb4b4d7b4da8b681d38180acc87270092f1fd6", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -78,7 +78,7 @@ where\n         //\n         // Example: if the LHS is a type variable, and RHS is\n         // `Box<i32>`, then we current compare `v` to the RHS first,\n-        // which will instantiate `v` with `Box<i32>`.  Then when `v`\n+        // which will instantiate `v` with `Box<i32>`. Then when `v`\n         // is compared to the LHS, we instantiate LHS with `Box<i32>`.\n         // But if we did in reverse order, we would create a `v <:\n         // LHS` (or vice versa) constraint and then instantiate"}, {"sha": "0b478f4cf5cd0701d6293af19f2bab9b2d5af568", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -52,7 +52,7 @@ pub struct LexicalRegionResolutions<'tcx> {\n \n #[derive(Copy, Clone, Debug)]\n pub(crate) enum VarValue<'tcx> {\n-    /// Empty lifetime is for data that is never accessed.  We tag the\n+    /// Empty lifetime is for data that is never accessed. We tag the\n     /// empty lifetime with a universe -- the idea is that we don't\n     /// want `exists<'a> { forall<'b> { 'b: 'a } }` to be satisfiable.\n     /// Therefore, the `'empty` in a universe `U` is less than all\n@@ -510,7 +510,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n \n         // If both `a` and `b` are free, consult the declared\n-        // relationships.  Note that this can be more precise than the\n+        // relationships. Note that this can be more precise than the\n         // `lub` relationship defined below, since sometimes the \"lub\"\n         // is actually the `postdom_upper_bound` (see\n         // `TransitiveRelation` for more details).\n@@ -665,7 +665,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         // conflicting regions to report to the user. As we walk, we\n         // trip the flags from false to true, and if we find that\n         // we've already reported an error involving any particular\n-        // node we just stop and don't report the current error.  The\n+        // node we just stop and don't report the current error. The\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n@@ -702,26 +702,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     // Obtain the spans for all the places that can\n                     // influence the constraints on this value for\n                     // richer diagnostics in `static_impl_trait`.\n-                    let influences: Vec<Span> = self\n-                        .data\n-                        .constraints\n-                        .iter()\n-                        .filter_map(|(constraint, origin)| match (constraint, origin) {\n-                            (\n-                                Constraint::VarSubVar(_, sup),\n-                                SubregionOrigin::DataBorrowed(_, sp),\n-                            ) if sup == &node_vid => Some(*sp),\n-                            _ => None,\n-                        })\n-                        .collect();\n-\n-                    self.collect_error_for_expanding_node(\n-                        graph,\n-                        &mut dup_vec,\n-                        node_vid,\n-                        errors,\n-                        influences,\n-                    );\n+\n+                    self.collect_error_for_expanding_node(graph, &mut dup_vec, node_vid, errors);\n                 }\n             }\n         }\n@@ -775,7 +757,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         dup_vec: &mut IndexVec<RegionVid, Option<RegionVid>>,\n         node_idx: RegionVid,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n-        influences: Vec<Span>,\n     ) {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n@@ -830,7 +811,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                         lower_bound.region,\n                         upper_bound.origin.clone(),\n                         upper_bound.region,\n-                        influences,\n+                        vec![],\n                     ));\n                     return;\n                 }"}, {"sha": "f0e42c1fce49c3ea685f6301b22f1d09e702e774", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -410,9 +410,6 @@ pub enum SubregionOrigin<'tcx> {\n     /// Creating a pointer `b` to contents of another reference\n     Reborrow(Span),\n \n-    /// Data with type `Ty<'tcx>` was borrowed\n-    DataBorrowed(Ty<'tcx>, Span),\n-\n     /// (&'a &'b T) where a >= b\n     ReferenceOutlivesReferent(Ty<'tcx>, Span),\n \n@@ -688,6 +685,10 @@ impl<'tcx> InferCtxt<'tcx> {\n             typeck_results: None,\n             fallback_has_occurred: false,\n             normalize_fn_sig: Box::new(|fn_sig| fn_sig),\n+            autoderef_steps: Box::new(|ty| {\n+                debug_assert!(false, \"shouldn't be using autoderef_steps outside of typeck\");\n+                vec![(ty, vec![])]\n+            }),\n         }\n     }\n \n@@ -1104,7 +1105,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.tcx.mk_region(ty::ReVar(region_var))\n     }\n \n-    /// Return the universe that the region `r` was created in.  For\n+    /// Return the universe that the region `r` was created in. For\n     /// most regions (e.g., `'static`, named regions from the user,\n     /// etc) this is the root universe U0. For inference variables or\n     /// placeholders, however, it will return the universe which they\n@@ -1338,6 +1339,12 @@ impl<'tcx> InferCtxt<'tcx> {\n         var_infos\n     }\n \n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub fn take_opaque_types(&self) -> opaque_types::OpaqueTypeMap<'tcx> {\n+        debug_assert_ne!(self.defining_use_anchor, DefiningAnchor::Error);\n+        std::mem::take(&mut self.inner.borrow_mut().opaque_type_storage.opaque_types)\n+    }\n+\n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n         self.resolve_vars_if_possible(t).to_string()\n     }\n@@ -1354,7 +1361,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     }\n \n     /// Resolve any type variables found in `value` -- but only one\n-    /// level.  So, if the variable `?X` is bound to some type\n+    /// level. So, if the variable `?X` is bound to some type\n     /// `Foo<?Y>`, then this would return `Foo<?Y>` (but `?Y` may\n     /// itself be bound to a type).\n     ///\n@@ -1679,13 +1686,29 @@ impl<'tcx> InferCtxt<'tcx> {\n }\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    /// Processes registered region obliations and resolves regions, reporting\n+    /// any errors if any were raised. Prefer using this function over manually\n+    /// calling `resolve_regions_and_report_errors`.\n+    pub fn check_region_obligations_and_report_errors(\n+        &self,\n+        generic_param_scope: LocalDefId,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+    ) -> Result<(), ErrorGuaranteed> {\n+        self.process_registered_region_obligations(\n+            outlives_env.region_bound_pairs(),\n+            outlives_env.param_env,\n+        );\n+\n+        self.resolve_regions_and_report_errors(generic_param_scope, outlives_env)\n+    }\n+\n     /// Process the region constraints and report any errors that\n     /// result. After this, no more unification operations should be\n     /// done -- or the compiler will panic -- but it is legal to use\n     /// `resolve_vars_if_possible` as well as `fully_resolve`.\n     ///\n     /// Make sure to call [`InferCtxt::process_registered_region_obligations`]\n-    /// first, or preferably use [`InferCtxt::check_region_obligations_and_report_errors`]\n+    /// first, or preferably use [`TypeErrCtxt::check_region_obligations_and_report_errors`]\n     /// to do both of these operations together.\n     pub fn resolve_regions_and_report_errors(\n         &self,\n@@ -1697,7 +1720,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         if let None = self.tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors\n             // altogether if other errors have been reported while\n-            // this infcx was in use.  This is totally hokey but\n+            // this infcx was in use. This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n             self.report_region_errors(generic_param_scope, &errors);\n@@ -1952,7 +1975,6 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             RelateParamBound(a, ..) => a,\n             RelateRegionParamBound(a) => a,\n             Reborrow(a) => a,\n-            DataBorrowed(_, a) => a,\n             ReferenceOutlivesReferent(_, a) => a,\n             CompareImplItemObligation { span, .. } => span,\n             AscribeUserTypeProvePredicate(span) => span,"}, {"sha": "985cb6463a0646939a0609c09004787d5a39355b", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -439,7 +439,7 @@ trait VidValuePair<'tcx>: Debug {\n     fn value_ty(&self) -> Ty<'tcx>;\n \n     /// Extract the scopes that apply to whichever side of the tuple\n-    /// the vid was found on.  See the comment where this is called\n+    /// the vid was found on. See the comment where this is called\n     /// for more details on why we want them.\n     fn vid_scopes<'r, D: TypeRelatingDelegate<'tcx>>(\n         &self,\n@@ -831,7 +831,7 @@ where\n /// (these are not explicitly present in the ty representation right\n /// now). This visitor handles that: it descends the type, tracking\n /// binder depth, and finds late-bound regions targeting the\n-/// `for<..`>.  For each of those, it creates an entry in\n+/// `for<..`>. For each of those, it creates an entry in\n /// `bound_region_scope`.\n struct ScopeInstantiator<'me, 'tcx> {\n     next_region: &'me mut dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx>,"}, {"sha": "6b54ee9576f6703978ef6d7d091984c5735058be", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -112,7 +112,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                     DefiningAnchor::Bind(_) => {\n                         // Check that this is `impl Trait` type is\n                         // declared by `parent_def_id` -- i.e., one whose\n-                        // value we are inferring.  At present, this is\n+                        // value we are inferring. At present, this is\n                         // always true during the first phase of\n                         // type-check, but not always true later on during\n                         // NLL. Once we support named opaque types more fully,\n@@ -380,7 +380,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         };\n         let item_kind = &self.tcx.hir().expect_item(def_id).kind;\n \n-        let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {\n+        let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) = item_kind else {\n             span_bug!(\n                 span,\n                 \"weird opaque type: {:#?}, {:#?}\","}, {"sha": "ae4b85c8799ef130b252ffe50a210834c6bcfd58", "filename": "compiler/rustc_infer/src/infer/opaque_types/table.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -29,11 +29,6 @@ impl<'tcx> OpaqueTypeStorage<'tcx> {\n         }\n     }\n \n-    #[instrument(level = \"debug\", ret)]\n-    pub fn take_opaque_types(&mut self) -> OpaqueTypeMap<'tcx> {\n-        std::mem::take(&mut self.opaque_types)\n-    }\n-\n     #[inline]\n     pub(crate) fn with_log<'a>(\n         &'a mut self,"}, {"sha": "31d978b4ccb2b902006ff20d871e8df1f269418d", "filename": "compiler/rustc_infer/src/infer/outlives/components.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -153,7 +153,7 @@ fn compute_components<'tcx>(\n                     out.push(Component::Projection(*data));\n                 } else {\n                     // fallback case: hard code\n-                    // OutlivesProjectionComponents.  Continue walking\n+                    // OutlivesProjectionComponents. Continue walking\n                     // through and constrain Pi.\n                     let mut subcomponents = smallvec![];\n                     let mut subvisited = SsoHashSet::new();\n@@ -195,7 +195,7 @@ fn compute_components<'tcx>(\n             ty::Error(_) => {\n                 // (*) Function pointers and trait objects are both binders.\n                 // In the RFC, this means we would add the bound regions to\n-                // the \"bound regions list\".  In our representation, no such\n+                // the \"bound regions list\". In our representation, no such\n                 // list is maintained explicitly, because bound regions\n                 // themselves can be readily identified.\n                 compute_components_recursive(tcx, ty.into(), out, visited);"}, {"sha": "07838911c885eacdac83e701f8a7bc14f6e92ae2", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -60,17 +60,14 @@\n //! imply that `'b: 'a`.\n \n use crate::infer::outlives::components::{push_outlives_components, Component};\n-use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::outlives::verify::VerifyBoundCx;\n use crate::infer::{\n     self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, UndoLog, VerifyBound,\n };\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::undo_log::UndoLogs;\n-use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::def_id::LocalDefId;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Region, SubstsRef, Ty, TyCtxt, TypeVisitable};\n@@ -116,7 +113,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         std::mem::take(&mut self.inner.borrow_mut().region_obligations)\n     }\n \n-    /// NOTE: Prefer using [`InferCtxt::check_region_obligations_and_report_errors`]\n+    /// NOTE: Prefer using `TypeErrCtxt::check_region_obligations_and_report_errors`\n     /// instead of calling this directly.\n     ///\n     /// Process the region obligations that must be proven (during\n@@ -170,22 +167,6 @@ impl<'tcx> InferCtxt<'tcx> {\n             outlives.type_must_outlive(origin, sup_type, sub_region, category);\n         }\n     }\n-\n-    /// Processes registered region obliations and resolves regions, reporting\n-    /// any errors if any were raised. Prefer using this function over manually\n-    /// calling `resolve_regions_and_report_errors`.\n-    pub fn check_region_obligations_and_report_errors(\n-        &self,\n-        generic_param_scope: LocalDefId,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-    ) -> Result<(), ErrorGuaranteed> {\n-        self.process_registered_region_obligations(\n-            outlives_env.region_bound_pairs(),\n-            outlives_env.param_env,\n-        );\n-\n-        self.err_ctxt().resolve_regions_and_report_errors(generic_param_scope, outlives_env)\n-    }\n }\n \n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n@@ -390,7 +371,7 @@ where\n         // particular). :) First off, we have to choose between using the\n         // OutlivesProjectionEnv, OutlivesProjectionTraitDef, and\n         // OutlivesProjectionComponent rules, any one of which is\n-        // sufficient.  If there are no inference variables involved, it's\n+        // sufficient. If there are no inference variables involved, it's\n         // not hard to pick the right rule, but if there are, we're in a\n         // bit of a catch 22: if we picked which rule we were going to\n         // use, we could add constraints to the region inference graph"}, {"sha": "263c6a47dd2af79f791343f418ca911376d44a52", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -433,7 +433,7 @@ impl<'tcx> ut::UnifyValue for TypeVariableValue<'tcx> {\n     fn unify_values(value1: &Self, value2: &Self) -> Result<Self, ut::NoError> {\n         match (value1, value2) {\n             // We never equate two type variables, both of which\n-            // have known types.  Instead, we recursively equate\n+            // have known types. Instead, we recursively equate\n             // those types.\n             (&TypeVariableValue::Known { .. }, &TypeVariableValue::Known { .. }) => {\n                 bug!(\"equating two type variables, both of which have known types\")"}, {"sha": "c2ac2c5db26e4814b78d77cd8ad295f819d69c45", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -333,7 +333,7 @@ pub fn transitive_bounds<'tcx>(\n /// A specialized variant of `elaborate_trait_refs` that only elaborates trait references that may\n /// define the given associated type `assoc_name`. It uses the\n /// `super_predicates_that_define_assoc_type` query to avoid enumerating super-predicates that\n-/// aren't related to `assoc_item`.  This is used when resolving types like `Self::Item` or\n+/// aren't related to `assoc_item`. This is used when resolving types like `Self::Item` or\n /// `T::Item` and helps to avoid cycle errors (see e.g. #35237).\n pub fn transitive_bounds_that_define_assoc_type<'tcx>(\n     tcx: TyCtxt<'tcx>,"}, {"sha": "041bb9eb7a1cbcd58b9239fa432b9784334fbc99", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 60, "deletions": 48, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -5,6 +5,7 @@ use crate::passes::{self, BoxedResolver, QueryContext};\n use rustc_ast as ast;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n+use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_hir::def_id::LOCAL_CRATE;\n@@ -19,43 +20,53 @@ use rustc_session::{output::find_crate_name, Session};\n use rustc_span::symbol::sym;\n use rustc_span::Symbol;\n use std::any::Any;\n-use std::cell::{Ref, RefCell, RefMut};\n+use std::cell::{RefCell, RefMut};\n use std::rc::Rc;\n use std::sync::Arc;\n \n /// Represent the result of a query.\n ///\n-/// This result can be stolen with the [`take`] method and generated with the [`compute`] method.\n+/// This result can be stolen once with the [`steal`] method and generated with the [`compute`] method.\n ///\n-/// [`take`]: Self::take\n+/// [`steal`]: Steal::steal\n /// [`compute`]: Self::compute\n pub struct Query<T> {\n-    result: RefCell<Option<Result<T>>>,\n+    /// `None` means no value has been computed yet.\n+    result: RefCell<Option<Result<Steal<T>>>>,\n }\n \n impl<T> Query<T> {\n-    fn compute<F: FnOnce() -> Result<T>>(&self, f: F) -> Result<&Query<T>> {\n-        self.result.borrow_mut().get_or_insert_with(f).as_ref().map(|_| self).map_err(|&err| err)\n+    fn compute<F: FnOnce() -> Result<T>>(&self, f: F) -> Result<QueryResult<'_, T>> {\n+        RefMut::filter_map(\n+            self.result.borrow_mut(),\n+            |r: &mut Option<Result<Steal<T>>>| -> Option<&mut Steal<T>> {\n+                r.get_or_insert_with(|| f().map(Steal::new)).as_mut().ok()\n+            },\n+        )\n+        .map_err(|r| *r.as_ref().unwrap().as_ref().map(|_| ()).unwrap_err())\n+        .map(QueryResult)\n     }\n+}\n+\n+pub struct QueryResult<'a, T>(RefMut<'a, Steal<T>>);\n+\n+impl<'a, T> std::ops::Deref for QueryResult<'a, T> {\n+    type Target = RefMut<'a, Steal<T>>;\n \n-    /// Takes ownership of the query result. Further attempts to take or peek the query\n-    /// result will panic unless it is generated by calling the `compute` method.\n-    pub fn take(&self) -> T {\n-        self.result.borrow_mut().take().expect(\"missing query result\").unwrap()\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n     }\n+}\n \n-    /// Borrows the query result using the RefCell. Panics if the result is stolen.\n-    pub fn peek(&self) -> Ref<'_, T> {\n-        Ref::map(self.result.borrow(), |r| {\n-            r.as_ref().unwrap().as_ref().expect(\"missing query result\")\n-        })\n+impl<'a, T> std::ops::DerefMut for QueryResult<'a, T> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n     }\n+}\n \n-    /// Mutably borrows the query result using the RefCell. Panics if the result is stolen.\n-    pub fn peek_mut(&self) -> RefMut<'_, T> {\n-        RefMut::map(self.result.borrow_mut(), |r| {\n-            r.as_mut().unwrap().as_mut().expect(\"missing query result\")\n-        })\n+impl<'a, 'tcx> QueryResult<'a, QueryContext<'tcx>> {\n+    pub fn enter<T>(mut self, f: impl FnOnce(TyCtxt<'tcx>) -> T) -> T {\n+        (*self.0).get_mut().enter(f)\n     }\n }\n \n@@ -111,24 +122,24 @@ impl<'tcx> Queries<'tcx> {\n         self.compiler.codegen_backend()\n     }\n \n-    fn dep_graph_future(&self) -> Result<&Query<Option<DepGraphFuture>>> {\n+    fn dep_graph_future(&self) -> Result<QueryResult<'_, Option<DepGraphFuture>>> {\n         self.dep_graph_future.compute(|| {\n             let sess = self.session();\n             Ok(sess.opts.build_dep_graph().then(|| rustc_incremental::load_dep_graph(sess)))\n         })\n     }\n \n-    pub fn parse(&self) -> Result<&Query<ast::Crate>> {\n+    pub fn parse(&self) -> Result<QueryResult<'_, ast::Crate>> {\n         self.parse.compute(|| {\n             passes::parse(self.session(), &self.compiler.input)\n                 .map_err(|mut parse_error| parse_error.emit())\n         })\n     }\n \n-    pub fn register_plugins(&self) -> Result<&Query<(ast::Crate, Lrc<LintStore>)>> {\n+    pub fn register_plugins(&self) -> Result<QueryResult<'_, (ast::Crate, Lrc<LintStore>)>> {\n         self.register_plugins.compute(|| {\n-            let crate_name = *self.crate_name()?.peek();\n-            let krate = self.parse()?.take();\n+            let crate_name = *self.crate_name()?.borrow();\n+            let krate = self.parse()?.steal();\n \n             let empty: &(dyn Fn(&Session, &mut LintStore) + Sync + Send) = &|_, _| {};\n             let (krate, lint_store) = passes::register_plugins(\n@@ -150,11 +161,11 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    pub fn crate_name(&self) -> Result<&Query<Symbol>> {\n+    pub fn crate_name(&self) -> Result<QueryResult<'_, Symbol>> {\n         self.crate_name.compute(|| {\n             Ok({\n                 let parse_result = self.parse()?;\n-                let krate = parse_result.peek();\n+                let krate = parse_result.borrow();\n                 // parse `#[crate_name]` even if `--crate-name` was passed, to make sure it matches.\n                 find_crate_name(self.session(), &krate.attrs, &self.compiler.input)\n             })\n@@ -163,11 +174,12 @@ impl<'tcx> Queries<'tcx> {\n \n     pub fn expansion(\n         &self,\n-    ) -> Result<&Query<(Lrc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>> {\n+    ) -> Result<QueryResult<'_, (Lrc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>>\n+    {\n         trace!(\"expansion\");\n         self.expansion.compute(|| {\n-            let crate_name = *self.crate_name()?.peek();\n-            let (krate, lint_store) = self.register_plugins()?.take();\n+            let crate_name = *self.crate_name()?.borrow();\n+            let (krate, lint_store) = self.register_plugins()?.steal();\n             let _timer = self.session().timer(\"configure_and_expand\");\n             let sess = self.session();\n             let mut resolver = passes::create_resolver(\n@@ -183,10 +195,10 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    fn dep_graph(&self) -> Result<&Query<DepGraph>> {\n+    fn dep_graph(&self) -> Result<QueryResult<'_, DepGraph>> {\n         self.dep_graph.compute(|| {\n             let sess = self.session();\n-            let future_opt = self.dep_graph_future()?.take();\n+            let future_opt = self.dep_graph_future()?.steal();\n             let dep_graph = future_opt\n                 .and_then(|future| {\n                     let (prev_graph, prev_work_products) =\n@@ -199,10 +211,11 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    pub fn prepare_outputs(&self) -> Result<&Query<OutputFilenames>> {\n+    pub fn prepare_outputs(&self) -> Result<QueryResult<'_, OutputFilenames>> {\n         self.prepare_outputs.compute(|| {\n-            let (krate, boxed_resolver, _) = &*self.expansion()?.peek();\n-            let crate_name = *self.crate_name()?.peek();\n+            let expansion = self.expansion()?;\n+            let (krate, boxed_resolver, _) = &*expansion.borrow();\n+            let crate_name = *self.crate_name()?.borrow();\n             passes::prepare_outputs(\n                 self.session(),\n                 self.compiler,\n@@ -213,12 +226,12 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    pub fn global_ctxt(&'tcx self) -> Result<&Query<QueryContext<'tcx>>> {\n+    pub fn global_ctxt(&'tcx self) -> Result<QueryResult<'_, QueryContext<'tcx>>> {\n         self.global_ctxt.compute(|| {\n-            let crate_name = *self.crate_name()?.peek();\n-            let outputs = self.prepare_outputs()?.take();\n-            let dep_graph = self.dep_graph()?.peek().clone();\n-            let (krate, resolver, lint_store) = self.expansion()?.take();\n+            let crate_name = *self.crate_name()?.borrow();\n+            let outputs = self.prepare_outputs()?.steal();\n+            let dep_graph = self.dep_graph()?.borrow().clone();\n+            let (krate, resolver, lint_store) = self.expansion()?.steal();\n             Ok(passes::create_global_ctxt(\n                 self.compiler,\n                 lint_store,\n@@ -235,9 +248,9 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    pub fn ongoing_codegen(&'tcx self) -> Result<&Query<Box<dyn Any>>> {\n+    pub fn ongoing_codegen(&'tcx self) -> Result<QueryResult<'_, Box<dyn Any>>> {\n         self.ongoing_codegen.compute(|| {\n-            self.global_ctxt()?.peek_mut().enter(|tcx| {\n+            self.global_ctxt()?.enter(|tcx| {\n                 tcx.analysis(()).ok();\n \n                 // Don't do code generation if there were any errors\n@@ -293,12 +306,10 @@ impl<'tcx> Queries<'tcx> {\n         let sess = self.session().clone();\n         let codegen_backend = self.codegen_backend().clone();\n \n-        let dep_graph = self.dep_graph()?.peek().clone();\n-        let (crate_hash, prepare_outputs) = self\n-            .global_ctxt()?\n-            .peek_mut()\n-            .enter(|tcx| (tcx.crate_hash(LOCAL_CRATE), tcx.output_filenames(()).clone()));\n-        let ongoing_codegen = self.ongoing_codegen()?.take();\n+        let (crate_hash, prepare_outputs, dep_graph) = self.global_ctxt()?.enter(|tcx| {\n+            (tcx.crate_hash(LOCAL_CRATE), tcx.output_filenames(()).clone(), tcx.dep_graph.clone())\n+        });\n+        let ongoing_codegen = self.ongoing_codegen()?.steal();\n \n         Ok(Linker {\n             sess,\n@@ -382,6 +393,7 @@ impl Compiler {\n         // NOTE: intentionally does not compute the global context if it hasn't been built yet,\n         // since that likely means there was a parse error.\n         if let Some(Ok(gcx)) = &mut *queries.global_ctxt.result.borrow_mut() {\n+            let gcx = gcx.get_mut();\n             // We assume that no queries are run past here. If there are new queries\n             // after this point, they'll show up as \"<unknown>\" in self-profiling data.\n             {"}, {"sha": "a3b9891ee64e90a5f6c7f323a2d172b6c2b6c403", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -715,7 +715,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(asm_comments, true);\n     tracked!(assume_incomplete_release, true);\n     tracked!(binary_dep_depinfo, true);\n-    tracked!(box_noalias, Some(false));\n+    tracked!(box_noalias, false);\n     tracked!(\n         branch_protection,\n         Some(BranchProtection {\n@@ -754,7 +754,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(mir_enable_passes, vec![(\"DestProp\".to_string(), false)]);\n     tracked!(mir_opt_level, Some(4));\n     tracked!(move_size_limit, Some(4096));\n-    tracked!(mutable_noalias, Some(true));\n+    tracked!(mutable_noalias, false);\n     tracked!(no_generate_arange_section, true);\n     tracked!(no_jump_tables, true);\n     tracked!(no_link, true);"}, {"sha": "6e815863d06ff9e226d6fa1f5bb06fd0152a6e5d", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -2,7 +2,7 @@\n //!\n //! The idea with `rustc_lexer` is to make a reusable library,\n //! by separating out pure lexing and rustc-specific concerns, like spans,\n-//! error reporting, and interning.  So, rustc_lexer operates directly on `&str`,\n+//! error reporting, and interning. So, rustc_lexer operates directly on `&str`,\n //! produces simple tokens which are a pair of type-tag and a bit of original text,\n //! and does not report errors, instead storing them as flags on the token.\n //!"}, {"sha": "8507ca9d89ed776b77228fec41521ab835ce75e3", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -299,7 +299,7 @@ where\n         let tail = &tail[first_non_space..];\n         if let Some(c) = tail.chars().nth(0) {\n             // For error reporting, we would like the span to contain the character that was not\n-            // skipped.  The +1 is necessary to account for the leading \\ that started the escape.\n+            // skipped. The +1 is necessary to account for the leading \\ that started the escape.\n             let end = start + first_non_space + c.len_utf8() + 1;\n             if c.is_whitespace() {\n                 callback(start..end, Err(EscapeError::UnskippedWhitespaceWarning));"}, {"sha": "3593f141df61ba783befdccf739ad5a95948a413", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 16, "deletions": 34, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,5 +1,5 @@\n+use crate::lints::{ArrayIntoIterDiag, ArrayIntoIterDiagSub};\n use crate::{LateContext, LateLintPass, LintContext};\n-use rustc_errors::{fluent, Applicability};\n use rustc_hir as hir;\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n@@ -118,41 +118,23 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n                 // to an array or to a slice.\n                 _ => bug!(\"array type coerced to something other than array or slice\"),\n             };\n-            cx.struct_span_lint(\n+            let sub = if self.for_expr_span == expr.span {\n+                Some(ArrayIntoIterDiagSub::RemoveIntoIter {\n+                    span: receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n+                })\n+            } else if receiver_ty.is_array() {\n+                Some(ArrayIntoIterDiagSub::UseExplicitIntoIter {\n+                    start_span: expr.span.shrink_to_lo(),\n+                    end_span: receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n+                })\n+            } else {\n+                None\n+            };\n+            cx.emit_spanned_lint(\n                 ARRAY_INTO_ITER,\n                 call.ident.span,\n-                fluent::lint_array_into_iter,\n-                |diag| {\n-                    diag.set_arg(\"target\", target);\n-                    diag.span_suggestion(\n-                        call.ident.span,\n-                        fluent::use_iter_suggestion,\n-                        \"iter\",\n-                        Applicability::MachineApplicable,\n-                    );\n-                    if self.for_expr_span == expr.span {\n-                        diag.span_suggestion(\n-                            receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n-                            fluent::remove_into_iter_suggestion,\n-                            \"\",\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else if receiver_ty.is_array() {\n-                        diag.multipart_suggestion(\n-                            fluent::use_explicit_into_iter_suggestion,\n-                            vec![\n-                                (expr.span.shrink_to_lo(), \"IntoIterator::into_iter(\".into()),\n-                                (\n-                                    receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n-                                    \")\".into(),\n-                                ),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    diag\n-                },\n-            )\n+                ArrayIntoIterDiag { target, suggestion: call.ident.span, sub },\n+            );\n         }\n     }\n }"}, {"sha": "6f445426df70e7218c5b1a744a7ca34fdd73e66f", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 251, "deletions": 476, "changes": 727, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -22,6 +22,23 @@\n \n use crate::{\n     errors::BuiltinEllpisisInclusiveRangePatterns,\n+    lints::{\n+        BuiltinAnonymousParams, BuiltinBoxPointers, BuiltinClashingExtern,\n+        BuiltinClashingExternSub, BuiltinConstNoMangle, BuiltinDeprecatedAttrLink,\n+        BuiltinDeprecatedAttrLinkSuggestion, BuiltinDeprecatedAttrUsed, BuiltinDerefNullptr,\n+        BuiltinEllipsisInclusiveRangePatternsLint, BuiltinExplicitOutlives,\n+        BuiltinExplicitOutlivesSuggestion, BuiltinIncompleteFeatures,\n+        BuiltinIncompleteFeaturesHelp, BuiltinIncompleteFeaturesNote, BuiltinKeywordIdents,\n+        BuiltinMissingCopyImpl, BuiltinMissingDebugImpl, BuiltinMissingDoc,\n+        BuiltinMutablesTransmutes, BuiltinNoMangleGeneric, BuiltinNonShorthandFieldPatterns,\n+        BuiltinSpecialModuleNameUsed, BuiltinTrivialBounds, BuiltinTypeAliasGenericBounds,\n+        BuiltinTypeAliasGenericBoundsSuggestion, BuiltinTypeAliasWhereClause,\n+        BuiltinUnexpectedCliConfigName, BuiltinUnexpectedCliConfigValue,\n+        BuiltinUngatedAsyncFnTrackCaller, BuiltinUnnameableTestItems, BuiltinUnpermittedTypeInit,\n+        BuiltinUnpermittedTypeInitSub, BuiltinUnreachablePub, BuiltinUnsafe,\n+        BuiltinUnstableFeatures, BuiltinUnusedDocComment, BuiltinUnusedDocCommentSub,\n+        BuiltinWhileTrue, SuggestChangingAssocTypes,\n+    },\n     types::{transparent_newtype_field, CItemKind},\n     EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n };\n@@ -33,10 +50,7 @@ use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust::{self, expr_to_string};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::{\n-    fluent, Applicability, DelayDm, Diagnostic, DiagnosticBuilder, DiagnosticMessage,\n-    DiagnosticStyledString, MultiSpan,\n-};\n+use rustc_errors::{fluent, Applicability, DecorateLint, MultiSpan};\n use rustc_feature::{deprecated_attributes, AttributeGate, BuiltinAttribute, GateIssue, Stability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -110,25 +124,17 @@ impl EarlyLintPass for WhileTrue {\n             && !cond.span.from_expansion()\n         {\n             let condition_span = e.span.with_hi(cond.span.hi());\n-            cx.struct_span_lint(\n-                            WHILE_TRUE,\n-                            condition_span,\n-                fluent::lint_builtin_while_true,\n-                            |lint| {\n-                    lint.span_suggestion_short(\n-                        condition_span,\n-                        fluent::suggestion,\n-                        format!(\n+            let replace = format!(\n                             \"{}loop\",\n                             label.map_or_else(String::new, |label| format!(\n                                 \"{}: \",\n                                 label.ident,\n                             ))\n-                        ),\n-                        Applicability::MachineApplicable,\n-                    )\n-                },\n-            )\n+                        );\n+            cx.emit_spanned_lint(WHILE_TRUE, condition_span, BuiltinWhileTrue {\n+                suggestion: condition_span,\n+                replace,\n+            });\n         }\n     }\n }\n@@ -164,12 +170,7 @@ impl BoxPointers {\n         for leaf in ty.walk() {\n             if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n                 if leaf_ty.is_box() {\n-                    cx.struct_span_lint(\n-                        BOX_POINTERS,\n-                        span,\n-                        fluent::lint_builtin_box_pointers,\n-                        |lint| lint.set_arg(\"ty\", ty),\n-                    );\n+                    cx.emit_spanned_lint(BOX_POINTERS, span, BuiltinBoxPointers { ty });\n                 }\n             }\n         }\n@@ -267,19 +268,13 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n                     if cx.tcx.find_field_index(ident, &variant)\n                         == Some(cx.typeck_results().field_index(fieldpat.hir_id))\n                     {\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             NON_SHORTHAND_FIELD_PATTERNS,\n                             fieldpat.span,\n-                            fluent::lint_builtin_non_shorthand_field_patterns,\n-                            |lint| {\n-                                let suggested_ident =\n-                                    format!(\"{}{}\", binding_annot.prefix_str(), ident);\n-                                lint.set_arg(\"ident\", ident).span_suggestion(\n-                                    fieldpat.span,\n-                                    fluent::suggestion,\n-                                    suggested_ident,\n-                                    Applicability::MachineApplicable,\n-                                )\n+                            BuiltinNonShorthandFieldPatterns {\n+                                ident,\n+                                suggestion: fieldpat.span,\n+                                prefix: binding_annot.prefix_str(),\n                             },\n                         );\n                     }\n@@ -321,48 +316,21 @@ impl UnsafeCode {\n         &self,\n         cx: &EarlyContext<'_>,\n         span: Span,\n-        msg: impl Into<DiagnosticMessage>,\n-        decorate: impl for<'a, 'b> FnOnce(\n-            &'b mut DiagnosticBuilder<'a, ()>,\n-        ) -> &'b mut DiagnosticBuilder<'a, ()>,\n+        decorate: impl for<'a> DecorateLint<'a, ()>,\n     ) {\n         // This comes from a macro that has `#[allow_internal_unsafe]`.\n         if span.allows_unsafe() {\n             return;\n         }\n \n-        cx.struct_span_lint(UNSAFE_CODE, span, msg, decorate);\n-    }\n-\n-    fn report_overridden_symbol_name(\n-        &self,\n-        cx: &EarlyContext<'_>,\n-        span: Span,\n-        msg: DiagnosticMessage,\n-    ) {\n-        self.report_unsafe(cx, span, msg, |lint| {\n-            lint.note(fluent::lint_builtin_overridden_symbol_name)\n-        })\n-    }\n-\n-    fn report_overridden_symbol_section(\n-        &self,\n-        cx: &EarlyContext<'_>,\n-        span: Span,\n-        msg: DiagnosticMessage,\n-    ) {\n-        self.report_unsafe(cx, span, msg, |lint| {\n-            lint.note(fluent::lint_builtin_overridden_symbol_section)\n-        })\n+        cx.emit_spanned_lint(UNSAFE_CODE, span, decorate);\n     }\n }\n \n impl EarlyLintPass for UnsafeCode {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n         if attr.has_name(sym::allow_internal_unsafe) {\n-            self.report_unsafe(cx, attr.span, fluent::lint_builtin_allow_internal_unsafe, |lint| {\n-                lint\n-            });\n+            self.report_unsafe(cx, attr.span, BuiltinUnsafe::AllowInternalUnsafe);\n         }\n     }\n \n@@ -371,70 +339,46 @@ impl EarlyLintPass for UnsafeCode {\n         if let ast::ExprKind::Block(ref blk, _) = e.kind {\n             // Don't warn about generated blocks; that'll just pollute the output.\n             if blk.rules == ast::BlockCheckMode::Unsafe(ast::UserProvided) {\n-                self.report_unsafe(cx, blk.span, fluent::lint_builtin_unsafe_block, |lint| lint);\n+                self.report_unsafe(cx, blk.span, BuiltinUnsafe::UnsafeBlock);\n             }\n         }\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, it: &ast::Item) {\n         match it.kind {\n             ast::ItemKind::Trait(box ast::Trait { unsafety: ast::Unsafe::Yes(_), .. }) => {\n-                self.report_unsafe(cx, it.span, fluent::lint_builtin_unsafe_trait, |lint| lint)\n+                self.report_unsafe(cx, it.span, BuiltinUnsafe::UnsafeTrait);\n             }\n \n             ast::ItemKind::Impl(box ast::Impl { unsafety: ast::Unsafe::Yes(_), .. }) => {\n-                self.report_unsafe(cx, it.span, fluent::lint_builtin_unsafe_impl, |lint| lint)\n+                self.report_unsafe(cx, it.span, BuiltinUnsafe::UnsafeImpl);\n             }\n \n             ast::ItemKind::Fn(..) => {\n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n-                    self.report_overridden_symbol_name(\n-                        cx,\n-                        attr.span,\n-                        fluent::lint_builtin_no_mangle_fn,\n-                    );\n+                    self.report_unsafe(cx, attr.span, BuiltinUnsafe::NoMangleFn);\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n-                    self.report_overridden_symbol_name(\n-                        cx,\n-                        attr.span,\n-                        fluent::lint_builtin_export_name_fn,\n-                    );\n+                    self.report_unsafe(cx, attr.span, BuiltinUnsafe::ExportNameFn);\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n-                    self.report_overridden_symbol_section(\n-                        cx,\n-                        attr.span,\n-                        fluent::lint_builtin_link_section_fn,\n-                    );\n+                    self.report_unsafe(cx, attr.span, BuiltinUnsafe::LinkSectionFn);\n                 }\n             }\n \n             ast::ItemKind::Static(..) => {\n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n-                    self.report_overridden_symbol_name(\n-                        cx,\n-                        attr.span,\n-                        fluent::lint_builtin_no_mangle_static,\n-                    );\n+                    self.report_unsafe(cx, attr.span, BuiltinUnsafe::NoMangleStatic);\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n-                    self.report_overridden_symbol_name(\n-                        cx,\n-                        attr.span,\n-                        fluent::lint_builtin_export_name_static,\n-                    );\n+                    self.report_unsafe(cx, attr.span, BuiltinUnsafe::ExportNameStatic);\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n-                    self.report_overridden_symbol_section(\n-                        cx,\n-                        attr.span,\n-                        fluent::lint_builtin_link_section_static,\n-                    );\n+                    self.report_unsafe(cx, attr.span, BuiltinUnsafe::LinkSectionStatic);\n                 }\n             }\n \n@@ -445,18 +389,10 @@ impl EarlyLintPass for UnsafeCode {\n     fn check_impl_item(&mut self, cx: &EarlyContext<'_>, it: &ast::AssocItem) {\n         if let ast::AssocItemKind::Fn(..) = it.kind {\n             if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n-                self.report_overridden_symbol_name(\n-                    cx,\n-                    attr.span,\n-                    fluent::lint_builtin_no_mangle_method,\n-                );\n+                self.report_unsafe(cx, attr.span, BuiltinUnsafe::NoMangleMethod);\n             }\n             if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n-                self.report_overridden_symbol_name(\n-                    cx,\n-                    attr.span,\n-                    fluent::lint_builtin_export_name_method,\n-                );\n+                self.report_unsafe(cx, attr.span, BuiltinUnsafe::ExportNameMethod);\n             }\n         }\n     }\n@@ -471,13 +407,13 @@ impl EarlyLintPass for UnsafeCode {\n             body,\n         ) = fk\n         {\n-            let msg = match ctxt {\n+            let decorator = match ctxt {\n                 FnCtxt::Foreign => return,\n-                FnCtxt::Free => fluent::lint_builtin_decl_unsafe_fn,\n-                FnCtxt::Assoc(_) if body.is_none() => fluent::lint_builtin_decl_unsafe_method,\n-                FnCtxt::Assoc(_) => fluent::lint_builtin_impl_unsafe_method,\n+                FnCtxt::Free => BuiltinUnsafe::DeclUnsafeFn,\n+                FnCtxt::Assoc(_) if body.is_none() => BuiltinUnsafe::DeclUnsafeMethod,\n+                FnCtxt::Assoc(_) => BuiltinUnsafe::ImplUnsafeMethod,\n             };\n-            self.report_unsafe(cx, span, msg, |lint| lint);\n+            self.report_unsafe(cx, span, decorator);\n         }\n     }\n }\n@@ -578,11 +514,10 @@ impl MissingDoc {\n         let attrs = cx.tcx.hir().attrs(cx.tcx.hir().local_def_id_to_hir_id(def_id));\n         let has_doc = attrs.iter().any(has_doc);\n         if !has_doc {\n-            cx.struct_span_lint(\n+            cx.emit_spanned_lint(\n                 MISSING_DOCS,\n                 cx.tcx.def_span(def_id),\n-                fluent::lint_builtin_missing_doc,\n-                |lint| lint.set_arg(\"article\", article).set_arg(\"desc\", desc),\n+                BuiltinMissingDoc { article, desc },\n             );\n         }\n     }\n@@ -799,12 +734,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n         )\n         .is_ok()\n         {\n-            cx.struct_span_lint(\n-                MISSING_COPY_IMPLEMENTATIONS,\n-                item.span,\n-                fluent::lint_builtin_missing_copy_impl,\n-                |lint| lint,\n-            )\n+            cx.emit_spanned_lint(MISSING_COPY_IMPLEMENTATIONS, item.span, BuiltinMissingCopyImpl);\n         }\n     }\n }\n@@ -878,11 +808,10 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n         }\n \n         if !self.impling_types.as_ref().unwrap().contains(&item.owner_id.def_id) {\n-            cx.struct_span_lint(\n+            cx.emit_spanned_lint(\n                 MISSING_DEBUG_IMPLEMENTATIONS,\n                 item.span,\n-                fluent::lint_builtin_missing_debug_impl,\n-                |lint| lint.set_arg(\"debug\", cx.tcx.def_path_str(debug)),\n+                BuiltinMissingDebugImpl { tcx: cx.tcx, def_id: debug },\n             );\n         }\n     }\n@@ -958,19 +887,11 @@ impl EarlyLintPass for AnonymousParameters {\n                         } else {\n                             (\"<type>\", Applicability::HasPlaceholders)\n                         };\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             ANONYMOUS_PARAMETERS,\n                             arg.pat.span,\n-                            fluent::lint_builtin_anonymous_params,\n-                            |lint| {\n-                                lint.span_suggestion(\n-                                    arg.pat.span,\n-                                    fluent::suggestion,\n-                                    format!(\"_: {}\", ty_snip),\n-                                    appl,\n-                                )\n-                            },\n-                        )\n+                            BuiltinAnonymousParams { suggestion: (arg.pat.span, appl), ty_snip },\n+                        );\n                     }\n                 }\n             }\n@@ -1005,42 +926,30 @@ impl EarlyLintPass for DeprecatedAttr {\n                     _,\n                 ) = gate\n                 {\n-                    // FIXME(davidtwco) translatable deprecated attr\n-                    cx.struct_span_lint(\n+                    let suggestion = match suggestion {\n+                        Some(msg) => {\n+                            BuiltinDeprecatedAttrLinkSuggestion::Msg { suggestion: attr.span, msg }\n+                        }\n+                        None => {\n+                            BuiltinDeprecatedAttrLinkSuggestion::Default { suggestion: attr.span }\n+                        }\n+                    };\n+                    cx.emit_spanned_lint(\n                         DEPRECATED,\n                         attr.span,\n-                        fluent::lint_builtin_deprecated_attr_link,\n-                        |lint| {\n-                            lint.set_arg(\"name\", name)\n-                                .set_arg(\"reason\", reason)\n-                                .set_arg(\"link\", link)\n-                                .span_suggestion_short(\n-                                    attr.span,\n-                                    suggestion.map(|s| s.into()).unwrap_or(\n-                                        fluent::lint_builtin_deprecated_attr_default_suggestion,\n-                                    ),\n-                                    \"\",\n-                                    Applicability::MachineApplicable,\n-                                )\n-                        },\n+                        BuiltinDeprecatedAttrLink { name, reason, link, suggestion },\n                     );\n                 }\n                 return;\n             }\n         }\n         if attr.has_name(sym::no_start) || attr.has_name(sym::crate_id) {\n-            cx.struct_span_lint(\n+            cx.emit_spanned_lint(\n                 DEPRECATED,\n                 attr.span,\n-                fluent::lint_builtin_deprecated_attr_used,\n-                |lint| {\n-                    lint.set_arg(\"name\", pprust::path_to_string(&attr.get_normal_item().path))\n-                        .span_suggestion_short(\n-                            attr.span,\n-                            fluent::lint_builtin_deprecated_attr_default_suggestion,\n-                            \"\",\n-                            Applicability::MachineApplicable,\n-                        )\n+                BuiltinDeprecatedAttrUsed {\n+                    name: pprust::path_to_string(&attr.get_normal_item().path),\n+                    suggestion: attr.span,\n                 },\n             );\n         }\n@@ -1069,20 +978,18 @@ fn warn_if_doc(cx: &EarlyContext<'_>, node_span: Span, node_kind: &str, attrs: &\n         let span = sugared_span.take().unwrap_or(attr.span);\n \n         if is_doc_comment || attr.has_name(sym::doc) {\n-            cx.struct_span_lint(\n+            let sub = match attr.kind {\n+                AttrKind::DocComment(CommentKind::Line, _) | AttrKind::Normal(..) => {\n+                    BuiltinUnusedDocCommentSub::PlainHelp\n+                }\n+                AttrKind::DocComment(CommentKind::Block, _) => {\n+                    BuiltinUnusedDocCommentSub::BlockHelp\n+                }\n+            };\n+            cx.emit_spanned_lint(\n                 UNUSED_DOC_COMMENTS,\n                 span,\n-                fluent::lint_builtin_unused_doc_comment,\n-                |lint| {\n-                    lint.set_arg(\"kind\", node_kind).span_label(node_span, fluent::label).help(\n-                        match attr.kind {\n-                            AttrKind::DocComment(CommentKind::Line, _) | AttrKind::Normal(..) => {\n-                                fluent::plain_help\n-                            }\n-                            AttrKind::DocComment(CommentKind::Block, _) => fluent::block_help,\n-                        },\n-                    )\n-                },\n+                BuiltinUnusedDocComment { kind: node_kind, label: node_span, sub },\n             );\n         }\n     }\n@@ -1197,20 +1104,10 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                 match param.kind {\n                     GenericParamKind::Lifetime { .. } => {}\n                     GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             NO_MANGLE_GENERIC_ITEMS,\n                             span,\n-                            fluent::lint_builtin_no_mangle_generic,\n-                            |lint| {\n-                                lint.span_suggestion_short(\n-                                    no_mangle_attr.span,\n-                                    fluent::suggestion,\n-                                    \"\",\n-                                    // Use of `#[no_mangle]` suggests FFI intent; correct\n-                                    // fix may be to monomorphize source by hand\n-                                    Applicability::MaybeIncorrect,\n-                                )\n-                            },\n+                            BuiltinNoMangleGeneric { suggestion: no_mangle_attr.span },\n                         );\n                         break;\n                     }\n@@ -1225,30 +1122,23 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n             }\n             hir::ItemKind::Const(..) => {\n                 if cx.sess().contains_name(attrs, sym::no_mangle) {\n+                    // account for \"pub const\" (#45562)\n+                    let start = cx\n+                        .tcx\n+                        .sess\n+                        .source_map()\n+                        .span_to_snippet(it.span)\n+                        .map(|snippet| snippet.find(\"const\").unwrap_or(0))\n+                        .unwrap_or(0) as u32;\n+                    // `const` is 5 chars\n+                    let suggestion = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n+\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         NO_MANGLE_CONST_ITEMS,\n                         it.span,\n-                        fluent::lint_builtin_const_no_mangle,\n-                        |lint| {\n-                            // account for \"pub const\" (#45562)\n-                            let start = cx\n-                                .tcx\n-                                .sess\n-                                .source_map()\n-                                .span_to_snippet(it.span)\n-                                .map(|snippet| snippet.find(\"const\").unwrap_or(0))\n-                                .unwrap_or(0) as u32;\n-                            // `const` is 5 chars\n-                            let const_span = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n-                            lint.span_suggestion(\n-                                const_span,\n-                                fluent::suggestion,\n-                                \"pub static\",\n-                                Applicability::MachineApplicable,\n-                            )\n-                        },\n+                        BuiltinConstNoMangle { suggestion },\n                     );\n                 }\n             }\n@@ -1309,12 +1199,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n             get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (ty1.kind(), ty2.kind()))\n         {\n             if from_mutbl < to_mutbl {\n-                cx.struct_span_lint(\n-                    MUTABLE_TRANSMUTES,\n-                    expr.span,\n-                    fluent::lint_builtin_mutable_transmutes,\n-                    |lint| lint,\n-                );\n+                cx.emit_spanned_lint(MUTABLE_TRANSMUTES, expr.span, BuiltinMutablesTransmutes);\n             }\n         }\n \n@@ -1362,12 +1247,7 @@ impl<'tcx> LateLintPass<'tcx> for UnstableFeatures {\n         if attr.has_name(sym::feature) {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n-                    cx.struct_span_lint(\n-                        UNSTABLE_FEATURES,\n-                        item.span(),\n-                        fluent::lint_builtin_unstable_features,\n-                        |lint| lint,\n-                    );\n+                    cx.emit_spanned_lint(UNSTABLE_FEATURES, item.span(), BuiltinUnstableFeatures);\n                 }\n             }\n         }\n@@ -1422,20 +1302,10 @@ impl<'tcx> LateLintPass<'tcx> for UngatedAsyncFnTrackCaller {\n             // Now, check if the function has the `#[track_caller]` attribute\n             && let Some(attr) = attrs.iter().find(|attr| attr.has_name(sym::track_caller))\n             {\n-                cx.struct_span_lint(\n-                    UNGATED_ASYNC_FN_TRACK_CALLER,\n-                    attr.span,\n-                    fluent::lint_ungated_async_fn_track_caller,\n-                    |lint| {\n-                        lint.span_label(span, fluent::label);\n-                        rustc_session::parse::add_feature_diagnostics(\n-                            lint,\n-                            &cx.tcx.sess.parse_sess,\n-                            sym::closure_track_caller,\n-                        );\n-                        lint\n-                    },\n-                );\n+                cx.emit_spanned_lint(UNGATED_ASYNC_FN_TRACK_CALLER, attr.span, BuiltinUngatedAsyncFnTrackCaller {\n+                    label: span,\n+                    parse_sess: &cx.tcx.sess.parse_sess,\n+                });\n             }\n     }\n }\n@@ -1493,18 +1363,13 @@ impl UnreachablePub {\n                 applicability = Applicability::MaybeIncorrect;\n             }\n             let def_span = cx.tcx.def_span(def_id);\n-            cx.struct_span_lint(\n+            cx.emit_spanned_lint(\n                 UNREACHABLE_PUB,\n                 def_span,\n-                fluent::lint_builtin_unreachable_pub,\n-                |lint| {\n-                    lint.set_arg(\"what\", what);\n-\n-                    lint.span_suggestion(vis_span, fluent::suggestion, \"pub(crate)\", applicability);\n-                    if exportable {\n-                        lint.help(fluent::help);\n-                    }\n-                    lint\n+                BuiltinUnreachablePub {\n+                    what,\n+                    suggestion: (vis_span, applicability),\n+                    help: exportable.then_some(()),\n                 },\n             );\n         }\n@@ -1569,7 +1434,7 @@ declare_lint_pass!(\n );\n \n impl TypeAliasBounds {\n-    fn is_type_variable_assoc(qpath: &hir::QPath<'_>) -> bool {\n+    pub(crate) fn is_type_variable_assoc(qpath: &hir::QPath<'_>) -> bool {\n         match *qpath {\n             hir::QPath::TypeRelative(ref ty, _) => {\n                 // If this is a type variable, we found a `T::Assoc`.\n@@ -1583,29 +1448,6 @@ impl TypeAliasBounds {\n             hir::QPath::Resolved(..) | hir::QPath::LangItem(..) => false,\n         }\n     }\n-\n-    fn suggest_changing_assoc_types(ty: &hir::Ty<'_>, err: &mut Diagnostic) {\n-        // Access to associates types should use `<T as Bound>::Assoc`, which does not need a\n-        // bound.  Let's see if this type does that.\n-\n-        // We use a HIR visitor to walk the type.\n-        use rustc_hir::intravisit::{self, Visitor};\n-        struct WalkAssocTypes<'a> {\n-            err: &'a mut Diagnostic,\n-        }\n-        impl Visitor<'_> for WalkAssocTypes<'_> {\n-            fn visit_qpath(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) {\n-                if TypeAliasBounds::is_type_variable_assoc(qpath) {\n-                    self.err.span_help(span, fluent::lint_builtin_type_alias_bounds_help);\n-                }\n-                intravisit::walk_qpath(self, qpath, id)\n-            }\n-        }\n-\n-        // Let's go for a walk!\n-        let mut visitor = WalkAssocTypes { err };\n-        visitor.visit_ty(ty);\n-    }\n }\n \n impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n@@ -1639,35 +1481,31 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n \n         let mut suggested_changing_assoc_types = false;\n         if !where_spans.is_empty() {\n-            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint_builtin_type_alias_where_clause, |lint| {\n-                lint.set_span(where_spans);\n-                lint.span_suggestion(\n-                    type_alias_generics.where_clause_span,\n-                    fluent::suggestion,\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n-                if !suggested_changing_assoc_types {\n-                    TypeAliasBounds::suggest_changing_assoc_types(ty, lint);\n-                    suggested_changing_assoc_types = true;\n-                }\n-                lint\n+            let sub = (!suggested_changing_assoc_types).then(|| {\n+                suggested_changing_assoc_types = true;\n+                SuggestChangingAssocTypes { ty }\n             });\n+            cx.emit_spanned_lint(\n+                TYPE_ALIAS_BOUNDS,\n+                where_spans,\n+                BuiltinTypeAliasWhereClause {\n+                    suggestion: type_alias_generics.where_clause_span,\n+                    sub,\n+                },\n+            );\n         }\n \n         if !inline_spans.is_empty() {\n-            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint_builtin_type_alias_generic_bounds, |lint| {\n-                lint.set_span(inline_spans);\n-                lint.multipart_suggestion(\n-                    fluent::suggestion,\n-                    inline_sugg,\n-                    Applicability::MachineApplicable,\n-                );\n-                if !suggested_changing_assoc_types {\n-                    TypeAliasBounds::suggest_changing_assoc_types(ty, lint);\n-                }\n-                lint\n+            let suggestion = BuiltinTypeAliasGenericBoundsSuggestion { suggestions: inline_sugg };\n+            let sub = (!suggested_changing_assoc_types).then(|| {\n+                suggested_changing_assoc_types = true;\n+                SuggestChangingAssocTypes { ty }\n             });\n+            cx.emit_spanned_lint(\n+                TYPE_ALIAS_BOUNDS,\n+                inline_spans,\n+                BuiltinTypeAliasGenericBounds { suggestion, sub },\n+            );\n         }\n     }\n }\n@@ -1767,14 +1605,10 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     TypeWellFormedFromEnv(..) => continue,\n                 };\n                 if predicate.is_global() {\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         TRIVIAL_BOUNDS,\n                         span,\n-                        fluent::lint_builtin_trivial_bounds,\n-                        |lint| {\n-                            lint.set_arg(\"predicate_kind_name\", predicate_kind_name)\n-                                .set_arg(\"predicate\", predicate)\n-                        },\n+                        BuiltinTrivialBounds { predicate_kind_name, predicate },\n                     );\n                 }\n             }\n@@ -1875,8 +1709,6 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n         };\n \n         if let Some((start, end, join)) = endpoints {\n-            let msg = fluent::lint_builtin_ellipsis_inclusive_range_patterns;\n-            let suggestion = fluent::suggestion;\n             if parenthesise {\n                 self.node_id = Some(pat.id);\n                 let end = expr_to_string(&end);\n@@ -1891,14 +1723,14 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n                         replace,\n                     });\n                 } else {\n-                    cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, pat.span, msg, |lint| {\n-                        lint.span_suggestion(\n-                            pat.span,\n-                            suggestion,\n+                    cx.emit_spanned_lint(\n+                        ELLIPSIS_INCLUSIVE_RANGE_PATTERNS,\n+                        pat.span,\n+                        BuiltinEllipsisInclusiveRangePatternsLint::Parenthesise {\n+                            suggestion: pat.span,\n                             replace,\n-                            Applicability::MachineApplicable,\n-                        )\n-                    });\n+                        },\n+                    );\n                 }\n             } else {\n                 let replace = \"..=\";\n@@ -1909,14 +1741,13 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n                         replace: replace.to_string(),\n                     });\n                 } else {\n-                    cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, join, msg, |lint| {\n-                        lint.span_suggestion_short(\n-                            join,\n-                            suggestion,\n-                            replace,\n-                            Applicability::MachineApplicable,\n-                        )\n-                    });\n+                    cx.emit_spanned_lint(\n+                        ELLIPSIS_INCLUSIVE_RANGE_PATTERNS,\n+                        join,\n+                        BuiltinEllipsisInclusiveRangePatternsLint::NonParenthesise {\n+                            suggestion: join,\n+                        },\n+                    );\n                 }\n             };\n         }\n@@ -1996,12 +1827,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n \n         let attrs = cx.tcx.hir().attrs(it.hir_id());\n         if let Some(attr) = cx.sess().find_by_name(attrs, sym::rustc_test_marker) {\n-            cx.struct_span_lint(\n-                UNNAMEABLE_TEST_ITEMS,\n-                attr.span,\n-                fluent::lint_builtin_unnameable_test_items,\n-                |lint| lint,\n-            );\n+            cx.emit_spanned_lint(UNNAMEABLE_TEST_ITEMS, attr.span, BuiltinUnnameableTestItems);\n         }\n     }\n \n@@ -2117,18 +1943,10 @@ impl KeywordIdents {\n             return;\n         }\n \n-        cx.struct_span_lint(\n+        cx.emit_spanned_lint(\n             KEYWORD_IDENTS,\n             ident.span,\n-            fluent::lint_builtin_keyword_idents,\n-            |lint| {\n-                lint.set_arg(\"kw\", ident).set_arg(\"next\", next_edition).span_suggestion(\n-                    ident.span,\n-                    fluent::suggestion,\n-                    format!(\"r#{}\", ident),\n-                    Applicability::MachineApplicable,\n-                )\n-            },\n+            BuiltinKeywordIdents { kw: ident, next: next_edition, suggestion: ident.span },\n         );\n     }\n }\n@@ -2405,16 +2223,15 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                     Applicability::MaybeIncorrect\n                 };\n \n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     EXPLICIT_OUTLIVES_REQUIREMENTS,\n                     lint_spans.clone(),\n-                    fluent::lint_builtin_explicit_outlives,\n-                    |lint| {\n-                        lint.set_arg(\"count\", bound_count).multipart_suggestion(\n-                            fluent::suggestion,\n-                            lint_spans.into_iter().map(|span| (span, String::new())).collect(),\n+                    BuiltinExplicitOutlives {\n+                        count: bound_count,\n+                        suggestion: BuiltinExplicitOutlivesSuggestion {\n+                            spans: lint_spans,\n                             applicability,\n-                        )\n+                        },\n                     },\n                 );\n             }\n@@ -2463,24 +2280,18 @@ impl EarlyLintPass for IncompleteFeatures {\n             .chain(features.declared_lib_features.iter().map(|(name, span)| (name, span)))\n             .filter(|(&name, _)| features.incomplete(name))\n             .for_each(|(&name, &span)| {\n-                cx.struct_span_lint(\n+                let note = rustc_feature::find_feature_issue(name, GateIssue::Language)\n+                    .map(|n| BuiltinIncompleteFeaturesNote { n });\n+                let help = if HAS_MIN_FEATURES.contains(&name) {\n+                    Some(BuiltinIncompleteFeaturesHelp)\n+                } else {\n+                    None\n+                };\n+                cx.emit_spanned_lint(\n                     INCOMPLETE_FEATURES,\n                     span,\n-                    fluent::lint_builtin_incomplete_features,\n-                    |lint| {\n-                        lint.set_arg(\"name\", name);\n-                        if let Some(n) =\n-                            rustc_feature::find_feature_issue(name, GateIssue::Language)\n-                        {\n-                            lint.set_arg(\"n\", n);\n-                            lint.note(fluent::note);\n-                        }\n-                        if HAS_MIN_FEATURES.contains(&name) {\n-                            lint.help(fluent::help);\n-                        }\n-                        lint\n-                    },\n-                )\n+                    BuiltinIncompleteFeatures { name, note, help },\n+                );\n             });\n     }\n }\n@@ -2525,6 +2336,36 @@ declare_lint! {\n \n declare_lint_pass!(InvalidValue => [INVALID_VALUE]);\n \n+/// Information about why a type cannot be initialized this way.\n+pub struct InitError {\n+    pub(crate) message: String,\n+    /// Spans from struct fields and similar that can be obtained from just the type.\n+    pub(crate) span: Option<Span>,\n+    /// Used to report a trace through adts.\n+    pub(crate) nested: Option<Box<InitError>>,\n+}\n+impl InitError {\n+    fn spanned(self, span: Span) -> InitError {\n+        Self { span: Some(span), ..self }\n+    }\n+\n+    fn nested(self, nested: impl Into<Option<InitError>>) -> InitError {\n+        assert!(self.nested.is_none());\n+        Self { nested: nested.into().map(Box::new), ..self }\n+    }\n+}\n+\n+impl<'a> From<&'a str> for InitError {\n+    fn from(s: &'a str) -> Self {\n+        s.to_owned().into()\n+    }\n+}\n+impl From<String> for InitError {\n+    fn from(message: String) -> Self {\n+        Self { message, span: None, nested: None }\n+    }\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) {\n         #[derive(Debug, Copy, Clone, PartialEq)]\n@@ -2533,36 +2374,6 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             Uninit,\n         }\n \n-        /// Information about why a type cannot be initialized this way.\n-        struct InitError {\n-            message: String,\n-            /// Spans from struct fields and similar that can be obtained from just the type.\n-            span: Option<Span>,\n-            /// Used to report a trace through adts.\n-            nested: Option<Box<InitError>>,\n-        }\n-        impl InitError {\n-            fn spanned(self, span: Span) -> InitError {\n-                Self { span: Some(span), ..self }\n-            }\n-\n-            fn nested(self, nested: impl Into<Option<InitError>>) -> InitError {\n-                assert!(self.nested.is_none());\n-                Self { nested: nested.into().map(Box::new), ..self }\n-            }\n-        }\n-\n-        impl<'a> From<&'a str> for InitError {\n-            fn from(s: &'a str) -> Self {\n-                s.to_owned().into()\n-            }\n-        }\n-        impl From<String> for InitError {\n-            fn from(message: String) -> Self {\n-                Self { message, span: None, nested: None }\n-            }\n-        }\n-\n         /// Test if this constant is all-0.\n         fn is_zero(expr: &hir::Expr<'_>) -> bool {\n             use hir::ExprKind::*;\n@@ -2786,46 +2597,16 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             // using zeroed or uninitialized memory.\n             // We are extremely conservative with what we warn about.\n             let conjured_ty = cx.typeck_results().expr_ty(expr);\n-            if let Some(mut err) = with_no_trimmed_paths!(ty_find_init_error(cx, conjured_ty, init))\n-            {\n-                // FIXME(davidtwco): make translatable\n-                cx.struct_span_lint(\n+            if let Some(err) = with_no_trimmed_paths!(ty_find_init_error(cx, conjured_ty, init)) {\n+                let msg = match init {\n+                    InitKind::Zeroed => fluent::lint_builtin_unpermitted_type_init_zeroed,\n+                    InitKind::Uninit => fluent::lint_builtin_unpermitted_type_init_unint,\n+                };\n+                let sub = BuiltinUnpermittedTypeInitSub { err };\n+                cx.emit_spanned_lint(\n                     INVALID_VALUE,\n                     expr.span,\n-                    DelayDm(|| {\n-                        format!(\n-                            \"the type `{}` does not permit {}\",\n-                            conjured_ty,\n-                            match init {\n-                                InitKind::Zeroed => \"zero-initialization\",\n-                                InitKind::Uninit => \"being left uninitialized\",\n-                            },\n-                        )\n-                    }),\n-                    |lint| {\n-                        lint.span_label(\n-                            expr.span,\n-                            \"this code causes undefined behavior when executed\",\n-                        );\n-                        lint.span_label(\n-                            expr.span,\n-                            \"help: use `MaybeUninit<T>` instead, \\\n-                            and only call `assume_init` after initialization is done\",\n-                        );\n-                        loop {\n-                            if let Some(span) = err.span {\n-                                lint.span_note(span, &err.message);\n-                            } else {\n-                                lint.note(&err.message);\n-                            }\n-                            if let Some(e) = err.nested {\n-                                err = *e;\n-                            } else {\n-                                break;\n-                            }\n-                        }\n-                        lint\n-                    },\n+                    BuiltinUnpermittedTypeInit { msg, ty: conjured_ty, label: expr.span, sub },\n                 );\n             }\n         }\n@@ -3171,31 +2952,39 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n                             SymbolName::Normal(_) => fi.span,\n                             SymbolName::Link(_, annot_span) => fi.span.to(annot_span),\n                         };\n-                    // Finally, emit the diagnostic.\n \n-                    let msg = if orig.get_name() == this_fi.ident.name {\n-                        fluent::lint_builtin_clashing_extern_same_name\n+                    // Finally, emit the diagnostic.\n+                    let this = this_fi.ident.name;\n+                    let orig = orig.get_name();\n+                    let previous_decl_label = get_relevant_span(orig_fi);\n+                    let mismatch_label = get_relevant_span(this_fi);\n+                    let sub = BuiltinClashingExternSub {\n+                        tcx,\n+                        expected: existing_decl_ty,\n+                        found: this_decl_ty,\n+                    };\n+                    let decorator = if orig == this {\n+                        BuiltinClashingExtern::SameName {\n+                            this,\n+                            orig,\n+                            previous_decl_label,\n+                            mismatch_label,\n+                            sub,\n+                        }\n                     } else {\n-                        fluent::lint_builtin_clashing_extern_diff_name\n+                        BuiltinClashingExtern::DiffName {\n+                            this,\n+                            orig,\n+                            previous_decl_label,\n+                            mismatch_label,\n+                            sub,\n+                        }\n                     };\n-                    tcx.struct_span_lint_hir(\n+                    tcx.emit_spanned_lint(\n                         CLASHING_EXTERN_DECLARATIONS,\n                         this_fi.hir_id(),\n                         get_relevant_span(this_fi),\n-                        msg,\n-                        |lint| {\n-                            let mut expected_str = DiagnosticStyledString::new();\n-                            expected_str.push(existing_decl_ty.fn_sig(tcx).to_string(), false);\n-                            let mut found_str = DiagnosticStyledString::new();\n-                            found_str.push(this_decl_ty.fn_sig(tcx).to_string(), true);\n-\n-                            lint.set_arg(\"this_fi\", this_fi.ident.name)\n-                                .set_arg(\"orig\", orig.get_name())\n-                                .span_label(get_relevant_span(orig_fi), fluent::previous_decl_label)\n-                                .span_label(get_relevant_span(this_fi), fluent::mismatch_label)\n-                                // FIXME(davidtwco): translatable expected/found\n-                                .note_expected_found(&\"\", expected_str, &\"\", found_str)\n-                        },\n+                        decorator,\n                     );\n                 }\n             }\n@@ -3275,11 +3064,10 @@ impl<'tcx> LateLintPass<'tcx> for DerefNullPtr {\n \n         if let rustc_hir::ExprKind::Unary(rustc_hir::UnOp::Deref, expr_deref) = expr.kind {\n             if is_null_ptr(cx, expr_deref) {\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     DEREF_NULLPTR,\n                     expr.span,\n-                    fluent::lint_builtin_deref_nullptr,\n-                    |lint| lint.span_label(expr.span, fluent::label),\n+                    BuiltinDerefNullptr { label: expr.span },\n                 );\n             }\n         }\n@@ -3324,6 +3112,7 @@ declare_lint! {\n declare_lint_pass!(NamedAsmLabels => [NAMED_ASM_LABELS]);\n \n impl<'tcx> LateLintPass<'tcx> for NamedAsmLabels {\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n         if let hir::Expr {\n             kind: hir::ExprKind::InlineAsm(hir::InlineAsm { template_strs, .. }),\n@@ -3464,16 +3253,17 @@ impl EarlyLintPass for SpecialModuleName {\n                 }\n \n                 match item.ident.name.as_str() {\n-                    \"lib\" => cx.struct_span_lint(SPECIAL_MODULE_NAME, item.span, \"found module declaration for lib.rs\", |lint| {\n-                        lint\n-                            .note(\"lib.rs is the root of this crate's library target\")\n-                            .help(\"to refer to it from other targets, use the library's name as the path\")\n-                    }),\n-                    \"main\" => cx.struct_span_lint(SPECIAL_MODULE_NAME, item.span, \"found module declaration for main.rs\", |lint| {\n-                        lint\n-                            .note(\"a binary crate cannot be used as library\")\n-                    }),\n-                    _ => continue\n+                    \"lib\" => cx.emit_spanned_lint(\n+                        SPECIAL_MODULE_NAME,\n+                        item.span,\n+                        BuiltinSpecialModuleNameUsed::Lib,\n+                    ),\n+                    \"main\" => cx.emit_spanned_lint(\n+                        SPECIAL_MODULE_NAME,\n+                        item.span,\n+                        BuiltinSpecialModuleNameUsed::Main,\n+                    ),\n+                    _ => continue,\n                 }\n             }\n         }\n@@ -3489,31 +3279,16 @@ impl EarlyLintPass for UnexpectedCfgs {\n         let cfg = &cx.sess().parse_sess.config;\n         let check_cfg = &cx.sess().parse_sess.check_config;\n         for &(name, value) in cfg {\n-            if let Some(names_valid) = &check_cfg.names_valid {\n-                if !names_valid.contains(&name) {\n-                    cx.lookup(\n-                        UNEXPECTED_CFGS,\n-                        None::<MultiSpan>,\n-                        fluent::lint_builtin_unexpected_cli_config_name,\n-                        |diag| diag.help(fluent::help).set_arg(\"name\", name),\n-                    );\n-                }\n+            if let Some(names_valid) = &check_cfg.names_valid && !names_valid.contains(&name){\n+                cx.emit_lint(UNEXPECTED_CFGS, BuiltinUnexpectedCliConfigName {\n+                    name,\n+                });\n             }\n-            if let Some(value) = value {\n-                if let Some(values) = &check_cfg.values_valid.get(&name) {\n-                    if !values.contains(&value) {\n-                        cx.lookup(\n-                            UNEXPECTED_CFGS,\n-                            None::<MultiSpan>,\n-                            fluent::lint_builtin_unexpected_cli_config_value,\n-                            |diag| {\n-                                diag.help(fluent::help)\n-                                    .set_arg(\"name\", name)\n-                                    .set_arg(\"value\", value)\n-                            },\n-                        );\n-                    }\n-                }\n+            if let Some(value) = value && let Some(values) = check_cfg.values_valid.get(&name) && !values.contains(&value) {\n+                cx.emit_lint(\n+                    UNEXPECTED_CFGS,\n+                    BuiltinUnexpectedCliConfigValue { name, value },\n+                );\n             }\n         }\n     }"}, {"sha": "c9b9a62257148c51a8614717ade5d77b03cf30d1", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -965,6 +965,7 @@ pub trait LintContext: Sized {\n     /// Note that this function should only be called for [`LintExpectationId`]s\n     /// retrieved from the current lint pass. Buffered or manually created ids can\n     /// cause ICEs.\n+    #[rustc_lint_diagnostics]\n     fn fulfill_expectation(&self, expectation: LintExpectationId) {\n         // We need to make sure that submitted expectation ids are correctly fulfilled suppressed\n         // and stored between compilation sessions. To not manually do these steps, we simply create\n@@ -1011,6 +1012,7 @@ impl<'tcx> LintContext for LateContext<'tcx> {\n         &*self.lint_store\n     }\n \n+    #[rustc_lint_diagnostics]\n     fn lookup<S: Into<MultiSpan>>(\n         &self,\n         lint: &'static Lint,\n@@ -1045,6 +1047,7 @@ impl LintContext for EarlyContext<'_> {\n         self.builder.lint_store()\n     }\n \n+    #[rustc_lint_diagnostics]\n     fn lookup<S: Into<MultiSpan>>(\n         &self,\n         lint: &'static Lint,"}, {"sha": "dff5a645c175ecf11c0d30de5917caa78148f659", "filename": "compiler/rustc_lint/src/deref_into_dyn_supertrait.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fderef_into_dyn_supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fderef_into_dyn_supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fderef_into_dyn_supertrait.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,6 +1,8 @@\n-use crate::{LateContext, LateLintPass, LintContext};\n+use crate::{\n+    lints::{SupertraitAsDerefTarget, SupertraitAsDerefTargetLabel},\n+    LateContext, LateLintPass, LintContext,\n+};\n \n-use rustc_errors::DelayDm;\n use rustc_hir as hir;\n use rustc_middle::{traits::util::supertraits, ty};\n use rustc_span::sym;\n@@ -71,22 +73,14 @@ impl<'tcx> LateLintPass<'tcx> for DerefIntoDynSupertrait {\n             && supertraits(cx.tcx, t_principal.with_self_ty(cx.tcx, cx.tcx.types.trait_object_dummy_self))\n                 .any(|sup| sup.map_bound(|x| ty::ExistentialTraitRef::erase_self_ty(cx.tcx, x)) == target_principal)\n         {\n-            cx.struct_span_lint(\n-                DEREF_INTO_DYN_SUPERTRAIT,\n-                cx.tcx.def_span(item.owner_id.def_id),\n-                DelayDm(|| {\n-                    format!(\n-                        \"`{t}` implements `Deref` with supertrait `{target_principal}` as target\"\n-                    )\n-                }),\n-                |lint| {\n-                    if let Some(target_span) = impl_.items.iter().find_map(|i| (i.ident.name == sym::Target).then_some(i.span)) {\n-                        lint.span_label(target_span, \"target type is set here\");\n-                    }\n-\n-                    lint\n-                },\n-            )\n+            let label = impl_.items.iter().find_map(|i| (i.ident.name == sym::Target).then_some(i.span)).map(|label| SupertraitAsDerefTargetLabel {\n+                label,\n+            });\n+            cx.emit_spanned_lint(DEREF_INTO_DYN_SUPERTRAIT, cx.tcx.def_span(item.owner_id.def_id), SupertraitAsDerefTarget {\n+                t,\n+                target_principal: target_principal.to_string(),\n+                label,\n+            });\n         }\n     }\n }"}, {"sha": "f9b2df49592244fa701928bfbe71eeac0357df41", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -19,6 +19,7 @@ use crate::passes::{EarlyLintPass, EarlyLintPassObject};\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self as ast_visit, Visitor};\n use rustc_ast::{self as ast, walk_list, HasAttrs};\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_middle::ty::RegisteredTools;\n use rustc_session::lint::{BufferedEarlyLint, LintBuffer, LintPass};\n use rustc_session::Session;\n@@ -39,6 +40,7 @@ pub struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n     // This always-inlined function is for the hot call site.\n     #[inline(always)]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     fn inlined_check_id(&mut self, id: ast::NodeId) {\n         for early_lint in self.context.buffered.take(id) {\n             let BufferedEarlyLint { span, msg, node_id: _, lint_id, diagnostic } = early_lint;\n@@ -71,7 +73,7 @@ impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n         self.inlined_check_id(id);\n         debug!(\"early context: enter_attrs({:?})\", attrs);\n         lint_callback!(self, enter_lint_attrs, attrs);\n-        f(self);\n+        ensure_sufficient_stack(|| f(self));\n         debug!(\"early context: exit_attrs({:?})\", attrs);\n         lint_callback!(self, exit_lint_attrs, attrs);\n         self.context.builder.pop(push);"}, {"sha": "73bd4173270baf86c56f6aa3548368ab1d15e7a3", "filename": "compiler/rustc_lint/src/enum_intrinsics_non_enums.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,5 +1,8 @@\n-use crate::{context::LintContext, LateContext, LateLintPass};\n-use rustc_errors::fluent;\n+use crate::{\n+    context::LintContext,\n+    lints::{EnumIntrinsicsMemDiscriminate, EnumIntrinsicsMemVariant},\n+    LateContext, LateLintPass,\n+};\n use rustc_hir as hir;\n use rustc_middle::ty::{visit::TypeVisitable, Ty};\n use rustc_span::{symbol::sym, Span};\n@@ -50,23 +53,21 @@ fn enforce_mem_discriminant(\n ) {\n     let ty_param = cx.typeck_results().node_substs(func_expr.hir_id).type_at(0);\n     if is_non_enum(ty_param) {\n-        cx.struct_span_lint(\n+        cx.emit_spanned_lint(\n             ENUM_INTRINSICS_NON_ENUMS,\n             expr_span,\n-            fluent::lint_enum_intrinsics_mem_discriminant,\n-            |lint| lint.set_arg(\"ty_param\", ty_param).span_note(args_span, fluent::note),\n+            EnumIntrinsicsMemDiscriminate { ty_param, note: args_span },\n         );\n     }\n }\n \n fn enforce_mem_variant_count(cx: &LateContext<'_>, func_expr: &hir::Expr<'_>, span: Span) {\n     let ty_param = cx.typeck_results().node_substs(func_expr.hir_id).type_at(0);\n     if is_non_enum(ty_param) {\n-        cx.struct_span_lint(\n+        cx.emit_spanned_lint(\n             ENUM_INTRINSICS_NON_ENUMS,\n             span,\n-            fluent::lint_enum_intrinsics_mem_variant,\n-            |lint| lint.set_arg(\"ty_param\", ty_param).note(fluent::note),\n+            EnumIntrinsicsMemVariant { ty_param },\n         );\n     }\n }"}, {"sha": "f3ae26091863d964f7c9f827153d9f202f153cc7", "filename": "compiler/rustc_lint/src/errors.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -8,12 +8,12 @@ use rustc_span::{Span, Symbol};\n \n #[derive(Diagnostic)]\n #[diag(lint_overruled_attribute, code = \"E0453\")]\n-pub struct OverruledAttribute {\n+pub struct OverruledAttribute<'a> {\n     #[primary_span]\n     pub span: Span,\n     #[label]\n     pub overruled: Span,\n-    pub lint_level: String,\n+    pub lint_level: &'a str,\n     pub lint_source: Symbol,\n     #[subdiagnostic]\n     pub sub: OverruledAttributeSub,\n@@ -38,6 +38,7 @@ impl AddToDiagnostic for OverruledAttributeSub {\n             OverruledAttributeSub::NodeSource { span, reason } => {\n                 diag.span_label(span, fluent::lint_node_source);\n                 if let Some(rationale) = reason {\n+                    #[allow(rustc::untranslatable_diagnostic)]\n                     diag.note(rationale.as_str());\n                 }\n             }"}, {"sha": "70c999811a52b297c9363298f75f389e8cff68b8", "filename": "compiler/rustc_lint/src/expect.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,8 +1,7 @@\n-use crate::builtin;\n-use rustc_errors::fluent;\n-use rustc_hir::HirId;\n+use crate::lints::{Expectation, ExpectationNote};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::{lint::LintExpectation, ty::TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::lint::builtin::UNFULFILLED_LINT_EXPECTATIONS;\n use rustc_session::lint::LintExpectationId;\n use rustc_span::symbol::sym;\n use rustc_span::Symbol;\n@@ -28,34 +27,17 @@ fn check_expectations(tcx: TyCtxt<'_>, tool_filter: Option<Symbol>) {\n             if !fulfilled_expectations.contains(&id)\n                 && tool_filter.map_or(true, |filter| expectation.lint_tool == Some(filter))\n             {\n-                emit_unfulfilled_expectation_lint(tcx, *hir_id, expectation);\n+                let rationale = expectation.reason.map(|rationale| ExpectationNote { rationale });\n+                let note = expectation.is_unfulfilled_lint_expectations.then_some(());\n+                tcx.emit_spanned_lint(\n+                    UNFULFILLED_LINT_EXPECTATIONS,\n+                    *hir_id,\n+                    expectation.emission_span,\n+                    Expectation { rationale, note },\n+                );\n             }\n         } else {\n             unreachable!(\"at this stage all `LintExpectationId`s are stable\");\n         }\n     }\n }\n-\n-fn emit_unfulfilled_expectation_lint(\n-    tcx: TyCtxt<'_>,\n-    hir_id: HirId,\n-    expectation: &LintExpectation,\n-) {\n-    tcx.struct_span_lint_hir(\n-        builtin::UNFULFILLED_LINT_EXPECTATIONS,\n-        hir_id,\n-        expectation.emission_span,\n-        fluent::lint_expectation,\n-        |lint| {\n-            if let Some(rationale) = expectation.reason {\n-                lint.note(rationale.as_str());\n-            }\n-\n-            if expectation.is_unfulfilled_lint_expectations {\n-                lint.note(fluent::note);\n-            }\n-\n-            lint\n-        },\n-    );\n-}"}, {"sha": "5219992ee94f0a76e4590bb0bebbe5508c029140", "filename": "compiler/rustc_lint/src/for_loops_over_fallibles.rs", "status": "modified", "additions": 27, "deletions": 46, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,7 +1,12 @@\n-use crate::{LateContext, LateLintPass, LintContext};\n+use crate::{\n+    lints::{\n+        ForLoopsOverFalliblesDiag, ForLoopsOverFalliblesLoopSub, ForLoopsOverFalliblesQuestionMark,\n+        ForLoopsOverFalliblesSuggestion,\n+    },\n+    LateContext, LateLintPass, LintContext,\n+};\n \n use hir::{Expr, Pat};\n-use rustc_errors::{Applicability, DelayDm};\n use rustc_hir as hir;\n use rustc_infer::{infer::TyCtxtInferExt, traits::ObligationCause};\n use rustc_middle::ty::{self, List};\n@@ -53,53 +58,29 @@ impl<'tcx> LateLintPass<'tcx> for ForLoopsOverFallibles {\n             _ => return,\n         };\n \n-        let msg = DelayDm(|| {\n-            format!(\n-                \"for loop over {article} `{ty}`. This is more readably written as an `if let` statement\",\n-            )\n-        });\n-\n-        cx.struct_span_lint(FOR_LOOPS_OVER_FALLIBLES, arg.span, msg, |lint| {\n-            if let Some(recv) = extract_iterator_next_call(cx, arg)\n+        let sub =  if let Some(recv) = extract_iterator_next_call(cx, arg)\n             && let Ok(recv_snip) = cx.sess().source_map().span_to_snippet(recv.span)\n             {\n-                lint.span_suggestion(\n-                    recv.span.between(arg.span.shrink_to_hi()),\n-                    format!(\"to iterate over `{recv_snip}` remove the call to `next`\"),\n-                    \".by_ref()\",\n-                    Applicability::MaybeIncorrect\n-                );\n+                ForLoopsOverFalliblesLoopSub::RemoveNext { suggestion: recv.span.between(arg.span.shrink_to_hi()), recv_snip }\n             } else {\n-                lint.multipart_suggestion_verbose(\n-                    \"to check pattern in a loop use `while let`\",\n-                    vec![\n-                        // NB can't use `until` here because `expr.span` and `pat.span` have different syntax contexts\n-                        (expr.span.with_hi(pat.span.lo()), format!(\"while let {var}(\")),\n-                        (pat.span.between(arg.span), \") = \".to_string()),\n-                    ],\n-                    Applicability::MaybeIncorrect\n-                );\n-            }\n-\n-            if suggest_question_mark(cx, adt, substs, expr.span) {\n-                lint.span_suggestion(\n-                    arg.span.shrink_to_hi(),\n-                    \"consider unwrapping the `Result` with `?` to iterate over its contents\",\n-                    \"?\",\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-\n-            lint.multipart_suggestion_verbose(\n-                \"consider using `if let` to clear intent\",\n-                vec![\n-                    // NB can't use `until` here because `expr.span` and `pat.span` have different syntax contexts\n-                    (expr.span.with_hi(pat.span.lo()), format!(\"if let {var}(\")),\n-                    (pat.span.between(arg.span), \") = \".to_string()),\n-                ],\n-                Applicability::MaybeIncorrect,\n-            )\n-        })\n+                ForLoopsOverFalliblesLoopSub::UseWhileLet { start_span: expr.span.with_hi(pat.span.lo()), end_span: pat.span.between(arg.span), var }\n+            } ;\n+        let question_mark = if suggest_question_mark(cx, adt, substs, expr.span) {\n+            Some(ForLoopsOverFalliblesQuestionMark { suggestion: arg.span.shrink_to_hi() })\n+        } else {\n+            None\n+        };\n+        let suggestion = ForLoopsOverFalliblesSuggestion {\n+            var,\n+            start_span: expr.span.with_hi(pat.span.lo()),\n+            end_span: pat.span.between(arg.span),\n+        };\n+\n+        cx.emit_spanned_lint(\n+            FOR_LOOPS_OVER_FALLIBLES,\n+            arg.span,\n+            ForLoopsOverFalliblesDiag { article, ty, sub, question_mark, suggestion },\n+        );\n     }\n }\n "}, {"sha": "7c1af6bee1dd6e3835ece76b689baaeb082136a0", "filename": "compiler/rustc_lint/src/hidden_unicode_codepoints.rs", "status": "modified", "additions": 18, "deletions": 49, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,7 +1,12 @@\n-use crate::{EarlyContext, EarlyLintPass, LintContext};\n+use crate::{\n+    lints::{\n+        HiddenUnicodeCodepointsDiag, HiddenUnicodeCodepointsDiagLabels,\n+        HiddenUnicodeCodepointsDiagSub,\n+    },\n+    EarlyContext, EarlyLintPass, LintContext,\n+};\n use ast::util::unicode::{contains_text_flow_control_chars, TEXT_FLOW_CONTROL_CHARS};\n use rustc_ast as ast;\n-use rustc_errors::{fluent, Applicability, SuggestionStyle};\n use rustc_span::{BytePos, Span, Symbol};\n \n declare_lint! {\n@@ -60,55 +65,19 @@ impl HiddenUnicodeCodepoints {\n             })\n             .collect();\n \n-        cx.struct_span_lint(\n+        let count = spans.len();\n+        let labels = point_at_inner_spans\n+            .then_some(HiddenUnicodeCodepointsDiagLabels { spans: spans.clone() });\n+        let sub = if point_at_inner_spans && !spans.is_empty() {\n+            HiddenUnicodeCodepointsDiagSub::Escape { spans }\n+        } else {\n+            HiddenUnicodeCodepointsDiagSub::NoEscape { spans }\n+        };\n+\n+        cx.emit_spanned_lint(\n             TEXT_DIRECTION_CODEPOINT_IN_LITERAL,\n             span,\n-            fluent::lint_hidden_unicode_codepoints,\n-            |lint| {\n-                lint.set_arg(\"label\", label);\n-                lint.set_arg(\"count\", spans.len());\n-                lint.span_label(span, fluent::label);\n-                lint.note(fluent::note);\n-                if point_at_inner_spans {\n-                    for (c, span) in &spans {\n-                        lint.span_label(*span, format!(\"{:?}\", c));\n-                    }\n-                }\n-                if point_at_inner_spans && !spans.is_empty() {\n-                    lint.multipart_suggestion_with_style(\n-                        fluent::suggestion_remove,\n-                        spans.iter().map(|(_, span)| (*span, \"\".to_string())).collect(),\n-                        Applicability::MachineApplicable,\n-                        SuggestionStyle::HideCodeAlways,\n-                    );\n-                    lint.multipart_suggestion(\n-                        fluent::suggestion_escape,\n-                        spans\n-                            .into_iter()\n-                            .map(|(c, span)| {\n-                                let c = format!(\"{:?}\", c);\n-                                (span, c[1..c.len() - 1].to_string())\n-                            })\n-                            .collect(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    // FIXME: in other suggestions we've reversed the inner spans of doc comments. We\n-                    // should do the same here to provide the same good suggestions as we do for\n-                    // literals above.\n-                    lint.set_arg(\n-                        \"escaped\",\n-                        spans\n-                            .into_iter()\n-                            .map(|(c, _)| format!(\"{:?}\", c))\n-                            .collect::<Vec<String>>()\n-                            .join(\", \"),\n-                    );\n-                    lint.note(fluent::suggestion_remove);\n-                    lint.note(fluent::no_suggestion_note_escape);\n-                }\n-                lint\n-            },\n+            HiddenUnicodeCodepointsDiag { label, count, span_label: span, labels, sub },\n         );\n     }\n }"}, {"sha": "5eb54cc0034279392c1eac3a4cdf8ad6b7d78b80", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 33, "deletions": 76, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,9 +1,12 @@\n //! Some lints that are only useful in the compiler or crates that use compiler internals, such as\n //! Clippy.\n \n+use crate::lints::{\n+    BadOptAccessDiag, DefaultHashTypesDiag, DiagOutOfImpl, LintPassByHand, NonExistantDocKeyword,\n+    QueryInstability, TyQualified, TykindDiag, TykindKind, UntranslatableDiag,\n+};\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n-use rustc_errors::{fluent, Applicability};\n use rustc_hir::def::Res;\n use rustc_hir::{def_id::DefId, Expr, ExprKind, GenericArg, PatKind, Path, PathSegment, QPath};\n use rustc_hir::{HirId, Impl, Item, ItemKind, Node, Pat, Ty, TyKind};\n@@ -29,20 +32,15 @@ impl LateLintPass<'_> for DefaultHashTypes {\n             // don't lint imports, only actual usages\n             return;\n         }\n-        let replace = match cx.tcx.get_diagnostic_name(def_id) {\n+        let preferred = match cx.tcx.get_diagnostic_name(def_id) {\n             Some(sym::HashMap) => \"FxHashMap\",\n             Some(sym::HashSet) => \"FxHashSet\",\n             _ => return,\n         };\n-        cx.struct_span_lint(\n+        cx.emit_spanned_lint(\n             DEFAULT_HASH_TYPES,\n             path.span,\n-            fluent::lint_default_hash_types,\n-            |lint| {\n-                lint.set_arg(\"preferred\", replace)\n-                    .set_arg(\"used\", cx.tcx.item_name(def_id))\n-                    .note(fluent::note)\n-            },\n+            DefaultHashTypesDiag { preferred, used: cx.tcx.item_name(def_id) },\n         );\n     }\n }\n@@ -83,12 +81,11 @@ impl LateLintPass<'_> for QueryStability {\n         if let Ok(Some(instance)) = ty::Instance::resolve(cx.tcx, cx.param_env, def_id, substs) {\n             let def_id = instance.def_id();\n             if cx.tcx.has_attr(def_id, sym::rustc_lint_query_instability) {\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     POTENTIAL_QUERY_INSTABILITY,\n                     span,\n-                    fluent::lint_query_instability,\n-                    |lint| lint.set_arg(\"query\", cx.tcx.item_name(def_id)).note(fluent::note),\n-                )\n+                    QueryInstability { query: cx.tcx.item_name(def_id) },\n+                );\n             }\n         }\n     }\n@@ -126,14 +123,8 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n             let span = path.span.with_hi(\n                 segment.args.map_or(segment.ident.span, |a| a.span_ext).hi()\n             );\n-            cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, fluent::lint_tykind_kind, |lint| {\n-                lint\n-                    .span_suggestion(\n-                        span,\n-                        fluent::suggestion,\n-                        \"ty\",\n-                        Applicability::MaybeIncorrect, // ty maybe needs an import\n-                    )\n+            cx.emit_spanned_lint(USAGE_OF_TY_TYKIND, path.span, TykindKind {\n+                suggestion: span,\n             });\n         }\n     }\n@@ -190,39 +181,17 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n \n                     match span {\n                         Some(span) => {\n-                            cx.struct_span_lint(\n-                                USAGE_OF_TY_TYKIND,\n-                                path.span,\n-                                fluent::lint_tykind_kind,\n-                                |lint| lint.span_suggestion(\n-                                    span,\n-                                    fluent::suggestion,\n-                                    \"ty\",\n-                                    Applicability::MaybeIncorrect, // ty maybe needs an import\n-                                )\n-                            )\n+                            cx.emit_spanned_lint(USAGE_OF_TY_TYKIND, path.span, TykindKind {\n+                                suggestion: span,\n+                            });\n                         },\n-                        None => cx.struct_span_lint(\n-                            USAGE_OF_TY_TYKIND,\n-                            path.span,\n-                            fluent::lint_tykind,\n-                            |lint| lint.help(fluent::help)\n-                        )\n-                    }\n-                } else if !ty.span.from_expansion() && let Some(t) = is_ty_or_ty_ctxt(cx, &path) {\n-                    if path.segments.len() > 1 {\n-                        cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, fluent::lint_ty_qualified, |lint| {\n-                            lint\n-                                .set_arg(\"ty\", t.clone())\n-                                .span_suggestion(\n-                                    path.span,\n-                                    fluent::suggestion,\n-                                    t,\n-                                    // The import probably needs to be changed\n-                                    Applicability::MaybeIncorrect,\n-                                )\n-                        })\n+                        None => cx.emit_spanned_lint(USAGE_OF_TY_TYKIND, path.span, TykindDiag),\n                     }\n+                } else if !ty.span.from_expansion() && path.segments.len() > 1 && let Some(t) = is_ty_or_ty_ctxt(cx, &path) {\n+                    cx.emit_spanned_lint(USAGE_OF_QUALIFIED_TY, path.span, TyQualified {\n+                        ty: t.clone(),\n+                        suggestion: path.span,\n+                    });\n                 }\n             }\n             _ => {}\n@@ -303,12 +272,11 @@ impl EarlyLintPass for LintPassImpl {\n                         && call_site.ctxt().outer_expn_data().kind\n                             != ExpnKind::Macro(MacroKind::Bang, sym::declare_lint_pass)\n                     {\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             LINT_PASS_IMPL_WITHOUT_MACRO,\n                             lint_pass.path.span,\n-                            fluent::lint_lintpass_by_hand,\n-                            |lint| lint.help(fluent::help),\n-                        )\n+                            LintPassByHand,\n+                        );\n                     }\n                 }\n             }\n@@ -338,17 +306,16 @@ impl<'tcx> LateLintPass<'tcx> for ExistingDocKeyword {\n             if let Some(list) = attr.meta_item_list() {\n                 for nested in list {\n                     if nested.has_name(sym::keyword) {\n-                        let v = nested\n+                        let keyword = nested\n                             .value_str()\n                             .expect(\"#[doc(keyword = \\\"...\\\")] expected a value!\");\n-                        if is_doc_keyword(v) {\n+                        if is_doc_keyword(keyword) {\n                             return;\n                         }\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             EXISTING_DOC_KEYWORD,\n                             attr.span,\n-                            fluent::lint_non_existant_doc_keyword,\n-                            |lint| lint.set_arg(\"keyword\", v).help(fluent::help),\n+                            NonExistantDocKeyword { keyword },\n                         );\n                     }\n                 }\n@@ -407,12 +374,7 @@ impl LateLintPass<'_> for Diagnostics {\n         }\n         debug!(?found_impl);\n         if !found_parent_with_attr && !found_impl {\n-            cx.struct_span_lint(\n-                DIAGNOSTIC_OUTSIDE_OF_IMPL,\n-                span,\n-                fluent::lint_diag_out_of_impl,\n-                |lint| lint,\n-            )\n+            cx.emit_spanned_lint(DIAGNOSTIC_OUTSIDE_OF_IMPL, span, DiagOutOfImpl);\n         }\n \n         let mut found_diagnostic_message = false;\n@@ -428,12 +390,7 @@ impl LateLintPass<'_> for Diagnostics {\n         }\n         debug!(?found_diagnostic_message);\n         if !found_parent_with_attr && !found_diagnostic_message {\n-            cx.struct_span_lint(\n-                UNTRANSLATABLE_DIAGNOSTIC,\n-                span,\n-                fluent::lint_untranslatable_diag,\n-                |lint| lint,\n-            )\n+            cx.emit_spanned_lint(UNTRANSLATABLE_DIAGNOSTIC, span, UntranslatableDiag);\n         }\n     }\n }\n@@ -465,9 +422,9 @@ impl LateLintPass<'_> for BadOptAccess {\n                 let Some(lit) = item.lit()  &&\n                 let ast::LitKind::Str(val, _) = lit.kind\n             {\n-                cx.struct_span_lint(BAD_OPT_ACCESS, expr.span, val.as_str(), |lint|\n-                    lint\n-                );\n+                cx.emit_spanned_lint(BAD_OPT_ACCESS, expr.span, BadOptAccessDiag {\n+                    msg: val.as_str(),\n+                });\n             }\n         }\n     }"}, {"sha": "b83a9665fc0c60ef48e3fd1d0639bad6b9f41eaa", "filename": "compiler/rustc_lint/src/let_underscore.rs", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,5 +1,8 @@\n-use crate::{LateContext, LateLintPass, LintContext};\n-use rustc_errors::{Applicability, DiagnosticBuilder, MultiSpan};\n+use crate::{\n+    lints::{NonBindingLet, NonBindingLetSub},\n+    LateContext, LateLintPass, LintContext,\n+};\n+use rustc_errors::MultiSpan;\n use rustc_hir as hir;\n use rustc_middle::ty;\n use rustc_span::Symbol;\n@@ -119,6 +122,11 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                 _ => false,\n             };\n \n+            let sub = NonBindingLetSub {\n+                suggestion: local.pat.span,\n+                multi_suggestion_start: local.span.until(init.span),\n+                multi_suggestion_end: init.span.shrink_to_hi(),\n+            };\n             if is_sync_lock {\n                 let mut span = MultiSpan::from_spans(vec![local.pat.span, init.span]);\n                 span.push_span_label(\n@@ -129,41 +137,14 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                     init.span,\n                     \"this binding will immediately drop the value assigned to it\".to_string(),\n                 );\n-                cx.struct_span_lint(\n-                    LET_UNDERSCORE_LOCK,\n-                    span,\n-                    \"non-binding let on a synchronization lock\",\n-                    |lint| build_lint(lint, local, init.span),\n-                )\n+                cx.emit_spanned_lint(LET_UNDERSCORE_LOCK, span, NonBindingLet::SyncLock { sub });\n             } else {\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     LET_UNDERSCORE_DROP,\n                     local.span,\n-                    \"non-binding let on a type that implements `Drop`\",\n-                    |lint| build_lint(lint, local, init.span),\n-                )\n+                    NonBindingLet::DropType { sub },\n+                );\n             }\n         }\n     }\n }\n-\n-fn build_lint<'a, 'b>(\n-    lint: &'a mut DiagnosticBuilder<'b, ()>,\n-    local: &hir::Local<'_>,\n-    init_span: rustc_span::Span,\n-) -> &'a mut DiagnosticBuilder<'b, ()> {\n-    lint.span_suggestion_verbose(\n-        local.pat.span,\n-        \"consider binding to an unused variable to avoid immediately dropping the value\",\n-        \"_unused\",\n-        Applicability::MachineApplicable,\n-    )\n-    .multipart_suggestion(\n-        \"consider immediately dropping the value\",\n-        vec![\n-            (local.span.until(init_span), \"drop(\".to_string()),\n-            (init_span.shrink_to_hi(), \")\".to_string()),\n-        ],\n-        Applicability::MachineApplicable,\n-    )\n-}"}, {"sha": "cca36913dea113650269b7376a8bef5b31da5c31", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 71, "deletions": 120, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,9 +1,13 @@\n use crate::context::{CheckLintNameResult, LintStore};\n use crate::late::unerased_lint_store;\n+use crate::lints::{\n+    DeprecatedLintName, IgnoredUnlessCrateSpecified, OverruledAtributeLint, RenamedOrRemovedLint,\n+    RenamedOrRemovedLintSuggestion, UnknownLint, UnknownLintSuggestion,\n+};\n use rustc_ast as ast;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage, MultiSpan};\n+use rustc_errors::{fluent, DecorateLint, DiagnosticBuilder, DiagnosticMessage, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::HirId;\n@@ -15,6 +19,7 @@ use rustc_middle::lint::{\n };\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{RegisteredTools, TyCtxt};\n+use rustc_session::lint::builtin::{RENAMED_AND_REMOVED_LINTS, UNKNOWN_LINTS, UNUSED_ATTRIBUTES};\n use rustc_session::lint::{\n     builtin::{self, FORBIDDEN_LINT_GROUPS, SINGLE_USE_LIFETIMES, UNFULFILLED_LINT_EXPECTATIONS},\n     Level, Lint, LintExpectationId, LintId,\n@@ -45,7 +50,7 @@ rustc_index::newtype_index! {\n     }\n }\n \n-/// Specifications found at this position in the stack.  This map only represents the lints\n+/// Specifications found at this position in the stack. This map only represents the lints\n /// found for one set of attributes (like `shallow_lint_levels_on` does).\n ///\n /// We store the level specifications as a linked list.\n@@ -158,7 +163,7 @@ fn shallow_lint_levels_on(tcx: TyCtxt<'_>, owner: hir::OwnerId) -> ShallowLintLe\n     match attrs.map.range(..) {\n         // There is only something to do if there are attributes at all.\n         [] => {}\n-        // Most of the time, there is only one attribute.  Avoid fetching HIR in that case.\n+        // Most of the time, there is only one attribute. Avoid fetching HIR in that case.\n         [(local_id, _)] => levels.add_id(HirId { owner, local_id: *local_id }),\n         // Otherwise, we need to visit the attributes in source code order, so we fetch HIR and do\n         // a standard visit.\n@@ -583,57 +588,32 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                     old_src,\n                     id_name\n                 );\n-\n-                let decorate_diag = |diag: &mut Diagnostic| {\n-                    diag.span_label(src.span(), \"overruled by previous forbid\");\n-                    match old_src {\n-                        LintLevelSource::Default => {\n-                            diag.note(&format!(\n-                                \"`forbid` lint level is the default for {}\",\n-                                id.to_string()\n-                            ));\n-                        }\n-                        LintLevelSource::Node { span, reason, .. } => {\n-                            diag.span_label(span, \"`forbid` level set here\");\n-                            if let Some(rationale) = reason {\n-                                diag.note(rationale.as_str());\n-                            }\n-                        }\n-                        LintLevelSource::CommandLine(_, _) => {\n-                            diag.note(\"`forbid` lint level was set on command line\");\n-                        }\n+                let sub = match old_src {\n+                    LintLevelSource::Default => {\n+                        OverruledAttributeSub::DefaultSource { id: id.to_string() }\n                     }\n+                    LintLevelSource::Node { span, reason, .. } => {\n+                        OverruledAttributeSub::NodeSource { span, reason }\n+                    }\n+                    LintLevelSource::CommandLine(_, _) => OverruledAttributeSub::CommandLineSource,\n                 };\n                 if !fcw_warning {\n                     self.sess.emit_err(OverruledAttribute {\n                         span: src.span(),\n                         overruled: src.span(),\n-                        lint_level: level.as_str().to_string(),\n+                        lint_level: level.as_str(),\n                         lint_source: src.name(),\n-                        sub: match old_src {\n-                            LintLevelSource::Default => {\n-                                OverruledAttributeSub::DefaultSource { id: id.to_string() }\n-                            }\n-                            LintLevelSource::Node { span, reason, .. } => {\n-                                OverruledAttributeSub::NodeSource { span, reason }\n-                            }\n-                            LintLevelSource::CommandLine(_, _) => {\n-                                OverruledAttributeSub::CommandLineSource\n-                            }\n-                        },\n+                        sub,\n                     });\n                 } else {\n-                    self.struct_lint(\n+                    self.emit_spanned_lint(\n                         FORBIDDEN_LINT_GROUPS,\n-                        Some(src.span().into()),\n-                        format!(\n-                            \"{}({}) incompatible with previous forbid\",\n-                            level.as_str(),\n-                            src.name(),\n-                        ),\n-                        |lint| {\n-                            decorate_diag(lint);\n-                            lint\n+                        src.span().into(),\n+                        OverruledAtributeLint {\n+                            overruled: src.span(),\n+                            lint_level: level.as_str(),\n+                            lint_source: src.name(),\n+                            sub,\n                         },\n                     );\n                 }\n@@ -858,25 +838,13 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                             }\n                             Err((Some(ids), ref new_lint_name)) => {\n                                 let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                                let (lvl, src) = self.provider.get_lint_level(lint, &sess);\n-                                struct_lint_level(\n-                                    self.sess,\n+                                self.emit_spanned_lint(\n                                     lint,\n-                                    lvl,\n-                                    src,\n-                                    Some(sp.into()),\n-                                    format!(\n-                                        \"lint name `{}` is deprecated \\\n-                                         and may not have an effect in the future.\",\n-                                        name\n-                                    ),\n-                                    |lint| {\n-                                        lint.span_suggestion(\n-                                            sp,\n-                                            \"change it to\",\n-                                            new_lint_name,\n-                                            Applicability::MachineApplicable,\n-                                        )\n+                                    sp.into(),\n+                                    DeprecatedLintName {\n+                                        name,\n+                                        suggestion: sp,\n+                                        replace: &new_lint_name,\n                                     },\n                                 );\n \n@@ -917,54 +885,29 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                     _ if !self.warn_about_weird_lints => {}\n \n                     CheckLintNameResult::Warning(msg, renamed) => {\n-                        let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                        let (renamed_lint_level, src) = self.provider.get_lint_level(lint, &sess);\n-                        struct_lint_level(\n-                            self.sess,\n-                            lint,\n-                            renamed_lint_level,\n-                            src,\n-                            Some(sp.into()),\n-                            msg,\n-                            |lint| {\n-                                if let Some(new_name) = &renamed {\n-                                    lint.span_suggestion(\n-                                        sp,\n-                                        \"use the new name\",\n-                                        new_name,\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n-                                lint\n-                            },\n+                        let suggestion =\n+                            renamed.as_ref().map(|replace| RenamedOrRemovedLintSuggestion {\n+                                suggestion: sp,\n+                                replace: replace.as_str(),\n+                            });\n+                        self.emit_spanned_lint(\n+                            RENAMED_AND_REMOVED_LINTS,\n+                            sp.into(),\n+                            RenamedOrRemovedLint { msg, suggestion },\n                         );\n                     }\n                     CheckLintNameResult::NoLint(suggestion) => {\n-                        let lint = builtin::UNKNOWN_LINTS;\n-                        let (level, src) = self.provider.get_lint_level(lint, self.sess);\n                         let name = if let Some(tool_ident) = tool_ident {\n                             format!(\"{}::{}\", tool_ident.name, name)\n                         } else {\n                             name.to_string()\n                         };\n-                        struct_lint_level(\n-                            self.sess,\n-                            lint,\n-                            level,\n-                            src,\n-                            Some(sp.into()),\n-                            format!(\"unknown lint: `{}`\", name),\n-                            |lint| {\n-                                if let Some(suggestion) = suggestion {\n-                                    lint.span_suggestion(\n-                                        sp,\n-                                        \"did you mean\",\n-                                        suggestion,\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                                lint\n-                            },\n+                        let suggestion = suggestion\n+                            .map(|replace| UnknownLintSuggestion { suggestion: sp, replace });\n+                        self.emit_spanned_lint(\n+                            UNKNOWN_LINTS,\n+                            sp.into(),\n+                            UnknownLint { name, suggestion },\n                         );\n                     }\n                 }\n@@ -1010,20 +953,10 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                     continue\n                 };\n \n-                let lint = builtin::UNUSED_ATTRIBUTES;\n-                let (lint_level, lint_src) = self.provider.get_lint_level(lint, &self.sess);\n-                struct_lint_level(\n-                    self.sess,\n-                    lint,\n-                    lint_level,\n-                    lint_src,\n-                    Some(lint_attr_span.into()),\n-                    format!(\n-                        \"{}({}) is ignored unless specified at crate level\",\n-                        level.as_str(),\n-                        lint_attr_name\n-                    ),\n-                    |lint| lint,\n+                self.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    lint_attr_span.into(),\n+                    IgnoredUnlessCrateSpecified { level: level.as_str(), name: lint_attr_name },\n                 );\n                 // don't set a separate error for every lint in the group\n                 break;\n@@ -1047,11 +980,10 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                     level,\n                     src,\n                     Some(span.into()),\n-                    format!(\"unknown lint: `{}`\", lint_id.lint.name_lower()),\n+                    fluent::lint_unknown_gated_lint,\n                     |lint| {\n-                        lint.note(\n-                            &format!(\"the `{}` lint is unstable\", lint_id.lint.name_lower(),),\n-                        );\n+                        lint.set_arg(\"name\", lint_id.lint.name_lower());\n+                        lint.note(fluent::note);\n                         add_feature_diagnostics(lint, &self.sess.parse_sess, feature);\n                         lint\n                     },\n@@ -1086,6 +1018,25 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n         let (level, src) = self.lint_level(lint);\n         struct_lint_level(self.sess, lint, level, src, span, msg, decorate)\n     }\n+\n+    pub fn emit_spanned_lint(\n+        &self,\n+        lint: &'static Lint,\n+        span: MultiSpan,\n+        decorate: impl for<'a> DecorateLint<'a, ()>,\n+    ) {\n+        let (level, src) = self.lint_level(lint);\n+        struct_lint_level(self.sess, lint, level, src, Some(span), decorate.msg(), |lint| {\n+            decorate.decorate_lint(lint)\n+        });\n+    }\n+\n+    pub fn emit_lint(&self, lint: &'static Lint, decorate: impl for<'a> DecorateLint<'a, ()>) {\n+        let (level, src) = self.lint_level(lint);\n+        struct_lint_level(self.sess, lint, level, src, None, decorate.msg(), |lint| {\n+            decorate.decorate_lint(lint)\n+        });\n+    }\n }\n \n pub(crate) fn provide(providers: &mut Providers) {"}, {"sha": "3d818154cb94ff48c1a7c33fd2a19d473b089588", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -38,6 +38,8 @@\n #![feature(never_type)]\n #![feature(rustc_attrs)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_middle;\n@@ -60,6 +62,7 @@ mod internal;\n mod late;\n mod let_underscore;\n mod levels;\n+mod lints;\n mod methods;\n mod non_ascii_idents;\n mod non_fmt_panic;"}, {"sha": "c997d8945d16ebdf2d5ac2f4a3f9dbee0e41d8b3", "filename": "compiler/rustc_lint/src/lints.rs", "status": "added", "additions": 1479, "deletions": 0, "changes": 1479, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -0,0 +1,1479 @@\n+#![allow(rustc::untranslatable_diagnostic)]\n+#![allow(rustc::diagnostic_outside_of_impl)]\n+use std::num::NonZeroU32;\n+\n+use rustc_errors::{\n+    fluent, AddToDiagnostic, Applicability, DecorateLint, DiagnosticMessage,\n+    DiagnosticStyledString, SuggestionStyle,\n+};\n+use rustc_hir::def_id::DefId;\n+use rustc_macros::{LintDiagnostic, Subdiagnostic};\n+use rustc_middle::ty::{Predicate, Ty, TyCtxt};\n+use rustc_session::parse::ParseSess;\n+use rustc_span::{edition::Edition, sym, symbol::Ident, Span, Symbol};\n+\n+use crate::{\n+    builtin::InitError, builtin::TypeAliasBounds, errors::OverruledAttributeSub, LateContext,\n+};\n+\n+// array_into_iter.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_array_into_iter)]\n+pub struct ArrayIntoIterDiag<'a> {\n+    pub target: &'a str,\n+    #[suggestion(use_iter_suggestion, code = \"iter\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    #[subdiagnostic]\n+    pub sub: Option<ArrayIntoIterDiagSub>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum ArrayIntoIterDiagSub {\n+    #[suggestion(remove_into_iter_suggestion, code = \"\", applicability = \"maybe-incorrect\")]\n+    RemoveIntoIter {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[multipart_suggestion(use_explicit_into_iter_suggestion, applicability = \"maybe-incorrect\")]\n+    UseExplicitIntoIter {\n+        #[suggestion_part(code = \"IntoIterator::into_iter(\")]\n+        start_span: Span,\n+        #[suggestion_part(code = \")\")]\n+        end_span: Span,\n+    },\n+}\n+\n+// builtin.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_while_true)]\n+pub struct BuiltinWhileTrue {\n+    #[suggestion(style = \"short\", code = \"{replace}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    pub replace: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_box_pointers)]\n+pub struct BuiltinBoxPointers<'a> {\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_non_shorthand_field_patterns)]\n+pub struct BuiltinNonShorthandFieldPatterns {\n+    pub ident: Ident,\n+    #[suggestion(code = \"{prefix}{ident}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    pub prefix: &'static str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+pub enum BuiltinUnsafe {\n+    #[diag(lint_builtin_allow_internal_unsafe)]\n+    AllowInternalUnsafe,\n+    #[diag(lint_builtin_unsafe_block)]\n+    UnsafeBlock,\n+    #[diag(lint_builtin_unsafe_trait)]\n+    UnsafeTrait,\n+    #[diag(lint_builtin_unsafe_impl)]\n+    UnsafeImpl,\n+    #[diag(lint_builtin_no_mangle_fn)]\n+    #[note(lint_builtin_overridden_symbol_name)]\n+    NoMangleFn,\n+    #[diag(lint_builtin_export_name_fn)]\n+    #[note(lint_builtin_overridden_symbol_name)]\n+    ExportNameFn,\n+    #[diag(lint_builtin_link_section_fn)]\n+    #[note(lint_builtin_overridden_symbol_section)]\n+    LinkSectionFn,\n+    #[diag(lint_builtin_no_mangle_static)]\n+    #[note(lint_builtin_overridden_symbol_name)]\n+    NoMangleStatic,\n+    #[diag(lint_builtin_export_name_static)]\n+    #[note(lint_builtin_overridden_symbol_name)]\n+    ExportNameStatic,\n+    #[diag(lint_builtin_link_section_static)]\n+    #[note(lint_builtin_overridden_symbol_section)]\n+    LinkSectionStatic,\n+    #[diag(lint_builtin_no_mangle_method)]\n+    #[note(lint_builtin_overridden_symbol_name)]\n+    NoMangleMethod,\n+    #[diag(lint_builtin_export_name_method)]\n+    #[note(lint_builtin_overridden_symbol_name)]\n+    ExportNameMethod,\n+    #[diag(lint_builtin_decl_unsafe_fn)]\n+    DeclUnsafeFn,\n+    #[diag(lint_builtin_decl_unsafe_method)]\n+    DeclUnsafeMethod,\n+    #[diag(lint_builtin_impl_unsafe_method)]\n+    ImplUnsafeMethod,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_missing_doc)]\n+pub struct BuiltinMissingDoc<'a> {\n+    pub article: &'a str,\n+    pub desc: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_missing_copy_impl)]\n+pub struct BuiltinMissingCopyImpl;\n+\n+pub struct BuiltinMissingDebugImpl<'a> {\n+    pub tcx: TyCtxt<'a>,\n+    pub def_id: DefId,\n+}\n+\n+// Needed for def_path_str\n+impl<'a> DecorateLint<'a, ()> for BuiltinMissingDebugImpl<'_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"debug\", self.tcx.def_path_str(self.def_id));\n+        diag\n+    }\n+\n+    fn msg(&self) -> DiagnosticMessage {\n+        fluent::lint_builtin_missing_debug_impl\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_anonymous_params)]\n+pub struct BuiltinAnonymousParams<'a> {\n+    #[suggestion(code = \"_: {ty_snip}\")]\n+    pub suggestion: (Span, Applicability),\n+    pub ty_snip: &'a str,\n+}\n+\n+// FIXME(davidtwco) translatable deprecated attr\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_deprecated_attr_link)]\n+pub struct BuiltinDeprecatedAttrLink<'a> {\n+    pub name: Symbol,\n+    pub reason: &'a str,\n+    pub link: &'a str,\n+    #[subdiagnostic]\n+    pub suggestion: BuiltinDeprecatedAttrLinkSuggestion<'a>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum BuiltinDeprecatedAttrLinkSuggestion<'a> {\n+    #[suggestion(msg_suggestion, code = \"\", applicability = \"machine-applicable\")]\n+    Msg {\n+        #[primary_span]\n+        suggestion: Span,\n+        msg: &'a str,\n+    },\n+    #[suggestion(default_suggestion, code = \"\", applicability = \"machine-applicable\")]\n+    Default {\n+        #[primary_span]\n+        suggestion: Span,\n+    },\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_deprecated_attr_used)]\n+pub struct BuiltinDeprecatedAttrUsed {\n+    pub name: String,\n+    #[suggestion(\n+        lint_builtin_deprecated_attr_default_suggestion,\n+        style = \"short\",\n+        code = \"\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unused_doc_comment)]\n+pub struct BuiltinUnusedDocComment<'a> {\n+    pub kind: &'a str,\n+    #[label]\n+    pub label: Span,\n+    #[subdiagnostic]\n+    pub sub: BuiltinUnusedDocCommentSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum BuiltinUnusedDocCommentSub {\n+    #[help(plain_help)]\n+    PlainHelp,\n+    #[help(block_help)]\n+    BlockHelp,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_no_mangle_generic)]\n+pub struct BuiltinNoMangleGeneric {\n+    // Use of `#[no_mangle]` suggests FFI intent; correct\n+    // fix may be to monomorphize source by hand\n+    #[suggestion(style = \"short\", code = \"\", applicability = \"maybe-incorrect\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_const_no_mangle)]\n+pub struct BuiltinConstNoMangle {\n+    #[suggestion(code = \"pub static\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_mutable_transmutes)]\n+pub struct BuiltinMutablesTransmutes;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unstable_features)]\n+pub struct BuiltinUnstableFeatures;\n+\n+// lint_ungated_async_fn_track_caller\n+pub struct BuiltinUngatedAsyncFnTrackCaller<'a> {\n+    pub label: Span,\n+    pub parse_sess: &'a ParseSess,\n+}\n+\n+impl<'a> DecorateLint<'a, ()> for BuiltinUngatedAsyncFnTrackCaller<'_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.span_label(self.label, fluent::label);\n+        rustc_session::parse::add_feature_diagnostics(\n+            diag,\n+            &self.parse_sess,\n+            sym::closure_track_caller,\n+        );\n+        diag\n+    }\n+\n+    fn msg(&self) -> DiagnosticMessage {\n+        fluent::lint_ungated_async_fn_track_caller\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unreachable_pub)]\n+pub struct BuiltinUnreachablePub<'a> {\n+    pub what: &'a str,\n+    #[suggestion(code = \"pub(crate)\")]\n+    pub suggestion: (Span, Applicability),\n+    #[help]\n+    pub help: Option<()>,\n+}\n+\n+pub struct SuggestChangingAssocTypes<'a, 'b> {\n+    pub ty: &'a rustc_hir::Ty<'b>,\n+}\n+\n+impl AddToDiagnostic for SuggestChangingAssocTypes<'_, '_> {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        // Access to associates types should use `<T as Bound>::Assoc`, which does not need a\n+        // bound. Let's see if this type does that.\n+\n+        // We use a HIR visitor to walk the type.\n+        use rustc_hir::intravisit::{self, Visitor};\n+        struct WalkAssocTypes<'a> {\n+            err: &'a mut rustc_errors::Diagnostic,\n+        }\n+        impl Visitor<'_> for WalkAssocTypes<'_> {\n+            fn visit_qpath(\n+                &mut self,\n+                qpath: &rustc_hir::QPath<'_>,\n+                id: rustc_hir::HirId,\n+                span: Span,\n+            ) {\n+                if TypeAliasBounds::is_type_variable_assoc(qpath) {\n+                    self.err.span_help(span, fluent::lint_builtin_type_alias_bounds_help);\n+                }\n+                intravisit::walk_qpath(self, qpath, id)\n+            }\n+        }\n+\n+        // Let's go for a walk!\n+        let mut visitor = WalkAssocTypes { err: diag };\n+        visitor.visit_ty(self.ty);\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_type_alias_where_clause)]\n+pub struct BuiltinTypeAliasWhereClause<'a, 'b> {\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    #[subdiagnostic]\n+    pub sub: Option<SuggestChangingAssocTypes<'a, 'b>>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_type_alias_generic_bounds)]\n+pub struct BuiltinTypeAliasGenericBounds<'a, 'b> {\n+    #[subdiagnostic]\n+    pub suggestion: BuiltinTypeAliasGenericBoundsSuggestion,\n+    #[subdiagnostic]\n+    pub sub: Option<SuggestChangingAssocTypes<'a, 'b>>,\n+}\n+\n+pub struct BuiltinTypeAliasGenericBoundsSuggestion {\n+    pub suggestions: Vec<(Span, String)>,\n+}\n+\n+impl AddToDiagnostic for BuiltinTypeAliasGenericBoundsSuggestion {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        diag.multipart_suggestion(\n+            fluent::suggestion,\n+            self.suggestions,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_trivial_bounds)]\n+pub struct BuiltinTrivialBounds<'a> {\n+    pub predicate_kind_name: &'a str,\n+    pub predicate: Predicate<'a>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+pub enum BuiltinEllipsisInclusiveRangePatternsLint {\n+    #[diag(lint_builtin_ellipsis_inclusive_range_patterns)]\n+    Parenthesise {\n+        #[suggestion(code = \"{replace}\", applicability = \"machine-applicable\")]\n+        suggestion: Span,\n+        replace: String,\n+    },\n+    #[diag(lint_builtin_ellipsis_inclusive_range_patterns)]\n+    NonParenthesise {\n+        #[suggestion(style = \"short\", code = \"..=\", applicability = \"machine-applicable\")]\n+        suggestion: Span,\n+    },\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unnameable_test_items)]\n+pub struct BuiltinUnnameableTestItems;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_keyword_idents)]\n+pub struct BuiltinKeywordIdents {\n+    pub kw: Ident,\n+    pub next: Edition,\n+    #[suggestion(code = \"r#{kw}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_explicit_outlives)]\n+pub struct BuiltinExplicitOutlives {\n+    pub count: usize,\n+    #[subdiagnostic]\n+    pub suggestion: BuiltinExplicitOutlivesSuggestion,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(suggestion)]\n+pub struct BuiltinExplicitOutlivesSuggestion {\n+    #[suggestion_part(code = \"\")]\n+    pub spans: Vec<Span>,\n+    #[applicability]\n+    pub applicability: Applicability,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_incomplete_features)]\n+pub struct BuiltinIncompleteFeatures {\n+    pub name: Symbol,\n+    #[subdiagnostic]\n+    pub note: Option<BuiltinIncompleteFeaturesNote>,\n+    #[subdiagnostic]\n+    pub help: Option<BuiltinIncompleteFeaturesHelp>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(help)]\n+pub struct BuiltinIncompleteFeaturesHelp;\n+\n+#[derive(Subdiagnostic)]\n+#[note(note)]\n+pub struct BuiltinIncompleteFeaturesNote {\n+    pub n: NonZeroU32,\n+}\n+\n+pub struct BuiltinUnpermittedTypeInit<'a> {\n+    pub msg: DiagnosticMessage,\n+    pub ty: Ty<'a>,\n+    pub label: Span,\n+    pub sub: BuiltinUnpermittedTypeInitSub,\n+}\n+\n+impl<'a> DecorateLint<'a, ()> for BuiltinUnpermittedTypeInit<'_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"ty\", self.ty);\n+        diag.span_label(self.label, fluent::lint_builtin_unpermitted_type_init_label);\n+        diag.span_label(self.label, fluent::lint_builtin_unpermitted_type_init_label_suggestion);\n+        self.sub.add_to_diagnostic(diag);\n+        diag\n+    }\n+\n+    fn msg(&self) -> rustc_errors::DiagnosticMessage {\n+        self.msg.clone()\n+    }\n+}\n+\n+// FIXME(davidtwco): make translatable\n+pub struct BuiltinUnpermittedTypeInitSub {\n+    pub err: InitError,\n+}\n+\n+impl AddToDiagnostic for BuiltinUnpermittedTypeInitSub {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        let mut err = self.err;\n+        loop {\n+            if let Some(span) = err.span {\n+                diag.span_note(span, err.message);\n+            } else {\n+                diag.note(err.message);\n+            }\n+            if let Some(e) = err.nested {\n+                err = *e;\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+pub enum BuiltinClashingExtern<'a> {\n+    #[diag(lint_builtin_clashing_extern_same_name)]\n+    SameName {\n+        this: Symbol,\n+        orig: Symbol,\n+        #[label(previous_decl_label)]\n+        previous_decl_label: Span,\n+        #[label(mismatch_label)]\n+        mismatch_label: Span,\n+        #[subdiagnostic]\n+        sub: BuiltinClashingExternSub<'a>,\n+    },\n+    #[diag(lint_builtin_clashing_extern_diff_name)]\n+    DiffName {\n+        this: Symbol,\n+        orig: Symbol,\n+        #[label(previous_decl_label)]\n+        previous_decl_label: Span,\n+        #[label(mismatch_label)]\n+        mismatch_label: Span,\n+        #[subdiagnostic]\n+        sub: BuiltinClashingExternSub<'a>,\n+    },\n+}\n+\n+// FIXME(davidtwco): translatable expected/found\n+pub struct BuiltinClashingExternSub<'a> {\n+    pub tcx: TyCtxt<'a>,\n+    pub expected: Ty<'a>,\n+    pub found: Ty<'a>,\n+}\n+\n+impl AddToDiagnostic for BuiltinClashingExternSub<'_> {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        let mut expected_str = DiagnosticStyledString::new();\n+        expected_str.push(self.expected.fn_sig(self.tcx).to_string(), false);\n+        let mut found_str = DiagnosticStyledString::new();\n+        found_str.push(self.found.fn_sig(self.tcx).to_string(), true);\n+        diag.note_expected_found(&\"\", expected_str, &\"\", found_str);\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_deref_nullptr)]\n+pub struct BuiltinDerefNullptr {\n+    #[label]\n+    pub label: Span,\n+}\n+\n+// FIXME: migrate fluent::lint::builtin_asm_labels\n+\n+#[derive(LintDiagnostic)]\n+pub enum BuiltinSpecialModuleNameUsed {\n+    #[diag(lint_builtin_special_module_name_used_lib)]\n+    #[note]\n+    #[help]\n+    Lib,\n+    #[diag(lint_builtin_special_module_name_used_main)]\n+    #[note]\n+    Main,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unexpected_cli_config_name)]\n+#[help]\n+pub struct BuiltinUnexpectedCliConfigName {\n+    pub name: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unexpected_cli_config_value)]\n+#[help]\n+pub struct BuiltinUnexpectedCliConfigValue {\n+    pub name: Symbol,\n+    pub value: Symbol,\n+}\n+\n+// deref_into_dyn_supertrait.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_supertrait_as_deref_target)]\n+pub struct SupertraitAsDerefTarget<'a> {\n+    pub t: Ty<'a>,\n+    pub target_principal: String,\n+    // pub target_principal: Binder<'a, ExistentialTraitRef<'b>>,\n+    #[subdiagnostic]\n+    pub label: Option<SupertraitAsDerefTargetLabel>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(label)]\n+pub struct SupertraitAsDerefTargetLabel {\n+    #[primary_span]\n+    pub label: Span,\n+}\n+\n+// enum_intrinsics_non_enums.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_enum_intrinsics_mem_discriminant)]\n+pub struct EnumIntrinsicsMemDiscriminate<'a> {\n+    pub ty_param: Ty<'a>,\n+    #[note]\n+    pub note: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_enum_intrinsics_mem_variant)]\n+#[note]\n+pub struct EnumIntrinsicsMemVariant<'a> {\n+    pub ty_param: Ty<'a>,\n+}\n+\n+// expect.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_expectation)]\n+pub struct Expectation {\n+    #[subdiagnostic]\n+    pub rationale: Option<ExpectationNote>,\n+    #[note]\n+    pub note: Option<()>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(rationale)]\n+pub struct ExpectationNote {\n+    pub rationale: Symbol,\n+}\n+\n+// for_loops_over_fallibles.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_for_loops_over_fallibles)]\n+pub struct ForLoopsOverFalliblesDiag<'a> {\n+    pub article: &'static str,\n+    pub ty: &'static str,\n+    #[subdiagnostic]\n+    pub sub: ForLoopsOverFalliblesLoopSub<'a>,\n+    #[subdiagnostic]\n+    pub question_mark: Option<ForLoopsOverFalliblesQuestionMark>,\n+    #[subdiagnostic]\n+    pub suggestion: ForLoopsOverFalliblesSuggestion<'a>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum ForLoopsOverFalliblesLoopSub<'a> {\n+    #[suggestion(remove_next, code = \".by_ref()\", applicability = \"maybe-incorrect\")]\n+    RemoveNext {\n+        #[primary_span]\n+        suggestion: Span,\n+        recv_snip: String,\n+    },\n+    #[multipart_suggestion(use_while_let, applicability = \"maybe-incorrect\")]\n+    UseWhileLet {\n+        #[suggestion_part(code = \"while let {var}(\")]\n+        start_span: Span,\n+        #[suggestion_part(code = \") = \")]\n+        end_span: Span,\n+        var: &'a str,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(use_question_mark, code = \"?\", applicability = \"maybe-incorrect\")]\n+pub struct ForLoopsOverFalliblesQuestionMark {\n+    #[primary_span]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(suggestion, applicability = \"maybe-incorrect\")]\n+pub struct ForLoopsOverFalliblesSuggestion<'a> {\n+    pub var: &'a str,\n+    #[suggestion_part(code = \"if let {var}(\")]\n+    pub start_span: Span,\n+    #[suggestion_part(code = \") = \")]\n+    pub end_span: Span,\n+}\n+\n+// hidden_unicode_codepoints.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_hidden_unicode_codepoints)]\n+#[note]\n+pub struct HiddenUnicodeCodepointsDiag<'a> {\n+    pub label: &'a str,\n+    pub count: usize,\n+    #[label]\n+    pub span_label: Span,\n+    #[subdiagnostic]\n+    pub labels: Option<HiddenUnicodeCodepointsDiagLabels>,\n+    #[subdiagnostic]\n+    pub sub: HiddenUnicodeCodepointsDiagSub,\n+}\n+\n+pub struct HiddenUnicodeCodepointsDiagLabels {\n+    pub spans: Vec<(char, Span)>,\n+}\n+\n+impl AddToDiagnostic for HiddenUnicodeCodepointsDiagLabels {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        for (c, span) in self.spans {\n+            diag.span_label(span, format!(\"{:?}\", c));\n+        }\n+    }\n+}\n+\n+pub enum HiddenUnicodeCodepointsDiagSub {\n+    Escape { spans: Vec<(char, Span)> },\n+    NoEscape { spans: Vec<(char, Span)> },\n+}\n+\n+// Used because of multiple multipart_suggestion and note\n+impl AddToDiagnostic for HiddenUnicodeCodepointsDiagSub {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        match self {\n+            HiddenUnicodeCodepointsDiagSub::Escape { spans } => {\n+                diag.multipart_suggestion_with_style(\n+                    fluent::suggestion_remove,\n+                    spans.iter().map(|(_, span)| (*span, \"\".to_string())).collect(),\n+                    Applicability::MachineApplicable,\n+                    SuggestionStyle::HideCodeAlways,\n+                );\n+                diag.multipart_suggestion(\n+                    fluent::suggestion_escape,\n+                    spans\n+                        .into_iter()\n+                        .map(|(c, span)| {\n+                            let c = format!(\"{:?}\", c);\n+                            (span, c[1..c.len() - 1].to_string())\n+                        })\n+                        .collect(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            HiddenUnicodeCodepointsDiagSub::NoEscape { spans } => {\n+                // FIXME: in other suggestions we've reversed the inner spans of doc comments. We\n+                // should do the same here to provide the same good suggestions as we do for\n+                // literals above.\n+                diag.set_arg(\n+                    \"escaped\",\n+                    spans\n+                        .into_iter()\n+                        .map(|(c, _)| format!(\"{:?}\", c))\n+                        .collect::<Vec<String>>()\n+                        .join(\", \"),\n+                );\n+                diag.note(fluent::suggestion_remove);\n+                diag.note(fluent::no_suggestion_note_escape);\n+            }\n+        }\n+    }\n+}\n+\n+// internal.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_default_hash_types)]\n+#[note]\n+pub struct DefaultHashTypesDiag<'a> {\n+    pub preferred: &'a str,\n+    pub used: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_query_instability)]\n+#[note]\n+pub struct QueryInstability {\n+    pub query: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_tykind_kind)]\n+pub struct TykindKind {\n+    #[suggestion(code = \"ty\", applicability = \"maybe-incorrect\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_tykind)]\n+#[help]\n+pub struct TykindDiag;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_ty_qualified)]\n+pub struct TyQualified {\n+    pub ty: String,\n+    #[suggestion(code = \"{ty}\", applicability = \"maybe-incorrect\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_lintpass_by_hand)]\n+#[help]\n+pub struct LintPassByHand;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_non_existant_doc_keyword)]\n+#[help]\n+pub struct NonExistantDocKeyword {\n+    pub keyword: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_diag_out_of_impl)]\n+pub struct DiagOutOfImpl;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_untranslatable_diag)]\n+pub struct UntranslatableDiag;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_bad_opt_access)]\n+pub struct BadOptAccessDiag<'a> {\n+    pub msg: &'a str,\n+}\n+\n+// let_underscore.rs\n+#[derive(LintDiagnostic)]\n+pub enum NonBindingLet {\n+    #[diag(lint_non_binding_let_on_sync_lock)]\n+    SyncLock {\n+        #[subdiagnostic]\n+        sub: NonBindingLetSub,\n+    },\n+    #[diag(lint_non_binding_let_on_drop_type)]\n+    DropType {\n+        #[subdiagnostic]\n+        sub: NonBindingLetSub,\n+    },\n+}\n+\n+pub struct NonBindingLetSub {\n+    pub suggestion: Span,\n+    pub multi_suggestion_start: Span,\n+    pub multi_suggestion_end: Span,\n+}\n+\n+impl AddToDiagnostic for NonBindingLetSub {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        diag.span_suggestion_verbose(\n+            self.suggestion,\n+            fluent::lint_non_binding_let_suggestion,\n+            \"_unused\",\n+            Applicability::MachineApplicable,\n+        );\n+        diag.multipart_suggestion(\n+            fluent::lint_non_binding_let_multi_suggestion,\n+            vec![\n+                (self.multi_suggestion_start, \"drop(\".to_string()),\n+                (self.multi_suggestion_end, \")\".to_string()),\n+            ],\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+// levels.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_overruled_attribute)]\n+pub struct OverruledAtributeLint<'a> {\n+    #[label]\n+    pub overruled: Span,\n+    pub lint_level: &'a str,\n+    pub lint_source: Symbol,\n+    #[subdiagnostic]\n+    pub sub: OverruledAttributeSub,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_deprecated_lint_name)]\n+pub struct DeprecatedLintName<'a> {\n+    pub name: String,\n+    #[suggestion(code = \"{replace}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    pub replace: &'a str,\n+}\n+\n+// FIXME: Non-translatable msg\n+#[derive(LintDiagnostic)]\n+#[diag(lint_renamed_or_removed_lint)]\n+pub struct RenamedOrRemovedLint<'a> {\n+    pub msg: &'a str,\n+    #[subdiagnostic]\n+    pub suggestion: Option<RenamedOrRemovedLintSuggestion<'a>>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(suggestion, code = \"{replace}\", applicability = \"machine-applicable\")]\n+pub struct RenamedOrRemovedLintSuggestion<'a> {\n+    #[primary_span]\n+    pub suggestion: Span,\n+    pub replace: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unknown_lint)]\n+pub struct UnknownLint {\n+    pub name: String,\n+    #[subdiagnostic]\n+    pub suggestion: Option<UnknownLintSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(suggestion, code = \"{replace}\", applicability = \"maybe-incorrect\")]\n+pub struct UnknownLintSuggestion {\n+    #[primary_span]\n+    pub suggestion: Span,\n+    pub replace: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_ignored_unless_crate_specified)]\n+pub struct IgnoredUnlessCrateSpecified<'a> {\n+    pub level: &'a str,\n+    pub name: Symbol,\n+}\n+\n+// methods.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_cstring_ptr)]\n+#[note]\n+#[help]\n+pub struct CStringPtr {\n+    #[label(as_ptr_label)]\n+    pub as_ptr: Span,\n+    #[label(unwrap_label)]\n+    pub unwrap: Span,\n+}\n+\n+// non_ascii_idents.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_identifier_non_ascii_char)]\n+pub struct IdentifierNonAsciiChar;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_identifier_uncommon_codepoints)]\n+pub struct IdentifierUncommonCodepoints;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_confusable_identifier_pair)]\n+pub struct ConfusableIdentifierPair {\n+    pub existing_sym: Symbol,\n+    pub sym: Symbol,\n+    #[label]\n+    pub label: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_mixed_script_confusables)]\n+#[note(includes_note)]\n+#[note]\n+pub struct MixedScriptConfusables {\n+    pub set: String,\n+    pub includes: String,\n+}\n+\n+// non_fmt_panic.rs\n+pub struct NonFmtPanicUnused {\n+    pub count: usize,\n+    pub suggestion: Option<Span>,\n+}\n+\n+// Used because of two suggestions based on one Option<Span>\n+impl<'a> DecorateLint<'a, ()> for NonFmtPanicUnused {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"count\", self.count);\n+        diag.note(fluent::note);\n+        if let Some(span) = self.suggestion {\n+            diag.span_suggestion(\n+                span.shrink_to_hi(),\n+                fluent::add_args_suggestion,\n+                \", ...\",\n+                Applicability::HasPlaceholders,\n+            );\n+            diag.span_suggestion(\n+                span.shrink_to_lo(),\n+                fluent::add_fmt_suggestion,\n+                \"\\\"{}\\\", \",\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+        diag\n+    }\n+\n+    fn msg(&self) -> rustc_errors::DiagnosticMessage {\n+        fluent::lint_non_fmt_panic_unused\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_non_fmt_panic_braces)]\n+#[note]\n+pub struct NonFmtPanicBraces {\n+    pub count: usize,\n+    #[suggestion(code = \"\\\"{{}}\\\", \", applicability = \"machine-applicable\")]\n+    pub suggestion: Option<Span>,\n+}\n+\n+// nonstandard_style.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_non_camel_case_type)]\n+pub struct NonCamelCaseType<'a> {\n+    pub sort: &'a str,\n+    pub name: &'a str,\n+    #[subdiagnostic]\n+    pub sub: NonCamelCaseTypeSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum NonCamelCaseTypeSub {\n+    #[label(label)]\n+    Label {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion(suggestion, code = \"{replace}\", applicability = \"maybe-incorrect\")]\n+    Suggestion {\n+        #[primary_span]\n+        span: Span,\n+        replace: String,\n+    },\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_non_snake_case)]\n+pub struct NonSnakeCaseDiag<'a> {\n+    pub sort: &'a str,\n+    pub name: &'a str,\n+    pub sc: String,\n+    #[subdiagnostic]\n+    pub sub: NonSnakeCaseDiagSub,\n+}\n+\n+pub enum NonSnakeCaseDiagSub {\n+    Label { span: Span },\n+    Help,\n+    RenameOrConvertSuggestion { span: Span, suggestion: Ident },\n+    ConvertSuggestion { span: Span, suggestion: String },\n+    SuggestionAndNote { span: Span },\n+}\n+\n+impl AddToDiagnostic for NonSnakeCaseDiagSub {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        match self {\n+            NonSnakeCaseDiagSub::Label { span } => {\n+                diag.span_label(span, fluent::label);\n+            }\n+            NonSnakeCaseDiagSub::Help => {\n+                diag.help(fluent::help);\n+            }\n+            NonSnakeCaseDiagSub::ConvertSuggestion { span, suggestion } => {\n+                diag.span_suggestion(\n+                    span,\n+                    fluent::convert_suggestion,\n+                    suggestion,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            NonSnakeCaseDiagSub::RenameOrConvertSuggestion { span, suggestion } => {\n+                diag.span_suggestion(\n+                    span,\n+                    fluent::rename_or_convert_suggestion,\n+                    suggestion,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            NonSnakeCaseDiagSub::SuggestionAndNote { span } => {\n+                diag.note(fluent::cannot_convert_note);\n+                diag.span_suggestion(\n+                    span,\n+                    fluent::rename_suggestion,\n+                    \"\",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_non_upper_case_global)]\n+pub struct NonUpperCaseGlobal<'a> {\n+    pub sort: &'a str,\n+    pub name: &'a str,\n+    #[subdiagnostic]\n+    pub sub: NonUpperCaseGlobalSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum NonUpperCaseGlobalSub {\n+    #[label(label)]\n+    Label {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion(suggestion, code = \"{replace}\", applicability = \"maybe-incorrect\")]\n+    Suggestion {\n+        #[primary_span]\n+        span: Span,\n+        replace: String,\n+    },\n+}\n+\n+// noop_method_call.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_noop_method_call)]\n+#[note]\n+pub struct NoopMethodCallDiag<'a> {\n+    pub method: Symbol,\n+    pub receiver_ty: Ty<'a>,\n+    #[label]\n+    pub label: Span,\n+}\n+\n+// pass_by_value.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_pass_by_value)]\n+pub struct PassByValueDiag {\n+    pub ty: String,\n+    #[suggestion(code = \"{ty}\", applicability = \"maybe-incorrect\")]\n+    pub suggestion: Span,\n+}\n+\n+// redundant_semicolon.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_redundant_semicolons)]\n+pub struct RedundantSemicolonsDiag {\n+    pub multiple: bool,\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub suggestion: Span,\n+}\n+\n+// traits.rs\n+pub struct DropTraitConstraintsDiag<'a> {\n+    pub predicate: Predicate<'a>,\n+    pub tcx: TyCtxt<'a>,\n+    pub def_id: DefId,\n+}\n+\n+// Needed for def_path_str\n+impl<'a> DecorateLint<'a, ()> for DropTraitConstraintsDiag<'_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"predicate\", self.predicate);\n+        diag.set_arg(\"needs_drop\", self.tcx.def_path_str(self.def_id))\n+    }\n+\n+    fn msg(&self) -> rustc_errors::DiagnosticMessage {\n+        fluent::lint_drop_trait_constraints\n+    }\n+}\n+\n+pub struct DropGlue<'a> {\n+    pub tcx: TyCtxt<'a>,\n+    pub def_id: DefId,\n+}\n+\n+// Needed for def_path_str\n+impl<'a> DecorateLint<'a, ()> for DropGlue<'_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"needs_drop\", self.tcx.def_path_str(self.def_id))\n+    }\n+\n+    fn msg(&self) -> rustc_errors::DiagnosticMessage {\n+        fluent::lint_drop_glue\n+    }\n+}\n+\n+// types.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_range_endpoint_out_of_range)]\n+pub struct RangeEndpointOutOfRange<'a> {\n+    pub ty: &'a str,\n+    #[suggestion(code = \"{start}..={literal}{suffix}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    pub start: String,\n+    pub literal: u128,\n+    pub suffix: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_overflowing_bin_hex)]\n+pub struct OverflowingBinHex<'a> {\n+    pub ty: &'a str,\n+    pub lit: String,\n+    pub dec: u128,\n+    pub actually: String,\n+    #[subdiagnostic]\n+    pub sign: OverflowingBinHexSign,\n+    #[subdiagnostic]\n+    pub sub: Option<OverflowingBinHexSub<'a>>,\n+}\n+\n+pub enum OverflowingBinHexSign {\n+    Positive,\n+    Negative,\n+}\n+\n+impl AddToDiagnostic for OverflowingBinHexSign {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        match self {\n+            OverflowingBinHexSign::Positive => {\n+                diag.note(fluent::positive_note);\n+            }\n+            OverflowingBinHexSign::Negative => {\n+                diag.note(fluent::negative_note);\n+                diag.note(fluent::negative_becomes_note);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum OverflowingBinHexSub<'a> {\n+    #[suggestion(\n+        suggestion,\n+        code = \"{sans_suffix}{suggestion_ty}\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Suggestion {\n+        #[primary_span]\n+        span: Span,\n+        suggestion_ty: &'a str,\n+        sans_suffix: &'a str,\n+    },\n+    #[help(help)]\n+    Help { suggestion_ty: &'a str },\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_overflowing_int)]\n+#[note]\n+pub struct OverflowingInt<'a> {\n+    pub ty: &'a str,\n+    pub lit: String,\n+    pub min: i128,\n+    pub max: u128,\n+    #[subdiagnostic]\n+    pub help: Option<OverflowingIntHelp<'a>>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(help)]\n+pub struct OverflowingIntHelp<'a> {\n+    pub suggestion_ty: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_only_cast_u8_to_char)]\n+pub struct OnlyCastu8ToChar {\n+    #[suggestion(code = \"'\\\\u{{{literal:X}}}'\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    pub literal: u128,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_overflowing_uint)]\n+#[note]\n+pub struct OverflowingUInt<'a> {\n+    pub ty: &'a str,\n+    pub lit: String,\n+    pub min: u128,\n+    pub max: u128,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_overflowing_literal)]\n+#[note]\n+pub struct OverflowingLiteral<'a> {\n+    pub ty: &'a str,\n+    pub lit: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_comparisons)]\n+pub struct UnusedComparisons;\n+\n+pub struct ImproperCTypes<'a> {\n+    pub ty: Ty<'a>,\n+    pub desc: &'a str,\n+    pub label: Span,\n+    pub help: Option<DiagnosticMessage>,\n+    pub note: DiagnosticMessage,\n+    pub span_note: Option<Span>,\n+}\n+\n+// Used because of the complexity of Option<DiagnosticMessage>, DiagnosticMessage, and Option<Span>\n+impl<'a> DecorateLint<'a, ()> for ImproperCTypes<'_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"ty\", self.ty);\n+        diag.set_arg(\"desc\", self.desc);\n+        diag.span_label(self.label, fluent::label);\n+        if let Some(help) = self.help {\n+            diag.help(help);\n+        }\n+        diag.note(self.note);\n+        if let Some(note) = self.span_note {\n+            diag.span_note(note, fluent::note);\n+        }\n+        diag\n+    }\n+\n+    fn msg(&self) -> rustc_errors::DiagnosticMessage {\n+        fluent::lint_improper_ctypes\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_variant_size_differences)]\n+pub struct VariantSizeDifferencesDiag {\n+    pub largest: u64,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_atomic_ordering_load)]\n+#[help]\n+pub struct AtomicOrderingLoad;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_atomic_ordering_store)]\n+#[help]\n+pub struct AtomicOrderingStore;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_atomic_ordering_fence)]\n+#[help]\n+pub struct AtomicOrderingFence;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_atomic_ordering_invalid)]\n+#[help]\n+pub struct InvalidAtomicOrderingDiag {\n+    pub method: Symbol,\n+    #[label]\n+    pub fail_order_arg_span: Span,\n+}\n+\n+// unused.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_op)]\n+pub struct UnusedOp<'a> {\n+    pub op: &'a str,\n+    #[label]\n+    pub label: Span,\n+    #[suggestion(style = \"verbose\", code = \"let _ = \", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_result)]\n+pub struct UnusedResult<'a> {\n+    pub ty: Ty<'a>,\n+}\n+\n+// FIXME(davidtwco): this isn't properly translatable becauses of the\n+// pre/post strings\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_closure)]\n+#[note]\n+pub struct UnusedClosure<'a> {\n+    pub count: usize,\n+    pub pre: &'a str,\n+    pub post: &'a str,\n+}\n+\n+// FIXME(davidtwco): this isn't properly translatable becauses of the\n+// pre/post strings\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_generator)]\n+#[note]\n+pub struct UnusedGenerator<'a> {\n+    pub count: usize,\n+    pub pre: &'a str,\n+    pub post: &'a str,\n+}\n+\n+// FIXME(davidtwco): this isn't properly translatable becauses of the pre/post\n+// strings\n+pub struct UnusedDef<'a, 'b> {\n+    pub pre: &'a str,\n+    pub post: &'a str,\n+    pub cx: &'a LateContext<'b>,\n+    pub def_id: DefId,\n+    pub note: Option<Symbol>,\n+}\n+\n+// Needed because of def_path_str\n+impl<'a> DecorateLint<'a, ()> for UnusedDef<'_, '_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"pre\", self.pre);\n+        diag.set_arg(\"post\", self.post);\n+        diag.set_arg(\"def\", self.cx.tcx.def_path_str(self.def_id));\n+        // check for #[must_use = \"...\"]\n+        if let Some(note) = self.note {\n+            diag.note(note.as_str());\n+        }\n+        diag\n+    }\n+\n+    fn msg(&self) -> rustc_errors::DiagnosticMessage {\n+        fluent::lint_unused_def\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_path_statement_drop)]\n+pub struct PathStatementDrop {\n+    #[subdiagnostic]\n+    pub sub: PathStatementDropSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum PathStatementDropSub {\n+    #[suggestion(suggestion, code = \"drop({snippet});\", applicability = \"machine-applicable\")]\n+    Suggestion {\n+        #[primary_span]\n+        span: Span,\n+        snippet: String,\n+    },\n+    #[help(help)]\n+    Help {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_path_statement_no_effect)]\n+pub struct PathStatementNoEffect;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_delim)]\n+pub struct UnusedDelim<'a> {\n+    pub delim: &'static str,\n+    pub item: &'a str,\n+    #[subdiagnostic]\n+    pub suggestion: Option<UnusedDelimSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n+pub struct UnusedDelimSuggestion {\n+    #[suggestion_part(code = \"{start_replace}\")]\n+    pub start_span: Span,\n+    pub start_replace: &'static str,\n+    #[suggestion_part(code = \"{end_replace}\")]\n+    pub end_span: Span,\n+    pub end_replace: &'static str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_import_braces)]\n+pub struct UnusedImportBracesDiag {\n+    pub node: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_allocation)]\n+pub struct UnusedAllocationDiag;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_allocation_mut)]\n+pub struct UnusedAllocationMutDiag;"}, {"sha": "3045fc1a4761e47d2a1f2f339242338f9f5fb707", "filename": "compiler/rustc_lint/src/methods.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,7 +1,7 @@\n+use crate::lints::CStringPtr;\n use crate::LateContext;\n use crate::LateLintPass;\n use crate::LintContext;\n-use rustc_errors::fluent;\n use rustc_hir::{Expr, ExprKind, PathSegment};\n use rustc_middle::ty;\n use rustc_span::{symbol::sym, ExpnKind, Span};\n@@ -90,16 +90,10 @@ fn lint_cstring_as_ptr(\n         if cx.tcx.is_diagnostic_item(sym::Result, def.did()) {\n             if let ty::Adt(adt, _) = substs.type_at(0).kind() {\n                 if cx.tcx.is_diagnostic_item(sym::cstring_type, adt.did()) {\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         TEMPORARY_CSTRING_AS_PTR,\n                         as_ptr_span,\n-                        fluent::lint_cstring_ptr,\n-                        |diag| {\n-                            diag.span_label(as_ptr_span, fluent::as_ptr_label)\n-                                .span_label(unwrap.span, fluent::unwrap_label)\n-                                .note(fluent::note)\n-                                .help(fluent::help)\n-                        },\n+                        CStringPtr { as_ptr: as_ptr_span, unwrap: unwrap.span },\n                     );\n                 }\n             }"}, {"sha": "f130a98185d611aeb243c676e8b428d1c1068a01", "filename": "compiler/rustc_lint/src/non_ascii_idents.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,7 +1,10 @@\n+use crate::lints::{\n+    ConfusableIdentifierPair, IdentifierNonAsciiChar, IdentifierUncommonCodepoints,\n+    MixedScriptConfusables,\n+};\n use crate::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::fluent;\n use rustc_span::symbol::Symbol;\n \n declare_lint! {\n@@ -180,21 +183,11 @@ impl EarlyLintPass for NonAsciiIdents {\n                 continue;\n             }\n             has_non_ascii_idents = true;\n-            cx.struct_span_lint(\n-                NON_ASCII_IDENTS,\n-                sp,\n-                fluent::lint_identifier_non_ascii_char,\n-                |lint| lint,\n-            );\n+            cx.emit_spanned_lint(NON_ASCII_IDENTS, sp, IdentifierNonAsciiChar);\n             if check_uncommon_codepoints\n                 && !symbol_str.chars().all(GeneralSecurityProfile::identifier_allowed)\n             {\n-                cx.struct_span_lint(\n-                    UNCOMMON_CODEPOINTS,\n-                    sp,\n-                    fluent::lint_identifier_uncommon_codepoints,\n-                    |lint| lint,\n-                )\n+                cx.emit_spanned_lint(UNCOMMON_CODEPOINTS, sp, IdentifierUncommonCodepoints);\n             }\n         }\n \n@@ -222,14 +215,13 @@ impl EarlyLintPass for NonAsciiIdents {\n                     .entry(skeleton_sym)\n                     .and_modify(|(existing_symbol, existing_span, existing_is_ascii)| {\n                         if !*existing_is_ascii || !is_ascii {\n-                            cx.struct_span_lint(\n+                            cx.emit_spanned_lint(\n                                 CONFUSABLE_IDENTS,\n                                 sp,\n-                                fluent::lint_confusable_identifier_pair,\n-                                |lint| {\n-                                    lint.set_arg(\"existing_sym\", *existing_symbol)\n-                                        .set_arg(\"sym\", symbol)\n-                                        .span_label(*existing_span, fluent::label)\n+                                ConfusableIdentifierPair {\n+                                    existing_sym: *existing_symbol,\n+                                    sym: symbol,\n+                                    label: *existing_span,\n                                 },\n                             );\n                         }\n@@ -331,24 +323,18 @@ impl EarlyLintPass for NonAsciiIdents {\n                 }\n \n                 for ((sp, ch_list), script_set) in lint_reports {\n-                    cx.struct_span_lint(\n+                    let mut includes = String::new();\n+                    for (idx, ch) in ch_list.into_iter().enumerate() {\n+                        if idx != 0 {\n+                            includes += \", \";\n+                        }\n+                        let char_info = format!(\"'{}' (U+{:04X})\", ch, ch as u32);\n+                        includes += &char_info;\n+                    }\n+                    cx.emit_spanned_lint(\n                         MIXED_SCRIPT_CONFUSABLES,\n                         sp,\n-                        fluent::lint_mixed_script_confusables,\n-                        |lint| {\n-                            let mut includes = String::new();\n-                            for (idx, ch) in ch_list.into_iter().enumerate() {\n-                                if idx != 0 {\n-                                    includes += \", \";\n-                                }\n-                                let char_info = format!(\"'{}' (U+{:04X})\", ch, ch as u32);\n-                                includes += &char_info;\n-                            }\n-                            lint.set_arg(\"set\", script_set.to_string())\n-                                .set_arg(\"includes\", includes)\n-                                .note(fluent::includes_note)\n-                                .note(fluent::note)\n-                        },\n+                        MixedScriptConfusables { set: script_set.to_string(), includes },\n                     );\n                 }\n             }"}, {"sha": "4a02c6cce47ed92de0385735b7e5e896ebac460a", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,3 +1,4 @@\n+use crate::lints::{NonFmtPanicBraces, NonFmtPanicUnused};\n use crate::{LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_errors::{fluent, Applicability};\n@@ -118,6 +119,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n         arg_span = expn.call_site;\n     }\n \n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     cx.struct_span_lint(NON_FMT_PANICS, arg_span, fluent::lint_non_fmt_panic, |lint| {\n         lint.set_arg(\"name\", symbol);\n         lint.note(fluent::note);\n@@ -253,25 +255,14 @@ fn check_panic_str<'tcx>(\n                 .map(|span| fmt_span.from_inner(InnerSpan::new(span.start, span.end)))\n                 .collect(),\n         };\n-        cx.struct_span_lint(NON_FMT_PANICS, arg_spans, fluent::lint_non_fmt_panic_unused, |lint| {\n-            lint.set_arg(\"count\", n_arguments);\n-            lint.note(fluent::note);\n-            if is_arg_inside_call(arg.span, span) {\n-                lint.span_suggestion(\n-                    arg.span.shrink_to_hi(),\n-                    fluent::add_args_suggestion,\n-                    \", ...\",\n-                    Applicability::HasPlaceholders,\n-                );\n-                lint.span_suggestion(\n-                    arg.span.shrink_to_lo(),\n-                    fluent::add_fmt_suggestion,\n-                    \"\\\"{}\\\", \",\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            lint\n-        });\n+        cx.emit_spanned_lint(\n+            NON_FMT_PANICS,\n+            arg_spans,\n+            NonFmtPanicUnused {\n+                count: n_arguments,\n+                suggestion: is_arg_inside_call(arg.span, span).then_some(arg.span),\n+            },\n+        );\n     } else {\n         let brace_spans: Option<Vec<_>> =\n             snippet.filter(|s| s.starts_with('\"') || s.starts_with(\"r#\")).map(|s| {\n@@ -281,22 +272,12 @@ fn check_panic_str<'tcx>(\n                     .collect()\n             });\n         let count = brace_spans.as_ref().map(|v| v.len()).unwrap_or(/* any number >1 */ 2);\n-        cx.struct_span_lint(\n+        cx.emit_spanned_lint(\n             NON_FMT_PANICS,\n             brace_spans.unwrap_or_else(|| vec![span]),\n-            fluent::lint_non_fmt_panic_braces,\n-            |lint| {\n-                lint.set_arg(\"count\", count);\n-                lint.note(fluent::note);\n-                if is_arg_inside_call(arg.span, span) {\n-                    lint.span_suggestion(\n-                        arg.span.shrink_to_lo(),\n-                        fluent::suggestion,\n-                        \"\\\"{}\\\", \",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                lint\n+            NonFmtPanicBraces {\n+                count,\n+                suggestion: is_arg_inside_call(arg.span, span).then_some(arg.span.shrink_to_lo()),\n             },\n         );\n     }"}, {"sha": "74d234fabea0872467d98c5828b39e472ddc9e0f", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 49, "deletions": 80, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,7 +1,10 @@\n+use crate::lints::{\n+    NonCamelCaseType, NonCamelCaseTypeSub, NonSnakeCaseDiag, NonSnakeCaseDiagSub,\n+    NonUpperCaseGlobal, NonUpperCaseGlobalSub,\n+};\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_attr as attr;\n-use rustc_errors::{fluent, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::FnKind;\n@@ -136,30 +139,17 @@ impl NonCamelCaseTypes {\n         let name = ident.name.as_str();\n \n         if !is_camel_case(name) {\n-            cx.struct_span_lint(\n+            let cc = to_camel_case(name);\n+            let sub = if *name != cc {\n+                NonCamelCaseTypeSub::Suggestion { span: ident.span, replace: cc }\n+            } else {\n+                NonCamelCaseTypeSub::Label { span: ident.span }\n+            };\n+            cx.emit_spanned_lint(\n                 NON_CAMEL_CASE_TYPES,\n                 ident.span,\n-                fluent::lint_non_camel_case_type,\n-                |lint| {\n-                    let cc = to_camel_case(name);\n-                    // We cannot provide meaningful suggestions\n-                    // if the characters are in the category of \"Lowercase Letter\".\n-                    if *name != cc {\n-                        lint.span_suggestion(\n-                            ident.span,\n-                            fluent::suggestion,\n-                            to_camel_case(name),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        lint.span_label(ident.span, fluent::label);\n-                    }\n-\n-                    lint.set_arg(\"sort\", sort);\n-                    lint.set_arg(\"name\", name);\n-                    lint\n-                },\n-            )\n+                NonCamelCaseType { sort, name, sub },\n+            );\n         }\n     }\n }\n@@ -294,47 +284,37 @@ impl NonSnakeCase {\n         let name = ident.name.as_str();\n \n         if !is_snake_case(name) {\n-            cx.struct_span_lint(NON_SNAKE_CASE, ident.span, fluent::lint_non_snake_case, |lint| {\n-                let sc = NonSnakeCase::to_snake_case(name);\n-                // We cannot provide meaningful suggestions\n-                // if the characters are in the category of \"Uppercase Letter\".\n-                if name != sc {\n-                    // We have a valid span in almost all cases, but we don't have one when linting a crate\n-                    // name provided via the command line.\n-                    if !ident.span.is_dummy() {\n-                        let sc_ident = Ident::from_str_and_span(&sc, ident.span);\n-                        let (message, suggestion) = if sc_ident.is_reserved() {\n-                            // We shouldn't suggest a reserved identifier to fix non-snake-case identifiers.\n-                            // Instead, recommend renaming the identifier entirely or, if permitted,\n-                            // escaping it to create a raw identifier.\n-                            if sc_ident.name.can_be_raw() {\n-                                (fluent::rename_or_convert_suggestion, sc_ident.to_string())\n-                            } else {\n-                                lint.note(fluent::cannot_convert_note);\n-                                (fluent::rename_suggestion, String::new())\n+            let span = ident.span;\n+            let sc = NonSnakeCase::to_snake_case(name);\n+            // We cannot provide meaningful suggestions\n+            // if the characters are in the category of \"Uppercase Letter\".\n+            let sub = if name != sc {\n+                // We have a valid span in almost all cases, but we don't have one when linting a crate\n+                // name provided via the command line.\n+                if !span.is_dummy() {\n+                    let sc_ident = Ident::from_str_and_span(&sc, span);\n+                    if sc_ident.is_reserved() {\n+                        // We shouldn't suggest a reserved identifier to fix non-snake-case identifiers.\n+                        // Instead, recommend renaming the identifier entirely or, if permitted,\n+                        // escaping it to create a raw identifier.\n+                        if sc_ident.name.can_be_raw() {\n+                            NonSnakeCaseDiagSub::RenameOrConvertSuggestion {\n+                                span,\n+                                suggestion: sc_ident,\n                             }\n                         } else {\n-                            (fluent::convert_suggestion, sc.clone())\n-                        };\n-\n-                        lint.span_suggestion(\n-                            ident.span,\n-                            message,\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                            NonSnakeCaseDiagSub::SuggestionAndNote { span }\n+                        }\n                     } else {\n-                        lint.help(fluent::help);\n+                        NonSnakeCaseDiagSub::ConvertSuggestion { span, suggestion: sc.clone() }\n                     }\n                 } else {\n-                    lint.span_label(ident.span, fluent::label);\n+                    NonSnakeCaseDiagSub::Help\n                 }\n-\n-                lint.set_arg(\"sort\", sort);\n-                lint.set_arg(\"name\", name);\n-                lint.set_arg(\"sc\", sc);\n-                lint\n-            });\n+            } else {\n+                NonSnakeCaseDiagSub::Label { span }\n+            };\n+            cx.emit_spanned_lint(NON_SNAKE_CASE, span, NonSnakeCaseDiag { sort, name, sc, sub });\n         }\n     }\n }\n@@ -490,30 +470,19 @@ impl NonUpperCaseGlobals {\n     fn check_upper_case(cx: &LateContext<'_>, sort: &str, ident: &Ident) {\n         let name = ident.name.as_str();\n         if name.chars().any(|c| c.is_lowercase()) {\n-            cx.struct_span_lint(\n+            let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n+            // We cannot provide meaningful suggestions\n+            // if the characters are in the category of \"Lowercase Letter\".\n+            let sub = if *name != uc {\n+                NonUpperCaseGlobalSub::Suggestion { span: ident.span, replace: uc }\n+            } else {\n+                NonUpperCaseGlobalSub::Label { span: ident.span }\n+            };\n+            cx.emit_spanned_lint(\n                 NON_UPPER_CASE_GLOBALS,\n                 ident.span,\n-                fluent::lint_non_upper_case_global,\n-                |lint| {\n-                    let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n-                    // We cannot provide meaningful suggestions\n-                    // if the characters are in the category of \"Lowercase Letter\".\n-                    if *name != uc {\n-                        lint.span_suggestion(\n-                            ident.span,\n-                            fluent::suggestion,\n-                            uc,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        lint.span_label(ident.span, fluent::label);\n-                    }\n-\n-                    lint.set_arg(\"sort\", sort);\n-                    lint.set_arg(\"name\", name);\n-                    lint\n-                },\n-            )\n+                NonUpperCaseGlobal { sort, name, sub },\n+            );\n         }\n     }\n }"}, {"sha": "d67a00619dd09eb1a5cb7fb0d3d8e0af542fd018", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,7 +1,7 @@\n use crate::context::LintContext;\n+use crate::lints::NoopMethodCallDiag;\n use crate::LateContext;\n use crate::LateLintPass;\n-use rustc_errors::fluent;\n use rustc_hir::def::DefKind;\n use rustc_hir::{Expr, ExprKind};\n use rustc_middle::ty;\n@@ -85,11 +85,10 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n         }\n         let expr_span = expr.span;\n         let span = expr_span.with_lo(receiver.span.hi());\n-        cx.struct_span_lint(NOOP_METHOD_CALL, span, fluent::lint_noop_method_call, |lint| {\n-            lint.set_arg(\"method\", call.ident.name)\n-                .set_arg(\"receiver_ty\", receiver_ty)\n-                .span_label(span, fluent::label)\n-                .note(fluent::note)\n-        });\n+        cx.emit_spanned_lint(\n+            NOOP_METHOD_CALL,\n+            span,\n+            NoopMethodCallDiag { method: call.ident.name, receiver_ty, label: span },\n+        );\n     }\n }"}, {"sha": "57482a9edba880761fd97b38a0b4dc567aba419d", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,5 +1,5 @@\n+use crate::lints::PassByValueDiag;\n use crate::{LateContext, LateLintPass, LintContext};\n-use rustc_errors::{fluent, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::{GenericArg, PathSegment, QPath, TyKind};\n@@ -29,20 +29,11 @@ impl<'tcx> LateLintPass<'tcx> for PassByValue {\n                     }\n                 }\n                 if let Some(t) = path_for_pass_by_value(cx, &inner_ty) {\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         PASS_BY_VALUE,\n                         ty.span,\n-                        fluent::lint_pass_by_value,\n-                        |lint| {\n-                            lint.set_arg(\"ty\", t.clone()).span_suggestion(\n-                                ty.span,\n-                                fluent::suggestion,\n-                                t,\n-                                // Changing type of function argument\n-                                Applicability::MaybeIncorrect,\n-                            )\n-                        },\n-                    )\n+                        PassByValueDiag { ty: t.clone(), suggestion: ty.span },\n+                    );\n                 }\n             }\n             _ => {}"}, {"sha": "9a8b14b4907eaeeac69f112a5584b8b5b57d1530", "filename": "compiler/rustc_lint/src/redundant_semicolon.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,6 +1,5 @@\n-use crate::{EarlyContext, EarlyLintPass, LintContext};\n+use crate::{lints::RedundantSemicolonsDiag, EarlyContext, EarlyLintPass, LintContext};\n use rustc_ast::{Block, StmtKind};\n-use rustc_errors::{fluent, Applicability};\n use rustc_span::Span;\n \n declare_lint! {\n@@ -48,18 +47,10 @@ fn maybe_lint_redundant_semis(cx: &EarlyContext<'_>, seq: &mut Option<(Span, boo\n             return;\n         }\n \n-        cx.struct_span_lint(\n+        cx.emit_spanned_lint(\n             REDUNDANT_SEMICOLONS,\n             span,\n-            fluent::lint_redundant_semicolons,\n-            |lint| {\n-                lint.set_arg(\"multiple\", multiple).span_suggestion(\n-                    span,\n-                    fluent::suggestion,\n-                    \"\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-            },\n+            RedundantSemicolonsDiag { multiple, suggestion: span },\n         );\n     }\n }"}, {"sha": "7ea1a138b7e60252e771b4ddffa896577a0c48b1", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,7 +1,7 @@\n+use crate::lints::{DropGlue, DropTraitConstraintsDiag};\n use crate::LateContext;\n use crate::LateLintPass;\n use crate::LintContext;\n-use rustc_errors::fluent;\n use rustc_hir as hir;\n use rustc_span::symbol::sym;\n \n@@ -101,17 +101,13 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n                 if trait_predicate.trait_ref.self_ty().is_impl_trait() {\n                     continue;\n                 }\n-                let Some(needs_drop) = cx.tcx.get_diagnostic_item(sym::needs_drop) else {\n-                    continue;\n+                let Some(def_id) = cx.tcx.get_diagnostic_item(sym::needs_drop) else {\n+                    return\n                 };\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     DROP_BOUNDS,\n                     span,\n-                    fluent::lint_drop_trait_constraints,\n-                    |lint| {\n-                        lint.set_arg(\"predicate\", predicate)\n-                            .set_arg(\"needs_drop\", cx.tcx.def_path_str(needs_drop))\n-                    },\n+                    DropTraitConstraintsDiag { predicate, tcx: cx.tcx, def_id },\n                 );\n             }\n         }\n@@ -123,12 +119,11 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n         };\n         for bound in &bounds[..] {\n             let def_id = bound.trait_ref.trait_def_id();\n-            if cx.tcx.lang_items().drop_trait() == def_id\n-                && let Some(needs_drop) = cx.tcx.get_diagnostic_item(sym::needs_drop)\n-            {\n-                cx.struct_span_lint(DYN_DROP, bound.span, fluent::lint_drop_glue, |lint| {\n-                    lint.set_arg(\"needs_drop\", cx.tcx.def_path_str(needs_drop))\n-                });\n+            if cx.tcx.lang_items().drop_trait() == def_id {\n+                let Some(def_id) = cx.tcx.get_diagnostic_item(sym::needs_drop) else {\n+                    return\n+                };\n+                cx.emit_spanned_lint(DYN_DROP, bound.span, DropGlue { tcx: cx.tcx, def_id });\n             }\n         }\n     }"}, {"sha": "f2ab44ac97c838410338ee687e3a434f81c2eb43", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 133, "deletions": 200, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,11 +1,16 @@\n+use crate::lints::{\n+    AtomicOrderingFence, AtomicOrderingLoad, AtomicOrderingStore, ImproperCTypes,\n+    InvalidAtomicOrderingDiag, OnlyCastu8ToChar, OverflowingBinHex, OverflowingBinHexSign,\n+    OverflowingBinHexSub, OverflowingInt, OverflowingIntHelp, OverflowingLiteral, OverflowingUInt,\n+    RangeEndpointOutOfRange, UnusedComparisons, VariantSizeDifferencesDiag,\n+};\n use crate::{LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{fluent, Applicability, DiagnosticMessage};\n+use rustc_errors::{fluent, DiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::{is_range_literal, Expr, ExprKind, Node};\n-use rustc_macros::LintDiagnostic;\n use rustc_middle::ty::layout::{IntegerExt, LayoutOf, SizeSkeleton};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtKind, DefIdTree, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable};\n@@ -146,32 +151,22 @@ fn lint_overflowing_range_endpoint<'tcx>(\n     };\n     let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) else { return false };\n \n-    cx.struct_span_lint(\n+    use rustc_ast::{LitIntType, LitKind};\n+    let suffix = match lit.node {\n+        LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n+        LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n+        LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n+        _ => bug!(),\n+    };\n+    cx.emit_spanned_lint(\n         OVERFLOWING_LITERALS,\n         struct_expr.span,\n-        fluent::lint_range_endpoint_out_of_range,\n-        |lint| {\n-            use ast::{LitIntType, LitKind};\n-\n-            lint.set_arg(\"ty\", ty);\n-\n-            // We need to preserve the literal's suffix,\n-            // as it may determine typing information.\n-            let suffix = match lit.node {\n-                LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n-                LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n-                LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n-                _ => bug!(),\n-            };\n-            let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n-            lint.span_suggestion(\n-                struct_expr.span,\n-                fluent::suggestion,\n-                suggestion,\n-                Applicability::MachineApplicable,\n-            );\n-\n-            lint\n+        RangeEndpointOutOfRange {\n+            ty,\n+            suggestion: struct_expr.span,\n+            start,\n+            literal: lit_val - 1,\n+            suffix,\n         },\n     );\n \n@@ -228,58 +223,37 @@ fn report_bin_hex_error(\n     val: u128,\n     negative: bool,\n ) {\n-    cx.struct_span_lint(\n-        OVERFLOWING_LITERALS,\n-        expr.span,\n-        fluent::lint_overflowing_bin_hex,\n-        |lint| {\n-            let (t, actually) = match ty {\n-                attr::IntType::SignedInt(t) => {\n-                    let actually = if negative {\n-                        -(size.sign_extend(val) as i128)\n-                    } else {\n-                        size.sign_extend(val) as i128\n-                    };\n-                    (t.name_str(), actually.to_string())\n-                }\n-                attr::IntType::UnsignedInt(t) => {\n-                    let actually = size.truncate(val);\n-                    (t.name_str(), actually.to_string())\n-                }\n+    let (t, actually) = match ty {\n+        attr::IntType::SignedInt(t) => {\n+            let actually = if negative {\n+                -(size.sign_extend(val) as i128)\n+            } else {\n+                size.sign_extend(val) as i128\n             };\n-\n-            if negative {\n-                // If the value is negative,\n-                // emits a note about the value itself, apart from the literal.\n-                lint.note(fluent::negative_note);\n-                lint.note(fluent::negative_becomes_note);\n+            (t.name_str(), actually.to_string())\n+        }\n+        attr::IntType::UnsignedInt(t) => {\n+            let actually = size.truncate(val);\n+            (t.name_str(), actually.to_string())\n+        }\n+    };\n+    let sign =\n+        if negative { OverflowingBinHexSign::Negative } else { OverflowingBinHexSign::Positive };\n+    let sub = get_type_suggestion(cx.typeck_results().node_type(expr.hir_id), val, negative).map(\n+        |suggestion_ty| {\n+            if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n+                let (sans_suffix, _) = repr_str.split_at(pos);\n+                OverflowingBinHexSub::Suggestion { span: expr.span, suggestion_ty, sans_suffix }\n             } else {\n-                lint.note(fluent::positive_note);\n-            }\n-            if let Some(sugg_ty) =\n-                get_type_suggestion(cx.typeck_results().node_type(expr.hir_id), val, negative)\n-            {\n-                lint.set_arg(\"suggestion_ty\", sugg_ty);\n-                if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n-                    let (sans_suffix, _) = repr_str.split_at(pos);\n-                    lint.span_suggestion(\n-                        expr.span,\n-                        fluent::suggestion,\n-                        format!(\"{}{}\", sans_suffix, sugg_ty),\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    lint.help(fluent::help);\n-                }\n+                OverflowingBinHexSub::Help { suggestion_ty }\n             }\n-            lint.set_arg(\"ty\", t)\n-                .set_arg(\"lit\", repr_str)\n-                .set_arg(\"dec\", val)\n-                .set_arg(\"actually\", actually);\n-\n-            lint\n         },\n     );\n+    cx.emit_spanned_lint(\n+        OVERFLOWING_LITERALS,\n+        expr.span,\n+        OverflowingBinHex { ty: t, lit: repr_str.clone(), dec: val, actually, sign, sub },\n+    )\n }\n \n // This function finds the next fitting type and generates a suggestion string.\n@@ -363,28 +337,19 @@ fn lint_int_literal<'tcx>(\n             return;\n         }\n \n-        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint_overflowing_int, |lint| {\n-            lint.set_arg(\"ty\", t.name_str())\n-                .set_arg(\n-                    \"lit\",\n-                    cx.sess()\n-                        .source_map()\n-                        .span_to_snippet(lit.span)\n-                        .expect(\"must get snippet from literal\"),\n-                )\n-                .set_arg(\"min\", min)\n-                .set_arg(\"max\", max)\n-                .note(fluent::note);\n-\n-            if let Some(sugg_ty) =\n-                get_type_suggestion(cx.typeck_results().node_type(e.hir_id), v, negative)\n-            {\n-                lint.set_arg(\"suggestion_ty\", sugg_ty);\n-                lint.help(fluent::help);\n-            }\n-\n-            lint\n-        });\n+        let lit = cx\n+            .sess()\n+            .source_map()\n+            .span_to_snippet(lit.span)\n+            .expect(\"must get snippet from literal\");\n+        let help = get_type_suggestion(cx.typeck_results().node_type(e.hir_id), v, negative)\n+            .map(|suggestion_ty| OverflowingIntHelp { suggestion_ty });\n+\n+        cx.emit_spanned_lint(\n+            OVERFLOWING_LITERALS,\n+            e.span,\n+            OverflowingInt { ty: t.name_str(), lit, min, max, help },\n+        );\n     }\n }\n \n@@ -408,18 +373,10 @@ fn lint_uint_literal<'tcx>(\n             match par_e.kind {\n                 hir::ExprKind::Cast(..) => {\n                     if let ty::Char = cx.typeck_results().expr_ty(par_e).kind() {\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             OVERFLOWING_LITERALS,\n                             par_e.span,\n-                            fluent::lint_only_cast_u8_to_char,\n-                            |lint| {\n-                                lint.span_suggestion(\n-                                    par_e.span,\n-                                    fluent::suggestion,\n-                                    format!(\"'\\\\u{{{:X}}}'\", lit_val),\n-                                    Applicability::MachineApplicable,\n-                                )\n-                            },\n+                            OnlyCastu8ToChar { span: par_e.span, literal: lit_val },\n                         );\n                         return;\n                     }\n@@ -443,19 +400,20 @@ fn lint_uint_literal<'tcx>(\n             );\n             return;\n         }\n-        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint_overflowing_uint, |lint| {\n-            lint.set_arg(\"ty\", t.name_str())\n-                .set_arg(\n-                    \"lit\",\n-                    cx.sess()\n-                        .source_map()\n-                        .span_to_snippet(lit.span)\n-                        .expect(\"must get snippet from literal\"),\n-                )\n-                .set_arg(\"min\", min)\n-                .set_arg(\"max\", max)\n-                .note(fluent::note)\n-        });\n+        cx.emit_spanned_lint(\n+            OVERFLOWING_LITERALS,\n+            e.span,\n+            OverflowingUInt {\n+                ty: t.name_str(),\n+                lit: cx\n+                    .sess()\n+                    .source_map()\n+                    .span_to_snippet(lit.span)\n+                    .expect(\"must get snippet from literal\"),\n+                min,\n+                max,\n+            },\n+        );\n     }\n }\n \n@@ -484,20 +442,16 @@ fn lint_literal<'tcx>(\n                 _ => bug!(),\n             };\n             if is_infinite == Ok(true) {\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     OVERFLOWING_LITERALS,\n                     e.span,\n-                    fluent::lint_overflowing_literal,\n-                    |lint| {\n-                        lint.set_arg(\"ty\", t.name_str())\n-                            .set_arg(\n-                                \"lit\",\n-                                cx.sess()\n-                                    .source_map()\n-                                    .span_to_snippet(lit.span)\n-                                    .expect(\"must get snippet from literal\"),\n-                            )\n-                            .note(fluent::note)\n+                    OverflowingLiteral {\n+                        ty: t.name_str(),\n+                        lit: cx\n+                            .sess()\n+                            .source_map()\n+                            .span_to_snippet(lit.span)\n+                            .expect(\"must get snippet from literal\"),\n                     },\n                 );\n             }\n@@ -517,12 +471,7 @@ impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n             }\n             hir::ExprKind::Binary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx, binop, &l, &r) {\n-                    cx.struct_span_lint(\n-                        UNUSED_COMPARISONS,\n-                        e.span,\n-                        fluent::lint_unused_comparisons,\n-                        |lint| lint,\n-                    );\n+                    cx.emit_spanned_lint(UNUSED_COMPARISONS, e.span, UnusedComparisons);\n                 }\n             }\n             hir::ExprKind::Lit(ref lit) => lint_literal(cx, self, e, lit),\n@@ -878,39 +827,39 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     ) -> FfiResult<'tcx> {\n         use FfiResult::*;\n \n-        if def.repr().transparent() {\n+        let transparent_safety = def.repr().transparent().then(|| {\n             // Can assume that at most one field is not a ZST, so only check\n             // that field's type for FFI-safety.\n             if let Some(field) = transparent_newtype_field(self.cx.tcx, variant) {\n-                self.check_field_type_for_ffi(cache, field, substs)\n+                return self.check_field_type_for_ffi(cache, field, substs);\n             } else {\n                 // All fields are ZSTs; this means that the type should behave\n-                // like (), which is FFI-unsafe\n+                // like (), which is FFI-unsafe... except if all fields are PhantomData,\n+                // which is tested for below\n                 FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_struct_zst, help: None }\n             }\n-        } else {\n-            // We can't completely trust repr(C) markings; make sure the fields are\n-            // actually safe.\n-            let mut all_phantom = !variant.fields.is_empty();\n-            for field in &variant.fields {\n-                match self.check_field_type_for_ffi(cache, &field, substs) {\n-                    FfiSafe => {\n-                        all_phantom = false;\n-                    }\n-                    FfiPhantom(..) if def.is_enum() => {\n-                        return FfiUnsafe {\n-                            ty,\n-                            reason: fluent::lint_improper_ctypes_enum_phantomdata,\n-                            help: None,\n-                        };\n-                    }\n-                    FfiPhantom(..) => {}\n-                    r => return r,\n+        });\n+        // We can't completely trust repr(C) markings; make sure the fields are\n+        // actually safe.\n+        let mut all_phantom = !variant.fields.is_empty();\n+        for field in &variant.fields {\n+            match self.check_field_type_for_ffi(cache, &field, substs) {\n+                FfiSafe => {\n+                    all_phantom = false;\n+                }\n+                FfiPhantom(..) if !def.repr().transparent() && def.is_enum() => {\n+                    return FfiUnsafe {\n+                        ty,\n+                        reason: fluent::lint_improper_ctypes_enum_phantomdata,\n+                        help: None,\n+                    };\n                 }\n+                FfiPhantom(..) => {}\n+                r => return transparent_safety.unwrap_or(r),\n             }\n-\n-            if all_phantom { FfiPhantom(ty) } else { FfiSafe }\n         }\n+\n+        if all_phantom { FfiPhantom(ty) } else { transparent_safety.unwrap_or(FfiSafe) }\n     }\n \n     /// Checks if the given type is \"ffi-safe\" (has a stable, well-defined\n@@ -1174,26 +1123,21 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             CItemKind::Declaration => IMPROPER_CTYPES,\n             CItemKind::Definition => IMPROPER_CTYPES_DEFINITIONS,\n         };\n-\n-        self.cx.struct_span_lint(lint, sp, fluent::lint_improper_ctypes, |lint| {\n-            let item_description = match self.mode {\n-                CItemKind::Declaration => \"block\",\n-                CItemKind::Definition => \"fn\",\n+        let desc = match self.mode {\n+            CItemKind::Declaration => \"block\",\n+            CItemKind::Definition => \"fn\",\n+        };\n+        let span_note = if let ty::Adt(def, _) = ty.kind()\n+            && let Some(sp) = self.cx.tcx.hir().span_if_local(def.did()) {\n+                Some(sp)\n+            } else {\n+                None\n             };\n-            lint.set_arg(\"ty\", ty);\n-            lint.set_arg(\"desc\", item_description);\n-            lint.span_label(sp, fluent::label);\n-            if let Some(help) = help {\n-                lint.help(help);\n-            }\n-            lint.note(note);\n-            if let ty::Adt(def, _) = ty.kind() {\n-                if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did()) {\n-                    lint.span_note(sp, fluent::note);\n-                }\n-            }\n-            lint\n-        });\n+        self.cx.emit_spanned_lint(\n+            lint,\n+            sp,\n+            ImproperCTypes { ty, desc, label: sp, help, note, span_note },\n+        );\n     }\n \n     fn check_for_opaque_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n@@ -1397,11 +1341,10 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n             // We only warn if the largest variant is at least thrice as large as\n             // the second-largest.\n             if largest > slargest * 3 && slargest > 0 {\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     VARIANT_SIZE_DIFFERENCES,\n                     enum_definition.variants[largest_index].span,\n-                    fluent::lint_variant_size_differences,\n-                    |lint| lint.set_arg(\"largest\", largest),\n+                    VariantSizeDifferencesDiag { largest },\n                 );\n             }\n         }\n@@ -1509,17 +1452,19 @@ impl InvalidAtomicOrdering {\n \n     fn check_atomic_load_store(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if let Some((method, args)) = Self::inherent_atomic_method_call(cx, expr, &[sym::load, sym::store])\n-            && let Some((ordering_arg, invalid_ordering, msg)) = match method {\n-                sym::load => Some((&args[0], sym::Release, fluent::lint_atomic_ordering_load)),\n-                sym::store => Some((&args[1], sym::Acquire, fluent::lint_atomic_ordering_store)),\n+            && let Some((ordering_arg, invalid_ordering)) = match method {\n+                sym::load => Some((&args[0], sym::Release)),\n+                sym::store => Some((&args[1], sym::Acquire)),\n                 _ => None,\n             }\n             && let Some(ordering) = Self::match_ordering(cx, ordering_arg)\n             && (ordering == invalid_ordering || ordering == sym::AcqRel)\n         {\n-            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, msg, |lint| {\n-                lint.help(fluent::help)\n-            });\n+            if method == sym::load {\n+                cx.emit_spanned_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, AtomicOrderingLoad);\n+            } else {\n+                cx.emit_spanned_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, AtomicOrderingStore);\n+            };\n         }\n     }\n \n@@ -1530,10 +1475,7 @@ impl InvalidAtomicOrdering {\n             && matches!(cx.tcx.get_diagnostic_name(def_id), Some(sym::fence | sym::compiler_fence))\n             && Self::match_ordering(cx, &args[0]) == Some(sym::Relaxed)\n         {\n-            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, args[0].span, fluent::lint_atomic_ordering_fence, |lint| {\n-                lint\n-                    .help(fluent::help)\n-            });\n+            cx.emit_spanned_lint(INVALID_ATOMIC_ORDERING, args[0].span, AtomicOrderingFence);\n         }\n     }\n \n@@ -1550,15 +1492,6 @@ impl InvalidAtomicOrdering {\n         let Some(fail_ordering) = Self::match_ordering(cx, fail_order_arg) else { return };\n \n         if matches!(fail_ordering, sym::Release | sym::AcqRel) {\n-            #[derive(LintDiagnostic)]\n-            #[diag(lint_atomic_ordering_invalid)]\n-            #[help]\n-            struct InvalidAtomicOrderingDiag {\n-                method: Symbol,\n-                #[label]\n-                fail_order_arg_span: Span,\n-            }\n-\n             cx.emit_spanned_lint(\n                 INVALID_ATOMIC_ORDERING,\n                 fail_order_arg.span,"}, {"sha": "ac2b32b44e6a1d42e16ab70e7f41872df229b829", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 67, "deletions": 102, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,9 +1,14 @@\n+use crate::lints::{\n+    PathStatementDrop, PathStatementDropSub, PathStatementNoEffect, UnusedAllocationDiag,\n+    UnusedAllocationMutDiag, UnusedClosure, UnusedDef, UnusedDelim, UnusedDelimSuggestion,\n+    UnusedGenerator, UnusedImportBracesDiag, UnusedOp, UnusedResult,\n+};\n use crate::Lint;\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_ast::util::{classify, parser};\n use rustc_ast::{ExprKind, StmtKind};\n-use rustc_errors::{fluent, pluralize, Applicability, MultiSpan};\n+use rustc_errors::{pluralize, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -163,23 +168,20 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n         let mut op_warned = false;\n \n         if let Some(must_use_op) = must_use_op {\n-            cx.struct_span_lint(UNUSED_MUST_USE, expr.span, fluent::lint_unused_op, |lint| {\n-                lint.set_arg(\"op\", must_use_op)\n-                    .span_label(expr.span, fluent::label)\n-                    .span_suggestion_verbose(\n-                        expr.span.shrink_to_lo(),\n-                        fluent::suggestion,\n-                        \"let _ = \",\n-                        Applicability::MachineApplicable,\n-                    )\n-            });\n+            cx.emit_spanned_lint(\n+                UNUSED_MUST_USE,\n+                expr.span,\n+                UnusedOp {\n+                    op: must_use_op,\n+                    label: expr.span,\n+                    suggestion: expr.span.shrink_to_lo(),\n+                },\n+            );\n             op_warned = true;\n         }\n \n         if !(type_lint_emitted_or_suppressed || fn_warned || op_warned) {\n-            cx.struct_span_lint(UNUSED_RESULTS, s.span, fluent::lint_unused_result, |lint| {\n-                lint.set_arg(\"ty\", ty)\n-            });\n+            cx.emit_spanned_lint(UNUSED_RESULTS, s.span, UnusedResult { ty });\n         }\n \n         fn check_fn_must_use(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n@@ -402,47 +404,31 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     );\n                 }\n                 MustUsePath::Closure(span) => {\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         UNUSED_MUST_USE,\n                         *span,\n-                        fluent::lint_unused_closure,\n-                        |lint| {\n-                            // FIXME(davidtwco): this isn't properly translatable because of the\n-                            // pre/post strings\n-                            lint.set_arg(\"count\", plural_len)\n-                                .set_arg(\"pre\", descr_pre)\n-                                .set_arg(\"post\", descr_post)\n-                                .note(fluent::note)\n-                        },\n+                        UnusedClosure { count: plural_len, pre: descr_pre, post: descr_post },\n                     );\n                 }\n                 MustUsePath::Generator(span) => {\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         UNUSED_MUST_USE,\n                         *span,\n-                        fluent::lint_unused_generator,\n-                        |lint| {\n-                            // FIXME(davidtwco): this isn't properly translatable because of the\n-                            // pre/post strings\n-                            lint.set_arg(\"count\", plural_len)\n-                                .set_arg(\"pre\", descr_pre)\n-                                .set_arg(\"post\", descr_post)\n-                                .note(fluent::note)\n-                        },\n+                        UnusedGenerator { count: plural_len, pre: descr_pre, post: descr_post },\n                     );\n                 }\n                 MustUsePath::Def(span, def_id, reason) => {\n-                    cx.struct_span_lint(UNUSED_MUST_USE, *span, fluent::lint_unused_def, |lint| {\n-                        // FIXME(davidtwco): this isn't properly translatable because of the pre/post\n-                        // strings\n-                        lint.set_arg(\"pre\", descr_pre);\n-                        lint.set_arg(\"post\", descr_post);\n-                        lint.set_arg(\"def\", cx.tcx.def_path_str(*def_id));\n-                        if let Some(note) = reason {\n-                            lint.note(note.as_str());\n-                        }\n-                        lint\n-                    });\n+                    cx.emit_spanned_lint(\n+                        UNUSED_MUST_USE,\n+                        *span,\n+                        UnusedDef {\n+                            pre: descr_pre,\n+                            post: descr_post,\n+                            cx,\n+                            def_id: *def_id,\n+                            note: *reason,\n+                        },\n+                    );\n                 }\n             }\n         }\n@@ -478,31 +464,15 @@ impl<'tcx> LateLintPass<'tcx> for PathStatements {\n             if let hir::ExprKind::Path(_) = expr.kind {\n                 let ty = cx.typeck_results().expr_ty(expr);\n                 if ty.needs_drop(cx.tcx, cx.param_env) {\n-                    cx.struct_span_lint(\n-                        PATH_STATEMENTS,\n-                        s.span,\n-                        fluent::lint_path_statement_drop,\n-                        |lint| {\n-                            if let Ok(snippet) = cx.sess().source_map().span_to_snippet(expr.span) {\n-                                lint.span_suggestion(\n-                                    s.span,\n-                                    fluent::suggestion,\n-                                    format!(\"drop({});\", snippet),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            } else {\n-                                lint.span_help(s.span, fluent::suggestion);\n-                            }\n-                            lint\n-                        },\n-                    );\n+                    let sub = if let Ok(snippet) = cx.sess().source_map().span_to_snippet(expr.span)\n+                    {\n+                        PathStatementDropSub::Suggestion { span: s.span, snippet }\n+                    } else {\n+                        PathStatementDropSub::Help { span: s.span }\n+                    };\n+                    cx.emit_spanned_lint(PATH_STATEMENTS, s.span, PathStatementDrop { sub })\n                 } else {\n-                    cx.struct_span_lint(\n-                        PATH_STATEMENTS,\n-                        s.span,\n-                        fluent::lint_path_statement_no_effect,\n-                        |lint| lint,\n-                    );\n+                    cx.emit_spanned_lint(PATH_STATEMENTS, s.span, PathStatementNoEffect);\n                 }\n             }\n         }\n@@ -695,36 +665,35 @@ trait UnusedDelimLint {\n         } else {\n             MultiSpan::from(value_span)\n         };\n-        cx.struct_span_lint(self.lint(), primary_span, fluent::lint_unused_delim, |lint| {\n-            lint.set_arg(\"delim\", Self::DELIM_STR);\n-            lint.set_arg(\"item\", msg);\n-            if let Some((lo, hi)) = spans {\n-                let sm = cx.sess().source_map();\n-                let lo_replace =\n+        let suggestion = spans.map(|(lo, hi)| {\n+            let sm = cx.sess().source_map();\n+            let lo_replace =\n                     if keep_space.0 &&\n                         let Ok(snip) = sm.span_to_prev_source(lo) && !snip.ends_with(' ') {\n-                        \" \".to_string()\n+                        \" \"\n                         } else {\n-                            \"\".to_string()\n+                            \"\"\n                         };\n \n-                let hi_replace =\n+            let hi_replace =\n                     if keep_space.1 &&\n                         let Ok(snip) = sm.span_to_next_source(hi) && !snip.starts_with(' ') {\n-                        \" \".to_string()\n+                        \" \"\n                         } else {\n-                            \"\".to_string()\n+                            \"\"\n                         };\n-\n-                let replacement = vec![(lo, lo_replace), (hi, hi_replace)];\n-                lint.multipart_suggestion(\n-                    fluent::suggestion,\n-                    replacement,\n-                    Applicability::MachineApplicable,\n-                );\n+            UnusedDelimSuggestion {\n+                start_span: lo,\n+                start_replace: lo_replace,\n+                end_span: hi,\n+                end_replace: hi_replace,\n             }\n-            lint\n         });\n+        cx.emit_spanned_lint(\n+            self.lint(),\n+            primary_span,\n+            UnusedDelim { delim: Self::DELIM_STR, item: msg, suggestion },\n+        );\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n@@ -1297,11 +1266,10 @@ impl UnusedImportBraces {\n                 ast::UseTreeKind::Nested(_) => return,\n             };\n \n-            cx.struct_span_lint(\n+            cx.emit_spanned_lint(\n                 UNUSED_IMPORT_BRACES,\n                 item.span,\n-                fluent::lint_unused_import_braces,\n-                |lint| lint.set_arg(\"node\", node_name),\n+                UnusedImportBracesDiag { node: node_name },\n             );\n         }\n     }\n@@ -1351,17 +1319,14 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAllocation {\n \n         for adj in cx.typeck_results().expr_adjustments(e) {\n             if let adjustment::Adjust::Borrow(adjustment::AutoBorrow::Ref(_, m)) = adj.kind {\n-                cx.struct_span_lint(\n-                    UNUSED_ALLOCATION,\n-                    e.span,\n-                    match m {\n-                        adjustment::AutoBorrowMutability::Not => fluent::lint_unused_allocation,\n-                        adjustment::AutoBorrowMutability::Mut { .. } => {\n-                            fluent::lint_unused_allocation_mut\n-                        }\n-                    },\n-                    |lint| lint,\n-                );\n+                match m {\n+                    adjustment::AutoBorrowMutability::Not => {\n+                        cx.emit_spanned_lint(UNUSED_ALLOCATION, e.span, UnusedAllocationDiag);\n+                    }\n+                    adjustment::AutoBorrowMutability::Mut { .. } => {\n+                        cx.emit_spanned_lint(UNUSED_ALLOCATION, e.span, UnusedAllocationMutDiag);\n+                    }\n+                };\n             }\n         }\n     }"}, {"sha": "f4b4c5168bfd6c392b2c6c0b4cf3f53fcf2e9d09", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -253,6 +253,19 @@ impl Level {\n         }\n     }\n \n+    pub fn to_cmd_flag(self) -> &'static str {\n+        match self {\n+            Level::Warn => \"-W\",\n+            Level::Deny => \"-D\",\n+            Level::Forbid => \"-F\",\n+            Level::Allow => \"-A\",\n+            Level::ForceWarn(_) => \"--force-warn\",\n+            Level::Expect(_) => {\n+                unreachable!(\"the expect level does not have a commandline flag\")\n+            }\n+        }\n+    }\n+\n     pub fn is_error(self) -> bool {\n         match self {\n             Level::Allow | Level::Expect(_) | Level::Warn | Level::ForceWarn(_) => false,"}, {"sha": "03e6d2149e96984846c0c90e83b0a67323e38b49", "filename": "compiler/rustc_llvm/llvm-wrapper/CoverageMappingWrapper.cpp", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -28,8 +28,8 @@ extern \"C\" void LLVMRustCoverageWriteFilenamesSectionToBuffer(\n   for (size_t i = 0; i < FilenamesLen; i++) {\n     FilenameRefs.push_back(std::string(Filenames[i]));\n   }\n-  auto FilenamesWriter = coverage::CoverageFilenamesSectionWriter(\n-    makeArrayRef(FilenameRefs));\n+  auto FilenamesWriter =\n+      coverage::CoverageFilenamesSectionWriter(ArrayRef<std::string>(FilenameRefs));\n   RawRustStringOstream OS(BufferOut);\n   FilenamesWriter.write(OS);\n }\n@@ -45,15 +45,16 @@ extern \"C\" void LLVMRustCoverageWriteMappingToBuffer(\n   // Convert from FFI representation to LLVM representation.\n   SmallVector<coverage::CounterMappingRegion, 0> MappingRegions;\n   MappingRegions.reserve(NumMappingRegions);\n-  for (const auto &Region : makeArrayRef(RustMappingRegions, NumMappingRegions)) {\n+  for (const auto &Region : ArrayRef<LLVMRustCounterMappingRegion>(\n+           RustMappingRegions, NumMappingRegions)) {\n     MappingRegions.emplace_back(\n         Region.Count, Region.FalseCount, Region.FileID, Region.ExpandedFileID,\n         Region.LineStart, Region.ColumnStart, Region.LineEnd, Region.ColumnEnd,\n         Region.Kind);\n   }\n   auto CoverageMappingWriter = coverage::CoverageMappingWriter(\n-      makeArrayRef(VirtualFileMappingIDs, NumVirtualFileMappingIDs),\n-      makeArrayRef(Expressions, NumExpressions),\n+      ArrayRef<unsigned>(VirtualFileMappingIDs, NumVirtualFileMappingIDs),\n+      ArrayRef<coverage::CounterExpression>(Expressions, NumExpressions),\n       MappingRegions);\n   RawRustStringOstream OS(BufferOut);\n   CoverageMappingWriter.write(OS);"}, {"sha": "f728bff0e3b91a3a1665ae58eab72654474ed1c9", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -461,7 +461,7 @@ extern \"C\" void LLVMRustAddLibraryInfo(LLVMPassManagerRef PMR, LLVMModuleRef M,\n \n extern \"C\" void LLVMRustSetLLVMOptions(int Argc, char **Argv) {\n   // Initializing the command-line options more than once is not allowed. So,\n-  // check if they've already been initialized.  (This could happen if we're\n+  // check if they've already been initialized. (This could happen if we're\n   // being called from rustpkg, for example). If the arguments change, then\n   // that's just kinda unfortunate.\n   static bool Initialized = false;\n@@ -1428,7 +1428,7 @@ LLVMRustThinLTOBufferLen(const LLVMRustThinLTOBuffer *Buffer) {\n }\n \n // This is what we used to parse upstream bitcode for actual ThinLTO\n-// processing.  We'll call this once per module optimized through ThinLTO, and\n+// processing. We'll call this once per module optimized through ThinLTO, and\n // it'll be called concurrently on many threads.\n extern \"C\" LLVMModuleRef\n LLVMRustParseBitcodeForLTO(LLVMContextRef Context,"}, {"sha": "8f94e8a4ab2e1d2422d009ec6665eeb7e209ab88", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -257,7 +257,7 @@ template<typename T> static inline void AddAttributes(T *t, unsigned Index,\n   PALNew = PAL.addAttributes(t->getContext(), Index, B);\n #else\n   AttrBuilder B(t->getContext());\n-  for (LLVMAttributeRef Attr : makeArrayRef(Attrs, AttrsLen))\n+  for (LLVMAttributeRef Attr : ArrayRef<LLVMAttributeRef>(Attrs, AttrsLen))\n     B.addAttribute(unwrap(Attr));\n   PALNew = PAL.addAttributesAtIndex(t->getContext(), Index, B);\n #endif\n@@ -1064,7 +1064,7 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateEnumerator(\n     LLVMRustDIBuilderRef Builder, const char *Name, size_t NameLen,\n     const uint64_t Value[2], unsigned SizeInBits, bool IsUnsigned) {\n   return wrap(Builder->createEnumerator(StringRef(Name, NameLen),\n-      APSInt(APInt(SizeInBits, makeArrayRef(Value, 2)), IsUnsigned)));\n+      APSInt(APInt(SizeInBits, ArrayRef<uint64_t>(Value, 2)), IsUnsigned)));\n }\n \n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateEnumerationType(\n@@ -1477,7 +1477,7 @@ extern \"C\" void LLVMRustAddHandler(LLVMValueRef CatchSwitchRef,\n extern \"C\" OperandBundleDef *LLVMRustBuildOperandBundleDef(const char *Name,\n                                                            LLVMValueRef *Inputs,\n                                                            unsigned NumInputs) {\n-  return new OperandBundleDef(Name, makeArrayRef(unwrap(Inputs), NumInputs));\n+  return new OperandBundleDef(Name, ArrayRef<Value*>(unwrap(Inputs), NumInputs));\n }\n \n extern \"C\" void LLVMRustFreeOperandBundleDef(OperandBundleDef *Bundle) {\n@@ -1491,8 +1491,8 @@ extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMTypeRef Ty, LLVM\n   Value *Callee = unwrap(Fn);\n   FunctionType *FTy = unwrap<FunctionType>(Ty);\n   return wrap(unwrap(B)->CreateCall(\n-      FTy, Callee, makeArrayRef(unwrap(Args), NumArgs),\n-      makeArrayRef(*OpBundles, NumOpBundles)));\n+      FTy, Callee, ArrayRef<Value*>(unwrap(Args), NumArgs),\n+      ArrayRef<OperandBundleDef>(*OpBundles, NumOpBundles)));\n }\n \n extern \"C\" LLVMValueRef LLVMRustGetInstrProfIncrementIntrinsic(LLVMModuleRef M) {\n@@ -1537,8 +1537,8 @@ LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn,\n   Value *Callee = unwrap(Fn);\n   FunctionType *FTy = unwrap<FunctionType>(Ty);\n   return wrap(unwrap(B)->CreateInvoke(FTy, Callee, unwrap(Then), unwrap(Catch),\n-                                      makeArrayRef(unwrap(Args), NumArgs),\n-                                      makeArrayRef(*OpBundles, NumOpBundles),\n+                                      ArrayRef<Value*>(unwrap(Args), NumArgs),\n+                                      ArrayRef<OperandBundleDef>(*OpBundles, NumOpBundles),\n                                       Name));\n }\n "}, {"sha": "e405462bbb862268856c601acf1e0711bbce8cdd", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -382,10 +382,26 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                     return Ok(quote! { #diag.subdiagnostic(#binding); });\n                 }\n             }\n-            (Meta::List(_), \"subdiagnostic\") => {\n-                throw_invalid_attr!(attr, &meta, |diag| {\n-                    diag.help(\"`subdiagnostic` does not support nested attributes\")\n-                })\n+            (Meta::List(MetaList { ref nested, .. }), \"subdiagnostic\") => {\n+                if nested.len() == 1\n+                    && let Some(NestedMeta::Meta(Meta::Path(path))) = nested.first()\n+                    && path.is_ident(\"eager\") {\n+                        let handler = match &self.parent.kind {\n+                            DiagnosticDeriveKind::Diagnostic { handler } => handler,\n+                            DiagnosticDeriveKind::LintDiagnostic => {\n+                                throw_invalid_attr!(attr, &meta, |diag| {\n+                                    diag.help(\"eager subdiagnostics are not supported on lints\")\n+                                })\n+                            }\n+                        };\n+                        return Ok(quote! { #diag.eager_subdiagnostic(#handler, #binding); });\n+                } else {\n+                    throw_invalid_attr!(attr, &meta, |diag| {\n+                        diag.help(\n+                            \"`eager` is the only supported nested attribute for `subdiagnostic`\",\n+                        )\n+                    })\n+                }\n             }\n             _ => (),\n         }"}, {"sha": "bb3722fe156e03b8d01a47d6bbdfe08675e16730", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,5 +1,6 @@\n #![feature(allow_internal_unstable)]\n #![feature(if_let_guard)]\n+#![feature(let_chains)]\n #![feature(never_type)]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_span)]"}, {"sha": "f6431899731fffdeea6d97a3170f96e924ba984c", "filename": "compiler/rustc_metadata/src/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -90,7 +90,7 @@ pub fn encode_and_write_metadata(tcx: TyCtxt<'_>) -> (EncodedMetadata, bool) {\n     let _prof_timer = tcx.sess.prof.generic_activity(\"write_crate_metadata\");\n \n     // If the user requests metadata as output, rename `metadata_filename`\n-    // to the expected output `out_filename`.  The match above should ensure\n+    // to the expected output `out_filename`. The match above should ensure\n     // this file always exists.\n     let need_metadata_file = tcx.sess.opts.output_types.contains_key(&OutputType::Metadata);\n     let (metadata_filename, metadata_tmpdir) = if need_metadata_file {"}, {"sha": "0f5f74007c1060536912477a6b5815635a37a7d1", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -591,7 +591,7 @@ impl<'a> CrateLocator<'a> {\n                     Err(MetadataError::LoadFailure(err)) => {\n                         info!(\"no metadata found: {}\", err);\n                         // The file was present and created by the same compiler version, but we\n-                        // couldn't load it for some reason.  Give a hard error instead of silently\n+                        // couldn't load it for some reason. Give a hard error instead of silently\n                         // ignoring it, but only if we would have given an error anyway.\n                         self.crate_rejections\n                             .via_invalid"}, {"sha": "6f05c76e89de1adc89b5e7344f186dd3d565c8c4", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -433,10 +433,10 @@ impl<'tcx> Collector<'tcx> {\n         }\n \n         // Update kind and, optionally, the name of all native libraries\n-        // (there may be more than one) with the specified name.  If any\n+        // (there may be more than one) with the specified name. If any\n         // library is mentioned more than once, keep the latest mention\n         // of it, so that any possible dependent libraries appear before\n-        // it.  (This ensures that the linker is able to see symbols from\n+        // it. (This ensures that the linker is able to see symbols from\n         // all possible dependent libraries before linking in the library\n         // in question.)\n         for passed_lib in &self.tcx.sess.opts.libs {"}, {"sha": "6407ff7d0971400479bfd6ce40e67aefe9239dcf", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -172,7 +172,7 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for SyntaxContext {\n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for ExpnId {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) {\n         if self.krate == LOCAL_CRATE {\n-            // We will only write details for local expansions.  Non-local expansions will fetch\n+            // We will only write details for local expansions. Non-local expansions will fetch\n             // data from the corresponding crate's metadata.\n             // FIXME(#43047) FIXME(#74731) We may eventually want to avoid relying on external\n             // metadata from proc-macro crates.\n@@ -1429,7 +1429,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let instance =\n                 ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id.to_def_id()));\n             let unused = tcx.unused_generic_params(instance);\n-            if !unused.is_empty() {\n+            if !unused.all_used() {\n                 record!(self.tables.unused_generic_params[def_id.to_def_id()] <- unused);\n             }\n         }\n@@ -1686,6 +1686,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n \n             ty::Closure(_, substs) => {\n+                let constness = self.tcx.constness(def_id.to_def_id());\n+                self.tables.constness.set(def_id.to_def_id().index, constness);\n                 record!(self.tables.fn_sig[def_id.to_def_id()] <- substs.as_closure().sig());\n             }\n "}, {"sha": "bf9be714daf7e940b09c29bdc1819efee06106a6", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def::{CtorKind, DefKind};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, DefPathHash, StableCrateId};\n use rustc_hir::definitions::DefKey;\n use rustc_hir::lang_items::LangItem;\n-use rustc_index::bit_set::{BitSet, FiniteBitSet};\n+use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n@@ -22,7 +22,7 @@ use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc_middle::mir;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, ReprOptions, Ty};\n+use rustc_middle::ty::{self, ReprOptions, Ty, UnusedGenericParams};\n use rustc_middle::ty::{DeducedParamAttrs, GeneratorDiagnosticData, ParameterizedOverTcx, TyCtxt};\n use rustc_serialize::opaque::FileEncoder;\n use rustc_session::config::SymbolManglingVersion;\n@@ -384,7 +384,7 @@ define_tables! {\n     trait_item_def_id: Table<DefIndex, RawDefId>,\n     inherent_impls: Table<DefIndex, LazyArray<DefIndex>>,\n     expn_that_defined: Table<DefIndex, LazyValue<ExpnId>>,\n-    unused_generic_params: Table<DefIndex, LazyValue<FiniteBitSet<u32>>>,\n+    unused_generic_params: Table<DefIndex, LazyValue<UnusedGenericParams>>,\n     params_in_repr: Table<DefIndex, LazyValue<BitSet<u32>>>,\n     repr_options: Table<DefIndex, LazyValue<ReprOptions>>,\n     // `def_keys` and `def_path_hashes` represent a lazy version of a"}, {"sha": "9e63c2bd2216ff652f879dd787d551ce5a13471a", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -485,7 +485,9 @@ impl<'hir> Map<'hir> {\n             BodyOwnerKind::Static(mt) => ConstContext::Static(mt),\n \n             BodyOwnerKind::Fn if self.tcx.is_constructor(def_id.to_def_id()) => return None,\n-            BodyOwnerKind::Fn if self.tcx.is_const_fn_raw(def_id.to_def_id()) => {\n+            BodyOwnerKind::Fn | BodyOwnerKind::Closure\n+                if self.tcx.is_const_fn_raw(def_id.to_def_id()) =>\n+            {\n                 ConstContext::ConstFn\n             }\n             BodyOwnerKind::Fn if self.tcx.is_const_default_method(def_id.to_def_id()) => {\n@@ -580,10 +582,10 @@ impl<'hir> Map<'hir> {\n \n     /// Visits all item-likes in the crate in some deterministic (but unspecified) order. If you\n     /// need to process every item-like, and don't care about visiting nested items in a particular\n-    /// order then this method is the best choice.  If you do care about this nesting, you should\n+    /// order then this method is the best choice. If you do care about this nesting, you should\n     /// use the `tcx.hir().walk_toplevel_module`.\n     ///\n-    /// Note that this function will access HIR for all the item-likes in the crate.  If you only\n+    /// Note that this function will access HIR for all the item-likes in the crate. If you only\n     /// need to access some of them, it is usually better to manually loop on the iterators\n     /// provided by `tcx.hir_crate_items(())`.\n     ///"}, {"sha": "96d36b441f31aa4d73278d86734b8368b3faf274", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Owner<'tcx> {\n }\n \n /// Gather the LocalDefId for each item-like within a module, including items contained within\n-/// bodies.  The Ids are in visitor order.  This is used to partition a pass between modules.\n+/// bodies. The Ids are in visitor order. This is used to partition a pass between modules.\n #[derive(Debug, HashStable, Encodable, Decodable)]\n pub struct ModuleItems {\n     submodules: Box<[OwnerId]>,"}, {"sha": "614cf1a0051da8b423c96e536cb018646518ab97", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -213,9 +213,7 @@ impl QueryRegionConstraints<'_> {\n     }\n }\n \n-pub type Canonicalized<'tcx, V> = Canonical<'tcx, V>;\n-\n-pub type CanonicalizedQueryResponse<'tcx, T> = &'tcx Canonical<'tcx, QueryResponse<'tcx, T>>;\n+pub type CanonicalQueryResponse<'tcx, T> = &'tcx Canonical<'tcx, QueryResponse<'tcx, T>>;\n \n /// Indicates whether or not we were able to prove the query to be\n /// true."}, {"sha": "c61de97d53271320e7cbf5e138a3b284413626ef", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -234,16 +234,7 @@ pub fn explain_lint_level_source(\n             err.note_once(&format!(\"`#[{}({})]` on by default\", level.as_str(), name));\n         }\n         LintLevelSource::CommandLine(lint_flag_val, orig_level) => {\n-            let flag = match orig_level {\n-                Level::Warn => \"-W\",\n-                Level::Deny => \"-D\",\n-                Level::Forbid => \"-F\",\n-                Level::Allow => \"-A\",\n-                Level::ForceWarn(_) => \"--force-warn\",\n-                Level::Expect(_) => {\n-                    unreachable!(\"the expect level does not have a commandline flag\")\n-                }\n-            };\n+            let flag = orig_level.to_cmd_flag();\n             let hyphen_case_lint_name = name.replace('_', \"-\");\n             if lint_flag_val.as_str() == name {\n                 err.note_once(&format!("}, {"sha": "5f425a287687e60a562e446be171d156c959ebae", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -509,7 +509,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.reserve_and_set_dedup(GlobalAlloc::Static(static_id))\n     }\n \n-    /// Generates an `AllocId` for a function.  Depending on the function type,\n+    /// Generates an `AllocId` for a function. Depending on the function type,\n     /// this might get deduplicated or assigned a new ID each time.\n     pub fn create_fn_alloc(self, instance: Instance<'tcx>) -> AllocId {\n         // Functions cannot be identified by pointers, as asm-equal functions can get deduplicated\n@@ -518,7 +518,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // We thus generate a new `AllocId` for every mention of a function. This means that\n         // `main as fn() == main as fn()` is false, while `let x = main as fn(); x == x` is true.\n         // However, formatting code relies on function identity (see #58320), so we only do\n-        // this for generic functions.  Lifetime parameters are ignored.\n+        // this for generic functions. Lifetime parameters are ignored.\n         let is_generic = instance\n             .substs\n             .into_iter()\n@@ -535,7 +535,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    /// Generates an `AllocId` for a (symbolic, not-reified) vtable.  Will get deduplicated.\n+    /// Generates an `AllocId` for a (symbolic, not-reified) vtable. Will get deduplicated.\n     pub fn create_vtable_alloc(\n         self,\n         ty: Ty<'tcx>,"}, {"sha": "e52b243ecf635fa82eaf406ca40d5301d38e2c4a", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -2483,7 +2483,7 @@ impl<'tcx> ConstantKind<'tcx> {\n \n         // FIXME(const_generics): We currently have to special case parameters because `min_const_generics`\n         // does not provide the parents generics to anonymous constants. We still allow generic const\n-        // parameters by themselves however, e.g. `N`.  These constants would cause an ICE if we were to\n+        // parameters by themselves however, e.g. `N`. These constants would cause an ICE if we were to\n         // ever try to substitute the generic parameters in their bodies.\n         //\n         // While this doesn't happen as these constants are always used as `ty::ConstKind::Param`, it does"}, {"sha": "6e905224c1336b5d6e0d1839d078523058648834", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -74,7 +74,7 @@ impl SwitchTargets {\n     }\n \n     /// Finds the `BasicBlock` to which this `SwitchInt` will branch given the\n-    /// specific value.  This cannot fail, as it'll return the `otherwise`\n+    /// specific value. This cannot fail, as it'll return the `otherwise`\n     /// branch if there's not a specific match for the value.\n     pub fn target_for_value(&self, value: u128) -> BasicBlock {\n         self.iter().find_map(|(v, t)| (v == value).then_some(t)).unwrap_or_else(|| self.otherwise())"}, {"sha": "076ce1bdb3486f52604e53a7843c9e45356bf7ba", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1839,7 +1839,7 @@ rustc_queries! {\n         desc { \"getting codegen unit `{sym}`\" }\n     }\n \n-    query unused_generic_params(key: ty::InstanceDef<'tcx>) -> FiniteBitSet<u32> {\n+    query unused_generic_params(key: ty::InstanceDef<'tcx>) -> UnusedGenericParams {\n         cache_on_disk_if { key.def_id().is_local() }\n         desc {\n             |tcx| \"determining which generic parameters are unused by `{}`\","}, {"sha": "5f320708c8416944466a25137159b95386baee11", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -9,6 +9,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/thir.html\n \n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::RangeEnd;\n@@ -575,6 +576,12 @@ impl<'tcx> Pat<'tcx> {\n     }\n }\n \n+impl<'tcx> IntoDiagnosticArg for Pat<'tcx> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        format!(\"{}\", self).into_diagnostic_arg()\n+    }\n+}\n+\n #[derive(Clone, Debug, HashStable)]\n pub struct Ascription<'tcx> {\n     pub annotation: CanonicalUserTypeAnnotation<'tcx>,"}, {"sha": "543f5b87e00bccd3a0c887f9c06f31ce3149f923", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -15,22 +15,19 @@ use rustc_span::source_map::Span;\n \n pub mod type_op {\n     use crate::ty::fold::TypeFoldable;\n-    use crate::ty::subst::UserSubsts;\n-    use crate::ty::{Predicate, Ty};\n-    use rustc_hir::def_id::DefId;\n+    use crate::ty::{Predicate, Ty, UserType};\n     use std::fmt;\n \n     #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, Lift)]\n     #[derive(TypeFoldable, TypeVisitable)]\n     pub struct AscribeUserType<'tcx> {\n         pub mir_ty: Ty<'tcx>,\n-        pub def_id: DefId,\n-        pub user_substs: UserSubsts<'tcx>,\n+        pub user_ty: UserType<'tcx>,\n     }\n \n     impl<'tcx> AscribeUserType<'tcx> {\n-        pub fn new(mir_ty: Ty<'tcx>, def_id: DefId, user_substs: UserSubsts<'tcx>) -> Self {\n-            Self { mir_ty, def_id, user_substs }\n+        pub fn new(mir_ty: Ty<'tcx>, user_ty: UserType<'tcx>) -> Self {\n+            Self { mir_ty, user_ty }\n         }\n     }\n "}, {"sha": "1cc9fd526b44f3133445f3bb781c333f7f01f5d0", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -131,7 +131,9 @@ pub enum SelectionCandidate<'tcx> {\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous types\n     /// generated for an `||` expression.\n-    ClosureCandidate,\n+    ClosureCandidate {\n+        is_const: bool,\n+    },\n \n     /// Implementation of a `Generator` trait by one of the anonymous types\n     /// generated for a generator."}, {"sha": "b9c5a4e0d0d49b2cb028ea937c0cd79fa3d46dfb", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -89,7 +89,9 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n                 Err(TypeError::Sorts(relate::expected_found(self, a, b)))\n             }\n \n-            (&ty::Error(_), _) | (_, &ty::Error(_)) => Ok(self.tcx().ty_error()),\n+            (&ty::Error(guar), _) | (_, &ty::Error(guar)) => {\n+                Ok(self.tcx().ty_error_with_guaranteed(guar))\n+            }\n \n             _ => relate::super_relate_tys(self, a, b),\n         }"}, {"sha": "859a58c8998c770f5fe2100f836c1c60e867d4c7", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -72,7 +72,7 @@ impl AssocItem {\n             ty::AssocKind::Fn => {\n                 // We skip the binder here because the binder would deanonymize all\n                 // late-bound regions, and we don't want method signatures to show up\n-                // `as for<'r> fn(&'r MyType)`.  Pretty-printing handles late-bound\n+                // `as for<'r> fn(&'r MyType)`. Pretty-printing handles late-bound\n                 // regions just fine, showing `fn(&MyType)`.\n                 tcx.fn_sig(self.def_id).skip_binder().to_string()\n             }"}, {"sha": "c1d2672f2792df5caebb3df6721c9dd3414dc4a1", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -891,7 +891,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.dep_graph.read_index(DepNodeIndex::FOREVER_RED_NODE);\n \n         // Leak a read lock once we start iterating on definitions, to prevent adding new ones\n-        // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n+        // while iterating. If some query needs to add definitions, it should be `ensure`d above.\n         let definitions = self.untracked.definitions.leak();\n         definitions.def_path_table()\n     }\n@@ -903,7 +903,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // definitions change.\n         self.ensure().hir_crate(());\n         // Leak a read lock once we start iterating on definitions, to prevent adding new ones\n-        // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n+        // while iterating. If some query needs to add definitions, it should be `ensure`d above.\n         let definitions = self.untracked.definitions.leak();\n         definitions.def_path_hash_to_def_index_map()\n     }"}, {"sha": "5d394f71f0d764024b33c0f2e4f047a61a8743e9", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -2,10 +2,10 @@ use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty::diagnostics::suggest_constraining_type_param;\n use crate::ty::print::{with_forced_trimmed_paths, FmtPrinter, Printer};\n use crate::ty::{self, BoundRegionKind, Region, Ty, TyCtxt};\n-use hir::def::DefKind;\n use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n use rustc_errors::{pluralize, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n+use rustc_hir::def::{CtorOf, DefKind};\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Span};\n@@ -319,7 +319,11 @@ impl<'tcx> Ty<'tcx> {\n                     .into()\n                 }\n             }\n-            ty::FnDef(..) => \"fn item\".into(),\n+            ty::FnDef(def_id, ..) => match tcx.def_kind(def_id) {\n+                DefKind::Ctor(CtorOf::Struct, _) => \"struct constructor\".into(),\n+                DefKind::Ctor(CtorOf::Variant, _) => \"enum constructor\".into(),\n+                _ => \"fn item\".into(),\n+            },\n             ty::FnPtr(_) => \"fn pointer\".into(),\n             ty::Dynamic(ref inner, ..) if let Some(principal) = inner.principal() => {\n                 format!(\"trait object `dyn {}`\", tcx.def_path_str(principal.def_id())).into()\n@@ -366,7 +370,11 @@ impl<'tcx> Ty<'tcx> {\n                 _ => \"reference\",\n             }\n             .into(),\n-            ty::FnDef(..) => \"fn item\".into(),\n+            ty::FnDef(def_id, ..) => match tcx.def_kind(def_id) {\n+                DefKind::Ctor(CtorOf::Struct, _) => \"struct constructor\".into(),\n+                DefKind::Ctor(CtorOf::Variant, _) => \"enum constructor\".into(),\n+                _ => \"fn item\".into(),\n+            },\n             ty::FnPtr(_) => \"fn pointer\".into(),\n             ty::Dynamic(..) => \"trait object\".into(),\n             ty::Closure(..) => \"closure\".into(),"}, {"sha": "6b9a37d848da2966870256959d7e1d10ecb672cc", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -290,7 +290,7 @@ pub struct RegionFolder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n     /// Stores the index of a binder *just outside* the stuff we have\n-    /// visited.  So this begins as INNERMOST; when we pass through a\n+    /// visited. So this begins as INNERMOST; when we pass through a\n     /// binder, it is incremented (via `shift_in`).\n     current_index: ty::DebruijnIndex,\n "}, {"sha": "6ac00d16c53de8f859a2395f1c0ff4979653e086", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -6,6 +6,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::lang_items::LangItem;\n+use rustc_index::bit_set::FiniteBitSet;\n use rustc_macros::HashStable;\n use rustc_middle::ty::normalize_erasing_regions::NormalizationError;\n use rustc_span::Symbol;\n@@ -711,7 +712,7 @@ fn polymorphize<'tcx>(\n     }\n \n     InternalSubsts::for_item(tcx, def_id, |param, _| {\n-        let is_unused = unused.contains(param.index).unwrap_or(false);\n+        let is_unused = unused.is_unused(param.index);\n         debug!(\"polymorphize: param={:?} is_unused={:?}\", param, is_unused);\n         match param.kind {\n             // Upvar case: If parameter is a type parameter..\n@@ -733,7 +734,7 @@ fn polymorphize<'tcx>(\n             // Simple case: If parameter is a const or type parameter..\n             ty::GenericParamDefKind::Const { .. } | ty::GenericParamDefKind::Type { .. } if\n                 // ..and is within range and unused..\n-                unused.contains(param.index).unwrap_or(false) =>\n+                unused.is_unused(param.index) =>\n                     // ..then use the identity for this parameter.\n                     tcx.mk_param_from_def(param),\n \n@@ -755,14 +756,14 @@ fn needs_fn_once_adapter_shim(\n             Ok(false)\n         }\n         (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n-            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n+            // The closure fn `llfn` is a `fn(&self, ...)`. We want a\n             // `fn(&mut self, ...)`. In fact, at codegen time, these are\n             // basically the same thing, so we can just return llfn.\n             Ok(false)\n         }\n         (ty::ClosureKind::Fn | ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n             // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n-            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n+            // self, ...)`. We want a `fn(self, ...)`. We can produce\n             // this by doing something like:\n             //\n             //     fn call_once(self, ...) { call_mut(&self, ...) }\n@@ -774,3 +775,36 @@ fn needs_fn_once_adapter_shim(\n         (ty::ClosureKind::FnMut | ty::ClosureKind::FnOnce, _) => Err(()),\n     }\n }\n+\n+// Set bits represent unused generic parameters.\n+// An empty set indicates that all parameters are used.\n+#[derive(Debug, Copy, Clone, Eq, PartialEq, Decodable, Encodable, HashStable)]\n+pub struct UnusedGenericParams(FiniteBitSet<u32>);\n+\n+impl UnusedGenericParams {\n+    pub fn new_all_unused(amount: u32) -> Self {\n+        let mut bitset = FiniteBitSet::new_empty();\n+        bitset.set_range(0..amount);\n+        Self(bitset)\n+    }\n+\n+    pub fn new_all_used() -> Self {\n+        Self(FiniteBitSet::new_empty())\n+    }\n+\n+    pub fn mark_used(&mut self, idx: u32) {\n+        self.0.clear(idx);\n+    }\n+\n+    pub fn is_unused(&self, idx: u32) -> bool {\n+        self.0.contains(idx).unwrap_or(false)\n+    }\n+\n+    pub fn is_used(&self, idx: u32) -> bool {\n+        !self.is_unused(idx)\n+    }\n+\n+    pub fn all_used(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+}"}, {"sha": "dfd016569c27a51de3135d2dbcef1706291d9747", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -879,7 +879,7 @@ where\n                     //\n                     // If the niche is a pointer, it's either valid (according\n                     // to its type), or null (which the niche field's scalar\n-                    // validity range encodes).  This allows using\n+                    // validity range encodes). This allows using\n                     // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n                     // this will continue to work as long as we don't start\n                     // using more niches than just null (e.g., the first page of"}, {"sha": "1df19a2abf334b95407d8d9a262ef27c63d92f78", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -86,7 +86,7 @@ pub use self::context::{\n     tls, CtxtInterners, DeducedParamAttrs, FreeRegionInfo, GlobalCtxt, Lift, OnDiskCache, TyCtxt,\n     TyCtxtFeed,\n };\n-pub use self::instance::{Instance, InstanceDef, ShortInstance};\n+pub use self::instance::{Instance, InstanceDef, ShortInstance, UnusedGenericParams};\n pub use self::list::List;\n pub use self::parameterized::ParameterizedOverTcx;\n pub use self::rvalue_scopes::RvalueScopes;\n@@ -689,7 +689,7 @@ impl<'tcx> Predicate<'tcx> {\n         //\n         // In terms of why this is sound, the idea is that whenever there\n         // is an impl of `T:Foo<'a>`, it must show that `T:Bar<'a,'a>`\n-        // holds.  So if there is an impl of `T:Foo<'a>` that applies to\n+        // holds. So if there is an impl of `T:Foo<'a>` that applies to\n         // all `'a`, then we must know that `T:Bar<'a,'a>` holds for all\n         // `'a`.\n         //\n@@ -701,7 +701,7 @@ impl<'tcx> Predicate<'tcx> {\n         // Here, if we have `for<'x> T: Foo1<'x>`, then what do we know?\n         // The answer is that we know `for<'x,'b> T: Bar1<'x,'b>`. The\n         // reason is similar to the previous example: any impl of\n-        // `T:Foo1<'x>` must show that `for<'b> T: Bar1<'x, 'b>`.  So\n+        // `T:Foo1<'x>` must show that `for<'b> T: Bar1<'x, 'b>`. So\n         // basically we would want to collapse the bound lifetimes from\n         // the input (`trait_ref`) and the supertraits.\n         //\n@@ -1330,7 +1330,7 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n         debug!(?id_substs);\n \n         // This zip may have several times the same lifetime in `substs` paired with a different\n-        // lifetime from `id_substs`.  Simply `collect`ing the iterator is the correct behaviour:\n+        // lifetime from `id_substs`. Simply `collect`ing the iterator is the correct behaviour:\n         // it will pick the last one, which is the one we introduced in the impl-trait desugaring.\n         let map = substs.iter().zip(id_substs);\n \n@@ -2141,7 +2141,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Look up the name of a definition across crates. This does not look at HIR.\n     ///\n-    /// This method will ICE if the corresponding item does not have a name.  In these cases, use\n+    /// This method will ICE if the corresponding item does not have a name. In these cases, use\n     /// [`opt_item_name`] instead.\n     ///\n     /// [`opt_item_name`]: Self::opt_item_name\n@@ -2465,8 +2465,10 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn is_const_fn_raw(self, def_id: DefId) -> bool {\n-        matches!(self.def_kind(def_id), DefKind::Fn | DefKind::AssocFn | DefKind::Ctor(..))\n-            && self.constness(def_id) == hir::Constness::Const\n+        matches!(\n+            self.def_kind(def_id),\n+            DefKind::Fn | DefKind::AssocFn | DefKind::Ctor(..) | DefKind::Closure\n+        ) && self.constness(def_id) == hir::Constness::Const\n     }\n \n     #[inline]"}, {"sha": "72f451985796b82ac54a5809cf1f7dfd8dec9bd8", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -60,6 +60,7 @@ trivially_parameterized_over_tcx! {\n     ty::ImplPolarity,\n     ty::ReprOptions,\n     ty::TraitDef,\n+    ty::UnusedGenericParams,\n     ty::Visibility<DefIndex>,\n     ty::adjustment::CoerceUnsizedInfo,\n     ty::fast_reject::SimplifiedType,"}, {"sha": "42fc78a4715f49dd15b8508cfcfa22b9ca33b26e", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -283,6 +283,8 @@ pub trait PrettyPrinter<'tcx>:\n     /// This is typically the case for all non-`'_` regions.\n     fn should_print_region(&self, region: ty::Region<'tcx>) -> bool;\n \n+    fn reset_type_limit(&mut self) {}\n+\n     // Defaults (should not be overridden):\n \n     /// If possible, this returns a global path resolving to `def_id` that is visible\n@@ -1981,6 +1983,10 @@ impl<'tcx> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx> {\n         self.0.ty_infer_name_resolver.as_ref().and_then(|func| func(id))\n     }\n \n+    fn reset_type_limit(&mut self) {\n+        self.printed_type_count = 0;\n+    }\n+\n     fn const_infer_name(&self, id: ty::ConstVid<'tcx>) -> Option<Symbol> {\n         self.0.const_infer_name_resolver.as_ref().and_then(|func| func(id))\n     }\n@@ -2126,9 +2132,9 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n \n         let identify_regions = self.tcx.sess.opts.unstable_opts.identify_regions;\n \n-        // These printouts are concise.  They do not contain all the information\n+        // These printouts are concise. They do not contain all the information\n         // the user might want to diagnose an error, but there is basically no way\n-        // to fit that into a short string.  Hence the recommendation to use\n+        // to fit that into a short string. Hence the recommendation to use\n         // `explain_region()` or `note_and_explain_region()`.\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n@@ -2722,11 +2728,15 @@ define_print_and_forward_display! {\n     }\n \n     ty::SubtypePredicate<'tcx> {\n-        p!(print(self.a), \" <: \", print(self.b))\n+        p!(print(self.a), \" <: \");\n+        cx.reset_type_limit();\n+        p!(print(self.b))\n     }\n \n     ty::CoercePredicate<'tcx> {\n-        p!(print(self.a), \" -> \", print(self.b))\n+        p!(print(self.a), \" -> \");\n+        cx.reset_type_limit();\n+        p!(print(self.b))\n     }\n \n     ty::TraitPredicate<'tcx> {\n@@ -2738,7 +2748,9 @@ define_print_and_forward_display! {\n     }\n \n     ty::ProjectionPredicate<'tcx> {\n-        p!(print(self.projection_ty), \" == \", print(self.term))\n+        p!(print(self.projection_ty), \" == \");\n+        cx.reset_type_limit();\n+        p!(print(self.term))\n     }\n \n     ty::Term<'tcx> {"}, {"sha": "9d4ee22a7273beba58c8cb282379a132a7585c03", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -34,7 +34,7 @@ use crate::ty::layout::TyAndLayout;\n use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::GeneratorDiagnosticData;\n-use crate::ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n+use crate::ty::{self, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt, UnusedGenericParams};\n use rustc_ast as ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_attr as attr;\n@@ -50,7 +50,7 @@ use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId};\n use rustc_hir::hir_id::OwnerId;\n use rustc_hir::lang_items::{LangItem, LanguageItems};\n use rustc_hir::{Crate, ItemLocalId, TraitCandidate};\n-use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n+use rustc_index::vec::IndexVec;\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use rustc_session::cstore::{CrateDepKind, CrateSource};\n use rustc_session::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLib};"}, {"sha": "65fd8d9753de18b7ad6982fe5124671803917d2b", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -414,7 +414,7 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n             bug!(\"bound types encountered in super_relate_tys\")\n         }\n \n-        (&ty::Error(_), _) | (_, &ty::Error(_)) => Ok(tcx.ty_error()),\n+        (&ty::Error(guar), _) | (_, &ty::Error(guar)) => Ok(tcx.ty_error_with_guaranteed(guar)),\n \n         (&ty::Never, _)\n         | (&ty::Char, _)"}, {"sha": "7c5563ac1aedeb597b8646603c27017da0488232", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -455,7 +455,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n             let slot = Rc::get_mut_unchecked(&mut unique);\n \n             // Semantically move the contained type out from `unique`, fold\n-            // it, then move the folded value back into `unique`.  Should\n+            // it, then move the folded value back into `unique`. Should\n             // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n             // value is not re-dropped.\n             let owned = ManuallyDrop::take(slot);\n@@ -501,7 +501,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Arc<T> {\n             let slot = Arc::get_mut_unchecked(&mut unique);\n \n             // Semantically move the contained type out from `unique`, fold\n-            // it, then move the folded value back into `unique`.  Should\n+            // it, then move the folded value back into `unique`. Should\n             // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n             // value is not re-dropped.\n             let owned = ManuallyDrop::take(slot);"}, {"sha": "14e5f01099a0832b94fa095941dc837402babc4d", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -205,7 +205,7 @@ static_assert_size!(TyKind<'_>, 32);\n ///\n /// ## Generators\n ///\n-/// Generators are handled similarly in `GeneratorSubsts`.  The set of\n+/// Generators are handled similarly in `GeneratorSubsts`. The set of\n /// type parameters is similar, but `CK` and `CS` are replaced by the\n /// following type parameters:\n ///"}, {"sha": "1018dd7e2adf69b238e8375e2a95e077695d4493", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -397,10 +397,10 @@ impl<'tcx> TypeckResults<'tcx> {\n \n     /// Returns the type of an expression as a monotype.\n     ///\n-    /// NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n+    /// NB (1): This is the PRE-ADJUSTMENT TYPE for the expression. That is, in\n     /// some cases, we insert `Adjustment` annotations such as auto-deref or\n-    /// auto-ref.  The type returned by this function does not consider such\n-    /// adjustments.  See `expr_ty_adjusted()` instead.\n+    /// auto-ref. The type returned by this function does not consider such\n+    /// adjustments. See `expr_ty_adjusted()` instead.\n     ///\n     /// NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n     /// ask for the type of `id` in `id(3)`, it will return `fn(&isize) -> isize`\n@@ -626,7 +626,7 @@ pub struct CanonicalUserTypeAnnotation<'tcx> {\n     pub inferred_ty: Ty<'tcx>,\n }\n \n-/// Canonicalized user type annotation.\n+/// Canonical user type annotation.\n pub type CanonicalUserType<'tcx> = Canonical<'tcx, UserType<'tcx>>;\n \n impl<'tcx> CanonicalUserType<'tcx> {\n@@ -679,7 +679,7 @@ impl<'tcx> CanonicalUserType<'tcx> {\n /// from constants that are named via paths, like `Foo::<A>::new` and\n /// so forth.\n #[derive(Copy, Clone, Debug, PartialEq, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n+#[derive(Eq, Hash, HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub enum UserType<'tcx> {\n     Ty(Ty<'tcx>),\n "}, {"sha": "c621efb3b3a523e888da8f8670f926d19cb9d09c", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -27,7 +27,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// suitable also to be passed as function arguments.\n     ///\n     /// The operand returned from this function will *not be valid* after an ExprKind::Scope is\n-    /// passed, so please do *not* return it from functions to avoid bad miscompiles.  Returns an\n+    /// passed, so please do *not* return it from functions to avoid bad miscompiles. Returns an\n     /// operand suitable for use as a call argument. This is almost always equivalent to\n     /// `as_operand`, except for the particular case of passing values of (potentially) unsized\n     /// types \"by value\" (see details below)."}, {"sha": "a73ab344718a0c9ed9d745dc921a802d45a300a3", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -57,7 +57,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // question raised here -- should we \"freeze\" the\n                 // value of the lhs here?  I'm inclined to think not,\n                 // since it seems closer to the semantics of the\n-                // overloaded version, which takes `&mut self`.  This\n+                // overloaded version, which takes `&mut self`. This\n                 // only affects weird things like `x += {x += 1; x}`\n                 // -- is that equal to `x + (x + 1)` or `2*(x+1)`?\n "}, {"sha": "0961ce11e2f9a0f710d78e7bce6f96ecd496655e", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1870,7 +1870,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // ```\n         // let place = Foo::new();\n         // match place { foo if inspect(foo)\n-        //     => feed(foo), ...  }\n+        //     => feed(foo), ... }\n         // ```\n         //\n         // will be treated as if it were really something like:\n@@ -1885,7 +1885,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // ```\n         // let place = Foo::new();\n         // match place { ref mut foo if inspect(foo)\n-        //     => feed(foo), ...  }\n+        //     => feed(foo), ... }\n         // ```\n         //\n         // will be treated as if it were really something like:"}, {"sha": "ad7a568a231814fcf8c7dbe9aed308eb125716f6", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -456,7 +456,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     span: source_info.span,\n \n                     // FIXME(#54571): This constant comes from user input (a\n-                    // constant in a pattern).  Are there forms where users can add\n+                    // constant in a pattern). Are there forms where users can add\n                     // type annotations here?  For example, an associated constant?\n                     // Need to experiment.\n                     user_ty: None,\n@@ -504,7 +504,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// This is used by the overall `match_candidates` algorithm to structure\n     /// the match as a whole. See `match_candidates` for more details.\n     ///\n-    /// FIXME(#29623). In some cases, we have some tricky choices to make.  for\n+    /// FIXME(#29623). In some cases, we have some tricky choices to make. for\n     /// example, if we are testing that `x == 22`, but the candidate is `x @\n     /// 13..55`, what should we do? In the event that the test is true, we know\n     /// that the candidate applies, but in the event of false, we don't know"}, {"sha": "591b416337b3595c36380af7d0197cccf9562086", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -53,7 +53,7 @@ loop {\n ```\n \n When processing the `let x`, we will add one drop to the scope for\n-`x`.  The break will then insert a drop for `x`. When we process `let\n+`x`. The break will then insert a drop for `x`. When we process `let\n y`, we will add another drop (in fact, to a subscope, but let's ignore\n that for now); any later drops would also drop `y`.\n \n@@ -757,7 +757,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if self.tcx.sess.opts.unstable_opts.maximal_hir_to_mir_coverage {\n                 // Some consumers of rustc need to map MIR locations back to HIR nodes. Currently the\n                 // the only part of rustc that tracks MIR -> HIR is the `SourceScopeLocalData::lint_root`\n-                // field that tracks lint levels for MIR locations.  Normally the number of source scopes\n+                // field that tracks lint levels for MIR locations. Normally the number of source scopes\n                 // is limited to the set of nodes with lint annotations. The -Zmaximal-hir-to-mir-coverage\n                 // flag changes this behavior to maximize the number of source scopes, increasing the\n                 // granularity of the MIR->HIR mapping."}, {"sha": "06523b0a1de84cb658fc3e410bb4d61837eeeec9", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 235, "deletions": 1, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,9 +1,13 @@\n+use crate::thir::pattern::deconstruct_pat::DeconstructedPat;\n use crate::thir::pattern::MatchCheckCtxt;\n use rustc_errors::Handler;\n use rustc_errors::{\n-    error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, MultiSpan,\n+    error_code, AddToDiagnostic, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+    IntoDiagnostic, MultiSpan, SubdiagnosticMessage,\n };\n+use rustc_hir::def::Res;\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n+use rustc_middle::thir::Pat;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::{symbol::Ident, Span};\n \n@@ -493,6 +497,16 @@ pub struct LowerRangeBoundMustBeLessThanOrEqualToUpper {\n     pub teach: Option<()>,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(mir_build_literal_in_range_out_of_bounds)]\n+pub struct LiteralOutOfRange<'tcx> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub max: u128,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(mir_build_lower_range_bound_must_be_less_than_upper, code = \"E0579\")]\n pub struct LowerRangeBoundMustBeLessThanUpper {\n@@ -614,3 +628,223 @@ pub enum MultipleMutBorrowOccurence {\n         name_moved: Ident,\n     },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_union_pattern)]\n+pub struct UnionPattern {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_type_not_structural)]\n+pub struct TypeNotStructural<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_invalid_pattern)]\n+pub struct InvalidPattern<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_unsized_pattern)]\n+pub struct UnsizedPattern<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_float_pattern)]\n+pub struct FloatPattern;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_pointer_pattern)]\n+pub struct PointerPattern;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_indirect_structural_match)]\n+pub struct IndirectStructuralMatch<'tcx> {\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_nontrivial_structural_match)]\n+pub struct NontrivialStructuralMatch<'tcx> {\n+    pub non_sm_ty: Ty<'tcx>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_overlapping_range_endpoints)]\n+#[note]\n+pub struct OverlappingRangeEndpoints<'tcx> {\n+    #[label(range)]\n+    pub range: Span,\n+    #[subdiagnostic]\n+    pub overlap: Vec<Overlap<'tcx>>,\n+}\n+\n+pub struct Overlap<'tcx> {\n+    pub span: Span,\n+    pub range: Pat<'tcx>,\n+}\n+\n+impl<'tcx> AddToDiagnostic for Overlap<'tcx> {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        let Overlap { span, range } = self;\n+\n+        // FIXME(mejrs) unfortunately `#[derive(LintDiagnostic)]`\n+        // does not support `#[subdiagnostic(eager)]`...\n+        let message = format!(\"this range overlaps on `{range}`...\");\n+        diag.span_label(span, message);\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_build_non_exhaustive_omitted_pattern)]\n+#[help]\n+#[note]\n+pub(crate) struct NonExhaustiveOmittedPattern<'tcx> {\n+    pub scrut_ty: Ty<'tcx>,\n+    #[subdiagnostic]\n+    pub uncovered: Uncovered<'tcx>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(mir_build_uncovered)]\n+pub(crate) struct Uncovered<'tcx> {\n+    #[primary_span]\n+    span: Span,\n+    count: usize,\n+    witness_1: Pat<'tcx>,\n+    witness_2: Pat<'tcx>,\n+    witness_3: Pat<'tcx>,\n+    remainder: usize,\n+}\n+\n+impl<'tcx> Uncovered<'tcx> {\n+    pub fn new<'p>(\n+        span: Span,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n+    ) -> Self {\n+        let witness_1 = witnesses.get(0).unwrap().to_pat(cx);\n+        Self {\n+            span,\n+            count: witnesses.len(),\n+            // Substitute dummy values if witnesses is smaller than 3. These will never be read.\n+            witness_2: witnesses.get(1).map(|w| w.to_pat(cx)).unwrap_or_else(|| witness_1.clone()),\n+            witness_3: witnesses.get(2).map(|w| w.to_pat(cx)).unwrap_or_else(|| witness_1.clone()),\n+            witness_1,\n+            remainder: witnesses.len().saturating_sub(3),\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_pattern_not_covered, code = \"E0005\")]\n+pub(crate) struct PatternNotCovered<'s, 'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub origin: &'s str,\n+    #[subdiagnostic]\n+    pub uncovered: Uncovered<'tcx>,\n+    #[subdiagnostic]\n+    pub inform: Option<Inform>,\n+    #[subdiagnostic]\n+    pub interpreted_as_const: Option<InterpretedAsConst>,\n+    #[subdiagnostic]\n+    pub adt_defined_here: Option<AdtDefinedHere<'tcx>>,\n+    #[note(pattern_ty)]\n+    pub _p: (),\n+    pub pattern_ty: Ty<'tcx>,\n+    #[subdiagnostic]\n+    pub let_suggestion: Option<SuggestLet>,\n+    #[subdiagnostic]\n+    pub res_defined_here: Option<ResDefinedHere>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(mir_build_inform_irrefutable)]\n+#[note(mir_build_more_information)]\n+pub struct Inform;\n+\n+pub struct AdtDefinedHere<'tcx> {\n+    pub adt_def_span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub variants: Vec<Variant>,\n+}\n+\n+pub struct Variant {\n+    pub span: Span,\n+}\n+\n+impl<'tcx> AddToDiagnostic for AdtDefinedHere<'tcx> {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        diag.set_arg(\"ty\", self.ty);\n+        let mut spans = MultiSpan::from(self.adt_def_span);\n+\n+        for Variant { span } in self.variants {\n+            spans.push_span_label(span, rustc_errors::fluent::mir_build_variant_defined_here);\n+        }\n+\n+        diag.span_note(spans, rustc_errors::fluent::mir_build_adt_defined_here);\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(mir_build_res_defined_here)]\n+pub struct ResDefinedHere {\n+    #[primary_span]\n+    pub def_span: Span,\n+    pub res: Res,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    mir_build_interpreted_as_const,\n+    code = \"{variable}_var\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+#[label(mir_build_confused)]\n+pub struct InterpretedAsConst {\n+    #[primary_span]\n+    pub span: Span,\n+    pub article: &'static str,\n+    pub variable: String,\n+    pub res: Res,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum SuggestLet {\n+    #[multipart_suggestion(mir_build_suggest_if_let, applicability = \"has-placeholders\")]\n+    If {\n+        #[suggestion_part(code = \"if \")]\n+        start_span: Span,\n+        #[suggestion_part(code = \" {{ todo!() }}\")]\n+        semi_span: Span,\n+        count: usize,\n+    },\n+    #[suggestion(\n+        mir_build_suggest_let_else,\n+        code = \" else {{ todo!() }}\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    Else {\n+        #[primary_span]\n+        end_span: Span,\n+        count: usize,\n+    },\n+}"}, {"sha": "fb7ae6f1d242412e8e72197107f2214969a54e50", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -10,6 +10,7 @@\n #![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(once_cell)]\n+#![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "fac4997fcbf6dc27b660319da5f07207dc0bc3de", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -60,7 +60,7 @@ impl<'mir, 'tcx> Search<'mir, 'tcx> {\n     /// Returns `true` if `func` refers to the function we are searching in.\n     fn is_recursive_call(&self, func: &Operand<'tcx>, args: &[Operand<'tcx>]) -> bool {\n         let Search { tcx, body, trait_substs, .. } = *self;\n-        // Resolving function type to a specific instance that is being called is expensive.  To\n+        // Resolving function type to a specific instance that is being called is expensive. To\n         // avoid the cost we check the number of arguments first, which is sufficient to reject\n         // most of calls as non-recursive.\n         if args.len() != body.arg_count {"}, {"sha": "e13c0662ef85f17cb45edb3bd2f7dd26820e7256", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 59, "deletions": 132, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -9,8 +9,7 @@ use crate::errors::*;\n use rustc_arena::TypedArena;\n use rustc_ast::Mutability;\n use rustc_errors::{\n-    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n-    MultiSpan,\n+    struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::*;\n@@ -378,8 +377,8 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n \n         let pattern = self.lower_pattern(&mut cx, pat, &mut false);\n         let pattern_ty = pattern.ty();\n-        let arms = vec![MatchArm { pat: pattern, hir_id: pat.hir_id, has_guard: false }];\n-        let report = compute_match_usefulness(&cx, &arms, pat.hir_id, pattern_ty);\n+        let arm = MatchArm { pat: pattern, hir_id: pat.hir_id, has_guard: false };\n+        let report = compute_match_usefulness(&cx, &[arm], pat.hir_id, pattern_ty);\n \n         // Note: we ignore whether the pattern is unreachable (i.e. whether the type is empty). We\n         // only care about exhaustiveness here.\n@@ -390,145 +389,73 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             return;\n         }\n \n-        let joined_patterns = joined_uncovered_patterns(&cx, &witnesses);\n-\n-        let mut bindings = vec![];\n-\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            pat.span,\n-            E0005,\n-            \"refutable pattern in {}: {} not covered\",\n-            origin,\n-            joined_patterns\n-        );\n-        let suggest_if_let = match &pat.kind {\n-            hir::PatKind::Path(hir::QPath::Resolved(None, path))\n-                if path.segments.len() == 1 && path.segments[0].args.is_none() =>\n+        let (inform, interpreted_as_const, res_defined_here,let_suggestion) =\n+            if let hir::PatKind::Path(hir::QPath::Resolved(\n+                None,\n+                hir::Path {\n+                    segments: &[hir::PathSegment { args: None, res, ident, .. }],\n+                    ..\n+                },\n+            )) = &pat.kind\n             {\n-                const_not_var(&mut err, cx.tcx, pat, path);\n-                false\n-            }\n-            _ => {\n-                pat.walk(&mut |pat: &hir::Pat<'_>| {\n-                    match pat.kind {\n-                        hir::PatKind::Binding(_, _, ident, _) => {\n-                            bindings.push(ident);\n+                (\n+                    None,\n+                    Some(InterpretedAsConst {\n+                        span: pat.span,\n+                        article: res.article(),\n+                        variable: ident.to_string().to_lowercase(),\n+                        res,\n+                    }),\n+                    try {\n+                        ResDefinedHere {\n+                            def_span: cx.tcx.hir().res_span(res)?,\n+                            res,\n                         }\n-                        _ => {}\n+                    },\n+                    None,\n+                )\n+            } else if let Some(span) = sp && self.tcx.sess.source_map().is_span_accessible(span) {\n+                let mut bindings = vec![];\n+                pat.walk_always(&mut |pat: &hir::Pat<'_>| {\n+                    if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n+                        bindings.push(ident);\n                     }\n-                    true\n                 });\n-\n-                err.span_label(pat.span, pattern_not_covered_label(&witnesses, &joined_patterns));\n-                true\n-            }\n-        };\n-\n-        if let (Some(span), true) = (sp, suggest_if_let) {\n-            err.note(\n-                \"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n-                 an `enum` with only one variant\",\n-            );\n-            if self.tcx.sess.source_map().is_span_accessible(span) {\n                 let semi_span = span.shrink_to_hi().with_lo(span.hi() - BytePos(1));\n                 let start_span = span.shrink_to_lo();\n                 let end_span = semi_span.shrink_to_lo();\n-                err.multipart_suggestion(\n-                    &format!(\n-                        \"you might want to use `if let` to ignore the variant{} that {} matched\",\n-                        pluralize!(witnesses.len()),\n-                        match witnesses.len() {\n-                            1 => \"isn't\",\n-                            _ => \"aren't\",\n-                        },\n-                    ),\n-                    vec![\n-                        match &bindings[..] {\n-                            [] => (start_span, \"if \".to_string()),\n-                            [binding] => (start_span, format!(\"let {} = if \", binding)),\n-                            bindings => (\n-                                start_span,\n-                                format!(\n-                                    \"let ({}) = if \",\n-                                    bindings\n-                                        .iter()\n-                                        .map(|ident| ident.to_string())\n-                                        .collect::<Vec<_>>()\n-                                        .join(\", \")\n-                                ),\n-                            ),\n-                        },\n-                        match &bindings[..] {\n-                            [] => (semi_span, \" { todo!() }\".to_string()),\n-                            [binding] => {\n-                                (end_span, format!(\" {{ {} }} else {{ todo!() }}\", binding))\n-                            }\n-                            bindings => (\n-                                end_span,\n-                                format!(\n-                                    \" {{ ({}) }} else {{ todo!() }}\",\n-                                    bindings\n-                                        .iter()\n-                                        .map(|ident| ident.to_string())\n-                                        .collect::<Vec<_>>()\n-                                        .join(\", \")\n-                                ),\n-                            ),\n-                        },\n-                    ],\n-                    Applicability::HasPlaceholders,\n-                );\n-                if !bindings.is_empty() {\n-                    err.span_suggestion_verbose(\n-                        semi_span.shrink_to_lo(),\n-                        &format!(\n-                            \"alternatively, you might want to use \\\n-                             let else to handle the variant{} that {} matched\",\n-                            pluralize!(witnesses.len()),\n-                            match witnesses.len() {\n-                                1 => \"isn't\",\n-                                _ => \"aren't\",\n-                            },\n-                        ),\n-                        \" else { todo!() }\",\n-                        Applicability::HasPlaceholders,\n-                    );\n-                }\n-            }\n-            err.note(\n-                \"for more information, visit \\\n-                 https://doc.rust-lang.org/book/ch18-02-refutability.html\",\n-            );\n-        }\n+                let count = witnesses.len();\n \n-        adt_defined_here(&cx, &mut err, pattern_ty, &witnesses);\n-        err.note(&format!(\"the matched value is of type `{}`\", pattern_ty));\n-        err.emit();\n-    }\n-}\n+                let let_suggestion = if bindings.is_empty() {SuggestLet::If{start_span, semi_span, count}} else{ SuggestLet::Else{end_span, count }};\n+                (sp.map(|_|Inform), None, None, Some(let_suggestion))\n+            } else{\n+                (sp.map(|_|Inform), None, None,  None)\n+            };\n \n-/// A path pattern was interpreted as a constant, not a new variable.\n-/// This caused an irrefutable match failure in e.g. `let`.\n-fn const_not_var(err: &mut Diagnostic, tcx: TyCtxt<'_>, pat: &Pat<'_>, path: &hir::Path<'_>) {\n-    let descr = path.res.descr();\n-    err.span_label(\n-        pat.span,\n-        format!(\"interpreted as {} {} pattern, not a new variable\", path.res.article(), descr,),\n-    );\n+        let adt_defined_here = try {\n+            let ty = pattern_ty.peel_refs();\n+            let ty::Adt(def, _) = ty.kind() else { None? };\n+            let adt_def_span = cx.tcx.hir().get_if_local(def.did())?.ident()?.span;\n+            let mut variants = vec![];\n \n-    err.span_suggestion(\n-        pat.span,\n-        \"introduce a variable instead\",\n-        format!(\"{}_var\", path.segments[0].ident).to_lowercase(),\n-        // Cannot use `MachineApplicable` as it's not really *always* correct\n-        // because there may be such an identifier in scope or the user maybe\n-        // really wanted to match against the constant. This is quite unlikely however.\n-        Applicability::MaybeIncorrect,\n-    );\n+            for span in maybe_point_at_variant(&cx, *def, witnesses.iter().take(5)) {\n+                variants.push(Variant { span });\n+            }\n+            AdtDefinedHere { adt_def_span, ty, variants }\n+        };\n \n-    if let Some(span) = tcx.hir().res_span(path.res) {\n-        err.span_label(span, format!(\"{} defined here\", descr));\n+        self.tcx.sess.emit_err(PatternNotCovered {\n+            span: pat.span,\n+            origin,\n+            uncovered: Uncovered::new(pat.span, &cx, witnesses),\n+            inform,\n+            interpreted_as_const,\n+            _p: (),\n+            pattern_ty,\n+            let_suggestion,\n+            res_defined_here,\n+            adt_defined_here,\n+        });\n     }\n }\n "}, {"sha": "7f3519945c3fed4ea3ba3ea29da636dd456c5e02", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 51, "deletions": 137, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,11 +1,9 @@\n-use rustc_errors::DelayDm;\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::mir::{self, Field};\n use rustc_middle::thir::{FieldPat, Pat, PatKind};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_span::Span;\n use rustc_trait_selection::traits::predicate_for_trait_def;\n@@ -15,6 +13,10 @@ use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligation};\n use std::cell::Cell;\n \n use super::PatCtxt;\n+use crate::errors::{\n+    FloatPattern, IndirectStructuralMatch, InvalidPattern, NontrivialStructuralMatch,\n+    PointerPattern, TypeNotStructural, UnionPattern, UnsizedPattern,\n+};\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// Converts an evaluated constant to a pattern (if possible).\n@@ -105,47 +107,6 @@ impl<'tcx> ConstToPat<'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn adt_derive_msg(&self, adt_def: AdtDef<'tcx>) -> String {\n-        let path = self.tcx().def_path_str(adt_def.did());\n-        format!(\n-            \"to use a constant of type `{}` in a pattern, \\\n-            `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-            path, path,\n-        )\n-    }\n-\n-    fn search_for_structural_match_violation(&self, ty: Ty<'tcx>) -> Option<String> {\n-        traits::search_for_structural_match_violation(self.span, self.tcx(), ty).map(|non_sm_ty| {\n-            with_no_trimmed_paths!(match non_sm_ty.kind() {\n-                ty::Adt(adt, _) => self.adt_derive_msg(*adt),\n-                ty::Dynamic(..) => {\n-                    \"trait objects cannot be used in patterns\".to_string()\n-                }\n-                ty::Alias(ty::Opaque, ..) => {\n-                    \"opaque types cannot be used in patterns\".to_string()\n-                }\n-                ty::Closure(..) => {\n-                    \"closures cannot be used in patterns\".to_string()\n-                }\n-                ty::Generator(..) | ty::GeneratorWitness(..) => {\n-                    \"generators cannot be used in patterns\".to_string()\n-                }\n-                ty::Float(..) => {\n-                    \"floating-point numbers cannot be used in patterns\".to_string()\n-                }\n-                ty::FnPtr(..) => {\n-                    \"function pointers cannot be used in patterns\".to_string()\n-                }\n-                ty::RawPtr(..) => {\n-                    \"raw pointers cannot be used in patterns\".to_string()\n-                }\n-                _ => {\n-                    bug!(\"use of a value of `{non_sm_ty}` inside a pattern\")\n-                }\n-            })\n-        })\n-    }\n-\n     fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {\n         ty.is_structural_eq_shallow(self.infcx.tcx)\n     }\n@@ -176,7 +137,8 @@ impl<'tcx> ConstToPat<'tcx> {\n             // If we were able to successfully convert the const to some pat,\n             // double-check that all types in the const implement `Structural`.\n \n-            let structural = self.search_for_structural_match_violation(cv.ty());\n+            let structural =\n+                traits::search_for_structural_match_violation(self.span, self.tcx(), cv.ty());\n             debug!(\n                 \"search_for_structural_match_violation cv.ty: {:?} returned: {:?}\",\n                 cv.ty(),\n@@ -194,17 +156,18 @@ impl<'tcx> ConstToPat<'tcx> {\n                 return inlined_const_as_pat;\n             }\n \n-            if let Some(msg) = structural {\n+            if let Some(non_sm_ty) = structural {\n                 if !self.type_may_have_partial_eq_impl(cv.ty()) {\n-                    // span_fatal avoids ICE from resolution of non-existent method (rare case).\n-                    self.tcx().sess.span_fatal(self.span, &msg);\n+                    // fatal avoids ICE from resolution of non-existent method (rare case).\n+                    self.tcx()\n+                        .sess\n+                        .emit_fatal(TypeNotStructural { span: self.span, non_sm_ty: non_sm_ty });\n                 } else if mir_structural_match_violation && !self.saw_const_match_lint.get() {\n-                    self.tcx().struct_span_lint_hir(\n+                    self.tcx().emit_spanned_lint(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         self.id,\n                         self.span,\n-                        msg,\n-                        |lint| lint,\n+                        IndirectStructuralMatch { non_sm_ty },\n                     );\n                 } else {\n                     debug!(\n@@ -278,42 +241,34 @@ impl<'tcx> ConstToPat<'tcx> {\n         let kind = match cv.ty().kind() {\n             ty::Float(_) => {\n                 if self.include_lint_checks {\n-                    tcx.struct_span_lint_hir(\n+                    tcx.emit_spanned_lint(\n                         lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                         id,\n                         span,\n-                        \"floating-point types cannot be used in patterns\",\n-                        |lint| lint,\n+                        FloatPattern,\n                     );\n                 }\n                 PatKind::Constant { value: cv }\n             }\n             ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 self.saw_const_match_error.set(true);\n-                let msg = \"cannot use unions in constant patterns\";\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(span, msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(span, msg);\n-                }\n+                let err = UnionPattern { span };\n+                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n             ty::Adt(..)\n                 if !self.type_may_have_partial_eq_impl(cv.ty())\n                     // FIXME(#73448): Find a way to bring const qualification into parity with\n                     // `search_for_structural_match_violation` and then remove this condition.\n-                    && self.search_for_structural_match_violation(cv.ty()).is_some() =>\n+\n+                    // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n+                    // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n+                    && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, cv.ty()) =>\n             {\n-                // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n-                // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-                let msg = self.search_for_structural_match_violation(cv.ty()).unwrap();\n                 self.saw_const_match_error.set(true);\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(self.span, &msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(self.span, &msg);\n-                }\n+                let err = TypeNotStructural { span, non_sm_ty };\n+                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n             // If the type is not structurally comparable, just emit the constant directly,\n@@ -331,19 +286,11 @@ impl<'tcx> ConstToPat<'tcx> {\n                     && !self.saw_const_match_lint.get()\n                 {\n                     self.saw_const_match_lint.set(true);\n-                    tcx.struct_span_lint_hir(\n+                    tcx.emit_spanned_lint(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         id,\n                         span,\n-                        DelayDm(|| {\n-                            format!(\n-                                \"to use a constant of type `{}` in a pattern, \\\n-                                 `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                                cv.ty(),\n-                                cv.ty(),\n-                            )\n-                        }),\n-                        |lint| lint,\n+                        IndirectStructuralMatch { non_sm_ty: cv.ty() },\n                     );\n                 }\n                 // Since we are behind a reference, we can just bubble the error up so we get a\n@@ -357,18 +304,9 @@ impl<'tcx> ConstToPat<'tcx> {\n                     adt_def,\n                     cv.ty()\n                 );\n-                let path = tcx.def_path_str(adt_def.did());\n-                let msg = format!(\n-                    \"to use a constant of type `{}` in a pattern, \\\n-                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                    path, path,\n-                );\n                 self.saw_const_match_error.set(true);\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(span, &msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(span, &msg);\n-                }\n+                let err = TypeNotStructural { span, non_sm_ty: cv.ty() };\n+                tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n@@ -401,12 +339,8 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // These are not allowed and will error elsewhere anyway.\n                 ty::Dynamic(..) => {\n                     self.saw_const_match_error.set(true);\n-                    let msg = format!(\"`{}` cannot be used in patterns\", cv.ty());\n-                    if self.include_lint_checks {\n-                        tcx.sess.span_err(span, &msg);\n-                    } else {\n-                        tcx.sess.delay_span_bug(span, &msg);\n-                    }\n+                    let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n+                    tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                     PatKind::Wild\n                 }\n                 // `&str` is represented as `ConstValue::Slice`, let's keep using this\n@@ -471,32 +405,26 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // this pattern to a `PartialEq::eq` comparison and `PartialEq::eq` takes a\n                 // reference. This makes the rest of the matching logic simpler as it doesn't have\n                 // to figure out how to get a reference again.\n-                ty::Adt(adt_def, _) if !self.type_marked_structural(*pointee_ty) => {\n+                ty::Adt(_, _) if !self.type_marked_structural(*pointee_ty) => {\n                     if self.behind_reference.get() {\n                         if self.include_lint_checks\n                             && !self.saw_const_match_error.get()\n                             && !self.saw_const_match_lint.get()\n                         {\n-                            self.saw_const_match_lint.set(true);\n-                            let msg = self.adt_derive_msg(adt_def);\n-                            self.tcx().struct_span_lint_hir(\n+                           self.saw_const_match_lint.set(true);\n+                           tcx.emit_spanned_lint(\n                                 lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                                 self.id,\n-                                self.span,\n-                                msg,\n-                                |lint| lint,\n+                                span,\n+                                IndirectStructuralMatch { non_sm_ty: *pointee_ty },\n                             );\n                         }\n                         PatKind::Constant { value: cv }\n                     } else {\n                         if !self.saw_const_match_error.get() {\n                             self.saw_const_match_error.set(true);\n-                            let msg = self.adt_derive_msg(adt_def);\n-                            if self.include_lint_checks {\n-                                tcx.sess.span_err(span, &msg);\n-                            } else {\n-                                tcx.sess.delay_span_bug(span, &msg);\n-                            }\n+                            let err = TypeNotStructural { span, non_sm_ty: *pointee_ty };\n+                            tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                         }\n                         PatKind::Wild\n                     }\n@@ -508,12 +436,10 @@ impl<'tcx> ConstToPat<'tcx> {\n                     if !pointee_ty.is_sized(tcx, param_env) {\n                         // `tcx.deref_mir_constant()` below will ICE with an unsized type\n                         // (except slices, which are handled in a separate arm above).\n-                        let msg = format!(\"cannot use unsized non-slice type `{}` in constant patterns\", pointee_ty);\n-                        if self.include_lint_checks {\n-                            tcx.sess.span_err(span, &msg);\n-                        } else {\n-                            tcx.sess.delay_span_bug(span, &msg);\n-                        }\n+\n+                        let err = UnsizedPattern { span, non_sm_ty: *pointee_ty };\n+                        tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n+\n                         PatKind::Wild\n                     } else {\n                         let old = self.behind_reference.replace(true);\n@@ -545,27 +471,19 @@ impl<'tcx> ConstToPat<'tcx> {\n                     && !self.saw_const_match_lint.get()\n                 {\n                     self.saw_const_match_lint.set(true);\n-                    let msg = \"function pointers and unsized pointers in patterns behave \\\n-                        unpredictably and should not be relied upon. \\\n-                        See https://github.com/rust-lang/rust/issues/70861 for details.\";\n-                    tcx.struct_span_lint_hir(\n+                    tcx.emit_spanned_lint(\n                         lint::builtin::POINTER_STRUCTURAL_MATCH,\n                         id,\n                         span,\n-                        msg,\n-                        |lint| lint,\n+                        PointerPattern\n                     );\n                 }\n                 PatKind::Constant { value: cv }\n             }\n             _ => {\n                 self.saw_const_match_error.set(true);\n-                let msg = format!(\"`{}` cannot be used in patterns\", cv.ty());\n-                if self.include_lint_checks {\n-                    tcx.sess.span_err(span, &msg);\n-                } else {\n-                    tcx.sess.delay_span_bug(span, &msg);\n-                }\n+                let err = InvalidPattern { span, non_sm_ty: cv.ty() };\n+                    tcx.sess.create_err(err).emit_unless(!self.include_lint_checks);\n                 PatKind::Wild\n             }\n         };\n@@ -576,21 +494,17 @@ impl<'tcx> ConstToPat<'tcx> {\n             && mir_structural_match_violation\n             // FIXME(#73448): Find a way to bring const qualification into parity with\n             // `search_for_structural_match_violation` and then remove this condition.\n-            && self.search_for_structural_match_violation(cv.ty()).is_some()\n-        {\n-            self.saw_const_match_lint.set(true);\n+\n             // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n             // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n-            let msg = self.search_for_structural_match_violation(cv.ty()).unwrap().replace(\n-                \"in a pattern,\",\n-                \"in a pattern, the constant's initializer must be trivial or\",\n-            );\n-            tcx.struct_span_lint_hir(\n+            && let Some(non_sm_ty) = traits::search_for_structural_match_violation(span, tcx, cv.ty())\n+        {\n+            self.saw_const_match_lint.set(true);\n+            tcx.emit_spanned_lint(\n                 lint::builtin::NONTRIVIAL_STRUCTURAL_MATCH,\n                 id,\n                 span,\n-                msg,\n-                |lint| lint,\n+                NontrivialStructuralMatch {non_sm_ty}\n             );\n         }\n "}, {"sha": "17b3c475f83c78a3d4711e65092859da5d5d147b", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -67,6 +67,7 @@ use self::SliceKind::*;\n \n use super::compare_const_vals;\n use super::usefulness::{MatchCheckCtxt, PatCtxt};\n+use crate::errors::{Overlap, OverlappingRangeEndpoints};\n \n /// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n fn expand_or_pat<'p, 'tcx>(pat: &'p Pat<'tcx>) -> Vec<&'p Pat<'tcx>> {\n@@ -96,7 +97,7 @@ fn expand_or_pat<'p, 'tcx>(pat: &'p Pat<'tcx>) -> Vec<&'p Pat<'tcx>> {\n /// `IntRange` is never used to encode an empty range or a \"range\" that wraps\n /// around the (offset) space: i.e., `range.lo <= range.hi`.\n #[derive(Clone, PartialEq, Eq)]\n-pub(super) struct IntRange {\n+pub(crate) struct IntRange {\n     range: RangeInclusive<u128>,\n     /// Keeps the bias used for encoding the range. It depends on the type of the range and\n     /// possibly the pointer size of the current architecture. The algorithm ensures we never\n@@ -284,32 +285,21 @@ impl IntRange {\n             return;\n         }\n \n-        let overlaps: Vec<_> = pats\n+        let overlap: Vec<_> = pats\n             .filter_map(|pat| Some((pat.ctor().as_int_range()?, pat.span())))\n             .filter(|(range, _)| self.suspicious_intersection(range))\n-            .map(|(range, span)| (self.intersection(&range).unwrap(), span))\n+            .map(|(range, span)| Overlap {\n+                range: self.intersection(&range).unwrap().to_pat(pcx.cx.tcx, pcx.ty),\n+                span,\n+            })\n             .collect();\n \n-        if !overlaps.is_empty() {\n-            pcx.cx.tcx.struct_span_lint_hir(\n+        if !overlap.is_empty() {\n+            pcx.cx.tcx.emit_spanned_lint(\n                 lint::builtin::OVERLAPPING_RANGE_ENDPOINTS,\n                 hir_id,\n                 pcx.span,\n-                \"multiple patterns overlap on their endpoints\",\n-                |lint| {\n-                    for (int_range, span) in overlaps {\n-                        lint.span_label(\n-                            span,\n-                            &format!(\n-                                \"this range overlaps on `{}`...\",\n-                                int_range.to_pat(pcx.cx.tcx, pcx.ty)\n-                            ),\n-                        );\n-                    }\n-                    lint.span_label(pcx.span, \"... with this range\");\n-                    lint.note(\"you likely meant to write mutually exclusive ranges\");\n-                    lint\n-                },\n+                OverlappingRangeEndpoints { overlap, range: pcx.span },\n             );\n         }\n     }"}, {"sha": "3a6ef87c9c662d393768c1c8f82ea6c95925d1a4", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 63, "deletions": 7, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -2,7 +2,7 @@\n \n mod check_match;\n mod const_to_pat;\n-mod deconstruct_pat;\n+pub(crate) mod deconstruct_pat;\n mod usefulness;\n \n pub(crate) use self::check_match::check_match;\n@@ -129,10 +129,20 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         hi: mir::ConstantKind<'tcx>,\n         end: RangeEnd,\n         span: Span,\n+        lo_expr: Option<&hir::Expr<'tcx>>,\n+        hi_expr: Option<&hir::Expr<'tcx>>,\n     ) -> PatKind<'tcx> {\n         assert_eq!(lo.ty(), ty);\n         assert_eq!(hi.ty(), ty);\n         let cmp = compare_const_vals(self.tcx, lo, hi, self.param_env);\n+        let max = || {\n+            self.tcx\n+                .layout_of(self.param_env.with_reveal_all_normalized(self.tcx).and(ty))\n+                .ok()\n+                .unwrap()\n+                .size\n+                .unsigned_int_max()\n+        };\n         match (end, cmp) {\n             // `x..y` where `x < y`.\n             // Non-empty because the range includes at least `x`.\n@@ -141,7 +151,27 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n             // `x..y` where `x >= y`. The range is empty => error.\n             (RangeEnd::Excluded, _) => {\n-                self.tcx.sess.emit_err(LowerRangeBoundMustBeLessThanUpper { span });\n+                let mut lower_overflow = false;\n+                let mut higher_overflow = false;\n+                if let Some(hir::Expr { kind: hir::ExprKind::Lit(lit), .. }) = lo_expr\n+                    && let rustc_ast::ast::LitKind::Int(val, _) = lit.node\n+                {\n+                    if lo.eval_bits(self.tcx, self.param_env, ty) != val {\n+                        lower_overflow = true;\n+                        self.tcx.sess.emit_err(LiteralOutOfRange { span: lit.span, ty, max: max() });\n+                    }\n+                }\n+                if let Some(hir::Expr { kind: hir::ExprKind::Lit(lit), .. }) = hi_expr\n+                    && let rustc_ast::ast::LitKind::Int(val, _) = lit.node\n+                {\n+                    if hi.eval_bits(self.tcx, self.param_env, ty) != val {\n+                        higher_overflow = true;\n+                        self.tcx.sess.emit_err(LiteralOutOfRange { span: lit.span, ty, max: max() });\n+                    }\n+                }\n+                if !lower_overflow && !higher_overflow {\n+                    self.tcx.sess.emit_err(LowerRangeBoundMustBeLessThanUpper { span });\n+                }\n                 PatKind::Wild\n             }\n             // `x..=y` where `x == y`.\n@@ -152,10 +182,34 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n             // `x..=y` where `x > y` hence the range is empty => error.\n             (RangeEnd::Included, _) => {\n-                self.tcx.sess.emit_err(LowerRangeBoundMustBeLessThanOrEqualToUpper {\n-                    span,\n-                    teach: if self.tcx.sess.teach(&error_code!(E0030)) { Some(()) } else { None },\n-                });\n+                let mut lower_overflow = false;\n+                let mut higher_overflow = false;\n+                if let Some(hir::Expr { kind: hir::ExprKind::Lit(lit), .. }) = lo_expr\n+                    && let rustc_ast::ast::LitKind::Int(val, _) = lit.node\n+                {\n+                    if lo.eval_bits(self.tcx, self.param_env, ty) != val {\n+                        lower_overflow = true;\n+                        self.tcx.sess.emit_err(LiteralOutOfRange { span: lit.span, ty, max: max() });\n+                    }\n+                }\n+                if let Some(hir::Expr { kind: hir::ExprKind::Lit(lit), .. }) = hi_expr\n+                    && let rustc_ast::ast::LitKind::Int(val, _) = lit.node\n+                {\n+                    if hi.eval_bits(self.tcx, self.param_env, ty) != val {\n+                        higher_overflow = true;\n+                        self.tcx.sess.emit_err(LiteralOutOfRange { span: lit.span, ty, max: max() });\n+                    }\n+                }\n+                if !lower_overflow && !higher_overflow {\n+                    self.tcx.sess.emit_err(LowerRangeBoundMustBeLessThanOrEqualToUpper {\n+                        span,\n+                        teach: if self.tcx.sess.teach(&error_code!(E0030)) {\n+                            Some(())\n+                        } else {\n+                            None\n+                        },\n+                    });\n+                }\n                 PatKind::Wild\n             }\n         }\n@@ -201,7 +255,9 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n                 let (lp, hp) = (lo.as_ref().map(|(x, _)| x), hi.as_ref().map(|(x, _)| x));\n                 let mut kind = match self.normalize_range_pattern_ends(ty, lp, hp) {\n-                    Some((lc, hc)) => self.lower_pattern_range(ty, lc, hc, end, lo_span),\n+                    Some((lc, hc)) => {\n+                        self.lower_pattern_range(ty, lc, hc, end, lo_span, lo_expr, hi_expr)\n+                    }\n                     None => {\n                         let msg = &format!(\n                             \"found bad range pattern `{:?}` outside of error recovery\","}, {"sha": "be66d0d476513992b4009fef5d85ba354ba4b82a", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -291,9 +291,8 @@\n \n use self::ArmType::*;\n use self::Usefulness::*;\n-\n-use super::check_match::{joined_uncovered_patterns, pattern_not_covered_label};\n use super::deconstruct_pat::{Constructor, DeconstructedPat, Fields, SplitWildcard};\n+use crate::errors::{NonExhaustiveOmittedPattern, Uncovered};\n \n use rustc_data_structures::captures::Captures;\n \n@@ -743,31 +742,6 @@ impl<'p, 'tcx> Witness<'p, 'tcx> {\n     }\n }\n \n-/// Report that a match of a `non_exhaustive` enum marked with `non_exhaustive_omitted_patterns`\n-/// is not exhaustive enough.\n-///\n-/// NB: The partner lint for structs lives in `compiler/rustc_hir_analysis/src/check/pat.rs`.\n-fn lint_non_exhaustive_omitted_patterns<'p, 'tcx>(\n-    cx: &MatchCheckCtxt<'p, 'tcx>,\n-    scrut_ty: Ty<'tcx>,\n-    sp: Span,\n-    hir_id: HirId,\n-    witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n-) {\n-    cx.tcx.struct_span_lint_hir(NON_EXHAUSTIVE_OMITTED_PATTERNS, hir_id, sp, \"some variants are not matched explicitly\", |lint| {\n-        let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n-        lint.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n-        lint.help(\n-            \"ensure that all variants are matched explicitly by adding the suggested match arms\",\n-        );\n-        lint.note(&format!(\n-            \"the matched value is of type `{}` and the `non_exhaustive_omitted_patterns` attribute was found\",\n-            scrut_ty,\n-        ));\n-        lint\n-    });\n-}\n-\n /// Algorithm from <http://moscova.inria.fr/~maranget/papers/warn/index.html>.\n /// The algorithm from the paper has been modified to correctly handle empty\n /// types. The changes are:\n@@ -913,7 +887,19 @@ fn is_useful<'p, 'tcx>(\n                         .collect::<Vec<_>>()\n                 };\n \n-                lint_non_exhaustive_omitted_patterns(pcx.cx, pcx.ty, pcx.span, hir_id, patterns);\n+                // Report that a match of a `non_exhaustive` enum marked with `non_exhaustive_omitted_patterns`\n+                // is not exhaustive enough.\n+                //\n+                // NB: The partner lint for structs lives in `compiler/rustc_hir_analysis/src/check/pat.rs`.\n+                cx.tcx.emit_spanned_lint(\n+                    NON_EXHAUSTIVE_OMITTED_PATTERNS,\n+                    hir_id,\n+                    pcx.span,\n+                    NonExhaustiveOmittedPattern {\n+                        scrut_ty: pcx.ty,\n+                        uncovered: Uncovered::new(pcx.span, pcx.cx, patterns),\n+                    },\n+                );\n             }\n \n             ret.extend(usefulness);"}, {"sha": "4b5324e203aa3725aad358ad587e2eb714b366b1", "filename": "compiler/rustc_mir_dataflow/src/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -750,7 +750,7 @@ where\n \n /// Calls `f` for each mutable borrow or raw reference in the program.\n ///\n-/// This DOES NOT call `f` for a shared borrow of a type with interior mutability.  That's okay for\n+/// This DOES NOT call `f` for a shared borrow of a type with interior mutability. That's okay for\n /// initializedness, because we cannot move from an `UnsafeCell` (outside of `core::cell`), but\n /// other analyses will likely need to check for `!Freeze`.\n fn for_each_mut_borrow<'tcx>("}, {"sha": "7d2146214c6dc2128040b12ab248e32272d1b016", "filename": "compiler/rustc_mir_transform/src/add_retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -120,7 +120,7 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         // PART 3\n         // Add retag after assignments where data \"enters\" this function: the RHS is behind a deref and the LHS is not.\n         for block_data in basic_blocks {\n-            // We want to insert statements as we iterate.  To this end, we\n+            // We want to insert statements as we iterate. To this end, we\n             // iterate backwards using indices.\n             for i in (0..block_data.statements.len()).rev() {\n                 let (retag_kind, place) = match block_data.statements[i].kind {"}, {"sha": "5c45abc5a170ec63bae49cbb386edd0d854accfe", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -655,11 +655,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n-        if self.tcx.sess.mir_opt_level() >= 4 {\n-            self.eval_rvalue_with_identities(rvalue, place)\n-        } else {\n-            self.use_ecx(|this| this.ecx.eval_rvalue_into_place(rvalue, place))\n-        }\n+        self.eval_rvalue_with_identities(rvalue, place)\n     }\n \n     // Attempt to use algebraic identities to eliminate constant expressions"}, {"sha": "42124f5a4808d0a3ff074da042b6db40791be5e1", "filename": "compiler/rustc_mir_transform/src/sroa.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -215,7 +215,7 @@ struct ReplacementVisitor<'tcx, 'll> {\n     replacements: ReplacementMap<'tcx>,\n     /// This is used to check that we are not leaving references to replaced locals behind.\n     all_dead_locals: BitSet<Local>,\n-    /// Pre-computed list of all \"new\" locals for each \"old\" local.  This is used to expand storage\n+    /// Pre-computed list of all \"new\" locals for each \"old\" local. This is used to expand storage\n     /// and deinit statement and debuginfo.\n     fragments: IndexVec<Local, Vec<(&'tcx [PlaceElem<'tcx>], Local)>>,\n }"}, {"sha": "d4b1cfe433723c26157c035d3a66a07bfe8fb0bf", "filename": "compiler/rustc_mir_transform/src/unreachable_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -87,7 +87,7 @@ where\n                 // unless otherwise is unreachable, in which case deleting a normal branch causes it to be merged with\n                 // the otherwise, keeping its unreachable.\n                 // This looses information about reachability causing worse codegen.\n-                // For example (see src/test/codegen/match-optimizes-away.rs)\n+                // For example (see tests/codegen/match-optimizes-away.rs)\n                 //\n                 // pub enum Two { A, B }\n                 // pub fn identity(x: Two) -> Two {"}, {"sha": "5233cfb21203ba470e434673a921670a82bc1960", "filename": "compiler/rustc_monomorphize/src/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -32,13 +32,13 @@ pub struct TypeLengthLimit {\n     pub type_length: usize,\n }\n \n-pub struct UnusedGenericParams {\n+pub struct UnusedGenericParamsHint {\n     pub span: Span,\n     pub param_spans: Vec<Span>,\n     pub param_names: Vec<String>,\n }\n \n-impl IntoDiagnostic<'_> for UnusedGenericParams {\n+impl IntoDiagnostic<'_> for UnusedGenericParamsHint {\n     #[track_caller]\n     fn into_diagnostic(\n         self,"}, {"sha": "c8fc69eb856abdc5b12b202122e5fbde68851f75", "filename": "compiler/rustc_monomorphize/src/polymorphize.rs", "status": "modified", "additions": 18, "deletions": 65, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -6,7 +6,6 @@\n //! for their size, offset of a field, etc.).\n \n use rustc_hir::{def::DefKind, def_id::DefId, ConstContext};\n-use rustc_index::bit_set::FiniteBitSet;\n use rustc_middle::mir::{\n     self,\n     visit::{TyContext, Visitor},\n@@ -17,12 +16,12 @@ use rustc_middle::ty::{\n     query::Providers,\n     subst::SubstsRef,\n     visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor},\n-    Const, Ty, TyCtxt,\n+    Const, Ty, TyCtxt, UnusedGenericParams,\n };\n use rustc_span::symbol::sym;\n use std::ops::ControlFlow;\n \n-use crate::errors::UnusedGenericParams;\n+use crate::errors::UnusedGenericParamsHint;\n \n /// Provide implementations of queries relating to polymorphization analysis.\n pub fn provide(providers: &mut Providers) {\n@@ -36,31 +35,30 @@ pub fn provide(providers: &mut Providers) {\n fn unused_generic_params<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: ty::InstanceDef<'tcx>,\n-) -> FiniteBitSet<u32> {\n+) -> UnusedGenericParams {\n     if !tcx.sess.opts.unstable_opts.polymorphize {\n         // If polymorphization disabled, then all parameters are used.\n-        return FiniteBitSet::new_empty();\n+        return UnusedGenericParams::new_all_used();\n     }\n \n     let def_id = instance.def_id();\n     // Exit early if this instance should not be polymorphized.\n     if !should_polymorphize(tcx, def_id, instance) {\n-        return FiniteBitSet::new_empty();\n+        return UnusedGenericParams::new_all_used();\n     }\n \n     let generics = tcx.generics_of(def_id);\n     debug!(?generics);\n \n     // Exit early when there are no parameters to be unused.\n     if generics.count() == 0 {\n-        return FiniteBitSet::new_empty();\n+        return UnusedGenericParams::new_all_used();\n     }\n \n     // Create a bitset with N rightmost ones for each parameter.\n     let generics_count: u32 =\n         generics.count().try_into().expect(\"more generic parameters than can fit into a `u32`\");\n-    let mut unused_parameters = FiniteBitSet::<u32>::new_empty();\n-    unused_parameters.set_range(0..generics_count);\n+    let mut unused_parameters = UnusedGenericParams::new_all_unused(generics_count);\n     debug!(?unused_parameters, \"(start)\");\n \n     mark_used_by_default_parameters(tcx, def_id, generics, &mut unused_parameters);\n@@ -78,7 +76,7 @@ fn unused_generic_params<'tcx>(\n     debug!(?unused_parameters, \"(end)\");\n \n     // Emit errors for debugging and testing if enabled.\n-    if !unused_parameters.is_empty() {\n+    if !unused_parameters.all_used() {\n         emit_unused_generic_params_error(tcx, def_id, generics, &unused_parameters);\n     }\n \n@@ -136,13 +134,13 @@ fn mark_used_by_default_parameters<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     generics: &'tcx ty::Generics,\n-    unused_parameters: &mut FiniteBitSet<u32>,\n+    unused_parameters: &mut UnusedGenericParams,\n ) {\n     match tcx.def_kind(def_id) {\n         DefKind::Closure | DefKind::Generator => {\n             for param in &generics.params {\n                 debug!(?param, \"(closure/gen)\");\n-                unused_parameters.clear(param.index);\n+                unused_parameters.mark_used(param.index);\n             }\n         }\n         DefKind::Mod\n@@ -178,7 +176,7 @@ fn mark_used_by_default_parameters<'tcx>(\n             for param in &generics.params {\n                 debug!(?param, \"(other)\");\n                 if let ty::GenericParamDefKind::Lifetime = param.kind {\n-                    unused_parameters.clear(param.index);\n+                    unused_parameters.mark_used(param.index);\n                 }\n             }\n         }\n@@ -196,7 +194,7 @@ fn emit_unused_generic_params_error<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     generics: &'tcx ty::Generics,\n-    unused_parameters: &FiniteBitSet<u32>,\n+    unused_parameters: &UnusedGenericParams,\n ) {\n     let base_def_id = tcx.typeck_root_def_id(def_id);\n     if !tcx.has_attr(base_def_id, sym::rustc_polymorphize_error) {\n@@ -213,7 +211,7 @@ fn emit_unused_generic_params_error<'tcx>(\n     let mut next_generics = Some(generics);\n     while let Some(generics) = next_generics {\n         for param in &generics.params {\n-            if unused_parameters.contains(param.index).unwrap_or(false) {\n+            if unused_parameters.is_unused(param.index) {\n                 debug!(?param);\n                 let def_span = tcx.def_span(param.def_id);\n                 param_spans.push(def_span);\n@@ -224,14 +222,14 @@ fn emit_unused_generic_params_error<'tcx>(\n         next_generics = generics.parent.map(|did| tcx.generics_of(did));\n     }\n \n-    tcx.sess.emit_err(UnusedGenericParams { span: fn_span, param_spans, param_names });\n+    tcx.sess.emit_err(UnusedGenericParamsHint { span: fn_span, param_spans, param_names });\n }\n \n /// Visitor used to aggregate generic parameter uses.\n struct MarkUsedGenericParams<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-    unused_parameters: &'a mut FiniteBitSet<u32>,\n+    unused_parameters: &'a mut UnusedGenericParams,\n }\n \n impl<'a, 'tcx> MarkUsedGenericParams<'a, 'tcx> {\n@@ -244,7 +242,7 @@ impl<'a, 'tcx> MarkUsedGenericParams<'a, 'tcx> {\n         debug!(?self.unused_parameters, ?unused);\n         for (i, arg) in substs.iter().enumerate() {\n             let i = i.try_into().unwrap();\n-            if !unused.contains(i).unwrap_or(false) {\n+            if unused.is_used(i) {\n                 arg.visit_with(self);\n             }\n         }\n@@ -308,7 +306,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n         match c.kind() {\n             ty::ConstKind::Param(param) => {\n                 debug!(?param);\n-                self.unused_parameters.clear(param.index);\n+                self.unused_parameters.mark_used(param.index);\n                 ControlFlow::CONTINUE\n             }\n             ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs })\n@@ -342,55 +340,10 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n             }\n             ty::Param(param) => {\n                 debug!(?param);\n-                self.unused_parameters.clear(param.index);\n+                self.unused_parameters.mark_used(param.index);\n                 ControlFlow::CONTINUE\n             }\n             _ => ty.super_visit_with(self),\n         }\n     }\n }\n-\n-/// Visitor used to check if a generic parameter is used.\n-struct HasUsedGenericParams<'a> {\n-    unused_parameters: &'a FiniteBitSet<u32>,\n-}\n-\n-impl<'a, 'tcx> TypeVisitor<'tcx> for HasUsedGenericParams<'a> {\n-    type BreakTy = ();\n-\n-    #[instrument(level = \"debug\", skip(self))]\n-    fn visit_const(&mut self, c: Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if !c.has_non_region_param() {\n-            return ControlFlow::CONTINUE;\n-        }\n-\n-        match c.kind() {\n-            ty::ConstKind::Param(param) => {\n-                if self.unused_parameters.contains(param.index).unwrap_or(false) {\n-                    ControlFlow::CONTINUE\n-                } else {\n-                    ControlFlow::BREAK\n-                }\n-            }\n-            _ => c.super_visit_with(self),\n-        }\n-    }\n-\n-    #[instrument(level = \"debug\", skip(self))]\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if !ty.has_non_region_param() {\n-            return ControlFlow::CONTINUE;\n-        }\n-\n-        match ty.kind() {\n-            ty::Param(param) => {\n-                if self.unused_parameters.contains(param.index).unwrap_or(false) {\n-                    ControlFlow::CONTINUE\n-                } else {\n-                    ControlFlow::BREAK\n-                }\n-            }\n-            _ => ty.super_visit_with(self),\n-        }\n-    }\n-}"}, {"sha": "06b970ad979770b633ed432e5e0e6ed0e6db06ed", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -970,6 +970,24 @@ pub(crate) struct StructLiteralBodyWithoutPathSugg {\n     pub after: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(parse_struct_literal_needing_parens)]\n+pub(crate) struct StructLiteralNeedingParens {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub sugg: StructLiteralNeedingParensSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct StructLiteralNeedingParensSugg {\n+    #[suggestion_part(code = \"(\")]\n+    pub before: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub after: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(parse_unmatched_angle_brackets)]\n pub(crate) struct UnmatchedAngleBrackets {\n@@ -1237,3 +1255,27 @@ pub(crate) struct ExpectedFnPathFoundFnKeyword {\n     #[suggestion(applicability = \"machine-applicable\", code = \"Fn\", style = \"verbose\")]\n     pub fn_token_span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_where_clause_before_tuple_struct_body)]\n+pub(crate) struct WhereClauseBeforeTupleStructBody {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(name_label)]\n+    pub name: Span,\n+    #[label(body_label)]\n+    pub body: Span,\n+    #[subdiagnostic]\n+    pub sugg: Option<WhereClauseBeforeTupleStructBodySugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n+pub(crate) struct WhereClauseBeforeTupleStructBodySugg {\n+    #[suggestion_part(code = \"{snippet}\")]\n+    pub left: Span,\n+    pub snippet: String,\n+    #[suggestion_part(code = \"\")]\n+    pub right: Span,\n+}"}, {"sha": "4c918c6702ed9b19f3a2ed08af51506c50e17666", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -12,9 +12,10 @@ use crate::errors::{\n     IncorrectAwait, IncorrectSemicolon, IncorrectUseOfAwait, ParenthesesInForHead,\n     ParenthesesInForHeadSugg, PatternMethodParamWithoutBody, QuestionMarkInType,\n     QuestionMarkInTypeSugg, SelfParamNotFirst, StructLiteralBodyWithoutPath,\n-    StructLiteralBodyWithoutPathSugg, SuggEscapeToUseAsIdentifier, SuggRemoveComma,\n-    UnexpectedConstInGenericParam, UnexpectedConstParamDeclaration,\n-    UnexpectedConstParamDeclarationSugg, UnmatchedAngleBrackets, UseEqInstead,\n+    StructLiteralBodyWithoutPathSugg, StructLiteralNeedingParens, StructLiteralNeedingParensSugg,\n+    SuggEscapeToUseAsIdentifier, SuggRemoveComma, UnexpectedConstInGenericParam,\n+    UnexpectedConstParamDeclaration, UnexpectedConstParamDeclarationSugg, UnmatchedAngleBrackets,\n+    UseEqInstead,\n };\n \n use crate::lexer::UnmatchedBrace;\n@@ -623,12 +624,15 @@ impl<'a> Parser<'a> {\n         &mut self,\n         lo: Span,\n         s: BlockCheckMode,\n+        maybe_struct_name: token::Token,\n+        can_be_struct_literal: bool,\n     ) -> Option<PResult<'a, P<Block>>> {\n         if self.token.is_ident() && self.look_ahead(1, |t| t == &token::Colon) {\n             // We might be having a struct literal where people forgot to include the path:\n             // fn foo() -> Foo {\n             //     field: value,\n             // }\n+            info!(?maybe_struct_name, ?self.token);\n             let mut snapshot = self.create_snapshot_for_diagnostic();\n             let path = Path {\n                 segments: ThinVec::new(),\n@@ -648,21 +652,32 @@ impl<'a> Parser<'a> {\n                     //     field: value,\n                     // } }\n                     err.delay_as_bug();\n-                    self.sess.emit_err(StructLiteralBodyWithoutPath {\n-                        span: expr.span,\n-                        sugg: StructLiteralBodyWithoutPathSugg {\n-                            before: expr.span.shrink_to_lo(),\n-                            after: expr.span.shrink_to_hi(),\n-                        },\n-                    });\n                     self.restore_snapshot(snapshot);\n                     let mut tail = self.mk_block(\n                         vec![self.mk_stmt_err(expr.span)],\n                         s,\n                         lo.to(self.prev_token.span),\n                     );\n                     tail.could_be_bare_literal = true;\n-                    Ok(tail)\n+                    if maybe_struct_name.is_ident() && can_be_struct_literal {\n+                        // Account for `if Example { a: one(), }.is_pos() {}`.\n+                        Err(self.sess.create_err(StructLiteralNeedingParens {\n+                            span: maybe_struct_name.span.to(expr.span),\n+                            sugg: StructLiteralNeedingParensSugg {\n+                                before: maybe_struct_name.span.shrink_to_lo(),\n+                                after: expr.span.shrink_to_hi(),\n+                            },\n+                        }))\n+                    } else {\n+                        self.sess.emit_err(StructLiteralBodyWithoutPath {\n+                            span: expr.span,\n+                            sugg: StructLiteralBodyWithoutPathSugg {\n+                                before: expr.span.shrink_to_lo(),\n+                                after: expr.span.shrink_to_hi(),\n+                            },\n+                        });\n+                        Ok(tail)\n+                    }\n                 }\n                 (Err(err), Ok(tail)) => {\n                     // We have a block tail that contains a somehow valid type ascription expr."}, {"sha": "dd2b03988c3e8089536b1412b2cbba1e50203a3b", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1325,7 +1325,10 @@ impl<'a> Parser<'a> {\n             self.parse_array_or_repeat_expr(Delimiter::Bracket)\n         } else if self.check_path() {\n             self.parse_path_start_expr()\n-        } else if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n+        } else if self.check_keyword(kw::Move)\n+            || self.check_keyword(kw::Static)\n+            || self.check_const_closure()\n+        {\n             self.parse_closure_expr()\n         } else if self.eat_keyword(kw::If) {\n             self.parse_if_expr()\n@@ -2039,7 +2042,7 @@ impl<'a> Parser<'a> {\n             });\n         }\n \n-        let (attrs, blk) = self.parse_block_common(lo, blk_mode)?;\n+        let (attrs, blk) = self.parse_block_common(lo, blk_mode, true)?;\n         Ok(self.mk_expr_with_attrs(blk.span, ExprKind::Block(blk, opt_label), attrs))\n     }\n \n@@ -2065,6 +2068,8 @@ impl<'a> Parser<'a> {\n             ClosureBinder::NotPresent\n         };\n \n+        let constness = self.parse_constness(Case::Sensitive);\n+\n         let movability =\n             if self.eat_keyword(kw::Static) { Movability::Static } else { Movability::Movable };\n \n@@ -2111,6 +2116,7 @@ impl<'a> Parser<'a> {\n             ExprKind::Closure(Box::new(ast::Closure {\n                 binder,\n                 capture_clause,\n+                constness,\n                 asyncness,\n                 movability,\n                 fn_decl,"}, {"sha": "8ba811715d80db6dc9bbf88837990d629e721a29", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 108, "deletions": 10, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,11 +1,20 @@\n+use crate::errors::{WhereClauseBeforeTupleStructBody, WhereClauseBeforeTupleStructBodySugg};\n+\n use super::{ForceCollect, Parser, TrailingToken};\n \n+use ast::token::Delimiter;\n use rustc_ast::token;\n use rustc_ast::{\n     self as ast, AttrVec, GenericBounds, GenericParam, GenericParamKind, TyKind, WhereClause,\n };\n use rustc_errors::{Applicability, PResult};\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, Ident};\n+use rustc_span::Span;\n+\n+enum PredicateOrStructBody {\n+    Predicate(ast::WherePredicate),\n+    StructBody(Vec<ast::FieldDef>),\n+}\n \n impl<'a> Parser<'a> {\n     /// Parses bounds of a lifetime parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n@@ -240,23 +249,39 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// Parses an optional where-clause and places it in `generics`.\n+    /// Parses an optional where-clause.\n     ///\n     /// ```ignore (only-for-syntax-highlight)\n     /// where T : Trait<U, V> + 'b, 'a : 'b\n     /// ```\n     pub(super) fn parse_where_clause(&mut self) -> PResult<'a, WhereClause> {\n+        self.parse_where_clause_common(None).map(|(clause, _)| clause)\n+    }\n+\n+    pub(super) fn parse_struct_where_clause(\n+        &mut self,\n+        struct_name: Ident,\n+        body_insertion_point: Span,\n+    ) -> PResult<'a, (WhereClause, Option<Vec<ast::FieldDef>>)> {\n+        self.parse_where_clause_common(Some((struct_name, body_insertion_point)))\n+    }\n+\n+    fn parse_where_clause_common(\n+        &mut self,\n+        struct_: Option<(Ident, Span)>,\n+    ) -> PResult<'a, (WhereClause, Option<Vec<ast::FieldDef>>)> {\n         let mut where_clause = WhereClause {\n             has_where_token: false,\n             predicates: Vec::new(),\n             span: self.prev_token.span.shrink_to_hi(),\n         };\n+        let mut tuple_struct_body = None;\n \n         if !self.eat_keyword(kw::Where) {\n-            return Ok(where_clause);\n+            return Ok((where_clause, None));\n         }\n         where_clause.has_where_token = true;\n-        let lo = self.prev_token.span;\n+        let where_lo = self.prev_token.span;\n \n         // We are considering adding generics to the `where` keyword as an alternative higher-rank\n         // parameter syntax (as in `where<'a>` or `where<T>`. To avoid that being a breaking\n@@ -272,21 +297,30 @@ impl<'a> Parser<'a> {\n         }\n \n         loop {\n-            let lo = self.token.span;\n+            let where_sp = where_lo.to(self.prev_token.span);\n+            let pred_lo = self.token.span;\n             if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n                 let lifetime = self.expect_lifetime();\n                 // Bounds starting with a colon are mandatory, but possibly empty.\n                 self.expect(&token::Colon)?;\n                 let bounds = self.parse_lt_param_bounds();\n                 where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n                     ast::WhereRegionPredicate {\n-                        span: lo.to(self.prev_token.span),\n+                        span: pred_lo.to(self.prev_token.span),\n                         lifetime,\n                         bounds,\n                     },\n                 ));\n             } else if self.check_type() {\n-                where_clause.predicates.push(self.parse_ty_where_predicate()?);\n+                match self.parse_ty_where_predicate_or_recover_tuple_struct_body(\n+                    struct_, pred_lo, where_sp,\n+                )? {\n+                    PredicateOrStructBody::Predicate(pred) => where_clause.predicates.push(pred),\n+                    PredicateOrStructBody::StructBody(body) => {\n+                        tuple_struct_body = Some(body);\n+                        break;\n+                    }\n+                }\n             } else {\n                 break;\n             }\n@@ -297,7 +331,7 @@ impl<'a> Parser<'a> {\n             if self.eat_keyword_noexpect(kw::Where) {\n                 let msg = \"cannot define duplicate `where` clauses on an item\";\n                 let mut err = self.struct_span_err(self.token.span, msg);\n-                err.span_label(lo, \"previous `where` clause starts here\");\n+                err.span_label(pred_lo, \"previous `where` clause starts here\");\n                 err.span_suggestion_verbose(\n                     prev_token.shrink_to_hi().to(self.prev_token.span),\n                     \"consider joining the two `where` clauses into one\",\n@@ -310,8 +344,72 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        where_clause.span = lo.to(self.prev_token.span);\n-        Ok(where_clause)\n+        where_clause.span = where_lo.to(self.prev_token.span);\n+        Ok((where_clause, tuple_struct_body))\n+    }\n+\n+    fn parse_ty_where_predicate_or_recover_tuple_struct_body(\n+        &mut self,\n+        struct_: Option<(Ident, Span)>,\n+        pred_lo: Span,\n+        where_sp: Span,\n+    ) -> PResult<'a, PredicateOrStructBody> {\n+        let mut snapshot = None;\n+\n+        if let Some(struct_) = struct_\n+            && self.may_recover()\n+            && self.token.kind == token::OpenDelim(Delimiter::Parenthesis)\n+        {\n+            snapshot = Some((struct_, self.create_snapshot_for_diagnostic()));\n+        };\n+\n+        match self.parse_ty_where_predicate() {\n+            Ok(pred) => Ok(PredicateOrStructBody::Predicate(pred)),\n+            Err(type_err) => {\n+                let Some(((struct_name, body_insertion_point), mut snapshot)) = snapshot else {\n+                    return Err(type_err);\n+                };\n+\n+                // Check if we might have encountered an out of place tuple struct body.\n+                match snapshot.parse_tuple_struct_body() {\n+                    // Since we don't know the exact reason why we failed to parse the\n+                    // predicate (we might have stumbled upon something bogus like `(T): ?`),\n+                    // employ a simple heuristic to weed out some pathological cases:\n+                    // Look for a semicolon (strong indicator) or anything that might mark\n+                    // the end of the item (weak indicator) following the body.\n+                    Ok(body)\n+                        if matches!(snapshot.token.kind, token::Semi | token::Eof)\n+                            || snapshot.token.can_begin_item() =>\n+                    {\n+                        type_err.cancel();\n+\n+                        let body_sp = pred_lo.to(snapshot.prev_token.span);\n+                        let map = self.sess.source_map();\n+\n+                        self.sess.emit_err(WhereClauseBeforeTupleStructBody {\n+                            span: where_sp,\n+                            name: struct_name.span,\n+                            body: body_sp,\n+                            sugg: map.span_to_snippet(body_sp).ok().map(|body| {\n+                                WhereClauseBeforeTupleStructBodySugg {\n+                                    left: body_insertion_point.shrink_to_hi(),\n+                                    snippet: body,\n+                                    right: map.end_point(where_sp).to(body_sp),\n+                                }\n+                            }),\n+                        });\n+\n+                        self.restore_snapshot(snapshot);\n+                        Ok(PredicateOrStructBody::StructBody(body))\n+                    }\n+                    Ok(_) => Err(type_err),\n+                    Err(body_err) => {\n+                        body_err.cancel();\n+                        Err(type_err)\n+                    }\n+                }\n+            }\n+        }\n     }\n \n     fn parse_ty_where_predicate(&mut self) -> PResult<'a, ast::WherePredicate> {"}, {"sha": "53680a82bdc2e11825a278169dab577cb8aa8ddf", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1454,8 +1454,16 @@ impl<'a> Parser<'a> {\n         // struct.\n \n         let vdata = if self.token.is_keyword(kw::Where) {\n-            generics.where_clause = self.parse_where_clause()?;\n-            if self.eat(&token::Semi) {\n+            let tuple_struct_body;\n+            (generics.where_clause, tuple_struct_body) =\n+                self.parse_struct_where_clause(class_name, generics.span)?;\n+\n+            if let Some(body) = tuple_struct_body {\n+                // If we see a misplaced tuple struct body: `struct Foo<T> where T: Copy, (T);`\n+                let body = VariantData::Tuple(body, DUMMY_NODE_ID);\n+                self.expect_semi()?;\n+                body\n+            } else if self.eat(&token::Semi) {\n                 // If we see a: `struct Foo<T> where T: Copy;` style decl.\n                 VariantData::Unit(DUMMY_NODE_ID)\n             } else {\n@@ -1575,7 +1583,7 @@ impl<'a> Parser<'a> {\n         Ok((fields, recovered))\n     }\n \n-    fn parse_tuple_struct_body(&mut self) -> PResult<'a, Vec<FieldDef>> {\n+    pub(super) fn parse_tuple_struct_body(&mut self) -> PResult<'a, Vec<FieldDef>> {\n         // This is the case where we find `struct Foo<T>(T) where T: Copy;`\n         // Unit like structs are handled in parse_item_struct function\n         self.parse_paren_comma_seq(|p| {\n@@ -2214,7 +2222,8 @@ impl<'a> Parser<'a> {\n             *sig_hi = self.prev_token.span;\n             (AttrVec::new(), None)\n         } else if self.check(&token::OpenDelim(Delimiter::Brace)) || self.token.is_whole_block() {\n-            self.parse_inner_attrs_and_block().map(|(attrs, body)| (attrs, Some(body)))?\n+            self.parse_block_common(self.token.span, BlockCheckMode::Default, false)\n+                .map(|(attrs, body)| (attrs, Some(body)))?\n         } else if self.token.kind == token::Eq {\n             // Recover `fn foo() = $expr;`.\n             self.bump(); // `=`"}, {"sha": "ffb23b50a160de4101fb021faff9b6af54166b4c", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -542,9 +542,9 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Expect next token to be edible or inedible token.  If edible,\n+    /// Expect next token to be edible or inedible token. If edible,\n     /// then consume it; if inedible, then return without consuming\n-    /// anything.  Signal a fatal error if next token is unexpected.\n+    /// anything. Signal a fatal error if next token is unexpected.\n     pub fn expect_one_of(\n         &mut self,\n         edible: &[TokenKind],\n@@ -736,6 +736,16 @@ impl<'a> Parser<'a> {\n         self.check_or_expected(self.token.can_begin_const_arg(), TokenType::Const)\n     }\n \n+    fn check_const_closure(&self) -> bool {\n+        self.is_keyword_ahead(0, &[kw::Const])\n+            && self.look_ahead(1, |t| match &t.kind {\n+                token::Ident(kw::Move | kw::Static | kw::Async, _)\n+                | token::OrOr\n+                | token::BinOp(token::Or) => true,\n+                _ => false,\n+            })\n+    }\n+\n     fn check_inline_const(&self, dist: usize) -> bool {\n         self.is_keyword_ahead(dist, &[kw::Const])\n             && self.look_ahead(dist + 1, |t| match &t.kind {"}, {"sha": "1e5c2834960352c03082ef1e40994755af26dff4", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -498,24 +498,31 @@ impl<'a> Parser<'a> {\n \n     /// Parses a block. Inner attributes are allowed.\n     pub(super) fn parse_inner_attrs_and_block(&mut self) -> PResult<'a, (AttrVec, P<Block>)> {\n-        self.parse_block_common(self.token.span, BlockCheckMode::Default)\n+        self.parse_block_common(self.token.span, BlockCheckMode::Default, true)\n     }\n \n     /// Parses a block. Inner attributes are allowed.\n     pub(super) fn parse_block_common(\n         &mut self,\n         lo: Span,\n         blk_mode: BlockCheckMode,\n+        can_be_struct_literal: bool,\n     ) -> PResult<'a, (AttrVec, P<Block>)> {\n         maybe_whole!(self, NtBlock, |x| (AttrVec::new(), x));\n \n+        let maybe_ident = self.prev_token.clone();\n         self.maybe_recover_unexpected_block_label();\n         if !self.eat(&token::OpenDelim(Delimiter::Brace)) {\n             return self.error_block_no_opening_brace();\n         }\n \n         let attrs = self.parse_inner_attributes()?;\n-        let tail = match self.maybe_suggest_struct_literal(lo, blk_mode) {\n+        let tail = match self.maybe_suggest_struct_literal(\n+            lo,\n+            blk_mode,\n+            maybe_ident,\n+            can_be_struct_literal,\n+        ) {\n             Some(tail) => tail?,\n             None => self.parse_block_tail(lo, blk_mode, AttemptLocalParseRecovery::Yes)?,\n         };"}, {"sha": "6afdcc37fe86ea9d15652bcd848aec739c6ad4b8", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -191,9 +191,9 @@ pub fn provide(providers: &mut Providers) {\n // Creating ir_maps\n //\n // This is the first pass and the one that drives the main\n-// computation.  It walks up and down the IR once.  On the way down,\n+// computation. It walks up and down the IR once. On the way down,\n // we count for each function the number of variables as well as\n-// liveness nodes.  A liveness node is basically an expression or\n+// liveness nodes. A liveness node is basically an expression or\n // capture clause that does something of interest: either it has\n // interesting control flow or it uses/defines a local variable.\n //\n@@ -203,11 +203,11 @@ pub fn provide(providers: &mut Providers) {\n // of live variables at each program point.\n //\n // Finally, we run back over the IR one last time and, using the\n-// computed liveness, check various safety conditions.  For example,\n+// computed liveness, check various safety conditions. For example,\n // there must be no live nodes at the definition site for a variable\n-// unless it has an initializer.  Similarly, each non-mutable local\n+// unless it has an initializer. Similarly, each non-mutable local\n // variable must not be assigned if there is some successor\n-// assignment.  And so forth.\n+// assignment. And so forth.\n \n struct CaptureInfo {\n     ln: LiveNode,\n@@ -417,7 +417,7 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n                 self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span, expr.hir_id));\n \n                 // Make a live_node for each mentioned variable, with the span\n-                // being the location that the variable is used.  This results\n+                // being the location that the variable is used. This results\n                 // in better error messages than just pointing at the closure\n                 // construction site.\n                 let mut call_caps = Vec::new();\n@@ -792,7 +792,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match stmt.kind {\n             hir::StmtKind::Local(ref local) => {\n                 // Note: we mark the variable as defined regardless of whether\n-                // there is an initializer.  Initially I had thought to only mark\n+                // there is an initializer. Initially I had thought to only mark\n                 // the live variable as defined if it was initialized, and then we\n                 // could check for uninit variables just by scanning what is live\n                 // at the start of the function. But that doesn't work so well for\n@@ -1169,24 +1169,24 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         //\n         // # Tracked places\n         //\n-        // A tracked place is a local variable/argument `x`.  In\n+        // A tracked place is a local variable/argument `x`. In\n         // these cases, the link_node where the write occurs is linked\n-        // to node id of `x`.  The `write_place()` routine generates\n-        // the contents of this node.  There are no subcomponents to\n+        // to node id of `x`. The `write_place()` routine generates\n+        // the contents of this node. There are no subcomponents to\n         // consider.\n         //\n         // # Non-tracked places\n         //\n-        // These are places like `x[5]` or `x.f`.  In that case, we\n+        // These are places like `x[5]` or `x.f`. In that case, we\n         // basically ignore the value which is written to but generate\n-        // reads for the components---`x` in these two examples.  The\n+        // reads for the components---`x` in these two examples. The\n         // components reads are generated by\n         // `propagate_through_place_components()` (this fn).\n         //\n         // # Illegal places\n         //\n         // It is still possible to observe assignments to non-places;\n-        // these errors are detected in the later pass borrowck.  We\n+        // these errors are detected in the later pass borrowck. We\n         // just ignore such cases and treat them as reads.\n \n         match expr.kind {\n@@ -1204,7 +1204,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             // We do not track other places, so just propagate through\n-            // to their subcomponents.  Also, it may happen that\n+            // to their subcomponents. Also, it may happen that\n             // non-places occur here, because those are detected in the\n             // later pass borrowck.\n             _ => succ,"}, {"sha": "34e1abb78b2d4fa33323c278cd85d36d24a70fce", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         }\n \n         if !self.tcx.features().staged_api {\n-            // Propagate unstability.  This can happen even for non-staged-api crates in case\n+            // Propagate unstability. This can happen even for non-staged-api crates in case\n             // -Zforce-unstable-if-unmarked is set.\n             if let Some(stab) = self.parent_stab {\n                 if inherit_deprecation.yes() && stab.is_unstable() {"}, {"sha": "564cb1baa690914fca320ceb77a56a07e17b5706", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1755,7 +1755,7 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n         // clauses that the compiler inferred. We only want to\n         // consider the ones that the user wrote. This is important\n         // for the inferred outlives rules; see\n-        // `src/test/ui/rfc-2093-infer-outlives/privacy.rs`.\n+        // `tests/ui/rfc-2093-infer-outlives/privacy.rs`.\n         self.visit_predicates(self.tcx.explicit_predicates_of(self.item_def_id));\n         self\n     }"}, {"sha": "47b2fd8f8f47a4d31da672b7e76c5de3b69d5d2f", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -490,8 +490,8 @@ impl<K: DepKind> DepGraph<K> {\n     /// This is used to remove cycles during type-checking const generic parameters.\n     ///\n     /// As usual in the query system, we consider the current state of the calling query\n-    /// only depends on the list of dependencies up to now.  As a consequence, the value\n-    /// that this query gives us can only depend on those dependencies too.  Therefore,\n+    /// only depends on the list of dependencies up to now. As a consequence, the value\n+    /// that this query gives us can only depend on those dependencies too. Therefore,\n     /// it is sound to use the current dependency set for the created node.\n     ///\n     /// During replay, the order of the nodes is relevant in the dependency graph.\n@@ -510,9 +510,9 @@ impl<K: DepKind> DepGraph<K> {\n         hash_result: Option<fn(&mut StableHashingContext<'_>, &R) -> Fingerprint>,\n     ) -> DepNodeIndex {\n         if let Some(data) = self.data.as_ref() {\n-            // The caller query has more dependencies than the node we are creating.  We may\n+            // The caller query has more dependencies than the node we are creating. We may\n             // encounter a case where this created node is marked as green, but the caller query is\n-            // subsequently marked as red or recomputed.  In this case, we will end up feeding a\n+            // subsequently marked as red or recomputed. In this case, we will end up feeding a\n             // value to an existing node.\n             //\n             // For sanity, we still check that the loaded stable hash and the new one match.\n@@ -980,7 +980,7 @@ rustc_index::newtype_index! {\n /// graph: they are only added.\n ///\n /// The nodes in it are identified by a `DepNodeIndex`. We avoid keeping the nodes\n-/// in memory.  This is important, because these graph structures are some of the\n+/// in memory. This is important, because these graph structures are some of the\n /// largest in the compiler.\n ///\n /// For this reason, we avoid storing `DepNode`s more than once as map"}, {"sha": "a81595b2420c041e9c8e535483c8fc3f5f601dfd", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,14 +1,14 @@\n //! The data that we will serialize and deserialize.\n //!\n //! The dep-graph is serialized as a sequence of NodeInfo, with the dependencies\n-//! specified inline.  The total number of nodes and edges are stored as the last\n+//! specified inline. The total number of nodes and edges are stored as the last\n //! 16 bytes of the file, so we can find them easily at decoding time.\n //!\n //! The serialisation is performed on-demand when each node is emitted. Using this\n //! scheme, we do not need to keep the current graph in memory.\n //!\n //! The deserialization is performed manually, in order to convert from the stored\n-//! sequence of NodeInfos to the different arrays in SerializedDepGraph.  Since the\n+//! sequence of NodeInfos to the different arrays in SerializedDepGraph. Since the\n //! node and edge count are stored at the end of the file, all the arrays can be\n //! pre-allocated with the right length.\n "}, {"sha": "77d0d0314fc17de7a36de449436e484118bec350", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -116,7 +116,7 @@ where\n         let mut lock = self.cache.get_shard_by_value(&key).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n-        // We may be overwriting another value.  This is all right, since the dep-graph\n+        // We may be overwriting another value. This is all right, since the dep-graph\n         // will check that the fingerprint matches.\n         lock.insert(key, (value.clone(), index));\n         value\n@@ -203,7 +203,7 @@ where\n         let mut lock = self.cache.get_shard_by_value(&key).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n-        // We may be overwriting another value.  This is all right, since the dep-graph\n+        // We may be overwriting another value. This is all right, since the dep-graph\n         // will check that the fingerprint matches.\n         lock.insert(key, value);\n         &value.0"}, {"sha": "b1b04c92a75042cfa4af912ff5024c1acbde65f5", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -334,6 +334,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         self.r.field_names.insert(def_id, field_names);\n     }\n \n+    fn insert_field_visibilities_local(&mut self, def_id: DefId, vdata: &ast::VariantData) {\n+        let field_vis = vdata\n+            .fields()\n+            .iter()\n+            .map(|field| field.vis.span.until(field.ident.map_or(field.ty.span, |i| i.span)))\n+            .collect();\n+        self.r.field_visibility_spans.insert(def_id, field_vis);\n+    }\n+\n     fn insert_field_names_extern(&mut self, def_id: DefId) {\n         let field_names =\n             self.r.cstore().struct_field_names_untracked(def_id, self.r.session).collect();\n@@ -514,7 +523,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                             ModuleKind::Block => unreachable!(),\n                         };\n                         // HACK(eddyb) unclear how good this is, but keeping `$crate`\n-                        // in `source` breaks `src/test/ui/imports/import-crate-var.rs`,\n+                        // in `source` breaks `tests/ui/imports/import-crate-var.rs`,\n                         // while the current crate doesn't have a valid `crate_name`.\n                         if crate_name != kw::Empty {\n                             // `crate_name` should not be interpreted as relative.\n@@ -737,6 +746,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n                 // Record field names for error reporting.\n                 self.insert_field_names_local(def_id, vdata);\n+                self.insert_field_visibilities_local(def_id, vdata);\n \n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n@@ -770,6 +780,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id.to_def_id());\n                     self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, sp, expansion));\n                     self.r.visibilities.insert(ctor_def_id, ctor_vis);\n+                    // We need the field visibility spans also for the constructor for E0603.\n+                    self.insert_field_visibilities_local(ctor_def_id.to_def_id(), vdata);\n \n                     self.r\n                         .struct_constructors\n@@ -783,6 +795,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n                 // Record field names for error reporting.\n                 self.insert_field_names_local(def_id, vdata);\n+                self.insert_field_visibilities_local(def_id, vdata);\n             }\n \n             ItemKind::Trait(..) => {\n@@ -1510,6 +1523,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n \n         // Record field names for error reporting.\n         self.insert_field_names_local(def_id.to_def_id(), &variant.data);\n+        self.insert_field_visibilities_local(def_id.to_def_id(), &variant.data);\n \n         visit::walk_variant(self, variant);\n     }"}, {"sha": "1a852de8eed690d29e6e2cabebff7ead288bb83c", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -6,7 +6,9 @@ use rustc_ast::{self as ast, Crate, ItemKind, ModKind, NodeId, Path, CRATE_NODE_\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n+use rustc_errors::{\n+    pluralize, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n+};\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind, PerNS};\n@@ -161,6 +163,7 @@ impl<'a> Resolver<'a> {\n                     found_use,\n                     DiagnosticMode::Normal,\n                     path,\n+                    \"\",\n                 );\n                 err.emit();\n             } else if let Some((span, msg, sugg, appl)) = suggestion {\n@@ -690,6 +693,7 @@ impl<'a> Resolver<'a> {\n                         FoundUse::Yes,\n                         DiagnosticMode::Pattern,\n                         vec![],\n+                        \"\",\n                     );\n                 }\n                 err\n@@ -1344,6 +1348,7 @@ impl<'a> Resolver<'a> {\n             FoundUse::Yes,\n             DiagnosticMode::Normal,\n             vec![],\n+            \"\",\n         );\n \n         if macro_kind == MacroKind::Derive && (ident.name == sym::Send || ident.name == sym::Sync) {\n@@ -1601,6 +1606,16 @@ impl<'a> Resolver<'a> {\n         err.span_label(ident.span, &format!(\"private {}\", descr));\n         if let Some(span) = ctor_fields_span {\n             err.span_label(span, \"a constructor is private if any of the fields is private\");\n+            if let Res::Def(_, d) = res && let Some(fields) = self.field_visibility_spans.get(&d) {\n+                err.multipart_suggestion_verbose(\n+                    &format!(\n+                        \"consider making the field{} publicly accessible\",\n+                        pluralize!(fields.len())\n+                    ),\n+                    fields.iter().map(|span| (*span, \"pub \".to_string())).collect(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n         }\n \n         // Print the whole import chain to make it easier to see what happens.\n@@ -2309,7 +2324,7 @@ enum FoundUse {\n }\n \n /// Whether a binding is part of a pattern or a use statement. Used for diagnostics.\n-enum DiagnosticMode {\n+pub(crate) enum DiagnosticMode {\n     Normal,\n     /// The binding is part of a pattern\n     Pattern,\n@@ -2324,6 +2339,8 @@ pub(crate) fn import_candidates(\n     // This is `None` if all placement locations are inside expansions\n     use_placement_span: Option<Span>,\n     candidates: &[ImportSuggestion],\n+    mode: DiagnosticMode,\n+    append: &str,\n ) {\n     show_candidates(\n         session,\n@@ -2333,8 +2350,9 @@ pub(crate) fn import_candidates(\n         candidates,\n         Instead::Yes,\n         FoundUse::Yes,\n-        DiagnosticMode::Import,\n+        mode,\n         vec![],\n+        append,\n     );\n }\n \n@@ -2352,6 +2370,7 @@ fn show_candidates(\n     found_use: FoundUse,\n     mode: DiagnosticMode,\n     path: Vec<Segment>,\n+    append: &str,\n ) {\n     if candidates.is_empty() {\n         return;\n@@ -2416,7 +2435,7 @@ fn show_candidates(\n                 // produce an additional newline to separate the new use statement\n                 // from the directly following item.\n                 let additional_newline = if let FoundUse::Yes = found_use { \"\" } else { \"\\n\" };\n-                candidate.0 = format!(\"{}{};\\n{}\", add_use, &candidate.0, additional_newline);\n+                candidate.0 = format!(\"{add_use}{}{append};\\n{additional_newline}\", &candidate.0);\n             }\n \n             err.span_suggestions("}, {"sha": "00f65ac37b6a8eaaa0105b5fd422184229679c2c", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 55, "deletions": 26, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1,6 +1,6 @@\n //! A bunch of methods and structures more or less related to resolving imports.\n \n-use crate::diagnostics::{import_candidates, Suggestion};\n+use crate::diagnostics::{import_candidates, DiagnosticMode, Suggestion};\n use crate::Determinacy::{self, *};\n use crate::Namespace::*;\n use crate::{module_to_string, names_to_string, ImportSuggestion};\n@@ -402,7 +402,7 @@ struct UnresolvedImportError {\n     label: Option<String>,\n     note: Option<String>,\n     suggestion: Option<Suggestion>,\n-    candidate: Option<Vec<ImportSuggestion>>,\n+    candidates: Option<Vec<ImportSuggestion>>,\n }\n \n pub struct ImportResolver<'a, 'b> {\n@@ -475,12 +475,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     errors = vec![];\n                 }\n                 if seen_spans.insert(err.span) {\n-                    let path = import_path_to_string(\n-                        &import.module_path.iter().map(|seg| seg.ident).collect::<Vec<_>>(),\n-                        &import.kind,\n-                        err.span,\n-                    );\n-                    errors.push((path, err));\n+                    errors.push((import, err));\n                     prev_root_id = import.root_id;\n                 }\n             } else if is_indeterminate {\n@@ -494,10 +489,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     label: None,\n                     note: None,\n                     suggestion: None,\n-                    candidate: None,\n+                    candidates: None,\n                 };\n+                // FIXME: there should be a better way of doing this than\n+                // formatting this as a string then checking for `::`\n                 if path.contains(\"::\") {\n-                    errors.push((path, err))\n+                    errors.push((import, err))\n                 }\n             }\n         }\n@@ -507,7 +504,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         }\n     }\n \n-    fn throw_unresolved_import_error(&self, errors: Vec<(String, UnresolvedImportError)>) {\n+    fn throw_unresolved_import_error(&self, errors: Vec<(&Import<'_>, UnresolvedImportError)>) {\n         if errors.is_empty() {\n             return;\n         }\n@@ -516,7 +513,17 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         const MAX_LABEL_COUNT: usize = 10;\n \n         let span = MultiSpan::from_spans(errors.iter().map(|(_, err)| err.span).collect());\n-        let paths = errors.iter().map(|(path, _)| format!(\"`{}`\", path)).collect::<Vec<_>>();\n+        let paths = errors\n+            .iter()\n+            .map(|(import, err)| {\n+                let path = import_path_to_string(\n+                    &import.module_path.iter().map(|seg| seg.ident).collect::<Vec<_>>(),\n+                    &import.kind,\n+                    err.span,\n+                );\n+                format!(\"`{path}`\")\n+            })\n+            .collect::<Vec<_>>();\n         let msg = format!(\"unresolved import{} {}\", pluralize!(paths.len()), paths.join(\", \"),);\n \n         let mut diag = struct_span_err!(self.r.session, span, E0432, \"{}\", &msg);\n@@ -525,7 +532,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             diag.note(note);\n         }\n \n-        for (_, err) in errors.into_iter().take(MAX_LABEL_COUNT) {\n+        for (import, err) in errors.into_iter().take(MAX_LABEL_COUNT) {\n             if let Some(label) = err.label {\n                 diag.span_label(err.span, label);\n             }\n@@ -538,14 +545,36 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 diag.multipart_suggestion(&msg, suggestions, applicability);\n             }\n \n-            if let Some(candidate) = &err.candidate {\n-                import_candidates(\n-                    self.r.session,\n-                    &self.r.untracked.source_span,\n-                    &mut diag,\n-                    Some(err.span),\n-                    &candidate,\n-                )\n+            if let Some(candidates) = &err.candidates {\n+                match &import.kind {\n+                    ImportKind::Single { nested: false, source, target, .. } => import_candidates(\n+                        self.r.session,\n+                        &self.r.untracked.source_span,\n+                        &mut diag,\n+                        Some(err.span),\n+                        &candidates,\n+                        DiagnosticMode::Import,\n+                        (source != target)\n+                            .then(|| format!(\" as {target}\"))\n+                            .as_deref()\n+                            .unwrap_or(\"\"),\n+                    ),\n+                    ImportKind::Single { nested: true, source, target, .. } => {\n+                        import_candidates(\n+                            self.r.session,\n+                            &self.r.untracked.source_span,\n+                            &mut diag,\n+                            None,\n+                            &candidates,\n+                            DiagnosticMode::Normal,\n+                            (source != target)\n+                                .then(|| format!(\" as {target}\"))\n+                                .as_deref()\n+                                .unwrap_or(\"\"),\n+                        );\n+                    }\n+                    _ => {}\n+                }\n             }\n         }\n \n@@ -707,14 +736,14 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                 String::from(\"a similar path exists\"),\n                                 Applicability::MaybeIncorrect,\n                             )),\n-                            candidate: None,\n+                            candidates: None,\n                         },\n                         None => UnresolvedImportError {\n                             span,\n                             label: Some(label),\n                             note: None,\n                             suggestion,\n-                            candidate: None,\n+                            candidates: None,\n                         },\n                     };\n                     return Some(err);\n@@ -761,7 +790,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                 )),\n                                 note: None,\n                                 suggestion: None,\n-                                candidate: None,\n+                                candidates: None,\n                             });\n                         }\n                     }\n@@ -873,7 +902,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n                 let names = resolutions\n                     .filter_map(|(BindingKey { ident: i, .. }, resolution)| {\n-                        if *i == ident {\n+                        if i.name == ident.name {\n                             return None;\n                         } // Never suggest the same name\n                         match *resolution.borrow() {\n@@ -943,7 +972,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     label: Some(label),\n                     note,\n                     suggestion,\n-                    candidate: if !parent_suggestion.is_empty() {\n+                    candidates: if !parent_suggestion.is_empty() {\n                         Some(parent_suggestion)\n                     } else {\n                         None"}, {"sha": "d6491b8b0146619de3fb1ed2544b8b9309bb6846", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -668,7 +668,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     && let Some(partial_res) = self.r.partial_res_map.get(&ty.id)\n                     && let Some(Res::Def(DefKind::Trait | DefKind::TraitAlias, _)) = partial_res.full_res()\n                 {\n-                    // This path is actually a bare trait object.  In case of a bare `Fn`-trait\n+                    // This path is actually a bare trait object. In case of a bare `Fn`-trait\n                     // object with anonymous lifetimes, we need this rib to correctly place the\n                     // synthetic lifetimes.\n                     let span = ty.span.shrink_to_lo().to(path.span.shrink_to_lo());\n@@ -1046,7 +1046,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     // Probe the lifetime ribs to know how to behave.\n                     for rib in self.lifetime_ribs.iter().rev() {\n                         match rib.kind {\n-                            // We are inside a `PolyTraitRef`.  The lifetimes are\n+                            // We are inside a `PolyTraitRef`. The lifetimes are\n                             // to be intoduced in that (maybe implicit) `for<>` binder.\n                             LifetimeRibKind::Generics {\n                                 binder,\n@@ -1069,7 +1069,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                                 );\n                                 break;\n                             }\n-                            // We have nowhere to introduce generics.  Code is malformed,\n+                            // We have nowhere to introduce generics. Code is malformed,\n                             // so use regular lifetime resolution to avoid spurious errors.\n                             LifetimeRibKind::Item | LifetimeRibKind::Generics { .. } => {\n                                 visit::walk_generic_args(self, args);\n@@ -1775,7 +1775,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         break;\n                     }\n                     // `LifetimeRes::Error`, which would usually be used in the case of\n-                    // `ReportError`, is unsuitable here, as we don't emit an error yet.  Instead,\n+                    // `ReportError`, is unsuitable here, as we don't emit an error yet. Instead,\n                     // we simply resolve to an implicit lifetime, which will be checked later, at\n                     // which point a suitable error will be emitted.\n                     LifetimeRibKind::AnonymousReportError | LifetimeRibKind::Item => {\n@@ -3647,7 +3647,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         if let Some(qself) = qself {\n             if qself.position == 0 {\n                 // This is a case like `<T>::B`, where there is no\n-                // trait to resolve.  In that case, we leave the `B`\n+                // trait to resolve. In that case, we leave the `B`\n                 // segment to be resolved by type-check.\n                 return Ok(Some(PartialRes::with_unresolved_segments(\n                     Res::Def(DefKind::Mod, CRATE_DEF_ID.to_def_id()),\n@@ -3658,7 +3658,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // Make sure `A::B` in `<T as A::B>::C` is a trait item.\n             //\n             // Currently, `path` names the full item (`A::B::C`, in\n-            // our example).  so we extract the prefix of that that is\n+            // our example). so we extract the prefix of that that is\n             // the trait (the slice upto and including\n             // `qself.position`). And then we recursively resolve that,\n             // but with `qself` set to `None`."}, {"sha": "d92f5a7c05e6d8473ae85c0eff0107f9e6be3300", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1451,6 +1451,17 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         .collect();\n \n                     if non_visible_spans.len() > 0 {\n+                        if let Some(fields) = self.r.field_visibility_spans.get(&def_id) {\n+                            err.multipart_suggestion_verbose(\n+                                &format!(\n+                                    \"consider making the field{} publicly accessible\",\n+                                    pluralize!(fields.len())\n+                                ),\n+                                fields.iter().map(|span| (*span, \"pub \".to_string())).collect(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+\n                         let mut m: MultiSpan = non_visible_spans.clone().into();\n                         non_visible_spans\n                             .into_iter()"}, {"sha": "84d9794ccf26671471aab168841bca043c1acdff", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -881,6 +881,10 @@ pub struct Resolver<'a> {\n     /// Used for hints during error reporting.\n     field_names: FxHashMap<DefId, Vec<Spanned<Symbol>>>,\n \n+    /// Span of the privacy modifier in fields of an item `DefId` accessible with dot syntax.\n+    /// Used for hints during error reporting.\n+    field_visibility_spans: FxHashMap<DefId, Vec<Span>>,\n+\n     /// All imports known to succeed or fail.\n     determined_imports: Vec<&'a Import<'a>>,\n \n@@ -1268,6 +1272,7 @@ impl<'a> Resolver<'a> {\n \n             has_self: FxHashSet::default(),\n             field_names: FxHashMap::default(),\n+            field_visibility_spans: FxHashMap::default(),\n \n             determined_imports: Vec::new(),\n             indeterminate_imports: Vec::new(),"}, {"sha": "1f9d634017135ee0420e0eb5a3ccd99e6098cf34", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -715,7 +715,7 @@ impl OutputFilenames {\n pub fn host_triple() -> &'static str {\n     // Get the host triple out of the build environment. This ensures that our\n     // idea of the host triple is the same as for the set of libraries we've\n-    // actually built.  We can't just take LLVM's host triple because they\n+    // actually built. We can't just take LLVM's host triple because they\n     // normalize all ix86 architectures to i386.\n     //\n     // Instead of grabbing the host triple (for the current host), we grab (at\n@@ -1271,7 +1271,7 @@ impl RustcOptGroup {\n \n // The `opt` local module holds wrappers around the `getopts` API that\n // adds extra rustc-specific metadata to each option; such metadata\n-// is exposed by .  The public\n+// is exposed by . The public\n // functions below ending with `_u` are the functions that return\n // *unstable* options, i.e., options that are only enabled when the\n // user also passes the `-Z unstable-options` debugging flag."}, {"sha": "4ae9a3fae474b3c9a993b97f77cf765de06ed3a7", "filename": "compiler/rustc_session/src/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcstore.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -228,7 +228,7 @@ pub trait CrateStore: std::fmt::Debug {\n     fn def_path_hash(&self, def: DefId) -> DefPathHash;\n \n     // This information is safe to access, since it's hashed as part of the StableCrateId, which\n-    // incr.  comp. uses to identify a CrateNum.\n+    // incr. comp. uses to identify a CrateNum.\n     fn crate_name(&self, cnum: CrateNum) -> Symbol;\n     fn stable_crate_id(&self, cnum: CrateNum) -> StableCrateId;\n     fn stable_crate_id_to_crate_num(&self, stable_crate_id: StableCrateId) -> CrateNum;"}, {"sha": "b6a328908ce085834d74cb534ba1503486cca6cf", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -155,7 +155,7 @@ pub fn sysroot_candidates() -> SmallVec<[PathBuf; 2]> {\n /// This function checks if sysroot is found using env::args().next(), and if it\n /// is not found, finds sysroot from current rustc_driver dll.\n pub fn get_or_default_sysroot() -> Result<PathBuf, String> {\n-    // Follow symlinks.  If the resolved path is relative, make it absolute.\n+    // Follow symlinks. If the resolved path is relative, make it absolute.\n     fn canonicalize(path: PathBuf) -> PathBuf {\n         let path = fs::canonicalize(&path).unwrap_or(path);\n         // See comments on this target function, but the gist is that"}, {"sha": "b062b43873b29b28120a142ea689a4c83977932b", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -1241,7 +1241,7 @@ options! {\n \n     // tidy-alphabetical-start\n     allow_features: Option<Vec<String>> = (None, parse_opt_comma_list, [TRACKED],\n-        \"only allow the listed language features to be enabled in code (space separated)\"),\n+        \"only allow the listed language features to be enabled in code (comma separated)\"),\n     always_encode_mir: bool = (false, parse_bool, [TRACKED],\n         \"encode MIR of all functions into the crate metadata (default: no)\"),\n     asm_comments: bool = (false, parse_bool, [TRACKED],\n@@ -1255,7 +1255,7 @@ options! {\n     binary_dep_depinfo: bool = (false, parse_bool, [TRACKED],\n         \"include artifacts (sysroot, crate dependencies) used during compilation in dep-info \\\n         (default: no)\"),\n-    box_noalias: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+    box_noalias: bool = (true, parse_bool, [TRACKED],\n         \"emit noalias metadata for box (default: yes)\"),\n     branch_protection: Option<BranchProtection> = (None, parse_branch_protection, [TRACKED],\n         \"set options for branch target identification and pointer authentication on AArch64\"),\n@@ -1437,7 +1437,7 @@ options! {\n         \"use line numbers relative to the function in mir pretty printing\"),\n     move_size_limit: Option<usize> = (None, parse_opt_number, [TRACKED],\n         \"the size at which the `large_assignments` lint starts to be emitted\"),\n-    mutable_noalias: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+    mutable_noalias: bool = (true, parse_bool, [TRACKED],\n         \"emit noalias metadata for mutable references (default: yes)\"),\n     nll_facts: bool = (false, parse_bool, [UNTRACKED],\n         \"dump facts from NLL analysis into side files (default: no)\"),\n@@ -1570,7 +1570,7 @@ options! {\n     /// o/w tests have closure@path\n     span_free_formats: bool = (false, parse_bool, [UNTRACKED],\n         \"exclude spans when debug-printing compiler state (default: no)\"),\n-    split_dwarf_inlining: bool = (true, parse_bool, [TRACKED],\n+    split_dwarf_inlining: bool = (false, parse_bool, [TRACKED],\n         \"provide minimal debug info in the object/executable to facilitate online \\\n          symbolication/stack traces in the absence of .dwo/.dwp files when using Split DWARF\"),\n     split_dwarf_kind: SplitDwarfKind = (SplitDwarfKind::Split, parse_split_dwarf_kind, [TRACKED],"}, {"sha": "cf45d6f1aa5c55c3c629731b287b5915aa39a3a7", "filename": "compiler/rustc_session/src/output.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foutput.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -29,9 +29,9 @@ pub fn out_filename(\n     out_filename\n }\n \n-/// Make sure files are writeable.  Mac, FreeBSD, and Windows system linkers\n+/// Make sure files are writeable. Mac, FreeBSD, and Windows system linkers\n /// check this already -- however, the Linux linker will happily overwrite a\n-/// read-only file.  We should be consistent.\n+/// read-only file. We should be consistent.\n pub fn check_file_is_writeable(file: &Path, sess: &Session) {\n     if !is_writeable(file) {\n         sess.emit_fatal(FileIsNotWriteable { file });"}, {"sha": "8d92954ec94972ee875ab2ed460c68f280f49ee9", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -197,7 +197,7 @@ pub struct Session {\n     pub ctfe_backtrace: Lock<CtfeBacktrace>,\n \n     /// This tracks where `-Zunleash-the-miri-inside-of-you` was used to get around a\n-    /// const check, optionally with the relevant feature gate.  We use this to\n+    /// const check, optionally with the relevant feature gate. We use this to\n     /// warn about unleashing, but with a single diagnostic instead of dozens that\n     /// drown everything else in noise.\n     miri_unleashed_features: Lock<Vec<(Span, Option<Symbol>)>>,"}, {"sha": "dee823eefde689b013e18644f0572b3bc9363678", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -338,7 +338,7 @@ pub struct HygieneData {\n     /// first and then resolved later), so we use an `Option` here.\n     local_expn_data: IndexVec<LocalExpnId, Option<ExpnData>>,\n     local_expn_hashes: IndexVec<LocalExpnId, ExpnHash>,\n-    /// Data and hash information from external crates.  We may eventually want to remove these\n+    /// Data and hash information from external crates. We may eventually want to remove these\n     /// maps, and fetch the information directly from the other crate's metadata like DefIds do.\n     foreign_expn_data: FxHashMap<ExpnId, ExpnData>,\n     foreign_expn_hashes: FxHashMap<ExpnId, ExpnHash>,"}, {"sha": "706002f79b1fb98163ff6e2abe678f0fdabe443c", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -498,6 +498,7 @@ symbols! {\n         console,\n         const_allocate,\n         const_async_blocks,\n+        const_closures,\n         const_compare_raw_pointers,\n         const_constructor,\n         const_deallocate,\n@@ -613,6 +614,7 @@ symbols! {\n         dispatch_from_dyn,\n         div,\n         div_assign,\n+        do_not_recommend,\n         doc,\n         doc_alias,\n         doc_auto_cfg,"}, {"sha": "b69ade7e4aa08eee89426153ea3d6b427e62af92", "filename": "compiler/rustc_target/src/spec/aarch64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -12,7 +12,7 @@ pub fn target() -> Target {\n \n     Target {\n         // Clang automatically chooses a more specific target based on\n-        // MACOSX_DEPLOYMENT_TARGET.  To enable cross-language LTO to work\n+        // MACOSX_DEPLOYMENT_TARGET. To enable cross-language LTO to work\n         // correctly, we do too.\n         llvm_target: macos_llvm_target(arch).into(),\n         pointer_width: 64,"}, {"sha": "ddecbb1a8c4a46350588fc91f5a10474dabceacb", "filename": "compiler/rustc_target/src/spec/aarch64_fuchsia.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9475277c235d2297dc446155325b0b3fcfdbf722/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_fuchsia.rs?ref=9475277c235d2297dc446155325b0b3fcfdbf722", "patch": "@@ -0,0 +1 @@\n+pub use crate::spec::aarch64_unknown_fuchsia::target;"}]}