{"sha": "31ba223c26824ed26d8f848b307d599ab24a733b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxYmEyMjNjMjY4MjRlZDI2ZDhmODQ4YjMwN2Q1OTlhYjI0YTczM2I=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-04-16T20:32:38Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-20T22:23:22Z"}, "message": "end-to-end impl of global loop w/ high-level ref counting.. needs work\n\n- starting/stoping the loop based on client work is functioning, correctly\n- the issue appears to be that, when the process is about to exit, the\nsignal to let weak tasks know that they need to exit isn't getting fired.", "tree": {"sha": "903bf16e7e3397fa85304e43a8e93a9ce5750a7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/903bf16e7e3397fa85304e43a8e93a9ce5750a7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31ba223c26824ed26d8f848b307d599ab24a733b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31ba223c26824ed26d8f848b307d599ab24a733b", "html_url": "https://github.com/rust-lang/rust/commit/31ba223c26824ed26d8f848b307d599ab24a733b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31ba223c26824ed26d8f848b307d599ab24a733b/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6f6a8ced4797b02a86c5143334f18a582db8d2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6f6a8ced4797b02a86c5143334f18a582db8d2e", "html_url": "https://github.com/rust-lang/rust/commit/e6f6a8ced4797b02a86c5143334f18a582db8d2e"}], "stats": {"total": 491, "additions": 440, "deletions": 51}, "files": [{"sha": "f72471dff6681e05b0b6885ef9adb4a187cf3dfa", "filename": "src/libstd/uv_hl.rs", "status": "modified", "additions": 440, "deletions": 51, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/31ba223c26824ed26d8f848b307d599ab24a733b/src%2Flibstd%2Fuv_hl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ba223c26824ed26d8f848b307d599ab24a733b/src%2Flibstd%2Fuv_hl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_hl.rs?ref=31ba223c26824ed26d8f848b307d599ab24a733b", "patch": "@@ -6,27 +6,135 @@ provide a high-level, abstracted interface to some set of\n libuv functionality.\n \"];\n \n+export high_level_loop;\n+export run_high_level_loop, interact, ref_handle, unref_handle;\n+// this will eventually move into its own, unexported (from std) module\n+export get_global_loop;\n+\n import ll = uv_ll;\n \n-export high_level_loop;\n-export interact, prepare_loop;\n+native mod rustrt {\n+    fn rust_uv_get_kernel_global_chan_ptr() -> *libc::uintptr_t;\n+    fn rust_uv_get_kernel_global_async_handle() -> **libc::c_void;\n+    fn rust_uv_set_kernel_global_async_handle(handle: *ll::uv_async_t);\n+    fn rust_uv_free_kernel_global_async_handle();\n+}\n \n #[doc = \"\n Used to abstract-away direct interaction with a libuv loop.\n \n # Arguments\n \n-* async_handle - a pointer to a uv_async_t struct used to 'poke'\n+* async_handle - a pointer to a pointer to a uv_async_t struct used to 'poke'\n the C uv loop to process any pending callbacks\n \n * op_chan - a channel used to send function callbacks to be processed\n by the C uv loop\n \"]\n type high_level_loop = {\n-    async_handle: *ll::uv_async_t,\n-    op_chan: comm::chan<fn~(*libc::c_void)>\n+    async_handle: **ll::uv_async_t,\n+    op_chan: comm::chan<high_level_msg>\n };\n \n+#[doc = \"\n+Race-free helper to get access to a global task where a libuv\n+loop is running.\n+\n+# Return\n+\n+* A `high_level_loop` that encapsulates communication with the global loop.\n+\"]\n+fn get_global_loop() -> high_level_loop unsafe {\n+    let global_loop_chan_ptr = rustrt::rust_uv_get_kernel_global_chan_ptr();\n+    log(debug, #fmt(\"ENTERING get_global_loop() loop chan: %?\",\n+       global_loop_chan_ptr));\n+    log(debug, #fmt(\"ENTERING get_global_loop() loop chan: %?\",\n+       global_loop_chan_ptr));\n+    log(debug,#fmt(\"value of loop ptr: %?\", *global_loop_chan_ptr));\n+\n+    let builder_fn = {||\n+        let builder = task::builder();\n+        let opts = {\n+            supervise: true,\n+            notify_chan: none,\n+            sched:\n+                some({mode: task::manual_threads(1u),\n+                      native_stack_size: none })\n+        };\n+        task::set_opts(builder, opts);\n+        builder\n+    };\n+    unsafe {\n+        log(debug, \"before priv::chan_from_global_ptr\");\n+        let chan = priv::chan_from_global_ptr::<high_level_msg>(\n+            global_loop_chan_ptr,\n+            builder_fn) {|port|\n+\n+            // the actual body of our global loop lives here\n+            log(debug, \"initialized global port task!\");\n+            log(debug, \"GLOBAL!!!! initialized global port task!\");\n+            outer_global_loop_body(port);\n+        };\n+        log(debug, \"after priv::chan_from_global_ptr\");\n+        let handle = get_global_async_handle();\n+        ret { async_handle: handle, op_chan: chan };\n+    }\n+}\n+\n+#[doc = \"\n+Takes a vanilla libuv `uv_loop_t*` ptr, performs some setup and then calls\n+`uv_run()`. Users will be able to access this loop via a provided\n+`async_handle` and `msg_ptr_po`. On top of libuv's internal handle refcount,\n+the high_level_loop manages its own lifetime with a similar refcount scheme.\n+\n+This call blocks for the lifetime of the libuv loop.\n+\n+# Arguments\n+\n+* loop_ptr - a pointer to a currently unused libuv loop. Its `data` field\n+will be overwritten before the loop begins\n+* async_handle - a pointer to a _fresh_ `ll::uv_async_t` record that _has\n+not_ been initialized via `uv_async_init`, `ll::uv::async_init`, etc. It\n+must be a pointer to a clean rust `uv_async_t` record\n+* before_run - a unique closure that is invoked just before the call to\n+`uv_run`\n+* before_msg_drain - a unique closure that is invoked every time the loop is\n+awoken, but before the port pointed to in the `msg_po` argument is drained.\n+\"]\n+unsafe fn run_high_level_loop(loop_ptr: *libc::c_void,\n+                              msg_po: comm::port<high_level_msg>,\n+                              before_run: fn~(*global_loop_data),\n+                              before_msg_drain: fn~() -> bool,\n+                              before_tear_down: fn~()) {\n+    // set up the special async handle we'll use to allow multi-task\n+    // communication with this loop\n+    let async = ll::async_t();\n+    let async_handle = ptr::addr_of(async);\n+    // associate the async handle with the loop\n+    ll::async_init(loop_ptr, async_handle, high_level_wake_up_cb);\n+    \n+    // initialize our loop data and store it in the loop\n+    let data: global_loop_data = {\n+        async_handle: async_handle,\n+        mut active: true,\n+        before_msg_drain: before_msg_drain,\n+        before_tear_down: before_tear_down,\n+        msg_po_ptr: ptr::addr_of(msg_po),\n+        mut refd_handles: [mut],\n+        mut unrefd_handles: [mut]\n+    };\n+    let data_ptr = ptr::addr_of(data);\n+    ll::set_data_for_uv_handle(async_handle, data_ptr);\n+\n+    // call before_run\n+    before_run(data_ptr);\n+\n+    log(debug, \"about to run high level loop\");\n+    // enter the loop... this blocks until the loop is done..\n+    ll::run(loop_ptr);\n+    log(debug, \"high-level loop ended\");\n+}\n+\n #[doc = \"\n Pass in a callback to be processed on the running libuv loop's thread\n \n@@ -35,69 +143,350 @@ Pass in a callback to be processed on the running libuv loop's thread\n * a_loop - a high_level_loop record that represents a channel of\n communication with an active libuv loop running on a thread\n somwhere in the current process\n-\n * cb - a function callback to be processed on the running loop's\n thread. The only parameter is an opaque pointer to the running\n uv_loop_t. You can use this pointer to initiate or continue any\n operations against the loop\n \"]\n unsafe fn interact(a_loop: high_level_loop,\n                       -cb: fn~(*libc::c_void)) {\n-    comm::send(a_loop.op_chan, cb);\n-    ll::async_send(a_loop.async_handle);\n+    send_high_level_msg(a_loop, interaction(cb));\n }\n \n-#[doc = \"\n-Prepares a clean, inactive uv_loop_t* to be used with any of the\n-functions in the `uv::hl` module.\n-\n-Library developers can use this function to prepare a given\n-`uv_loop_t*`, whose lifecycle they manage, to be used, ran\n-and controlled with the tools in this module.\n-\n-After this is ran against a loop, a library developer can run\n-the loop in its own thread and then use the returned\n-`high_level_loop` to interact with it.\n+iface uv_handle_manager<T> {\n+    fn init() -> T;\n+}\n \n-# Arguments\n+resource uv_safe_handle<T>(handle_val: uv_handle_manager<T>) {\n+}\n \n-* loop_ptr - a pointer to a newly created `uv_loop_t*` with no\n-handles registered (this will interfere with the internal lifecycle\n-management this module provides). Ideally, this should be called\n-immediately after using `uv::ll::loop_new()`\n+#[doc=\"\n+\"]\n+fn ref_handle<T>(hl_loop: high_level_loop, handle: *T) unsafe {\n+    send_high_level_msg(hl_loop, auto_ref_handle(handle as *libc::c_void));\n+}\n+#[doc=\"\n+\"]\n+fn unref_handle<T>(hl_loop: high_level_loop, handle: *T) unsafe {\n+    send_high_level_msg(hl_loop, auto_unref_handle(handle as *libc::c_void));\n+}\n \n-# Return\n+/////////////////////\n+// INTERNAL API\n+/////////////////////\n \n-A `high_level_loop` record that can be used to interact with the\n-loop (after you use `uv::ll::run()` on the `uv_loop_t*`, of course\n-\"]\n-unsafe fn prepare_loop(loop_ptr: *libc::c_void)\n-    -> high_level_loop {\n-    // will probably need to stake out a data record\n-    // here, as well, to keep whatever state we want to\n-    // use with the loop\n+unsafe fn send_high_level_msg(hl_loop: high_level_loop,\n+                              -msg: high_level_msg) unsafe {\n+    comm::send(hl_loop.op_chan, msg);\n \n-    // move this into a malloc\n-    let async = ll::async_t();\n-    let async_ptr = ptr::addr_of(async);\n-    let op_port = comm::port::<fn~(*libc::c_void)>();\n-    let async_result = ll::async_init(loop_ptr,\n-                                      async_ptr,\n-                                      interact_poke);\n-    if (async_result != 0i32) {\n-        fail ll::get_last_err_info(loop_ptr);\n+    // if the global async handle == 0, then that means\n+    // the loop isn't active, so we don't need to wake it up,\n+    // (the loop's enclosing task should be blocking on a message\n+    // receive on this port)\n+    if (*(hl_loop.async_handle) != 0 as *ll::uv_async_t) {\n+        log(debug,\"global async handle != 0, waking up loop..\");\n+        ll::async_send(*(hl_loop.async_handle));\n+    }\n+    else {\n+        log(debug,\"GLOBAL ASYNC handle == 0\");\n     }\n-    // need to store the port and async_ptr in the top-level\n-    // of the provided loop ..\n-    ret { async_handle: async_ptr,\n-         op_chan: comm::chan::<fn~(*libc::c_void)>(op_port)\n-        };\n }\n \n-// this will be invoked by a called to uv::hl::interact(), so\n-// we'll drain the port of pending callbacks, processing each\n-crust fn interact_poke(async_handle: *libc::c_void) {\n+// this will be invoked by a call to uv::hl::interact() with\n+// the high_level_loop corresponding to this async_handle. We\n+// simply check if the loop is active and, if so, invoke the\n+// user-supplied on_wake callback that is stored in the loop's\n+// data member\n+crust fn high_level_wake_up_cb(async_handle: *libc::c_void,\n+                               status: int) unsafe {\n     // nothing here, yet.\n-    log(debug, #fmt(\"interact_poke crust.. handle: %?\",\n+    log(debug, #fmt(\"high_level_wake_up_cb crust.. handle: %?\",\n                      async_handle));\n+    let loop_ptr = ll::get_loop_for_uv_handle(async_handle);\n+    let data = ll::get_data_for_uv_handle(async_handle) as *global_loop_data;\n+    // we check to see if the loop is \"active\" (the loop is set to\n+    // active = false the first time we realize we need to 'tear down',\n+    // set subsequent calls to the global async handle may be triggered\n+    // before all of the uv_close() calls are processed and loop exits\n+    // on its own. So if the loop isn't active, we won't run the user's\n+    // on_wake callback (and, consequently, let messages pile up, probably\n+    // in the loops msg_po)\n+    if (*data).active {\n+        log(debug, \"before on_wake\");\n+        let mut do_msg_drain = (*data).before_msg_drain();\n+        let mut continue = true;\n+        if do_msg_drain {\n+            let msg_po = *((*data).msg_po_ptr);\n+            if comm::peek(msg_po) {\n+                // if this is true, we'll iterate over the\n+                // msgs waiting in msg_po until there's no more\n+                log(debug,\"got msg_po\");\n+                while(continue) {\n+                    log(debug,\"before alt'ing on high_level_msg\");\n+                    alt comm::recv(msg_po) {\n+                      interaction(cb) {\n+                        log(debug,\"got interaction, before cb..\");\n+                        // call it..\n+                        cb(loop_ptr);\n+                        log(debug,\"after calling cb\");\n+                      }\n+                      auto_ref_handle(handle) {\n+                        high_level_ref(data, handle);\n+                      }\n+                      auto_unref_handle(handle) {\n+                        high_level_unref(data, handle, false);\n+                      }\n+                      tear_down {\n+                        log(debug,\"incoming hl_msg: got tear_down\");\n+                      }\n+                    }\n+                    continue = comm::peek(msg_po);\n+                }\n+            }\n+        }\n+        log(debug, #fmt(\"after on_wake, continue? %?\", continue));\n+        if !do_msg_drain {\n+            high_level_tear_down(data);\n+        }\n+    }\n+}\n+\n+crust fn tear_down_close_cb(handle: *ll::uv_async_t) unsafe {\n+    log(debug, #fmt(\"tear_down_close_cb called, closing handle at %?\",\n+                    handle));\n+    // TODO: iterate through open handles on the loop and uv_close()\n+    // them all\n+    let data = ll::get_data_for_uv_handle(handle) as *global_loop_data;\n+}\n+\n+fn high_level_tear_down(data: *global_loop_data) unsafe {\n+    log(debug, \"high_level_tear_down() called, close async_handle\");\n+    // call user-suppled before_tear_down cb\n+    (*data).before_tear_down();\n+    let async_handle = (*data).async_handle;\n+    ll::close(async_handle as *libc::c_void, tear_down_close_cb);\n+}\n+\n+unsafe fn high_level_ref(data: *global_loop_data, handle: *libc::c_void) {\n+    log(debug,\"incoming hl_msg: got auto_ref_handle\");\n+    let mut refd_handles = (*data).refd_handles;\n+    let handle_already_refd = refd_handles.contains(handle);\n+    if handle_already_refd {\n+        fail \"attempt to do a high-level ref an already ref'd handle\";\n+    }\n+    refd_handles += [handle];\n+    (*data).refd_handles = refd_handles;\n+}\n+\n+crust fn auto_unref_close_cb(handle: *libc::c_void) {\n+    log(debug, \"closing handle via high_level_unref\");\n+}\n+\n+unsafe fn high_level_unref(data: *global_loop_data, handle: *libc::c_void,\n+                   manual_unref: bool) {\n+    log(debug,\"incoming hl_msg: got auto_unref_handle\");\n+    let mut refd_handles = (*data).refd_handles;\n+    let mut unrefd_handles = (*data).unrefd_handles;\n+    let handle_already_refd = refd_handles.contains(handle);\n+    if !handle_already_refd {\n+        fail \"attempting to high-level unref an untracked handle\";\n+    }\n+    let double_unref = unrefd_handles.contains(handle);\n+    if double_unref {\n+        if manual_unref {\n+            // will allow a user to manual unref, but only signal\n+            // a fail when a double-unref is caused by a user\n+            fail \"attempting to high-level unref an unrefd handle\";\n+        }\n+    }\n+    else {\n+        ll::close(handle, auto_unref_close_cb);\n+        let last_idx = vec::len(refd_handles) - 1u;\n+        let handle_idx = vec::position_elem(refd_handles, handle);\n+        alt handle_idx {\n+          none {\n+            fail \"trying to remove handle that isn't in refd_handles\";\n+          }\n+          some(idx) {\n+            refd_handles[idx] <-> refd_handles[last_idx];\n+            vec::pop(refd_handles);\n+          }\n+        }\n+        (*data).refd_handles = refd_handles;\n+        unrefd_handles += [handle];\n+        (*data).unrefd_handles = unrefd_handles;\n+        if vec::len(refd_handles) == 0u {\n+            log(debug, \"0 referenced handles, start loop teardown\");\n+            high_level_tear_down(data);\n+        }\n+        else {\n+            log(debug, \"more than 0 referenced handles\");\n+        }\n+    }\n+\n+}\n+\n+enum high_level_msg {\n+    interaction (fn~(*libc::c_void)),\n+    auto_ref_handle (*libc::c_void),\n+    auto_unref_handle (*libc::c_void),\n+    tear_down\n+}\n+\n+fn get_global_async_handle() -> **ll::uv_async_t {\n+    ret rustrt::rust_uv_get_kernel_global_async_handle() as **ll::uv_async_t;\n+}\n+\n+fn set_global_async_handle(handle: *ll::uv_async_t) {\n+    rustrt::rust_uv_set_kernel_global_async_handle(handle);\n+}\n+\n+type global_loop_data = {\n+    async_handle: *ll::uv_async_t,\n+    mut active: bool,\n+    before_msg_drain: fn~() -> bool,\n+    before_tear_down: fn~(),\n+    msg_po_ptr: *comm::port<high_level_msg>,\n+    mut refd_handles: [mut *libc::c_void],\n+    mut unrefd_handles: [mut *libc::c_void]\n+};\n+\n+unsafe fn outer_global_loop_body(msg_po: comm::port<high_level_msg>) {\n+    // we're going to use a single libuv-generated loop ptr\n+    // for the duration of the process\n+    let loop_ptr = ll::loop_new();\n+\n+    // data structure for loop goes here..\n+\n+    // immediately weaken the task this is running in.\n+    priv::weaken_task() {|weak_exit_po|\n+        // when we first enter this loop, we're going\n+        // to wait on stand-by to receive a request to\n+        // fire-up the libuv loop\n+        let mut continue = true;\n+        while continue {\n+            log(debug, \"in outer_loop...\");\n+            continue = either::either(\n+                {|left_val|\n+                    // bail out..\n+                    // if we catch this msg at this point,\n+                    // we should just be able to exit because\n+                    // the loop isn't active\n+                    log(debug, \"got msg on weak_exit_po in outer loop\");\n+                    false\n+                }, {|right_val|\n+                    log(debug, \"about to enter inner loop\");\n+                    inner_global_loop_body(weak_exit_po, msg_po, loop_ptr,\n+                                          copy(right_val))\n+                }, comm::select2(weak_exit_po, msg_po));\n+            log(debug,#fmt(\"GLOBAL LOOP EXITED, WAITING TO RESTART? %?\",\n+                       continue));\n+        }\n+    };\n+\n+    ll::loop_delete(loop_ptr);\n+    // once we get here, show's over.\n+    rustrt::rust_uv_free_kernel_global_async_handle();\n+}\n+\n+unsafe fn inner_global_loop_body(weak_exit_po_in: comm::port<()>,\n+                          msg_po_in: comm::port<high_level_msg>,\n+                          loop_ptr: *libc::c_void,\n+                          -first_interaction: high_level_msg) -> bool {\n+    // resend the msg\n+    comm::send(comm::chan(msg_po_in), first_interaction);\n+\n+    // black magic\n+    let weak_exit_po_ptr = ptr::addr_of(weak_exit_po_in);\n+    run_high_level_loop(\n+        loop_ptr,\n+        msg_po_in,\n+        // before_run\n+        {|data|\n+            // set the handle as the global\n+            set_global_async_handle((*data).async_handle);\n+            // when this is ran, our async_handle is set up, so let's\n+            // do an async_send with it\n+            ll::async_send((*data).async_handle);\n+        },\n+        // before_msg_drain\n+        {||\n+            log(debug,\"entering before_msg_drain for the global loop\");\n+            let weak_exit_po = *weak_exit_po_ptr;\n+            if(comm::peek(weak_exit_po)) {\n+                // if this is true, immediately bail and return false, causing\n+                // the libuv loop to start tearing down\n+                log(debug,\"got weak_exit meg inside libuv loop\");\n+                comm::recv(weak_exit_po);\n+                false\n+            }\n+            // if no weak_exit_po msg is received, then we'll let the\n+            // loop continue\n+            else {\n+                true\n+            }\n+        },\n+        // before_tear_down\n+        {||\n+            set_global_async_handle(0 as *ll::uv_async_t);\n+        });\n+    // supposed to return a bool to indicate to the enclosing loop whether\n+    // it should continue or not..\n+    ret true;\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    crust fn simple_timer_close_cb(timer_ptr: *ll::uv_timer_t) unsafe {\n+        log(debug, \"UNUSED...\");\n+    }\n+    crust fn simple_timer_cb(timer_ptr: *ll::uv_timer_t,\n+                             status: libc::c_int) unsafe {\n+        log(debug, \"in simple timer cb\");\n+        let exit_ch_ptr = ll::get_data_for_uv_handle(\n+            timer_ptr as *libc::c_void) as *comm::chan<bool>;\n+        ll::timer_stop(timer_ptr);\n+        let hl_loop = get_global_loop();\n+        interact(hl_loop) {|loop_ptr|\n+            log(debug, \"closing timer\");\n+            //ll::close(timer_ptr as *libc::c_void, simple_timer_close_cb);\n+            unref_handle(hl_loop, timer_ptr);\n+            log(debug, \"about to deref exit_ch_ptr\");\n+            let exit_ch = *exit_ch_ptr;\n+            comm::send(exit_ch, true);\n+            log(debug, \"after msg sent on deref'd exit_ch\");\n+        };\n+        log(debug, \"exiting simple timer cb\");\n+    }\n+    #[test]\n+    fn test_uv_hl_simple_timer() unsafe {\n+        let exit_po = comm::port::<bool>();\n+        let exit_ch = comm::chan(exit_po);\n+        let exit_ch_ptr = ptr::addr_of(exit_ch);\n+        let hl_loop = get_global_loop();\n+        let timer_handle = ll::timer_t();\n+        let timer_ptr = ptr::addr_of(timer_handle);\n+        interact(hl_loop) {|loop_ptr|\n+            log(debug, \"user code inside interact loop!!!\");\n+            let init_status = ll::timer_init(loop_ptr, timer_ptr);\n+            if(init_status == 0i32) {\n+                ref_handle(hl_loop, timer_ptr);\n+                ll::set_data_for_uv_handle(\n+                    timer_ptr as *libc::c_void,\n+                    exit_ch_ptr as *libc::c_void);\n+                let start_status = ll::timer_start(timer_ptr, simple_timer_cb,\n+                                                   1u, 0u);\n+                if(start_status == 0i32) {\n+                }\n+                else {\n+                    fail \"failure on ll::timer_start()\";\n+                }\n+            }\n+            else {\n+                fail \"failure on ll::timer_init()\";\n+            }\n+        };\n+        comm::recv(exit_po);\n+        log(debug, \"test_uv_hl_simple_timer: msg recv on exit_po, done..\");\n+    }\n }\n\\ No newline at end of file"}]}