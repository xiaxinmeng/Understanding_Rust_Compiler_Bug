{"sha": "32453ce488909ec12b893ceb9a204718eae724e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNDUzY2U0ODg5MDllYzEyYjg5M2NlYjlhMjA0NzE4ZWFlNzI0ZTQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-06T07:44:15Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-06T09:06:11Z"}, "message": "remvoe to_scalar_ptr and use ref_to_mplace everywhere", "tree": {"sha": "3e7c38f9f96acd13464f74b4f8a709965780ee28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e7c38f9f96acd13464f74b4f8a709965780ee28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32453ce488909ec12b893ceb9a204718eae724e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32453ce488909ec12b893ceb9a204718eae724e4", "html_url": "https://github.com/rust-lang/rust/commit/32453ce488909ec12b893ceb9a204718eae724e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32453ce488909ec12b893ceb9a204718eae724e4/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14ee66acecc353c0b3045d74fbe3addd66f96d79", "url": "https://api.github.com/repos/rust-lang/rust/commits/14ee66acecc353c0b3045d74fbe3addd66f96d79", "html_url": "https://github.com/rust-lang/rust/commit/14ee66acecc353c0b3045d74fbe3addd66f96d79"}], "stats": {"total": 92, "additions": 30, "deletions": 62}, "files": [{"sha": "2171ceaa452c88f9134901485a9ced9f9f9c3900", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/32453ce488909ec12b893ceb9a204718eae724e4/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32453ce488909ec12b893ceb9a204718eae724e4/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=32453ce488909ec12b893ceb9a204718eae724e4", "patch": "@@ -192,20 +192,18 @@ for\n         let ty = mplace.layout.ty;\n         if let ty::Ref(_, referenced_ty, mutability) = ty.kind {\n             let value = self.ecx.read_immediate(mplace.into())?;\n+            let mplace = self.ecx.ref_to_mplace(value)?;\n             // Handle trait object vtables\n-            if let Ok(meta) = value.to_meta() {\n-                if let ty::Dynamic(..) =\n-                    self.ecx.tcx.struct_tail_erasing_lifetimes(\n-                        referenced_ty, self.ecx.param_env).kind\n-                {\n-                    if let Ok(vtable) = meta.unwrap().to_ptr() {\n-                        // explitly choose `Immutable` here, since vtables are immutable, even\n-                        // if the reference of the fat pointer is mutable\n-                        self.intern_shallow(vtable.alloc_id, Mutability::Immutable, None)?;\n-                    }\n+            if let ty::Dynamic(..) =\n+                self.ecx.tcx.struct_tail_erasing_lifetimes(\n+                    referenced_ty, self.ecx.param_env).kind\n+            {\n+                if let Ok(vtable) = mplace.meta.unwrap().to_ptr() {\n+                    // explitly choose `Immutable` here, since vtables are immutable, even\n+                    // if the reference of the fat pointer is mutable\n+                    self.intern_shallow(vtable.alloc_id, Mutability::Immutable, None)?;\n                 }\n             }\n-            let mplace = self.ecx.ref_to_mplace(value)?;\n             // Check if we have encountered this pointer+layout combination before.\n             // Only recurse for allocation-backed pointers.\n             if let Scalar::Ptr(ptr) = mplace.ptr {\n@@ -230,7 +228,7 @@ for\n                             ty::Array(_, n)\n                                 if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n                             ty::Slice(_)\n-                                if value.to_meta().unwrap().unwrap().to_usize(self.ecx)? == 0 => {}\n+                                if mplace.meta.unwrap().to_usize(self.ecx)? == 0 => {}\n                             _ => bug!(\"const qualif failed to prevent mutable references\"),\n                         }\n                     },"}, {"sha": "d80ad3848d20a79cc1bbfa11840be546154476f4", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/32453ce488909ec12b893ceb9a204718eae724e4/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32453ce488909ec12b893ceb9a204718eae724e4/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=32453ce488909ec12b893ceb9a204718eae724e4", "patch": "@@ -82,26 +82,6 @@ impl<'tcx, Tag> Immediate<Tag> {\n             Immediate::ScalarPair(a, b) => Ok((a.not_undef()?, b.not_undef()?))\n         }\n     }\n-\n-    /// Converts the immediate into a pointer (or a pointer-sized integer).\n-    /// Throws away the second half of a ScalarPair!\n-    #[inline]\n-    pub fn to_scalar_ptr(self) -> InterpResult<'tcx, Scalar<Tag>> {\n-        match self {\n-            Immediate::Scalar(ptr) |\n-            Immediate::ScalarPair(ptr, _) => ptr.not_undef(),\n-        }\n-    }\n-\n-    /// Converts the value into its metadata.\n-    /// Throws away the first half of a ScalarPair!\n-    #[inline]\n-    pub fn to_meta(self) -> InterpResult<'tcx, Option<Scalar<Tag>>> {\n-        Ok(match self {\n-            Immediate::Scalar(_) => None,\n-            Immediate::ScalarPair(_, meta) => Some(meta.not_undef()?),\n-        })\n-    }\n }\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together"}, {"sha": "36e58d356d1004b732d078b2bb5853f13a2a8666", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32453ce488909ec12b893ceb9a204718eae724e4/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32453ce488909ec12b893ceb9a204718eae724e4/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=32453ce488909ec12b893ceb9a204718eae724e4", "patch": "@@ -291,15 +291,19 @@ where\n             .expect(\"`ref_to_mplace` called on non-ptr type\")\n             .ty;\n         let layout = self.layout_of(pointee_type)?;\n+        let (ptr, meta) = match *val {\n+            Immediate::Scalar(ptr) => (ptr.not_undef()?, None),\n+            Immediate::ScalarPair(ptr, meta) => (ptr.not_undef()?, Some(meta.not_undef()?)),\n+        };\n \n         let mplace = MemPlace {\n-            ptr: val.to_scalar_ptr()?,\n+            ptr,\n             // We could use the run-time alignment here. For now, we do not, because\n             // the point of tracking the alignment here is to make sure that the *static*\n             // alignment information emitted with the loads is correct. The run-time\n             // alignment can only be more restrictive.\n             align: layout.align.abi,\n-            meta: val.to_meta()?,\n+            meta,\n         };\n         Ok(MPlaceTy { mplace, layout })\n     }"}, {"sha": "929425afc9e9182fdbf18f34970c1d4964b168b4", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/32453ce488909ec12b893ceb9a204718eae724e4/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32453ce488909ec12b893ceb9a204718eae724e4/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=32453ce488909ec12b893ceb9a204718eae724e4", "patch": "@@ -388,44 +388,31 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 }\n             }\n             ty::RawPtr(..) => {\n-                // Check pointer part.\n-                if self.ref_tracking_for_consts.is_some() {\n-                    // Integers/floats in CTFE: For consistency with integers, we do not\n-                    // accept undef.\n-                    let _ptr = try_validation!(value.to_scalar_ptr(),\n-                        \"undefined address in raw pointer\", self.path);\n-                } else {\n-                    // Remain consistent with `usize`: Accept anything.\n-                }\n-\n-                // Check metadata.\n-                let meta = try_validation!(value.to_meta(),\n-                    \"uninitialized data in wide pointer metadata\", self.path);\n-                let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n-                if layout.is_unsized() {\n-                    self.check_wide_ptr_meta(meta, layout)?;\n+                // We are conservative with undef for integers, but try to\n+                // actually enforce our current rules for raw pointers.\n+                let place = try_validation!(self.ecx.ref_to_mplace(value),\n+                    \"undefined pointer\", self.path);\n+                if place.layout.is_unsized() {\n+                    self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n             }\n             _ if ty.is_box() || ty.is_region_ptr() => {\n                 // Handle wide pointers.\n                 // Check metadata early, for better diagnostics\n-                let ptr = try_validation!(value.to_scalar_ptr(),\n-                    \"undefined address in pointer\", self.path);\n-                let meta = try_validation!(value.to_meta(),\n-                    \"uninitialized data in wide pointer metadata\", self.path);\n-                let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n-                if layout.is_unsized() {\n-                    self.check_wide_ptr_meta(meta, layout)?;\n+                let place = try_validation!(self.ecx.ref_to_mplace(value),\n+                    \"undefined pointer\", self.path);\n+                if place.layout.is_unsized() {\n+                    self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n                 // Make sure this is dereferencable and all.\n-                let (size, align) = self.ecx.size_and_align_of(meta, layout)?\n+                let (size, align) = self.ecx.size_and_align_of(place.meta, place.layout)?\n                     // for the purpose of validity, consider foreign types to have\n                     // alignment and size determined by the layout (size will be 0,\n                     // alignment should take attributes into account).\n-                    .unwrap_or_else(|| (layout.size, layout.align.abi));\n+                    .unwrap_or_else(|| (place.layout.size, place.layout.align.abi));\n                 let ptr: Option<_> = match\n                     self.ecx.memory.check_ptr_access_align(\n-                        ptr,\n+                        place.ptr,\n                         size,\n                         Some(align),\n                         CheckInAllocMsg::InboundsTest,\n@@ -435,7 +422,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     Err(err) => {\n                         info!(\n                             \"{:?} did not pass access check for size {:?}, align {:?}\",\n-                            ptr, size, align\n+                            place.ptr, size, align\n                         );\n                         match err.kind {\n                             err_unsup!(InvalidNullPointerUsage) =>\n@@ -459,7 +446,6 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 };\n                 // Recursive checking\n                 if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n-                    let place = self.ecx.ref_to_mplace(value)?;\n                     if let Some(ptr) = ptr { // not a ZST\n                         // Skip validation entirely for some external statics\n                         let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);"}]}