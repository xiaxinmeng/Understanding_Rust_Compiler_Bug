{"sha": "599dab59824b164b1c24e2e51adeae1ac1307964", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5OWRhYjU5ODI0YjE2NGIxYzI0ZTJlNTFhZGVhZTFhYzEzMDc5NjQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-01T19:30:28Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-02T18:33:13Z"}, "message": "Extract unification code to unify module", "tree": {"sha": "3a31914d0647dd18f6e0026681ca1aed5a0e262a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a31914d0647dd18f6e0026681ca1aed5a0e262a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/599dab59824b164b1c24e2e51adeae1ac1307964", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/599dab59824b164b1c24e2e51adeae1ac1307964", "html_url": "https://github.com/rust-lang/rust/commit/599dab59824b164b1c24e2e51adeae1ac1307964", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/599dab59824b164b1c24e2e51adeae1ac1307964/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbf262a1bc72f10dc93a4993da0012d3b0abb56f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbf262a1bc72f10dc93a4993da0012d3b0abb56f", "html_url": "https://github.com/rust-lang/rust/commit/cbf262a1bc72f10dc93a4993da0012d3b0abb56f"}], "stats": {"total": 575, "additions": 312, "deletions": 263}, "files": [{"sha": "81afbd2b47f7c5031df7461ca7ca133e5e5099cb", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 22, "deletions": 233, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/599dab59824b164b1c24e2e51adeae1ac1307964/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599dab59824b164b1c24e2e51adeae1ac1307964/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=599dab59824b164b1c24e2e51adeae1ac1307964", "patch": "@@ -18,7 +18,6 @@ use std::mem;\n use std::ops::Index;\n use std::sync::Arc;\n \n-use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n use rustc_hash::FxHashMap;\n \n use hir_def::{\n@@ -33,12 +32,11 @@ use hir_def::{\n use hir_expand::{diagnostics::DiagnosticSink, name};\n use ra_arena::map::ArenaMap;\n use ra_prof::profile;\n-use test_utils::tested_by;\n \n use super::{\n     primitive::{FloatTy, IntTy},\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n-    ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n+    ApplicationTy, InEnvironment, ProjectionTy, TraitEnvironment, TraitRef, Ty, TypeCtor,\n     TypeWalk, Uncertain,\n };\n use crate::{db::HirDatabase, infer::diagnostics::InferenceDiagnostic};\n@@ -191,7 +189,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     owner: DefWithBodyId,\n     body: Arc<Body>,\n     resolver: Resolver,\n-    var_unification_table: InPlaceUnificationTable<TypeVarId>,\n+    table: unify::InferenceTable,\n     trait_env: Arc<TraitEnvironment>,\n     obligations: Vec<Obligation>,\n     result: InferenceResult,\n@@ -209,7 +207,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn new(db: &'a D, owner: DefWithBodyId, resolver: Resolver) -> Self {\n         InferenceContext {\n             result: InferenceResult::default(),\n-            var_unification_table: InPlaceUnificationTable::new(),\n+            table: unify::InferenceTable::new(),\n             obligations: Vec::default(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             trait_env: TraitEnvironment::lower(db, &resolver),\n@@ -224,13 +222,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn resolve_all(mut self) -> InferenceResult {\n         // FIXME resolve obligations as well (use Guidance if necessary)\n         let mut result = mem::replace(&mut self.result, InferenceResult::default());\n-        let mut tv_stack = Vec::new();\n         for ty in result.type_of_expr.values_mut() {\n-            let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n+            let resolved = self.table.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n             *ty = resolved;\n         }\n         for ty in result.type_of_pat.values_mut() {\n-            let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n+            let resolved = self.table.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n             *ty = resolved;\n         }\n         result\n@@ -275,96 +272,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.normalize_associated_types_in(ty)\n     }\n \n-    fn unify_substs(&mut self, substs1: &Substs, substs2: &Substs, depth: usize) -> bool {\n-        substs1.0.iter().zip(substs2.0.iter()).all(|(t1, t2)| self.unify_inner(t1, t2, depth))\n-    }\n-\n-    fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n-        self.unify_inner(ty1, ty2, 0)\n-    }\n-\n-    fn unify_inner(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {\n-        if depth > 1000 {\n-            // prevent stackoverflows\n-            panic!(\"infinite recursion in unification\");\n-        }\n-        if ty1 == ty2 {\n-            return true;\n-        }\n-        // try to resolve type vars first\n-        let ty1 = self.resolve_ty_shallow(ty1);\n-        let ty2 = self.resolve_ty_shallow(ty2);\n-        match (&*ty1, &*ty2) {\n-            (Ty::Apply(a_ty1), Ty::Apply(a_ty2)) if a_ty1.ctor == a_ty2.ctor => {\n-                self.unify_substs(&a_ty1.parameters, &a_ty2.parameters, depth + 1)\n-            }\n-            _ => self.unify_inner_trivial(&ty1, &ty2),\n-        }\n-    }\n-\n-    fn unify_inner_trivial(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n-        match (ty1, ty2) {\n-            (Ty::Unknown, _) | (_, Ty::Unknown) => true,\n-\n-            (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n-            | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n-            | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2)))\n-            | (\n-                Ty::Infer(InferTy::MaybeNeverTypeVar(tv1)),\n-                Ty::Infer(InferTy::MaybeNeverTypeVar(tv2)),\n-            ) => {\n-                // both type vars are unknown since we tried to resolve them\n-                self.var_unification_table.union(*tv1, *tv2);\n-                true\n-            }\n-\n-            // The order of MaybeNeverTypeVar matters here.\n-            // Unifying MaybeNeverTypeVar and TypeVar will let the latter become MaybeNeverTypeVar.\n-            // Unifying MaybeNeverTypeVar and other concrete type will let the former become it.\n-            (Ty::Infer(InferTy::TypeVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::TypeVar(tv)))\n-            | (Ty::Infer(InferTy::MaybeNeverTypeVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::MaybeNeverTypeVar(tv)))\n-            | (Ty::Infer(InferTy::IntVar(tv)), other @ ty_app!(TypeCtor::Int(_)))\n-            | (other @ ty_app!(TypeCtor::Int(_)), Ty::Infer(InferTy::IntVar(tv)))\n-            | (Ty::Infer(InferTy::FloatVar(tv)), other @ ty_app!(TypeCtor::Float(_)))\n-            | (other @ ty_app!(TypeCtor::Float(_)), Ty::Infer(InferTy::FloatVar(tv))) => {\n-                // the type var is unknown since we tried to resolve it\n-                self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n-                true\n-            }\n-\n-            _ => false,\n-        }\n-    }\n-\n-    fn new_type_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::TypeVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n-    }\n-\n-    fn new_integer_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::IntVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n-    }\n-\n-    fn new_float_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::FloatVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n-    }\n-\n-    fn new_maybe_never_type_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::MaybeNeverTypeVar(\n-            self.var_unification_table.new_key(TypeVarValue::Unknown),\n-        ))\n-    }\n-\n     /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n         match ty {\n-            Ty::Unknown => self.new_type_var(),\n+            Ty::Unknown => self.table.new_type_var(),\n             Ty::Apply(ApplicationTy { ctor: TypeCtor::Int(Uncertain::Unknown), .. }) => {\n-                self.new_integer_var()\n+                self.table.new_integer_var()\n             }\n             Ty::Apply(ApplicationTy { ctor: TypeCtor::Float(Uncertain::Unknown), .. }) => {\n-                self.new_float_var()\n+                self.table.new_float_var()\n             }\n             _ => ty,\n         }\n@@ -402,64 +318,22 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n \n+    fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+        self.table.unify(ty1, ty2)\n+    }\n+\n     /// Resolves the type as far as currently possible, replacing type variables\n     /// by their known types. All types returned by the infer_* functions should\n     /// be resolved as far as possible, i.e. contain no type variables with\n     /// known type.\n-    fn resolve_ty_as_possible(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n+    fn resolve_ty_as_possible(&mut self, ty: Ty) -> Ty {\n         self.resolve_obligations_as_possible();\n \n-        ty.fold(&mut |ty| match ty {\n-            Ty::Infer(tv) => {\n-                let inner = tv.to_inner();\n-                if tv_stack.contains(&inner) {\n-                    tested_by!(type_var_cycles_resolve_as_possible);\n-                    // recursive type\n-                    return tv.fallback_value();\n-                }\n-                if let Some(known_ty) =\n-                    self.var_unification_table.inlined_probe_value(inner).known()\n-                {\n-                    // known_ty may contain other variables that are known by now\n-                    tv_stack.push(inner);\n-                    let result = self.resolve_ty_as_possible(tv_stack, known_ty.clone());\n-                    tv_stack.pop();\n-                    result\n-                } else {\n-                    ty\n-                }\n-            }\n-            _ => ty,\n-        })\n+        self.table.resolve_ty_as_possible(ty)\n     }\n \n-    /// If `ty` is a type variable with known type, returns that type;\n-    /// otherwise, return ty.\n     fn resolve_ty_shallow<'b>(&mut self, ty: &'b Ty) -> Cow<'b, Ty> {\n-        let mut ty = Cow::Borrowed(ty);\n-        // The type variable could resolve to a int/float variable. Hence try\n-        // resolving up to three times; each type of variable shouldn't occur\n-        // more than once\n-        for i in 0..3 {\n-            if i > 0 {\n-                tested_by!(type_var_resolves_to_int_var);\n-            }\n-            match &*ty {\n-                Ty::Infer(tv) => {\n-                    let inner = tv.to_inner();\n-                    match self.var_unification_table.inlined_probe_value(inner).known() {\n-                        Some(known_ty) => {\n-                            // The known_ty can't be a type var itself\n-                            ty = Cow::Owned(known_ty.clone());\n-                        }\n-                        _ => return ty,\n-                    }\n-                }\n-                _ => return ty,\n-            }\n-        }\n-        log::error!(\"Inference variable still not resolved: {:?}\", ty);\n-        ty\n+        self.table.resolve_ty_shallow(ty)\n     }\n \n     /// Recurses through the given type, normalizing associated types mentioned\n@@ -469,48 +343,21 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// call). `make_ty` handles this already, but e.g. for field types we need\n     /// to do it as well.\n     fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        let ty = self.resolve_ty_as_possible(ty);\n         ty.fold(&mut |ty| match ty {\n             Ty::Projection(proj_ty) => self.normalize_projection_ty(proj_ty),\n             _ => ty,\n         })\n     }\n \n     fn normalize_projection_ty(&mut self, proj_ty: ProjectionTy) -> Ty {\n-        let var = self.new_type_var();\n+        let var = self.table.new_type_var();\n         let predicate = ProjectionPredicate { projection_ty: proj_ty, ty: var.clone() };\n         let obligation = Obligation::Projection(predicate);\n         self.obligations.push(obligation);\n         var\n     }\n \n-    /// Resolves the type completely; type variables without known type are\n-    /// replaced by Ty::Unknown.\n-    fn resolve_ty_completely(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty {\n-            Ty::Infer(tv) => {\n-                let inner = tv.to_inner();\n-                if tv_stack.contains(&inner) {\n-                    tested_by!(type_var_cycles_resolve_completely);\n-                    // recursive type\n-                    return tv.fallback_value();\n-                }\n-                if let Some(known_ty) =\n-                    self.var_unification_table.inlined_probe_value(inner).known()\n-                {\n-                    // known_ty may contain other variables that are known by now\n-                    tv_stack.push(inner);\n-                    let result = self.resolve_ty_completely(tv_stack, known_ty.clone());\n-                    tv_stack.pop();\n-                    result\n-                } else {\n-                    tv.fallback_value()\n-                }\n-            }\n-            _ => ty,\n-        })\n-    }\n-\n     fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantId>) {\n         let path = match path {\n             Some(path) => path,\n@@ -615,78 +462,20 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n }\n \n-/// The ID of a type variable.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct TypeVarId(pub(super) u32);\n-\n-impl UnifyKey for TypeVarId {\n-    type Value = TypeVarValue;\n-\n-    fn index(&self) -> u32 {\n-        self.0\n-    }\n-\n-    fn from_index(i: u32) -> Self {\n-        TypeVarId(i)\n-    }\n-\n-    fn tag() -> &'static str {\n-        \"TypeVarId\"\n-    }\n-}\n-\n-/// The value of a type variable: either we already know the type, or we don't\n-/// know it yet.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum TypeVarValue {\n-    Known(Ty),\n-    Unknown,\n-}\n-\n-impl TypeVarValue {\n-    fn known(&self) -> Option<&Ty> {\n-        match self {\n-            TypeVarValue::Known(ty) => Some(ty),\n-            TypeVarValue::Unknown => None,\n-        }\n-    }\n-}\n-\n-impl UnifyValue for TypeVarValue {\n-    type Error = NoError;\n-\n-    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, NoError> {\n-        match (value1, value2) {\n-            // We should never equate two type variables, both of which have\n-            // known types. Instead, we recursively equate those types.\n-            (TypeVarValue::Known(t1), TypeVarValue::Known(t2)) => panic!(\n-                \"equating two type variables, both of which have known types: {:?} and {:?}\",\n-                t1, t2\n-            ),\n-\n-            // If one side is known, prefer that one.\n-            (TypeVarValue::Known(..), TypeVarValue::Unknown) => Ok(value1.clone()),\n-            (TypeVarValue::Unknown, TypeVarValue::Known(..)) => Ok(value2.clone()),\n-\n-            (TypeVarValue::Unknown, TypeVarValue::Unknown) => Ok(TypeVarValue::Unknown),\n-        }\n-    }\n-}\n-\n /// The kinds of placeholders we need during type inference. There's separate\n /// values for general types, and for integer and float variables. The latter\n /// two are used for inference of literal values (e.g. `100` could be one of\n /// several integer types).\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InferTy {\n-    TypeVar(TypeVarId),\n-    IntVar(TypeVarId),\n-    FloatVar(TypeVarId),\n-    MaybeNeverTypeVar(TypeVarId),\n+    TypeVar(unify::TypeVarId),\n+    IntVar(unify::TypeVarId),\n+    FloatVar(unify::TypeVarId),\n+    MaybeNeverTypeVar(unify::TypeVarId),\n }\n \n impl InferTy {\n-    fn to_inner(self) -> TypeVarId {\n+    fn to_inner(self) -> unify::TypeVarId {\n         match self {\n             InferTy::TypeVar(ty)\n             | InferTy::IntVar(ty)"}, {"sha": "9bfc701cd56861ee9225a17bd872392d12b8f72b", "filename": "crates/ra_hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/599dab59824b164b1c24e2e51adeae1ac1307964/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599dab59824b164b1c24e2e51adeae1ac1307964/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=599dab59824b164b1c24e2e51adeae1ac1307964", "patch": "@@ -10,7 +10,7 @@ use test_utils::tested_by;\n \n use crate::{autoderef, db::HirDatabase, Substs, Ty, TypeCtor, TypeWalk};\n \n-use super::{InEnvironment, InferTy, InferenceContext, TypeVarValue};\n+use super::{InEnvironment, InferTy, InferenceContext, unify::TypeVarValue};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// Unify two types, but may coerce the first one to the second one\n@@ -85,16 +85,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         match (&from_ty, to_ty) {\n             // Never type will make type variable to fallback to Never Type instead of Unknown.\n             (ty_app!(TypeCtor::Never), Ty::Infer(InferTy::TypeVar(tv))) => {\n-                let var = self.new_maybe_never_type_var();\n-                self.var_unification_table.union_value(*tv, TypeVarValue::Known(var));\n+                let var = self.table.new_maybe_never_type_var();\n+                self.table.var_unification_table.union_value(*tv, TypeVarValue::Known(var));\n                 return true;\n             }\n             (ty_app!(TypeCtor::Never), _) => return true,\n \n             // Trivial cases, this should go after `never` check to\n             // avoid infer result type to be never\n             _ => {\n-                if self.unify_inner_trivial(&from_ty, &to_ty) {\n+                if self.table.unify_inner_trivial(&from_ty, &to_ty) {\n                     return true;\n                 }\n             }\n@@ -330,7 +330,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 // Stop when constructor matches.\n                 (ty_app!(from_ctor, st1), ty_app!(to_ctor, st2)) if from_ctor == to_ctor => {\n                     // It will not recurse to `coerce`.\n-                    return self.unify_substs(st1, st2, 0);\n+                    return self.table.unify_substs(st1, st2, 0);\n                 }\n                 _ => {}\n             }"}, {"sha": "1e78f6efd46f7da85329321f0ced3036a6ac3f1e", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/599dab59824b164b1c24e2e51adeae1ac1307964/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599dab59824b164b1c24e2e51adeae1ac1307964/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=599dab59824b164b1c24e2e51adeae1ac1307964", "patch": "@@ -32,7 +32,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n             );\n         }\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        let ty = self.resolve_ty_as_possible(ty);\n         ty\n     }\n \n@@ -53,7 +53,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             expected.ty.clone()\n         };\n \n-        self.resolve_ty_as_possible(&mut vec![], ty)\n+        self.resolve_ty_as_possible(ty)\n     }\n \n     fn infer_expr_inner(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n@@ -94,7 +94,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 let pat_ty = match self.resolve_into_iter_item() {\n                     Some(into_iter_item_alias) => {\n-                        let pat_ty = self.new_type_var();\n+                        let pat_ty = self.table.new_type_var();\n                         let projection = ProjectionPredicate {\n                             ty: pat_ty.clone(),\n                             projection_ty: ProjectionTy {\n@@ -103,7 +103,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             },\n                         };\n                         self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(&mut vec![], pat_ty)\n+                        self.resolve_ty_as_possible(pat_ty)\n                     }\n                     None => Ty::Unknown,\n                 };\n@@ -128,7 +128,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n \n                 // add return type\n-                let ret_ty = self.new_type_var();\n+                let ret_ty = self.table.new_type_var();\n                 sig_tys.push(ret_ty.clone());\n                 let sig_ty = Ty::apply(\n                     TypeCtor::FnPtr { num_args: sig_tys.len() as u16 - 1 },\n@@ -167,7 +167,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Match { expr, arms } => {\n                 let input_ty = self.infer_expr(*expr, &Expectation::none());\n \n-                let mut result_ty = self.new_maybe_never_type_var();\n+                let mut result_ty = self.table.new_maybe_never_type_var();\n \n                 for arm in arms {\n                     for &pat in &arm.pats {\n@@ -283,7 +283,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 let ty = match self.resolve_future_future_output() {\n                     Some(future_future_output_alias) => {\n-                        let ty = self.new_type_var();\n+                        let ty = self.table.new_type_var();\n                         let projection = ProjectionPredicate {\n                             ty: ty.clone(),\n                             projection_ty: ProjectionTy {\n@@ -292,7 +292,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             },\n                         };\n                         self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(&mut vec![], ty)\n+                        self.resolve_ty_as_possible(ty)\n                     }\n                     None => Ty::Unknown,\n                 };\n@@ -302,7 +302,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 let ty = match self.resolve_ops_try_ok() {\n                     Some(ops_try_ok_alias) => {\n-                        let ty = self.new_type_var();\n+                        let ty = self.table.new_type_var();\n                         let projection = ProjectionPredicate {\n                             ty: ty.clone(),\n                             projection_ty: ProjectionTy {\n@@ -311,7 +311,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             },\n                         };\n                         self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(&mut vec![], ty)\n+                        self.resolve_ty_as_possible(ty)\n                     }\n                     None => Ty::Unknown,\n                 };\n@@ -465,10 +465,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     ty_app!(TypeCtor::Tuple { .. }, st) => st\n                         .iter()\n                         .cloned()\n-                        .chain(repeat_with(|| self.new_type_var()))\n+                        .chain(repeat_with(|| self.table.new_type_var()))\n                         .take(exprs.len())\n                         .collect::<Vec<_>>(),\n-                    _ => (0..exprs.len()).map(|_| self.new_type_var()).collect(),\n+                    _ => (0..exprs.len()).map(|_| self.table.new_type_var()).collect(),\n                 };\n \n                 for (expr, ty) in exprs.iter().zip(tys.iter_mut()) {\n@@ -482,7 +482,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     ty_app!(TypeCtor::Array, st) | ty_app!(TypeCtor::Slice, st) => {\n                         st.as_single().clone()\n                     }\n-                    _ => self.new_type_var(),\n+                    _ => self.table.new_type_var(),\n                 };\n \n                 match array {\n@@ -524,7 +524,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        let ty = self.resolve_ty_as_possible(ty);\n         self.write_expr_ty(tgt_expr, ty.clone());\n         ty\n     }\n@@ -553,7 +553,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         }\n                     }\n \n-                    let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+                    let ty = self.resolve_ty_as_possible(ty);\n                     self.infer_pat(*pat, &ty, BindingMode::default());\n                 }\n                 Statement::Expr(expr) => {"}, {"sha": "a14662884458c9fe05307b582f2200c06d863b0c", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/599dab59824b164b1c24e2e51adeae1ac1307964/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599dab59824b164b1c24e2e51adeae1ac1307964/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=599dab59824b164b1c24e2e51adeae1ac1307964", "patch": "@@ -170,7 +170,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     }\n                     BindingMode::Move => inner_ty.clone(),\n                 };\n-                let bound_ty = self.resolve_ty_as_possible(&mut vec![], bound_ty);\n+                let bound_ty = self.resolve_ty_as_possible(bound_ty);\n                 self.write_pat_ty(pat, bound_ty);\n                 return inner_ty;\n             }\n@@ -179,7 +179,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n         self.unify(&ty, expected);\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        let ty = self.resolve_ty_as_possible(ty);\n         self.write_pat_ty(pat, ty.clone());\n         ty\n     }"}, {"sha": "d0d7646a49d3345d3f301c9619df0450f04eabd6", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/599dab59824b164b1c24e2e51adeae1ac1307964/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599dab59824b164b1c24e2e51adeae1ac1307964/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=599dab59824b164b1c24e2e51adeae1ac1307964", "patch": "@@ -57,7 +57,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let typable: ValueTyDefId = match value {\n             ValueNs::LocalBinding(pat) => {\n                 let ty = self.result.type_of_pat.get(pat)?.clone();\n-                let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+                let ty = self.resolve_ty_as_possible(ty);\n                 return Some(ty);\n             }\n             ValueNs::FunctionId(it) => it.into(),\n@@ -211,7 +211,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         // we're picking this method\n                         let trait_substs = Substs::build_for_def(self.db, trait_)\n                             .push(ty.clone())\n-                            .fill(std::iter::repeat_with(|| self.new_type_var()))\n+                            .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n                         let substs = Substs::build_for_def(self.db, item)\n                             .use_parent_substs(&trait_substs)"}, {"sha": "ff50138f5d990a01ec21b70df73c6824817aca0c", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "modified", "additions": 266, "deletions": 6, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/599dab59824b164b1c24e2e51adeae1ac1307964/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/599dab59824b164b1c24e2e51adeae1ac1307964/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=599dab59824b164b1c24e2e51adeae1ac1307964", "patch": "@@ -1,9 +1,15 @@\n //! Unification and canonicalization logic.\n \n+use std::borrow::Cow;\n+\n+use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n+\n+use test_utils::tested_by;\n+\n use super::{InferenceContext, Obligation};\n use crate::{\n     db::HirDatabase, utils::make_mut_slice, Canonical, InEnvironment, InferTy, ProjectionPredicate,\n-    ProjectionTy, Substs, TraitRef, Ty, TypeWalk,\n+    ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n@@ -24,7 +30,7 @@ where\n     /// A stack of type variables that is used to detect recursive types (which\n     /// are an error, but we need to protect against them to avoid stack\n     /// overflows).\n-    var_stack: Vec<super::TypeVarId>,\n+    var_stack: Vec<TypeVarId>,\n }\n \n pub(super) struct Canonicalized<T> {\n@@ -53,14 +59,14 @@ where\n                     return tv.fallback_value();\n                 }\n                 if let Some(known_ty) =\n-                    self.ctx.var_unification_table.inlined_probe_value(inner).known()\n+                    self.ctx.table.var_unification_table.inlined_probe_value(inner).known()\n                 {\n                     self.var_stack.push(inner);\n                     let result = self.do_canonicalize_ty(known_ty.clone());\n                     self.var_stack.pop();\n                     result\n                 } else {\n-                    let root = self.ctx.var_unification_table.find(inner);\n+                    let root = self.ctx.table.var_unification_table.find(inner);\n                     let free_var = match tv {\n                         InferTy::TypeVar(_) => InferTy::TypeVar(root),\n                         InferTy::IntVar(_) => InferTy::IntVar(root),\n@@ -153,10 +159,264 @@ impl<T> Canonicalized<T> {\n         solution: Canonical<Vec<Ty>>,\n     ) {\n         // the solution may contain new variables, which we need to convert to new inference vars\n-        let new_vars = Substs((0..solution.num_vars).map(|_| ctx.new_type_var()).collect());\n+        let new_vars = Substs((0..solution.num_vars).map(|_| ctx.table.new_type_var()).collect());\n         for (i, ty) in solution.value.into_iter().enumerate() {\n             let var = self.free_vars[i];\n-            ctx.unify(&Ty::Infer(var), &ty.subst_bound_vars(&new_vars));\n+            ctx.table.unify(&Ty::Infer(var), &ty.subst_bound_vars(&new_vars));\n+        }\n+    }\n+}\n+\n+pub fn unify(ty1: Canonical<&Ty>, ty2: &Ty) -> Substs {\n+    let mut table = InferenceTable::new();\n+    let vars = Substs::builder(ty1.num_vars)\n+        .fill(std::iter::repeat_with(|| table.new_type_var())).build();\n+    let ty_with_vars = ty1.value.clone().subst_bound_vars(&vars);\n+    table.unify(&ty_with_vars, ty2);\n+    Substs::builder(ty1.num_vars).fill(vars.iter().map(|v| table.resolve_ty_completely(v.clone()))).build()\n+}\n+\n+#[derive(Clone, Debug)]\n+pub(crate) struct InferenceTable {\n+    pub(super) var_unification_table: InPlaceUnificationTable<TypeVarId>,\n+}\n+\n+impl InferenceTable {\n+    pub fn new() -> Self {\n+        InferenceTable {\n+            var_unification_table: InPlaceUnificationTable::new(),\n+        }\n+    }\n+\n+    pub fn new_type_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::TypeVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n+    }\n+\n+    pub fn new_integer_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::IntVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n+    }\n+\n+    pub fn new_float_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::FloatVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n+    }\n+\n+    pub fn new_maybe_never_type_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::MaybeNeverTypeVar(\n+            self.var_unification_table.new_key(TypeVarValue::Unknown),\n+        ))\n+    }\n+\n+    pub fn resolve_ty_completely(&mut self, ty: Ty) -> Ty {\n+        self.resolve_ty_completely_inner(&mut Vec::new(), ty)\n+    }\n+\n+    pub fn resolve_ty_as_possible(&mut self, ty: Ty) -> Ty {\n+        self.resolve_ty_as_possible_inner(&mut Vec::new(), ty)\n+    }\n+\n+    pub fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+        self.unify_inner(ty1, ty2, 0)\n+    }\n+\n+    pub fn unify_substs(&mut self, substs1: &Substs, substs2: &Substs, depth: usize) -> bool {\n+        substs1.0.iter().zip(substs2.0.iter()).all(|(t1, t2)| self.unify_inner(t1, t2, depth))\n+    }\n+\n+    fn unify_inner(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {\n+        if depth > 1000 {\n+            // prevent stackoverflows\n+            panic!(\"infinite recursion in unification\");\n+        }\n+        if ty1 == ty2 {\n+            return true;\n+        }\n+        // try to resolve type vars first\n+        let ty1 = self.resolve_ty_shallow(ty1);\n+        let ty2 = self.resolve_ty_shallow(ty2);\n+        match (&*ty1, &*ty2) {\n+            (Ty::Apply(a_ty1), Ty::Apply(a_ty2)) if a_ty1.ctor == a_ty2.ctor => {\n+                self.unify_substs(&a_ty1.parameters, &a_ty2.parameters, depth + 1)\n+            }\n+            _ => self.unify_inner_trivial(&ty1, &ty2),\n+        }\n+    }\n+\n+    pub(super) fn unify_inner_trivial(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+        match (ty1, ty2) {\n+            (Ty::Unknown, _) | (_, Ty::Unknown) => true,\n+\n+            (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n+            | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n+            | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2)))\n+            | (\n+                Ty::Infer(InferTy::MaybeNeverTypeVar(tv1)),\n+                Ty::Infer(InferTy::MaybeNeverTypeVar(tv2)),\n+            ) => {\n+                // both type vars are unknown since we tried to resolve them\n+                self.var_unification_table.union(*tv1, *tv2);\n+                true\n+            }\n+\n+            // The order of MaybeNeverTypeVar matters here.\n+            // Unifying MaybeNeverTypeVar and TypeVar will let the latter become MaybeNeverTypeVar.\n+            // Unifying MaybeNeverTypeVar and other concrete type will let the former become it.\n+            (Ty::Infer(InferTy::TypeVar(tv)), other)\n+            | (other, Ty::Infer(InferTy::TypeVar(tv)))\n+            | (Ty::Infer(InferTy::MaybeNeverTypeVar(tv)), other)\n+            | (other, Ty::Infer(InferTy::MaybeNeverTypeVar(tv)))\n+            | (Ty::Infer(InferTy::IntVar(tv)), other @ ty_app!(TypeCtor::Int(_)))\n+            | (other @ ty_app!(TypeCtor::Int(_)), Ty::Infer(InferTy::IntVar(tv)))\n+            | (Ty::Infer(InferTy::FloatVar(tv)), other @ ty_app!(TypeCtor::Float(_)))\n+            | (other @ ty_app!(TypeCtor::Float(_)), Ty::Infer(InferTy::FloatVar(tv))) => {\n+                // the type var is unknown since we tried to resolve it\n+                self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n+                true\n+            }\n+\n+            _ => false,\n+        }\n+    }\n+\n+    /// If `ty` is a type variable with known type, returns that type;\n+    /// otherwise, return ty.\n+    pub fn resolve_ty_shallow<'b>(&mut self, ty: &'b Ty) -> Cow<'b, Ty> {\n+        let mut ty = Cow::Borrowed(ty);\n+        // The type variable could resolve to a int/float variable. Hence try\n+        // resolving up to three times; each type of variable shouldn't occur\n+        // more than once\n+        for i in 0..3 {\n+            if i > 0 {\n+                tested_by!(type_var_resolves_to_int_var);\n+            }\n+            match &*ty {\n+                Ty::Infer(tv) => {\n+                    let inner = tv.to_inner();\n+                    match self.var_unification_table.inlined_probe_value(inner).known() {\n+                        Some(known_ty) => {\n+                            // The known_ty can't be a type var itself\n+                            ty = Cow::Owned(known_ty.clone());\n+                        }\n+                        _ => return ty,\n+                    }\n+                }\n+                _ => return ty,\n+            }\n+        }\n+        log::error!(\"Inference variable still not resolved: {:?}\", ty);\n+        ty\n+    }\n+\n+    /// Resolves the type as far as currently possible, replacing type variables\n+    /// by their known types. All types returned by the infer_* functions should\n+    /// be resolved as far as possible, i.e. contain no type variables with\n+    /// known type.\n+    fn resolve_ty_as_possible_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| match ty {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                if tv_stack.contains(&inner) {\n+                    tested_by!(type_var_cycles_resolve_as_possible);\n+                    // recursive type\n+                    return tv.fallback_value();\n+                }\n+                if let Some(known_ty) =\n+                    self.var_unification_table.inlined_probe_value(inner).known()\n+                {\n+                    // known_ty may contain other variables that are known by now\n+                    tv_stack.push(inner);\n+                    let result = self.resolve_ty_as_possible_inner(tv_stack, known_ty.clone());\n+                    tv_stack.pop();\n+                    result\n+                } else {\n+                    ty\n+                }\n+            }\n+            _ => ty,\n+        })\n+    }\n+\n+    /// Resolves the type completely; type variables without known type are\n+    /// replaced by Ty::Unknown.\n+    fn resolve_ty_completely_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| match ty {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                if tv_stack.contains(&inner) {\n+                    tested_by!(type_var_cycles_resolve_completely);\n+                    // recursive type\n+                    return tv.fallback_value();\n+                }\n+                if let Some(known_ty) =\n+                    self.var_unification_table.inlined_probe_value(inner).known()\n+                {\n+                    // known_ty may contain other variables that are known by now\n+                    tv_stack.push(inner);\n+                    let result = self.resolve_ty_completely_inner(tv_stack, known_ty.clone());\n+                    tv_stack.pop();\n+                    result\n+                } else {\n+                    tv.fallback_value()\n+                }\n+            }\n+            _ => ty,\n+        })\n+    }\n+}\n+\n+/// The ID of a type variable.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct TypeVarId(pub(super) u32);\n+\n+impl UnifyKey for TypeVarId {\n+    type Value = TypeVarValue;\n+\n+    fn index(&self) -> u32 {\n+        self.0\n+    }\n+\n+    fn from_index(i: u32) -> Self {\n+        TypeVarId(i)\n+    }\n+\n+    fn tag() -> &'static str {\n+        \"TypeVarId\"\n+    }\n+}\n+\n+/// The value of a type variable: either we already know the type, or we don't\n+/// know it yet.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum TypeVarValue {\n+    Known(Ty),\n+    Unknown,\n+}\n+\n+impl TypeVarValue {\n+    fn known(&self) -> Option<&Ty> {\n+        match self {\n+            TypeVarValue::Known(ty) => Some(ty),\n+            TypeVarValue::Unknown => None,\n+        }\n+    }\n+}\n+\n+impl UnifyValue for TypeVarValue {\n+    type Error = NoError;\n+\n+    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, NoError> {\n+        match (value1, value2) {\n+            // We should never equate two type variables, both of which have\n+            // known types. Instead, we recursively equate those types.\n+            (TypeVarValue::Known(t1), TypeVarValue::Known(t2)) => panic!(\n+                \"equating two type variables, both of which have known types: {:?} and {:?}\",\n+                t1, t2\n+            ),\n+\n+            // If one side is known, prefer that one.\n+            (TypeVarValue::Known(..), TypeVarValue::Unknown) => Ok(value1.clone()),\n+            (TypeVarValue::Unknown, TypeVarValue::Known(..)) => Ok(value2.clone()),\n+\n+            (TypeVarValue::Unknown, TypeVarValue::Unknown) => Ok(TypeVarValue::Unknown),\n         }\n     }\n }"}]}