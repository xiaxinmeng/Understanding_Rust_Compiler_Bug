{"sha": "d68b152c3e2feb6ee18bdf2c992098376dbb528c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2OGIxNTJjM2UyZmViNmVlMThiZGYyYzk5MjA5ODM3NmRiYjUyOGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-16T18:59:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-21T16:18:30Z"}, "message": "std: Be resilient to failure in pthread_getattr_np\n\nThis can fail on linux for various reasons, such as the /proc filesystem not\nbeing mounted. There are already many cases where we can't set up stack guards,\nso just don't worry about this case and communicate that no guard was enabled.\n\nI've confirmed that this allows the compiler to run in a chroot without /proc\nmounted.\n\nCloses #22642", "tree": {"sha": "535bd20cf5b0c241227ab828a8580f2bd1ab38d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/535bd20cf5b0c241227ab828a8580f2bd1ab38d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d68b152c3e2feb6ee18bdf2c992098376dbb528c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d68b152c3e2feb6ee18bdf2c992098376dbb528c", "html_url": "https://github.com/rust-lang/rust/commit/d68b152c3e2feb6ee18bdf2c992098376dbb528c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d68b152c3e2feb6ee18bdf2c992098376dbb528c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39d4faf989cea236e2e1669ab85d060d1c62cd85", "url": "https://api.github.com/repos/rust-lang/rust/commits/39d4faf989cea236e2e1669ab85d060d1c62cd85", "html_url": "https://github.com/rust-lang/rust/commit/39d4faf989cea236e2e1669ab85d060d1c62cd85"}], "stats": {"total": 107, "additions": 60, "deletions": 47}, "files": [{"sha": "0ac0d03e19d404b87059f5e48b4167f6738aefad", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d68b152c3e2feb6ee18bdf2c992098376dbb528c/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b152c3e2feb6ee18bdf2c992098376dbb528c/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=d68b152c3e2feb6ee18bdf2c992098376dbb528c", "patch": "@@ -96,15 +96,15 @@ fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n         // own fault handlers if we hit it.\n         sys_common::stack::record_os_managed_stack_bounds(my_stack_bottom,\n                                                           my_stack_top);\n-        sys::thread::guard::init();\n+        let main_guard = sys::thread::guard::init();\n         sys::stack_overflow::init();\n \n         // Next, set up the current Thread with the guard information we just\n         // created. Note that this isn't necessary in general for new threads,\n         // but we just do this to name the main thread and to give it correct\n         // info about the stack bounds.\n         let thread: Thread = NewThread::new(Some(\"<main>\".to_string()));\n-        thread_info::set(sys::thread::guard::main(), thread);\n+        thread_info::set(main_guard, thread);\n \n         // By default, some platforms will send a *signal* when a EPIPE error\n         // would otherwise be delivered. This runtime doesn't install a SIGPIPE"}, {"sha": "bb47c946e49934bc5d0f65b14dac84cc1f4e7064", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d68b152c3e2feb6ee18bdf2c992098376dbb528c/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b152c3e2feb6ee18bdf2c992098376dbb528c/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=d68b152c3e2feb6ee18bdf2c992098376dbb528c", "patch": "@@ -18,7 +18,7 @@ use thread::Thread;\n use thread::LocalKeyState;\n \n struct ThreadInfo {\n-    stack_guard: usize,\n+    stack_guard: Option<usize>,\n     thread: Thread,\n }\n \n@@ -33,7 +33,7 @@ impl ThreadInfo {\n         THREAD_INFO.with(move |c| {\n             if c.borrow().is_none() {\n                 *c.borrow_mut() = Some(ThreadInfo {\n-                    stack_guard: 0,\n+                    stack_guard: None,\n                     thread: NewThread::new(None),\n                 })\n             }\n@@ -47,10 +47,10 @@ pub fn current_thread() -> Option<Thread> {\n }\n \n pub fn stack_guard() -> Option<usize> {\n-    ThreadInfo::with(|info| info.stack_guard)\n+    ThreadInfo::with(|info| info.stack_guard).and_then(|o| o)\n }\n \n-pub fn set(stack_guard: usize, thread: Thread) {\n+pub fn set(stack_guard: Option<usize>, thread: Thread) {\n     THREAD_INFO.with(|c| assert!(c.borrow().is_none()));\n     THREAD_INFO.with(move |c| *c.borrow_mut() = Some(ThreadInfo{\n         stack_guard: stack_guard,"}, {"sha": "6be61f069266f59a6d1eaec9c4c09d3d4af08141", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 50, "deletions": 38, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/d68b152c3e2feb6ee18bdf2c992098376dbb528c/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b152c3e2feb6ee18bdf2c992098376dbb528c/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=d68b152c3e2feb6ee18bdf2c992098376dbb528c", "patch": "@@ -166,9 +166,10 @@ impl Drop for Thread {\n           not(target_os = \"netbsd\"),\n           not(target_os = \"openbsd\")))]\n pub mod guard {\n-    pub unsafe fn current() -> usize { 0 }\n-    pub unsafe fn main() -> usize { 0 }\n-    pub unsafe fn init() {}\n+    use prelude::v1::*;\n+\n+    pub unsafe fn current() -> Option<usize> { None }\n+    pub unsafe fn init() -> Option<usize> { None }\n }\n \n \n@@ -179,6 +180,8 @@ pub mod guard {\n           target_os = \"openbsd\"))]\n #[allow(unused_imports)]\n pub mod guard {\n+    use prelude::v1::*;\n+\n     use libc::{self, pthread_t};\n     use libc::funcs::posix88::mman::mmap;\n     use libc::consts::os::posix88::{PROT_NONE,\n@@ -191,31 +194,38 @@ pub mod guard {\n     use super::{pthread_self, pthread_attr_destroy};\n     use sys::os;\n \n-    // These are initialized in init() and only read from after\n-    static mut GUARD_PAGE: usize = 0;\n-\n     #[cfg(any(target_os = \"macos\",\n               target_os = \"bitrig\",\n               target_os = \"netbsd\",\n               target_os = \"openbsd\"))]\n-    unsafe fn get_stack_start() -> *mut libc::c_void {\n-        current() as *mut libc::c_void\n+    unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n+        current().map(|s| s as *mut libc::c_void)\n     }\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    unsafe fn get_stack_start() -> *mut libc::c_void {\n+    unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n+        use super::pthread_attr_init;\n+\n+        let mut ret = None;\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n-        assert_eq!(pthread_getattr_np(pthread_self(), &mut attr), 0);\n-        let mut stackaddr = ptr::null_mut();\n-        let mut stacksize = 0;\n-        assert_eq!(pthread_attr_getstack(&attr, &mut stackaddr, &mut stacksize), 0);\n+        assert_eq!(pthread_attr_init(&mut attr), 0);\n+        if pthread_getattr_np(pthread_self(), &mut attr) == 0 {\n+            let mut stackaddr = ptr::null_mut();\n+            let mut stacksize = 0;\n+            assert_eq!(pthread_attr_getstack(&attr, &mut stackaddr,\n+                                             &mut stacksize), 0);\n+            ret = Some(stackaddr);\n+        }\n         assert_eq!(pthread_attr_destroy(&mut attr), 0);\n-        stackaddr\n+        ret\n     }\n \n-    pub unsafe fn init() {\n+    pub unsafe fn init() -> Option<usize> {\n         let psize = os::page_size();\n-        let mut stackaddr = get_stack_start();\n+        let mut stackaddr = match get_stack_start() {\n+            Some(addr) => addr,\n+            None => return None,\n+        };\n \n         // Ensure stackaddr is page aligned! A parent process might\n         // have reset RLIMIT_STACK to be non-page aligned. The\n@@ -245,25 +255,21 @@ pub mod guard {\n \n         let offset = if cfg!(target_os = \"linux\") {2} else {1};\n \n-        GUARD_PAGE = stackaddr as usize + offset * psize;\n-    }\n-\n-    pub unsafe fn main() -> usize {\n-        GUARD_PAGE\n+        Some(stackaddr as usize + offset * psize)\n     }\n \n     #[cfg(target_os = \"macos\")]\n-    pub unsafe fn current() -> usize {\n+    pub unsafe fn current() -> Option<usize> {\n         extern {\n             fn pthread_get_stackaddr_np(thread: pthread_t) -> *mut libc::c_void;\n             fn pthread_get_stacksize_np(thread: pthread_t) -> libc::size_t;\n         }\n-        (pthread_get_stackaddr_np(pthread_self()) as libc::size_t -\n-         pthread_get_stacksize_np(pthread_self())) as usize\n+        Some((pthread_get_stackaddr_np(pthread_self()) as libc::size_t -\n+              pthread_get_stacksize_np(pthread_self())) as usize)\n     }\n \n     #[cfg(any(target_os = \"openbsd\", target_os = \"netbsd\", target_os = \"bitrig\"))]\n-    pub unsafe fn current() -> usize {\n+    pub unsafe fn current() -> Option<usize> {\n         #[repr(C)]\n         struct stack_t {\n             ss_sp: *mut libc::c_void,\n@@ -280,30 +286,36 @@ pub mod guard {\n         assert_eq!(pthread_stackseg_np(pthread_self(), &mut current_stack), 0);\n \n         let extra = if cfg!(target_os = \"bitrig\") {3} else {1} * os::page_size();\n-        if pthread_main_np() == 1 {\n+        Some(if pthread_main_np() == 1 {\n             // main thread\n             current_stack.ss_sp as usize - current_stack.ss_size as usize + extra\n         } else {\n             // new thread\n             current_stack.ss_sp as usize - current_stack.ss_size as usize\n-        }\n+        })\n     }\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-    pub unsafe fn current() -> usize {\n+    pub unsafe fn current() -> Option<usize> {\n+        use super::pthread_attr_init;\n+\n+        let mut ret = None;\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n-        assert_eq!(pthread_getattr_np(pthread_self(), &mut attr), 0);\n-        let mut guardsize = 0;\n-        assert_eq!(pthread_attr_getguardsize(&attr, &mut guardsize), 0);\n-        if guardsize == 0 {\n-            panic!(\"there is no guard page\");\n+        assert_eq!(pthread_attr_init(&mut attr), 0);\n+        if pthread_getattr_np(pthread_self(), &mut attr) == 0 {\n+            let mut guardsize = 0;\n+            assert_eq!(pthread_attr_getguardsize(&attr, &mut guardsize), 0);\n+            if guardsize == 0 {\n+                panic!(\"there is no guard page\");\n+            }\n+            let mut stackaddr = ptr::null_mut();\n+            let mut size = 0;\n+            assert_eq!(pthread_attr_getstack(&attr, &mut stackaddr, &mut size), 0);\n+\n+            ret = Some(stackaddr as usize + guardsize as usize);\n         }\n-        let mut stackaddr = ptr::null_mut();\n-        let mut size = 0;\n-        assert_eq!(pthread_attr_getstack(&attr, &mut stackaddr, &mut size), 0);\n         assert_eq!(pthread_attr_destroy(&mut attr), 0);\n-\n-        stackaddr as usize + guardsize as usize\n+        return ret\n     }\n \n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]"}, {"sha": "42805c2ac52c450bbc328d6189ac42035e15f81d", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d68b152c3e2feb6ee18bdf2c992098376dbb528c/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b152c3e2feb6ee18bdf2c992098376dbb528c/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=d68b152c3e2feb6ee18bdf2c992098376dbb528c", "patch": "@@ -86,7 +86,8 @@ impl Thread {\n }\n \n pub mod guard {\n-    pub unsafe fn main() -> usize { 0 }\n-    pub unsafe fn current() -> usize { 0 }\n-    pub unsafe fn init() {}\n+    use prelude::v1::*;\n+\n+    pub unsafe fn current() -> Option<usize> { None }\n+    pub unsafe fn init() -> Option<usize> { None }\n }"}]}