{"sha": "5ae1e17e81276041b9aa9aca6e6f53385bff5acd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhZTFlMTdlODEyNzYwNDFiOWFhOWFjYTZlNmY1MzM4NWJmZjVhY2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-01T11:37:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-01T11:37:08Z"}, "message": "Auto merge of #6813 - matthiaskrgr:lintcheck_refactor, r=flip1995\n\nlintcheck, do some refactoring and add more sources\n\nrefactor: add a Config object\ndon't run in parallel mode by default (it didn't make sense because cargo would lock the shared target dir anyway)\nshow full paths (from repo root) to the source files in clippy warnings so we can just copy the path from the logfile\nfix more bugs\nadd more crates by dtolnay and embark to the sources toml\n\nchangelog: lintcheck: refactor some code and add more sources", "tree": {"sha": "e40c73499d5c9058c84355a176a2cfe173a1db23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e40c73499d5c9058c84355a176a2cfe173a1db23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ae1e17e81276041b9aa9aca6e6f53385bff5acd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ae1e17e81276041b9aa9aca6e6f53385bff5acd", "html_url": "https://github.com/rust-lang/rust/commit/5ae1e17e81276041b9aa9aca6e6f53385bff5acd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ae1e17e81276041b9aa9aca6e6f53385bff5acd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac2f041b4787a128f4eaf26736c2d2df40e2bee6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac2f041b4787a128f4eaf26736c2d2df40e2bee6", "html_url": "https://github.com/rust-lang/rust/commit/ac2f041b4787a128f4eaf26736c2d2df40e2bee6"}, {"sha": "25f909863b9946c65ae37375f8f95720b728cc9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/25f909863b9946c65ae37375f8f95720b728cc9e", "html_url": "https://github.com/rust-lang/rust/commit/25f909863b9946c65ae37375f8f95720b728cc9e"}], "stats": {"total": 7097, "additions": 3626, "deletions": 3471}, "files": [{"sha": "dfee28f1a87128e0e4ef92472e72ba5968e55a7d", "filename": "clippy_dev/lintcheck_crates.toml", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5ae1e17e81276041b9aa9aca6e6f53385bff5acd/clippy_dev%2Flintcheck_crates.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5ae1e17e81276041b9aa9aca6e6f53385bff5acd/clippy_dev%2Flintcheck_crates.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Flintcheck_crates.toml?ref=5ae1e17e81276041b9aa9aca6e6f53385bff5acd", "patch": "@@ -14,10 +14,22 @@ bitflags = {name = \"bitflags\", versions = ['1.2.1']}\n libc = {name = \"libc\", versions = ['0.2.81']}\n log = {name = \"log\", versions = ['0.4.11']}\n proc-macro2 = {name = \"proc-macro2\", versions = ['1.0.24']}\n-puffin = {name = \"puffin\", git_url = \"https://github.com/EmbarkStudios/puffin\", git_hash = \"02dd4a3\"}\n quote = {name = \"quote\", versions = ['1.0.7']}\n rand = {name = \"rand\", versions = ['0.7.3']}\n rand_core = {name = \"rand_core\", versions = ['0.6.0']}\n regex = {name = \"regex\", versions = ['1.3.2']}\n syn = {name = \"syn\", versions = ['1.0.54']}\n unicode-xid = {name = \"unicode-xid\", versions = ['0.2.1']}\n+# some more of dtolnays crates\n+anyhow = {name = \"anyhow\", versions = ['1.0.38']}\n+async-trait = {name = \"async-trait\", versions = ['0.1.42']}\n+cxx = {name = \"cxx\", versions = ['1.0.32']}\n+ryu = {name = \"ryu\", version = ['1.0.5']}\n+serde_yaml = {name = \"serde_yaml\", versions = ['0.8.17']}\n+thiserror = {name = \"thiserror\", versions = ['1.0.24']}\n+# some embark crates, there are other interesting crates but\n+# unfortunately adding them increases lintcheck runtime drastically\n+cfg-expr = {name = \"cfg-expr\", versions = ['0.7.1']}\n+puffin = {name = \"puffin\", git_url = \"https://github.com/EmbarkStudios/puffin\", git_hash = \"02dd4a3\"}\n+rpmalloc = {name = \"rpmalloc\", versions = ['0.2.0']}\n+tame-oidc = {name = \"tame-oidc\", versions = ['0.1.0']}"}, {"sha": "1db0445559cd55e5cbee3e4de974e509eb253eaf", "filename": "clippy_dev/src/lintcheck.rs", "status": "modified", "additions": 129, "deletions": 89, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/5ae1e17e81276041b9aa9aca6e6f53385bff5acd/clippy_dev%2Fsrc%2Flintcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ae1e17e81276041b9aa9aca6e6f53385bff5acd/clippy_dev%2Fsrc%2Flintcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flintcheck.rs?ref=5ae1e17e81276041b9aa9aca6e6f53385bff5acd", "patch": "@@ -19,6 +19,12 @@ use rayon::prelude::*;\n use serde::{Deserialize, Serialize};\n use serde_json::Value;\n \n+const CLIPPY_DRIVER_PATH: &str = \"target/debug/clippy-driver\";\n+const CARGO_CLIPPY_PATH: &str = \"target/debug/cargo-clippy\";\n+\n+const LINTCHECK_DOWNLOADS: &str = \"target/lintcheck/downloads\";\n+const LINTCHECK_SOURCES: &str = \"target/lintcheck/sources\";\n+\n /// List of sources to check, loaded from a .toml file\n #[derive(Debug, Serialize, Deserialize)]\n struct SourceList {\n@@ -86,7 +92,7 @@ impl std::fmt::Display for ClippyWarning {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         writeln!(\n             f,\n-            r#\"{}-{}/{}:{}:{} {} \"{}\"\"#,\n+            r#\"target/lintcheck/sources/{}-{}/{}:{}:{} {} \"{}\"\"#,\n             &self.crate_name, &self.crate_version, &self.file, &self.line, &self.column, &self.linttype, &self.message\n         )\n     }\n@@ -99,8 +105,8 @@ impl CrateSource {\n     fn download_and_extract(&self) -> Crate {\n         match self {\n             CrateSource::CratesIo { name, version, options } => {\n-                let extract_dir = PathBuf::from(\"target/lintcheck/crates\");\n-                let krate_download_dir = PathBuf::from(\"target/lintcheck/downloads\");\n+                let extract_dir = PathBuf::from(LINTCHECK_SOURCES);\n+                let krate_download_dir = PathBuf::from(LINTCHECK_DOWNLOADS);\n \n                 // url to download the crate from crates.io\n                 let url = format!(\"https://crates.io/api/v1/crates/{}/{}/download\", name, version);\n@@ -140,7 +146,7 @@ impl CrateSource {\n                 options,\n             } => {\n                 let repo_path = {\n-                    let mut repo_path = PathBuf::from(\"target/lintcheck/crates\");\n+                    let mut repo_path = PathBuf::from(LINTCHECK_SOURCES);\n                     // add a -git suffix in case we have the same crate from crates.io and a git repo\n                     repo_path.push(format!(\"{}-git\", name));\n                     repo_path\n@@ -182,7 +188,7 @@ impl CrateSource {\n                 use fs_extra::dir;\n \n                 // simply copy the entire directory into our target dir\n-                let copy_dest = PathBuf::from(\"target/lintcheck/crates/\");\n+                let copy_dest = PathBuf::from(format!(\"{}/\", LINTCHECK_SOURCES));\n \n                 // the source path of the crate we copied,  ${copy_dest}/crate_name\n                 let crate_root = copy_dest.join(name); // .../crates/local_crate\n@@ -287,6 +293,64 @@ impl Crate {\n     }\n }\n \n+#[derive(Debug)]\n+struct LintcheckConfig {\n+    // max number of jobs to spawn (default 1)\n+    max_jobs: usize,\n+    // we read the sources to check from here\n+    sources_toml_path: PathBuf,\n+    // we save the clippy lint results here\n+    lintcheck_results_path: PathBuf,\n+}\n+\n+impl LintcheckConfig {\n+    fn from_clap(clap_config: &ArgMatches) -> Self {\n+        // first, check if we got anything passed via the LINTCHECK_TOML env var,\n+        // if not, ask clap if we got any value for --crates-toml  <foo>\n+        // if not, use the default \"clippy_dev/lintcheck_crates.toml\"\n+        let sources_toml = env::var(\"LINTCHECK_TOML\").unwrap_or(\n+            clap_config\n+                .value_of(\"crates-toml\")\n+                .clone()\n+                .unwrap_or(\"clippy_dev/lintcheck_crates.toml\")\n+                .to_string(),\n+        );\n+\n+        let sources_toml_path = PathBuf::from(sources_toml);\n+\n+        // for the path where we save the lint results, get the filename without extension (so for\n+        // wasd.toml, use \"wasd\"...)\n+        let filename: PathBuf = sources_toml_path.file_stem().unwrap().into();\n+        let lintcheck_results_path = PathBuf::from(format!(\"lintcheck-logs/{}_logs.txt\", filename.display()));\n+\n+        // look at the --threads arg, if 0 is passed, ask rayon rayon how many threads it would spawn and\n+        // use half of that for the physical core count\n+        // by default use a single thread\n+        let max_jobs = match clap_config.value_of(\"threads\") {\n+            Some(threads) => {\n+                let threads: usize = threads\n+                    .parse()\n+                    .expect(&format!(\"Failed to parse '{}' to a digit\", threads));\n+                if threads == 0 {\n+                    // automatic choice\n+                    // Rayon seems to return thread count so half that for core count\n+                    (rayon::current_num_threads() / 2) as usize\n+                } else {\n+                    threads\n+                }\n+            },\n+            // no -j passed, use a single thread\n+            None => 1,\n+        };\n+\n+        LintcheckConfig {\n+            max_jobs,\n+            sources_toml_path,\n+            lintcheck_results_path,\n+        }\n+    }\n+}\n+\n /// takes a single json-formatted clippy warnings and returns true (we are interested in that line)\n /// or false (we aren't)\n fn filter_clippy_warnings(line: &str) -> bool {\n@@ -310,19 +374,6 @@ fn filter_clippy_warnings(line: &str) -> bool {\n     false\n }\n \n-/// get the path to lintchecks crate sources .toml file, check LINTCHECK_TOML first but if it's\n-/// empty use the default path\n-fn lintcheck_config_toml(toml_path: Option<&str>) -> PathBuf {\n-    PathBuf::from(\n-        env::var(\"LINTCHECK_TOML\").unwrap_or(\n-            toml_path\n-                .clone()\n-                .unwrap_or(\"clippy_dev/lintcheck_crates.toml\")\n-                .to_string(),\n-        ),\n-    )\n-}\n-\n /// Builds clippy inside the repo to make sure we have a clippy executable we can use.\n fn build_clippy() {\n     let status = Command::new(\"cargo\")\n@@ -336,9 +387,7 @@ fn build_clippy() {\n }\n \n /// Read a `toml` file and return a list of `CrateSources` that we want to check with clippy\n-fn read_crates(toml_path: &PathBuf) -> (String, Vec<CrateSource>) {\n-    // save it so that we can use the name of the sources.toml as name for the logfile later.\n-    let toml_filename = toml_path.file_stem().unwrap().to_str().unwrap().to_string();\n+fn read_crates(toml_path: &PathBuf) -> Vec<CrateSource> {\n     let toml_content: String =\n         std::fs::read_to_string(&toml_path).unwrap_or_else(|_| panic!(\"Failed to read {}\", toml_path.display()));\n     let crate_list: SourceList =\n@@ -398,7 +447,7 @@ fn read_crates(toml_path: &PathBuf) -> (String, Vec<CrateSource>) {\n     // sort the crates\n     crate_sources.sort();\n \n-    (toml_filename, crate_sources)\n+    crate_sources\n }\n \n /// Parse the json output of clippy and return a `ClippyWarning`\n@@ -450,42 +499,39 @@ fn gather_stats(clippy_warnings: &[ClippyWarning]) -> (String, HashMap<&String,\n \n /// check if the latest modification of the logfile is older than the modification date of the\n /// clippy binary, if this is true, we should clean the lintchec shared target directory and recheck\n-fn lintcheck_needs_rerun(toml_path: &PathBuf) -> bool {\n+fn lintcheck_needs_rerun(lintcheck_logs_path: &PathBuf) -> bool {\n     let clippy_modified: std::time::SystemTime = {\n-        let mut times = [\"target/debug/clippy-driver\", \"target/debug/cargo-clippy\"]\n-            .iter()\n-            .map(|p| {\n-                std::fs::metadata(p)\n-                    .expect(\"failed to get metadata of file\")\n-                    .modified()\n-                    .expect(\"failed to get modification date\")\n-            });\n+        let mut times = [CLIPPY_DRIVER_PATH, CARGO_CLIPPY_PATH].iter().map(|p| {\n+            std::fs::metadata(p)\n+                .expect(\"failed to get metadata of file\")\n+                .modified()\n+                .expect(\"failed to get modification date\")\n+        });\n         // the oldest modification of either of the binaries\n-        std::cmp::min(times.next().unwrap(), times.next().unwrap())\n+        std::cmp::max(times.next().unwrap(), times.next().unwrap())\n     };\n \n-    let logs_modified: std::time::SystemTime = std::fs::metadata(toml_path)\n+    let logs_modified: std::time::SystemTime = std::fs::metadata(lintcheck_logs_path)\n         .expect(\"failed to get metadata of file\")\n         .modified()\n         .expect(\"failed to get modification date\");\n \n-    // if clippys modification time is smaller (older) than the logs mod time, we need to rerun\n-    // lintcheck\n-    clippy_modified < logs_modified\n+    // time is represented in seconds since X\n+    // logs_modified 2 and clippy_modified 5 means clippy binary is older and we need to recheck\n+    logs_modified < clippy_modified\n }\n \n /// lintchecks `main()` function\n pub fn run(clap_config: &ArgMatches) {\n+    let config = LintcheckConfig::from_clap(clap_config);\n+\n     println!(\"Compiling clippy...\");\n     build_clippy();\n     println!(\"Done compiling\");\n \n-    let clap_toml_path: Option<&str> = clap_config.value_of(\"crates-toml\");\n-    let toml_path: PathBuf = lintcheck_config_toml(clap_toml_path);\n-\n     // if the clippy bin is newer than our logs, throw away target dirs to force clippy to\n     // refresh the logs\n-    if lintcheck_needs_rerun(&toml_path) {\n+    if lintcheck_needs_rerun(&config.lintcheck_results_path) {\n         let shared_target_dir = \"target/lintcheck/shared_target_dir\";\n         match std::fs::metadata(&shared_target_dir) {\n             Ok(metadata) => {\n@@ -495,12 +541,11 @@ pub fn run(clap_config: &ArgMatches) {\n                         .expect(\"failed to remove target/lintcheck/shared_target_dir\");\n                 }\n             },\n-            Err(_) => { // dir probably does not exist, don't remove anything\n-            },\n+            Err(_) => { /*  dir probably does not exist, don't remove anything  */ },\n         }\n     }\n \n-    let cargo_clippy_path: PathBuf = PathBuf::from(\"target/debug/cargo-clippy\")\n+    let cargo_clippy_path: PathBuf = PathBuf::from(CARGO_CLIPPY_PATH)\n         .canonicalize()\n         .expect(\"failed to canonicalize path to clippy binary\");\n \n@@ -511,7 +556,7 @@ pub fn run(clap_config: &ArgMatches) {\n         cargo_clippy_path.display()\n     );\n \n-    let clippy_ver = std::process::Command::new(\"target/debug/cargo-clippy\")\n+    let clippy_ver = std::process::Command::new(CARGO_CLIPPY_PATH)\n         .arg(\"--version\")\n         .output()\n         .map(|o| String::from_utf8_lossy(&o.stdout).into_owned())\n@@ -520,9 +565,10 @@ pub fn run(clap_config: &ArgMatches) {\n     // download and extract the crates, then run clippy on them and collect clippys warnings\n     // flatten into one big list of warnings\n \n-    let (filename, crates) = read_crates(&toml_path);\n-    let file = format!(\"lintcheck-logs/{}_logs.txt\", filename);\n-    let old_stats = read_stats_from_file(&file);\n+    let crates = read_crates(&config.sources_toml_path);\n+    let old_stats = read_stats_from_file(&config.lintcheck_results_path);\n+\n+    let counter = AtomicUsize::new(1);\n \n     let clippy_warnings: Vec<ClippyWarning> = if let Some(only_one_crate) = clap_config.value_of(\"only\") {\n         // if we don't have the specified crate in the .toml, throw an error\n@@ -550,44 +596,39 @@ pub fn run(clap_config: &ArgMatches) {\n             .flatten()\n             .collect()\n     } else {\n-        let counter = std::sync::atomic::AtomicUsize::new(0);\n-\n-        // Ask rayon for thread count. Assume that half of that is the number of physical cores\n-        // Use one target dir for each core so that we can run N clippys in parallel.\n-        // We need to use different target dirs because cargo would lock them for a single build otherwise,\n-        // killing the parallelism. However this also means that deps will only be reused half/a\n-        // quarter of the time which might result in a longer wall clock runtime\n-\n-        // This helps when we check many small crates with dep-trees that don't have a lot of branches in\n-        // order to achive some kind of parallelism\n-\n-        // by default, use a single thread\n-        let num_cpus = match clap_config.value_of(\"threads\") {\n-            Some(threads) => {\n-                let threads: usize = threads\n-                    .parse()\n-                    .expect(&format!(\"Failed to parse '{}' to a digit\", threads));\n-                if threads == 0 {\n-                    // automatic choice\n-                    // Rayon seems to return thread count so half that for core count\n-                    (rayon::current_num_threads() / 2) as usize\n-                } else {\n-                    threads\n-                }\n-            },\n-            // no -j passed, use a single thread\n-            None => 1,\n-        };\n-\n-        let num_crates = crates.len();\n-\n-        // check all crates (default)\n-        crates\n-            .into_par_iter()\n-            .map(|krate| krate.download_and_extract())\n-            .map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &counter, num_cpus, num_crates))\n-            .flatten()\n-            .collect()\n+        if config.max_jobs > 1 {\n+            // run parallel with rayon\n+\n+            // Ask rayon for thread count. Assume that half of that is the number of physical cores\n+            // Use one target dir for each core so that we can run N clippys in parallel.\n+            // We need to use different target dirs because cargo would lock them for a single build otherwise,\n+            // killing the parallelism. However this also means that deps will only be reused half/a\n+            // quarter of the time which might result in a longer wall clock runtime\n+\n+            // This helps when we check many small crates with dep-trees that don't have a lot of branches in\n+            // order to achive some kind of parallelism\n+\n+            // by default, use a single thread\n+            let num_cpus = config.max_jobs;\n+            let num_crates = crates.len();\n+\n+            // check all crates (default)\n+            crates\n+                .into_par_iter()\n+                .map(|krate| krate.download_and_extract())\n+                .map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &counter, num_cpus, num_crates))\n+                .flatten()\n+                .collect()\n+        } else {\n+            // run sequential\n+            let num_crates = crates.len();\n+            crates\n+                .into_iter()\n+                .map(|krate| krate.download_and_extract())\n+                .map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &counter, 1, num_crates))\n+                .flatten()\n+                .collect()\n+        }\n     };\n \n     // generate some stats\n@@ -612,15 +653,14 @@ pub fn run(clap_config: &ArgMatches) {\n     ices.iter()\n         .for_each(|(cratename, msg)| text.push_str(&format!(\"{}: '{}'\", cratename, msg)));\n \n-    println!(\"Writing logs to {}\", file);\n-    write(&file, text).unwrap();\n+    println!(\"Writing logs to {}\", config.lintcheck_results_path.display());\n+    write(&config.lintcheck_results_path, text).unwrap();\n \n     print_stats(old_stats, new_stats);\n }\n \n /// read the previous stats from the lintcheck-log file\n-fn read_stats_from_file(file_path: &String) -> HashMap<String, usize> {\n-    let file_path = PathBuf::from(file_path);\n+fn read_stats_from_file(file_path: &PathBuf) -> HashMap<String, usize> {\n     let file_content: String = match std::fs::read_to_string(file_path).ok() {\n         Some(content) => content,\n         None => {"}, {"sha": "167024b3a056baa623a831886eb731fd82da91eb", "filename": "lintcheck-logs/lintcheck_crates_logs.txt", "status": "modified", "additions": 3484, "deletions": 3381, "changes": 6865, "blob_url": "https://github.com/rust-lang/rust/blob/5ae1e17e81276041b9aa9aca6e6f53385bff5acd/lintcheck-logs%2Flintcheck_crates_logs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5ae1e17e81276041b9aa9aca6e6f53385bff5acd/lintcheck-logs%2Flintcheck_crates_logs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck-logs%2Flintcheck_crates_logs.txt?ref=5ae1e17e81276041b9aa9aca6e6f53385bff5acd"}]}