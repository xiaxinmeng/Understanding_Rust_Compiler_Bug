{"sha": "dc0e9c0b1222dc9ee0be8040635605e0c21fdbcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMGU5YzBiMTIyMmRjOWVlMGJlODA0MDYzNTYwNWUwYzIxZmRiY2Q=", "commit": {"author": {"name": "ggomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-09-06T14:31:18Z"}, "committer": {"name": "ggomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-09-06T14:31:18Z"}, "message": "Add missing urls", "tree": {"sha": "bf151119d9ab7f8d9285cd8e6b77ee6e58f68495", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf151119d9ab7f8d9285cd8e6b77ee6e58f68495"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc0e9c0b1222dc9ee0be8040635605e0c21fdbcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc0e9c0b1222dc9ee0be8040635605e0c21fdbcd", "html_url": "https://github.com/rust-lang/rust/commit/dc0e9c0b1222dc9ee0be8040635605e0c21fdbcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc0e9c0b1222dc9ee0be8040635605e0c21fdbcd/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5114f8a29ba29c7a168b46ede82fb62d67a2d619", "url": "https://api.github.com/repos/rust-lang/rust/commits/5114f8a29ba29c7a168b46ede82fb62d67a2d619", "html_url": "https://github.com/rust-lang/rust/commit/5114f8a29ba29c7a168b46ede82fb62d67a2d619"}], "stats": {"total": 60, "additions": 42, "deletions": 18}, "files": [{"sha": "4eb2c8f064414733e3869044c4511fdffce0d78f", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/dc0e9c0b1222dc9ee0be8040635605e0c21fdbcd/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc0e9c0b1222dc9ee0be8040635605e0c21fdbcd/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=dc0e9c0b1222dc9ee0be8040635605e0c21fdbcd", "patch": "@@ -206,7 +206,7 @@ fn test_resize_policy() {\n /// require this behavior you can create your own hashing function using\n /// [BuildHasherDefault](../hash/struct.BuildHasherDefault.html).\n ///\n-/// It is required that the keys implement the `Eq` and `Hash` traits, although\n+/// It is required that the keys implement the [`Eq`] and [`Hash`] traits, although\n /// this can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`.\n /// If you implement these yourself, it is important that the following\n /// property holds:\n@@ -218,9 +218,9 @@ fn test_resize_policy() {\n /// In other words, if two keys are equal, their hashes must be equal.\n ///\n /// It is a logic error for a key to be modified in such a way that the key's\n-/// hash, as determined by the `Hash` trait, or its equality, as determined by\n-/// the `Eq` trait, changes while it is in the map. This is normally only\n-/// possible through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n+/// hash, as determined by the [`Hash`] trait, or its equality, as determined by\n+/// the [`Eq`] trait, changes while it is in the map. This is normally only\n+/// possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n ///\n /// Relevant papers/articles:\n ///\n@@ -298,8 +298,14 @@ fn test_resize_policy() {\n /// *stat += random_stat_buff();\n /// ```\n ///\n-/// The easiest way to use `HashMap` with a custom type as key is to derive `Eq` and `Hash`.\n-/// We must also derive `PartialEq`.\n+/// The easiest way to use `HashMap` with a custom type as key is to derive [`Eq`] and [`Hash`].\n+/// We must also derive [`PartialEq`].\n+///\n+/// [`Eq`]: ../../std/cmp/trait.Eq.html\n+/// [`Hash`]: ../../std/hash/trait.Hash.html\n+/// [`PartialEq`]: ../../std/cmp/trait.PartialEq.html\n+/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`Cell`]: ../../std/cell/struct.Cell.html\n ///\n /// ```\n /// use std::collections::HashMap;\n@@ -525,7 +531,7 @@ impl<K, V, S> HashMap<K, V, S>\n }\n \n impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n-    /// Creates an empty HashMap.\n+    /// Creates an empty `HashMap`.\n     ///\n     /// # Examples\n     ///\n@@ -539,7 +545,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n         Default::default()\n     }\n \n-    /// Creates an empty hash map with the given initial capacity.\n+    /// Creates an empty `HashMap` with the given initial capacity.\n     ///\n     /// # Examples\n     ///\n@@ -557,7 +563,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n impl<K, V, S> HashMap<K, V, S>\n     where K: Eq + Hash, S: BuildHasher\n {\n-    /// Creates an empty hashmap which will use the given hash builder to hash\n+    /// Creates an empty `HashMap` which will use the given hash builder to hash\n     /// keys.\n     ///\n     /// The created map has the default initial capacity.\n@@ -587,7 +593,7 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n     }\n \n-    /// Creates an empty HashMap with space for at least `capacity`\n+    /// Creates an empty `HashMap` with space for at least `capacity`\n     /// elements, using `hasher` to hash the keys.\n     ///\n     /// Warning: `hasher` is normally randomly generated, and\n@@ -677,7 +683,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// Resizes the internal vectors to a new capacity. It's your responsibility to:\n     ///   1) Make sure the new capacity is enough for all the elements, accounting\n     ///      for the load factor.\n-    ///   2) Ensure new_capacity is a power of two or zero.\n+    ///   2) Ensure `new_capacity` is a power of two or zero.\n     fn resize(&mut self, new_capacity: usize) {\n         assert!(self.table.size() <= new_capacity);\n         assert!(new_capacity.is_power_of_two() || new_capacity == 0);\n@@ -1040,9 +1046,12 @@ impl<K, V, S> HashMap<K, V, S>\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n+    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n+    /// [`Hash`]: ../../std/hash/trait.Hash.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1063,9 +1072,12 @@ impl<K, V, S> HashMap<K, V, S>\n     /// Returns true if the map contains a value for the specified key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n+    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n+    /// [`Hash`]: ../../std/hash/trait.Hash.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1086,9 +1098,12 @@ impl<K, V, S> HashMap<K, V, S>\n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n+    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n+    /// [`Hash`]: ../../std/hash/trait.Hash.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1143,9 +1158,12 @@ impl<K, V, S> HashMap<K, V, S>\n     /// was previously in the map.\n     ///\n     /// The key may be any borrowed form of the map's key type, but\n-    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n     /// the key type.\n     ///\n+    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n+    /// [`Hash`]: ../../std/hash/trait.Hash.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1904,12 +1922,15 @@ impl<'a, K, V, S> Extend<(&'a K, &'a V)> for HashMap<K, V, S>\n     }\n }\n \n-/// `RandomState` is the default state for `HashMap` types.\n+/// `RandomState` is the default state for [`HashMap`] types.\n ///\n /// A particular instance `RandomState` will create the same instances of\n-/// `Hasher`, but the hashers created by two different `RandomState`\n+/// [`Hasher`], but the hashers created by two different `RandomState`\n /// instances are unlikely to produce the same result for the same values.\n ///\n+/// [`HashMap`]: struct.HashMap.html\n+/// [`Hasher`]: ../../hash/trait.Hasher.html\n+///\n /// # Examples\n ///\n /// ```\n@@ -1980,10 +2001,13 @@ impl BuildHasher for RandomState {\n     }\n }\n \n-/// The default `Hasher` used by `RandomState`.\n+/// The default [`Hasher`] used by [`RandomState`].\n ///\n /// The internal algorithm is not specified, and so it and its hashes should\n /// not be relied upon over releases.\n+///\n+/// [`RandomState`]: struct.RandomState.html\n+/// [`Hasher`]: ../../hash/trait.Hasher.html\n #[unstable(feature = \"hashmap_default_hasher\", issue = \"0\")]\n pub struct DefaultHasher(SipHasher13);\n "}]}