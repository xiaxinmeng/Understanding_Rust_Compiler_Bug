{"sha": "214bcc5290c338d50ee170a67f3924e8cd9d40b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxNGJjYzUyOTBjMzM4ZDUwZWUxNzBhNjdmMzkyNGU4Y2Q5ZDQwYjM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-11-17T18:40:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-17T18:40:58Z"}, "message": "Rollup merge of #37806 - GuillaumeGomez:net_examples, r=frewsxcv\n\nNet examples\n\nr? @steveklabnik", "tree": {"sha": "6265168bc7b0144803767dbb50a5589b4cea398c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6265168bc7b0144803767dbb50a5589b4cea398c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/214bcc5290c338d50ee170a67f3924e8cd9d40b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/214bcc5290c338d50ee170a67f3924e8cd9d40b3", "html_url": "https://github.com/rust-lang/rust/commit/214bcc5290c338d50ee170a67f3924e8cd9d40b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/214bcc5290c338d50ee170a67f3924e8cd9d40b3/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e88e13d31158780260b1be829242f8fb845d39c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e88e13d31158780260b1be829242f8fb845d39c1", "html_url": "https://github.com/rust-lang/rust/commit/e88e13d31158780260b1be829242f8fb845d39c1"}, {"sha": "976bfc032266e1b6f8281c1f08df3d6cb8242776", "url": "https://api.github.com/repos/rust-lang/rust/commits/976bfc032266e1b6f8281c1f08df3d6cb8242776", "html_url": "https://github.com/rust-lang/rust/commit/976bfc032266e1b6f8281c1f08df3d6cb8242776"}], "stats": {"total": 150, "additions": 144, "deletions": 6}, "files": [{"sha": "7b7be6e2eeeb3628c61afe8c5f70da74612c1e2a", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 142, "deletions": 5, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/214bcc5290c338d50ee170a67f3924e8cd9d40b3/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214bcc5290c338d50ee170a67f3924e8cd9d40b3/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=214bcc5290c338d50ee170a67f3924e8cd9d40b3", "patch": "@@ -154,6 +154,14 @@ impl Ipv4Addr {\n     /// Creates a new IPv4 address from four eight-bit octets.\n     ///\n     /// The result will represent the IP address `a`.`b`.`c`.`d`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n         Ipv4Addr {\n@@ -167,6 +175,15 @@ impl Ipv4Addr {\n     }\n \n     /// Returns the four eight-bit integers that make up this address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n+    /// assert_eq!(addr.octets(), [127, 0, 0, 1]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn octets(&self) -> [u8; 4] {\n         let bits = ntoh(self.inner.s_addr);\n@@ -176,8 +193,18 @@ impl Ipv4Addr {\n     /// Returns true for the special 'unspecified' address (0.0.0.0).\n     ///\n     /// This property is defined in _UNIX Network Programming, Second Edition_,\n-    /// W. Richard Stevens, p. 891; see also [ip7]\n-    /// [ip7][http://man7.org/linux/man-pages/man7/ip.7.html]\n+    /// W. Richard Stevens, p. 891; see also [ip7].\n+    ///\n+    /// [ip7]: http://man7.org/linux/man-pages/man7/ip.7.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_unspecified(), true);\n+    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_unspecified(), false);\n+    /// ```\n     #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n     pub fn is_unspecified(&self) -> bool {\n         self.inner.s_addr == 0\n@@ -186,7 +213,17 @@ impl Ipv4Addr {\n     /// Returns true if this is a loopback address (127.0.0.0/8).\n     ///\n     /// This property is defined by [RFC 1122].\n+    ///\n     /// [RFC 1122]: https://tools.ietf.org/html/rfc1122\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_loopback(), true);\n+    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_loopback(), false);\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_loopback(&self) -> bool {\n         self.octets()[0] == 127\n@@ -195,11 +232,26 @@ impl Ipv4Addr {\n     /// Returns true if this is a private address.\n     ///\n     /// The private address ranges are defined in [RFC 1918] and include:\n-    /// [RFC 1918]: https://tools.ietf.org/html/rfc1918\n     ///\n     ///  - 10.0.0.0/8\n     ///  - 172.16.0.0/12\n     ///  - 192.168.0.0/16\n+    ///\n+    /// [RFC 1918]: https://tools.ietf.org/html/rfc1918\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(10, 0, 0, 1).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(10, 10, 10, 10).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 10).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 29, 45, 14).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 32, 0, 2).is_private(), false);\n+    /// assert_eq!(Ipv4Addr::new(192, 168, 0, 2).is_private(), true);\n+    /// assert_eq!(Ipv4Addr::new(192, 169, 0, 2).is_private(), false);\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_private(&self) -> bool {\n         match (self.octets()[0], self.octets()[1]) {\n@@ -213,15 +265,25 @@ impl Ipv4Addr {\n     /// Returns true if the address is link-local (169.254.0.0/16).\n     ///\n     /// This property is defined by [RFC 3927].\n+    ///\n     /// [RFC 3927]: https://tools.ietf.org/html/rfc3927\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(169, 254, 0, 0).is_link_local(), true);\n+    /// assert_eq!(Ipv4Addr::new(169, 254, 10, 65).is_link_local(), true);\n+    /// assert_eq!(Ipv4Addr::new(16, 89, 10, 65).is_link_local(), false);\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_link_local(&self) -> bool {\n         self.octets()[0] == 169 && self.octets()[1] == 254\n     }\n \n     /// Returns true if the address appears to be globally routable.\n     /// See [iana-ipv4-special-registry][ipv4-sr].\n-    /// [ipv4-sr]: http://goo.gl/RaZ7lg\n     ///\n     /// The following return false:\n     ///\n@@ -231,6 +293,24 @@ impl Ipv4Addr {\n     /// - the broadcast address (255.255.255.255/32)\n     /// - test addresses used for documentation (192.0.2.0/24, 198.51.100.0/24 and 203.0.113.0/24)\n     /// - the unspecified address (0.0.0.0)\n+    ///\n+    /// [ipv4-sr]: http://goo.gl/RaZ7lg\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ip)]\n+    ///\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(Ipv4Addr::new(10, 254, 0, 0).is_global(), false);\n+    ///     assert_eq!(Ipv4Addr::new(192, 168, 10, 65).is_global(), false);\n+    ///     assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_global(), false);\n+    ///     assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_global(), false);\n+    ///     assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n+    /// }\n+    /// ```\n     pub fn is_global(&self) -> bool {\n         !self.is_private() && !self.is_loopback() && !self.is_link_local() &&\n         !self.is_broadcast() && !self.is_documentation() && !self.is_unspecified()\n@@ -240,7 +320,18 @@ impl Ipv4Addr {\n     ///\n     /// Multicast addresses have a most significant octet between 224 and 239,\n     /// and is defined by [RFC 5771].\n+    ///\n     /// [RFC 5771]: https://tools.ietf.org/html/rfc5771\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(224, 254, 0, 0).is_multicast(), true);\n+    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_multicast(), true);\n+    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_multicast(), false);\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_multicast(&self) -> bool {\n         self.octets()[0] >= 224 && self.octets()[0] <= 239\n@@ -249,7 +340,17 @@ impl Ipv4Addr {\n     /// Returns true if this is a broadcast address (255.255.255.255).\n     ///\n     /// A broadcast address has all octets set to 255 as defined in [RFC 919].\n+    ///\n     /// [RFC 919]: https://tools.ietf.org/html/rfc919\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_broadcast(), true);\n+    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_broadcast(), false);\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_broadcast(&self) -> bool {\n         self.octets()[0] == 255 && self.octets()[1] == 255 &&\n@@ -259,11 +360,23 @@ impl Ipv4Addr {\n     /// Returns true if this address is in a range designated for documentation.\n     ///\n     /// This is defined in [RFC 5737]:\n-    /// [RFC 5737]: https://tools.ietf.org/html/rfc5737\n     ///\n     /// - 192.0.2.0/24 (TEST-NET-1)\n     /// - 198.51.100.0/24 (TEST-NET-2)\n     /// - 203.0.113.0/24 (TEST-NET-3)\n+    ///\n+    /// [RFC 5737]: https://tools.ietf.org/html/rfc5737\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::Ipv4Addr;\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_documentation(), true);\n+    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_documentation(), true);\n+    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_documentation(), true);\n+    /// assert_eq!(Ipv4Addr::new(193, 34, 17, 19).is_documentation(), false);\n+    /// ```\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_documentation(&self) -> bool {\n         match(self.octets()[0], self.octets()[1], self.octets()[2], self.octets()[3]) {\n@@ -277,6 +390,15 @@ impl Ipv4Addr {\n     /// Converts this address to an IPv4-compatible IPv6 address.\n     ///\n     /// a.b.c.d becomes ::a.b.c.d\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_compatible(),\n+    ///            Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 767));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_ipv6_compatible(&self) -> Ipv6Addr {\n         Ipv6Addr::new(0, 0, 0, 0, 0, 0,\n@@ -287,6 +409,15 @@ impl Ipv4Addr {\n     /// Converts this address to an IPv4-mapped IPv6 address.\n     ///\n     /// a.b.c.d becomes ::ffff:a.b.c.d\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::net::{Ipv4Addr, Ipv6Addr};\n+    ///\n+    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_mapped(),\n+    ///            Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 49152, 767));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_ipv6_mapped(&self) -> Ipv6Addr {\n         Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff,\n@@ -425,6 +556,7 @@ impl Ipv6Addr {\n     /// Returns true for the special 'unspecified' address (::).\n     ///\n     /// This property is defined in [RFC 4291].\n+    ///\n     /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_unspecified(&self) -> bool {\n@@ -434,6 +566,7 @@ impl Ipv6Addr {\n     /// Returns true if this is a loopback address (::1).\n     ///\n     /// This property is defined in [RFC 4291].\n+    ///\n     /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_loopback(&self) -> bool {\n@@ -458,6 +591,7 @@ impl Ipv6Addr {\n     /// Returns true if this is a unique local address (fc00::/7).\n     ///\n     /// This property is defined in [RFC 4193].\n+    ///\n     /// [RFC 4193]: https://tools.ietf.org/html/rfc4193\n     pub fn is_unique_local(&self) -> bool {\n         (self.segments()[0] & 0xfe00) == 0xfc00\n@@ -466,6 +600,7 @@ impl Ipv6Addr {\n     /// Returns true if the address is unicast and link-local (fe80::/10).\n     ///\n     /// This property is defined in [RFC 4291].\n+    ///\n     /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n     pub fn is_unicast_link_local(&self) -> bool {\n         (self.segments()[0] & 0xffc0) == 0xfe80\n@@ -481,6 +616,7 @@ impl Ipv6Addr {\n     /// (2001:db8::/32).\n     ///\n     /// This property is defined in [RFC 3849].\n+    ///\n     /// [RFC 3849]: https://tools.ietf.org/html/rfc3849\n     pub fn is_documentation(&self) -> bool {\n         (self.segments()[0] == 0x2001) && (self.segments()[1] == 0xdb8)\n@@ -524,6 +660,7 @@ impl Ipv6Addr {\n     /// Returns true if this is a multicast address (ff00::/8).\n     ///\n     /// This property is defined by [RFC 4291].\n+    ///\n     /// [RFC 4291]: https://tools.ietf.org/html/rfc4291\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_multicast(&self) -> bool {"}, {"sha": "159aa997b27285cc8e407df79d382752eee23e84", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/214bcc5290c338d50ee170a67f3924e8cd9d40b3/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214bcc5290c338d50ee170a67f3924e8cd9d40b3/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=214bcc5290c338d50ee170a67f3924e8cd9d40b3", "patch": "@@ -67,11 +67,12 @@ pub struct TcpListener(net_imp::TcpListener);\n \n /// An infinite iterator over the connections from a `TcpListener`.\n ///\n-/// This iterator will infinitely yield `Some` of the accepted connections. It\n+/// This iterator will infinitely yield [`Some`] of the accepted connections. It\n /// is equivalent to calling `accept` in a loop.\n ///\n /// This `struct` is created by the [`incoming`] method on [`TcpListener`].\n ///\n+/// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n /// [`incoming`]: struct.TcpListener.html#method.incoming\n /// [`TcpListener`]: struct.TcpListener.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}]}