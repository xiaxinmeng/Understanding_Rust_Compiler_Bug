{"sha": "8456c403e1e79220d898b29074ce41dfeb752b08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0NTZjNDAzZTFlNzkyMjBkODk4YjI5MDc0Y2U0MWRmZWI3NTJiMDg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-07T02:07:35Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-23T12:55:04Z"}, "message": "extract parse_not_expr", "tree": {"sha": "20f95a28e7691e6d3c99ee4b3b1ba22468ac3b40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20f95a28e7691e6d3c99ee4b3b1ba22468ac3b40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8456c403e1e79220d898b29074ce41dfeb752b08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8456c403e1e79220d898b29074ce41dfeb752b08", "html_url": "https://github.com/rust-lang/rust/commit/8456c403e1e79220d898b29074ce41dfeb752b08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8456c403e1e79220d898b29074ce41dfeb752b08/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efdea63c432fb1c88000bd1e12566641705fdb13", "url": "https://api.github.com/repos/rust-lang/rust/commits/efdea63c432fb1c88000bd1e12566641705fdb13", "html_url": "https://github.com/rust-lang/rust/commit/efdea63c432fb1c88000bd1e12566641705fdb13"}], "stats": {"total": 194, "additions": 86, "deletions": 108}, "files": [{"sha": "0be83e418e3096f9212aa8c673f49247ae67a36c", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=8456c403e1e79220d898b29074ce41dfeb752b08", "patch": "@@ -1,9 +1,10 @@\n use super::{Parser, PathStyle, TokenType};\n use rustc_errors::PResult;\n use syntax::ast;\n-use syntax::attr;\n+use syntax::print::pprust;\n use syntax::token::{self, Nonterminal};\n use syntax::util::comments;\n+use syntax::util::comments;\n use syntax_pos::{Span, Symbol};\n \n use log::debug;\n@@ -154,7 +155,7 @@ impl<'a> Parser<'a> {\n                 (attr_sp, item, style)\n             }\n             _ => {\n-                let token_str = self.this_token_to_string();\n+                let token_str = pprust::token_to_string(&self.token);\n                 return Err(self.fatal(&format!(\"expected `#`, found `{}`\", token_str)));\n             }\n         };\n@@ -329,7 +330,7 @@ impl<'a> Parser<'a> {\n             Err(ref mut err) => err.cancel(),\n         }\n \n-        let found = self.this_token_to_string();\n+        let found = pprust::token_to_string(&self.token);\n         let msg = format!(\"expected unsuffixed literal or identifier, found `{}`\", found);\n         Err(self.diagnostic().struct_span_err(self.token.span, &msg))\n     }"}, {"sha": "578f816be58c8f58ad79fcabc2b19b5df64e01fe", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=8456c403e1e79220d898b29074ce41dfeb752b08", "patch": "@@ -200,7 +200,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn expected_ident_found(&self) -> DiagnosticBuilder<'a> {\n         let mut err = self.struct_span_err(\n             self.token.span,\n-            &format!(\"expected identifier, found {}\", self.this_token_descr()),\n+            &format!(\"expected identifier, found {}\", super::token_descr(&self.token)),\n         );\n         let valid_follow = &[\n             TokenKind::Eq,\n@@ -225,7 +225,7 @@ impl<'a> Parser<'a> {\n                 );\n             }\n         }\n-        if let Some(token_descr) = self.token_descr() {\n+        if let Some(token_descr) = super::token_descr_opt(&self.token) {\n             err.span_label(self.token.span, format!(\"expected identifier, found {}\", token_descr));\n         } else {\n             err.span_label(self.token.span, \"expected identifier\");\n@@ -272,7 +272,7 @@ impl<'a> Parser<'a> {\n         expected.sort_by_cached_key(|x| x.to_string());\n         expected.dedup();\n         let expect = tokens_to_string(&expected[..]);\n-        let actual = self.this_token_descr();\n+        let actual = super::token_descr(&self.token);\n         let (msg_exp, (label_sp, label_exp)) = if expected.len() > 1 {\n             let short_expect = if expected.len() > 6 {\n                 format!(\"{} possible tokens\", expected.len())\n@@ -815,7 +815,7 @@ impl<'a> Parser<'a> {\n         t: &TokenKind,\n     ) -> PResult<'a, bool /* recovered */> {\n         let token_str = pprust::token_kind_to_string(t);\n-        let this_token_str = self.this_token_descr();\n+        let this_token_str = super::token_descr(&self.token);\n         let (prev_sp, sp) = match (&self.token.kind, self.subparser_name) {\n             // Point at the end of the macro call when reaching end of macro arguments.\n             (token::Eof, Some(_)) => {\n@@ -862,7 +862,7 @@ impl<'a> Parser<'a> {\n             return Ok(());\n         }\n         let sm = self.sess.source_map();\n-        let msg = format!(\"expected `;`, found `{}`\", self.this_token_descr());\n+        let msg = format!(\"expected `;`, found `{}`\", super::token_descr(&self.token));\n         let appl = Applicability::MachineApplicable;\n         if self.token.span == DUMMY_SP || self.prev_span == DUMMY_SP {\n             // Likely inside a macro, can't provide meaninful suggestions.\n@@ -1270,7 +1270,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn expected_semi_or_open_brace<T>(&mut self) -> PResult<'a, T> {\n-        let token_str = self.this_token_descr();\n+        let token_str = super::token_descr(&self.token);\n         let mut err = self.fatal(&format!(\"expected `;` or `{{`, found {}\", token_str));\n         err.span_label(self.token.span, \"expected `;` or `{`\");\n         Err(err)\n@@ -1447,7 +1447,7 @@ impl<'a> Parser<'a> {\n             }\n             _ => (\n                 self.token.span,\n-                format!(\"expected expression, found {}\", self.this_token_descr(),),\n+                format!(\"expected expression, found {}\", super::token_descr(&self.token),),\n             ),\n         };\n         let mut err = self.struct_span_err(span, &msg);"}, {"sha": "9b106b6db3c0172f72726d31f901fa404733cc38", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 34, "deletions": 52, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=8456c403e1e79220d898b29074ce41dfeb752b08", "patch": "@@ -442,35 +442,37 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a prefix-unary-operator expr.\n-    fn parse_prefix_expr(&mut self, already_parsed_attrs: Option<AttrVec>) -> PResult<'a, P<Expr>> {\n-        let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n+    fn parse_prefix_expr(&mut self, attrs: Option<AttrVec>) -> PResult<'a, P<Expr>> {\n+        let attrs = self.parse_or_use_outer_attributes(attrs)?;\n         let lo = self.token.span;\n         // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n         let (hi, ex) = match self.token.kind {\n-            token::Not => {\n-                self.bump();\n-                let e = self.parse_prefix_expr(None);\n-                let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (lo.to(span), self.mk_unary(UnOp::Not, e))\n-            }\n-            token::Tilde => self.recover_tilde_expr(lo)?,\n-            token::BinOp(token::Minus) => self.parse_neg_expr(lo)?,\n-            token::BinOp(token::Star) => self.parse_deref_expr(lo)?,\n-            token::BinOp(token::And) | token::AndAnd => self.parse_borrow_expr(lo)?,\n-            token::Ident(..) if self.token.is_keyword(kw::Box) => self.parse_box_expr(lo)?,\n-            token::Ident(..) if self.is_mistaken_not_ident_negation() => {\n-                self.recover_not_expr(lo)?\n-            }\n+            token::Not => self.parse_unary_expr(lo, UnOp::Not), // `!expr`\n+            token::Tilde => self.recover_tilde_expr(lo),        // `~expr`\n+            token::BinOp(token::Minus) => self.parse_unary_expr(lo, UnOp::Neg), // `-expr`\n+            token::BinOp(token::Star) => self.parse_unary_expr(lo, UnOp::Deref), // `*expr`\n+            token::BinOp(token::And) | token::AndAnd => self.parse_borrow_expr(lo),\n+            token::Ident(..) if self.token.is_keyword(kw::Box) => self.parse_box_expr(lo),\n+            token::Ident(..) if self.is_mistaken_not_ident_negation() => self.recover_not_expr(lo),\n             _ => return self.parse_dot_or_call_expr(Some(attrs)),\n-        };\n-        return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n+        }?;\n+        Ok(self.mk_expr(lo.to(hi), ex, attrs))\n     }\n \n-    // Recover on `!` suggesting for bitwise negation instead.\n-    fn recover_tilde_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n+    fn parse_prefix_expr_common(&mut self, lo: Span) -> PResult<'a, (Span, P<Expr>)> {\n         self.bump();\n         let expr = self.parse_prefix_expr(None);\n         let (span, expr) = self.interpolated_or_expr_span(expr)?;\n+        Ok((lo.to(span), expr))\n+    }\n+\n+    fn parse_unary_expr(&mut self, lo: Span, op: UnOp) -> PResult<'a, (Span, ExprKind)> {\n+        let (span, expr) = self.parse_prefix_expr_common(lo)?;\n+        Ok((span, self.mk_unary(op, expr)))\n+    }\n+\n+    // Recover on `!` suggesting for bitwise negation instead.\n+    fn recover_tilde_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n         self.struct_span_err(lo, \"`~` cannot be used as a unary operator\")\n             .span_suggestion_short(\n                 lo,\n@@ -479,31 +481,13 @@ impl<'a> Parser<'a> {\n                 Applicability::MachineApplicable,\n             )\n             .emit();\n-        Ok((lo.to(span), self.mk_unary(UnOp::Not, expr)))\n-    }\n \n-    /// Parse `-expr`.\n-    fn parse_neg_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n-        self.bump(); // `-`\n-        let expr = self.parse_prefix_expr(None);\n-        let (span, expr) = self.interpolated_or_expr_span(expr)?;\n-        Ok((lo.to(span), self.mk_unary(UnOp::Neg, expr)))\n-    }\n-\n-    /// Parse `*expr`.\n-    fn parse_deref_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n-        self.bump(); // `*`\n-        let expr = self.parse_prefix_expr(None);\n-        let (span, expr) = self.interpolated_or_expr_span(expr)?;\n-        Ok((lo.to(span), self.mk_unary(UnOp::Deref, expr)))\n+        self.parse_unary_expr(lo, UnOp::Not)\n     }\n \n     /// Parse `box expr`.\n     fn parse_box_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n-        self.bump(); // `box`\n-        let expr = self.parse_prefix_expr(None);\n-        let (span, expr) = self.interpolated_or_expr_span(expr)?;\n-        let span = lo.to(span);\n+        let (span, expr) = self.parse_prefix_expr_common(lo)?;\n         self.sess.gated_spans.gate(sym::box_syntax, span);\n         Ok((span, ExprKind::Box(expr)))\n     }\n@@ -521,26 +505,24 @@ impl<'a> Parser<'a> {\n \n     /// Recover on `not expr` in favor of `!expr`.\n     fn recover_not_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n-        self.bump();\n-        // Emit the error ...\n+        // Emit the error...\n+        let not_token = self.look_ahead(1, |t| t.clone());\n         self.struct_span_err(\n-            self.token.span,\n-            &format!(\"unexpected {} after identifier\", self.this_token_descr()),\n+            not_token.span,\n+            &format!(\"unexpected {} after identifier\", super::token_descr(&not_token)),\n         )\n         .span_suggestion_short(\n             // Span the `not` plus trailing whitespace to avoid\n             // trailing whitespace after the `!` in our suggestion\n-            self.sess.source_map().span_until_non_whitespace(lo.to(self.token.span)),\n+            self.sess.source_map().span_until_non_whitespace(lo.to(not_token.span)),\n             \"use `!` to perform logical negation\",\n             \"!\".to_owned(),\n             Applicability::MachineApplicable,\n         )\n         .emit();\n-        // \u2014and recover! (just as if we were in the block\n-        // for the `token::Not` arm)\n-        let expr = self.parse_prefix_expr(None);\n-        let (span, e) = self.interpolated_or_expr_span(expr)?;\n-        Ok((lo.to(span), self.mk_unary(UnOp::Not, e)))\n+\n+        // ...and recover!\n+        self.parse_unary_expr(lo, UnOp::Not)\n     }\n \n     /// Returns the span of expr, if it was not interpolated or the span of the interpolated token.\n@@ -738,7 +720,7 @@ impl<'a> Parser<'a> {\n \n     fn error_unexpected_after_dot(&self) {\n         // FIXME Could factor this out into non_fatal_unexpected or something.\n-        let actual = self.this_token_to_string();\n+        let actual = pprust::token_to_string(&self.token);\n         self.struct_span_err(self.token.span, &format!(\"unexpected token: `{}`\", actual)).emit();\n     }\n \n@@ -1142,7 +1124,7 @@ impl<'a> Parser<'a> {\n \n     pub(super) fn parse_lit(&mut self) -> PResult<'a, Lit> {\n         self.parse_opt_lit().ok_or_else(|| {\n-            let msg = format!(\"unexpected token: {}\", self.this_token_descr());\n+            let msg = format!(\"unexpected token: {}\", super::token_descr(&self.token));\n             self.span_fatal(self.token.span, &msg)\n         })\n     }"}, {"sha": "343c6667d47d595d294a4a30467d1a42ffc08ac8", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=8456c403e1e79220d898b29074ce41dfeb752b08", "patch": "@@ -1348,7 +1348,7 @@ impl<'a> Parser<'a> {\n             self.expect_semi()?;\n             body\n         } else {\n-            let token_str = self.this_token_descr();\n+            let token_str = super::token_descr(&self.token);\n             let mut err = self.fatal(&format!(\n                 \"expected `where`, `{{`, `(`, or `;` after struct name, found {}\",\n                 token_str\n@@ -1374,7 +1374,7 @@ impl<'a> Parser<'a> {\n             let (fields, recovered) = self.parse_record_struct_body()?;\n             VariantData::Struct(fields, recovered)\n         } else {\n-            let token_str = self.this_token_descr();\n+            let token_str = super::token_descr(&self.token);\n             let mut err = self\n                 .fatal(&format!(\"expected `where` or `{{` after union name, found {}\", token_str));\n             err.span_label(self.token.span, \"expected `where` or `{` after union name\");\n@@ -1411,7 +1411,7 @@ impl<'a> Parser<'a> {\n             }\n             self.eat(&token::CloseDelim(token::Brace));\n         } else {\n-            let token_str = self.this_token_descr();\n+            let token_str = super::token_descr(&self.token);\n             let mut err = self.fatal(&format!(\n                 \"expected `where`, or `{{` after struct name, found {}\",\n                 token_str\n@@ -1498,7 +1498,7 @@ impl<'a> Parser<'a> {\n                 let sp = self.sess.source_map().next_point(self.prev_span);\n                 let mut err = self.struct_span_err(\n                     sp,\n-                    &format!(\"expected `,`, or `}}`, found {}\", self.this_token_descr()),\n+                    &format!(\"expected `,`, or `}}`, found {}\", super::token_descr(&self.token)),\n                 );\n                 if self.token.is_ident() {\n                     // This is likely another field; emit the diagnostic and keep going"}, {"sha": "103bbe5dd763e20aab519bf7a5e7d6cc7cacc8fe", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=8456c403e1e79220d898b29074ce41dfeb752b08", "patch": "@@ -354,6 +354,24 @@ pub enum FollowedByType {\n     No,\n }\n \n+fn token_descr_opt(token: &Token) -> Option<&'static str> {\n+    Some(match token.kind {\n+        _ if token.is_special_ident() => \"reserved identifier\",\n+        _ if token.is_used_keyword() => \"keyword\",\n+        _ if token.is_unused_keyword() => \"reserved keyword\",\n+        token::DocComment(..) => \"doc comment\",\n+        _ => return None,\n+    })\n+}\n+\n+pub(super) fn token_descr(token: &Token) -> String {\n+    let token_str = pprust::token_to_string(token);\n+    match token_descr_opt(token) {\n+        Some(prefix) => format!(\"{} `{}`\", prefix, token_str),\n+        _ => format!(\"`{}`\", token_str),\n+    }\n+}\n+\n impl<'a> Parser<'a> {\n     pub fn new(\n         sess: &'a ParseSess,\n@@ -422,29 +440,6 @@ impl<'a> Parser<'a> {\n         next\n     }\n \n-    /// Converts the current token to a string using `self`'s reader.\n-    pub fn this_token_to_string(&self) -> String {\n-        pprust::token_to_string(&self.token)\n-    }\n-\n-    fn token_descr(&self) -> Option<&'static str> {\n-        Some(match &self.token.kind {\n-            _ if self.token.is_special_ident() => \"reserved identifier\",\n-            _ if self.token.is_used_keyword() => \"keyword\",\n-            _ if self.token.is_unused_keyword() => \"reserved keyword\",\n-            token::DocComment(..) => \"doc comment\",\n-            _ => return None,\n-        })\n-    }\n-\n-    pub(super) fn this_token_descr(&self) -> String {\n-        if let Some(prefix) = self.token_descr() {\n-            format!(\"{} `{}`\", prefix, self.this_token_to_string())\n-        } else {\n-            format!(\"`{}`\", self.this_token_to_string())\n-        }\n-    }\n-\n     crate fn unexpected<T>(&mut self) -> PResult<'a, T> {\n         match self.expect_one_of(&[], &[]) {\n             Err(e) => Err(e),"}, {"sha": "3f54e0b6de031f7922368433a62760b50a415a32", "filename": "src/librustc_parse/parser/module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=8456c403e1e79220d898b29074ce41dfeb752b08", "patch": "@@ -79,7 +79,7 @@ impl<'a> Parser<'a> {\n         }\n \n         if !self.eat(term) {\n-            let token_str = self.this_token_descr();\n+            let token_str = super::token_descr(&self.token);\n             if !self.maybe_consume_incorrect_semicolon(&items) {\n                 let mut err = self.fatal(&format!(\"expected item, found {}\", token_str));\n                 err.span_label(self.token.span, \"expected item\");"}, {"sha": "01b122618acb0204e15b9993550d8d1fe68855af", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=8456c403e1e79220d898b29074ce41dfeb752b08", "patch": "@@ -670,7 +670,7 @@ impl<'a> Parser<'a> {\n         err.cancel();\n \n         let expected = expected.unwrap_or(\"pattern\");\n-        let msg = format!(\"expected {}, found {}\", expected, self.this_token_descr());\n+        let msg = format!(\"expected {}, found {}\", expected, super::token_descr(&self.token));\n \n         let mut err = self.fatal(&msg);\n         err.span_label(self.token.span, format!(\"expected {}\", expected));\n@@ -875,7 +875,7 @@ impl<'a> Parser<'a> {\n                     etc_span = Some(etc_sp);\n                     break;\n                 }\n-                let token_str = self.this_token_descr();\n+                let token_str = super::token_descr(&self.token);\n                 let mut err = self.fatal(&format!(\"expected `}}`, found {}\", token_str));\n \n                 err.span_label(self.token.span, \"expected `}`\");"}, {"sha": "8270da6c0234f8f17fe4ce9a07452a7b4adf954b", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=8456c403e1e79220d898b29074ce41dfeb752b08", "patch": "@@ -323,7 +323,7 @@ impl<'a> Parser<'a> {\n \n     fn error_block_no_opening_brace<T>(&mut self) -> PResult<'a, T> {\n         let sp = self.token.span;\n-        let tok = self.this_token_descr();\n+        let tok = super::token_descr(&self.token);\n         let mut e = self.span_fatal(sp, &format!(\"expected `{{`, found {}\", tok));\n         let do_not_suggest_help = self.token.is_keyword(kw::In) || self.token == token::Colon;\n \n@@ -463,7 +463,7 @@ impl<'a> Parser<'a> {\n     fn warn_missing_semicolon(&self) {\n         self.diagnostic()\n             .struct_span_warn(self.token.span, {\n-                &format!(\"expected `;`, found {}\", self.this_token_descr())\n+                &format!(\"expected `;`, found {}\", super::token_descr(&self.token))\n             })\n             .note({\n                 \"this was erroneously allowed and will become a hard error in a future release\""}, {"sha": "049c077c3cea338abd50624d701bec86f8cebe76", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=8456c403e1e79220d898b29074ce41dfeb752b08", "patch": "@@ -135,7 +135,7 @@ impl<'a> Parser<'a> {\n                 TyKind::Err\n             }\n         } else {\n-            let msg = format!(\"expected type, found {}\", self.this_token_descr());\n+            let msg = format!(\"expected type, found {}\", super::token_descr(&self.token));\n             let mut err = self.struct_span_err(self.token.span, &msg);\n             err.span_label(self.token.span, \"expected type\");\n             self.maybe_annotate_with_ascription(&mut err, true);"}, {"sha": "4df51ff41f3f6441b8614eee2bff7d8821de8853", "filename": "src/libsyntax_expand/expand.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibsyntax_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibsyntax_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fexpand.rs?ref=8456c403e1e79220d898b29074ce41dfeb752b08", "patch": "@@ -904,10 +904,8 @@ pub fn ensure_complete_parse<'a>(\n     span: Span,\n ) {\n     if this.token != token::Eof {\n-        let msg = format!(\n-            \"macro expansion ignores token `{}` and any following\",\n-            this.this_token_to_string()\n-        );\n+        let token = pprust::token_to_string(&this.token);\n+        let msg = format!(\"macro expansion ignores token `{}` and any following\", token);\n         // Avoid emitting backtrace info twice.\n         let def_site_span = this.token.span.with_ctxt(SyntaxContext::root());\n         let mut err = this.struct_span_err(def_site_span, &msg);"}, {"sha": "fccc36e2ea8093a36601c87ed29fe7edaf763ef7", "filename": "src/libsyntax_ext/source_util.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibsyntax_ext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8456c403e1e79220d898b29074ce41dfeb752b08/src%2Flibsyntax_ext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fsource_util.rs?ref=8456c403e1e79220d898b29074ce41dfeb752b08", "patch": "@@ -133,15 +133,17 @@ pub fn expand_include<'cx>(\n             while self.p.token != token::Eof {\n                 match panictry!(self.p.parse_item()) {\n                     Some(item) => ret.push(item),\n-                    None => self\n-                        .p\n-                        .sess\n-                        .span_diagnostic\n-                        .span_fatal(\n-                            self.p.token.span,\n-                            &format!(\"expected item, found `{}`\", self.p.this_token_to_string()),\n-                        )\n-                        .raise(),\n+                    None => {\n+                        let token = pprust::token_to_string(&self.p.token);\n+                        self.p\n+                            .sess\n+                            .span_diagnostic\n+                            .span_fatal(\n+                                self.p.token.span,\n+                                &format!(\"expected item, found `{}`\", token),\n+                            )\n+                            .raise();\n+                    }\n                 }\n             }\n             Some(ret)"}]}