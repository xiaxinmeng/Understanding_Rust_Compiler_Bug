{"sha": "efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYjllZTJkZjVhOTlhMDVlNmY4MGFlMWFkNjgwMTljOGZhNzcxMDc=", "commit": {"author": {"name": "Joshua Nelson", "email": "joshua@yottadb.com", "date": "2021-03-01T16:25:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-01T16:25:07Z"}, "message": "Rollup merge of #82578 - camsteffen:diag-items, r=oli-obk\n\nAdd some diagnostic items for Clippy", "tree": {"sha": "5943d2ebde54000d6446a08d0cd1ddc0b76aba86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5943d2ebde54000d6446a08d0cd1ddc0b76aba86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgPRVkCRBK7hj4Ov3rIwAAdHIIAB/gRbFXRMoPoYiDdLTmBp6u\nobYPPKVff+HkleFxkClPFFlvMBu9XGFcwAT/XeyO4i7ezNYDzGEI3LN5wWE5PW+M\nNeclIMakwG+BEJWAHZeaeKXxxq2mVHYJuMT9+Vs9dKxHpcc1akMgfOgQN9SLHlre\nq6PAhQhtBH759KzZY6H6TMWLM27weIlBZMs9EhiAnYtcovgCJbZtU6jLgPJu0Ll+\nK8Wh9RMkVGRlcUEyS0ohXbCj6mJs9FhDzVkMnhfhUj72ZEazWk8YoCYjOuq+0A6E\nbXNqTHEliV0JrzGUtulNPDmlJqFv966TD+MpZwTw9ad6O1K8AJYoID4l+yfFJQA=\n=xKAl\n-----END PGP SIGNATURE-----\n", "payload": "tree 5943d2ebde54000d6446a08d0cd1ddc0b76aba86\nparent 4f14f174859da3394f2014a4dcab59446c77b008\nparent 6a3b834b39e0d6418e96cd7e3abd8043afd89d1c\nauthor Joshua Nelson <joshua@yottadb.com> 1614615907 -0500\ncommitter GitHub <noreply@github.com> 1614615907 -0500\n\nRollup merge of #82578 - camsteffen:diag-items, r=oli-obk\n\nAdd some diagnostic items for Clippy\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "html_url": "https://github.com/rust-lang/rust/commit/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/comments", "author": null, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f14f174859da3394f2014a4dcab59446c77b008", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f14f174859da3394f2014a4dcab59446c77b008", "html_url": "https://github.com/rust-lang/rust/commit/4f14f174859da3394f2014a4dcab59446c77b008"}, {"sha": "6a3b834b39e0d6418e96cd7e3abd8043afd89d1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a3b834b39e0d6418e96cd7e3abd8043afd89d1c", "html_url": "https://github.com/rust-lang/rust/commit/6a3b834b39e0d6418e96cd7e3abd8043afd89d1c"}], "stats": {"total": 96, "additions": 55, "deletions": 41}, "files": [{"sha": "f87267da9f6c7dfe4df46498f9b3edb6b7e9e059", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "patch": "@@ -126,6 +126,9 @@ symbols! {\n         Argument,\n         ArgumentV1,\n         Arguments,\n+        BTreeMap,\n+        BTreeSet,\n+        BinaryHeap,\n         C,\n         CString,\n         Center,\n@@ -163,6 +166,7 @@ symbols! {\n         Iterator,\n         Layout,\n         Left,\n+        LinkedList,\n         LintPass,\n         None,\n         Ok,\n@@ -191,6 +195,7 @@ symbols! {\n         RangeToInclusive,\n         Rc,\n         Ready,\n+        Receiver,\n         Result,\n         Return,\n         Right,\n@@ -592,6 +597,8 @@ symbols! {\n         gt,\n         half_open_range_patterns,\n         hash,\n+        hashmap_type,\n+        hashset_type,\n         hexagon_target_feature,\n         hidden,\n         homogeneous_aggregate,\n@@ -1256,6 +1263,7 @@ symbols! {\n         variant_count,\n         vec,\n         vec_type,\n+        vecdeque_type,\n         version,\n         vis,\n         visible_private_types,"}, {"sha": "4377780e15f4590fb58331e02991730e30ddf4ba", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "patch": "@@ -247,6 +247,7 @@ use super::SpecExtend;\n /// [peek]: BinaryHeap::peek\n /// [peek\\_mut]: BinaryHeap::peek_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"BinaryHeap\")]\n pub struct BinaryHeap<T> {\n     data: Vec<T>,\n }"}, {"sha": "783f88f026b8fe1346e67111acd80f4da44a8b51", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "patch": "@@ -138,6 +138,7 @@ pub(super) const MIN_LEN: usize = node::MIN_LEN_AFTER_SPLIT;\n /// *stat += random_stat_buff();\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"BTreeMap\")]\n pub struct BTreeMap<K, V> {\n     root: Option<Root<K, V>>,\n     length: usize,"}, {"sha": "a331b8d8e4bbbe5e87009de2ee5bf539827449f0", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "patch": "@@ -61,6 +61,7 @@ use super::Recover;\n /// ```\n #[derive(Hash, PartialEq, Eq, Ord, PartialOrd)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"BTreeSet\")]\n pub struct BTreeSet<T> {\n     map: BTreeMap<T, ()>,\n }"}, {"sha": "a5481fd175e307cb5e86deb9c0bc00bd974af6b4", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "patch": "@@ -35,6 +35,7 @@ mod tests;\n /// array-based containers are generally faster,\n /// more memory efficient, and make better use of CPU cache.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"LinkedList\")]\n pub struct LinkedList<T> {\n     head: Option<NonNull<Node<T>>>,\n     tail: Option<NonNull<Node<T>>>,"}, {"sha": "b12e7eeb13814e8472113e2ced9a80bb0cad7975", "filename": "library/std/src/sync/mpsc/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs?ref=efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "patch": "@@ -310,6 +310,7 @@ mod cache_aligned;\n /// println!(\"{}\", recv.recv().unwrap()); // Received after 2 seconds\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"Receiver\")]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n }"}, {"sha": "55575969927ba891e35cb2faebb9302622f26df6", "filename": "src/tools/clippy/clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fentry.rs?ref=efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "patch": "@@ -9,6 +9,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for uses of `contains_key` + `insert` on `HashMap`\n@@ -111,7 +112,7 @@ fn check_cond<'a>(cx: &LateContext<'_>, check: &'a Expr<'a>) -> Option<(&'static\n             return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n                 Some((\"BTreeMap\", map, key))\n             }\n-            else if is_type_diagnostic_item(cx, obj_ty, sym!(hashmap_type)) {\n+            else if is_type_diagnostic_item(cx, obj_ty, sym::hashmap_type) {\n                 Some((\"HashMap\", map, key))\n             }\n             else {"}, {"sha": "63d9b7f8645978aa349996cd99f9d9d1c9d3c185", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "patch": "@@ -1010,7 +1010,7 @@ fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n         _ => false,\n     };\n \n-    is_slice || is_type_diagnostic_item(cx, ty, sym::vec_type) || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n+    is_slice || is_type_diagnostic_item(cx, ty, sym::vec_type) || is_type_diagnostic_item(cx, ty, sym::vecdeque_type)\n }\n \n fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n@@ -1908,7 +1908,7 @@ fn check_for_loop_over_map_kv<'tcx>(\n                 _ => arg,\n             };\n \n-            if is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) || match_type(cx, ty, &paths::BTREEMAP) {\n+            if is_type_diagnostic_item(cx, ty, sym::hashmap_type) || match_type(cx, ty, &paths::BTREEMAP) {\n                 span_lint_and_then(\n                     cx,\n                     FOR_KV_MAP,\n@@ -2386,9 +2386,9 @@ fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n     is_iterable_array(ty, cx) ||\n     is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n     match_type(cx, ty, &paths::LINKED_LIST) ||\n-    is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) ||\n-    is_type_diagnostic_item(cx, ty, sym!(hashset_type)) ||\n-    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+    is_type_diagnostic_item(cx, ty, sym::hashmap_type) ||\n+    is_type_diagnostic_item(cx, ty, sym::hashset_type) ||\n+    is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n     match_type(cx, ty, &paths::BINARY_HEAP) ||\n     match_type(cx, ty, &paths::BTREEMAP) ||\n     match_type(cx, ty, &paths::BTREESET)\n@@ -2922,9 +2922,9 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n         then {\n             let ty = cx.typeck_results().node_type(ty.hir_id);\n             if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n-                is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+                is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n                 match_type(cx, ty, &paths::BTREEMAP) ||\n-                is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) {\n+                is_type_diagnostic_item(cx, ty, sym::hashmap_type) {\n                 if method.ident.name == sym!(len) {\n                     let span = shorten_needless_collect_span(expr);\n                     span_lint_and_sugg(\n@@ -2992,7 +2992,7 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                 if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n                 if let ty = cx.typeck_results().node_type(ty.hir_id);\n                 if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n-                    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+                    is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n                     match_type(cx, ty, &paths::LINKED_LIST);\n                 if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n                 if iter_calls.len() == 1;"}, {"sha": "5163074453b5fafdf5f9f03f7c97cafbec66633c", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "patch": "@@ -24,7 +24,7 @@ use rustc_middle::ty::{self, TraitRef, Ty, TyS};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::{sym, SymbolStr};\n+use rustc_span::symbol::{sym, Symbol, SymbolStr};\n use rustc_typeck::hir_ty_to_ty;\n \n use crate::consts::{constant, Constant};\n@@ -2598,7 +2598,7 @@ fn lint_iter_nth<'tcx>(\n         \"slice\"\n     } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym::vec_type) {\n         \"Vec\"\n-    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym!(vecdeque_type)) {\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym::vecdeque_type) {\n         \"VecDeque\"\n     } else {\n         let nth_args = nth_and_iter_args[0];\n@@ -2652,10 +2652,10 @@ fn lint_get_unwrap<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args:\n     } else if is_type_diagnostic_item(cx, expr_ty, sym::vec_type) {\n         needs_ref = get_args_str.parse::<usize>().is_ok();\n         \"Vec\"\n-    } else if is_type_diagnostic_item(cx, expr_ty, sym!(vecdeque_type)) {\n+    } else if is_type_diagnostic_item(cx, expr_ty, sym::vecdeque_type) {\n         needs_ref = get_args_str.parse::<usize>().is_ok();\n         \"VecDeque\"\n-    } else if !is_mut && is_type_diagnostic_item(cx, expr_ty, sym!(hashmap_type)) {\n+    } else if !is_mut && is_type_diagnostic_item(cx, expr_ty, sym::hashmap_type) {\n         needs_ref = true;\n         \"HashMap\"\n     } else if !is_mut && match_type(cx, expr_ty, &paths::BTREEMAP) {\n@@ -3619,7 +3619,7 @@ fn lint_asref(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_re\n     }\n }\n \n-fn ty_has_iter_method(cx: &LateContext<'_>, self_ref_ty: Ty<'_>) -> Option<(&'static str, &'static str)> {\n+fn ty_has_iter_method(cx: &LateContext<'_>, self_ref_ty: Ty<'_>) -> Option<(Symbol, &'static str)> {\n     has_iter_method(cx, self_ref_ty).map(|ty_name| {\n         let mutbl = match self_ref_ty.kind() {\n             ty::Ref(_, _, mutbl) => mutbl,"}, {"sha": "9d8a0c248334f582af850002b48f112be4447374", "filename": "src/tools/clippy/clippy_lints/src/swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs?ref=efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "patch": "@@ -199,7 +199,7 @@ fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<\n                 if matches!(ty.kind(), ty::Slice(_))\n                     || matches!(ty.kind(), ty::Array(_, _))\n                     || is_type_diagnostic_item(cx, ty, sym::vec_type)\n-                    || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n+                    || is_type_diagnostic_item(cx, ty, sym::vecdeque_type)\n                 {\n                     return Slice::Swappable(lhs1, idx1, idx2);\n                 }"}, {"sha": "eb2016db3dc2c5557f9affb75fbabee6fc776860", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "patch": "@@ -2680,14 +2680,14 @@ impl<'tcx> ImplicitHasherType<'tcx> {\n \n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n \n-            if is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) && params_len == 2 {\n+            if is_type_diagnostic_item(cx, ty, sym::hashmap_type) && params_len == 2 {\n                 Some(ImplicitHasherType::HashMap(\n                     hir_ty.span,\n                     ty,\n                     snippet(cx, params[0].span, \"K\"),\n                     snippet(cx, params[1].span, \"V\"),\n                 ))\n-            } else if is_type_diagnostic_item(cx, ty, sym!(hashset_type)) && params_len == 1 {\n+            } else if is_type_diagnostic_item(cx, ty, sym::hashset_type) && params_len == 1 {\n                 Some(ImplicitHasherType::HashSet(\n                     hir_ty.span,\n                     ty,"}, {"sha": "316b8d820a715adb298edc2b847f8efcfe55cdba", "filename": "src/tools/clippy/clippy_lints/src/zero_sized_map_values.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs?ref=efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "patch": "@@ -5,6 +5,7 @@ use rustc_middle::ty::{Adt, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_target::abi::LayoutOf as _;\n use rustc_typeck::hir_ty_to_ty;\n+use rustc_span::sym;\n \n use crate::utils::{is_normalizable, is_type_diagnostic_item, match_type, paths, span_lint_and_help};\n \n@@ -47,7 +48,7 @@ impl LateLintPass<'_> for ZeroSizedMapValues {\n             if !hir_ty.span.from_expansion();\n             if !in_trait_impl(cx, hir_ty.hir_id);\n             let ty = ty_from_hir_ty(cx, hir_ty);\n-            if is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) || match_type(cx, ty, &paths::BTREEMAP);\n+            if is_type_diagnostic_item(cx, ty, sym::hashmap_type) || match_type(cx, ty, &paths::BTREEMAP);\n             if let Adt(_, ref substs) = ty.kind();\n             let ty = substs.type_at(1);\n             // Do this to prevent `layout_of` crashing, being unable to fully normalize `ty`."}, {"sha": "81cd99c0558dce7f8f149eab452c72562d06d147", "filename": "src/tools/clippy/clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "patch": "@@ -18,6 +18,7 @@ use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::{Block, Expr, ExprKind, Path, QPath};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n+use rustc_span::sym;\n \n /// Is the expr pure (is it free from side-effects)?\n /// This function is named so to stress that it isn't exhaustive and returns FNs.\n@@ -99,7 +100,7 @@ fn identify_some_potentially_expensive_patterns<'tcx>(cx: &LateContext<'tcx>, ex\n                 ExprKind::Call(..) => !is_ctor_or_promotable_const_function(self.cx, expr),\n                 ExprKind::Index(obj, _) => {\n                     let ty = self.cx.typeck_results().expr_ty(obj);\n-                    is_type_diagnostic_item(self.cx, ty, sym!(hashmap_type))\n+                    is_type_diagnostic_item(self.cx, ty, sym::hashmap_type)\n                         || match_type(self.cx, ty, &paths::BTREEMAP)\n                 },\n                 ExprKind::MethodCall(..) => true,"}, {"sha": "42512cadfb18dfcebb026ef7cc17559dd748a43e", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "patch": "@@ -1295,24 +1295,24 @@ pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_>, node: HirId) -> bool\n }\n \n /// Returns true if ty has `iter` or `iter_mut` methods\n-pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<&'static str> {\n+pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<Symbol> {\n     // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n     // exists and has the desired signature. Unfortunately FnCtxt is not exported\n     // so we can't use its `lookup_method` method.\n-    let into_iter_collections: [&[&str]; 13] = [\n-        &paths::VEC,\n-        &paths::OPTION,\n-        &paths::RESULT,\n-        &paths::BTREESET,\n-        &paths::BTREEMAP,\n-        &paths::VEC_DEQUE,\n-        &paths::LINKED_LIST,\n-        &paths::BINARY_HEAP,\n-        &paths::HASHSET,\n-        &paths::HASHMAP,\n-        &paths::PATH_BUF,\n-        &paths::PATH,\n-        &paths::RECEIVER,\n+    let into_iter_collections: &[Symbol] = &[\n+        sym::vec_type,\n+        sym::option_type,\n+        sym::result_type,\n+        sym::BTreeMap,\n+        sym::BTreeSet,\n+        sym::vecdeque_type,\n+        sym::LinkedList,\n+        sym::BinaryHeap,\n+        sym::hashset_type,\n+        sym::hashmap_type,\n+        sym::PathBuf,\n+        sym::Path,\n+        sym::Receiver,\n     ];\n \n     let ty_to_check = match probably_ref_ty.kind() {\n@@ -1321,15 +1321,15 @@ pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<\n     };\n \n     let def_id = match ty_to_check.kind() {\n-        ty::Array(..) => return Some(\"array\"),\n-        ty::Slice(..) => return Some(\"slice\"),\n+        ty::Array(..) => return Some(sym::array),\n+        ty::Slice(..) => return Some(sym::slice),\n         ty::Adt(adt, _) => adt.did,\n         _ => return None,\n     };\n \n-    for path in &into_iter_collections {\n-        if match_def_path(cx, def_id, path) {\n-            return Some(*path.last().unwrap());\n+    for &name in into_iter_collections {\n+        if cx.tcx.is_diagnostic_item(name, def_id) {\n+            return Some(cx.tcx.item_name(def_id));\n         }\n     }\n     None"}, {"sha": "c2da1f9b7c9f9360c1d15be3e237302d376e82a7", "filename": "src/tools/clippy/clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb9ee2df5a99a05e6f80ae1ad68019c8fa77107/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs?ref=efb9ee2df5a99a05e6f80ae1ad68019c8fa77107", "patch": "@@ -99,7 +99,6 @@ pub(super) const PANIC_ANY: [&str; 3] = [\"std\", \"panic\", \"panic_any\"];\n pub const PARKING_LOT_MUTEX_GUARD: [&str; 2] = [\"parking_lot\", \"MutexGuard\"];\n pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockReadGuard\"];\n pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockWriteGuard\"];\n-pub const PATH: [&str; 3] = [\"std\", \"path\", \"Path\"];\n pub const PATH_BUF: [&str; 3] = [\"std\", \"path\", \"PathBuf\"];\n pub const PATH_BUF_AS_PATH: [&str; 4] = [\"std\", \"path\", \"PathBuf\", \"as_path\"];\n pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n@@ -116,7 +115,6 @@ pub const PUSH_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"push_str\"];\n pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];\n-pub const RECEIVER: [&str; 4] = [\"std\", \"sync\", \"mpsc\", \"Receiver\"];\n pub const REFCELL_REF: [&str; 3] = [\"core\", \"cell\", \"Ref\"];\n pub const REFCELL_REFMUT: [&str; 3] = [\"core\", \"cell\", \"RefMut\"];\n pub const REGEX_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"unicode\", \"RegexBuilder\", \"new\"];"}]}