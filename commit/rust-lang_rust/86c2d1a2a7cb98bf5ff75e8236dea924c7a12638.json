{"sha": "86c2d1a2a7cb98bf5ff75e8236dea924c7a12638", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2YzJkMWEyYTdjYjk4YmY1ZmY3NWU4MjM2ZGVhOTI0YzdhMTI2Mzg=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-06-01T08:47:39Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-06-08T17:24:17Z"}, "message": "Don't use a generator for BoxedResolver\n\nThe generator is non-trivial and requires unsafe code anyway. Using\nregular unsafe code without a generator is much easier to follow.", "tree": {"sha": "e37916142c9a3ceeff6fcbe1bd8cb13e459d037c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e37916142c9a3ceeff6fcbe1bd8cb13e459d037c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86c2d1a2a7cb98bf5ff75e8236dea924c7a12638", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86c2d1a2a7cb98bf5ff75e8236dea924c7a12638", "html_url": "https://github.com/rust-lang/rust/commit/86c2d1a2a7cb98bf5ff75e8236dea924c7a12638", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86c2d1a2a7cb98bf5ff75e8236dea924c7a12638/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36bdfdc411c5d1fc6c83498f406f2191273e0833", "url": "https://api.github.com/repos/rust-lang/rust/commits/36bdfdc411c5d1fc6c83498f406f2191273e0833", "html_url": "https://github.com/rust-lang/rust/commit/36bdfdc411c5d1fc6c83498f406f2191273e0833"}], "stats": {"total": 167, "additions": 48, "deletions": 119}, "files": [{"sha": "c7424b9e2a120560a39c506abd23157056f73470", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86c2d1a2a7cb98bf5ff75e8236dea924c7a12638/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c2d1a2a7cb98bf5ff75e8236dea924c7a12638/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=86c2d1a2a7cb98bf5ff75e8236dea924c7a12638", "patch": "@@ -2,8 +2,6 @@\n #![feature(box_patterns)]\n #![feature(internal_output_capture)]\n #![feature(nll)]\n-#![feature(generator_trait)]\n-#![feature(generators)]\n #![feature(once_cell)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "19fa5043295d3053a94b35ad4ea4e205f499afe7", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 48, "deletions": 117, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/86c2d1a2a7cb98bf5ff75e8236dea924c7a12638/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c2d1a2a7cb98bf5ff75e8236dea924c7a12638/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=86c2d1a2a7cb98bf5ff75e8236dea924c7a12638", "patch": "@@ -46,8 +46,7 @@ use std::cell::RefCell;\n use std::ffi::OsString;\n use std::io::{self, BufWriter, Write};\n use std::lazy::SyncLazy;\n-use std::marker::PhantomData;\n-use std::ops::{Generator, GeneratorState};\n+use std::marker::PhantomPinned;\n use std::path::PathBuf;\n use std::pin::Pin;\n use std::rc::Rc;\n@@ -87,99 +86,64 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n     counter.count\n }\n \n-pub struct AccessAction(*mut dyn for<'a> FnMut(&mut Resolver<'a>));\n-\n-impl AccessAction {\n-    pub fn get(self) -> *mut dyn for<'a> FnMut(&mut Resolver<'a>) {\n-        self.0\n-    }\n-}\n-\n-pub enum Action {\n-    Initial,\n-    Access(AccessAction),\n-    Complete,\n-}\n-\n-#[derive(PartialEq)]\n-struct Marker<T>(PhantomData<T>);\n-\n-impl<T> Marker<T> {\n-    unsafe fn new() -> Self {\n-        Marker(PhantomData)\n-    }\n-}\n-\n-enum YieldType<I, A> {\n-    Initial(I),\n-    Accessor(Marker<A>),\n-}\n-\n-pub struct BoxedResolver {\n-    generator: Pin<\n-        Box<\n-            dyn Generator<\n-                Action,\n-                Yield = YieldType<Result<ast::Crate>, for<'a> fn(&mut Resolver<'a>)>,\n-                Return = ResolverOutputs,\n-            >,\n-        >,\n-    >,\n+pub struct BoxedResolver(Pin<Box<BoxedResolverInner>>);\n+\n+// Note: Drop order is important to prevent dangling references. Resolver must be dropped first,\n+// then resolver_arenas and finally session.\n+// The drop order is defined to be from top to bottom in RFC1857, so there is no need for\n+// ManuallyDrop for as long as the fields are not reordered.\n+struct BoxedResolverInner {\n+    resolver: Option<Resolver<'static>>,\n+    resolver_arenas: ResolverArenas<'static>,\n+    session: Lrc<Session>,\n+    _pin: PhantomPinned,\n }\n \n impl BoxedResolver {\n-    fn new<T>(generator: T) -> Result<(ast::Crate, Self)>\n+    fn new<F>(session: Lrc<Session>, make_resolver: F) -> Result<(ast::Crate, Self)>\n     where\n-        T: ::std::ops::Generator<\n-                Action,\n-                Yield = YieldType<Result<ast::Crate>, fn(&mut Resolver<'_>)>,\n-                Return = ResolverOutputs,\n-            > + 'static,\n+        F: for<'a> FnOnce(\n+            &'a Session,\n+            &'a ResolverArenas<'a>,\n+        ) -> Result<(ast::Crate, Resolver<'a>)>,\n     {\n-        let mut generator = Box::pin(generator);\n-\n-        // Run it to the first yield to set it up\n-        let init = match generator.as_mut().resume(Action::Initial) {\n-            GeneratorState::Yielded(YieldType::Initial(y)) => y,\n-            _ => panic!(),\n-        };\n-\n-        init.map(|init| (init, BoxedResolver { generator }))\n+        let mut boxed_resolver = Box::new(BoxedResolverInner {\n+            session,\n+            resolver_arenas: Resolver::arenas(),\n+            resolver: None,\n+            _pin: PhantomPinned,\n+        });\n+        unsafe {\n+            let (crate_, resolver) = make_resolver(\n+                std::mem::transmute::<&Session, &Session>(&boxed_resolver.session),\n+                std::mem::transmute::<&ResolverArenas<'_>, &ResolverArenas<'_>>(\n+                    &boxed_resolver.resolver_arenas,\n+                ),\n+            )?;\n+            boxed_resolver.resolver =\n+                Some(std::mem::transmute::<Resolver<'_>, Resolver<'_>>(resolver));\n+            Ok((crate_, BoxedResolver(Pin::new_unchecked(boxed_resolver))))\n+        }\n     }\n \n     pub fn access<F: for<'a> FnOnce(&mut Resolver<'a>) -> R, R>(&mut self, f: F) -> R {\n-        // Turn the FnOnce closure into *mut dyn FnMut()\n-        // so we can pass it in to the generator\n-        let mut r = None;\n-        let mut f = Some(f);\n-        let mut_f: &mut dyn for<'a> FnMut(&mut Resolver<'a>) = &mut |resolver| {\n-            let f = f.take().unwrap();\n-            r = Some(f(resolver));\n+        let mut resolver = unsafe {\n+            self.0.as_mut().map_unchecked_mut(|boxed_resolver| &mut boxed_resolver.resolver)\n         };\n-        let mut_f = mut_f as *mut dyn for<'a> FnMut(&mut Resolver<'a>);\n-\n-        // Get the generator to call our closure\n-        unsafe {\n-            // Call the generator, which in turn will call the closure\n-            if let GeneratorState::Complete(_) = self\n-                .generator\n-                .as_mut()\n-                .resume(Action::Access(AccessAction(::std::mem::transmute(mut_f))))\n-            {\n-                panic!()\n-            }\n-        }\n-\n-        // Unwrap the result\n-        r.unwrap()\n+        f((&mut *resolver).as_mut().unwrap())\n     }\n \n     pub fn to_resolver_outputs(resolver: Rc<RefCell<BoxedResolver>>) -> ResolverOutputs {\n         match Rc::try_unwrap(resolver) {\n             Ok(resolver) => {\n-                // Tell the generator we want it to complete, consuming it and yielding a result\n-                let result = resolver.into_inner().generator.as_mut().resume(Action::Complete);\n-                if let GeneratorState::Complete(r) = result { r } else { panic!() }\n+                let mut resolver = resolver.into_inner();\n+                let mut resolver = unsafe {\n+                    resolver\n+                        .0\n+                        .as_mut()\n+                        .map_unchecked_mut(|boxed_resolver| &mut boxed_resolver.resolver)\n+                };\n+                resolver.take().unwrap().into_outputs()\n             }\n             Err(resolver) => resolver.borrow_mut().access(|resolver| resolver.clone_outputs()),\n         }\n@@ -206,48 +170,15 @@ pub fn configure_and_expand(\n     // its contents but the results of name resolution on those contents. Hopefully we'll push\n     // this back at some point.\n     let crate_name = crate_name.to_string();\n-    BoxedResolver::new(static move |mut action| {\n-        let _ = action;\n-        let sess = &*sess;\n-        let resolver_arenas = Resolver::arenas();\n-        let res = configure_and_expand_inner(\n+    BoxedResolver::new(sess, move |sess, resolver_arenas| {\n+        configure_and_expand_inner(\n             sess,\n             &lint_store,\n             krate,\n             &crate_name,\n             &resolver_arenas,\n             metadata_loader,\n-        );\n-        let mut resolver = match res {\n-            Err(v) => {\n-                yield YieldType::Initial(Err(v));\n-                panic!()\n-            }\n-            Ok((krate, resolver)) => {\n-                action = yield YieldType::Initial(Ok(krate));\n-                resolver\n-            }\n-        };\n-\n-        loop {\n-            match action {\n-                Action::Access(accessor) => {\n-                    let accessor: &mut dyn FnMut(&mut Resolver<'_>) =\n-                        unsafe { ::std::mem::transmute(accessor.get()) };\n-                    (*accessor)(&mut resolver);\n-                    unsafe {\n-                        let marker = Marker::<fn(&mut Resolver<'_>)>::new();\n-                        action = yield YieldType::Accessor(marker);\n-                    };\n-                }\n-                Action::Complete => break,\n-                Action::Initial => {\n-                    panic!(\"unexpected box_region action: Initial\")\n-                }\n-            }\n-        }\n-\n-        resolver.into_outputs()\n+        )\n     })\n }\n "}]}