{"sha": "d4684182096326ccc57ea70bdb080c95607ff238", "node_id": "C_kwDOAAsO6NoAKGQ0Njg0MTgyMDk2MzI2Y2NjNTdlYTcwYmRiMDgwYzk1NjA3ZmYyMzg", "commit": {"author": {"name": "Muhammad Falak R Wani", "email": "falakreyaz@gmail.com", "date": "2021-11-01T06:32:01Z"}, "committer": {"name": "Muhammad Falak R Wani", "email": "falakreyaz@gmail.com", "date": "2021-11-05T02:14:05Z"}, "message": "rustdoc: use Type::def_id() instead of Type::def_id_no_primitives()\n\nSigned-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>", "tree": {"sha": "047a3527c4f2ad4c5f340bade24f9d2fb6890f5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/047a3527c4f2ad4c5f340bade24f9d2fb6890f5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4684182096326ccc57ea70bdb080c95607ff238", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEUur4WEwOm1FAXKgN0yOl4BdMht0FAmGEk20ACgkQ0yOl4BdM\nht0oqBAAjUwXLBn0XBXtwCWlS0Nx69TpaOWoZmfSRyvvBR0Dzy+RlKJGKcTFBOTQ\nwRFxHkfdkzEl367yfTK9qLLx0623BN+9L2A7M0JC8VUZoPFY4mXwPKvPbmGMaSaj\ncdavqguYiH0bG1mofeAO0u7vSuRlWvWFY+JY/X1ujCoEdfwR3yBksB3Yy2ha2fjC\nnFCa7g8MCgG3nOWA7RmuBmELyOUGL8If8tuJfisv3k8lsiF6OU2O2eYuYXqMAKg/\na3anp6u3icbL/xu/1JuwDArgDmHaV2MktuBhVTIVTbbrKTzRqZK+N+SKOz02oYRt\nKXh8ZSkLQz2udHxE4MSwOOLqtz2olcO3f/Y9Tg6NzjMAm1NSHKzhsHg7el8OqeKO\neRB6lvsqqu6BHi3wIt8FHICc16gZO8Z640o7yyWHwSEDv4qfkpyrp1P3g5lJZhc+\n/5AyvOeqRW9JR+aMLtZhm65pnM35LWXDelix2utZYEtrO9oBNttBdOEGFWb/5kgt\nyuzZzao9psXkIR6WKqWtYwFftnj87cRO64v0G4KHMfh/kGWRe5DL48ybyCpbZSPJ\noL44p82fJ2obHFEqu/E7G7Fi471BzUNSt9vVcjScVnyFeEO+ODsY+8TSPvfNroqK\ngnoBj/SkIvkT+HP2tVgph8RERsj2iQ4naX3yhH4ygBTHKQYoIIs=\n=2wSU\n-----END PGP SIGNATURE-----", "payload": "tree 047a3527c4f2ad4c5f340bade24f9d2fb6890f5b\nparent 2cff30b17a5409e15134f8634444069fc6f21cb6\nauthor Muhammad Falak R Wani <falakreyaz@gmail.com> 1635748321 +0530\ncommitter Muhammad Falak R Wani <falakreyaz@gmail.com> 1636078445 +0530\n\nrustdoc: use Type::def_id() instead of Type::def_id_no_primitives()\n\nSigned-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4684182096326ccc57ea70bdb080c95607ff238", "html_url": "https://github.com/rust-lang/rust/commit/d4684182096326ccc57ea70bdb080c95607ff238", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4684182096326ccc57ea70bdb080c95607ff238/comments", "author": {"login": "mfrw", "id": 4929861, "node_id": "MDQ6VXNlcjQ5Mjk4NjE=", "avatar_url": "https://avatars.githubusercontent.com/u/4929861?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mfrw", "html_url": "https://github.com/mfrw", "followers_url": "https://api.github.com/users/mfrw/followers", "following_url": "https://api.github.com/users/mfrw/following{/other_user}", "gists_url": "https://api.github.com/users/mfrw/gists{/gist_id}", "starred_url": "https://api.github.com/users/mfrw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mfrw/subscriptions", "organizations_url": "https://api.github.com/users/mfrw/orgs", "repos_url": "https://api.github.com/users/mfrw/repos", "events_url": "https://api.github.com/users/mfrw/events{/privacy}", "received_events_url": "https://api.github.com/users/mfrw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mfrw", "id": 4929861, "node_id": "MDQ6VXNlcjQ5Mjk4NjE=", "avatar_url": "https://avatars.githubusercontent.com/u/4929861?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mfrw", "html_url": "https://github.com/mfrw", "followers_url": "https://api.github.com/users/mfrw/followers", "following_url": "https://api.github.com/users/mfrw/following{/other_user}", "gists_url": "https://api.github.com/users/mfrw/gists{/gist_id}", "starred_url": "https://api.github.com/users/mfrw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mfrw/subscriptions", "organizations_url": "https://api.github.com/users/mfrw/orgs", "repos_url": "https://api.github.com/users/mfrw/repos", "events_url": "https://api.github.com/users/mfrw/events{/privacy}", "received_events_url": "https://api.github.com/users/mfrw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cff30b17a5409e15134f8634444069fc6f21cb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cff30b17a5409e15134f8634444069fc6f21cb6", "html_url": "https://github.com/rust-lang/rust/commit/2cff30b17a5409e15134f8634444069fc6f21cb6"}], "stats": {"total": 59, "additions": 33, "deletions": 26}, "files": [{"sha": "1e951a89023f6195845e556ef344871155420e1b", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4684182096326ccc57ea70bdb080c95607ff238/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4684182096326ccc57ea70bdb080c95607ff238/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=d4684182096326ccc57ea70bdb080c95607ff238", "patch": "@@ -303,7 +303,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                             desc,\n                             parent,\n                             parent_idx: None,\n-                            search_type: get_index_search_type(&item, self.tcx),\n+                            search_type: get_index_search_type(&item, self.tcx, self.cache),\n                             aliases: item.attrs.get_doc_aliases(),\n                         });\n                     }"}, {"sha": "a4a43cba4e69c104184eecc4a377ca3ca6e77674", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d4684182096326ccc57ea70bdb080c95607ff238/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4684182096326ccc57ea70bdb080c95607ff238/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=d4684182096326ccc57ea70bdb080c95607ff238", "patch": "@@ -43,7 +43,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n                 desc,\n                 parent: Some(did),\n                 parent_idx: None,\n-                search_type: get_index_search_type(item, tcx),\n+                search_type: get_index_search_type(item, tcx, cache),\n                 aliases: item.attrs.get_doc_aliases(),\n             });\n         }\n@@ -191,11 +191,12 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n crate fn get_index_search_type<'tcx>(\n     item: &clean::Item,\n     tcx: TyCtxt<'tcx>,\n+    cache: &Cache,\n ) -> Option<IndexItemFunctionType> {\n     let (mut inputs, mut output) = match *item.kind {\n-        clean::FunctionItem(ref f) => get_all_types(&f.generics, &f.decl, tcx),\n-        clean::MethodItem(ref m, _) => get_all_types(&m.generics, &m.decl, tcx),\n-        clean::TyMethodItem(ref m) => get_all_types(&m.generics, &m.decl, tcx),\n+        clean::FunctionItem(ref f) => get_all_types(&f.generics, &f.decl, tcx, cache),\n+        clean::MethodItem(ref m, _) => get_all_types(&m.generics, &m.decl, tcx, cache),\n+        clean::TyMethodItem(ref m) => get_all_types(&m.generics, &m.decl, tcx, cache),\n         _ => return None,\n     };\n \n@@ -249,12 +250,14 @@ crate fn get_real_types<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     recurse: usize,\n     res: &mut Vec<TypeWithKind>,\n+    cache: &Cache,\n ) {\n     fn insert_ty(\n         res: &mut Vec<TypeWithKind>,\n         tcx: TyCtxt<'_>,\n         ty: Type,\n         mut generics: Vec<TypeWithKind>,\n+        cache: &Cache,\n     ) {\n         let is_full_generic = ty.is_full_generic();\n \n@@ -306,7 +309,7 @@ crate fn get_real_types<'tcx>(\n             // We remove the name of the full generic because we have no use for it.\n             index_ty.name = Some(String::new());\n             res.push(TypeWithKind::from((index_ty, ItemType::Generic)));\n-        } else if let Some(kind) = ty.def_id_no_primitives().map(|did| tcx.def_kind(did).into()) {\n+        } else if let Some(kind) = ty.def_id(cache).map(|did| tcx.def_kind(did).into()) {\n             res.push(TypeWithKind::from((index_ty, kind)));\n         } else if ty.is_primitive() {\n             // This is a primitive, let's store it as such.\n@@ -321,9 +324,7 @@ crate fn get_real_types<'tcx>(\n \n     if let Type::Generic(arg_s) = *arg {\n         if let Some(where_pred) = generics.where_predicates.iter().find(|g| match g {\n-            WherePredicate::BoundPredicate { ty, .. } => {\n-                ty.def_id_no_primitives() == arg.def_id_no_primitives()\n-            }\n+            WherePredicate::BoundPredicate { ty, .. } => ty.def_id(cache) == arg.def_id(cache),\n             _ => false,\n         }) {\n             let mut ty_generics = Vec::new();\n@@ -335,31 +336,38 @@ crate fn get_real_types<'tcx>(\n                             continue;\n                         }\n                         if let Some(ty) = x.get_type() {\n-                            get_real_types(generics, &ty, tcx, recurse + 1, &mut ty_generics);\n+                            get_real_types(\n+                                generics,\n+                                &ty,\n+                                tcx,\n+                                recurse + 1,\n+                                &mut ty_generics,\n+                                cache,\n+                            );\n                         }\n                     }\n                 }\n             }\n-            insert_ty(res, tcx, arg.clone(), ty_generics);\n+            insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n         }\n         if let Some(bound) = generics.params.iter().find(|g| g.is_type() && g.name == arg_s) {\n             let mut ty_generics = Vec::new();\n             for bound in bound.get_bounds().unwrap_or(&[]) {\n                 if let Some(path) = bound.get_trait_path() {\n                     let ty = Type::ResolvedPath { did: path.def_id(), path };\n-                    get_real_types(generics, &ty, tcx, recurse + 1, &mut ty_generics);\n+                    get_real_types(generics, &ty, tcx, recurse + 1, &mut ty_generics, cache);\n                 }\n             }\n-            insert_ty(res, tcx, arg.clone(), ty_generics);\n+            insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n         }\n     } else {\n         let mut ty_generics = Vec::new();\n         if let Some(arg_generics) = arg.generics() {\n             for gen in arg_generics.iter() {\n-                get_real_types(generics, gen, tcx, recurse + 1, &mut ty_generics);\n+                get_real_types(generics, gen, tcx, recurse + 1, &mut ty_generics, cache);\n             }\n         }\n-        insert_ty(res, tcx, arg.clone(), ty_generics);\n+        insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n     }\n }\n \n@@ -371,6 +379,7 @@ crate fn get_all_types<'tcx>(\n     generics: &Generics,\n     decl: &FnDecl,\n     tcx: TyCtxt<'tcx>,\n+    cache: &Cache,\n ) -> (Vec<TypeWithKind>, Vec<TypeWithKind>) {\n     let mut all_types = Vec::new();\n     for arg in decl.inputs.values.iter() {\n@@ -380,14 +389,13 @@ crate fn get_all_types<'tcx>(\n         // FIXME: performance wise, it'd be much better to move `args` declaration outside of the\n         // loop and replace this line with `args.clear()`.\n         let mut args = Vec::new();\n-        get_real_types(generics, &arg.type_, tcx, 0, &mut args);\n+        get_real_types(generics, &arg.type_, tcx, 0, &mut args, cache);\n         if !args.is_empty() {\n             // FIXME: once back to performance improvements, replace this line with:\n             // `all_types.extend(args.drain(..));`.\n             all_types.extend(args);\n         } else {\n-            if let Some(kind) = arg.type_.def_id_no_primitives().map(|did| tcx.def_kind(did).into())\n-            {\n+            if let Some(kind) = arg.type_.def_id(cache).map(|did| tcx.def_kind(did).into()) {\n                 all_types.push(TypeWithKind::from((get_index_type(&arg.type_, vec![]), kind)));\n             }\n         }\n@@ -396,11 +404,9 @@ crate fn get_all_types<'tcx>(\n     let mut ret_types = Vec::new();\n     match decl.output {\n         FnRetTy::Return(ref return_type) => {\n-            get_real_types(generics, return_type, tcx, 0, &mut ret_types);\n+            get_real_types(generics, return_type, tcx, 0, &mut ret_types, cache);\n             if ret_types.is_empty() {\n-                if let Some(kind) =\n-                    return_type.def_id_no_primitives().map(|did| tcx.def_kind(did).into())\n-                {\n+                if let Some(kind) = return_type.def_id(cache).map(|did| tcx.def_kind(did).into()) {\n                     ret_types.push(TypeWithKind::from((get_index_type(return_type, vec![]), kind)));\n                 }\n             }"}, {"sha": "fdc552872ca7392fccc327c8da76e9f01aa15336", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4684182096326ccc57ea70bdb080c95607ff238/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4684182096326ccc57ea70bdb080c95607ff238/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=d4684182096326ccc57ea70bdb080c95607ff238", "patch": "@@ -2166,7 +2166,7 @@ fn sidebar_deref_methods(\n         }\n \n         // Recurse into any further impls that might exist for `target`\n-        if let Some(target_did) = target.def_id_no_primitives() {\n+        if let Some(target_did) = target.def_id(c) {\n             if let Some(target_impls) = c.impls.get(&target_did) {\n                 if let Some(target_deref_impl) = target_impls.iter().find(|i| {\n                     i.inner_impl()"}, {"sha": "2aaf1dabd8696fe61bfc948afe4d3d828927b6cd", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4684182096326ccc57ea70bdb080c95607ff238/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4684182096326ccc57ea70bdb080c95607ff238/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=d4684182096326ccc57ea70bdb080c95607ff238", "patch": "@@ -57,6 +57,7 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n \n     // Follow all `Deref` targets of included items and recursively add them as valid\n     fn add_deref_target(\n+        cx: &DocContext<'_>,\n         map: &FxHashMap<DefId, &Type>,\n         cleaner: &mut BadImplStripper,\n         type_did: DefId,\n@@ -65,14 +66,14 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n             debug!(\"add_deref_target: type {:?}, target {:?}\", type_did, target);\n             if let Some(target_prim) = target.primitive_type() {\n                 cleaner.prims.insert(target_prim);\n-            } else if let Some(target_did) = target.def_id_no_primitives() {\n+            } else if let Some(target_did) = target.def_id(&cx.cache) {\n                 // `impl Deref<Target = S> for S`\n                 if target_did == type_did {\n                     // Avoid infinite cycles\n                     return;\n                 }\n                 cleaner.items.insert(target_did.into());\n-                add_deref_target(map, cleaner, target_did);\n+                add_deref_target(cx, map, cleaner, target_did);\n             }\n         }\n     }\n@@ -102,7 +103,7 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n                         // `Deref` target type and the impl for type positions, this map of types is keyed by\n                         // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n                         if cleaner.keep_impl_with_def_id(for_did.into()) {\n-                            add_deref_target(&type_did_to_deref_target, &mut cleaner, for_did);\n+                            add_deref_target(cx, &type_did_to_deref_target, &mut cleaner, for_did);\n                         }\n                     }\n                 }"}]}