{"sha": "426835762bd757cb21001598fe6aa701e59bd354", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNjgzNTc2MmJkNzU3Y2IyMTAwMTU5OGZlNmFhNzAxZTU5YmQzNTQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-11-21T18:44:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-21T18:44:10Z"}, "message": "Rollup merge of #79067 - bjorn3:abi_refactor, r=nagisa\n\nRefactor the abi handling code a bit\n\nI am not quite sure if all changes are improvements.", "tree": {"sha": "e4226656860e0a8e85c8bd37f79e7772065d93e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4226656860e0a8e85c8bd37f79e7772065d93e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/426835762bd757cb21001598fe6aa701e59bd354", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfuV/6CRBK7hj4Ov3rIwAAdHIIAEZCC/Pb8Xyi5qyEtG9Rjzdc\nrkT3sJuzqX0dD6NFkvyuYnFPHQGRJ2yAIeS1XcXNyiCmArQm53qF7pbSYCWSa86X\nC9Y1vBZFrKL8YGMmnrSm/zPBDtEafEM3XGwk3Y6oax3oa3BS1Vfh5y+rPaWEBx3n\n2TdgiXSR1Ae76jiJEMbnW//7z9irv2bsG/hgn9CYdI7vaiIa3pjl7zS3h6bfaIHP\n+Yz5g9QZr6G/O3EUMfMDrekYPVYnWQYVbUNsWDkcrIY78GGaB41wiKH2XZOBtZUV\nZl3QG9G/HLRhoGgYtrjvuQhkBITzRmbTPKmqJSIbwzFjwS8/Vgi56KhtgJhbbcs=\n=jHu3\n-----END PGP SIGNATURE-----\n", "payload": "tree e4226656860e0a8e85c8bd37f79e7772065d93e6\nparent 6cd02a85f1e40f8feac4f09c987baba0821b7756\nparent 43968aa8b8c1d0073410d3af36bd83debf6fcf78\nauthor Dylan DPC <dylan.dpc@gmail.com> 1605984250 +0100\ncommitter GitHub <noreply@github.com> 1605984250 +0100\n\nRollup merge of #79067 - bjorn3:abi_refactor, r=nagisa\n\nRefactor the abi handling code a bit\n\nI am not quite sure if all changes are improvements.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/426835762bd757cb21001598fe6aa701e59bd354", "html_url": "https://github.com/rust-lang/rust/commit/426835762bd757cb21001598fe6aa701e59bd354", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/426835762bd757cb21001598fe6aa701e59bd354/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cd02a85f1e40f8feac4f09c987baba0821b7756", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cd02a85f1e40f8feac4f09c987baba0821b7756", "html_url": "https://github.com/rust-lang/rust/commit/6cd02a85f1e40f8feac4f09c987baba0821b7756"}, {"sha": "43968aa8b8c1d0073410d3af36bd83debf6fcf78", "url": "https://api.github.com/repos/rust-lang/rust/commits/43968aa8b8c1d0073410d3af36bd83debf6fcf78", "html_url": "https://github.com/rust-lang/rust/commit/43968aa8b8c1d0073410d3af36bd83debf6fcf78"}], "stats": {"total": 237, "additions": 157, "deletions": 80}, "files": [{"sha": "915dd3d9eda1586ecef67545eb8514b309e790cb", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 102, "deletions": 44, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/426835762bd757cb21001598fe6aa701e59bd354/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426835762bd757cb21001598fe6aa701e59bd354/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=426835762bd757cb21001598fe6aa701e59bd354", "patch": "@@ -36,17 +36,17 @@ impl ArgAttributeExt for ArgAttribute {\n     where\n         F: FnMut(llvm::Attribute),\n     {\n-        for_each_kind!(self, f, NoAlias, NoCapture, NonNull, ReadOnly, SExt, StructRet, ZExt, InReg)\n+        for_each_kind!(self, f, NoAlias, NoCapture, NonNull, ReadOnly, InReg)\n     }\n }\n \n pub trait ArgAttributesExt {\n-    fn apply_llfn(&self, idx: AttributePlace, llfn: &Value, ty: Option<&Type>);\n-    fn apply_callsite(&self, idx: AttributePlace, callsite: &Value, ty: Option<&Type>);\n+    fn apply_attrs_to_llfn(&self, idx: AttributePlace, llfn: &Value);\n+    fn apply_attrs_to_callsite(&self, idx: AttributePlace, callsite: &Value);\n }\n \n impl ArgAttributesExt for ArgAttributes {\n-    fn apply_llfn(&self, idx: AttributePlace, llfn: &Value, ty: Option<&Type>) {\n+    fn apply_attrs_to_llfn(&self, idx: AttributePlace, llfn: &Value) {\n         let mut regular = self.regular;\n         unsafe {\n             let deref = self.pointee_size.bytes();\n@@ -61,14 +61,20 @@ impl ArgAttributesExt for ArgAttributes {\n             if let Some(align) = self.pointee_align {\n                 llvm::LLVMRustAddAlignmentAttr(llfn, idx.as_uint(), align.bytes() as u32);\n             }\n-            if regular.contains(ArgAttribute::ByVal) {\n-                llvm::LLVMRustAddByValAttr(llfn, idx.as_uint(), ty.unwrap());\n-            }\n             regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));\n+            match self.arg_ext {\n+                ArgExtension::None => {}\n+                ArgExtension::Zext => {\n+                    llvm::Attribute::ZExt.apply_llfn(idx, llfn);\n+                }\n+                ArgExtension::Sext => {\n+                    llvm::Attribute::SExt.apply_llfn(idx, llfn);\n+                }\n+            }\n         }\n     }\n \n-    fn apply_callsite(&self, idx: AttributePlace, callsite: &Value, ty: Option<&Type>) {\n+    fn apply_attrs_to_callsite(&self, idx: AttributePlace, callsite: &Value) {\n         let mut regular = self.regular;\n         unsafe {\n             let deref = self.pointee_size.bytes();\n@@ -91,10 +97,16 @@ impl ArgAttributesExt for ArgAttributes {\n                     align.bytes() as u32,\n                 );\n             }\n-            if regular.contains(ArgAttribute::ByVal) {\n-                llvm::LLVMRustAddByValCallSiteAttr(callsite, idx.as_uint(), ty.unwrap());\n-            }\n             regular.for_each_kind(|attr| attr.apply_callsite(idx, callsite));\n+            match self.arg_ext {\n+                ArgExtension::None => {}\n+                ArgExtension::Zext => {\n+                    llvm::Attribute::ZExt.apply_callsite(idx, callsite);\n+                }\n+                ArgExtension::Sext => {\n+                    llvm::Attribute::SExt.apply_callsite(idx, callsite);\n+                }\n+            }\n         }\n     }\n }\n@@ -146,7 +158,7 @@ impl LlvmType for CastTarget {\n             .prefix\n             .iter()\n             .flat_map(|option_kind| {\n-                option_kind.map(|kind| Reg { kind, size: self.prefix_chunk }.llvm_type(cx))\n+                option_kind.map(|kind| Reg { kind, size: self.prefix_chunk_size }.llvm_type(cx))\n             })\n             .chain((0..rest_count).map(|_| rest_ll_unit))\n             .collect();\n@@ -267,10 +279,12 @@ impl ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             PassMode::Pair(..) => {\n                 OperandValue::Pair(next(), next()).store(bx, dst);\n             }\n-            PassMode::Indirect(_, Some(_)) => {\n+            PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n                 OperandValue::Ref(next(), Some(next()), self.layout.align.abi).store(bx, dst);\n             }\n-            PassMode::Direct(_) | PassMode::Indirect(_, None) | PassMode::Cast(_) => {\n+            PassMode::Direct(_)\n+            | PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ }\n+            | PassMode::Cast(_) => {\n                 let next_arg = next();\n                 self.store(bx, next_arg, dst);\n             }\n@@ -315,14 +329,14 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             if let PassMode::Pair(_, _) = arg.mode { 2 } else { 1 }\n         ).sum();\n         let mut llargument_tys = Vec::with_capacity(\n-            if let PassMode::Indirect(..) = self.ret.mode { 1 } else { 0 } + args_capacity,\n+            if let PassMode::Indirect { .. } = self.ret.mode { 1 } else { 0 } + args_capacity,\n         );\n \n         let llreturn_ty = match self.ret.mode {\n             PassMode::Ignore => cx.type_void(),\n             PassMode::Direct(_) | PassMode::Pair(..) => self.ret.layout.immediate_llvm_type(cx),\n             PassMode::Cast(cast) => cast.llvm_type(cx),\n-            PassMode::Indirect(..) => {\n+            PassMode::Indirect { .. } => {\n                 llargument_tys.push(cx.type_ptr_to(self.ret.memory_ty(cx)));\n                 cx.type_void()\n             }\n@@ -342,15 +356,17 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                     llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 1, true));\n                     continue;\n                 }\n-                PassMode::Indirect(_, Some(_)) => {\n+                PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n                     let ptr_ty = cx.tcx.mk_mut_ptr(arg.layout.ty);\n                     let ptr_layout = cx.layout_of(ptr_ty);\n                     llargument_tys.push(ptr_layout.scalar_pair_element_llvm_type(cx, 0, true));\n                     llargument_tys.push(ptr_layout.scalar_pair_element_llvm_type(cx, 1, true));\n                     continue;\n                 }\n                 PassMode::Cast(cast) => cast.llvm_type(cx),\n-                PassMode::Indirect(_, None) => cx.type_ptr_to(arg.memory_ty(cx)),\n+                PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n+                    cx.type_ptr_to(arg.memory_ty(cx))\n+                }\n             };\n             llargument_tys.push(llarg_ty);\n         }\n@@ -402,35 +418,54 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         }\n \n         let mut i = 0;\n-        let mut apply = |attrs: &ArgAttributes, ty: Option<&Type>| {\n-            attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn, ty);\n+        let mut apply = |attrs: &ArgAttributes| {\n+            attrs.apply_attrs_to_llfn(llvm::AttributePlace::Argument(i), llfn);\n             i += 1;\n+            i - 1\n         };\n         match self.ret.mode {\n             PassMode::Direct(ref attrs) => {\n-                attrs.apply_llfn(llvm::AttributePlace::ReturnValue, llfn, None);\n+                attrs.apply_attrs_to_llfn(llvm::AttributePlace::ReturnValue, llfn);\n+            }\n+            PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n+                assert!(!on_stack);\n+                let i = apply(attrs);\n+                llvm::Attribute::StructRet.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n             }\n-            PassMode::Indirect(ref attrs, _) => apply(attrs, Some(self.ret.layout.llvm_type(cx))),\n             _ => {}\n         }\n         for arg in &self.args {\n             if arg.pad.is_some() {\n-                apply(&ArgAttributes::new(), None);\n+                apply(&ArgAttributes::new());\n             }\n             match arg.mode {\n                 PassMode::Ignore => {}\n-                PassMode::Direct(ref attrs) | PassMode::Indirect(ref attrs, None) => {\n-                    apply(attrs, Some(arg.layout.llvm_type(cx)))\n+                PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: true } => {\n+                    let i = apply(attrs);\n+                    unsafe {\n+                        llvm::LLVMRustAddByValAttr(\n+                            llfn,\n+                            llvm::AttributePlace::Argument(i).as_uint(),\n+                            arg.layout.llvm_type(cx),\n+                        );\n+                    }\n                 }\n-                PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {\n-                    apply(attrs, None);\n-                    apply(extra_attrs, None);\n+                PassMode::Direct(ref attrs)\n+                | PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: false } => {\n+                    apply(attrs);\n+                }\n+                PassMode::Indirect { ref attrs, extra_attrs: Some(ref extra_attrs), on_stack } => {\n+                    assert!(!on_stack);\n+                    apply(attrs);\n+                    apply(extra_attrs);\n                 }\n                 PassMode::Pair(ref a, ref b) => {\n-                    apply(a, None);\n-                    apply(b, None);\n+                    apply(a);\n+                    apply(b);\n+                }\n+                PassMode::Cast(_) => {\n+                    apply(&ArgAttributes::new());\n                 }\n-                PassMode::Cast(_) => apply(&ArgAttributes::new(), None),\n             }\n         }\n     }\n@@ -439,15 +474,21 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         // FIXME(wesleywiser, eddyb): We should apply `nounwind` and `noreturn` as appropriate to this callsite.\n \n         let mut i = 0;\n-        let mut apply = |attrs: &ArgAttributes, ty: Option<&Type>| {\n-            attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite, ty);\n+        let mut apply = |attrs: &ArgAttributes| {\n+            attrs.apply_attrs_to_callsite(llvm::AttributePlace::Argument(i), callsite);\n             i += 1;\n+            i - 1\n         };\n         match self.ret.mode {\n             PassMode::Direct(ref attrs) => {\n-                attrs.apply_callsite(llvm::AttributePlace::ReturnValue, callsite, None);\n+                attrs.apply_attrs_to_callsite(llvm::AttributePlace::ReturnValue, callsite);\n+            }\n+            PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n+                assert!(!on_stack);\n+                let i = apply(attrs);\n+                llvm::Attribute::StructRet\n+                    .apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n             }\n-            PassMode::Indirect(ref attrs, _) => apply(attrs, Some(self.ret.layout.llvm_type(bx))),\n             _ => {}\n         }\n         if let abi::Abi::Scalar(ref scalar) = self.ret.layout.abi {\n@@ -465,22 +506,39 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         }\n         for arg in &self.args {\n             if arg.pad.is_some() {\n-                apply(&ArgAttributes::new(), None);\n+                apply(&ArgAttributes::new());\n             }\n             match arg.mode {\n                 PassMode::Ignore => {}\n-                PassMode::Direct(ref attrs) | PassMode::Indirect(ref attrs, None) => {\n-                    apply(attrs, Some(arg.layout.llvm_type(bx)))\n+                PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: true } => {\n+                    let i = apply(attrs);\n+                    unsafe {\n+                        llvm::LLVMRustAddByValCallSiteAttr(\n+                            callsite,\n+                            llvm::AttributePlace::Argument(i).as_uint(),\n+                            arg.layout.llvm_type(bx),\n+                        );\n+                    }\n                 }\n-                PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {\n-                    apply(attrs, None);\n-                    apply(extra_attrs, None);\n+                PassMode::Direct(ref attrs)\n+                | PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: false } => {\n+                    apply(attrs);\n+                }\n+                PassMode::Indirect {\n+                    ref attrs,\n+                    extra_attrs: Some(ref extra_attrs),\n+                    on_stack: _,\n+                } => {\n+                    apply(attrs);\n+                    apply(extra_attrs);\n                 }\n                 PassMode::Pair(ref a, ref b) => {\n-                    apply(a, None);\n-                    apply(b, None);\n+                    apply(a);\n+                    apply(b);\n+                }\n+                PassMode::Cast(_) => {\n+                    apply(&ArgAttributes::new());\n                 }\n-                PassMode::Cast(_) => apply(&ArgAttributes::new(), None),\n             }\n         }\n "}, {"sha": "fd20709f5d80f67ef96ac901725ee362c67bc594", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/426835762bd757cb21001598fe6aa701e59bd354/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426835762bd757cb21001598fe6aa701e59bd354/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=426835762bd757cb21001598fe6aa701e59bd354", "patch": "@@ -255,7 +255,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             return;\n         }\n         let llval = match self.fn_abi.ret.mode {\n-            PassMode::Ignore | PassMode::Indirect(..) => {\n+            PassMode::Ignore | PassMode::Indirect { .. } => {\n                 bx.ret_void();\n                 return;\n             }\n@@ -1101,7 +1101,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Force by-ref if we have to load through a cast pointer.\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => match arg.mode {\n-                PassMode::Indirect(..) | PassMode::Cast(_) => {\n+                PassMode::Indirect { .. } | PassMode::Cast(_) => {\n                     let scratch = PlaceRef::alloca(bx, arg.layout);\n                     op.val.store(bx, scratch);\n                     (scratch.llval, scratch.align, true)"}, {"sha": "fa0711193df487bbf72025f5e9aa7e0d514f7662", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/426835762bd757cb21001598fe6aa701e59bd354/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426835762bd757cb21001598fe6aa701e59bd354/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=426835762bd757cb21001598fe6aa701e59bd354", "patch": "@@ -15,7 +15,7 @@ use rustc_session::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::call::{\n-    ArgAbi, ArgAttribute, ArgAttributes, Conv, FnAbi, PassMode, Reg, RegKind,\n+    ArgAbi, ArgAttribute, ArgAttributes, ArgExtension, Conv, FnAbi, PassMode, Reg, RegKind,\n };\n use rustc_target::abi::*;\n use rustc_target::spec::{abi::Abi as SpecAbi, HasTargetSpec, PanicStrategy};\n@@ -2619,7 +2619,7 @@ where\n                                       is_return: bool| {\n             // Booleans are always an i1 that needs to be zero-extended.\n             if scalar.is_bool() {\n-                attrs.set(ArgAttribute::ZExt);\n+                attrs.ext(ArgExtension::Zext);\n                 return;\n             }\n \n@@ -2801,9 +2801,6 @@ where\n             for arg in &mut self.args {\n                 fixup(arg, false);\n             }\n-            if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n-                attrs.set(ArgAttribute::StructRet);\n-            }\n             return;\n         }\n "}, {"sha": "a630c84142b4d4ebb4f749ff68097bbcfa615d96", "filename": "compiler/rustc_target/src/abi/call/mips64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/426835762bd757cb21001598fe6aa701e59bd354/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426835762bd757cb21001598fe6aa701e59bd354/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs?ref=426835762bd757cb21001598fe6aa701e59bd354", "patch": "@@ -1,4 +1,4 @@\n-use crate::abi::call::{ArgAbi, ArgAttribute, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n+use crate::abi::call::{ArgAbi, ArgExtension, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n use crate::abi::{self, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods};\n \n fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n@@ -7,7 +7,7 @@ fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n         if let abi::Int(i, signed) = scalar.value {\n             if !signed && i.size().bits() == 32 {\n                 if let PassMode::Direct(ref mut attrs) = arg.mode {\n-                    attrs.set(ArgAttribute::SExt);\n+                    attrs.ext(ArgExtension::Sext);\n                     return;\n                 }\n             }\n@@ -137,7 +137,7 @@ where\n     let rest_size = size - Size::from_bytes(8) * prefix_index as u64;\n     arg.cast_to(CastTarget {\n         prefix,\n-        prefix_chunk: Size::from_bytes(8),\n+        prefix_chunk_size: Size::from_bytes(8),\n         rest: Uniform { unit: Reg::i64(), total: rest_size },\n     });\n }"}, {"sha": "5de9a8dfa7ac1719a7b0e388962d3c1881c6374f", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/426835762bd757cb21001598fe6aa701e59bd354/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426835762bd757cb21001598fe6aa701e59bd354/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=426835762bd757cb21001598fe6aa701e59bd354", "patch": "@@ -36,9 +36,12 @@ pub enum PassMode {\n     /// a single uniform or a pair of registers.\n     Cast(CastTarget),\n     /// Pass the argument indirectly via a hidden pointer.\n-    /// The second value, if any, is for the extra data (vtable or length)\n+    /// The `extra_attrs` value, if any, is for the extra data (vtable or length)\n     /// which indicates that it refers to an unsized rvalue.\n-    Indirect(ArgAttributes, Option<ArgAttributes>),\n+    /// `on_stack` defines that the the value should be passed at a fixed\n+    /// stack offset in accordance to the ABI rather than passed using a\n+    /// pointer. This corresponds to the `byval` LLVM argument attribute.\n+    Indirect { attrs: ArgAttributes, extra_attrs: Option<ArgAttributes>, on_stack: bool },\n }\n \n // Hack to disable non_upper_case_globals only for the bitflags! and not for the rest\n@@ -52,24 +55,31 @@ mod attr_impl {\n     bitflags::bitflags! {\n         #[derive(Default)]\n         pub struct ArgAttribute: u16 {\n-            const ByVal     = 1 << 0;\n             const NoAlias   = 1 << 1;\n             const NoCapture = 1 << 2;\n             const NonNull   = 1 << 3;\n             const ReadOnly  = 1 << 4;\n-            const SExt      = 1 << 5;\n-            const StructRet = 1 << 6;\n-            const ZExt      = 1 << 7;\n             const InReg     = 1 << 8;\n         }\n     }\n }\n \n+/// Sometimes an ABI requires small integers to be extended to a full or partial register. This enum\n+/// defines if this extension should be zero-extension or sign-extension when necssary. When it is\n+/// not necesary to extend the argument, this enum is ignored.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum ArgExtension {\n+    None,\n+    Zext,\n+    Sext,\n+}\n+\n /// A compact representation of LLVM attributes (at least those relevant for this module)\n /// that can be manipulated without interacting with LLVM's Attribute machinery.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub struct ArgAttributes {\n     pub regular: ArgAttribute,\n+    pub arg_ext: ArgExtension,\n     /// The minimum size of the pointee, guaranteed to be valid for the duration of the whole call\n     /// (corresponding to LLVM's dereferenceable and dereferenceable_or_null attributes).\n     pub pointee_size: Size,\n@@ -80,11 +90,18 @@ impl ArgAttributes {\n     pub fn new() -> Self {\n         ArgAttributes {\n             regular: ArgAttribute::default(),\n+            arg_ext: ArgExtension::None,\n             pointee_size: Size::ZERO,\n             pointee_align: None,\n         }\n     }\n \n+    pub fn ext(&mut self, ext: ArgExtension) -> &mut Self {\n+        assert!(self.arg_ext == ArgExtension::None || self.arg_ext == ext);\n+        self.arg_ext = ext;\n+        self\n+    }\n+\n     pub fn set(&mut self, attr: ArgAttribute) -> &mut Self {\n         self.regular |= attr;\n         self\n@@ -180,7 +197,7 @@ impl Uniform {\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub struct CastTarget {\n     pub prefix: [Option<RegKind>; 8],\n-    pub prefix_chunk: Size,\n+    pub prefix_chunk_size: Size,\n     pub rest: Uniform,\n }\n \n@@ -192,29 +209,29 @@ impl From<Reg> for CastTarget {\n \n impl From<Uniform> for CastTarget {\n     fn from(uniform: Uniform) -> CastTarget {\n-        CastTarget { prefix: [None; 8], prefix_chunk: Size::ZERO, rest: uniform }\n+        CastTarget { prefix: [None; 8], prefix_chunk_size: Size::ZERO, rest: uniform }\n     }\n }\n \n impl CastTarget {\n     pub fn pair(a: Reg, b: Reg) -> CastTarget {\n         CastTarget {\n             prefix: [Some(a.kind), None, None, None, None, None, None, None],\n-            prefix_chunk: a.size,\n+            prefix_chunk_size: a.size,\n             rest: Uniform::from(b),\n         }\n     }\n \n     pub fn size<C: HasDataLayout>(&self, cx: &C) -> Size {\n-        (self.prefix_chunk * self.prefix.iter().filter(|x| x.is_some()).count() as u64)\n+        (self.prefix_chunk_size * self.prefix.iter().filter(|x| x.is_some()).count() as u64)\n             .align_to(self.rest.align(cx))\n             + self.rest.total\n     }\n \n     pub fn align<C: HasDataLayout>(&self, cx: &C) -> Align {\n         self.prefix\n             .iter()\n-            .filter_map(|x| x.map(|kind| Reg { kind, size: self.prefix_chunk }.align(cx)))\n+            .filter_map(|x| x.map(|kind| Reg { kind, size: self.prefix_chunk_size }.align(cx)))\n             .fold(cx.data_layout().aggregate_align.abi.max(self.rest.align(cx)), |acc, align| {\n                 acc.max(align)\n             })\n@@ -438,14 +455,14 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n \n         let extra_attrs = self.layout.is_unsized().then_some(ArgAttributes::new());\n \n-        self.mode = PassMode::Indirect(attrs, extra_attrs);\n+        self.mode = PassMode::Indirect { attrs, extra_attrs, on_stack: false };\n     }\n \n     pub fn make_indirect_byval(&mut self) {\n         self.make_indirect();\n         match self.mode {\n-            PassMode::Indirect(ref mut attrs, _) => {\n-                attrs.set(ArgAttribute::ByVal);\n+            PassMode::Indirect { attrs: _, extra_attrs: _, ref mut on_stack } => {\n+                *on_stack = true;\n             }\n             _ => unreachable!(),\n         }\n@@ -457,7 +474,11 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n             if let abi::Int(i, signed) = scalar.value {\n                 if i.size().bits() < bits {\n                     if let PassMode::Direct(ref mut attrs) = self.mode {\n-                        attrs.set(if signed { ArgAttribute::SExt } else { ArgAttribute::ZExt });\n+                        if signed {\n+                            attrs.ext(ArgExtension::Sext)\n+                        } else {\n+                            attrs.ext(ArgExtension::Zext)\n+                        };\n                     }\n                 }\n             }\n@@ -474,15 +495,15 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n     }\n \n     pub fn is_indirect(&self) -> bool {\n-        matches!(self.mode, PassMode::Indirect(..))\n+        matches!(self.mode, PassMode::Indirect {..})\n     }\n \n     pub fn is_sized_indirect(&self) -> bool {\n-        matches!(self.mode, PassMode::Indirect(_, None))\n+        matches!(self.mode, PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ })\n     }\n \n     pub fn is_unsized_indirect(&self) -> bool {\n-        matches!(self.mode, PassMode::Indirect(_, Some(_)))\n+        matches!(self.mode, PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ })\n     }\n \n     pub fn is_ignore(&self) -> bool {\n@@ -591,10 +612,6 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             a => return Err(format!(\"unrecognized arch \\\"{}\\\" in target specification\", a)),\n         }\n \n-        if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n-            attrs.set(ArgAttribute::StructRet);\n-        }\n-\n         Ok(())\n     }\n }"}, {"sha": "1ab881dd13d1c46a1e8d5f4e0e0b7519fc115ff7", "filename": "compiler/rustc_target/src/abi/call/riscv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/426835762bd757cb21001598fe6aa701e59bd354/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426835762bd757cb21001598fe6aa701e59bd354/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs?ref=426835762bd757cb21001598fe6aa701e59bd354", "patch": "@@ -4,7 +4,7 @@\n // Reference: Clang RISC-V ELF psABI lowering code\n // https://github.com/llvm/llvm-project/blob/8e780252a7284be45cf1ba224cabd884847e8e92/clang/lib/CodeGen/TargetInfo.cpp#L9311-L9773\n \n-use crate::abi::call::{ArgAbi, ArgAttribute, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n+use crate::abi::call::{ArgAbi, ArgExtension, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n use crate::abi::{\n     self, Abi, FieldsShape, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods,\n };\n@@ -308,7 +308,7 @@ fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n             // 32-bit integers are always sign-extended\n             if i.size().bits() == 32 && xlen > 32 {\n                 if let PassMode::Direct(ref mut attrs) = arg.mode {\n-                    attrs.set(ArgAttribute::SExt);\n+                    attrs.ext(ArgExtension::Sext);\n                     return;\n                 }\n             }"}, {"sha": "713b4100a33351472f8a1abfc739588956617021", "filename": "compiler/rustc_target/src/abi/call/x86.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/426835762bd757cb21001598fe6aa701e59bd354/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426835762bd757cb21001598fe6aa701e59bd354/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs?ref=426835762bd757cb21001598fe6aa701e59bd354", "patch": "@@ -92,9 +92,14 @@ where\n \n         for arg in &mut fn_abi.args {\n             let attrs = match arg.mode {\n-                PassMode::Ignore | PassMode::Indirect(_, None) => continue,\n+                PassMode::Ignore\n+                | PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n+                    continue;\n+                }\n                 PassMode::Direct(ref mut attrs) => attrs,\n-                PassMode::Pair(..) | PassMode::Indirect(_, Some(_)) | PassMode::Cast(_) => {\n+                PassMode::Pair(..)\n+                | PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ }\n+                | PassMode::Cast(_) => {\n                     unreachable!(\"x86 shouldn't be passing arguments by {:?}\", arg.mode)\n                 }\n             };"}]}