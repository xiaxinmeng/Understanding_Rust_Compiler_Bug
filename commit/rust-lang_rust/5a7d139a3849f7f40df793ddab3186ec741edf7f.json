{"sha": "5a7d139a3849f7f40df793ddab3186ec741edf7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhN2QxMzlhMzg0OWY3ZjQwZGY3OTNkZGFiMzE4NmVjNzQxZWRmN2Y=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-14T08:03:54Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-07-14T08:03:54Z"}, "message": "Merge branch 'vector-reform' into incoming", "tree": {"sha": "35617a2bb085753994d613dc4aa62d3f11b3efbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35617a2bb085753994d613dc4aa62d3f11b3efbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a7d139a3849f7f40df793ddab3186ec741edf7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a7d139a3849f7f40df793ddab3186ec741edf7f", "html_url": "https://github.com/rust-lang/rust/commit/5a7d139a3849f7f40df793ddab3186ec741edf7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a7d139a3849f7f40df793ddab3186ec741edf7f/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebb33f2c284fb92df8611dd208866117feb8c61f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebb33f2c284fb92df8611dd208866117feb8c61f", "html_url": "https://github.com/rust-lang/rust/commit/ebb33f2c284fb92df8611dd208866117feb8c61f"}, {"sha": "e2af78560696384d169040d3e94d6d50f572f318", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2af78560696384d169040d3e94d6d50f572f318", "html_url": "https://github.com/rust-lang/rust/commit/e2af78560696384d169040d3e94d6d50f572f318"}], "stats": {"total": 16426, "additions": 8275, "deletions": 8151}, "files": [{"sha": "21d15c8b114fc6752848feb517cea1b6d68f4829", "filename": "doc/rust.md", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -449,7 +449,7 @@ Two examples of paths with type arguments:\n # import std::map;\n # fn f() {\n # fn id<T:copy>(t: T) -> T { t }\n-type t = map::hashmap<int,str>;  // Type arguments used in a type expression\n+type t = map::hashmap<int,~str>;  // Type arguments used in a type expression\n let x = id::<int>(10);           // Type arguments used in a call expression\n # }\n ~~~~\n@@ -563,7 +563,7 @@ a referencing crate file, or by the filename of the source file itself.\n \n A source file that contains a `main` function can be compiled to an\n executable. If a `main` function is present, it must have no [type parameters](#type-parameters)\n-and no [constraints](#constraints). Its return type must be [`nil`](#primitive-types) and it must either have no arguments, or a single argument of type `[str]`.\n+and no [constraints](#constraints). Its return type must be [`nil`](#primitive-types) and it must either have no arguments, or a single argument of type `[~str]`.\n \n # Items and attributes\n \n@@ -745,8 +745,8 @@ fn main() {\n     log(info, some(1.0));\n \n     // Equivalent to 'log(core::info,\n-    //                    core::str::hash(core::str::slice(\"foo\", 0u, 1u)));'\n-    log(info, hash(slice(\"foo\", 0u, 1u)));\n+    //                    core::str::hash(core::str::slice(~\"foo\", 0u, 1u)));'\n+    log(info, hash(slice(~\"foo\", 0u, 1u)));\n }\n ~~~~\n \n@@ -861,7 +861,7 @@ A special kind of function can be declared with a `!` character where the\n output slot type would normally be. For example:\n \n ~~~~\n-fn my_err(s: str) -> ! {\n+fn my_err(s: ~str) -> ! {\n     log(info, s);\n     fail;\n }\n@@ -881,14 +881,14 @@ were declared without the `!` annotation, the following code would not\n typecheck:\n \n ~~~~\n-# fn my_err(s: str) -> ! { fail }\n+# fn my_err(s: ~str) -> ! { fail }\n \n fn f(i: int) -> int {\n    if i == 42 {\n      ret 42;\n    }\n    else {\n-     my_err(\"Bad number!\");\n+     my_err(~\"Bad number!\");\n    }\n }\n ~~~~\n@@ -1497,7 +1497,7 @@ string, boolean value, or the nil value.\n \n ~~~~~~~~ {.literals}\n ();        // nil type\n-\"hello\";   // string type\n+~\"hello\";  // string type\n '5';       // character type\n 5;         // integer type\n ~~~~~~~~\n@@ -1510,7 +1510,7 @@ values.\n \n ~~~~~~~~ {.tuple}\n (0f, 4.5f);\n-(\"a\", 4u, true);\n+(~\"a\", 4u, true);\n ~~~~~~~~\n \n ### Record expressions\n@@ -1529,8 +1529,8 @@ written before its name.\n \n ~~~~\n {x: 10f, y: 20f};\n-{name: \"Joe\", age: 35u, score: 100_000};\n-{ident: \"X\", mut count: 0u};\n+{name: ~\"Joe\", age: 35u, score: 100_000};\n+{ident: ~\"X\", mut count: 0u};\n ~~~~\n \n The order of the fields in a record expression is significant, and\n@@ -1594,7 +1594,7 @@ When no mutability is specified, the vector is immutable.\n \n ~~~~\n ~[1, 2, 3, 4];\n-~[\"a\", \"b\", \"c\", \"d\"];\n+~[~\"a\", ~\"b\", ~\"c\", ~\"d\"];\n ~[mut 0u8, 0u8, 0u8, 0u8];\n ~~~~\n \n@@ -1620,7 +1620,7 @@ task in a _failing state_.\n \n (~[1, 2, 3, 4])[0];\n (~[mut 'x', 'y'])[1] = 'z';\n-(~[\"a\", \"b\"])[10]; // fails\n+(~[~\"a\", ~\"b\"])[10]; // fails\n \n # }\n ~~~~\n@@ -1965,7 +1965,7 @@ An example:\n # let println = io::println;\n \n while i < 10 {\n-    println(\"hello\\n\");\n+    println(~\"hello\\n\");\n     i = i + 1;\n }\n ~~~~\n@@ -2103,9 +2103,9 @@ enum list<X> { nil, cons(X, @list<X>) }\n let x: list<int> = cons(10, @cons(11, @nil));\n \n alt x {\n-    cons(_, @nil) { fail \"singleton list\"; }\n+    cons(_, @nil) { fail ~\"singleton list\"; }\n     cons(*)       { ret; }\n-    nil           { fail \"empty list\"; }\n+    nil           { fail ~\"empty list\"; }\n }\n ~~~~\n \n@@ -2152,28 +2152,28 @@ When matching fields of a record, the fields being matched are specified\n first, then a placeholder (`_`) represents the remaining fields.\n \n ~~~~\n-# type options = {choose: bool, size: str};\n-# type player = {player: str, stats: (), options: options};\n+# type options = {choose: bool, size: ~str};\n+# type player = {player: ~str, stats: (), options: options};\n # fn load_stats() { }\n # fn choose_player(r: player) { }\n # fn next_player() { }\n \n fn main() {\n     let r = {\n-        player: \"ralph\",\n+        player: ~\"ralph\",\n         stats: load_stats(),\n         options: {\n             choose: true,\n-            size: \"small\"\n+            size: ~\"small\"\n         }\n     };\n \n     alt r {\n       {options: {choose: true, _}, _} {\n         choose_player(r)\n       }\n-      {player: p, options: {size: \"small\", _}, _} {\n-        log(info, p + \" is small\");\n+      {player: p, options: {size: ~\"small\", _}, _} {\n+        log(info, p + ~\" is small\");\n       }\n       _ {\n         next_player();\n@@ -2189,9 +2189,9 @@ range of values may be specified with `to`. For example:\n # let x = 2;\n \n let message = alt x {\n-  0 | 1  { \"not many\" }\n-  2 to 9 { \"a few\" }\n-  _      { \"lots\" }\n+  0 | 1  { ~\"not many\" }\n+  2 to 9 { ~\"a few\" }\n+  _      { ~\"lots\" }\n };\n ~~~~\n \n@@ -2250,9 +2250,9 @@ the `note` to the internal logging diagnostic buffer.\n An example of a `note` expression:\n \n ~~~~{.xfail-test}\n-fn read_file_lines(path: str) -> ~[str] {\n+fn read_file_lines(path: ~str) -> ~[~str] {\n     note path;\n-    let r: [str];\n+    let r: [~str];\n     let f: file = open_read(path);\n     lines(f) |s| {\n         r += ~[s];\n@@ -2323,13 +2323,13 @@ The following examples all produce the same output, logged at the `error`\n logging level:\n \n ~~~~\n-# let filename = \"bulbasaur\";\n+# let filename = ~\"bulbasaur\";\n \n // Full version, logging a value.\n-log(core::error, \"file not found: \" + filename);\n+log(core::error, ~\"file not found: \" + filename);\n \n // Log-level abbreviated, since core::* is imported by default.\n-log(error, \"file not found: \" + filename);\n+log(error, ~\"file not found: \" + filename);\n \n // Formatting the message using a format-string and #fmt\n log(error, #fmt(\"file not found: %s\", filename));\n@@ -2627,12 +2627,12 @@ type `float` may not be equal to the largest *supported* floating-point type.\n \n ### Textual types\n \n-The types `char` and `str` hold textual data.\n+The types `char` and `~str` hold textual data.\n \n A value of type `char` is a Unicode character, represented as a 32-bit\n unsigned word holding a UCS-4 codepoint.\n \n-A value of type `str` is a Unicode string, represented as a vector of 8-bit\n+A value of type `~str` is a Unicode string, represented as a vector of 8-bit\n unsigned bytes holding a sequence of UTF-8 codepoints.\n \n \n@@ -2670,10 +2670,10 @@ order specified by the tuple type.\n An example of a tuple type and its use:\n \n ~~~~\n-type pair = (int,str);\n-let p: pair = (10,\"hello\");\n+type pair = (int,~str);\n+let p: pair = (10,~\"hello\");\n let (a, b) = p;\n-assert b != \"world\";\n+assert b != ~\"world\";\n ~~~~\n \n ### Vector types\n@@ -2837,7 +2837,7 @@ For example, this code:\n ~~~~~~~~\n # let mut s;\n \n-s = \"hello, world\";\n+s = ~\"hello, world\";\n io::println(s);\n ~~~~~~~~\n \n@@ -2862,8 +2862,8 @@ Whereas this code:\n \n \n ~~~~~~~~\n-# fn x() -> str { \"\" }\n-# fn y() -> str { \"\" }\n+# fn x() -> ~str { ~\"\" }\n+# fn y() -> ~str { ~\"\" }\n \n io::println(x() + y());\n ~~~~~~~~\n@@ -3364,7 +3364,7 @@ An example of a send:\n ~~~~\n let po = comm::port();\n let ch = comm::chan(po);\n-comm::send(ch, \"hello, world\");\n+comm::send(ch, ~\"hello, world\");\n ~~~~\n \n \n@@ -3380,7 +3380,7 @@ An example of a *receive*:\n ~~~~~~~~\n # let po = comm::port();\n # let ch = comm::chan(po);\n-# comm::send(ch, \"\");\n+# comm::send(ch, ~\"\");\n let s = comm::recv(po);\n ~~~~~~~~\n "}, {"sha": "749dcf043de88befa75a0d8f6418654a2604a530", "filename": "doc/tutorial.md", "status": "modified", "additions": 97, "deletions": 97, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -84,8 +84,8 @@ fn main() {\n     do listen |result_from_game| {\n \n         let times = 10;\n-        let player1 = \"graydon\";\n-        let player2 = \"patrick\";\n+        let player1 = ~\"graydon\";\n+        let player2 = ~\"patrick\";\n \n         for repeat(times) {\n             // Start another task to play the game\n@@ -102,7 +102,7 @@ fn main() {\n         }\n     }\n \n-    fn play_game(player1: str, player2: str) -> str {\n+    fn play_game(player1: ~str, player2: ~str) -> ~str {\n \n         // Our rock/paper/scissors types\n         enum gesture {\n@@ -117,7 +117,7 @@ fn main() {\n         alt (pick(), pick()) {\n             (rock, scissors) | (paper, rock) | (scissors, paper) { copy player1 }\n             (scissors, rock) | (rock, paper) | (paper, scissors) { copy player2 }\n-            _ { \"tie\" }\n+            _ { ~\"tie\" }\n         }\n     }\n }\n@@ -206,8 +206,8 @@ Rust program files are, by convention, given the extension `.rs`. Say\n we have a file `hello.rs` containing this program:\n \n ~~~~\n-fn main(args: ~[str]) {\n-    io::println(\"hello world from '\" + args[0] + \"'!\");\n+fn main(args: ~[~str]) {\n+    io::println(~\"hello world from '\" + args[0] + ~\"'!\");\n }\n ~~~~\n \n@@ -220,7 +220,7 @@ If you modify the program to make it invalid (for example, by changing\n \n ~~~~ {.notrust}\n hello.rs:2:4: 2:16 error: unresolved name: io::print_it\n-hello.rs:2     io::print_it(\"hello world from '\" + args[0] + \"'!\");\n+hello.rs:2     io::print_it(~\"hello world from '\" + args[0] + ~\"'!\");\n                ^~~~~~~~~~~~\n ~~~~\n \n@@ -367,7 +367,7 @@ defined with `const`:\n use std;\n const repeat: uint = 5u;\n fn main() {\n-    let hi = \"Hi!\";\n+    let hi = ~\"Hi!\";\n     let mut count = 0u;\n     while count < repeat {\n         io::println(hi);\n@@ -437,7 +437,7 @@ The basic types are written like this:\n `char`\n   : A character is a 32-bit Unicode code point.\n \n-`str`\n+`~str`\n   : String type. A string contains a UTF-8 encoded sequence of characters.\n \n These can be combined in composite types, which will be described in\n@@ -560,13 +560,13 @@ character escapes, using the backslash character:\n     form the character code.\n \n String literals allow the same escape sequences. They are written\n-between double quotes (`\"hello\"`). Rust strings may contain newlines.\n+between double quotes (`~\"hello\"`). Rust strings may contain newlines.\n When a newline is preceded by a backslash, it, and all white space\n following it, will not appear in the resulting string literal. So\n-this is equivalent to `\"abc\"`:\n+this is equivalent to `~\"abc\"`:\n \n ~~~~\n-let s = \"a\\\n+let s = ~\"a\\\n          b\\\n          c\";\n ~~~~\n@@ -649,7 +649,7 @@ one is `#fmt`, a printf-style text formatting macro that is expanded\n at compile time.\n \n ~~~~\n-io::println(#fmt(\"%s is %d\", \"the answer\", 42));\n+io::println(#fmt(\"%s is %d\", ~\"the answer\", 42));\n ~~~~\n \n `#fmt` supports most of the directives that [printf][pf] supports, but\n@@ -676,11 +676,11 @@ compulsory, an optional `else` clause can be appended, and multiple\n \n ~~~~\n if false {\n-    io::println(\"that's odd\");\n+    io::println(~\"that's odd\");\n } else if true {\n-    io::println(\"right\");\n+    io::println(~\"right\");\n } else {\n-    io::println(\"neither true nor false\");\n+    io::println(~\"neither true nor false\");\n }\n ~~~~\n \n@@ -713,10 +713,10 @@ the value.\n ~~~~\n # let my_number = 1;\n alt my_number {\n-  0       { io::println(\"zero\"); }\n-  1 | 2   { io::println(\"one or two\"); }\n-  3 to 10 { io::println(\"three to ten\"); }\n-  _       { io::println(\"something else\"); }\n+  0       { io::println(~\"zero\"); }\n+  1 | 2   { io::println(~\"one or two\"); }\n+  3 to 10 { io::println(~\"three to ten\"); }\n+  _       { io::println(~\"something else\"); }\n }\n ~~~~\n \n@@ -822,7 +822,7 @@ failure; failure is nonrecoverable. It is, however, possible for\n running.\n \n `fail` takes an optional argument specifying the reason for the\n-failure. It must have type `str`.\n+failure. It must have type `~str`.\n \n In addition to the `fail` statement, the following circumstances cause\n task failure:\n@@ -860,7 +860,7 @@ runtime will do its best to output a textual representation of the\n value.\n \n ~~~~\n-log(warn, \"hi\");\n+log(warn, ~\"hi\");\n log(error, (1, ~[2.5, -1.8]));\n ~~~~\n \n@@ -886,7 +886,7 @@ are available. These take a string and any number of format arguments,\n and will log the formatted string:\n \n ~~~~\n-# fn get_error_string() -> str { \"boo\" }\n+# fn get_error_string() -> ~str { ~\"boo\" }\n #warn(\"only %d seconds remaining\", 10);\n #error(\"fatal: %s\", get_error_string());\n ~~~~\n@@ -905,8 +905,8 @@ with the `fn` keyword, the type of arguments are specified following\n colons and the return type follows the arrow.\n \n ~~~~\n-fn int_to_str(i: int) -> str {\n-    ret \"tube sock\";\n+fn int_to_str(i: int) -> ~str {\n+    ret ~\"tube sock\";\n }\n ~~~~\n \n@@ -917,20 +917,20 @@ expression.\n \n ~~~~\n # const copernicus: int = 0;\n-fn int_to_str(i: int) -> str {\n+fn int_to_str(i: int) -> ~str {\n     if i == copernicus {\n-        ret \"tube sock\";\n+        ret ~\"tube sock\";\n     } else {\n-        ret \"violin\";\n+        ret ~\"violin\";\n     }\n }\n ~~~~\n \n ~~~~\n # const copernicus: int = 0;\n-fn int_to_str(i: int) -> str {\n-    if i == copernicus { \"tube sock\" }\n-    else { \"violin\" }\n+fn int_to_str(i: int) -> ~str {\n+    if i == copernicus { ~\"tube sock\" }\n+    else { ~\"violin\" }\n }\n ~~~~\n \n@@ -1348,7 +1348,7 @@ the pointer is guaranteed not to outlive the value it points to.\n \n ~~~~\n # fn work_with_foo_by_pointer(f: &~str) { }\n-let foo = \"foo\";\n+let foo = ~\"foo\";\n work_with_foo_by_pointer(&foo);\n ~~~~\n \n@@ -1359,7 +1359,7 @@ would outlive `foo` itself.\n ~~~~ {.ignore}\n let foo_ptr;\n {\n-    let foo = \"foo\";\n+    let foo = ~\"foo\";\n     foo_ptr = &foo;\n }\n ~~~~\n@@ -1469,7 +1469,7 @@ my_crayons += your_crayons;\n \n ## Strings\n \n-The `str` type in Rust is represented exactly the same way as a unique\n+The `~str` type in Rust is represented exactly the same way as a unique\n vector of immutable bytes (`~[u8]`). This sequence of bytes is\n interpreted as an UTF-8 encoded sequence of characters. This has the\n advantage that UTF-8 encoded I/O (which should really be the default\n@@ -1479,7 +1479,7 @@ disadvantage that you only get constant-time access by byte, not by\n character.\n \n ~~~~\n-let huh = \"what?\";\n+let huh = ~\"what?\";\n let que: u8 = huh[4]; // indexing a string returns a `u8`\n assert que == '?' as u8;\n ~~~~\n@@ -1510,7 +1510,7 @@ brief look at a few common ones.\n # fn unwrap_crayon(c: crayon) -> int { 0 }\n # fn eat_crayon_wax(i: int) { }\n # fn store_crayon_in_nasal_cavity(i: uint, c: crayon) { }\n-# fn crayon_to_str(c: crayon) -> str { \"\" }\n+# fn crayon_to_str(c: crayon) -> ~str { ~\"\" }\n \n let crayons = ~[almond, antique_brass, apricot];\n \n@@ -1571,7 +1571,7 @@ them. In the rare case where the compiler needs assistance though, the\n arguments and return types may be annotated.\n \n ~~~~\n-# type mygoodness = fn(str) -> str; type what_the = int;\n+# type mygoodness = fn(~str) -> ~str; type what_the = int;\n let bloop = |well, oh: mygoodness| -> what_the { fail oh(well) };\n ~~~~\n \n@@ -1611,25 +1611,25 @@ returns it from a function, and then calls it:\n ~~~~\n use std;\n \n-fn mk_appender(suffix: str) -> fn@(str) -> str {\n-    ret fn@(s: str) -> str { s + suffix };\n+fn mk_appender(suffix: ~str) -> fn@(~str) -> ~str {\n+    ret fn@(s: ~str) -> ~str { s + suffix };\n }\n \n fn main() {\n-    let shout = mk_appender(\"!\");\n-    io::println(shout(\"hey ho, let's go\"));\n+    let shout = mk_appender(~\"!\");\n+    io::println(shout(~\"hey ho, let's go\"));\n }\n ~~~~\n \n-This example uses the long closure syntax, `fn@(s: str) ...`,\n+This example uses the long closure syntax, `fn@(s: ~str) ...`,\n making the fact that we are declaring a box closure explicit. In\n practice boxed closures are usually defined with the short closure\n syntax introduced earlier, in which case the compiler will infer\n the type of closure. Thus our boxed closure example could also\n be written:\n \n ~~~~\n-fn mk_appender(suffix: str) -> fn@(str) -> str {\n+fn mk_appender(suffix: ~str) -> fn@(~str) -> ~str {\n     ret |s| s + suffix;\n }\n ~~~~\n@@ -1654,11 +1654,11 @@ that callers have the flexibility to pass whatever they want.\n \n ~~~~\n fn call_twice(f: fn()) { f(); f(); }\n-call_twice(|| { \"I am an inferred stack closure\"; } );\n-call_twice(fn&() { \"I am also a stack closure\"; } );\n-call_twice(fn@() { \"I am a boxed closure\"; });\n-call_twice(fn~() { \"I am a unique closure\"; });\n-fn bare_function() { \"I am a plain function\"; }\n+call_twice(|| { ~\"I am an inferred stack closure\"; } );\n+call_twice(fn&() { ~\"I am also a stack closure\"; } );\n+call_twice(fn@() { ~\"I am a boxed closure\"; });\n+call_twice(fn~() { ~\"I am a unique closure\"; });\n+fn bare_function() { ~\"I am a plain function\"; }\n call_twice(bare_function);\n ~~~~\n \n@@ -1762,7 +1762,7 @@ And using this function to iterate over a vector:\n # import println = io::println;\n each(~[2, 4, 8, 5, 16], |n| {\n     if n % 2 != 0 {\n-        println(\"found odd number!\");\n+        println(~\"found odd number!\");\n         false\n     } else { true }\n });\n@@ -1779,7 +1779,7 @@ to the next iteration, write `again`.\n # import println = io::println;\n for each(~[2, 4, 8, 5, 16]) |n| {\n     if n % 2 != 0 {\n-        println(\"found odd number!\");\n+        println(~\"found odd number!\");\n         break;\n     }\n }\n@@ -1832,7 +1832,7 @@ class example {\n   }\n \n   fn a() {\n-    io::println(\"a\");\n+    io::println(~\"a\");\n   }\n \n   drop {\n@@ -1953,8 +1953,8 @@ being owned by the data structure, so if that can be done without a\n copy, that's a win.\n \n ~~~~\n-type person = {name: str, address: str};\n-fn make_person(+name: str, +address: str) -> person {\n+type person = {name: ~str, address: ~str};\n+fn make_person(+name: ~str, +address: ~str) -> person {\n     ret {name: name, address: address};\n }\n ~~~~\n@@ -2007,7 +2007,7 @@ enum option<T> { some(T), none }\n ~~~~\n \n You can then declare a function to take a `circular_buf<u8>` or return\n-an `option<str>`, or even an `option<T>` if the function itself is\n+an `option<~str>`, or even an `option<T>` if the function itself is\n generic.\n \n The `option` type given above exists in the core library and is the\n@@ -2051,8 +2051,8 @@ take any type of value and output it.\n More interesting is that Rust also defines an ordering for values of\n all datatypes, and allows you to meaningfully apply comparison\n operators (`<`, `>`, `<=`, `>=`, `==`, `!=`) to them. For structural\n-types, the comparison happens left to right, so `\"abc\" < \"bac\"` (but\n-note that `\"bac\" < \"\u00e1c\"`, because the ordering acts on UTF-8 sequences\n+types, the comparison happens left to right, so `~\"abc\" < ~\"bac\"` (but\n+note that `~\"bac\" < ~\"\u00e1c\"`, because the ordering acts on UTF-8 sequences\n without any sophistication).\n \n ## Kinds\n@@ -2135,8 +2135,8 @@ explicitly import it, you must refer to it by its long name,\n \n ~~~~\n mod farm {\n-    fn chicken() -> str { \"cluck cluck\" }\n-    fn cow() -> str { \"mooo\" }\n+    fn chicken() -> ~str { ~\"cluck cluck\" }\n+    fn cow() -> ~str { ~\"mooo\" }\n }\n fn main() {\n     io::println(farm::chicken());\n@@ -2249,14 +2249,14 @@ these two files:\n ~~~~\n // mylib.rs\n #[link(name = \"mylib\", vers = \"1.0\")];\n-fn world() -> str { \"world\" }\n+fn world() -> ~str { ~\"world\" }\n ~~~~\n \n ~~~~ {.ignore}\n // main.rs\n use std;\n use mylib;\n-fn main() { io::println(\"hello \" + mylib::world()); }\n+fn main() { io::println(~\"hello \" + mylib::world()); }\n ~~~~\n \n Now compile and run like this (adjust to your platform if necessary):\n@@ -2279,7 +2279,7 @@ identifiers at the top of a file, module, or block.\n use std;\n import io::println;\n fn main() {\n-    println(\"that was easy\");\n+    println(~\"that was easy\");\n }\n ~~~~\n \n@@ -2345,7 +2345,7 @@ Identifiers can shadow each other. In this program, `x` is of type\n `int`:\n \n ~~~~\n-type t = str;\n+type t = ~str;\n fn main() {\n     type t = int;\n     let x: t;\n@@ -2408,28 +2408,28 @@ can be converted to a string, with a single method of the same name:\n \n ~~~~\n iface to_str {\n-    fn to_str() -> str;\n+    fn to_str() -> ~str;\n }\n ~~~~\n \n ## Implementation\n \n To actually implement an interface for a given type, the `impl` form\n is used. This defines implementations of `to_str` for the `int` and\n-`str` types.\n+`~str` types.\n \n ~~~~\n-# iface to_str { fn to_str() -> str; }\n+# iface to_str { fn to_str() -> ~str; }\n impl of to_str for int {\n-    fn to_str() -> str { int::to_str(self, 10u) }\n+    fn to_str() -> ~str { int::to_str(self, 10u) }\n }\n-impl of to_str for str {\n-    fn to_str() -> str { self }\n+impl of to_str for ~str {\n+    fn to_str() -> ~str { self }\n }\n ~~~~\n \n-Given these, we may call `1.to_str()` to get `\"1\"`, or\n-`\"foo\".to_str()` to get `\"foo\"` again. This is basically a form of\n+Given these, we may call `1.to_str()` to get `~\"1\"`, or\n+`(~\"foo\").to_str()` to get `~\"foo\"` again. This is basically a form of\n static overloading\u2014when the Rust compiler sees the `to_str` method\n call, it looks for an implementation that matches the type with a\n method that matches the name, and simply calls that.\n@@ -2444,9 +2444,9 @@ without problems). Or you can give them an explicit name if you\n prefer, using this syntax:\n \n ~~~~\n-# iface to_str { fn to_str() -> str; }\n+# iface to_str { fn to_str() -> ~str; }\n impl nil_to_str of to_str for () {\n-    fn to_str() -> str { \"()\" }\n+    fn to_str() -> ~str { ~\"()\" }\n }\n ~~~~\n \n@@ -2460,12 +2460,12 @@ known at compile time, it is possible to specify 'bounds' for type\n parameters.\n \n ~~~~\n-# iface to_str { fn to_str() -> str; }\n-fn comma_sep<T: to_str>(elts: ~[T]) -> str {\n-    let mut result = \"\", first = true;\n+# iface to_str { fn to_str() -> ~str; }\n+fn comma_sep<T: to_str>(elts: ~[T]) -> ~str {\n+    let mut result = ~\"\", first = true;\n     for elts.each |elt| {\n         if first { first = false; }\n-        else { result += \", \"; }\n+        else { result += ~\", \"; }\n         result += elt.to_str();\n     }\n     ret result;\n@@ -2576,14 +2576,14 @@ to leave off the `of` clause.\n \n ~~~~\n # type currency = ();\n-# fn mk_currency(x: int, s: str) {}\n+# fn mk_currency(x: int, s: ~str) {}\n impl int_util for int {\n     fn times(b: fn(int)) {\n         let mut i = 0;\n         while i < self { b(i); i += 1; }\n     }\n     fn dollars() -> currency {\n-        mk_currency(self, \"USD\")\n+        mk_currency(self, ~\"USD\")\n     }\n }\n ~~~~\n@@ -2615,20 +2615,20 @@ extern mod crypto {\n     fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n }\n \n-fn as_hex(data: ~[u8]) -> str {\n-    let mut acc = \"\";\n+fn as_hex(data: ~[u8]) -> ~str {\n+    let mut acc = ~\"\";\n     for data.each |byte| { acc += #fmt(\"%02x\", byte as uint); }\n     ret acc;\n }\n \n-fn sha1(data: str) -> str unsafe {\n+fn sha1(data: ~str) -> ~str unsafe {\n     let bytes = str::bytes(data);\n     let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n                             vec::len(bytes), ptr::null());\n     ret as_hex(vec::unsafe::from_buf(hash, 20u));\n }\n \n-fn main(args: ~[str]) {\n+fn main(args: ~[~str]) {\n     io::println(sha1(args[1]));\n }\n ~~~~\n@@ -2719,8 +2719,8 @@ The `sha1` function is the most obscure part of the program.\n \n ~~~~\n # mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n-# fn as_hex(data: ~[u8]) -> str { \"hi\" }\n-fn sha1(data: str) -> str {\n+# fn as_hex(data: ~[u8]) -> ~str { ~\"hi\" }\n+fn sha1(data: ~str) -> ~str {\n     unsafe {\n         let bytes = str::bytes(data);\n         let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n@@ -2746,7 +2746,7 @@ Unsafe blocks isolate unsafety. Unsafe functions, on the other hand,\n advertise it to the world. An unsafe function is written like this:\n \n ~~~~\n-unsafe fn kaboom() { \"I'm harmless!\"; }\n+unsafe fn kaboom() { ~\"I'm harmless!\"; }\n ~~~~\n \n This function can only be called from an unsafe block or another\n@@ -2762,8 +2762,8 @@ Let's look at our `sha1` function again.\n \n ~~~~\n # mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n-# fn as_hex(data: ~[u8]) -> str { \"hi\" }\n-# fn x(data: str) -> str {\n+# fn as_hex(data: ~[u8]) -> ~str { ~\"hi\" }\n+# fn x(data: ~str) -> ~str {\n # unsafe {\n let bytes = str::bytes(data);\n let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n@@ -2816,7 +2816,7 @@ fn unix_time_in_microseconds() -> u64 unsafe {\n     ret (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n }\n \n-# fn main() { assert #fmt(\"%?\", unix_time_in_microseconds()) != \"\"; }\n+# fn main() { assert #fmt(\"%?\", unix_time_in_microseconds()) != ~\"\"; }\n ~~~~\n \n The `#[nolink]` attribute indicates that there's no foreign library to\n@@ -2855,7 +2855,7 @@ import io::println;\n let some_value = 22;\n \n do spawn {\n-    println(\"This executes in the child task.\");\n+    println(~\"This executes in the child task.\");\n     println(#fmt(\"%d\", some_value));\n }\n ~~~~\n@@ -2957,7 +2957,7 @@ Here is the function which implements the child task:\n ~~~~\n # import comm::{port, chan, methods};\n fn stringifier(from_parent: port<uint>,\n-               to_parent: chan<str>) {\n+               to_parent: chan<~str>) {\n     let mut value: uint;\n     loop {\n         value = from_parent.recv();\n@@ -2981,10 +2981,10 @@ Here is the code for the parent task:\n # import task::{spawn_listener};\n # import comm::{chan, port, methods};\n # fn stringifier(from_parent: comm::port<uint>,\n-#                to_parent: comm::chan<str>) {\n-#     comm::send(to_parent, \"22\");\n-#     comm::send(to_parent, \"23\");\n-#     comm::send(to_parent, \"0\");\n+#                to_parent: comm::chan<~str>) {\n+#     comm::send(to_parent, ~\"22\");\n+#     comm::send(to_parent, ~\"23\");\n+#     comm::send(to_parent, ~\"0\");\n # }\n # fn main() {\n \n@@ -2995,13 +2995,13 @@ let to_child = do spawn_listener |from_parent| {\n };\n \n to_child.send(22u);\n-assert from_child.recv() == \"22\";\n+assert from_child.recv() == ~\"22\";\n \n to_child.send(23u);\n-assert from_child.recv() == \"23\";\n+assert from_child.recv() == ~\"23\";\n \n to_child.send(0u);\n-assert from_child.recv() == \"0\";\n+assert from_child.recv() == ~\"0\";\n \n # }\n ~~~~"}, {"sha": "6b9b6c9c39de29fe8112ae51f2ff96b69a5973bb", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 359, "deletions": 352, "changes": 711, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -15,106 +15,106 @@ import json::to_str;\n import getopts::{optflag, optopt, opt_present};\n \n type package = {\n-    name: str,\n-    uuid: str,\n-    url: str,\n-    method: str,\n-    description: str,\n-    ref: option<str>,\n-    tags: ~[str],\n-    versions: ~[(str, str)]\n+    name: ~str,\n+    uuid: ~str,\n+    url: ~str,\n+    method: ~str,\n+    description: ~str,\n+    ref: option<~str>,\n+    tags: ~[~str],\n+    versions: ~[(~str, ~str)]\n };\n \n type local_package = {\n-    name: str,\n-    metaname: str,\n-    version: str,\n-    files: ~[str]\n+    name: ~str,\n+    metaname: ~str,\n+    version: ~str,\n+    files: ~[~str]\n };\n \n type source = @{\n-    name: str,\n-    mut url: str,\n-    mut method: str,\n-    mut key: option<str>,\n-    mut keyfp: option<str>,\n+    name: ~str,\n+    mut url: ~str,\n+    mut method: ~str,\n+    mut key: option<~str>,\n+    mut keyfp: option<~str>,\n     mut packages: ~[mut package]\n };\n \n type cargo = {\n     pgp: bool,\n-    root: str,\n-    installdir: str,\n-    bindir: str,\n-    libdir: str,\n-    workdir: str,\n-    sourcedir: str,\n-    sources: map::hashmap<str, source>,\n-    mut current_install: str,\n-    dep_cache: map::hashmap<str, bool>,\n+    root: ~str,\n+    installdir: ~str,\n+    bindir: ~str,\n+    libdir: ~str,\n+    workdir: ~str,\n+    sourcedir: ~str,\n+    sources: map::hashmap<~str, source>,\n+    mut current_install: ~str,\n+    dep_cache: map::hashmap<~str, bool>,\n     opts: options\n };\n \n type crate = {\n-    name: str,\n-    vers: str,\n-    uuid: str,\n-    desc: option<str>,\n-    sigs: option<str>,\n-    crate_type: option<str>,\n-    deps: ~[str]\n+    name: ~str,\n+    vers: ~str,\n+    uuid: ~str,\n+    desc: option<~str>,\n+    sigs: option<~str>,\n+    crate_type: option<~str>,\n+    deps: ~[~str]\n };\n \n type options = {\n     test: bool,\n     mode: mode,\n-    free: ~[str],\n+    free: ~[~str],\n     help: bool,\n };\n \n enum mode { system_mode, user_mode, local_mode }\n \n fn opts() -> ~[getopts::opt] {\n-    ~[optflag(\"g\"), optflag(\"G\"), optflag(\"test\"),\n-     optflag(\"h\"), optflag(\"help\")]\n+    ~[optflag(~\"g\"), optflag(~\"G\"), optflag(~\"test\"),\n+     optflag(~\"h\"), optflag(~\"help\")]\n }\n \n-fn info(msg: str) {\n+fn info(msg: ~str) {\n     let out = io::stdout();\n \n     if term::color_supported() {\n         term::fg(out, term::color_green);\n-        out.write_str(\"info: \");\n+        out.write_str(~\"info: \");\n         term::reset(out);\n         out.write_line(msg);\n-    } else { out.write_line(\"info: \" + msg); }\n+    } else { out.write_line(~\"info: \" + msg); }\n }\n \n-fn warn(msg: str) {\n+fn warn(msg: ~str) {\n     let out = io::stdout();\n \n     if term::color_supported() {\n         term::fg(out, term::color_yellow);\n-        out.write_str(\"warning: \");\n+        out.write_str(~\"warning: \");\n         term::reset(out);\n         out.write_line(msg);\n-    }else { out.write_line(\"warning: \" + msg); }\n+    }else { out.write_line(~\"warning: \" + msg); }\n }\n \n-fn error(msg: str) {\n+fn error(msg: ~str) {\n     let out = io::stdout();\n \n     if term::color_supported() {\n         term::fg(out, term::color_red);\n-        out.write_str(\"error: \");\n+        out.write_str(~\"error: \");\n         term::reset(out);\n         out.write_line(msg);\n     }\n-    else { out.write_line(\"error: \" + msg); }\n+    else { out.write_line(~\"error: \" + msg); }\n }\n \n-fn is_uuid(id: str) -> bool {\n-    let parts = str::split_str(id, \"-\");\n+fn is_uuid(id: ~str) -> bool {\n+    let parts = str::split_str(id, ~\"-\");\n     if vec::len(parts) == 5u {\n         let mut correct = 0u;\n         for vec::eachi(parts) |i, part| {\n@@ -156,89 +156,89 @@ fn is_uuid(id: str) -> bool {\n \n #[test]\n fn test_is_uuid() {\n-    assert is_uuid(\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaafAF09\");\n-    assert !is_uuid(\"aaaaaaaa-aaaa-aaaa-aaaaa-aaaaaaaaaaaa\");\n-    assert !is_uuid(\"\");\n-    assert !is_uuid(\"aaaaaaaa-aaa -aaaa-aaaa-aaaaaaaaaaaa\");\n-    assert !is_uuid(\"aaaaaaaa-aaa!-aaaa-aaaa-aaaaaaaaaaaa\");\n-    assert !is_uuid(\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa-a\");\n-    assert !is_uuid(\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa\u0e1b\");\n+    assert is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaafAF09\");\n+    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaaa-aaaaaaaaaaaa\");\n+    assert !is_uuid(~\"\");\n+    assert !is_uuid(~\"aaaaaaaa-aaa -aaaa-aaaa-aaaaaaaaaaaa\");\n+    assert !is_uuid(~\"aaaaaaaa-aaa!-aaaa-aaaa-aaaaaaaaaaaa\");\n+    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa-a\");\n+    assert !is_uuid(~\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa\u0e1b\");\n }\n \n // FIXME (#2661): implement url/URL parsing so we don't have to resort\n // to weak checks\n \n-fn has_archive_extension(p: str) -> bool {\n-    str::ends_with(p, \".tar\") ||\n-    str::ends_with(p, \".tar.gz\") ||\n-    str::ends_with(p, \".tar.bz2\") ||\n-    str::ends_with(p, \".tar.Z\") ||\n-    str::ends_with(p, \".tar.lz\") ||\n-    str::ends_with(p, \".tar.xz\") ||\n-    str::ends_with(p, \".tgz\") ||\n-    str::ends_with(p, \".tbz\") ||\n-    str::ends_with(p, \".tbz2\") ||\n-    str::ends_with(p, \".tb2\") ||\n-    str::ends_with(p, \".taz\") ||\n-    str::ends_with(p, \".tlz\") ||\n-    str::ends_with(p, \".txz\")\n-}\n-\n-fn is_archive_path(u: str) -> bool {\n+fn has_archive_extension(p: ~str) -> bool {\n+    str::ends_with(p, ~\".tar\") ||\n+    str::ends_with(p, ~\".tar.gz\") ||\n+    str::ends_with(p, ~\".tar.bz2\") ||\n+    str::ends_with(p, ~\".tar.Z\") ||\n+    str::ends_with(p, ~\".tar.lz\") ||\n+    str::ends_with(p, ~\".tar.xz\") ||\n+    str::ends_with(p, ~\".tgz\") ||\n+    str::ends_with(p, ~\".tbz\") ||\n+    str::ends_with(p, ~\".tbz2\") ||\n+    str::ends_with(p, ~\".tb2\") ||\n+    str::ends_with(p, ~\".taz\") ||\n+    str::ends_with(p, ~\".tlz\") ||\n+    str::ends_with(p, ~\".txz\")\n+}\n+\n+fn is_archive_path(u: ~str) -> bool {\n     has_archive_extension(u) && os::path_exists(u)\n }\n \n-fn is_archive_url(u: str) -> bool {\n+fn is_archive_url(u: ~str) -> bool {\n     // FIXME (#2661): this requires the protocol bit - if we had proper\n     // url parsing, we wouldn't need it\n \n-    alt str::find_str(u, \"://\") {\n+    alt str::find_str(u, ~\"://\") {\n         option::some(i) { has_archive_extension(u) }\n         _ { false }\n     }\n }\n \n-fn is_git_url(url: str) -> bool {\n-    if str::ends_with(url, \"/\") { str::ends_with(url, \".git/\") }\n+fn is_git_url(url: ~str) -> bool {\n+    if str::ends_with(url, ~\"/\") { str::ends_with(url, ~\".git/\") }\n     else {\n-        str::starts_with(url, \"git://\") || str::ends_with(url, \".git\")\n+        str::starts_with(url, ~\"git://\") || str::ends_with(url, ~\".git\")\n     }\n }\n \n-fn assume_source_method(url: str) -> str {\n+fn assume_source_method(url: ~str) -> ~str {\n     if is_git_url(url) {\n-        ret \"git\";\n+        ret ~\"git\";\n     }\n-    if str::starts_with(url, \"file://\") || os::path_exists(url) {\n-        ret \"file\";\n+    if str::starts_with(url, ~\"file://\") || os::path_exists(url) {\n+        ret ~\"file\";\n     }\n \n-    \"curl\"\n+    ~\"curl\"\n }\n \n-fn load_link(mis: ~[@ast::meta_item]) -> (option<str>,\n-                                         option<str>,\n-                                         option<str>) {\n+fn load_link(mis: ~[@ast::meta_item]) -> (option<~str>,\n+                                         option<~str>,\n+                                         option<~str>) {\n     let mut name = none;\n     let mut vers = none;\n     let mut uuid = none;\n     for mis.each |a| {\n         alt a.node {\n             ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) {\n                 alt *v {\n-                    \"name\" { name = some(*s); }\n-                    \"vers\" { vers = some(*s); }\n-                    \"uuid\" { uuid = some(*s); }\n+                    ~\"name\" { name = some(*s); }\n+                    ~\"vers\" { vers = some(*s); }\n+                    ~\"uuid\" { uuid = some(*s); }\n                     _ { }\n                 }\n             }\n-            _ { fail \"load_link: meta items must be name-values\"; }\n+            _ { fail ~\"load_link: meta items must be name-values\"; }\n         }\n     }\n     (name, vers, uuid)\n }\n \n-fn load_crate(filename: str) -> option<crate> {\n+fn load_crate(filename: ~str) -> option<crate> {\n     let sess = parse::new_parse_sess(none);\n     let c = parse::parse_crate_from_crate_file(filename, ~[], sess);\n \n@@ -253,52 +253,53 @@ fn load_crate(filename: str) -> option<crate> {\n         alt a.node.value.node {\n             ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) {\n                 alt *v {\n-                    \"desc\" { desc = some(*v); }\n-                    \"sigs\" { sigs = some(*v); }\n-                    \"crate_type\" { crate_type = some(*v); }\n+                    ~\"desc\" { desc = some(*v); }\n+                    ~\"sigs\" { sigs = some(*v); }\n+                    ~\"crate_type\" { crate_type = some(*v); }\n                     _ { }\n                 }\n             }\n             ast::meta_list(v, mis) {\n-                if *v == \"link\" {\n+                if *v == ~\"link\" {\n                     let (n, v, u) = load_link(mis);\n                     name = n;\n                     vers = v;\n                     uuid = u;\n                 }\n             }\n             _ {\n-                fail \"crate attributes may not contain \" +\n-                     \"meta_words\";\n+                fail ~\"crate attributes may not contain \" +\n+                     ~\"meta_words\";\n             }\n         }\n     }\n \n     type env = @{\n-        mut deps: ~[str]\n+        mut deps: ~[~str]\n     };\n \n     fn goto_view_item(e: env, i: @ast::view_item) {\n         alt i.node {\n             ast::view_item_use(ident, metas, id) {\n-                let name_items = attr::find_meta_items_by_name(metas, \"name\");\n+                let name_items =\n+                    attr::find_meta_items_by_name(metas, ~\"name\");\n                 let m = if name_items.is_empty() {\n-                    metas + ~[attr::mk_name_value_item_str(@\"name\", *ident)]\n+                    metas + ~[attr::mk_name_value_item_str(@~\"name\", *ident)]\n                 } else {\n                     metas\n                 };\n                 let mut attr_name = ident;\n-                let mut attr_vers = \"\";\n-                let mut attr_from = \"\";\n+                let mut attr_vers = ~\"\";\n+                let mut attr_from = ~\"\";\n \n               for m.each |item| {\n                     alt attr::get_meta_item_value_str(item) {\n                         some(value) {\n                             let name = attr::get_meta_item_name(item);\n \n                             alt *name {\n-                                \"vers\" { attr_vers = *value; }\n-                                \"from\" { attr_from = *value; }\n+                                ~\"vers\" { attr_vers = *value; }\n+                                ~\"from\" { attr_from = *value; }\n                                 _ {}\n                             }\n                         }\n@@ -310,12 +311,12 @@ fn load_crate(filename: str) -> option<crate> {\n                     attr_from\n                 } else {\n                     if !str::is_empty(attr_vers) {\n-                        *attr_name + \"@\" + attr_vers\n+                        *attr_name + ~\"@\" + attr_vers\n                     } else { *attr_name }\n                 };\n \n                 alt *attr_name {\n-                    \"std\" | \"core\" { }\n+                    ~\"std\" | ~\"core\" { }\n                     _ { vec::push(e.deps, query); }\n                 }\n             }\n@@ -353,26 +354,26 @@ fn load_crate(filename: str) -> option<crate> {\n     }\n }\n \n-fn print(s: str) {\n+fn print(s: ~str) {\n     io::stdout().write_line(s);\n }\n \n-fn rest(s: str, start: uint) -> str {\n+fn rest(s: ~str, start: uint) -> ~str {\n     if (start >= str::len(s)) {\n-        \"\"\n+        ~\"\"\n     } else {\n         str::slice(s, start, str::len(s))\n     }\n }\n \n-fn need_dir(s: str) {\n+fn need_dir(s: ~str) {\n     if os::path_is_dir(s) { ret; }\n     if !os::make_dir(s, 493_i32 /* oct: 755 */) {\n         fail #fmt[\"can't make_dir %s\", s];\n     }\n }\n \n-fn valid_pkg_name(s: str) -> bool {\n+fn valid_pkg_name(s: ~str) -> bool {\n     fn is_valid_digit(c: char) -> bool {\n         ('0' <= c && c <= '9') ||\n         ('a' <= c && c <= 'z') ||\n@@ -384,38 +385,38 @@ fn valid_pkg_name(s: str) -> bool {\n     s.all(is_valid_digit)\n }\n \n-fn parse_source(name: str, j: json::json) -> source {\n+fn parse_source(name: ~str, j: json::json) -> source {\n     if !valid_pkg_name(name) {\n         fail #fmt(\"'%s' is an invalid source name\", name);\n     }\n \n     alt j {\n         json::dict(j) {\n-            let mut url = alt j.find(\"url\") {\n+            let mut url = alt j.find(~\"url\") {\n                 some(json::string(u)) {\n                     *u\n                 }\n-                _ { fail \"needed 'url' field in source\"; }\n+                _ { fail ~\"needed 'url' field in source\"; }\n             };\n-            let method = alt j.find(\"method\") {\n+            let method = alt j.find(~\"method\") {\n                 some(json::string(u)) {\n                     *u\n                 }\n                 _ { assume_source_method(url) }\n             };\n-            let key = alt j.find(\"key\") {\n+            let key = alt j.find(~\"key\") {\n                 some(json::string(u)) {\n                     some(*u)\n                 }\n                 _ { none }\n             };\n-            let keyfp = alt j.find(\"keyfp\") {\n+            let keyfp = alt j.find(~\"keyfp\") {\n                 some(json::string(u)) {\n                     some(*u)\n                 }\n                 _ { none }\n             };\n-            if method == \"file\" {\n+            if method == ~\"file\" {\n                 url = os::make_absolute(url);\n             }\n             ret @{\n@@ -426,11 +427,11 @@ fn parse_source(name: str, j: json::json) -> source {\n                 mut keyfp: keyfp,\n                 mut packages: ~[mut] };\n         }\n-        _ { fail \"needed dict value in source\"; }\n+        _ { fail ~\"needed dict value in source\"; }\n     };\n }\n \n-fn try_parse_sources(filename: str, sources: map::hashmap<str, source>) {\n+fn try_parse_sources(filename: ~str, sources: map::hashmap<~str, source>) {\n     if !os::path_exists(filename)  { ret; }\n     let c = io::read_whole_file_str(filename);\n     alt json::from_str(result::get(c)) {\n@@ -440,66 +441,69 @@ fn try_parse_sources(filename: str, sources: map::hashmap<str, source>) {\n                 #debug(\"source: %s\", k);\n             }\n         }\n-        ok(_) { fail \"malformed sources.json\"; }\n+        ok(_) { fail ~\"malformed sources.json\"; }\n         err(e) { fail #fmt(\"%s:%s\", filename, e.to_str()); }\n     }\n }\n \n-fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n-    let name = alt p.find(\"name\") {\n+fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n+    let name = alt p.find(~\"name\") {\n         some(json::string(n)) {\n             if !valid_pkg_name(*n) {\n-                warn(\"malformed source json: \" + src.name + \", '\" + *n + \"'\"+\n-                     \" is an invalid name (alphanumeric, underscores and\" +\n-                     \" dashes only)\");\n+                warn(~\"malformed source json: \"\n+                     + src.name + ~\", '\" + *n + ~\"'\"+\n+                     ~\" is an invalid name (alphanumeric, underscores and\" +\n+                     ~\" dashes only)\");\n                 ret;\n             }\n             *n\n         }\n         _ {\n-            warn(\"malformed source json: \" + src.name + \" (missing name)\");\n+            warn(~\"malformed source json: \" + src.name + ~\" (missing name)\");\n             ret;\n         }\n     };\n \n-    let uuid = alt p.find(\"uuid\") {\n+    let uuid = alt p.find(~\"uuid\") {\n         some(json::string(n)) {\n             if !is_uuid(*n) {\n-                warn(\"malformed source json: \" + src.name + \", '\" + *n + \"'\"+\n-                     \" is an invalid uuid\");\n+                warn(~\"malformed source json: \"\n+                     + src.name + ~\", '\" + *n + ~\"'\"+\n+                     ~\" is an invalid uuid\");\n                 ret;\n             }\n             *n\n         }\n         _ {\n-            warn(\"malformed source json: \" + src.name + \" (missing uuid)\");\n+            warn(~\"malformed source json: \" + src.name + ~\" (missing uuid)\");\n             ret;\n         }\n     };\n \n-    let url = alt p.find(\"url\") {\n+    let url = alt p.find(~\"url\") {\n         some(json::string(n)) { *n }\n         _ {\n-            warn(\"malformed source json: \" + src.name + \" (missing url)\");\n+            warn(~\"malformed source json: \" + src.name + ~\" (missing url)\");\n             ret;\n         }\n     };\n \n-    let method = alt p.find(\"method\") {\n+    let method = alt p.find(~\"method\") {\n         some(json::string(n)) { *n }\n         _ {\n-            warn(\"malformed source json: \" + src.name + \" (missing method)\");\n+            warn(~\"malformed source json: \"\n+                 + src.name + ~\" (missing method)\");\n             ret;\n         }\n     };\n \n-    let ref = alt p.find(\"ref\") {\n+    let ref = alt p.find(~\"ref\") {\n         some(json::string(n)) { some(*n) }\n         _ { none }\n     };\n \n     let mut tags = ~[];\n-    alt p.find(\"tags\") {\n+    alt p.find(~\"tags\") {\n         some(json::list(js)) {\n           for (*js).each |j| {\n                 alt j {\n@@ -511,11 +515,11 @@ fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n         _ { }\n     }\n \n-    let description = alt p.find(\"description\") {\n+    let description = alt p.find(~\"description\") {\n         some(json::string(n)) { *n }\n         _ {\n-            warn(\"malformed source json: \" + src.name\n-                 + \" (missing description)\");\n+            warn(~\"malformed source json: \" + src.name\n+                 + ~\" (missing description)\");\n             ret;\n         }\n     };\n@@ -534,19 +538,19 @@ fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n     alt src.packages.position(|pkg| pkg.uuid == uuid ) {\n       some(idx) {\n         src.packages[idx] = newpkg;\n-        log(debug, \"  updated package: \" + src.name + \"/\" + name);\n+        log(debug, ~\"  updated package: \" + src.name + ~\"/\" + name);\n       }\n       none {\n         vec::grow(src.packages, 1u, newpkg);\n       }\n     }\n \n-    log(debug, \"  loaded package: \" + src.name + \"/\" + name);\n+    log(debug, ~\"  loaded package: \" + src.name + ~\"/\" + name);\n }\n \n fn load_source_info(c: cargo, src: source) {\n     let dir = path::connect(c.sourcedir, src.name);\n-    let srcfile = path::connect(dir, \"source.json\");\n+    let srcfile = path::connect(dir, ~\"source.json\");\n     if !os::path_exists(srcfile) { ret; }\n     let srcstr = io::read_whole_file_str(srcfile);\n     alt json::from_str(result::get(srcstr)) {\n@@ -557,18 +561,18 @@ fn load_source_info(c: cargo, src: source) {\n             src.keyfp = o.keyfp;\n         }\n         ok(_) {\n-            warn(\"malformed source.json: \" + src.name +\n-                 \"(source info is not a dict)\");\n+            warn(~\"malformed source.json: \" + src.name +\n+                 ~\"(source info is not a dict)\");\n         }\n         err(e) {\n             warn(#fmt(\"%s:%s\", src.name, e.to_str()));\n         }\n     };\n }\n fn load_source_packages(c: cargo, src: source) {\n-    log(debug, \"loading source: \" + src.name);\n+    log(debug, ~\"loading source: \" + src.name);\n     let dir = path::connect(c.sourcedir, src.name);\n-    let pkgfile = path::connect(dir, \"packages.json\");\n+    let pkgfile = path::connect(dir, ~\"packages.json\");\n     if !os::path_exists(pkgfile) { ret; }\n     let pkgstr = io::read_whole_file_str(pkgfile);\n     alt json::from_str(result::get(pkgstr)) {\n@@ -579,43 +583,43 @@ fn load_source_packages(c: cargo, src: source) {\n                         load_one_source_package(src, p);\n                     }\n                     _ {\n-                        warn(\"malformed source json: \" + src.name +\n-                             \" (non-dict pkg)\");\n+                        warn(~\"malformed source json: \" + src.name +\n+                             ~\" (non-dict pkg)\");\n                     }\n                 }\n             }\n         }\n         ok(_) {\n-            warn(\"malformed packages.json: \" + src.name +\n-                 \"(packages is not a list)\");\n+            warn(~\"malformed packages.json: \" + src.name +\n+                 ~\"(packages is not a list)\");\n         }\n         err(e) {\n             warn(#fmt(\"%s:%s\", src.name, e.to_str()));\n         }\n     };\n }\n \n-fn build_cargo_options(argv: ~[str]) -> options {\n+fn build_cargo_options(argv: ~[~str]) -> options {\n     let match = alt getopts::getopts(argv, opts()) {\n         result::ok(m) { m }\n         result::err(f) {\n             fail #fmt[\"%s\", getopts::fail_str(f)];\n         }\n     };\n \n-    let test = opt_present(match, \"test\");\n-    let G    = opt_present(match, \"G\");\n-    let g    = opt_present(match, \"g\");\n-    let help = opt_present(match, \"h\") || opt_present(match, \"help\");\n+    let test = opt_present(match, ~\"test\");\n+    let G    = opt_present(match, ~\"G\");\n+    let g    = opt_present(match, ~\"g\");\n+    let help = opt_present(match, ~\"h\") || opt_present(match, ~\"help\");\n     let len  = vec::len(match.free);\n \n-    let is_install = len > 1u && match.free[1] == \"install\";\n-    let is_uninstall = len > 1u && match.free[1] == \"uninstall\";\n+    let is_install = len > 1u && match.free[1] == ~\"install\";\n+    let is_uninstall = len > 1u && match.free[1] == ~\"uninstall\";\n \n-    if G && g { fail \"-G and -g both provided\"; }\n+    if G && g { fail ~\"-G and -g both provided\"; }\n \n     if !is_install && !is_uninstall && (g || G) {\n-        fail \"-g and -G are only valid for `install` and `uninstall|rm`\";\n+        fail ~\"-g and -G are only valid for `install` and `uninstall|rm`\";\n     }\n \n     let mode =\n@@ -641,21 +645,21 @@ fn configure(opts: options) -> cargo {\n     let p = result::get(get_cargo_dir());\n \n     let sources = map::str_hash();\n-    try_parse_sources(path::connect(home, \"sources.json\"), sources);\n-    try_parse_sources(path::connect(home, \"local-sources.json\"), sources);\n+    try_parse_sources(path::connect(home, ~\"sources.json\"), sources);\n+    try_parse_sources(path::connect(home, ~\"local-sources.json\"), sources);\n \n     let dep_cache = map::str_hash();\n \n     let mut c = {\n         pgp: pgp::supported(),\n         root: home,\n         installdir: p,\n-        bindir: path::connect(p, \"bin\"),\n-        libdir: path::connect(p, \"lib\"),\n-        workdir: path::connect(p, \"work\"),\n-        sourcedir: path::connect(home, \"sources\"),\n+        bindir: path::connect(p, ~\"bin\"),\n+        libdir: path::connect(p, ~\"lib\"),\n+        workdir: path::connect(p, ~\"work\"),\n+        sourcedir: path::connect(home, ~\"sources\"),\n         sources: sources,\n-        mut current_install: \"\",\n+        mut current_install: ~\"\",\n         dep_cache: dep_cache,\n         opts: opts\n     };\n@@ -676,9 +680,9 @@ fn configure(opts: options) -> cargo {\n     if c.pgp {\n         pgp::init(c.root);\n     } else {\n-        warn(\"command `gpg` was not found\");\n-        warn(\"you have to install gpg from source \" +\n-             \" or package manager to get it to work correctly\");\n+        warn(~\"command `gpg` was not found\");\n+        warn(~\"you have to install gpg from source \" +\n+             ~\" or package manager to get it to work correctly\");\n     }\n \n     c\n@@ -696,7 +700,7 @@ fn for_each_package(c: cargo, b: fn(source, package)) {\n }\n \n // Runs all programs in directory <buildpath>\n-fn run_programs(buildpath: str) {\n+fn run_programs(buildpath: ~str) {\n     let newv = os::list_dir_path(buildpath);\n     for newv.each |ct| {\n         run::run_program(ct, ~[]);\n@@ -705,41 +709,41 @@ fn run_programs(buildpath: str) {\n \n // Runs rustc in <path + subdir> with the given flags\n // and returns <path + subdir>\n-fn run_in_buildpath(what: str, path: str, subdir: str, cf: str,\n-                    extra_flags: ~[str]) -> option<str> {\n+fn run_in_buildpath(what: ~str, path: ~str, subdir: ~str, cf: ~str,\n+                    extra_flags: ~[~str]) -> option<~str> {\n     let buildpath = path::connect(path, subdir);\n     need_dir(buildpath);\n     #debug(\"%s: %s -> %s\", what, cf, buildpath);\n     let p = run::program_output(rustc_sysroot(),\n-                                ~[\"--out-dir\", buildpath, cf] + extra_flags);\n+                                ~[~\"--out-dir\", buildpath, cf] + extra_flags);\n     if p.status != 0 {\n         error(#fmt[\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out]);\n         ret none;\n     }\n     some(buildpath)\n }\n \n-fn test_one_crate(_c: cargo, path: str, cf: str) {\n-  let buildpath = alt run_in_buildpath(\"testing\", path, \"/test\", cf,\n-                                       ~[ \"--test\"]) {\n+fn test_one_crate(_c: cargo, path: ~str, cf: ~str) {\n+  let buildpath = alt run_in_buildpath(~\"testing\", path, ~\"/test\", cf,\n+                                       ~[ ~\"--test\"]) {\n       none { ret; }\n       some(bp) { bp }\n   };\n   run_programs(buildpath);\n }\n \n-fn install_one_crate(c: cargo, path: str, cf: str) {\n-    let buildpath = alt run_in_buildpath(\"installing\", path,\n-                                         \"/build\", cf, ~[]) {\n+fn install_one_crate(c: cargo, path: ~str, cf: ~str) {\n+    let buildpath = alt run_in_buildpath(~\"installing\", path,\n+                                         ~\"/build\", cf, ~[]) {\n       none { ret; }\n       some(bp) { bp }\n     };\n     let newv = os::list_dir_path(buildpath);\n     let exec_suffix = os::exe_suffix();\n     for newv.each |ct| {\n-        if (exec_suffix != \"\" && str::ends_with(ct, exec_suffix)) ||\n-            (exec_suffix == \"\" && !str::starts_with(path::basename(ct),\n-                                                    \"lib\")) {\n+        if (exec_suffix != ~\"\" && str::ends_with(ct, exec_suffix)) ||\n+            (exec_suffix == ~\"\" && !str::starts_with(path::basename(ct),\n+                                                    ~\"lib\")) {\n             #debug(\"  bin: %s\", ct);\n             install_to_dir(ct, c.bindir);\n             if c.opts.mode == system_mode {\n@@ -755,32 +759,32 @@ fn install_one_crate(c: cargo, path: str, cf: str) {\n }\n \n \n-fn rustc_sysroot() -> str {\n+fn rustc_sysroot() -> ~str {\n     alt os::self_exe_path() {\n         some(path) {\n-            let path = ~[path, \"..\", \"bin\", \"rustc\"];\n+            let path = ~[path, ~\"..\", ~\"bin\", ~\"rustc\"];\n             check vec::is_not_empty(path);\n             let rustc = path::normalize(path::connect_many(path));\n             #debug(\"  rustc: %s\", rustc);\n             rustc\n         }\n-        none { \"rustc\" }\n+        none { ~\"rustc\" }\n     }\n }\n \n-fn install_source(c: cargo, path: str) {\n+fn install_source(c: cargo, path: ~str) {\n     #debug(\"source: %s\", path);\n     os::change_dir(path);\n \n     let mut cratefiles = ~[];\n-    for os::walk_dir(\".\") |p| {\n-        if str::ends_with(p, \".rc\") {\n+    for os::walk_dir(~\".\") |p| {\n+        if str::ends_with(p, ~\".rc\") {\n             vec::push(cratefiles, p);\n         }\n     }\n \n     if vec::is_empty(cratefiles) {\n-        fail \"this doesn't look like a rust package (no .rc files)\";\n+        fail ~\"this doesn't look like a rust package (no .rc files)\";\n     }\n \n     for cratefiles.each |cf| {\n@@ -793,7 +797,7 @@ fn install_source(c: cargo, path: str) {\n                     // condition\")\n \n                     let wd_base = c.workdir + path::path_sep();\n-                    let wd = alt tempfile::mkdtemp(wd_base, \"\") {\n+                    let wd = alt tempfile::mkdtemp(wd_base, ~\"\") {\n                         some(wd) { wd }\n                         none { fail #fmt(\"needed temp dir: %s\", wd_base); }\n                     };\n@@ -812,64 +816,64 @@ fn install_source(c: cargo, path: str) {\n     }\n }\n \n-fn install_git(c: cargo, wd: str, url: str, ref: option<str>) {\n-    run::program_output(\"git\", ~[\"clone\", url, wd]);\n+fn install_git(c: cargo, wd: ~str, url: ~str, ref: option<~str>) {\n+    run::program_output(~\"git\", ~[~\"clone\", url, wd]);\n     if option::is_some(ref) {\n         let r = option::get(ref);\n         os::change_dir(wd);\n-        run::run_program(\"git\", ~[\"checkout\", r]);\n+        run::run_program(~\"git\", ~[~\"checkout\", r]);\n     }\n \n     install_source(c, wd);\n }\n \n-fn install_curl(c: cargo, wd: str, url: str) {\n-    let tarpath = path::connect(wd, \"pkg.tar\");\n-    let p = run::program_output(\"curl\", ~[\"-f\", \"-s\", \"-o\",\n+fn install_curl(c: cargo, wd: ~str, url: ~str) {\n+    let tarpath = path::connect(wd, ~\"pkg.tar\");\n+    let p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n                                          tarpath, url]);\n     if p.status != 0 {\n         fail #fmt[\"fetch of %s failed: %s\", url, p.err];\n     }\n-    run::run_program(\"tar\", ~[\"-x\", \"--strip-components=1\",\n-                             \"-C\", wd, \"-f\", tarpath]);\n+    run::run_program(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n+                             ~\"-C\", wd, ~\"-f\", tarpath]);\n     install_source(c, wd);\n }\n \n-fn install_file(c: cargo, wd: str, path: str) {\n-    run::program_output(\"tar\", ~[\"-x\", \"--strip-components=1\",\n-                             \"-C\", wd, \"-f\", path]);\n+fn install_file(c: cargo, wd: ~str, path: ~str) {\n+    run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n+                             ~\"-C\", wd, ~\"-f\", path]);\n     install_source(c, wd);\n }\n \n-fn install_package(c: cargo, src: str, wd: str, pkg: package) {\n+fn install_package(c: cargo, src: ~str, wd: ~str, pkg: package) {\n     let url = copy pkg.url;\n     let method = alt pkg.method {\n-        \"git\" { \"git\" }\n-        \"file\" { \"file\" }\n-        _ { \"curl\" }\n+        ~\"git\" { ~\"git\" }\n+        ~\"file\" { ~\"file\" }\n+        _ { ~\"curl\" }\n     };\n \n     info(#fmt[\"installing %s/%s via %s...\", src, pkg.name, method]);\n \n     alt method {\n-        \"git\" { install_git(c, wd, url, copy pkg.ref); }\n-        \"file\" { install_file(c, wd, url); }\n-        \"curl\" { install_curl(c, wd, copy url); }\n+        ~\"git\" { install_git(c, wd, url, copy pkg.ref); }\n+        ~\"file\" { install_file(c, wd, url); }\n+        ~\"curl\" { install_curl(c, wd, copy url); }\n         _ {}\n     }\n }\n \n fn cargo_suggestion(c: cargo, fallback: fn())\n {\n     if c.sources.size() == 0u {\n-        error(\"no sources defined - you may wish to run \" +\n-              \"`cargo init`\");\n+        error(~\"no sources defined - you may wish to run \" +\n+              ~\"`cargo init`\");\n         ret;\n     }\n     fallback();\n }\n \n-fn install_uuid(c: cargo, wd: str, uuid: str) {\n+fn install_uuid(c: cargo, wd: ~str, uuid: ~str) {\n     let mut ps = ~[];\n     for_each_package(c, |s, p| {\n         if p.uuid == uuid {\n@@ -882,18 +886,18 @@ fn install_uuid(c: cargo, wd: str, uuid: str) {\n         ret;\n     } else if vec::len(ps) == 0u {\n         cargo_suggestion(c, || {\n-            error(\"can't find package: \" + uuid);\n+            error(~\"can't find package: \" + uuid);\n         });\n         ret;\n     }\n-    error(\"found multiple packages:\");\n+    error(~\"found multiple packages:\");\n     for ps.each |elt| {\n         let (sname,p) = copy elt;\n-        info(\"  \" + sname + \"/\" + p.uuid + \" (\" + p.name + \")\");\n+        info(~\"  \" + sname + ~\"/\" + p.uuid + ~\" (\" + p.name + ~\")\");\n     }\n }\n \n-fn install_named(c: cargo, wd: str, name: str) {\n+fn install_named(c: cargo, wd: ~str, name: ~str) {\n     let mut ps = ~[];\n     for_each_package(c, |s, p| {\n         if p.name == name {\n@@ -906,18 +910,18 @@ fn install_named(c: cargo, wd: str, name: str) {\n         ret;\n     } else if vec::len(ps) == 0u {\n         cargo_suggestion(c, || {\n-            error(\"can't find package: \" + name);\n+            error(~\"can't find package: \" + name);\n         });\n         ret;\n     }\n-    error(\"found multiple packages:\");\n+    error(~\"found multiple packages:\");\n     for ps.each |elt| {\n         let (sname,p) = copy elt;\n-        info(\"  \" + sname + \"/\" + p.uuid + \" (\" + p.name + \")\");\n+        info(~\"  \" + sname + ~\"/\" + p.uuid + ~\" (\" + p.name + ~\")\");\n     }\n }\n \n-fn install_uuid_specific(c: cargo, wd: str, src: str, uuid: str) {\n+fn install_uuid_specific(c: cargo, wd: ~str, src: ~str, uuid: ~str) {\n     alt c.sources.find(src) {\n       some(s) {\n         let packages = copy s.packages;\n@@ -930,10 +934,10 @@ fn install_uuid_specific(c: cargo, wd: str, src: str, uuid: str) {\n       }\n       _ { }\n     }\n-    error(\"can't find package: \" + src + \"/\" + uuid);\n+    error(~\"can't find package: \" + src + ~\"/\" + uuid);\n }\n \n-fn install_named_specific(c: cargo, wd: str, src: str, name: str) {\n+fn install_named_specific(c: cargo, wd: ~str, src: ~str, name: ~str) {\n     alt c.sources.find(src) {\n         some(s) {\n           let packages = copy s.packages;\n@@ -946,7 +950,7 @@ fn install_named_specific(c: cargo, wd: str, src: str, name: str) {\n         }\n         _ { }\n     }\n-    error(\"can't find package: \" + src + \"/\" + name);\n+    error(~\"can't find package: \" + src + ~\"/\" + name);\n }\n \n fn cmd_uninstall(c: cargo) {\n@@ -965,31 +969,31 @@ fn cmd_uninstall(c: cargo) {\n     // name only)\n     if is_uuid(target) {\n         for os::list_dir(lib).each |file| {\n-            alt str::find_str(file, \"-\" + target + \"-\") {\n+            alt str::find_str(file, ~\"-\" + target + ~\"-\") {\n                 some(idx) {\n                     let full = path::normalize(path::connect(lib, file));\n                     if os::remove_file(full) {\n-                        info(\"uninstalled: '\" + full + \"'\");\n+                        info(~\"uninstalled: '\" + full + ~\"'\");\n                     } else {\n-                        error(\"could not uninstall: '\" + full + \"'\");\n+                        error(~\"could not uninstall: '\" + full + ~\"'\");\n                     }\n                     ret;\n                 }\n                 none { again; }\n             }\n         }\n \n-        error(\"can't find package with uuid: \" + target);\n+        error(~\"can't find package with uuid: \" + target);\n     } else {\n         for os::list_dir(lib).each |file| {\n-            alt str::find_str(file, \"lib\" + target + \"-\") {\n+            alt str::find_str(file, ~\"lib\" + target + ~\"-\") {\n                 some(idx) {\n                     let full = path::normalize(path::connect(lib,\n                                file));\n                     if os::remove_file(full) {\n-                        info(\"uninstalled: '\" + full + \"'\");\n+                        info(~\"uninstalled: '\" + full + ~\"'\");\n                     } else {\n-                        error(\"could not uninstall: '\" + full + \"'\");\n+                        error(~\"could not uninstall: '\" + full + ~\"'\");\n                     }\n                     ret;\n                 }\n@@ -1001,21 +1005,21 @@ fn cmd_uninstall(c: cargo) {\n                 some(idx) {\n                     let full = path::normalize(path::connect(bin, file));\n                     if os::remove_file(full) {\n-                        info(\"uninstalled: '\" + full + \"'\");\n+                        info(~\"uninstalled: '\" + full + ~\"'\");\n                     } else {\n-                        error(\"could not uninstall: '\" + full + \"'\");\n+                        error(~\"could not uninstall: '\" + full + ~\"'\");\n                     }\n                     ret;\n                 }\n                 none { again; }\n             }\n         }\n \n-        error(\"can't find package with name: \" + target);\n+        error(~\"can't find package with name: \" + target);\n     }\n }\n \n-fn install_query(c: cargo, wd: str, target: str) {\n+fn install_query(c: cargo, wd: ~str, target: ~str) {\n     alt c.dep_cache.find(target) {\n         some(inst) {\n             if inst {\n@@ -1071,20 +1075,20 @@ fn install_query(c: cargo, wd: str, target: str) {\n             c.dep_cache.remove(k);\n         }\n \n-        c.current_install = \"\";\n+        c.current_install = ~\"\";\n     }\n }\n \n fn cmd_install(c: cargo) unsafe {\n     let wd_base = c.workdir + path::path_sep();\n-    let wd = alt tempfile::mkdtemp(wd_base, \"\") {\n+    let wd = alt tempfile::mkdtemp(wd_base, ~\"\") {\n         some(wd) { wd }\n         none { fail #fmt(\"needed temp dir: %s\", wd_base); }\n     };\n \n     if vec::len(c.opts.free) == 2u {\n         let cwd = os::getcwd();\n-        let status = run::run_program(\"cp\", ~[\"-R\", cwd, wd]);\n+        let status = run::run_program(~\"cp\", ~[~\"-R\", cwd, wd]);\n \n         if status != 0 {\n             fail #fmt(\"could not copy directory: %s\", cwd);\n@@ -1110,34 +1114,34 @@ fn sync(c: cargo) {\n     }\n }\n \n-fn sync_one_file(c: cargo, dir: str, src: source) -> bool {\n+fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n     let name = src.name;\n-    let srcfile = path::connect(dir, \"source.json.new\");\n-    let destsrcfile = path::connect(dir, \"source.json\");\n-    let pkgfile = path::connect(dir, \"packages.json.new\");\n-    let destpkgfile = path::connect(dir, \"packages.json\");\n-    let keyfile = path::connect(dir, \"key.gpg\");\n-    let srcsigfile = path::connect(dir, \"source.json.sig\");\n-    let sigfile = path::connect(dir, \"packages.json.sig\");\n+    let srcfile = path::connect(dir, ~\"source.json.new\");\n+    let destsrcfile = path::connect(dir, ~\"source.json\");\n+    let pkgfile = path::connect(dir, ~\"packages.json.new\");\n+    let destpkgfile = path::connect(dir, ~\"packages.json\");\n+    let keyfile = path::connect(dir, ~\"key.gpg\");\n+    let srcsigfile = path::connect(dir, ~\"source.json.sig\");\n+    let sigfile = path::connect(dir, ~\"packages.json.sig\");\n     let url = src.url;\n     let mut has_src_file = false;\n \n-    if !os::copy_file(path::connect(url, \"packages.json\"), pkgfile) {\n+    if !os::copy_file(path::connect(url, ~\"packages.json\"), pkgfile) {\n         error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n         ret false;\n     }\n \n-    if os::copy_file(path::connect(url, \"source.json\"), srcfile) {\n+    if os::copy_file(path::connect(url, ~\"source.json\"), srcfile) {\n         has_src_file = false;\n     }\n \n-    os::copy_file(path::connect(url, \"source.json.sig\"), srcsigfile);\n-    os::copy_file(path::connect(url, \"packages.json.sig\"), sigfile);\n+    os::copy_file(path::connect(url, ~\"source.json.sig\"), srcsigfile);\n+    os::copy_file(path::connect(url, ~\"packages.json.sig\"), sigfile);\n \n     alt copy src.key {\n         some(u) {\n-            let p = run::program_output(\"curl\",  ~[\"-f\", \"-s\", \"-o\", keyfile,\n-                                                  u]);\n+            let p = run::program_output(~\"curl\",\n+                                        ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n             if p.status != 0 {\n                 error(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n                 ret false;\n@@ -1186,41 +1190,41 @@ fn sync_one_file(c: cargo, dir: str, src: source) -> bool {\n     ret true;\n }\n \n-fn sync_one_git(c: cargo, dir: str, src: source) -> bool {\n+fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n     let name = src.name;\n-    let srcfile = path::connect(dir, \"source.json\");\n-    let pkgfile = path::connect(dir, \"packages.json\");\n-    let keyfile = path::connect(dir, \"key.gpg\");\n-    let srcsigfile = path::connect(dir, \"source.json.sig\");\n-    let sigfile = path::connect(dir, \"packages.json.sig\");\n+    let srcfile = path::connect(dir, ~\"source.json\");\n+    let pkgfile = path::connect(dir, ~\"packages.json\");\n+    let keyfile = path::connect(dir, ~\"key.gpg\");\n+    let srcsigfile = path::connect(dir, ~\"source.json.sig\");\n+    let sigfile = path::connect(dir, ~\"packages.json.sig\");\n     let url = src.url;\n \n-    fn rollback(name: str, dir: str, insecure: bool) {\n-        fn msg(name: str, insecure: bool) {\n+    fn rollback(name: ~str, dir: ~str, insecure: bool) {\n+        fn msg(name: ~str, insecure: bool) {\n             error(#fmt[\"could not rollback source: %s\", name]);\n \n             if insecure {\n-                warn(\"a past security check failed on source \" +\n-                     name + \" and rolling back the source failed -\"\n-                     + \" this source may be compromised\");\n+                warn(~\"a past security check failed on source \" +\n+                     name + ~\" and rolling back the source failed -\"\n+                     + ~\" this source may be compromised\");\n             }\n         }\n \n         if !os::change_dir(dir) {\n             msg(name, insecure);\n         }\n         else {\n-            let p = run::program_output(\"git\", ~[\"reset\", \"--hard\",\n-                                                \"HEAD@{1}\"]);\n+            let p = run::program_output(~\"git\", ~[~\"reset\", ~\"--hard\",\n+                                                ~\"HEAD@{1}\"]);\n \n             if p.status != 0 {\n                 msg(name, insecure);\n             }\n         }\n     }\n \n-    if !os::path_exists(path::connect(dir, \".git\")) {\n-        let p = run::program_output(\"git\", ~[\"clone\", url, dir]);\n+    if !os::path_exists(path::connect(dir, ~\".git\")) {\n+        let p = run::program_output(~\"git\", ~[~\"clone\", url, dir]);\n \n         if p.status != 0 {\n             error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n@@ -1233,7 +1237,7 @@ fn sync_one_git(c: cargo, dir: str, src: source) -> bool {\n             ret false;\n         }\n \n-        let p = run::program_output(\"git\", ~[\"pull\"]);\n+        let p = run::program_output(~\"git\", ~[~\"pull\"]);\n \n         if p.status != 0 {\n             error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n@@ -1245,8 +1249,8 @@ fn sync_one_git(c: cargo, dir: str, src: source) -> bool {\n \n     alt copy src.key {\n         some(u) {\n-            let p = run::program_output(\"curl\",  ~[\"-f\", \"-s\", \"-o\", keyfile,\n-                                                  u]);\n+            let p = run::program_output(~\"curl\",\n+                                        ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n             if p.status != 0 {\n                 error(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n                 rollback(name, dir, false);\n@@ -1288,33 +1292,35 @@ fn sync_one_git(c: cargo, dir: str, src: source) -> bool {\n     ret true;\n }\n \n-fn sync_one_curl(c: cargo, dir: str, src: source) -> bool {\n+fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n     let name = src.name;\n-    let srcfile = path::connect(dir, \"source.json.new\");\n-    let destsrcfile = path::connect(dir, \"source.json\");\n-    let pkgfile = path::connect(dir, \"packages.json.new\");\n-    let destpkgfile = path::connect(dir, \"packages.json\");\n-    let keyfile = path::connect(dir, \"key.gpg\");\n-    let srcsigfile = path::connect(dir, \"source.json.sig\");\n-    let sigfile = path::connect(dir, \"packages.json.sig\");\n+    let srcfile = path::connect(dir, ~\"source.json.new\");\n+    let destsrcfile = path::connect(dir, ~\"source.json\");\n+    let pkgfile = path::connect(dir, ~\"packages.json.new\");\n+    let destpkgfile = path::connect(dir, ~\"packages.json\");\n+    let keyfile = path::connect(dir, ~\"key.gpg\");\n+    let srcsigfile = path::connect(dir, ~\"source.json.sig\");\n+    let sigfile = path::connect(dir, ~\"packages.json.sig\");\n     let mut url = src.url;\n-    let smart = !str::ends_with(src.url, \"packages.json\");\n+    let smart = !str::ends_with(src.url, ~\"packages.json\");\n     let mut has_src_file = false;\n \n     if smart {\n-        url += \"/packages.json\";\n+        url += ~\"/packages.json\";\n     }\n \n-    let p = run::program_output(\"curl\", ~[\"-f\", \"-s\", \"-o\", pkgfile, url]);\n+    let p = run::program_output(~\"curl\",\n+                                ~[~\"-f\", ~\"-s\", ~\"-o\", pkgfile, url]);\n \n     if p.status != 0 {\n         error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n         ret false;\n     }\n     if smart {\n-        url = src.url + \"/source.json\";\n+        url = src.url + ~\"/source.json\";\n         let p =\n-            run::program_output(\"curl\", ~[\"-f\", \"-s\", \"-o\", srcfile, url]);\n+            run::program_output(~\"curl\",\n+                                ~[~\"-f\", ~\"-s\", ~\"-o\", srcfile, url]);\n \n         if p.status == 0 {\n             has_src_file = true;\n@@ -1323,8 +1329,8 @@ fn sync_one_curl(c: cargo, dir: str, src: source) -> bool {\n \n     alt copy src.key {\n         some(u) {\n-            let p = run::program_output(\"curl\",  ~[\"-f\", \"-s\", \"-o\", keyfile,\n-                                                  u]);\n+            let p = run::program_output(~\"curl\",\n+                                        ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n             if p.status != 0 {\n                 error(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n                 ret false;\n@@ -1336,13 +1342,13 @@ fn sync_one_curl(c: cargo, dir: str, src: source) -> bool {\n     alt (src.key, src.keyfp) {\n         (some(_), some(f)) {\n             if smart {\n-                url = src.url + \"/packages.json.sig\";\n+                url = src.url + ~\"/packages.json.sig\";\n             }\n             else {\n-                url = src.url + \".sig\";\n+                url = src.url + ~\".sig\";\n             }\n \n-            let mut p = run::program_output(\"curl\", ~[\"-f\", \"-s\", \"-o\",\n+            let mut p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n                         sigfile, url]);\n             if p.status != 0 {\n                 error(#fmt[\"fetch for source %s (sig %s) failed\", name, url]);\n@@ -1358,10 +1364,11 @@ fn sync_one_curl(c: cargo, dir: str, src: source) -> bool {\n             }\n \n             if smart && has_src_file {\n-                url = src.url + \"/source.json.sig\";\n+                url = src.url + ~\"/source.json.sig\";\n \n-                p = run::program_output(\"curl\",\n-                                        ~[\"-f\", \"-s\", \"-o\", srcsigfile, url]);\n+                p = run::program_output(~\"curl\",\n+                                        ~[~\"-f\", ~\"-s\", ~\"-o\",\n+                                          srcsigfile, url]);\n                 if p.status != 0 {\n                     error(#fmt[\"fetch for source %s (sig %s) failed\",\n                           name, url]);\n@@ -1371,8 +1378,8 @@ fn sync_one_curl(c: cargo, dir: str, src: source) -> bool {\n                 let e = pgp::verify(c.root, srcfile, srcsigfile, f);\n \n                 if !e {\n-                    error(\"signature verification failed for \" +\n-                          \"source \" + name);\n+                    error(~\"signature verification failed for \" +\n+                          ~\"source \" + name);\n                     ret false;\n                 }\n             }\n@@ -1406,8 +1413,8 @@ fn sync_one(c: cargo, src: source) {\n     need_dir(dir);\n \n     let result = alt src.method {\n-        \"git\" { sync_one_git(c, dir, src) }\n-        \"file\" { sync_one_file(c, dir, src) }\n+        ~\"git\" { sync_one_git(c, dir, src) }\n+        ~\"file\" { sync_one_file(c, dir, src) }\n         _ { sync_one_curl(c, dir, src) }\n     };\n \n@@ -1418,22 +1425,22 @@ fn sync_one(c: cargo, src: source) {\n }\n \n fn cmd_init(c: cargo) {\n-    let srcurl = \"http://www.rust-lang.org/cargo/sources.json\";\n-    let sigurl = \"http://www.rust-lang.org/cargo/sources.json.sig\";\n+    let srcurl = ~\"http://www.rust-lang.org/cargo/sources.json\";\n+    let sigurl = ~\"http://www.rust-lang.org/cargo/sources.json.sig\";\n \n-    let srcfile = path::connect(c.root, \"sources.json.new\");\n-    let sigfile = path::connect(c.root, \"sources.json.sig\");\n-    let destsrcfile = path::connect(c.root, \"sources.json\");\n+    let srcfile = path::connect(c.root, ~\"sources.json.new\");\n+    let sigfile = path::connect(c.root, ~\"sources.json.sig\");\n+    let destsrcfile = path::connect(c.root, ~\"sources.json\");\n \n     let p =\n-        run::program_output(\"curl\", ~[\"-f\", \"-s\", \"-o\", srcfile, srcurl]);\n+        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\", srcfile, srcurl]);\n     if p.status != 0 {\n         error(#fmt[\"fetch of sources.json failed: %s\", p.out]);\n         ret;\n     }\n \n     let p =\n-        run::program_output(\"curl\", ~[\"-f\", \"-s\", \"-o\", sigfile, sigurl]);\n+        run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\", sigfile, sigurl]);\n     if p.status != 0 {\n         error(#fmt[\"fetch of sources.json.sig failed: %s\", p.out]);\n         ret;\n@@ -1453,31 +1460,31 @@ fn cmd_init(c: cargo) {\n }\n \n fn print_pkg(s: source, p: package) {\n-    let mut m = s.name + \"/\" + p.name + \" (\" + p.uuid + \")\";\n+    let mut m = s.name + ~\"/\" + p.name + ~\" (\" + p.uuid + ~\")\";\n     if vec::len(p.tags) > 0u {\n-        m = m + \" [\" + str::connect(p.tags, \", \") + \"]\";\n+        m = m + ~\" [\" + str::connect(p.tags, ~\", \") + ~\"]\";\n     }\n     info(m);\n-    if p.description != \"\" {\n-        print(\"   >> \" + p.description + \"\\n\")\n+    if p.description != ~\"\" {\n+        print(~\"   >> \" + p.description + ~\"\\n\")\n     }\n }\n \n fn print_source(s: source) {\n-    info(s.name + \" (\" + s.url + \")\");\n+    info(s.name + ~\" (\" + s.url + ~\")\");\n \n     let pks = sort::merge_sort(|a, b| a < b, copy s.packages);\n     let l = vec::len(pks);\n \n     print(io::with_str_writer(|writer| {\n-        let mut list = \"   >> \";\n+        let mut list = ~\"   >> \";\n \n         do vec::iteri(pks) |i, pk| {\n             if str::len(list) > 78u {\n                 writer.write_line(list);\n-                list = \"   >> \";\n+                list = ~\"   >> \";\n             }\n-            list += pk.name + (if l - 1u == i { \"\" } else { \", \" });\n+            list += pk.name + (if l - 1u == i { ~\"\" } else { ~\", \" });\n         }\n \n         writer.write_line(list);\n@@ -1521,7 +1528,7 @@ fn cmd_search(c: cargo) {\n     let name = c.opts.free[2];\n     let tags = vec::slice(c.opts.free, 3u, vec::len(c.opts.free));\n     for_each_package(c, |s, p| {\n-        if (str::contains(p.name, name) || name == \"*\") &&\n+        if (str::contains(p.name, name) || name == ~\"*\") &&\n             vec::all(tags, |t| vec::contains(p.tags, t) ) {\n             print_pkg(s, p);\n             n += 1;\n@@ -1530,10 +1537,10 @@ fn cmd_search(c: cargo) {\n     info(#fmt[\"found %d packages\", n]);\n }\n \n-fn install_to_dir(srcfile: str, destdir: str) {\n+fn install_to_dir(srcfile: ~str, destdir: ~str) {\n     let newfile = path::connect(destdir, path::basename(srcfile));\n \n-    let status = run::run_program(\"cp\", ~[\"-r\", srcfile, newfile]);\n+    let status = run::run_program(~\"cp\", ~[~\"-r\", srcfile, newfile]);\n     if status == 0 {\n         info(#fmt[\"installed: '%s'\", newfile]);\n     } else {\n@@ -1544,11 +1551,11 @@ fn install_to_dir(srcfile: str, destdir: str) {\n fn dump_cache(c: cargo) {\n     need_dir(c.root);\n \n-    let out = path::connect(c.root, \"cache.json\");\n+    let out = path::connect(c.root, ~\"cache.json\");\n     let _root = json::dict(map::str_hash());\n \n     if os::path_exists(out) {\n-        copy_warn(out, path::connect(c.root, \"cache.json.old\"));\n+        copy_warn(out, path::connect(c.root, ~\"cache.json.old\"));\n     }\n }\n fn dump_sources(c: cargo) {\n@@ -1558,10 +1565,10 @@ fn dump_sources(c: cargo) {\n \n     need_dir(c.root);\n \n-    let out = path::connect(c.root, \"sources.json\");\n+    let out = path::connect(c.root, ~\"sources.json\");\n \n     if os::path_exists(out) {\n-        copy_warn(out, path::connect(c.root, \"sources.json.old\"));\n+        copy_warn(out, path::connect(c.root, ~\"sources.json.old\"));\n     }\n \n     alt io::buffered_file_writer(out) {\n@@ -1573,18 +1580,18 @@ fn dump_sources(c: cargo) {\n                 let chash = map::str_hash();\n                 let child = json::dict(chash);\n \n-                chash.insert(\"url\", json::string(@v.url));\n-                chash.insert(\"method\", json::string(@v.method));\n+                chash.insert(~\"url\", json::string(@v.url));\n+                chash.insert(~\"method\", json::string(@v.method));\n \n                 alt copy v.key {\n                     some(key) {\n-                        chash.insert(\"key\", json::string(@key));\n+                        chash.insert(~\"key\", json::string(@key));\n                     }\n                     _ {}\n                 }\n                 alt copy v.keyfp {\n                     some(keyfp) {\n-                        chash.insert(\"keyfp\", json::string(@keyfp));\n+                        chash.insert(~\"keyfp\", json::string(@keyfp));\n                     }\n                     _ {}\n                 }\n@@ -1600,7 +1607,7 @@ fn dump_sources(c: cargo) {\n     }\n }\n \n-fn copy_warn(srcfile: str, destfile: str) {\n+fn copy_warn(srcfile: ~str, destfile: ~str) {\n     if !os::copy_file(srcfile, destfile) {\n         warn(#fmt[\"copying %s to %s failed\", srcfile, destfile]);\n     }\n@@ -1618,14 +1625,14 @@ fn cmd_sources(c: cargo) {\n     let action = c.opts.free[2u];\n \n     alt action {\n-        \"clear\" {\n+        ~\"clear\" {\n           for c.sources.each_key |k| {\n                 c.sources.remove(k);\n             }\n \n-            info(\"cleared sources\");\n+            info(~\"cleared sources\");\n         }\n-        \"add\" {\n+        ~\"add\" {\n             if vec::len(c.opts.free) < 5u {\n                 cmd_usage();\n                 ret;\n@@ -1656,7 +1663,7 @@ fn cmd_sources(c: cargo) {\n                 }\n             }\n         }\n-        \"remove\" {\n+        ~\"remove\" {\n             if vec::len(c.opts.free) < 4u {\n                 cmd_usage();\n                 ret;\n@@ -1679,7 +1686,7 @@ fn cmd_sources(c: cargo) {\n                 }\n             }\n         }\n-        \"set-url\" {\n+        ~\"set-url\" {\n             if vec::len(c.opts.free) < 5u {\n                 cmd_usage();\n                 ret;\n@@ -1710,7 +1717,7 @@ fn cmd_sources(c: cargo) {\n                 }\n             }\n         }\n-        \"set-method\" {\n+        ~\"set-method\" {\n             if vec::len(c.opts.free) < 5u {\n                 cmd_usage();\n                 ret;\n@@ -1729,9 +1736,9 @@ fn cmd_sources(c: cargo) {\n                     let old = copy source.method;\n \n                     source.method = alt method {\n-                        \"git\" { \"git\" }\n-                        \"file\" { \"file\" }\n-                        _ { \"curl\" }\n+                        ~\"git\" { ~\"git\" }\n+                        ~\"file\" { ~\"file\" }\n+                        _ { ~\"curl\" }\n                     };\n \n                     c.sources.insert(name, source);\n@@ -1744,7 +1751,7 @@ fn cmd_sources(c: cargo) {\n                 }\n             }\n         }\n-        \"rename\" {\n+        ~\"rename\" {\n             if vec::len(c.opts.free) < 5u {\n                 cmd_usage();\n                 ret;\n@@ -1778,7 +1785,7 @@ fn cmd_sources(c: cargo) {\n }\n \n fn cmd_usage() {\n-    print(\"Usage: cargo <cmd> [options] [args..]\n+    print(~\"Usage: cargo <cmd> [options] [args..]\n e.g. cargo install <name>\n \n Where <cmd> is one of:\n@@ -1793,14 +1800,14 @@ Options:\n }\n \n fn cmd_usage_init() {\n-    print(\"cargo init\n+    print(~\"cargo init\n \n Re-initialize cargo in ~/.cargo. Clears all sources and then adds the\n default sources from <www.rust-lang.org/sources.json>.\");\n }\n \n fn cmd_usage_install() {\n-    print(\"cargo install\n+    print(~\"cargo install\n cargo install [source/]<name>[@version]\n cargo install [source/]<uuid>[@version]\n cargo install <git url> [ref]\n@@ -1819,7 +1826,7 @@ from that source, otherwise it installs from any source.\");\n }\n \n fn cmd_usage_uninstall() {\n-    print(\"cargo uninstall [source/]<name>[@version]\n+    print(~\"cargo uninstall [source/]<name>[@version]\n cargo uninstall [source/]<uuid>[@version]\n cargo uninstall <meta-name>[@version]\n cargo uninstall <meta-uuid>[@version]\n@@ -1836,21 +1843,21 @@ it by metadata.\");\n }\n \n fn cmd_usage_list() {\n-    print(\"cargo list [sources..]\n+    print(~\"cargo list [sources..]\n \n If no arguments are provided, list all sources and their packages.\n If source names are provided, list those sources and their packages.\n \");\n }\n \n fn cmd_usage_search() {\n-    print(\"cargo search <query | '*'> [tags..]\n+    print(~\"cargo search <query | '*'> [tags..]\n \n Search packages.\");\n }\n \n fn cmd_usage_sources() {\n-    print(\"cargo sources\n+    print(~\"cargo sources\n cargo sources add <name> <url>\n cargo sources remove <name>\n cargo sources rename <name> <new>\n@@ -1868,7 +1875,7 @@ Commands:\n     set-method      Change the method for a source.\");\n }\n \n-fn main(argv: ~[str]) {\n+fn main(argv: ~[~str]) {\n     let o = build_cargo_options(argv);\n \n     if vec::len(o.free) < 2u {\n@@ -1877,39 +1884,39 @@ fn main(argv: ~[str]) {\n     }\n     if o.help {\n         alt o.free[1] {\n-            \"init\" { cmd_usage_init(); }\n-            \"install\" { cmd_usage_install(); }\n-            \"uninstall\" { cmd_usage_uninstall(); }\n-            \"list\" { cmd_usage_list(); }\n-            \"search\" { cmd_usage_search(); }\n-            \"sources\" { cmd_usage_sources(); }\n+            ~\"init\" { cmd_usage_init(); }\n+            ~\"install\" { cmd_usage_install(); }\n+            ~\"uninstall\" { cmd_usage_uninstall(); }\n+            ~\"list\" { cmd_usage_list(); }\n+            ~\"search\" { cmd_usage_search(); }\n+            ~\"sources\" { cmd_usage_sources(); }\n             _ { cmd_usage(); }\n         }\n         ret;\n     }\n-    if o.free[1] == \"usage\" {\n+    if o.free[1] == ~\"usage\" {\n         cmd_usage();\n         ret;\n     }\n \n     let mut c = configure(o);\n     let home = c.root;\n-    let first_time = os::path_exists(path::connect(home, \"sources.json\"));\n+    let first_time = os::path_exists(path::connect(home, ~\"sources.json\"));\n \n-    if !first_time && o.free[1] != \"init\" {\n+    if !first_time && o.free[1] != ~\"init\" {\n         cmd_init(c);\n \n         // FIXME (#2662): shouldn't need to reconfigure\n         c = configure(o);\n     }\n \n     alt o.free[1] {\n-        \"init\" { cmd_init(c); }\n-        \"install\" { cmd_install(c); }\n-        \"uninstall\" { cmd_uninstall(c); }\n-        \"list\" { cmd_list(c); }\n-        \"search\" { cmd_search(c); }\n-        \"sources\" { cmd_sources(c); }\n+        ~\"init\" { cmd_init(c); }\n+        ~\"install\" { cmd_install(c); }\n+        ~\"uninstall\" { cmd_uninstall(c); }\n+        ~\"list\" { cmd_list(c); }\n+        ~\"search\" { cmd_search(c); }\n+        ~\"sources\" { cmd_sources(c); }\n         _ { cmd_usage(); }\n     }\n "}, {"sha": "6977cdf02564ba77b90c9517daeb7cf964bbf978", "filename": "src/cargo/pgp.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcargo%2Fpgp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcargo%2Fpgp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fpgp.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -1,9 +1,9 @@\n-fn gpg(args: ~[str]) -> { status: int, out: str, err: str } {\n-    ret run::program_output(\"gpg\", args);\n+fn gpg(args: ~[~str]) -> { status: int, out: ~str, err: ~str } {\n+    ret run::program_output(~\"gpg\", args);\n }\n \n-fn signing_key() -> str {\n-    \"\n+fn signing_key() -> ~str {\n+    ~\"\n -----BEGIN PGP PUBLIC KEY BLOCK-----\n Version: SKS 1.1.0\n \n@@ -54,42 +54,42 @@ HI1jilzwKSXuV2EmyBk3tKh9NwscT/A78pr30FxxPUg3v72raNgusTo=\n \"\n }\n \n-fn signing_key_fp() -> str {\n-    \"FE79 EDB0 3DEF B0D8 27D2  6C41 0B2D 6A28 3033 6376\"\n+fn signing_key_fp() -> ~str {\n+    ~\"FE79 EDB0 3DEF B0D8 27D2  6C41 0B2D 6A28 3033 6376\"\n }\n \n fn supported() -> bool {\n-    let r = gpg(~[\"--version\"]);\n+    let r = gpg(~[~\"--version\"]);\n     r.status == 0\n }\n \n-fn init(root: str) {\n-    let p = path::connect(root, \"gpg\");\n+fn init(root: ~str) {\n+    let p = path::connect(root, ~\"gpg\");\n     if !os::path_is_dir(p) {\n         os::make_dir(p, 0x1c0i32);\n-        let p = run::start_program(\"gpg\", ~[\"--homedir\", p, \"--import\"]);\n+        let p = run::start_program(~\"gpg\", ~[~\"--homedir\", p, ~\"--import\"]);\n         p.input().write_str(signing_key());\n         let s = p.finish();\n         if s != 0 {\n-            fail \"pgp init failed\";\n+            fail ~\"pgp init failed\";\n         }\n     }\n }\n \n-fn add(root: str, key: str) {\n-    let path = path::connect(root, \"gpg\");\n+fn add(root: ~str, key: ~str) {\n+    let path = path::connect(root, ~\"gpg\");\n     let p =\n-        run::program_output(\"gpg\", ~[\"--homedir\", path, \"--import\", key]);\n+        run::program_output(~\"gpg\", ~[~\"--homedir\", path, ~\"--import\", key]);\n     if p.status != 0 {\n-        fail \"pgp add failed: \" + p.out;\n+        fail ~\"pgp add failed: \" + p.out;\n     }\n }\n \n-fn verify(root: str, data: str, sig: str, keyfp: str) -> bool {\n-    let path = path::connect(root, \"gpg\");\n-    let p = gpg(~[\"--homedir\", path, \"--with-fingerprint\", \"--verify\", sig,\n+fn verify(root: ~str, data: ~str, sig: ~str, keyfp: ~str) -> bool {\n+    let path = path::connect(root, ~\"gpg\");\n+    let p = gpg(~[~\"--homedir\", path, ~\"--with-fingerprint\", ~\"--verify\", sig,\n                  data]);\n-    let res = \"Primary key fingerprint: \" + keyfp;\n+    let res = ~\"Primary key fingerprint: \" + keyfp;\n     for str::split_char(p.err, '\\n').each |line| {\n         if line == res { ret true; }\n     }"}, {"sha": "a7bcc8d67cc3ddc899ebe9b253d20663de213b9b", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -4,25 +4,25 @@ enum mode { mode_compile_fail, mode_run_fail, mode_run_pass, mode_pretty, }\n \n type config = {\n     // The library paths required for running the compiler\n-    compile_lib_path: str,\n+    compile_lib_path: ~str,\n \n     // The library paths required for running compiled programs\n-    run_lib_path: str,\n+    run_lib_path: ~str,\n \n     // The rustc executable\n-    rustc_path: str,\n+    rustc_path: ~str,\n \n     // The directory containing the tests to run\n-    src_base: str,\n+    src_base: ~str,\n \n     // The directory where programs should be built\n-    build_base: str,\n+    build_base: ~str,\n \n     // Directory for auxiliary libraries\n-    aux_base: str,\n+    aux_base: ~str,\n \n     // The name of the stage being built (stage1, etc)\n-    stage_id: str,\n+    stage_id: ~str,\n \n     // The test mode, compile-fail, run-fail, run-pass\n     mode: mode,\n@@ -31,17 +31,17 @@ type config = {\n     run_ignored: bool,\n \n     // Only run tests that match this filter\n-    filter: option<str>,\n+    filter: option<~str>,\n \n     // Write out a parseable log of tests that were run\n-    logfile: option<str>,\n+    logfile: option<~str>,\n \n     // A command line to prefix program execution with,\n     // for running under valgrind\n-    runtool: option<str>,\n+    runtool: option<~str>,\n \n     // Flags to pass to the compiler\n-    rustcflags: option<str>,\n+    rustcflags: option<~str>,\n \n     // Explain what's going on\n     verbose: bool};"}, {"sha": "30adf8ba5bbe527db4200def56888f64fec2b6c7", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -21,23 +21,23 @@ import common::mode_pretty;\n import common::mode;\n import util::logv;\n \n-fn main(args: ~[str]) {\n+fn main(args: ~[~str]) {\n     let config = parse_config(args);\n     log_config(config);\n     run_tests(config);\n }\n \n-fn parse_config(args: ~[str]) -> config {\n+fn parse_config(args: ~[~str]) -> config {\n     let opts =\n-        ~[getopts::reqopt(\"compile-lib-path\"),\n-          getopts::reqopt(\"run-lib-path\"),\n-          getopts::reqopt(\"rustc-path\"), getopts::reqopt(\"src-base\"),\n-          getopts::reqopt(\"build-base\"), getopts::reqopt(\"aux-base\"),\n-          getopts::reqopt(\"stage-id\"),\n-          getopts::reqopt(\"mode\"), getopts::optflag(\"ignored\"),\n-          getopts::optopt(\"runtool\"), getopts::optopt(\"rustcflags\"),\n-          getopts::optflag(\"verbose\"),\n-          getopts::optopt(\"logfile\")];\n+        ~[getopts::reqopt(~\"compile-lib-path\"),\n+          getopts::reqopt(~\"run-lib-path\"),\n+          getopts::reqopt(~\"rustc-path\"), getopts::reqopt(~\"src-base\"),\n+          getopts::reqopt(~\"build-base\"), getopts::reqopt(~\"aux-base\"),\n+          getopts::reqopt(~\"stage-id\"),\n+          getopts::reqopt(~\"mode\"), getopts::optflag(~\"ignored\"),\n+          getopts::optopt(~\"runtool\"), getopts::optopt(~\"rustcflags\"),\n+          getopts::optflag(~\"verbose\"),\n+          getopts::optopt(~\"logfile\")];\n \n     check (vec::is_not_empty(args));\n     let args_ = vec::tail(args);\n@@ -47,23 +47,23 @@ fn parse_config(args: ~[str]) -> config {\n           err(f) { fail getopts::fail_str(f) }\n         };\n \n-    ret {compile_lib_path: getopts::opt_str(match, \"compile-lib-path\"),\n-         run_lib_path: getopts::opt_str(match, \"run-lib-path\"),\n-         rustc_path: getopts::opt_str(match, \"rustc-path\"),\n-         src_base: getopts::opt_str(match, \"src-base\"),\n-         build_base: getopts::opt_str(match, \"build-base\"),\n-         aux_base: getopts::opt_str(match, \"aux-base\"),\n-         stage_id: getopts::opt_str(match, \"stage-id\"),\n-         mode: str_mode(getopts::opt_str(match, \"mode\")),\n-         run_ignored: getopts::opt_present(match, \"ignored\"),\n+    ret {compile_lib_path: getopts::opt_str(match, ~\"compile-lib-path\"),\n+         run_lib_path: getopts::opt_str(match, ~\"run-lib-path\"),\n+         rustc_path: getopts::opt_str(match, ~\"rustc-path\"),\n+         src_base: getopts::opt_str(match, ~\"src-base\"),\n+         build_base: getopts::opt_str(match, ~\"build-base\"),\n+         aux_base: getopts::opt_str(match, ~\"aux-base\"),\n+         stage_id: getopts::opt_str(match, ~\"stage-id\"),\n+         mode: str_mode(getopts::opt_str(match, ~\"mode\")),\n+         run_ignored: getopts::opt_present(match, ~\"ignored\"),\n          filter:\n              if vec::len(match.free) > 0u {\n                  option::some(match.free[0])\n              } else { option::none },\n-         logfile: getopts::opt_maybe_str(match, \"logfile\"),\n-         runtool: getopts::opt_maybe_str(match, \"runtool\"),\n-         rustcflags: getopts::opt_maybe_str(match, \"rustcflags\"),\n-         verbose: getopts::opt_present(match, \"verbose\")};\n+         logfile: getopts::opt_maybe_str(match, ~\"logfile\"),\n+         runtool: getopts::opt_maybe_str(match, ~\"runtool\"),\n+         rustcflags: getopts::opt_maybe_str(match, ~\"rustcflags\"),\n+         verbose: getopts::opt_present(match, ~\"verbose\")};\n }\n \n fn log_config(config: config) {\n@@ -84,38 +84,38 @@ fn log_config(config: config) {\n     logv(c, #fmt[\"\\n\"]);\n }\n \n-fn opt_str(maybestr: option<str>) -> str {\n-    alt maybestr { option::some(s) { s } option::none { \"(none)\" } }\n+fn opt_str(maybestr: option<~str>) -> ~str {\n+    alt maybestr { option::some(s) { s } option::none { ~\"(none)\" } }\n }\n \n-fn str_opt(maybestr: str) -> option<str> {\n-    if maybestr != \"(none)\" { option::some(maybestr) } else { option::none }\n+fn str_opt(maybestr: ~str) -> option<~str> {\n+    if maybestr != ~\"(none)\" { option::some(maybestr) } else { option::none }\n }\n \n-fn str_mode(s: str) -> mode {\n+fn str_mode(s: ~str) -> mode {\n     alt s {\n-      \"compile-fail\" { mode_compile_fail }\n-      \"run-fail\" { mode_run_fail }\n-      \"run-pass\" { mode_run_pass }\n-      \"pretty\" { mode_pretty }\n-      _ { fail \"invalid mode\" }\n+      ~\"compile-fail\" { mode_compile_fail }\n+      ~\"run-fail\" { mode_run_fail }\n+      ~\"run-pass\" { mode_run_pass }\n+      ~\"pretty\" { mode_pretty }\n+      _ { fail ~\"invalid mode\" }\n     }\n }\n \n-fn mode_str(mode: mode) -> str {\n+fn mode_str(mode: mode) -> ~str {\n     alt mode {\n-      mode_compile_fail { \"compile-fail\" }\n-      mode_run_fail { \"run-fail\" }\n-      mode_run_pass { \"run-pass\" }\n-      mode_pretty { \"pretty\" }\n+      mode_compile_fail { ~\"compile-fail\" }\n+      mode_run_fail { ~\"run-fail\" }\n+      mode_run_pass { ~\"run-pass\" }\n+      mode_pretty { ~\"pretty\" }\n     }\n }\n \n fn run_tests(config: config) {\n     let opts = test_opts(config);\n     let tests = make_tests(config);\n     let res = test::run_tests_console(opts, tests);\n-    if !res { fail \"Some tests failed\"; }\n+    if !res { fail ~\"Some tests failed\"; }\n }\n \n fn test_opts(config: config) -> test::test_opts {\n@@ -146,11 +146,11 @@ fn make_tests(config: config) -> ~[test::test_desc] {\n     ret tests;\n }\n \n-fn is_test(config: config, testfile: str) -> bool {\n+fn is_test(config: config, testfile: ~str) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions =\n-        alt config.mode { mode_pretty { ~[\".rs\"] } _ { ~[\".rc\", \".rs\"] } };\n-    let invalid_prefixes = ~[\".\", \"#\", \"~\"];\n+        alt config.mode { mode_pretty { ~[~\".rs\"] } _ { ~[~\".rc\", ~\".rs\"] } };\n+    let invalid_prefixes = ~[~\".\", ~\"#\", ~\"~\"];\n     let name = path::basename(testfile);\n \n     let mut valid = false;\n@@ -166,7 +166,7 @@ fn is_test(config: config, testfile: str) -> bool {\n     ret valid;\n }\n \n-fn make_test(config: config, testfile: str) ->\n+fn make_test(config: config, testfile: ~str) ->\n    test::test_desc {\n     {\n         name: make_test_name(config, testfile),\n@@ -176,11 +176,11 @@ fn make_test(config: config, testfile: str) ->\n     }\n }\n \n-fn make_test_name(config: config, testfile: str) -> str {\n+fn make_test_name(config: config, testfile: ~str) -> ~str {\n     #fmt[\"[%s] %s\", mode_str(config.mode), testfile]\n }\n \n-fn make_test_closure(config: config, testfile: str) -> test::test_fn {\n+fn make_test_closure(config: config, testfile: ~str) -> test::test_fn {\n     fn~() { runtest::run(config, copy testfile) }\n }\n "}, {"sha": "64e36cb1f5e861e287acf6a665d5ce252acecd47", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -5,10 +5,10 @@ import common::config;\n export load_errors;\n export expected_error;\n \n-type expected_error = { line: uint, kind: str, msg: str };\n+type expected_error = { line: uint, kind: ~str, msg: ~str };\n \n // Load any test directives embedded in the file\n-fn load_errors(testfile: str) -> ~[expected_error] {\n+fn load_errors(testfile: ~str) -> ~[expected_error] {\n     let mut error_patterns = ~[];\n     let rdr = result::get(io::file_reader(testfile));\n     let mut line_num = 1u;\n@@ -20,8 +20,8 @@ fn load_errors(testfile: str) -> ~[expected_error] {\n     ret error_patterns;\n }\n \n-fn parse_expected(line_num: uint, line: str) -> ~[expected_error] unsafe {\n-    let error_tag = \"//~\";\n+fn parse_expected(line_num: uint, line: ~str) -> ~[expected_error] unsafe {\n+    let error_tag = ~\"//~\";\n     let mut idx;\n     alt str::find_str(line, error_tag) {\n          option::none { ret ~[]; }"}, {"sha": "0d90f1435b9c909c9f1bab3a9d1b39290f30504c", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -10,20 +10,20 @@ export is_test_ignored;\n \n type test_props = {\n     // Lines that should be expected, in order, on standard out\n-    error_patterns: ~[str],\n+    error_patterns: ~[~str],\n     // Extra flags to pass to the compiler\n-    compile_flags: option<str>,\n+    compile_flags: option<~str>,\n     // If present, the name of a file that this test should match when\n     // pretty-printed\n-    pp_exact: option<str>,\n+    pp_exact: option<~str>,\n     // Modules from aux directory that should be compiled\n-    aux_builds: ~[str],\n+    aux_builds: ~[~str],\n     // Environment settings to use during execution\n-    exec_env: ~[(str,str)]\n+    exec_env: ~[(~str,~str)]\n };\n \n // Load any test directives embedded in the file\n-fn load_props(testfile: str) -> test_props {\n+fn load_props(testfile: ~str) -> test_props {\n     let mut error_patterns = ~[];\n     let mut aux_builds = ~[];\n     let mut exec_env = ~[];\n@@ -60,66 +60,66 @@ fn load_props(testfile: str) -> test_props {\n     };\n }\n \n-fn is_test_ignored(config: config, testfile: str) -> bool {\n+fn is_test_ignored(config: config, testfile: ~str) -> bool {\n     let mut found = false;\n     for iter_header(testfile) |ln| {\n-        if parse_name_directive(ln, \"xfail-test\") { ret true; }\n+        if parse_name_directive(ln, ~\"xfail-test\") { ret true; }\n         if parse_name_directive(ln, xfail_target()) { ret true; }\n         if config.mode == common::mode_pretty &&\n-           parse_name_directive(ln, \"xfail-pretty\") { ret true; }\n+           parse_name_directive(ln, ~\"xfail-pretty\") { ret true; }\n     };\n     ret found;\n \n-    fn xfail_target() -> str {\n-        \"xfail-\" + os::sysname()\n+    fn xfail_target() -> ~str {\n+        ~\"xfail-\" + os::sysname()\n     }\n }\n \n-fn iter_header(testfile: str, it: fn(str) -> bool) -> bool {\n+fn iter_header(testfile: ~str, it: fn(~str) -> bool) -> bool {\n     let rdr = result::get(io::file_reader(testfile));\n     while !rdr.eof() {\n         let ln = rdr.read_line();\n \n         // Assume that any directives will be found before the first\n         // module or function. This doesn't seem to be an optimization\n         // with a warm page cache. Maybe with a cold one.\n-        if str::starts_with(ln, \"fn\")\n-            || str::starts_with(ln, \"mod\") {\n+        if str::starts_with(ln, ~\"fn\")\n+            || str::starts_with(ln, ~\"mod\") {\n             ret false;\n         } else { if !(it(ln)) { ret false; } }\n     }\n     ret true;\n }\n \n-fn parse_error_pattern(line: str) -> option<str> {\n-    parse_name_value_directive(line, \"error-pattern\")\n+fn parse_error_pattern(line: ~str) -> option<~str> {\n+    parse_name_value_directive(line, ~\"error-pattern\")\n }\n \n-fn parse_aux_build(line: str) -> option<str> {\n-    parse_name_value_directive(line, \"aux-build\")\n+fn parse_aux_build(line: ~str) -> option<~str> {\n+    parse_name_value_directive(line, ~\"aux-build\")\n }\n \n-fn parse_compile_flags(line: str) -> option<str> {\n-    parse_name_value_directive(line, \"compile-flags\")\n+fn parse_compile_flags(line: ~str) -> option<~str> {\n+    parse_name_value_directive(line, ~\"compile-flags\")\n }\n \n-fn parse_exec_env(line: str) -> option<(str, str)> {\n-    do parse_name_value_directive(line, \"exec-env\").map |nv| {\n+fn parse_exec_env(line: ~str) -> option<(~str, ~str)> {\n+    do parse_name_value_directive(line, ~\"exec-env\").map |nv| {\n         // nv is either FOO or FOO=BAR\n         let strs = str::splitn_char(nv, '=', 1u);\n         alt strs.len() {\n-          1u { (strs[0], \"\") }\n+          1u { (strs[0], ~\"\") }\n           2u { (strs[0], strs[1]) }\n           n { fail #fmt[\"Expected 1 or 2 strings, not %u\", n]; }\n         }\n     }\n }\n \n-fn parse_pp_exact(line: str, testfile: str) -> option<str> {\n-    alt parse_name_value_directive(line, \"pp-exact\") {\n+fn parse_pp_exact(line: ~str, testfile: ~str) -> option<~str> {\n+    alt parse_name_value_directive(line, ~\"pp-exact\") {\n       option::some(s) { option::some(s) }\n       option::none {\n-        if parse_name_directive(line, \"pp-exact\") {\n+        if parse_name_directive(line, ~\"pp-exact\") {\n             option::some(path::basename(testfile))\n         } else {\n             option::none\n@@ -128,13 +128,13 @@ fn parse_pp_exact(line: str, testfile: str) -> option<str> {\n     }\n }\n \n-fn parse_name_directive(line: str, directive: str) -> bool {\n+fn parse_name_directive(line: ~str, directive: ~str) -> bool {\n     str::contains(line, directive)\n }\n \n-fn parse_name_value_directive(line: str,\n-                              directive: str) -> option<str> unsafe {\n-    let keycolon = directive + \":\";\n+fn parse_name_value_directive(line: ~str,\n+                              directive: ~str) -> option<~str> unsafe {\n+    let keycolon = directive + ~\":\";\n     alt str::find_str(line, keycolon) {\n         option::some(colon) {\n             let value = str::slice(line, colon + str::len(keycolon),"}, {"sha": "d69d02c32eb59f0a14baaf52795410a6bcfdb196", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -27,17 +27,17 @@ fn target_env(lib_path: str, prog: str) -> ~[(str,str)] {\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn target_env(_lib_path: str, _prog: str) -> ~[(str,str)] {\n+fn target_env(_lib_path: ~str, _prog: ~str) -> ~[(~str,~str)] {\n     ~[]\n }\n \n \n // FIXME (#2659): This code is duplicated in core::run::program_output\n-fn run(lib_path: str,\n-       prog: str,\n-       args: ~[str],\n-       env: ~[(str, str)],\n-       input: option<str>) -> {status: int, out: str, err: str} {\n+fn run(lib_path: ~str,\n+       prog: ~str,\n+       args: ~[~str],\n+       env: ~[(~str, ~str)],\n+       input: option<~str>) -> {status: int, out: ~str, err: ~str} {\n \n     let pipe_in = os::pipe();\n     let pipe_out = os::pipe();\n@@ -69,8 +69,8 @@ fn run(lib_path: str,\n         comm::send(ch, (1, output));\n     }\n     let status = run::waitpid(pid);\n-    let mut errs = \"\";\n-    let mut outs = \"\";\n+    let mut errs = ~\"\";\n+    let mut outs = ~\"\";\n     let mut count = 2;\n     while count > 0 {\n         let stream = comm::recv(p);\n@@ -87,7 +87,7 @@ fn run(lib_path: str,\n     ret {status: status, out: outs, err: errs};\n }\n \n-fn writeclose(fd: c_int, s: option<str>) {\n+fn writeclose(fd: c_int, s: option<~str>) {\n     if option::is_some(s) {\n         let writer = io::fd_writer(fd, false);\n         writer.write_str(option::get(s));\n@@ -96,11 +96,11 @@ fn writeclose(fd: c_int, s: option<str>) {\n     os::close(fd);\n }\n \n-fn readclose(fd: c_int) -> str {\n+fn readclose(fd: c_int) -> ~str {\n     // Copied from run::program_output\n     let file = os::fdopen(fd);\n     let reader = io::FILE_reader(file, false);\n-    let mut buf = \"\";\n+    let mut buf = ~\"\";\n     while !reader.eof() {\n         let bytes = reader.read_bytes(4096u);\n         buf += str::from_bytes(bytes);"}, {"sha": "cd8bcb79a9a9c01b52c286070c65dbbfeb946fb6", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 85, "deletions": 83, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -11,10 +11,10 @@ import util::logv;\n \n export run;\n \n-fn run(config: config, testfile: str) {\n+fn run(config: config, testfile: ~str) {\n     if config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n-        io::stdout().write_str(\"\\n\\n\");\n+        io::stdout().write_str(~\"\\n\\n\");\n     }\n     #debug(\"running %s\", testfile);\n     let props = load_props(testfile);\n@@ -26,37 +26,37 @@ fn run(config: config, testfile: str) {\n     }\n }\n \n-fn run_cfail_test(config: config, props: test_props, testfile: str) {\n+fn run_cfail_test(config: config, props: test_props, testfile: ~str) {\n     let procres = compile_test(config, props, testfile);\n \n     if procres.status == 0 {\n-        fatal_procres(\"compile-fail test compiled successfully!\", procres);\n+        fatal_procres(~\"compile-fail test compiled successfully!\", procres);\n     }\n \n     check_correct_failure_status(procres);\n \n     let expected_errors = errors::load_errors(testfile);\n     if vec::is_not_empty(expected_errors) {\n         if vec::is_not_empty(props.error_patterns) {\n-            fatal(\"both error pattern and expected errors specified\");\n+            fatal(~\"both error pattern and expected errors specified\");\n         }\n         check_expected_errors(expected_errors, testfile, procres);\n     } else {\n         check_error_patterns(props, testfile, procres);\n     }\n }\n \n-fn run_rfail_test(config: config, props: test_props, testfile: str) {\n+fn run_rfail_test(config: config, props: test_props, testfile: ~str) {\n     let mut procres = compile_test(config, props, testfile);\n \n-    if procres.status != 0 { fatal_procres(\"compilation failed!\", procres); }\n+    if procres.status != 0 { fatal_procres(~\"compilation failed!\", procres); }\n \n     procres = exec_compiled_test(config, props, testfile);\n \n     // The value our Makefile configures valgrind to return on failure\n     const valgrind_err: int = 100;\n     if procres.status == valgrind_err {\n-        fatal_procres(\"run-fail test isn't valgrind-clean!\", procres);\n+        fatal_procres(~\"run-fail test isn't valgrind-clean!\", procres);\n     }\n \n     check_correct_failure_status(procres);\n@@ -74,20 +74,20 @@ fn check_correct_failure_status(procres: procres) {\n     }\n }\n \n-fn run_rpass_test(config: config, props: test_props, testfile: str) {\n+fn run_rpass_test(config: config, props: test_props, testfile: ~str) {\n     let mut procres = compile_test(config, props, testfile);\n \n-    if procres.status != 0 { fatal_procres(\"compilation failed!\", procres); }\n+    if procres.status != 0 { fatal_procres(~\"compilation failed!\", procres); }\n \n     procres = exec_compiled_test(config, props, testfile);\n \n-    if procres.status != 0 { fatal_procres(\"test run failed!\", procres); }\n+    if procres.status != 0 { fatal_procres(~\"test run failed!\", procres); }\n }\n \n-fn run_pretty_test(config: config, props: test_props, testfile: str) {\n+fn run_pretty_test(config: config, props: test_props, testfile: ~str) {\n     if option::is_some(props.pp_exact) {\n-        logv(config, \"testing for exact pretty-printing\");\n-    } else { logv(config, \"testing for converging pretty-printing\"); }\n+        logv(config, ~\"testing for exact pretty-printing\");\n+    } else { logv(config, ~\"testing for converging pretty-printing\"); }\n \n     let rounds =\n         alt props.pp_exact { option::some(_) { 1 } option::none { 2 } };\n@@ -120,10 +120,10 @@ fn run_pretty_test(config: config, props: test_props, testfile: str) {\n \n     if option::is_some(props.pp_exact) {\n         // Now we have to care about line endings\n-        let cr = \"\\r\";\n+        let cr = ~\"\\r\";\n         check (str::is_not_empty(cr));\n-        actual = str::replace(actual, cr, \"\");\n-        expected = str::replace(expected, cr, \"\");\n+        actual = str::replace(actual, cr, ~\"\");\n+        expected = str::replace(expected, cr, ~\"\");\n     }\n \n     compare_source(expected, actual);\n@@ -132,25 +132,25 @@ fn run_pretty_test(config: config, props: test_props, testfile: str) {\n     let procres = typecheck_source(config, props, testfile, actual);\n \n     if procres.status != 0 {\n-        fatal_procres(\"pretty-printed source does not typecheck\", procres);\n+        fatal_procres(~\"pretty-printed source does not typecheck\", procres);\n     }\n \n     ret;\n \n-    fn print_source(config: config, testfile: str, src: str) -> procres {\n+    fn print_source(config: config, testfile: ~str, src: ~str) -> procres {\n         compose_and_run(config, testfile, make_pp_args(config, testfile),\n                         ~[], config.compile_lib_path, option::some(src))\n     }\n \n-    fn make_pp_args(config: config, _testfile: str) -> procargs {\n+    fn make_pp_args(config: config, _testfile: ~str) -> procargs {\n         let prog = config.rustc_path;\n-        let args = ~[\"-\", \"--pretty\", \"normal\"];\n+        let args = ~[~\"-\", ~\"--pretty\", ~\"normal\"];\n         ret {prog: prog, args: args};\n     }\n \n-    fn compare_source(expected: str, actual: str) {\n+    fn compare_source(expected: ~str, actual: ~str) {\n         if expected != actual {\n-            error(\"pretty-printed source does not match expected source\");\n+            error(~\"pretty-printed source does not match expected source\");\n             let msg =\n                 #fmt[\"\\n\\\n expected:\\n\\\n@@ -169,31 +169,32 @@ actual:\\n\\\n     }\n \n     fn typecheck_source(config: config, props: test_props,\n-                        testfile: str, src: str) -> procres {\n+                        testfile: ~str, src: ~str) -> procres {\n         compose_and_run_compiler(\n             config, props, testfile,\n             make_typecheck_args(config, testfile),\n             option::some(src))\n     }\n \n-    fn make_typecheck_args(config: config, testfile: str) -> procargs {\n+    fn make_typecheck_args(config: config, testfile: ~str) -> procargs {\n         let prog = config.rustc_path;\n-        let mut args = ~[\"-\", \"--no-trans\", \"--lib\", \"-L\", config.build_base,\n-                        \"-L\", aux_output_dir_name(config, testfile)];\n+        let mut args = ~[~\"-\",\n+                         ~\"--no-trans\", ~\"--lib\", ~\"-L\", config.build_base,\n+                         ~\"-L\", aux_output_dir_name(config, testfile)];\n         args += split_maybe_args(config.rustcflags);\n         ret {prog: prog, args: args};\n     }\n }\n \n fn check_error_patterns(props: test_props,\n-                        testfile: str,\n+                        testfile: ~str,\n                         procres: procres) {\n     if vec::is_empty(props.error_patterns) {\n-        fatal(\"no error pattern specified in \" + testfile);\n+        fatal(~\"no error pattern specified in \" + testfile);\n     }\n \n     if procres.status == 0 {\n-        fatal(\"process did not return an error status\");\n+        fatal(~\"process did not return an error status\");\n     }\n \n     let mut next_err_idx = 0u;\n@@ -223,20 +224,20 @@ fn check_error_patterns(props: test_props,\n         for missing_patterns.each |pattern| {\n             error(#fmt[\"error pattern '%s' not found!\", pattern]);\n         }\n-        fatal_procres(\"multiple error patterns not found\", procres);\n+        fatal_procres(~\"multiple error patterns not found\", procres);\n     }\n }\n \n fn check_expected_errors(expected_errors: ~[errors::expected_error],\n-                         testfile: str,\n+                         testfile: ~str,\n                          procres: procres) {\n \n     // true if we found the error in question\n     let found_flags = vec::to_mut(vec::from_elem(\n         vec::len(expected_errors), false));\n \n     if procres.status == 0 {\n-        fatal(\"process did not return an error status\");\n+        fatal(~\"process did not return an error status\");\n     }\n \n     let prefixes = vec::map(expected_errors, |ee| {\n@@ -266,12 +267,12 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n         }\n \n         // ignore this msg which gets printed at the end\n-        if str::contains(line, \"aborting due to\") {\n+        if str::contains(line, ~\"aborting due to\") {\n             was_expected = true;\n         }\n \n-        if !was_expected && (str::contains(line, \"error\") ||\n-                             str::contains(line, \"warning\")) {\n+        if !was_expected && (str::contains(line, ~\"error\") ||\n+                             str::contains(line, ~\"warning\")) {\n             fatal_procres(#fmt[\"unexpected error pattern '%s'!\", line],\n                           procres);\n         }\n@@ -286,13 +287,13 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n     }\n }\n \n-type procargs = {prog: str, args: ~[str]};\n+type procargs = {prog: ~str, args: ~[~str]};\n \n-type procres = {status: int, stdout: str, stderr: str, cmdline: str};\n+type procres = {status: int, stdout: ~str, stderr: ~str, cmdline: ~str};\n \n fn compile_test(config: config, props: test_props,\n-                testfile: str) -> procres {\n-    let link_args = ~[\"-L\", aux_output_dir_name(config, testfile)];\n+                testfile: ~str) -> procres {\n+    let link_args = ~[~\"-L\", aux_output_dir_name(config, testfile)];\n     compose_and_run_compiler(\n         config, props, testfile,\n         make_compile_args(config, props, link_args,\n@@ -301,7 +302,7 @@ fn compile_test(config: config, props: test_props,\n }\n \n fn exec_compiled_test(config: config, props: test_props,\n-                      testfile: str) -> procres {\n+                      testfile: ~str) -> procres {\n     compose_and_run(config, testfile,\n                     make_run_args(config, props, testfile),\n                     props.exec_env,\n@@ -311,20 +312,20 @@ fn exec_compiled_test(config: config, props: test_props,\n fn compose_and_run_compiler(\n     config: config,\n     props: test_props,\n-    testfile: str,\n+    testfile: ~str,\n     args: procargs,\n-    input: option<str>) -> procres {\n+    input: option<~str>) -> procres {\n \n     if props.aux_builds.is_not_empty() {\n         ensure_dir(aux_output_dir_name(config, testfile));\n     }\n \n-    let extra_link_args = ~[\"-L\", aux_output_dir_name(config, testfile)];\n+    let extra_link_args = ~[~\"-L\", aux_output_dir_name(config, testfile)];\n \n     do vec::iter(props.aux_builds) |rel_ab| {\n         let abs_ab = path::connect(config.aux_base, rel_ab);\n         let aux_args =\n-            make_compile_args(config, props, ~[\"--lib\"] + extra_link_args,\n+            make_compile_args(config, props, ~[~\"--lib\"] + extra_link_args,\n                               |a,b| make_lib_name(a, b, testfile), abs_ab);\n         let auxres = compose_and_run(config, abs_ab, aux_args, ~[],\n                                      config.compile_lib_path, option::none);\n@@ -346,38 +347,38 @@ fn ensure_dir(path: path) {\n     }\n }\n \n-fn compose_and_run(config: config, testfile: str,\n+fn compose_and_run(config: config, testfile: ~str,\n                    procargs: procargs,\n-                   procenv: ~[(str, str)],\n-                   lib_path: str,\n-                   input: option<str>) -> procres {\n+                   procenv: ~[(~str, ~str)],\n+                   lib_path: ~str,\n+                   input: option<~str>) -> procres {\n     ret program_output(config, testfile, lib_path,\n                        procargs.prog, procargs.args, procenv, input);\n }\n \n-fn make_compile_args(config: config, props: test_props, extras: ~[str],\n-                     xform: fn(config, str) -> str, testfile: str) ->\n+fn make_compile_args(config: config, props: test_props, extras: ~[~str],\n+                     xform: fn(config, ~str) -> ~str, testfile: ~str) ->\n    procargs {\n     let prog = config.rustc_path;\n-    let mut args = ~[testfile, \"-o\", xform(config, testfile),\n-                    \"-L\", config.build_base] + extras;\n+    let mut args = ~[testfile, ~\"-o\", xform(config, testfile),\n+                    ~\"-L\", config.build_base] + extras;\n     args += split_maybe_args(config.rustcflags);\n     args += split_maybe_args(props.compile_flags);\n     ret {prog: prog, args: args};\n }\n \n-fn make_lib_name(config: config, auxfile: str, testfile: str) -> str {\n+fn make_lib_name(config: config, auxfile: ~str, testfile: ~str) -> ~str {\n     // what we return here is not particularly important, as it\n     // happens; rustc ignores everything except for the directory.\n     let auxname = output_testname(auxfile);\n     path::connect(aux_output_dir_name(config, testfile), auxname)\n }\n \n-fn make_exe_name(config: config, testfile: str) -> str {\n+fn make_exe_name(config: config, testfile: ~str) -> ~str {\n     output_base_name(config, testfile) + os::exe_suffix()\n }\n \n-fn make_run_args(config: config, _props: test_props, testfile: str) ->\n+fn make_run_args(config: config, _props: test_props, testfile: ~str) ->\n    procargs {\n     let toolargs = {\n             // If we've got another tool to run under (valgrind),\n@@ -394,9 +395,9 @@ fn make_run_args(config: config, _props: test_props, testfile: str) ->\n     ret {prog: args[0], args: vec::slice(args, 1u, vec::len(args))};\n }\n \n-fn split_maybe_args(argstr: option<str>) -> ~[str] {\n-    fn rm_whitespace(v: ~[str]) -> ~[str] {\n-        fn flt(&&s: str) -> option<str> {\n+fn split_maybe_args(argstr: option<~str>) -> ~[~str] {\n+    fn rm_whitespace(v: ~[~str]) -> ~[~str] {\n+        fn flt(&&s: ~str) -> option<~str> {\n           if !str::is_whitespace(s) { option::some(s) } else { option::none }\n         }\n         vec::filter_map(v, flt)\n@@ -408,9 +409,9 @@ fn split_maybe_args(argstr: option<str>) -> ~[str] {\n     }\n }\n \n-fn program_output(config: config, testfile: str, lib_path: str, prog: str,\n-                  args: ~[str], env: ~[(str, str)],\n-                  input: option<str>) -> procres {\n+fn program_output(config: config, testfile: ~str, lib_path: ~str, prog: ~str,\n+                  args: ~[~str], env: ~[(~str, ~str)],\n+                  input: option<~str>) -> procres {\n     let cmdline =\n         {\n             let cmdline = make_cmdline(lib_path, prog, args);\n@@ -429,8 +430,8 @@ fn program_output(config: config, testfile: str, lib_path: str, prog: str,\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn make_cmdline(_libpath: str, prog: str, args: ~[str]) -> str {\n-    #fmt[\"%s %s\", prog, str::connect(args, \" \")]\n+fn make_cmdline(_libpath: ~str, prog: ~str, args: ~[~str]) -> ~str {\n+    #fmt[\"%s %s\", prog, str::connect(args, ~\" \")]\n }\n \n #[cfg(target_os = \"win32\")]\n@@ -441,47 +442,48 @@ fn make_cmdline(libpath: str, prog: str, args: ~[str]) -> str {\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n // for diagnostic purposes\n-fn lib_path_cmd_prefix(path: str) -> str {\n+fn lib_path_cmd_prefix(path: ~str) -> ~str {\n     #fmt[\"%s=\\\"%s\\\"\", util::lib_path_env_var(), util::make_new_path(path)]\n }\n \n-fn dump_output(config: config, testfile: str, out: str, err: str) {\n-    dump_output_file(config, testfile, out, \"out\");\n-    dump_output_file(config, testfile, err, \"err\");\n+fn dump_output(config: config, testfile: ~str, out: ~str, err: ~str) {\n+    dump_output_file(config, testfile, out, ~\"out\");\n+    dump_output_file(config, testfile, err, ~\"err\");\n     maybe_dump_to_stdout(config, out, err);\n }\n \n-fn dump_output_file(config: config, testfile: str, out: str, extension: str) {\n+fn dump_output_file(config: config, testfile: ~str,\n+                    out: ~str, extension: ~str) {\n     let outfile = make_out_name(config, testfile, extension);\n     let writer = result::get(\n         io::file_writer(outfile, ~[io::create, io::truncate]));\n     writer.write_str(out);\n }\n \n-fn make_out_name(config: config, testfile: str, extension: str) -> str {\n-    output_base_name(config, testfile) + \".\" + extension\n+fn make_out_name(config: config, testfile: ~str, extension: ~str) -> ~str {\n+    output_base_name(config, testfile) + ~\".\" + extension\n }\n \n-fn aux_output_dir_name(config: config, testfile: str) -> str {\n-    output_base_name(config, testfile) + \".libaux\"\n+fn aux_output_dir_name(config: config, testfile: ~str) -> ~str {\n+    output_base_name(config, testfile) + ~\".libaux\"\n }\n \n-fn output_testname(testfile: str) -> str {\n+fn output_testname(testfile: ~str) -> ~str {\n     let parts = str::split_char(path::basename(testfile), '.');\n-    str::connect(vec::slice(parts, 0u, vec::len(parts) - 1u), \".\")\n+    str::connect(vec::slice(parts, 0u, vec::len(parts) - 1u), ~\".\")\n }\n \n-fn output_base_name(config: config, testfile: str) -> str {\n+fn output_base_name(config: config, testfile: ~str) -> ~str {\n     let base = config.build_base;\n     let filename = output_testname(testfile);\n     #fmt[\"%s%s.%s\", base, filename, config.stage_id]\n }\n \n-fn maybe_dump_to_stdout(config: config, out: str, err: str) {\n+fn maybe_dump_to_stdout(config: config, out: ~str, err: ~str) {\n     if config.verbose {\n-        let sep1 = #fmt[\"------%s------------------------------\", \"stdout\"];\n-        let sep2 = #fmt[\"------%s------------------------------\", \"stderr\"];\n-        let sep3 = \"------------------------------------------\";\n+        let sep1 = #fmt[\"------%s------------------------------\", ~\"stdout\"];\n+        let sep2 = #fmt[\"------%s------------------------------\", ~\"stderr\"];\n+        let sep3 = ~\"------------------------------------------\";\n         io::stdout().write_line(sep1);\n         io::stdout().write_line(out);\n         io::stdout().write_line(sep2);\n@@ -490,11 +492,11 @@ fn maybe_dump_to_stdout(config: config, out: str, err: str) {\n     }\n }\n \n-fn error(err: str) { io::stdout().write_line(#fmt[\"\\nerror: %s\", err]); }\n+fn error(err: ~str) { io::stdout().write_line(#fmt[\"\\nerror: %s\", err]); }\n \n-fn fatal(err: str) -> ! { error(err); fail; }\n+fn fatal(err: ~str) -> ! { error(err); fail; }\n \n-fn fatal_procres(err: str, procres: procres) -> ! {\n+fn fatal_procres(err: ~str, procres: procres) -> ! {\n     let msg =\n         #fmt[\"\\n\\\n error: %s\\n\\"}, {"sha": "7a38ffcc212d7f65d19fc5e6007e03a248cceb1a", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -3,7 +3,7 @@ import os::getenv;\n \n import common::config;\n \n-fn make_new_path(path: str) -> str {\n+fn make_new_path(path: ~str) -> ~str {\n \n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n@@ -17,7 +17,7 @@ fn make_new_path(path: str) -> str {\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"freebsd\")]\n-fn lib_path_env_var() -> str { \"LD_LIBRARY_PATH\" }\n+fn lib_path_env_var() -> ~str { ~\"LD_LIBRARY_PATH\" }\n \n #[cfg(target_os = \"macos\")]\n fn lib_path_env_var() -> str { \"DYLD_LIBRARY_PATH\" }\n@@ -28,12 +28,12 @@ fn lib_path_env_var() -> str { \"PATH\" }\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn path_div() -> str { \":\" }\n+fn path_div() -> ~str { ~\":\" }\n \n #[cfg(target_os = \"win32\")]\n fn path_div() -> str { \";\" }\n \n-fn logv(config: config, s: str) {\n+fn logv(config: config, s: ~str) {\n     log(debug, s);\n     if config.verbose { io::println(s); }\n }"}, {"sha": "047d6433915a64966bb0df2b18661bec2019ba84", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 105, "deletions": 100, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -8,23 +8,23 @@ import syntax::diagnostic;\n enum test_mode { tm_converge, tm_run, }\n type context = { mode: test_mode }; // + rng\n \n-fn write_file(filename: str, content: str) {\n+fn write_file(filename: ~str, content: ~str) {\n     result::get(\n         io::file_writer(filename, ~[io::create, io::truncate]))\n         .write_str(content);\n }\n \n-fn contains(haystack: str, needle: str) -> bool {\n+fn contains(haystack: ~str, needle: ~str) -> bool {\n     str::contains(haystack, needle)\n }\n \n-fn find_rust_files(&files: ~[str], path: str) {\n-    if str::ends_with(path, \".rs\") && !contains(path, \"utf8\") {\n+fn find_rust_files(&files: ~[~str], path: ~str) {\n+    if str::ends_with(path, ~\".rs\") && !contains(path, ~\"utf8\") {\n         // ignoring \"utf8\" tests because something is broken\n         files += ~[path];\n     } else if os::path_is_dir(path)\n-        && !contains(path, \"compile-fail\")\n-        && !contains(path, \"build\") {\n+        && !contains(path, ~\"compile-fail\")\n+        && !contains(path, ~\"build\") {\n         for os::list_dir_path(path).each |p| {\n             find_rust_files(files, p);\n         }\n@@ -45,7 +45,7 @@ fn common_exprs() -> ~[ast::expr] {\n      dse(ast::expr_again),\n      dse(ast::expr_fail(option::none)),\n      dse(ast::expr_fail(option::some(\n-         @dse(ast::expr_lit(@dsl(ast::lit_str(@\"boo\"))))))),\n+         @dse(ast::expr_lit(@dsl(ast::lit_str(@~\"boo\"))))))),\n      dse(ast::expr_ret(option::none)),\n      dse(ast::expr_lit(@dsl(ast::lit_nil))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n@@ -228,31 +228,31 @@ fn under(n: uint, it: fn(uint)) {\n \n fn devnull() -> io::writer { io::mem_buffer_writer(io::mem_buffer()) }\n \n-fn as_str(f: fn@(io::writer)) -> str {\n+fn as_str(f: fn@(io::writer)) -> ~str {\n     let buf = io::mem_buffer();\n     f(io::mem_buffer_writer(buf));\n     io::mem_buffer_str(buf)\n }\n \n fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n-                         filename: str, cx: context) {\n+                         filename: ~str, cx: context) {\n     let stolen = steal(crate, cx.mode);\n     let extra_exprs = vec::filter(common_exprs(),\n                                   |a| safe_to_use_expr(a, cx.mode) );\n-    check_variants_T(crate, codemap, filename, \"expr\",\n+    check_variants_T(crate, codemap, filename, ~\"expr\",\n                      extra_exprs + stolen.exprs, pprust::expr_to_str,\n                      replace_expr_in_crate, cx);\n-    check_variants_T(crate, codemap, filename, \"ty\", stolen.tys,\n+    check_variants_T(crate, codemap, filename, ~\"ty\", stolen.tys,\n                      pprust::ty_to_str, replace_ty_in_crate, cx);\n }\n \n fn check_variants_T<T: copy>(\n   crate: ast::crate,\n   codemap: codemap::codemap,\n-  filename: str,\n-  thing_label: str,\n+  filename: ~str,\n+  thing_label: ~str,\n   things: ~[T],\n-  stringifier: fn@(@T) -> str,\n+  stringifier: fn@(@T) -> ~str,\n   replacer: fn@(ast::crate, uint, T, test_mode) -> ast::crate,\n   cx: context\n   ) {\n@@ -263,9 +263,9 @@ fn check_variants_T<T: copy>(\n \n     if L < 100u {\n         do under(uint::min(L, 20u)) |i| {\n-            log(error, \"Replacing... #\" + uint::str(i));\n+            log(error, ~\"Replacing... #\" + uint::str(i));\n             do under(uint::min(L, 30u)) |j| {\n-                log(error, \"With... \" + stringifier(@things[j]));\n+                log(error, ~\"With... \" + stringifier(@things[j]));\n                 let crate2 = @replacer(crate, i, things[j], cx.mode);\n                 // It would be best to test the *crate* for stability, but\n                 // testing the string for stability is easier and ok for now.\n@@ -276,7 +276,7 @@ fn check_variants_T<T: copy>(\n                         diagnostic::mk_span_handler(handler, codemap),\n                         crate2,\n                         filename,\n-                        io::str_reader(\"\"), a,\n+                        io::str_reader(~\"\"), a,\n                         pprust::no_ann(),\n                         false));\n                 alt cx.mode {\n@@ -297,21 +297,26 @@ fn check_variants_T<T: copy>(\n     }\n }\n \n-fn last_part(filename: str) -> str {\n+fn last_part(filename: ~str) -> ~str {\n   let ix = option::get(str::rfind_char(filename, '/'));\n   str::slice(filename, ix + 1u, str::len(filename) - 3u)\n }\n \n-enum happiness { passed, cleanly_rejected(str), known_bug(str), failed(str), }\n+enum happiness {\n+    passed,\n+    cleanly_rejected(~str),\n+    known_bug(~str),\n+    failed(~str),\n+}\n \n // We'd find more bugs if we could take an AST here, but\n // - that would find many \"false positives\" or unimportant bugs\n // - that would be tricky, requiring use of tasks or serialization\n //   or randomness.\n // This seems to find plenty of bugs as it is :)\n-fn check_whole_compiler(code: str, suggested_filename_prefix: str,\n+fn check_whole_compiler(code: ~str, suggested_filename_prefix: ~str,\n                         allow_running: bool) {\n-    let filename = suggested_filename_prefix + \".rs\";\n+    let filename = suggested_filename_prefix + ~\".rs\";\n     write_file(filename, code);\n \n     let compile_result = check_compiling(filename);\n@@ -324,102 +329,102 @@ fn check_whole_compiler(code: str, suggested_filename_prefix: str,\n     alt run_result {\n       passed | cleanly_rejected(_) | known_bug(_) {\n         removeIfExists(suggested_filename_prefix);\n-        removeIfExists(suggested_filename_prefix + \".rs\");\n-        removeDirIfExists(suggested_filename_prefix + \".dSYM\");\n+        removeIfExists(suggested_filename_prefix + ~\".rs\");\n+        removeDirIfExists(suggested_filename_prefix + ~\".dSYM\");\n       }\n       failed(s) {\n-        log(error, \"check_whole_compiler failure: \" + s);\n-        log(error, \"Saved as: \" + filename);\n+        log(error, ~\"check_whole_compiler failure: \" + s);\n+        log(error, ~\"Saved as: \" + filename);\n       }\n     }\n }\n \n-fn removeIfExists(filename: str) {\n+fn removeIfExists(filename: ~str) {\n     // So sketchy!\n-    assert !contains(filename, \" \");\n-    run::program_output(\"bash\", ~[\"-c\", \"rm \" + filename]);\n+    assert !contains(filename, ~\" \");\n+    run::program_output(~\"bash\", ~[~\"-c\", ~\"rm \" + filename]);\n }\n \n-fn removeDirIfExists(filename: str) {\n+fn removeDirIfExists(filename: ~str) {\n     // So sketchy!\n-    assert !contains(filename, \" \");\n-    run::program_output(\"bash\", ~[\"-c\", \"rm -r \" + filename]);\n+    assert !contains(filename, ~\" \");\n+    run::program_output(~\"bash\", ~[~\"-c\", ~\"rm -r \" + filename]);\n }\n \n-fn check_running(exe_filename: str) -> happiness {\n+fn check_running(exe_filename: ~str) -> happiness {\n     let p = run::program_output(\n-        \"/Users/jruderman/scripts/timed_run_rust_program.py\",\n+        ~\"/Users/jruderman/scripts/timed_run_rust_program.py\",\n         ~[exe_filename]);\n-    let comb = p.out + \"\\n\" + p.err;\n+    let comb = p.out + ~\"\\n\" + p.err;\n     if str::len(comb) > 1u {\n-        log(error, \"comb comb comb: \" + comb);\n+        log(error, ~\"comb comb comb: \" + comb);\n     }\n \n-    if contains(comb, \"Assertion failed:\") {\n-        failed(\"C++ assertion failure\")\n-    } else if contains(comb, \"leaked memory in rust main loop\") {\n+    if contains(comb, ~\"Assertion failed:\") {\n+        failed(~\"C++ assertion failure\")\n+    } else if contains(comb, ~\"leaked memory in rust main loop\") {\n         // might also use exit code 134\n         //failed(\"Leaked\")\n-        known_bug(\"https://github.com/mozilla/rust/issues/910\")\n-    } else if contains(comb, \"src/rt/\") {\n-        failed(\"Mentioned src/rt/\")\n-    } else if contains(comb, \"malloc\") {\n-        failed(\"Mentioned malloc\")\n+        known_bug(~\"https://github.com/mozilla/rust/issues/910\")\n+    } else if contains(comb, ~\"src/rt/\") {\n+        failed(~\"Mentioned src/rt/\")\n+    } else if contains(comb, ~\"malloc\") {\n+        failed(~\"Mentioned malloc\")\n     } else {\n         alt p.status {\n             0         { passed }\n-            100       { cleanly_rejected(\"running: explicit fail\") }\n-            101 | 247 { cleanly_rejected(\"running: timed out\") }\n+            100       { cleanly_rejected(~\"running: explicit fail\") }\n+            101 | 247 { cleanly_rejected(~\"running: timed out\") }\n             245 | 246 | 138 | 252 {\n-              known_bug(\"https://github.com/mozilla/rust/issues/1466\")\n+              known_bug(~\"https://github.com/mozilla/rust/issues/1466\")\n             }\n             136 | 248 {\n               known_bug(\n-                  \"SIGFPE - https://github.com/mozilla/rust/issues/944\")\n+                  ~\"SIGFPE - https://github.com/mozilla/rust/issues/944\")\n             }\n             rc {\n-              failed(\"Rust program ran but exited with status \" +\n+              failed(~\"Rust program ran but exited with status \" +\n                      int::str(rc))\n             }\n         }\n     }\n }\n \n-fn check_compiling(filename: str) -> happiness {\n+fn check_compiling(filename: ~str) -> happiness {\n     let p = run::program_output(\n-        \"/Users/jruderman/code/rust/build/x86_64-apple-darwin/\\\n+        ~\"/Users/jruderman/code/rust/build/x86_64-apple-darwin/\\\n          stage1/bin/rustc\",\n         ~[filename]);\n \n     //#error(\"Status: %d\", p.status);\n     if p.status == 0 {\n         passed\n-    } else if p.err != \"\" {\n-        if contains(p.err, \"error:\") {\n-            cleanly_rejected(\"rejected with span_error\")\n+    } else if p.err != ~\"\" {\n+        if contains(p.err, ~\"error:\") {\n+            cleanly_rejected(~\"rejected with span_error\")\n         } else {\n-            log(error, \"Stderr: \" + p.err);\n-            failed(\"Unfamiliar error message\")\n+            log(error, ~\"Stderr: \" + p.err);\n+            failed(~\"Unfamiliar error message\")\n         }\n-    } else if contains(p.out, \"Assertion\") && contains(p.out, \"failed\") {\n-        log(error, \"Stdout: \" + p.out);\n-        failed(\"Looks like an llvm assertion failure\")\n-    } else if contains(p.out, \"internal compiler error unimplemented\") {\n-        known_bug(\"Something unimplemented\")\n-    } else if contains(p.out, \"internal compiler error\") {\n-        log(error, \"Stdout: \" + p.out);\n-        failed(\"internal compiler error\")\n+    } else if contains(p.out, ~\"Assertion\") && contains(p.out, ~\"failed\") {\n+        log(error, ~\"Stdout: \" + p.out);\n+        failed(~\"Looks like an llvm assertion failure\")\n+    } else if contains(p.out, ~\"internal compiler error unimplemented\") {\n+        known_bug(~\"Something unimplemented\")\n+    } else if contains(p.out, ~\"internal compiler error\") {\n+        log(error, ~\"Stdout: \" + p.out);\n+        failed(~\"internal compiler error\")\n \n     } else {\n         log(error, p.status);\n-        log(error, \"!Stdout: \" + p.out);\n-        failed(\"What happened?\")\n+        log(error, ~\"!Stdout: \" + p.out);\n+        failed(~\"What happened?\")\n     }\n }\n \n \n-fn parse_and_print(code: @str/~) -> str {\n-    let filename = \"tmp.rs\";\n+fn parse_and_print(code: @~str) -> ~str {\n+    let filename = ~\"tmp.rs\";\n     let sess = parse::new_parse_sess(option::none);\n     write_file(filename, *code);\n     let crate = parse::parse_crate_from_source_str(\n@@ -450,49 +455,49 @@ fn has_raw_pointers(c: ast::crate) -> bool {\n     ret *has_rp;\n }\n \n-fn content_is_dangerous_to_run(code: str) -> bool {\n+fn content_is_dangerous_to_run(code: ~str) -> bool {\n     let dangerous_patterns =\n-        ~[\"xfail-test\",\n-         \"import\",  // espeically fs, run\n-         \"extern\",\n-         \"unsafe\",\n-         \"log\"];    // python --> rust pipe deadlock?\n+        ~[~\"xfail-test\",\n+         ~\"import\",  // espeically fs, run\n+         ~\"extern\",\n+         ~\"unsafe\",\n+         ~\"log\"];    // python --> rust pipe deadlock?\n \n     for dangerous_patterns.each |p| { if contains(code, p) { ret true; } }\n     ret false;\n }\n \n-fn content_is_dangerous_to_compile(code: str) -> bool {\n+fn content_is_dangerous_to_compile(code: ~str) -> bool {\n     let dangerous_patterns =\n-        ~[\"xfail-test\"];\n+        ~[~\"xfail-test\"];\n \n     for dangerous_patterns.each |p| { if contains(code, p) { ret true; } }\n     ret false;\n }\n \n-fn content_might_not_converge(code: str) -> bool {\n+fn content_might_not_converge(code: ~str) -> bool {\n     let confusing_patterns =\n-        ~[\"xfail-test\",\n-         \"xfail-pretty\",\n-         \"self\",       // crazy rules enforced by parser not typechecker?\n-         \"spawn\",      // precedence issues?\n-         \"bind\",       // precedence issues?\n-         \" be \",       // don't want to replace its child with a non-call:\n+        ~[~\"xfail-test\",\n+         ~\"xfail-pretty\",\n+         ~\"self\",       // crazy rules enforced by parser not typechecker?\n+         ~\"spawn\",      // precedence issues?\n+         ~\"bind\",       // precedence issues?\n+         ~\" be \",       // don't want to replace its child with a non-call:\n                        // \"Non-call expression in tail call\"\n-         \"\\n\\n\\n\\n\\n\"  // https://github.com/mozilla/rust/issues/850\n+         ~\"\\n\\n\\n\\n\\n\"  // https://github.com/mozilla/rust/issues/850\n         ];\n \n     for confusing_patterns.each |p| { if contains(code, p) { ret true; } }\n     ret false;\n }\n \n-fn file_might_not_converge(filename: str) -> bool {\n+fn file_might_not_converge(filename: ~str) -> bool {\n     let confusing_files = ~[\n-      \"expr-alt.rs\", // pretty-printing \"(a = b) = c\"\n+      ~\"expr-alt.rs\", // pretty-printing \"(a = b) = c\"\n                      // vs \"a = b = c\" and wrapping\n-      \"block-arg-in-ternary.rs\", // wrapping\n-      \"move-3-unique.rs\", // 0 becomes (0), but both seem reasonable. wtf?\n-      \"move-3.rs\"  // 0 becomes (0), but both seem reasonable. wtf?\n+      ~\"block-arg-in-ternary.rs\", // wrapping\n+      ~\"move-3-unique.rs\", // 0 becomes (0), but both seem reasonable. wtf?\n+      ~\"move-3.rs\"  // 0 becomes (0), but both seem reasonable. wtf?\n     ];\n \n \n@@ -501,7 +506,7 @@ fn file_might_not_converge(filename: str) -> bool {\n     ret false;\n }\n \n-fn check_roundtrip_convergence(code: @str/~, maxIters: uint) {\n+fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n \n     let mut i = 0u;\n     let mut newv = code;\n@@ -519,16 +524,16 @@ fn check_roundtrip_convergence(code: @str/~, maxIters: uint) {\n         #error(\"Converged after %u iterations\", i);\n     } else {\n         #error(\"Did not converge after %u iterations!\", i);\n-        write_file(\"round-trip-a.rs\", *oldv);\n-        write_file(\"round-trip-b.rs\", *newv);\n-        run::run_program(\"diff\",\n-                         ~[\"-w\", \"-u\", \"round-trip-a.rs\",\n-                          \"round-trip-b.rs\"]);\n-        fail \"Mismatch\";\n+        write_file(~\"round-trip-a.rs\", *oldv);\n+        write_file(~\"round-trip-b.rs\", *newv);\n+        run::run_program(~\"diff\",\n+                         ~[~\"-w\", ~\"-u\", ~\"round-trip-a.rs\",\n+                          ~\"round-trip-b.rs\"]);\n+        fail ~\"Mismatch\";\n     }\n }\n \n-fn check_convergence(files: ~[str]) {\n+fn check_convergence(files: ~[~str]) {\n     #error(\"pp convergence tests: %u files\", vec::len(files));\n     for files.each |file| {\n         if !file_might_not_converge(file) {\n@@ -543,7 +548,7 @@ fn check_convergence(files: ~[str]) {\n     }\n }\n \n-fn check_variants(files: ~[str], cx: context) {\n+fn check_variants(files: ~[~str], cx: context) {\n     for files.each |file| {\n         if cx.mode == tm_converge && file_might_not_converge(file) {\n             #error(\"Skipping convergence test based on\\\n@@ -552,7 +557,7 @@ fn check_variants(files: ~[str], cx: context) {\n         }\n \n         let s = @result::get(io::read_whole_file_str(file));\n-        if contains(*s, \"#\") {\n+        if contains(*s, ~\"#\") {\n             again; // Macros are confusing\n         }\n         if cx.mode == tm_converge && content_might_not_converge(*s) {\n@@ -562,7 +567,7 @@ fn check_variants(files: ~[str], cx: context) {\n             again;\n         }\n \n-        log(error, \"check_variants: \" + file);\n+        log(error, ~\"check_variants: \" + file);\n         let sess = parse::new_parse_sess(option::none);\n         let crate =\n             parse::parse_crate_from_source_str(\n@@ -582,7 +587,7 @@ fn check_variants(files: ~[str], cx: context) {\n     }\n }\n \n-fn main(args: ~[str]) {\n+fn main(args: ~[~str]) {\n     if vec::len(args) != 2u {\n         #error(\"usage: %s <testdir>\", args[0]);\n         ret;"}, {"sha": "83e7ebec8601351e6df428b049e023c2cec66bbd", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -38,16 +38,16 @@ pure fn is_true(v: bool) -> bool { v }\n pure fn is_false(v: bool) -> bool { !v }\n \n /// Parse logic value from `s`\n-pure fn from_str(s: str) -> option<bool> {\n+pure fn from_str(s: ~str) -> option<bool> {\n     alt check s {\n-      \"true\" { some(true) }\n-      \"false\" { some(false) }\n+      ~\"true\" { some(true) }\n+      ~\"false\" { some(false) }\n       _ { none }\n     }\n }\n \n /// Convert `v` into a string\n-pure fn to_str(v: bool) -> str { if v { \"true\" } else { \"false\" } }\n+pure fn to_str(v: bool) -> ~str { if v { ~\"true\" } else { ~\"false\" } }\n \n /**\n  * Iterates over all truth values by passing them to `blk` in an unspecified\n@@ -70,8 +70,8 @@ fn test_bool_from_str() {\n \n #[test]\n fn test_bool_to_str() {\n-    assert to_str(false) == \"false\";\n-    assert to_str(true) == \"true\";\n+    assert to_str(false) == ~\"false\";\n+    assert to_str(true) == ~\"true\";\n }\n \n #[test]"}, {"sha": "af65c3f4b96826c24a935c31a25237e13c61af51", "filename": "src/libcore/char.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -132,15 +132,15 @@ pure fn to_digit(c: char, radix: uint) -> option<uint> {\n  *   - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n  *   - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n  */\n-fn escape_unicode(c: char) -> str {\n+fn escape_unicode(c: char) -> ~str {\n     let s = u32::to_str(c as u32, 16u);\n     let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n                     else if c <= '\\uffff' { ('u', 4u) }\n                     else { ('U', 8u) });\n     assert str::len(s) <= pad;\n-    let mut out = \"\\\\\";\n+    let mut out = ~\"\\\\\";\n     str::push_str(out, str::from_char(c));\n-    for uint::range(str::len(s), pad) |_i| { str::push_str(out, \"0\"); }\n+    for uint::range(str::len(s), pad) |_i| { str::push_str(out, ~\"0\"); }\n     str::push_str(out, s);\n     ret out;\n }\n@@ -157,14 +157,14 @@ fn escape_unicode(c: char) -> str {\n  *   - Any other chars in the range [0x20,0x7e] are not escaped.\n  *   - Any other chars are given hex unicode escapes; see `escape_unicode`.\n  */\n-fn escape_default(c: char) -> str {\n+fn escape_default(c: char) -> ~str {\n     alt c {\n-      '\\t' { \"\\\\t\" }\n-      '\\r' { \"\\\\r\" }\n-      '\\n' { \"\\\\n\" }\n-      '\\\\' { \"\\\\\\\\\" }\n-      '\\'' { \"\\\\'\" }\n-      '\"' { \"\\\\\\\"\" }\n+      '\\t' { ~\"\\\\t\" }\n+      '\\r' { ~\"\\\\r\" }\n+      '\\n' { ~\"\\\\n\" }\n+      '\\\\' { ~\"\\\\\\\\\" }\n+      '\\'' { ~\"\\\\'\" }\n+      '\"' { ~\"\\\\\\\"\" }\n       '\\x20' to '\\x7e' { str::from_char(c) }\n       _ { escape_unicode(c) }\n     }\n@@ -232,8 +232,8 @@ fn test_to_digit() {\n \n #[test]\n fn test_is_ascii() {\n-   assert str::all(\"banana\", char::is_ascii);\n-   assert ! str::all(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", char::is_ascii);\n+   assert str::all(~\"banana\", char::is_ascii);\n+   assert ! str::all(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", char::is_ascii);\n }\n \n #[test]\n@@ -248,28 +248,28 @@ fn test_is_digit() {\n \n #[test]\n fn test_escape_default() {\n-    assert escape_default('\\n') == \"\\\\n\";\n-    assert escape_default('\\r') == \"\\\\r\";\n-    assert escape_default('\\'') == \"\\\\'\";\n-    assert escape_default('\"') == \"\\\\\\\"\";\n-    assert escape_default(' ') == \" \";\n-    assert escape_default('a') == \"a\";\n-    assert escape_default('~') == \"~\";\n-    assert escape_default('\\x00') == \"\\\\x00\";\n-    assert escape_default('\\x1f') == \"\\\\x1f\";\n-    assert escape_default('\\x7f') == \"\\\\x7f\";\n-    assert escape_default('\\xff') == \"\\\\xff\";\n-    assert escape_default('\\u011b') == \"\\\\u011b\";\n-    assert escape_default('\\U0001d4b6') == \"\\\\U0001d4b6\";\n+    assert escape_default('\\n') == ~\"\\\\n\";\n+    assert escape_default('\\r') == ~\"\\\\r\";\n+    assert escape_default('\\'') == ~\"\\\\'\";\n+    assert escape_default('\"') == ~\"\\\\\\\"\";\n+    assert escape_default(' ') == ~\" \";\n+    assert escape_default('a') == ~\"a\";\n+    assert escape_default('~') == ~\"~\";\n+    assert escape_default('\\x00') == ~\"\\\\x00\";\n+    assert escape_default('\\x1f') == ~\"\\\\x1f\";\n+    assert escape_default('\\x7f') == ~\"\\\\x7f\";\n+    assert escape_default('\\xff') == ~\"\\\\xff\";\n+    assert escape_default('\\u011b') == ~\"\\\\u011b\";\n+    assert escape_default('\\U0001d4b6') == ~\"\\\\U0001d4b6\";\n }\n \n \n #[test]\n fn test_escape_unicode() {\n-    assert escape_unicode('\\x00') == \"\\\\x00\";\n-    assert escape_unicode('\\n') == \"\\\\x0a\";\n-    assert escape_unicode(' ') == \"\\\\x20\";\n-    assert escape_unicode('a') == \"\\\\x61\";\n-    assert escape_unicode('\\u011b') == \"\\\\u011b\";\n-    assert escape_unicode('\\U0001d4b6') == \"\\\\U0001d4b6\";\n+    assert escape_unicode('\\x00') == ~\"\\\\x00\";\n+    assert escape_unicode('\\n') == ~\"\\\\x0a\";\n+    assert escape_unicode(' ') == ~\"\\\\x20\";\n+    assert escape_unicode('a') == ~\"\\\\x61\";\n+    assert escape_unicode('\\u011b') == ~\"\\\\u011b\";\n+    assert escape_unicode('\\U0001d4b6') == ~\"\\\\U0001d4b6\";\n }"}, {"sha": "7c85e5c5d5a782cc337302801a0483c915982d7d", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -142,9 +142,9 @@ fn as_raw_port<T: send, U>(ch: comm::chan<T>, f: fn(*rust_port) -> U) -> U {\n     let p = portref(rustrt::rust_port_take(*ch));\n \n     if ptr::is_null(p.p) {\n-        fail \"unable to locate port for channel\"\n+        fail ~\"unable to locate port for channel\"\n     } else if rustrt::get_task_id() != rustrt::rust_port_task(p.p) {\n-        fail \"unable to access unowned port\"\n+        fail ~\"unable to access unowned port\"\n     }\n \n     f(p.p)\n@@ -245,7 +245,7 @@ fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n     } else if resport == (**p_b).po {\n         either::right(recv(p_b))\n     } else {\n-        fail \"unexpected result from rust_port_select\";\n+        fail ~\"unexpected result from rust_port_select\";\n     }\n }\n \n@@ -348,13 +348,13 @@ fn test_select2_available() {\n     let ch_a = chan(po_a);\n     let ch_b = chan(po_b);\n \n-    send(ch_a, \"a\");\n+    send(ch_a, ~\"a\");\n \n-    assert select2(po_a, po_b) == either::left(\"a\");\n+    assert select2(po_a, po_b) == either::left(~\"a\");\n \n-    send(ch_b, \"b\");\n+    send(ch_b, ~\"b\");\n \n-    assert select2(po_a, po_b) == either::right(\"b\");\n+    assert select2(po_a, po_b) == either::right(~\"b\");\n }\n \n #[test]\n@@ -367,17 +367,17 @@ fn test_select2_rendezvous() {\n     for iter::repeat(10u) {\n         do task::spawn {\n             for iter::repeat(10u) { task::yield() }\n-            send(ch_a, \"a\");\n+            send(ch_a, ~\"a\");\n         };\n \n-        assert select2(po_a, po_b) == either::left(\"a\");\n+        assert select2(po_a, po_b) == either::left(~\"a\");\n \n         do task::spawn {\n             for iter::repeat(10u) { task::yield() }\n-            send(ch_b, \"b\");\n+            send(ch_b, ~\"b\");\n         };\n \n-        assert select2(po_a, po_b) == either::right(\"b\");\n+        assert select2(po_a, po_b) == either::right(~\"b\");\n     }\n }\n \n@@ -394,12 +394,12 @@ fn test_select2_stress() {\n     for iter::repeat(times) {\n         do task::spawn {\n             for iter::repeat(msgs) {\n-                send(ch_a, \"a\")\n+                send(ch_a, ~\"a\")\n             }\n         };\n         do task::spawn {\n             for iter::repeat(msgs) {\n-                send(ch_b, \"b\")\n+                send(ch_b, ~\"b\")\n             }\n         };\n     }\n@@ -408,8 +408,8 @@ fn test_select2_stress() {\n     let mut bs = 0;\n     for iter::repeat(msgs * times * 2u) {\n         alt check select2(po_a, po_b) {\n-          either::left(\"a\") { as += 1 }\n-          either::right(\"b\") { bs += 1 }\n+          either::left(~\"a\") { as += 1 }\n+          either::right(~\"b\") { bs += 1 }\n         }\n     }\n \n@@ -421,16 +421,16 @@ fn test_select2_stress() {\n fn test_recv_chan() {\n     let po = port();\n     let ch = chan(po);\n-    send(ch, \"flower\");\n-    assert recv_chan(ch) == \"flower\";\n+    send(ch, ~\"flower\");\n+    assert recv_chan(ch) == ~\"flower\";\n }\n \n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_recv_chan_dead() {\n     let ch = chan(port());\n-    send(ch, \"flower\");\n+    send(ch, ~\"flower\");\n     recv_chan(ch);\n }\n \n@@ -439,7 +439,7 @@ fn test_recv_chan_dead() {\n fn test_recv_chan_wrong_task() {\n     let po = port();\n     let ch = chan(po);\n-    send(ch, \"flower\");\n+    send(ch, ~\"flower\");\n     assert result::is_err(task::try(||\n         recv_chan(ch)\n     ))\n@@ -464,9 +464,9 @@ fn test_chan_peek() {\n fn test_listen() {\n     do listen |parent| {\n         do task::spawn {\n-            parent.send(\"oatmeal-salad\");\n+            parent.send(~\"oatmeal-salad\");\n         }\n-        assert parent.recv() == \"oatmeal-salad\";\n+        assert parent.recv() == ~\"oatmeal-salad\";\n     }\n }\n "}, {"sha": "4cadf018df823b2ab9b1187d6423c6634cf941ac", "filename": "src/libcore/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -69,6 +69,6 @@ mod std {\n  * any code paths following the appearance of this function as unreachable.\n  */\n fn unreachable() -> ! {\n-    fail \"Internal error: entered unreachable code\";\n+    fail ~\"Internal error: entered unreachable code\";\n }\n "}, {"sha": "4fdad63eec581d136cec85884db5d2281e3f69d7", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -32,10 +32,10 @@ impl private_methods<T> for dlist_node<T> {\n                 alt neighbour.prev {\n                     some(me) {\n                         if !box::ptr_eq(*self, *me) {\n-                            fail \"Asymmetric next-link in dlist node.\"\n+                            fail ~\"Asymmetric next-link in dlist node.\"\n                         }\n                     }\n-                    none { fail \"One-way next-link in dlist node.\" }\n+                    none { fail ~\"One-way next-link in dlist node.\" }\n                 }\n             }\n             none { }\n@@ -45,10 +45,10 @@ impl private_methods<T> for dlist_node<T> {\n                 alt neighbour.next {\n                     some(me) {\n                         if !box::ptr_eq(*me, *self) {\n-                            fail \"Asymmetric prev-link in dlist node.\"\n+                            fail ~\"Asymmetric prev-link in dlist node.\"\n                         }\n                     }\n-                    none { fail \"One-way prev-link in dlist node.\" }\n+                    none { fail ~\"One-way prev-link in dlist node.\" }\n                 }\n             }\n             none { }\n@@ -66,7 +66,7 @@ impl extensions<T> for dlist_node<T> {\n     pure fn next_node() -> dlist_node<T> {\n         alt self.next_link() {\n             some(nobe) { nobe }\n-            none       { fail \"This dlist node has no next neighbour.\" }\n+            none       { fail ~\"This dlist node has no next neighbour.\" }\n         }\n     }\n     /// Get the previous node in the list, if there is one.\n@@ -78,7 +78,7 @@ impl extensions<T> for dlist_node<T> {\n     pure fn prev_node() -> dlist_node<T> {\n         alt self.prev_link() {\n             some(nobe) { nobe }\n-            none       { fail \"This dlist node has no previous neighbour.\" }\n+            none       { fail ~\"This dlist node has no previous neighbour.\" }\n         }\n     }\n \n@@ -87,7 +87,7 @@ impl extensions<T> for dlist_node<T> {\n         if option::is_some(self.root) {\n             option::get(self.root).remove(self);\n         } else {\n-            fail \"Removing an orphaned dlist node - what do I remove from?\"\n+            fail ~\"Removing an orphaned dlist node - what do I remove from?\"\n         }\n     }\n }\n@@ -124,12 +124,12 @@ impl private_methods<T> for dlist<T> {\n     pure fn assert_mine(nobe: dlist_node<T>) {\n         alt nobe.root {\n             some(me) { assert box::ptr_eq(*self, *me); }\n-            none     { fail \"This node isn't on this dlist.\" }\n+            none     { fail ~\"This node isn't on this dlist.\" }\n         }\n     }\n     fn make_mine(nobe: dlist_node<T>) {\n         if option::is_some(nobe.root) {\n-            fail \"Cannot insert node that's already on a dlist!\"\n+            fail ~\"Cannot insert node that's already on a dlist!\"\n         }\n         nobe.root = some(self);\n     }\n@@ -287,14 +287,18 @@ impl extensions<T> for dlist<T> {\n     pure fn head_n() -> dlist_node<T> {\n         alt self.hd {\n             some(nobe) { nobe }\n-            none       { fail \"Attempted to get the head of an empty dlist.\" }\n+            none       {\n+              fail ~\"Attempted to get the head of an empty dlist.\"\n+            }\n         }\n     }\n     /// Get the node at the list's tail, failing if empty. O(1).\n     pure fn tail_n() -> dlist_node<T> {\n         alt self.tl {\n             some(nobe) { nobe }\n-            none       { fail \"Attempted to get the tail of an empty dlist.\" }\n+            none       {\n+              fail ~\"Attempted to get the tail of an empty dlist.\"\n+            }\n         }\n     }\n "}, {"sha": "2a5df0ea1563559dd6a14d46dc3d2a5daa7cd4d3", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -80,7 +80,7 @@ impl private_methods<A> for dvec<A> {\n         unsafe {\n             let data: *() = unsafe::reinterpret_cast(self.data);\n             if data.is_null() {\n-                fail \"Recursive use of dvec\";\n+                fail ~\"Recursive use of dvec\";\n             }\n         }\n     }\n@@ -91,7 +91,7 @@ impl private_methods<A> for dvec<A> {\n             let mut data = unsafe::reinterpret_cast(null::<()>());\n             data <-> self.data;\n             let data_ptr: *() = unsafe::reinterpret_cast(data);\n-            if data_ptr.is_null() { fail \"Recursive use of dvec\"; }\n+            if data_ptr.is_null() { fail ~\"Recursive use of dvec\"; }\n             ret f(data);\n         }\n     }\n@@ -149,11 +149,11 @@ impl extensions<A> for dvec<A> {\n             let mut data = unsafe::reinterpret_cast(null::<()>());\n             data <-> self.data;\n             let data_ptr: *() = unsafe::reinterpret_cast(data);\n-            if data_ptr.is_null() { fail \"Recursive use of dvec\"; }\n-            log(error, \"a\");\n+            if data_ptr.is_null() { fail ~\"Recursive use of dvec\"; }\n+            log(error, ~\"a\");\n             self.data <- ~[mut t];\n             vec::push_all_move(self.data, data);\n-            log(error, \"b\");\n+            log(error, ~\"b\");\n         }\n     }\n \n@@ -276,7 +276,7 @@ impl extensions<A:copy> for dvec<A> {\n \n         let length = self.len();\n         if length == 0u {\n-            fail \"attempt to retrieve the last element of an empty vector\";\n+            fail ~\"attempt to retrieve the last element of an empty vector\";\n         }\n \n         ret self.data[length - 1u];"}, {"sha": "09910ce5cff0761fa3b821eff28b7111ac1ff402", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -78,31 +78,31 @@ mod ct {\n \n \n     // A fragment of the output sequence\n-    enum piece { piece_string(str), piece_conv(conv), }\n-    type error_fn = fn@(str) -> ! ;\n+    enum piece { piece_string(~str), piece_conv(conv), }\n+    type error_fn = fn@(~str) -> ! ;\n \n-    fn parse_fmt_string(s: str, error: error_fn) -> ~[piece] {\n+    fn parse_fmt_string(s: ~str, error: error_fn) -> ~[piece] {\n         let mut pieces: ~[piece] = ~[];\n         let lim = str::len(s);\n-        let mut buf = \"\";\n-        fn flush_buf(buf: str, &pieces: ~[piece]) -> str {\n+        let mut buf = ~\"\";\n+        fn flush_buf(buf: ~str, &pieces: ~[piece]) -> ~str {\n             if str::len(buf) > 0u {\n                 let piece = piece_string(buf);\n                 vec::push(pieces, piece);\n             }\n-            ret \"\";\n+            ret ~\"\";\n         }\n         let mut i = 0u;\n         while i < lim {\n             let size = str::utf8_char_width(s[i]);\n             let curr = str::slice(s, i, i+size);\n-            if str::eq(curr, \"%\") {\n+            if str::eq(curr, ~\"%\") {\n                 i += 1u;\n                 if i >= lim {\n-                    error(\"unterminated conversion at end of string\");\n+                    error(~\"unterminated conversion at end of string\");\n                 }\n                 let curr2 = str::slice(s, i, i+1u);\n-                if str::eq(curr2, \"%\") {\n+                if str::eq(curr2, ~\"%\") {\n                     buf += curr2;\n                     i += 1u;\n                 } else {\n@@ -116,7 +116,7 @@ mod ct {\n         flush_buf(buf, pieces);\n         ret pieces;\n     }\n-    fn peek_num(s: str, i: uint, lim: uint) ->\n+    fn peek_num(s: ~str, i: uint, lim: uint) ->\n        option<{num: uint, next: uint}> {\n         if i >= lim { ret none; }\n         let c = s[i];\n@@ -131,7 +131,7 @@ mod ct {\n               }\n             };\n     }\n-    fn parse_conversion(s: str, i: uint, lim: uint, error: error_fn) ->\n+    fn parse_conversion(s: ~str, i: uint, lim: uint, error: error_fn) ->\n        {piece: piece, next: uint} {\n         let parm = parse_parameter(s, i, lim);\n         let flags = parse_flags(s, parm.next, lim);\n@@ -146,7 +146,7 @@ mod ct {\n                              ty: ty.ty}),\n              next: ty.next};\n     }\n-    fn parse_parameter(s: str, i: uint, lim: uint) ->\n+    fn parse_parameter(s: ~str, i: uint, lim: uint) ->\n        {param: option<int>, next: uint} {\n         if i >= lim { ret {param: none, next: i}; }\n         let num = peek_num(s, i, lim);\n@@ -161,12 +161,12 @@ mod ct {\n               }\n             };\n     }\n-    fn parse_flags(s: str, i: uint, lim: uint) ->\n+    fn parse_flags(s: ~str, i: uint, lim: uint) ->\n        {flags: ~[flag], next: uint} {\n         let noflags: ~[flag] = ~[];\n         if i >= lim { ret {flags: noflags, next: i}; }\n \n-        fn more_(f: flag, s: str, i: uint, lim: uint) ->\n+        fn more_(f: flag, s: ~str, i: uint, lim: uint) ->\n            {flags: ~[flag], next: uint} {\n             let next = parse_flags(s, i + 1u, lim);\n             let rest = next.flags;\n@@ -188,7 +188,8 @@ mod ct {\n                 more(flag_alternate)\n             } else { {flags: noflags, next: i} };\n     }\n-    fn parse_count(s: str, i: uint, lim: uint) -> {count: count, next: uint} {\n+    fn parse_count(s: ~str, i: uint, lim: uint)\n+        -> {count: count, next: uint} {\n         ret if i >= lim {\n                 {count: count_implied, next: i}\n             } else if s[i] == '*' as u8 {\n@@ -208,7 +209,7 @@ mod ct {\n                 }\n             };\n     }\n-    fn parse_precision(s: str, i: uint, lim: uint) ->\n+    fn parse_precision(s: ~str, i: uint, lim: uint) ->\n        {count: count, next: uint} {\n         ret if i >= lim {\n                 {count: count_implied, next: i}\n@@ -224,36 +225,36 @@ mod ct {\n                 }\n             } else { {count: count_implied, next: i} };\n     }\n-    fn parse_type(s: str, i: uint, lim: uint, error: error_fn) ->\n+    fn parse_type(s: ~str, i: uint, lim: uint, error: error_fn) ->\n        {ty: ty, next: uint} {\n-        if i >= lim { error(\"missing type in conversion\"); }\n+        if i >= lim { error(~\"missing type in conversion\"); }\n         let tstr = str::slice(s, i, i+1u);\n         // FIXME (#2249): Do we really want two signed types here?\n         // How important is it to be printf compatible?\n         let t =\n-            if str::eq(tstr, \"b\") {\n+            if str::eq(tstr, ~\"b\") {\n                 ty_bool\n-            } else if str::eq(tstr, \"s\") {\n+            } else if str::eq(tstr, ~\"s\") {\n                 ty_str\n-            } else if str::eq(tstr, \"c\") {\n+            } else if str::eq(tstr, ~\"c\") {\n                 ty_char\n-            } else if str::eq(tstr, \"d\") || str::eq(tstr, \"i\") {\n+            } else if str::eq(tstr, ~\"d\") || str::eq(tstr, ~\"i\") {\n                 ty_int(signed)\n-            } else if str::eq(tstr, \"u\") {\n+            } else if str::eq(tstr, ~\"u\") {\n                 ty_int(unsigned)\n-            } else if str::eq(tstr, \"x\") {\n+            } else if str::eq(tstr, ~\"x\") {\n                 ty_hex(case_lower)\n-            } else if str::eq(tstr, \"X\") {\n+            } else if str::eq(tstr, ~\"X\") {\n                 ty_hex(case_upper)\n-            } else if str::eq(tstr, \"t\") {\n+            } else if str::eq(tstr, ~\"t\") {\n                 ty_bits\n-            } else if str::eq(tstr, \"o\") {\n+            } else if str::eq(tstr, ~\"o\") {\n                 ty_octal\n-            } else if str::eq(tstr, \"f\") {\n+            } else if str::eq(tstr, ~\"f\") {\n                 ty_float\n-            } else if str::eq(tstr, \"?\") {\n+            } else if str::eq(tstr, ~\"?\") {\n                 ty_poly\n-            } else { error(\"unknown type in conversion: \" + tstr) };\n+            } else { error(~\"unknown type in conversion: \" + tstr) };\n         ret {ty: t, next: i + 1u};\n     }\n }\n@@ -276,10 +277,10 @@ mod rt {\n \n     type conv = {flags: u32, width: count, precision: count, ty: ty};\n \n-    fn conv_int(cv: conv, i: int) -> str {\n+    fn conv_int(cv: conv, i: int) -> ~str {\n         let radix = 10u;\n         let prec = get_int_precision(cv);\n-        let mut s : str = int_to_str_prec(i, radix, prec);\n+        let mut s : ~str = int_to_str_prec(i, radix, prec);\n         if 0 <= i {\n             if have_flag(cv.flags, flag_sign_always) {\n                 str::unshift_char(s, '+');\n@@ -289,7 +290,7 @@ mod rt {\n         }\n         ret pad(cv, s, pad_signed);\n     }\n-    fn conv_uint(cv: conv, u: uint) -> str {\n+    fn conv_uint(cv: conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n         let mut rs =\n             alt cv.ty {\n@@ -301,17 +302,17 @@ mod rt {\n             };\n         ret pad(cv, rs, pad_unsigned);\n     }\n-    fn conv_bool(cv: conv, b: bool) -> str {\n-        let s = if b { \"true\" } else { \"false\" };\n+    fn conv_bool(cv: conv, b: bool) -> ~str {\n+        let s = if b { ~\"true\" } else { ~\"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n         ret conv_str(cv, s);\n     }\n-    fn conv_char(cv: conv, c: char) -> str {\n+    fn conv_char(cv: conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n         ret pad(cv, s, pad_nozero);\n     }\n-    fn conv_str(cv: conv, s: str) -> str {\n+    fn conv_str(cv: conv, s: ~str) -> ~str {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = alt cv.precision {\n@@ -324,40 +325,40 @@ mod rt {\n         };\n         ret pad(cv, unpadded, pad_nozero);\n     }\n-    fn conv_float(cv: conv, f: float) -> str {\n+    fn conv_float(cv: conv, f: float) -> ~str {\n         let (to_str, digits) = alt cv.precision {\n               count_is(c) { (float::to_str_exact, c as uint) }\n               count_implied { (float::to_str, 6u) }\n         };\n         let mut s = to_str(f, digits);\n         if 0.0 <= f {\n             if have_flag(cv.flags, flag_sign_always) {\n-                s = \"+\" + s;\n+                s = ~\"+\" + s;\n             } else if have_flag(cv.flags, flag_space_for_sign) {\n-                s = \" \" + s;\n+                s = ~\" \" + s;\n             }\n         }\n         ret pad(cv, s, pad_float);\n     }\n-    fn conv_poly<T>(cv: conv, v: T) -> str {\n+    fn conv_poly<T>(cv: conv, v: T) -> ~str {\n         let s = sys::log_str(v);\n         ret conv_str(cv, s);\n     }\n \n     // Convert an int to string with minimum number of digits. If precision is\n     // 0 and num is 0 then the result is the empty string.\n-    fn int_to_str_prec(num: int, radix: uint, prec: uint) -> str {\n+    fn int_to_str_prec(num: int, radix: uint, prec: uint) -> ~str {\n         ret if num < 0 {\n-                \"-\" + uint_to_str_prec(-num as uint, radix, prec)\n+                ~\"-\" + uint_to_str_prec(-num as uint, radix, prec)\n             } else { uint_to_str_prec(num as uint, radix, prec) };\n     }\n \n     // Convert a uint to string with a minimum number of digits.  If precision\n     // is 0 and num is 0 then the result is the empty string. Could move this\n     // to uint: but it doesn't seem all that useful.\n-    fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> str {\n+    fn uint_to_str_prec(num: uint, radix: uint, prec: uint) -> ~str {\n         ret if prec == 0u && num == 0u {\n-                \"\"\n+                ~\"\"\n             } else {\n                 let s = uint::to_str(num, radix);\n                 let len = str::char_len(s);\n@@ -375,7 +376,7 @@ mod rt {\n             };\n     }\n     enum pad_mode { pad_signed, pad_unsigned, pad_nozero, pad_float }\n-    fn pad(cv: conv, &s: str, mode: pad_mode) -> str {\n+    fn pad(cv: conv, &s: ~str, mode: pad_mode) -> ~str {\n         let uwidth : uint = alt cv.width {\n           count_implied { ret s; }\n           count_is(width) {"}, {"sha": "0139c60873b8868ee5dee398869ea100d1862ccd", "filename": "src/libcore/float.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -102,12 +102,12 @@ mod consts {\n  * * digits - The number of significant digits\n  * * exact - Whether to enforce the exact number of significant digits\n  */\n-fn to_str_common(num: float, digits: uint, exact: bool) -> str {\n-    if is_NaN(num) { ret \"NaN\"; }\n-    if num == infinity { ret \"inf\"; }\n-    if num == neg_infinity { ret \"-inf\"; }\n+fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n+    if is_NaN(num) { ret ~\"NaN\"; }\n+    if num == infinity { ret ~\"inf\"; }\n+    if num == neg_infinity { ret ~\"-inf\"; }\n \n-    let mut (num, sign) = if num < 0.0 { (-num, \"-\") } else { (num, \"\") };\n+    let mut (num, sign) = if num < 0.0 { (-num, ~\"-\") } else { (num, ~\"\") };\n \n     // truncated integer\n     let trunc = num as uint;\n@@ -145,7 +145,7 @@ fn to_str_common(num: float, digits: uint, exact: bool) -> str {\n     }\n \n     let mut acc;\n-    let mut racc = \"\";\n+    let mut racc = ~\"\";\n     let mut carry = if frac * 10.0 as uint >= 5u { 1u } else { 0u };\n \n     // turn digits into string\n@@ -165,15 +165,15 @@ fn to_str_common(num: float, digits: uint, exact: bool) -> str {\n \n     // pad decimals with trailing zeroes\n     while str::len(racc) < digits && exact {\n-        racc += \"0\"\n+        racc += ~\"0\"\n     }\n \n     // combine ints and decimals\n     let mut ones = uint::str(trunc + carry);\n-    if racc == \"\" {\n+    if racc == ~\"\" {\n         acc = sign + ones;\n     } else {\n-        acc = sign + ones + \".\" + racc;\n+        acc = sign + ones + ~\".\" + racc;\n     }\n \n     ret acc;\n@@ -188,14 +188,14 @@ fn to_str_common(num: float, digits: uint, exact: bool) -> str {\n  * * num - The float value\n  * * digits - The number of significant digits\n  */\n-fn to_str_exact(num: float, digits: uint) -> str {\n+fn to_str_exact(num: float, digits: uint) -> ~str {\n     to_str_common(num, digits, true)\n }\n \n #[test]\n fn test_to_str_exact_do_decimal() {\n     let s = to_str_exact(5.0, 4u);\n-    assert s == \"5.0000\";\n+    assert s == ~\"5.0000\";\n }\n \n \n@@ -208,7 +208,7 @@ fn test_to_str_exact_do_decimal() {\n  * * num - The float value\n  * * digits - The number of significant digits\n  */\n-fn to_str(num: float, digits: uint) -> str {\n+fn to_str(num: float, digits: uint) -> ~str {\n     to_str_common(num, digits, false)\n }\n \n@@ -238,12 +238,12 @@ fn to_str(num: float, digits: uint) -> str {\n  * `none` if the string did not represent a valid number.  Otherwise,\n  * `some(n)` where `n` is the floating-point number represented by `[num]`.\n  */\n-fn from_str(num: str) -> option<float> {\n-   if num == \"inf\" {\n+fn from_str(num: ~str) -> option<float> {\n+   if num == ~\"inf\" {\n        ret some(infinity as float);\n-   } else if num == \"-inf\" {\n+   } else if num == ~\"-inf\" {\n        ret some(neg_infinity as float);\n-   } else if num == \"NaN\" {\n+   } else if num == ~\"NaN\" {\n        ret some(NaN as float);\n    }\n \n@@ -433,45 +433,45 @@ impl num of num::num for float {\n \n #[test]\n fn test_from_str() {\n-   assert from_str(\"3\") == some(3.);\n-   assert from_str(\"3\") == some(3.);\n-   assert from_str(\"3.14\") == some(3.14);\n-   assert from_str(\"+3.14\") == some(3.14);\n-   assert from_str(\"-3.14\") == some(-3.14);\n-   assert from_str(\"2.5E10\") == some(25000000000.);\n-   assert from_str(\"2.5e10\") == some(25000000000.);\n-   assert from_str(\"25000000000.E-10\") == some(2.5);\n-   assert from_str(\".\") == some(0.);\n-   assert from_str(\".e1\") == some(0.);\n-   assert from_str(\".e-1\") == some(0.);\n-   assert from_str(\"5.\") == some(5.);\n-   assert from_str(\".5\") == some(0.5);\n-   assert from_str(\"0.5\") == some(0.5);\n-   assert from_str(\"0.5\") == some(0.5);\n-   assert from_str(\"0.5\") == some(0.5);\n-   assert from_str(\"-.5\") == some(-0.5);\n-   assert from_str(\"-.5\") == some(-0.5);\n-   assert from_str(\"-5\") == some(-5.);\n-   assert from_str(\"-0\") == some(-0.);\n-   assert from_str(\"0\") == some(0.);\n-   assert from_str(\"inf\") == some(infinity);\n-   assert from_str(\"-inf\") == some(neg_infinity);\n+   assert from_str(~\"3\") == some(3.);\n+   assert from_str(~\"3\") == some(3.);\n+   assert from_str(~\"3.14\") == some(3.14);\n+   assert from_str(~\"+3.14\") == some(3.14);\n+   assert from_str(~\"-3.14\") == some(-3.14);\n+   assert from_str(~\"2.5E10\") == some(25000000000.);\n+   assert from_str(~\"2.5e10\") == some(25000000000.);\n+   assert from_str(~\"25000000000.E-10\") == some(2.5);\n+   assert from_str(~\".\") == some(0.);\n+   assert from_str(~\".e1\") == some(0.);\n+   assert from_str(~\".e-1\") == some(0.);\n+   assert from_str(~\"5.\") == some(5.);\n+   assert from_str(~\".5\") == some(0.5);\n+   assert from_str(~\"0.5\") == some(0.5);\n+   assert from_str(~\"0.5\") == some(0.5);\n+   assert from_str(~\"0.5\") == some(0.5);\n+   assert from_str(~\"-.5\") == some(-0.5);\n+   assert from_str(~\"-.5\") == some(-0.5);\n+   assert from_str(~\"-5\") == some(-5.);\n+   assert from_str(~\"-0\") == some(-0.);\n+   assert from_str(~\"0\") == some(0.);\n+   assert from_str(~\"inf\") == some(infinity);\n+   assert from_str(~\"-inf\") == some(neg_infinity);\n    // note: NaN != NaN, hence this slightly complex test\n-   alt from_str(\"NaN\") {\n+   alt from_str(~\"NaN\") {\n        some(f) { assert is_NaN(f); }\n        none { fail; }\n    }\n \n-   assert from_str(\"\") == none;\n-   assert from_str(\"x\") == none;\n-   assert from_str(\" \") == none;\n-   assert from_str(\"   \") == none;\n-   assert from_str(\"e\") == none;\n-   assert from_str(\"E\") == none;\n-   assert from_str(\"E1\") == none;\n-   assert from_str(\"1e1e1\") == none;\n-   assert from_str(\"1e1.1\") == none;\n-   assert from_str(\"1e1-1\") == none;\n+   assert from_str(~\"\") == none;\n+   assert from_str(~\"x\") == none;\n+   assert from_str(~\" \") == none;\n+   assert from_str(~\"   \") == none;\n+   assert from_str(~\"e\") == none;\n+   assert from_str(~\"E\") == none;\n+   assert from_str(~\"E1\") == none;\n+   assert from_str(~\"1e1e1\") == none;\n+   assert from_str(~\"1e1.1\") == none;\n+   assert from_str(~\"1e1-1\") == none;\n }\n \n #[test]\n@@ -520,8 +520,8 @@ fn test_nonnegative() {\n \n #[test]\n fn test_to_str_inf() {\n-    assert to_str(infinity, 10u) == \"inf\";\n-    assert to_str(-infinity, 10u) == \"-inf\";\n+    assert to_str(infinity, 10u) == ~\"inf\";\n+    assert to_str(-infinity, 10u) == ~\"-inf\";\n }\n \n #[test]"}, {"sha": "f26643a6cab4238d52e8146dba0f516c82679a64", "filename": "src/libcore/future.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -143,53 +143,53 @@ proto! future_pipe {\n \n #[test]\n fn test_from_value() {\n-    let f = from_value(\"snail\");\n-    assert get(f) == \"snail\";\n+    let f = from_value(~\"snail\");\n+    assert get(f) == ~\"snail\";\n }\n \n #[test]\n fn test_from_port() {\n     let (po, ch) = future_pipe::init();\n-    future_pipe::server::completed(ch, \"whale\");\n+    future_pipe::server::completed(ch, ~\"whale\");\n     let f = from_port(po);\n-    assert get(f) == \"whale\";\n+    assert get(f) == ~\"whale\";\n }\n \n #[test]\n fn test_from_fn() {\n-    let f = fn@() -> str { \"brail\" };\n+    let f = fn@() -> ~str { ~\"brail\" };\n     let f = from_fn(f);\n-    assert get(f) == \"brail\";\n+    assert get(f) == ~\"brail\";\n }\n \n #[test]\n fn test_iface_get() {\n-    let f = from_value(\"fail\");\n-    assert f.get() == \"fail\";\n+    let f = from_value(~\"fail\");\n+    assert f.get() == ~\"fail\";\n }\n \n #[test]\n fn test_with() {\n-    let f = from_value(\"nail\");\n-    assert with(f, |v| v) == \"nail\";\n+    let f = from_value(~\"nail\");\n+    assert with(f, |v| v) == ~\"nail\";\n }\n \n #[test]\n fn test_iface_with() {\n-    let f = from_value(\"kale\");\n-    assert f.with(|v| v) == \"kale\";\n+    let f = from_value(~\"kale\");\n+    assert f.with(|v| v) == ~\"kale\";\n }\n \n #[test]\n fn test_spawn() {\n-    let f = spawn(|| \"bale\");\n-    assert get(f) == \"bale\";\n+    let f = spawn(|| ~\"bale\");\n+    assert get(f) == ~\"bale\";\n }\n \n #[test]\n #[should_fail]\n #[ignore(cfg(target_os = \"win32\"))]\n fn test_futurefail() {\n     let f = spawn(|| fail);\n-    let _x: str = get(f);\n+    let _x: ~str = get(f);\n }"}, {"sha": "983d1b9968f3e9f3201fee5486d53e1736c9b91e", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -89,10 +89,10 @@ fn parse_buf(buf: ~[u8], radix: uint) -> option<T> {\n }\n \n /// Parse a string to an int\n-fn from_str(s: str) -> option<T> { parse_buf(str::bytes(s), 10u) }\n+fn from_str(s: ~str) -> option<T> { parse_buf(str::bytes(s), 10u) }\n \n /// Convert to a string in a given base\n-fn to_str(n: T, radix: uint) -> str {\n+fn to_str(n: T, radix: uint) -> ~str {\n     do to_str_bytes(n, radix) |slice| {\n         do vec::unpack_slice(slice) |p, len| {\n             unsafe { str::unsafe::from_buf_len(p, len) }\n@@ -109,7 +109,7 @@ fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n }\n \n /// Convert to a string\n-fn str(i: T) -> str { ret to_str(i, 10u); }\n+fn str(i: T) -> ~str { ret to_str(i, 10u); }\n \n impl ord of ord for T {\n     fn lt(&&other: T) -> bool {\n@@ -159,57 +159,57 @@ impl times of iter::times for T {\n #[test]\n #[ignore]\n fn test_from_str() {\n-    assert from_str(\"0\") == some(0 as T);\n-    assert from_str(\"3\") == some(3 as T);\n-    assert from_str(\"10\") == some(10 as T);\n-    assert from_str(\"123456789\") == some(123456789 as T);\n-    assert from_str(\"00100\") == some(100 as T);\n+    assert from_str(~\"0\") == some(0 as T);\n+    assert from_str(~\"3\") == some(3 as T);\n+    assert from_str(~\"10\") == some(10 as T);\n+    assert from_str(~\"123456789\") == some(123456789 as T);\n+    assert from_str(~\"00100\") == some(100 as T);\n \n-    assert from_str(\"-1\") == some(-1 as T);\n-    assert from_str(\"-3\") == some(-3 as T);\n-    assert from_str(\"-10\") == some(-10 as T);\n-    assert from_str(\"-123456789\") == some(-123456789 as T);\n-    assert from_str(\"-00100\") == some(-100 as T);\n+    assert from_str(~\"-1\") == some(-1 as T);\n+    assert from_str(~\"-3\") == some(-3 as T);\n+    assert from_str(~\"-10\") == some(-10 as T);\n+    assert from_str(~\"-123456789\") == some(-123456789 as T);\n+    assert from_str(~\"-00100\") == some(-100 as T);\n \n-    assert from_str(\" \") == none;\n-    assert from_str(\"x\") == none;\n+    assert from_str(~\" \") == none;\n+    assert from_str(~\"x\") == none;\n }\n \n // FIXME: Has alignment issues on windows and 32-bit linux (#2609)\n #[test]\n #[ignore]\n fn test_parse_buf() {\n     import str::bytes;\n-    assert parse_buf(bytes(\"123\"), 10u) == some(123 as T);\n-    assert parse_buf(bytes(\"1001\"), 2u) == some(9 as T);\n-    assert parse_buf(bytes(\"123\"), 8u) == some(83 as T);\n-    assert parse_buf(bytes(\"123\"), 16u) == some(291 as T);\n-    assert parse_buf(bytes(\"ffff\"), 16u) == some(65535 as T);\n-    assert parse_buf(bytes(\"FFFF\"), 16u) == some(65535 as T);\n-    assert parse_buf(bytes(\"z\"), 36u) == some(35 as T);\n-    assert parse_buf(bytes(\"Z\"), 36u) == some(35 as T);\n-\n-    assert parse_buf(bytes(\"-123\"), 10u) == some(-123 as T);\n-    assert parse_buf(bytes(\"-1001\"), 2u) == some(-9 as T);\n-    assert parse_buf(bytes(\"-123\"), 8u) == some(-83 as T);\n-    assert parse_buf(bytes(\"-123\"), 16u) == some(-291 as T);\n-    assert parse_buf(bytes(\"-ffff\"), 16u) == some(-65535 as T);\n-    assert parse_buf(bytes(\"-FFFF\"), 16u) == some(-65535 as T);\n-    assert parse_buf(bytes(\"-z\"), 36u) == some(-35 as T);\n-    assert parse_buf(bytes(\"-Z\"), 36u) == some(-35 as T);\n-\n-    assert parse_buf(str::bytes(\"Z\"), 35u) == none;\n-    assert parse_buf(str::bytes(\"-9\"), 2u) == none;\n+    assert parse_buf(bytes(~\"123\"), 10u) == some(123 as T);\n+    assert parse_buf(bytes(~\"1001\"), 2u) == some(9 as T);\n+    assert parse_buf(bytes(~\"123\"), 8u) == some(83 as T);\n+    assert parse_buf(bytes(~\"123\"), 16u) == some(291 as T);\n+    assert parse_buf(bytes(~\"ffff\"), 16u) == some(65535 as T);\n+    assert parse_buf(bytes(~\"FFFF\"), 16u) == some(65535 as T);\n+    assert parse_buf(bytes(~\"z\"), 36u) == some(35 as T);\n+    assert parse_buf(bytes(~\"Z\"), 36u) == some(35 as T);\n+\n+    assert parse_buf(bytes(~\"-123\"), 10u) == some(-123 as T);\n+    assert parse_buf(bytes(~\"-1001\"), 2u) == some(-9 as T);\n+    assert parse_buf(bytes(~\"-123\"), 8u) == some(-83 as T);\n+    assert parse_buf(bytes(~\"-123\"), 16u) == some(-291 as T);\n+    assert parse_buf(bytes(~\"-ffff\"), 16u) == some(-65535 as T);\n+    assert parse_buf(bytes(~\"-FFFF\"), 16u) == some(-65535 as T);\n+    assert parse_buf(bytes(~\"-z\"), 36u) == some(-35 as T);\n+    assert parse_buf(bytes(~\"-Z\"), 36u) == some(-35 as T);\n+\n+    assert parse_buf(str::bytes(~\"Z\"), 35u) == none;\n+    assert parse_buf(str::bytes(~\"-9\"), 2u) == none;\n }\n \n #[test]\n fn test_to_str() {\n     import str::eq;\n-    assert (eq(to_str(0 as T, 10u), \"0\"));\n-    assert (eq(to_str(1 as T, 10u), \"1\"));\n-    assert (eq(to_str(-1 as T, 10u), \"-1\"));\n-    assert (eq(to_str(127 as T, 16u), \"7f\"));\n-    assert (eq(to_str(100 as T, 10u), \"100\"));\n+    assert (eq(to_str(0 as T, 10u), ~\"0\"));\n+    assert (eq(to_str(1 as T, 10u), ~\"1\"));\n+    assert (eq(to_str(-1 as T, 10u), ~\"-1\"));\n+    assert (eq(to_str(127 as T, 16u), ~\"7f\"));\n+    assert (eq(to_str(100 as T, 10u), ~\"100\"));\n }\n \n #[test]\n@@ -243,5 +243,5 @@ fn test_times() {\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_times_negative() {\n-    for (-10).times { log(error, \"nope!\"); }\n+    for (-10).times { log(error, ~\"nope!\"); }\n }"}, {"sha": "cb4b94b8286f4e5683a6efddd8f5848f598391aa", "filename": "src/libcore/io.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -109,7 +109,7 @@ impl reader_util for reader {\n         ret c[0];\n     }\n \n-    fn read_line() -> str {\n+    fn read_line() -> ~str {\n         let mut buf = ~[];\n         loop {\n             let ch = self.read_byte();\n@@ -119,7 +119,7 @@ impl reader_util for reader {\n         str::from_bytes(buf)\n     }\n \n-    fn read_c_str() -> str {\n+    fn read_c_str() -> ~str {\n         let mut buf: ~[u8] = ~[];\n         loop {\n             let ch = self.read_byte();\n@@ -174,7 +174,7 @@ impl reader_util for reader {\n         }\n     }\n \n-    fn each_line(it: fn(str) -> bool) {\n+    fn each_line(it: fn(~str) -> bool) {\n         while !self.eof() {\n             if !it(self.read_line()) { break; }\n         }\n@@ -244,13 +244,13 @@ fn FILE_reader(f: *libc::FILE, cleanup: bool) -> reader {\n \n fn stdin() -> reader { rustrt::rust_get_stdin() as reader }\n \n-fn file_reader(path: str) -> result<reader, str> {\n+fn file_reader(path: ~str) -> result<reader, ~str> {\n     let f = os::as_c_charp(path, |pathbuf| {\n-        os::as_c_charp(\"r\", |modebuf|\n+        os::as_c_charp(~\"r\", |modebuf|\n             libc::fopen(pathbuf, modebuf)\n         )\n     });\n-    ret if f as uint == 0u { result::err(\"error opening \" + path) }\n+    ret if f as uint == 0u { result::err(~\"error opening \" + path) }\n     else {\n         result::ok(FILE_reader(f, true))\n     }\n@@ -303,11 +303,11 @@ fn with_bytes_reader_between<t>(bytes: ~[u8], start: uint, end: uint,\n     f(bytes_reader_between(bytes, start, end))\n }\n \n-fn str_reader(s: str) -> reader {\n+fn str_reader(s: ~str) -> reader {\n     bytes_reader(str::bytes(s))\n }\n \n-fn with_str_reader<T>(s: str, f: fn(reader) -> T) -> T {\n+fn with_str_reader<T>(s: ~str, f: fn(reader) -> T) -> T {\n     do str::as_bytes(s) |bytes| {\n         with_bytes_reader_between(bytes, 0u, str::len(s), f)\n     }\n@@ -402,8 +402,8 @@ fn fd_writer(fd: fd_t, cleanup: bool) -> writer {\n }\n \n \n-fn mk_file_writer(path: str, flags: ~[fileflag])\n-    -> result<writer, str> {\n+fn mk_file_writer(path: ~str, flags: ~[fileflag])\n+    -> result<writer, ~str> {\n \n     #[cfg(windows)]\n     fn wb() -> c_int { (O_WRONLY | O_BINARY) as c_int }\n@@ -514,10 +514,10 @@ impl writer_util for writer {\n             self.write_str(str::from_char(ch));\n         }\n     }\n-    fn write_str(s: str/&) { str::byte_slice(s, |v| self.write(v)) }\n-    fn write_line(s: str/&) {\n+    fn write_str(s: &str) { str::byte_slice(s, |v| self.write(v)) }\n+    fn write_line(s: &str) {\n         self.write_str(s);\n-        self.write_str(\"\\n\"/&);\n+        self.write_str(&\"\\n\");\n     }\n     fn write_int(n: int) {\n         int::to_str_bytes(n, 10u, |buf| self.write(buf))\n@@ -577,19 +577,19 @@ impl writer_util for writer {\n     fn write_u8(n: u8) { self.write(&[n]) }\n }\n \n-fn file_writer(path: str, flags: ~[fileflag]) -> result<writer, str> {\n+fn file_writer(path: ~str, flags: ~[fileflag]) -> result<writer, ~str> {\n     result::chain(mk_file_writer(path, flags), |w| result::ok(w))\n }\n \n \n // FIXME: fileflags // #2004\n-fn buffered_file_writer(path: str) -> result<writer, str> {\n+fn buffered_file_writer(path: ~str) -> result<writer, ~str> {\n     let f = do os::as_c_charp(path) |pathbuf| {\n-        do os::as_c_charp(\"w\") |modebuf| {\n+        do os::as_c_charp(~\"w\") |modebuf| {\n             libc::fopen(pathbuf, modebuf)\n         }\n     };\n-    ret if f as uint == 0u { result::err(\"error opening \" + path) }\n+    ret if f as uint == 0u { result::err(~\"error opening \" + path) }\n     else { result::ok(FILE_writer(f, true)) }\n }\n \n@@ -599,8 +599,8 @@ fn buffered_file_writer(path: str) -> result<writer, str> {\n fn stdout() -> writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n fn stderr() -> writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n \n-fn print(s: str) { stdout().write_str(s); }\n-fn println(s: str) { stdout().write_line(s); }\n+fn print(s: ~str) { stdout().write_str(s); }\n+fn println(s: ~str) { stdout().write_line(s); }\n \n type mem_buffer = @{buf: dvec<u8>, mut pos: uint};\n \n@@ -639,11 +639,11 @@ fn mem_buffer() -> mem_buffer {\n }\n fn mem_buffer_writer(b: mem_buffer) -> writer { b as writer }\n fn mem_buffer_buf(b: mem_buffer) -> ~[u8] { b.buf.get() }\n-fn mem_buffer_str(b: mem_buffer) -> str {\n+fn mem_buffer_str(b: mem_buffer) -> ~str {\n     str::from_bytes(b.buf.get())\n }\n \n-fn with_str_writer(f: fn(writer)) -> str {\n+fn with_str_writer(f: fn(writer)) -> ~str {\n     let buf = mem_buffer();\n     let wr = mem_buffer_writer(buf);\n     f(wr);\n@@ -671,15 +671,15 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n     ret bpos as uint;\n }\n \n-fn read_whole_file_str(file: str) -> result<str, str> {\n+fn read_whole_file_str(file: ~str) -> result<~str, ~str> {\n     result::chain(read_whole_file(file), |bytes| {\n         result::ok(str::from_bytes(bytes))\n     })\n }\n \n // FIXME (#2004): implement this in a low-level way. Going through the\n // abstractions is pointless.\n-fn read_whole_file(file: str) -> result<~[u8], str> {\n+fn read_whole_file(file: ~str) -> result<~[u8], ~str> {\n     result::chain(file_reader(file), |rdr| {\n         result::ok(rdr.read_whole_stream())\n     })\n@@ -765,9 +765,10 @@ mod tests {\n \n     #[test]\n     fn test_simple() {\n-        let tmpfile: str = \"tmp/lib-io-test-simple.tmp\";\n+        let tmpfile: ~str = ~\"tmp/lib-io-test-simple.tmp\";\n         log(debug, tmpfile);\n-        let frood: str = \"A hoopy frood who really knows where his towel is.\";\n+        let frood: ~str =\n+            ~\"A hoopy frood who really knows where his towel is.\";\n         log(debug, frood);\n         {\n             let out: io::writer =\n@@ -776,28 +777,28 @@ mod tests {\n             out.write_str(frood);\n         }\n         let inp: io::reader = result::get(io::file_reader(tmpfile));\n-        let frood2: str = inp.read_c_str();\n+        let frood2: ~str = inp.read_c_str();\n         log(debug, frood2);\n         assert (str::eq(frood, frood2));\n     }\n \n     #[test]\n     fn test_readchars_empty() {\n-        let inp : io::reader = io::str_reader(\"\");\n+        let inp : io::reader = io::str_reader(~\"\");\n         let res : ~[char] = inp.read_chars(128u);\n         assert(vec::len(res) == 0u);\n     }\n \n     #[test]\n     fn test_readchars_wide() {\n-        let wide_test = \"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\";\n+        let wide_test = ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\";\n         let ivals : ~[int] = ~[\n             29983, 38152, 30340, 27748,\n             21273, 20999, 32905, 27748,\n             104, 101, 108, 108, 111,\n             29983, 38152, 30340, 27748,\n             21273, 20999, 32905, 27748];\n-        fn check_read_ln(len : uint, s: str, ivals: ~[int]) {\n+        fn check_read_ln(len : uint, s: ~str, ivals: ~[int]) {\n             let inp : io::reader = io::str_reader(s);\n             let res : ~[char] = inp.read_chars(len);\n             if (len <= vec::len(ivals)) {\n@@ -817,43 +818,43 @@ mod tests {\n \n     #[test]\n     fn test_readchar() {\n-        let inp : io::reader = io::str_reader(\"\u751f\");\n+        let inp : io::reader = io::str_reader(~\"\u751f\");\n         let res : char = inp.read_char();\n         assert(res as int == 29983);\n     }\n \n     #[test]\n     fn test_readchar_empty() {\n-        let inp : io::reader = io::str_reader(\"\");\n+        let inp : io::reader = io::str_reader(~\"\");\n         let res : char = inp.read_char();\n         assert(res as int == -1);\n     }\n \n     #[test]\n     fn file_reader_not_exist() {\n-        alt io::file_reader(\"not a file\") {\n+        alt io::file_reader(~\"not a file\") {\n           result::err(e) {\n-            assert e == \"error opening not a file\";\n+            assert e == ~\"error opening not a file\";\n           }\n           result::ok(_) { fail; }\n         }\n     }\n \n     #[test]\n     fn file_writer_bad_name() {\n-        alt io::file_writer(\"?/?\", ~[]) {\n+        alt io::file_writer(~\"?/?\", ~[]) {\n           result::err(e) {\n-            assert str::starts_with(e, \"error opening ?/?\");\n+            assert str::starts_with(e, ~\"error opening ?/?\");\n           }\n           result::ok(_) { fail; }\n         }\n     }\n \n     #[test]\n     fn buffered_file_writer_bad_name() {\n-        alt io::buffered_file_writer(\"?/?\") {\n+        alt io::buffered_file_writer(~\"?/?\") {\n           result::err(e) {\n-            assert e == \"error opening ?/?\";\n+            assert e == ~\"error opening ?/?\";\n           }\n           result::ok(_) { fail; }\n         }"}, {"sha": "e00e51b494116379b2507d81becf136c91a5a34e", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -16,15 +16,15 @@ fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n         // Check dlist invariant.\n         if !option::is_some(nobe.root) ||\n            !box::ptr_eq(*option::get(nobe.root), *self) {\n-            fail \"Iteration encountered a dlist node not on this dlist.\"\n+            fail ~\"Iteration encountered a dlist node not on this dlist.\"\n         }\n         if !f(nobe.data) { break; }\n         // Check that the user didn't do a remove.\n         // Note that this makes it ok for the user to remove the node and then\n         // immediately put it back in a different position. I allow this.\n         if !option::is_some(nobe.root) ||\n            !box::ptr_eq(*option::get(nobe.root), *self) {\n-            fail \"Removing a dlist node during iteration is forbidden!\"\n+            fail ~\"Removing a dlist node during iteration is forbidden!\"\n         }\n         link = nobe.next_link();\n     }"}, {"sha": "e2a321cde23d98592de922bd61aee2ef9f44b471", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -132,7 +132,7 @@ fn min<A:copy,IA:base_iter<A>>(self: IA) -> A {\n         }\n     } {\n         some(val) { val }\n-        none { fail \"min called on empty iterator\" }\n+        none { fail ~\"min called on empty iterator\" }\n     }\n }\n \n@@ -148,7 +148,7 @@ fn max<A:copy,IA:base_iter<A>>(self: IA) -> A {\n         }\n     } {\n         some(val) { val }\n-        none { fail \"max called on empty iterator\" }\n+        none { fail ~\"max called on empty iterator\" }\n     }\n }\n "}, {"sha": "80b3915cb90d5d2112c063b0cf1018ae59e5a04a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -23,10 +23,10 @@ pure fn get<T: copy>(opt: option<T>) -> T {\n      * Fails if the value equals `none`\n      */\n \n-    alt opt { some(x) { ret x; } none { fail \"option none\"; } }\n+    alt opt { some(x) { ret x; } none { fail ~\"option none\"; } }\n }\n \n-pure fn expect<T: copy>(opt: option<T>, reason: str) -> T {\n+pure fn expect<T: copy>(opt: option<T>, reason: ~str) -> T {\n     #[doc = \"\n     Gets the value out of an option, printing a specified message on failure\n \n@@ -93,7 +93,7 @@ pure fn unwrap<T>(-opt: option<T>) -> T {\n     unsafe {\n         let addr = alt opt {\n           some(x) { ptr::addr_of(x) }\n-          none { fail \"option none\" }\n+          none { fail ~\"option none\" }\n         };\n         let liberated_value = unsafe::reinterpret_cast(*addr);\n         unsafe::forget(opt);\n@@ -138,7 +138,7 @@ impl extensions<T: copy> for option<T> {\n      *\n      * Fails if the value equals `none`\n      */\n-    pure fn expect(reason: str) -> T { expect(self, reason) }\n+    pure fn expect(reason: ~str) -> T { expect(self, reason) }\n }\n \n #[test]\n@@ -153,7 +153,7 @@ fn test_unwrap_ptr() {\n \n #[test]\n fn test_unwrap_str() {\n-    let x = \"test\";\n+    let x = ~\"test\";\n     let addr_x = str::as_buf(x, |buf| ptr::addr_of(buf));\n     let opt = some(x);\n     let y = unwrap(opt);"}, {"sha": "24988870c0d3735a5232df3a22d5e4c7b443312a", "filename": "src/libcore/os.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -40,18 +40,18 @@ export walk_dir;\n export as_c_charp, fill_charp_buf;\n \n extern mod rustrt {\n-    fn rust_env_pairs() -> ~[str];\n-    fn rust_getcwd() -> str;\n+    fn rust_env_pairs() -> ~[~str];\n+    fn rust_getcwd() -> ~str;\n     fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n     fn rust_path_exists(path: *libc::c_char) -> c_int;\n-    fn rust_list_files(path: str) -> ~[str];\n+    fn rust_list_files(path: ~str) -> ~[~str];\n     fn rust_process_wait(handle: c_int) -> c_int;\n-    fn last_os_error() -> str;\n+    fn last_os_error() -> ~str;\n     fn rust_set_exit_status(code: libc::intptr_t);\n }\n \n \n-fn env() -> ~[(str,str)] {\n+fn env() -> ~[(~str,~str)] {\n     let mut pairs = ~[];\n     for vec::each(rustrt::rust_env_pairs()) |p| {\n         let vs = str::splitn_char(p, '=', 1u);\n@@ -63,12 +63,12 @@ fn env() -> ~[(str,str)] {\n \n const tmpbuf_sz : uint = 1000u;\n \n-fn as_c_charp<T>(s: str, f: fn(*c_char) -> T) -> T {\n+fn as_c_charp<T>(s: ~str, f: fn(*c_char) -> T) -> T {\n     str::as_c_str(s, |b| f(b as *c_char))\n }\n \n fn fill_charp_buf(f: fn(*mut c_char, size_t) -> bool)\n-    -> option<str> {\n+    -> option<~str> {\n     let buf = vec::to_mut(vec::from_elem(tmpbuf_sz, 0u8 as c_char));\n     do vec::as_mut_buf(buf) |b| {\n         if f(b, tmpbuf_sz as size_t) unsafe {\n@@ -121,11 +121,11 @@ mod win32 {\n     }\n }\n \n-fn getenv(n: str) -> option<str> {\n+fn getenv(n: ~str) -> option<~str> {\n     global_env::getenv(n)\n }\n \n-fn setenv(n: str, v: str) {\n+fn setenv(n: ~str, v: ~str) {\n     global_env::setenv(n, v)\n }\n \n@@ -140,18 +140,18 @@ mod global_env {\n     }\n \n     enum msg {\n-        msg_getenv(str, comm::chan<option<str>>),\n-        msg_setenv(str, str, comm::chan<()>)\n+        msg_getenv(~str, comm::chan<option<~str>>),\n+        msg_setenv(~str, ~str, comm::chan<()>)\n     }\n \n-    fn getenv(n: str) -> option<str> {\n+    fn getenv(n: ~str) -> option<~str> {\n         let env_ch = get_global_env_chan();\n         let po = comm::port();\n         comm::send(env_ch, msg_getenv(n, comm::chan(po)));\n         comm::recv(po)\n     }\n \n-    fn setenv(n: str, v: str) {\n+    fn setenv(n: ~str, v: ~str) {\n         let env_ch = get_global_env_chan();\n         let po = comm::port();\n         comm::send(env_ch, msg_setenv(n, v, comm::chan(po)));\n@@ -199,14 +199,14 @@ mod global_env {\n     mod impl {\n \n         #[cfg(unix)]\n-        fn getenv(n: str) -> option<str> {\n+        fn getenv(n: ~str) -> option<~str> {\n             unsafe {\n                 let s = str::as_c_str(n, libc::getenv);\n                 ret if unsafe::reinterpret_cast(s) == 0 {\n-                    option::none::<str>\n+                    option::none::<~str>\n                 } else {\n                     let s = unsafe::reinterpret_cast(s);\n-                    option::some::<str>(str::unsafe::from_buf(s))\n+                    option::some::<~str>(str::unsafe::from_buf(s))\n                 };\n             }\n         }\n@@ -225,7 +225,7 @@ mod global_env {\n \n \n         #[cfg(unix)]\n-        fn setenv(n: str, v: str) {\n+        fn setenv(n: ~str, v: ~str) {\n \n             // FIXME: remove this when export globs work properly. #1238\n             import libc::funcs::posix01::unistd::setenv;\n@@ -253,7 +253,7 @@ mod global_env {\n }\n \n fn fdopen(fd: c_int) -> *FILE {\n-    ret do as_c_charp(\"r\") |modebuf| {\n+    ret do as_c_charp(~\"r\") |modebuf| {\n         libc::fdopen(fd, modebuf)\n     };\n }\n@@ -348,11 +348,11 @@ fn pipe() -> {in: c_int, out: c_int} {\n }\n \n \n-fn dll_filename(base: str) -> str {\n+fn dll_filename(base: ~str) -> ~str {\n     ret pre() + base + dll_suffix();\n \n     #[cfg(unix)]\n-    fn pre() -> str { \"lib\" }\n+    fn pre() -> ~str { ~\"lib\" }\n \n     #[cfg(windows)]\n     fn pre() -> str { \"\" }\n@@ -381,7 +381,7 @@ fn self_exe_path() -> option<path> {\n     fn load_self() -> option<path> {\n         import libc::funcs::posix01::unistd::readlink;\n         do fill_charp_buf() |buf, sz| {\n-            do as_c_charp(\"/proc/self/exe\") |proc_self_buf| {\n+            do as_c_charp(~\"/proc/self/exe\") |proc_self_buf| {\n                 readlink(proc_self_buf, buf, sz) != (-1 as ssize_t)\n             }\n         }\n@@ -428,7 +428,7 @@ fn self_exe_path() -> option<path> {\n  * Otherwise, homedir returns option::none.\n  */\n fn homedir() -> option<path> {\n-    ret alt getenv(\"HOME\") {\n+    ret alt getenv(~\"HOME\") {\n         some(p) {\n             if !str::is_empty(p) {\n                 some(p)\n@@ -548,10 +548,10 @@ fn make_dir(p: path, mode: c_int) -> bool {\n }\n \n /// Lists the contents of a directory\n-fn list_dir(p: path) -> ~[str] {\n+fn list_dir(p: path) -> ~[~str] {\n \n     #[cfg(unix)]\n-    fn star(p: str) -> str { p }\n+    fn star(p: ~str) -> ~str { p }\n \n     #[cfg(windows)]\n     fn star(p: str) -> str {\n@@ -565,7 +565,7 @@ fn list_dir(p: path) -> ~[str] {\n     }\n \n     do rustrt::rust_list_files(star(p)).filter |filename| {\n-        !str::eq(filename, \".\") && !str::eq(filename, \"..\")\n+        !str::eq(filename, ~\".\") && !str::eq(filename, ~\"..\")\n     }\n }\n \n@@ -574,7 +574,7 @@ fn list_dir(p: path) -> ~[str] {\n  *\n  * This version prepends each entry with the directory.\n  */\n-fn list_dir_path(p: path) -> ~[str] {\n+fn list_dir_path(p: path) -> ~[~str] {\n     let mut p = p;\n     let pl = str::len(p);\n     if pl == 0u || (p[pl - 1u] as char != path::consts::path_sep\n@@ -649,15 +649,15 @@ fn copy_file(from: path, to: path) -> bool {\n     #[cfg(unix)]\n     fn do_copy_file(from: path, to: path) -> bool {\n         let istream = do as_c_charp(from) |fromp| {\n-            do as_c_charp(\"rb\") |modebuf| {\n+            do as_c_charp(~\"rb\") |modebuf| {\n                 libc::fopen(fromp, modebuf)\n             }\n         };\n         if istream as uint == 0u {\n             ret false;\n         }\n         let ostream = do as_c_charp(to) |top| {\n-            do as_c_charp(\"w+b\") |modebuf| {\n+            do as_c_charp(~\"w+b\") |modebuf| {\n                 libc::fopen(top, modebuf)\n             }\n         };\n@@ -717,7 +717,7 @@ fn remove_file(p: path) -> bool {\n }\n \n /// Get a string representing the platform-dependent last error\n-fn last_os_error() -> str {\n+fn last_os_error() -> ~str {\n     rustrt::last_os_error()\n }\n \n@@ -734,7 +734,7 @@ fn set_exit_status(code: int) {\n }\n \n #[cfg(unix)]\n-fn family() -> str { \"unix\" }\n+fn family() -> ~str { ~\"unix\" }\n \n #[cfg(windows)]\n fn family() -> str { \"windows\" }\n@@ -755,9 +755,9 @@ mod consts {\n \n #[cfg(target_os = \"linux\")]\n mod consts {\n-    fn sysname() -> str { \"linux\" }\n-    fn exe_suffix() -> str { \"\" }\n-    fn dll_suffix() -> str { \".so\" }\n+    fn sysname() -> ~str { ~\"linux\" }\n+    fn exe_suffix() -> ~str { ~\"\" }\n+    fn dll_suffix() -> ~str { ~\".so\" }\n }\n \n #[cfg(target_os = \"win32\")]\n@@ -771,7 +771,7 @@ mod consts {\n fn arch() -> str { \"x86\" }\n \n #[cfg(target_arch = \"x86_64\")]\n-fn arch() -> str { \"x86_64\" }\n+fn arch() -> ~str { ~\"x86_64\" }\n \n #[cfg(target_arch = \"arm\")]\n fn arch() -> str { \"arm\" }\n@@ -784,31 +784,31 @@ mod tests {\n         log(debug, last_os_error());\n     }\n \n-    fn make_rand_name() -> str {\n+    fn make_rand_name() -> ~str {\n         import rand;\n         let rng: rand::rng = rand::rng();\n-        let n = \"TEST\" + rng.gen_str(10u);\n+        let n = ~\"TEST\" + rng.gen_str(10u);\n         assert option::is_none(getenv(n));\n         n\n     }\n \n     #[test]\n     fn test_setenv() {\n         let n = make_rand_name();\n-        setenv(n, \"VALUE\");\n-        assert getenv(n) == option::some(\"VALUE\");\n+        setenv(n, ~\"VALUE\");\n+        assert getenv(n) == option::some(~\"VALUE\");\n     }\n \n     #[test]\n     #[ignore(cfg(windows))]\n     #[ignore]\n     fn test_setenv_overwrite() {\n         let n = make_rand_name();\n-        setenv(n, \"1\");\n-        setenv(n, \"2\");\n-        assert getenv(n) == option::some(\"2\");\n-        setenv(n, \"\");\n-        assert getenv(n) == option::some(\"\");\n+        setenv(n, ~\"1\");\n+        setenv(n, ~\"2\");\n+        assert getenv(n) == option::some(~\"2\");\n+        setenv(n, ~\"\");\n+        assert getenv(n) == option::some(~\"\");\n     }\n \n     // Windows GetEnvironmentVariable requires some extra work to make sure\n@@ -817,9 +817,9 @@ mod tests {\n     #[ignore(cfg(windows))]\n     #[ignore]\n     fn test_getenv_big() {\n-        let mut s = \"\";\n+        let mut s = ~\"\";\n         let mut i = 0;\n-        while i < 100 { s += \"aaaaaaaaaa\"; i += 1; }\n+        while i < 100 { s += ~\"aaaaaaaaaa\"; i += 1; }\n         let n = make_rand_name();\n         setenv(n, s);\n         log(debug, s);\n@@ -834,7 +834,7 @@ mod tests {\n         log(debug, path);\n \n         // Hard to test this function\n-        if os::sysname() != \"win32\" {\n+        if os::sysname() != ~\"win32\" {\n             assert str::starts_with(path, path::path_sep());\n         } else {\n             assert path[1] == ':' as u8;\n@@ -862,35 +862,35 @@ mod tests {\n         let n = make_rand_name();\n \n         let mut e = env();\n-        setenv(n, \"VALUE\");\n-        assert !vec::contains(e, (n, \"VALUE\"));\n+        setenv(n, ~\"VALUE\");\n+        assert !vec::contains(e, (n, ~\"VALUE\"));\n \n         e = env();\n-        assert vec::contains(e, (n, \"VALUE\"));\n+        assert vec::contains(e, (n, ~\"VALUE\"));\n     }\n \n     #[test]\n     fn test() {\n-        assert (!path::path_is_absolute(\"test-path\"));\n+        assert (!path::path_is_absolute(~\"test-path\"));\n \n-        log(debug, \"Current working directory: \" + getcwd());\n+        log(debug, ~\"Current working directory: \" + getcwd());\n \n-        log(debug, make_absolute(\"test-path\"));\n-        log(debug, make_absolute(\"/usr/bin\"));\n+        log(debug, make_absolute(~\"test-path\"));\n+        log(debug, make_absolute(~\"/usr/bin\"));\n     }\n \n     #[test]\n     #[cfg(unix)]\n     fn homedir() {\n-        let oldhome = getenv(\"HOME\");\n+        let oldhome = getenv(~\"HOME\");\n \n-        setenv(\"HOME\", \"/home/MountainView\");\n-        assert os::homedir() == some(\"/home/MountainView\");\n+        setenv(~\"HOME\", ~\"/home/MountainView\");\n+        assert os::homedir() == some(~\"/home/MountainView\");\n \n-        setenv(\"HOME\", \"\");\n+        setenv(~\"HOME\", ~\"\");\n         assert os::homedir() == none;\n \n-        option::iter(oldhome, |s| setenv(\"HOME\", s));\n+        option::iter(oldhome, |s| setenv(~\"HOME\", s));\n     }\n \n     #[test]\n@@ -927,11 +927,11 @@ mod tests {\n \n     // Issue #712\n     #[test]\n-    fn test_list_dir_no_invalid_memory_access() { os::list_dir(\".\"); }\n+    fn test_list_dir_no_invalid_memory_access() { os::list_dir(~\".\"); }\n \n     #[test]\n     fn list_dir() {\n-        let dirs = os::list_dir(\".\");\n+        let dirs = os::list_dir(~\".\");\n         // Just assuming that we've got some contents in the current directory\n         assert (vec::len(dirs) > 0u);\n \n@@ -940,39 +940,39 @@ mod tests {\n \n     #[test]\n     fn path_is_dir() {\n-        assert (os::path_is_dir(\".\"));\n-        assert (!os::path_is_dir(\"test/stdtest/fs.rs\"));\n+        assert (os::path_is_dir(~\".\"));\n+        assert (!os::path_is_dir(~\"test/stdtest/fs.rs\"));\n     }\n \n     #[test]\n     fn path_exists() {\n-        assert (os::path_exists(\".\"));\n-        assert (!os::path_exists(\"test/nonexistent-bogus-path\"));\n+        assert (os::path_exists(~\".\"));\n+        assert (!os::path_exists(~\"test/nonexistent-bogus-path\"));\n     }\n \n     #[test]\n     fn copy_file_does_not_exist() {\n-      assert !os::copy_file(\"test/nonexistent-bogus-path\",\n-                           \"test/other-bogus-path\");\n-      assert !os::path_exists(\"test/other-bogus-path\");\n+      assert !os::copy_file(~\"test/nonexistent-bogus-path\",\n+                           ~\"test/other-bogus-path\");\n+      assert !os::path_exists(~\"test/other-bogus-path\");\n     }\n \n     #[test]\n     fn copy_file_ok() {\n       let tempdir = getcwd(); // would like to use $TMPDIR,\n                               // doesn't seem to work on Linux\n       assert (str::len(tempdir) > 0u);\n-      let in = tempdir + path::path_sep() + \"in.txt\";\n-      let out = tempdir + path::path_sep() + \"out.txt\";\n+      let in = tempdir + path::path_sep() + ~\"in.txt\";\n+      let out = tempdir + path::path_sep() + ~\"out.txt\";\n \n       /* Write the temp input file */\n         let ostream = do as_c_charp(in) |fromp| {\n-            do as_c_charp(\"w+b\") |modebuf| {\n+            do as_c_charp(~\"w+b\") |modebuf| {\n                 libc::fopen(fromp, modebuf)\n             }\n       };\n       assert (ostream as uint != 0u);\n-      let s = \"hello\";\n+      let s = ~\"hello\";\n       let mut buf = vec::to_mut(str::bytes(s) + ~[0 as u8]);\n       do vec::as_mut_buf(buf) |b| {\n           assert (libc::fwrite(b as *c_void, 1u as size_t,\n@@ -984,7 +984,7 @@ mod tests {\n         fail (#fmt(\"%s doesn't exist\", in));\n       }\n       assert(rs);\n-      let rslt = run::run_program(\"diff\", ~[in, out]);\n+      let rslt = run::run_program(~\"diff\", ~[in, out]);\n       assert (rslt == 0);\n       assert (remove_file(in));\n       assert (remove_file(out));"}, {"sha": "35fc7510757e30f797bad899ed8012e3cdfdb3d6", "filename": "src/libcore/path.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -14,7 +14,7 @@ export normalize;\n \n // FIXME: This type should probably be constrained (#2624)\n /// A path or fragment of a filesystem path\n-type path = str;\n+type path = ~str;\n \n #[cfg(unix)]\n mod consts {\n@@ -58,17 +58,17 @@ fn path_is_absolute(p: str) -> bool {\n }\n \n /// Get the default path separator for the host platform\n-fn path_sep() -> str { ret str::from_char(consts::path_sep); }\n+fn path_sep() -> ~str { ret str::from_char(consts::path_sep); }\n \n-fn split_dirname_basename (pp: path) -> {dirname: str, basename: str} {\n+fn split_dirname_basename (pp: path) -> {dirname: ~str, basename: ~str} {\n     alt str::rfind(pp, |ch|\n         ch == consts::path_sep || ch == consts::alt_path_sep\n     ) {\n       some(i) {\n         {dirname: str::slice(pp, 0u, i),\n          basename: str::slice(pp, i + 1u, str::len(pp))}\n       }\n-      none { {dirname: \".\", basename: pp} }\n+      none { {dirname: ~\".\", basename: pp} }\n     }\n }\n \n@@ -159,28 +159,28 @@ fn split(p: path) -> ~[path] {\n  * ignored.  If the path includes directory components then they are included\n  * in the filename part of the result pair.\n  */\n-fn splitext(p: path) -> (str, str) {\n-    if str::is_empty(p) { (\"\", \"\") }\n+fn splitext(p: path) -> (~str, ~str) {\n+    if str::is_empty(p) { (~\"\", ~\"\") }\n     else {\n         let parts = str::split_char(p, '.');\n         if vec::len(parts) > 1u {\n-            let base = str::connect(vec::init(parts), \".\");\n+            let base = str::connect(vec::init(parts), ~\".\");\n             // We just checked that parts is non-empty, so this is safe\n-            let ext = \".\" + vec::last(parts);\n+            let ext = ~\".\" + vec::last(parts);\n \n-            fn is_dotfile(base: str) -> bool {\n+            fn is_dotfile(base: ~str) -> bool {\n                 str::is_empty(base)\n                     || str::ends_with(\n                         base, str::from_char(consts::path_sep))\n                     || str::ends_with(\n                         base, str::from_char(consts::alt_path_sep))\n             }\n \n-            fn ext_contains_sep(ext: str) -> bool {\n+            fn ext_contains_sep(ext: ~str) -> bool {\n                 vec::len(split(ext)) > 1u\n             }\n \n-            fn no_basename(ext: str) -> bool {\n+            fn no_basename(ext: ~str) -> bool {\n                 str::ends_with(\n                     ext, str::from_char(consts::path_sep))\n                     || str::ends_with(\n@@ -190,12 +190,12 @@ fn splitext(p: path) -> (str, str) {\n             if is_dotfile(base)\n                 || ext_contains_sep(ext)\n                 || no_basename(ext) {\n-                (p, \"\")\n+                (p, ~\"\")\n             } else {\n                 (base, ext)\n             }\n         } else {\n-            (p, \"\")\n+            (p, ~\"\")\n         }\n     }\n }\n@@ -220,13 +220,13 @@ fn normalize(p: path) -> path {\n     let s = if check vec::is_not_empty(s) {\n         connect_many(s)\n     } else {\n-        \"\"\n+        ~\"\"\n     };\n     let s = reabsolute(p, s);\n     let s = reterminate(p, s);\n \n     let s = if str::len(s) == 0u {\n-        \".\"\n+        ~\".\"\n     } else {\n         s\n     };\n@@ -235,7 +235,7 @@ fn normalize(p: path) -> path {\n \n     fn strip_dots(s: ~[path]) -> ~[path] {\n         vec::filter_map(s, |elem|\n-            if elem == \".\" {\n+            if elem == ~\".\" {\n                 option::none\n             } else {\n                 option::some(elem)\n@@ -252,7 +252,7 @@ fn normalize(p: path) -> path {\n         let mut skip = 0;\n         while i != 0u {\n             i -= 1u;\n-            if s[i] == \"..\" {\n+            if s[i] == ~\"..\" {\n                 skip += 1;\n             } else {\n                 if skip == 0 {\n@@ -264,7 +264,7 @@ fn normalize(p: path) -> path {\n         }\n         let mut t = vec::reversed(t);\n         while skip > 0 {\n-            vec::push(t, \"..\");\n+            vec::push(t, ~\"..\");\n             skip -= 1;\n         }\n         ret t;\n@@ -304,122 +304,122 @@ mod tests {\n     #[test]\n     fn test_connect() {\n         let slash = path_sep();\n-        log(error, connect(\"a\", \"b\"));\n-        assert (connect(\"a\", \"b\") == \"a\" + slash + \"b\");\n-        assert (connect(\"a\" + slash, \"b\") == \"a\" + slash + \"b\");\n+        log(error, connect(~\"a\", ~\"b\"));\n+        assert (connect(~\"a\", ~\"b\") == ~\"a\" + slash + ~\"b\");\n+        assert (connect(~\"a\" + slash, ~\"b\") == ~\"a\" + slash + ~\"b\");\n     }\n \n-    fn ps() -> str {\n+    fn ps() -> ~str {\n         path_sep()\n     }\n \n-    fn aps() -> str {\n-        \"/\"\n+    fn aps() -> ~str {\n+        ~\"/\"\n     }\n \n     #[test]\n     fn split1() {\n-        let actual = split(\"a\" + ps() + \"b\");\n-        let expected = ~[\"a\", \"b\"];\n+        let actual = split(~\"a\" + ps() + ~\"b\");\n+        let expected = ~[~\"a\", ~\"b\"];\n         assert actual == expected;\n     }\n \n     #[test]\n     fn split2() {\n-        let actual = split(\"a\" + aps() + \"b\");\n-        let expected = ~[\"a\", \"b\"];\n+        let actual = split(~\"a\" + aps() + ~\"b\");\n+        let expected = ~[~\"a\", ~\"b\"];\n         assert actual == expected;\n     }\n \n     #[test]\n     fn split3() {\n-        let actual = split(ps() + \"a\" + ps() + \"b\");\n-        let expected = ~[\"a\", \"b\"];\n+        let actual = split(ps() + ~\"a\" + ps() + ~\"b\");\n+        let expected = ~[~\"a\", ~\"b\"];\n         assert actual == expected;\n     }\n \n     #[test]\n     fn split4() {\n-        let actual = split(\"a\" + ps() + \"b\" + aps() + \"c\");\n-        let expected = ~[\"a\", \"b\", \"c\"];\n+        let actual = split(~\"a\" + ps() + ~\"b\" + aps() + ~\"c\");\n+        let expected = ~[~\"a\", ~\"b\", ~\"c\"];\n         assert actual == expected;\n     }\n \n     #[test]\n     fn normalize1() {\n-        let actual = normalize(\"a/b/..\");\n-        let expected = \"a\";\n+        let actual = normalize(~\"a/b/..\");\n+        let expected = ~\"a\";\n         assert actual == expected;\n     }\n \n     #[test]\n     fn normalize2() {\n-        let actual = normalize(\"/a/b/..\");\n-        let expected = \"/a\";\n+        let actual = normalize(~\"/a/b/..\");\n+        let expected = ~\"/a\";\n         assert actual == expected;\n     }\n \n     #[test]\n     fn normalize3() {\n-        let actual = normalize(\"a/../b\");\n-        let expected = \"b\";\n+        let actual = normalize(~\"a/../b\");\n+        let expected = ~\"b\";\n         assert actual == expected;\n     }\n \n     #[test]\n     fn normalize4() {\n-        let actual = normalize(\"/a/../b\");\n-        let expected = \"/b\";\n+        let actual = normalize(~\"/a/../b\");\n+        let expected = ~\"/b\";\n         assert actual == expected;\n     }\n \n     #[test]\n     fn normalize5() {\n-        let actual = normalize(\"a/.\");\n-        let expected = \"a\";\n+        let actual = normalize(~\"a/.\");\n+        let expected = ~\"a\";\n         assert actual == expected;\n     }\n \n     #[test]\n     fn normalize6() {\n-        let actual = normalize(\"a/./b/\");\n-        let expected = \"a/b/\";\n+        let actual = normalize(~\"a/./b/\");\n+        let expected = ~\"a/b/\";\n         assert actual == expected;\n     }\n \n     #[test]\n     fn normalize7() {\n-        let actual = normalize(\"a/..\");\n-        let expected = \".\";\n+        let actual = normalize(~\"a/..\");\n+        let expected = ~\".\";\n         assert actual == expected;\n     }\n \n     #[test]\n     fn normalize8() {\n-        let actual = normalize(\"../../..\");\n-        let expected = \"../../..\";\n+        let actual = normalize(~\"../../..\");\n+        let expected = ~\"../../..\";\n         assert actual == expected;\n     }\n \n     #[test]\n     fn normalize9() {\n-        let actual = normalize(\"a/b/../../..\");\n-        let expected = \"..\";\n+        let actual = normalize(~\"a/b/../../..\");\n+        let expected = ~\"..\";\n         assert actual == expected;\n     }\n \n     #[test]\n     fn normalize10() {\n-        let actual = normalize(\"/a/b/c/../d/./../../e/\");\n-        let expected = \"/a/e/\";\n+        let actual = normalize(~\"/a/b/c/../d/./../../e/\");\n+        let expected = ~\"/a/e/\";\n         log(error, actual);\n         assert actual == expected;\n     }\n \n     #[test]\n     fn normalize11() {\n-        let actual = normalize(\"/a/..\");\n-        let expected = \"/\";\n+        let actual = normalize(~\"/a/..\");\n+        let expected = ~\"/\";\n         assert actual == expected;\n     }\n \n@@ -440,58 +440,58 @@ mod tests {\n \n     #[test]\n     fn splitext_empty() {\n-        let (base, ext) = splitext(\"\");\n-        assert base == \"\";\n-        assert ext == \"\";\n+        let (base, ext) = splitext(~\"\");\n+        assert base == ~\"\";\n+        assert ext == ~\"\";\n     }\n \n     #[test]\n     fn splitext_ext() {\n-        let (base, ext) = splitext(\"grum.exe\");\n-        assert base == \"grum\";\n-        assert ext == \".exe\";\n+        let (base, ext) = splitext(~\"grum.exe\");\n+        assert base == ~\"grum\";\n+        assert ext == ~\".exe\";\n     }\n \n     #[test]\n     fn splitext_noext() {\n-        let (base, ext) = splitext(\"grum\");\n-        assert base == \"grum\";\n-        assert ext == \"\";\n+        let (base, ext) = splitext(~\"grum\");\n+        assert base == ~\"grum\";\n+        assert ext == ~\"\";\n     }\n \n     #[test]\n     fn splitext_dotfile() {\n-        let (base, ext) = splitext(\".grum\");\n-        assert base == \".grum\";\n-        assert ext == \"\";\n+        let (base, ext) = splitext(~\".grum\");\n+        assert base == ~\".grum\";\n+        assert ext == ~\"\";\n     }\n \n     #[test]\n     fn splitext_path_ext() {\n-        let (base, ext) = splitext(\"oh/grum.exe\");\n-        assert base == \"oh/grum\";\n-        assert ext == \".exe\";\n+        let (base, ext) = splitext(~\"oh/grum.exe\");\n+        assert base == ~\"oh/grum\";\n+        assert ext == ~\".exe\";\n     }\n \n     #[test]\n     fn splitext_path_noext() {\n-        let (base, ext) = splitext(\"oh/grum\");\n-        assert base == \"oh/grum\";\n-        assert ext == \"\";\n+        let (base, ext) = splitext(~\"oh/grum\");\n+        assert base == ~\"oh/grum\";\n+        assert ext == ~\"\";\n     }\n \n     #[test]\n     fn splitext_dot_in_path() {\n-        let (base, ext) = splitext(\"oh.my/grum\");\n-        assert base == \"oh.my/grum\";\n-        assert ext == \"\";\n+        let (base, ext) = splitext(~\"oh.my/grum\");\n+        assert base == ~\"oh.my/grum\";\n+        assert ext == ~\"\";\n     }\n \n     #[test]\n     fn splitext_nobasename() {\n-        let (base, ext) = splitext(\"oh.my/\");\n-        assert base == \"oh.my/\";\n-        assert ext == \"\";\n+        let (base, ext) = splitext(~\"oh.my/\");\n+        assert base == ~\"oh.my/\";\n+        assert ext == ~\"\";\n     }\n }\n "}, {"sha": "d16f0f3a3307222665b7205ee7ff78fc1681bb8d", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -84,7 +84,7 @@ fn wait_event(this: *rust_task) -> *libc::c_void {\n \n     let res = rustrt::task_wait_event(this, &mut killed);\n     if killed && !task::failing() {\n-        fail \"killed\"\n+        fail ~\"killed\"\n     }\n     res\n }\n@@ -118,15 +118,15 @@ fn send<T: send>(-p: send_packet<T>, -payload: T) {\n         // The receiver will eventually clean this up.\n         unsafe { forget(p); }\n       }\n-      full { fail \"duplicate send\" }\n+      full { fail ~\"duplicate send\" }\n       blocked {\n         #debug(\"waking up task for %?\", p_);\n         alt p.header.blocked_task {\n           some(task) {\n             rustrt::task_signal_event(\n                 task, ptr::addr_of(p.header) as *libc::c_void);\n           }\n-          none { fail \"blocked packet has no task\" }\n+          none { fail ~\"blocked packet has no task\" }\n         }\n \n         // The receiver will eventually clean this up.\n@@ -162,7 +162,7 @@ fn try_recv<T: send>(-p: recv_packet<T>) -> option<T> {\n           }\n           blocked {\n             if first {\n-                fail \"blocking on already blocked packet\"\n+                fail ~\"blocking on already blocked packet\"\n             }\n           }\n           full {\n@@ -184,7 +184,7 @@ fn try_recv<T: send>(-p: recv_packet<T>) -> option<T> {\n pure fn peek<T: send>(p: recv_packet<T>) -> bool {\n     alt unsafe {(*p.header()).state} {\n       empty { false }\n-      blocked { fail \"peeking on blocked packet\" }\n+      blocked { fail ~\"peeking on blocked packet\" }\n       full | terminated { true }\n     }\n }\n@@ -207,7 +207,7 @@ fn sender_terminate<T: send>(p: *packet<T>) {\n       }\n       full {\n         // This is impossible\n-        fail \"you dun goofed\"\n+        fail ~\"you dun goofed\"\n       }\n       terminated {\n         // I have to clean up, use drop_glue\n@@ -224,7 +224,7 @@ fn receiver_terminate<T: send>(p: *packet<T>) {\n       }\n       blocked {\n         // this shouldn't happen.\n-        fail \"terminating a blocked packet\"\n+        fail ~\"terminating a blocked packet\"\n       }\n       terminated | full {\n         // I have to clean up, use drop_glue\n@@ -267,7 +267,7 @@ fn wait_many(pkts: &[*packet_header]) -> uint {\n             (*p).state = old;\n             break;\n           }\n-          blocked { fail \"blocking on blocked packet\" }\n+          blocked { fail ~\"blocking on blocked packet\" }\n           empty { }\n         }\n     }\n@@ -313,7 +313,7 @@ fn select2<A: send, B: send>(\n         alt i {\n           0 { left((try_recv(a), b)) }\n           1 { right((a, try_recv(b))) }\n-          _ { fail \"select2 return an invalid packet\" }\n+          _ { fail ~\"select2 return an invalid packet\" }\n         }\n     }\n }\n@@ -397,7 +397,7 @@ class recv_packet<T: send> {\n                 header\n             }\n           }\n-          none { fail \"packet already consumed\" }\n+          none { fail ~\"packet already consumed\" }\n         }\n     }\n }\n@@ -508,7 +508,7 @@ impl port<T: send> for port<T> {\n           some(endp) {\n             pipes::peek(endp)\n           }\n-          none { fail \"peeking empty stream\" }\n+          none { fail ~\"peeking empty stream\" }\n         };\n         self.endp <-> endp;\n         peek\n@@ -558,7 +558,7 @@ impl private_methods/&<T: send> for pipes::port<T> {\n           some(endp) {\n             endp.header()\n           }\n-          none { fail \"peeking empty stream\" }\n+          none { fail ~\"peeking empty stream\" }\n         }\n     }\n }"}, {"sha": "4d6ac7bac35d37d96e053d9dba041c50d99213b9", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -32,11 +32,11 @@ unsafe fn chan_from_global_ptr<T: send>(\n         abort\n     }\n \n-    log(debug,\"ENTERING chan_from_global_ptr, before is_prob_zero check\");\n+    log(debug,~\"ENTERING chan_from_global_ptr, before is_prob_zero check\");\n     let is_probably_zero = *global == 0u;\n-    log(debug,\"after is_prob_zero check\");\n+    log(debug,~\"after is_prob_zero check\");\n     if is_probably_zero {\n-        log(debug,\"is probably zero...\");\n+        log(debug,~\"is probably zero...\");\n         // There's no global channel. We must make it\n \n         let setup_po = comm::port();\n@@ -54,14 +54,14 @@ unsafe fn chan_from_global_ptr<T: send>(\n             }\n         };\n \n-        log(debug,\"before setup recv..\");\n+        log(debug,~\"before setup recv..\");\n         // This is the proposed global channel\n         let ch = comm::recv(setup_po);\n         // 0 is our sentinal value. It is not a valid channel\n         assert unsafe::reinterpret_cast(ch) != 0u;\n \n         // Install the channel\n-        log(debug,\"BEFORE COMPARE AND SWAP\");\n+        log(debug,~\"BEFORE COMPARE AND SWAP\");\n         let swapped = compare_and_swap(\n             global, 0u, unsafe::reinterpret_cast(ch));\n         log(debug,#fmt(\"AFTER .. swapped? %?\", swapped));\n@@ -76,7 +76,7 @@ unsafe fn chan_from_global_ptr<T: send>(\n             unsafe::reinterpret_cast(*global)\n         }\n     } else {\n-        log(debug, \"global != 0\");\n+        log(debug, ~\"global != 0\");\n         unsafe::reinterpret_cast(*global)\n     }\n }"}, {"sha": "178a68a1c654ffe12e704376b7dfb6e43b7082a4", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -174,7 +174,7 @@ fn test_position() {\n     import str::as_c_str;\n     import libc::c_char;\n \n-    let s = \"hello\";\n+    let s = ~\"hello\";\n     unsafe {\n         assert 2u == as_c_str(s, |p| position(p, |c| c == 'l' as c_char));\n         assert 4u == as_c_str(s, |p| position(p, |c| c == 'o' as c_char));\n@@ -184,9 +184,9 @@ fn test_position() {\n \n #[test]\n fn test_buf_len() {\n-    let s0 = \"hello\";\n-    let s1 = \"there\";\n-    let s2 = \"thing\";\n+    let s0 = ~\"hello\";\n+    let s1 = ~\"there\";\n+    let s2 = ~\"thing\";\n     do str::as_c_str(s0) |p0| {\n         do str::as_c_str(s1) |p1| {\n             do str::as_c_str(s2) |p2| {"}, {"sha": "8d392e1be90f74ffe18319fc44be9cd948739798", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -121,7 +121,7 @@ impl extensions for rng {\n     /**\n      * Return a char randomly chosen from chars, failing if chars is empty\n      */\n-    fn gen_char_from(chars: str) -> char {\n+    fn gen_char_from(chars: ~str) -> char {\n         assert !chars.is_empty();\n         self.choose(str::chars(chars))\n     }\n@@ -143,11 +143,11 @@ impl extensions for rng {\n     /**\n      * Return a random string of the specified length composed of A-Z,a-z,0-9\n      */\n-    fn gen_str(len: uint) -> str {\n-        let charset = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n+    fn gen_str(len: uint) -> ~str {\n+        let charset = ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                        abcdefghijklmnopqrstuvwxyz\\\n                        0123456789\";\n-        let mut s = \"\";\n+        let mut s = ~\"\";\n         let mut i = 0u;\n         while (i < len) {\n             s = s + str::from_char(self.gen_char_from(charset));"}, {"sha": "c0c68459fb63e38c59e79d19ba8239f557ff269c", "filename": "src/libcore/result.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -37,7 +37,7 @@ pure fn get_err<T, U: copy>(res: result<T, U>) -> U {\n     alt res {\n       err(u) { u }\n       ok(_) {\n-        fail \"get_error called on ok result\";\n+        fail ~\"get_error called on ok result\";\n       }\n     }\n }\n@@ -333,7 +333,7 @@ fn unwrap<T, U>(-res: result<T, U>) -> T {\n     unsafe {\n         let addr = alt res {\n           ok(x) { ptr::addr_of(x) }\n-          err(_) { fail \"error result\" }\n+          err(_) { fail ~\"error result\" }\n         };\n         let liberated_value = unsafe::reinterpret_cast(*addr);\n         unsafe::forget(res);\n@@ -343,13 +343,13 @@ fn unwrap<T, U>(-res: result<T, U>) -> T {\n \n #[cfg(test)]\n mod tests {\n-    fn op1() -> result::result<int, str> { result::ok(666) }\n+    fn op1() -> result::result<int, ~str> { result::ok(666) }\n \n-    fn op2(&&i: int) -> result::result<uint, str> {\n+    fn op2(&&i: int) -> result::result<uint, ~str> {\n         result::ok(i as uint + 1u)\n     }\n \n-    fn op3() -> result::result<int, str> { result::err(\"sadface\") }\n+    fn op3() -> result::result<int, ~str> { result::err(~\"sadface\") }\n \n     #[test]\n     fn chain_success() {\n@@ -358,39 +358,39 @@ mod tests {\n \n     #[test]\n     fn chain_failure() {\n-        assert get_err(chain(op3(), op2)) == \"sadface\";\n+        assert get_err(chain(op3(), op2)) == ~\"sadface\";\n     }\n \n     #[test]\n     fn test_impl_iter() {\n         let mut valid = false;\n-        ok::<str, str>(\"a\").iter(|_x| valid = true);\n+        ok::<~str, ~str>(~\"a\").iter(|_x| valid = true);\n         assert valid;\n \n-        err::<str, str>(\"b\").iter(|_x| valid = false);\n+        err::<~str, ~str>(~\"b\").iter(|_x| valid = false);\n         assert valid;\n     }\n \n     #[test]\n     fn test_impl_iter_err() {\n         let mut valid = true;\n-        ok::<str, str>(\"a\").iter_err(|_x| valid = false);\n+        ok::<~str, ~str>(~\"a\").iter_err(|_x| valid = false);\n         assert valid;\n \n         valid = false;\n-        err::<str, str>(\"b\").iter_err(|_x| valid = true);\n+        err::<~str, ~str>(~\"b\").iter_err(|_x| valid = true);\n         assert valid;\n     }\n \n     #[test]\n     fn test_impl_map() {\n-        assert ok::<str, str>(\"a\").map(|_x| \"b\") == ok(\"b\");\n-        assert err::<str, str>(\"a\").map(|_x| \"b\") == err(\"a\");\n+        assert ok::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == ok(~\"b\");\n+        assert err::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == err(~\"a\");\n     }\n \n     #[test]\n     fn test_impl_map_err() {\n-        assert ok::<str, str>(\"a\").map_err(|_x| \"b\") == ok(\"a\");\n-        assert err::<str, str>(\"a\").map_err(|_x| \"b\") == err(\"b\");\n+        assert ok::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == ok(~\"a\");\n+        assert err::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == err(~\"b\");\n     }\n }"}, {"sha": "c8e55bea2a5a85132cb38053d50aad1ebf9be841", "filename": "src/libcore/run.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -62,9 +62,9 @@ iface program {\n  *\n  * The process id of the spawned process\n  */\n-fn spawn_process(prog: str, args: ~[str],\n-                 env: option<~[(str,str)]>,\n-                 dir: option<str>,\n+fn spawn_process(prog: ~str, args: ~[~str],\n+                 env: option<~[(~str,~str)]>,\n+                 dir: option<~str>,\n                  in_fd: c_int, out_fd: c_int, err_fd: c_int)\n    -> pid_t {\n     do with_argv(prog, args) |argv| {\n@@ -77,7 +77,7 @@ fn spawn_process(prog: str, args: ~[str],\n     }\n }\n \n-fn with_argv<T>(prog: str, args: ~[str],\n+fn with_argv<T>(prog: ~str, args: ~[~str],\n                 cb: fn(**libc::c_char) -> T) -> T {\n     let mut argptrs = str::as_c_str(prog, |b| ~[b]);\n     let mut tmps = ~[];\n@@ -91,7 +91,7 @@ fn with_argv<T>(prog: str, args: ~[str],\n }\n \n #[cfg(unix)]\n-fn with_envp<T>(env: option<~[(str,str)]>,\n+fn with_envp<T>(env: option<~[(~str,~str)]>,\n                 cb: fn(*c_void) -> T) -> T {\n     // On posixy systems we can pass a char** for envp, which is\n     // a null-terminated array of \"k=v\\n\" strings.\n@@ -144,7 +144,7 @@ fn with_envp<T>(env: option<~[(str,str)]>,\n     }\n }\n \n-fn with_dirp<T>(d: option<str>,\n+fn with_dirp<T>(d: option<~str>,\n                 cb: fn(*libc::c_char) -> T) -> T {\n     alt d {\n       some(dir) { str::as_c_str(dir, cb) }\n@@ -164,7 +164,7 @@ fn with_dirp<T>(d: option<str>,\n  *\n  * The process id\n  */\n-fn run_program(prog: str, args: ~[str]) -> int {\n+fn run_program(prog: ~str, args: ~[~str]) -> int {\n     let pid = spawn_process(prog, args, none, none,\n                             0i32, 0i32, 0i32);\n     if pid == -1 as pid_t { fail; }\n@@ -187,7 +187,7 @@ fn run_program(prog: str, args: ~[str]) -> int {\n  *\n  * A class with a <program> field\n  */\n-fn start_program(prog: str, args: ~[str]) -> program {\n+fn start_program(prog: ~str, args: ~[~str]) -> program {\n     let pipe_input = os::pipe();\n     let pipe_output = os::pipe();\n     let pipe_err = os::pipe();\n@@ -248,8 +248,8 @@ fn start_program(prog: str, args: ~[str]) -> program {\n     ret prog_res(repr) as program;\n }\n \n-fn read_all(rd: io::reader) -> str {\n-    let mut buf = \"\";\n+fn read_all(rd: io::reader) -> ~str {\n+    let mut buf = ~\"\";\n     while !rd.eof() {\n         let bytes = rd.read_bytes(4096u);\n         buf += str::from_bytes(bytes);\n@@ -271,8 +271,8 @@ fn read_all(rd: io::reader) -> str {\n  * A record, {status: int, out: str, err: str} containing the exit code,\n  * the contents of stdout and the contents of stderr.\n  */\n-fn program_output(prog: str, args: ~[str]) ->\n-   {status: int, out: str, err: str} {\n+fn program_output(prog: ~str, args: ~[~str]) ->\n+   {status: int, out: ~str, err: ~str} {\n \n     let pipe_in = os::pipe();\n     let pipe_out = os::pipe();\n@@ -307,8 +307,8 @@ fn program_output(prog: str, args: ~[str]) ->\n         comm::send(ch, (1, output));\n     };\n     let status = run::waitpid(pid);\n-    let mut errs = \"\";\n-    let mut outs = \"\";\n+    let mut errs = ~\"\";\n+    let mut outs = ~\"\";\n     let mut count = 2;\n     while count > 0 {\n         let stream = comm::recv(p);\n@@ -325,7 +325,7 @@ fn program_output(prog: str, args: ~[str]) ->\n     ret {status: status, out: outs, err: errs};\n }\n \n-fn writeclose(fd: c_int, s: str) {\n+fn writeclose(fd: c_int, s: ~str) {\n     import io::writer_util;\n \n     #error(\"writeclose %d, %s\", fd as int, s);\n@@ -335,10 +335,10 @@ fn writeclose(fd: c_int, s: str) {\n     os::close(fd);\n }\n \n-fn readclose(fd: c_int) -> str {\n+fn readclose(fd: c_int) -> ~str {\n     let file = os::fdopen(fd);\n     let reader = io::FILE_reader(file, false);\n-    let mut buf = \"\";\n+    let mut buf = ~\"\";\n     while !reader.eof() {\n         let bytes = reader.read_bytes(4096u);\n         buf += str::from_bytes(bytes);\n@@ -397,9 +397,9 @@ mod tests {\n     // Regression test for memory leaks\n     #[ignore(cfg(windows))] // FIXME (#2626)\n     fn test_leaks() {\n-        run::run_program(\"echo\", ~[]);\n-        run::start_program(\"echo\", ~[]);\n-        run::program_output(\"echo\", ~[]);\n+        run::run_program(~\"echo\", ~[]);\n+        run::start_program(~\"echo\", ~[]);\n+        run::program_output(~\"echo\", ~[]);\n     }\n \n     #[test]\n@@ -410,14 +410,14 @@ mod tests {\n \n         let pid =\n             run::spawn_process(\n-                \"cat\", ~[], none, none,\n+                ~\"cat\", ~[], none, none,\n                 pipe_in.in, pipe_out.out, pipe_err.out);\n         os::close(pipe_in.in);\n         os::close(pipe_out.out);\n         os::close(pipe_err.out);\n \n         if pid == -1i32 { fail; }\n-        let expected = \"test\";\n+        let expected = ~\"test\";\n         writeclose(pipe_in.out, expected);\n         let actual = readclose(pipe_out.in);\n         readclose(pipe_err.in);\n@@ -430,7 +430,7 @@ mod tests {\n \n     #[test]\n     fn waitpid() {\n-        let pid = run::spawn_process(\"false\", ~[],\n+        let pid = run::spawn_process(~\"false\", ~[],\n                                      none, none,\n                                      0i32, 0i32, 0i32);\n         let status = run::waitpid(pid);"}, {"sha": "cc5ae30268df53409fc01f7276a1622fe26a0501", "filename": "src/libcore/str.rs", "status": "modified", "additions": 515, "deletions": 513, "changes": 1028, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -110,8 +110,8 @@ export\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    fn rust_str_push(&s: str, ch: u8);\n-    fn str_reserve_shared(&ss: str, nn: libc::size_t);\n+    fn rust_str_push(&s: ~str, ch: u8);\n+    fn str_reserve_shared(&ss: ~str, nn: libc::size_t);\n }\n \n /*\n@@ -125,7 +125,7 @@ Section: Creating a string\n  *\n  * Fails if invalid UTF-8\n  */\n-pure fn from_bytes(+vv: ~[u8]) -> str {\n+pure fn from_bytes(+vv: ~[u8]) -> ~str {\n     assert is_utf8(vv);\n     ret unsafe { unsafe::from_bytes(vv) };\n }\n@@ -137,14 +137,14 @@ pure fn from_bytes(+vv: ~[u8]) -> str {\n  *\n  * Fails if invalid UTF-8\n  */\n-pure fn from_byte(b: u8) -> str {\n+pure fn from_byte(b: u8) -> ~str {\n     assert b < 128u8;\n     let mut v = ~[b, 0u8];\n     unsafe { ::unsafe::transmute(v) }\n }\n \n /// Appends a character at the end of a string\n-fn push_char(&s: str, ch: char) {\n+fn push_char(&s: ~str, ch: char) {\n     unsafe {\n         let code = ch as uint;\n         let nb = if code < max_one_b { 1u }\n@@ -220,15 +220,15 @@ fn push_char(&s: str, ch: char) {\n }\n \n /// Convert a char to a string\n-pure fn from_char(ch: char) -> str {\n-    let mut buf = \"\";\n+pure fn from_char(ch: char) -> ~str {\n+    let mut buf = ~\"\";\n     unchecked { push_char(buf, ch); }\n     ret buf;\n }\n \n /// Convert a vector of chars to a string\n-pure fn from_chars(chs: &[const char]) -> str {\n-    let mut buf = \"\";\n+pure fn from_chars(chs: &[const char]) -> ~str {\n+    let mut buf = ~\"\";\n     unchecked {\n         reserve(buf, chs.len());\n         for vec::each(chs) |ch| { push_char(buf, ch); }\n@@ -238,7 +238,7 @@ pure fn from_chars(chs: &[const char]) -> str {\n \n /// Appends a string slice to the back of a string, without overallocating\n #[inline(always)]\n-fn push_str_no_overallocate(&lhs: str, rhs: str/&) {\n+fn push_str_no_overallocate(&lhs: ~str, rhs: &str) {\n     unsafe {\n         let llen = lhs.len();\n         let rlen = rhs.len();\n@@ -254,7 +254,7 @@ fn push_str_no_overallocate(&lhs: str, rhs: str/&) {\n }\n /// Appends a string slice to the back of a string\n #[inline(always)]\n-fn push_str(&lhs: str, rhs: str/&) {\n+fn push_str(&lhs: ~str, rhs: &str) {\n     unsafe {\n         let llen = lhs.len();\n         let rlen = rhs.len();\n@@ -271,7 +271,7 @@ fn push_str(&lhs: str, rhs: str/&) {\n \n /// Concatenate two strings together\n #[inline(always)]\n-pure fn append(+lhs: str, rhs: str/&) -> str {\n+pure fn append(+lhs: ~str, rhs: &str) -> ~str {\n     let mut v <- lhs;\n     unchecked {\n         push_str_no_overallocate(v, rhs);\n@@ -281,15 +281,15 @@ pure fn append(+lhs: str, rhs: str/&) -> str {\n \n \n /// Concatenate a vector of strings\n-pure fn concat(v: &[const str]) -> str {\n-    let mut s: str = \"\";\n+pure fn concat(v: &[const ~str]) -> ~str {\n+    let mut s: ~str = ~\"\";\n     for vec::each(v) |ss| { unchecked { push_str(s, ss) }; }\n     ret s;\n }\n \n /// Concatenate a vector of strings, placing a given separator between each\n-pure fn connect(v: &[const str], sep: str) -> str {\n-    let mut s = \"\", first = true;\n+pure fn connect(v: &[const ~str], sep: ~str) -> ~str {\n+    let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n         if first { first = false; } else { unchecked { push_str(s, sep); } }\n         unchecked { push_str(s, ss) };\n@@ -308,7 +308,7 @@ Section: Adding to and removing from a string\n  *\n  * If the string does not contain any characters\n  */\n-fn pop_char(&s: str) -> char {\n+fn pop_char(&s: ~str) -> char {\n     let end = len(s);\n     assert end > 0u;\n     let {ch, prev} = char_range_at_reverse(s, end);\n@@ -323,19 +323,19 @@ fn pop_char(&s: str) -> char {\n  *\n  * If the string does not contain any characters\n  */\n-fn shift_char(&s: str) -> char {\n+fn shift_char(&s: ~str) -> char {\n     let {ch, next} = char_range_at(s, 0u);\n     s = unsafe { unsafe::slice_bytes(s, next, len(s)) };\n     ret ch;\n }\n \n /// Prepend a char to a string\n-fn unshift_char(&s: str, ch: char) { s = from_char(ch) + s; }\n+fn unshift_char(&s: ~str, ch: char) { s = from_char(ch) + s; }\n \n /// Returns a string with leading whitespace removed\n-pure fn trim_left(+s: str) -> str {\n+pure fn trim_left(+s: ~str) -> ~str {\n     alt find(s, |c| !char::is_whitespace(c)) {\n-      none { \"\" }\n+      none { ~\"\" }\n       some(first) {\n         if first == 0u { s }\n         else unsafe { unsafe::slice_bytes(s, first, len(s)) }\n@@ -344,9 +344,9 @@ pure fn trim_left(+s: str) -> str {\n }\n \n /// Returns a string with trailing whitespace removed\n-pure fn trim_right(+s: str) -> str {\n+pure fn trim_right(+s: ~str) -> ~str {\n     alt rfind(s, |c| !char::is_whitespace(c)) {\n-      none { \"\" }\n+      none { ~\"\" }\n       some(last) {\n         let {next, _} = char_range_at(s, last);\n         if next == len(s) { s }\n@@ -356,7 +356,7 @@ pure fn trim_right(+s: str) -> str {\n }\n \n /// Returns a string with leading and trailing whitespace removed\n-pure fn trim(+s: str) -> str { trim_left(trim_right(s)) }\n+pure fn trim(+s: ~str) -> ~str { trim_left(trim_right(s)) }\n \n /*\n Section: Transforming strings\n@@ -367,7 +367,7 @@ Section: Transforming strings\n  *\n  * The result vector is not null-terminated.\n  */\n-pure fn bytes(s: str) -> ~[u8] {\n+pure fn bytes(s: ~str) -> ~[u8] {\n     unsafe {\n         let mut s_copy = s;\n         let mut v: ~[u8] = ::unsafe::transmute(s_copy);\n@@ -378,14 +378,14 @@ pure fn bytes(s: str) -> ~[u8] {\n \n /// Work with the string as a byte slice, not including trailing null.\n #[inline(always)]\n-pure fn byte_slice<T>(s: str/&, f: fn(v: &[u8]) -> T) -> T {\n+pure fn byte_slice<T>(s: &str, f: fn(v: &[u8]) -> T) -> T {\n     do unpack_slice(s) |p,n| {\n         unsafe { vec::unsafe::form_slice(p, n-1u, f) }\n     }\n }\n \n /// Convert a string to a vector of characters\n-pure fn chars(s: str/&) -> ~[char] {\n+pure fn chars(s: &str) -> ~[char] {\n     let mut buf = ~[], i = 0u;\n     let len = len(s);\n     while i < len {\n@@ -402,7 +402,7 @@ pure fn chars(s: str/&) -> ~[char] {\n  * Returns a string containing `n` characters starting at byte offset\n  * `begin`.\n  */\n-pure fn substr(s: str/&, begin: uint, n: uint) -> str {\n+pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n     slice(s, begin, begin + count_bytes(s, begin, n))\n }\n \n@@ -412,14 +412,14 @@ pure fn substr(s: str/&, begin: uint, n: uint) -> str {\n  * Fails when `begin` and `end` do not point to valid characters or\n  * beyond the last character of the string\n  */\n-pure fn slice(s: str/&, begin: uint, end: uint) -> str {\n+pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n     assert is_char_boundary(s, begin);\n     assert is_char_boundary(s, end);\n     unsafe { unsafe::slice_bytes(s, begin, end) }\n }\n \n /// Splits a string into substrings at each occurrence of a given character\n-pure fn split_char(s: str/&, sep: char) -> ~[str] {\n+pure fn split_char(s: &str, sep: char) -> ~[~str] {\n     split_char_inner(s, sep, len(s), true)\n }\n \n@@ -429,17 +429,17 @@ pure fn split_char(s: str/&, sep: char) -> ~[str] {\n  *\n  * The byte must be a valid UTF-8/ASCII byte\n  */\n-pure fn splitn_char(s: str/&, sep: char, count: uint) -> ~[str] {\n+pure fn splitn_char(s: &str, sep: char, count: uint) -> ~[~str] {\n     split_char_inner(s, sep, count, true)\n }\n \n /// Like `split_char`, but omits empty strings from the returned vector\n-pure fn split_char_nonempty(s: str/&, sep: char) -> ~[str] {\n+pure fn split_char_nonempty(s: &str, sep: char) -> ~[~str] {\n     split_char_inner(s, sep, len(s), false)\n }\n \n-pure fn split_char_inner(s: str/&, sep: char, count: uint, allow_empty: bool)\n-    -> ~[str] {\n+pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n+    -> ~[~str] {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n         let mut result = ~[], done = 0u;\n@@ -466,25 +466,25 @@ pure fn split_char_inner(s: str/&, sep: char, count: uint, allow_empty: bool)\n \n \n /// Splits a string into substrings using a character function\n-pure fn split(s: str/&, sepfn: fn(char) -> bool) -> ~[str] {\n+pure fn split(s: &str, sepfn: fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), true)\n }\n \n /**\n  * Splits a string into substrings using a character function, cutting at\n  * most `count` times.\n  */\n-pure fn splitn(s: str/&, sepfn: fn(char) -> bool, count: uint) -> ~[str] {\n+pure fn splitn(s: &str, sepfn: fn(char) -> bool, count: uint) -> ~[~str] {\n     split_inner(s, sepfn, count, true)\n }\n \n /// Like `split`, but omits empty strings from the returned vector\n-pure fn split_nonempty(s: str/&, sepfn: fn(char) -> bool) -> ~[str] {\n+pure fn split_nonempty(s: &str, sepfn: fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), false)\n }\n \n-pure fn split_inner(s: str/&, sepfn: fn(cc: char) -> bool, count: uint,\n-               allow_empty: bool) -> ~[str] {\n+pure fn split_inner(s: &str, sepfn: fn(cc: char) -> bool, count: uint,\n+               allow_empty: bool) -> ~[~str] {\n     let l = len(s);\n     let mut result = ~[], i = 0u, start = 0u, done = 0u;\n     while i < l && done < count {\n@@ -505,7 +505,7 @@ pure fn split_inner(s: str/&, sepfn: fn(cc: char) -> bool, count: uint,\n }\n \n // See Issue #1932 for why this is a naive search\n-pure fn iter_matches(s: str/&a, sep: str/&b, f: fn(uint, uint)) {\n+pure fn iter_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n     let sep_len = len(sep), l = len(s);\n     assert sep_len > 0u;\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n@@ -532,7 +532,7 @@ pure fn iter_matches(s: str/&a, sep: str/&b, f: fn(uint, uint)) {\n     }\n }\n \n-pure fn iter_between_matches(s: str/&a, sep: str/&b, f: fn(uint, uint)) {\n+pure fn iter_between_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n     let mut last_end = 0u;\n     do iter_matches(s, sep) |from, to| {\n         f(last_end, from);\n@@ -550,15 +550,15 @@ pure fn iter_between_matches(s: str/&a, sep: str/&b, f: fn(uint, uint)) {\n  * assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\")\n  * ~~~\n  */\n-pure fn split_str(s: str/&a, sep: str/&b) -> ~[str] {\n+pure fn split_str(s: &a/str, sep: &b/str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         unsafe { vec::push(result, unsafe::slice_bytes(s, from, to)); }\n     }\n     result\n }\n \n-pure fn split_str_nonempty(s: str/&a, sep: str/&b) -> ~[str] {\n+pure fn split_str_nonempty(s: &a/str, sep: &b/str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         if to > from {\n@@ -571,13 +571,13 @@ pure fn split_str_nonempty(s: str/&a, sep: str/&b) -> ~[str] {\n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n')\n  */\n-pure fn lines(s: str/&) -> ~[str] { split_char(s, '\\n') }\n+pure fn lines(s: &str) -> ~[~str] { split_char(s, '\\n') }\n \n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n')\n  * and/or CR LF (\"\\r\\n\")\n  */\n-pure fn lines_any(s: str/&) -> ~[str] {\n+pure fn lines_any(s: &str) -> ~[~str] {\n     vec::map(lines(s), |s| {\n         let l = len(s);\n         let mut cp = s;\n@@ -589,19 +589,19 @@ pure fn lines_any(s: str/&) -> ~[str] {\n }\n \n /// Splits a string into a vector of the substrings separated by whitespace\n-pure fn words(s: str/&) -> ~[str] {\n+pure fn words(s: &str) -> ~[~str] {\n     split_nonempty(s, |c| char::is_whitespace(c))\n }\n \n /// Convert a string to lowercase. ASCII only\n-pure fn to_lower(s: str/&) -> str {\n+pure fn to_lower(s: &str) -> ~str {\n     map(s,\n         |c| unchecked{(libc::tolower(c as libc::c_char)) as char}\n     )\n }\n \n /// Convert a string to uppercase. ASCII only\n-pure fn to_upper(s: str/&) -> str {\n+pure fn to_upper(s: &str) -> ~str {\n     map(s,\n         |c| unchecked{(libc::toupper(c as libc::c_char)) as char}\n     )\n@@ -620,8 +620,8 @@ pure fn to_upper(s: str/&) -> str {\n  *\n  * The original string with all occurances of `from` replaced with `to`\n  */\n-pure fn replace(s: str, from: str, to: str) -> str {\n-    let mut result = \"\", first = true;\n+pure fn replace(s: ~str, from: ~str, to: ~str) -> ~str {\n+    let mut result = ~\"\", first = true;\n     do iter_between_matches(s, from) |start, end| {\n         if first { first = false; } else { unchecked {push_str(result, to); }}\n         unsafe { push_str(result, unsafe::slice_bytes(s, start, end)); }\n@@ -634,7 +634,7 @@ Section: Comparing strings\n */\n \n /// Bytewise string equality\n-pure fn eq(&&a: str, &&b: str) -> bool {\n+pure fn eq(&&a: ~str, &&b: ~str) -> bool {\n     // FIXME (#2627): This should just be \"a == b\" but that calls into the\n     // shape code.\n     let a_len = a.len();\n@@ -652,10 +652,10 @@ pure fn eq(&&a: str, &&b: str) -> bool {\n }\n \n /// Bytewise less than or equal\n-pure fn le(&&a: str, &&b: str) -> bool { a <= b }\n+pure fn le(&&a: ~str, &&b: ~str) -> bool { a <= b }\n \n /// String hash function\n-pure fn hash(&&s: str) -> uint {\n+pure fn hash(&&s: ~str) -> uint {\n     // djb hash.\n     // FIXME: replace with murmur. (see #859 and #1616)\n     let mut u: uint = 5381u;\n@@ -671,21 +671,21 @@ Section: Iterating through strings\n  * Return true if a predicate matches all characters or if the string\n  * contains no characters\n  */\n-pure fn all(s: str/&, it: fn(char) -> bool) -> bool {\n+pure fn all(s: &str, it: fn(char) -> bool) -> bool {\n     all_between(s, 0u, len(s), it)\n }\n \n /**\n  * Return true if a predicate matches any character (and false if it\n  * matches none or there are no characters)\n  */\n-pure fn any(ss: str/&, pred: fn(char) -> bool) -> bool {\n+pure fn any(ss: &str, pred: fn(char) -> bool) -> bool {\n     !all(ss, |cc| !pred(cc))\n }\n \n /// Apply a function to each character\n-pure fn map(ss: str/&, ff: fn(char) -> char) -> str {\n-    let mut result = \"\";\n+pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n+    let mut result = ~\"\";\n     unchecked {\n         reserve(result, len(ss));\n         do chars_iter(ss) |cc| {\n@@ -696,7 +696,7 @@ pure fn map(ss: str/&, ff: fn(char) -> char) -> str {\n }\n \n /// Iterate over the bytes in a string\n-pure fn bytes_iter(ss: str/&, it: fn(u8)) {\n+pure fn bytes_iter(ss: &str, it: fn(u8)) {\n     let mut pos = 0u;\n     let len = len(ss);\n \n@@ -708,13 +708,13 @@ pure fn bytes_iter(ss: str/&, it: fn(u8)) {\n \n /// Iterate over the bytes in a string\n #[inline(always)]\n-pure fn each(s: str/&, it: fn(u8) -> bool) {\n+pure fn each(s: &str, it: fn(u8) -> bool) {\n     eachi(s, |_i, b| it(b) )\n }\n \n /// Iterate over the bytes in a string, with indices\n #[inline(always)]\n-pure fn eachi(s: str/&, it: fn(uint, u8) -> bool) {\n+pure fn eachi(s: &str, it: fn(uint, u8) -> bool) {\n     let mut i = 0u, l = len(s);\n     while (i < l) {\n         if !it(i, s[i]) { break; }\n@@ -724,13 +724,13 @@ pure fn eachi(s: str/&, it: fn(uint, u8) -> bool) {\n \n /// Iterates over the chars in a string\n #[inline(always)]\n-pure fn each_char(s: str/&, it: fn(char) -> bool) {\n+pure fn each_char(s: &str, it: fn(char) -> bool) {\n     each_chari(s, |_i, c| it(c))\n }\n \n /// Iterates over the chars in a string, with indices\n #[inline(always)]\n-pure fn each_chari(s: str/&, it: fn(uint, char) -> bool) {\n+pure fn each_chari(s: &str, it: fn(uint, char) -> bool) {\n     let mut pos = 0u, ch_pos = 0u;\n     let len = len(s);\n     while pos < len {\n@@ -742,7 +742,7 @@ pure fn each_chari(s: str/&, it: fn(uint, char) -> bool) {\n }\n \n /// Iterate over the characters in a string\n-pure fn chars_iter(s: str/&, it: fn(char)) {\n+pure fn chars_iter(s: &str, it: fn(char)) {\n     let mut pos = 0u;\n     let len = len(s);\n     while (pos < len) {\n@@ -753,28 +753,28 @@ pure fn chars_iter(s: str/&, it: fn(char)) {\n }\n \n /// Apply a function to each substring after splitting by character\n-pure fn split_char_iter(ss: str/&, cc: char, ff: fn(&&str)) {\n+pure fn split_char_iter(ss: &str, cc: char, ff: fn(&&~str)) {\n    vec::iter(split_char(ss, cc), ff)\n }\n \n /**\n  * Apply a function to each substring after splitting by character, up to\n  * `count` times\n  */\n-pure fn splitn_char_iter(ss: str/&, sep: char, count: uint,\n-                         ff: fn(&&str)) {\n+pure fn splitn_char_iter(ss: &str, sep: char, count: uint,\n+                         ff: fn(&&~str)) {\n    vec::iter(splitn_char(ss, sep, count), ff)\n }\n \n /// Apply a function to each word\n-pure fn words_iter(ss: str/&, ff: fn(&&str)) {\n+pure fn words_iter(ss: &str, ff: fn(&&~str)) {\n     vec::iter(words(ss), ff)\n }\n \n /**\n  * Apply a function to each line (by '\\n')\n  */\n-pure fn lines_iter(ss: str/&, ff: fn(&&str)) {\n+pure fn lines_iter(ss: &str, ff: fn(&&~str)) {\n     vec::iter(lines(ss), ff)\n }\n \n@@ -795,7 +795,7 @@ Section: Searching\n  * An `option` containing the byte index of the first matching character\n  * or `none` if there is no match\n  */\n-pure fn find_char(s: str/&, c: char) -> option<uint> {\n+pure fn find_char(s: &str, c: char) -> option<uint> {\n     find_char_between(s, c, 0u, len(s))\n }\n \n@@ -819,7 +819,7 @@ pure fn find_char(s: str/&, c: char) -> option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pure fn find_char_from(s: str/&, c: char, start: uint) -> option<uint> {\n+pure fn find_char_from(s: &str, c: char, start: uint) -> option<uint> {\n     find_char_between(s, c, start, len(s))\n }\n \n@@ -844,7 +844,7 @@ pure fn find_char_from(s: str/&, c: char, start: uint) -> option<uint> {\n  * or equal to `len(s)`. `start` must be the index of a character boundary,\n  * as defined by `is_char_boundary`.\n  */\n-pure fn find_char_between(s: str/&, c: char, start: uint, end: uint)\n+pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n     -> option<uint> {\n     if c < 128u as char {\n         assert start <= end;\n@@ -874,7 +874,7 @@ pure fn find_char_between(s: str/&, c: char, start: uint, end: uint)\n  * An `option` containing the byte index of the last matching character\n  * or `none` if there is no match\n  */\n-pure fn rfind_char(s: str/&, c: char) -> option<uint> {\n+pure fn rfind_char(s: &str, c: char) -> option<uint> {\n     rfind_char_between(s, c, len(s), 0u)\n }\n \n@@ -898,7 +898,7 @@ pure fn rfind_char(s: str/&, c: char) -> option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be\n  * the index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pure fn rfind_char_from(s: str/&, c: char, start: uint) -> option<uint> {\n+pure fn rfind_char_from(s: &str, c: char, start: uint) -> option<uint> {\n     rfind_char_between(s, c, start, 0u)\n }\n \n@@ -923,7 +923,7 @@ pure fn rfind_char_from(s: str/&, c: char, start: uint) -> option<uint> {\n  * or equal to `len(s)`. `start` must be the index of a character boundary,\n  * as defined by `is_char_boundary`.\n  */\n-pure fn rfind_char_between(s: str/&, c: char, start: uint, end: uint)\n+pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n     -> option<uint> {\n     if c < 128u as char {\n         assert start >= end;\n@@ -954,7 +954,7 @@ pure fn rfind_char_between(s: str/&, c: char, start: uint, end: uint)\n  * An `option` containing the byte index of the first matching character\n  * or `none` if there is no match\n  */\n-pure fn find(s: str/&, f: fn(char) -> bool) -> option<uint> {\n+pure fn find(s: &str, f: fn(char) -> bool) -> option<uint> {\n     find_between(s, 0u, len(s), f)\n }\n \n@@ -978,7 +978,7 @@ pure fn find(s: str/&, f: fn(char) -> bool) -> option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pure fn find_from(s: str/&, start: uint, f: fn(char)\n+pure fn find_from(s: &str, start: uint, f: fn(char)\n     -> bool) -> option<uint> {\n     find_between(s, start, len(s), f)\n }\n@@ -1005,7 +1005,7 @@ pure fn find_from(s: str/&, start: uint, f: fn(char)\n  * or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`.\n  */\n-pure fn find_between(s: str/&, start: uint, end: uint, f: fn(char) -> bool)\n+pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     assert start <= end;\n     assert end <= len(s);\n@@ -1033,7 +1033,7 @@ pure fn find_between(s: str/&, start: uint, end: uint, f: fn(char) -> bool)\n  * An option containing the byte index of the last matching character\n  * or `none` if there is no match\n  */\n-pure fn rfind(s: str/&, f: fn(char) -> bool) -> option<uint> {\n+pure fn rfind(s: &str, f: fn(char) -> bool) -> option<uint> {\n     rfind_between(s, len(s), 0u, f)\n }\n \n@@ -1057,7 +1057,7 @@ pure fn rfind(s: str/&, f: fn(char) -> bool) -> option<uint> {\n  * `start` must be less than or equal to `len(s)', `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`\n  */\n-pure fn rfind_from(s: str/&, start: uint, f: fn(char) -> bool)\n+pure fn rfind_from(s: &str, start: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n@@ -1084,7 +1084,7 @@ pure fn rfind_from(s: str/&, start: uint, f: fn(char) -> bool)\n  * than or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`\n  */\n-pure fn rfind_between(s: str/&, start: uint, end: uint, f: fn(char) -> bool)\n+pure fn rfind_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     assert start >= end;\n     assert start <= len(s);\n@@ -1099,7 +1099,7 @@ pure fn rfind_between(s: str/&, start: uint, end: uint, f: fn(char) -> bool)\n }\n \n // Utility used by various searching functions\n-pure fn match_at(haystack: str/&a, needle: str/&b, at: uint) -> bool {\n+pure fn match_at(haystack: &a/str, needle: &b/str, at: uint) -> bool {\n     let mut i = at;\n     for each(needle) |c| { if haystack[i] != c { ret false; } i += 1u; }\n     ret true;\n@@ -1118,7 +1118,7 @@ pure fn match_at(haystack: str/&a, needle: str/&b, at: uint) -> bool {\n  * An `option` containing the byte index of the first matching substring\n  * or `none` if there is no match\n  */\n-pure fn find_str(haystack: str/&a, needle: str/&b) -> option<uint> {\n+pure fn find_str(haystack: &a/str, needle: &b/str) -> option<uint> {\n     find_str_between(haystack, needle, 0u, len(haystack))\n }\n \n@@ -1141,7 +1141,7 @@ pure fn find_str(haystack: str/&a, needle: str/&b) -> option<uint> {\n  *\n  * `start` must be less than or equal to `len(s)`\n  */\n-pure fn find_str_from(haystack: str/&a, needle: str/&b, start: uint)\n+pure fn find_str_from(haystack: &a/str, needle: &b/str, start: uint)\n   -> option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n@@ -1166,7 +1166,7 @@ pure fn find_str_from(haystack: str/&a, needle: str/&b, start: uint)\n  * `start` must be less than or equal to `end` and `end` must be less than\n  * or equal to `len(s)`.\n  */\n-pure fn find_str_between(haystack: str/&a, needle: str/&b, start: uint,\n+pure fn find_str_between(haystack: &a/str, needle: &b/str, start: uint,\n                          end:uint)\n   -> option<uint> {\n     // See Issue #1932 for why this is a naive search\n@@ -1192,7 +1192,7 @@ pure fn find_str_between(haystack: str/&a, needle: str/&b, start: uint,\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pure fn contains(haystack: str/&a, needle: str/&b) -> bool {\n+pure fn contains(haystack: &a/str, needle: &b/str) -> bool {\n     option::is_some(find_str(haystack, needle))\n }\n \n@@ -1204,7 +1204,7 @@ pure fn contains(haystack: str/&a, needle: str/&b) -> bool {\n  * * haystack - The string to look in\n  * * needle - The char to look for\n  */\n-pure fn contains_char(haystack: str/&, needle: char) -> bool {\n+pure fn contains_char(haystack: &str, needle: char) -> bool {\n     option::is_some(find_char(haystack, needle))\n }\n \n@@ -1216,7 +1216,7 @@ pure fn contains_char(haystack: str/&, needle: char) -> bool {\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pure fn starts_with(haystack: str/&a, needle: str/&b) -> bool {\n+pure fn starts_with(haystack: &a/str, needle: &b/str) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1231,7 +1231,7 @@ pure fn starts_with(haystack: str/&a, needle: str/&b) -> bool {\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pure fn ends_with(haystack: str/&a, needle: str/&b) -> bool {\n+pure fn ends_with(haystack: &a/str, needle: &b/str) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1243,24 +1243,24 @@ Section: String properties\n */\n \n /// Determines if a string contains only ASCII characters\n-pure fn is_ascii(s: str/&) -> bool {\n+pure fn is_ascii(s: &str) -> bool {\n     let mut i: uint = len(s);\n     while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { ret false; } }\n     ret true;\n }\n \n /// Returns true if the string has length 0\n-pure fn is_empty(s: str/&) -> bool { len(s) == 0u }\n+pure fn is_empty(s: &str) -> bool { len(s) == 0u }\n \n /// Returns true if the string has length greater than 0\n-pure fn is_not_empty(s: str/&) -> bool { !is_empty(s) }\n+pure fn is_not_empty(s: &str) -> bool { !is_empty(s) }\n \n /**\n  * Returns true if the string contains only whitespace\n  *\n  * Whitespace characters are determined by `char::is_whitespace`\n  */\n-pure fn is_whitespace(s: str/&) -> bool {\n+pure fn is_whitespace(s: &str) -> bool {\n     ret all(s, char::is_whitespace);\n }\n \n@@ -1269,17 +1269,17 @@ pure fn is_whitespace(s: str/&) -> bool {\n  *\n  * Alphanumeric characters are determined by `char::is_alphanumeric`\n  */\n-fn is_alphanumeric(s: str/&) -> bool {\n+fn is_alphanumeric(s: &str) -> bool {\n     ret all(s, char::is_alphanumeric);\n }\n \n /// Returns the string length/size in bytes not counting the null terminator\n-pure fn len(s: str/&) -> uint {\n+pure fn len(s: &str) -> uint {\n     do unpack_slice(s) |_p, n| { n - 1u }\n }\n \n /// Returns the number of characters that a string holds\n-pure fn char_len(s: str/&) -> uint { count_chars(s, 0u, len(s)) }\n+pure fn char_len(s: &str) -> uint { count_chars(s, 0u, len(s)) }\n \n /*\n Section: Misc\n@@ -1325,7 +1325,7 @@ pure fn is_utf16(v: &[const u16]) -> bool {\n }\n \n /// Converts to a vector of `u16` encoded as UTF-16\n-pure fn to_utf16(s: str/&) -> ~[u16] {\n+pure fn to_utf16(s: &str) -> ~[u16] {\n     let mut u = ~[];\n     do chars_iter(s) |cch| {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n@@ -1372,8 +1372,8 @@ pure fn utf16_chars(v: &[const u16], f: fn(char)) {\n }\n \n \n-pure fn from_utf16(v: &[const u16]) -> str {\n-    let mut buf = \"\";\n+pure fn from_utf16(v: &[const u16]) -> ~str {\n+    let mut buf = ~\"\";\n     unchecked {\n         reserve(buf, vec::len(v));\n         utf16_chars(v, |ch| push_char(buf, ch));\n@@ -1395,7 +1395,7 @@ pure fn from_utf16(v: &[const u16]) -> str {\n  *\n  * The number of Unicode characters in `s` between the given indices.\n  */\n-pure fn count_chars(s: str/&, start: uint, end: uint) -> uint {\n+pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n     assert is_char_boundary(s, start);\n     assert is_char_boundary(s, end);\n     let mut i = start, len = 0u;\n@@ -1408,7 +1408,7 @@ pure fn count_chars(s: str/&, start: uint, end: uint) -> uint {\n }\n \n /// Counts the number of bytes taken by the `n` in `s` starting from `start`.\n-pure fn count_bytes(s: str/&b, start: uint, n: uint) -> uint {\n+pure fn count_bytes(s: &b/str, start: uint, n: uint) -> uint {\n     assert is_char_boundary(s, start);\n     let mut end = start, cnt = n;\n     let l = len(s);\n@@ -1438,7 +1438,7 @@ pure fn utf8_char_width(b: u8) -> uint {\n  * Returns false if the index points into the middle of a multi-byte\n  * character sequence.\n  */\n-pure fn is_char_boundary(s: str/&, index: uint) -> bool {\n+pure fn is_char_boundary(s: &str, index: uint) -> bool {\n     if index == len(s) { ret true; }\n     let b = s[index];\n     ret b < 128u8 || b >= 192u8;\n@@ -1493,7 +1493,7 @@ pure fn is_char_boundary(s: str/&, index: uint) -> bool {\n  * If `i` is greater than or equal to the length of the string.\n  * If `i` is not the index of the beginning of a valid UTF-8 character.\n  */\n-pure fn char_range_at(s: str/&, i: uint) -> {ch: char, next: uint} {\n+pure fn char_range_at(s: &str, i: uint) -> {ch: char, next: uint} {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n     assert (w != 0u);\n@@ -1516,14 +1516,14 @@ pure fn char_range_at(s: str/&, i: uint) -> {ch: char, next: uint} {\n }\n \n /// Pluck a character out of a string\n-pure fn char_at(s: str/&, i: uint) -> char { ret char_range_at(s, i).ch; }\n+pure fn char_at(s: &str, i: uint) -> char { ret char_range_at(s, i).ch; }\n \n /**\n  * Given a byte position and a str, return the previous char and its position\n  *\n  * This function can be used to iterate over a unicode string in reverse.\n  */\n-pure fn char_range_at_reverse(ss: str/&, start: uint)\n+pure fn char_range_at_reverse(ss: &str, start: uint)\n     -> {ch: char, prev: uint} {\n \n     let mut prev = start;\n@@ -1562,7 +1562,7 @@ pure fn char_range_at_reverse(ss: str/&, start: uint)\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-pure fn all_between(s: str/&, start: uint, end: uint,\n+pure fn all_between(s: &str, start: uint, end: uint,\n                     it: fn(char) -> bool) -> bool {\n     assert is_char_boundary(s, start);\n     let mut i = start;\n@@ -1595,7 +1595,7 @@ pure fn all_between(s: str/&, start: uint, end: uint,\n  *\n  * `true` if `it` returns `true` for any character\n  */\n-pure fn any_between(s: str/&, start: uint, end: uint,\n+pure fn any_between(s: &str, start: uint, end: uint,\n                     it: fn(char) -> bool) -> bool {\n     !all_between(s, start, end, |c| !it(c))\n }\n@@ -1627,7 +1627,7 @@ const tag_six_b: uint = 252u;\n  * let i = str::as_bytes(\"Hello World\") { |bytes| vec::len(bytes) };\n  * ~~~\n  */\n-pure fn as_bytes<T>(s: str, f: fn(~[u8]) -> T) -> T {\n+pure fn as_bytes<T>(s: ~str, f: fn(~[u8]) -> T) -> T {\n     unsafe {\n         let v: *~[u8] = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n         f(*v)\n@@ -1640,7 +1640,7 @@ pure fn as_bytes<T>(s: str, f: fn(~[u8]) -> T) -> T {\n  * Allows for unsafe manipulation of strings, which is useful for foreign\n  * interop.\n  */\n-pure fn as_buf<T>(s: str, f: fn(*u8) -> T) -> T {\n+pure fn as_buf<T>(s: ~str, f: fn(*u8) -> T) -> T {\n     as_bytes(s, |v| unsafe { vec::as_buf(v, f) })\n }\n \n@@ -1656,7 +1656,7 @@ pure fn as_buf<T>(s: str, f: fn(*u8) -> T) -> T {\n  * let s = str::as_buf(\"PATH\", { |path_buf| libc::getenv(path_buf) });\n  * ~~~\n  */\n-pure fn as_c_str<T>(s: str, f: fn(*libc::c_char) -> T) -> T {\n+pure fn as_c_str<T>(s: ~str, f: fn(*libc::c_char) -> T) -> T {\n     as_buf(s, |buf| f(buf as *libc::c_char))\n }\n \n@@ -1670,7 +1670,7 @@ pure fn as_c_str<T>(s: str, f: fn(*libc::c_char) -> T) -> T {\n  * to full strings, or suffixes of them.\n  */\n #[inline(always)]\n-pure fn unpack_slice<T>(s: str/&, f: fn(*u8, uint) -> T) -> T {\n+pure fn unpack_slice<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n     unsafe {\n         let v : *(*u8,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n         let (buf,len) = *v;\n@@ -1694,7 +1694,7 @@ pure fn unpack_slice<T>(s: str/&, f: fn(*u8, uint) -> T) -> T {\n  * * s - A string\n  * * n - The number of bytes to reserve space for\n  */\n-fn reserve(&s: str, n: uint) {\n+fn reserve(&s: ~str, n: uint) {\n     if capacity(s) < n {\n         rustrt::str_reserve_shared(s, n as size_t);\n     }\n@@ -1720,15 +1720,15 @@ fn reserve(&s: str, n: uint) {\n  * * s - A string\n  * * n - The number of bytes to reserve space for\n  */\n-fn reserve_at_least(&s: str, n: uint) {\n+fn reserve_at_least(&s: ~str, n: uint) {\n     reserve(s, uint::next_power_of_two(n + 1u) - 1u)\n }\n \n /**\n  * Returns the number of single-byte characters the string can hold without\n  * reallocating\n  */\n-pure fn capacity(&&s: str) -> uint {\n+pure fn capacity(&&s: ~str) -> uint {\n     do as_bytes(s) |buf| {\n         let vcap = vec::capacity(buf);\n         assert vcap > 0u;\n@@ -1737,8 +1737,8 @@ pure fn capacity(&&s: str) -> uint {\n }\n \n /// Escape each char in `s` with char::escape_default.\n-pure fn escape_default(s: str/&) -> str {\n-    let mut out: str = \"\";\n+pure fn escape_default(s: &str) -> ~str {\n+    let mut out: ~str = ~\"\";\n     unchecked {\n         reserve_at_least(out, str::len(s));\n         chars_iter(s, |c| push_str(out, char::escape_default(c)));\n@@ -1747,8 +1747,8 @@ pure fn escape_default(s: str/&) -> str {\n }\n \n /// Escape each char in `s` with char::escape_unicode.\n-pure fn escape_unicode(s: str/&) -> str {\n-    let mut out: str = \"\";\n+pure fn escape_unicode(s: &str) -> ~str {\n+    let mut out: ~str = ~\"\";\n     unchecked {\n         reserve_at_least(out, str::len(s));\n         chars_iter(s, |c| push_str(out, char::escape_unicode(c)));\n@@ -1771,7 +1771,7 @@ mod unsafe {\n       set_len;\n \n     /// Create a Rust string from a null-terminated *u8 buffer\n-    unsafe fn from_buf(buf: *u8) -> str {\n+    unsafe fn from_buf(buf: *u8) -> ~str {\n         let mut curr = buf, i = 0u;\n         while *curr != 0u8 {\n             i += 1u;\n@@ -1781,7 +1781,7 @@ mod unsafe {\n     }\n \n     /// Create a Rust string from a *u8 buffer of the given length\n-    unsafe fn from_buf_len(buf: *u8, len: uint) -> str {\n+    unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v: ~[u8] = ~[];\n         vec::reserve(v, len + 1u);\n         vec::as_buf(v, |b| ptr::memcpy(b, buf, len));\n@@ -1793,12 +1793,12 @@ mod unsafe {\n     }\n \n     /// Create a Rust string from a null-terminated C string\n-    unsafe fn from_c_str(c_str: *libc::c_char) -> str {\n+    unsafe fn from_c_str(c_str: *libc::c_char) -> ~str {\n         from_buf(::unsafe::reinterpret_cast(c_str))\n     }\n \n     /// Create a Rust string from a `*c_char` buffer of the given length\n-    unsafe fn from_c_str_len(c_str: *libc::c_char, len: uint) -> str {\n+    unsafe fn from_c_str_len(c_str: *libc::c_char, len: uint) -> ~str {\n         from_buf_len(::unsafe::reinterpret_cast(c_str), len)\n     }\n \n@@ -1807,7 +1807,7 @@ mod unsafe {\n     *\n     * Does not verify that the vector contains valid UTF-8.\n     */\n-   unsafe fn from_bytes(+v: ~[const u8]) -> str {\n+   unsafe fn from_bytes(+v: ~[const u8]) -> ~str {\n        unsafe {\n            let mut vcopy = ::unsafe::transmute(v);\n            vec::push(vcopy, 0u8);\n@@ -1820,7 +1820,7 @@ mod unsafe {\n     *\n     * Does not verify that the byte is valid UTF-8.\n     */\n-   unsafe fn from_byte(u: u8) -> str { unsafe::from_bytes(~[u]) }\n+   unsafe fn from_byte(u: u8) -> ~str { unsafe::from_bytes(~[u]) }\n \n    /**\n     * Takes a bytewise (not UTF-8) slice from a string.\n@@ -1832,7 +1832,7 @@ mod unsafe {\n     * If begin is greater than end.\n     * If end is greater than the length of the string.\n     */\n-   unsafe fn slice_bytes(s: str/&, begin: uint, end: uint) -> str {\n+   unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> ~str {\n        do unpack_slice(s) |sbuf, n| {\n            assert (begin <= end);\n            assert (end <= n);\n@@ -1852,17 +1852,17 @@ mod unsafe {\n    }\n \n    /// Appends a byte to a string. (Not UTF-8 safe).\n-   unsafe fn push_byte(&s: str, b: u8) {\n+   unsafe fn push_byte(&s: ~str, b: u8) {\n        rustrt::rust_str_push(s, b);\n    }\n \n    /// Appends a vector of bytes to a string. (Not UTF-8 safe).\n-   unsafe fn push_bytes(&s: str, bytes: ~[u8]) {\n+   unsafe fn push_bytes(&s: ~str, bytes: ~[u8]) {\n        for vec::each(bytes) |byte| { rustrt::rust_str_push(s, byte); }\n    }\n \n    /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n-   unsafe fn pop_byte(&s: str) -> u8 {\n+   unsafe fn pop_byte(&s: ~str) -> u8 {\n        let len = len(s);\n        assert (len > 0u);\n        let b = s[len - 1u];\n@@ -1871,7 +1871,7 @@ mod unsafe {\n    }\n \n    /// Removes the first byte from a string and returns it. (Not UTF-8 safe).\n-   unsafe fn shift_byte(&s: str) -> u8 {\n+   unsafe fn shift_byte(&s: ~str) -> u8 {\n        let len = len(s);\n        assert (len > 0u);\n        let b = s[0];\n@@ -1880,7 +1880,7 @@ mod unsafe {\n    }\n \n     /// Sets the length of the string and adds the null terminator\n-    unsafe fn set_len(&v: str, new_len: uint) {\n+    unsafe fn set_len(&v: ~str, new_len: uint) {\n         let repr: *vec::unsafe::vec_repr = ::unsafe::reinterpret_cast(v);\n         (*repr).fill = new_len + 1u;\n         let null = ptr::mut_offset(ptr::mut_addr_of((*repr).data), new_len);\n@@ -1893,7 +1893,7 @@ mod unsafe {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = vec::unsafe::to_ptr(a);\n             let c = from_buf_len(b, 3u);\n-            assert (c == \"AAA\");\n+            assert (c == ~\"AAA\");\n         }\n     }\n \n@@ -1903,57 +1903,57 @@ trait unique_str {\n     fn trim() -> self;\n     fn trim_left() -> self;\n     fn trim_right() -> self;\n-    pure fn +(rhs: str/&) -> self;\n+    pure fn +(rhs: &str) -> self;\n }\n \n /// Extension methods for strings\n-impl extensions of unique_str for str {\n+impl extensions of unique_str for ~str {\n     /// Returns a string with leading and trailing whitespace removed\n     #[inline]\n-    fn trim() -> str { trim(self) }\n+    fn trim() -> ~str { trim(self) }\n     /// Returns a string with leading whitespace removed\n     #[inline]\n-    fn trim_left() -> str { trim_left(self) }\n+    fn trim_left() -> ~str { trim_left(self) }\n     /// Returns a string with trailing whitespace removed\n     #[inline]\n-    fn trim_right() -> str { trim_right(self) }\n+    fn trim_right() -> ~str { trim_right(self) }\n \n     /// Concatenate two strings: operator version\n     #[inline(always)]\n-    pure fn +(rhs: str/&) -> str {\n+    pure fn +(rhs: &str) -> ~str {\n         append(self, rhs)\n     }\n }\n \n trait str_slice {\n     fn all(it: fn(char) -> bool) -> bool;\n     fn any(it: fn(char) -> bool) -> bool;\n-    fn contains(needle: str/&a) -> bool;\n+    fn contains(needle: &a/str) -> bool;\n     fn contains_char(needle: char) -> bool;\n     fn each(it: fn(u8) -> bool);\n     fn eachi(it: fn(uint, u8) -> bool);\n     fn each_char(it: fn(char) -> bool);\n     fn each_chari(it: fn(uint, char) -> bool);\n-    fn ends_with(needle: str/&) -> bool;\n+    fn ends_with(needle: &str) -> bool;\n     fn is_empty() -> bool;\n     fn is_not_empty() -> bool;\n     fn is_whitespace() -> bool;\n     fn is_alphanumeric() -> bool;\n     pure fn len() -> uint;\n-    fn slice(begin: uint, end: uint) -> str;\n-    fn split(sepfn: fn(char) -> bool) -> ~[str];\n-    fn split_char(sep: char) -> ~[str];\n-    fn split_str(sep: str/&a) -> ~[str];\n-    fn starts_with(needle: str/&a) -> bool;\n-    fn substr(begin: uint, n: uint) -> str;\n-    fn to_lower() -> str;\n-    fn to_upper() -> str;\n-    fn escape_default() -> str;\n-    fn escape_unicode() -> str;\n+    fn slice(begin: uint, end: uint) -> ~str;\n+    fn split(sepfn: fn(char) -> bool) -> ~[~str];\n+    fn split_char(sep: char) -> ~[~str];\n+    fn split_str(sep: &a/str) -> ~[~str];\n+    fn starts_with(needle: &a/str) -> bool;\n+    fn substr(begin: uint, n: uint) -> ~str;\n+    fn to_lower() -> ~str;\n+    fn to_upper() -> ~str;\n+    fn escape_default() -> ~str;\n+    fn escape_unicode() -> ~str;\n }\n \n /// Extension methods for strings\n-impl extensions/& of str_slice for str/& {\n+impl extensions/& of str_slice for &str {\n     /**\n      * Return true if a predicate matches all characters or if the string\n      * contains no characters\n@@ -1968,7 +1968,7 @@ impl extensions/& of str_slice for str/& {\n     fn any(it: fn(char) -> bool) -> bool { any(self, it) }\n     /// Returns true if one string contains another\n     #[inline]\n-    fn contains(needle: str/&a) -> bool { contains(self, needle) }\n+    fn contains(needle: &a/str) -> bool { contains(self, needle) }\n     /// Returns true if a string contains a char\n     #[inline]\n     fn contains_char(needle: char) -> bool { contains_char(self, needle) }\n@@ -1986,7 +1986,7 @@ impl extensions/& of str_slice for str/& {\n     fn each_chari(it: fn(uint, char) -> bool) { each_chari(self, it) }\n     /// Returns true if one string ends with another\n     #[inline]\n-    fn ends_with(needle: str/&) -> bool { ends_with(self, needle) }\n+    fn ends_with(needle: &str) -> bool { ends_with(self, needle) }\n     /// Returns true if the string has length 0\n     #[inline]\n     fn is_empty() -> bool { is_empty(self) }\n@@ -2018,44 +2018,44 @@ impl extensions/& of str_slice for str/& {\n      * beyond the last character of the string\n      */\n     #[inline]\n-    fn slice(begin: uint, end: uint) -> str { slice(self, begin, end) }\n+    fn slice(begin: uint, end: uint) -> ~str { slice(self, begin, end) }\n     /// Splits a string into substrings using a character function\n     #[inline]\n-    fn split(sepfn: fn(char) -> bool) -> ~[str] { split(self, sepfn) }\n+    fn split(sepfn: fn(char) -> bool) -> ~[~str] { split(self, sepfn) }\n     /**\n      * Splits a string into substrings at each occurrence of a given character\n      */\n     #[inline]\n-    fn split_char(sep: char) -> ~[str] { split_char(self, sep) }\n+    fn split_char(sep: char) -> ~[~str] { split_char(self, sep) }\n     /**\n      * Splits a string into a vector of the substrings separated by a given\n      * string\n      */\n     #[inline]\n-    fn split_str(sep: str/&a) -> ~[str] { split_str(self, sep) }\n+    fn split_str(sep: &a/str) -> ~[~str] { split_str(self, sep) }\n     /// Returns true if one string starts with another\n     #[inline]\n-    fn starts_with(needle: str/&a) -> bool { starts_with(self, needle) }\n+    fn starts_with(needle: &a/str) -> bool { starts_with(self, needle) }\n     /**\n      * Take a substring of another.\n      *\n      * Returns a string containing `n` characters starting at byte offset\n      * `begin`.\n      */\n     #[inline]\n-    fn substr(begin: uint, n: uint) -> str { substr(self, begin, n) }\n+    fn substr(begin: uint, n: uint) -> ~str { substr(self, begin, n) }\n     /// Convert a string to lowercase\n     #[inline]\n-    fn to_lower() -> str { to_lower(self) }\n+    fn to_lower() -> ~str { to_lower(self) }\n     /// Convert a string to uppercase\n     #[inline]\n-    fn to_upper() -> str { to_upper(self) }\n+    fn to_upper() -> ~str { to_upper(self) }\n     /// Escape each char in `s` with char::escape_default.\n     #[inline]\n-    fn escape_default() -> str { escape_default(self) }\n+    fn escape_default() -> ~str { escape_default(self) }\n     /// Escape each char in `s` with char::escape_unicode.\n     #[inline]\n-    fn escape_unicode() -> str { escape_unicode(self) }\n+    fn escape_unicode() -> ~str { escape_unicode(self) }\n }\n \n #[cfg(test)]\n@@ -2065,346 +2065,347 @@ mod tests {\n \n     #[test]\n     fn test_eq() {\n-        assert (eq(\"\", \"\"));\n-        assert (eq(\"foo\", \"foo\"));\n-        assert (!eq(\"foo\", \"bar\"));\n+        assert (eq(~\"\", ~\"\"));\n+        assert (eq(~\"foo\", ~\"foo\"));\n+        assert (!eq(~\"foo\", ~\"bar\"));\n     }\n \n     #[test]\n     fn test_le() {\n-        assert (le(\"\", \"\"));\n-        assert (le(\"\", \"foo\"));\n-        assert (le(\"foo\", \"foo\"));\n-        assert (!eq(\"foo\", \"bar\"));\n+        assert (le(~\"\", ~\"\"));\n+        assert (le(~\"\", ~\"foo\"));\n+        assert (le(~\"foo\", ~\"foo\"));\n+        assert (!eq(~\"foo\", ~\"bar\"));\n     }\n \n     #[test]\n     fn test_len() {\n-        assert (len(\"\") == 0u);\n-        assert (len(\"hello world\") == 11u);\n-        assert (len(\"\\x63\") == 1u);\n-        assert (len(\"\\xa2\") == 2u);\n-        assert (len(\"\\u03c0\") == 2u);\n-        assert (len(\"\\u2620\") == 3u);\n-        assert (len(\"\\U0001d11e\") == 4u);\n+        assert (len(~\"\") == 0u);\n+        assert (len(~\"hello world\") == 11u);\n+        assert (len(~\"\\x63\") == 1u);\n+        assert (len(~\"\\xa2\") == 2u);\n+        assert (len(~\"\\u03c0\") == 2u);\n+        assert (len(~\"\\u2620\") == 3u);\n+        assert (len(~\"\\U0001d11e\") == 4u);\n \n-        assert (char_len(\"\") == 0u);\n-        assert (char_len(\"hello world\") == 11u);\n-        assert (char_len(\"\\x63\") == 1u);\n-        assert (char_len(\"\\xa2\") == 1u);\n-        assert (char_len(\"\\u03c0\") == 1u);\n-        assert (char_len(\"\\u2620\") == 1u);\n-        assert (char_len(\"\\U0001d11e\") == 1u);\n-        assert (char_len(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\") == 19u);\n+        assert (char_len(~\"\") == 0u);\n+        assert (char_len(~\"hello world\") == 11u);\n+        assert (char_len(~\"\\x63\") == 1u);\n+        assert (char_len(~\"\\xa2\") == 1u);\n+        assert (char_len(~\"\\u03c0\") == 1u);\n+        assert (char_len(~\"\\u2620\") == 1u);\n+        assert (char_len(~\"\\U0001d11e\") == 1u);\n+        assert (char_len(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\") == 19u);\n     }\n \n     #[test]\n     fn test_rfind_char() {\n-        assert rfind_char(\"hello\", 'l') == some(3u);\n-        assert rfind_char(\"hello\", 'o') == some(4u);\n-        assert rfind_char(\"hello\", 'h') == some(0u);\n-        assert rfind_char(\"hello\", 'z') == none;\n-        assert rfind_char(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e') == some(30u);\n+        assert rfind_char(~\"hello\", 'l') == some(3u);\n+        assert rfind_char(~\"hello\", 'o') == some(4u);\n+        assert rfind_char(~\"hello\", 'h') == some(0u);\n+        assert rfind_char(~\"hello\", 'z') == none;\n+        assert rfind_char(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e') == some(30u);\n     }\n \n     #[test]\n     fn test_pop_char() {\n-        let mut data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n         let cc = pop_char(data);\n-        assert \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\" == data;\n+        assert ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\" == data;\n         assert '\u534e' == cc;\n     }\n \n     #[test]\n     fn test_pop_char_2() {\n-        let mut data2 = \"\u534e\";\n+        let mut data2 = ~\"\u534e\";\n         let cc2 = pop_char(data2);\n-        assert \"\" == data2;\n+        assert ~\"\" == data2;\n         assert '\u534e' == cc2;\n     }\n \n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_pop_char_fail() {\n-        let mut data = \"\";\n+        let mut data = ~\"\";\n         let _cc3 = pop_char(data);\n     }\n \n     #[test]\n     fn test_split_char() {\n-        fn t(s: str, c: char, u: ~[str]) {\n-            log(debug, \"split_byte: \" + s);\n+        fn t(s: ~str, c: char, u: ~[~str]) {\n+            log(debug, ~\"split_byte: \" + s);\n             let v = split_char(s, c);\n             #debug(\"split_byte to: %?\", v);\n             assert vec::all2(v, u, |a,b| a == b);\n         }\n-        t(\"abc.hello.there\", '.', ~[\"abc\", \"hello\", \"there\"]);\n-        t(\".hello.there\", '.', ~[\"\", \"hello\", \"there\"]);\n-        t(\"...hello.there.\", '.', ~[\"\", \"\", \"\", \"hello\", \"there\", \"\"]);\n+        t(~\"abc.hello.there\", '.', ~[~\"abc\", ~\"hello\", ~\"there\"]);\n+        t(~\".hello.there\", '.', ~[~\"\", ~\"hello\", ~\"there\"]);\n+        t(~\"...hello.there.\", '.', ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n \n-        assert ~[\"\", \"\", \"\", \"hello\", \"there\", \"\"]\n-            == split_char(\"...hello.there.\", '.');\n+        assert ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]\n+            == split_char(~\"...hello.there.\", '.');\n \n-        assert ~[\"\"] == split_char(\"\", 'z');\n-        assert ~[\"\",\"\"] == split_char(\"z\", 'z');\n-        assert ~[\"ok\"] == split_char(\"ok\", 'z');\n+        assert ~[~\"\"] == split_char(~\"\", 'z');\n+        assert ~[~\"\",~\"\"] == split_char(~\"z\", 'z');\n+        assert ~[~\"ok\"] == split_char(~\"ok\", 'z');\n     }\n \n     #[test]\n     fn test_split_char_2() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~[\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", \"i\u1ec7t Nam\"]\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n             == split_char(data, 'V');\n-        assert ~[\"\u0e1b\u0e23\u0e30\u0e40\", \"\u0e28\u0e44\", \"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n+        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n             == split_char(data, '\u0e17');\n     }\n \n     #[test]\n     fn test_splitn_char() {\n-        fn t(s: str, c: char, n: uint, u: ~[str]) {\n-            log(debug, \"splitn_byte: \" + s);\n+        fn t(s: ~str, c: char, n: uint, u: ~[~str]) {\n+            log(debug, ~\"splitn_byte: \" + s);\n             let v = splitn_char(s, c, n);\n             #debug(\"split_byte to: %?\", v);\n             #debug(\"comparing vs. %?\", u);\n             assert vec::all2(v, u, |a,b| a == b);\n         }\n-        t(\"abc.hello.there\", '.', 0u, ~[\"abc.hello.there\"]);\n-        t(\"abc.hello.there\", '.', 1u, ~[\"abc\", \"hello.there\"]);\n-        t(\"abc.hello.there\", '.', 2u, ~[\"abc\", \"hello\", \"there\"]);\n-        t(\"abc.hello.there\", '.', 3u, ~[\"abc\", \"hello\", \"there\"]);\n-        t(\".hello.there\", '.', 0u, ~[\".hello.there\"]);\n-        t(\".hello.there\", '.', 1u, ~[\"\", \"hello.there\"]);\n-        t(\"...hello.there.\", '.', 3u, ~[\"\", \"\", \"\", \"hello.there.\"]);\n-        t(\"...hello.there.\", '.', 5u, ~[\"\", \"\", \"\", \"hello\", \"there\", \"\"]);\n+        t(~\"abc.hello.there\", '.', 0u, ~[~\"abc.hello.there\"]);\n+        t(~\"abc.hello.there\", '.', 1u, ~[~\"abc\", ~\"hello.there\"]);\n+        t(~\"abc.hello.there\", '.', 2u, ~[~\"abc\", ~\"hello\", ~\"there\"]);\n+        t(~\"abc.hello.there\", '.', 3u, ~[~\"abc\", ~\"hello\", ~\"there\"]);\n+        t(~\".hello.there\", '.', 0u, ~[~\".hello.there\"]);\n+        t(~\".hello.there\", '.', 1u, ~[~\"\", ~\"hello.there\"]);\n+        t(~\"...hello.there.\", '.', 3u, ~[~\"\", ~\"\", ~\"\", ~\"hello.there.\"]);\n+        t(~\"...hello.there.\", '.', 5u,\n+          ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n \n-        assert ~[\"\"] == splitn_char(\"\", 'z', 5u);\n-        assert ~[\"\",\"\"] == splitn_char(\"z\", 'z', 5u);\n-        assert ~[\"ok\"] == splitn_char(\"ok\", 'z', 5u);\n-        assert ~[\"z\"] == splitn_char(\"z\", 'z', 0u);\n-        assert ~[\"w.x.y\"] == splitn_char(\"w.x.y\", '.', 0u);\n-        assert ~[\"w\",\"x.y\"] == splitn_char(\"w.x.y\", '.', 1u);\n+        assert ~[~\"\"] == splitn_char(~\"\", 'z', 5u);\n+        assert ~[~\"\",~\"\"] == splitn_char(~\"z\", 'z', 5u);\n+        assert ~[~\"ok\"] == splitn_char(~\"ok\", 'z', 5u);\n+        assert ~[~\"z\"] == splitn_char(~\"z\", 'z', 0u);\n+        assert ~[~\"w.x.y\"] == splitn_char(~\"w.x.y\", '.', 0u);\n+        assert ~[~\"w\",~\"x.y\"] == splitn_char(~\"w.x.y\", '.', 1u);\n     }\n \n     #[test]\n     fn test_splitn_char_2 () {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~[\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n             == splitn_char(data, '\u534e', 1u);\n \n-        assert ~[\"\", \"\", \"XXX\", \"YYYzWWWz\"]\n-            == splitn_char(\"zzXXXzYYYzWWWz\", 'z', 3u);\n-        assert ~[\"\",\"\"] == splitn_char(\"z\", 'z', 5u);\n-        assert ~[\"\"] == splitn_char(\"\", 'z', 5u);\n-        assert ~[\"ok\"] == splitn_char(\"ok\", 'z', 5u);\n+        assert ~[~\"\", ~\"\", ~\"XXX\", ~\"YYYzWWWz\"]\n+            == splitn_char(~\"zzXXXzYYYzWWWz\", 'z', 3u);\n+        assert ~[~\"\",~\"\"] == splitn_char(~\"z\", 'z', 5u);\n+        assert ~[~\"\"] == splitn_char(~\"\", 'z', 5u);\n+        assert ~[~\"ok\"] == splitn_char(~\"ok\", 'z', 5u);\n     }\n \n \n     #[test]\n     fn test_splitn_char_3() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~[\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", \"i\u1ec7t Nam\"]\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n             == splitn_char(data, 'V', 1u);\n-        assert ~[\"\u0e1b\u0e23\u0e30\u0e40\", \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n+        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n             == splitn_char(data, '\u0e17', 1u);\n \n     }\n \n     #[test]\n     fn test_split_str() {\n-        fn t(s: str, sep: str/&a, i: int, k: str) {\n+        fn t(s: ~str, sep: &a/str, i: int, k: ~str) {\n             let v = split_str(s, sep);\n             assert eq(v[i], k);\n         }\n \n-        t(\"--1233345--\", \"12345\", 0, \"--1233345--\");\n-        t(\"abc::hello::there\", \"::\", 0, \"abc\");\n-        t(\"abc::hello::there\", \"::\", 1, \"hello\");\n-        t(\"abc::hello::there\", \"::\", 2, \"there\");\n-        t(\"::hello::there\", \"::\", 0, \"\");\n-        t(\"hello::there::\", \"::\", 2, \"\");\n-        t(\"::hello::there::\", \"::\", 3, \"\");\n+        t(~\"--1233345--\", ~\"12345\", 0, ~\"--1233345--\");\n+        t(~\"abc::hello::there\", ~\"::\", 0, ~\"abc\");\n+        t(~\"abc::hello::there\", ~\"::\", 1, ~\"hello\");\n+        t(~\"abc::hello::there\", ~\"::\", 2, ~\"there\");\n+        t(~\"::hello::there\", ~\"::\", 0, ~\"\");\n+        t(~\"hello::there::\", ~\"::\", 2, ~\"\");\n+        t(~\"::hello::there::\", ~\"::\", 3, ~\"\");\n \n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~[\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", \"Vi\u1ec7t Nam\"]\n-            == split_str (data, \"\u4e2d\u534e\");\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", ~\"Vi\u1ec7t Nam\"]\n+            == split_str (data, ~\"\u4e2d\u534e\");\n \n-        assert ~[\"\", \"XXX\", \"YYY\", \"\"]\n-            == split_str(\"zzXXXzzYYYzz\", \"zz\");\n+        assert ~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]\n+            == split_str(~\"zzXXXzzYYYzz\", ~\"zz\");\n \n-        assert ~[\"zz\", \"zYYYz\"]\n-            == split_str(\"zzXXXzYYYz\", \"XXX\");\n+        assert ~[~\"zz\", ~\"zYYYz\"]\n+            == split_str(~\"zzXXXzYYYz\", ~\"XXX\");\n \n \n-        assert ~[\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\");\n-        assert ~[\"\"] == split_str(\"\", \".\");\n-        assert ~[\"\",\"\"] == split_str(\"zz\", \"zz\");\n-        assert ~[\"ok\"] == split_str(\"ok\", \"z\");\n-        assert ~[\"\",\"z\"] == split_str(\"zzz\", \"zz\");\n-        assert ~[\"\",\"\",\"z\"] == split_str(\"zzzzz\", \"zz\");\n+        assert ~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"] == split_str(~\".XXX.YYY.\", ~\".\");\n+        assert ~[~\"\"] == split_str(~\"\", ~\".\");\n+        assert ~[~\"\",~\"\"] == split_str(~\"zz\", ~\"zz\");\n+        assert ~[~\"ok\"] == split_str(~\"ok\", ~\"z\");\n+        assert ~[~\"\",~\"z\"] == split_str(~\"zzz\", ~\"zz\");\n+        assert ~[~\"\",~\"\",~\"z\"] == split_str(~\"zzzzz\", ~\"zz\");\n     }\n \n \n     #[test]\n     fn test_split() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~[\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"Vi\u1ec7t Nam\"]\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n             == split (data, |cc| cc == '\u534e');\n \n-        assert ~[\"\", \"\", \"XXX\", \"YYY\", \"\"]\n-            == split(\"zzXXXzYYYz\", char::is_lowercase);\n+        assert ~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]\n+            == split(~\"zzXXXzYYYz\", char::is_lowercase);\n \n-        assert ~[\"zz\", \"\", \"\", \"z\", \"\", \"\", \"z\"]\n-            == split(\"zzXXXzYYYz\", char::is_uppercase);\n+        assert ~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]\n+            == split(~\"zzXXXzYYYz\", char::is_uppercase);\n \n-        assert ~[\"\",\"\"] == split(\"z\", |cc| cc == 'z');\n-        assert ~[\"\"] == split(\"\", |cc| cc == 'z');\n-        assert ~[\"ok\"] == split(\"ok\", |cc| cc == 'z');\n+        assert ~[~\"\",~\"\"] == split(~\"z\", |cc| cc == 'z');\n+        assert ~[~\"\"] == split(~\"\", |cc| cc == 'z');\n+        assert ~[~\"ok\"] == split(~\"ok\", |cc| cc == 'z');\n     }\n \n     #[test]\n     fn test_lines() {\n-        let lf = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n-        let crlf = \"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n+        let lf = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        let crlf = ~\"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n \n-        assert ~[\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]\n+        assert ~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n             == lines(lf);\n \n-        assert ~[\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]\n+        assert ~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n             == lines_any(lf);\n \n-        assert ~[\"\\r\", \"Mary had a little lamb\\r\", \"Little lamb\\r\", \"\"]\n+        assert ~[~\"\\r\", ~\"Mary had a little lamb\\r\", ~\"Little lamb\\r\", ~\"\"]\n             == lines(crlf);\n \n-        assert ~[\"\", \"Mary had a little lamb\", \"Little lamb\", \"\"]\n+        assert ~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n             == lines_any(crlf);\n \n-        assert ~[\"\"] == lines    (\"\");\n-        assert ~[\"\"] == lines_any(\"\");\n-        assert ~[\"\",\"\"] == lines    (\"\\n\");\n-        assert ~[\"\",\"\"] == lines_any(\"\\n\");\n-        assert ~[\"banana\"] == lines    (\"banana\");\n-        assert ~[\"banana\"] == lines_any(\"banana\");\n+        assert ~[~\"\"] == lines    (~\"\");\n+        assert ~[~\"\"] == lines_any(~\"\");\n+        assert ~[~\"\",~\"\"] == lines    (~\"\\n\");\n+        assert ~[~\"\",~\"\"] == lines_any(~\"\\n\");\n+        assert ~[~\"banana\"] == lines    (~\"banana\");\n+        assert ~[~\"banana\"] == lines_any(~\"banana\");\n     }\n \n     #[test]\n     fn test_words () {\n-        let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n-        assert ~[\"Mary\",\"had\",\"a\",\"little\",\"lamb\",\"Little\",\"lamb\"]\n+        let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        assert ~[~\"Mary\",~\"had\",~\"a\",~\"little\",~\"lamb\",~\"Little\",~\"lamb\"]\n             == words(data);\n \n-        assert ~[\"ok\"] == words(\"ok\");\n-        assert ~[] == words(\"\");\n+        assert ~[~\"ok\"] == words(~\"ok\");\n+        assert ~[] == words(~\"\");\n     }\n \n     #[test]\n     fn test_find_str() {\n         // byte positions\n-        assert find_str(\"banana\", \"apple pie\") == none;\n-        assert find_str(\"\", \"\") == some(0u);\n+        assert find_str(~\"banana\", ~\"apple pie\") == none;\n+        assert find_str(~\"\", ~\"\") == some(0u);\n \n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert find_str(data, \"\")     == some(0u);\n-        assert find_str(data, \"\u0e1b\u0e23\u0e30\u0e40\") == some( 0u);\n-        assert find_str(data, \"\u0e30\u0e40\")   == some( 6u);\n-        assert find_str(data, \"\u4e2d\u534e\") == some(27u);\n-        assert find_str(data, \"\u0e44\u0e17\u534e\") == none;\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert find_str(data, ~\"\")     == some(0u);\n+        assert find_str(data, ~\"\u0e1b\u0e23\u0e30\u0e40\") == some( 0u);\n+        assert find_str(data, ~\"\u0e30\u0e40\")   == some( 6u);\n+        assert find_str(data, ~\"\u4e2d\u534e\") == some(27u);\n+        assert find_str(data, ~\"\u0e44\u0e17\u534e\") == none;\n     }\n \n     #[test]\n     fn test_find_str_between() {\n         // byte positions\n-        assert find_str_between(\"\", \"\", 0u, 0u) == some(0u);\n+        assert find_str_between(~\"\", ~\"\", 0u, 0u) == some(0u);\n \n-        let data = \"abcabc\";\n-        assert find_str_between(data, \"ab\", 0u, 6u) == some(0u);\n-        assert find_str_between(data, \"ab\", 2u, 6u) == some(3u);\n-        assert find_str_between(data, \"ab\", 2u, 4u) == none;\n+        let data = ~\"abcabc\";\n+        assert find_str_between(data, ~\"ab\", 0u, 6u) == some(0u);\n+        assert find_str_between(data, ~\"ab\", 2u, 6u) == some(3u);\n+        assert find_str_between(data, ~\"ab\", 2u, 4u) == none;\n \n-        let mut data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         data += data;\n-        assert find_str_between(data, \"\", 0u, 43u) == some(0u);\n-        assert find_str_between(data, \"\", 6u, 43u) == some(6u);\n+        assert find_str_between(data, ~\"\", 0u, 43u) == some(0u);\n+        assert find_str_between(data, ~\"\", 6u, 43u) == some(6u);\n \n-        assert find_str_between(data, \"\u0e1b\u0e23\u0e30\", 0u, 43u) == some( 0u);\n-        assert find_str_between(data, \"\u0e17\u0e28\u0e44\", 0u, 43u) == some(12u);\n-        assert find_str_between(data, \"\u0e22\u4e2d\", 0u, 43u) == some(24u);\n-        assert find_str_between(data, \"i\u1ec7t\", 0u, 43u) == some(34u);\n-        assert find_str_between(data, \"Nam\", 0u, 43u) == some(40u);\n+        assert find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 0u, 43u) == some( 0u);\n+        assert find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 0u, 43u) == some(12u);\n+        assert find_str_between(data, ~\"\u0e22\u4e2d\", 0u, 43u) == some(24u);\n+        assert find_str_between(data, ~\"i\u1ec7t\", 0u, 43u) == some(34u);\n+        assert find_str_between(data, ~\"Nam\", 0u, 43u) == some(40u);\n \n-        assert find_str_between(data, \"\u0e1b\u0e23\u0e30\", 43u, 86u) == some(43u);\n-        assert find_str_between(data, \"\u0e17\u0e28\u0e44\", 43u, 86u) == some(55u);\n-        assert find_str_between(data, \"\u0e22\u4e2d\", 43u, 86u) == some(67u);\n-        assert find_str_between(data, \"i\u1ec7t\", 43u, 86u) == some(77u);\n-        assert find_str_between(data, \"Nam\", 43u, 86u) == some(83u);\n+        assert find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 43u, 86u) == some(43u);\n+        assert find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 43u, 86u) == some(55u);\n+        assert find_str_between(data, ~\"\u0e22\u4e2d\", 43u, 86u) == some(67u);\n+        assert find_str_between(data, ~\"i\u1ec7t\", 43u, 86u) == some(77u);\n+        assert find_str_between(data, ~\"Nam\", 43u, 86u) == some(83u);\n     }\n \n     #[test]\n     fn test_substr() {\n-        fn t(a: str, b: str, start: int) {\n+        fn t(a: ~str, b: ~str, start: int) {\n             assert (eq(substr(a, start as uint, len(b)), b));\n         }\n-        t(\"hello\", \"llo\", 2);\n-        t(\"hello\", \"el\", 1);\n-        assert \"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\" == substr(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", 6u, 6u);\n+        t(~\"hello\", ~\"llo\", 2);\n+        t(~\"hello\", ~\"el\", 1);\n+        assert ~\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\" == substr(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", 6u, 6u);\n     }\n \n     #[test]\n     fn test_concat() {\n-        fn t(v: ~[str], s: str) { assert (eq(concat(v), s)); }\n-        t(~[\"you\", \"know\", \"I'm\", \"no\", \"good\"], \"youknowI'mnogood\");\n-        let v: ~[str] = ~[];\n-        t(v, \"\");\n-        t(~[\"hi\"], \"hi\");\n+        fn t(v: ~[~str], s: ~str) { assert (eq(concat(v), s)); }\n+        t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\"youknowI'mnogood\");\n+        let v: ~[~str] = ~[];\n+        t(v, ~\"\");\n+        t(~[~\"hi\"], ~\"hi\");\n     }\n \n     #[test]\n     fn test_connect() {\n-        fn t(v: ~[str], sep: str, s: str) {\n+        fn t(v: ~[~str], sep: ~str, s: ~str) {\n             assert (eq(connect(v, sep), s));\n         }\n-        t(~[\"you\", \"know\", \"I'm\", \"no\", \"good\"],\n-          \" \", \"you know I'm no good\");\n-        let v: ~[str] = ~[];\n-        t(v, \" \", \"\");\n-        t(~[\"hi\"], \" \", \"hi\");\n+        t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"],\n+          ~\" \", ~\"you know I'm no good\");\n+        let v: ~[~str] = ~[];\n+        t(v, ~\" \", ~\"\");\n+        t(~[~\"hi\"], ~\" \", ~\"hi\");\n     }\n \n     #[test]\n     fn test_to_upper() {\n         // libc::toupper, and hence str::to_upper\n         // are culturally insensitive: they only work for ASCII\n         // (see Issue #1347)\n-        let unicode = \"\"; //\"\\u65e5\\u672c\"; // uncomment once non-ASCII works\n-        let input = \"abcDEF\" + unicode + \"xyz:.;\";\n-        let expected = \"ABCDEF\" + unicode + \"XYZ:.;\";\n+        let unicode = ~\"\"; //\"\\u65e5\\u672c\"; // uncomment once non-ASCII works\n+        let input = ~\"abcDEF\" + unicode + ~\"xyz:.;\";\n+        let expected = ~\"ABCDEF\" + unicode + ~\"XYZ:.;\";\n         let actual = to_upper(input);\n         assert (eq(expected, actual));\n     }\n \n     #[test]\n     fn test_to_lower() {\n-        assert \"\" == map(\"\", |c| libc::tolower(c as c_char) as char);\n-        assert \"ymca\" == map(\"YMCA\",\n+        assert ~\"\" == map(~\"\", |c| libc::tolower(c as c_char) as char);\n+        assert ~\"ymca\" == map(~\"YMCA\",\n                              |c| libc::tolower(c as c_char) as char);\n     }\n \n     #[test]\n     fn test_unsafe_slice() {\n         unsafe {\n-            assert (eq(\"ab\", unsafe::slice_bytes(\"abc\", 0u, 2u)));\n-            assert (eq(\"bc\", unsafe::slice_bytes(\"abc\", 1u, 3u)));\n-            assert (eq(\"\", unsafe::slice_bytes(\"abc\", 1u, 1u)));\n-            fn a_million_letter_a() -> str {\n+            assert (eq(~\"ab\", unsafe::slice_bytes(~\"abc\", 0u, 2u)));\n+            assert (eq(~\"bc\", unsafe::slice_bytes(~\"abc\", 1u, 3u)));\n+            assert (eq(~\"\", unsafe::slice_bytes(~\"abc\", 1u, 1u)));\n+            fn a_million_letter_a() -> ~str {\n                 let mut i = 0;\n-                let mut rs = \"\";\n-                while i < 100000 { push_str(rs, \"aaaaaaaaaa\"); i += 1; }\n+                let mut rs = ~\"\";\n+                while i < 100000 { push_str(rs, ~\"aaaaaaaaaa\"); i += 1; }\n                 ret rs;\n             }\n-            fn half_a_million_letter_a() -> str {\n+            fn half_a_million_letter_a() -> ~str {\n                 let mut i = 0;\n-                let mut rs = \"\";\n-                while i < 100000 { push_str(rs, \"aaaaa\"); i += 1; }\n+                let mut rs = ~\"\";\n+                while i < 100000 { push_str(rs, ~\"aaaaa\"); i += 1; }\n                 ret rs;\n             }\n             assert eq(half_a_million_letter_a(),\n@@ -2415,107 +2416,107 @@ mod tests {\n \n     #[test]\n     fn test_starts_with() {\n-        assert (starts_with(\"\", \"\"));\n-        assert (starts_with(\"abc\", \"\"));\n-        assert (starts_with(\"abc\", \"a\"));\n-        assert (!starts_with(\"a\", \"abc\"));\n-        assert (!starts_with(\"\", \"abc\"));\n+        assert (starts_with(~\"\", ~\"\"));\n+        assert (starts_with(~\"abc\", ~\"\"));\n+        assert (starts_with(~\"abc\", ~\"a\"));\n+        assert (!starts_with(~\"a\", ~\"abc\"));\n+        assert (!starts_with(~\"\", ~\"abc\"));\n     }\n \n     #[test]\n     fn test_ends_with() {\n-        assert (ends_with(\"\", \"\"));\n-        assert (ends_with(\"abc\", \"\"));\n-        assert (ends_with(\"abc\", \"c\"));\n-        assert (!ends_with(\"a\", \"abc\"));\n-        assert (!ends_with(\"\", \"abc\"));\n+        assert (ends_with(~\"\", ~\"\"));\n+        assert (ends_with(~\"abc\", ~\"\"));\n+        assert (ends_with(~\"abc\", ~\"c\"));\n+        assert (!ends_with(~\"a\", ~\"abc\"));\n+        assert (!ends_with(~\"\", ~\"abc\"));\n     }\n \n     #[test]\n     fn test_is_empty() {\n-        assert (is_empty(\"\"));\n-        assert (!is_empty(\"a\"));\n+        assert (is_empty(~\"\"));\n+        assert (!is_empty(~\"a\"));\n     }\n \n     #[test]\n     fn test_is_not_empty() {\n-        assert (is_not_empty(\"a\"));\n-        assert (!is_not_empty(\"\"));\n+        assert (is_not_empty(~\"a\"));\n+        assert (!is_not_empty(~\"\"));\n     }\n \n     #[test]\n     fn test_replace() {\n-        let a = \"a\";\n-        assert replace(\"\", a, \"b\") == \"\";\n-        assert replace(\"a\", a, \"b\") == \"b\";\n-        assert replace(\"ab\", a, \"b\") == \"bb\";\n-        let test = \"test\";\n-        assert replace(\" test test \", test, \"toast\") == \" toast toast \";\n-        assert replace(\" test test \", test, \"\") == \"   \";\n+        let a = ~\"a\";\n+        assert replace(~\"\", a, ~\"b\") == ~\"\";\n+        assert replace(~\"a\", a, ~\"b\") == ~\"b\";\n+        assert replace(~\"ab\", a, ~\"b\") == ~\"bb\";\n+        let test = ~\"test\";\n+        assert replace(~\" test test \", test, ~\"toast\") == ~\" toast toast \";\n+        assert replace(~\" test test \", test, ~\"\") == ~\"   \";\n     }\n \n     #[test]\n     fn test_replace_2a() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n-        let a = \"\u0e1b\u0e23\u0e30\u0e40\";\n-        let A = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let a = ~\"\u0e1b\u0e23\u0e30\u0e40\";\n+        let A = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n         assert (replace(data, a, repl) ==  A);\n     }\n \n     #[test]\n     fn test_replace_2b() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n-        let b = \"\u0e30\u0e40\";\n-        let B = \"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let b = ~\"\u0e30\u0e40\";\n+        let B = ~\"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n         assert (replace(data, b,   repl) ==  B);\n     }\n \n     #[test]\n     fn test_replace_2c() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n-        let c = \"\u4e2d\u534e\";\n-        let C = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+        let c = ~\"\u4e2d\u534e\";\n+        let C = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n         assert (replace(data, c, repl) ==  C);\n     }\n \n     #[test]\n     fn test_replace_2d() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n-        let d = \"\u0e44\u0e17\u534e\";\n+        let d = ~\"\u0e44\u0e17\u534e\";\n         assert (replace(data, d, repl) == data);\n     }\n \n     #[test]\n     fn test_slice() {\n-        assert (eq(\"ab\", slice(\"abc\", 0u, 2u)));\n-        assert (eq(\"bc\", slice(\"abc\", 1u, 3u)));\n-        assert (eq(\"\", slice(\"abc\", 1u, 1u)));\n-        assert (eq(\"\\u65e5\", slice(\"\\u65e5\\u672c\", 0u, 3u)));\n-\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert \"\u0e1b\" == slice(data, 0u, 3u);\n-        assert \"\u0e23\" == slice(data, 3u, 6u);\n-        assert \"\" == slice(data, 3u, 3u);\n-        assert \"\u534e\" == slice(data, 30u, 33u);\n-\n-        fn a_million_letter_X() -> str {\n+        assert (eq(~\"ab\", slice(~\"abc\", 0u, 2u)));\n+        assert (eq(~\"bc\", slice(~\"abc\", 1u, 3u)));\n+        assert (eq(~\"\", slice(~\"abc\", 1u, 1u)));\n+        assert (eq(~\"\\u65e5\", slice(~\"\\u65e5\\u672c\", 0u, 3u)));\n+\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        assert ~\"\u0e1b\" == slice(data, 0u, 3u);\n+        assert ~\"\u0e23\" == slice(data, 3u, 6u);\n+        assert ~\"\" == slice(data, 3u, 3u);\n+        assert ~\"\u534e\" == slice(data, 30u, 33u);\n+\n+        fn a_million_letter_X() -> ~str {\n             let mut i = 0;\n-            let mut rs = \"\";\n-            while i < 100000 { push_str(rs, \"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n+            let mut rs = ~\"\";\n+            while i < 100000 { push_str(rs, ~\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n             ret rs;\n         }\n-        fn half_a_million_letter_X() -> str {\n+        fn half_a_million_letter_X() -> ~str {\n             let mut i = 0;\n-            let mut rs = \"\";\n-            while i < 100000 { push_str(rs, \"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n+            let mut rs = ~\"\";\n+            while i < 100000 { push_str(rs, ~\"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n             ret rs;\n         }\n         assert eq(half_a_million_letter_X(),\n@@ -2524,18 +2525,18 @@ mod tests {\n \n     #[test]\n     fn test_slice_2() {\n-        let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+        let ss = ~\"\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        assert \"\u534e\" == slice(ss, 3u, 6u);\n-        assert \"Vi\u1ec7t Nam\" == slice(ss, 6u, 16u);\n+        assert ~\"\u534e\" == slice(ss, 3u, 6u);\n+        assert ~\"Vi\u1ec7t Nam\" == slice(ss, 6u, 16u);\n \n-        assert \"ab\" == slice(\"abc\", 0u, 2u);\n-        assert \"bc\" == slice(\"abc\", 1u, 3u);\n-        assert \"\" == slice(\"abc\", 1u, 1u);\n+        assert ~\"ab\" == slice(~\"abc\", 0u, 2u);\n+        assert ~\"bc\" == slice(~\"abc\", 1u, 3u);\n+        assert ~\"\" == slice(~\"abc\", 1u, 1u);\n \n-        assert \"\u4e2d\" == slice(ss, 0u, 3u);\n-        assert \"\u534eV\" == slice(ss, 3u, 7u);\n-        assert \"\" == slice(ss, 3u, 3u);\n+        assert ~\"\u4e2d\" == slice(ss, 0u, 3u);\n+        assert ~\"\u534eV\" == slice(ss, 3u, 7u);\n+        assert ~\"\" == slice(ss, 3u, 3u);\n         /*0: \u4e2d\n           3: \u534e\n           6: V\n@@ -2552,81 +2553,81 @@ mod tests {\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_slice_fail() {\n-        slice(\"\u4e2d\u534eVi\u1ec7t Nam\", 0u, 2u);\n+        slice(~\"\u4e2d\u534eVi\u1ec7t Nam\", 0u, 2u);\n     }\n \n     #[test]\n     fn test_trim_left() {\n-        assert (trim_left(\"\") == \"\");\n-        assert (trim_left(\"a\") == \"a\");\n-        assert (trim_left(\"    \") == \"\");\n-        assert (trim_left(\"     blah\") == \"blah\");\n-        assert (trim_left(\"   \\u3000  wut\") == \"wut\");\n-        assert (trim_left(\"hey \") == \"hey \");\n+        assert (trim_left(~\"\") == ~\"\");\n+        assert (trim_left(~\"a\") == ~\"a\");\n+        assert (trim_left(~\"    \") == ~\"\");\n+        assert (trim_left(~\"     blah\") == ~\"blah\");\n+        assert (trim_left(~\"   \\u3000  wut\") == ~\"wut\");\n+        assert (trim_left(~\"hey \") == ~\"hey \");\n     }\n \n     #[test]\n     fn test_trim_right() {\n-        assert (trim_right(\"\") == \"\");\n-        assert (trim_right(\"a\") == \"a\");\n-        assert (trim_right(\"    \") == \"\");\n-        assert (trim_right(\"blah     \") == \"blah\");\n-        assert (trim_right(\"wut   \\u3000  \") == \"wut\");\n-        assert (trim_right(\" hey\") == \" hey\");\n+        assert (trim_right(~\"\") == ~\"\");\n+        assert (trim_right(~\"a\") == ~\"a\");\n+        assert (trim_right(~\"    \") == ~\"\");\n+        assert (trim_right(~\"blah     \") == ~\"blah\");\n+        assert (trim_right(~\"wut   \\u3000  \") == ~\"wut\");\n+        assert (trim_right(~\" hey\") == ~\" hey\");\n     }\n \n     #[test]\n     fn test_trim() {\n-        assert (trim(\"\") == \"\");\n-        assert (trim(\"a\") == \"a\");\n-        assert (trim(\"    \") == \"\");\n-        assert (trim(\"    blah     \") == \"blah\");\n-        assert (trim(\"\\nwut   \\u3000  \") == \"wut\");\n-        assert (trim(\" hey dude \") == \"hey dude\");\n+        assert (trim(~\"\") == ~\"\");\n+        assert (trim(~\"a\") == ~\"a\");\n+        assert (trim(~\"    \") == ~\"\");\n+        assert (trim(~\"    blah     \") == ~\"blah\");\n+        assert (trim(~\"\\nwut   \\u3000  \") == ~\"wut\");\n+        assert (trim(~\" hey dude \") == ~\"hey dude\");\n     }\n \n     #[test]\n     fn test_is_whitespace() {\n-        assert (is_whitespace(\"\"));\n-        assert (is_whitespace(\" \"));\n-        assert (is_whitespace(\"\\u2009\")); // Thin space\n-        assert (is_whitespace(\"  \\n\\t   \"));\n-        assert (!is_whitespace(\"   _   \"));\n+        assert (is_whitespace(~\"\"));\n+        assert (is_whitespace(~\" \"));\n+        assert (is_whitespace(~\"\\u2009\")); // Thin space\n+        assert (is_whitespace(~\"  \\n\\t   \"));\n+        assert (!is_whitespace(~\"   _   \"));\n     }\n \n     #[test]\n     fn test_is_ascii() {\n-        assert (is_ascii(\"\"));\n-        assert (is_ascii(\"a\"));\n-        assert (!is_ascii(\"\\u2009\"));\n+        assert (is_ascii(~\"\"));\n+        assert (is_ascii(~\"a\"));\n+        assert (!is_ascii(~\"\\u2009\"));\n     }\n \n     #[test]\n     fn test_shift_byte() {\n-        let mut s = \"ABC\";\n+        let mut s = ~\"ABC\";\n         let b = unsafe { unsafe::shift_byte(s) };\n-        assert (s == \"BC\");\n+        assert (s == ~\"BC\");\n         assert (b == 65u8);\n     }\n \n     #[test]\n     fn test_pop_byte() {\n-        let mut s = \"ABC\";\n+        let mut s = ~\"ABC\";\n         let b = unsafe { unsafe::pop_byte(s) };\n-        assert (s == \"AB\");\n+        assert (s == ~\"AB\");\n         assert (b == 67u8);\n     }\n \n     #[test]\n     fn test_unsafe_from_bytes() {\n         let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n         let b = unsafe { unsafe::from_bytes(a) };\n-        assert (b == \"AAAAAAA\");\n+        assert (b == ~\"AAAAAAA\");\n     }\n \n     #[test]\n     fn test_from_bytes() {\n-        let ss = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let ss = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let bb = ~[0xe0_u8, 0xb8_u8, 0xa8_u8,\n                   0xe0_u8, 0xb9_u8, 0x84_u8,\n                   0xe0_u8, 0xb8_u8, 0x97_u8,\n@@ -2665,7 +2666,7 @@ mod tests {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = vec::unsafe::to_ptr(a);\n             let c = unsafe::from_buf(b);\n-            assert (c == \"AAAAAAA\");\n+            assert (c == ~\"AAAAAAA\");\n         }\n     }\n \n@@ -2674,12 +2675,12 @@ mod tests {\n     #[should_fail]\n     fn test_as_bytes_fail() {\n         // Don't double free\n-        as_bytes::<()>(\"\", |_bytes| fail );\n+        as_bytes::<()>(~\"\", |_bytes| fail );\n     }\n \n     #[test]\n     fn test_as_buf() {\n-        let a = \"Abcdefg\";\n+        let a = ~\"Abcdefg\";\n         let b = as_buf(a, |buf| {\n             assert unsafe { *buf } == 65u8;\n             100\n@@ -2689,7 +2690,7 @@ mod tests {\n \n     #[test]\n     fn test_as_buf_small() {\n-        let a = \"A\";\n+        let a = ~\"A\";\n         let b = as_buf(a, |buf| {\n             assert unsafe { *buf } == 65u8;\n             100\n@@ -2700,7 +2701,7 @@ mod tests {\n     #[test]\n     fn test_as_buf2() {\n         unsafe {\n-            let s = \"hello\";\n+            let s = ~\"hello\";\n             let sb = as_buf(s, |b| b);\n             let s_cstr = unsafe::from_buf(sb);\n             assert (eq(s_cstr, s));\n@@ -2709,10 +2710,10 @@ mod tests {\n \n     #[test]\n     fn vec_str_conversions() {\n-        let s1: str = \"All mimsy were the borogoves\";\n+        let s1: ~str = ~\"All mimsy were the borogoves\";\n \n         let v: ~[u8] = bytes(s1);\n-        let s2: str = from_bytes(v);\n+        let s2: ~str = from_bytes(v);\n         let mut i: uint = 0u;\n         let n1: uint = len(s1);\n         let n2: uint = vec::len::<u8>(v);\n@@ -2729,33 +2730,33 @@ mod tests {\n \n     #[test]\n     fn test_contains() {\n-        assert contains(\"abcde\", \"bcd\");\n-        assert contains(\"abcde\", \"abcd\");\n-        assert contains(\"abcde\", \"bcde\");\n-        assert contains(\"abcde\", \"\");\n-        assert contains(\"\", \"\");\n-        assert !contains(\"abcde\", \"def\");\n-        assert !contains(\"\", \"a\");\n+        assert contains(~\"abcde\", ~\"bcd\");\n+        assert contains(~\"abcde\", ~\"abcd\");\n+        assert contains(~\"abcde\", ~\"bcde\");\n+        assert contains(~\"abcde\", ~\"\");\n+        assert contains(~\"\", ~\"\");\n+        assert !contains(~\"abcde\", ~\"def\");\n+        assert !contains(~\"\", ~\"a\");\n \n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert  contains(data, \"\u0e1b\u0e23\u0e30\u0e40\");\n-        assert  contains(data, \"\u0e30\u0e40\");\n-        assert  contains(data, \"\u4e2d\u534e\");\n-        assert !contains(data, \"\u0e44\u0e17\u534e\");\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert  contains(data, ~\"\u0e1b\u0e23\u0e30\u0e40\");\n+        assert  contains(data, ~\"\u0e30\u0e40\");\n+        assert  contains(data, ~\"\u4e2d\u534e\");\n+        assert !contains(data, ~\"\u0e44\u0e17\u534e\");\n     }\n \n     #[test]\n     fn test_contains_char() {\n-        assert contains_char(\"abc\", 'b');\n-        assert contains_char(\"a\", 'a');\n-        assert !contains_char(\"abc\", 'd');\n-        assert !contains_char(\"\", 'a');\n+        assert contains_char(~\"abc\", 'b');\n+        assert contains_char(~\"a\", 'a');\n+        assert !contains_char(~\"abc\", 'd');\n+        assert !contains_char(~\"\", 'a');\n     }\n \n     #[test]\n     fn test_chars_iter() {\n         let mut i = 0;\n-        do chars_iter(\"x\\u03c0y\") |ch| {\n+        do chars_iter(~\"x\\u03c0y\") |ch| {\n             alt check i {\n               0 { assert ch == 'x'; }\n               1 { assert ch == '\\u03c0'; }\n@@ -2764,14 +2765,14 @@ mod tests {\n             i += 1;\n         }\n \n-        chars_iter(\"\", |_ch| fail ); // should not fail\n+        chars_iter(~\"\", |_ch| fail ); // should not fail\n     }\n \n     #[test]\n     fn test_bytes_iter() {\n         let mut i = 0;\n \n-        do bytes_iter(\"xyz\") |bb| {\n+        do bytes_iter(~\"xyz\") |bb| {\n             alt check i {\n               0 { assert bb == 'x' as u8; }\n               1 { assert bb == 'y' as u8; }\n@@ -2780,21 +2781,21 @@ mod tests {\n             i += 1;\n         }\n \n-        bytes_iter(\"\", |bb| assert bb == 0u8);\n+        bytes_iter(~\"\", |bb| assert bb == 0u8);\n     }\n \n     #[test]\n     fn test_split_char_iter() {\n-        let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n         do split_char_iter(data, ' ') |xx| {\n             alt ii {\n-              0 { assert \"\\nMary\" == xx; }\n-              1 { assert \"had\"    == xx; }\n-              2 { assert \"a\"      == xx; }\n-              3 { assert \"little\" == xx; }\n+              0 { assert ~\"\\nMary\" == xx; }\n+              1 { assert ~\"had\"    == xx; }\n+              2 { assert ~\"a\"      == xx; }\n+              3 { assert ~\"little\" == xx; }\n               _ { () }\n             }\n             ii += 1;\n@@ -2803,15 +2804,15 @@ mod tests {\n \n     #[test]\n     fn test_splitn_char_iter() {\n-        let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n         do splitn_char_iter(data, ' ', 2u) |xx| {\n             alt ii {\n-              0 { assert \"\\nMary\" == xx; }\n-              1 { assert \"had\"    == xx; }\n-              2 { assert \"a little lamb\\nLittle lamb\\n\" == xx; }\n+              0 { assert ~\"\\nMary\" == xx; }\n+              1 { assert ~\"had\"    == xx; }\n+              2 { assert ~\"a little lamb\\nLittle lamb\\n\" == xx; }\n               _ { () }\n             }\n             ii += 1;\n@@ -2820,36 +2821,36 @@ mod tests {\n \n     #[test]\n     fn test_words_iter() {\n-        let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n         do words_iter(data) |ww| {\n             alt ii {\n-              0 { assert \"Mary\"   == ww; }\n-              1 { assert \"had\"    == ww; }\n-              2 { assert \"a\"      == ww; }\n-              3 { assert \"little\" == ww; }\n+              0 { assert ~\"Mary\"   == ww; }\n+              1 { assert ~\"had\"    == ww; }\n+              2 { assert ~\"a\"      == ww; }\n+              3 { assert ~\"little\" == ww; }\n               _ { () }\n             }\n             ii += 1;\n         }\n \n-        words_iter(\"\", |_x| fail); // should not fail\n+        words_iter(~\"\", |_x| fail); // should not fail\n     }\n \n     #[test]\n     fn test_lines_iter () {\n-        let lf = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        let lf = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n         do lines_iter(lf) |x| {\n             alt ii {\n-                0 { assert \"\" == x; }\n-                1 { assert \"Mary had a little lamb\" == x; }\n-                2 { assert \"Little lamb\" == x; }\n-                3 { assert \"\" == x; }\n+                0 { assert ~\"\" == x; }\n+                1 { assert ~\"Mary had a little lamb\" == x; }\n+                2 { assert ~\"Little lamb\" == x; }\n+                3 { assert ~\"\" == x; }\n                 _ { () }\n             }\n             ii += 1;\n@@ -2858,53 +2859,54 @@ mod tests {\n \n     #[test]\n     fn test_map() {\n-        assert \"\" == map(\"\", |c| libc::toupper(c as c_char) as char);\n-        assert \"YMCA\" == map(\"ymca\", |c| libc::toupper(c as c_char) as char);\n+        assert ~\"\" == map(~\"\", |c| libc::toupper(c as c_char) as char);\n+        assert ~\"YMCA\" == map(~\"ymca\",\n+                              |c| libc::toupper(c as c_char) as char);\n     }\n \n     #[test]\n     fn test_all() {\n-        assert true  == all(\"\", char::is_uppercase);\n-        assert false == all(\"ymca\", char::is_uppercase);\n-        assert true  == all(\"YMCA\", char::is_uppercase);\n-        assert false == all(\"yMCA\", char::is_uppercase);\n-        assert false == all(\"YMCy\", char::is_uppercase);\n+        assert true  == all(~\"\", char::is_uppercase);\n+        assert false == all(~\"ymca\", char::is_uppercase);\n+        assert true  == all(~\"YMCA\", char::is_uppercase);\n+        assert false == all(~\"yMCA\", char::is_uppercase);\n+        assert false == all(~\"YMCy\", char::is_uppercase);\n     }\n \n     #[test]\n     fn test_any() {\n-        assert false  == any(\"\", char::is_uppercase);\n-        assert false == any(\"ymca\", char::is_uppercase);\n-        assert true  == any(\"YMCA\", char::is_uppercase);\n-        assert true == any(\"yMCA\", char::is_uppercase);\n-        assert true == any(\"Ymcy\", char::is_uppercase);\n+        assert false  == any(~\"\", char::is_uppercase);\n+        assert false == any(~\"ymca\", char::is_uppercase);\n+        assert true  == any(~\"YMCA\", char::is_uppercase);\n+        assert true == any(~\"yMCA\", char::is_uppercase);\n+        assert true == any(~\"Ymcy\", char::is_uppercase);\n     }\n \n     #[test]\n     fn test_chars() {\n-        let ss = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let ss = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         assert ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m']\n             == chars(ss);\n     }\n \n     #[test]\n     fn test_utf16() {\n         let pairs =\n-            ~[(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\",\n+            ~[(~\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\",\n               ~[0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n                0xd800_u16, 0xdf3b_u16, 0xd800_u16, 0xdf46_u16,\n                0xd800_u16, 0xdf39_u16, 0xd800_u16, 0xdf3b_u16,\n                0xd800_u16, 0xdf30_u16, 0x000a_u16]),\n \n-             (\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\",\n+             (~\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\",\n               ~[0xd801_u16, 0xdc12_u16, 0xd801_u16,\n                0xdc49_u16, 0xd801_u16, 0xdc2e_u16, 0xd801_u16,\n                0xdc40_u16, 0xd801_u16, 0xdc32_u16, 0xd801_u16,\n                0xdc4b_u16, 0x0020_u16, 0xd801_u16, 0xdc0f_u16,\n                0xd801_u16, 0xdc32_u16, 0xd801_u16, 0xdc4d_u16,\n                0x000a_u16]),\n \n-             (\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\",\n+             (~\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\",\n               ~[0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n                0xd800_u16, 0xdf0b_u16, 0xd800_u16, 0xdf04_u16,\n                0xd800_u16, 0xdf11_u16, 0xd800_u16, 0xdf09_u16,\n@@ -2913,7 +2915,7 @@ mod tests {\n                0xdf04_u16, 0xd800_u16, 0xdf0b_u16, 0xd800_u16,\n                0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]),\n \n-             (\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\",\n+             (~\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\",\n               ~[0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n                0xd801_u16, 0xdc88_u16, 0xd801_u16, 0xdc91_u16,\n                0xd801_u16, 0xdc9b_u16, 0xd801_u16, 0xdc92_u16,\n@@ -2937,7 +2939,7 @@ mod tests {\n \n     #[test]\n     fn test_each_char() {\n-        let s = \"abc\";\n+        let s = ~\"abc\";\n         let mut found_b = false;\n         for each_char(s) |ch| {\n             if ch == 'b' {\n@@ -2950,7 +2952,7 @@ mod tests {\n \n     #[test]\n     fn test_unpack_slice() {\n-        let a = \"hello\";\n+        let a = ~\"hello\";\n         do unpack_slice(a) |buf, len| {\n             unsafe {\n                 assert a[0] == 'h' as u8;\n@@ -2964,29 +2966,29 @@ mod tests {\n \n     #[test]\n     fn test_escape_unicode() {\n-        assert escape_unicode(\"abc\") == \"\\\\x61\\\\x62\\\\x63\";\n-        assert escape_unicode(\"a c\") == \"\\\\x61\\\\x20\\\\x63\";\n-        assert escape_unicode(\"\\r\\n\\t\") == \"\\\\x0d\\\\x0a\\\\x09\";\n-        assert escape_unicode(\"'\\\"\\\\\") == \"\\\\x27\\\\x22\\\\x5c\";\n-        assert escape_unicode(\"\\x00\\x01\\xfe\\xff\") == \"\\\\x00\\\\x01\\\\xfe\\\\xff\";\n-        assert escape_unicode(\"\\u0100\\uffff\") == \"\\\\u0100\\\\uffff\";\n-        assert escape_unicode(\"\\U00010000\\U0010ffff\") ==\n-            \"\\\\U00010000\\\\U0010ffff\";\n-        assert escape_unicode(\"ab\\ufb00\") == \"\\\\x61\\\\x62\\\\ufb00\";\n-        assert escape_unicode(\"\\U0001d4ea\\r\") == \"\\\\U0001d4ea\\\\x0d\";\n+        assert escape_unicode(~\"abc\") == ~\"\\\\x61\\\\x62\\\\x63\";\n+        assert escape_unicode(~\"a c\") == ~\"\\\\x61\\\\x20\\\\x63\";\n+        assert escape_unicode(~\"\\r\\n\\t\") == ~\"\\\\x0d\\\\x0a\\\\x09\";\n+        assert escape_unicode(~\"'\\\"\\\\\") == ~\"\\\\x27\\\\x22\\\\x5c\";\n+        assert escape_unicode(~\"\\x00\\x01\\xfe\\xff\") == ~\"\\\\x00\\\\x01\\\\xfe\\\\xff\";\n+        assert escape_unicode(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\";\n+        assert escape_unicode(~\"\\U00010000\\U0010ffff\") ==\n+            ~\"\\\\U00010000\\\\U0010ffff\";\n+        assert escape_unicode(~\"ab\\ufb00\") == ~\"\\\\x61\\\\x62\\\\ufb00\";\n+        assert escape_unicode(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\x0d\";\n     }\n \n     #[test]\n     fn test_escape_default() {\n-        assert escape_default(\"abc\") == \"abc\";\n-        assert escape_default(\"a c\") == \"a c\";\n-        assert escape_default(\"\\r\\n\\t\") == \"\\\\r\\\\n\\\\t\";\n-        assert escape_default(\"'\\\"\\\\\") == \"\\\\'\\\\\\\"\\\\\\\\\";\n-        assert escape_default(\"\\u0100\\uffff\") == \"\\\\u0100\\\\uffff\";\n-        assert escape_default(\"\\U00010000\\U0010ffff\") ==\n-            \"\\\\U00010000\\\\U0010ffff\";\n-        assert escape_default(\"ab\\ufb00\") == \"ab\\\\ufb00\";\n-        assert escape_default(\"\\U0001d4ea\\r\") == \"\\\\U0001d4ea\\\\r\";\n+        assert escape_default(~\"abc\") == ~\"abc\";\n+        assert escape_default(~\"a c\") == ~\"a c\";\n+        assert escape_default(~\"\\r\\n\\t\") == ~\"\\\\r\\\\n\\\\t\";\n+        assert escape_default(~\"'\\\"\\\\\") == ~\"\\\\'\\\\\\\"\\\\\\\\\";\n+        assert escape_default(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\";\n+        assert escape_default(~\"\\U00010000\\U0010ffff\") ==\n+            ~\"\\\\U00010000\\\\U0010ffff\";\n+        assert escape_default(~\"ab\\ufb00\") == ~\"ab\\\\ufb00\";\n+        assert escape_default(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\r\";\n     }\n \n }"}, {"sha": "0e5a39e859e5e566e445cc2ebb0407e0831eedbb", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -20,7 +20,7 @@ type rust_cond_lock = *libc::c_void;\n #[abi = \"cdecl\"]\n extern mod rustrt {\n     fn unsupervise();\n-    pure fn shape_log_str(t: *sys::type_desc, data: *()) -> str;\n+    pure fn shape_log_str(t: *sys::type_desc, data: *()) -> ~str;\n \n     fn rust_create_cond_lock() -> rust_cond_lock;\n     fn rust_destroy_cond_lock(lock: rust_cond_lock);\n@@ -77,7 +77,7 @@ pure fn refcount<T>(+t: @T) -> uint {\n     }\n }\n \n-pure fn log_str<T>(t: T) -> str {\n+pure fn log_str<T>(t: T) -> ~str {\n     unsafe {\n         let data_ptr: *() = unsafe::reinterpret_cast(ptr::addr_of(t));\n         rustrt::shape_log_str(get_type_desc::<T>(), data_ptr)"}, {"sha": "b9a642c16b51379eadeb9ef87db15d090745dea9", "filename": "src/libcore/task.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -520,7 +520,7 @@ fn yield() {\n     let mut killed = false;\n     rustrt::rust_task_yield(task_, killed);\n     if killed && !failing() {\n-        fail \"killed\";\n+        fail ~\"killed\";\n     }\n }\n \n@@ -782,20 +782,20 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n \n     fn new_task_in_new_sched(opts: sched_opts) -> *rust_task {\n         if opts.foreign_stack_size != none {\n-            fail \"foreign_stack_size scheduler option unimplemented\";\n+            fail ~\"foreign_stack_size scheduler option unimplemented\";\n         }\n \n         let num_threads = alt opts.mode {\n           single_threaded { 1u }\n           thread_per_core {\n-            fail \"thread_per_core scheduling mode unimplemented\"\n+            fail ~\"thread_per_core scheduling mode unimplemented\"\n           }\n           thread_per_task {\n-            fail \"thread_per_task scheduling mode unimplemented\"\n+            fail ~\"thread_per_task scheduling mode unimplemented\"\n           }\n           manual_threads(threads) {\n             if threads == 0u {\n-                fail \"can not create a scheduler with no threads\";\n+                fail ~\"can not create a scheduler with no threads\";\n             }\n             threads\n           }\n@@ -1146,21 +1146,21 @@ fn test_spawn_listiner_bidi() {\n         // Now the child has a port called 'po' to read from and\n         // an environment-captured channel called 'ch'.\n         let res = comm::recv(po);\n-        assert res == \"ping\";\n-        comm::send(ch, \"pong\");\n+        assert res == ~\"ping\";\n+        comm::send(ch, ~\"pong\");\n     };\n     // Likewise, the parent has both a 'po' and 'ch'\n-    comm::send(ch, \"ping\");\n+    comm::send(ch, ~\"ping\");\n     let res = comm::recv(po);\n-    assert res == \"pong\";\n+    assert res == ~\"pong\";\n }\n \n #[test]\n fn test_try_success() {\n     alt do try {\n-        \"Success!\"\n+        ~\"Success!\"\n     } {\n-        result::ok(\"Success!\") { }\n+        result::ok(~\"Success!\") { }\n         _ { fail; }\n     }\n }\n@@ -1466,54 +1466,54 @@ fn test_unkillable_nested() {\n \n #[test]\n fn test_tls_multitask() unsafe {\n-    fn my_key(+_x: @str/~) { }\n-    local_data_set(my_key, @\"parent data\");\n+    fn my_key(+_x: @~str) { }\n+    local_data_set(my_key, @~\"parent data\");\n     do task::spawn {\n         assert local_data_get(my_key) == none; // TLS shouldn't carry over.\n-        local_data_set(my_key, @\"child data\");\n-        assert *(local_data_get(my_key).get()) == \"child data\";\n+        local_data_set(my_key, @~\"child data\");\n+        assert *(local_data_get(my_key).get()) == ~\"child data\";\n         // should be cleaned up for us\n     }\n     // Must work multiple times\n-    assert *(local_data_get(my_key).get()) == \"parent data\";\n-    assert *(local_data_get(my_key).get()) == \"parent data\";\n-    assert *(local_data_get(my_key).get()) == \"parent data\";\n+    assert *(local_data_get(my_key).get()) == ~\"parent data\";\n+    assert *(local_data_get(my_key).get()) == ~\"parent data\";\n+    assert *(local_data_get(my_key).get()) == ~\"parent data\";\n }\n \n #[test]\n fn test_tls_overwrite() unsafe {\n-    fn my_key(+_x: @str/~) { }\n-    local_data_set(my_key, @\"first data\");\n-    local_data_set(my_key, @\"next data\"); // Shouldn't leak.\n-    assert *(local_data_get(my_key).get()) == \"next data\";\n+    fn my_key(+_x: @~str) { }\n+    local_data_set(my_key, @~\"first data\");\n+    local_data_set(my_key, @~\"next data\"); // Shouldn't leak.\n+    assert *(local_data_get(my_key).get()) == ~\"next data\";\n }\n \n #[test]\n fn test_tls_pop() unsafe {\n-    fn my_key(+_x: @str/~) { }\n-    local_data_set(my_key, @\"weasel\");\n-    assert *(local_data_pop(my_key).get()) == \"weasel\";\n+    fn my_key(+_x: @~str) { }\n+    local_data_set(my_key, @~\"weasel\");\n+    assert *(local_data_pop(my_key).get()) == ~\"weasel\";\n     // Pop must remove the data from the map.\n     assert local_data_pop(my_key) == none;\n }\n \n #[test]\n fn test_tls_modify() unsafe {\n-    fn my_key(+_x: @str/~) { }\n+    fn my_key(+_x: @~str) { }\n     local_data_modify(my_key, |data| {\n         alt data {\n-            some(@val) { fail \"unwelcome value: \" + val }\n-            none       { some(@\"first data\") }\n+            some(@val) { fail ~\"unwelcome value: \" + val }\n+            none       { some(@~\"first data\") }\n         }\n     });\n     local_data_modify(my_key, |data| {\n         alt data {\n-            some(@\"first data\") { some(@\"next data\") }\n-            some(@val)          { fail \"wrong value: \" + val }\n-            none                { fail \"missing value\" }\n+            some(@~\"first data\") { some(@~\"next data\") }\n+            some(@val)          { fail ~\"wrong value: \" + val }\n+            none                { fail ~\"missing value\" }\n         }\n     });\n-    assert *(local_data_pop(my_key).get()) == \"next data\";\n+    assert *(local_data_pop(my_key).get()) == ~\"next data\";\n }\n \n #[test]\n@@ -1523,31 +1523,31 @@ fn test_tls_crust_automorestack_memorial_bug() unsafe {\n     // jump over to the rust stack, which causes next_c_sp to get recorded as\n     // something within a rust stack segment. Then a subsequent upcall (esp.\n     // for logging, think vsnprintf) would run on a stack smaller than 1 MB.\n-    fn my_key(+_x: @str/~) { }\n+    fn my_key(+_x: @~str) { }\n     do task::spawn {\n-        unsafe { local_data_set(my_key, @\"hax\"); }\n+        unsafe { local_data_set(my_key, @~\"hax\"); }\n     }\n }\n \n #[test]\n fn test_tls_multiple_types() unsafe {\n-    fn str_key(+_x: @str/~) { }\n+    fn str_key(+_x: @~str) { }\n     fn box_key(+_x: @@()) { }\n     fn int_key(+_x: @int) { }\n     do task::spawn {\n-        local_data_set(str_key, @\"string data\");\n+        local_data_set(str_key, @~\"string data\");\n         local_data_set(box_key, @@());\n         local_data_set(int_key, @42);\n     }\n }\n \n #[test]\n fn test_tls_overwrite_multiple_types() unsafe {\n-    fn str_key(+_x: @str/~) { }\n+    fn str_key(+_x: @~str) { }\n     fn box_key(+_x: @@()) { }\n     fn int_key(+_x: @int) { }\n     do task::spawn {\n-        local_data_set(str_key, @\"string data\");\n+        local_data_set(str_key, @~\"string data\");\n         local_data_set(int_key, @42);\n         // This could cause a segfault if overwriting-destruction is done with\n         // the crazy polymorphic transmute rather than the provided finaliser.\n@@ -1559,13 +1559,13 @@ fn test_tls_overwrite_multiple_types() unsafe {\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_tls_cleanup_on_failure() unsafe {\n-    fn str_key(+_x: @str/~) { }\n+    fn str_key(+_x: @~str) { }\n     fn box_key(+_x: @@()) { }\n     fn int_key(+_x: @int) { }\n-    local_data_set(str_key, @\"parent data\");\n+    local_data_set(str_key, @~\"parent data\");\n     local_data_set(box_key, @@());\n     do task::spawn { // spawn_linked\n-        local_data_set(str_key, @\"string data\");\n+        local_data_set(str_key, @~\"string data\");\n         local_data_set(box_key, @@());\n         local_data_set(int_key, @42);\n         fail;"}, {"sha": "0daeff8197517403fec221ab153bd73ca5f3aaf3", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -10,10 +10,10 @@ impl of to_bytes for @~[u8] {\n     fn to_bytes() -> ~[u8] { copy *self }\n }\n \n-impl of to_bytes for str {\n+impl of to_bytes for ~str {\n     fn to_bytes() -> ~[u8] { str::bytes(self) }\n }\n \n-impl of to_bytes for @(str/~) {\n+impl of to_bytes for @(~str) {\n     fn to_bytes() -> ~[u8] { str::bytes(*self) }\n }"}, {"sha": "138a408435a5cbdf506127d0c68c7e3e44c45c8d", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -1,67 +1,67 @@\n-iface to_str { fn to_str() -> str; }\n+iface to_str { fn to_str() -> ~str; }\n \n impl of to_str for int {\n-    fn to_str() -> str { int::str(self) }\n+    fn to_str() -> ~str { int::str(self) }\n }\n impl of to_str for i8 {\n-    fn to_str() -> str { i8::str(self) }\n+    fn to_str() -> ~str { i8::str(self) }\n }\n impl of to_str for i16 {\n-    fn to_str() -> str { i16::str(self) }\n+    fn to_str() -> ~str { i16::str(self) }\n }\n impl of to_str for i32 {\n-    fn to_str() -> str { i32::str(self) }\n+    fn to_str() -> ~str { i32::str(self) }\n }\n impl of to_str for i64 {\n-    fn to_str() -> str { i64::str(self) }\n+    fn to_str() -> ~str { i64::str(self) }\n }\n impl of to_str for uint {\n-    fn to_str() -> str { uint::str(self) }\n+    fn to_str() -> ~str { uint::str(self) }\n }\n impl of to_str for u8 {\n-    fn to_str() -> str { u8::str(self) }\n+    fn to_str() -> ~str { u8::str(self) }\n }\n impl of to_str for u16 {\n-    fn to_str() -> str { u16::str(self) }\n+    fn to_str() -> ~str { u16::str(self) }\n }\n impl of to_str for u32 {\n-    fn to_str() -> str { u32::str(self) }\n+    fn to_str() -> ~str { u32::str(self) }\n }\n impl of to_str for u64 {\n-    fn to_str() -> str { u64::str(self) }\n+    fn to_str() -> ~str { u64::str(self) }\n }\n impl of to_str for float {\n-    fn to_str() -> str { float::to_str(self, 4u) }\n+    fn to_str() -> ~str { float::to_str(self, 4u) }\n }\n impl of to_str for bool {\n-    fn to_str() -> str { bool::to_str(self) }\n+    fn to_str() -> ~str { bool::to_str(self) }\n }\n impl of to_str for () {\n-    fn to_str() -> str { \"()\" }\n+    fn to_str() -> ~str { ~\"()\" }\n }\n-impl of to_str for str {\n-    fn to_str() -> str { self }\n+impl of to_str for ~str {\n+    fn to_str() -> ~str { self }\n }\n \n impl <A: to_str copy, B: to_str copy> of to_str for (A, B) {\n-    fn to_str() -> str {\n+    fn to_str() -> ~str {\n         let (a, b) = self;\n-        \"(\" + a.to_str() + \", \" + b.to_str() + \")\"\n+        ~\"(\" + a.to_str() + ~\", \" + b.to_str() + ~\")\"\n     }\n }\n impl <A: to_str copy, B: to_str copy, C: to_str copy> of to_str for (A, B, C){\n-    fn to_str() -> str {\n+    fn to_str() -> ~str {\n         let (a, b, c) = self;\n-        \"(\" + a.to_str() + \", \" + b.to_str() + \", \" + c.to_str() + \")\"\n+        ~\"(\" + a.to_str() + ~\", \" + b.to_str() + ~\", \" + c.to_str() + ~\")\"\n     }\n }\n \n impl <A: to_str> of to_str for ~[A] {\n-    fn to_str() -> str {\n-        let mut acc = \"[\", first = true;\n+    fn to_str() -> ~str {\n+        let mut acc = ~\"[\", first = true;\n         for vec::each(self) |elt| {\n             if first { first = false; }\n-            else { str::push_str(acc, \", \"); }\n+            else { str::push_str(acc, ~\", \"); }\n             str::push_str(acc, elt.to_str());\n         }\n         str::push_char(acc, ']');\n@@ -70,47 +70,47 @@ impl <A: to_str> of to_str for ~[A] {\n }\n \n impl <A: to_str> of to_str for @A {\n-    fn to_str() -> str { \"@\" + (*self).to_str() }\n+    fn to_str() -> ~str { ~\"@\" + (*self).to_str() }\n }\n impl <A: to_str> of to_str for ~A {\n-    fn to_str() -> str { \"~\" + (*self).to_str() }\n+    fn to_str() -> ~str { ~\"~\" + (*self).to_str() }\n }\n \n #[cfg(test)]\n mod tests {\n     #[test]\n     fn test_simple_types() {\n-        assert 1.to_str() == \"1\";\n-        assert (-1).to_str() == \"-1\";\n-        assert 200u.to_str() == \"200\";\n-        assert 2u8.to_str() == \"2\";\n-        assert true.to_str() == \"true\";\n-        assert false.to_str() == \"false\";\n-        assert ().to_str() == \"()\";\n-        assert \"hi\".to_str() == \"hi\";\n+        assert 1.to_str() == ~\"1\";\n+        assert (-1).to_str() == ~\"-1\";\n+        assert 200u.to_str() == ~\"200\";\n+        assert 2u8.to_str() == ~\"2\";\n+        assert true.to_str() == ~\"true\";\n+        assert false.to_str() == ~\"false\";\n+        assert ().to_str() == ~\"()\";\n+        assert (~\"hi\").to_str() == ~\"hi\";\n     }\n \n     #[test]\n     fn test_tuple_types() {\n-        assert (1, 2).to_str() == \"(1, 2)\";\n-        assert (\"a\", \"b\", false).to_str() == \"(a, b, false)\";\n-        assert ((), ((), 100)).to_str() == \"((), ((), 100))\";\n+        assert (1, 2).to_str() == ~\"(1, 2)\";\n+        assert (~\"a\", ~\"b\", false).to_str() == ~\"(a, b, false)\";\n+        assert ((), ((), 100)).to_str() == ~\"((), ((), 100))\";\n     }\n \n     #[test]\n     #[ignore]\n     fn test_vectors() {\n         let x: ~[int] = ~[];\n-        assert x.to_str() == \"~[]\";\n-        assert (~[1]).to_str() == \"~[1]\";\n-        assert (~[1, 2, 3]).to_str() == \"~[1, 2, 3]\";\n+        assert x.to_str() == ~\"~[]\";\n+        assert (~[1]).to_str() == ~\"~[1]\";\n+        assert (~[1, 2, 3]).to_str() == ~\"~[1, 2, 3]\";\n         assert (~[~[], ~[1], ~[1, 1]]).to_str() ==\n-               \"~[~[], ~[1], ~[1, 1]]\";\n+               ~\"~[~[], ~[1], ~[1, 1]]\";\n     }\n \n     #[test]\n     fn test_pointer_types() {\n-        assert (@1).to_str() == \"@1\";\n-        assert (~(true, false)).to_str() == \"~(true, false)\";\n+        assert (@1).to_str() == ~\"@1\";\n+        assert (~(true, false)).to_str() == ~\"~(true, false)\";\n     }\n }"}, {"sha": "fe6f15f5d6909c4546d363a70833031a2c437100", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -22,7 +22,7 @@ pure fn swap<T:copy, U:copy>(pair: (T, U)) -> (U, T) {\n #[test]\n fn test_tuple() {\n     assert first((948, 4039.48)) == 948;\n-    assert second((34.5, \"foo\")) == \"foo\";\n+    assert second((34.5, ~\"foo\")) == ~\"foo\";\n     assert swap(('a', 2)) == (2, 'a');\n }\n "}, {"sha": "7c4244efd9bde4827de92403b53780a8dbae1d03", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -121,10 +121,10 @@ impl times of iter::times for T {\n }\n \n /// Parse a string to an int\n-fn from_str(s: str) -> option<T> { parse_buf(str::bytes(s), 10u) }\n+fn from_str(s: ~str) -> option<T> { parse_buf(str::bytes(s), 10u) }\n \n /// Parse a string as an unsigned integer.\n-fn from_str_radix(buf: str, radix: u64) -> option<u64> {\n+fn from_str_radix(buf: ~str, radix: u64) -> option<u64> {\n     if str::len(buf) == 0u { ret none; }\n     let mut i = str::len(buf) - 1u;\n     let mut power = 1u64, n = 0u64;\n@@ -146,7 +146,7 @@ fn from_str_radix(buf: str, radix: u64) -> option<u64> {\n  *\n  * Fails if `radix` < 2 or `radix` > 16\n  */\n-fn to_str(num: T, radix: uint) -> str {\n+fn to_str(num: T, radix: uint) -> ~str {\n     do to_str_bytes(false, num, radix) |slice| {\n         do vec::unpack_slice(slice) |p, len| {\n             unsafe { str::unsafe::from_buf_len(p, len) }\n@@ -220,46 +220,46 @@ fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n }\n \n /// Convert to a string\n-fn str(i: T) -> str { ret to_str(i, 10u); }\n+fn str(i: T) -> ~str { ret to_str(i, 10u); }\n \n #[test]\n fn test_to_str() {\n-    assert to_str(0 as T, 10u) == \"0\";\n-    assert to_str(1 as T, 10u) == \"1\";\n-    assert to_str(2 as T, 10u) == \"2\";\n-    assert to_str(11 as T, 10u) == \"11\";\n-    assert to_str(11 as T, 16u) == \"b\";\n-    assert to_str(255 as T, 16u) == \"ff\";\n-    assert to_str(0xff as T, 10u) == \"255\";\n+    assert to_str(0 as T, 10u) == ~\"0\";\n+    assert to_str(1 as T, 10u) == ~\"1\";\n+    assert to_str(2 as T, 10u) == ~\"2\";\n+    assert to_str(11 as T, 10u) == ~\"11\";\n+    assert to_str(11 as T, 16u) == ~\"b\";\n+    assert to_str(255 as T, 16u) == ~\"ff\";\n+    assert to_str(0xff as T, 10u) == ~\"255\";\n }\n \n #[test]\n #[ignore]\n fn test_from_str() {\n-    assert from_str(\"0\") == some(0u as T);\n-    assert from_str(\"3\") == some(3u as T);\n-    assert from_str(\"10\") == some(10u as T);\n-    assert from_str(\"123456789\") == some(123456789u as T);\n-    assert from_str(\"00100\") == some(100u as T);\n-\n-    assert from_str(\"\") == none;\n-    assert from_str(\" \") == none;\n-    assert from_str(\"x\") == none;\n+    assert from_str(~\"0\") == some(0u as T);\n+    assert from_str(~\"3\") == some(3u as T);\n+    assert from_str(~\"10\") == some(10u as T);\n+    assert from_str(~\"123456789\") == some(123456789u as T);\n+    assert from_str(~\"00100\") == some(100u as T);\n+\n+    assert from_str(~\"\") == none;\n+    assert from_str(~\" \") == none;\n+    assert from_str(~\"x\") == none;\n }\n \n #[test]\n #[ignore]\n fn test_parse_buf() {\n     import str::bytes;\n-    assert parse_buf(bytes(\"123\"), 10u) == some(123u as T);\n-    assert parse_buf(bytes(\"1001\"), 2u) == some(9u as T);\n-    assert parse_buf(bytes(\"123\"), 8u) == some(83u as T);\n-    assert parse_buf(bytes(\"123\"), 16u) == some(291u as T);\n-    assert parse_buf(bytes(\"ffff\"), 16u) == some(65535u as T);\n-    assert parse_buf(bytes(\"z\"), 36u) == some(35u as T);\n-\n-    assert parse_buf(str::bytes(\"Z\"), 10u) == none;\n-    assert parse_buf(str::bytes(\"_\"), 2u) == none;\n+    assert parse_buf(bytes(~\"123\"), 10u) == some(123u as T);\n+    assert parse_buf(bytes(~\"1001\"), 2u) == some(9u as T);\n+    assert parse_buf(bytes(~\"123\"), 8u) == some(83u as T);\n+    assert parse_buf(bytes(~\"123\"), 16u) == some(291u as T);\n+    assert parse_buf(bytes(~\"ffff\"), 16u) == some(65535u as T);\n+    assert parse_buf(bytes(~\"z\"), 36u) == some(35u as T);\n+\n+    assert parse_buf(str::bytes(~\"Z\"), 10u) == none;\n+    assert parse_buf(str::bytes(~\"_\"), 2u) == none;\n }\n \n #[test]"}, {"sha": "343fca55813e14e3b18154143b0c1d2047d7e5cc", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -58,13 +58,13 @@ mod tests {\n     #[test]\n     fn test_bump_box_refcount() {\n         unsafe {\n-            let box = @\"box box box\";       // refcount 1\n+            let box = @~\"box box box\";       // refcount 1\n             bump_box_refcount(box);         // refcount 2\n             let ptr: *int = transmute(box); // refcount 2\n-            let _box1: @str/~ = reinterpret_cast(ptr);\n-            let _box2: @str/~ = reinterpret_cast(ptr);\n-            assert *_box1 == \"box box box\";\n-            assert *_box2 == \"box box box\";\n+            let _box1: @~str = reinterpret_cast(ptr);\n+            let _box2: @~str = reinterpret_cast(ptr);\n+            assert *_box1 == ~\"box box box\";\n+            assert *_box2 == ~\"box box box\";\n             // Will destroy _box1 and _box2. Without the bump, this would\n             // use-after-free. With too many bumps, it would leak.\n         }\n@@ -83,7 +83,7 @@ mod tests {\n     #[test]\n     fn test_transmute2() {\n         unsafe {\n-            assert transmute(\"L\") == ~[76u8, 0u8];\n+            assert transmute(~\"L\") == ~[76u8, 0u8];\n         }\n     }\n }"}, {"sha": "475f1557610275898a3f307cd4869f9f72c74d72", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -239,7 +239,7 @@ pure fn init<T: copy>(v: &[const T]) -> ~[T] {\n \n /// Returns the last element of the slice `v`, failing if the slice is empty.\n pure fn last<T: copy>(v: &[const T]) -> T {\n-    if len(v) == 0u { fail \"last_unsafe: empty vector\" }\n+    if len(v) == 0u { fail ~\"last_unsafe: empty vector\" }\n     v[len(v) - 1u]\n }\n "}, {"sha": "e2c8ad31344df65e27e4941dc1f31e75908f9a8c", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -1,17 +1,17 @@\n import io::{reader, reader_util};\n \n iface to_base64 {\n-    fn to_base64() -> str;\n+    fn to_base64() -> ~str;\n }\n \n impl of to_base64 for ~[u8] {\n-    fn to_base64() -> str {\n+    fn to_base64() -> ~str {\n         let chars = str::chars(\n-            \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n+          ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n         );\n \n         let len = self.len();\n-        let mut s = \"\";\n+        let mut s = ~\"\";\n         str::reserve(s, ((len + 3u) / 4u) * 3u);\n \n         let mut i = 0u;\n@@ -52,8 +52,8 @@ impl of to_base64 for ~[u8] {\n     }\n }\n \n-impl of to_base64 for str {\n-    fn to_base64() -> str {\n+impl of to_base64 for ~str {\n+    fn to_base64() -> ~str {\n         str::bytes(self).to_base64()\n     }\n }\n@@ -64,7 +64,7 @@ iface from_base64 {\n \n impl of from_base64 for ~[u8] {\n     fn from_base64() -> ~[u8] {\n-        if self.len() % 4u != 0u { fail \"invalid base64 length\"; }\n+        if self.len() % 4u != 0u { fail ~\"invalid base64 length\"; }\n \n         let len = self.len();\n         let mut padding = 0u;\n@@ -107,11 +107,11 @@ impl of from_base64 for ~[u8] {\n                         ret copy r;\n                       }\n                       _ {\n-                        fail \"invalid base64 padding\";\n+                        fail ~\"invalid base64 padding\";\n                       }\n                     }\n                 } else {\n-                    fail \"invalid base64 character\";\n+                    fail ~\"invalid base64 character\";\n                 }\n \n                 i += 1u;\n@@ -126,7 +126,7 @@ impl of from_base64 for ~[u8] {\n     }\n }\n \n-impl of from_base64 for str {\n+impl of from_base64 for ~str {\n     fn from_base64() -> ~[u8] {\n         str::bytes(self).from_base64()\n     }\n@@ -136,23 +136,23 @@ impl of from_base64 for str {\n mod tests {\n     #[test]\n     fn test_to_base64() {\n-        assert \"\".to_base64()       == \"\";\n-        assert \"f\".to_base64()      == \"Zg==\";\n-        assert \"fo\".to_base64()     == \"Zm8=\";\n-        assert \"foo\".to_base64()    == \"Zm9v\";\n-        assert \"foob\".to_base64()   == \"Zm9vYg==\";\n-        assert \"fooba\".to_base64()  == \"Zm9vYmE=\";\n-        assert \"foobar\".to_base64() == \"Zm9vYmFy\";\n+        assert (~\"\").to_base64()       == ~\"\";\n+        assert (~\"f\").to_base64()      == ~\"Zg==\";\n+        assert (~\"fo\").to_base64()     == ~\"Zm8=\";\n+        assert (~\"foo\").to_base64()    == ~\"Zm9v\";\n+        assert (~\"foob\").to_base64()   == ~\"Zm9vYg==\";\n+        assert (~\"fooba\").to_base64()  == ~\"Zm9vYmE=\";\n+        assert (~\"foobar\").to_base64() == ~\"Zm9vYmFy\";\n     }\n \n     #[test]\n     fn test_from_base64() {\n-        assert \"\".from_base64() == str::bytes(\"\");\n-        assert \"Zg==\".from_base64() == str::bytes(\"f\");\n-        assert \"Zm8=\".from_base64() == str::bytes(\"fo\");\n-        assert \"Zm9v\".from_base64() == str::bytes(\"foo\");\n-        assert \"Zm9vYg==\".from_base64() == str::bytes(\"foob\");\n-        assert \"Zm9vYmE=\".from_base64() == str::bytes(\"fooba\");\n-        assert \"Zm9vYmFy\".from_base64() == str::bytes(\"foobar\");\n+        assert (~\"\").from_base64() == str::bytes(~\"\");\n+        assert (~\"Zg==\").from_base64() == str::bytes(~\"f\");\n+        assert (~\"Zm8=\").from_base64() == str::bytes(~\"fo\");\n+        assert (~\"Zm9v\").from_base64() == str::bytes(~\"foo\");\n+        assert (~\"Zm9vYg==\").from_base64() == str::bytes(~\"foob\");\n+        assert (~\"Zm9vYmE=\").from_base64() == str::bytes(~\"fooba\");\n+        assert (~\"Zm9vYmFy\").from_base64() == str::bytes(~\"foobar\");\n     }\n }"}, {"sha": "3816e415b9636e4711966b2412357eff8f3db7be", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -213,9 +213,9 @@ fn each_storage(v: bitv, op: fn(&uint) -> bool) {\n  * The resulting string has the same length as the bitvector, and each\n  * character is either '0' or '1'.\n  */\n-fn to_str(v: bitv) -> str {\n-    let mut rs = \"\";\n-    for each(v) |i| { if i { rs += \"1\"; } else { rs += \"0\"; } }\n+fn to_str(v: bitv) -> ~str {\n+    let mut rs = ~\"\";\n+    for each(v) |i| { if i { rs += ~\"1\"; } else { rs += ~\"0\"; } }\n     ret rs;\n }\n \n@@ -243,10 +243,10 @@ mod tests {\n     #[test]\n     fn test_to_str() {\n         let zerolen = bitv(0u, false);\n-        assert to_str(zerolen) == \"\";\n+        assert to_str(zerolen) == ~\"\";\n \n         let eightbits = bitv(8u, false);\n-        assert to_str(eightbits) == \"00000000\";\n+        assert to_str(eightbits) == ~\"00000000\";\n     }\n \n     #[test]"}, {"sha": "5f833a20e326868637ee833c3ac567ad94276f0e", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -127,7 +127,7 @@ fn with_doc_data<T>(d: doc, f: fn(x: &[u8]) -> T) -> T {\n     ret f(vec::slice::<u8>(*d.data, d.start, d.end));\n }\n \n-fn doc_as_str(d: doc) -> str { ret str::from_bytes(doc_data(d)); }\n+fn doc_as_str(d: doc) -> ~str { ret str::from_bytes(doc_data(d)); }\n \n fn doc_as_u8(d: doc) -> u8 {\n     assert d.end == d.start + 1u;\n@@ -271,7 +271,7 @@ impl writer for writer {\n         self.wr_tagged_bytes(tag_id, &[v as u8]);\n     }\n \n-    fn wr_tagged_str(tag_id: uint, v: str) {\n+    fn wr_tagged_str(tag_id: uint, v: ~str) {\n         // Lame: can't use str::as_bytes() here because the resulting\n         // vector is NULL-terminated.  Annoyingly, the underlying\n         // writer interface doesn't permit us to write a slice of a\n@@ -286,7 +286,7 @@ impl writer for writer {\n         self.writer.write(b);\n     }\n \n-    fn wr_str(s: str) {\n+    fn wr_str(s: ~str) {\n         #debug[\"Write str: %?\", s];\n         self.writer.write(str::bytes(s));\n     }\n@@ -320,7 +320,7 @@ impl serializer of serialization::serializer for ebml::writer {\n         self.wr_tagged_u32(t as uint, v as u32);\n     }\n \n-    fn _emit_label(label: str) {\n+    fn _emit_label(label: ~str) {\n         // There are various strings that we have access to, such as\n         // the name of a record field, which do not actually appear in\n         // the serialized EBML (normally).  This is just for\n@@ -345,17 +345,17 @@ impl serializer of serialization::serializer for ebml::writer {\n     fn emit_bool(v: bool) { self.wr_tagged_u8(es_bool as uint, v as u8) }\n \n     // FIXME (#2742): implement these\n-    fn emit_f64(_v: f64) { fail \"Unimplemented: serializing an f64\"; }\n-    fn emit_f32(_v: f32) { fail \"Unimplemented: serializing an f32\"; }\n-    fn emit_float(_v: float) { fail \"Unimplemented: serializing a float\"; }\n+    fn emit_f64(_v: f64) { fail ~\"Unimplemented: serializing an f64\"; }\n+    fn emit_f32(_v: f32) { fail ~\"Unimplemented: serializing an f32\"; }\n+    fn emit_float(_v: float) { fail ~\"Unimplemented: serializing a float\"; }\n \n-    fn emit_str(v: str) { self.wr_tagged_str(es_str as uint, v) }\n+    fn emit_str(v: ~str) { self.wr_tagged_str(es_str as uint, v) }\n \n-    fn emit_enum(name: str, f: fn()) {\n+    fn emit_enum(name: ~str, f: fn()) {\n         self._emit_label(name);\n         self.wr_tag(es_enum as uint, f)\n     }\n-    fn emit_enum_variant(_v_name: str, v_id: uint, _cnt: uint, f: fn()) {\n+    fn emit_enum_variant(_v_name: ~str, v_id: uint, _cnt: uint, f: fn()) {\n         self._emit_tagged_uint(es_enum_vid, v_id);\n         self.wr_tag(es_enum_body as uint, f)\n     }\n@@ -375,7 +375,7 @@ impl serializer of serialization::serializer for ebml::writer {\n     fn emit_box(f: fn()) { f() }\n     fn emit_uniq(f: fn()) { f() }\n     fn emit_rec(f: fn()) { f() }\n-    fn emit_rec_field(f_name: str, _f_idx: uint, f: fn()) {\n+    fn emit_rec_field(f_name: ~str, _f_idx: uint, f: fn()) {\n         self._emit_label(f_name);\n         f()\n     }\n@@ -391,7 +391,7 @@ fn ebml_deserializer(d: ebml::doc) -> ebml_deserializer {\n }\n \n impl deserializer of serialization::deserializer for ebml_deserializer {\n-    fn _check_label(lbl: str) {\n+    fn _check_label(lbl: ~str) {\n         if self.pos < self.parent.end {\n             let {tag: r_tag, doc: r_doc} =\n                 ebml::doc_at(self.parent.data, self.pos);\n@@ -408,7 +408,7 @@ impl deserializer of serialization::deserializer for ebml_deserializer {\n     fn next_doc(exp_tag: ebml_serializer_tag) -> ebml::doc {\n         #debug[\". next_doc(exp_tag=%?)\", exp_tag];\n         if self.pos >= self.parent.end {\n-            fail \"no more documents in current node!\";\n+            fail ~\"no more documents in current node!\";\n         }\n         let {tag: r_tag, doc: r_doc} =\n             ebml::doc_at(self.parent.data, self.pos);\n@@ -472,14 +472,14 @@ impl deserializer of serialization::deserializer for ebml_deserializer {\n \n     fn read_bool() -> bool { ebml::doc_as_u8(self.next_doc(es_bool)) as bool }\n \n-    fn read_f64() -> f64 { fail \"read_f64()\"; }\n-    fn read_f32() -> f32 { fail \"read_f32()\"; }\n-    fn read_float() -> float { fail \"read_float()\"; }\n+    fn read_f64() -> f64 { fail ~\"read_f64()\"; }\n+    fn read_f32() -> f32 { fail ~\"read_f32()\"; }\n+    fn read_float() -> float { fail ~\"read_float()\"; }\n \n-    fn read_str() -> str { ebml::doc_as_str(self.next_doc(es_str)) }\n+    fn read_str() -> ~str { ebml::doc_as_str(self.next_doc(es_str)) }\n \n     // Compound types:\n-    fn read_enum<T:copy>(name: str, f: fn() -> T) -> T {\n+    fn read_enum<T:copy>(name: ~str, f: fn() -> T) -> T {\n         #debug[\"read_enum(%s)\", name];\n         self._check_label(name);\n         self.push_doc(self.next_doc(es_enum), f)\n@@ -528,7 +528,7 @@ impl deserializer of serialization::deserializer for ebml_deserializer {\n         f()\n     }\n \n-    fn read_rec_field<T:copy>(f_name: str, f_idx: uint, f: fn() -> T) -> T {\n+    fn read_rec_field<T:copy>(f_name: ~str, f_idx: uint, f: fn() -> T) -> T {\n         #debug[\"read_rec_field(%s, idx=%u)\", f_name, f_idx];\n         self._check_label(f_name);\n         f()\n@@ -556,13 +556,13 @@ fn test_option_int() {\n     }\n \n     fn serialize_0<S: serialization::serializer>(s: S, v: option<int>) {\n-        do s.emit_enum(\"core::option::t\") {\n+        do s.emit_enum(~\"core::option::t\") {\n             alt v {\n               none {\n-                s.emit_enum_variant(\"core::option::none\", 0u, 0u, || { } );\n+                s.emit_enum_variant(~\"core::option::none\", 0u, 0u, || { } );\n               }\n               some(v0) {\n-                do s.emit_enum_variant(\"core::option::some\", 1u, 1u) {\n+                do s.emit_enum_variant(~\"core::option::some\", 1u, 1u) {\n                     s.emit_enum_variant_arg(0u, || serialize_1(s, v0));\n                 }\n               }\n@@ -575,7 +575,7 @@ fn test_option_int() {\n     }\n \n     fn deserialize_0<S: serialization::deserializer>(s: S) -> option<int> {\n-        do s.read_enum(\"core::option::t\") {\n+        do s.read_enum(~\"core::option::t\") {\n             do s.read_enum_variant |i| {\n                 alt check i {\n                   0u { none }"}, {"sha": "8ba2dc16b76c00f81b6e4b1c495bac3fd8abd77e", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 177, "deletions": 174, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -84,7 +84,7 @@ export opt_maybe_str;\n export opt_default;\n export result; //NDM\n \n-enum name { long(str), short(char), }\n+enum name { long(~str), short(char), }\n \n enum hasarg { yes, no, maybe, }\n \n@@ -93,53 +93,53 @@ enum occur { req, optional, multi, }\n /// A description of a possible option\n type opt = {name: name, hasarg: hasarg, occur: occur};\n \n-fn mkname(nm: str) -> name {\n+fn mkname(nm: ~str) -> name {\n     ret if str::len(nm) == 1u {\n             short(str::char_at(nm, 0u))\n         } else { long(nm) };\n }\n \n /// Create an option that is required and takes an argument\n-fn reqopt(name: str) -> opt {\n+fn reqopt(name: ~str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: req};\n }\n \n /// Create an option that is optional and takes an argument\n-fn optopt(name: str) -> opt {\n+fn optopt(name: ~str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: optional};\n }\n \n /// Create an option that is optional and does not take an argument\n-fn optflag(name: str) -> opt {\n+fn optflag(name: ~str) -> opt {\n     ret {name: mkname(name), hasarg: no, occur: optional};\n }\n \n /// Create an option that is optional and takes an optional argument\n-fn optflagopt(name: str) -> opt {\n+fn optflagopt(name: ~str) -> opt {\n     ret {name: mkname(name), hasarg: maybe, occur: optional};\n }\n \n /**\n  * Create an option that is optional, takes an argument, and may occur\n  * multiple times\n  */\n-fn optmulti(name: str) -> opt {\n+fn optmulti(name: ~str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: multi};\n }\n \n-enum optval { val(str), given, }\n+enum optval { val(~str), given, }\n \n /**\n  * The result of checking command line arguments. Contains a vector\n  * of matches and a vector of free strings.\n  */\n-type match = {opts: ~[opt], vals: ~[~[optval]], free: ~[str]};\n+type match = {opts: ~[opt], vals: ~[~[optval]], free: ~[~str]};\n \n-fn is_arg(arg: str) -> bool {\n+fn is_arg(arg: ~str) -> bool {\n     ret str::len(arg) > 1u && arg[0] == '-' as u8;\n }\n \n-fn name_str(nm: name) -> str {\n+fn name_str(nm: name) -> ~str {\n     ret alt nm { short(ch) { str::from_char(ch) } long(s) { s } };\n }\n \n@@ -152,24 +152,26 @@ fn find_opt(opts: ~[opt], nm: name) -> option<uint> {\n  * expected format. Pass this value to <fail_str> to get an error message.\n  */\n enum fail_ {\n-    argument_missing(str),\n-    unrecognized_option(str),\n-    option_missing(str),\n-    option_duplicated(str),\n-    unexpected_argument(str),\n+    argument_missing(~str),\n+    unrecognized_option(~str),\n+    option_missing(~str),\n+    option_duplicated(~str),\n+    unexpected_argument(~str),\n }\n \n /// Convert a `fail_` enum into an error string\n-fn fail_str(f: fail_) -> str {\n+fn fail_str(f: fail_) -> ~str {\n     ret alt f {\n-          argument_missing(nm) { \"Argument to option '\" + nm + \"' missing.\" }\n-          unrecognized_option(nm) { \"Unrecognized option: '\" + nm + \"'.\" }\n-          option_missing(nm) { \"Required option '\" + nm + \"' missing.\" }\n+          argument_missing(nm) {\n+            ~\"Argument to option '\" + nm + ~\"' missing.\"\n+          }\n+          unrecognized_option(nm) { ~\"Unrecognized option: '\" + nm + ~\"'.\" }\n+          option_missing(nm) { ~\"Required option '\" + nm + ~\"' missing.\" }\n           option_duplicated(nm) {\n-            \"Option '\" + nm + \"' given more than once.\"\n+            ~\"Option '\" + nm + ~\"' given more than once.\"\n           }\n           unexpected_argument(nm) {\n-            \"Option \" + nm + \" does not take an argument.\"\n+            ~\"Option \" + nm + ~\" does not take an argument.\"\n           }\n         };\n }\n@@ -187,25 +189,25 @@ type result = result::result<match, fail_>;\n  * `opt_str`, etc. to interrogate results.  Returns `err(fail_)` on failure.\n  * Use <fail_str> to get an error message.\n  */\n-fn getopts(args: ~[str], opts: ~[opt]) -> result unsafe {\n+fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n     let n_opts = vec::len::<opt>(opts);\n     fn f(_x: uint) -> ~[optval] { ret ~[]; }\n     let vals = vec::to_mut(vec::from_fn(n_opts, f));\n-    let mut free: ~[str] = ~[];\n+    let mut free: ~[~str] = ~[];\n     let l = vec::len(args);\n     let mut i = 0u;\n     while i < l {\n         let cur = args[i];\n         let curlen = str::len(cur);\n         if !is_arg(cur) {\n             vec::push(free, cur);\n-        } else if str::eq(cur, \"--\") {\n+        } else if str::eq(cur, ~\"--\") {\n             let mut j = i + 1u;\n             while j < l { vec::push(free, args[j]); j += 1u; }\n             break;\n         } else {\n             let mut names;\n-            let mut i_arg = option::none::<str>;\n+            let mut i_arg = option::none::<~str>;\n             if cur[1] == '-' as u8 {\n                 let tail = str::slice(cur, 2u, curlen);\n                 let tail_eq = str::splitn_char(tail, '=', 1u);\n@@ -215,7 +217,7 @@ fn getopts(args: ~[str], opts: ~[opt]) -> result unsafe {\n                     names =\n                         ~[long(tail_eq[0])];\n                     i_arg =\n-                        option::some::<str>(tail_eq[1]);\n+                        option::some::<~str>(tail_eq[1]);\n                 }\n             } else {\n                 let mut j = 1u;\n@@ -264,23 +266,23 @@ fn getopts(args: ~[str], opts: ~[opt]) -> result unsafe {\n                 };\n                 alt opts[optid].hasarg {\n                   no {\n-                    if !option::is_none::<str>(i_arg) {\n+                    if !option::is_none::<~str>(i_arg) {\n                         ret err(unexpected_argument(name_str(nm)));\n                     }\n                     vec::push(vals[optid], given);\n                   }\n                   maybe {\n-                    if !option::is_none::<str>(i_arg) {\n+                    if !option::is_none::<~str>(i_arg) {\n                         vec::push(vals[optid], val(option::get(i_arg)));\n                     } else if name_pos < vec::len::<name>(names) ||\n                                   i + 1u == l || is_arg(args[i + 1u]) {\n                         vec::push(vals[optid], given);\n                     } else { i += 1u; vec::push(vals[optid], val(args[i])); }\n                   }\n                   yes {\n-                    if !option::is_none::<str>(i_arg) {\n+                    if !option::is_none::<~str>(i_arg) {\n                         vec::push(vals[optid],\n-                                  val(option::get::<str>(i_arg)));\n+                                  val(option::get::<~str>(i_arg)));\n                     } else if i + 1u == l {\n                         ret err(argument_missing(name_str(nm)));\n                     } else { i += 1u; vec::push(vals[optid], val(args[i])); }\n@@ -309,22 +311,22 @@ fn getopts(args: ~[str], opts: ~[opt]) -> result unsafe {\n     ret ok({opts: opts, vals: vec::from_mut(vals), free: free});\n }\n \n-fn opt_vals(m: match, nm: str) -> ~[optval] {\n+fn opt_vals(m: match, nm: ~str) -> ~[optval] {\n     ret alt find_opt(m.opts, mkname(nm)) {\n           some(id) { m.vals[id] }\n           none { #error(\"No option '%s' defined\", nm); fail }\n         };\n }\n \n-fn opt_val(m: match, nm: str) -> optval { ret opt_vals(m, nm)[0]; }\n+fn opt_val(m: match, nm: ~str) -> optval { ret opt_vals(m, nm)[0]; }\n \n /// Returns true if an option was matched\n-fn opt_present(m: match, nm: str) -> bool {\n+fn opt_present(m: match, nm: ~str) -> bool {\n     ret vec::len::<optval>(opt_vals(m, nm)) > 0u;\n }\n \n /// Returns true if any of several options were matched\n-fn opts_present(m: match, names: ~[str]) -> bool {\n+fn opts_present(m: match, names: ~[~str]) -> bool {\n     for vec::each(names) |nm| {\n         alt find_opt(m.opts, mkname(nm)) {\n           some(_) { ret true; }\n@@ -341,7 +343,7 @@ fn opts_present(m: match, names: ~[str]) -> bool {\n  * Fails if the option was not matched or if the match did not take an\n  * argument\n  */\n-fn opt_str(m: match, nm: str) -> str {\n+fn opt_str(m: match, nm: ~str) -> ~str {\n     ret alt opt_val(m, nm) { val(s) { s } _ { fail } };\n }\n \n@@ -351,7 +353,7 @@ fn opt_str(m: match, nm: str) -> str {\n  * Fails if the no option was provided from the given list, or if the no such\n  * option took an argument\n  */\n-fn opts_str(m: match, names: ~[str]) -> str {\n+fn opts_str(m: match, names: ~[~str]) -> ~str {\n     for vec::each(names) |nm| {\n         alt opt_val(m, nm) {\n           val(s) { ret s }\n@@ -368,19 +370,19 @@ fn opts_str(m: match, names: ~[str]) -> str {\n  *\n  * Used when an option accepts multiple values.\n  */\n-fn opt_strs(m: match, nm: str) -> ~[str] {\n-    let mut acc: ~[str] = ~[];\n+fn opt_strs(m: match, nm: ~str) -> ~[~str] {\n+    let mut acc: ~[~str] = ~[];\n     for vec::each(opt_vals(m, nm)) |v| {\n         alt v { val(s) { vec::push(acc, s); } _ { } }\n     }\n     ret acc;\n }\n \n /// Returns the string argument supplied to a matching option or none\n-fn opt_maybe_str(m: match, nm: str) -> option<str> {\n+fn opt_maybe_str(m: match, nm: ~str) -> option<~str> {\n     let vals = opt_vals(m, nm);\n-    if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n-    ret alt vals[0] { val(s) { some::<str>(s) } _ { none::<str> } };\n+    if vec::len::<optval>(vals) == 0u { ret none::<~str>; }\n+    ret alt vals[0] { val(s) { some::<~str>(s) } _ { none::<~str> } };\n }\n \n \n@@ -391,10 +393,10 @@ fn opt_maybe_str(m: match, nm: str) -> option<str> {\n  * present but no argument was provided, and the argument if the option was\n  * present and an argument was provided.\n  */\n-fn opt_default(m: match, nm: str, def: str) -> option<str> {\n+fn opt_default(m: match, nm: ~str, def: ~str) -> option<~str> {\n     let vals = opt_vals(m, nm);\n-    if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n-    ret alt vals[0] { val(s) { some::<str>(s) } _ { some::<str>(def) } }\n+    if vec::len::<optval>(vals) == 0u { ret none::<~str>; }\n+    ret alt vals[0] { val(s) { some::<~str>(s) } _ { some::<~str>(def) } }\n }\n \n #[cfg(test)]\n@@ -424,21 +426,21 @@ mod tests {\n     // Tests for reqopt\n     #[test]\n     fn test_reqopt_long() {\n-        let args = ~[\"--test=20\"];\n-        let opts = ~[reqopt(\"test\")];\n+        let args = ~[~\"--test=20\"];\n+        let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt check rs {\n           ok(m) {\n-            assert (opt_present(m, \"test\"));\n-            assert (opt_str(m, \"test\") == \"20\");\n+            assert (opt_present(m, ~\"test\"));\n+            assert (opt_str(m, ~\"test\") == ~\"20\");\n           }\n         }\n     }\n \n     #[test]\n     fn test_reqopt_long_missing() {\n-        let args = ~[\"blah\"];\n-        let opts = ~[reqopt(\"test\")];\n+        let args = ~[~\"blah\"];\n+        let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_missing_); }\n@@ -448,8 +450,8 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_long_no_arg() {\n-        let args = ~[\"--test\"];\n-        let opts = ~[reqopt(\"test\")];\n+        let args = ~[~\"--test\"];\n+        let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, argument_missing_); }\n@@ -459,8 +461,8 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_long_multi() {\n-        let args = ~[\"--test=20\", \"--test=30\"];\n-        let opts = ~[reqopt(\"test\")];\n+        let args = ~[~\"--test=20\", ~\"--test=30\"];\n+        let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_duplicated_); }\n@@ -470,22 +472,22 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_short() {\n-        let args = ~[\"-t\", \"20\"];\n-        let opts = ~[reqopt(\"t\")];\n+        let args = ~[~\"-t\", ~\"20\"];\n+        let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n-            assert (opt_present(m, \"t\"));\n-            assert (opt_str(m, \"t\") == \"20\");\n+            assert (opt_present(m, ~\"t\"));\n+            assert (opt_str(m, ~\"t\") == ~\"20\");\n           }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_reqopt_short_missing() {\n-        let args = ~[\"blah\"];\n-        let opts = ~[reqopt(\"t\")];\n+        let args = ~[~\"blah\"];\n+        let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_missing_); }\n@@ -495,8 +497,8 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_short_no_arg() {\n-        let args = ~[\"-t\"];\n-        let opts = ~[reqopt(\"t\")];\n+        let args = ~[~\"-t\"];\n+        let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, argument_missing_); }\n@@ -506,8 +508,8 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_short_multi() {\n-        let args = ~[\"-t\", \"20\", \"-t\", \"30\"];\n-        let opts = ~[reqopt(\"t\")];\n+        let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n+        let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_duplicated_); }\n@@ -519,33 +521,33 @@ mod tests {\n     // Tests for optopt\n     #[test]\n     fn test_optopt_long() {\n-        let args = ~[\"--test=20\"];\n-        let opts = ~[optopt(\"test\")];\n+        let args = ~[~\"--test=20\"];\n+        let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n-            assert (opt_present(m, \"test\"));\n-            assert (opt_str(m, \"test\") == \"20\");\n+            assert (opt_present(m, ~\"test\"));\n+            assert (opt_str(m, ~\"test\") == ~\"20\");\n           }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_optopt_long_missing() {\n-        let args = ~[\"blah\"];\n-        let opts = ~[optopt(\"test\")];\n+        let args = ~[~\"blah\"];\n+        let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (!opt_present(m, \"test\")); }\n+          ok(m) { assert (!opt_present(m, ~\"test\")); }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_optopt_long_no_arg() {\n-        let args = ~[\"--test\"];\n-        let opts = ~[optopt(\"test\")];\n+        let args = ~[~\"--test\"];\n+        let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, argument_missing_); }\n@@ -555,8 +557,8 @@ mod tests {\n \n     #[test]\n     fn test_optopt_long_multi() {\n-        let args = ~[\"--test=20\", \"--test=30\"];\n-        let opts = ~[optopt(\"test\")];\n+        let args = ~[~\"--test=20\", ~\"--test=30\"];\n+        let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_duplicated_); }\n@@ -566,33 +568,33 @@ mod tests {\n \n     #[test]\n     fn test_optopt_short() {\n-        let args = ~[\"-t\", \"20\"];\n-        let opts = ~[optopt(\"t\")];\n+        let args = ~[~\"-t\", ~\"20\"];\n+        let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n-            assert (opt_present(m, \"t\"));\n-            assert (opt_str(m, \"t\") == \"20\");\n+            assert (opt_present(m, ~\"t\"));\n+            assert (opt_str(m, ~\"t\") == ~\"20\");\n           }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_optopt_short_missing() {\n-        let args = ~[\"blah\"];\n-        let opts = ~[optopt(\"t\")];\n+        let args = ~[~\"blah\"];\n+        let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (!opt_present(m, \"t\")); }\n+          ok(m) { assert (!opt_present(m, ~\"t\")); }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_optopt_short_no_arg() {\n-        let args = ~[\"-t\"];\n-        let opts = ~[optopt(\"t\")];\n+        let args = ~[~\"-t\"];\n+        let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, argument_missing_); }\n@@ -602,8 +604,8 @@ mod tests {\n \n     #[test]\n     fn test_optopt_short_multi() {\n-        let args = ~[\"-t\", \"20\", \"-t\", \"30\"];\n-        let opts = ~[optopt(\"t\")];\n+        let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n+        let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_duplicated_); }\n@@ -615,30 +617,30 @@ mod tests {\n     // Tests for optflag\n     #[test]\n     fn test_optflag_long() {\n-        let args = ~[\"--test\"];\n-        let opts = ~[optflag(\"test\")];\n+        let args = ~[~\"--test\"];\n+        let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (opt_present(m, \"test\")); }\n+          ok(m) { assert (opt_present(m, ~\"test\")); }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_optflag_long_missing() {\n-        let args = ~[\"blah\"];\n-        let opts = ~[optflag(\"test\")];\n+        let args = ~[~\"blah\"];\n+        let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (!opt_present(m, \"test\")); }\n+          ok(m) { assert (!opt_present(m, ~\"test\")); }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_optflag_long_arg() {\n-        let args = ~[\"--test=20\"];\n-        let opts = ~[optflag(\"test\")];\n+        let args = ~[~\"--test=20\"];\n+        let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) {\n@@ -651,8 +653,8 @@ mod tests {\n \n     #[test]\n     fn test_optflag_long_multi() {\n-        let args = ~[\"--test\", \"--test\"];\n-        let opts = ~[optflag(\"test\")];\n+        let args = ~[~\"--test\", ~\"--test\"];\n+        let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_duplicated_); }\n@@ -662,45 +664,45 @@ mod tests {\n \n     #[test]\n     fn test_optflag_short() {\n-        let args = ~[\"-t\"];\n-        let opts = ~[optflag(\"t\")];\n+        let args = ~[~\"-t\"];\n+        let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (opt_present(m, \"t\")); }\n+          ok(m) { assert (opt_present(m, ~\"t\")); }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_optflag_short_missing() {\n-        let args = ~[\"blah\"];\n-        let opts = ~[optflag(\"t\")];\n+        let args = ~[~\"blah\"];\n+        let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (!opt_present(m, \"t\")); }\n+          ok(m) { assert (!opt_present(m, ~\"t\")); }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_optflag_short_arg() {\n-        let args = ~[\"-t\", \"20\"];\n-        let opts = ~[optflag(\"t\")];\n+        let args = ~[~\"-t\", ~\"20\"];\n+        let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n             // The next variable after the flag is just a free argument\n \n-            assert (m.free[0] == \"20\");\n+            assert (m.free[0] == ~\"20\");\n           }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_optflag_short_multi() {\n-        let args = ~[\"-t\", \"-t\"];\n-        let opts = ~[optflag(\"t\")];\n+        let args = ~[~\"-t\", ~\"-t\"];\n+        let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, option_duplicated_); }\n@@ -712,33 +714,33 @@ mod tests {\n     // Tests for optmulti\n     #[test]\n     fn test_optmulti_long() {\n-        let args = ~[\"--test=20\"];\n-        let opts = ~[optmulti(\"test\")];\n+        let args = ~[~\"--test=20\"];\n+        let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n-            assert (opt_present(m, \"test\"));\n-            assert (opt_str(m, \"test\") == \"20\");\n+            assert (opt_present(m, ~\"test\"));\n+            assert (opt_str(m, ~\"test\") == ~\"20\");\n           }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_optmulti_long_missing() {\n-        let args = ~[\"blah\"];\n-        let opts = ~[optmulti(\"test\")];\n+        let args = ~[~\"blah\"];\n+        let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (!opt_present(m, \"test\")); }\n+          ok(m) { assert (!opt_present(m, ~\"test\")); }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_optmulti_long_no_arg() {\n-        let args = ~[\"--test\"];\n-        let opts = ~[optmulti(\"test\")];\n+        let args = ~[~\"--test\"];\n+        let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, argument_missing_); }\n@@ -748,49 +750,49 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_long_multi() {\n-        let args = ~[\"--test=20\", \"--test=30\"];\n-        let opts = ~[optmulti(\"test\")];\n+        let args = ~[~\"--test=20\", ~\"--test=30\"];\n+        let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n-            assert (opt_present(m, \"test\"));\n-            assert (opt_str(m, \"test\") == \"20\");\n-            assert (opt_strs(m, \"test\")[0] == \"20\");\n-            assert (opt_strs(m, \"test\")[1] == \"30\");\n+            assert (opt_present(m, ~\"test\"));\n+            assert (opt_str(m, ~\"test\") == ~\"20\");\n+            assert (opt_strs(m, ~\"test\")[0] == ~\"20\");\n+            assert (opt_strs(m, ~\"test\")[1] == ~\"30\");\n           }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_optmulti_short() {\n-        let args = ~[\"-t\", \"20\"];\n-        let opts = ~[optmulti(\"t\")];\n+        let args = ~[~\"-t\", ~\"20\"];\n+        let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n-            assert (opt_present(m, \"t\"));\n-            assert (opt_str(m, \"t\") == \"20\");\n+            assert (opt_present(m, ~\"t\"));\n+            assert (opt_str(m, ~\"t\") == ~\"20\");\n           }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_optmulti_short_missing() {\n-        let args = ~[\"blah\"];\n-        let opts = ~[optmulti(\"t\")];\n+        let args = ~[~\"blah\"];\n+        let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n-          ok(m) { assert (!opt_present(m, \"t\")); }\n+          ok(m) { assert (!opt_present(m, ~\"t\")); }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_optmulti_short_no_arg() {\n-        let args = ~[\"-t\"];\n-        let opts = ~[optmulti(\"t\")];\n+        let args = ~[~\"-t\"];\n+        let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, argument_missing_); }\n@@ -800,24 +802,24 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_short_multi() {\n-        let args = ~[\"-t\", \"20\", \"-t\", \"30\"];\n-        let opts = ~[optmulti(\"t\")];\n+        let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n+        let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n-            assert (opt_present(m, \"t\"));\n-            assert (opt_str(m, \"t\") == \"20\");\n-            assert (opt_strs(m, \"t\")[0] == \"20\");\n-            assert (opt_strs(m, \"t\")[1] == \"30\");\n+            assert (opt_present(m, ~\"t\"));\n+            assert (opt_str(m, ~\"t\") == ~\"20\");\n+            assert (opt_strs(m, ~\"t\")[0] == ~\"20\");\n+            assert (opt_strs(m, ~\"t\")[1] == ~\"30\");\n           }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_unrecognized_option_long() {\n-        let args = ~[\"--untest\"];\n-        let opts = ~[optmulti(\"t\")];\n+        let args = ~[~\"--untest\"];\n+        let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, unrecognized_option_); }\n@@ -827,8 +829,8 @@ mod tests {\n \n     #[test]\n     fn test_unrecognized_option_short() {\n-        let args = ~[\"-t\"];\n-        let opts = ~[optmulti(\"test\")];\n+        let args = ~[~\"-t\"];\n+        let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           err(f) { check_fail_type(f, unrecognized_option_); }\n@@ -839,63 +841,64 @@ mod tests {\n     #[test]\n     fn test_combined() {\n         let args =\n-            ~[\"prog\", \"free1\", \"-s\", \"20\", \"free2\", \"--flag\", \"--long=30\",\n-             \"-f\", \"-m\", \"40\", \"-m\", \"50\", \"-n\", \"-A B\", \"-n\", \"-60 70\"];\n+            ~[~\"prog\", ~\"free1\", ~\"-s\", ~\"20\", ~\"free2\",\n+              ~\"--flag\", ~\"--long=30\", ~\"-f\", ~\"-m\", ~\"40\",\n+              ~\"-m\", ~\"50\", ~\"-n\", ~\"-A B\", ~\"-n\", ~\"-60 70\"];\n         let opts =\n-            ~[optopt(\"s\"), optflag(\"flag\"), reqopt(\"long\"),\n-             optflag(\"f\"), optmulti(\"m\"), optmulti(\"n\"),\n-             optopt(\"notpresent\")];\n+            ~[optopt(~\"s\"), optflag(~\"flag\"), reqopt(~\"long\"),\n+             optflag(~\"f\"), optmulti(~\"m\"), optmulti(~\"n\"),\n+             optopt(~\"notpresent\")];\n         let rs = getopts(args, opts);\n         alt rs {\n           ok(m) {\n-            assert (m.free[0] == \"prog\");\n-            assert (m.free[1] == \"free1\");\n-            assert (opt_str(m, \"s\") == \"20\");\n-            assert (m.free[2] == \"free2\");\n-            assert (opt_present(m, \"flag\"));\n-            assert (opt_str(m, \"long\") == \"30\");\n-            assert (opt_present(m, \"f\"));\n-            assert (opt_strs(m, \"m\")[0] == \"40\");\n-            assert (opt_strs(m, \"m\")[1] == \"50\");\n-            assert (opt_strs(m, \"n\")[0] == \"-A B\");\n-            assert (opt_strs(m, \"n\")[1] == \"-60 70\");\n-            assert (!opt_present(m, \"notpresent\"));\n+            assert (m.free[0] == ~\"prog\");\n+            assert (m.free[1] == ~\"free1\");\n+            assert (opt_str(m, ~\"s\") == ~\"20\");\n+            assert (m.free[2] == ~\"free2\");\n+            assert (opt_present(m, ~\"flag\"));\n+            assert (opt_str(m, ~\"long\") == ~\"30\");\n+            assert (opt_present(m, ~\"f\"));\n+            assert (opt_strs(m, ~\"m\")[0] == ~\"40\");\n+            assert (opt_strs(m, ~\"m\")[1] == ~\"50\");\n+            assert (opt_strs(m, ~\"n\")[0] == ~\"-A B\");\n+            assert (opt_strs(m, ~\"n\")[1] == ~\"-60 70\");\n+            assert (!opt_present(m, ~\"notpresent\"));\n           }\n           _ { fail; }\n         }\n     }\n \n     #[test]\n     fn test_multi() {\n-        let args = ~[\"-e\", \"foo\", \"--encrypt\", \"foo\"];\n-        let opts = ~[optopt(\"e\"), optopt(\"encrypt\")];\n+        let args = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n+        let opts = ~[optopt(~\"e\"), optopt(~\"encrypt\")];\n         let match = alt getopts(args, opts) {\n           result::ok(m) { m }\n           result::err(f) { fail; }\n         };\n-        assert opts_present(match, ~[\"e\"]);\n-        assert opts_present(match, ~[\"encrypt\"]);\n-        assert opts_present(match, ~[\"encrypt\", \"e\"]);\n-        assert opts_present(match, ~[\"e\", \"encrypt\"]);\n-        assert !opts_present(match, ~[\"thing\"]);\n+        assert opts_present(match, ~[~\"e\"]);\n+        assert opts_present(match, ~[~\"encrypt\"]);\n+        assert opts_present(match, ~[~\"encrypt\", ~\"e\"]);\n+        assert opts_present(match, ~[~\"e\", ~\"encrypt\"]);\n+        assert !opts_present(match, ~[~\"thing\"]);\n         assert !opts_present(match, ~[]);\n \n-        assert opts_str(match, ~[\"e\"]) == \"foo\";\n-        assert opts_str(match, ~[\"encrypt\"]) == \"foo\";\n-        assert opts_str(match, ~[\"e\", \"encrypt\"]) == \"foo\";\n-        assert opts_str(match, ~[\"encrypt\", \"e\"]) == \"foo\";\n+        assert opts_str(match, ~[~\"e\"]) == ~\"foo\";\n+        assert opts_str(match, ~[~\"encrypt\"]) == ~\"foo\";\n+        assert opts_str(match, ~[~\"e\", ~\"encrypt\"]) == ~\"foo\";\n+        assert opts_str(match, ~[~\"encrypt\", ~\"e\"]) == ~\"foo\";\n     }\n \n     #[test]\n     fn test_nospace() {\n-        let args = ~[\"-Lfoo\"];\n-        let opts = ~[optmulti(\"L\")];\n+        let args = ~[~\"-Lfoo\"];\n+        let opts = ~[optmulti(~\"L\")];\n         let match = alt getopts(args, opts) {\n           result::ok(m) { m }\n           result::err(f) { fail; }\n         };\n-        assert opts_present(match, ~[\"L\"]);\n-        assert opts_str(match, ~[\"L\"]) == \"foo\";\n+        assert opts_present(match, ~[~\"L\"]);\n+        assert opts_str(match, ~[~\"L\"]) == ~\"foo\";\n     }\n }\n "}, {"sha": "f819420462652e47da55c4cdede3b66d01879653", "filename": "src/libstd/json.rs", "status": "modified", "additions": 217, "deletions": 216, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -29,17 +29,17 @@ export null;\n /// Represents a json value\n enum json {\n     num(float),\n-    string(@str/~),\n+    string(@~str),\n     boolean(bool),\n     list(@~[json]),\n-    dict(map::hashmap<str, json>),\n+    dict(map::hashmap<~str, json>),\n     null,\n }\n \n type error = {\n     line: uint,\n     col: uint,\n-    msg: @str/~,\n+    msg: @~str,\n };\n \n /// Serializes a json value into a io::writer\n@@ -50,14 +50,14 @@ fn to_writer(wr: io::writer, j: json) {\n         wr.write_str(escape_str(*s));\n       }\n       boolean(b) {\n-        wr.write_str(if b { \"true\" } else { \"false\" });\n+        wr.write_str(if b { ~\"true\" } else { ~\"false\" });\n       }\n       list(v) {\n         wr.write_char('[');\n         let mut first = true;\n         for (*v).each |item| {\n             if !first {\n-                wr.write_str(\", \");\n+                wr.write_str(~\", \");\n             }\n             first = false;\n             to_writer(wr, item);\n@@ -66,51 +66,51 @@ fn to_writer(wr: io::writer, j: json) {\n       }\n       dict(d) {\n         if d.size() == 0u {\n-            wr.write_str(\"{}\");\n+            wr.write_str(~\"{}\");\n             ret;\n         }\n \n-        wr.write_str(\"{ \");\n+        wr.write_str(~\"{ \");\n         let mut first = true;\n         for d.each |key, value| {\n             if !first {\n-                wr.write_str(\", \");\n+                wr.write_str(~\", \");\n             }\n             first = false;\n             wr.write_str(escape_str(key));\n-            wr.write_str(\": \");\n+            wr.write_str(~\": \");\n             to_writer(wr, value);\n         };\n-        wr.write_str(\" }\");\n+        wr.write_str(~\" }\");\n       }\n       null {\n-        wr.write_str(\"null\");\n+        wr.write_str(~\"null\");\n       }\n     }\n }\n \n-fn escape_str(s: str) -> str {\n-    let mut escaped = \"\\\"\";\n+fn escape_str(s: ~str) -> ~str {\n+    let mut escaped = ~\"\\\"\";\n     do str::chars_iter(s) |c| {\n         alt c {\n-          '\"' { escaped += \"\\\\\\\"\"; }\n-          '\\\\' { escaped += \"\\\\\\\\\"; }\n-          '\\x08' { escaped += \"\\\\b\"; }\n-          '\\x0c' { escaped += \"\\\\f\"; }\n-          '\\n' { escaped += \"\\\\n\"; }\n-          '\\r' { escaped += \"\\\\r\"; }\n-          '\\t' { escaped += \"\\\\t\"; }\n+          '\"' { escaped += ~\"\\\\\\\"\"; }\n+          '\\\\' { escaped += ~\"\\\\\\\\\"; }\n+          '\\x08' { escaped += ~\"\\\\b\"; }\n+          '\\x0c' { escaped += ~\"\\\\f\"; }\n+          '\\n' { escaped += ~\"\\\\n\"; }\n+          '\\r' { escaped += ~\"\\\\r\"; }\n+          '\\t' { escaped += ~\"\\\\t\"; }\n           _ { escaped += str::from_char(c); }\n         }\n     };\n \n-    escaped += \"\\\"\";\n+    escaped += ~\"\\\"\";\n \n     escaped\n }\n \n /// Serializes a json value into a string\n-fn to_str(j: json) -> str {\n+fn to_str(j: json) -> ~str {\n     io::with_str_writer(|wr| to_writer(wr, j))\n }\n \n@@ -140,7 +140,7 @@ impl parser for parser {\n         self.ch\n     }\n \n-    fn error<T>(+msg: str) -> result<T, error> {\n+    fn error<T>(+msg: ~str) -> result<T, error> {\n         err({ line: self.line, col: self.col, msg: @msg })\n     }\n \n@@ -153,7 +153,7 @@ impl parser for parser {\n             if self.eof() {\n                 ok(value)\n             } else {\n-                self.error(\"trailing characters\")\n+                self.error(~\"trailing characters\")\n             }\n           }\n           e { e }\n@@ -163,12 +163,12 @@ impl parser for parser {\n     fn parse_value() -> result<json, error> {\n         self.parse_whitespace();\n \n-        if self.eof() { ret self.error(\"EOF while parsing value\"); }\n+        if self.eof() { ret self.error(~\"EOF while parsing value\"); }\n \n         alt self.ch {\n-          'n' { self.parse_ident(\"ull\", null) }\n-          't' { self.parse_ident(\"rue\", boolean(true)) }\n-          'f' { self.parse_ident(\"alse\", boolean(false)) }\n+          'n' { self.parse_ident(~\"ull\", null) }\n+          't' { self.parse_ident(~\"rue\", boolean(true)) }\n+          'f' { self.parse_ident(~\"alse\", boolean(false)) }\n           '0' to '9' | '-' { self.parse_number() }\n           '\"' {\n               alt self.parse_str() {\n@@ -178,20 +178,20 @@ impl parser for parser {\n           }\n           '[' { self.parse_list() }\n           '{' { self.parse_object() }\n-          _ { self.error(\"invalid syntax\") }\n+          _ { self.error(~\"invalid syntax\") }\n         }\n     }\n \n     fn parse_whitespace() {\n         while char::is_whitespace(self.ch) { self.bump(); }\n     }\n \n-    fn parse_ident(ident: str, value: json) -> result<json, error> {\n+    fn parse_ident(ident: ~str, value: json) -> result<json, error> {\n         if str::all(ident, |c| c == self.next_char()) {\n             self.bump();\n             ok(value)\n         } else {\n-            self.error(\"invalid syntax\")\n+            self.error(~\"invalid syntax\")\n         }\n     }\n \n@@ -234,7 +234,7 @@ impl parser for parser {\n \n             // There can be only one leading '0'.\n             alt self.ch {\n-              '0' to '9' { ret self.error(\"invalid number\"); }\n+              '0' to '9' { ret self.error(~\"invalid number\"); }\n               _ {}\n             }\n           }\n@@ -251,7 +251,7 @@ impl parser for parser {\n                 }\n             }\n           }\n-          _ { ret self.error(\"invalid number\"); }\n+          _ { ret self.error(~\"invalid number\"); }\n         }\n \n         ok(res)\n@@ -263,7 +263,7 @@ impl parser for parser {\n         // Make sure a digit follows the decimal place.\n         alt self.ch {\n           '0' to '9' {}\n-          _ { ret self.error(\"invalid number\"); }\n+          _ { ret self.error(~\"invalid number\"); }\n         }\n \n         let mut res = res;\n@@ -299,7 +299,7 @@ impl parser for parser {\n         // Make sure a digit follows the exponent place.\n         alt self.ch {\n           '0' to '9' {}\n-          _ { ret self.error(\"invalid number\"); }\n+          _ { ret self.error(~\"invalid number\"); }\n         }\n \n         while !self.eof() {\n@@ -324,9 +324,9 @@ impl parser for parser {\n         ok(res)\n     }\n \n-    fn parse_str() -> result<@str/~, error> {\n+    fn parse_str() -> result<@~str, error> {\n         let mut escape = false;\n-        let mut res = \"\";\n+        let mut res = ~\"\";\n \n         while !self.eof() {\n             self.bump();\n@@ -351,19 +351,19 @@ impl parser for parser {\n                               n = n * 10u +\n                                   (self.ch as uint) - ('0' as uint);\n                             }\n-                            _ { ret self.error(\"invalid \\\\u escape\"); }\n+                            _ { ret self.error(~\"invalid \\\\u escape\"); }\n                           }\n                           i += 1u;\n                       }\n \n                       // Error out if we didn't parse 4 digits.\n                       if i != 4u {\n-                          ret self.error(\"invalid \\\\u escape\");\n+                          ret self.error(~\"invalid \\\\u escape\");\n                       }\n \n                       str::push_char(res, n as char);\n                   }\n-                  _ { ret self.error(\"invalid escape\"); }\n+                  _ { ret self.error(~\"invalid escape\"); }\n                 }\n                 escape = false;\n             } else if self.ch == '\\\\' {\n@@ -377,7 +377,7 @@ impl parser for parser {\n             }\n         }\n \n-        self.error(\"EOF while parsing string\")\n+        self.error(~\"EOF while parsing string\")\n     }\n \n     fn parse_list() -> result<json, error> {\n@@ -399,13 +399,13 @@ impl parser for parser {\n \n             self.parse_whitespace();\n             if self.eof() {\n-                ret self.error(\"EOF while parsing list\");\n+                ret self.error(~\"EOF while parsing list\");\n             }\n \n             alt self.ch {\n               ',' { self.bump(); }\n               ']' { self.bump(); ret ok(list(@values)); }\n-              _ { ret self.error(\"expected `,` or `]`\"); }\n+              _ { ret self.error(~\"expected `,` or `]`\"); }\n             }\n         };\n     }\n@@ -425,7 +425,7 @@ impl parser for parser {\n             self.parse_whitespace();\n \n             if self.ch != '\"' {\n-                ret self.error(\"key must be a string\");\n+                ret self.error(~\"key must be a string\");\n             }\n \n             let key = alt self.parse_str() {\n@@ -437,7 +437,7 @@ impl parser for parser {\n \n             if self.ch != ':' {\n                 if self.eof() { break; }\n-                ret self.error(\"expected `:`\");\n+                ret self.error(~\"expected `:`\");\n             }\n             self.bump();\n \n@@ -452,12 +452,12 @@ impl parser for parser {\n               '}' { self.bump(); ret ok(dict(values)); }\n               _ {\n                   if self.eof() { break; }\n-                  ret self.error(\"expected `,` or `}`\");\n+                  ret self.error(~\"expected `,` or `}`\");\n               }\n             }\n         }\n \n-        ret self.error(\"EOF while parsing object\");\n+        ret self.error(~\"EOF while parsing object\");\n     }\n }\n \n@@ -474,7 +474,7 @@ fn from_reader(rdr: io::reader) -> result<json, error> {\n }\n \n /// Deserializes a json value from a string\n-fn from_str(s: str) -> result<json, error> {\n+fn from_str(s: ~str) -> result<json, error> {\n     io::with_str_reader(s, from_reader)\n }\n \n@@ -575,11 +575,11 @@ impl of to_json for bool {\n     fn to_json() -> json { boolean(self) }\n }\n \n-impl of to_json for str {\n+impl of to_json for ~str {\n     fn to_json() -> json { string(@copy self) }\n }\n \n-impl of to_json for @str/~ {\n+impl of to_json for @~str {\n     fn to_json() -> json { string(self) }\n }\n \n@@ -602,7 +602,7 @@ impl <A: to_json> of to_json for ~[A] {\n     fn to_json() -> json { list(@self.map(|elt| elt.to_json())) }\n }\n \n-impl <A: to_json copy> of to_json for hashmap<str, A> {\n+impl <A: to_json copy> of to_json for hashmap<~str, A> {\n     fn to_json() -> json {\n         let d = map::str_hash();\n         for self.each() |key, value| {\n@@ -622,18 +622,18 @@ impl <A: to_json> of to_json for option<A> {\n }\n \n impl of to_str::to_str for json {\n-    fn to_str() -> str { to_str(self) }\n+    fn to_str() -> ~str { to_str(self) }\n }\n \n impl of to_str::to_str for error {\n-    fn to_str() -> str {\n+    fn to_str() -> ~str {\n         #fmt(\"%u:%u: %s\", self.line, self.col, *self.msg)\n     }\n }\n \n #[cfg(test)]\n mod tests {\n-    fn mk_dict(items: ~[(str, json)]) -> json {\n+    fn mk_dict(items: ~[(~str, json)]) -> json {\n         let d = map::str_hash();\n \n         do vec::iter(items) |item| {\n@@ -646,237 +646,238 @@ mod tests {\n \n     #[test]\n     fn test_write_null() {\n-        assert to_str(null) == \"null\";\n+        assert to_str(null) == ~\"null\";\n     }\n \n     #[test]\n     fn test_write_num() {\n-        assert to_str(num(3f)) == \"3\";\n-        assert to_str(num(3.1f)) == \"3.1\";\n-        assert to_str(num(-1.5f)) == \"-1.5\";\n-        assert to_str(num(0.5f)) == \"0.5\";\n+        assert to_str(num(3f)) == ~\"3\";\n+        assert to_str(num(3.1f)) == ~\"3.1\";\n+        assert to_str(num(-1.5f)) == ~\"-1.5\";\n+        assert to_str(num(0.5f)) == ~\"0.5\";\n     }\n \n     #[test]\n     fn test_write_str() {\n-        assert to_str(string(@\"\")) == \"\\\"\\\"\";\n-        assert to_str(string(@\"foo\")) == \"\\\"foo\\\"\";\n+        assert to_str(string(@~\"\")) == ~\"\\\"\\\"\";\n+        assert to_str(string(@~\"foo\")) == ~\"\\\"foo\\\"\";\n     }\n \n     #[test]\n     fn test_write_bool() {\n-        assert to_str(boolean(true)) == \"true\";\n-        assert to_str(boolean(false)) == \"false\";\n+        assert to_str(boolean(true)) == ~\"true\";\n+        assert to_str(boolean(false)) == ~\"false\";\n     }\n \n     #[test]\n     fn test_write_list() {\n-        assert to_str(list(@~[])) == \"[]\";\n-        assert to_str(list(@~[boolean(true)])) == \"[true]\";\n+        assert to_str(list(@~[])) == ~\"[]\";\n+        assert to_str(list(@~[boolean(true)])) == ~\"[true]\";\n         assert to_str(list(@~[\n             boolean(false),\n             null,\n-            list(@~[string(@\"foo\\nbar\"), num(3.5f)])\n-        ])) == \"[false, null, [\\\"foo\\\\nbar\\\", 3.5]]\";\n+            list(@~[string(@~\"foo\\nbar\"), num(3.5f)])\n+        ])) == ~\"[false, null, [\\\"foo\\\\nbar\\\", 3.5]]\";\n     }\n \n     #[test]\n     fn test_write_dict() {\n-        assert to_str(mk_dict(~[])) == \"{}\";\n-        assert to_str(mk_dict(~[(\"a\", boolean(true))])) == \"{ \\\"a\\\": true }\";\n+        assert to_str(mk_dict(~[])) == ~\"{}\";\n+        assert to_str(mk_dict(~[(~\"a\", boolean(true))]))\n+            == ~\"{ \\\"a\\\": true }\";\n         assert to_str(mk_dict(~[\n-            (\"a\", boolean(true)),\n-            (\"b\", list(@~[\n-                mk_dict(~[(\"c\", string(@\"\\x0c\\r\"))]),\n-                mk_dict(~[(\"d\", string(@\"\"))])\n+            (~\"a\", boolean(true)),\n+            (~\"b\", list(@~[\n+                mk_dict(~[(~\"c\", string(@~\"\\x0c\\r\"))]),\n+                mk_dict(~[(~\"d\", string(@~\"\"))])\n             ]))\n         ])) ==\n-            \"{ \" +\n-                \"\\\"a\\\": true, \" +\n-                \"\\\"b\\\": [\" +\n-                    \"{ \\\"c\\\": \\\"\\\\f\\\\r\\\" }, \" +\n-                    \"{ \\\"d\\\": \\\"\\\" }\" +\n-                \"]\" +\n-            \" }\";\n+            ~\"{ \" +\n+                ~\"\\\"a\\\": true, \" +\n+                ~\"\\\"b\\\": [\" +\n+                    ~\"{ \\\"c\\\": \\\"\\\\f\\\\r\\\" }, \" +\n+                    ~\"{ \\\"d\\\": \\\"\\\" }\" +\n+                ~\"]\" +\n+            ~\" }\";\n     }\n \n     #[test]\n     fn test_trailing_characters() {\n-        assert from_str(\"nulla\") ==\n-            err({line: 1u, col: 5u, msg: @\"trailing characters\"});\n-        assert from_str(\"truea\") ==\n-            err({line: 1u, col: 5u, msg: @\"trailing characters\"});\n-        assert from_str(\"falsea\") ==\n-            err({line: 1u, col: 6u, msg: @\"trailing characters\"});\n-        assert from_str(\"1a\") ==\n-            err({line: 1u, col: 2u, msg: @\"trailing characters\"});\n-        assert from_str(\"[]a\") ==\n-            err({line: 1u, col: 3u, msg: @\"trailing characters\"});\n-        assert from_str(\"{}a\") ==\n-            err({line: 1u, col: 3u, msg: @\"trailing characters\"});\n+        assert from_str(~\"nulla\") ==\n+            err({line: 1u, col: 5u, msg: @~\"trailing characters\"});\n+        assert from_str(~\"truea\") ==\n+            err({line: 1u, col: 5u, msg: @~\"trailing characters\"});\n+        assert from_str(~\"falsea\") ==\n+            err({line: 1u, col: 6u, msg: @~\"trailing characters\"});\n+        assert from_str(~\"1a\") ==\n+            err({line: 1u, col: 2u, msg: @~\"trailing characters\"});\n+        assert from_str(~\"[]a\") ==\n+            err({line: 1u, col: 3u, msg: @~\"trailing characters\"});\n+        assert from_str(~\"{}a\") ==\n+            err({line: 1u, col: 3u, msg: @~\"trailing characters\"});\n     }\n \n     #[test]\n     fn test_read_identifiers() {\n-        assert from_str(\"n\") ==\n-            err({line: 1u, col: 2u, msg: @\"invalid syntax\"});\n-        assert from_str(\"nul\") ==\n-            err({line: 1u, col: 4u, msg: @\"invalid syntax\"});\n+        assert from_str(~\"n\") ==\n+            err({line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n+        assert from_str(~\"nul\") ==\n+            err({line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n \n-        assert from_str(\"t\") ==\n-            err({line: 1u, col: 2u, msg: @\"invalid syntax\"});\n-        assert from_str(\"truz\") ==\n-            err({line: 1u, col: 4u, msg: @\"invalid syntax\"});\n+        assert from_str(~\"t\") ==\n+            err({line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n+        assert from_str(~\"truz\") ==\n+            err({line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n \n-        assert from_str(\"f\") ==\n-            err({line: 1u, col: 2u, msg: @\"invalid syntax\"});\n-        assert from_str(\"faz\") ==\n-            err({line: 1u, col: 3u, msg: @\"invalid syntax\"});\n+        assert from_str(~\"f\") ==\n+            err({line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n+        assert from_str(~\"faz\") ==\n+            err({line: 1u, col: 3u, msg: @~\"invalid syntax\"});\n \n-        assert from_str(\"null\") == ok(null);\n-        assert from_str(\"true\") == ok(boolean(true));\n-        assert from_str(\"false\") == ok(boolean(false));\n-        assert from_str(\" null \") == ok(null);\n-        assert from_str(\" true \") == ok(boolean(true));\n-        assert from_str(\" false \") == ok(boolean(false));\n+        assert from_str(~\"null\") == ok(null);\n+        assert from_str(~\"true\") == ok(boolean(true));\n+        assert from_str(~\"false\") == ok(boolean(false));\n+        assert from_str(~\" null \") == ok(null);\n+        assert from_str(~\" true \") == ok(boolean(true));\n+        assert from_str(~\" false \") == ok(boolean(false));\n     }\n \n     #[test]\n     fn test_read_num() {\n-        assert from_str(\"+\") ==\n-            err({line: 1u, col: 1u, msg: @\"invalid syntax\"});\n-        assert from_str(\".\") ==\n-            err({line: 1u, col: 1u, msg: @\"invalid syntax\"});\n-\n-        assert from_str(\"-\") ==\n-            err({line: 1u, col: 2u, msg: @\"invalid number\"});\n-        assert from_str(\"00\") ==\n-            err({line: 1u, col: 2u, msg: @\"invalid number\"});\n-        assert from_str(\"1.\") ==\n-            err({line: 1u, col: 3u, msg: @\"invalid number\"});\n-        assert from_str(\"1e\") ==\n-            err({line: 1u, col: 3u, msg: @\"invalid number\"});\n-        assert from_str(\"1e+\") ==\n-            err({line: 1u, col: 4u, msg: @\"invalid number\"});\n-\n-        assert from_str(\"3\") == ok(num(3f));\n-        assert from_str(\"3.1\") == ok(num(3.1f));\n-        assert from_str(\"-1.2\") == ok(num(-1.2f));\n-        assert from_str(\"0.4\") == ok(num(0.4f));\n-        assert from_str(\"0.4e5\") == ok(num(0.4e5f));\n-        assert from_str(\"0.4e+15\") == ok(num(0.4e15f));\n-        assert from_str(\"0.4e-01\") == ok(num(0.4e-01f));\n-        assert from_str(\" 3 \") == ok(num(3f));\n+        assert from_str(~\"+\") ==\n+            err({line: 1u, col: 1u, msg: @~\"invalid syntax\"});\n+        assert from_str(~\".\") ==\n+            err({line: 1u, col: 1u, msg: @~\"invalid syntax\"});\n+\n+        assert from_str(~\"-\") ==\n+            err({line: 1u, col: 2u, msg: @~\"invalid number\"});\n+        assert from_str(~\"00\") ==\n+            err({line: 1u, col: 2u, msg: @~\"invalid number\"});\n+        assert from_str(~\"1.\") ==\n+            err({line: 1u, col: 3u, msg: @~\"invalid number\"});\n+        assert from_str(~\"1e\") ==\n+            err({line: 1u, col: 3u, msg: @~\"invalid number\"});\n+        assert from_str(~\"1e+\") ==\n+            err({line: 1u, col: 4u, msg: @~\"invalid number\"});\n+\n+        assert from_str(~\"3\") == ok(num(3f));\n+        assert from_str(~\"3.1\") == ok(num(3.1f));\n+        assert from_str(~\"-1.2\") == ok(num(-1.2f));\n+        assert from_str(~\"0.4\") == ok(num(0.4f));\n+        assert from_str(~\"0.4e5\") == ok(num(0.4e5f));\n+        assert from_str(~\"0.4e+15\") == ok(num(0.4e15f));\n+        assert from_str(~\"0.4e-01\") == ok(num(0.4e-01f));\n+        assert from_str(~\" 3 \") == ok(num(3f));\n     }\n \n     #[test]\n     fn test_read_str() {\n-        assert from_str(\"\\\"\") ==\n-            err({line: 1u, col: 2u, msg: @\"EOF while parsing string\"});\n-        assert from_str(\"\\\"lol\") ==\n-            err({line: 1u, col: 5u, msg: @\"EOF while parsing string\"});\n+        assert from_str(~\"\\\"\") ==\n+            err({line: 1u, col: 2u, msg: @~\"EOF while parsing string\"});\n+        assert from_str(~\"\\\"lol\") ==\n+            err({line: 1u, col: 5u, msg: @~\"EOF while parsing string\"});\n \n-        assert from_str(\"\\\"\\\"\") == ok(string(@\"\"));\n-        assert from_str(\"\\\"foo\\\"\") == ok(string(@\"foo\"));\n-        assert from_str(\"\\\"\\\\\\\"\\\"\") == ok(string(@\"\\\"\"));\n-        assert from_str(\"\\\"\\\\b\\\"\") == ok(string(@\"\\x08\"));\n-        assert from_str(\"\\\"\\\\n\\\"\") == ok(string(@\"\\n\"));\n-        assert from_str(\"\\\"\\\\r\\\"\") == ok(string(@\"\\r\"));\n-        assert from_str(\"\\\"\\\\t\\\"\") == ok(string(@\"\\t\"));\n-        assert from_str(\" \\\"foo\\\" \") == ok(string(@\"foo\"));\n+        assert from_str(~\"\\\"\\\"\") == ok(string(@~\"\"));\n+        assert from_str(~\"\\\"foo\\\"\") == ok(string(@~\"foo\"));\n+        assert from_str(~\"\\\"\\\\\\\"\\\"\") == ok(string(@~\"\\\"\"));\n+        assert from_str(~\"\\\"\\\\b\\\"\") == ok(string(@~\"\\x08\"));\n+        assert from_str(~\"\\\"\\\\n\\\"\") == ok(string(@~\"\\n\"));\n+        assert from_str(~\"\\\"\\\\r\\\"\") == ok(string(@~\"\\r\"));\n+        assert from_str(~\"\\\"\\\\t\\\"\") == ok(string(@~\"\\t\"));\n+        assert from_str(~\" \\\"foo\\\" \") == ok(string(@~\"foo\"));\n     }\n \n     #[test]\n     fn test_read_list() {\n-        assert from_str(\"[\") ==\n-            err({line: 1u, col: 2u, msg: @\"EOF while parsing value\"});\n-        assert from_str(\"[1\") ==\n-            err({line: 1u, col: 3u, msg: @\"EOF while parsing list\"});\n-        assert from_str(\"[1,\") ==\n-            err({line: 1u, col: 4u, msg: @\"EOF while parsing value\"});\n-        assert from_str(\"[1,]\") ==\n-            err({line: 1u, col: 4u, msg: @\"invalid syntax\"});\n-        assert from_str(\"[6 7]\") ==\n-            err({line: 1u, col: 4u, msg: @\"expected `,` or `]`\"});\n-\n-        assert from_str(\"[]\") == ok(list(@~[]));\n-        assert from_str(\"[ ]\") == ok(list(@~[]));\n-        assert from_str(\"[true]\") == ok(list(@~[boolean(true)]));\n-        assert from_str(\"[ false ]\") == ok(list(@~[boolean(false)]));\n-        assert from_str(\"[null]\") == ok(list(@~[null]));\n-        assert from_str(\"[3, 1]\") == ok(list(@~[num(3f), num(1f)]));\n-        assert from_str(\"\\n[3, 2]\\n\") == ok(list(@~[num(3f), num(2f)]));\n-        assert from_str(\"[2, [4, 1]]\") ==\n+        assert from_str(~\"[\") ==\n+            err({line: 1u, col: 2u, msg: @~\"EOF while parsing value\"});\n+        assert from_str(~\"[1\") ==\n+            err({line: 1u, col: 3u, msg: @~\"EOF while parsing list\"});\n+        assert from_str(~\"[1,\") ==\n+            err({line: 1u, col: 4u, msg: @~\"EOF while parsing value\"});\n+        assert from_str(~\"[1,]\") ==\n+            err({line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n+        assert from_str(~\"[6 7]\") ==\n+            err({line: 1u, col: 4u, msg: @~\"expected `,` or `]`\"});\n+\n+        assert from_str(~\"[]\") == ok(list(@~[]));\n+        assert from_str(~\"[ ]\") == ok(list(@~[]));\n+        assert from_str(~\"[true]\") == ok(list(@~[boolean(true)]));\n+        assert from_str(~\"[ false ]\") == ok(list(@~[boolean(false)]));\n+        assert from_str(~\"[null]\") == ok(list(@~[null]));\n+        assert from_str(~\"[3, 1]\") == ok(list(@~[num(3f), num(1f)]));\n+        assert from_str(~\"\\n[3, 2]\\n\") == ok(list(@~[num(3f), num(2f)]));\n+        assert from_str(~\"[2, [4, 1]]\") ==\n                ok(list(@~[num(2f), list(@~[num(4f), num(1f)])]));\n     }\n \n     #[test]\n     fn test_read_dict() {\n-        assert from_str(\"{\") ==\n-            err({line: 1u, col: 2u, msg: @\"EOF while parsing object\"});\n-        assert from_str(\"{ \") ==\n-            err({line: 1u, col: 3u, msg: @\"EOF while parsing object\"});\n-        assert from_str(\"{1\") ==\n-            err({line: 1u, col: 2u, msg: @\"key must be a string\"});\n-        assert from_str(\"{ \\\"a\\\"\") ==\n-            err({line: 1u, col: 6u, msg: @\"EOF while parsing object\"});\n-        assert from_str(\"{\\\"a\\\"\") ==\n-            err({line: 1u, col: 5u, msg: @\"EOF while parsing object\"});\n-        assert from_str(\"{\\\"a\\\" \") ==\n-            err({line: 1u, col: 6u, msg: @\"EOF while parsing object\"});\n-\n-        assert from_str(\"{\\\"a\\\" 1\") ==\n-            err({line: 1u, col: 6u, msg: @\"expected `:`\"});\n-        assert from_str(\"{\\\"a\\\":\") ==\n-            err({line: 1u, col: 6u, msg: @\"EOF while parsing value\"});\n-        assert from_str(\"{\\\"a\\\":1\") ==\n-            err({line: 1u, col: 7u, msg: @\"EOF while parsing object\"});\n-        assert from_str(\"{\\\"a\\\":1 1\") ==\n-            err({line: 1u, col: 8u, msg: @\"expected `,` or `}`\"});\n-        assert from_str(\"{\\\"a\\\":1,\") ==\n-            err({line: 1u, col: 8u, msg: @\"EOF while parsing object\"});\n-\n-        assert eq(result::get(from_str(\"{}\")), mk_dict(~[]));\n-        assert eq(result::get(from_str(\"{\\\"a\\\": 3}\")),\n-                  mk_dict(~[(\"a\", num(3.0f))]));\n-\n-        assert eq(result::get(from_str(\"{ \\\"a\\\": null, \\\"b\\\" : true }\")),\n+        assert from_str(~\"{\") ==\n+            err({line: 1u, col: 2u, msg: @~\"EOF while parsing object\"});\n+        assert from_str(~\"{ \") ==\n+            err({line: 1u, col: 3u, msg: @~\"EOF while parsing object\"});\n+        assert from_str(~\"{1\") ==\n+            err({line: 1u, col: 2u, msg: @~\"key must be a string\"});\n+        assert from_str(~\"{ \\\"a\\\"\") ==\n+            err({line: 1u, col: 6u, msg: @~\"EOF while parsing object\"});\n+        assert from_str(~\"{\\\"a\\\"\") ==\n+            err({line: 1u, col: 5u, msg: @~\"EOF while parsing object\"});\n+        assert from_str(~\"{\\\"a\\\" \") ==\n+            err({line: 1u, col: 6u, msg: @~\"EOF while parsing object\"});\n+\n+        assert from_str(~\"{\\\"a\\\" 1\") ==\n+            err({line: 1u, col: 6u, msg: @~\"expected `:`\"});\n+        assert from_str(~\"{\\\"a\\\":\") ==\n+            err({line: 1u, col: 6u, msg: @~\"EOF while parsing value\"});\n+        assert from_str(~\"{\\\"a\\\":1\") ==\n+            err({line: 1u, col: 7u, msg: @~\"EOF while parsing object\"});\n+        assert from_str(~\"{\\\"a\\\":1 1\") ==\n+            err({line: 1u, col: 8u, msg: @~\"expected `,` or `}`\"});\n+        assert from_str(~\"{\\\"a\\\":1,\") ==\n+            err({line: 1u, col: 8u, msg: @~\"EOF while parsing object\"});\n+\n+        assert eq(result::get(from_str(~\"{}\")), mk_dict(~[]));\n+        assert eq(result::get(from_str(~\"{\\\"a\\\": 3}\")),\n+                  mk_dict(~[(~\"a\", num(3.0f))]));\n+\n+        assert eq(result::get(from_str(~\"{ \\\"a\\\": null, \\\"b\\\" : true }\")),\n                   mk_dict(~[\n-                      (\"a\", null),\n-                      (\"b\", boolean(true))]));\n-        assert eq(result::get(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")),\n+                      (~\"a\", null),\n+                      (~\"b\", boolean(true))]));\n+        assert eq(result::get(from_str(~\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")),\n                   mk_dict(~[\n-                      (\"a\", null),\n-                      (\"b\", boolean(true))]));\n-        assert eq(result::get(from_str(\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")),\n+                      (~\"a\", null),\n+                      (~\"b\", boolean(true))]));\n+        assert eq(result::get(from_str(~\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")),\n                   mk_dict(~[\n-                      (\"a\", num(1.0)),\n-                      (\"b\", list(@~[boolean(true)]))\n+                      (~\"a\", num(1.0)),\n+                      (~\"b\", list(@~[boolean(true)]))\n                   ]));\n         assert eq(result::get(from_str(\n-                      \"{\" +\n-                          \"\\\"a\\\": 1.0, \" +\n-                          \"\\\"b\\\": [\" +\n-                              \"true,\" +\n-                              \"\\\"foo\\\\nbar\\\", \" +\n-                              \"{ \\\"c\\\": {\\\"d\\\": null} } \" +\n-                          \"]\" +\n-                      \"}\")),\n+                      ~\"{\" +\n+                          ~\"\\\"a\\\": 1.0, \" +\n+                          ~\"\\\"b\\\": [\" +\n+                              ~\"true,\" +\n+                              ~\"\\\"foo\\\\nbar\\\", \" +\n+                              ~\"{ \\\"c\\\": {\\\"d\\\": null} } \" +\n+                          ~\"]\" +\n+                      ~\"}\")),\n                   mk_dict(~[\n-                      (\"a\", num(1.0f)),\n-                      (\"b\", list(@~[\n+                      (~\"a\", num(1.0f)),\n+                      (~\"b\", list(@~[\n                           boolean(true),\n-                          string(@\"foo\\nbar\"),\n+                          string(@~\"foo\\nbar\"),\n                           mk_dict(~[\n-                              (\"c\", mk_dict(~[(\"d\", null)]))\n+                              (~\"c\", mk_dict(~[(~\"d\", null)]))\n                           ])\n                       ]))\n                   ]));\n     }\n \n     #[test]\n     fn test_multiline_errors() {\n-        assert from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\") ==\n-            err({line: 3u, col: 8u, msg: @\"EOF while parsing object\"});\n+        assert from_str(~\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\") ==\n+            err({line: 3u, col: 8u, msg: @~\"EOF while parsing object\"});\n     }\n }"}, {"sha": "46bb01250fe8c3c0cc60400b633cb819908454a5", "filename": "src/libstd/list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -85,7 +85,7 @@ fn len<T>(ls: @list<T>) -> uint {\n pure fn tail<T: copy>(ls: @list<T>) -> @list<T> {\n     alt *ls {\n         cons(_, tl) { ret tl; }\n-        nil { fail \"list empty\" }\n+        nil { fail ~\"list empty\" }\n     }\n }\n "}, {"sha": "bce843224d1f063168ec69f474eaa946e31ecfd1", "filename": "src/libstd/map.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -237,7 +237,7 @@ mod chained {\n         }\n \n         fn get(k: K) -> V {\n-            self.find(k).expect(\"Key not found in table\")\n+            self.find(k).expect(~\"Key not found in table\")\n         }\n \n         fn [](k: K) -> V {\n@@ -305,13 +305,13 @@ fn hashmap<K: const, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>)\n }\n \n /// Construct a hashmap for string keys\n-fn str_hash<V: copy>() -> hashmap<str, V> {\n+fn str_hash<V: copy>() -> hashmap<~str, V> {\n     ret hashmap(str::hash, str::eq);\n }\n \n /// Construct a hashmap for boxed string keys\n-fn box_str_hash<V: copy>() -> hashmap<@str/~, V> {\n-    ret hashmap(|x: @str/~| str::hash(*x), |x,y| str::eq(*x,*y));\n+fn box_str_hash<V: copy>() -> hashmap<@~str, V> {\n+    ret hashmap(|x: @~str| str::hash(*x), |x,y| str::eq(*x,*y));\n }\n \n /// Construct a hashmap for byte string keys\n@@ -356,7 +356,7 @@ fn hash_from_vec<K: const copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>,\n }\n \n /// Construct a hashmap from a vector with string keys\n-fn hash_from_strs<V: copy>(items: ~[(str, V)]) -> hashmap<str, V> {\n+fn hash_from_strs<V: copy>(items: ~[(~str, V)]) -> hashmap<~str, V> {\n     hash_from_vec(str::hash, str::eq, items)\n }\n \n@@ -385,8 +385,8 @@ mod tests {\n         fn uint_id(&&x: uint) -> uint { x }\n         let hasher_uint: map::hashfn<uint> = uint_id;\n         let eqer_uint: map::eqfn<uint> = eq_uint;\n-        let hasher_str: map::hashfn<str> = str::hash;\n-        let eqer_str: map::eqfn<str> = str::eq;\n+        let hasher_str: map::hashfn<~str> = str::hash;\n+        let eqer_str: map::eqfn<~str> = str::eq;\n         #debug(\"uint -> uint\");\n         let hm_uu: map::hashmap<uint, uint> =\n             map::hashmap::<uint, uint>(hasher_uint, eqer_uint);\n@@ -400,49 +400,49 @@ mod tests {\n         assert (hm_uu.get(12u) == 14u);\n         assert (!hm_uu.insert(12u, 12u));\n         assert (hm_uu.get(12u) == 12u);\n-        let ten: str = \"ten\";\n-        let eleven: str = \"eleven\";\n-        let twelve: str = \"twelve\";\n+        let ten: ~str = ~\"ten\";\n+        let eleven: ~str = ~\"eleven\";\n+        let twelve: ~str = ~\"twelve\";\n         #debug(\"str -> uint\");\n-        let hm_su: map::hashmap<str, uint> =\n-            map::hashmap::<str, uint>(hasher_str, eqer_str);\n-        assert (hm_su.insert(\"ten\", 12u));\n+        let hm_su: map::hashmap<~str, uint> =\n+            map::hashmap::<~str, uint>(hasher_str, eqer_str);\n+        assert (hm_su.insert(~\"ten\", 12u));\n         assert (hm_su.insert(eleven, 13u));\n-        assert (hm_su.insert(\"twelve\", 14u));\n+        assert (hm_su.insert(~\"twelve\", 14u));\n         assert (hm_su.get(eleven) == 13u);\n-        assert (hm_su.get(\"eleven\") == 13u);\n-        assert (hm_su.get(\"twelve\") == 14u);\n-        assert (hm_su.get(\"ten\") == 12u);\n-        assert (!hm_su.insert(\"twelve\", 14u));\n-        assert (hm_su.get(\"twelve\") == 14u);\n-        assert (!hm_su.insert(\"twelve\", 12u));\n-        assert (hm_su.get(\"twelve\") == 12u);\n+        assert (hm_su.get(~\"eleven\") == 13u);\n+        assert (hm_su.get(~\"twelve\") == 14u);\n+        assert (hm_su.get(~\"ten\") == 12u);\n+        assert (!hm_su.insert(~\"twelve\", 14u));\n+        assert (hm_su.get(~\"twelve\") == 14u);\n+        assert (!hm_su.insert(~\"twelve\", 12u));\n+        assert (hm_su.get(~\"twelve\") == 12u);\n         #debug(\"uint -> str\");\n-        let hm_us: map::hashmap<uint, str> =\n-            map::hashmap::<uint, str>(hasher_uint, eqer_uint);\n-        assert (hm_us.insert(10u, \"twelve\"));\n-        assert (hm_us.insert(11u, \"thirteen\"));\n-        assert (hm_us.insert(12u, \"fourteen\"));\n-        assert (str::eq(hm_us.get(11u), \"thirteen\"));\n-        assert (str::eq(hm_us.get(12u), \"fourteen\"));\n-        assert (str::eq(hm_us.get(10u), \"twelve\"));\n-        assert (!hm_us.insert(12u, \"fourteen\"));\n-        assert (str::eq(hm_us.get(12u), \"fourteen\"));\n-        assert (!hm_us.insert(12u, \"twelve\"));\n-        assert (str::eq(hm_us.get(12u), \"twelve\"));\n+        let hm_us: map::hashmap<uint, ~str> =\n+            map::hashmap::<uint, ~str>(hasher_uint, eqer_uint);\n+        assert (hm_us.insert(10u, ~\"twelve\"));\n+        assert (hm_us.insert(11u, ~\"thirteen\"));\n+        assert (hm_us.insert(12u, ~\"fourteen\"));\n+        assert (str::eq(hm_us.get(11u), ~\"thirteen\"));\n+        assert (str::eq(hm_us.get(12u), ~\"fourteen\"));\n+        assert (str::eq(hm_us.get(10u), ~\"twelve\"));\n+        assert (!hm_us.insert(12u, ~\"fourteen\"));\n+        assert (str::eq(hm_us.get(12u), ~\"fourteen\"));\n+        assert (!hm_us.insert(12u, ~\"twelve\"));\n+        assert (str::eq(hm_us.get(12u), ~\"twelve\"));\n         #debug(\"str -> str\");\n-        let hm_ss: map::hashmap<str, str> =\n-            map::hashmap::<str, str>(hasher_str, eqer_str);\n-        assert (hm_ss.insert(ten, \"twelve\"));\n-        assert (hm_ss.insert(eleven, \"thirteen\"));\n-        assert (hm_ss.insert(twelve, \"fourteen\"));\n-        assert (str::eq(hm_ss.get(\"eleven\"), \"thirteen\"));\n-        assert (str::eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n-        assert (str::eq(hm_ss.get(\"ten\"), \"twelve\"));\n-        assert (!hm_ss.insert(\"twelve\", \"fourteen\"));\n-        assert (str::eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n-        assert (!hm_ss.insert(\"twelve\", \"twelve\"));\n-        assert (str::eq(hm_ss.get(\"twelve\"), \"twelve\"));\n+        let hm_ss: map::hashmap<~str, ~str> =\n+            map::hashmap::<~str, ~str>(hasher_str, eqer_str);\n+        assert (hm_ss.insert(ten, ~\"twelve\"));\n+        assert (hm_ss.insert(eleven, ~\"thirteen\"));\n+        assert (hm_ss.insert(twelve, ~\"fourteen\"));\n+        assert (str::eq(hm_ss.get(~\"eleven\"), ~\"thirteen\"));\n+        assert (str::eq(hm_ss.get(~\"twelve\"), ~\"fourteen\"));\n+        assert (str::eq(hm_ss.get(~\"ten\"), ~\"twelve\"));\n+        assert (!hm_ss.insert(~\"twelve\", ~\"fourteen\"));\n+        assert (str::eq(hm_ss.get(~\"twelve\"), ~\"fourteen\"));\n+        assert (!hm_ss.insert(~\"twelve\", ~\"twelve\"));\n+        assert (str::eq(hm_ss.get(~\"twelve\"), ~\"twelve\"));\n         #debug(\"*** finished test_simple\");\n     }\n \n@@ -484,10 +484,10 @@ mod tests {\n             i += 1u;\n         }\n         #debug(\"str -> str\");\n-        let hasher_str: map::hashfn<str> = str::hash;\n-        let eqer_str: map::eqfn<str> = str::eq;\n-        let hm_ss: map::hashmap<str, str> =\n-            map::hashmap::<str, str>(hasher_str, eqer_str);\n+        let hasher_str: map::hashfn<~str> = str::hash;\n+        let eqer_str: map::eqfn<~str> = str::eq;\n+        let hm_ss: map::hashmap<~str, ~str> =\n+            map::hashmap::<~str, ~str>(hasher_str, eqer_str);\n         i = 0u;\n         while i < num_to_insert {\n             assert hm_ss.insert(uint::to_str(i, 2u), uint::to_str(i * i, 2u));\n@@ -602,27 +602,27 @@ mod tests {\n \n     #[test]\n     fn test_contains_key() {\n-        let key = \"k\";\n-        let map = map::hashmap::<str, str>(str::hash, str::eq);\n+        let key = ~\"k\";\n+        let map = map::hashmap::<~str, ~str>(str::hash, str::eq);\n         assert (!map.contains_key(key));\n-        map.insert(key, \"val\");\n+        map.insert(key, ~\"val\");\n         assert (map.contains_key(key));\n     }\n \n     #[test]\n     fn test_find() {\n-        let key = \"k\";\n-        let map = map::hashmap::<str, str>(str::hash, str::eq);\n+        let key = ~\"k\";\n+        let map = map::hashmap::<~str, ~str>(str::hash, str::eq);\n         assert (option::is_none(map.find(key)));\n-        map.insert(key, \"val\");\n-        assert (option::get(map.find(key)) == \"val\");\n+        map.insert(key, ~\"val\");\n+        assert (option::get(map.find(key)) == ~\"val\");\n     }\n \n     #[test]\n     fn test_clear() {\n-        let key = \"k\";\n-        let map = map::hashmap::<str, str>(str::hash, str::eq);\n-        map.insert(key, \"val\");\n+        let key = ~\"k\";\n+        let map = map::hashmap::<~str, ~str>(str::hash, str::eq);\n+        map.insert(key, ~\"val\");\n         assert (map.size() == 1);\n         assert (map.contains_key(key));\n         map.clear();\n@@ -633,13 +633,13 @@ mod tests {\n     #[test]\n     fn test_hash_from_vec() {\n         let map = map::hash_from_strs(~[\n-            (\"a\", 1),\n-            (\"b\", 2),\n-            (\"c\", 3)\n+            (~\"a\", 1),\n+            (~\"b\", 2),\n+            (~\"c\", 3)\n         ]);\n         assert map.size() == 3u;\n-        assert map.get(\"a\") == 1;\n-        assert map.get(\"b\") == 2;\n-        assert map.get(\"c\") == 3;\n+        assert map.get(~\"a\") == 1;\n+        assert map.get(~\"b\") == 2;\n+        assert map.get(~\"c\") == 3;\n     }\n }"}, {"sha": "134091dfd1dc6c25fc004eeb9101948fa0821b7e", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -82,37 +82,37 @@ fn md4(msg: ~[u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n     ret {a: a, b: b, c: c, d: d};\n }\n \n-fn md4_str(msg: ~[u8]) -> str {\n+fn md4_str(msg: ~[u8]) -> ~str {\n     let {a, b, c, d} = md4(msg);\n     fn app(a: u32, b: u32, c: u32, d: u32, f: fn(u32)) {\n         f(a); f(b); f(c); f(d);\n     }\n-    let mut result = \"\";\n+    let mut result = ~\"\";\n     do app(a, b, c, d) |u| {\n         let mut i = 0u32;\n         while i < 4u32 {\n             let byte = (u >> (i * 8u32)) as u8;\n-            if byte <= 16u8 { result += \"0\"; }\n+            if byte <= 16u8 { result += ~\"0\"; }\n             result += uint::to_str(byte as uint, 16u);\n             i += 1u32;\n         }\n     }\n     result\n }\n \n-fn md4_text(msg: str) -> str { md4_str(str::bytes(msg)) }\n+fn md4_text(msg: ~str) -> ~str { md4_str(str::bytes(msg)) }\n \n #[test]\n fn test_md4() {\n-    assert md4_text(\"\") == \"31d6cfe0d16ae931b73c59d7e0c089c0\";\n-    assert md4_text(\"a\") == \"bde52cb31de33e46245e05fbdbd6fb24\";\n-    assert md4_text(\"abc\") == \"a448017aaf21d8525fc10ae87aa6729d\";\n-    assert md4_text(\"message digest\") == \"d9130a8164549fe818874806e1c7014b\";\n-    assert md4_text(\"abcdefghijklmnopqrstuvwxyz\") ==\n-        \"d79e1c308aa5bbcdeea8ed63df412da9\";\n-    assert md4_text(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123\\\n-                     456789\") == \"043f8582f241db351ce627e153e7f0e4\";\n-    assert md4_text(\"12345678901234567890123456789012345678901234567890123456\\\n-                     789012345678901234567890\") ==\n-        \"e33b4ddc9c38f2199c3e7b164fcc0536\";\n+    assert md4_text(~\"\") == ~\"31d6cfe0d16ae931b73c59d7e0c089c0\";\n+    assert md4_text(~\"a\") == ~\"bde52cb31de33e46245e05fbdbd6fb24\";\n+    assert md4_text(~\"abc\") == ~\"a448017aaf21d8525fc10ae87aa6729d\";\n+    assert md4_text(~\"message digest\") == ~\"d9130a8164549fe818874806e1c7014b\";\n+    assert md4_text(~\"abcdefghijklmnopqrstuvwxyz\") ==\n+        ~\"d79e1c308aa5bbcdeea8ed63df412da9\";\n+    assert md4_text(~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\n+                     0123456789\") == ~\"043f8582f241db351ce627e153e7f0e4\";\n+    assert md4_text(~\"1234567890123456789012345678901234567890123456789\\\n+                     0123456789012345678901234567890\") ==\n+        ~\"e33b4ddc9c38f2199c3e7b164fcc0536\";\n }"}, {"sha": "a78b6a5f1723fbd5cf45892dcb1a969537981295", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -36,7 +36,7 @@ enum ip_addr {\n \n /// Human-friendly feedback on why a parse_addr attempt failed\n type parse_addr_err = {\n-    err_msg: str\n+    err_msg: ~str\n };\n \n /**\n@@ -46,22 +46,22 @@ type parse_addr_err = {\n  *\n  * * ip - a `std::net::ip::ip_addr`\n  */\n-fn format_addr(ip: ip_addr) -> str {\n+fn format_addr(ip: ip_addr) -> ~str {\n     alt ip {\n       ipv4(addr) {\n         unsafe {\n             let result = uv_ip4_name(&addr);\n-            if result == \"\" {\n-                fail \"failed to convert inner sockaddr_in address to str\"\n+            if result == ~\"\" {\n+                fail ~\"failed to convert inner sockaddr_in address to str\"\n             }\n             result\n         }\n       }\n       ipv6(addr) {\n         unsafe {\n             let result = uv_ip6_name(&addr);\n-            if result == \"\" {\n-                fail \"failed to convert inner sockaddr_in address to str\"\n+            if result == ~\"\" {\n+                fail ~\"failed to convert inner sockaddr_in address to str\"\n             }\n             result\n         }\n@@ -88,7 +88,7 @@ enum ip_get_addr_err {\n  * a vector of `ip_addr` results, in the case of success, or an error\n  * object in the case of failure\n  */\n-fn get_addr(++node: str, iotask: iotask)\n+fn get_addr(++node: ~str, iotask: iotask)\n         -> result::result<~[ip_addr], ip_get_addr_err> unsafe {\n     do comm::listen |output_ch| {\n         do str::unpack_slice(node) |node_ptr, len| {\n@@ -137,7 +137,7 @@ mod v4 {\n      *\n      * * an `ip_addr` of the `ipv4` variant\n      */\n-    fn parse_addr(ip: str) -> ip_addr {\n+    fn parse_addr(ip: ~str) -> ip_addr {\n         alt try_parse_addr(ip) {\n           result::ok(addr) { copy(addr) }\n           result::err(err_data) {\n@@ -154,7 +154,7 @@ mod v4 {\n             *((ptr::addr_of(self)) as *u32)\n         }\n     }\n-    fn parse_to_ipv4_rep(ip: str) -> result::result<ipv4_rep, str> {\n+    fn parse_to_ipv4_rep(ip: ~str) -> result::result<ipv4_rep, ~str> {\n         let parts = vec::map(str::split_char(ip, '.'), |s| {\n             alt uint::from_str(s) {\n               some(n) if n <= 255u { n }\n@@ -172,7 +172,7 @@ mod v4 {\n                         c: parts[2] as u8, d: parts[3] as u8})\n         }\n     }\n-    fn try_parse_addr(ip: str) -> result::result<ip_addr,parse_addr_err> {\n+    fn try_parse_addr(ip: ~str) -> result::result<ip_addr,parse_addr_err> {\n         unsafe {\n             let INADDR_NONE = ll::get_INADDR_NONE();\n             let ip_rep_result = parse_to_ipv4_rep(ip);\n@@ -196,7 +196,7 @@ mod v4 {\n             if result::get(ref_ip_rep_result).as_u32() == INADDR_NONE &&\n                  !input_is_inaddr_none {\n                 ret result::err(\n-                    {err_msg: \"uv_ip4_name produced invalid result.\"})\n+                    {err_msg: ~\"uv_ip4_name produced invalid result.\"})\n             }\n             else {\n                 result::ok(ipv4(copy(new_addr)))\n@@ -220,15 +220,15 @@ mod v6 {\n      *\n      * * an `ip_addr` of the `ipv6` variant\n      */\n-    fn parse_addr(ip: str) -> ip_addr {\n+    fn parse_addr(ip: ~str) -> ip_addr {\n         alt try_parse_addr(ip) {\n           result::ok(addr) { copy(addr) }\n           result::err(err_data) {\n             fail err_data.err_msg\n           }\n         }\n     }\n-    fn try_parse_addr(ip: str) -> result::result<ip_addr,parse_addr_err> {\n+    fn try_parse_addr(ip: ~str) -> result::result<ip_addr,parse_addr_err> {\n         unsafe {\n             // need to figure out how to establish a parse failure..\n             let new_addr = uv_ip6_addr(ip, 22);\n@@ -237,7 +237,7 @@ mod v6 {\n                             ip, reparsed_name));\n             // '::' appears to be uv_ip6_name() returns for bogus\n             // parses..\n-            if  ip != \"::\" && reparsed_name == \"::\" {\n+            if  ip != ~\"::\" && reparsed_name == ~\"::\" {\n                 result::err({err_msg:#fmt(\"failed to parse '%s'\",\n                                            ip)})\n             }\n@@ -254,7 +254,7 @@ type get_addr_data = {\n \n extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                      res: *addrinfo) unsafe {\n-    log(debug, \"in get_addr_cb\");\n+    log(debug, ~\"in get_addr_cb\");\n     let handle_data = get_data_for_req(handle) as\n         *get_addr_data;\n     if status == 0i32 {\n@@ -272,8 +272,8 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                         *ll::addrinfo_as_sockaddr_in6(curr_addr))))\n                 }\n                 else {\n-                    log(debug, \"curr_addr is not of family AF_INET or \"+\n-                        \"AF_INET6. Error.\");\n+                    log(debug, ~\"curr_addr is not of family AF_INET or \"+\n+                        ~\"AF_INET6. Error.\");\n                     (*handle_data).output_ch.send(\n                         result::err(get_addr_unknown_error));\n                     break;\n@@ -282,7 +282,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n \n                 let next_addr = ll::get_next_addrinfo(curr_addr);\n                 if next_addr == ptr::null::<addrinfo>() as *addrinfo {\n-                    log(debug, \"null next_addr encountered. no mas\");\n+                    log(debug, ~\"null next_addr encountered. no mas\");\n                     break;\n                 }\n                 else {\n@@ -295,41 +295,41 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n             (*handle_data).output_ch.send(result::ok(out_vec));\n         }\n         else {\n-            log(debug, \"addrinfo pointer is NULL\");\n+            log(debug, ~\"addrinfo pointer is NULL\");\n             (*handle_data).output_ch.send(\n                 result::err(get_addr_unknown_error));\n         }\n     }\n     else {\n-        log(debug, \"status != 0 error in get_addr_cb\");\n+        log(debug, ~\"status != 0 error in get_addr_cb\");\n         (*handle_data).output_ch.send(\n             result::err(get_addr_unknown_error));\n     }\n     if res != (ptr::null::<addrinfo>()) {\n         uv_freeaddrinfo(res);\n     }\n-    log(debug, \"leaving get_addr_cb\");\n+    log(debug, ~\"leaving get_addr_cb\");\n }\n \n #[cfg(test)]\n mod test {\n     #[test]\n     fn test_ip_ipv4_parse_and_format_ip() {\n-        let localhost_str = \"127.0.0.1\";\n+        let localhost_str = ~\"127.0.0.1\";\n         assert (format_addr(v4::parse_addr(localhost_str))\n                 == localhost_str)\n     }\n     #[test]\n     fn test_ip_ipv6_parse_and_format_ip() {\n-        let localhost_str = \"::1\";\n+        let localhost_str = ~\"::1\";\n         let format_result = format_addr(v6::parse_addr(localhost_str));\n         log(debug, #fmt(\"results: expected: '%s' actual: '%s'\",\n             localhost_str, format_result));\n         assert format_result == localhost_str;\n     }\n     #[test]\n     fn test_ip_ipv4_bad_parse() {\n-        alt v4::try_parse_addr(\"b4df00d\") {\n+        alt v4::try_parse_addr(~\"b4df00d\") {\n           result::err(err_info) {\n             log(debug, #fmt(\"got error as expected %?\", err_info));\n             assert true;\n@@ -342,7 +342,7 @@ mod test {\n     #[test]\n     #[ignore(target_os=\"win32\")]\n     fn test_ip_ipv6_bad_parse() {\n-        alt v6::try_parse_addr(\"::,~2234k;\") {\n+        alt v6::try_parse_addr(~\"::,~2234k;\") {\n           result::err(err_info) {\n             log(debug, #fmt(\"got error as expected %?\", err_info));\n             assert true;\n@@ -355,11 +355,11 @@ mod test {\n     #[test]\n     #[ignore(reason = \"valgrind says it's leaky\")]\n     fn test_ip_get_addr() {\n-        let localhost_name = \"localhost\";\n+        let localhost_name = ~\"localhost\";\n         let iotask = uv::global_loop::get();\n         let ga_result = get_addr(localhost_name, iotask);\n         if result::is_err(ga_result) {\n-            fail \"got err result from net::ip::get_addr();\"\n+            fail ~\"got err result from net::ip::get_addr();\"\n         }\n         // note really sure how to realiably test/assert\n         // this.. mostly just wanting to see it work, atm.\n@@ -369,10 +369,10 @@ mod test {\n         for vec::each(results) |r| {\n             let ipv_prefix = alt r {\n               ipv4(_) {\n-                \"IPv4\"\n+                ~\"IPv4\"\n               }\n               ipv6(_) {\n-                \"IPv6\"\n+                ~\"IPv6\"\n               }\n             };\n             log(debug, #fmt(\"test_get_addr: result %s: '%s'\",\n@@ -385,7 +385,7 @@ mod test {\n     #[test]\n     #[ignore(reason = \"valgrind says it's leaky\")]\n     fn test_ip_get_addr_bad_input() {\n-        let localhost_name = \"sjkl234m,./sdf\";\n+        let localhost_name = ~\"sjkl234m,./sdf\";\n         let iotask = uv::global_loop::get();\n         let ga_result = get_addr(localhost_name, iotask);\n         assert result::is_err(ga_result);"}, {"sha": "31b8841933bc3f62225a7c5f9cb7427683483f72", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 104, "deletions": 104, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -62,16 +62,16 @@ class tcp_socket_buf {\n \n /// Contains raw, string-based, error information returned from libuv\n type tcp_err_data = {\n-    err_name: str,\n-    err_msg: str\n+    err_name: ~str,\n+    err_msg: ~str\n };\n /// Details returned as part of a `result::err` result from `tcp::listen`\n enum tcp_listen_err_data {\n     /**\n      * Some unplanned-for error. The first and second fields correspond\n      * to libuv's `err_name` and `err_msg` fields, respectively.\n      */\n-    generic_listen_err(str, str),\n+    generic_listen_err(~str, ~str),\n     /**\n      * Failed to bind to the requested IP/Port, because it is already in use.\n      *\n@@ -98,7 +98,7 @@ enum tcp_connect_err_data {\n      * Some unplanned-for error. The first and second fields correspond\n      * to libuv's `err_name` and `err_msg` fields, respectively.\n      */\n-    generic_connect_err(str, str),\n+    generic_connect_err(~str, ~str),\n     /// Invalid IP or invalid port\n     connection_refused\n }\n@@ -147,15 +147,15 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n     log(debug, #fmt(\"stream_handle_ptr outside interact %?\",\n         stream_handle_ptr));\n     do iotask::interact(iotask) |loop_ptr| {\n-        log(debug, \"in interact cb for tcp client connect..\");\n+        log(debug, ~\"in interact cb for tcp client connect..\");\n         log(debug, #fmt(\"stream_handle_ptr in interact %?\",\n             stream_handle_ptr));\n         alt uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n           0i32 {\n-            log(debug, \"tcp_init successful\");\n+            log(debug, ~\"tcp_init successful\");\n             alt input_ip {\n               ipv4 {\n-                log(debug, \"dealing w/ ipv4 connection..\");\n+                log(debug, ~\"dealing w/ ipv4 connection..\");\n                 let connect_req_ptr =\n                     ptr::addr_of((*socket_data_ptr).connect_req);\n                 let addr_str = ip::format_addr(input_ip);\n@@ -186,7 +186,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n                 };\n                 alt connect_result {\n                   0i32 {\n-                    log(debug, \"tcp_connect successful\");\n+                    log(debug, ~\"tcp_connect successful\");\n                     // reusable data that we'll have for the\n                     // duration..\n                     uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n@@ -196,7 +196,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n                     // outcome..\n                     uv::ll::set_data_for_req(connect_req_ptr,\n                                              conn_data_ptr);\n-                    log(debug, \"leaving tcp_connect interact cb...\");\n+                    log(debug, ~\"leaving tcp_connect interact cb...\");\n                     // let tcp_connect_on_connect_cb send on\n                     // the result_ch, now..\n                   }\n@@ -224,17 +224,17 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n     };\n     alt comm::recv(result_po) {\n       conn_success {\n-        log(debug, \"tcp::connect - received success on result_po\");\n+        log(debug, ~\"tcp::connect - received success on result_po\");\n         result::ok(tcp_socket(socket_data))\n       }\n       conn_failure(err_data) {\n         comm::recv(closed_signal_po);\n-        log(debug, \"tcp::connect - received failure on result_po\");\n+        log(debug, ~\"tcp::connect - received failure on result_po\");\n         // still have to free the malloc'd stream handle..\n         rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n                                            as *libc::c_void);\n         let tcp_conn_err = alt err_data.err_name {\n-          \"ECONNREFUSED\" { connection_refused }\n+          ~\"ECONNREFUSED\" { connection_refused }\n           _ { generic_connect_err(err_data.err_name, err_data.err_msg) }\n         };\n         result::err(tcp_conn_err)\n@@ -497,31 +497,31 @@ fn accept(new_conn: tcp_new_connection)\n         // the rules here because this always has to be\n         // called within the context of a listen() new_connect_cb\n         // callback (or it will likely fail and drown your cat)\n-        log(debug, \"in interact cb for tcp::accept\");\n+        log(debug, ~\"in interact cb for tcp::accept\");\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(\n             server_handle_ptr);\n         alt uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n           0i32 {\n-            log(debug, \"uv_tcp_init successful for client stream\");\n+            log(debug, ~\"uv_tcp_init successful for client stream\");\n             alt uv::ll::accept(\n                 server_handle_ptr as *libc::c_void,\n                 client_stream_handle_ptr as *libc::c_void) {\n               0i32 {\n-                log(debug, \"successfully accepted client connection\");\n+                log(debug, ~\"successfully accepted client connection\");\n                 uv::ll::set_data_for_uv_handle(client_stream_handle_ptr,\n                                                client_socket_data_ptr\n                                                    as *libc::c_void);\n                 comm::send(result_ch, none);\n               }\n               _ {\n-                log(debug, \"failed to accept client conn\");\n+                log(debug, ~\"failed to accept client conn\");\n                 comm::send(result_ch, some(\n                     uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n               }\n             }\n           }\n           _ {\n-            log(debug, \"failed to init client stream\");\n+            log(debug, ~\"failed to init client stream\");\n             comm::send(result_ch, some(\n                 uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n           }\n@@ -642,21 +642,21 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n                         comm::send(setup_ch, none);\n                       }\n                       _ {\n-                        log(debug, \"failure to uv_listen()\");\n+                        log(debug, ~\"failure to uv_listen()\");\n                         let err_data = uv::ll::get_last_err_data(loop_ptr);\n                         comm::send(setup_ch, some(err_data));\n                       }\n                     }\n                   }\n                   _ {\n-                    log(debug, \"failure to uv_tcp_bind\");\n+                    log(debug, ~\"failure to uv_tcp_bind\");\n                     let err_data = uv::ll::get_last_err_data(loop_ptr);\n                     comm::send(setup_ch, some(err_data));\n                   }\n                 }\n               }\n               _ {\n-                log(debug, \"failure to uv_tcp_init\");\n+                log(debug, ~\"failure to uv_tcp_init\");\n                 let err_data = uv::ll::get_last_err_data(loop_ptr);\n                 comm::send(setup_ch, some(err_data));\n               }\n@@ -674,12 +674,12 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n         };\n         stream_closed_po.recv();\n         alt err_data.err_name {\n-          \"EACCES\" {\n-            log(debug, \"Got EACCES error\");\n+          ~\"EACCES\" {\n+            log(debug, ~\"Got EACCES error\");\n             result::err(access_denied)\n           }\n-          \"EADDRINUSE\" {\n-            log(debug, \"Got EADDRINUSE error\");\n+          ~\"EADDRINUSE\" {\n+            log(debug, ~\"Got EADDRINUSE error\");\n             result::err(address_in_use)\n           }\n           _ {\n@@ -855,40 +855,40 @@ fn tear_down_socket_data(socket_data: @tcp_socket_data) unsafe {\n     log(debug, #fmt(\"about to free socket_data at %?\", socket_data));\n     rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n                                        as *libc::c_void);\n-    log(debug, \"exiting dtor for tcp_socket\");\n+    log(debug, ~\"exiting dtor for tcp_socket\");\n }\n \n // shared implementation for tcp::read\n fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n     -> result::result<~[u8],tcp_err_data> unsafe {\n-    log(debug, \"starting tcp::read\");\n+    log(debug, ~\"starting tcp::read\");\n     let iotask = (*socket_data).iotask;\n     let rs_result = read_start_common_impl(socket_data);\n     if result::is_err(rs_result) {\n         let err_data = result::get_err(rs_result);\n         result::err(err_data)\n     }\n     else {\n-        log(debug, \"tcp::read before recv_timeout\");\n+        log(debug, ~\"tcp::read before recv_timeout\");\n         let read_result = if timeout_msecs > 0u {\n             timer::recv_timeout(\n                iotask, timeout_msecs, result::get(rs_result))\n         } else {\n             some(comm::recv(result::get(rs_result)))\n         };\n-        log(debug, \"tcp::read after recv_timeout\");\n+        log(debug, ~\"tcp::read after recv_timeout\");\n         alt read_result {\n           none {\n-            log(debug, \"tcp::read: timed out..\");\n+            log(debug, ~\"tcp::read: timed out..\");\n             let err_data = {\n-                err_name: \"TIMEOUT\",\n-                err_msg: \"req timed out\"\n+                err_name: ~\"TIMEOUT\",\n+                err_msg: ~\"req timed out\"\n             };\n             read_stop_common_impl(socket_data);\n             result::err(err_data)\n           }\n           some(data_result) {\n-            log(debug, \"tcp::read got data\");\n+            log(debug, ~\"tcp::read got data\");\n             read_stop_common_impl(socket_data);\n             data_result\n           }\n@@ -903,14 +903,14 @@ fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n     let stop_po = comm::port::<option<tcp_err_data>>();\n     let stop_ch = comm::chan(stop_po);\n     do iotask::interact((*socket_data).iotask) |loop_ptr| {\n-        log(debug, \"in interact cb for tcp::read_stop\");\n+        log(debug, ~\"in interact cb for tcp::read_stop\");\n         alt uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n           0i32 {\n-            log(debug, \"successfully called uv_read_stop\");\n+            log(debug, ~\"successfully called uv_read_stop\");\n             comm::send(stop_ch, none);\n           }\n           _ {\n-            log(debug, \"failure in calling uv_read_stop\");\n+            log(debug, ~\"failure in calling uv_read_stop\");\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n             comm::send(stop_ch, some(err_data.to_tcp_err()));\n           }\n@@ -933,18 +933,18 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     let start_po = comm::port::<option<uv::ll::uv_err_data>>();\n     let start_ch = comm::chan(start_po);\n-    log(debug, \"in tcp::read_start before interact loop\");\n+    log(debug, ~\"in tcp::read_start before interact loop\");\n     do iotask::interact((*socket_data).iotask) |loop_ptr| {\n         log(debug, #fmt(\"in tcp::read_start interact cb %?\", loop_ptr));\n         alt uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n                                on_alloc_cb,\n                                on_tcp_read_cb) {\n           0i32 {\n-            log(debug, \"success doing uv_read_start\");\n+            log(debug, ~\"success doing uv_read_start\");\n             comm::send(start_ch, none);\n           }\n           _ {\n-            log(debug, \"error attempting uv_read_start\");\n+            log(debug, ~\"error attempting uv_read_start\");\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n             comm::send(start_ch, some(err_data));\n           }\n@@ -985,11 +985,11 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n                           write_buf_vec_ptr,\n                           tcp_write_complete_cb) {\n           0i32 {\n-            log(debug, \"uv_write() invoked successfully\");\n+            log(debug, ~\"uv_write() invoked successfully\");\n             uv::ll::set_data_for_req(write_req_ptr, write_data_ptr);\n           }\n           _ {\n-            log(debug, \"error invoking uv_write()\");\n+            log(debug, ~\"error invoking uv_write()\");\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n             comm::send((*write_data_ptr).result_ch,\n                        tcp_write_error(err_data.to_tcp_err()));\n@@ -1113,13 +1113,13 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n       }\n     }\n     uv::ll::free_base_of_buf(buf);\n-    log(debug, \"exiting on_tcp_read_cb\");\n+    log(debug, ~\"exiting on_tcp_read_cb\");\n }\n \n extern fn on_alloc_cb(handle: *libc::c_void,\n                      ++suggested_size: size_t)\n     -> uv::ll::uv_buf_t unsafe {\n-    log(debug, \"tcp read on_alloc_cb!\");\n+    log(debug, ~\"tcp read on_alloc_cb!\");\n     let char_ptr = uv::ll::malloc_buf_base_of(suggested_size);\n     log(debug, #fmt(\"tcp read on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n                      handle,\n@@ -1137,22 +1137,22 @@ extern fn tcp_socket_dtor_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n         as *tcp_socket_close_data;\n     let closed_ch = (*data).closed_ch;\n     comm::send(closed_ch, ());\n-    log(debug, \"tcp_socket_dtor_close_cb exiting..\");\n+    log(debug, ~\"tcp_socket_dtor_close_cb exiting..\");\n }\n \n extern fn tcp_write_complete_cb(write_req: *uv::ll::uv_write_t,\n                               status: libc::c_int) unsafe {\n     let write_data_ptr = uv::ll::get_data_for_req(write_req)\n         as *write_req_data;\n     if status == 0i32 {\n-        log(debug, \"successful write complete\");\n+        log(debug, ~\"successful write complete\");\n         comm::send((*write_data_ptr).result_ch, tcp_write_success);\n     } else {\n         let stream_handle_ptr = uv::ll::get_stream_handle_from_write_req(\n             write_req);\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(stream_handle_ptr);\n         let err_data = uv::ll::get_last_err_data(loop_ptr);\n-        log(debug, \"failure to write\");\n+        log(debug, ~\"failure to write\");\n         comm::send((*write_data_ptr).result_ch, tcp_write_error(err_data));\n     }\n }\n@@ -1187,11 +1187,11 @@ extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n         uv::ll::get_stream_handle_from_connect_req(connect_req_ptr);\n     alt status {\n       0i32 {\n-        log(debug, \"successful tcp connection!\");\n+        log(debug, ~\"successful tcp connection!\");\n         comm::send(result_ch, conn_success);\n       }\n       _ {\n-        log(debug, \"error in tcp_connect_on_connect_cb\");\n+        log(debug, ~\"error in tcp_connect_on_connect_cb\");\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(tcp_stream_ptr);\n         let err_data = uv::ll::get_last_err_data(loop_ptr);\n         log(debug, #fmt(\"err_data %? %?\", err_data.err_name,\n@@ -1202,7 +1202,7 @@ extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n         uv::ll::close(tcp_stream_ptr, stream_error_close_cb);\n       }\n     }\n-    log(debug, \"leaving tcp_connect_on_connect_cb\");\n+    log(debug, ~\"leaving tcp_connect_on_connect_cb\");\n }\n \n enum conn_attempt {\n@@ -1287,12 +1287,12 @@ mod test {\n     }\n     fn impl_gl_tcp_ipv4_server_and_client() {\n         let hl_loop = uv::global_loop::get();\n-        let server_ip = \"127.0.0.1\";\n+        let server_ip = ~\"127.0.0.1\";\n         let server_port = 8888u;\n-        let expected_req = \"ping\";\n-        let expected_resp = \"pong\";\n+        let expected_req = ~\"ping\";\n+        let expected_resp = ~\"pong\";\n \n-        let server_result_po = comm::port::<str>();\n+        let server_result_po = comm::port::<~str>();\n         let server_result_ch = comm::chan(server_result_po);\n \n         let cont_po = comm::port::<()>();\n@@ -1312,7 +1312,7 @@ mod test {\n         };\n         comm::recv(cont_po);\n         // client\n-        log(debug, \"server started, firing up client..\");\n+        log(debug, ~\"server started, firing up client..\");\n         let actual_resp_result = do comm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n@@ -1333,11 +1333,11 @@ mod test {\n     }\n     fn impl_gl_tcp_ipv4_client_error_connection_refused() {\n         let hl_loop = uv::global_loop::get();\n-        let server_ip = \"127.0.0.1\";\n+        let server_ip = ~\"127.0.0.1\";\n         let server_port = 8889u;\n-        let expected_req = \"ping\";\n+        let expected_req = ~\"ping\";\n         // client\n-        log(debug, \"firing up client..\");\n+        log(debug, ~\"firing up client..\");\n         let actual_resp_result = do comm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n@@ -1350,18 +1350,18 @@ mod test {\n           connection_refused {\n           }\n           _ {\n-            fail \"unknown error.. expected connection_refused\"\n+            fail ~\"unknown error.. expected connection_refused\"\n           }\n         }\n     }\n     fn impl_gl_tcp_ipv4_server_address_in_use() {\n         let hl_loop = uv::global_loop::get();\n-        let server_ip = \"127.0.0.1\";\n+        let server_ip = ~\"127.0.0.1\";\n         let server_port = 8890u;\n-        let expected_req = \"ping\";\n-        let expected_resp = \"pong\";\n+        let expected_req = ~\"ping\";\n+        let expected_resp = ~\"pong\";\n \n-        let server_result_po = comm::port::<str>();\n+        let server_result_po = comm::port::<~str>();\n         let server_result_ch = comm::chan(server_result_po);\n \n         let cont_po = comm::port::<()>();\n@@ -1386,7 +1386,7 @@ mod test {\n                             server_port,\n                             hl_loop);\n         // client.. just doing this so that the first server tears down\n-        log(debug, \"server started, firing up client..\");\n+        log(debug, ~\"server started, firing up client..\");\n         do comm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n@@ -1400,14 +1400,14 @@ mod test {\n             assert true;\n           }\n           _ {\n-            fail \"expected address_in_use listen error,\"+\n-                      \"but got a different error varient. check logs.\";\n+            fail ~\"expected address_in_use listen error,\"+\n+                      ~\"but got a different error varient. check logs.\";\n           }\n         }\n     }\n     fn impl_gl_tcp_ipv4_server_access_denied() {\n         let hl_loop = uv::global_loop::get();\n-        let server_ip = \"127.0.0.1\";\n+        let server_ip = ~\"127.0.0.1\";\n         let server_port = 80u;\n         // this one should fail..\n         let listen_err = run_tcp_test_server_fail(\n@@ -1419,19 +1419,19 @@ mod test {\n             assert true;\n           }\n           _ {\n-            fail \"expected address_in_use listen error,\"+\n-                      \"but got a different error varient. check logs.\";\n+            fail ~\"expected address_in_use listen error,\"+\n+                      ~\"but got a different error varient. check logs.\";\n           }\n         }\n     }\n     fn impl_gl_tcp_ipv4_server_client_reader_writer() {\n         let iotask = uv::global_loop::get();\n-        let server_ip = \"127.0.0.1\";\n+        let server_ip = ~\"127.0.0.1\";\n         let server_port = 8891u;\n-        let expected_req = \"ping\";\n-        let expected_resp = \"pong\";\n+        let expected_req = ~\"ping\";\n+        let expected_resp = ~\"pong\";\n \n-        let server_result_po = comm::port::<str>();\n+        let server_result_po = comm::port::<~str>();\n         let server_result_ch = comm::chan(server_result_po);\n \n         let cont_po = comm::port::<()>();\n@@ -1474,7 +1474,7 @@ mod test {\n         assert str::contains(actual_resp, expected_resp);\n     }\n \n-    fn buf_write(+w: io::writer, val: str) {\n+    fn buf_write(+w: io::writer, val: ~str) {\n         log(debug, #fmt(\"BUF_WRITE: val len %?\", str::len(val)));\n         do str::byte_slice(val) |b_slice| {\n             log(debug, #fmt(\"BUF_WRITE: b_slice len %?\",\n@@ -1483,17 +1483,17 @@ mod test {\n         }\n     }\n \n-    fn buf_read(+r: io::reader, len: uint) -> str {\n+    fn buf_read(+r: io::reader, len: uint) -> ~str {\n         let new_bytes = r.read_bytes(len);\n         log(debug, #fmt(\"in buf_read.. new_bytes len: %?\",\n                         vec::len(new_bytes)));\n         str::from_bytes(new_bytes)\n     }\n \n-    fn run_tcp_test_server(server_ip: str, server_port: uint, resp: str,\n-                          server_ch: comm::chan<str>,\n+    fn run_tcp_test_server(server_ip: ~str, server_port: uint, resp: ~str,\n+                          server_ch: comm::chan<~str>,\n                           cont_ch: comm::chan<()>,\n-                          iotask: iotask) -> str {\n+                          iotask: iotask) -> ~str {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n             // on_establish_cb -- called when listener is set up\n@@ -1505,55 +1505,55 @@ mod test {\n             // risky to run this on the loop, but some users\n             // will want the POWER\n             |new_conn, kill_ch| {\n-            log(debug, \"SERVER: new connection!\");\n+            log(debug, ~\"SERVER: new connection!\");\n             do comm::listen |cont_ch| {\n                 do task::spawn_sched(task::manual_threads(1u)) {\n-                    log(debug, \"SERVER: starting worker for new req\");\n+                    log(debug, ~\"SERVER: starting worker for new req\");\n \n                     let accept_result = accept(new_conn);\n-                    log(debug, \"SERVER: after accept()\");\n+                    log(debug, ~\"SERVER: after accept()\");\n                     if result::is_err(accept_result) {\n-                        log(debug, \"SERVER: error accept connection\");\n+                        log(debug, ~\"SERVER: error accept connection\");\n                         let err_data = result::get_err(accept_result);\n                         comm::send(kill_ch, some(err_data));\n                         log(debug,\n-                            \"SERVER/WORKER: send on err cont ch\");\n+                            ~\"SERVER/WORKER: send on err cont ch\");\n                         cont_ch.send(());\n                     }\n                     else {\n                         log(debug,\n-                            \"SERVER/WORKER: send on cont ch\");\n+                            ~\"SERVER/WORKER: send on cont ch\");\n                         cont_ch.send(());\n                         let sock = result::unwrap(accept_result);\n-                        log(debug, \"SERVER: successfully accepted\"+\n-                            \"connection!\");\n+                        log(debug, ~\"SERVER: successfully accepted\"+\n+                            ~\"connection!\");\n                         let received_req_bytes = read(sock, 0u);\n                         alt received_req_bytes {\n                           result::ok(data) {\n-                            log(debug, \"SERVER: got REQ str::from_bytes..\");\n+                            log(debug, ~\"SERVER: got REQ str::from_bytes..\");\n                             log(debug, #fmt(\"SERVER: REQ data len: %?\",\n                                             vec::len(data)));\n                             server_ch.send(\n                                 str::from_bytes(data));\n-                            log(debug, \"SERVER: before write\");\n+                            log(debug, ~\"SERVER: before write\");\n                             tcp_write_single(sock, str::bytes(resp));\n-                            log(debug, \"SERVER: after write.. die\");\n+                            log(debug, ~\"SERVER: after write.. die\");\n                             comm::send(kill_ch, none);\n                           }\n                           result::err(err_data) {\n                             log(debug, #fmt(\"SERVER: error recvd: %s %s\",\n                                 err_data.err_name, err_data.err_msg));\n                             comm::send(kill_ch, some(err_data));\n-                            server_ch.send(\"\");\n+                            server_ch.send(~\"\");\n                           }\n                         }\n-                        log(debug, \"SERVER: worker spinning down\");\n+                        log(debug, ~\"SERVER: worker spinning down\");\n                     }\n                 }\n-                log(debug, \"SERVER: waiting to recv on cont_ch\");\n+                log(debug, ~\"SERVER: waiting to recv on cont_ch\");\n                 cont_ch.recv()\n             };\n-            log(debug, \"SERVER: recv'd on cont_ch..leaving listen cb\");\n+            log(debug, ~\"SERVER: recv'd on cont_ch..leaving listen cb\");\n         });\n         // err check on listen_result\n         if result::is_err(listen_result) {\n@@ -1563,10 +1563,10 @@ mod test {\n                                 name, msg);\n               }\n               access_denied {\n-                fail \"SERVER: exited abnormally, got access denied..\";\n+                fail ~\"SERVER: exited abnormally, got access denied..\";\n               }\n               address_in_use {\n-                fail \"SERVER: exited abnormally, got address in use...\";\n+                fail ~\"SERVER: exited abnormally, got address in use...\";\n               }\n             }\n         }\n@@ -1575,7 +1575,7 @@ mod test {\n         ret_val\n     }\n \n-    fn run_tcp_test_server_fail(server_ip: str, server_port: uint,\n+    fn run_tcp_test_server_fail(server_ip: ~str, server_port: uint,\n                           iotask: iotask) -> tcp_listen_err_data {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n@@ -1593,20 +1593,20 @@ mod test {\n             result::get_err(listen_result)\n         }\n         else {\n-            fail \"SERVER: did not fail as expected\"\n+            fail ~\"SERVER: did not fail as expected\"\n         }\n     }\n \n-    fn run_tcp_test_client(server_ip: str, server_port: uint, resp: str,\n-                          client_ch: comm::chan<str>,\n-                          iotask: iotask) -> result::result<str,\n+    fn run_tcp_test_client(server_ip: ~str, server_port: uint, resp: ~str,\n+                          client_ch: comm::chan<~str>,\n+                          iotask: iotask) -> result::result<~str,\n                                                     tcp_connect_err_data> {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n \n-        log(debug, \"CLIENT: starting..\");\n+        log(debug, ~\"CLIENT: starting..\");\n         let connect_result = connect(server_ip_addr, server_port, iotask);\n         if result::is_err(connect_result) {\n-            log(debug, \"CLIENT: failed to connect\");\n+            log(debug, ~\"CLIENT: failed to connect\");\n             let err_data = result::get_err(connect_result);\n             err(err_data)\n         }\n@@ -1616,8 +1616,8 @@ mod test {\n             tcp_write_single(sock, resp_bytes);\n             let read_result = sock.read(0u);\n             if read_result.is_err() {\n-                log(debug, \"CLIENT: failure to read\");\n-                ok(\"\")\n+                log(debug, ~\"CLIENT: failure to read\");\n+                ok(~\"\")\n             }\n             else {\n                 client_ch.send(str::from_bytes(read_result.get()));\n@@ -1633,12 +1633,12 @@ mod test {\n         let write_result_future = sock.write_future(val);\n         let write_result = write_result_future.get();\n         if result::is_err(write_result) {\n-            log(debug, \"tcp_write_single: write failed!\");\n+            log(debug, ~\"tcp_write_single: write failed!\");\n             let err_data = result::get_err(write_result);\n             log(debug, #fmt(\"tcp_write_single err name: %s msg: %s\",\n                 err_data.err_name, err_data.err_msg));\n             // meh. torn on what to do here.\n-            fail \"tcp_write_single failed\";\n+            fail ~\"tcp_write_single failed\";\n         }\n     }\n }"}, {"sha": "ce78bc945db74bc20203ee562defa2fb75dff803", "filename": "src/libstd/par.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -31,7 +31,7 @@ fn map_slices<A: copy send, B: copy send>(\n \n     let len = xs.len();\n     if len < min_granularity {\n-        log(info, \"small slice\");\n+        log(info, ~\"small slice\");\n         // This is a small vector, fall back on the normal map.\n         ~[f()(0u, xs)]\n     }\n@@ -42,7 +42,7 @@ fn map_slices<A: copy send, B: copy send>(\n \n         let mut futures = ~[];\n         let mut base = 0u;\n-        log(info, \"spawning tasks\");\n+        log(info, ~\"spawning tasks\");\n         while base < len {\n             let end = uint::min(len, base + items_per_task);\n             // FIXME: why is the ::<A, ()> annotation required here? (#2617)\n@@ -66,7 +66,7 @@ fn map_slices<A: copy send, B: copy send>(\n             };\n             base += items_per_task;\n         }\n-        log(info, \"tasks spawned\");\n+        log(info, ~\"tasks spawned\");\n \n         log(info, #fmt(\"num_tasks: %?\", (num_tasks, futures.len())));\n         assert(num_tasks == futures.len());"}, {"sha": "dbeb5ab63810e51bd5b1dfdd652cb9974f97b9f9", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -4,7 +4,7 @@ import serialization::serializer;\n \n impl of serializer for writer {\n     fn emit_nil() {\n-        self.write_str(\"()\")\n+        self.write_str(~\"()\")\n     }\n \n     fn emit_uint(v: uint) {\n@@ -63,68 +63,68 @@ impl of serializer for writer {\n         self.write_str(#fmt[\"%?_f32\", v]);\n     }\n \n-    fn emit_str(v: str) {\n+    fn emit_str(v: ~str) {\n         self.write_str(#fmt[\"%?\", v]);\n     }\n \n-    fn emit_enum(_name: str, f: fn()) {\n+    fn emit_enum(_name: ~str, f: fn()) {\n         f();\n     }\n \n-    fn emit_enum_variant(v_name: str, _v_id: uint, sz: uint, f: fn()) {\n+    fn emit_enum_variant(v_name: ~str, _v_id: uint, sz: uint, f: fn()) {\n         self.write_str(v_name);\n-        if sz > 0u { self.write_str(\"(\"); }\n+        if sz > 0u { self.write_str(~\"(\"); }\n         f();\n-        if sz > 0u { self.write_str(\")\"); }\n+        if sz > 0u { self.write_str(~\")\"); }\n     }\n \n     fn emit_enum_variant_arg(idx: uint, f: fn()) {\n-        if idx > 0u { self.write_str(\", \"); }\n+        if idx > 0u { self.write_str(~\", \"); }\n         f();\n     }\n \n     fn emit_vec(_len: uint, f: fn()) {\n-        self.write_str(\"[\");\n+        self.write_str(~\"[\");\n         f();\n-        self.write_str(\"]\");\n+        self.write_str(~\"]\");\n     }\n \n     fn emit_vec_elt(idx: uint, f: fn()) {\n-        if idx > 0u { self.write_str(\", \"); }\n+        if idx > 0u { self.write_str(~\", \"); }\n         f();\n     }\n \n     fn emit_box(f: fn()) {\n-        self.write_str(\"@\");\n+        self.write_str(~\"@\");\n         f();\n     }\n \n     fn emit_uniq(f: fn()) {\n-        self.write_str(\"~\");\n+        self.write_str(~\"~\");\n         f();\n     }\n \n     fn emit_rec(f: fn()) {\n-        self.write_str(\"{\");\n+        self.write_str(~\"{\");\n         f();\n-        self.write_str(\"}\");\n+        self.write_str(~\"}\");\n     }\n \n-    fn emit_rec_field(f_name: str, f_idx: uint, f: fn()) {\n-        if f_idx > 0u { self.write_str(\", \"); }\n+    fn emit_rec_field(f_name: ~str, f_idx: uint, f: fn()) {\n+        if f_idx > 0u { self.write_str(~\", \"); }\n         self.write_str(f_name);\n-        self.write_str(\": \");\n+        self.write_str(~\": \");\n         f();\n     }\n \n     fn emit_tup(_sz: uint, f: fn()) {\n-        self.write_str(\"(\");\n+        self.write_str(~\"(\");\n         f();\n-        self.write_str(\")\");\n+        self.write_str(~\")\");\n     }\n \n     fn emit_tup_elt(idx: uint, f: fn()) {\n-        if idx > 0u { self.write_str(\", \"); }\n+        if idx > 0u { self.write_str(~\", \"); }\n         f();\n     }\n }\n\\ No newline at end of file"}, {"sha": "dbca5ae4e76407e47910dd5c3317127ea6205778", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -53,7 +53,7 @@ fn empty() -> rope {\n  * * this operation does not copy the string;\n  * * the function runs in linear time.\n  */\n-fn of_str(str: @str/~) -> rope {\n+fn of_str(str: @~str) -> rope {\n     ret of_substr(str, 0u, str::len(*str));\n }\n \n@@ -79,7 +79,7 @@ fn of_str(str: @str/~) -> rope {\n  * * this function does _not_ check the validity of the substring;\n  * * this function fails if `byte_offset` or `byte_len` do not match `str`.\n  */\n-fn of_substr(str: @str/~, byte_offset: uint, byte_len: uint) -> rope {\n+fn of_substr(str: @~str, byte_offset: uint, byte_len: uint) -> rope {\n     if byte_len == 0u { ret node::empty; }\n     if byte_offset + byte_len  > str::len(*str) { fail; }\n     ret node::content(node::of_substr(str, byte_offset, byte_len));\n@@ -107,7 +107,7 @@ fn append_char(rope: rope, char: char) -> rope {\n  *\n  * * this function executes in near-linear time\n  */\n-fn append_str(rope: rope, str: @str/~) -> rope {\n+fn append_str(rope: rope, str: @~str) -> rope {\n     ret append_rope(rope, of_str(str))\n }\n \n@@ -127,7 +127,7 @@ fn prepend_char(rope: rope, char: char) -> rope {\n  * # Performance note\n  * * this function executes in near-linear time\n  */\n-fn prepend_str(rope: rope, str: @str/~) -> rope {\n+fn prepend_str(rope: rope, str: @~str) -> rope {\n     ret append_rope(of_str(str), rope)\n }\n \n@@ -567,7 +567,7 @@ mod node {\n         byte_offset: uint,\n         byte_len:    uint,\n         char_len:   uint,\n-        content:    @str/~\n+        content:    @~str\n     };\n \n     /**\n@@ -627,7 +627,7 @@ mod node {\n      * Performance note: The complexity of this function is linear in\n      * the length of `str`.\n      */\n-    fn of_str(str: @str/~) -> @node {\n+    fn of_str(str: @~str) -> @node {\n         ret of_substr(str, 0u, str::len(*str));\n     }\n \n@@ -648,7 +648,7 @@ mod node {\n      * Behavior is undefined if `byte_start` or `byte_len` do not represent\n      * valid positions in `str`\n      */\n-    fn of_substr(str: @str/~, byte_start: uint, byte_len: uint) -> @node {\n+    fn of_substr(str: @~str, byte_start: uint, byte_len: uint) -> @node {\n         ret of_substr_unsafer(str, byte_start, byte_len,\n                               str::count_chars(*str, byte_start, byte_len));\n     }\n@@ -674,7 +674,7 @@ mod node {\n      * * Behavior is undefined if `char_len` does not accurately represent the\n      *   number of chars between byte_start and byte_start+byte_len\n      */\n-    fn of_substr_unsafer(str: @str/~, byte_start: uint, byte_len: uint,\n+    fn of_substr_unsafer(str: @~str, byte_start: uint, byte_len: uint,\n                           char_len: uint) -> @node {\n         assert(byte_start + byte_len <= str::len(*str));\n         let candidate = @leaf({\n@@ -799,7 +799,7 @@ mod node {\n         ret forest[0];\n     }\n \n-    fn serialize_node(node: @node) -> str unsafe {\n+    fn serialize_node(node: @node) -> ~str unsafe {\n         let mut buf = vec::to_mut(vec::from_elem(byte_len(node), 0u8));\n         let mut offset = 0u;//Current position in the buffer\n         let it = leaf_iterator::start(node);\n@@ -1237,11 +1237,11 @@ mod node {\n mod tests {\n \n     //Utility function, used for sanity check\n-    fn rope_to_string(r: rope) -> str {\n+    fn rope_to_string(r: rope) -> ~str {\n         alt(r) {\n-          node::empty { ret \"\" }\n+          node::empty { ret ~\"\" }\n           node::content(x) {\n-            let str = @mut \"\";\n+            let str = @mut ~\"\";\n             fn aux(str: @mut str, node: @node::node) unsafe {\n                 alt(*node) {\n                   node::leaf(x) {\n@@ -1270,7 +1270,7 @@ mod tests {\n \n     #[test]\n     fn of_string1() {\n-        let sample = @\"0123456789ABCDE\";\n+        let sample = @~\"0123456789ABCDE\";\n         let r      = of_str(sample);\n \n         assert char_len(r) == str::char_len(*sample);\n@@ -1279,7 +1279,7 @@ mod tests {\n \n     #[test]\n     fn of_string2() {\n-        let buf = @ mut \"1234567890\";\n+        let buf = @ mut ~\"1234567890\";\n         let mut i = 0;\n         while i < 10 { *buf = *buf + *buf; i+=1;}\n         let sample = @*buf;\n@@ -1310,7 +1310,7 @@ mod tests {\n \n     #[test]\n     fn iter1() {\n-        let buf = @ mut \"1234567890\";\n+        let buf = @ mut ~\"1234567890\";\n         let mut i = 0;\n         while i < 10 { *buf = *buf + *buf; i+=1;}\n         let sample = @*buf;\n@@ -1330,8 +1330,8 @@ mod tests {\n \n     #[test]\n     fn bal1() {\n-        let init = @ \"1234567890\";\n-        let buf  = @ mut * init;\n+        let init = @~\"1234567890\";\n+        let buf  = @mut * init;\n         let mut i = 0;\n         while i < 8 { *buf = *buf + *buf; i+=1;}\n         let sample = @*buf;\n@@ -1352,7 +1352,7 @@ mod tests {\n     #[ignore]\n     fn char_at1() {\n         //Generate a large rope\n-        let mut r = of_str(@ \"123456789\");\n+        let mut r = of_str(@~\"123456789\");\n         for uint::range(0u, 10u) |_i| {\n             r = append_rope(r, r);\n         }\n@@ -1384,7 +1384,7 @@ mod tests {\n     #[test]\n     fn concat1() {\n         //Generate a reasonable rope\n-        let chunk = of_str(@ \"123456789\");\n+        let chunk = of_str(@~\"123456789\");\n         let mut r = empty();\n         for uint::range(0u, 10u) |_i| {\n             r = append_rope(r, chunk);"}, {"sha": "ba20ff88e3dbfe40d3d6fdb36c5401c4ff572574", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -23,18 +23,18 @@ iface serializer {\n     fn emit_float(v: float);\n     fn emit_f64(v: f64);\n     fn emit_f32(v: f32);\n-    fn emit_str(v: str);\n+    fn emit_str(v: ~str);\n \n     // Compound types:\n-    fn emit_enum(name: str, f: fn());\n-    fn emit_enum_variant(v_name: str, v_id: uint, sz: uint, f: fn());\n+    fn emit_enum(name: ~str, f: fn());\n+    fn emit_enum_variant(v_name: ~str, v_id: uint, sz: uint, f: fn());\n     fn emit_enum_variant_arg(idx: uint, f: fn());\n     fn emit_vec(len: uint, f: fn());\n     fn emit_vec_elt(idx: uint, f: fn());\n     fn emit_box(f: fn());\n     fn emit_uniq(f: fn());\n     fn emit_rec(f: fn());\n-    fn emit_rec_field(f_name: str, f_idx: uint, f: fn());\n+    fn emit_rec_field(f_name: ~str, f_idx: uint, f: fn());\n     fn emit_tup(sz: uint, f: fn());\n     fn emit_tup_elt(idx: uint, f: fn());\n }\n@@ -58,22 +58,22 @@ iface deserializer {\n \n     fn read_bool() -> bool;\n \n-    fn read_str() -> str;\n+    fn read_str() -> ~str;\n \n     fn read_f64() -> f64;\n     fn read_f32() -> f32;\n     fn read_float() -> float;\n \n     // Compound types:\n-    fn read_enum<T:copy>(name: str, f: fn() -> T) -> T;\n+    fn read_enum<T:copy>(name: ~str, f: fn() -> T) -> T;\n     fn read_enum_variant<T:copy>(f: fn(uint) -> T) -> T;\n     fn read_enum_variant_arg<T:copy>(idx: uint, f: fn() -> T) -> T;\n     fn read_vec<T:copy>(f: fn(uint) -> T) -> T;\n     fn read_vec_elt<T:copy>(idx: uint, f: fn() -> T) -> T;\n     fn read_box<T:copy>(f: fn() -> T) -> T;\n     fn read_uniq<T:copy>(f: fn() -> T) -> T;\n     fn read_rec<T:copy>(f: fn() -> T) -> T;\n-    fn read_rec_field<T:copy>(f_name: str, f_idx: uint, f: fn() -> T) -> T;\n+    fn read_rec_field<T:copy>(f_name: ~str, f_idx: uint, f: fn() -> T) -> T;\n     fn read_tup<T:copy>(sz: uint, f: fn() -> T) -> T;\n     fn read_tup_elt<T:copy>(idx: uint, f: fn() -> T) -> T;\n }\n@@ -193,11 +193,11 @@ fn deserialize_i64<D: deserializer>(d: D) -> i64 {\n     d.read_i64()\n }\n \n-fn serialize_str<S: serializer>(s: S, v: str) {\n+fn serialize_str<S: serializer>(s: S, v: ~str) {\n     s.emit_str(v);\n }\n \n-fn deserialize_str<D: deserializer>(d: D) -> str {\n+fn deserialize_str<D: deserializer>(d: D) -> ~str {\n     d.read_str()\n }\n \n@@ -234,15 +234,15 @@ fn deserialize_bool<D: deserializer>(d: D) -> bool {\n }\n \n fn serialize_option<S: serializer,T>(s: S, v: option<T>, st: fn(T)) {\n-    do s.emit_enum(\"option\") {\n+    do s.emit_enum(~\"option\") {\n         alt v {\n           none {\n-            do s.emit_enum_variant(\"none\", 0u, 0u) {\n+            do s.emit_enum_variant(~\"none\", 0u, 0u) {\n             }\n           }\n \n           some(v) {\n-            do s.emit_enum_variant(\"some\", 1u, 1u) {\n+            do s.emit_enum_variant(~\"some\", 1u, 1u) {\n                 do s.emit_enum_variant_arg(0u) {\n                     st(v)\n                 }\n@@ -254,7 +254,7 @@ fn serialize_option<S: serializer,T>(s: S, v: option<T>, st: fn(T)) {\n \n fn deserialize_option<D: deserializer,T: copy>(d: D, st: fn() -> T)\n     -> option<T> {\n-    do d.read_enum(\"option\") {\n+    do d.read_enum(~\"option\") {\n         do d.read_enum_variant |i| {\n             alt check i {\n               0u { // none"}, {"sha": "71f8fff28577e7c03ebe9038c49fb87fde39d7a5", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -24,7 +24,7 @@ iface sha1 {\n     /// Provide message input as bytes\n     fn input(~[u8]);\n     /// Provide message input as string\n-    fn input_str(str);\n+    fn input_str(~str);\n     /**\n      * Read the digest as a vector of 20 bytes. After calling this no further\n      * input may be provided until reset is called.\n@@ -34,7 +34,7 @@ iface sha1 {\n      * Read the digest as a hex string. After calling this no further\n      * input may be provided until reset is called.\n      */\n-    fn result_str() -> str;\n+    fn result_str() -> ~str;\n     /// Reset the SHA-1 state for reuse\n     fn reset();\n }\n@@ -232,11 +232,11 @@ fn sha1() -> sha1 {\n             self.computed = false;\n         }\n         fn input(msg: ~[u8]) { add_input(self, msg); }\n-        fn input_str(msg: str) { add_input(self, str::bytes(msg)); }\n+        fn input_str(msg: ~str) { add_input(self, str::bytes(msg)); }\n         fn result() -> ~[u8] { ret mk_result(self); }\n-        fn result_str() -> str {\n+        fn result_str() -> ~str {\n             let r = mk_result(self);\n-            let mut s = \"\";\n+            let mut s = ~\"\";\n             for vec::each(r) |b| { s += uint::to_str(b as uint, 16u); }\n             ret s;\n         }\n@@ -260,27 +260,27 @@ mod tests {\n \n     #[test]\n     fn test() unsafe {\n-        type test = {input: str, output: ~[u8]};\n+        type test = {input: ~str, output: ~[u8]};\n \n-        fn a_million_letter_a() -> str {\n+        fn a_million_letter_a() -> ~str {\n             let mut i = 0;\n-            let mut rs = \"\";\n-            while i < 100000 { str::push_str(rs, \"aaaaaaaaaa\"); i += 1; }\n+            let mut rs = ~\"\";\n+            while i < 100000 { str::push_str(rs, ~\"aaaaaaaaaa\"); i += 1; }\n             ret rs;\n         }\n         // Test messages from FIPS 180-1\n \n         let fips_180_1_tests: ~[test] =\n-            ~[{input: \"abc\",\n+            ~[{input: ~\"abc\",\n               output:\n                   ~[0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n                    0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n                    0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n                    0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n                    0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8]},\n              {input:\n-                  \"abcdbcdecdefdefgefghfghighij\" +\n-                  \"hijkijkljklmklmnlmnomnopnopq\",\n+                  ~\"abcdbcdecdefdefgefghfghighij\" +\n+                  ~\"hijkijkljklmklmnlmnomnopnopq\",\n               output:\n                   ~[0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n                    0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n@@ -297,14 +297,14 @@ mod tests {\n         // Examples from wikipedia\n \n         let wikipedia_tests: ~[test] =\n-            ~[{input: \"The quick brown fox jumps over the lazy dog\",\n+            ~[{input: ~\"The quick brown fox jumps over the lazy dog\",\n               output:\n                   ~[0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n                    0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n                    0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n                    0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n                    0x1bu8, 0x93u8, 0xebu8, 0x12u8]},\n-             {input: \"The quick brown fox jumps over the lazy cog\",\n+             {input: ~\"The quick brown fox jumps over the lazy cog\",\n               output:\n                   ~[0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n                    0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,"}, {"sha": "b6f5c81f57e7ef484f77aed8bf8e7887e74e3644", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -5,7 +5,7 @@ import option::{none, some};\n import rand;\n import core::rand::extensions;\n \n-fn mkdtemp(prefix: str, suffix: str) -> option<str> {\n+fn mkdtemp(prefix: ~str, suffix: ~str) -> option<~str> {\n     let r = rand::rng();\n     let mut i = 0u;\n     while (i < 1000u) {\n@@ -20,11 +20,11 @@ fn mkdtemp(prefix: str, suffix: str) -> option<str> {\n \n #[test]\n fn test_mkdtemp() {\n-    let r = mkdtemp(\"./\", \"foobar\");\n+    let r = mkdtemp(~\"./\", ~\"foobar\");\n     alt r {\n         some(p) {\n             os::remove_dir(p);\n-            assert(str::ends_with(p, \"foobar\"));\n+            assert(str::ends_with(p, ~\"foobar\"));\n         }\n         _ { assert(false); }\n     }"}, {"sha": "aa2d52822be6f5dce597600cf66d359aed9de0bf", "filename": "src/libstd/term.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -33,9 +33,9 @@ fn reset(writer: io::writer) {\n \n /// Returns true if the terminal supports color\n fn color_supported() -> bool {\n-    let supported_terms = ~[\"xterm-color\", \"xterm\",\n-                           \"screen-bce\", \"xterm-256color\"];\n-    ret alt os::getenv(\"TERM\") {\n+    let supported_terms = ~[~\"xterm-color\", ~\"xterm\",\n+                           ~\"screen-bce\", ~\"xterm-256color\"];\n+    ret alt os::getenv(~\"TERM\") {\n           option::some(env) {\n             for vec::each(supported_terms) |term| {\n                 if str::eq(term, env) { ret true; }"}, {"sha": "d42bca74508818de5796654a75d428f27c916640", "filename": "src/libstd/test.rs", "status": "modified", "additions": 53, "deletions": 51, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -30,7 +30,7 @@ extern mod rustrt {\n // paths; i.e. it should be a series of identifiers seperated by double\n // colons. This way if some test runner wants to arrange the tests\n // hierarchically it may.\n-type test_name = str;\n+type test_name = ~str;\n \n // A function that runs a test. If the function returns successfully,\n // the test succeeds; if the function fails then the test fails. We\n@@ -49,24 +49,24 @@ type test_desc = {\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs (generated at compile time).\n-fn test_main(args: ~[str], tests: ~[test_desc]) {\n+fn test_main(args: ~[~str], tests: ~[test_desc]) {\n     let opts =\n         alt parse_opts(args) {\n           either::left(o) { o }\n           either::right(m) { fail m }\n         };\n-    if !run_tests_console(opts, tests) { fail \"Some tests failed\"; }\n+    if !run_tests_console(opts, tests) { fail ~\"Some tests failed\"; }\n }\n \n-type test_opts = {filter: option<str>, run_ignored: bool,\n-                  logfile: option<str>};\n+type test_opts = {filter: option<~str>, run_ignored: bool,\n+                  logfile: option<~str>};\n \n-type opt_res = either<test_opts, str>;\n+type opt_res = either<test_opts, ~str>;\n \n // Parses command line arguments into test options\n-fn parse_opts(args: ~[str]) -> opt_res {\n+fn parse_opts(args: ~[~str]) -> opt_res {\n     let args_ = vec::tail(args);\n-    let opts = ~[getopts::optflag(\"ignored\"), getopts::optopt(\"logfile\")];\n+    let opts = ~[getopts::optflag(~\"ignored\"), getopts::optopt(~\"logfile\")];\n     let match =\n         alt getopts::getopts(args_, opts) {\n           ok(m) { m }\n@@ -78,8 +78,8 @@ fn parse_opts(args: ~[str]) -> opt_res {\n             option::some(match.free[0])\n         } else { option::none };\n \n-    let run_ignored = getopts::opt_present(match, \"ignored\");\n-    let logfile = getopts::opt_maybe_str(match, \"logfile\");\n+    let run_ignored = getopts::opt_present(match, ~\"ignored\");\n+    let logfile = getopts::opt_maybe_str(match, ~\"logfile\");\n \n     let test_opts = {filter: filter, run_ignored: run_ignored,\n                      logfile: logfile};\n@@ -107,7 +107,7 @@ fn run_tests_console(opts: test_opts,\n         alt event {\n           te_filtered(filtered_tests) {\n             st.total = vec::len(filtered_tests);\n-            let noun = if st.total != 1u { \"tests\" } else { \"test\" };\n+            let noun = if st.total != 1u { ~\"tests\" } else { ~\"test\" };\n             st.out.write_line(#fmt[\"\\nrunning %u %s\", st.total, noun]);\n           }\n           te_wait(test) { st.out.write_str(#fmt[\"test %s ... \", test.name]); }\n@@ -122,18 +122,18 @@ fn run_tests_console(opts: test_opts,\n               tr_ok {\n                 st.passed += 1u;\n                 write_ok(st.out, st.use_color);\n-                st.out.write_line(\"\");\n+                st.out.write_line(~\"\");\n               }\n               tr_failed {\n                 st.failed += 1u;\n                 write_failed(st.out, st.use_color);\n-                st.out.write_line(\"\");\n+                st.out.write_line(~\"\");\n                 vec::push(st.failures, copy test);\n               }\n               tr_ignored {\n                 st.ignored += 1u;\n                 write_ignored(st.out, st.use_color);\n-                st.out.write_line(\"\");\n+                st.out.write_line(~\"\");\n               }\n             }\n           }\n@@ -184,25 +184,25 @@ fn run_tests_console(opts: test_opts,\n     fn write_log(out: io::writer, result: test_result, test: test_desc) {\n         out.write_line(#fmt(\"%s %s\",\n                     alt result {\n-                        tr_ok { \"ok\" }\n-                        tr_failed { \"failed\" }\n-                        tr_ignored { \"ignored\" }\n+                        tr_ok { ~\"ok\" }\n+                        tr_failed { ~\"failed\" }\n+                        tr_ignored { ~\"ignored\" }\n                     }, test.name));\n     }\n \n     fn write_ok(out: io::writer, use_color: bool) {\n-        write_pretty(out, \"ok\", term::color_green, use_color);\n+        write_pretty(out, ~\"ok\", term::color_green, use_color);\n     }\n \n     fn write_failed(out: io::writer, use_color: bool) {\n-        write_pretty(out, \"FAILED\", term::color_red, use_color);\n+        write_pretty(out, ~\"FAILED\", term::color_red, use_color);\n     }\n \n     fn write_ignored(out: io::writer, use_color: bool) {\n-        write_pretty(out, \"ignored\", term::color_yellow, use_color);\n+        write_pretty(out, ~\"ignored\", term::color_yellow, use_color);\n     }\n \n-    fn write_pretty(out: io::writer, word: str, color: u8, use_color: bool) {\n+    fn write_pretty(out: io::writer, word: ~str, color: u8, use_color: bool) {\n         if use_color && term::color_supported() {\n             term::fg(out, color);\n         }\n@@ -214,7 +214,7 @@ fn run_tests_console(opts: test_opts,\n }\n \n fn print_failures(st: console_test_state) {\n-    st.out.write_line(\"\\nfailures:\");\n+    st.out.write_line(~\"\\nfailures:\");\n     let failures = copy st.failures;\n     let failures = vec::map(failures, |test| test.name);\n     let failures = sort::merge_sort(str::le, failures);\n@@ -229,14 +229,14 @@ fn should_sort_failures_before_printing_them() {\n     let writer = io::mem_buffer_writer(buffer);\n \n     let test_a = {\n-        name: \"a\",\n+        name: ~\"a\",\n         fn: fn~() { },\n         ignore: false,\n         should_fail: false\n     };\n \n     let test_b = {\n-        name: \"b\",\n+        name: ~\"b\",\n         fn: fn~() { },\n         ignore: false,\n         should_fail: false\n@@ -256,8 +256,8 @@ fn should_sort_failures_before_printing_them() {\n \n     let s = io::mem_buffer_str(buffer);\n \n-    let apos = option::get(str::find_str(s, \"a\"));\n-    let bpos = option::get(str::find_str(s, \"b\"));\n+    let apos = option::get(str::find_str(s, ~\"a\"));\n+    let bpos = option::get(str::find_str(s, ~\"b\"));\n     assert apos < bpos;\n }\n \n@@ -339,10 +339,10 @@ fn filter_tests(opts: test_opts,\n         let filter_str =\n             alt opts.filter {\n           option::some(f) { f }\n-          option::none { \"\" }\n+          option::none { ~\"\" }\n         };\n \n-        fn filter_fn(test: test_desc, filter_str: str) ->\n+        fn filter_fn(test: test_desc, filter_str: ~str) ->\n             option<test_desc> {\n             if str::contains(test.name, filter_str) {\n                 ret option::some(copy test);\n@@ -419,7 +419,7 @@ mod tests {\n     fn do_not_run_ignored_tests() {\n         fn f() { fail; }\n         let desc = {\n-            name: \"whatever\",\n+            name: ~\"whatever\",\n             fn: f,\n             ignore: true,\n             should_fail: false\n@@ -435,7 +435,7 @@ mod tests {\n     fn ignored_tests_result_in_ignored() {\n         fn f() { }\n         let desc = {\n-            name: \"whatever\",\n+            name: ~\"whatever\",\n             fn: f,\n             ignore: true,\n             should_fail: false\n@@ -452,7 +452,7 @@ mod tests {\n     fn test_should_fail() {\n         fn f() { fail; }\n         let desc = {\n-            name: \"whatever\",\n+            name: ~\"whatever\",\n             fn: f,\n             ignore: false,\n             should_fail: true\n@@ -468,7 +468,7 @@ mod tests {\n     fn test_should_fail_but_succeeds() {\n         fn f() { }\n         let desc = {\n-            name: \"whatever\",\n+            name: ~\"whatever\",\n             fn: f,\n             ignore: false,\n             should_fail: true\n@@ -482,17 +482,17 @@ mod tests {\n \n     #[test]\n     fn first_free_arg_should_be_a_filter() {\n-        let args = ~[\"progname\", \"filter\"];\n+        let args = ~[~\"progname\", ~\"filter\"];\n         let opts = alt parse_opts(args) { either::left(o) { o }\n-          _ { fail \"Malformed arg in first_free_arg_should_be_a_filter\"; } };\n-        assert (str::eq(\"filter\", option::get(opts.filter)));\n+          _ { fail ~\"Malformed arg in first_free_arg_should_be_a_filter\"; } };\n+        assert (str::eq(~\"filter\", option::get(opts.filter)));\n     }\n \n     #[test]\n     fn parse_ignored_flag() {\n-        let args = ~[\"progname\", \"filter\", \"--ignored\"];\n+        let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n         let opts = alt parse_opts(args) { either::left(o) { o }\n-          _ { fail \"Malformed arg in parse_ignored_flag\"; } };\n+          _ { fail ~\"Malformed arg in parse_ignored_flag\"; } };\n         assert (opts.run_ignored);\n     }\n \n@@ -504,12 +504,12 @@ mod tests {\n         let opts = {filter: option::none, run_ignored: true,\n             logfile: option::none};\n         let tests =\n-            ~[{name: \"1\", fn: fn~() { }, ignore: true, should_fail: false},\n-             {name: \"2\", fn: fn~() { }, ignore: false, should_fail: false}];\n+            ~[{name: ~\"1\", fn: fn~() { }, ignore: true, should_fail: false},\n+             {name: ~\"2\", fn: fn~() { }, ignore: false, should_fail: false}];\n         let filtered = filter_tests(opts, tests);\n \n         assert (vec::len(filtered) == 1u);\n-        assert (filtered[0].name == \"1\");\n+        assert (filtered[0].name == ~\"1\");\n         assert (filtered[0].ignore == false);\n     }\n \n@@ -519,12 +519,12 @@ mod tests {\n             logfile: option::none};\n \n         let names =\n-            ~[\"sha1::test\", \"int::test_to_str\", \"int::test_pow\",\n-             \"test::do_not_run_ignored_tests\",\n-             \"test::ignored_tests_result_in_ignored\",\n-             \"test::first_free_arg_should_be_a_filter\",\n-             \"test::parse_ignored_flag\", \"test::filter_for_ignored_option\",\n-             \"test::sort_tests\"];\n+            ~[~\"sha1::test\", ~\"int::test_to_str\", ~\"int::test_pow\",\n+             ~\"test::do_not_run_ignored_tests\",\n+             ~\"test::ignored_tests_result_in_ignored\",\n+             ~\"test::first_free_arg_should_be_a_filter\",\n+             ~\"test::parse_ignored_flag\", ~\"test::filter_for_ignored_option\",\n+             ~\"test::sort_tests\"];\n         let tests =\n         {\n         let testfn = fn~() { };\n@@ -539,11 +539,13 @@ mod tests {\n     let filtered = filter_tests(opts, tests);\n \n     let expected =\n-        ~[\"int::test_pow\", \"int::test_to_str\", \"sha1::test\",\n-         \"test::do_not_run_ignored_tests\", \"test::filter_for_ignored_option\",\n-         \"test::first_free_arg_should_be_a_filter\",\n-         \"test::ignored_tests_result_in_ignored\", \"test::parse_ignored_flag\",\n-         \"test::sort_tests\"];\n+        ~[~\"int::test_pow\", ~\"int::test_to_str\", ~\"sha1::test\",\n+          ~\"test::do_not_run_ignored_tests\",\n+          ~\"test::filter_for_ignored_option\",\n+          ~\"test::first_free_arg_should_be_a_filter\",\n+          ~\"test::ignored_tests_result_in_ignored\",\n+          ~\"test::parse_ignored_flag\",\n+          ~\"test::sort_tests\"];\n \n     let pairs = vec::zip(expected, filtered);\n "}, {"sha": "553592b10bdcb62575e834a24aa2e12e8228aa69", "filename": "src/libstd/time.rs", "status": "modified", "additions": 296, "deletions": 295, "changes": 591, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -76,7 +76,7 @@ type tm = {\n     tm_yday: i32, // days since January 1 ~[0-365]\n     tm_isdst: i32, // Daylight Savings Time flag\n     tm_gmtoff: i32, // offset from UTC in seconds\n-    tm_zone: str, // timezone abbreviation\n+    tm_zone: ~str, // timezone abbreviation\n     tm_nsec: i32, // nanoseconds\n };\n \n@@ -92,7 +92,7 @@ fn empty_tm() -> tm {\n         tm_yday: 0_i32,\n         tm_isdst: 0_i32,\n         tm_gmtoff: 0_i32,\n-        tm_zone: \"\",\n+        tm_zone: ~\"\",\n         tm_nsec: 0_i32,\n     }\n }\n@@ -124,7 +124,7 @@ fn now() -> tm {\n }\n \n /// Parses the time from the string according to the format string.\n-fn strptime(s: str, format: str) -> result<tm, str> {\n+fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n     type tm_mut = {\n        mut tm_sec: i32,\n        mut tm_min: i32,\n@@ -136,11 +136,11 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n        mut tm_yday: i32,\n        mut tm_isdst: i32,\n        mut tm_gmtoff: i32,\n-       mut tm_zone: str,\n+       mut tm_zone: ~str,\n        mut tm_nsec: i32,\n     };\n \n-    fn match_str(s: str, pos: uint, needle: str) -> bool {\n+    fn match_str(s: ~str, pos: uint, needle: ~str) -> bool {\n         let mut i = pos;\n         for str::each(needle) |ch| {\n             if s[i] != ch {\n@@ -151,7 +151,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n         ret true;\n     }\n \n-    fn match_strs(s: str, pos: uint, strs: ~[(str, i32)])\n+    fn match_strs(s: ~str, pos: uint, strs: ~[(~str, i32)])\n       -> option<(i32, uint)> {\n         let mut i = 0u;\n         let len = vec::len(strs);\n@@ -167,7 +167,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n         none\n     }\n \n-    fn match_digits(s: str, pos: uint, digits: uint, ws: bool)\n+    fn match_digits(s: ~str, pos: uint, digits: uint, ws: bool)\n       -> option<(i32, uint)> {\n         let mut pos = pos;\n         let mut value = 0_i32;\n@@ -190,7 +190,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n         some((value, pos))\n     }\n \n-    fn parse_char(s: str, pos: uint, c: char) -> result<uint, str> {\n+    fn parse_char(s: ~str, pos: uint, c: char) -> result<uint, ~str> {\n         let {ch, next} = str::char_range_at(s, pos);\n \n         if c == ch {\n@@ -202,73 +202,73 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n         }\n     }\n \n-    fn parse_type(s: str, pos: uint, ch: char, tm: tm_mut)\n-      -> result<uint, str> {\n+    fn parse_type(s: ~str, pos: uint, ch: char, tm: tm_mut)\n+      -> result<uint, ~str> {\n         alt ch {\n           'A' {\n             alt match_strs(s, pos, ~[\n-                (\"Sunday\", 0_i32),\n-                (\"Monday\", 1_i32),\n-                (\"Tuesday\", 2_i32),\n-                (\"Wednesday\", 3_i32),\n-                (\"Thursday\", 4_i32),\n-                (\"Friday\", 5_i32),\n-                (\"Saturday\", 6_i32)\n+                (~\"Sunday\", 0_i32),\n+                (~\"Monday\", 1_i32),\n+                (~\"Tuesday\", 2_i32),\n+                (~\"Wednesday\", 3_i32),\n+                (~\"Thursday\", 4_i32),\n+                (~\"Friday\", 5_i32),\n+                (~\"Saturday\", 6_i32)\n             ]) {\n               some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n-              none { err(\"Invalid day\") }\n+              none { err(~\"Invalid day\") }\n             }\n           }\n           'a' {\n             alt match_strs(s, pos, ~[\n-                (\"Sun\", 0_i32),\n-                (\"Mon\", 1_i32),\n-                (\"Tue\", 2_i32),\n-                (\"Wed\", 3_i32),\n-                (\"Thu\", 4_i32),\n-                (\"Fri\", 5_i32),\n-                (\"Sat\", 6_i32)\n+                (~\"Sun\", 0_i32),\n+                (~\"Mon\", 1_i32),\n+                (~\"Tue\", 2_i32),\n+                (~\"Wed\", 3_i32),\n+                (~\"Thu\", 4_i32),\n+                (~\"Fri\", 5_i32),\n+                (~\"Sat\", 6_i32)\n             ]) {\n               some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n-              none { err(\"Invalid day\") }\n+              none { err(~\"Invalid day\") }\n             }\n           }\n           'B' {\n             alt match_strs(s, pos, ~[\n-                (\"January\", 0_i32),\n-                (\"February\", 1_i32),\n-                (\"March\", 2_i32),\n-                (\"April\", 3_i32),\n-                (\"May\", 4_i32),\n-                (\"June\", 5_i32),\n-                (\"July\", 6_i32),\n-                (\"August\", 7_i32),\n-                (\"September\", 8_i32),\n-                (\"October\", 9_i32),\n-                (\"November\", 10_i32),\n-                (\"December\", 11_i32)\n+                (~\"January\", 0_i32),\n+                (~\"February\", 1_i32),\n+                (~\"March\", 2_i32),\n+                (~\"April\", 3_i32),\n+                (~\"May\", 4_i32),\n+                (~\"June\", 5_i32),\n+                (~\"July\", 6_i32),\n+                (~\"August\", 7_i32),\n+                (~\"September\", 8_i32),\n+                (~\"October\", 9_i32),\n+                (~\"November\", 10_i32),\n+                (~\"December\", 11_i32)\n             ]) {\n               some(item) { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n-              none { err(\"Invalid month\") }\n+              none { err(~\"Invalid month\") }\n             }\n           }\n           'b' | 'h' {\n             alt match_strs(s, pos, ~[\n-                (\"Jan\", 0_i32),\n-                (\"Feb\", 1_i32),\n-                (\"Mar\", 2_i32),\n-                (\"Apr\", 3_i32),\n-                (\"May\", 4_i32),\n-                (\"Jun\", 5_i32),\n-                (\"Jul\", 6_i32),\n-                (\"Aug\", 7_i32),\n-                (\"Sep\", 8_i32),\n-                (\"Oct\", 9_i32),\n-                (\"Nov\", 10_i32),\n-                (\"Dec\", 11_i32)\n+                (~\"Jan\", 0_i32),\n+                (~\"Feb\", 1_i32),\n+                (~\"Mar\", 2_i32),\n+                (~\"Apr\", 3_i32),\n+                (~\"May\", 4_i32),\n+                (~\"Jun\", 5_i32),\n+                (~\"Jul\", 6_i32),\n+                (~\"Aug\", 7_i32),\n+                (~\"Sep\", 8_i32),\n+                (~\"Oct\", 9_i32),\n+                (~\"Nov\", 10_i32),\n+                (~\"Dec\", 11_i32)\n             ]) {\n               some(item) { let (v, pos) = item; tm.tm_mon = v; ok(pos) }\n-              none { err(\"Invalid month\") }\n+              none { err(~\"Invalid month\") }\n             }\n           }\n           'C' {\n@@ -278,7 +278,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                 tm.tm_year += (v * 100_i32) - 1900_i32;\n                 ok(pos)\n               }\n-              none { err(\"Invalid year\") }\n+              none { err(~\"Invalid year\") }\n             }\n           }\n           'c' {\n@@ -302,13 +302,13 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n           'd' {\n             alt match_digits(s, pos, 2u, false) {\n               some(item) { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n-              none { err(\"Invalid day of the month\") }\n+              none { err(~\"Invalid day of the month\") }\n             }\n           }\n           'e' {\n             alt match_digits(s, pos, 2u, true) {\n               some(item) { let (v, pos) = item; tm.tm_mday = v; ok(pos) }\n-              none { err(\"Invalid day of the month\") }\n+              none { err(~\"Invalid day of the month\") }\n             }\n           }\n           'F' {\n@@ -322,7 +322,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n               some(item) { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n-              none { err(\"Invalid hour\") }\n+              none { err(~\"Invalid hour\") }\n             }\n           }\n           'I' {\n@@ -333,7 +333,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n                   ok(pos)\n               }\n-              none { err(\"Invalid hour\") }\n+              none { err(~\"Invalid hour\") }\n             }\n           }\n           'j' {\n@@ -344,14 +344,14 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                 tm.tm_yday = v - 1_i32;\n                 ok(pos)\n               }\n-              none { err(\"Invalid year\") }\n+              none { err(~\"Invalid year\") }\n             }\n           }\n           'k' {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, true) {\n               some(item) { let (v, pos) = item; tm.tm_hour = v; ok(pos) }\n-              none { err(\"Invalid hour\") }\n+              none { err(~\"Invalid hour\") }\n             }\n           }\n           'l' {\n@@ -362,14 +362,14 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                   tm.tm_hour = if v == 12_i32 { 0_i32 } else { v };\n                   ok(pos)\n               }\n-              none { err(\"Invalid hour\") }\n+              none { err(~\"Invalid hour\") }\n             }\n           }\n           'M' {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 2u, false) {\n               some(item) { let (v, pos) = item; tm.tm_min = v; ok(pos) }\n-              none { err(\"Invalid minute\") }\n+              none { err(~\"Invalid minute\") }\n             }\n           }\n           'm' {\n@@ -380,20 +380,20 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                 tm.tm_mon = v - 1_i32;\n                 ok(pos)\n               }\n-              none { err(\"Invalid month\") }\n+              none { err(~\"Invalid month\") }\n             }\n           }\n           'n' { parse_char(s, pos, '\\n') }\n           'P' {\n-            alt match_strs(s, pos, ~[(\"am\", 0_i32), (\"pm\", 12_i32)]) {\n+            alt match_strs(s, pos, ~[(~\"am\", 0_i32), (~\"pm\", 12_i32)]) {\n               some(item) { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n-              none { err(\"Invalid hour\") }\n+              none { err(~\"Invalid hour\") }\n             }\n           }\n           'p' {\n-            alt match_strs(s, pos, ~[(\"AM\", 0_i32), (\"PM\", 12_i32)]) {\n+            alt match_strs(s, pos, ~[(~\"AM\", 0_i32), (~\"PM\", 12_i32)]) {\n               some(item) { let (v, pos) = item; tm.tm_hour += v; ok(pos) }\n-              none { err(\"Invalid hour\") }\n+              none { err(~\"Invalid hour\") }\n             }\n           }\n           'R' {\n@@ -418,7 +418,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                 tm.tm_sec = v;\n                 ok(pos)\n               }\n-              none { err(\"Invalid second\") }\n+              none { err(~\"Invalid second\") }\n             }\n           }\n           //'s' {}\n@@ -438,7 +438,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                 tm.tm_wday = v;\n                 ok(pos)\n               }\n-              none { err(\"Invalid weekday\") }\n+              none { err(~\"Invalid weekday\") }\n             }\n           }\n           'v' {\n@@ -453,7 +453,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n             // FIXME (#2350): range check.\n             alt match_digits(s, pos, 1u, false) {\n               some(item) { let (v, pos) = item; tm.tm_wday = v; ok(pos) }\n-              none { err(\"Invalid weekday\") }\n+              none { err(~\"Invalid weekday\") }\n             }\n           }\n           //'X' {}\n@@ -466,7 +466,7 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                 tm.tm_year = v - 1900_i32;\n                 ok(pos)\n               }\n-              none { err(\"Invalid weekday\") }\n+              none { err(~\"Invalid weekday\") }\n             }\n           }\n           'y' {\n@@ -477,13 +477,13 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                 tm.tm_year = v - 1900_i32;\n                 ok(pos)\n               }\n-              none { err(\"Invalid weekday\") }\n+              none { err(~\"Invalid weekday\") }\n             }\n           }\n           'Z' {\n-            if match_str(s, pos, \"UTC\") || match_str(s, pos, \"GMT\") {\n+            if match_str(s, pos, ~\"UTC\") || match_str(s, pos, ~\"GMT\") {\n                 tm.tm_gmtoff = 0_i32;\n-                tm.tm_zone = \"UTC\";\n+                tm.tm_zone = ~\"UTC\";\n                 ok(pos + 3u)\n             } else {\n                 // It's odd, but to maintain compatibility with c's\n@@ -508,15 +508,15 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n                     let (v, pos) = item;\n                     if v == 0_i32 {\n                         tm.tm_gmtoff = 0_i32;\n-                        tm.tm_zone = \"UTC\";\n+                        tm.tm_zone = ~\"UTC\";\n                     }\n \n                     ok(pos)\n                   }\n-                  none { err(\"Invalid zone offset\") }\n+                  none { err(~\"Invalid zone offset\") }\n                 }\n             } else {\n-                err(\"Invalid zone offset\")\n+                err(~\"Invalid zone offset\")\n             }\n           }\n           '%' { parse_char(s, pos, '%') }\n@@ -538,12 +538,12 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n             mut tm_yday: 0_i32,\n             mut tm_isdst: 0_i32,\n             mut tm_gmtoff: 0_i32,\n-            mut tm_zone: \"\",\n+            mut tm_zone: ~\"\",\n             mut tm_nsec: 0_i32,\n         };\n         let mut pos = 0u;\n         let len = str::len(s);\n-        let mut result = err(\"Invalid time\");\n+        let mut result = err(~\"Invalid time\");\n \n         while !rdr.eof() && pos < len {\n             let {ch, next} = str::char_range_at(s, pos);\n@@ -581,62 +581,62 @@ fn strptime(s: str, format: str) -> result<tm, str> {\n     }\n }\n \n-fn strftime(format: str, tm: tm) -> str {\n-    fn parse_type(ch: char, tm: tm) -> str {\n+fn strftime(format: ~str, tm: tm) -> ~str {\n+    fn parse_type(ch: char, tm: tm) -> ~str {\n         //FIXME (#2350): Implement missing types.\n         alt check ch {\n           'A' {\n             alt check tm.tm_wday as int {\n-              0 { \"Sunday\" }\n-              1 { \"Monday\" }\n-              2 { \"Tuesday\" }\n-              3 { \"Wednesday\" }\n-              4 { \"Thursday\" }\n-              5 { \"Friday\" }\n-              6 { \"Saturday\" }\n+              0 { ~\"Sunday\" }\n+              1 { ~\"Monday\" }\n+              2 { ~\"Tuesday\" }\n+              3 { ~\"Wednesday\" }\n+              4 { ~\"Thursday\" }\n+              5 { ~\"Friday\" }\n+              6 { ~\"Saturday\" }\n             }\n           }\n           'a' {\n             alt check tm.tm_wday as int {\n-              0 { \"Sun\" }\n-              1 { \"Mon\" }\n-              2 { \"Tue\" }\n-              3 { \"Wed\" }\n-              4 { \"Thu\" }\n-              5 { \"Fri\" }\n-              6 { \"Sat\" }\n+              0 { ~\"Sun\" }\n+              1 { ~\"Mon\" }\n+              2 { ~\"Tue\" }\n+              3 { ~\"Wed\" }\n+              4 { ~\"Thu\" }\n+              5 { ~\"Fri\" }\n+              6 { ~\"Sat\" }\n             }\n           }\n           'B' {\n             alt check tm.tm_mon as int {\n-              0 { \"January\" }\n-              1 { \"February\" }\n-              2 { \"March\" }\n-              3 { \"April\" }\n-              4 { \"May\" }\n-              5 { \"June\" }\n-              6 { \"July\" }\n-              7 { \"August\" }\n-              8 { \"September\" }\n-              9 { \"October\" }\n-              10 { \"November\" }\n-              11 { \"December\" }\n+              0 { ~\"January\" }\n+              1 { ~\"February\" }\n+              2 { ~\"March\" }\n+              3 { ~\"April\" }\n+              4 { ~\"May\" }\n+              5 { ~\"June\" }\n+              6 { ~\"July\" }\n+              7 { ~\"August\" }\n+              8 { ~\"September\" }\n+              9 { ~\"October\" }\n+              10 { ~\"November\" }\n+              11 { ~\"December\" }\n             }\n           }\n           'b' | 'h' {\n             alt check tm.tm_mon as int {\n-              0 { \"Jan\" }\n-              1 { \"Feb\" }\n-              2 { \"Mar\" }\n-              3 { \"Apr\" }\n-              4 { \"May\" }\n-              5 { \"Jun\" }\n-              6 { \"Jul\" }\n-              7 { \"Aug\" }\n-              8 { \"Sep\" }\n-              9 { \"Oct\" }\n-              10 { \"Nov\" }\n-              11 { \"Dec\" }\n+              0 { ~\"Jan\" }\n+              1 { ~\"Feb\" }\n+              2 { ~\"Mar\" }\n+              3 { ~\"Apr\" }\n+              4 { ~\"May\" }\n+              5 { ~\"Jun\" }\n+              6 { ~\"Jul\" }\n+              7 { ~\"Aug\" }\n+              8 { ~\"Sep\" }\n+              9 { ~\"Oct\" }\n+              10 { ~\"Nov\" }\n+              11 { ~\"Dec\" }\n             }\n           }\n           'C' { #fmt(\"%02d\", (tm.tm_year as int + 1900) / 100) }\n@@ -681,9 +681,9 @@ fn strftime(format: str, tm: tm) -> str {\n           }\n           'M' { #fmt(\"%02d\", tm.tm_min as int) }\n           'm' { #fmt(\"%02d\", tm.tm_mon as int + 1) }\n-          'n' { \"\\n\" }\n-          'P' { if tm.tm_hour as int < 12 { \"am\" } else { \"pm\" } }\n-          'p' { if tm.tm_hour as int < 12 { \"AM\" } else { \"PM\" } }\n+          'n' { ~\"\\n\" }\n+          'P' { if tm.tm_hour as int < 12 { ~\"am\" } else { ~\"pm\" } }\n+          'p' { if tm.tm_hour as int < 12 { ~\"AM\" } else { ~\"PM\" } }\n           'R' {\n             #fmt(\"%s:%s\",\n                 parse_type('H', tm),\n@@ -704,7 +704,7 @@ fn strftime(format: str, tm: tm) -> str {\n                 parse_type('M', tm),\n                 parse_type('S', tm))\n           }\n-          't' { \"\\t\" }\n+          't' { ~\"\\t\" }\n           //'U' {}\n           'u' {\n             let i = tm.tm_wday as int;\n@@ -732,11 +732,11 @@ fn strftime(format: str, tm: tm) -> str {\n             #fmt(\"%c%02d%02d\", sign, h as int, m as int)\n           }\n           //'+' {}\n-          '%' { \"%\" }\n+          '%' { ~\"%\" }\n         }\n     }\n \n-    let mut buf = \"\";\n+    let mut buf = ~\"\";\n \n     do io::with_str_reader(format) |rdr| {\n         while !rdr.eof() {\n@@ -776,22 +776,22 @@ impl tm for tm {\n      * Return a string of the current time in the form\n      * \"Thu Jan  1 00:00:00 1970\".\n      */\n-    fn ctime() -> str { self.strftime(\"%c\") }\n+    fn ctime() -> ~str { self.strftime(~\"%c\") }\n \n     /// Formats the time according to the format string.\n-    fn strftime(format: str) -> str { strftime(format, self) }\n+    fn strftime(format: ~str) -> ~str { strftime(format, self) }\n \n     /**\n      * Returns a time string formatted according to RFC 822.\n      *\n      * local: \"Thu, 22 Mar 2012 07:53:18 PST\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 UTC\"\n      */\n-    fn rfc822() -> str {\n+    fn rfc822() -> ~str {\n         if self.tm_gmtoff == 0_i32 {\n-            self.strftime(\"%a, %d %b %Y %T GMT\")\n+            self.strftime(~\"%a, %d %b %Y %T GMT\")\n         } else {\n-            self.strftime(\"%a, %d %b %Y %T %Z\")\n+            self.strftime(~\"%a, %d %b %Y %T %Z\")\n         }\n     }\n \n@@ -801,8 +801,8 @@ impl tm for tm {\n      * local: \"Thu, 22 Mar 2012 07:53:18 -0700\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 -0000\"\n      */\n-    fn rfc822z() -> str {\n-        self.strftime(\"%a, %d %b %Y %T %z\")\n+    fn rfc822z() -> ~str {\n+        self.strftime(~\"%a, %d %b %Y %T %z\")\n     }\n \n     /**\n@@ -811,11 +811,11 @@ impl tm for tm {\n      * local: \"2012-02-22T07:53:18-07:00\"\n      * utc:   \"2012-02-22T14:53:18Z\"\n      */\n-    fn rfc3339() -> str {\n+    fn rfc3339() -> ~str {\n         if self.tm_gmtoff == 0_i32 {\n-            self.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n+            self.strftime(~\"%Y-%m-%dT%H:%M:%SZ\")\n         } else {\n-            let s = self.strftime(\"%Y-%m-%dT%H:%M:%S\");\n+            let s = self.strftime(~\"%Y-%m-%dT%H:%M:%S\");\n             let sign = if self.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = i32::abs(self.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n@@ -835,15 +835,15 @@ mod tests {\n         const some_future_date: i64 = 1577836800i64; // 2020-01-01T00:00:00Z\n \n         let tv1 = get_time();\n-        log(debug, \"tv1=\" + uint::str(tv1.sec as uint) + \" sec + \"\n-                   + uint::str(tv1.nsec as uint) + \" nsec\");\n+        log(debug, ~\"tv1=\" + uint::str(tv1.sec as uint) + ~\" sec + \"\n+                   + uint::str(tv1.nsec as uint) + ~\" nsec\");\n \n         assert tv1.sec > some_recent_date;\n         assert tv1.nsec < 1000000000i32;\n \n         let tv2 = get_time();\n-        log(debug, \"tv2=\" + uint::str(tv2.sec as uint) + \" sec + \"\n-                   + uint::str(tv2.nsec as uint) + \" nsec\");\n+        log(debug, ~\"tv2=\" + uint::str(tv2.sec as uint) + ~\" sec + \"\n+                   + uint::str(tv2.nsec as uint) + ~\" nsec\");\n \n         assert tv2.sec >= tv1.sec;\n         assert tv2.sec < some_future_date;\n@@ -858,22 +858,22 @@ mod tests {\n         let s0 = precise_time_s();\n         let ns1 = precise_time_ns();\n \n-        log(debug, \"s0=\" + float::to_str(s0, 9u) + \" sec\");\n+        log(debug, ~\"s0=\" + float::to_str(s0, 9u) + ~\" sec\");\n         assert s0 > 0.;\n         let ns0 = (s0 * 1000000000.) as u64;\n-        log(debug, \"ns0=\" + u64::str(ns0) + \" ns\");\n+        log(debug, ~\"ns0=\" + u64::str(ns0) + ~\" ns\");\n \n-        log(debug, \"ns1=\" + u64::str(ns1) + \" ns\");\n+        log(debug, ~\"ns1=\" + u64::str(ns1) + ~\" ns\");\n         assert ns1 >= ns0;\n \n         let ns2 = precise_time_ns();\n-        log(debug, \"ns2=\" + u64::str(ns2) + \" ns\");\n+        log(debug, ~\"ns2=\" + u64::str(ns2) + ~\" ns\");\n         assert ns2 >= ns1;\n     }\n \n     #[test]\n     fn test_at_utc() {\n-        os::setenv(\"TZ\", \"America/Los_Angeles\");\n+        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n         let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n@@ -889,13 +889,13 @@ mod tests {\n         assert utc.tm_yday == 43_i32;\n         assert utc.tm_isdst == 0_i32;\n         assert utc.tm_gmtoff == 0_i32;\n-        assert utc.tm_zone == \"UTC\";\n+        assert utc.tm_zone == ~\"UTC\";\n         assert utc.tm_nsec == 54321_i32;\n     }\n \n     #[test]\n     fn test_at() {\n-        os::setenv(\"TZ\", \"America/Los_Angeles\");\n+        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n         let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n@@ -917,14 +917,14 @@ mod tests {\n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let zone = local.tm_zone;\n-        assert zone == \"PST\" || zone == \"Pacific Standard Time\";\n+        assert zone == ~\"PST\" || zone == ~\"Pacific Standard Time\";\n \n         assert local.tm_nsec == 54321_i32;\n     }\n \n     #[test]\n     fn test_to_timespec() {\n-        os::setenv(\"TZ\", \"America/Los_Angeles\");\n+        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n         let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n@@ -936,7 +936,7 @@ mod tests {\n \n     #[test]\n     fn test_conversions() {\n-        os::setenv(\"TZ\", \"America/Los_Angeles\");\n+        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n         let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n@@ -953,10 +953,10 @@ mod tests {\n \n     #[test]\n     fn test_strptime() {\n-        os::setenv(\"TZ\", \"America/Los_Angeles\");\n+        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n-        alt strptime(\"\", \"\") {\n+        alt strptime(~\"\", ~\"\") {\n           ok(tm) {\n             assert tm.tm_sec == 0_i32;\n             assert tm.tm_min == 0_i32;\n@@ -967,17 +967,18 @@ mod tests {\n             assert tm.tm_wday == 0_i32;\n             assert tm.tm_isdst== 0_i32;\n             assert tm.tm_gmtoff == 0_i32;\n-            assert tm.tm_zone == \"\";\n+            assert tm.tm_zone == ~\"\";\n             assert tm.tm_nsec == 0_i32;\n           }\n           err(_) {}\n         }\n \n-        let format = \"%a %b %e %T %Y\";\n-        assert strptime(\"\", format) == err(\"Invalid time\");\n-        assert strptime(\"Fri Feb 13 15:31:30\", format) == err(\"Invalid time\");\n+        let format = ~\"%a %b %e %T %Y\";\n+        assert strptime(~\"\", format) == err(~\"Invalid time\");\n+        assert strptime(~\"Fri Feb 13 15:31:30\", format)\n+            == err(~\"Invalid time\");\n \n-        alt strptime(\"Fri Feb 13 15:31:30 2009\", format) {\n+        alt strptime(~\"Fri Feb 13 15:31:30 2009\", format) {\n           err(e) { fail e }\n           ok(tm) {\n             assert tm.tm_sec == 30_i32;\n@@ -990,116 +991,116 @@ mod tests {\n             assert tm.tm_yday == 0_i32;\n             assert tm.tm_isdst == 0_i32;\n             assert tm.tm_gmtoff == 0_i32;\n-            assert tm.tm_zone == \"\";\n+            assert tm.tm_zone == ~\"\";\n             assert tm.tm_nsec == 0_i32;\n           }\n         }\n \n-        fn test(s: str, format: str) -> bool {\n+        fn test(s: ~str, format: ~str) -> bool {\n             alt strptime(s, format) {\n               ok(tm) { tm.strftime(format) == s }\n               err(e) { fail e }\n             }\n         }\n \n         [\n-            \"Sunday\",\n-            \"Monday\",\n-            \"Tuesday\",\n-            \"Wednesday\",\n-            \"Thursday\",\n-            \"Friday\",\n-            \"Saturday\"\n-        ]/_.iter(|day| assert test(day, \"%A\"));\n+            ~\"Sunday\",\n+            ~\"Monday\",\n+            ~\"Tuesday\",\n+            ~\"Wednesday\",\n+            ~\"Thursday\",\n+            ~\"Friday\",\n+            ~\"Saturday\"\n+        ]/_.iter(|day| assert test(day, ~\"%A\"));\n \n         [\n-            \"Sun\",\n-            \"Mon\",\n-            \"Tue\",\n-            \"Wed\",\n-            \"Thu\",\n-            \"Fri\",\n-            \"Sat\"\n-        ]/_.iter(|day| assert test(day, \"%a\"));\n+            ~\"Sun\",\n+            ~\"Mon\",\n+            ~\"Tue\",\n+            ~\"Wed\",\n+            ~\"Thu\",\n+            ~\"Fri\",\n+            ~\"Sat\"\n+        ]/_.iter(|day| assert test(day, ~\"%a\"));\n \n         [\n-            \"January\",\n-            \"February\",\n-            \"March\",\n-            \"April\",\n-            \"May\",\n-            \"June\",\n-            \"July\",\n-            \"August\",\n-            \"September\",\n-            \"October\",\n-            \"November\",\n-            \"December\"\n-        ]/_.iter(|day| assert test(day, \"%B\"));\n+            ~\"January\",\n+            ~\"February\",\n+            ~\"March\",\n+            ~\"April\",\n+            ~\"May\",\n+            ~\"June\",\n+            ~\"July\",\n+            ~\"August\",\n+            ~\"September\",\n+            ~\"October\",\n+            ~\"November\",\n+            ~\"December\"\n+        ]/_.iter(|day| assert test(day, ~\"%B\"));\n \n         [\n-            \"Jan\",\n-            \"Feb\",\n-            \"Mar\",\n-            \"Apr\",\n-            \"May\",\n-            \"Jun\",\n-            \"Jul\",\n-            \"Aug\",\n-            \"Sep\",\n-            \"Oct\",\n-            \"Nov\",\n-            \"Dec\"\n-        ]/_.iter(|day| assert test(day, \"%b\"));\n-\n-        assert test(\"19\", \"%C\");\n-        assert test(\"Fri Feb 13 23:31:30 2009\", \"%c\");\n-        assert test(\"02/13/09\", \"%D\");\n-        assert test(\"03\", \"%d\");\n-        assert test(\"13\", \"%d\");\n-        assert test(\" 3\", \"%e\");\n-        assert test(\"13\", \"%e\");\n-        assert test(\"2009-02-13\", \"%F\");\n-        assert test(\"03\", \"%H\");\n-        assert test(\"13\", \"%H\");\n-        assert test(\"03\", \"%I\"); // FIXME (#2350): flesh out\n-        assert test(\"11\", \"%I\"); // FIXME (#2350): flesh out\n-        assert test(\"044\", \"%j\");\n-        assert test(\" 3\", \"%k\");\n-        assert test(\"13\", \"%k\");\n-        assert test(\" 1\", \"%l\");\n-        assert test(\"11\", \"%l\");\n-        assert test(\"03\", \"%M\");\n-        assert test(\"13\", \"%M\");\n-        assert test(\"\\n\", \"%n\");\n-        assert test(\"am\", \"%P\");\n-        assert test(\"pm\", \"%P\");\n-        assert test(\"AM\", \"%p\");\n-        assert test(\"PM\", \"%p\");\n-        assert test(\"23:31\", \"%R\");\n-        assert test(\"11:31:30 AM\", \"%r\");\n-        assert test(\"11:31:30 PM\", \"%r\");\n-        assert test(\"03\", \"%S\");\n-        assert test(\"13\", \"%S\");\n-        assert test(\"15:31:30\", \"%T\");\n-        assert test(\"\\t\", \"%t\");\n-        assert test(\"1\", \"%u\");\n-        assert test(\"7\", \"%u\");\n-        assert test(\"13-Feb-2009\", \"%v\");\n-        assert test(\"0\", \"%w\");\n-        assert test(\"6\", \"%w\");\n-        assert test(\"2009\", \"%Y\");\n-        assert test(\"09\", \"%y\");\n-        assert strptime(\"UTC\", \"%Z\").get().tm_zone == \"UTC\";\n-        assert strptime(\"PST\", \"%Z\").get().tm_zone == \"\";\n-        assert strptime(\"-0000\", \"%z\").get().tm_gmtoff == 0_i32;\n-        assert strptime(\"-0800\", \"%z\").get().tm_gmtoff == 0_i32;\n-        assert test(\"%\", \"%%\");\n+            ~\"Jan\",\n+            ~\"Feb\",\n+            ~\"Mar\",\n+            ~\"Apr\",\n+            ~\"May\",\n+            ~\"Jun\",\n+            ~\"Jul\",\n+            ~\"Aug\",\n+            ~\"Sep\",\n+            ~\"Oct\",\n+            ~\"Nov\",\n+            ~\"Dec\"\n+        ]/_.iter(|day| assert test(day, ~\"%b\"));\n+\n+        assert test(~\"19\", ~\"%C\");\n+        assert test(~\"Fri Feb 13 23:31:30 2009\", ~\"%c\");\n+        assert test(~\"02/13/09\", ~\"%D\");\n+        assert test(~\"03\", ~\"%d\");\n+        assert test(~\"13\", ~\"%d\");\n+        assert test(~\" 3\", ~\"%e\");\n+        assert test(~\"13\", ~\"%e\");\n+        assert test(~\"2009-02-13\", ~\"%F\");\n+        assert test(~\"03\", ~\"%H\");\n+        assert test(~\"13\", ~\"%H\");\n+        assert test(~\"03\", ~\"%I\"); // FIXME (#2350): flesh out\n+        assert test(~\"11\", ~\"%I\"); // FIXME (#2350): flesh out\n+        assert test(~\"044\", ~\"%j\");\n+        assert test(~\" 3\", ~\"%k\");\n+        assert test(~\"13\", ~\"%k\");\n+        assert test(~\" 1\", ~\"%l\");\n+        assert test(~\"11\", ~\"%l\");\n+        assert test(~\"03\", ~\"%M\");\n+        assert test(~\"13\", ~\"%M\");\n+        assert test(~\"\\n\", ~\"%n\");\n+        assert test(~\"am\", ~\"%P\");\n+        assert test(~\"pm\", ~\"%P\");\n+        assert test(~\"AM\", ~\"%p\");\n+        assert test(~\"PM\", ~\"%p\");\n+        assert test(~\"23:31\", ~\"%R\");\n+        assert test(~\"11:31:30 AM\", ~\"%r\");\n+        assert test(~\"11:31:30 PM\", ~\"%r\");\n+        assert test(~\"03\", ~\"%S\");\n+        assert test(~\"13\", ~\"%S\");\n+        assert test(~\"15:31:30\", ~\"%T\");\n+        assert test(~\"\\t\", ~\"%t\");\n+        assert test(~\"1\", ~\"%u\");\n+        assert test(~\"7\", ~\"%u\");\n+        assert test(~\"13-Feb-2009\", ~\"%v\");\n+        assert test(~\"0\", ~\"%w\");\n+        assert test(~\"6\", ~\"%w\");\n+        assert test(~\"2009\", ~\"%Y\");\n+        assert test(~\"09\", ~\"%y\");\n+        assert strptime(~\"UTC\", ~\"%Z\").get().tm_zone == ~\"UTC\";\n+        assert strptime(~\"PST\", ~\"%Z\").get().tm_zone == ~\"\";\n+        assert strptime(~\"-0000\", ~\"%z\").get().tm_gmtoff == 0_i32;\n+        assert strptime(~\"-0800\", ~\"%z\").get().tm_gmtoff == 0_i32;\n+        assert test(~\"%\", ~\"%%\");\n     }\n \n     #[test]\n     fn test_ctime() {\n-        os::setenv(\"TZ\", \"America/Los_Angeles\");\n+        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n         let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n@@ -1108,81 +1109,81 @@ mod tests {\n \n         #error(\"test_ctime: %? %?\", utc.ctime(), local.ctime());\n \n-        assert utc.ctime()   == \"Fri Feb 13 23:31:30 2009\";\n-        assert local.ctime() == \"Fri Feb 13 15:31:30 2009\";\n+        assert utc.ctime()   == ~\"Fri Feb 13 23:31:30 2009\";\n+        assert local.ctime() == ~\"Fri Feb 13 15:31:30 2009\";\n     }\n \n     #[test]\n     fn test_strftime() {\n-        os::setenv(\"TZ\", \"America/Los_Angeles\");\n+        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n         let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n         let utc = at_utc(time);\n         let local = at(time);\n \n-        assert local.strftime(\"\") == \"\";\n-        assert local.strftime(\"%A\") == \"Friday\";\n-        assert local.strftime(\"%a\") == \"Fri\";\n-        assert local.strftime(\"%B\") == \"February\";\n-        assert local.strftime(\"%b\") == \"Feb\";\n-        assert local.strftime(\"%C\") == \"20\";\n-        assert local.strftime(\"%c\") == \"Fri Feb 13 15:31:30 2009\";\n-        assert local.strftime(\"%D\") == \"02/13/09\";\n-        assert local.strftime(\"%d\") == \"13\";\n-        assert local.strftime(\"%e\") == \"13\";\n-        assert local.strftime(\"%F\") == \"2009-02-13\";\n+        assert local.strftime(~\"\") == ~\"\";\n+        assert local.strftime(~\"%A\") == ~\"Friday\";\n+        assert local.strftime(~\"%a\") == ~\"Fri\";\n+        assert local.strftime(~\"%B\") == ~\"February\";\n+        assert local.strftime(~\"%b\") == ~\"Feb\";\n+        assert local.strftime(~\"%C\") == ~\"20\";\n+        assert local.strftime(~\"%c\") == ~\"Fri Feb 13 15:31:30 2009\";\n+        assert local.strftime(~\"%D\") == ~\"02/13/09\";\n+        assert local.strftime(~\"%d\") == ~\"13\";\n+        assert local.strftime(~\"%e\") == ~\"13\";\n+        assert local.strftime(~\"%F\") == ~\"2009-02-13\";\n         // assert local.strftime(\"%G\") == \"2009\";\n         // assert local.strftime(\"%g\") == \"09\";\n-        assert local.strftime(\"%H\") == \"15\";\n-        assert local.strftime(\"%I\") == \"03\";\n-        assert local.strftime(\"%j\") == \"044\";\n-        assert local.strftime(\"%k\") == \"15\";\n-        assert local.strftime(\"%l\") == \" 3\";\n-        assert local.strftime(\"%M\") == \"31\";\n-        assert local.strftime(\"%m\") == \"02\";\n-        assert local.strftime(\"%n\") == \"\\n\";\n-        assert local.strftime(\"%P\") == \"pm\";\n-        assert local.strftime(\"%p\") == \"PM\";\n-        assert local.strftime(\"%R\") == \"15:31\";\n-        assert local.strftime(\"%r\") == \"03:31:30 PM\";\n-        assert local.strftime(\"%S\") == \"30\";\n-        assert local.strftime(\"%s\") == \"1234567890\";\n-        assert local.strftime(\"%T\") == \"15:31:30\";\n-        assert local.strftime(\"%t\") == \"\\t\";\n+        assert local.strftime(~\"%H\") == ~\"15\";\n+        assert local.strftime(~\"%I\") == ~\"03\";\n+        assert local.strftime(~\"%j\") == ~\"044\";\n+        assert local.strftime(~\"%k\") == ~\"15\";\n+        assert local.strftime(~\"%l\") == ~\" 3\";\n+        assert local.strftime(~\"%M\") == ~\"31\";\n+        assert local.strftime(~\"%m\") == ~\"02\";\n+        assert local.strftime(~\"%n\") == ~\"\\n\";\n+        assert local.strftime(~\"%P\") == ~\"pm\";\n+        assert local.strftime(~\"%p\") == ~\"PM\";\n+        assert local.strftime(~\"%R\") == ~\"15:31\";\n+        assert local.strftime(~\"%r\") == ~\"03:31:30 PM\";\n+        assert local.strftime(~\"%S\") == ~\"30\";\n+        assert local.strftime(~\"%s\") == ~\"1234567890\";\n+        assert local.strftime(~\"%T\") == ~\"15:31:30\";\n+        assert local.strftime(~\"%t\") == ~\"\\t\";\n         // assert local.strftime(\"%U\") == \"06\";\n-        assert local.strftime(\"%u\") == \"5\";\n+        assert local.strftime(~\"%u\") == ~\"5\";\n         // assert local.strftime(\"%V\") == \"07\";\n-        assert local.strftime(\"%v\") == \"13-Feb-2009\";\n+        assert local.strftime(~\"%v\") == ~\"13-Feb-2009\";\n         // assert local.strftime(\"%W\") == \"06\";\n-        assert local.strftime(\"%w\") == \"5\";\n+        assert local.strftime(~\"%w\") == ~\"5\";\n         // handle \"%X\"\n         // handle \"%x\"\n-        assert local.strftime(\"%Y\") == \"2009\";\n-        assert local.strftime(\"%y\") == \"09\";\n+        assert local.strftime(~\"%Y\") == ~\"2009\";\n+        assert local.strftime(~\"%y\") == ~\"09\";\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n-        let zone = local.strftime(\"%Z\");\n-        assert zone == \"PST\" || zone == \"Pacific Standard Time\";\n+        let zone = local.strftime(~\"%Z\");\n+        assert zone == ~\"PST\" || zone == ~\"Pacific Standard Time\";\n \n-        assert local.strftime(\"%z\") == \"-0800\";\n-        assert local.strftime(\"%%\") == \"%\";\n+        assert local.strftime(~\"%z\") == ~\"-0800\";\n+        assert local.strftime(~\"%%\") == ~\"%\";\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let rfc822 = local.rfc822();\n-        let prefix = \"Fri, 13 Feb 2009 15:31:30 \";\n-        assert rfc822 == prefix + \"PST\" ||\n-               rfc822 == prefix + \"Pacific Standard Time\";\n-\n-        assert local.ctime() == \"Fri Feb 13 15:31:30 2009\";\n-        assert local.rfc822z() == \"Fri, 13 Feb 2009 15:31:30 -0800\";\n-        assert local.rfc3339() == \"2009-02-13T15:31:30-08:00\";\n-\n-        assert utc.ctime() == \"Fri Feb 13 23:31:30 2009\";\n-        assert utc.rfc822() == \"Fri, 13 Feb 2009 23:31:30 GMT\";\n-        assert utc.rfc822z() == \"Fri, 13 Feb 2009 23:31:30 -0000\";\n-        assert utc.rfc3339() == \"2009-02-13T23:31:30Z\";\n+        let prefix = ~\"Fri, 13 Feb 2009 15:31:30 \";\n+        assert rfc822 == prefix + ~\"PST\" ||\n+               rfc822 == prefix + ~\"Pacific Standard Time\";\n+\n+        assert local.ctime() == ~\"Fri Feb 13 15:31:30 2009\";\n+        assert local.rfc822z() == ~\"Fri, 13 Feb 2009 15:31:30 -0800\";\n+        assert local.rfc3339() == ~\"2009-02-13T15:31:30-08:00\";\n+\n+        assert utc.ctime() == ~\"Fri Feb 13 23:31:30 2009\";\n+        assert utc.rfc822() == ~\"Fri, 13 Feb 2009 23:31:30 GMT\";\n+        assert utc.rfc822z() == ~\"Fri, 13 Feb 2009 23:31:30 -0000\";\n+        assert utc.rfc3339() == ~\"2009-02-13T23:31:30Z\";\n     }\n }"}, {"sha": "b72e2c475392c23556cb834da8a2425ca26d449d", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -41,12 +41,13 @@ fn delayed_send<T: copy send>(iotask: iotask,\n                     }\n                     else {\n                         let error_msg = uv::ll::get_last_err_info(loop_ptr);\n-                        fail \"timer::delayed_send() start failed: \"+error_msg;\n+                        fail ~\"timer::delayed_send() start failed: \" +\n+                            error_msg;\n                     }\n                 }\n                 else {\n                     let error_msg = uv::ll::get_last_err_info(loop_ptr);\n-                    fail \"timer::delayed_send() init failed: \"+error_msg;\n+                    fail ~\"timer::delayed_send() init failed: \"+error_msg;\n                 }\n             };\n             // delayed_send_cb has been processed by libuv\n@@ -128,7 +129,7 @@ extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n     else {\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n         let error_msg = uv::ll::get_last_err_info(loop_ptr);\n-        fail \"timer::sleep() init failed: \"+error_msg;\n+        fail ~\"timer::sleep() init failed: \"+error_msg;\n     }\n }\n \n@@ -232,7 +233,7 @@ mod test {\n \n         for iter::repeat(times as uint) {\n             let expected = rand::rng().gen_str(16u);\n-            let test_po = comm::port::<str>();\n+            let test_po = comm::port::<~str>();\n             let test_ch = comm::chan(test_po);\n \n             do task::spawn() {"}, {"sha": "3def5fbd0d156f7b403dd4df0e536f5b97b79516", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -132,13 +132,13 @@ mod tests {\n     fn u8_map() {\n         let m = treemap();\n \n-        let k1 = str::bytes(\"foo\");\n-        let k2 = str::bytes(\"bar\");\n+        let k1 = str::bytes(~\"foo\");\n+        let k2 = str::bytes(~\"bar\");\n \n-        insert(m, k1, \"foo\");\n-        insert(m, k2, \"bar\");\n+        insert(m, k1, ~\"foo\");\n+        insert(m, k2, ~\"bar\");\n \n-        assert (find(m, k2) == some(\"bar\"));\n-        assert (find(m, k1) == some(\"foo\"));\n+        assert (find(m, k2) == some(~\"bar\"));\n+        assert (find(m, k1) == some(~\"foo\"));\n     }\n }"}, {"sha": "4a7962a977f84309314c81c2a5d34e9bcd538bc4", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -118,16 +118,16 @@ mod test {\n     }\n     extern fn simple_timer_cb(timer_ptr: *ll::uv_timer_t,\n                              _status: libc::c_int) unsafe {\n-        log(debug, \"in simple timer cb\");\n+        log(debug, ~\"in simple timer cb\");\n         ll::timer_stop(timer_ptr);\n         let hl_loop = get_gl();\n         do iotask::interact(hl_loop) |_loop_ptr| {\n-            log(debug, \"closing timer\");\n+            log(debug, ~\"closing timer\");\n             ll::close(timer_ptr, simple_timer_close_cb);\n-            log(debug, \"about to deref exit_ch_ptr\");\n-            log(debug, \"after msg sent on deref'd exit_ch\");\n+            log(debug, ~\"about to deref exit_ch_ptr\");\n+            log(debug, ~\"after msg sent on deref'd exit_ch\");\n         };\n-        log(debug, \"exiting simple timer cb\");\n+        log(debug, ~\"exiting simple timer cb\");\n     }\n \n     fn impl_uv_hl_simple_timer(iotask: iotask) unsafe {\n@@ -139,7 +139,7 @@ mod test {\n         let timer_handle = ll::timer_t();\n         let timer_ptr = ptr::addr_of(timer_handle);\n         do iotask::interact(iotask) |loop_ptr| {\n-            log(debug, \"user code inside interact loop!!!\");\n+            log(debug, ~\"user code inside interact loop!!!\");\n             let init_status = ll::timer_init(loop_ptr, timer_ptr);\n             if(init_status == 0i32) {\n                 ll::set_data_for_uv_handle(\n@@ -150,15 +150,15 @@ mod test {\n                 if(start_status == 0i32) {\n                 }\n                 else {\n-                    fail \"failure on ll::timer_start()\";\n+                    fail ~\"failure on ll::timer_start()\";\n                 }\n             }\n             else {\n-                fail \"failure on ll::timer_init()\";\n+                fail ~\"failure on ll::timer_init()\";\n             }\n         };\n         comm::recv(exit_po);\n-        log(debug, \"global_loop timer test: msg recv on exit_po, done..\");\n+        log(debug, ~\"global_loop timer test: msg recv on exit_po, done..\");\n     }\n \n     #[test]\n@@ -192,7 +192,7 @@ mod test {\n         for iter::repeat(cycles) {\n             comm::recv(exit_po);\n         };\n-        log(debug, \"test_stress_gl_uv_global_loop_high_level_global_timer\"+\n-            \" exiting sucessfully!\");\n+        log(debug, ~\"test_stress_gl_uv_global_loop_high_level_global_timer\"+\n+            ~\" exiting sucessfully!\");\n     }\n }"}, {"sha": "d049c6f7c7b5402d20d5b011ed6cc9c5362c988d", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -114,10 +114,10 @@ fn run_loop(iotask_ch: chan<iotask>) unsafe {\n     });\n     iotask_ch.send(iotask);\n \n-    log(debug, \"about to run uv loop\");\n+    log(debug, ~\"about to run uv loop\");\n     // enter the loop... this blocks until the loop is done..\n     ll::run(loop_ptr);\n-    log(debug, \"uv loop ended\");\n+    log(debug, ~\"uv loop ended\");\n     ll::loop_delete(loop_ptr);\n }\n \n@@ -157,7 +157,7 @@ extern fn wake_up_cb(async_handle: *ll::uv_async_t,\n }\n \n fn begin_teardown(data: *iotask_loop_data) unsafe {\n-    log(debug, \"iotask begin_teardown() called, close async_handle\");\n+    log(debug, ~\"iotask begin_teardown() called, close async_handle\");\n     let async_handle = (*data).async_handle;\n     ll::close(async_handle as *c_void, tear_down_close_cb);\n }\n@@ -250,9 +250,9 @@ mod test {\n         for iter::repeat(7u) {\n             comm::recv(work_exit_po);\n         };\n-        log(debug, \"sending teardown_loop msg..\");\n+        log(debug, ~\"sending teardown_loop msg..\");\n         exit(iotask);\n         comm::recv(exit_po);\n-        log(debug, \"after recv on exit_po.. exiting..\");\n+        log(debug, ~\"after recv on exit_po.. exiting..\");\n     }\n }"}, {"sha": "56365514da92d17f67a222f22a5b0aa6fa411c25", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -793,7 +793,7 @@ unsafe fn buf_init(++input: *u8, len: uint) -> uv_buf_t {\n     // yuck :/\n     rustrt::rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n     //let result = rustrt::rust_uv_buf_init_2(input, len as size_t);\n-    log(debug, \"after rust_uv_buf_init\");\n+    log(debug, ~\"after rust_uv_buf_init\");\n     let res_base = get_base_from_buf(out_buf);\n     let res_len = get_len_from_buf(out_buf);\n     //let res_base = get_base_from_buf(result);\n@@ -803,21 +803,21 @@ unsafe fn buf_init(++input: *u8, len: uint) -> uv_buf_t {\n     ret out_buf;\n     //ret result;\n }\n-unsafe fn ip4_addr(ip: str, port: int)\n+unsafe fn ip4_addr(ip: ~str, port: int)\n -> sockaddr_in {\n     do str::as_c_str(ip) |ip_buf| {\n         rustrt::rust_uv_ip4_addr(ip_buf as *u8,\n                                  port as libc::c_int)\n     }\n }\n-unsafe fn ip6_addr(ip: str, port: int)\n+unsafe fn ip6_addr(ip: ~str, port: int)\n -> sockaddr_in6 {\n     do str::as_c_str(ip) |ip_buf| {\n         rustrt::rust_uv_ip6_addr(ip_buf as *u8,\n                                  port as libc::c_int)\n     }\n }\n-unsafe fn ip4_name(src: &sockaddr_in) -> str {\n+unsafe fn ip4_name(src: &sockaddr_in) -> ~str {\n     // ipv4 addr max size: 15 + 1 trailing null byte\n     let dst: ~[u8] = ~[0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                      0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8];\n@@ -834,7 +834,7 @@ unsafe fn ip4_name(src: &sockaddr_in) -> str {\n         str::unsafe::from_buf(dst_buf)\n     }\n }\n-unsafe fn ip6_name(src: &sockaddr_in6) -> str {\n+unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n     // ipv6 addr max size: 45 + 1 trailing null byte\n     let dst: ~[u8] = ~[0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                        0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n@@ -854,7 +854,7 @@ unsafe fn ip6_name(src: &sockaddr_in6) -> str {\n             str::unsafe::from_buf(dst_buf)\n           }\n           _ {\n-            \"\"\n+            ~\"\"\n           }\n         }\n     }\n@@ -961,7 +961,7 @@ unsafe fn free_base_of_buf(buf: uv_buf_t) {\n     rustrt::rust_uv_free_base_of_buf(buf);\n }\n \n-unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> str {\n+unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> ~str {\n     let err = last_error(uv_loop);\n     let err_ptr = ptr::addr_of(err);\n     let err_name = str::unsafe::from_c_str(err_name(err_ptr));\n@@ -979,8 +979,8 @@ unsafe fn get_last_err_data(uv_loop: *libc::c_void) -> uv_err_data {\n }\n \n type uv_err_data = {\n-    err_name: str,\n-    err_msg: str\n+    err_name: ~str,\n+    err_msg: ~str\n };\n \n unsafe fn is_ipv4_addrinfo(input: *addrinfo) -> bool {\n@@ -1013,7 +1013,7 @@ mod test {\n     type request_wrapper = {\n         write_req: *uv_write_t,\n         req_buf: *~[uv_buf_t],\n-        read_chan: *comm::chan<str>\n+        read_chan: *comm::chan<~str>\n     };\n \n     extern fn after_close_cb(handle: *libc::c_void) {\n@@ -1024,7 +1024,7 @@ mod test {\n     extern fn on_alloc_cb(handle: *libc::c_void,\n                          ++suggested_size: libc::size_t)\n         -> uv_buf_t unsafe {\n-        log(debug, \"on_alloc_cb!\");\n+        log(debug, ~\"on_alloc_cb!\");\n         let char_ptr = malloc_buf_base_of(suggested_size);\n         log(debug, #fmt(\"on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n                          handle,\n@@ -1056,15 +1056,15 @@ mod test {\n         }\n         else if (nread == -1) {\n             // err .. possibly EOF\n-            log(debug, \"read: eof!\");\n+            log(debug, ~\"read: eof!\");\n         }\n         else {\n             // nread == 0 .. do nothing, just free buf as below\n-            log(debug, \"read: do nothing!\");\n+            log(debug, ~\"read: do nothing!\");\n         }\n         // when we're done\n         free_base_of_buf(buf);\n-        log(debug, \"CLIENT exiting on_read_cb\");\n+        log(debug, ~\"CLIENT exiting on_read_cb\");\n     }\n \n     extern fn on_write_complete_cb(write_req: *uv_write_t,\n@@ -1086,7 +1086,7 @@ mod test {\n         let stream =\n             get_stream_handle_from_connect_req(connect_req_ptr);\n         if (status == 0i32) {\n-            log(debug, \"on_connect_cb: in status=0 if..\");\n+            log(debug, ~\"on_connect_cb: in status=0 if..\");\n             let client_data = get_data_for_req(\n                 connect_req_ptr as *libc::c_void)\n                 as *request_wrapper;\n@@ -1107,11 +1107,11 @@ mod test {\n             log(debug, err_msg);\n             assert false;\n         }\n-        log(debug, \"finishing on_connect_cb\");\n+        log(debug, ~\"finishing on_connect_cb\");\n     }\n \n-    fn impl_uv_tcp_request(ip: str, port: int, req_str: str,\n-                          client_chan: *comm::chan<str>) unsafe {\n+    fn impl_uv_tcp_request(ip: ~str, port: int, req_str: ~str,\n+                          client_chan: *comm::chan<~str>) unsafe {\n         let test_loop = loop_new();\n         let tcp_handle = tcp_t();\n         let tcp_handle_ptr = ptr::addr_of(tcp_handle);\n@@ -1143,9 +1143,9 @@ mod test {\n         let tcp_init_result = tcp_init(\n             test_loop as *libc::c_void, tcp_handle_ptr);\n         if (tcp_init_result == 0i32) {\n-            log(debug, \"sucessful tcp_init_result\");\n+            log(debug, ~\"sucessful tcp_init_result\");\n \n-            log(debug, \"building addr...\");\n+            log(debug, ~\"building addr...\");\n             let addr = ip4_addr(ip, port);\n             // FIXME ref #2064\n             let addr_ptr = ptr::addr_of(addr);\n@@ -1167,17 +1167,17 @@ mod test {\n                 set_data_for_uv_handle(\n                     tcp_handle_ptr as *libc::c_void,\n                     ptr::addr_of(client_data) as *libc::c_void);\n-                log(debug, \"before run tcp req loop\");\n+                log(debug, ~\"before run tcp req loop\");\n                 run(test_loop);\n-                log(debug, \"after run tcp req loop\");\n+                log(debug, ~\"after run tcp req loop\");\n             }\n             else {\n-               log(debug, \"tcp_connect() failure\");\n+               log(debug, ~\"tcp_connect() failure\");\n                assert false;\n             }\n         }\n         else {\n-            log(debug, \"tcp_init() failure\");\n+            log(debug, ~\"tcp_init() failure\");\n             assert false;\n         }\n         loop_delete(test_loop);\n@@ -1191,7 +1191,8 @@ mod test {\n \n     extern fn client_stream_after_close_cb(handle: *libc::c_void)\n         unsafe {\n-        log(debug, \"SERVER: closed client stream, now closing server stream\");\n+        log(debug,\n+            ~\"SERVER: closed client stream, now closing server stream\");\n         let client_data = get_data_for_uv_handle(\n             handle) as\n             *tcp_server_data;\n@@ -1202,7 +1203,7 @@ mod test {\n     extern fn after_server_resp_write(req: *uv_write_t) unsafe {\n         let client_stream_ptr =\n             get_stream_handle_from_write_req(req);\n-        log(debug, \"SERVER: resp sent... closing client stream\");\n+        log(debug, ~\"SERVER: resp sent... closing client stream\");\n         close(client_stream_ptr as *libc::c_void,\n                       client_stream_after_close_cb)\n     }\n@@ -1231,8 +1232,8 @@ mod test {\n             let server_kill_msg = (*client_data).server_kill_msg;\n             let write_req = (*client_data).server_write_req;\n             if (str::contains(request_str, server_kill_msg)) {\n-                log(debug, \"SERVER: client req contains kill_msg!\");\n-                log(debug, \"SERVER: sending response to client\");\n+                log(debug, ~\"SERVER: client req contains kill_msg!\");\n+                log(debug, ~\"SERVER: sending response to client\");\n                 read_stop(client_stream_ptr);\n                 let server_chan = *((*client_data).server_chan);\n                 comm::send(server_chan, request_str);\n@@ -1244,34 +1245,34 @@ mod test {\n                 log(debug, #fmt(\"SERVER: resp write result: %d\",\n                             write_result as int));\n                 if (write_result != 0i32) {\n-                    log(debug, \"bad result for server resp write()\");\n+                    log(debug, ~\"bad result for server resp write()\");\n                     log(debug, get_last_err_info(\n                         get_loop_for_uv_handle(client_stream_ptr\n                             as *libc::c_void)));\n                     assert false;\n                 }\n             }\n             else {\n-                log(debug, \"SERVER: client req !contain kill_msg!\");\n+                log(debug, ~\"SERVER: client req !contain kill_msg!\");\n             }\n         }\n         else if (nread == -1) {\n             // err .. possibly EOF\n-            log(debug, \"read: eof!\");\n+            log(debug, ~\"read: eof!\");\n         }\n         else {\n             // nread == 0 .. do nothing, just free buf as below\n-            log(debug, \"read: do nothing!\");\n+            log(debug, ~\"read: do nothing!\");\n         }\n         // when we're done\n         free_base_of_buf(buf);\n-        log(debug, \"SERVER exiting on_read_cb\");\n+        log(debug, ~\"SERVER exiting on_read_cb\");\n     }\n \n     extern fn server_connection_cb(server_stream_ptr:\n                                     *uv_stream_t,\n                                   status: libc::c_int) unsafe {\n-        log(debug, \"client connecting!\");\n+        log(debug, ~\"client connecting!\");\n         let test_loop = get_loop_for_uv_handle(\n                                server_stream_ptr as *libc::c_void);\n         if status != 0i32 {\n@@ -1289,7 +1290,7 @@ mod test {\n             client_stream_ptr as *libc::c_void,\n             server_data as *libc::c_void);\n         if (client_init_result == 0i32) {\n-            log(debug, \"successfully initialized client stream\");\n+            log(debug, ~\"successfully initialized client stream\");\n             let accept_result = accept(server_stream_ptr as\n                                                  *libc::c_void,\n                                                client_stream_ptr as\n@@ -1301,7 +1302,7 @@ mod test {\n                                                      on_alloc_cb,\n                                                      on_server_read_cb);\n                 if (read_result == 0i32) {\n-                    log(debug, \"successful server read start\");\n+                    log(debug, ~\"successful server read start\");\n                 }\n                 else {\n                     log(debug, #fmt(\"server_connection_cb: bad read:%d\",\n@@ -1325,9 +1326,9 @@ mod test {\n     type tcp_server_data = {\n         client: *uv_tcp_t,\n         server: *uv_tcp_t,\n-        server_kill_msg: str,\n+        server_kill_msg: ~str,\n         server_resp_buf: *~[uv_buf_t],\n-        server_chan: *comm::chan<str>,\n+        server_chan: *comm::chan<~str>,\n         server_write_req: *uv_write_t\n     };\n \n@@ -1354,11 +1355,11 @@ mod test {\n         close(async_handle as *libc::c_void, async_close_cb);\n     }\n \n-    fn impl_uv_tcp_server(server_ip: str,\n+    fn impl_uv_tcp_server(server_ip: ~str,\n                           server_port: int,\n-                          kill_server_msg: str,\n-                          server_resp_msg: str,\n-                          server_chan: *comm::chan<str>,\n+                          kill_server_msg: ~str,\n+                          server_resp_msg: ~str,\n+                          server_chan: *comm::chan<~str>,\n                           continue_chan: *comm::chan<bool>) unsafe {\n         let test_loop = loop_new();\n         let tcp_server = tcp_t();\n@@ -1408,7 +1409,7 @@ mod test {\n             let bind_result = tcp_bind(tcp_server_ptr,\n                                                server_addr_ptr);\n             if (bind_result == 0i32) {\n-                log(debug, \"successful uv_tcp_bind, listening\");\n+                log(debug, ~\"successful uv_tcp_bind, listening\");\n \n                 // uv_listen()\n                 let listen_result = listen(tcp_server_ptr as\n@@ -1428,7 +1429,7 @@ mod test {\n                         async_send(continue_async_handle_ptr);\n                         // uv_run()\n                         run(test_loop);\n-                        log(debug, \"server uv::run() has returned\");\n+                        log(debug, ~\"server uv::run() has returned\");\n                     }\n                     else {\n                         log(debug, #fmt(\"uv_async_init failure: %d\",\n@@ -1459,15 +1460,15 @@ mod test {\n     // this is the impl for a test that is (maybe) ran on a\n     // per-platform/arch basis below\n     fn impl_uv_tcp_server_and_request() unsafe {\n-        let bind_ip = \"0.0.0.0\";\n-        let request_ip = \"127.0.0.1\";\n+        let bind_ip = ~\"0.0.0.0\";\n+        let request_ip = ~\"127.0.0.1\";\n         let port = 8887;\n-        let kill_server_msg = \"does a dog have buddha nature?\";\n-        let server_resp_msg = \"mu!\";\n-        let client_port = comm::port::<str>();\n-        let client_chan = comm::chan::<str>(client_port);\n-        let server_port = comm::port::<str>();\n-        let server_chan = comm::chan::<str>(server_port);\n+        let kill_server_msg = ~\"does a dog have buddha nature?\";\n+        let server_resp_msg = ~\"mu!\";\n+        let client_port = comm::port::<~str>();\n+        let client_chan = comm::chan::<~str>(client_port);\n+        let server_port = comm::port::<~str>();\n+        let server_chan = comm::chan::<~str>(server_port);\n \n         let continue_port = comm::port::<bool>();\n         let continue_chan = comm::chan::<bool>(continue_port);\n@@ -1482,9 +1483,9 @@ mod test {\n         };\n \n         // block until the server up is.. possibly a race?\n-        log(debug, \"before receiving on server continue_port\");\n+        log(debug, ~\"before receiving on server continue_port\");\n         comm::recv(continue_port);\n-        log(debug, \"received on continue port, set up tcp client\");\n+        log(debug, ~\"received on continue port, set up tcp client\");\n \n         do task::spawn_sched(task::manual_threads(1u)) {\n             impl_uv_tcp_request(request_ip, port,"}, {"sha": "30535b45529bca1efbc15af5e020bc046c7ac5f4", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -32,7 +32,7 @@ fn deserialize_span<D>(_d: D) -> span {\n type spanned<T> = {node: T, span: span};\n \n #[auto_serialize]\n-type ident = @str/~;\n+type ident = @~str;\n \n // Functions may or may not have names.\n #[auto_serialize]\n@@ -428,11 +428,11 @@ type lit = spanned<lit_>;\n \n #[auto_serialize]\n enum lit_ {\n-    lit_str(@str/~),\n+    lit_str(@~str),\n     lit_int(i64, int_ty),\n     lit_uint(u64, uint_ty),\n     lit_int_unsuffixed(i64),\n-    lit_float(@str/~, float_ty),\n+    lit_float(@~str, float_ty),\n     lit_nil,\n     lit_bool(bool),\n }"}, {"sha": "7f1899792d705492803b4ad3d6b1165190cd2c5e", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -10,7 +10,7 @@ enum path_elt { path_mod(ident), path_name(ident) }\n type path = ~[path_elt];\n \n /* FIXMEs that say \"bad\" are as per #2543 */\n-fn path_to_str_with_sep(p: path, sep: str) -> str {\n+fn path_to_str_with_sep(p: path, sep: ~str) -> ~str {\n     let strs = do vec::map(p) |e| {\n         alt e {\n           path_mod(s) { /* FIXME (#2543) */ copy *s }\n@@ -20,16 +20,16 @@ fn path_to_str_with_sep(p: path, sep: str) -> str {\n     str::connect(strs, sep)\n }\n \n-fn path_ident_to_str(p: path, i: ident) -> str {\n+fn path_ident_to_str(p: path, i: ident) -> ~str {\n     if vec::is_empty(p) {\n         /* FIXME (#2543) */ copy *i\n     } else {\n         #fmt[\"%s::%s\", path_to_str(p), *i]\n     }\n }\n \n-fn path_to_str(p: path) -> str {\n-    path_to_str_with_sep(p, \"::\")\n+fn path_to_str(p: path) -> ~str {\n+    path_to_str_with_sep(p, ~\"::\")\n }\n \n enum ast_node {\n@@ -267,7 +267,7 @@ fn map_expr(ex: @expr, cx: ctx, v: vt) {\n     visit::visit_expr(ex, cx, v);\n }\n \n-fn node_id_to_str(map: map, id: node_id) -> str {\n+fn node_id_to_str(map: map, id: node_id) -> ~str {\n     alt map.find(id) {\n       none {\n         #fmt[\"unknown node (id=%d)\", id]"}, {"sha": "556239769da5789582c973ab27ae301b4b75044f", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -21,11 +21,11 @@ pure fn mk_sp(lo: uint, hi: uint) -> span {\n // make this a const, once the compiler supports it\n pure fn dummy_sp() -> span { ret mk_sp(0u, 0u); }\n \n-pure fn path_name(p: @path) -> str { path_name_i(p.idents) }\n+pure fn path_name(p: @path) -> ~str { path_name_i(p.idents) }\n \n-pure fn path_name_i(idents: ~[ident]) -> str {\n+pure fn path_name_i(idents: ~[ident]) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    str::connect(idents.map(|i|*i), \"::\")\n+    str::connect(idents.map(|i|*i), ~\"::\")\n }\n \n pure fn path_to_ident(p: @path) -> ident { vec::last(p.idents) }\n@@ -45,7 +45,7 @@ pure fn stmt_id(s: stmt) -> node_id {\n fn variant_def_ids(d: def) -> {enm: def_id, var: def_id} {\n     alt d { def_variant(enum_id, var_id) {\n             ret {enm: enum_id, var: var_id}; }\n-        _ { fail \"non-variant in variant_def_ids\"; } }\n+        _ { fail ~\"non-variant in variant_def_ids\"; } }\n }\n \n pure fn def_id_of_def(d: def) -> def_id {\n@@ -63,26 +63,26 @@ pure fn def_id_of_def(d: def) -> def_id {\n     }\n }\n \n-pure fn binop_to_str(op: binop) -> str {\n+pure fn binop_to_str(op: binop) -> ~str {\n     alt op {\n-      add { ret \"+\"; }\n-      subtract { ret \"-\"; }\n-      mul { ret \"*\"; }\n-      div { ret \"/\"; }\n-      rem { ret \"%\"; }\n-      and { ret \"&&\"; }\n-      or { ret \"||\"; }\n-      bitxor { ret \"^\"; }\n-      bitand { ret \"&\"; }\n-      bitor { ret \"|\"; }\n-      shl { ret \"<<\"; }\n-      shr { ret \">>\"; }\n-      eq { ret \"==\"; }\n-      lt { ret \"<\"; }\n-      le { ret \"<=\"; }\n-      ne { ret \"!=\"; }\n-      ge { ret \">=\"; }\n-      gt { ret \">\"; }\n+      add { ret ~\"+\"; }\n+      subtract { ret ~\"-\"; }\n+      mul { ret ~\"*\"; }\n+      div { ret ~\"/\"; }\n+      rem { ret ~\"%\"; }\n+      and { ret ~\"&&\"; }\n+      or { ret ~\"||\"; }\n+      bitxor { ret ~\"^\"; }\n+      bitand { ret ~\"&\"; }\n+      bitor { ret ~\"|\"; }\n+      shl { ret ~\"<<\"; }\n+      shr { ret ~\">>\"; }\n+      eq { ret ~\"==\"; }\n+      lt { ret ~\"<\"; }\n+      le { ret ~\"<=\"; }\n+      ne { ret ~\"!=\"; }\n+      ge { ret ~\">=\"; }\n+      gt { ret ~\">\"; }\n     }\n }\n \n@@ -98,25 +98,25 @@ pure fn is_shift_binop(b: binop) -> bool {\n     }\n }\n \n-pure fn unop_to_str(op: unop) -> str {\n+pure fn unop_to_str(op: unop) -> ~str {\n     alt op {\n-      box(mt) { if mt == m_mutbl { ret \"@mut \"; } ret \"@\"; }\n-      uniq(mt) { if mt == m_mutbl { ret \"~mut \"; } ret \"~\"; }\n-      deref { ret \"*\"; }\n-      not { ret \"!\"; }\n-      neg { ret \"-\"; }\n+      box(mt) { if mt == m_mutbl { ret ~\"@mut \"; } ret ~\"@\"; }\n+      uniq(mt) { if mt == m_mutbl { ret ~\"~mut \"; } ret ~\"~\"; }\n+      deref { ret ~\"*\"; }\n+      not { ret ~\"!\"; }\n+      neg { ret ~\"-\"; }\n     }\n }\n \n pure fn is_path(e: @expr) -> bool {\n     ret alt e.node { expr_path(_) { true } _ { false } };\n }\n \n-pure fn int_ty_to_str(t: int_ty) -> str {\n+pure fn int_ty_to_str(t: int_ty) -> ~str {\n     alt t {\n-      ty_char { \"u8\" } // ???\n-      ty_i { \"\" } ty_i8 { \"i8\" } ty_i16 { \"i16\" }\n-      ty_i32 { \"i32\" } ty_i64 { \"i64\" }\n+      ty_char { ~\"u8\" } // ???\n+      ty_i { ~\"\" } ty_i8 { ~\"i8\" } ty_i16 { ~\"i16\" }\n+      ty_i32 { ~\"i32\" } ty_i64 { ~\"i64\" }\n     }\n }\n \n@@ -129,10 +129,10 @@ pure fn int_ty_max(t: int_ty) -> u64 {\n     }\n }\n \n-pure fn uint_ty_to_str(t: uint_ty) -> str {\n+pure fn uint_ty_to_str(t: uint_ty) -> ~str {\n     alt t {\n-      ty_u { \"u\" } ty_u8 { \"u8\" } ty_u16 { \"u16\" }\n-      ty_u32 { \"u32\" } ty_u64 { \"u64\" }\n+      ty_u { ~\"u\" } ty_u8 { ~\"u8\" } ty_u16 { ~\"u16\" }\n+      ty_u32 { ~\"u32\" } ty_u64 { ~\"u64\" }\n     }\n }\n \n@@ -145,8 +145,8 @@ pure fn uint_ty_max(t: uint_ty) -> u64 {\n     }\n }\n \n-pure fn float_ty_to_str(t: float_ty) -> str {\n-    alt t { ty_f { \"\" } ty_f32 { \"f32\" } ty_f64 { \"f64\" } }\n+pure fn float_ty_to_str(t: float_ty) -> ~str {\n+    alt t { ty_f { ~\"\" } ty_f32 { ~\"f32\" } ty_f64 { ~\"f64\" } }\n }\n \n fn is_exported(i: ident, m: _mod) -> bool {\n@@ -191,7 +191,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n                             if id.node.name == i { ret true; }\n                         }\n                     } else {\n-                        fail \"export of path-qualified list\";\n+                        fail ~\"export of path-qualified list\";\n                     }\n                   }\n \n@@ -381,7 +381,7 @@ fn dtor_dec() -> fn_decl {\n     let nil_t = @{id: 0, node: ty_nil, span: dummy_sp()};\n     // dtor has one argument, of type ()\n     {inputs: ~[{mode: ast::expl(ast::by_ref),\n-               ty: nil_t, ident: @\"_\", id: 0}],\n+               ty: nil_t, ident: @~\"_\", id: 0}],\n      output: nil_t, purity: impure_fn, cf: return_val, constraints: ~[]}\n }\n "}, {"sha": "859bc70bfd64876752bd5d4c9bd5565056d84621", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -49,7 +49,8 @@ export require_unique_names;\n \n /* Constructors */\n \n-fn mk_name_value_item_str(+name: ast::ident, +value: str) -> @ast::meta_item {\n+fn mk_name_value_item_str(+name: ast::ident, +value: ~str) ->\n+    @ast::meta_item {\n     let value_lit = dummy_spanned(ast::lit_str(@value));\n     ret mk_name_value_item(name, value_lit);\n }\n@@ -73,11 +74,11 @@ fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n                        is_sugared_doc: false});\n }\n \n-fn mk_sugared_doc_attr(text: str, lo: uint, hi: uint) -> ast::attribute {\n+fn mk_sugared_doc_attr(text: ~str, lo: uint, hi: uint) -> ast::attribute {\n     let lit = spanned(lo, hi, ast::lit_str(@text));\n     let attr = {\n         style: doc_comment_style(text),\n-        value: spanned(lo, hi, ast::meta_name_value(@\"doc\", lit)),\n+        value: spanned(lo, hi, ast::meta_name_value(@~\"doc\", lit)),\n         is_sugared_doc: true\n     };\n     ret spanned(lo, hi, attr);\n@@ -97,7 +98,7 @@ fn attr_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n fn desugar_doc_attr(attr: ast::attribute) -> ast::attribute {\n     if attr.node.is_sugared_doc {\n         let comment = get_meta_item_value_str(@attr.node.value).get();\n-        let meta = mk_name_value_item_str(@\"doc\",\n+        let meta = mk_name_value_item_str(@~\"doc\",\n                                      strip_doc_comment_decoration(*comment));\n         ret mk_attr(meta);\n     } else {\n@@ -124,7 +125,7 @@ fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n  * Gets the string value if the meta_item is a meta_name_value variant\n  * containing a string, otherwise none\n  */\n-fn get_meta_item_value_str(meta: @ast::meta_item) -> option<@str/~> {\n+fn get_meta_item_value_str(meta: @ast::meta_item) -> option<@~str> {\n     alt meta.node {\n       ast::meta_name_value(_, v) {\n         alt v.node {\n@@ -154,7 +155,7 @@ fn get_meta_item_list(meta: @ast::meta_item) -> option<~[@ast::meta_item]> {\n  */\n fn get_name_value_str_pair(\n     item: @ast::meta_item\n-) -> option<(ast::ident, @str/~)> {\n+) -> option<(ast::ident, @~str)> {\n     alt attr::get_meta_item_value_str(item) {\n       some(value) {\n         let name = attr::get_meta_item_name(item);\n@@ -168,7 +169,7 @@ fn get_name_value_str_pair(\n /* Searching */\n \n /// Search a list of attributes and return only those with a specific name\n-fn find_attrs_by_name(attrs: ~[ast::attribute], +name: str) ->\n+fn find_attrs_by_name(attrs: ~[ast::attribute], +name: ~str) ->\n    ~[ast::attribute] {\n     let filter = (\n         fn@(a: ast::attribute) -> option<ast::attribute> {\n@@ -181,7 +182,7 @@ fn find_attrs_by_name(attrs: ~[ast::attribute], +name: str) ->\n }\n \n /// Searcha list of meta items and return only those with a specific name\n-fn find_meta_items_by_name(metas: ~[@ast::meta_item], +name: str) ->\n+fn find_meta_items_by_name(metas: ~[@ast::meta_item], +name: ~str) ->\n    ~[@ast::meta_item] {\n     let filter = fn@(&&m: @ast::meta_item) -> option<@ast::meta_item> {\n         if *get_meta_item_name(m) == name {\n@@ -224,22 +225,22 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n             // FIXME (#607): Needs implementing\n             // This involves probably sorting the list by name and\n             // meta_item variant\n-            fail \"unimplemented meta_item variant\"\n+            fail ~\"unimplemented meta_item variant\"\n           }\n         }\n }\n \n-fn contains_name(metas: ~[@ast::meta_item], +name: str) -> bool {\n+fn contains_name(metas: ~[@ast::meta_item], +name: ~str) -> bool {\n     let matches = find_meta_items_by_name(metas, name);\n     ret vec::len(matches) > 0u;\n }\n \n-fn attrs_contains_name(attrs: ~[ast::attribute], +name: str) -> bool {\n+fn attrs_contains_name(attrs: ~[ast::attribute], +name: ~str) -> bool {\n     vec::is_not_empty(find_attrs_by_name(attrs, name))\n }\n \n-fn first_attr_value_str_by_name(attrs: ~[ast::attribute], +name: str)\n-    -> option<@str/~> {\n+fn first_attr_value_str_by_name(attrs: ~[ast::attribute], +name: ~str)\n+    -> option<@~str> {\n     let mattrs = find_attrs_by_name(attrs, name);\n     if vec::len(mattrs) > 0u {\n         ret get_meta_item_value_str(attr_meta(mattrs[0]));\n@@ -249,16 +250,16 @@ fn first_attr_value_str_by_name(attrs: ~[ast::attribute], +name: str)\n \n fn last_meta_item_by_name(\n     items: ~[@ast::meta_item],\n-    +name: str\n+    +name: ~str\n ) -> option<@ast::meta_item> {\n     let items = attr::find_meta_items_by_name(items, name);\n     vec::last_opt(items)\n }\n \n fn last_meta_item_value_str_by_name(\n     items: ~[@ast::meta_item],\n-    +name: str\n-) -> option<@str/~> {\n+    +name: ~str\n+) -> option<@~str> {\n     alt last_meta_item_by_name(items, name) {\n       some(item) {\n         alt attr::get_meta_item_value_str(item) {\n@@ -272,7 +273,7 @@ fn last_meta_item_value_str_by_name(\n \n fn last_meta_item_list_by_name(\n     items: ~[@ast::meta_item],\n-    +name: str\n+    +name: ~str\n ) -> option<~[@ast::meta_item]> {\n     alt last_meta_item_by_name(items, name) {\n       some(item) {\n@@ -319,7 +320,7 @@ fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ast::ident) ->\n \n fn find_linkage_attrs(attrs: ~[ast::attribute]) -> ~[ast::attribute] {\n     let mut found = ~[];\n-    for find_attrs_by_name(attrs, \"link\").each |attr| {\n+    for find_attrs_by_name(attrs, ~\"link\").each |attr| {\n         alt attr.node.value.node {\n           ast::meta_list(_, _) { vec::push(found, attr) }\n           _ { #debug(\"ignoring link attribute that has incorrect type\"); }\n@@ -340,22 +341,22 @@ fn find_linkage_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n     }\n }\n \n-fn foreign_abi(attrs: ~[ast::attribute]) -> either<str, ast::foreign_abi> {\n-    ret alt attr::first_attr_value_str_by_name(attrs, \"abi\") {\n+fn foreign_abi(attrs: ~[ast::attribute]) -> either<~str, ast::foreign_abi> {\n+    ret alt attr::first_attr_value_str_by_name(attrs, ~\"abi\") {\n       option::none {\n         either::right(ast::foreign_abi_cdecl)\n       }\n-      option::some(@\"rust-intrinsic\") {\n+      option::some(@~\"rust-intrinsic\") {\n         either::right(ast::foreign_abi_rust_intrinsic)\n       }\n-      option::some(@\"cdecl\") {\n+      option::some(@~\"cdecl\") {\n         either::right(ast::foreign_abi_cdecl)\n       }\n-      option::some(@\"stdcall\") {\n+      option::some(@~\"stdcall\") {\n         either::right(ast::foreign_abi_stdcall)\n       }\n       option::some(t) {\n-        either::left(\"unsupported abi: \" + *t)\n+        either::left(~\"unsupported abi: \" + *t)\n       }\n     };\n }\n@@ -371,9 +372,9 @@ fn find_inline_attr(attrs: ~[ast::attribute]) -> inline_attr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline(always)]\n     do vec::foldl(ia_none, attrs) |ia,attr| {\n         alt attr.node.value.node {\n-          ast::meta_word(@\"inline\") { ia_hint }\n-          ast::meta_list(@\"inline\", items) {\n-            if !vec::is_empty(find_meta_items_by_name(items, \"always\")) {\n+          ast::meta_word(@~\"inline\") { ia_hint }\n+          ast::meta_list(@~\"inline\", items) {\n+            if !vec::is_empty(find_meta_items_by_name(items, ~\"always\")) {\n                 ia_always\n             } else {\n                 ia_hint"}, {"sha": "76625d3f918cd355b84305a1862c13c71b013f44", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -28,7 +28,7 @@ export loc;\n export get_filemap;\n export new_codemap;\n \n-type filename = str;\n+type filename = ~str;\n \n type file_pos = {ch: uint, byte: uint};\n \n@@ -41,11 +41,11 @@ type file_pos = {ch: uint, byte: uint};\n enum file_substr {\n     fss_none,\n     fss_internal(span),\n-    fss_external({filename: str, line: uint, col: uint})\n+    fss_external({filename: ~str, line: uint, col: uint})\n }\n \n type filemap =\n-    @{name: filename, substr: file_substr, src: @str/~,\n+    @{name: filename, substr: file_substr, src: @~str,\n       start_pos: file_pos, mut lines: ~[file_pos]};\n \n type codemap = @{files: dvec<filemap>};\n@@ -55,22 +55,22 @@ type loc = {file: filemap, line: uint, col: uint};\n fn new_codemap() -> codemap { @{files: dvec()} }\n \n fn new_filemap_w_substr(+filename: filename, +substr: file_substr,\n-                        src: @str/~,\n+                        src: @~str,\n                         start_pos_ch: uint, start_pos_byte: uint)\n    -> filemap {\n     ret @{name: filename, substr: substr, src: src,\n           start_pos: {ch: start_pos_ch, byte: start_pos_byte},\n           mut lines: ~[{ch: start_pos_ch, byte: start_pos_byte}]};\n }\n \n-fn new_filemap(+filename: filename, src: @str/~,\n+fn new_filemap(+filename: filename, src: @~str,\n                start_pos_ch: uint, start_pos_byte: uint)\n     -> filemap {\n     ret new_filemap_w_substr(filename, fss_none, src,\n                              start_pos_ch, start_pos_byte);\n }\n \n-fn mk_substr_filename(cm: codemap, sp: span) -> str\n+fn mk_substr_filename(cm: codemap, sp: span) -> ~str\n {\n     let pos = lookup_char_pos(cm, sp.lo);\n     ret #fmt(\"<%s:%u:%u>\", pos.file.name, pos.line, pos.col);\n@@ -121,7 +121,7 @@ fn lookup_byte_pos(map: codemap, pos: uint) -> loc {\n }\n \n fn lookup_char_pos_adj(map: codemap, pos: uint)\n-    -> {filename: str, line: uint, col: uint, file: option<filemap>}\n+    -> {filename: ~str, line: uint, col: uint, file: option<filemap>}\n {\n     let loc = lookup_char_pos(map, pos);\n     alt (loc.file.substr) {\n@@ -158,19 +158,19 @@ fn adjust_span(map: codemap, sp: span) -> span {\n \n enum expn_info_ {\n     expanded_from({call_site: span,\n-                   callie: {name: str, span: option<span>}})\n+                   callie: {name: ~str, span: option<span>}})\n }\n type expn_info = option<@expn_info_>;\n type span = {lo: uint, hi: uint, expn_info: expn_info};\n \n-fn span_to_str_no_adj(sp: span, cm: codemap) -> str {\n+fn span_to_str_no_adj(sp: span, cm: codemap) -> ~str {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);\n     ret #fmt(\"%s:%u:%u: %u:%u\", lo.file.name,\n              lo.line, lo.col, hi.line, hi.col)\n }\n \n-fn span_to_str(sp: span, cm: codemap) -> str {\n+fn span_to_str(sp: span, cm: codemap) -> ~str {\n     let lo = lookup_char_pos_adj(cm, sp.lo);\n     let hi = lookup_char_pos_adj(cm, sp.hi);\n     ret #fmt(\"%s:%u:%u: %u:%u\", lo.filename,\n@@ -194,7 +194,7 @@ fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n     ret @{file: lo.file, lines: lines};\n }\n \n-fn get_line(fm: filemap, line: int) -> str unsafe {\n+fn get_line(fm: filemap, line: int) -> ~str unsafe {\n     let begin: uint = fm.lines[line].byte - fm.start_pos.byte;\n     let end = alt str::find_char_from(*fm.src, '\\n', begin) {\n       some(e) { e }\n@@ -213,20 +213,20 @@ fn lookup_byte_offset(cm: codemap::codemap, chpos: uint)\n     {fm: fm, pos: line_offset + col_offset}\n }\n \n-fn span_to_snippet(sp: span, cm: codemap::codemap) -> str {\n+fn span_to_snippet(sp: span, cm: codemap::codemap) -> ~str {\n     let begin = lookup_byte_offset(cm, sp.lo);\n     let end = lookup_byte_offset(cm, sp.hi);\n     assert begin.fm == end.fm;\n     ret str::slice(*begin.fm.src, begin.pos, end.pos);\n }\n \n-fn get_snippet(cm: codemap::codemap, fidx: uint, lo: uint, hi: uint) -> str\n+fn get_snippet(cm: codemap::codemap, fidx: uint, lo: uint, hi: uint) -> ~str\n {\n     let fm = cm.files[fidx];\n     ret str::slice(*fm.src, lo, hi)\n }\n \n-fn get_filemap(cm: codemap, filename: str) -> filemap {\n+fn get_filemap(cm: codemap, filename: ~str) -> filemap {\n     for cm.files.each |fm| { if fm.name == filename { ret fm; } }\n     //XXjdm the following triggers a mismatched type bug\n     //      (or expected function, found _|_)"}, {"sha": "cda49de8dd076a40357571aaa1e3514f10a1f978", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -10,30 +10,30 @@ export ice_msg;\n export expect;\n \n type emitter = fn@(cmsp: option<(codemap::codemap, span)>,\n-                   msg: str, lvl: level);\n+                   msg: ~str, lvl: level);\n \n \n iface span_handler {\n-    fn span_fatal(sp: span, msg: str) -> !;\n-    fn span_err(sp: span, msg: str);\n-    fn span_warn(sp: span, msg: str);\n-    fn span_note(sp: span, msg: str);\n-    fn span_bug(sp: span, msg: str) -> !;\n-    fn span_unimpl(sp: span, msg: str) -> !;\n+    fn span_fatal(sp: span, msg: ~str) -> !;\n+    fn span_err(sp: span, msg: ~str);\n+    fn span_warn(sp: span, msg: ~str);\n+    fn span_note(sp: span, msg: ~str);\n+    fn span_bug(sp: span, msg: ~str) -> !;\n+    fn span_unimpl(sp: span, msg: ~str) -> !;\n     fn handler() -> handler;\n }\n \n iface handler {\n-    fn fatal(msg: str) -> !;\n-    fn err(msg: str);\n+    fn fatal(msg: ~str) -> !;\n+    fn err(msg: ~str);\n     fn bump_err_count();\n     fn has_errors() -> bool;\n     fn abort_if_errors();\n-    fn warn(msg: str);\n-    fn note(msg: str);\n-    fn bug(msg: str) -> !;\n-    fn unimpl(msg: str) -> !;\n-    fn emit(cmsp: option<(codemap::codemap, span)>, msg: str, lvl: level);\n+    fn warn(msg: ~str);\n+    fn note(msg: ~str);\n+    fn bug(msg: ~str) -> !;\n+    fn unimpl(msg: ~str) -> !;\n+    fn emit(cmsp: option<(codemap::codemap, span)>, msg: ~str, lvl: level);\n }\n \n type handler_t = @{\n@@ -47,37 +47,37 @@ type codemap_t = @{\n };\n \n impl codemap_span_handler of span_handler for codemap_t {\n-    fn span_fatal(sp: span, msg: str) -> ! {\n+    fn span_fatal(sp: span, msg: ~str) -> ! {\n         self.handler.emit(some((self.cm, sp)), msg, fatal);\n         fail;\n     }\n-    fn span_err(sp: span, msg: str) {\n+    fn span_err(sp: span, msg: ~str) {\n         self.handler.emit(some((self.cm, sp)), msg, error);\n         self.handler.bump_err_count();\n     }\n-    fn span_warn(sp: span, msg: str) {\n+    fn span_warn(sp: span, msg: ~str) {\n         self.handler.emit(some((self.cm, sp)), msg, warning);\n     }\n-    fn span_note(sp: span, msg: str) {\n+    fn span_note(sp: span, msg: ~str) {\n         self.handler.emit(some((self.cm, sp)), msg, note);\n     }\n-    fn span_bug(sp: span, msg: str) -> ! {\n+    fn span_bug(sp: span, msg: ~str) -> ! {\n         self.span_fatal(sp, ice_msg(msg));\n     }\n-    fn span_unimpl(sp: span, msg: str) -> ! {\n-        self.span_bug(sp, \"unimplemented \" + msg);\n+    fn span_unimpl(sp: span, msg: ~str) -> ! {\n+        self.span_bug(sp, ~\"unimplemented \" + msg);\n     }\n     fn handler() -> handler {\n         self.handler\n     }\n }\n \n impl codemap_handler of handler for handler_t {\n-    fn fatal(msg: str) -> ! {\n+    fn fatal(msg: ~str) -> ! {\n         self.emit(none, msg, fatal);\n         fail;\n     }\n-    fn err(msg: str) {\n+    fn err(msg: ~str) {\n         self.emit(none, msg, error);\n         self.bump_err_count();\n     }\n@@ -89,28 +89,28 @@ impl codemap_handler of handler for handler_t {\n         let s;\n         alt self.err_count {\n           0u { ret; }\n-          1u { s = \"aborting due to previous error\"; }\n+          1u { s = ~\"aborting due to previous error\"; }\n           _  { s = #fmt[\"aborting due to %u previous errors\",\n                         self.err_count]; }\n         }\n         self.fatal(s);\n     }\n-    fn warn(msg: str) {\n+    fn warn(msg: ~str) {\n         self.emit(none, msg, warning);\n     }\n-    fn note(msg: str) {\n+    fn note(msg: ~str) {\n         self.emit(none, msg, note);\n     }\n-    fn bug(msg: str) -> ! {\n+    fn bug(msg: ~str) -> ! {\n         self.fatal(ice_msg(msg));\n     }\n-    fn unimpl(msg: str) -> ! { self.bug(\"unimplemented \" + msg); }\n-    fn emit(cmsp: option<(codemap::codemap, span)>, msg: str, lvl: level) {\n+    fn unimpl(msg: ~str) -> ! { self.bug(~\"unimplemented \" + msg); }\n+    fn emit(cmsp: option<(codemap::codemap, span)>, msg: ~str, lvl: level) {\n         self.emit(cmsp, msg, lvl);\n     }\n }\n \n-fn ice_msg(msg: str) -> str {\n+fn ice_msg(msg: ~str) -> ~str {\n     #fmt[\"internal compiler error: %s\", msg]\n }\n \n@@ -124,7 +124,7 @@ fn mk_handler(emitter: option<emitter>) -> handler {\n       some(e) { e }\n       none {\n         let f = fn@(cmsp: option<(codemap::codemap, span)>,\n-            msg: str, t: level) {\n+            msg: ~str, t: level) {\n             emit(cmsp, msg, t);\n         };\n         f\n@@ -144,12 +144,12 @@ enum level {\n     note,\n }\n \n-fn diagnosticstr(lvl: level) -> str {\n+fn diagnosticstr(lvl: level) -> ~str {\n     alt lvl {\n-      fatal { \"error\" }\n-      error { \"error\" }\n-      warning { \"warning\" }\n-      note { \"note\" }\n+      fatal { ~\"error\" }\n+      error { ~\"error\" }\n+      warning { ~\"warning\" }\n+      note { ~\"note\" }\n     }\n }\n \n@@ -162,7 +162,7 @@ fn diagnosticcolor(lvl: level) -> u8 {\n     }\n }\n \n-fn print_diagnostic(topic: str, lvl: level, msg: str) {\n+fn print_diagnostic(topic: ~str, lvl: level, msg: ~str) {\n     if str::is_not_empty(topic) {\n         io::stderr().write_str(#fmt[\"%s \", topic]);\n     }\n@@ -177,7 +177,7 @@ fn print_diagnostic(topic: str, lvl: level, msg: str) {\n }\n \n fn emit(cmsp: option<(codemap::codemap, span)>,\n-        msg: str, lvl: level) {\n+        msg: ~str, lvl: level) {\n     alt cmsp {\n       some((cm, sp)) {\n         let sp = codemap::adjust_span(cm,sp);\n@@ -188,7 +188,7 @@ fn emit(cmsp: option<(codemap::codemap, span)>,\n         print_macro_backtrace(cm, sp);\n       }\n       none {\n-        print_diagnostic(\"\", lvl, msg);\n+        print_diagnostic(~\"\", lvl, msg);\n       }\n     }\n }\n@@ -209,16 +209,16 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n     // Print the offending lines\n     for display_lines.each |line| {\n         io::stderr().write_str(#fmt[\"%s:%u \", fm.name, line + 1u]);\n-        let s = codemap::get_line(fm, line as int) + \"\\n\";\n+        let s = codemap::get_line(fm, line as int) + ~\"\\n\";\n         io::stderr().write_str(s);\n     }\n     if elided {\n         let last_line = display_lines[vec::len(display_lines) - 1u];\n         let s = #fmt[\"%s:%u \", fm.name, last_line + 1u];\n         let mut indent = str::len(s);\n-        let mut out = \"\";\n-        while indent > 0u { out += \" \"; indent -= 1u; }\n-        out += \"...\\n\";\n+        let mut out = ~\"\";\n+        while indent > 0u { out += ~\" \"; indent -= 1u; }\n+        out += ~\"...\\n\";\n         io::stderr().write_str(out);\n     }\n \n@@ -234,34 +234,34 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n \n         // indent past |name:## | and the 0-offset column location\n         let mut left = str::len(fm.name) + digits + lo.col + 3u;\n-        let mut s = \"\";\n+        let mut s = ~\"\";\n         while left > 0u { str::push_char(s, ' '); left -= 1u; }\n \n-        s += \"^\";\n+        s += ~\"^\";\n         let hi = codemap::lookup_char_pos(cm, sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n             let mut width = hi.col - lo.col - 1u;\n             while width > 0u { str::push_char(s, '~'); width -= 1u; }\n         }\n-        io::stderr().write_str(s + \"\\n\");\n+        io::stderr().write_str(s + ~\"\\n\");\n     }\n }\n \n fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n     do option::iter (sp.expn_info) |ei| {\n-        let ss = option::map_default(ei.callie.span, @\"\",\n+        let ss = option::map_default(ei.callie.span, @~\"\",\n                                      |span| @codemap::span_to_str(span, cm));\n         print_diagnostic(*ss, note,\n                          #fmt(\"in expansion of #%s\", ei.callie.name));\n         let ss = codemap::span_to_str(ei.call_site, cm);\n-        print_diagnostic(ss, note, \"expansion site\");\n+        print_diagnostic(ss, note, ~\"expansion site\");\n         print_macro_backtrace(cm, ei.call_site);\n     }\n }\n \n fn expect<T: copy>(diag: span_handler,\n-                   opt: option<T>, msg: fn() -> str) -> T {\n+                   opt: option<T>, msg: fn() -> ~str) -> T {\n     alt opt {\n        some(t) { t }\n        none { diag.handler().bug(msg()); }"}, {"sha": "ac2829643becd0cb36d9816e28e9856af0f82d14", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -84,15 +84,15 @@ mod syntax {\n     export parse;\n }\n \n-type ser_tps_map = map::hashmap<str, fn@(@ast::expr) -> ~[@ast::stmt]>;\n-type deser_tps_map = map::hashmap<str, fn@() -> @ast::expr>;\n+type ser_tps_map = map::hashmap<~str, fn@(@ast::expr) -> ~[@ast::stmt]>;\n+type deser_tps_map = map::hashmap<~str, fn@() -> @ast::expr>;\n \n fn expand(cx: ext_ctxt,\n           span: span,\n           _mitem: ast::meta_item,\n           in_items: ~[@ast::item]) -> ~[@ast::item] {\n     fn not_auto_serialize(a: ast::attribute) -> bool {\n-        attr::get_attr_name(a) != @\"auto_serialize\"\n+        attr::get_attr_name(a) != @~\"auto_serialize\"\n     }\n \n     fn filter_attrs(item: @ast::item) -> @ast::item {\n@@ -114,7 +114,7 @@ fn expand(cx: ext_ctxt,\n           }\n \n           _ {\n-            cx.span_err(span, \"#[auto_serialize] can only be \\\n+            cx.span_err(span, ~\"#[auto_serialize] can only be \\\n                                applied to type and enum \\\n                                definitions\");\n             ~[in_item]\n@@ -125,11 +125,11 @@ fn expand(cx: ext_ctxt,\n \n impl helpers for ext_ctxt {\n     fn helper_path(base_path: @ast::path,\n-                   helper_name: str) -> @ast::path {\n+                   helper_name: ~str) -> @ast::path {\n         let head = vec::init(base_path.idents);\n         let tail = vec::last(base_path.idents);\n         self.path(base_path.span,\n-                  vec::append(head, ~[@(helper_name + \"_\" + *tail)]))\n+                  vec::append(head, ~[@(helper_name + ~\"_\" + *tail)]))\n     }\n \n     fn path(span: span, strs: ~[ast::ident]) -> @ast::path {\n@@ -154,7 +154,7 @@ impl helpers for ext_ctxt {\n         let args = do vec::map(input_tys) |ty| {\n             {mode: ast::expl(ast::by_ref),\n              ty: ty,\n-             ident: @\"\",\n+             ident: @~\"\",\n              id: self.next_id()}\n         };\n \n@@ -219,12 +219,16 @@ impl helpers for ext_ctxt {\n                 ast::expr_alt(v, arms, ast::alt_exhaustive)))\n     }\n \n-    fn lit_str(span: span, s: @str/~) -> @ast::expr {\n+    fn lit_str(span: span, s: @~str) -> @ast::expr {\n         self.expr(\n             span,\n-            ast::expr_lit(\n-                @{node: ast::lit_str(s),\n-                  span: span}))\n+            ast::expr_vstore(\n+                self.expr(\n+                    span,\n+                    ast::expr_lit(\n+                        @{node: ast::lit_str(s),\n+                          span: span})),\n+                ast::vstore_uniq))\n     }\n \n     fn lit_uint(span: span, i: uint) -> @ast::expr {\n@@ -293,7 +297,7 @@ fn ser_path(cx: ext_ctxt, tps: ser_tps_map, path: @ast::path,\n         cx.expr(\n             path.span,\n             ast::expr_path(\n-                cx.helper_path(path, \"serialize\")));\n+                cx.helper_path(path, ~\"serialize\")));\n \n     let ty_args = do vec::map(path.types) |ty| {\n         let sv_stmts = ser_ty(cx, tps, ty, cx.clone(s), #ast{ __v });\n@@ -350,7 +354,7 @@ fn is_vec_or_str(ty: @ast::ty) -> bool {\n       // This may be wrong if the user has shadowed (!) str\n       ast::ty_path(@{span: _, global: _, idents: ids,\n                              rp: none, types: _}, _)\n-      if ids == ~[@\"str\"] { true }\n+      if ids == ~[@~\"str\"] { true }\n       _ { false }\n     }\n }\n@@ -388,7 +392,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n       }\n \n       ast::ty_ptr(_) | ast::ty_rptr(_, _) {\n-        cx.span_err(ty.span, \"cannot serialize pointer types\");\n+        cx.span_err(ty.span, ~\"cannot serialize pointer types\");\n         ~[]\n       }\n \n@@ -410,7 +414,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n       }\n \n       ast::ty_fn(_, _) {\n-        cx.span_err(ty.span, \"cannot serialize function types\");\n+        cx.span_err(ty.span, ~\"cannot serialize function types\");\n         ~[]\n       }\n \n@@ -467,12 +471,12 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n       }\n \n       ast::ty_mac(_) {\n-        cx.span_err(ty.span, \"cannot serialize macro types\");\n+        cx.span_err(ty.span, ~\"cannot serialize macro types\");\n         ~[]\n       }\n \n       ast::ty_infer {\n-        cx.span_err(ty.span, \"cannot serialize inferred types\");\n+        cx.span_err(ty.span, ~\"cannot serialize inferred types\");\n         ~[]\n       }\n \n@@ -499,7 +503,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n       }\n \n       ast::ty_vstore(_, _) {\n-        cx.span_unimpl(ty.span, \"serialization for vstore types\");\n+        cx.span_unimpl(ty.span, ~\"serialization for vstore types\");\n       }\n \n     }\n@@ -521,20 +525,20 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n              ty: cx.ty_fn(span,\n                           ~[cx.ty_path(span, ~[tp.ident], ~[])],\n                           cx.ty_nil(span)),\n-             ident: @(\"__s\" + *tp.ident),\n+             ident: @(~\"__s\" + *tp.ident),\n              id: cx.next_id()});\n \n     #debug[\"tp_inputs = %?\", tp_inputs];\n \n \n     let ser_inputs: ~[ast::arg] =\n         vec::append(~[{mode: ast::expl(ast::by_ref),\n-                      ty: cx.ty_path(span, ~[@\"__S\"], ~[]),\n-                      ident: @\"__s\",\n+                      ty: cx.ty_path(span, ~[@~\"__S\"], ~[]),\n+                      ident: @~\"__s\",\n                       id: cx.next_id()},\n                      {mode: ast::expl(ast::by_ref),\n                       ty: v_ty,\n-                      ident: @\"__v\",\n+                      ident: @~\"__v\",\n                       id: cx.next_id()}],\n                     tp_inputs);\n \n@@ -552,12 +556,12 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n \n     let ser_bnds = @~[\n         ast::bound_trait(cx.ty_path(span,\n-                                    ~[@\"std\", @\"serialization\",\n-                                     @\"serializer\"],\n+                                    ~[@~\"std\", @~\"serialization\",\n+                                     @~\"serializer\"],\n                                     ~[]))];\n \n     let ser_tps: ~[ast::ty_param] =\n-        vec::append(~[{ident: @\"__S\",\n+        vec::append(~[{ident: @~\"__S\",\n                       id: cx.next_id(),\n                       bounds: ser_bnds}],\n                     vec::map(tps, |tp| cx.clone_ty_param(tp)));\n@@ -569,7 +573,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n     let ser_blk = cx.blk(span,\n                          f(cx, tps_map, #ast{ __s }, #ast{ __v }));\n \n-    @{ident: @(\"serialize_\" + *name),\n+    @{ident: @(~\"serialize_\" + *name),\n       attrs: ~[],\n       id: cx.next_id(),\n       node: ast::item_fn({inputs: ser_inputs,\n@@ -594,7 +598,7 @@ fn deser_path(cx: ext_ctxt, tps: deser_tps_map, path: @ast::path,\n         cx.expr(\n             path.span,\n             ast::expr_path(\n-                cx.helper_path(path, \"deserialize\")));\n+                cx.helper_path(path, ~\"deserialize\")));\n \n     let ty_args = do vec::map(path.types) |ty| {\n         let dv_expr = deser_ty(cx, tps, ty, cx.clone(d));\n@@ -722,7 +726,7 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n       }\n \n       ast::ty_vstore(_, _) {\n-        cx.span_unimpl(ty.span, \"deserialization for vstore types\");\n+        cx.span_unimpl(ty.span, ~\"deserialization for vstore types\");\n       }\n     }\n }\n@@ -742,15 +746,15 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n              ty: cx.ty_fn(span,\n                           ~[],\n                           cx.ty_path(span, ~[tp.ident], ~[])),\n-             ident: @(\"__d\" + *tp.ident),\n+             ident: @(~\"__d\" + *tp.ident),\n              id: cx.next_id()});\n \n     #debug[\"tp_inputs = %?\", tp_inputs];\n \n     let deser_inputs: ~[ast::arg] =\n         vec::append(~[{mode: ast::expl(ast::by_ref),\n-                      ty: cx.ty_path(span, ~[@\"__D\"], ~[]),\n-                      ident: @\"__d\",\n+                      ty: cx.ty_path(span, ~[@~\"__D\"], ~[]),\n+                      ident: @~\"__d\",\n                       id: cx.next_id()}],\n                     tp_inputs);\n \n@@ -768,11 +772,11 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n     let deser_bnds = @~[\n         ast::bound_trait(cx.ty_path(\n             span,\n-            ~[@\"std\", @\"serialization\", @\"deserializer\"],\n+            ~[@~\"std\", @~\"serialization\", @~\"deserializer\"],\n             ~[]))];\n \n     let deser_tps: ~[ast::ty_param] =\n-        vec::append(~[{ident: @\"__D\",\n+        vec::append(~[{ident: @~\"__D\",\n                       id: cx.next_id(),\n                       bounds: deser_bnds}],\n                     vec::map(tps, |tp| {\n@@ -784,7 +788,7 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n \n     let deser_blk = cx.expr_blk(f(cx, tps_map, #ast(expr){__d}));\n \n-    @{ident: @(\"deserialize_\" + *name),\n+    @{ident: @(~\"deserialize_\" + *name),\n       attrs: ~[],\n       id: cx.next_id(),\n       node: ast::item_fn({inputs: deser_inputs,"}, {"sha": "b7d17a9d65201ca311e7396db3ccb5ea68173552", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -42,47 +42,47 @@ enum syntax_extension {\n \n // A temporary hard-coded map of methods for expanding syntax extension\n // AST nodes into full ASTs\n-fn syntax_expander_table() -> hashmap<str, syntax_extension> {\n+fn syntax_expander_table() -> hashmap<~str, syntax_extension> {\n     fn builtin(f: syntax_expander_) -> syntax_extension\n         {normal({expander: f, span: none})}\n     fn builtin_item_tt(f: syntax_expander_tt_item_) -> syntax_extension {\n         item_tt({expander: f, span: none})\n     }\n     let syntax_expanders = str_hash::<syntax_extension>();\n-    syntax_expanders.insert(\"macro\",\n+    syntax_expanders.insert(~\"macro\",\n                             macro_defining(ext::simplext::add_new_extension));\n-    syntax_expanders.insert(\"macro_rules\",\n+    syntax_expanders.insert(~\"macro_rules\",\n                             builtin_item_tt(\n                                 ext::tt::macro_rules::add_new_extension));\n-    syntax_expanders.insert(\"fmt\", builtin(ext::fmt::expand_syntax_ext));\n-    syntax_expanders.insert(\"auto_serialize\",\n+    syntax_expanders.insert(~\"fmt\", builtin(ext::fmt::expand_syntax_ext));\n+    syntax_expanders.insert(~\"auto_serialize\",\n                             item_decorator(ext::auto_serialize::expand));\n-    syntax_expanders.insert(\"env\", builtin(ext::env::expand_syntax_ext));\n-    syntax_expanders.insert(\"concat_idents\",\n+    syntax_expanders.insert(~\"env\", builtin(ext::env::expand_syntax_ext));\n+    syntax_expanders.insert(~\"concat_idents\",\n                             builtin(ext::concat_idents::expand_syntax_ext));\n-    syntax_expanders.insert(\"ident_to_str\",\n+    syntax_expanders.insert(~\"ident_to_str\",\n                             builtin(ext::ident_to_str::expand_syntax_ext));\n-    syntax_expanders.insert(\"log_syntax\",\n+    syntax_expanders.insert(~\"log_syntax\",\n                             builtin(ext::log_syntax::expand_syntax_ext));\n-    syntax_expanders.insert(\"ast\",\n+    syntax_expanders.insert(~\"ast\",\n                             builtin(ext::qquote::expand_ast));\n-    syntax_expanders.insert(\"line\",\n+    syntax_expanders.insert(~\"line\",\n                             builtin(ext::source_util::expand_line));\n-    syntax_expanders.insert(\"col\",\n+    syntax_expanders.insert(~\"col\",\n                             builtin(ext::source_util::expand_col));\n-    syntax_expanders.insert(\"file\",\n+    syntax_expanders.insert(~\"file\",\n                             builtin(ext::source_util::expand_file));\n-    syntax_expanders.insert(\"stringify\",\n+    syntax_expanders.insert(~\"stringify\",\n                             builtin(ext::source_util::expand_stringify));\n-    syntax_expanders.insert(\"include\",\n+    syntax_expanders.insert(~\"include\",\n                             builtin(ext::source_util::expand_include));\n-    syntax_expanders.insert(\"include_str\",\n+    syntax_expanders.insert(~\"include_str\",\n                             builtin(ext::source_util::expand_include_str));\n-    syntax_expanders.insert(\"include_bin\",\n+    syntax_expanders.insert(~\"include_bin\",\n                             builtin(ext::source_util::expand_include_bin));\n-    syntax_expanders.insert(\"mod\",\n+    syntax_expanders.insert(~\"mod\",\n                             builtin(ext::source_util::expand_mod));\n-    syntax_expanders.insert(\"proto\",\n+    syntax_expanders.insert(~\"proto\",\n                             builtin_item_tt(ext::pipes::expand_proto));\n     ret syntax_expanders;\n }\n@@ -98,11 +98,11 @@ iface ext_ctxt {\n     fn mod_path() -> ~[ast::ident];\n     fn bt_push(ei: codemap::expn_info_);\n     fn bt_pop();\n-    fn span_fatal(sp: span, msg: str) -> !;\n-    fn span_err(sp: span, msg: str);\n-    fn span_unimpl(sp: span, msg: str) -> !;\n-    fn span_bug(sp: span, msg: str) -> !;\n-    fn bug(msg: str) -> !;\n+    fn span_fatal(sp: span, msg: ~str) -> !;\n+    fn span_err(sp: span, msg: ~str);\n+    fn span_unimpl(sp: span, msg: ~str) -> !;\n+    fn span_bug(sp: span, msg: ~str) -> !;\n+    fn bug(msg: ~str) -> !;\n     fn next_id() -> ast::node_id;\n }\n \n@@ -137,26 +137,26 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n               some(@expanded_from({call_site: {expn_info: prev, _}, _})) {\n                 self.backtrace = prev\n               }\n-              _ { self.bug(\"tried to pop without a push\"); }\n+              _ { self.bug(~\"tried to pop without a push\"); }\n             }\n         }\n-        fn span_fatal(sp: span, msg: str) -> ! {\n+        fn span_fatal(sp: span, msg: ~str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_fatal(sp, msg);\n         }\n-        fn span_err(sp: span, msg: str) {\n+        fn span_err(sp: span, msg: ~str) {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_err(sp, msg);\n         }\n-        fn span_unimpl(sp: span, msg: str) -> ! {\n+        fn span_unimpl(sp: span, msg: ~str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_unimpl(sp, msg);\n         }\n-        fn span_bug(sp: span, msg: str) -> ! {\n+        fn span_bug(sp: span, msg: ~str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_bug(sp, msg);\n         }\n-        fn bug(msg: str) -> ! {\n+        fn bug(msg: ~str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.handler().bug(msg);\n         }\n@@ -173,7 +173,7 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n     ret imp as ext_ctxt\n }\n \n-fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, error: str) -> str {\n+fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, error: ~str) -> ~str {\n     alt expr.node {\n       ast::expr_lit(l) {\n         alt l.node {\n@@ -185,7 +185,7 @@ fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, error: str) -> str {\n     }\n }\n \n-fn expr_to_ident(cx: ext_ctxt, expr: @ast::expr, error: str) -> ast::ident {\n+fn expr_to_ident(cx: ext_ctxt, expr: @ast::expr, error: ~str) -> ast::ident {\n     alt expr.node {\n       ast::expr_path(p) {\n         if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {\n@@ -197,12 +197,12 @@ fn expr_to_ident(cx: ext_ctxt, expr: @ast::expr, error: str) -> ast::ident {\n }\n \n fn get_mac_args_no_max(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                       min: uint, name: str) -> ~[@ast::expr] {\n+                       min: uint, name: ~str) -> ~[@ast::expr] {\n     ret get_mac_args(cx, sp, arg, min, none, name);\n }\n \n fn get_mac_args(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n-                min: uint, max: option<uint>, name: str) -> ~[@ast::expr] {\n+                min: uint, max: option<uint>, name: ~str) -> ~[@ast::expr] {\n     alt arg {\n       some(expr) {\n         alt expr.node {\n@@ -235,7 +235,7 @@ fn get_mac_body(cx: ext_ctxt, sp: span, args: ast::mac_body)\n {\n     alt (args) {\n       some(body) {body}\n-      none {cx.span_fatal(sp, \"missing macro body\")}\n+      none {cx.span_fatal(sp, ~\"missing macro body\")}\n     }\n }\n "}, {"sha": "5eca1e8e17c327d787666368286b01f001641682", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -11,10 +11,6 @@ fn mk_lit(cx: ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n     let sp_lit = @{node: lit, span: sp};\n     mk_expr(cx, sp, ast::expr_lit(sp_lit))\n }\n-fn mk_str(cx: ext_ctxt, sp: span, s: str) -> @ast::expr {\n-    let lit = ast::lit_str(@s);\n-    ret mk_lit(cx, sp, lit);\n-}\n fn mk_int(cx: ext_ctxt, sp: span, i: int) -> @ast::expr {\n     let lit = ast::lit_int(i as i64, ast::ty_i);\n     ret mk_lit(cx, sp, lit);\n@@ -23,6 +19,10 @@ fn mk_uint(cx: ext_ctxt, sp: span, u: uint) -> @ast::expr {\n     let lit = ast::lit_uint(u as u64, ast::ty_u);\n     ret mk_lit(cx, sp, lit);\n }\n+fn mk_u8(cx: ext_ctxt, sp: span, u: u8) -> @ast::expr {\n+    let lit = ast::lit_uint(u as u64, ast::ty_u8);\n+    ret mk_lit(cx, sp, lit);\n+}\n fn mk_binary(cx: ext_ctxt, sp: span, op: ast::binop,\n              lhs: @ast::expr, rhs: @ast::expr)\n    -> @ast::expr {\n@@ -77,6 +77,13 @@ fn mk_fixed_vec_e(cx: ext_ctxt, sp: span, exprs: ~[@ast::expr]) ->\n    @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs), ast::vstore_fixed(none))\n }\n+fn mk_base_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n+    let lit = ast::lit_str(@s);\n+    ret mk_lit(cx, sp, lit);\n+}\n+fn mk_uniq_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n+    mk_vstore_e(cx, sp, mk_base_str(cx, sp, s), ast::vstore_uniq)\n+}\n \n fn mk_rec_e(cx: ext_ctxt, sp: span,\n             fields: ~[{ident: ast::ident, ex: @ast::expr}]) ->"}, {"sha": "b3545cc635d4f11e4240930288fcbf75853913f7", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -2,10 +2,10 @@ import base::*;\n \n fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args_no_max(cx,sp,arg,1u,\"concat_idents\");\n-    let mut res = \"\";\n+    let args = get_mac_args_no_max(cx,sp,arg,1u,~\"concat_idents\");\n+    let mut res = ~\"\";\n     for args.each |e| {\n-        res += *expr_to_ident(cx, e, \"expected an ident\");\n+        res += *expr_to_ident(cx, e, ~\"expected an ident\");\n     }\n \n     ret @{id: cx.next_id(),"}, {"sha": "e03fc2ce47b0e7f77b5573e179c733c19a376376", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -5,26 +5,23 @@\n  * interface.\n  */\n import base::*;\n-import build::mk_lit;\n+import build::mk_uniq_str;\n export expand_syntax_ext;\n \n fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx, sp, arg, 1u, option::some(1u), \"env\");\n+    let args = get_mac_args(cx, sp, arg, 1u, option::some(1u), ~\"env\");\n \n     // FIXME (#2248): if this was more thorough it would manufacture an\n     // option<str> rather than just an maybe-empty string.\n \n-    let var = expr_to_str(cx, args[0], \"#env requires a string\");\n+    let var = expr_to_str(cx, args[0], ~\"#env requires a string\");\n     alt os::getenv(var) {\n-      option::none { ret make_new_str(cx, sp, \"\"); }\n-      option::some(s) { ret make_new_str(cx, sp, s); }\n+      option::none { ret mk_uniq_str(cx, sp, ~\"\"); }\n+      option::some(s) { ret mk_uniq_str(cx, sp, s); }\n     }\n }\n \n-fn make_new_str(cx: ext_ctxt, sp: codemap::span, +s: str) -> @ast::expr {\n-    ret mk_lit(cx, sp, ast::lit_str(@s));\n-}\n //\n // Local Variables:\n // mode: rust"}, {"sha": "2a41afc97430dd357e15c7a78364dafea229fbea", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -10,7 +10,7 @@ import parse::{parser, parse_expr_from_source_str, new_parser_from_tt};\n \n import codemap::{span, expanded_from};\n \n-fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n+fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                e: expr_, s: span, fld: ast_fold,\n                orig: fn@(expr_, span, ast_fold) -> (expr_, span))\n     -> (expr_, span)\n@@ -54,7 +54,7 @@ fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n                   }\n                   some(item_tt(*)) {\n                     cx.span_fatal(pth.span,\n-                                  \"cannot use item macros in this context\");\n+                                  ~\"cannot use item macros in this context\");\n                   }\n                 }\n               }\n@@ -91,14 +91,14 @@ fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n \n                 }\n               }\n-              _ { cx.span_bug(mac.span, \"naked syntactic bit\") }\n+              _ { cx.span_bug(mac.span, ~\"naked syntactic bit\") }\n             }\n           }\n           _ { orig(e, s, fld) }\n         };\n }\n \n-fn expand_mod_items(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n+fn expand_mod_items(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                     module: ast::_mod, fld: ast_fold,\n                     orig: fn@(ast::_mod, ast_fold) -> ast::_mod)\n     -> ast::_mod\n@@ -133,7 +133,7 @@ fn expand_mod_items(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n }\n \n /* record module we enter for `#mod` */\n-fn expand_item(exts: hashmap<str, syntax_extension>,\n+fn expand_item(exts: hashmap<~str, syntax_extension>,\n                cx: ext_ctxt, &&it: @ast::item, fld: ast_fold,\n                orig: fn@(&&@ast::item, ast_fold) -> option<@ast::item>)\n     -> option<@ast::item>\n@@ -160,7 +160,7 @@ fn expand_item(exts: hashmap<str, syntax_extension>,\n     }\n }\n \n-fn expand_item_mac(exts: hashmap<str, syntax_extension>,\n+fn expand_item_mac(exts: hashmap<~str, syntax_extension>,\n                    cx: ext_ctxt, &&it: @ast::item,\n                    fld: ast_fold) -> option<@ast::item> {\n     alt it.node {\n@@ -179,7 +179,7 @@ fn expand_item_mac(exts: hashmap<str, syntax_extension>,\n             let maybe_it = alt expanded {\n               mr_item(it) { fld.fold_item(it) }\n               mr_expr(e) { cx.span_fatal(pth.span,\n-                                         \"expr macro in item position: \" +\n+                                         ~\"expr macro in item position: \" +\n                                          *extname) }\n               mr_def(mdef) {\n                 exts.insert(*mdef.ident, mdef.ext);\n@@ -194,7 +194,7 @@ fn expand_item_mac(exts: hashmap<str, syntax_extension>,\n         }\n       }\n       _ {\n-        cx.span_bug(it.span, \"invalid item macro invocation\");\n+        cx.span_bug(it.span, ~\"invalid item macro invocation\");\n       }\n     }\n }\n@@ -209,9 +209,9 @@ fn new_span(cx: ext_ctxt, sp: span) -> span {\n // is substantially more mature, these should move from here, into a\n // compiled part of libcore at very least.\n \n-fn core_macros() -> str {\n+fn core_macros() -> ~str {\n     ret\n-\"{\n+~\"{\n     #macro([#error[f, ...], log(core::error, #fmt[f, ...])]);\n     #macro([#warn[f, ...], log(core::warn, #fmt[f, ...])]);\n     #macro([#info[f, ...], log(core::info, #fmt[f, ...])]);\n@@ -231,7 +231,7 @@ fn expand_crate(parse_sess: parse::parse_sess,\n           new_span: |a|new_span(cx, a)\n           with *afp};\n     let f = make_fold(f_pre);\n-    let cm = parse_expr_from_source_str(\"<core-macros>\",\n+    let cm = parse_expr_from_source_str(~\"<core-macros>\",\n                                         @core_macros(),\n                                         cfg,\n                                         parse_sess);"}, {"sha": "53b5db8b6a619651ed210be847f0c1e4d9c02d2e", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -13,17 +13,17 @@ export expand_syntax_ext;\n \n fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args_no_max(cx, sp, arg, 1u, \"fmt\");\n+    let args = get_mac_args_no_max(cx, sp, arg, 1u, ~\"fmt\");\n     let fmt =\n         expr_to_str(cx, args[0],\n-                    \"first argument to #fmt must be a string literal.\");\n+                    ~\"first argument to #fmt must be a string literal.\");\n     let fmtspan = args[0].span;\n     #debug(\"Format string:\");\n     log(debug, fmt);\n-    fn parse_fmt_err_(cx: ext_ctxt, sp: span, msg: str) -> ! {\n+    fn parse_fmt_err_(cx: ext_ctxt, sp: span, msg: ~str) -> ! {\n         cx.span_fatal(sp, msg);\n     }\n-    let parse_fmt_err = fn@(s: str) -> ! {\n+    let parse_fmt_err = fn@(s: ~str) -> ! {\n         parse_fmt_err_(cx, fmtspan, s)\n     };\n     let pieces = parse_fmt_string(fmt, parse_fmt_err);\n@@ -38,7 +38,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n                   pieces: ~[piece], args: ~[@ast::expr])\n    -> @ast::expr {\n     fn make_path_vec(_cx: ext_ctxt, ident: ast::ident) -> ~[ast::ident] {\n-        ret ~[@\"extfmt\", @\"rt\", ident];\n+        ret ~[@~\"extfmt\", @~\"rt\", ident];\n     }\n     fn make_rt_path_expr(cx: ext_ctxt, sp: span,\n                          ident: ast::ident) -> @ast::expr {\n@@ -50,14 +50,14 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n \n     fn make_rt_conv_expr(cx: ext_ctxt, sp: span, cnv: conv) -> @ast::expr {\n         fn make_flags(cx: ext_ctxt, sp: span, flags: ~[flag]) -> @ast::expr {\n-            let mut tmp_expr = make_rt_path_expr(cx, sp, @\"flag_none\");\n+            let mut tmp_expr = make_rt_path_expr(cx, sp, @~\"flag_none\");\n             for flags.each |f| {\n                 let fstr = alt f {\n-                  flag_left_justify { \"flag_left_justify\" }\n-                  flag_left_zero_pad { \"flag_left_zero_pad\" }\n-                  flag_space_for_sign { \"flag_space_for_sign\" }\n-                  flag_sign_always { \"flag_sign_always\" }\n-                  flag_alternate { \"flag_alternate\" }\n+                  flag_left_justify { ~\"flag_left_justify\" }\n+                  flag_left_zero_pad { ~\"flag_left_zero_pad\" }\n+                  flag_space_for_sign { ~\"flag_space_for_sign\" }\n+                  flag_sign_always { ~\"flag_sign_always\" }\n+                  flag_alternate { ~\"flag_alternate\" }\n                 };\n                 tmp_expr = mk_binary(cx, sp, ast::bitor, tmp_expr,\n                                      make_rt_path_expr(cx, sp, @fstr));\n@@ -67,40 +67,40 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         fn make_count(cx: ext_ctxt, sp: span, cnt: count) -> @ast::expr {\n             alt cnt {\n               count_implied {\n-                ret make_rt_path_expr(cx, sp, @\"count_implied\");\n+                ret make_rt_path_expr(cx, sp, @~\"count_implied\");\n               }\n               count_is(c) {\n                 let count_lit = mk_int(cx, sp, c);\n-                let count_is_path = make_path_vec(cx, @\"count_is\");\n+                let count_is_path = make_path_vec(cx, @~\"count_is\");\n                 let count_is_args = ~[count_lit];\n                 ret mk_call(cx, sp, count_is_path, count_is_args);\n               }\n-              _ { cx.span_unimpl(sp, \"unimplemented #fmt conversion\"); }\n+              _ { cx.span_unimpl(sp, ~\"unimplemented #fmt conversion\"); }\n             }\n         }\n         fn make_ty(cx: ext_ctxt, sp: span, t: ty) -> @ast::expr {\n             let mut rt_type;\n             alt t {\n               ty_hex(c) {\n                 alt c {\n-                  case_upper { rt_type = \"ty_hex_upper\"; }\n-                  case_lower { rt_type = \"ty_hex_lower\"; }\n+                  case_upper { rt_type = ~\"ty_hex_upper\"; }\n+                  case_lower { rt_type = ~\"ty_hex_lower\"; }\n                 }\n               }\n-              ty_bits { rt_type = \"ty_bits\"; }\n-              ty_octal { rt_type = \"ty_octal\"; }\n-              _ { rt_type = \"ty_default\"; }\n+              ty_bits { rt_type = ~\"ty_bits\"; }\n+              ty_octal { rt_type = ~\"ty_octal\"; }\n+              _ { rt_type = ~\"ty_default\"; }\n             }\n             ret make_rt_path_expr(cx, sp, @rt_type);\n         }\n         fn make_conv_rec(cx: ext_ctxt, sp: span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n             ret mk_rec_e(cx, sp,\n-                         ~[{ident: @\"flags\", ex: flags_expr},\n-                          {ident: @\"width\", ex: width_expr},\n-                          {ident: @\"precision\", ex: precision_expr},\n-                          {ident: @\"ty\", ex: ty_expr}]);\n+                         ~[{ident: @~\"flags\", ex: flags_expr},\n+                          {ident: @~\"width\", ex: width_expr},\n+                          {ident: @~\"precision\", ex: precision_expr},\n+                          {ident: @~\"ty\", ex: ty_expr}]);\n         }\n         let rt_conv_flags = make_flags(cx, sp, cnv.flags);\n         let rt_conv_width = make_count(cx, sp, cnv.width);\n@@ -109,9 +109,9 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         ret make_conv_rec(cx, sp, rt_conv_flags, rt_conv_width,\n                           rt_conv_precision, rt_conv_ty);\n     }\n-    fn make_conv_call(cx: ext_ctxt, sp: span, conv_type: str, cnv: conv,\n+    fn make_conv_call(cx: ext_ctxt, sp: span, conv_type: ~str, cnv: conv,\n                       arg: @ast::expr) -> @ast::expr {\n-        let fname = \"conv_\" + conv_type;\n+        let fname = ~\"conv_\" + conv_type;\n         let path = make_path_vec(cx, @fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         let args = ~[cnv_expr, arg];\n@@ -131,7 +131,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n               _ { ret false; }\n             }\n         }\n-        let unsupported = \"conversion not supported in #fmt string\";\n+        let unsupported = ~\"conversion not supported in #fmt string\";\n         alt cnv.param {\n           option::none { }\n           _ { cx.span_unimpl(sp, unsupported); }\n@@ -142,15 +142,15 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n               flag_sign_always {\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n-                                  \"+ flag only valid in \" +\n-                                      \"signed #fmt conversion\");\n+                                  ~\"+ flag only valid in \" +\n+                                      ~\"signed #fmt conversion\");\n                 }\n               }\n               flag_space_for_sign {\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n-                                  \"space flag only valid in \" +\n-                                      \"signed #fmt conversions\");\n+                                  ~\"space flag only valid in \" +\n+                                      ~\"signed #fmt conversions\");\n                 }\n               }\n               flag_left_zero_pad { }\n@@ -168,27 +168,27 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n           _ { cx.span_unimpl(sp, unsupported); }\n         }\n         alt cnv.ty {\n-          ty_str { ret make_conv_call(cx, arg.span, \"str\", cnv, arg); }\n+          ty_str { ret make_conv_call(cx, arg.span, ~\"str\", cnv, arg); }\n           ty_int(sign) {\n             alt sign {\n-              signed { ret make_conv_call(cx, arg.span, \"int\", cnv, arg); }\n+              signed { ret make_conv_call(cx, arg.span, ~\"int\", cnv, arg); }\n               unsigned {\n-                ret make_conv_call(cx, arg.span, \"uint\", cnv, arg);\n+                ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg);\n               }\n             }\n           }\n-          ty_bool { ret make_conv_call(cx, arg.span, \"bool\", cnv, arg); }\n-          ty_char { ret make_conv_call(cx, arg.span, \"char\", cnv, arg); }\n-          ty_hex(_) { ret make_conv_call(cx, arg.span, \"uint\", cnv, arg); }\n-          ty_bits { ret make_conv_call(cx, arg.span, \"uint\", cnv, arg); }\n-          ty_octal { ret make_conv_call(cx, arg.span, \"uint\", cnv, arg); }\n-          ty_float { ret make_conv_call(cx, arg.span, \"float\", cnv, arg); }\n-          ty_poly { ret make_conv_call(cx, arg.span, \"poly\", cnv, arg); }\n+          ty_bool { ret make_conv_call(cx, arg.span, ~\"bool\", cnv, arg); }\n+          ty_char { ret make_conv_call(cx, arg.span, ~\"char\", cnv, arg); }\n+          ty_hex(_) { ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n+          ty_bits { ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n+          ty_octal { ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n+          ty_float { ret make_conv_call(cx, arg.span, ~\"float\", cnv, arg); }\n+          ty_poly { ret make_conv_call(cx, arg.span, ~\"poly\", cnv, arg); }\n         }\n     }\n     fn log_conv(c: conv) {\n         alt c.param {\n-          some(p) { log(debug, \"param: \" + int::to_str(p, 10u)); }\n+          some(p) { log(debug, ~\"param: \" + int::to_str(p, 10u)); }\n           _ { #debug(\"param: none\"); }\n         }\n         for c.flags.each |f| {\n@@ -202,20 +202,20 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         }\n         alt c.width {\n           count_is(i) { log(debug,\n-                                 \"width: count is \" + int::to_str(i, 10u)); }\n+                                 ~\"width: count is \" + int::to_str(i, 10u)); }\n           count_is_param(i) {\n             log(debug,\n-                     \"width: count is param \" + int::to_str(i, 10u));\n+                     ~\"width: count is param \" + int::to_str(i, 10u));\n           }\n           count_is_next_param { #debug(\"width: count is next param\"); }\n           count_implied { #debug(\"width: count is implied\"); }\n         }\n         alt c.precision {\n           count_is(i) { log(debug,\n-                                 \"prec: count is \" + int::to_str(i, 10u)); }\n+                                 ~\"prec: count is \" + int::to_str(i, 10u)); }\n           count_is_param(i) {\n             log(debug,\n-                     \"prec: count is param \" + int::to_str(i, 10u));\n+                     ~\"prec: count is param \" + int::to_str(i, 10u));\n           }\n           count_is_next_param { #debug(\"prec: count is next param\"); }\n           count_implied { #debug(\"prec: count is implied\"); }\n@@ -249,14 +249,14 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     for pieces.each |pc| {\n         alt pc {\n           piece_string(s) {\n-            vec::push(piece_exprs, mk_str(cx, fmt_sp, s));\n+            vec::push(piece_exprs, mk_uniq_str(cx, fmt_sp, s));\n           }\n           piece_conv(conv) {\n             n += 1u;\n             if n >= nargs {\n                 cx.span_fatal(sp,\n-                              \"not enough arguments to #fmt \" +\n-                                  \"for the given format string\");\n+                              ~\"not enough arguments to #fmt \" +\n+                                  ~\"for the given format string\");\n             }\n             #debug(\"Building conversion:\");\n             log_conv(conv);\n@@ -275,7 +275,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     }\n \n     let arg_vec = mk_fixed_vec_e(cx, fmt_sp, piece_exprs);\n-    ret mk_call(cx, fmt_sp, ~[@\"str\", @\"concat\"], ~[arg_vec]);\n+    ret mk_call(cx, fmt_sp, ~[@~\"str\", @~\"concat\"], ~[arg_vec]);\n }\n //\n // Local Variables:"}, {"sha": "54f97912f3d5807c602266de8c60b57abc3fd51b", "filename": "src/libsyntax/ext/ident_to_str.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fident_to_str.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -1,12 +1,11 @@\n import base::*;\n-import build::mk_lit;\n+import build::mk_uniq_str;\n import option;\n \n fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx,sp,arg,1u,option::some(1u),\"ident_to_str\");\n+    let args = get_mac_args(cx,sp,arg,1u,option::some(1u),~\"ident_to_str\");\n \n-    ret mk_lit(cx, sp,\n-               ast::lit_str(expr_to_ident(cx, args[0u],\n-                                          \"expected an ident\")));\n+    ret mk_uniq_str(cx, sp, *expr_to_ident(cx, args[0u],\n+                                           ~\"expected an ident\"));\n }"}, {"sha": "70d83b164c847bb62358bf949c0d928db951d3a4", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -3,11 +3,11 @@ import io::writer_util;\n \n fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args_no_max(cx,sp,arg,0u,\"log_syntax\");\n+    let args = get_mac_args_no_max(cx,sp,arg,0u,~\"log_syntax\");\n     cx.print_backtrace();\n     io::stdout().write_line(\n         str::connect(vec::map(args,\n-                              |&&ex| print::pprust::expr_to_str(ex)), \", \")\n+                              |&&ex| print::pprust::expr_to_str(ex)), ~\", \")\n     );\n \n     //trivial expression"}, {"sha": "cb0abe9e8e5a96d26772df1b1bf556accd6095b7", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -7,7 +7,7 @@ import ast::{ident, node_id};\n import codemap::span;\n import ext::base::mk_ctxt;\n \n-fn ident(s: str) -> ast::ident {\n+fn ident(s: ~str) -> ast::ident {\n     @(copy s)\n }\n "}, {"sha": "cf29c409e6ba9d8addb037d0da24bc22b4db812f", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -28,8 +28,8 @@ impl proto_parser for parser {\n         };\n         self.bump();\n         let dir = alt dir {\n-          @\"send\" { send }\n-          @\"recv\" { recv }\n+          @~\"send\" { send }\n+          @~\"recv\" { recv }\n           _ { fail }\n         };\n "}, {"sha": "9406458d1acdc8317b84bb33213829268200dd60", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -23,10 +23,10 @@ enum direction {\n }\n \n impl of to_str for direction {\n-    fn to_str() -> str {\n+    fn to_str() -> ~str {\n         alt self {\n-          send { \"send\" }\n-          recv { \"recv\" }\n+          send { ~\"send\" }\n+          recv { ~\"recv\" }\n         }\n     }\n }\n@@ -68,35 +68,35 @@ impl methods for message {\n           message(id, tys, this, next, next_tys) {\n             let next = this.proto.get_state(next);\n             assert next_tys.len() == next.ty_params.len();\n-            let arg_names = tys.mapi(|i, _ty| @(\"x_\" + i.to_str()));\n+            let arg_names = tys.mapi(|i, _ty| @(~\"x_\" + i.to_str()));\n \n             let args_ast = (arg_names, tys).map(\n                 |n, t| cx.arg_mode(n, t, ast::by_copy)\n             );\n \n             let args_ast = vec::append(\n-                ~[cx.arg_mode(@\"pipe\",\n+                ~[cx.arg_mode(@~\"pipe\",\n                               cx.ty_path(path(this.data_name())\n                                         .add_tys(cx.ty_vars(this.ty_params))),\n                               ast::by_copy)],\n                 args_ast);\n \n             let pat = alt (this.dir, next.dir) {\n-              (send, send) { \"(c, s)\" }\n-              (send, recv) { \"(s, c)\" }\n-              (recv, send) { \"(s, c)\" }\n-              (recv, recv) { \"(c, s)\" }\n+              (send, send) { ~\"(c, s)\" }\n+              (send, recv) { ~\"(s, c)\" }\n+              (recv, send) { ~\"(s, c)\" }\n+              (recv, recv) { ~\"(c, s)\" }\n             };\n \n             let mut body = #fmt(\"{ let %s = pipes::entangle();\\n\", pat);\n             body += #fmt(\"let message = %s::%s(%s);\\n\",\n                          *this.proto.name,\n                          *self.name(),\n-                         str::connect(vec::append_one(arg_names, @\"s\")\n+                         str::connect(vec::append_one(arg_names, @~\"s\")\n                                       .map(|x| *x),\n-                                      \", \"));\n+                                      ~\", \"));\n             body += #fmt(\"pipes::send(pipe, message);\\n\");\n-            body += \"c }\";\n+            body += ~\"c }\";\n \n             let body = cx.parse_expr(body);\n \n@@ -127,7 +127,7 @@ impl methods for state {\n         self.messages.push(message(name, data, self, next, next_tys));\n     }\n \n-    fn filename() -> str {\n+    fn filename() -> ~str {\n         (*self).proto.filename()\n     }\n \n@@ -158,8 +158,8 @@ impl methods for state {\n             let next_name = next.data_name();\n \n             let dir = alt this.dir {\n-              send { @\"server\" }\n-              recv { @\"client\" }\n+              send { @~\"server\" }\n+              recv { @~\"client\" }\n             };\n \n             let v = cx.variant(name,\n@@ -190,7 +190,7 @@ impl methods for state {\n                   cx.item_ty_poly(\n                       self.data_name(),\n                       cx.ty_path(\n-                          (@\"pipes\" + @(dir.to_str() + \"_packet\"))\n+                          (@~\"pipes\" + @(dir.to_str() + ~\"_packet\"))\n                           .add_ty(cx.ty_path(\n                               (self.proto.name + self.data_name())\n                               .add_tys(cx.ty_vars(self.ty_params))))),\n@@ -236,17 +236,17 @@ impl methods for protocol {\n         state\n     }\n \n-    fn filename() -> str {\n-        \"proto://\" + *self.name\n+    fn filename() -> ~str {\n+        ~\"proto://\" + *self.name\n     }\n \n     fn gen_init(cx: ext_ctxt) -> @ast::item {\n         let start_state = self.states[0];\n \n         let body = alt start_state.dir {\n-          send { cx.parse_expr(\"pipes::entangle()\") }\n+          send { cx.parse_expr(~\"pipes::entangle()\") }\n           recv {\n-            cx.parse_expr(\"{ \\\n+            cx.parse_expr(~\"{ \\\n                            let (s, c) = pipes::entangle(); \\\n                            (c, s) \\\n                            }\")\n@@ -281,10 +281,10 @@ impl methods for protocol {\n         }\n \n         vec::push(items,\n-                  cx.item_mod(@\"client\",\n+                  cx.item_mod(@~\"client\",\n                               client_states));\n         vec::push(items,\n-                  cx.item_mod(@\"server\",\n+                  cx.item_mod(@~\"server\",\n                               server_states));\n \n         cx.item_mod(self.name, items)\n@@ -293,49 +293,49 @@ impl methods for protocol {\n \n iface to_source {\n     // Takes a thing and generates a string containing rust code for it.\n-    fn to_source() -> str;\n+    fn to_source() -> ~str;\n }\n \n impl of to_source for @ast::item {\n-    fn to_source() -> str {\n+    fn to_source() -> ~str {\n         item_to_str(self)\n     }\n }\n \n impl of to_source for ~[@ast::item] {\n-    fn to_source() -> str {\n-        str::connect(self.map(|i| i.to_source()), \"\\n\\n\")\n+    fn to_source() -> ~str {\n+        str::connect(self.map(|i| i.to_source()), ~\"\\n\\n\")\n     }\n }\n \n impl of to_source for @ast::ty {\n-    fn to_source() -> str {\n+    fn to_source() -> ~str {\n         ty_to_str(self)\n     }\n }\n \n impl of to_source for ~[@ast::ty] {\n-    fn to_source() -> str {\n-        str::connect(self.map(|i| i.to_source()), \", \")\n+    fn to_source() -> ~str {\n+        str::connect(self.map(|i| i.to_source()), ~\", \")\n     }\n }\n \n impl of to_source for ~[ast::ty_param] {\n-    fn to_source() -> str {\n+    fn to_source() -> ~str {\n         pprust::typarams_to_str(self)\n     }\n }\n \n impl of to_source for @ast::expr {\n-    fn to_source() -> str {\n+    fn to_source() -> ~str {\n         pprust::expr_to_str(self)\n     }\n }\n \n impl parse_utils for ext_ctxt {\n-    fn parse_item(s: str) -> @ast::item {\n+    fn parse_item(s: ~str) -> @ast::item {\n         let res = parse::parse_item_from_source_str(\n-            \"***protocol expansion***\",\n+            ~\"***protocol expansion***\",\n             @(copy s),\n             self.cfg(),\n             ~[],\n@@ -350,9 +350,9 @@ impl parse_utils for ext_ctxt {\n         }\n     }\n \n-    fn parse_expr(s: str) -> @ast::expr {\n+    fn parse_expr(s: ~str) -> @ast::expr {\n         parse::parse_expr_from_source_str(\n-            \"***protocol expansion***\",\n+            ~\"***protocol expansion***\",\n             @(copy s),\n             self.cfg(),\n             self.parse_sess())"}, {"sha": "4fd896e65bb604682610e764d33bce0c3cde0ece", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 51, "deletions": 45, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -16,7 +16,7 @@ import codemap::span;\n type aq_ctxt = @{lo: uint,\n                  gather: dvec<{lo: uint, hi: uint,\n                                e: @ast::expr,\n-                               constr: str}>};\n+                               constr: ~str}>};\n enum fragment {\n     from_expr(@ast::expr),\n     from_ty(@ast::ty)\n@@ -27,17 +27,18 @@ iface qq_helper {\n     fn visit(aq_ctxt, vt<aq_ctxt>);\n     fn extract_mac() -> option<ast::mac_>;\n     fn mk_parse_fn(ext_ctxt,span) -> @ast::expr;\n-    fn get_fold_fn() -> str;\n+    fn get_fold_fn() -> ~str;\n }\n \n impl of qq_helper for @ast::crate {\n     fn span() -> span {self.span}\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_crate(*self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, ~[@\"syntax\", @\"ext\", @\"qquote\", @\"parse_crate\"])\n+        mk_path(cx, sp,\n+                ~[@~\"syntax\", @~\"ext\", @~\"qquote\", @~\"parse_crate\"])\n     }\n-    fn get_fold_fn() -> str {\"fold_crate\"}\n+    fn get_fold_fn() -> ~str {~\"fold_crate\"}\n }\n impl of qq_helper for @ast::expr {\n     fn span() -> span {self.span}\n@@ -49,9 +50,10 @@ impl of qq_helper for @ast::expr {\n         }\n     }\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, ~[@\"syntax\", @\"ext\", @\"qquote\", @\"parse_expr\"])\n+        mk_path(cx, sp,\n+                ~[@~\"syntax\", @~\"ext\", @~\"qquote\", @~\"parse_expr\"])\n     }\n-    fn get_fold_fn() -> str {\"fold_expr\"}\n+    fn get_fold_fn() -> ~str {~\"fold_expr\"}\n }\n impl of qq_helper for @ast::ty {\n     fn span() -> span {self.span}\n@@ -63,42 +65,45 @@ impl of qq_helper for @ast::ty {\n         }\n     }\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, ~[@\"syntax\", @\"ext\", @\"qquote\", @\"parse_ty\"])\n+        mk_path(cx, sp,\n+                ~[@~\"syntax\", @~\"ext\", @~\"qquote\", @~\"parse_ty\"])\n     }\n-    fn get_fold_fn() -> str {\"fold_ty\"}\n+    fn get_fold_fn() -> ~str {~\"fold_ty\"}\n }\n impl of qq_helper for @ast::item {\n     fn span() -> span {self.span}\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_item(self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, ~[@\"syntax\", @\"ext\", @\"qquote\", @\"parse_item\"])\n+        mk_path(cx, sp,\n+                ~[@~\"syntax\", @~\"ext\", @~\"qquote\", @~\"parse_item\"])\n     }\n-    fn get_fold_fn() -> str {\"fold_item\"}\n+    fn get_fold_fn() -> ~str {~\"fold_item\"}\n }\n impl of qq_helper for @ast::stmt {\n     fn span() -> span {self.span}\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_stmt(self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, ~[@\"syntax\", @\"ext\", @\"qquote\", @\"parse_stmt\"])\n+        mk_path(cx, sp,\n+                ~[@~\"syntax\", @~\"ext\", @~\"qquote\", @~\"parse_stmt\"])\n     }\n-    fn get_fold_fn() -> str {\"fold_stmt\"}\n+    fn get_fold_fn() -> ~str {~\"fold_stmt\"}\n }\n impl of qq_helper for @ast::pat {\n     fn span() -> span {self.span}\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_pat(self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, ~[@\"syntax\", @\"ext\", @\"qquote\", @\"parse_pat\"])\n+        mk_path(cx, sp, ~[@~\"syntax\", @~\"ext\", @~\"qquote\", @~\"parse_pat\"])\n     }\n-    fn get_fold_fn() -> str {\"fold_pat\"}\n+    fn get_fold_fn() -> ~str {~\"fold_pat\"}\n }\n \n fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n {\n-    let v = @{visit_expr: |node, &&cx, v| visit_aq(node, \"from_expr\", cx, v),\n-              visit_ty: |node, &&cx, v| visit_aq(node, \"from_ty\", cx, v)\n+    let v = @{visit_expr: |node, &&cx, v| visit_aq(node, ~\"from_expr\", cx, v),\n+              visit_ty: |node, &&cx, v| visit_aq(node, ~\"from_ty\", cx, v)\n               with *default_visitor()};\n     let cx = @{lo:lo, gather: dvec()};\n     node.visit(cx, mk_vt(v));\n@@ -110,7 +115,7 @@ fn gather_anti_quotes<N: qq_helper>(lo: uint, node: N) -> aq_ctxt\n     ret cx;\n }\n \n-fn visit_aq<T:qq_helper>(node: T, constr: str, &&cx: aq_ctxt, v: vt<aq_ctxt>)\n+fn visit_aq<T:qq_helper>(node: T, constr: ~str, &&cx: aq_ctxt, v: vt<aq_ctxt>)\n {\n     alt (node.extract_mac()) {\n       some(mac_aq(sp, e)) {\n@@ -129,35 +134,35 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n               arg: ast::mac_arg, body: ast::mac_body)\n     -> @ast::expr\n {\n-    let mut what = \"expr\";\n+    let mut what = ~\"expr\";\n     do option::iter(arg) |arg| {\n         let args: ~[@ast::expr] =\n             alt arg.node {\n               ast::expr_vec(elts, _) { elts }\n               _ {\n                 ecx.span_fatal\n-                    (_sp, \"#ast requires arguments of the form `~[...]`.\")\n+                    (_sp, ~\"#ast requires arguments of the form `~[...]`.\")\n               }\n             };\n         if vec::len::<@ast::expr>(args) != 1u {\n-            ecx.span_fatal(_sp, \"#ast requires exactly one arg\");\n+            ecx.span_fatal(_sp, ~\"#ast requires exactly one arg\");\n         }\n         alt (args[0].node) {\n           ast::expr_path(@{idents: id, _}) if vec::len(id) == 1u\n               {what = *id[0]}\n-          _ {ecx.span_fatal(args[0].span, \"expected an identifier\");}\n+          _ {ecx.span_fatal(args[0].span, ~\"expected an identifier\");}\n         }\n     }\n     let body = get_mac_body(ecx,_sp,body);\n \n     ret alt what {\n-      \"crate\" {finish(ecx, body, parse_crate)}\n-      \"expr\" {finish(ecx, body, parse_expr)}\n-      \"ty\" {finish(ecx, body, parse_ty)}\n-      \"item\" {finish(ecx, body, parse_item)}\n-      \"stmt\" {finish(ecx, body, parse_stmt)}\n-      \"pat\" {finish(ecx, body, parse_pat)}\n-      _ {ecx.span_fatal(_sp, \"unsupported ast type\")}\n+      ~\"crate\" {finish(ecx, body, parse_crate)}\n+      ~\"expr\" {finish(ecx, body, parse_expr)}\n+      ~\"ty\" {finish(ecx, body, parse_ty)}\n+      ~\"item\" {finish(ecx, body, parse_item)}\n+      ~\"stmt\" {finish(ecx, body, parse_stmt)}\n+      ~\"pat\" {finish(ecx, body, parse_pat)}\n+      _ {ecx.span_fatal(_sp, ~\"unsupported ast type\")}\n     };\n }\n \n@@ -170,7 +175,7 @@ fn parse_pat(p: parser) -> @ast::pat { p.parse_pat() }\n fn parse_item(p: parser) -> @ast::item {\n     alt p.parse_item(~[], ast::public) {\n       some(item) { item }\n-      none       { fail \"parse_item: parsing an item failed\"; }\n+      none       { fail ~\"parse_item: parsing an item failed\"; }\n     }\n }\n \n@@ -198,7 +203,7 @@ fn finish<T: qq_helper>\n         // ^^ check that the spans are non-overlapping\n     }\n \n-    let mut str2 = \"\";\n+    let mut str2 = ~\"\";\n     enum state {active, skip(uint), blank};\n     let mut state = active;\n     let mut i = 0u, j = 0u;\n@@ -228,39 +233,39 @@ fn finish<T: qq_helper>\n     let cx = ecx;\n \n     let cfg_call = || mk_call_(\n-        cx, sp, mk_access(cx, sp, ~[@\"ext_cx\"], @\"cfg\"), ~[]);\n+        cx, sp, mk_access(cx, sp, ~[@~\"ext_cx\"], @~\"cfg\"), ~[]);\n \n     let parse_sess_call = || mk_call_(\n-        cx, sp, mk_access(cx, sp, ~[@\"ext_cx\"], @\"parse_sess\"), ~[]);\n+        cx, sp, mk_access(cx, sp, ~[@~\"ext_cx\"], @~\"parse_sess\"), ~[]);\n \n     let pcall = mk_call(cx,sp,\n-                       ~[@\"syntax\", @\"parse\", @\"parser\",\n-                        @\"parse_from_source_str\"],\n+                       ~[@~\"syntax\", @~\"parse\", @~\"parser\",\n+                        @~\"parse_from_source_str\"],\n                        ~[node.mk_parse_fn(cx,sp),\n-                        mk_str(cx,sp, fname),\n+                        mk_uniq_str(cx,sp, fname),\n                         mk_call(cx,sp,\n-                                ~[@\"syntax\",@\"ext\",\n-                                 @\"qquote\", @\"mk_file_substr\"],\n-                                ~[mk_str(cx,sp, loc.file.name),\n+                                ~[@~\"syntax\",@~\"ext\",\n+                                 @~\"qquote\", @~\"mk_file_substr\"],\n+                                ~[mk_uniq_str(cx,sp, loc.file.name),\n                                  mk_uint(cx,sp, loc.line),\n                                  mk_uint(cx,sp, loc.col)]),\n                         mk_unary(cx,sp, ast::box(ast::m_imm),\n-                                 mk_str(cx,sp, str2)),\n+                                 mk_uniq_str(cx,sp, str2)),\n                         cfg_call(),\n                         parse_sess_call()]\n                       );\n     let mut rcall = pcall;\n     if (g_len > 0u) {\n         rcall = mk_call(cx,sp,\n-                        ~[@\"syntax\", @\"ext\", @\"qquote\", @\"replace\"],\n+                        ~[@~\"syntax\", @~\"ext\", @~\"qquote\", @~\"replace\"],\n                         ~[pcall,\n                           mk_uniq_vec_e(cx,sp, qcx.gather.map_to_vec(|g| {\n                              mk_call(cx,sp,\n-                                     ~[@\"syntax\", @\"ext\",\n-                                      @\"qquote\", @g.constr],\n+                                     ~[@~\"syntax\", @~\"ext\",\n+                                      @~\"qquote\", @g.constr],\n                                      ~[g.e])})),\n                          mk_path(cx,sp,\n-                                 ~[@\"syntax\", @\"ext\", @\"qquote\",\n+                                 ~[@~\"syntax\", @~\"ext\", @~\"qquote\",\n                                   @node.get_fold_fn()])]);\n     }\n     ret rcall;\n@@ -321,10 +326,11 @@ fn print_expr(expr: @ast::expr) {\n     let pp = pprust::rust_printer(stdout);\n     pprust::print_expr(pp, expr);\n     pp::eof(pp.s);\n-    stdout.write_str(\"\\n\");\n+    stdout.write_str(~\"\\n\");\n }\n \n-fn mk_file_substr(fname: str, line: uint, col: uint) -> codemap::file_substr {\n+fn mk_file_substr(fname: ~str, line: uint, col: uint) ->\n+    codemap::file_substr {\n     codemap::fss_external({filename: fname, line: line, col: col})\n }\n "}, {"sha": "333c510b7cd8e3956a372c631b3e0883f66a59fb", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -35,29 +35,29 @@ enum matchable {\n }\n \n /* for when given an incompatible bit of AST */\n-fn match_error(cx: ext_ctxt, m: matchable, expected: str) -> ! {\n+fn match_error(cx: ext_ctxt, m: matchable, expected: ~str) -> ! {\n     alt m {\n       match_expr(x) {\n         cx.span_fatal(x.span,\n-                      \"this argument is an expr, expected \" + expected);\n+                      ~\"this argument is an expr, expected \" + expected);\n       }\n       match_path(x) {\n         cx.span_fatal(x.span,\n-                      \"this argument is a path, expected \" + expected);\n+                      ~\"this argument is a path, expected \" + expected);\n       }\n       match_ident(x) {\n         cx.span_fatal(x.span,\n-                      \"this argument is an ident, expected \" + expected);\n+                      ~\"this argument is an ident, expected \" + expected);\n       }\n       match_ty(x) {\n         cx.span_fatal(x.span,\n-                      \"this argument is a type, expected \" + expected);\n+                      ~\"this argument is a type, expected \" + expected);\n       }\n       match_block(x) {\n         cx.span_fatal(x.span,\n-                      \"this argument is a block, expected \" + expected);\n+                      ~\"this argument is a block, expected \" + expected);\n       }\n-      match_exact { cx.bug(\"what is a match_exact doing in a bindings?\"); }\n+      match_exact { cx.bug(~\"what is a match_exact doing in a bindings?\"); }\n     }\n }\n \n@@ -80,7 +80,7 @@ fn elts_to_ell(cx: ext_ctxt, elts: ~[@expr]) ->\n             alt m.node {\n               ast::mac_ellipsis {\n                 if res != none {\n-                    cx.span_fatal(m.span, \"only one ellipsis allowed\");\n+                    cx.span_fatal(m.span, ~\"only one ellipsis allowed\");\n                 }\n                 res =\n                     some({pre: vec::slice(elts, 0u, idx - 1u),\n@@ -234,8 +234,8 @@ fn follow_for_trans(cx: ext_ctxt, mmaybe: option<arb_depth<matchable>>,\n         ret alt follow(m, idx_path) {\n               seq(_, sp) {\n                 cx.span_fatal(sp,\n-                              \"syntax matched under ... but not \" +\n-                                  \"used that way.\")\n+                              ~\"syntax matched under ... but not \" +\n+                                  ~\"used that way.\")\n               }\n               leaf(m) { ret some(m) }\n             }\n@@ -302,8 +302,8 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n             alt repeat {\n               none {\n                 cx.span_fatal(repeat_me.span,\n-                              \"'...' surrounds an expression without any\" +\n-                                  \" repeating syntax variables\");\n+                              ~\"'...' surrounds an expression without any\" +\n+                                  ~\" repeating syntax variables\");\n               }\n               some({rep_count: rc, _}) {\n                 /* Whew, we now know how how many times to repeat */\n@@ -331,7 +331,7 @@ fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                     &&i: ident, _fld: ast_fold) -> ident {\n     ret alt follow_for_trans(cx, b.find(i), idx_path) {\n           some(match_ident(a_id)) { a_id.node }\n-          some(m) { match_error(cx, m, \"an identifier\") }\n+          some(m) { match_error(cx, m, ~\"an identifier\") }\n           none { i }\n         }\n }\n@@ -347,7 +347,7 @@ fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n          rp: none, types: ~[]}\n       }\n       some(match_path(a_pth)) { *a_pth }\n-      some(m) { match_error(cx, m, \"a path\") }\n+      some(m) { match_error(cx, m, ~\"a path\") }\n       none { p }\n     }\n }\n@@ -374,7 +374,7 @@ fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n               }\n               some(match_path(a_pth)) { (expr_path(a_pth), s) }\n               some(match_expr(a_exp)) { (a_exp.node, a_exp.span) }\n-              some(m) { match_error(cx, m, \"an expression\") }\n+              some(m) { match_error(cx, m, ~\"an expression\") }\n               none { orig(e, s, fld) }\n             }\n           }\n@@ -393,7 +393,7 @@ fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n               some(id) {\n                 alt follow_for_trans(cx, b.find(id), idx_path) {\n                   some(match_ty(ty)) { (ty.node, ty.span) }\n-                  some(m) { match_error(cx, m, \"a type\") }\n+                  some(m) { match_error(cx, m, ~\"a type\") }\n                   none { orig(t, s, fld) }\n                 }\n               }\n@@ -424,7 +424,7 @@ fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n \n               // possibly allow promotion of ident/path/expr to blocks?\n               some(m) {\n-                match_error(cx, m, \"a block\")\n+                match_error(cx, m, ~\"a block\")\n               }\n               none { orig(blk, s, fld) }\n             }\n@@ -455,12 +455,12 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n \n                 if vec::len(post) > 0u {\n                     cx.span_unimpl(e.span,\n-                                   \"matching after `...` not yet supported\");\n+                                   ~\"matching after `...` not yet supported\");\n                 }\n               }\n               {pre: pre, rep: none, post: post} {\n                 if post != ~[] {\n-                    cx.bug(\"elts_to_ell provided an invalid result\");\n+                    cx.bug(~\"elts_to_ell provided an invalid result\");\n                 }\n                 p_t_s_r_length(cx, vec::len(pre), false, s, b);\n                 p_t_s_r_actual_vector(cx, pre, false, s, b);\n@@ -478,15 +478,15 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n                       match_expr(e) {\n                         if e == pat { some(leaf(match_exact)) } else { none }\n                       }\n-                      _ { cx.bug(\"broken traversal in p_t_s_r\") }\n+                      _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n                     }\n             }\n             b.literal_ast_matchers.push(|x| select(cx, x, e));\n           }\n         }\n       }\n       _ {\n-          cx.bug(\"undocumented invariant in p_t_s_rec\");\n+          cx.bug(~\"undocumented invariant in p_t_s_rec\");\n       }\n     }\n }\n@@ -517,11 +517,11 @@ fn p_t_s_r_path(cx: ext_ctxt, p: @path, s: selector, b: binders) {\n         fn select(cx: ext_ctxt, m: matchable) -> match_result {\n             ret alt m {\n                   match_expr(e) { some(leaf(specialize_match(m))) }\n-                  _ { cx.bug(\"broken traversal in p_t_s_r\") }\n+                  _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n                 }\n         }\n         if b.real_binders.contains_key(p_id) {\n-            cx.span_fatal(p.span, \"duplicate binding identifier\");\n+            cx.span_fatal(p.span, ~\"duplicate binding identifier\");\n         }\n         b.real_binders.insert(p_id, compose_sels(s, |x| select(cx, x)));\n       }\n@@ -546,16 +546,16 @@ fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, s: selector, b: binders) {\n               match_expr(e) {\n                 alt e.node { expr_mac(mac) { fn_m(mac) } _ { none } }\n               }\n-              _ { cx.bug(\"broken traversal in p_t_s_r\") }\n+              _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n             }\n     }\n-    fn no_des(cx: ext_ctxt, sp: span, syn: str) -> ! {\n-        cx.span_fatal(sp, \"destructuring \" + syn + \" is not yet supported\");\n+    fn no_des(cx: ext_ctxt, sp: span, syn: ~str) -> ! {\n+        cx.span_fatal(sp, ~\"destructuring \" + syn + ~\" is not yet supported\");\n     }\n     alt mac.node {\n-      ast::mac_ellipsis { cx.span_fatal(mac.span, \"misused `...`\"); }\n-      ast::mac_invoc(_, _, _) { no_des(cx, mac.span, \"macro calls\"); }\n-      ast::mac_invoc_tt(_, _) { no_des(cx, mac.span, \"macro calls\"); }\n+      ast::mac_ellipsis { cx.span_fatal(mac.span, ~\"misused `...`\"); }\n+      ast::mac_invoc(_, _, _) { no_des(cx, mac.span, ~\"macro calls\"); }\n+      ast::mac_invoc_tt(_, _) { no_des(cx, mac.span, ~\"macro calls\"); }\n       ast::mac_embed_type(ty) {\n         alt ty.node {\n           ast::ty_path(pth, _) {\n@@ -571,10 +571,10 @@ fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, s: selector, b: binders) {\n                 let final_step = |x| select_pt_1(cx, x, select_pt_2);\n                 b.real_binders.insert(id, compose_sels(s, final_step));\n               }\n-              none { no_des(cx, pth.span, \"under `#<>`\"); }\n+              none { no_des(cx, pth.span, ~\"under `#<>`\"); }\n             }\n           }\n-          _ { no_des(cx, ty.span, \"under `#<>`\"); }\n+          _ { no_des(cx, ty.span, ~\"under `#<>`\"); }\n         }\n       }\n       ast::mac_embed_block(blk) {\n@@ -591,11 +591,11 @@ fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, s: selector, b: binders) {\n             let final_step = |x| select_pt_1(cx, x, select_pt_2);\n             b.real_binders.insert(id, compose_sels(s, final_step));\n           }\n-          none { no_des(cx, blk.span, \"under `#{}`\"); }\n+          none { no_des(cx, blk.span, ~\"under `#{}`\"); }\n         }\n       }\n-      ast::mac_aq(_,_) { no_des(cx, mac.span, \"antiquotes\"); }\n-      ast::mac_var(_) { no_des(cx, mac.span, \"antiquote variables\"); }\n+      ast::mac_aq(_,_) { no_des(cx, mac.span, ~\"antiquotes\"); }\n+      ast::mac_var(_) { no_des(cx, mac.span, ~\"antiquote variables\"); }\n     }\n }\n \n@@ -621,7 +621,7 @@ fn p_t_s_r_ellipses(cx: ext_ctxt, repeat_me: @expr, offset: uint, s: selector,\n                   _ { none }\n                 }\n               }\n-              _ { cx.bug(\"broken traversal in p_t_s_r\") }\n+              _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n             }\n     }\n     p_t_s_rec(cx, match_expr(repeat_me),\n@@ -666,7 +666,7 @@ fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: ~[@expr], _repeat_after: bool,\n                       _ { none }\n                     }\n                   }\n-                  _ { cx.bug(\"broken traversal in p_t_s_r\") }\n+                  _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n                 }\n         }\n         p_t_s_rec(cx, match_expr(elts[idx]),\n@@ -677,17 +677,17 @@ fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: ~[@expr], _repeat_after: bool,\n \n fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> base::macro_def {\n-    let args = get_mac_args_no_max(cx, sp, arg, 0u, \"macro\");\n+    let args = get_mac_args_no_max(cx, sp, arg, 0u, ~\"macro\");\n \n-    let mut macro_name: option<@str/~> = none;\n+    let mut macro_name: option<@~str> = none;\n     let mut clauses: ~[@clause] = ~[];\n     for args.each |arg| {\n         alt arg.node {\n           expr_vec(elts, mutbl) {\n             if vec::len(elts) != 2u {\n                 cx.span_fatal((*arg).span,\n-                              \"extension clause must consist of ~[\" +\n-                                  \"macro invocation, expansion body]\");\n+                              ~\"extension clause must consist of ~[\" +\n+                                  ~\"macro invocation, expansion body]\");\n             }\n \n \n@@ -702,21 +702,21 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                           some(other_id) {\n                             if id != other_id {\n                                 cx.span_fatal(pth.span,\n-                                              \"macro name must be \" +\n-                                                  \"consistent\");\n+                                              ~\"macro name must be \" +\n+                                                  ~\"consistent\");\n                             }\n                           }\n                         }\n                       }\n                       none {\n                         cx.span_fatal(pth.span,\n-                                      \"macro name must not be a path\");\n+                                      ~\"macro name must not be a path\");\n                       }\n                     }\n                     let arg = alt invoc_arg {\n                       some(arg) { arg }\n                       none { cx.span_fatal(mac.span,\n-                                           \"macro must have arguments\")}\n+                                           ~\"macro must have arguments\")}\n                     };\n                     vec::push(clauses,\n                               @{params: pattern_to_selectors(cx, arg),\n@@ -726,21 +726,21 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                     // the macro arg situation)\n                   }\n                   _ {\n-                      cx.span_bug(mac.span, \"undocumented invariant in \\\n+                      cx.span_bug(mac.span, ~\"undocumented invariant in \\\n                          add_extension\");\n                   }\n                 }\n               }\n               _ {\n                 cx.span_fatal(elts[0u].span,\n-                              \"extension clause must\" +\n-                                  \" start with a macro invocation.\");\n+                              ~\"extension clause must\" +\n+                                  ~\" start with a macro invocation.\");\n               }\n             }\n           }\n           _ {\n             cx.span_fatal((*arg).span,\n-                          \"extension must be ~[clause, \" + \" ...]\");\n+                          ~\"extension must be ~[clause, \" + ~\" ...]\");\n           }\n         }\n     }\n@@ -751,8 +751,8 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n              alt macro_name {\n                some(id) { id }\n                none {\n-                 cx.span_fatal(sp, \"macro definition must have \" +\n-                               \"at least one clause\")\n+                 cx.span_fatal(sp, ~\"macro definition must have \" +\n+                               ~\"at least one clause\")\n                }\n              },\n          ext: normal({expander: ext, span: some(option::get(arg).span)})};\n@@ -762,15 +762,15 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                          clauses: ~[@clause]) -> @expr {\n         let arg = alt arg {\n           some(arg) { arg }\n-          none { cx.span_fatal(sp, \"macro must have arguments\")}\n+          none { cx.span_fatal(sp, ~\"macro must have arguments\")}\n         };\n         for clauses.each |c| {\n             alt use_selectors_to_bind(c.params, arg) {\n               some(bindings) { ret transcribe(cx, bindings, c.body); }\n               none { again; }\n             }\n         }\n-        cx.span_fatal(sp, \"no clauses match macro invocation\");\n+        cx.span_fatal(sp, ~\"no clauses match macro invocation\");\n     }\n }\n "}, {"sha": "ff7fedde34e9380637bc472cec8ddcaa15199726", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -2,7 +2,7 @@ import base::*;\n import ast;\n import codemap::span;\n import print::pprust;\n-import build::{mk_lit,mk_uniq_vec_e};\n+import build::{mk_uint,mk_u8,mk_uniq_str,mk_uniq_vec_e};\n \n export expand_line;\n export expand_col;\n@@ -16,47 +16,47 @@ export expand_include_bin;\n /* #line(): expands to the current line number */\n fn expand_line(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                _body: ast::mac_body) -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::some(0u), \"line\");\n+    get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"line\");\n     let loc = codemap::lookup_char_pos(cx.codemap(), sp.lo);\n-    ret mk_lit(cx, sp, ast::lit_uint(loc.line as u64, ast::ty_u));\n+    ret mk_uint(cx, sp, loc.line);\n }\n \n /* #col(): expands to the current column number */\n fn expand_col(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n               _body: ast::mac_body) -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::some(0u), \"col\");\n+    get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"col\");\n     let loc = codemap::lookup_char_pos(cx.codemap(), sp.lo);\n-    ret mk_lit(cx, sp, ast::lit_uint(loc.col as u64, ast::ty_u));\n+    ret mk_uint(cx, sp, loc.col);\n }\n \n /* #file(): expands to the current filename */\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n fn expand_file(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                _body: ast::mac_body) -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::some(0u), \"file\");\n+    get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"file\");\n     let { file: @{ name: filename, _ }, _ } =\n         codemap::lookup_char_pos(cx.codemap(), sp.lo);\n-    ret mk_lit(cx, sp, ast::lit_str(@filename));\n+    ret mk_uniq_str(cx, sp, filename);\n }\n \n fn expand_stringify(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                     _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx, sp, arg, 1u, option::some(1u), \"stringify\");\n-    ret mk_lit(cx, sp, ast::lit_str(@pprust::expr_to_str(args[0])));\n+    let args = get_mac_args(cx, sp, arg, 1u, option::some(1u), ~\"stringify\");\n+    ret mk_uniq_str(cx, sp, pprust::expr_to_str(args[0]));\n }\n \n fn expand_mod(cx: ext_ctxt, sp: span, arg: ast::mac_arg, _body: ast::mac_body)\n     -> @ast::expr {\n-    get_mac_args(cx, sp, arg, 0u, option::some(0u), \"file\");\n-    ret mk_lit(cx, sp, ast::lit_str(\n-        @str::connect(cx.mod_path().map(|x|*x), \"::\")));\n+    get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"file\");\n+    ret mk_uniq_str(cx, sp,\n+                    str::connect(cx.mod_path().map(|x|*x), ~\"::\"));\n }\n \n fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                   _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx, sp, arg, 1u, option::some(1u), \"include\");\n-    let file = expr_to_str(cx, args[0], \"#include_str requires a string\");\n+    let args = get_mac_args(cx, sp, arg, 1u, option::some(1u), ~\"include\");\n+    let file = expr_to_str(cx, args[0], ~\"#include_str requires a string\");\n     let p = parse::new_parser_from_file(cx.parse_sess(), cx.cfg(),\n                                         res_rel_file(cx, sp, file),\n                                         parse::parser::SOURCE_FILE);\n@@ -65,9 +65,9 @@ fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n \n fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                       _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx,sp,arg,1u,option::some(1u),\"include_str\");\n+    let args = get_mac_args(cx,sp,arg,1u,option::some(1u),~\"include_str\");\n \n-    let file = expr_to_str(cx, args[0], \"#include_str requires a string\");\n+    let file = expr_to_str(cx, args[0], ~\"#include_str requires a string\");\n \n     let res = io::read_whole_file_str(res_rel_file(cx, sp, file));\n     alt res {\n@@ -77,19 +77,19 @@ fn expand_include_str(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n       }\n     }\n \n-    ret mk_lit(cx, sp, ast::lit_str(@result::unwrap(res)));\n+    ret mk_uniq_str(cx, sp, result::unwrap(res));\n }\n \n fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                       _body: ast::mac_body) -> @ast::expr {\n-    let args = get_mac_args(cx,sp,arg,1u,option::some(1u),\"include_bin\");\n+    let args = get_mac_args(cx,sp,arg,1u,option::some(1u),~\"include_bin\");\n \n-    let file = expr_to_str(cx, args[0], \"#include_bin requires a string\");\n+    let file = expr_to_str(cx, args[0], ~\"#include_bin requires a string\");\n \n     alt io::read_whole_file(res_rel_file(cx, sp, file)) {\n       result::ok(src) {\n         let u8_exprs = vec::map(src, |char: u8| {\n-            mk_lit(cx, sp, ast::lit_uint(char as u64, ast::ty_u8))\n+            mk_u8(cx, sp, char)\n         });\n         ret mk_uniq_vec_e(cx, sp, u8_exprs);\n       }"}, {"sha": "3f604aafb3d03ed676887774b7b0057669d90fdb", "filename": "src/libsyntax/ext/tt/earley_parser.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -83,7 +83,7 @@ fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@arb_depth])\n           }\n           {node: mtc_bb(bind_name, _, idx), span: sp} {\n             if ret_val.contains_key(bind_name) {\n-                p_s.span_diagnostic.span_fatal(sp, \"Duplicated bind name: \"\n+                p_s.span_diagnostic.span_fatal(sp, ~\"Duplicated bind name: \"\n                                                + *bind_name)\n             }\n             ret_val.insert(bind_name, res[idx]);\n@@ -97,7 +97,7 @@ fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@arb_depth])\n \n enum parse_result {\n     success(hashmap<ident, @arb_depth>),\n-    failure(codemap::span, str)\n+    failure(codemap::span, ~str)\n }\n \n fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n@@ -207,23 +207,23 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                     nameize(sess, ms,\n                             vec::map(eof_eis[0u].matches, |dv| dv.pop())));\n             } else if eof_eis.len() > 1u {\n-                ret failure(sp, \"Ambiguity: multiple successful parses\");\n+                ret failure(sp, ~\"Ambiguity: multiple successful parses\");\n             } else {\n-                ret failure(sp, \"Unexpected end of macro invocation\");\n+                ret failure(sp, ~\"Unexpected end of macro invocation\");\n             }\n         } else {\n             if (bb_eis.len() > 0u && next_eis.len() > 0u)\n                 || bb_eis.len() > 1u {\n                 let nts = str::connect(vec::map(bb_eis, |ei| {\n                     alt ei.elts[ei.idx].node\n                         { mtc_bb(_,name,_) { *name } _ { fail; } }\n-                }), \" or \");\n+                }), ~\" or \");\n                 ret failure(sp, #fmt[\n                     \"Local ambiguity: multiple parsing options: \\\n                      built-in NTs %s or %u other options.\",\n                     nts, next_eis.len()]);\n             } else if (bb_eis.len() == 0u && next_eis.len() == 0u) {\n-                ret failure(sp, \"No rules expected the token \"\n+                ret failure(sp, ~\"No rules expected the token \"\n                             + to_str(*rdr.interner(), tok));\n             } else if (next_eis.len() > 0u) {\n                 /* Now process the next token */\n@@ -259,32 +259,32 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n     }\n }\n \n-fn parse_nt(p: parser, name: str) -> whole_nt {\n+fn parse_nt(p: parser, name: ~str) -> whole_nt {\n     alt name {\n-      \"item\" { alt p.parse_item(~[], ast::public) {\n+      ~\"item\" { alt p.parse_item(~[], ast::public) {\n         some(i) { token::w_item(i) }\n-        none { p.fatal(\"expected an item keyword\") }\n+        none { p.fatal(~\"expected an item keyword\") }\n       }}\n-      \"block\" { token::w_block(p.parse_block()) }\n-      \"stmt\" { token::w_stmt(p.parse_stmt(~[])) }\n-      \"pat\" { token::w_pat(p.parse_pat()) }\n-      \"expr\" { token::w_expr(p.parse_expr()) }\n-      \"ty\" { token::w_ty(p.parse_ty(false /* no need to disambiguate*/)) }\n+      ~\"block\" { token::w_block(p.parse_block()) }\n+      ~\"stmt\" { token::w_stmt(p.parse_stmt(~[])) }\n+      ~\"pat\" { token::w_pat(p.parse_pat()) }\n+      ~\"expr\" { token::w_expr(p.parse_expr()) }\n+      ~\"ty\" { token::w_ty(p.parse_ty(false /* no need to disambiguate*/)) }\n       // this could be handled like a token, since it is one\n-      \"ident\" { alt copy p.token {\n+      ~\"ident\" { alt copy p.token {\n           token::IDENT(sn,b) { p.bump(); token::w_ident(sn,b) }\n-          _ { p.fatal(\"expected ident, found \"\n+          _ { p.fatal(~\"expected ident, found \"\n                       + token::to_str(*p.reader.interner(), copy p.token)) }\n       } }\n-      \"path\" { token::w_path(p.parse_path_with_tps(false)) }\n-      \"tt\" {\n+      ~\"path\" { token::w_path(p.parse_path_with_tps(false)) }\n+      ~\"tt\" {\n         p.quote_depth += 1u; //but in theory, non-quoted tts might be useful\n         let res = token::w_tt(@p.parse_token_tree());\n         p.quote_depth -= 1u;\n         res\n       }\n-      \"mtcs\" { token::w_mtcs(p.parse_matchers()) }\n-      _ { p.fatal(\"Unsupported builtin nonterminal parser: \" + name)}\n+      ~\"mtcs\" { token::w_mtcs(p.parse_matchers()) }\n+      _ { p.fatal(~\"Unsupported builtin nonterminal parser: \" + name)}\n     }\n }\n "}, {"sha": "7bed3107f533cb072f06b2cdc0a4250a83233f24", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -18,9 +18,9 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n \n     let argument_gram = ~[\n         ms(mtc_rep(~[\n-            ms(mtc_bb(@\"lhs\",@\"mtcs\", 0u)),\n+            ms(mtc_bb(@~\"lhs\",@~\"mtcs\", 0u)),\n             ms(mtc_tok(FAT_ARROW)),\n-            ms(mtc_bb(@\"rhs\",@\"tt\", 1u)),\n+            ms(mtc_bb(@~\"rhs\",@~\"tt\", 1u)),\n         ], some(SEMI), false))];\n \n     let arg_reader = new_tt_reader(cx.parse_sess().span_diagnostic,\n@@ -31,20 +31,20 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n       failure(sp, msg) { cx.span_fatal(sp, msg); }\n     };\n \n-    let lhses = alt arguments.get(@\"lhs\") {\n+    let lhses = alt arguments.get(@~\"lhs\") {\n       @seq(s, sp) { s }\n-      _ { cx.span_bug(sp, \"wrong-structured lhs\") }\n+      _ { cx.span_bug(sp, ~\"wrong-structured lhs\") }\n     };\n-    let rhses = alt arguments.get(@\"rhs\") {\n+    let rhses = alt arguments.get(@~\"rhs\") {\n       @seq(s, sp) { s }\n-      _ { cx.span_bug(sp, \"wrong-structured rhs\") }\n+      _ { cx.span_bug(sp, ~\"wrong-structured rhs\") }\n     };\n \n     fn generic_extension(cx: ext_ctxt, sp: span, arg: ~[ast::token_tree],\n                          lhses: ~[@arb_depth], rhses: ~[@arb_depth])\n     -> mac_result {\n         let mut best_fail_spot = {lo: 0u, hi: 0u, expn_info: none};\n-        let mut best_fail_msg = \"internal error: ran no matchers\";\n+        let mut best_fail_msg = ~\"internal error: ran no matchers\";\n \n         let s_d = cx.parse_sess().span_diagnostic;\n         let itr = cx.parse_sess().interner;\n@@ -57,7 +57,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                   success(m) {\n                     let rhs = alt rhses[i] {\n                       @leaf(w_tt(@tt)) { tt }\n-                      _ { cx.span_bug(sp, \"bad thing in rhs\") }\n+                      _ { cx.span_bug(sp, ~\"bad thing in rhs\") }\n                     };\n                     let trncbr = new_tt_reader(s_d, itr, some(m), ~[rhs]);\n                     let p = parser(cx.parse_sess(), cx.cfg(),\n@@ -71,7 +71,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                   }\n                 }\n               }\n-              _ { cx.bug(\"non-matcher found in parsed lhses\"); }\n+              _ { cx.bug(~\"non-matcher found in parsed lhses\"); }\n             }\n         }\n         cx.span_fatal(best_fail_spot, best_fail_msg);"}, {"sha": "a9bc124b60513f3164b57f53dd8bc25004ed10f5", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -25,7 +25,7 @@ type tt_frame = @{\n \n type tt_reader = @{\n     sp_diag: span_handler,\n-    interner: @interner<@str/~>,\n+    interner: @interner<@~str>,\n     mut cur: tt_frame,\n     /* for MBE-style macro transcription */\n     interpolations: std::map::hashmap<ident, @arb_depth>,\n@@ -39,7 +39,7 @@ type tt_reader = @{\n /** This can do Macro-By-Example transcription. On the other hand, if\n  *  `src` contains no `tt_dotdotdot`s and `tt_interpolate`s, `interp` can (and\n  *  should) be none. */\n-fn new_tt_reader(sp_diag: span_handler, itr: @interner<@str/~>,\n+fn new_tt_reader(sp_diag: span_handler, itr: @interner<@~str>,\n                  interp: option<std::map::hashmap<ident,@arb_depth>>,\n                  src: ~[ast::token_tree])\n     -> tt_reader {\n@@ -93,7 +93,7 @@ fn lookup_cur_ad(r: tt_reader, name: ident) -> @arb_depth {\n     lookup_cur_ad_by_ad(r, r.interpolations.get(name))\n }\n enum lis {\n-    lis_unconstrained, lis_constraint(uint, ident), lis_contradiction(str)\n+    lis_unconstrained, lis_constraint(uint, ident), lis_contradiction(~str)\n }\n \n fn lockstep_iter_size(&&t: token_tree, &&r: tt_reader) -> lis {\n@@ -183,7 +183,7 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n               lis_unconstrained {\n                 r.sp_diag.span_fatal(\n                     sp, /* blame macro writer */\n-                    \"attempted to repeat an expression containing no syntax \\\n+                    ~\"attempted to repeat an expression containing no syntax \\\n                      variables matched as repeating at this depth\");\n               }\n               lis_contradiction(msg) { /* FIXME #2887 blame macro invoker\n@@ -200,7 +200,7 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n                     if !zerok {\n                         r.sp_diag.span_fatal(sp, /* FIXME #2887 blame invoker\n                                                   */\n-                                             \"this must repeat at least \\\n+                                             ~\"this must repeat at least \\\n                                               once\");\n                     }\n                     /* we need to pop before we proceed, so recur */"}, {"sha": "9d56754e5d4ce2fc4d67f040a5d4d50dfe3f6dd9", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -25,7 +25,7 @@ type parse_sess = @{\n     cm: codemap::codemap,\n     mut next_id: node_id,\n     span_diagnostic: span_handler,\n-    interner: @interner::interner<@str/~>,\n+    interner: @interner::interner<@~str>,\n     // these two must be kept up to date\n     mut chpos: uint,\n     mut byte_pos: uint\n@@ -36,7 +36,7 @@ fn new_parse_sess(demitter: option<emitter>) -> parse_sess {\n     ret @{cm: cm,\n           mut next_id: 1,\n           span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n-          interner: @interner::mk::<@str/~>(|x| str::hash(*x),\n+          interner: @interner::mk::<@~str>(|x| str::hash(*x),\n                                           |x,y| str::eq(*x, *y)),\n           mut chpos: 0u, mut byte_pos: 0u};\n }\n@@ -46,24 +46,24 @@ fn new_parse_sess_special_handler(sh: span_handler, cm: codemap::codemap)\n     ret @{cm: cm,\n           mut next_id: 1,\n           span_diagnostic: sh,\n-          interner: @interner::mk::<@str/~>(|x| str::hash(*x),\n+          interner: @interner::mk::<@~str>(|x| str::hash(*x),\n                                           |x,y| str::eq(*x, *y)),\n           mut chpos: 0u, mut byte_pos: 0u};\n }\n \n-fn parse_crate_from_file(input: str, cfg: ast::crate_cfg, sess: parse_sess) ->\n-   @ast::crate {\n-    if str::ends_with(input, \".rc\") {\n+fn parse_crate_from_file(input: ~str, cfg: ast::crate_cfg,\n+                         sess: parse_sess) -> @ast::crate {\n+    if str::ends_with(input, ~\".rc\") {\n         parse_crate_from_crate_file(input, cfg, sess)\n-    } else if str::ends_with(input, \".rs\") {\n+    } else if str::ends_with(input, ~\".rs\") {\n         parse_crate_from_source_file(input, cfg, sess)\n     } else {\n-        sess.span_diagnostic.handler().fatal(\"unknown input file type: \" +\n+        sess.span_diagnostic.handler().fatal(~\"unknown input file type: \" +\n                                              input)\n     }\n }\n \n-fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n+fn parse_crate_from_crate_file(input: ~str, cfg: ast::crate_cfg,\n                                sess: parse_sess) -> @ast::crate {\n     let (p, rdr) = new_parser_etc_from_file(sess, cfg, input,\n                                             parser::CRATE_FILE);\n@@ -87,7 +87,7 @@ fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n                            config: /* FIXME (#2543) */ copy p.cfg});\n }\n \n-fn parse_crate_from_source_file(input: str, cfg: ast::crate_cfg,\n+fn parse_crate_from_source_file(input: ~str, cfg: ast::crate_cfg,\n                                 sess: parse_sess) -> @ast::crate {\n     let (p, rdr) = new_parser_etc_from_file(sess, cfg, input,\n                                             parser::SOURCE_FILE);\n@@ -97,7 +97,7 @@ fn parse_crate_from_source_file(input: str, cfg: ast::crate_cfg,\n     ret r;\n }\n \n-fn parse_crate_from_source_str(name: str, source: @str/~, cfg: ast::crate_cfg,\n+fn parse_crate_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n                                sess: parse_sess) -> @ast::crate {\n     let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name,\n                                                   codemap::fss_none, source);\n@@ -107,7 +107,7 @@ fn parse_crate_from_source_str(name: str, source: @str/~, cfg: ast::crate_cfg,\n     ret r;\n }\n \n-fn parse_expr_from_source_str(name: str, source: @str/~, cfg: ast::crate_cfg,\n+fn parse_expr_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n                               sess: parse_sess) -> @ast::expr {\n     let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name,\n                                                   codemap::fss_none, source);\n@@ -117,7 +117,7 @@ fn parse_expr_from_source_str(name: str, source: @str/~, cfg: ast::crate_cfg,\n     ret r;\n }\n \n-fn parse_item_from_source_str(name: str, source: @str/~, cfg: ast::crate_cfg,\n+fn parse_item_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n                               +attrs: ~[ast::attribute],\n                               vis: ast::visibility,\n                               sess: parse_sess) -> option<@ast::item> {\n@@ -130,16 +130,16 @@ fn parse_item_from_source_str(name: str, source: @str/~, cfg: ast::crate_cfg,\n }\n \n fn parse_from_source_str<T>(f: fn (p: parser) -> T,\n-                            name: str, ss: codemap::file_substr,\n-                            source: @str/~, cfg: ast::crate_cfg,\n+                            name: ~str, ss: codemap::file_substr,\n+                            source: @~str, cfg: ast::crate_cfg,\n                             sess: parse_sess)\n     -> T\n {\n     let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name, ss,\n                                                   source);\n     let r = f(p);\n     if !p.reader.is_eof() {\n-        p.reader.fatal(\"expected end-of-string\");\n+        p.reader.fatal(~\"expected end-of-string\");\n     }\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n@@ -155,8 +155,8 @@ fn next_node_id(sess: parse_sess) -> node_id {\n }\n \n fn new_parser_etc_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n-                                  +name: str, +ss: codemap::file_substr,\n-                                  source: @str/~) -> (parser, string_reader) {\n+                                  +name: ~str, +ss: codemap::file_substr,\n+                                  source: @~str) -> (parser, string_reader) {\n     let ftype = parser::SOURCE_FILE;\n     let filemap = codemap::new_filemap_w_substr\n         (name, ss, source, sess.chpos, sess.byte_pos);\n@@ -167,15 +167,15 @@ fn new_parser_etc_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n }\n \n fn new_parser_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n-                              +name: str, +ss: codemap::file_substr,\n-                              source: @str/~) -> parser {\n+                              +name: ~str, +ss: codemap::file_substr,\n+                              source: @~str) -> parser {\n     let (p, _) = new_parser_etc_from_source_str(sess, cfg, name, ss, source);\n     ret p;\n }\n \n \n-fn new_parser_etc_from_file(sess: parse_sess, cfg: ast::crate_cfg, +path: str,\n-                            ftype: parser::file_type) ->\n+fn new_parser_etc_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n+                            +path: ~str, ftype: parser::file_type) ->\n    (parser, string_reader) {\n     let res = io::read_whole_file_str(path);\n     alt res {\n@@ -190,7 +190,7 @@ fn new_parser_etc_from_file(sess: parse_sess, cfg: ast::crate_cfg, +path: str,\n     ret (parser(sess, cfg, srdr as reader, ftype), srdr);\n }\n \n-fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, +path: str,\n+fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, +path: ~str,\n                         ftype: parser::file_type) -> parser {\n     let (p, _) = new_parser_etc_from_file(sess, cfg, path, ftype);\n     ret p;"}, {"sha": "995feff0b70a993def8bd075336ffae437a45b4c", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -56,7 +56,7 @@ impl parser_attr for parser {\n                 let attr = ::attr::mk_sugared_doc_attr(\n                         *self.get_str(s), self.span.lo, self.span.hi);\n                 if attr.node.style != ast::attr_outer {\n-                  self.fatal(\"expected outer comment\");\n+                  self.fatal(~\"expected outer comment\");\n                 }\n                 attrs += ~[attr];\n                 self.bump();"}, {"sha": "737307bb648462c74e54c1b26722d4efd8dd58a8", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -18,28 +18,28 @@ enum cmnt_style {\n     blank_line, // Just a manual blank line \"\\n\\n\", for layout\n }\n \n-type cmnt = {style: cmnt_style, lines: ~[str], pos: uint};\n+type cmnt = {style: cmnt_style, lines: ~[~str], pos: uint};\n \n-fn is_doc_comment(s: str) -> bool {\n-    s.starts_with(\"///\") ||\n-    s.starts_with(\"//!\") ||\n-    s.starts_with(\"/**\") ||\n-    s.starts_with(\"/*!\")\n+fn is_doc_comment(s: ~str) -> bool {\n+    s.starts_with(~\"///\") ||\n+    s.starts_with(~\"//!\") ||\n+    s.starts_with(~\"/**\") ||\n+    s.starts_with(~\"/*!\")\n }\n \n-fn doc_comment_style(comment: str) -> ast::attr_style {\n+fn doc_comment_style(comment: ~str) -> ast::attr_style {\n     assert is_doc_comment(comment);\n-    if comment.starts_with(\"//!\") || comment.starts_with(\"/*!\") {\n+    if comment.starts_with(~\"//!\") || comment.starts_with(~\"/*!\") {\n         ast::attr_inner\n     } else {\n         ast::attr_outer\n     }\n }\n \n-fn strip_doc_comment_decoration(comment: str) -> str {\n+fn strip_doc_comment_decoration(comment: ~str) -> ~str {\n \n     /// remove whitespace-only lines from the start/end of lines\n-    fn vertical_trim(lines: ~[str]) -> ~[str] {\n+    fn vertical_trim(lines: ~[~str]) -> ~[~str] {\n         let mut i = 0u, j = lines.len();\n         while i < j && lines[i].trim().is_empty() {\n             i += 1u;\n@@ -51,7 +51,7 @@ fn strip_doc_comment_decoration(comment: str) -> str {\n     }\n \n     // drop leftmost columns that contain only values in chars\n-    fn block_trim(lines: ~[str], chars: str, max: option<uint>) -> ~[str] {\n+    fn block_trim(lines: ~[~str], chars: ~str, max: option<uint>) -> ~[~str] {\n \n         let mut i = max.get_default(uint::max_value);\n         for lines.each |line| {\n@@ -72,31 +72,31 @@ fn strip_doc_comment_decoration(comment: str) -> str {\n         ret do lines.map |line| {\n             let chars = str::chars(line);\n             if i > chars.len() {\n-                \"\"\n+                ~\"\"\n             } else {\n                 str::from_chars(chars.slice(i, chars.len()))\n             }\n         };\n     }\n \n-    if comment.starts_with(\"//\") {\n+    if comment.starts_with(~\"//\") {\n         ret comment.slice(3u, comment.len()).trim();\n     }\n \n-    if comment.starts_with(\"/*\") {\n+    if comment.starts_with(~\"/*\") {\n         let lines = str::lines_any(comment.slice(3u, comment.len() - 2u));\n         let lines = vertical_trim(lines);\n-        let lines = block_trim(lines, \"\\t \", none);\n-        let lines = block_trim(lines, \"*\", some(1u));\n-        let lines = block_trim(lines, \"\\t \", none);\n-        ret str::connect(lines, \"\\n\");\n+        let lines = block_trim(lines, ~\"\\t \", none);\n+        let lines = block_trim(lines, ~\"*\", some(1u));\n+        let lines = block_trim(lines, ~\"\\t \", none);\n+        ret str::connect(lines, ~\"\\n\");\n     }\n \n-    fail \"not a doc-comment: \" + comment;\n+    fail ~\"not a doc-comment: \" + comment;\n }\n \n-fn read_to_eol(rdr: string_reader) -> str {\n-    let mut val = \"\";\n+fn read_to_eol(rdr: string_reader) -> ~str {\n+    let mut val = ~\"\";\n     while rdr.curr != '\\n' && !is_eof(rdr) {\n         str::push_char(val, rdr.curr);\n         bump(rdr);\n@@ -105,7 +105,7 @@ fn read_to_eol(rdr: string_reader) -> str {\n     ret val;\n }\n \n-fn read_one_line_comment(rdr: string_reader) -> str {\n+fn read_one_line_comment(rdr: string_reader) -> ~str {\n     let val = read_to_eol(rdr);\n     assert ((val[0] == '/' as u8 && val[1] == '/' as u8) ||\n             (val[0] == '#' as u8 && val[1] == '!' as u8));\n@@ -120,7 +120,7 @@ fn consume_non_eol_whitespace(rdr: string_reader) {\n \n fn push_blank_line_comment(rdr: string_reader, &comments: ~[cmnt]) {\n     #debug(\">>> blank-line comment\");\n-    let v: ~[str] = ~[];\n+    let v: ~[~str] = ~[];\n     vec::push(comments, {style: blank_line, lines: v, pos: rdr.chpos});\n }\n \n@@ -151,7 +151,7 @@ fn read_line_comments(rdr: string_reader, code_to_the_left: bool,\n                                                         &comments: ~[cmnt]) {\n     #debug(\">>> line comments\");\n     let p = rdr.chpos;\n-    let mut lines: ~[str] = ~[];\n+    let mut lines: ~[~str] = ~[];\n     while rdr.curr == '/' && nextch(rdr) == '/' {\n         let line = read_one_line_comment(rdr);\n         log(debug, line);\n@@ -171,30 +171,30 @@ fn read_line_comments(rdr: string_reader, code_to_the_left: bool,\n     }\n }\n \n-fn all_whitespace(s: str, begin: uint, end: uint) -> bool {\n+fn all_whitespace(s: ~str, begin: uint, end: uint) -> bool {\n     let mut i: uint = begin;\n     while i != end { if !is_whitespace(s[i] as char) { ret false; } i += 1u; }\n     ret true;\n }\n \n-fn trim_whitespace_prefix_and_push_line(&lines: ~[str],\n-                                        s: str, col: uint) unsafe {\n+fn trim_whitespace_prefix_and_push_line(&lines: ~[~str],\n+                                        s: ~str, col: uint) unsafe {\n     let mut s1;\n     let len = str::len(s);\n     if all_whitespace(s, 0u, uint::min(len, col)) {\n         if col < len {\n             s1 = str::slice(s, col, len);\n-        } else { s1 = \"\"; }\n+        } else { s1 = ~\"\"; }\n     } else { s1 = s; }\n-    log(debug, \"pushing line: \" + s1);\n+    log(debug, ~\"pushing line: \" + s1);\n     vec::push(lines, s1);\n }\n \n fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n                                                         &comments: ~[cmnt]) {\n     #debug(\">>> block comment\");\n     let p = rdr.chpos;\n-    let mut lines: ~[str] = ~[];\n+    let mut lines: ~[~str] = ~[];\n     let mut col: uint = rdr.col;\n     bump(rdr);\n     bump(rdr);\n@@ -211,27 +211,27 @@ fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n         ret;\n     }\n \n-    let mut curr_line = \"/*\";\n+    let mut curr_line = ~\"/*\";\n     let mut level: int = 1;\n     while level > 0 {\n         #debug(\"=== block comment level %d\", level);\n-        if is_eof(rdr) {(rdr as reader).fatal(\"unterminated block comment\");}\n+        if is_eof(rdr) {(rdr as reader).fatal(~\"unterminated block comment\");}\n         if rdr.curr == '\\n' {\n             trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n-            curr_line = \"\";\n+            curr_line = ~\"\";\n             bump(rdr);\n         } else {\n             str::push_char(curr_line, rdr.curr);\n             if rdr.curr == '/' && nextch(rdr) == '*' {\n                 bump(rdr);\n                 bump(rdr);\n-                curr_line += \"*\";\n+                curr_line += ~\"*\";\n                 level += 1;\n             } else {\n                 if rdr.curr == '*' && nextch(rdr) == '/' {\n                     bump(rdr);\n                     bump(rdr);\n-                    curr_line += \"/\";\n+                    curr_line += ~\"/\";\n                     level -= 1;\n                 } else { bump(rdr); }\n             }\n@@ -268,14 +268,14 @@ fn consume_comment(rdr: string_reader, code_to_the_left: bool,\n     #debug(\"<<< consume comment\");\n }\n \n-type lit = {lit: str, pos: uint};\n+type lit = {lit: ~str, pos: uint};\n \n fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n-                                path: str,\n+                                path: ~str,\n                                 srdr: io::reader) ->\n    {cmnts: ~[cmnt], lits: ~[lit]} {\n     let src = @str::from_bytes(srdr.read_whole_stream());\n-    let itr = @interner::mk::<@str/~>(\n+    let itr = @interner::mk::<@~str>(\n         |x| str::hash(*x),\n         |x,y| str::eq(*x, *y)\n     );\n@@ -308,9 +308,9 @@ fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n         if token::is_lit(tok) {\n             let s = get_str_from(rdr, bstart);\n             vec::push(literals, {lit: s, pos: sp.lo});\n-            log(debug, \"tok lit: \" + s);\n+            log(debug, ~\"tok lit: \" + s);\n         } else {\n-            log(debug, \"tok: \" + token::to_str(*rdr.interner, tok));\n+            log(debug, ~\"tok: \" + token::to_str(*rdr.interner, tok));\n         }\n         first_read = false;\n     }"}, {"sha": "79ac3aeaf8b067dccc2dc863ee0f6539df6fac7c", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -18,7 +18,7 @@ fn seq_sep_none() -> seq_sep {\n     ret {sep: option::none, trailing_sep_allowed: false};\n }\n \n-fn token_to_str(reader: reader, ++token: token::token) -> str {\n+fn token_to_str(reader: reader, ++token: token::token) -> ~str {\n     token::to_str(*reader.interner(), token)\n }\n \n@@ -28,34 +28,34 @@ impl parser_common for parser {\n     fn unexpected_last(t: token::token) -> ! {\n         self.span_fatal(\n             copy self.last_span,\n-            \"unexpected token: `\" + token_to_str(self.reader, t) + \"`\");\n+            ~\"unexpected token: `\" + token_to_str(self.reader, t) + ~\"`\");\n     }\n \n     fn unexpected() -> ! {\n-        self.fatal(\"unexpected token: `\"\n-                   + token_to_str(self.reader, self.token) + \"`\");\n+        self.fatal(~\"unexpected token: `\"\n+                   + token_to_str(self.reader, self.token) + ~\"`\");\n     }\n \n     fn expect(t: token::token) {\n         if self.token == t {\n             self.bump();\n         } else {\n-            let mut s: str = \"expected `\";\n+            let mut s: ~str = ~\"expected `\";\n             s += token_to_str(self.reader, t);\n-            s += \"` but found `\";\n+            s += ~\"` but found `\";\n             s += token_to_str(self.reader, self.token);\n-            self.fatal(s + \"`\");\n+            self.fatal(s + ~\"`\");\n         }\n     }\n \n     fn parse_ident() -> ast::ident {\n         alt copy self.token {\n           token::IDENT(i, _) { self.bump(); ret self.get_str(i); }\n           token::ACTUALLY(token::w_ident(*)) { self.bug(\n-              \"ident interpolation not converted to real token\"); }\n-          _ { self.fatal(\"expected ident, found `\"\n+              ~\"ident interpolation not converted to real token\"); }\n+          _ { self.fatal(~\"expected ident, found `\"\n                          + token_to_str(self.reader, self.token)\n-                         + \"`\"); }\n+                         + ~\"`\"); }\n         }\n     }\n \n@@ -76,21 +76,21 @@ impl parser_common for parser {\n     }\n \n     // A sanity check that the word we are asking for is a known keyword\n-    fn require_keyword(word: str) {\n+    fn require_keyword(word: ~str) {\n         if !self.keywords.contains_key(word) {\n             self.bug(#fmt(\"unknown keyword: %s\", word));\n         }\n     }\n \n-    fn token_is_keyword(word: str, ++tok: token::token) -> bool {\n+    fn token_is_keyword(word: ~str, ++tok: token::token) -> bool {\n         self.require_keyword(word);\n         alt tok {\n           token::IDENT(sid, false) { str::eq(word, *self.get_str(sid)) }\n           _ { false }\n         }\n     }\n \n-    fn is_keyword(word: str) -> bool {\n+    fn is_keyword(word: ~str) -> bool {\n         self.token_is_keyword(word, self.token)\n     }\n \n@@ -103,7 +103,7 @@ impl parser_common for parser {\n         }\n     }\n \n-    fn eat_keyword(word: str) -> bool {\n+    fn eat_keyword(word: ~str) -> bool {\n         self.require_keyword(word);\n \n         // FIXME (#13042): this gratuitous use of @ is to\n@@ -119,16 +119,16 @@ impl parser_common for parser {\n         }\n     }\n \n-    fn expect_keyword(word: str) {\n+    fn expect_keyword(word: ~str) {\n         self.require_keyword(word);\n         if !self.eat_keyword(word) {\n-            self.fatal(\"expected `\" + word + \"`, found `\" +\n+            self.fatal(~\"expected `\" + word + ~\"`, found `\" +\n                        token_to_str(self.reader, self.token) +\n-                       \"`\");\n+                       ~\"`\");\n         }\n     }\n \n-    fn is_restricted_keyword(word: str) -> bool {\n+    fn is_restricted_keyword(word: ~str) -> bool {\n         self.restricted_keywords.contains_key(word)\n     }\n \n@@ -142,9 +142,9 @@ impl parser_common for parser {\n         }\n     }\n \n-    fn check_restricted_keywords_(w: str) {\n+    fn check_restricted_keywords_(w: ~str) {\n         if self.is_restricted_keyword(w) {\n-            self.fatal(\"found `\" + w + \"` in restricted position\");\n+            self.fatal(~\"found `\" + w + ~\"` in restricted position\");\n         }\n     }\n \n@@ -154,11 +154,11 @@ impl parser_common for parser {\n         } else if self.token == token::BINOP(token::SHR) {\n             self.swap(token::GT, self.span.lo + 1u, self.span.hi);\n         } else {\n-            let mut s: str = \"expected `\";\n+            let mut s: ~str = ~\"expected `\";\n             s += token_to_str(self.reader, token::GT);\n-            s += \"`, found `\";\n+            s += ~\"`, found `\";\n             s += token_to_str(self.reader, self.token);\n-            s += \"`\";\n+            s += ~\"`\";\n             self.fatal(s);\n         }\n     }"}, {"sha": "125dc809079e1b9fe7eecf0c937e1448edbe1883", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -9,7 +9,7 @@ type ctx =\n \n fn eval_crate_directives(cx: ctx,\n                          cdirs: ~[@ast::crate_directive],\n-                         prefix: str,\n+                         prefix: ~str,\n                          &view_items: ~[@ast::view_item],\n                          &items: ~[@ast::item]) {\n     for cdirs.each |sub_cdir| {\n@@ -18,11 +18,11 @@ fn eval_crate_directives(cx: ctx,\n }\n \n fn eval_crate_directives_to_mod(cx: ctx, cdirs: ~[@ast::crate_directive],\n-                                prefix: str, suffix: option<str>)\n+                                prefix: ~str, suffix: option<~str>)\n     -> (ast::_mod, ~[ast::attribute]) {\n     #debug(\"eval crate prefix: %s\", prefix);\n     #debug(\"eval crate suffix: %s\",\n-           option::get_default(suffix, \"none\"));\n+           option::get_default(suffix, ~\"none\"));\n     let (cview_items, citems, cattrs)\n         = parse_companion_mod(cx, prefix, suffix);\n     let mut view_items: ~[@ast::view_item] = ~[];\n@@ -43,17 +43,17 @@ companion mod is a .rs file with the same name as the directory.\n We build the path to the companion mod by combining the prefix and the\n optional suffix then adding the .rs extension.\n */\n-fn parse_companion_mod(cx: ctx, prefix: str, suffix: option<str>)\n+fn parse_companion_mod(cx: ctx, prefix: ~str, suffix: option<~str>)\n     -> (~[@ast::view_item], ~[@ast::item], ~[ast::attribute]) {\n \n-    fn companion_file(+prefix: str, suffix: option<str>) -> str {\n+    fn companion_file(+prefix: ~str, suffix: option<~str>) -> ~str {\n         ret alt suffix {\n           option::some(s) { path::connect(prefix, s) }\n           option::none { prefix }\n-        } + \".rs\";\n+        } + ~\".rs\";\n     }\n \n-    fn file_exists(path: str) -> bool {\n+    fn file_exists(path: ~str) -> bool {\n         // Crude, but there's no lib function for this and I'm not\n         // up to writing it just now\n         alt io::file_reader(path) {\n@@ -78,21 +78,21 @@ fn parse_companion_mod(cx: ctx, prefix: str, suffix: option<str>)\n     }\n }\n \n-fn cdir_path_opt(id: ast::ident, attrs: ~[ast::attribute]) -> @str/~ {\n-    alt ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n+fn cdir_path_opt(id: ast::ident, attrs: ~[ast::attribute]) -> @~str {\n+    alt ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n       some(d) {\n         ret d;\n       }\n       none { ret id; }\n     }\n }\n \n-fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n+fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: ~str,\n                         &view_items: ~[@ast::view_item],\n                         &items: ~[@ast::item]) {\n     alt cdir.node {\n       ast::cdir_src_mod(id, attrs) {\n-        let file_path = cdir_path_opt(@(*id + \".rs\"), attrs);\n+        let file_path = cdir_path_opt(@(*id + ~\".rs\"), attrs);\n         let full_path =\n             if path::path_is_absolute(*file_path) {\n                 *file_path"}, {"sha": "7afdc301b0235f6f4770be6c9e9643ebc3caa392", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -12,30 +12,30 @@ export string_reader_as_reader, tt_reader_as_reader;\n iface reader {\n     fn is_eof() -> bool;\n     fn next_token() -> {tok: token::token, sp: span};\n-    fn fatal(str) -> !;\n+    fn fatal(~str) -> !;\n     fn span_diag() -> span_handler;\n-    fn interner() -> @interner<@str/~>;\n+    fn interner() -> @interner<@~str>;\n     fn peek() -> {tok: token::token, sp: span};\n     fn dup() -> reader;\n }\n \n type string_reader = @{\n     span_diagnostic: span_handler,\n-    src: @str/~,\n+    src: @~str,\n     mut col: uint,\n     mut pos: uint,\n     mut curr: char,\n     mut chpos: uint,\n     filemap: codemap::filemap,\n-    interner: @interner<@str/~>,\n+    interner: @interner<@~str>,\n     /* cached: */\n     mut peek_tok: token::token,\n     mut peek_span: span\n };\n \n fn new_string_reader(span_diagnostic: span_handler,\n                      filemap: codemap::filemap,\n-                     itr: @interner<@str/~>) -> string_reader {\n+                     itr: @interner<@~str>) -> string_reader {\n     let r = new_low_level_string_reader(span_diagnostic, filemap, itr);\n     string_advance_token(r); /* fill in peek_* */\n     ret r;\n@@ -44,7 +44,7 @@ fn new_string_reader(span_diagnostic: span_handler,\n /* For comments.rs, which hackily pokes into 'pos' and 'curr' */\n fn new_low_level_string_reader(span_diagnostic: span_handler,\n                                filemap: codemap::filemap,\n-                               itr: @interner<@str/~>)\n+                               itr: @interner<@~str>)\n     -> string_reader {\n     let r = @{span_diagnostic: span_diagnostic, src: filemap.src,\n               mut col: 0u, mut pos: 0u, mut curr: -1 as char,\n@@ -75,11 +75,11 @@ impl string_reader_as_reader of reader for string_reader {\n         string_advance_token(self);\n         ret ret_val;\n     }\n-    fn fatal(m: str) -> ! {\n+    fn fatal(m: ~str) -> ! {\n         self.span_diagnostic.span_fatal(copy self.peek_span, m)\n     }\n     fn span_diag() -> span_handler { self.span_diagnostic }\n-    fn interner() -> @interner<@str/~> { self.interner }\n+    fn interner() -> @interner<@~str> { self.interner }\n     fn peek() -> {tok: token::token, sp: span} {\n         {tok: self.peek_tok, sp: self.peek_span}\n     }\n@@ -97,11 +97,11 @@ impl tt_reader_as_reader of reader for tt_reader {\n         }\n         tt_next_token(self)\n     }\n-    fn fatal(m: str) -> ! {\n+    fn fatal(m: ~str) -> ! {\n         self.sp_diag.span_fatal(copy self.cur_span, m);\n     }\n     fn span_diag() -> span_handler { self.sp_diag }\n-    fn interner() -> @interner<@str/~> { self.interner }\n+    fn interner() -> @interner<@~str> { self.interner }\n     fn peek() -> {tok: token::token, sp: span} {\n         { tok: self.cur_tok, sp: self.cur_span }\n     }\n@@ -125,7 +125,7 @@ fn string_advance_token(&&r: string_reader) {\n \n }\n \n-fn get_str_from(rdr: string_reader, start: uint) -> str unsafe {\n+fn get_str_from(rdr: string_reader, start: uint) -> ~str unsafe {\n     // I'm pretty skeptical about this subtraction. What if there's a\n     // multi-byte character before the mark?\n     ret str::slice(*rdr.src, start - 1u, rdr.pos - 1u);\n@@ -211,7 +211,7 @@ fn consume_any_line_comment(rdr: string_reader)\n             // line comments starting with \"///\" or \"//!\" are doc-comments\n             if rdr.curr == '/' || rdr.curr == '!' {\n                 let start_chpos = rdr.chpos - 2u;\n-                let mut acc = \"//\";\n+                let mut acc = ~\"//\";\n                 while rdr.curr != '\\n' && !is_eof(rdr) {\n                     str::push_char(acc, rdr.curr);\n                     bump(rdr);\n@@ -250,15 +250,15 @@ fn consume_block_comment(rdr: string_reader)\n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n     if rdr.curr == '*' || rdr.curr == '!' {\n         let start_chpos = rdr.chpos - 2u;\n-        let mut acc = \"/*\";\n+        let mut acc = ~\"/*\";\n         while !(rdr.curr == '*' && nextch(rdr) == '/') && !is_eof(rdr) {\n             str::push_char(acc, rdr.curr);\n             bump(rdr);\n         }\n         if is_eof(rdr) {\n-            rdr.fatal(\"unterminated block doc-comment\");\n+            rdr.fatal(~\"unterminated block doc-comment\");\n         } else {\n-            acc += \"*/\";\n+            acc += ~\"*/\";\n             bump(rdr);\n             bump(rdr);\n             ret some({\n@@ -270,7 +270,7 @@ fn consume_block_comment(rdr: string_reader)\n \n     let mut level: int = 1;\n     while level > 0 {\n-        if is_eof(rdr) { rdr.fatal(\"unterminated block comment\"); }\n+        if is_eof(rdr) { rdr.fatal(~\"unterminated block comment\"); }\n         if rdr.curr == '/' && nextch(rdr) == '*' {\n             bump(rdr);\n             bump(rdr);\n@@ -288,9 +288,9 @@ fn consume_block_comment(rdr: string_reader)\n     ret consume_whitespace_and_comments(rdr);\n }\n \n-fn scan_exponent(rdr: string_reader) -> option<str> {\n+fn scan_exponent(rdr: string_reader) -> option<~str> {\n     let mut c = rdr.curr;\n-    let mut rslt = \"\";\n+    let mut rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n         str::push_char(rslt, c);\n         bump(rdr);\n@@ -302,12 +302,12 @@ fn scan_exponent(rdr: string_reader) -> option<str> {\n         let exponent = scan_digits(rdr, 10u);\n         if str::len(exponent) > 0u {\n             ret some(rslt + exponent);\n-        } else { rdr.fatal(\"scan_exponent: bad fp literal\"); }\n-    } else { ret none::<str>; }\n+        } else { rdr.fatal(~\"scan_exponent: bad fp literal\"); }\n+    } else { ret none::<~str>; }\n }\n \n-fn scan_digits(rdr: string_reader, radix: uint) -> str {\n-    let mut rslt = \"\";\n+fn scan_digits(rdr: string_reader, radix: uint) -> ~str {\n+    let mut rslt = ~\"\";\n     loop {\n         let c = rdr.curr;\n         if c == '_' { bump(rdr); again; }\n@@ -366,7 +366,7 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n                       else { either::right(ast::ty_u64) };\n         }\n         if str::len(num_str) == 0u {\n-            rdr.fatal(\"no valid digits found for number\");\n+            rdr.fatal(~\"no valid digits found for number\");\n         }\n         let parsed = option::get(u64::from_str_radix(num_str, base as u64));\n         alt tp {\n@@ -379,7 +379,7 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n         is_float = true;\n         bump(rdr);\n         let dec_part = scan_digits(rdr, 10u);\n-        num_str += \".\" + dec_part;\n+        num_str += ~\".\" + dec_part;\n     }\n     alt scan_exponent(rdr) {\n       some(s) {\n@@ -414,7 +414,7 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n                              ast::ty_f);\n     } else {\n         if str::len(num_str) == 0u {\n-            rdr.fatal(\"no valid digits found for number\");\n+            rdr.fatal(~\"no valid digits found for number\");\n         }\n         let parsed = option::get(u64::from_str_radix(num_str, base as u64));\n \n@@ -440,7 +440,7 @@ fn scan_numeric_escape(rdr: string_reader, n_hex_digits: uint) -> char {\n }\n \n fn next_token_inner(rdr: string_reader) -> token::token {\n-    let mut accum_str = \"\";\n+    let mut accum_str = ~\"\";\n     let mut c = rdr.curr;\n     if (c >= 'a' && c <= 'z')\n         || (c >= 'A' && c <= 'Z')\n@@ -455,7 +455,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n             bump(rdr);\n             c = rdr.curr;\n         }\n-        if str::eq(accum_str, \"_\") { ret token::UNDERSCORE; }\n+        if str::eq(accum_str, ~\"_\") { ret token::UNDERSCORE; }\n         let is_mod_name = c == ':' && nextch(rdr) == ':';\n \n         // FIXME: perform NFKC normalization here. (Issue #2253)\n@@ -578,7 +578,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n             }\n         }\n         if rdr.curr != '\\'' {\n-            rdr.fatal(\"unterminated character constant\");\n+            rdr.fatal(~\"unterminated character constant\");\n         }\n         bump(rdr); // advance curr past token\n         ret token::LIT_INT(c2 as i64, ast::ty_char);"}, {"sha": "a19ea2d25e97c2cf8d3cc902b63242e4975833d6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 179, "deletions": 160, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -160,8 +160,8 @@ class parser {\n     let mut restriction: restriction;\n     let mut quote_depth: uint; // not (yet) related to the quasiquoter\n     let reader: reader;\n-    let keywords: hashmap<str, ()>;\n-    let restricted_keywords: hashmap<str, ()>;\n+    let keywords: hashmap<~str, ()>;\n+    let restricted_keywords: hashmap<~str, ()>;\n \n     new(sess: parse_sess, cfg: ast::crate_cfg, +rdr: reader, ftype: file_type)\n     {\n@@ -220,29 +220,29 @@ class parser {\n         }\n         ret copy self.buffer[(self.buffer_start + dist - 1) & 3].tok;\n     }\n-    fn fatal(m: str) -> ! {\n+    fn fatal(m: ~str) -> ! {\n         self.sess.span_diagnostic.span_fatal(copy self.span, m)\n     }\n-    fn span_fatal(sp: span, m: str) -> ! {\n+    fn span_fatal(sp: span, m: ~str) -> ! {\n         self.sess.span_diagnostic.span_fatal(sp, m)\n     }\n-    fn bug(m: str) -> ! {\n+    fn bug(m: ~str) -> ! {\n         self.sess.span_diagnostic.span_bug(copy self.span, m)\n     }\n-    fn warn(m: str) {\n+    fn warn(m: ~str) {\n         self.sess.span_diagnostic.span_warn(copy self.span, m)\n     }\n-    fn get_str(i: token::str_num) -> @str/~ {\n+    fn get_str(i: token::str_num) -> @~str {\n         interner::get(*self.reader.interner(), i)\n     }\n     fn get_id() -> node_id { next_node_id(self.sess) }\n \n     fn parse_ty_fn(purity: ast::purity) -> ty_ {\n-        let proto = if self.eat_keyword(\"extern\") {\n-            self.expect_keyword(\"fn\");\n+        let proto = if self.eat_keyword(~\"extern\") {\n+            self.expect_keyword(~\"fn\");\n             ast::proto_bare\n         } else {\n-            self.expect_keyword(\"fn\");\n+            self.expect_keyword(~\"fn\");\n             self.parse_fn_ty_proto()\n         };\n         ty_fn(proto, self.parse_ty_fn_decl(purity))\n@@ -259,7 +259,7 @@ class parser {\n                 let name = self.parse_value_ident();\n                 p.bump();\n                 name\n-            } else { @\"\" };\n+            } else { @~\"\" };\n \n             {mode: mode, ty: p.parse_ty(false), ident: name,\n              id: p.get_id()}\n@@ -317,8 +317,8 @@ class parser {\n                            vis: vis})\n               }\n \n-              _ { p.fatal(\"expected `;` or `}` but found `\" +\n-                          token_to_str(p.reader, p.token) + \"`\");\n+              _ { p.fatal(~\"expected `;` or `}` but found `\" +\n+                          token_to_str(p.reader, p.token) + ~\"`\");\n                 }\n             }\n         }\n@@ -345,7 +345,7 @@ class parser {\n     fn ident_index(args: ~[arg], i: ident) -> uint {\n         let mut j = 0u;\n         for args.each |a| { if a.ident == i { ret j; } j += 1u; }\n-        self.fatal(\"unbound variable `\" + *i + \"` in constraint arg\");\n+        self.fatal(~\"unbound variable `\" + *i + ~\"` in constraint arg\");\n     }\n \n     fn parse_type_constr_arg() -> @ty_constr_arg {\n@@ -431,7 +431,7 @@ class parser {\n         }\n     }\n \n-    fn region_from_name(s: option<@str/~>) -> @region {\n+    fn region_from_name(s: option<@~str>) -> @region {\n         let r = alt s {\n           some (string) { re_named(string) }\n           none { re_anon }\n@@ -538,19 +538,19 @@ class parser {\n             let region = self.parse_region_with_sep();\n             let mt = self.parse_mt();\n             ty_rptr(region, mt)\n-        } else if self.eat_keyword(\"pure\") {\n+        } else if self.eat_keyword(~\"pure\") {\n             self.parse_ty_fn(ast::pure_fn)\n-        } else if self.eat_keyword(\"unsafe\") {\n+        } else if self.eat_keyword(~\"unsafe\") {\n             self.parse_ty_fn(ast::unsafe_fn)\n-        } else if self.is_keyword(\"fn\") {\n+        } else if self.is_keyword(~\"fn\") {\n             self.parse_ty_fn(ast::impure_fn)\n-        } else if self.eat_keyword(\"extern\") {\n-            self.expect_keyword(\"fn\");\n+        } else if self.eat_keyword(~\"extern\") {\n+            self.expect_keyword(~\"fn\");\n             ty_fn(proto_bare, self.parse_ty_fn_decl(ast::impure_fn))\n         } else if self.token == token::MOD_SEP || is_ident(self.token) {\n             let path = self.parse_path_with_tps(colons_before_params);\n             ty_path(path, self.get_id())\n-        } else { self.fatal(\"expected type\"); };\n+        } else { self.fatal(~\"expected type\"); };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n         ret @{id: self.get_id(),\n@@ -588,9 +588,9 @@ class parser {\n             @{id: p.get_id(), is_move: is_move, name: ident, span: sp}\n         }\n \n-        if self.eat_keyword(\"move\") {\n+        if self.eat_keyword(~\"move\") {\n             either::right(parse_capture_item(self, true))\n-        } else if self.eat_keyword(\"copy\") {\n+        } else if self.eat_keyword(~\"copy\") {\n             either::right(parse_capture_item(self, false))\n         } else {\n             parse_arg_fn(self)\n@@ -642,7 +642,7 @@ class parser {\n                 some(mac_aq(mk_sp(lo,hi), e))\n               }\n               _ {\n-                self.fatal(\"expected `(` or unsuffixed integer literal\");\n+                self.fatal(~\"expected `(` or unsuffixed integer literal\");\n               }\n             }\n           }\n@@ -654,21 +654,12 @@ class parser {\n         if self.token == token::BINOP(token::SLASH) {\n             self.bump();\n             alt copy self.token {\n-              token::AT {\n-                self.bump(); some(vstore_box)\n-              }\n-              token::TILDE {\n-                self.bump(); some(vstore_uniq)\n-              }\n               token::UNDERSCORE {\n                 self.bump(); some(vstore_fixed(none))\n               }\n               token::LIT_INT_UNSUFFIXED(i) if i >= 0i64 {\n                 self.bump(); some(vstore_fixed(some(i as uint)))\n               }\n-              token::BINOP(token::AND) {\n-                some(vstore_slice(self.parse_region()))\n-              }\n               _ {\n                 none\n               }\n@@ -692,9 +683,9 @@ class parser {\n \n     fn parse_lit() -> lit {\n         let lo = self.span.lo;\n-        let lit = if self.eat_keyword(\"true\") {\n+        let lit = if self.eat_keyword(~\"true\") {\n             lit_bool(true)\n-        } else if self.eat_keyword(\"false\") {\n+        } else if self.eat_keyword(~\"false\") {\n             lit_bool(false)\n         } else {\n             let tok = self.token;\n@@ -753,7 +744,7 @@ class parser {\n             // Hack: avoid parsing vstores like /@ and /~.  This is painful\n             // because the notation for region bounds and the notation for\n             // vstores is... um... the same.  I guess that's my fault.  This\n-            // is still not ideal as for str/& we end up parsing more than we\n+            // is still not ideal as for &str we end up parsing more than we\n             // ought to and have to sort it out later.\n             if self.token == token::BINOP(token::SLASH)\n                 && self.look_ahead(1u) == token::BINOP(token::AND) {\n@@ -781,9 +772,9 @@ class parser {\n     }\n \n     fn parse_mutability() -> mutability {\n-        if self.eat_keyword(\"mut\") {\n+        if self.eat_keyword(~\"mut\") {\n             m_mutbl\n-        } else if self.eat_keyword(\"const\") {\n+        } else if self.eat_keyword(~\"const\") {\n             m_const\n         } else {\n             m_imm\n@@ -866,19 +857,19 @@ class parser {\n             ret self.mk_pexpr(lo, hi, expr_tup(es));\n         } else if self.token == token::LBRACE {\n             self.bump();\n-            if self.is_keyword(\"mut\") ||\n+            if self.is_keyword(~\"mut\") ||\n                 is_plain_ident(self.token)\n                 && self.look_ahead(1u) == token::COLON {\n                 let mut fields = ~[self.parse_field(token::COLON)];\n                 let mut base = none;\n                 while self.token != token::RBRACE {\n                     // optional comma before \"with\"\n                     if self.token == token::COMMA\n-                        && self.token_is_keyword(\"with\",\n+                        && self.token_is_keyword(~\"with\",\n                                                  self.look_ahead(1u)) {\n                         self.bump();\n                     }\n-                    if self.eat_keyword(\"with\") {\n+                    if self.eat_keyword(~\"with\") {\n                         base = some(self.parse_expr()); break;\n                     }\n                     self.expect(token::COMMA);\n@@ -897,36 +888,38 @@ class parser {\n             }\n         } else if token::is_bar(self.token) {\n             ret pexpr(self.parse_lambda_expr());\n-        } else if self.eat_keyword(\"new\") {\n+        } else if self.eat_keyword(~\"new\") {\n             self.expect(token::LPAREN);\n             let r = self.parse_expr();\n             self.expect(token::RPAREN);\n             let v = self.parse_expr();\n             ret self.mk_pexpr(lo, self.span.hi,\n                               expr_new(r, self.get_id(), v));\n-        } else if self.eat_keyword(\"if\") {\n+        } else if self.eat_keyword(~\"if\") {\n             ret pexpr(self.parse_if_expr());\n-        } else if self.eat_keyword(\"for\") {\n-            ret pexpr(self.parse_sugary_call_expr(\"for\", expr_loop_body));\n-        } else if self.eat_keyword(\"do\") {\n-            ret pexpr(self.parse_sugary_call_expr(\"do\", expr_do_body));\n-        } else if self.eat_keyword(\"while\") {\n+        } else if self.eat_keyword(~\"for\") {\n+            ret pexpr(self.parse_sugary_call_expr(~\"for\", expr_loop_body));\n+        } else if self.eat_keyword(~\"do\") {\n+            ret pexpr(self.parse_sugary_call_expr(~\"do\", expr_do_body));\n+        } else if self.eat_keyword(~\"while\") {\n             ret pexpr(self.parse_while_expr());\n-        } else if self.eat_keyword(\"loop\") {\n+        } else if self.eat_keyword(~\"loop\") {\n             ret pexpr(self.parse_loop_expr());\n-        } else if self.eat_keyword(\"alt\") {\n+        } else if self.eat_keyword(~\"alt\") {\n             ret pexpr(self.parse_alt_expr());\n-        } else if self.eat_keyword(\"fn\") {\n+        } else if self.eat_keyword(~\"fn\") {\n             let proto = self.parse_fn_ty_proto();\n             alt proto {\n-              proto_bare { self.fatal(\"fn expr are deprecated, use fn@\"); }\n-              proto_any { self.fatal(\"fn* cannot be used in an expression\"); }\n+              proto_bare { self.fatal(~\"fn expr are deprecated, use fn@\"); }\n+              proto_any {\n+                self.fatal(~\"fn* cannot be used in an expression\");\n+              }\n               _ { /* fallthrough */ }\n             }\n             ret pexpr(self.parse_fn_expr(proto));\n-        } else if self.eat_keyword(\"unchecked\") {\n+        } else if self.eat_keyword(~\"unchecked\") {\n             ret pexpr(self.parse_block_expr(lo, unchecked_blk));\n-        } else if self.eat_keyword(\"unsafe\") {\n+        } else if self.eat_keyword(~\"unsafe\") {\n             ret pexpr(self.parse_block_expr(lo, unsafe_blk));\n         } else if self.token == token::LBRACKET {\n             self.bump();\n@@ -958,58 +951,58 @@ class parser {\n             let ex_ext = self.parse_syntax_ext();\n             hi = ex_ext.span.hi;\n             ex = ex_ext.node;\n-        } else if self.eat_keyword(\"fail\") {\n+        } else if self.eat_keyword(~\"fail\") {\n             if can_begin_expr(self.token) {\n                 let e = self.parse_expr();\n                 hi = e.span.hi;\n                 ex = expr_fail(some(e));\n             } else { ex = expr_fail(none); }\n-        } else if self.eat_keyword(\"log\") {\n+        } else if self.eat_keyword(~\"log\") {\n             self.expect(token::LPAREN);\n             let lvl = self.parse_expr();\n             self.expect(token::COMMA);\n             let e = self.parse_expr();\n             ex = expr_log(2, lvl, e);\n             hi = self.span.hi;\n             self.expect(token::RPAREN);\n-        } else if self.eat_keyword(\"assert\") {\n+        } else if self.eat_keyword(~\"assert\") {\n             let e = self.parse_expr();\n             ex = expr_assert(e);\n             hi = e.span.hi;\n-        } else if self.eat_keyword(\"check\") {\n+        } else if self.eat_keyword(~\"check\") {\n             /* Should be a predicate (pure boolean function) applied to\n             arguments that are all either slot variables or literals.\n             but the typechecker enforces that. */\n             let e = self.parse_expr();\n             hi = e.span.hi;\n             ex = expr_check(checked_expr, e);\n-        } else if self.eat_keyword(\"claim\") {\n+        } else if self.eat_keyword(~\"claim\") {\n             /* Same rules as check, except that if check-claims\n             is enabled (a command-line flag), then the parser turns\n             claims into check */\n \n             let e = self.parse_expr();\n             hi = e.span.hi;\n             ex = expr_check(claimed_expr, e);\n-        } else if self.eat_keyword(\"ret\") {\n+        } else if self.eat_keyword(~\"ret\") {\n             if can_begin_expr(self.token) {\n                 let e = self.parse_expr();\n                 hi = e.span.hi;\n                 ex = expr_ret(some(e));\n             } else { ex = expr_ret(none); }\n-        } else if self.eat_keyword(\"break\") {\n+        } else if self.eat_keyword(~\"break\") {\n             ex = expr_break;\n             hi = self.span.hi;\n-        } else if self.eat_keyword(\"again\") {\n+        } else if self.eat_keyword(~\"again\") {\n             ex = expr_again;\n             hi = self.span.hi;\n-        } else if self.eat_keyword(\"copy\") {\n+        } else if self.eat_keyword(~\"copy\") {\n             let e = self.parse_expr();\n             ex = expr_copy(e);\n             hi = e.span.hi;\n         } else if self.token == token::MOD_SEP ||\n-            is_ident(self.token) && !self.is_keyword(\"true\") &&\n-            !self.is_keyword(\"false\") {\n+            is_ident(self.token) && !self.is_keyword(~\"true\") &&\n+            !self.is_keyword(~\"false\") {\n             let pth = self.parse_path_with_tps(true);\n \n             /* `!`, as an operator, is prefix, so we know this isn't that */\n@@ -1065,7 +1058,7 @@ class parser {\n     fn parse_syntax_ext_naked(lo: uint) -> @expr {\n         alt self.token {\n           token::IDENT(_, _) {}\n-          _ { self.fatal(\"expected a syntax expander name\"); }\n+          _ { self.fatal(~\"expected a syntax expander name\"); }\n         }\n         let pth = self.parse_path_without_tps();\n         //temporary for a backwards-compatible cycle:\n@@ -1093,7 +1086,7 @@ class parser {\n                 alt (self.token) {\n                   token::LBRACE {depth += 1u;}\n                   token::RBRACE {depth -= 1u;}\n-                  token::EOF {self.fatal(\"unexpected EOF in macro body\");}\n+                  token::EOF {self.fatal(~\"unexpected EOF in macro body\");}\n                   _ {}\n                 }\n                 self.bump();\n@@ -1181,7 +1174,7 @@ class parser {\n                 self.bump();\n                 ret (some(sep), zerok);\n             } else {\n-                self.fatal(\"expected `*` or `+`\");\n+                self.fatal(~\"expected `*` or `+`\");\n             }\n         }\n     }\n@@ -1201,11 +1194,11 @@ class parser {\n             alt p.token {\n               token::RPAREN | token::RBRACE | token::RBRACKET\n               if !delim_ok {\n-                p.fatal(\"incorrect close delimiter: `\"\n-                           + token_to_str(p.reader, p.token) + \"`\");\n+                p.fatal(~\"incorrect close delimiter: `\"\n+                           + token_to_str(p.reader, p.token) + ~\"`\");\n               }\n               token::EOF {\n-                p.fatal(\"file ended in the middle of a macro invocation\");\n+                p.fatal(~\"file ended in the middle of a macro invocation\");\n               }\n               /* we ought to allow different depths of unquotation */\n               token::DOLLAR if p.quote_depth > 0u {\n@@ -1280,7 +1273,7 @@ class parser {\n                 let ms = self.parse_matcher_subseq(name_idx, token::LPAREN,\n                                                    token::RPAREN);\n                 if ms.len() == 0u {\n-                    self.fatal(\"repetition body must be nonempty\");\n+                    self.fatal(~\"repetition body must be nonempty\");\n                 }\n                 let (sep, zerok) = self.parse_sep_and_zerok();\n                 mtc_rep(ms, sep, zerok)\n@@ -1337,7 +1330,8 @@ class parser {\n                 hi = e.span.hi;\n                 // HACK: turn &[...] into a &-evec\n                 ex = alt e.node {\n-                  expr_vec(*) if m == m_imm {\n+                  expr_vec(*) | expr_lit(@{node: lit_str(_), span: _})\n+                  if m == m_imm {\n                     expr_vstore(e, vstore_slice(self.region_from_name(none)))\n                   }\n                   _ { expr_addr_of(m, e) }\n@@ -1353,7 +1347,8 @@ class parser {\n             hi = e.span.hi;\n             // HACK: turn @[...] into a @-evec\n             ex = alt e.node {\n-              expr_vec(*) if m == m_imm { expr_vstore(e, vstore_box) }\n+              expr_vec(*) | expr_lit(@{node: lit_str(_), span: _})\n+              if m == m_imm { expr_vstore(e, vstore_box) }\n               _ { expr_unary(box(m), e) }\n             };\n           }\n@@ -1364,7 +1359,8 @@ class parser {\n             hi = e.span.hi;\n             // HACK: turn ~[...] into a ~-evec\n             ex = alt e.node {\n-              expr_vec(*) if m == m_imm { expr_vstore(e, vstore_uniq) }\n+              expr_vec(*) | expr_lit(@{node: lit_str(_), span: _})\n+              if m == m_imm { expr_vstore(e, vstore_uniq) }\n               _ { expr_unary(uniq(m), e) }\n             };\n           }\n@@ -1408,7 +1404,7 @@ class parser {\n           }\n           _ {}\n         }\n-        if as_prec > min_prec && self.eat_keyword(\"as\") {\n+        if as_prec > min_prec && self.eat_keyword(~\"as\") {\n             let rhs = self.parse_ty(true);\n             let _as =\n                 self.mk_pexpr(lhs.span.lo, rhs.span.hi, expr_cast(lhs, rhs));\n@@ -1471,7 +1467,7 @@ class parser {\n         let thn = self.parse_block();\n         let mut els: option<@expr> = none;\n         let mut hi = thn.span.hi;\n-        if self.eat_keyword(\"else\") {\n+        if self.eat_keyword(~\"else\") {\n             let elexpr = self.parse_else_expr();\n             els = some(elexpr);\n             hi = elexpr.span.hi;\n@@ -1480,7 +1476,7 @@ class parser {\n     }\n \n     fn parse_if_expr() -> @expr {\n-        if self.eat_keyword(\"check\") {\n+        if self.eat_keyword(~\"check\") {\n             let q = self.parse_if_expr_1();\n             ret self.mk_expr(q.lo, q.hi,\n                              expr_if_check(q.cond, q.then, q.els));\n@@ -1557,15 +1553,15 @@ class parser {\n     }\n \n     fn parse_else_expr() -> @expr {\n-        if self.eat_keyword(\"if\") {\n+        if self.eat_keyword(~\"if\") {\n             ret self.parse_if_expr();\n         } else {\n             let blk = self.parse_block();\n             ret self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n         }\n     }\n \n-    fn parse_sugary_call_expr(keyword: str,\n+    fn parse_sugary_call_expr(keyword: ~str,\n                               ctor: fn(+@expr) -> expr_) -> @expr {\n         let lo = self.last_span;\n         // Parse the callee `foo` in\n@@ -1622,15 +1618,15 @@ class parser {\n \n     fn parse_alt_expr() -> @expr {\n         let lo = self.last_span.lo;\n-        let mode = if self.eat_keyword(\"check\") { alt_check }\n+        let mode = if self.eat_keyword(~\"check\") { alt_check }\n         else { alt_exhaustive };\n         let discriminant = self.parse_expr();\n         self.expect(token::LBRACE);\n         let mut arms: ~[arm] = ~[];\n         while self.token != token::RBRACE {\n             let pats = self.parse_pats();\n             let mut guard = none;\n-            if self.eat_keyword(\"if\") { guard = some(self.parse_expr()); }\n+            if self.eat_keyword(~\"if\") { guard = some(self.parse_expr()); }\n             if self.token == token::FAT_ARROW { self.bump(); }\n             let blk = self.parse_block();\n             vec::push(arms, {pats: pats, guard: guard, body: blk});\n@@ -1693,14 +1689,33 @@ class parser {\n           token::AT {\n             self.bump();\n             let sub = self.parse_pat();\n-            pat = pat_box(sub);\n             hi = sub.span.hi;\n+            // HACK: parse @\"...\" as a literal of a vstore @str\n+            pat = alt sub.node {\n+              pat_lit(e@@{node: expr_lit(@{node: lit_str(_), span: _}), _}) {\n+                let vst = @{id: self.get_id(), callee_id: self.get_id(),\n+                            node: expr_vstore(e, vstore_box),\n+                            span: mk_sp(lo, hi)};\n+                pat_lit(vst)\n+              }\n+              _ { pat_box(sub) }\n+            };\n           }\n           token::TILDE {\n             self.bump();\n             let sub = self.parse_pat();\n-            pat = pat_uniq(sub);\n             hi = sub.span.hi;\n+            // HACK: parse ~\"...\" as a literal of a vstore ~str\n+            pat = alt sub.node {\n+              pat_lit(e@@{node: expr_lit(@{node: lit_str(_), span: _}), _}) {\n+                let vst = @{id: self.get_id(), callee_id: self.get_id(),\n+                            node: expr_vstore(e, vstore_uniq),\n+                            span: mk_sp(lo, hi)};\n+                pat_lit(vst)\n+              }\n+              _ { pat_uniq(sub) }\n+            };\n+\n           }\n           token::LBRACE {\n             self.bump();\n@@ -1714,9 +1729,9 @@ class parser {\n                 if self.token == token::UNDERSCORE {\n                     self.bump();\n                     if self.token != token::RBRACE {\n-                        self.fatal(\"expected `}`, found `\" +\n+                        self.fatal(~\"expected `}`, found `\" +\n                                    token_to_str(self.reader, self.token) +\n-                                   \"`\");\n+                                   ~\"`\");\n                     }\n                     etc = true;\n                     break;\n@@ -1767,10 +1782,10 @@ class parser {\n             }\n           }\n           tok {\n-            if !is_ident(tok) || self.is_keyword(\"true\")\n-                || self.is_keyword(\"false\") {\n+            if !is_ident(tok) || self.is_keyword(~\"true\")\n+                || self.is_keyword(~\"false\") {\n                 let val = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n-                if self.eat_keyword(\"to\") {\n+                if self.eat_keyword(~\"to\") {\n                     let end = self.parse_expr_res(RESTRICT_NO_BAR_OP);\n                     hi = end.span.hi;\n                     pat = pat_range(val, end);\n@@ -1844,7 +1859,7 @@ class parser {\n     }\n \n     fn parse_let() -> @decl {\n-        let is_mutbl = self.eat_keyword(\"mut\");\n+        let is_mutbl = self.eat_keyword(~\"mut\");\n         let lo = self.span.lo;\n         let mut locals = ~[self.parse_local(is_mutbl, true)];\n         while self.eat(token::COMMA) {\n@@ -1857,11 +1872,11 @@ class parser {\n     fn parse_instance_var(pr: visibility) -> @class_member {\n         let mut is_mutbl = class_immutable;\n         let lo = self.span.lo;\n-        if self.eat_keyword(\"mut\") {\n+        if self.eat_keyword(~\"mut\") {\n             is_mutbl = class_mutable;\n         }\n         if !is_plain_ident(self.token) {\n-            self.fatal(\"expected ident\");\n+            self.fatal(~\"expected ident\");\n         }\n         let name = self.parse_ident();\n         self.expect(token::COLON);\n@@ -1874,14 +1889,14 @@ class parser {\n         fn check_expected_item(p: parser, current_attrs: ~[attribute]) {\n             // If we have attributes then we should have an item\n             if vec::is_not_empty(current_attrs) {\n-                p.fatal(\"expected item\");\n+                p.fatal(~\"expected item\");\n             }\n         }\n \n         let lo = self.span.lo;\n-        if self.is_keyword(\"let\") {\n+        if self.is_keyword(~\"let\") {\n             check_expected_item(self, first_item_attrs);\n-            self.expect_keyword(\"let\");\n+            self.expect_keyword(~\"let\");\n             let decl = self.parse_let();\n             ret @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n         } else {\n@@ -1914,7 +1929,7 @@ class parser {\n     }\n \n     fn expr_is_complete(e: pexpr) -> bool {\n-        log(debug, (\"expr_is_complete\", self.restriction,\n+        log(debug, (~\"expr_is_complete\", self.restriction,\n                     print::pprust::expr_to_str(*e),\n                     classify::expr_requires_semi_to_be_stmt(*e)));\n         ret self.restriction == RESTRICT_STMT_EXPR &&\n@@ -1940,12 +1955,12 @@ class parser {\n         }\n \n         let lo = self.span.lo;\n-        if self.eat_keyword(\"unchecked\") {\n+        if self.eat_keyword(~\"unchecked\") {\n             self.expect(token::LBRACE);\n             let {inner, next} = maybe_parse_inner_attrs_and_next(self,\n                                                                  parse_attrs);\n             ret (inner, self.parse_block_tail_(lo, unchecked_blk, next));\n-        } else if self.eat_keyword(\"unsafe\") {\n+        } else if self.eat_keyword(~\"unsafe\") {\n             self.expect(token::LBRACE);\n             let {inner, next} = maybe_parse_inner_attrs_and_next(self,\n                                                                  parse_attrs);\n@@ -1982,7 +1997,7 @@ class parser {\n         let mut initial_attrs = attrs_remaining;\n \n         if self.token == token::RBRACE && !vec::is_empty(initial_attrs) {\n-            self.fatal(\"expected item\");\n+            self.fatal(~\"expected item\");\n         }\n \n         while self.token != token::RBRACE {\n@@ -2006,9 +2021,9 @@ class parser {\n                       }\n                       t {\n                         if classify::stmt_ends_with_semi(*stmt) {\n-                            self.fatal(\"expected `;` or `}` after expression \\\n-                                        but found `\"\n-                                       + token_to_str(self.reader, t) + \"`\");\n+                            self.fatal(~\"expected `;` or `}` after \\\n+                                         expression but found `\"\n+                                       + token_to_str(self.reader, t) + ~\"`\");\n                         }\n                         vec::push(stmts, stmt);\n                       }\n@@ -2038,9 +2053,9 @@ class parser {\n         let ident = self.parse_ident();\n         if self.eat(token::COLON) {\n             while self.token != token::COMMA && self.token != token::GT {\n-                if self.eat_keyword(\"send\") { push(bounds, bound_send); }\n-                else if self.eat_keyword(\"copy\") { push(bounds, bound_copy) }\n-                else if self.eat_keyword(\"const\") {\n+                if self.eat_keyword(~\"send\") { push(bounds, bound_send); }\n+                else if self.eat_keyword(~\"copy\") { push(bounds, bound_copy) }\n+                else if self.eat_keyword(~\"const\") {\n                     push(bounds, bound_const)\n                 }\n                 else { push(bounds, bound_trait(self.parse_ty(false))); }\n@@ -2134,12 +2149,16 @@ class parser {\n     fn parse_method_name() -> ident {\n         alt copy self.token {\n           token::BINOP(op) { self.bump(); @token::binop_to_str(op) }\n-          token::NOT { self.bump(); @\"!\" }\n-          token::LBRACKET { self.bump(); self.expect(token::RBRACKET); @\"[]\" }\n+          token::NOT { self.bump(); @~\"!\" }\n+          token::LBRACKET {\n+            self.bump();\n+            self.expect(token::RBRACKET);\n+            @~\"[]\"\n+          }\n           _ {\n             let id = self.parse_value_ident();\n-            if id == @\"unary\" && self.eat(token::BINOP(token::MINUS)) {\n-                @\"unary-\"\n+            if id == @~\"unary\" && self.eat(token::BINOP(token::MINUS)) {\n+                @~\"unary-\"\n             }\n             else { id }\n           }\n@@ -2182,15 +2201,15 @@ class parser {\n                 self.parse_region_param();\n                 (none, self.parse_ty_params())\n             }\n-            else if self.is_keyword(\"of\") {\n+            else if self.is_keyword(~\"of\") {\n                 (none, ~[])\n             } else {\n                 let id = self.parse_ident();\n                 self.parse_region_param();\n                 (some(id), self.parse_ty_params())\n             }\n         };\n-        let ifce = if self.eat_keyword(\"of\") {\n+        let ifce = if self.eat_keyword(~\"of\") {\n             let path = self.parse_path_with_tps(false);\n             if option::is_none(ident) {\n                 ident = some(vec::last(path.idents));\n@@ -2199,9 +2218,9 @@ class parser {\n         } else { none };\n         let ident = alt ident {\n           some(name) { name }\n-          none { self.expect_keyword(\"of\"); fail; }\n+          none { self.expect_keyword(~\"of\"); fail; }\n         };\n-        self.expect_keyword(\"for\");\n+        self.expect_keyword(~\"for\");\n         let ty = self.parse_ty(false);\n         let mut meths = ~[];\n         self.expect(token::LBRACE);\n@@ -2284,14 +2303,14 @@ class parser {\n           Is it strange for the parser to check this?\n           */\n           none {\n-            self.fatal(\"class with no constructor\");\n+            self.fatal(~\"class with no constructor\");\n           }\n         }\n     }\n \n     fn parse_single_class_item(vis: visibility)\n         -> @class_member {\n-        if self.eat_keyword(\"let\") {\n+        if self.eat_keyword(~\"let\") {\n             let a_var = self.parse_instance_var(vis);\n             self.expect(token::SEMI);\n             ret a_var;\n@@ -2322,15 +2341,15 @@ class parser {\n \n     fn parse_class_item(class_name_with_tps: @path)\n         -> class_contents {\n-        if self.eat_keyword(\"new\") {\n+        if self.eat_keyword(~\"new\") {\n             // result type is always the type of the class\n             ret self.parse_ctor(ty_path(class_name_with_tps,\n                                         self.get_id()));\n         }\n-        else if self.eat_keyword(\"drop\") {\n+        else if self.eat_keyword(~\"drop\") {\n             ret self.parse_dtor();\n         }\n-        else if self.eat_keyword(\"priv\") {\n+        else if self.eat_keyword(~\"priv\") {\n             self.expect(token::LBRACE);\n             let mut results = ~[];\n             while self.token != token::RBRACE {\n@@ -2346,8 +2365,8 @@ class parser {\n     }\n \n     fn parse_visibility(def: visibility) -> visibility {\n-        if self.eat_keyword(\"pub\") { public }\n-        else if self.eat_keyword(\"priv\") { private }\n+        if self.eat_keyword(~\"pub\") { public }\n+        else if self.eat_keyword(~\"priv\") { private }\n         else { def }\n     }\n \n@@ -2369,16 +2388,16 @@ class parser {\n             alt self.parse_item(attrs, vis) {\n               some(i) { vec::push(items, i); }\n               _ {\n-                self.fatal(\"expected item but found `\" +\n-                           token_to_str(self.reader, self.token) + \"`\");\n+                self.fatal(~\"expected item but found `\" +\n+                           token_to_str(self.reader, self.token) + ~\"`\");\n               }\n             }\n             #debug[\"parse_mod_items: attrs=%?\", attrs];\n         }\n \n         if first && attrs_remaining.len() > 0u {\n             // We parsed attributes for the first item but didn't find it\n-            self.fatal(\"expected item\");\n+            self.fatal(~\"expected item\");\n         }\n \n         ret {view_items: view_items, items: items};\n@@ -2418,12 +2437,12 @@ class parser {\n     }\n \n     fn parse_fn_purity() -> purity {\n-        if self.eat_keyword(\"fn\") { impure_fn }\n-        else if self.eat_keyword(\"pure\") {\n-            self.expect_keyword(\"fn\");\n+        if self.eat_keyword(~\"fn\") { impure_fn }\n+        else if self.eat_keyword(~\"pure\") {\n+            self.expect_keyword(~\"fn\");\n             pure_fn\n-        } else if self.eat_keyword(\"unsafe\") {\n-            self.expect_keyword(\"fn\");\n+        } else if self.eat_keyword(~\"unsafe\") {\n+            self.expect_keyword(~\"fn\");\n             unsafe_fn\n         }\n         else { self.unexpected(); }\n@@ -2452,7 +2471,7 @@ class parser {\n     }\n \n     fn parse_item_foreign_mod() -> item_info {\n-        self.expect_keyword(\"mod\");\n+        self.expect_keyword(~\"mod\");\n         let id = self.parse_ident();\n         self.expect(token::LBRACE);\n         let more_attrs = self.parse_inner_attrs_and_next();\n@@ -2537,7 +2556,7 @@ class parser {\n         }\n         self.expect(token::RBRACE);\n         if (have_disr && !all_nullary) {\n-            self.fatal(\"discriminator values can only be used with a c-like \\\n+            self.fatal(~\"discriminator values can only be used with a c-like \\\n                         enum\");\n         }\n         (id, item_enum(variants, ty_params), none)\n@@ -2577,39 +2596,39 @@ class parser {\n     fn parse_item(+attrs: ~[attribute], vis: visibility)\n         -> option<@item> {\n         let lo = self.span.lo;\n-        let (ident, item_, extra_attrs) = if self.eat_keyword(\"const\") {\n+        let (ident, item_, extra_attrs) = if self.eat_keyword(~\"const\") {\n             self.parse_item_const()\n-        } else if self.is_keyword(\"fn\") &&\n+        } else if self.is_keyword(~\"fn\") &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n             self.bump();\n             self.parse_item_fn(impure_fn)\n-        } else if self.eat_keyword(\"pure\") {\n-            self.expect_keyword(\"fn\");\n+        } else if self.eat_keyword(~\"pure\") {\n+            self.expect_keyword(~\"fn\");\n             self.parse_item_fn(pure_fn)\n-        } else if self.is_keyword(\"unsafe\")\n+        } else if self.is_keyword(~\"unsafe\")\n             && self.look_ahead(1u) != token::LBRACE {\n             self.bump();\n-            self.expect_keyword(\"fn\");\n+            self.expect_keyword(~\"fn\");\n             self.parse_item_fn(unsafe_fn)\n-        } else if self.eat_keyword(\"extern\") {\n-            if self.eat_keyword(\"fn\") {\n+        } else if self.eat_keyword(~\"extern\") {\n+            if self.eat_keyword(~\"fn\") {\n                 self.parse_item_fn(extern_fn)\n             } else {\n                 self.parse_item_foreign_mod()\n             }\n-        } else if self.eat_keyword(\"mod\") {\n+        } else if self.eat_keyword(~\"mod\") {\n             self.parse_item_mod()\n-        } else if self.eat_keyword(\"type\") {\n+        } else if self.eat_keyword(~\"type\") {\n             self.parse_item_type()\n-        } else if self.eat_keyword(\"enum\") {\n+        } else if self.eat_keyword(~\"enum\") {\n             self.parse_item_enum(vis)\n-        } else if self.eat_keyword(\"iface\") {\n+        } else if self.eat_keyword(~\"iface\") {\n             self.parse_item_trait()\n-        } else if self.eat_keyword(\"trait\") {\n+        } else if self.eat_keyword(~\"trait\") {\n             self.parse_item_trait()\n-        } else if self.eat_keyword(\"impl\") {\n+        } else if self.eat_keyword(~\"impl\") {\n             self.parse_item_impl()\n-        } else if self.eat_keyword(\"class\") {\n+        } else if self.eat_keyword(~\"class\") {\n             self.parse_item_class()\n         } else if !self.is_any_keyword(copy self.token)\n             && self.look_ahead(1) == token::NOT\n@@ -2721,21 +2740,21 @@ class parser {\n     }\n \n     fn is_view_item() -> bool {\n-        let tok = if !self.is_keyword(\"pub\") && !self.is_keyword(\"priv\") {\n+        let tok = if !self.is_keyword(~\"pub\") && !self.is_keyword(~\"priv\") {\n             self.token\n         } else { self.look_ahead(1u) };\n-        self.token_is_keyword(\"use\", tok)\n-            || self.token_is_keyword(\"import\", tok)\n-            || self.token_is_keyword(\"export\", tok)\n+        self.token_is_keyword(~\"use\", tok)\n+            || self.token_is_keyword(~\"import\", tok)\n+            || self.token_is_keyword(~\"export\", tok)\n     }\n \n     fn parse_view_item(+attrs: ~[attribute]) -> @view_item {\n         let lo = self.span.lo, vis = self.parse_visibility(private);\n-        let node = if self.eat_keyword(\"use\") {\n+        let node = if self.eat_keyword(~\"use\") {\n             self.parse_use()\n-        } else if self.eat_keyword(\"import\") {\n+        } else if self.eat_keyword(~\"import\") {\n             view_item_import(self.parse_view_paths())\n-        } else if self.eat_keyword(\"export\") {\n+        } else if self.eat_keyword(~\"export\") {\n             view_item_export(self.parse_view_paths())\n         } else { fail; };\n         self.expect(token::SEMI);\n@@ -2749,7 +2768,7 @@ class parser {\n         let mut attrs = vec::append(first_item_attrs,\n                                     self.parse_outer_attributes());\n         let mut items = ~[];\n-        while if only_imports { self.is_keyword(\"import\") }\n+        while if only_imports { self.is_keyword(~\"import\") }\n         else { self.is_view_item() } {\n             vec::push(items, self.parse_view_item(attrs));\n             attrs = self.parse_outer_attributes();\n@@ -2770,11 +2789,11 @@ class parser {\n                       config: self.cfg});\n     }\n \n-    fn parse_str() -> @str/~ {\n+    fn parse_str() -> @~str {\n         alt copy self.token {\n           token::LIT_STR(s) { self.bump(); self.get_str(s) }\n           _ {\n-            self.fatal(\"expected string literal\")\n+            self.fatal(~\"expected string literal\")\n           }\n         }\n     }\n@@ -2795,8 +2814,8 @@ class parser {\n         let expect_mod = vec::len(outer_attrs) > 0u;\n \n         let lo = self.span.lo;\n-        if expect_mod || self.is_keyword(\"mod\") {\n-            self.expect_keyword(\"mod\");\n+        if expect_mod || self.is_keyword(~\"mod\") {\n+            self.expect_keyword(~\"mod\");\n             let id = self.parse_ident();\n             alt self.token {\n               // mod x = \"foo.rs\";\n@@ -2823,7 +2842,7 @@ class parser {\n         } else if self.is_view_item() {\n             let vi = self.parse_view_item(outer_attrs);\n             ret spanned(lo, vi.span.hi, cdir_view_item(vi));\n-        } else { ret self.fatal(\"expected crate directive\"); }\n+        } else { ret self.fatal(~\"expected crate directive\"); }\n     }\n \n     fn parse_crate_directives(term: token::token,\n@@ -2834,7 +2853,7 @@ class parser {\n         // accept seeing the terminator next, so if we do see it then fail the\n         // same way parse_crate_directive would\n         if vec::len(first_outer_attr) > 0u && self.token == term {\n-            self.expect_keyword(\"mod\");\n+            self.expect_keyword(~\"mod\");\n         }\n \n         let mut cdirs: ~[@crate_directive] = ~[];"}, {"sha": "7db5af23266886eb83e157af25f4fc8d7662caf4", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -100,61 +100,61 @@ enum whole_nt {\n     w_mtcs(~[ast::matcher])\n }\n \n-fn binop_to_str(o: binop) -> str {\n+fn binop_to_str(o: binop) -> ~str {\n     alt o {\n-      PLUS { \"+\" }\n-      MINUS { \"-\" }\n-      STAR { \"*\" }\n-      SLASH { \"/\" }\n-      PERCENT { \"%\" }\n-      CARET { \"^\" }\n-      AND { \"&\" }\n-      OR { \"|\" }\n-      SHL { \"<<\" }\n-      SHR { \">>\" }\n+      PLUS { ~\"+\" }\n+      MINUS { ~\"-\" }\n+      STAR { ~\"*\" }\n+      SLASH { ~\"/\" }\n+      PERCENT { ~\"%\" }\n+      CARET { ~\"^\" }\n+      AND { ~\"&\" }\n+      OR { ~\"|\" }\n+      SHL { ~\"<<\" }\n+      SHR { ~\">>\" }\n     }\n }\n \n-fn to_str(in: interner<@str/~>, t: token) -> str {\n+fn to_str(in: interner<@~str>, t: token) -> ~str {\n     alt t {\n-      EQ { \"=\" }\n-      LT { \"<\" }\n-      LE { \"<=\" }\n-      EQEQ { \"==\" }\n-      NE { \"!=\" }\n-      GE { \">=\" }\n-      GT { \">\" }\n-      NOT { \"!\" }\n-      TILDE { \"~\" }\n-      OROR { \"||\" }\n-      ANDAND { \"&&\" }\n+      EQ { ~\"=\" }\n+      LT { ~\"<\" }\n+      LE { ~\"<=\" }\n+      EQEQ { ~\"==\" }\n+      NE { ~\"!=\" }\n+      GE { ~\">=\" }\n+      GT { ~\">\" }\n+      NOT { ~\"!\" }\n+      TILDE { ~\"~\" }\n+      OROR { ~\"||\" }\n+      ANDAND { ~\"&&\" }\n       BINOP(op) { binop_to_str(op) }\n-      BINOPEQ(op) { binop_to_str(op) + \"=\" }\n+      BINOPEQ(op) { binop_to_str(op) + ~\"=\" }\n \n       /* Structural symbols */\n-      AT { \"@\" }\n-      DOT { \".\" }\n-      ELLIPSIS { \"...\" }\n-      COMMA { \",\" }\n-      SEMI { \"\" }\n-      COLON { \":\" }\n-      MOD_SEP { \"::\" }\n-      RARROW { \"->\" }\n-      LARROW { \"<-\" }\n-      DARROW { \"<->\" }\n-      FAT_ARROW { \"=>\" }\n-      LPAREN { \"(\" }\n-      RPAREN { \")\" }\n-      LBRACKET { \"[\" }\n-      RBRACKET { \"]\" }\n-      LBRACE { \"{\" }\n-      RBRACE { \"}\" }\n-      POUND { \"#\" }\n-      DOLLAR { \"$\" }\n+      AT { ~\"@\" }\n+      DOT { ~\".\" }\n+      ELLIPSIS { ~\"...\" }\n+      COMMA { ~\",\" }\n+      SEMI { ~\"\" }\n+      COLON { ~\":\" }\n+      MOD_SEP { ~\"::\" }\n+      RARROW { ~\"->\" }\n+      LARROW { ~\"<-\" }\n+      DARROW { ~\"<->\" }\n+      FAT_ARROW { ~\"=>\" }\n+      LPAREN { ~\"(\" }\n+      RPAREN { ~\")\" }\n+      LBRACKET { ~\"[\" }\n+      RBRACKET { ~\"]\" }\n+      LBRACE { ~\"{\" }\n+      RBRACE { ~\"}\" }\n+      POUND { ~\"#\" }\n+      DOLLAR { ~\"$\" }\n \n       /* Literals */\n       LIT_INT(c, ast::ty_char) {\n-        \"'\" + char::escape_default(c as char) + \"'\"\n+        ~\"'\" + char::escape_default(c as char) + ~\"'\"\n       }\n       LIT_INT(i, t) {\n         int::to_str(i as int, 10u) + ast_util::int_ty_to_str(t)\n@@ -170,28 +170,28 @@ fn to_str(in: interner<@str/~>, t: token) -> str {\n             ast_util::float_ty_to_str(t)\n       }\n       LIT_STR(s) {\n-        \"\\\"\"\n+        ~\"\\\"\"\n             + str::escape_default(*interner::get(in, s))\n-            + \"\\\"\"\n+            + ~\"\\\"\"\n       }\n \n       /* Name components */\n       IDENT(s, _) {\n         *interner::get(in, s)\n       }\n-      UNDERSCORE { \"_\" }\n+      UNDERSCORE { ~\"_\" }\n \n       /* Other */\n       DOC_COMMENT(s) { *interner::get(in, s) }\n-      EOF { \"<eof>\" }\n+      EOF { ~\"<eof>\" }\n       ACTUALLY(w_nt) {\n-        \"an interpolated \" +\n+        ~\"an interpolated \" +\n             alt w_nt {\n-              w_item(*) { \"item\" } w_block(*) { \"block\" }\n-              w_stmt(*) { \"statement\" } w_pat(*) { \"pattern\" }\n-              w_expr(*) { \"expression\" } w_ty(*) { \"type\" }\n-              w_ident(*) { \"identifier\" } w_path(*) { \"path\" }\n-              w_tt(*) { \"tt\" } w_mtcs(*) { \"matcher sequence\" }\n+              w_item(*) { ~\"item\" } w_block(*) { ~\"block\" }\n+              w_stmt(*) { ~\"statement\" } w_pat(*) { ~\"pattern\" }\n+              w_expr(*) { ~\"expression\" } w_ty(*) { ~\"type\" }\n+              w_ident(*) { ~\"identifier\" } w_path(*) { ~\"path\" }\n+              w_tt(*) { ~\"tt\" } w_mtcs(*) { ~\"matcher sequence\" }\n             }\n       }\n     }\n@@ -256,7 +256,7 @@ pure fn is_bar(t: token) -> bool {\n  * the grammar is unambiguous. Restricted keywords may not appear\n  * in positions that might otherwise contain _value identifiers_.\n  */\n-fn keyword_table() -> hashmap<str, ()> {\n+fn keyword_table() -> hashmap<~str, ()> {\n     let keywords = str_hash();\n     for contextual_keyword_table().each_key |word| {\n         keywords.insert(word, ());\n@@ -268,18 +268,18 @@ fn keyword_table() -> hashmap<str, ()> {\n }\n \n /// Keywords that may be used as identifiers\n-fn contextual_keyword_table() -> hashmap<str, ()> {\n+fn contextual_keyword_table() -> hashmap<~str, ()> {\n     let words = str_hash();\n     let keys = ~[\n-        \"as\",\n-        \"else\",\n-        \"move\",\n-        \"of\",\n-        \"priv\", \"pub\",\n-        \"self\", \"send\", \"static\",\n-        \"to\",\n-        \"use\",\n-        \"with\"\n+        ~\"as\",\n+        ~\"else\",\n+        ~\"move\",\n+        ~\"of\",\n+        ~\"priv\", ~\"pub\",\n+        ~\"self\", ~\"send\", ~\"static\",\n+        ~\"to\",\n+        ~\"use\",\n+        ~\"with\"\n     ];\n     for keys.each |word| {\n         words.insert(word, ());\n@@ -301,23 +301,23 @@ fn contextual_keyword_table() -> hashmap<str, ()> {\n  * * `true` or `false` as identifiers would always be shadowed by\n  *   the boolean constants\n  */\n-fn restricted_keyword_table() -> hashmap<str, ()> {\n+fn restricted_keyword_table() -> hashmap<~str, ()> {\n     let words = str_hash();\n     let keys = ~[\n-        \"alt\", \"again\", \"assert\",\n-        \"break\",\n-        \"check\", \"claim\", \"class\", \"const\", \"copy\",\n-        \"do\", \"drop\",\n-        \"else\", \"enum\", \"export\", \"extern\",\n-        \"fail\", \"false\", \"fn\", \"for\",\n-        \"if\", \"iface\", \"impl\", \"import\",\n-        \"let\", \"log\", \"loop\",\n-        \"mod\", \"mut\",\n-        \"new\",\n-        \"pure\", \"ret\",\n-        \"true\", \"trait\", \"type\",\n-        \"unchecked\", \"unsafe\",\n-        \"while\"\n+        ~\"alt\", ~\"again\", ~\"assert\",\n+        ~\"break\",\n+        ~\"check\", ~\"claim\", ~\"class\", ~\"const\", ~\"copy\",\n+        ~\"do\", ~\"drop\",\n+        ~\"else\", ~\"enum\", ~\"export\", ~\"extern\",\n+        ~\"fail\", ~\"false\", ~\"fn\", ~\"for\",\n+        ~\"if\", ~\"iface\", ~\"impl\", ~\"import\",\n+        ~\"let\", ~\"log\", ~\"loop\",\n+        ~\"mod\", ~\"mut\",\n+        ~\"new\",\n+        ~\"pure\", ~\"ret\",\n+        ~\"true\", ~\"trait\", ~\"type\",\n+        ~\"unchecked\", ~\"unsafe\",\n+        ~\"while\"\n     ];\n     for keys.each |word| {\n         words.insert(word, ());"}, {"sha": "1a318d53635e89184c413e1ae7da17eea5267268", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f", "patch": "@@ -59,33 +59,33 @@ type break_t = {offset: int, blank_space: int};\n \n type begin_t = {offset: int, breaks: breaks};\n \n-enum token { STRING(@str/~, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n+enum token { STRING(@~str, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n \n-fn tok_str(++t: token) -> str {\n+fn tok_str(++t: token) -> ~str {\n     alt t {\n       STRING(s, len) { ret #fmt[\"STR(%s,%d)\", *s, len]; }\n-      BREAK(_) { ret \"BREAK\"; }\n-      BEGIN(_) { ret \"BEGIN\"; }\n-      END { ret \"END\"; }\n-      EOF { ret \"EOF\"; }\n+      BREAK(_) { ret ~\"BREAK\"; }\n+      BEGIN(_) { ret ~\"BEGIN\"; }\n+      END { ret ~\"END\"; }\n+      EOF { ret ~\"EOF\"; }\n     }\n }\n \n fn buf_str(toks: ~[mut token], szs: ~[mut int], left: uint, right: uint,\n-           lim: uint) -> str {\n+           lim: uint) -> ~str {\n     let n = vec::len(toks);\n     assert (n == vec::len(szs));\n     let mut i = left;\n     let mut L = lim;\n-    let mut s = \"[\";\n+    let mut s = ~\"[\";\n     while i != right && L != 0u {\n         L -= 1u;\n-        if i != left { s += \", \"; }\n+        if i != left { s += ~\", \"; }\n         s += #fmt[\"%d=%s\", szs[i], tok_str(toks[i])];\n         i += 1u;\n         i %= n;\n     }\n-    s += \"]\";\n+    s += ~\"]\";\n     ret s;\n }\n \n@@ -389,7 +389,7 @@ impl printer for printer {\n     }\n     fn print_newline(amount: int) {\n         #debug(\"NEWLINE %d\", amount);\n-        self.out.write_str(\"\\n\");\n+        self.out.write_str(~\"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n     }\n@@ -405,9 +405,9 @@ impl printer for printer {\n             {offset: 0, pbreak: broken(inconsistent)}\n         }\n     }\n-    fn write_str(s: str) {\n+    fn write_str(s: ~str) {\n         while self.pending_indentation > 0 {\n-            self.out.write_str(\" \");\n+            self.out.write_str(~\" \");\n             self.pending_indentation -= 1;\n         }\n         self.out.write_str(s);\n@@ -492,15 +492,15 @@ fn end(p: printer) { p.pretty_print(END); }\n \n fn eof(p: printer) { p.pretty_print(EOF); }\n \n-fn word(p: printer, wrd: str) {\n+fn word(p: printer, wrd: ~str) {\n     p.pretty_print(STRING(@wrd, str::len(wrd) as int));\n }\n \n-fn huge_word(p: printer, wrd: str) {\n+fn huge_word(p: printer, wrd: ~str) {\n     p.pretty_print(STRING(@wrd, size_infinity));\n }\n \n-fn zero_word(p: printer, wrd: str) { p.pretty_print(STRING(@wrd, 0)); }\n+fn zero_word(p: printer, wrd: ~str) { p.pretty_print(STRING(@wrd, 0)); }\n \n fn spaces(p: printer, n: uint) { break_offset(p, n, 0); }\n "}, {"sha": "29da51ec0839d417bb11023056141b797294539e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "6d3c2ba74bc92721ec364dbb840817c74368c7b1", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "8213ff1576e86bde5334b01c970ba02e2bad46a7", "filename": "src/rustc/back/abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fabi.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "22a9150df5657cefd85e795a53bb7f604d2ddd06", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 87, "deletions": 86, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "2e16d92cec8042948c351de377af984ea20ea282", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "798c4868a7c5657dd115794bdd541dd8a5c841e9", "filename": "src/rustc/back/target_strs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fback%2Ftarget_strs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fback%2Ftarget_strs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Ftarget_strs.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "94c69976c8c911cf4e9e94c065b64aa90cc0cd10", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "a7cd20e875bc95b6afd0699525171448d49085ec", "filename": "src/rustc/back/x86.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fx86.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "63399cd2b41c3c9d371a8c41529a33647ef5d1ba", "filename": "src/rustc/back/x86_64.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fx86_64.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "47b126df332408b5482e1ea8dbc04f9cdf24bd9f", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 150, "deletions": 146, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "e54ca83ebdcef6577271ce99e11b94a4361bd588", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "3697934dbc00984b2813f15a98543f8035bff748", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "c633cf5d2afa754a9ce3359325aef6c208f2673e", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "24b1a8094e3aa3869349d8368f943bd0df29b9c2", "filename": "src/rustc/front/core_inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fcore_inject.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "7f2e11ecccd776a202275cf6a46ec3dee5db225a", "filename": "src/rustc/front/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "ea841c0700cc8674c3d52f1088db73df048bd207", "filename": "src/rustc/front/intrinsic_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic_inject.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "17b92f6925e044d55194342993ffac3f3d8ae6ff", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "0c00a8674a529f330234dbd0978f503b6204112e", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "e7ef25a04d5584467124c00a232d22e9904a1304", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "28022a3732072431e154b4c17a050c4bde31e366", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "22d70f86eb8f80252c45f929ef93a9f3afec71bf", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "af9b6d57e5784651fc8396859d22d80de6f6ebf4", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "45bdee06070f9d9cf01a94b761c7593e024aa596", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "d1ecf88b3fe2c1915f1e1303227aaa6145d73d45", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "cb773589dcc2dfb4361803df459b64737d85ecad", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "862e6b90e7d3c3df4e4fb0958910d81be544072b", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "c0420f49a090f12e7de76742d372821db0fb7b7c", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "6cb430c519f3374694d6558651d24155aa5e0875", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "2211f62f2357291c68562086f8763f03e5a8c829", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "6c103915aaf113ce9db6b4b0f0cedb1ad15afc9c", "filename": "src/rustc/middle/block_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fblock_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fblock_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fblock_use.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "4db8ae6705dca97ab1ae7f2288137d8acec4ad0d", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "d32d5dfd4a9b29fc6c2d52731f2aa64ee45f625b", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "3c21c6d0c0ff1a22bb0efc70b21782f802562c45", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "5549ca53eb2f9d69e7d31c318f511944dc74eb2f", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "08d7227557b881912ca9fd67018347c011a9b266", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "9b2bcc3157248cd04021b1cfaf71554b3134999f", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "287c701d7d03d90a7e58eb2ffab2f01f886e17a0", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "69bb7220a4c40fab022f00a0dc1b73df207aabd1", "filename": "src/rustc/middle/check_loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_loop.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "cdb1a3b10d01e450ee15e7b7bf130b6d993a5c7e", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "7bbc2db066512f1809416eceb713a7c33127282d", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "7d89b4c701a8a8491a5e4aa9b4fe8077330b5022", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "0d2de5e8899ac410dc846e44f4757042bb3967e3", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "6bce1ab88d1a86091ee7c34a7c5280a7ec918e07", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "76851e4f778f938657f4d03bb89a70a1f5306273", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "9d026b1cc20986aa13c927af26810b0393dd87c4", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 83, "deletions": 82, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "07af1e5538a7c36119b77a7ef5a2949598081e82", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 96, "deletions": 93, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "0b7053a2c2bdf63e4f60179c3eabd6b530d49860", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "9273170c65c8212be9036442e1a862b3c8ecc7db", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 330, "deletions": 325, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "3d6746aa2eafc1f676d975ca3e07061b9c22f61e", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 107, "deletions": 107, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "22d16efbae556b104613eb3a5d37d0bc0f833d85", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "13f5b2f847058964ec2c3c68e66f0b1709a9f10b", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "b18569a093b94821dffc91e03216a504d12bc771", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "847aca0db2c4131c39f40c17ab24420856a132bc", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "8ea0583b81b4e2dc178b907b8c6f35a4511bc51a", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "7a371e7a5fde88b70373501517bca9cba1235591", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "56ad6f1363273e4d67af3d5e6b6596442a0cf4a7", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "24a1591a6c88279bd792e02e4f215d6440ffbbe6", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "0c233d2c1bc9a0e248c97e5e14ae5d3d0cbe904f", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "aac6f2d97bafc948290837ae901903ec1763dfa7", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "8d741655d3532ca601f0fa96a1df81b5e8f50362", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "b044d0ac23c68e0ccfd45c9432fc53b1c51c8f71", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "d1f19ba6e1f751e40041ac6c4b6bc92996aebaec", "filename": "src/rustc/middle/tstate/ann.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fann.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "de9a4540d21b2591e3cd6b2a22e6320f18f4c44d", "filename": "src/rustc/middle/tstate/annotate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "a098757175c2c87bc9816fee1e5197c33f5fd13d", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "d534b764c0786079d9db18a1a47c00685503f366", "filename": "src/rustc/middle/tstate/ck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "d7bfd0313077b8d11767682acf593dea8d01155a", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "591f152acb3cd600f260a0980fb89443856dfddb", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "ebe476b3d7f936ddf62ea49f306eda3394c38757", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "fc158262cb6ad1a5b703157e4c30c6b37a0103cc", "filename": "src/rustc/middle/tstate/tritv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "c3bcefb9fa556ee065e35755a7dfeca3ad2a9a58", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 86, "deletions": 84, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "1d86c47dddb66814f880e0d181f6659631251455", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "7d09c57dc924a62a7151b77a7703d45fefa22685", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "fa43449f30eda8c7af2c499b419cd496bb7f2c26", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 94, "deletions": 93, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "158d19bb6e2321cd4ca8bbe1894a3e5c74c86324", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "2dc80593e0279a8e0082ab4d297b2e7a4405a643", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "a883946252ca3a8dbdd6eb8b3b3a35438379e3ed", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "d563a4a99161d8a75663314ff165d4fab2108436", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "64d477ae63fad3989035fed936bbcd9dd255b320", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "da28e657758df5f33c62f5d84087f2d0359a264d", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "759ec5496b1dc627ded7577bfe81fc36f79f77ae", "filename": "src/rustc/middle/typeck/rscope.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "011b482f577de1831d1872dff1d14da9de7a9965", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "5d62bc31450689b790439e315ecb47d725f17b98", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 80, "deletions": 76, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "46884bcbe123792a49c339c8dc258c7f491a6205", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "931df85fa2ae8ac14422e527c16da610ba878959", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "c884c40e70fbc21598536eada44c2d3c1a7e8bc0", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "10bcbdb1404594346638af6dfa4c3bb72f9a01ee", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 77, "deletions": 76, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "bedb3605309f78d1e98a91c6156187ac8c605191", "filename": "src/rustdoc/demo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdemo.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "449ea1b5856ecc11ee47daf60189f894545cf110", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "d6b78095a152baeb82dc2a9c3c222fcaf783a758", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "dbc8a513f336130df1af9c3f4a21e4abb5d2da5e", "filename": "src/rustdoc/escape_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fescape_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fescape_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fescape_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "b3fd5257475501142e75ca02c97091be0f3f7ee0", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "e9d8615d1d4bb5257eeca99547ecee05becb2384", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "a98fe47ec0f327ae84fb3283ffd87f21d8272b56", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 59, "deletions": 58, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "9c36af9237bf3426c1fe4e9b3b721ff85620c382", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 128, "deletions": 126, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "5ac9998d9ea3cfc3c0de5743d8d9d7f5827cab44", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "972a697202e155c4b14c883649cef1ea9fb11260", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "ca30e8aa8a8fe05f477a9c2d857f06c56f1183a8", "filename": "src/rustdoc/parse.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fparse.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "45cd728786238fe35f20ef2e91e31a23f9693d3c", "filename": "src/rustdoc/path_pass.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpath_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "f5899e29df3ed800dc4411a27c53c6d09688117c", "filename": "src/rustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_hidden_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "00173e388505d1df55800bd1ea74215e83af9185", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "188c168d7c3e124be870910edeaedc1339ab164f", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "952539376ef43954f3da0de76ea05396e7d7985a", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "a6bb35746875f8d605f45fc5ac3f4ae90d2767b3", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "daf7d97c2ea46a61c10f69e1b0d253520ff458d0", "filename": "src/rustdoc/sort_item_name_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_name_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "bc2650e590a599398c02a43cdcc806d9647cb2b5", "filename": "src/rustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_type_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "a95de20d1baa7f9c5e6f1631c5fdb22856ce78a8", "filename": "src/rustdoc/sort_pass.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "ac419c557dfca760df8c852e8d56537d497bbe7e", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "1a5e96dbed41e326d2590fddad56e9544f30b983", "filename": "src/rustdoc/trim_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftrim_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "006e8bc66dc7daf02d3a6d863a8fb7064a66579f", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "52d91a7994f4f796c23f7295cf0b8dcbd30603d3", "filename": "src/rustdoc/unindent_pass.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Frustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Funindent_pass.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "19390ca63d592685701bbde9684e0e602e45b7f8", "filename": "src/snapshots.txt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "4bd1393a137a8ebf7f423b7e8bffdca57a31c5e5", "filename": "src/test/auxiliary/cci_class_4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "d031546c9dbeaf081eca796e60588d30908a670a", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "97787cc84066ea218743d2a9310c8f5fa8eb2124", "filename": "src/test/auxiliary/crate-method-reexport-grrrrrrr2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "d1a31246f5b0330e3e6cd525b60e16ffca2c4120", "filename": "src/test/auxiliary/crateresolve5-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "df28b2c25b7624bd18e521a5c28b32627f619924", "filename": "src/test/auxiliary/crateresolve5-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "c33ced59fec492b4c369c4f12fcf05dac033dbb1", "filename": "src/test/auxiliary/foreign_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "01cadc922469ed97f18f8473f69c88c1224e38c0", "filename": "src/test/auxiliary/issue-2414-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "dd8ace9ee7423a8da4d5187cace4283849cbcf1d", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "db7434a21396687398dc596fad1357f44fc46a34", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "5a6c9b9def7f591bfd9e267a24ab6597a1882bbd", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "dec0c0b9f22683f58aa0d426a89d1fd1f0b2b626", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "bd3f2c615bfda9d55af7d51d2aa0b11b2cc73e87", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "4a94083b8245be9c780ec12f94ed54336c668422", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "78eaab475669c418c9963769ee02ebe0ff65d857", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "3e2e955a08395d447c69084b9310b55964011d85", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "ceaed45f8f333beca791307d5a89cba3b75bc3bd", "filename": "src/test/bench/msgsend-ring.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "2f993d502ac9f6520da2dd641ca44aefe6a77cac", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "21d82f4daf9c90e551293bb839e83119adbe8cd0", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "f80060891c31f1dfffda4dd44d1e396a77114616", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "900df13cf3f4b1d060f06803de275d36b05bd8fa", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "0e0a5333c040ef71a2bdc394c218e1d9baa2d284", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "ca528764b1d9c5295dc87464cbb382d85804a178", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "08932324ac255b6f1aa9977c3f46fccf1835b8f9", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "fbf18ab7aa40e4b0c8ea8a68f2f3a87167532b3c", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "db6c1b67174df4e917542ccf5597c8c23f998b09", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "aa6377633c2f0a1e32d6914ec09a6ba662eb68ca", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "8c2c4426934946746c6ddfd7652628d113e1174e", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "41d2bdeb71b3f2d9b242a6f8e3f13fae5c886551", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "983efce1f50de0741a4b3338dca9a41d3babbde9", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "e064c9481f2a9e444f4c07ce880e140742bb8fd1", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "865385d81b0e20f2d1c95387b0835d8994c31de9", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "3eeb16f937960a6e50cb89def5c02352e9eceedb", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "240febf8f25fbd572c3d6cd11fe3568663c686bf", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "adb5e1a079909cd9d7fd7f8d58c398d319c1d907", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "32e701498b0412564e30b3a4be13c3596d54f1c9", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "62aa4d75f20b230280a608add92ee7ed29077eef", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "055da76b159f3844ab345fcb4fbf78a93edfb4e6", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "7c0601e7aa6a81ddb201ef3d99c864aacc36fa44", "filename": "src/test/compile-fail/bad-const-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-const-type.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "b698eb7c426e33779bb998f839a7ebc714e5b779", "filename": "src/test/compile-fail/binop-bitxor-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-bitxor-str.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "7e3e29f2b8f53a99141e9f807238c7e3fbdbfb48", "filename": "src/test/compile-fail/estr-subtyping.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "e3324cb59b4454bc329435a3bf940dfb32483b57", "filename": "src/test/compile-fail/fail-type-err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-type-err.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "b929ab0a1ce035052211d28bc08e813596b59902", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "00037ce0fda725d6c1d02d15a268f6f7cbe037cf", "filename": "src/test/compile-fail/minus-string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fminus-string.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "a54c5961d5503057d8e1171a8dd25e53a8f45fc0", "filename": "src/test/compile-fail/missing-do.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "35b81cdecb18dfa2b2c6d568918dafac4ca1aa09", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "88c6688b7662316bb0a0f85ac6c2effdb1e65253", "filename": "src/test/run-fail/alt-bot-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-bot-fail.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "09770179ebff7c249f5f85ffdd8401e3f1235e45", "filename": "src/test/run-fail/alt-disc-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Falt-disc-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Falt-disc-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-disc-bot.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "4a428f3cdb161c8a8917b145aa6b89d22ef9392f", "filename": "src/test/run-fail/alt-wildcards.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Falt-wildcards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Falt-wildcards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-wildcards.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "a28762aa9c2914da17870bd597fc302031bb399c", "filename": "src/test/run-fail/args-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fargs-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fargs-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fargs-fail.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "feb657efe0c874537bf34e06bdee15dd18e698f5", "filename": "src/test/run-fail/binop-fail-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbinop-fail-2.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "a4aa12003164d73a2ce83649ed68601ed05d217a", "filename": "src/test/run-fail/binop-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fbinop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fbinop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbinop-fail.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "e1b9187e0fb16c7875f9f004dfda61085a54bad9", "filename": "src/test/run-fail/bug-811.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fbug-811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fbug-811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-811.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "f3927f122ed44fee5f9f7855bb3cf8de9b9d38a4", "filename": "src/test/run-fail/explicit-fail-msg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexplicit-fail-msg.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "5d1e83d6203dcc4a16250397fbae5f94b14328c8", "filename": "src/test/run-fail/fail-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ffail-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ffail-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-arg.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "7791811220932fa25846a39e879c3a2ada1055f1", "filename": "src/test/run-fail/fail-main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ffail-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ffail-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-main.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "3950495e9c4ade5c19bc342aeb2a3fa0948ab9aa", "filename": "src/test/run-fail/fmt-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffmt-fail.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "e209a3de489859ca5cf5b1cbd87b4df52fe5af43", "filename": "src/test/run-fail/fn-constraint-claim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ffn-constraint-claim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ffn-constraint-claim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffn-constraint-claim.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "847be69522299d3dc65c81d00b2ad69114800041", "filename": "src/test/run-fail/for-each-loop-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffor-each-loop-fail.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "3aa87f04e2d5bf3c10deed65665829c0f459b9c8", "filename": "src/test/run-fail/if-check-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fif-check-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fif-check-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fif-check-fail.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "0a11fc35fcac7759871f6681296d79b4247582de", "filename": "src/test/run-fail/if-cond-bot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fif-cond-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fif-cond-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fif-cond-bot.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "0039c5b0358f99b95d9acc428a0680df14046d7f", "filename": "src/test/run-fail/issue-1459.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fissue-1459.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fissue-1459.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-1459.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "1e8fea9d111ffc5c6b05abb012b1aed2998dc111", "filename": "src/test/run-fail/issue-2156.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2156.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "abc67f7c4aaa85b426f63d0487c1193722d5256d", "filename": "src/test/run-fail/issue-948.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fissue-948.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fissue-948.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-948.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "926317c78366548eefccaa77bf4f4935a1d2d4f9", "filename": "src/test/run-fail/linked-failure3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Flinked-failure3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Flinked-failure3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure3.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "649d00dc1f4d9cf73681f993dc27e28193910938", "filename": "src/test/run-fail/morestack2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack2.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "e33130df83ce40a04bfef9143f55d9869188f3c0", "filename": "src/test/run-fail/port-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fport-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fport-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fport-type.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "41da3a6b55c82c7dc96ece765a0ba5be9db31952", "filename": "src/test/run-fail/result-get-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "c58f396f2eb9c890737c134c54455d560ba0222f", "filename": "src/test/run-fail/rhs-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Frhs-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Frhs-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frhs-type.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "a74cde845582948aa8b77b60daa3609952275707", "filename": "src/test/run-fail/rt-log-trunc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Frt-log-trunc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Frt-log-trunc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-log-trunc.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "32388eb0992c345809ae77659354e941e6b78e4b", "filename": "src/test/run-fail/rt-set-exit-status-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "1cd6784cf42c03e94fd8974bab6e66f120182f38", "filename": "src/test/run-fail/rt-set-exit-status-fail2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "c4e86715980fa90e3cf8acd088e8aba4d872c9e6", "filename": "src/test/run-fail/rt-set-exit-status.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "3275e30eb5b2f83c8cdf8f5785dbc77956029eba", "filename": "src/test/run-fail/run-unexported-tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Frun-unexported-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Frun-unexported-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frun-unexported-tests.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "b8bccfe82d4769cea50c50b009d3635bdfc8b555", "filename": "src/test/run-fail/str-overrun.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fstr-overrun.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "f55758d7196e894f230ddff97d61aa19813437ba", "filename": "src/test/run-fail/task-comm-recv-block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "e9a20e8132466632e28f1f584311ede674cbe91a", "filename": "src/test/run-fail/task-spawn-barefn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "36dd47c373b2e3215f2514686c66ca89cd1052c9", "filename": "src/test/run-fail/too-much-recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ftoo-much-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Ftoo-much-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftoo-much-recursion.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "751dc722fc898127b8c3a7e2a513b091e6ce797a", "filename": "src/test/run-fail/unwind-alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Funwind-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Funwind-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-alt.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "fa28160d8126652043ad91e2dcf0acfe6d6a2e12", "filename": "src/test/run-fail/unwind-box-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Funwind-box-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Funwind-box-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-str.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "d97c66b4b9b139b5b76ab0c636c3113d3d0a7a73", "filename": "src/test/run-fail/unwind-lambda.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-lambda.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "7a0324a0f16ef5baa92e52d7fa2cb9c58d3b14d0", "filename": "src/test/run-fail/unwind-misc-1.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-misc-1.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "4e422fc095e4a279f4548ac4eef45b56342ccd48", "filename": "src/test/run-fail/while-body-fails.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fwhile-body-fails.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fwhile-body-fails.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fwhile-body-fails.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "8dc923ab60e9ba61a5d44754ef9f448bf28c4366", "filename": "src/test/run-fail/while-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fwhile-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fwhile-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fwhile-fail.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "ae98291777a832ee3c856cd8111a1b1effc0fbc5", "filename": "src/test/run-fail/zip-different-lengths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "171531c5fb80d1b1f02913192d97db07f4eb7fc4", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "866ed58f842ca819b72a08a2accf52584518a119", "filename": "src/test/run-pass/alias-uninit-value.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "29bbc452d476e3139a22bc5c5acef0ad26bae142", "filename": "src/test/run-pass/alt-range.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-pass%2Falt-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-pass%2Falt-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-range.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "708932b2e1a720b6c5f740ef259dafff02c5b46c", "filename": "src/test/run-pass/alt-str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-pass%2Falt-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-pass%2Falt-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-str.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}, {"sha": "b12841dd22904454af7a03d4dd0d2c0dd5a201ee", "filename": "src/test/run-pass/alt-with-ret-arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7d139a3849f7f40df793ddab3186ec741edf7f/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs?ref=5a7d139a3849f7f40df793ddab3186ec741edf7f"}]}