{"sha": "5166682583a95a8e498c27d12154ddc1d9dda406", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNjY2ODI1ODNhOTVhOGU0OThjMjdkMTIxNTRkZGMxZDlkZGE0MDY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-12T18:54:46Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-17T14:38:48Z"}, "message": "pull out the record call for encode_info_for_item", "tree": {"sha": "30ed8149bf6a65ac9e60bdfe454c42b57b2509d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30ed8149bf6a65ac9e60bdfe454c42b57b2509d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5166682583a95a8e498c27d12154ddc1d9dda406", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5166682583a95a8e498c27d12154ddc1d9dda406", "html_url": "https://github.com/rust-lang/rust/commit/5166682583a95a8e498c27d12154ddc1d9dda406", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5166682583a95a8e498c27d12154ddc1d9dda406/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6277b1fef617610c32b36dba1b06f937488ca5a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6277b1fef617610c32b36dba1b06f937488ca5a9", "html_url": "https://github.com/rust-lang/rust/commit/6277b1fef617610c32b36dba1b06f937488ca5a9"}], "stats": {"total": 468, "additions": 226, "deletions": 242}, "files": [{"sha": "25b705b0d3a77a3091c519f48f4b30fe65206242", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 226, "deletions": 242, "changes": 468, "blob_url": "https://github.com/rust-lang/rust/blob/5166682583a95a8e498c27d12154ddc1d9dda406/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5166682583a95a8e498c27d12154ddc1d9dda406/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=5166682583a95a8e498c27d12154ddc1d9dda406", "patch": "@@ -748,8 +748,9 @@ fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     rbml_w.end_tag();\n }\n \n-impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_info_for_item(&mut self,\n+                            def_id: DefId,\n                             item: &hir::Item) {\n         let ecx = self.ecx();\n         let tcx = ecx.tcx;\n@@ -758,7 +759,6 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                tcx.sess.codemap().span_to_string(item.span));\n \n         let vis = &item.vis;\n-        let def_id = ecx.tcx.map.local_def_id(item.id);\n \n         let (stab, depr) = tcx.dep_graph.with_task(DepNode::MetaData(def_id), || {\n             (tcx.lookup_stability(ecx.tcx.map.local_def_id(item.id)),\n@@ -767,284 +767,264 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n \n         match item.node {\n             hir::ItemStatic(_, m, _) => {\n-                self.record(def_id, |this| {\n-                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n-                    if m == hir::MutMutable {\n-                        encode_family(this.rbml_w, 'b');\n-                    } else {\n-                        encode_family(this.rbml_w, 'c');\n-                    }\n-                    this.encode_bounds_and_type_for_item(item.id);\n-                    encode_name(this.rbml_w, item.name);\n-                    this.encode_visibility(vis);\n-                    encode_stability(this.rbml_w, stab);\n-                    encode_deprecation(this.rbml_w, depr);\n-                    encode_attributes(this.rbml_w, &item.attrs);\n-                });\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                if m == hir::MutMutable {\n+                    encode_family(self.rbml_w, 'b');\n+                } else {\n+                    encode_family(self.rbml_w, 'c');\n+                }\n+                self.encode_bounds_and_type_for_item(item.id);\n+                encode_name(self.rbml_w, item.name);\n+                self.encode_visibility(vis);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+                encode_attributes(self.rbml_w, &item.attrs);\n             }\n             hir::ItemConst(_, _) => {\n-                self.record(def_id, |this| {\n-                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n-                    encode_family(this.rbml_w, 'C');\n-                    this.encode_bounds_and_type_for_item(item.id);\n-                    encode_name(this.rbml_w, item.name);\n-                    encode_attributes(this.rbml_w, &item.attrs);\n-                    encode_inlined_item(ecx, this.rbml_w, InlinedItemRef::Item(def_id, item));\n-                    this.encode_mir(item.id);\n-                    this.encode_visibility(vis);\n-                    encode_stability(this.rbml_w, stab);\n-                    encode_deprecation(this.rbml_w, depr);\n-                });\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, 'C');\n+                self.encode_bounds_and_type_for_item(item.id);\n+                encode_name(self.rbml_w, item.name);\n+                encode_attributes(self.rbml_w, &item.attrs);\n+                encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n+                self.encode_mir(item.id);\n+                self.encode_visibility(vis);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n             }\n             hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n-                self.record(def_id, |this| {\n-                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n-                    encode_family(this.rbml_w, FN_FAMILY);\n-                    let tps_len = generics.ty_params.len();\n-                    this.encode_bounds_and_type_for_item(item.id);\n-                    encode_name(this.rbml_w, item.name);\n-                    encode_attributes(this.rbml_w, &item.attrs);\n-                    let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n-                    if needs_inline || constness == hir::Constness::Const {\n-                        encode_inlined_item(ecx, this.rbml_w, InlinedItemRef::Item(def_id, item));\n-                        this.encode_mir(item.id);\n-                    }\n-                    encode_constness(this.rbml_w, constness);\n-                    this.encode_visibility(vis);\n-                    encode_stability(this.rbml_w, stab);\n-                    encode_deprecation(this.rbml_w, depr);\n-                    this.encode_method_argument_names(&decl);\n-                });\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, FN_FAMILY);\n+                let tps_len = generics.ty_params.len();\n+                self.encode_bounds_and_type_for_item(item.id);\n+                encode_name(self.rbml_w, item.name);\n+                encode_attributes(self.rbml_w, &item.attrs);\n+                let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n+                if needs_inline || constness == hir::Constness::Const {\n+                    encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n+                    self.encode_mir(item.id);\n+                }\n+                encode_constness(self.rbml_w, constness);\n+                self.encode_visibility(vis);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+                self.encode_method_argument_names(&decl);\n             }\n             hir::ItemMod(ref m) => {\n-                self.record(def_id, |this| {\n-                    this.encode_info_for_mod(m,\n-                                             &item.attrs,\n-                                             item.id,\n-                                             item.name,\n-                                             &item.vis);\n-                });\n+                self.encode_info_for_mod(m,\n+                                         &item.attrs,\n+                                         item.id,\n+                                         item.name,\n+                                         &item.vis);\n             }\n             hir::ItemForeignMod(ref fm) => {\n-                self.record(def_id, |this| {\n-                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n-                    encode_family(this.rbml_w, 'n');\n-                    encode_name(this.rbml_w, item.name);\n-\n-                    // Encode all the items in this module.\n-                    for foreign_item in &fm.items {\n-                        this.rbml_w.wr_tagged_u64(tag_mod_child,\n-                                             def_to_u64(ecx.tcx.map.local_def_id(foreign_item.id)));\n-                    }\n-                    this.encode_visibility(vis);\n-                    encode_stability(this.rbml_w, stab);\n-                    encode_deprecation(this.rbml_w, depr);\n-                });\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, 'n');\n+                encode_name(self.rbml_w, item.name);\n+\n+                // Encode all the items in self module.\n+                for foreign_item in &fm.items {\n+                    self.rbml_w.wr_tagged_u64(tag_mod_child,\n+                                              def_to_u64(ecx.tcx.map.local_def_id(foreign_item.id)));\n+                }\n+                self.encode_visibility(vis);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n             }\n             hir::ItemTy(..) => {\n-                self.record(def_id, |this| {\n-                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n-                    encode_family(this.rbml_w, 'y');\n-                    this.encode_bounds_and_type_for_item(item.id);\n-                    encode_name(this.rbml_w, item.name);\n-                    this.encode_visibility(vis);\n-                    encode_stability(this.rbml_w, stab);\n-                    encode_deprecation(this.rbml_w, depr);\n-                });\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, 'y');\n+                self.encode_bounds_and_type_for_item(item.id);\n+                encode_name(self.rbml_w, item.name);\n+                self.encode_visibility(vis);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n             }\n             hir::ItemEnum(ref enum_definition, _) => {\n-                self.record(def_id, |this| {\n-                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n-                    encode_family(this.rbml_w, 't');\n-                    encode_item_variances(this.rbml_w, ecx, item.id);\n-                    this.encode_bounds_and_type_for_item(item.id);\n-                    encode_name(this.rbml_w, item.name);\n-                    encode_attributes(this.rbml_w, &item.attrs);\n-                    this.encode_repr_attrs(&item.attrs);\n-                    for v in &enum_definition.variants {\n-                        encode_variant_id(this.rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n-                    }\n-                    encode_inlined_item(ecx, this.rbml_w, InlinedItemRef::Item(def_id, item));\n-                    this.encode_mir(item.id);\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, 't');\n+                encode_item_variances(self.rbml_w, ecx, item.id);\n+                self.encode_bounds_and_type_for_item(item.id);\n+                encode_name(self.rbml_w, item.name);\n+                encode_attributes(self.rbml_w, &item.attrs);\n+                self.encode_repr_attrs(&item.attrs);\n+                for v in &enum_definition.variants {\n+                    encode_variant_id(self.rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n+                }\n+                encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n+                self.encode_mir(item.id);\n \n-                    // Encode inherent implementations for this enumeration.\n-                    encode_inherent_implementations(ecx, this.rbml_w, def_id);\n+                // Encode inherent implementations for self enumeration.\n+                encode_inherent_implementations(ecx, self.rbml_w, def_id);\n \n-                    this.encode_visibility(vis);\n-                    encode_stability(this.rbml_w, stab);\n-                    encode_deprecation(this.rbml_w, depr);\n-                });\n+                self.encode_visibility(vis);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n             }\n             hir::ItemStruct(ref struct_def, _) => {\n                 /* Index the class*/\n-                self.record(def_id, |this| {\n-                    let def = ecx.tcx.lookup_adt_def(def_id);\n-                    let variant = def.struct_variant();\n-\n-                    /* Now, make an item for the class itself */\n-                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n-                    encode_family(this.rbml_w, match *struct_def {\n-                        hir::VariantData::Struct(..) => 'S',\n-                        hir::VariantData::Tuple(..) => 's',\n-                        hir::VariantData::Unit(..) => 'u',\n-                    });\n-                    this.encode_bounds_and_type_for_item(item.id);\n-\n-                    encode_item_variances(this.rbml_w, ecx, item.id);\n-                    encode_name(this.rbml_w, item.name);\n-                    encode_attributes(this.rbml_w, &item.attrs);\n-                    encode_stability(this.rbml_w, stab);\n-                    encode_deprecation(this.rbml_w, depr);\n-                    this.encode_visibility(vis);\n-                    this.encode_repr_attrs(&item.attrs);\n-\n-                    /* Encode def_ids for each field and method\n-                    for methods, write all the stuff get_trait_method\n-                    needs to know*/\n-                    this.encode_struct_fields(variant);\n-\n-                    encode_inlined_item(ecx, this.rbml_w, InlinedItemRef::Item(def_id, item));\n-                    this.encode_mir(item.id);\n-\n-                    // Encode inherent implementations for this structure.\n-                    encode_inherent_implementations(ecx, this.rbml_w, def_id);\n-\n-                    if !struct_def.is_struct() {\n-                        let ctor_did = ecx.tcx.map.local_def_id(struct_def.id());\n-                        this.rbml_w.wr_tagged_u64(tag_items_data_item_struct_ctor,\n-                                             def_to_u64(ctor_did));\n-                    }\n+                let def = ecx.tcx.lookup_adt_def(def_id);\n+                let variant = def.struct_variant();\n+\n+                /* Now, make an item for the class itself */\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, match *struct_def {\n+                    hir::VariantData::Struct(..) => 'S',\n+                    hir::VariantData::Tuple(..) => 's',\n+                    hir::VariantData::Unit(..) => 'u',\n                 });\n+                self.encode_bounds_and_type_for_item(item.id);\n+\n+                encode_item_variances(self.rbml_w, ecx, item.id);\n+                encode_name(self.rbml_w, item.name);\n+                encode_attributes(self.rbml_w, &item.attrs);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+                self.encode_visibility(vis);\n+                self.encode_repr_attrs(&item.attrs);\n+\n+                /* Encode def_ids for each field and method\n+                for methods, write all the stuff get_trait_method\n+                needs to know*/\n+                self.encode_struct_fields(variant);\n+\n+                encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n+                self.encode_mir(item.id);\n+\n+                // Encode inherent implementations for self structure.\n+                encode_inherent_implementations(ecx, self.rbml_w, def_id);\n+\n+                if !struct_def.is_struct() {\n+                    let ctor_did = ecx.tcx.map.local_def_id(struct_def.id());\n+                    self.rbml_w.wr_tagged_u64(tag_items_data_item_struct_ctor,\n+                                              def_to_u64(ctor_did));\n+                }\n             }\n             hir::ItemDefaultImpl(unsafety, _) => {\n-                self.record(def_id, |this| {\n-                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n-                    encode_family(this.rbml_w, 'd');\n-                    encode_name(this.rbml_w, item.name);\n-                    encode_unsafety(this.rbml_w, unsafety);\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, 'd');\n+                encode_name(self.rbml_w, item.name);\n+                encode_unsafety(self.rbml_w, unsafety);\n \n-                    let trait_ref = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)).unwrap();\n-                    encode_trait_ref(this.rbml_w, ecx, trait_ref, tag_item_trait_ref);\n-                });\n+                let trait_ref = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)).unwrap();\n+                encode_trait_ref(self.rbml_w, ecx, trait_ref, tag_item_trait_ref);\n             }\n             hir::ItemImpl(unsafety, polarity, _, _, _, _) => {\n-                self.record(def_id, |this| {\n-                    // We need to encode information about the default methods we\n-                    // have inherited, so we drive this based on the impl structure.\n-                    let impl_items = tcx.impl_items.borrow();\n-                    let items = &impl_items[&def_id];\n-\n-                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n-                    encode_family(this.rbml_w, 'i');\n-                    this.encode_bounds_and_type_for_item(item.id);\n-                    encode_name(this.rbml_w, item.name);\n-                    encode_attributes(this.rbml_w, &item.attrs);\n-                    encode_unsafety(this.rbml_w, unsafety);\n-                    encode_polarity(this.rbml_w, polarity);\n-\n-                    match\n-                        tcx.custom_coerce_unsized_kinds\n-                           .borrow()\n-                           .get(&ecx.tcx.map.local_def_id(item.id))\n-                    {\n-                        Some(&kind) => {\n-                            this.rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n-                            kind.encode(this.rbml_w);\n-                            this.rbml_w.end_tag();\n-                        }\n-                        None => {}\n+                // We need to encode information about the default methods we\n+                // have inherited, so we drive self based on the impl structure.\n+                let impl_items = tcx.impl_items.borrow();\n+                let items = &impl_items[&def_id];\n+\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, 'i');\n+                self.encode_bounds_and_type_for_item(item.id);\n+                encode_name(self.rbml_w, item.name);\n+                encode_attributes(self.rbml_w, &item.attrs);\n+                encode_unsafety(self.rbml_w, unsafety);\n+                encode_polarity(self.rbml_w, polarity);\n+\n+                match\n+                    tcx.custom_coerce_unsized_kinds\n+                       .borrow()\n+                       .get(&ecx.tcx.map.local_def_id(item.id))\n+                {\n+                    Some(&kind) => {\n+                        self.rbml_w.start_tag(tag_impl_coerce_unsized_kind);\n+                        kind.encode(self.rbml_w);\n+                        self.rbml_w.end_tag();\n                     }\n+                    None => {}\n+                }\n \n-                    for &item_def_id in items {\n-                        this.rbml_w.start_tag(tag_item_impl_item);\n-                        match item_def_id {\n-                            ty::ConstTraitItemId(item_def_id) => {\n-                                encode_def_id(this.rbml_w, item_def_id);\n-                                encode_item_sort(this.rbml_w, 'C');\n-                            }\n-                            ty::MethodTraitItemId(item_def_id) => {\n-                                encode_def_id(this.rbml_w, item_def_id);\n-                                encode_item_sort(this.rbml_w, 'r');\n-                            }\n-                            ty::TypeTraitItemId(item_def_id) => {\n-                                encode_def_id(this.rbml_w, item_def_id);\n-                                encode_item_sort(this.rbml_w, 't');\n-                            }\n+                for &item_def_id in items {\n+                    self.rbml_w.start_tag(tag_item_impl_item);\n+                    match item_def_id {\n+                        ty::ConstTraitItemId(item_def_id) => {\n+                            encode_def_id(self.rbml_w, item_def_id);\n+                            encode_item_sort(self.rbml_w, 'C');\n+                        }\n+                        ty::MethodTraitItemId(item_def_id) => {\n+                            encode_def_id(self.rbml_w, item_def_id);\n+                            encode_item_sort(self.rbml_w, 'r');\n+                        }\n+                        ty::TypeTraitItemId(item_def_id) => {\n+                            encode_def_id(self.rbml_w, item_def_id);\n+                            encode_item_sort(self.rbml_w, 't');\n                         }\n-                        this.rbml_w.end_tag();\n                     }\n+                    self.rbml_w.end_tag();\n+                }\n \n-                    let did = ecx.tcx.map.local_def_id(item.id);\n-                    if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n-                        encode_trait_ref(this.rbml_w, ecx, trait_ref, tag_item_trait_ref);\n-\n-                        let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n-                        let parent = trait_def.ancestors(did)\n-                                              .skip(1)\n-                                              .next()\n-                                              .and_then(|node| match node {\n-                                                  specialization_graph::Node::Impl(parent) =>\n-                                                      Some(parent),\n-                                                  _ => None,\n-                                              });\n-                        encode_parent_impl(this.rbml_w, parent);\n-                    }\n-                    encode_stability(this.rbml_w, stab);\n-                    encode_deprecation(this.rbml_w, depr);\n-                });\n+                let did = ecx.tcx.map.local_def_id(item.id);\n+                if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n+                    encode_trait_ref(self.rbml_w, ecx, trait_ref, tag_item_trait_ref);\n+\n+                    let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n+                    let parent = trait_def.ancestors(did)\n+                                          .skip(1)\n+                                          .next()\n+                                          .and_then(|node| match node {\n+                                              specialization_graph::Node::Impl(parent) =>\n+                                                  Some(parent),\n+                                              _ => None,\n+                                          });\n+                    encode_parent_impl(self.rbml_w, parent);\n+                }\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n             }\n             hir::ItemTrait(_, _, _, _) => {\n-                self.record(def_id, |this| {\n-                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n-                    encode_family(this.rbml_w, 'I');\n-                    encode_item_variances(this.rbml_w, ecx, item.id);\n-                    let trait_def = tcx.lookup_trait_def(def_id);\n-                    let trait_predicates = tcx.lookup_predicates(def_id);\n-                    encode_unsafety(this.rbml_w, trait_def.unsafety);\n-                    encode_paren_sugar(this.rbml_w, trait_def.paren_sugar);\n-                    encode_defaulted(this.rbml_w, tcx.trait_has_default_impl(def_id));\n-                    encode_associated_type_names(this.rbml_w, &trait_def.associated_type_names);\n-                    this.encode_generics(&trait_def.generics, &trait_predicates);\n-                    this.encode_predicates(&tcx.lookup_super_predicates(def_id),\n-                                           tag_item_super_predicates);\n-                    encode_trait_ref(this.rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n-                    encode_name(this.rbml_w, item.name);\n-                    encode_attributes(this.rbml_w, &item.attrs);\n-                    this.encode_visibility(vis);\n-                    encode_stability(this.rbml_w, stab);\n-                    encode_deprecation(this.rbml_w, depr);\n-                    for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n-                        this.rbml_w.start_tag(tag_item_trait_item);\n-                        match method_def_id {\n-                            ty::ConstTraitItemId(const_def_id) => {\n-                                encode_def_id(this.rbml_w, const_def_id);\n-                                encode_item_sort(this.rbml_w, 'C');\n-                            }\n-                            ty::MethodTraitItemId(method_def_id) => {\n-                                encode_def_id(this.rbml_w, method_def_id);\n-                                encode_item_sort(this.rbml_w, 'r');\n-                            }\n-                            ty::TypeTraitItemId(type_def_id) => {\n-                                encode_def_id(this.rbml_w, type_def_id);\n-                                encode_item_sort(this.rbml_w, 't');\n-                            }\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, 'I');\n+                encode_item_variances(self.rbml_w, ecx, item.id);\n+                let trait_def = tcx.lookup_trait_def(def_id);\n+                let trait_predicates = tcx.lookup_predicates(def_id);\n+                encode_unsafety(self.rbml_w, trait_def.unsafety);\n+                encode_paren_sugar(self.rbml_w, trait_def.paren_sugar);\n+                encode_defaulted(self.rbml_w, tcx.trait_has_default_impl(def_id));\n+                encode_associated_type_names(self.rbml_w, &trait_def.associated_type_names);\n+                self.encode_generics(&trait_def.generics, &trait_predicates);\n+                self.encode_predicates(&tcx.lookup_super_predicates(def_id),\n+                                       tag_item_super_predicates);\n+                encode_trait_ref(self.rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n+                encode_name(self.rbml_w, item.name);\n+                encode_attributes(self.rbml_w, &item.attrs);\n+                self.encode_visibility(vis);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+                for &method_def_id in tcx.trait_item_def_ids(def_id).iter() {\n+                    self.rbml_w.start_tag(tag_item_trait_item);\n+                    match method_def_id {\n+                        ty::ConstTraitItemId(const_def_id) => {\n+                            encode_def_id(self.rbml_w, const_def_id);\n+                            encode_item_sort(self.rbml_w, 'C');\n+                        }\n+                        ty::MethodTraitItemId(method_def_id) => {\n+                            encode_def_id(self.rbml_w, method_def_id);\n+                            encode_item_sort(self.rbml_w, 'r');\n+                        }\n+                        ty::TypeTraitItemId(type_def_id) => {\n+                            encode_def_id(self.rbml_w, type_def_id);\n+                            encode_item_sort(self.rbml_w, 't');\n                         }\n-                        this.rbml_w.end_tag();\n-\n-                        this.rbml_w.wr_tagged_u64(tag_mod_child,\n-                                             def_to_u64(method_def_id.def_id()));\n                     }\n+                    self.rbml_w.end_tag();\n \n-                    // Encode inherent implementations for this trait.\n-                    encode_inherent_implementations(ecx, this.rbml_w, def_id);\n-                });\n+                    self.rbml_w.wr_tagged_u64(tag_mod_child,\n+                                              def_to_u64(method_def_id.def_id()));\n+                }\n+\n+                // Encode inherent implementations for self trait.\n+                encode_inherent_implementations(ecx, self.rbml_w, def_id);\n             }\n             hir::ItemExternCrate(_) | hir::ItemUse(_) => {\n-                // these are encoded separately\n+                bug!(\"cannot encode info for item {:?}\", item)\n             }\n         }\n     }\n+}\n \n+impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     /// In some cases, along with the item itself, we also\n     /// encode some sub-items. Usually we want some info from the item\n     /// so it's easier to do that here then to wait until we would encounter\n@@ -1318,7 +1298,11 @@ impl<'a, 'ecx, 'tcx, 'encoder> Visitor<'tcx> for EncodeVisitor<'a, 'ecx, 'tcx, '\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         intravisit::walk_item(self, item);\n-        self.index.encode_info_for_item(item);\n+        let def_id = self.index.ecx.tcx.map.local_def_id(item.id);\n+        match item.node {\n+            hir::ItemExternCrate(_) | hir::ItemUse(_) => (), // ignore these\n+            _ => self.index.record(def_id, |index| index.encode_info_for_item(def_id, item)),\n+        }\n         self.index.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {"}]}