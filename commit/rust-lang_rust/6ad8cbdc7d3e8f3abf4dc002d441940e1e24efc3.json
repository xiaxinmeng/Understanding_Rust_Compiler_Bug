{"sha": "6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZDhjYmRjN2QzZThmM2FiZjRkYzAwMmQ0NDE5NDBlMWUyNGVmYzM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-06-13T14:47:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-13T14:47:45Z"}, "message": "Rollup merge of #73066 - ecstatic-morse:query-structural-eq2, r=pnkfelix\n\nQuerify whether a type has structural equality (Take 2)\n\nAlternative to #72177.\n\nUnlike in #72177, this helper method works for all types, falling back to a query for `TyKind::Adt`s that determines whether the `{Partial,}StructuralEq` traits are implemented.\n\nThis is my preferred interface for this method. I think this is better than just documenting that the helper only works for ADTs. If others disagree, we can just merge #72177 with the fixes applied. This has already taken far too long.", "tree": {"sha": "3834cfd4ee327c14d8af6081635cb551d8447c24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3834cfd4ee327c14d8af6081635cb551d8447c24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe5OcSCRBK7hj4Ov3rIwAAdHIIAJED9208nSak/VvALd7Heman\nk7N4Vbwas1PSRnnLPQwz12XlsUTt1CJE7OxguwqKD/3FOMNF/PTIJOFMBka5SuyJ\n5W/tJzXwSTbNoNbjPPcqj4JadqxijC/OD1566L3tvCEDbkFzpButKqsONAbX3CI7\nWEYwGnbvniEardoqmbafYW8K3y1XQydfT80VCdLtfFd1gd0obf4+tVY5+DCi1fOk\n2pVDRvKUPqNg5WMemTZ7duKRwjxYxKuE9+0qBFWKBR8Fxemc/V6z9fqzL3lg9z04\nCLAW181UGfvzad6tk4lT9XU8JXIAkX3DQFyg0krwrgOsbKJJ4LPK79o/a68dMls=\n=MZ7/\n-----END PGP SIGNATURE-----\n", "payload": "tree 3834cfd4ee327c14d8af6081635cb551d8447c24\nparent 2cc267245dc1df5920190e7b3555a13bfacb11c5\nparent 280176178b1449ce9ba3bc1d2b7ebf3f1d0abb6a\nauthor Dylan DPC <dylan.dpc@gmail.com> 1592059665 +0200\ncommitter GitHub <noreply@github.com> 1592059665 +0200\n\nRollup merge of #73066 - ecstatic-morse:query-structural-eq2, r=pnkfelix\n\nQuerify whether a type has structural equality (Take 2)\n\nAlternative to #72177.\n\nUnlike in #72177, this helper method works for all types, falling back to a query for `TyKind::Adt`s that determines whether the `{Partial,}StructuralEq` traits are implemented.\n\nThis is my preferred interface for this method. I think this is better than just documenting that the helper only works for ADTs. If others disagree, we can just merge #72177 with the fixes applied. This has already taken far too long.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3", "html_url": "https://github.com/rust-lang/rust/commit/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cc267245dc1df5920190e7b3555a13bfacb11c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cc267245dc1df5920190e7b3555a13bfacb11c5", "html_url": "https://github.com/rust-lang/rust/commit/2cc267245dc1df5920190e7b3555a13bfacb11c5"}, {"sha": "280176178b1449ce9ba3bc1d2b7ebf3f1d0abb6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/280176178b1449ce9ba3bc1d2b7ebf3f1d0abb6a", "html_url": "https://github.com/rust-lang/rust/commit/280176178b1449ce9ba3bc1d2b7ebf3f1d0abb6a"}], "stats": {"total": 106, "additions": 86, "deletions": 20}, "files": [{"sha": "be15e6c576f69379f628818b89adda626770167b", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3", "patch": "@@ -789,6 +789,17 @@ rustc_queries! {\n             desc { \"computing whether `{}` needs drop\", env.value }\n         }\n \n+        /// Query backing `TyS::is_structural_eq_shallow`.\n+        ///\n+        /// This is only correct for ADTs. Call `is_structural_eq_shallow` to handle all types\n+        /// correctly.\n+        query has_structural_eq_impls(ty: Ty<'tcx>) -> bool {\n+            desc {\n+                \"computing whether `{:?}` implements `PartialStructuralEq` and `StructuralEq`\",\n+                ty\n+            }\n+        }\n+\n         /// A list of types where the ADT requires drop if and only if any of\n         /// those types require drop. If the ADT is known to always need drop\n         /// then `Err(AlwaysRequiresDrop)` is returned."}, {"sha": "c61e27528cef14f4c604890eb0d3af35a9d9b358", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3", "patch": "@@ -778,6 +778,57 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n     }\n \n+    /// Returns `true` if equality for this type is both reflexive and structural.\n+    ///\n+    /// Reflexive equality for a type is indicated by an `Eq` impl for that type.\n+    ///\n+    /// Primitive types (`u32`, `str`) have structural equality by definition. For composite data\n+    /// types, equality for the type as a whole is structural when it is the same as equality\n+    /// between all components (fields, array elements, etc.) of that type. For ADTs, structural\n+    /// equality is indicated by an implementation of `PartialStructuralEq` and `StructuralEq` for\n+    /// that type.\n+    ///\n+    /// This function is \"shallow\" because it may return `true` for a composite type whose fields\n+    /// are not `StructuralEq`. For example, `[T; 4]` has structural equality regardless of `T`\n+    /// because equality for arrays is determined by the equality of each array element. If you\n+    /// want to know whether a given call to `PartialEq::eq` will proceed structurally all the way\n+    /// down, you will need to use a type visitor.\n+    #[inline]\n+    pub fn is_structural_eq_shallow(&'tcx self, tcx: TyCtxt<'tcx>) -> bool {\n+        match self.kind {\n+            // Look for an impl of both `PartialStructuralEq` and `StructuralEq`.\n+            Adt(..) => tcx.has_structural_eq_impls(self),\n+\n+            // Primitive types that satisfy `Eq`.\n+            Bool | Char | Int(_) | Uint(_) | Str | Never => true,\n+\n+            // Composite types that satisfy `Eq` when all of their fields do.\n+            //\n+            // Because this function is \"shallow\", we return `true` for these composites regardless\n+            // of the type(s) contained within.\n+            Ref(..) | Array(..) | Slice(_) | Tuple(..) => true,\n+\n+            // Raw pointers use bitwise comparison.\n+            RawPtr(_) | FnPtr(_) => true,\n+\n+            // Floating point numbers are not `Eq`.\n+            Float(_) => false,\n+\n+            // Conservatively return `false` for all others...\n+\n+            // Anonymous function types\n+            FnDef(..) | Closure(..) | Dynamic(..) | Generator(..) => false,\n+\n+            // Generic or inferred types\n+            //\n+            // FIXME(ecstaticmorse): Maybe we should `bug` here? This should probably only be\n+            // called for known, fully-monomorphized types.\n+            Projection(_) | Opaque(..) | Param(_) | Bound(..) | Placeholder(_) | Infer(_) => false,\n+\n+            Foreign(_) | GeneratorWitness(..) | Error => false,\n+        }\n+    }\n+\n     pub fn same_type(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         match (&a.kind, &b.kind) {\n             (&Adt(did_a, substs_a), &Adt(did_b, substs_b)) => {"}, {"sha": "936c1a84e142eb9a595c042c016dfe695eac7303", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3", "patch": "@@ -2,7 +2,6 @@\n //!\n //! See the `Qualif` trait for more info.\n \n-use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n@@ -137,10 +136,7 @@ impl Qualif for CustomEq {\n         substs: SubstsRef<'tcx>,\n     ) -> bool {\n         let ty = cx.tcx.mk_ty(ty::Adt(adt, substs));\n-        let id = cx.tcx.hir().local_def_id_to_hir_id(cx.def_id.as_local().unwrap());\n-        cx.tcx\n-            .infer_ctxt()\n-            .enter(|infcx| !traits::type_marked_structural(id, cx.body.span, &infcx, ty))\n+        !ty.is_structural_eq_shallow(cx.tcx)\n     }\n }\n "}, {"sha": "46b687d76e50431e89e1c1c33f43e10bfd769ebc", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     }\n \n     fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {\n-        traits::type_marked_structural(self.id, self.span, &self.infcx, ty)\n+        ty.is_structural_eq_shallow(self.infcx.tcx)\n     }\n \n     fn to_pat("}, {"sha": "9ab87e6b6ca01f35c7f8616aa8ba36feecaee370", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3", "patch": "@@ -60,7 +60,6 @@ pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n pub use self::structural_match::search_for_structural_match_violation;\n-pub use self::structural_match::type_marked_structural;\n pub use self::structural_match::NonStructuralMatchTy;\n pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n@@ -553,6 +552,7 @@ fn type_implements_trait<'tcx>(\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     object_safety::provide(providers);\n+    structural_match::provide(providers);\n     *providers = ty::query::Providers {\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,"}, {"sha": "e59fbd313c8bc0160c25ca022a4de4a02f036df7", "filename": "src/librustc_trait_selection/traits/structural_match.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs?ref=6ad8cbdc7d3e8f3abf4dc002d441940e1e24efc3", "patch": "@@ -1,10 +1,11 @@\n use crate::infer::{InferCtxt, TyCtxtInferExt};\n use crate::traits::ObligationCause;\n-use crate::traits::{self, ConstPatternStructural, TraitEngine};\n+use crate::traits::{self, TraitEngine};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::lang_items::{StructuralPeqTraitLangItem, StructuralTeqTraitLangItem};\n+use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::Span;\n \n@@ -45,14 +46,14 @@ pub enum NonStructuralMatchTy<'tcx> {\n /// that arose when the requirement was not enforced completely, see\n /// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n pub fn search_for_structural_match_violation<'tcx>(\n-    id: hir::HirId,\n+    _id: hir::HirId,\n     span: Span,\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<NonStructuralMatchTy<'tcx>> {\n     // FIXME: we should instead pass in an `infcx` from the outside.\n     tcx.infer_ctxt().enter(|infcx| {\n-        let mut search = Search { id, span, infcx, found: None, seen: FxHashSet::default() };\n+        let mut search = Search { infcx, span, found: None, seen: FxHashSet::default() };\n         ty.visit_with(&mut search);\n         search.found\n     })\n@@ -65,27 +66,26 @@ pub fn search_for_structural_match_violation<'tcx>(\n ///\n /// Note that this does *not* recursively check if the substructure of `adt_ty`\n /// implements the traits.\n-pub fn type_marked_structural(\n-    id: hir::HirId,\n-    span: Span,\n+fn type_marked_structural(\n     infcx: &InferCtxt<'_, 'tcx>,\n     adt_ty: Ty<'tcx>,\n+    cause: ObligationCause<'tcx>,\n ) -> bool {\n     let mut fulfillment_cx = traits::FulfillmentContext::new();\n-    let cause = ObligationCause::new(span, id, ConstPatternStructural);\n     // require `#[derive(PartialEq)]`\n-    let structural_peq_def_id = infcx.tcx.require_lang_item(StructuralPeqTraitLangItem, Some(span));\n+    let structural_peq_def_id =\n+        infcx.tcx.require_lang_item(StructuralPeqTraitLangItem, Some(cause.span));\n     fulfillment_cx.register_bound(\n         infcx,\n         ty::ParamEnv::empty(),\n         adt_ty,\n         structural_peq_def_id,\n-        cause,\n+        cause.clone(),\n     );\n     // for now, require `#[derive(Eq)]`. (Doing so is a hack to work around\n     // the type `for<'a> fn(&'a ())` failing to implement `Eq` itself.)\n-    let cause = ObligationCause::new(span, id, ConstPatternStructural);\n-    let structural_teq_def_id = infcx.tcx.require_lang_item(StructuralTeqTraitLangItem, Some(span));\n+    let structural_teq_def_id =\n+        infcx.tcx.require_lang_item(StructuralTeqTraitLangItem, Some(cause.span));\n     fulfillment_cx.register_bound(\n         infcx,\n         ty::ParamEnv::empty(),\n@@ -110,7 +110,6 @@ pub fn type_marked_structural(\n /// find instances of ADTs (specifically structs or enums) that do not implement\n /// the structural-match traits (`StructuralPartialEq` and `StructuralEq`).\n struct Search<'a, 'tcx> {\n-    id: hir::HirId,\n     span: Span,\n \n     infcx: InferCtxt<'a, 'tcx>,\n@@ -129,7 +128,7 @@ impl Search<'a, 'tcx> {\n     }\n \n     fn type_marked_structural(&self, adt_ty: Ty<'tcx>) -> bool {\n-        type_marked_structural(self.id, self.span, &self.infcx, adt_ty)\n+        adt_ty.is_structural_eq_shallow(self.tcx())\n     }\n }\n \n@@ -266,3 +265,12 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n         false\n     }\n }\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    providers.has_structural_eq_impls = |tcx, ty| {\n+        tcx.infer_ctxt().enter(|infcx| {\n+            let cause = ObligationCause::dummy();\n+            type_marked_structural(&infcx, ty, cause)\n+        })\n+    };\n+}"}]}