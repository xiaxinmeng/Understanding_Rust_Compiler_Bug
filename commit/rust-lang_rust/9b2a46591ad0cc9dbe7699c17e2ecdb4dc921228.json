{"sha": "9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228", "node_id": "C_kwDOAAsO6NoAKDliMmE0NjU5MWFkMGNjOWRiZTc2OTljMTdlMmVjZGI0ZGM5MjEyMjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-25T11:00:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-25T11:00:32Z"}, "message": "Auto merge of #93644 - michaelwoerister:simpler-debuginfo-typemap, r=wesleywiser\n\ndebuginfo: Simplify TypeMap used during LLVM debuginfo generation.\n\nThis PR simplifies the TypeMap that is used in `rustc_codegen_llvm::debuginfo::metadata`. It was unnecessarily complicated because it was originally implemented when types were not yet normalized before codegen. So it did it's own normalization and kept track of multiple unnormalized types being mapped to a single unique id.\n\nThis PR is based on https://github.com/rust-lang/rust/pull/93503, which is not merged yet.\n\nThe PR also removes the arena used for allocating string ids and instead uses `InlinableString` from the [inlinable_string](https://crates.io/crates/inlinable_string) crate. That might not be the best choice, since that crate does not seem to be very actively maintained. The [flexible-string](https://crates.io/crates/flexible-string) crate would be an alternative.\n\nr? `@ghost`", "tree": {"sha": "73a1ad00223528c60ae3e93b2dcb22b0db767d92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73a1ad00223528c60ae3e93b2dcb22b0db767d92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228", "html_url": "https://github.com/rust-lang/rust/commit/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03c8ffaacb040a8753ef8e1accea701bc9f5be85", "url": "https://api.github.com/repos/rust-lang/rust/commits/03c8ffaacb040a8753ef8e1accea701bc9f5be85", "html_url": "https://github.com/rust-lang/rust/commit/03c8ffaacb040a8753ef8e1accea701bc9f5be85"}, {"sha": "bb2059f9591b9ecb02f8ac038e1e9f5771f15f55", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb2059f9591b9ecb02f8ac038e1e9f5771f15f55", "html_url": "https://github.com/rust-lang/rust/commit/bb2059f9591b9ecb02f8ac038e1e9f5771f15f55"}], "stats": {"total": 606, "additions": 254, "deletions": 352}, "files": [{"sha": "cb397821d1c8966b4a5d0df63450a4ba7890a110", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228", "patch": "@@ -3524,6 +3524,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_llvm\",\n+ \"rustc_macros\",\n  \"rustc_metadata\",\n  \"rustc_middle\",\n  \"rustc_query_system\","}, {"sha": "67183ff5887e9a4d5447f764898df5e6762f9803", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228", "patch": "@@ -25,6 +25,7 @@ rustc_fs_util = { path = \"../rustc_fs_util\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_llvm = { path = \"../rustc_llvm\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "89fc89800373714a41cc27bfc39d704226e76b17", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 242, "deletions": 350, "changes": 592, "blob_url": "https://github.com/rust-lang/rust/blob/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228", "patch": "@@ -23,9 +23,7 @@ use cstr::cstr;\n use rustc_codegen_ssa::debuginfo::type_names::cpp_like_debuginfo;\n use rustc_codegen_ssa::debuginfo::type_names::VTableNameKind;\n use rustc_codegen_ssa::traits::*;\n-use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_fs_util::path_to_c_string;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n@@ -37,17 +35,18 @@ use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{\n     self, AdtKind, GeneratorSubsts, Instance, ParamEnv, Ty, TyCtxt, COMMON_VTABLE_ENTRIES,\n };\n-use rustc_query_system::ich::NodeIdHashingMode;\n use rustc_session::config::{self, DebugInfo};\n use rustc_span::symbol::Symbol;\n use rustc_span::FileNameDisplayPreference;\n use rustc_span::{self, SourceFile, SourceFileHash};\n use rustc_target::abi::{Abi, Align, HasDataLayout, Integer, TagEncoding};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{Primitive, Size, VariantIdx, Variants};\n+use smallvec::SmallVec;\n use tracing::debug;\n \n use libc::{c_longlong, c_uint};\n+use std::cell::RefCell;\n use std::collections::hash_map::Entry;\n use std::fmt::{self, Write};\n use std::hash::{Hash, Hasher};\n@@ -95,193 +94,127 @@ pub const UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n pub const NO_SCOPE_METADATA: Option<&DIScope> = None;\n \n mod unique_type_id {\n-    use super::*;\n-    use rustc_arena::DroplessArena;\n-\n-    #[derive(Copy, Hash, Eq, PartialEq, Clone)]\n-    pub(super) struct UniqueTypeId(u32);\n+    use rustc_data_structures::{\n+        fingerprint::Fingerprint,\n+        stable_hasher::{HashStable, NodeIdHashingMode, StableHasher},\n+    };\n+    use rustc_middle::ty::{ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt};\n+    use rustc_target::abi::VariantIdx;\n+\n+    // This type cannot be constructed outside of this module because\n+    // it has a private field. We make use of this in order to prevent\n+    // `UniqueTypeId` from being constructed directly, without asserting\n+    // the preconditions.\n+    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, HashStable)]\n+    pub struct HiddenZst {\n+        _inaccessible: (),\n+    }\n \n-    // The `&'static str`s in this type actually point into the arena.\n-    //\n-    // The `FxHashMap`+`Vec` pair could be replaced by `FxIndexSet`, but #75278\n-    // found that to regress performance up to 2% in some cases. This might be\n-    // revisited after further improvements to `indexmap`.\n-    #[derive(Default)]\n-    pub(super) struct TypeIdInterner {\n-        arena: DroplessArena,\n-        names: FxHashMap<&'static str, UniqueTypeId>,\n-        strings: Vec<&'static str>,\n+    /// A unique identifier for anything that we create a debuginfo node for.\n+    /// The types it contains are expected to already be normalized (which\n+    /// is debug_asserted in the constructors).\n+    ///\n+    /// Note that there are some things that only show up in debuginfo, like\n+    /// the separate type descriptions for each enum variant. These get an ID\n+    /// too because they have their own debuginfo node in LLVM IR.\n+    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, HashStable)]\n+    pub(super) enum UniqueTypeId<'tcx> {\n+        /// The ID of a regular type as it shows up at the language level.\n+        Ty(Ty<'tcx>, HiddenZst),\n+        /// The ID for the artificial struct type describing a single enum variant.\n+        Variant(Ty<'tcx>, VariantIdx, HiddenZst),\n+        /// The ID for the single DW_TAG_variant_part nested inside the top-level\n+        /// DW_TAG_structure_type that describes enums and generators.\n+        VariantPart(Ty<'tcx>, HiddenZst),\n+        /// The ID of the artificial type we create for VTables.\n+        VTableTy(Ty<'tcx>, Option<PolyExistentialTraitRef<'tcx>>, HiddenZst),\n     }\n \n-    impl TypeIdInterner {\n-        #[inline]\n-        pub(super) fn intern(&mut self, string: &str) -> UniqueTypeId {\n-            if let Some(&name) = self.names.get(string) {\n-                return name;\n-            }\n+    impl<'tcx> UniqueTypeId<'tcx> {\n+        pub fn for_ty(tcx: TyCtxt<'tcx>, t: Ty<'tcx>) -> Self {\n+            debug_assert_eq!(t, tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t));\n+            UniqueTypeId::Ty(t, HiddenZst { _inaccessible: () })\n+        }\n+\n+        pub fn for_enum_variant(\n+            tcx: TyCtxt<'tcx>,\n+            enum_ty: Ty<'tcx>,\n+            variant_idx: VariantIdx,\n+        ) -> Self {\n+            debug_assert_eq!(\n+                enum_ty,\n+                tcx.normalize_erasing_regions(ParamEnv::reveal_all(), enum_ty)\n+            );\n+            UniqueTypeId::Variant(enum_ty, variant_idx, HiddenZst { _inaccessible: () })\n+        }\n \n-            let name = UniqueTypeId(self.strings.len() as u32);\n-\n-            // `from_utf8_unchecked` is safe since we just allocated a `&str` which is known to be\n-            // UTF-8.\n-            let string: &str =\n-                unsafe { std::str::from_utf8_unchecked(self.arena.alloc_slice(string.as_bytes())) };\n-            // It is safe to extend the arena allocation to `'static` because we only access\n-            // these while the arena is still alive.\n-            let string: &'static str = unsafe { &*(string as *const str) };\n-            self.strings.push(string);\n-            self.names.insert(string, name);\n-            name\n+        pub fn for_enum_variant_part(tcx: TyCtxt<'tcx>, enum_ty: Ty<'tcx>) -> Self {\n+            debug_assert_eq!(\n+                enum_ty,\n+                tcx.normalize_erasing_regions(ParamEnv::reveal_all(), enum_ty)\n+            );\n+            UniqueTypeId::VariantPart(enum_ty, HiddenZst { _inaccessible: () })\n         }\n \n-        // Get the symbol as a string. `Symbol::as_str()` should be used in\n-        // preference to this function.\n-        pub(super) fn get(&self, symbol: UniqueTypeId) -> &str {\n-            self.strings[symbol.0 as usize]\n+        pub fn for_vtable_ty(\n+            tcx: TyCtxt<'tcx>,\n+            self_type: Ty<'tcx>,\n+            implemented_trait: Option<PolyExistentialTraitRef<'tcx>>,\n+        ) -> Self {\n+            debug_assert_eq!(\n+                self_type,\n+                tcx.normalize_erasing_regions(ParamEnv::reveal_all(), self_type)\n+            );\n+            debug_assert_eq!(\n+                implemented_trait,\n+                tcx.normalize_erasing_regions(ParamEnv::reveal_all(), implemented_trait)\n+            );\n+            UniqueTypeId::VTableTy(self_type, implemented_trait, HiddenZst { _inaccessible: () })\n+        }\n+\n+        /// Generates a string version of this [UniqueTypeId], which can be used as the `UniqueId`\n+        /// argument of the various `LLVMRustDIBuilderCreate*Type()` methods.\n+        ///\n+        /// Right now this takes the form of a hex-encoded opaque hash value.\n+        pub fn generate_unique_id_string(&self, tcx: TyCtxt<'tcx>) -> String {\n+            let mut hasher = StableHasher::new();\n+            let mut hcx = tcx.create_stable_hashing_context();\n+            hcx.while_hashing_spans(false, |hcx| {\n+                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+                    self.hash_stable(hcx, &mut hasher);\n+                });\n+            });\n+            hasher.finish::<Fingerprint>().to_hex()\n         }\n     }\n }\n use unique_type_id::*;\n \n-/// The `TypeMap` is where the `CrateDebugContext` holds the type metadata nodes\n-/// created so far. The metadata nodes are indexed by `UniqueTypeId`, and, for\n-/// faster lookup, also by `Ty`. The `TypeMap` is responsible for creating\n-/// `UniqueTypeId`s.\n+/// The `TypeMap` is where the debug context holds the type metadata nodes\n+/// created so far. The metadata nodes are indexed by `UniqueTypeId`.\n #[derive(Default)]\n pub struct TypeMap<'ll, 'tcx> {\n-    /// The `UniqueTypeId`s created so far.\n-    unique_id_interner: TypeIdInterner,\n-    /// A map from `UniqueTypeId` to debuginfo metadata for that type. This is a 1:1 mapping.\n-    unique_id_to_metadata: FxHashMap<UniqueTypeId, &'ll DIType>,\n-    /// A map from types to debuginfo metadata. This is an N:1 mapping.\n-    type_to_metadata: FxHashMap<Ty<'tcx>, &'ll DIType>,\n-    /// A map from types to `UniqueTypeId`. This is an N:1 mapping.\n-    type_to_unique_id: FxHashMap<Ty<'tcx>, UniqueTypeId>,\n+    unique_id_to_metadata: RefCell<FxHashMap<UniqueTypeId<'tcx>, &'ll DIType>>,\n }\n \n impl<'ll, 'tcx> TypeMap<'ll, 'tcx> {\n-    /// Adds a Ty to metadata mapping to the TypeMap. The method will fail if\n-    /// the mapping already exists.\n-    fn register_type_with_metadata(&mut self, type_: Ty<'tcx>, metadata: &'ll DIType) {\n-        if self.type_to_metadata.insert(type_, metadata).is_some() {\n-            bug!(\"type metadata for `Ty` '{}' is already in the `TypeMap`!\", type_);\n-        }\n-    }\n-\n-    /// Removes a `Ty`-to-metadata mapping.\n-    /// This is useful when computing the metadata for a potentially\n-    /// recursive type (e.g., a function pointer of the form:\n-    ///\n-    ///     fn foo() -> impl Copy { foo }\n-    ///\n-    /// This kind of type cannot be properly represented\n-    /// via LLVM debuginfo. As a workaround,\n-    /// we register a temporary Ty to metadata mapping\n-    /// for the function before we compute its actual metadata.\n-    /// If the metadata computation ends up recursing back to the\n-    /// original function, it will use the temporary mapping\n-    /// for the inner self-reference, preventing us from\n-    /// recursing forever.\n-    ///\n-    /// This function is used to remove the temporary metadata\n-    /// mapping after we've computed the actual metadata.\n-    fn remove_type(&mut self, ty: Ty<'tcx>) {\n-        if self.type_to_metadata.remove(&ty).is_none() {\n-            bug!(\"type metadata `Ty` '{}' is not in the `TypeMap`!\", ty);\n-        }\n-    }\n-\n     /// Adds a `UniqueTypeId` to metadata mapping to the `TypeMap`. The method will\n     /// fail if the mapping already exists.\n     fn register_unique_id_with_metadata(\n-        &mut self,\n-        unique_type_id: UniqueTypeId,\n+        &self,\n+        unique_type_id: UniqueTypeId<'tcx>,\n         metadata: &'ll DIType,\n     ) {\n-        if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n-            bug!(\n-                \"type metadata for unique ID '{}' is already in the `TypeMap`!\",\n-                self.get_unique_type_id_as_string(unique_type_id)\n-            );\n+        if self.unique_id_to_metadata.borrow_mut().insert(unique_type_id, metadata).is_some() {\n+            bug!(\"type metadata for unique ID '{:?}' is already in the `TypeMap`!\", unique_type_id);\n         }\n     }\n \n-    fn find_metadata_for_type(&self, type_: Ty<'tcx>) -> Option<&'ll DIType> {\n-        self.type_to_metadata.get(&type_).cloned()\n-    }\n-\n-    fn find_metadata_for_unique_id(&self, unique_type_id: UniqueTypeId) -> Option<&'ll DIType> {\n-        self.unique_id_to_metadata.get(&unique_type_id).cloned()\n-    }\n-\n-    /// Gets the string representation of a `UniqueTypeId`. This method will fail if\n-    /// the ID is unknown.\n-    fn get_unique_type_id_as_string(&self, unique_type_id: UniqueTypeId) -> &str {\n-        self.unique_id_interner.get(unique_type_id)\n-    }\n-\n-    /// Gets the `UniqueTypeId` for the given type. If the `UniqueTypeId` for the given\n-    /// type has been requested before, this is just a table lookup. Otherwise, an\n-    /// ID will be generated and stored for later lookup.\n-    fn get_unique_type_id_of_type<'a>(\n-        &mut self,\n-        cx: &CodegenCx<'a, 'tcx>,\n-        type_: Ty<'tcx>,\n-    ) -> UniqueTypeId {\n-        // Let's see if we already have something in the cache.\n-        if let Some(unique_type_id) = self.type_to_unique_id.get(&type_).cloned() {\n-            return unique_type_id;\n-        }\n-        // If not, generate one.\n-\n-        // The hasher we are using to generate the UniqueTypeId. We want\n-        // something that provides more than the 64 bits of the DefaultHasher.\n-        let mut hasher = StableHasher::new();\n-        let mut hcx = cx.tcx.create_stable_hashing_context();\n-        let type_ = cx.tcx.erase_regions(type_);\n-        hcx.while_hashing_spans(false, |hcx| {\n-            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                type_.hash_stable(hcx, &mut hasher);\n-            });\n-        });\n-        let unique_type_id = hasher.finish::<Fingerprint>().to_hex();\n-\n-        let key = self.unique_id_interner.intern(&unique_type_id);\n-        self.type_to_unique_id.insert(type_, key);\n-\n-        key\n-    }\n-\n-    /// Gets the `UniqueTypeId` for an enum variant. Enum variants are not really\n-    /// types of their own, so they need special handling. We still need a\n-    /// `UniqueTypeId` for them, since to debuginfo they *are* real types.\n-    fn get_unique_type_id_of_enum_variant<'a>(\n-        &mut self,\n-        cx: &CodegenCx<'a, 'tcx>,\n-        enum_type: Ty<'tcx>,\n-        variant_name: &str,\n-    ) -> UniqueTypeId {\n-        let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n-        let enum_variant_type_id =\n-            format!(\"{}::{}\", self.get_unique_type_id_as_string(enum_type_id), variant_name);\n-        let interner_key = self.unique_id_interner.intern(&enum_variant_type_id);\n-        interner_key\n-    }\n-\n-    /// Gets the unique type ID string for an enum variant part.\n-    /// Variant parts are not types and shouldn't really have their own ID,\n-    /// but it makes `set_members_of_composite_type()` simpler.\n-    fn get_unique_type_id_str_of_enum_variant_part(\n-        &mut self,\n-        enum_type_id: UniqueTypeId,\n-    ) -> String {\n-        format!(\"{}_variant_part\", self.get_unique_type_id_as_string(enum_type_id))\n-    }\n-\n-    /// Gets the `UniqueTypeId` for the type of a vtable.\n-    fn get_unique_type_id_of_vtable_type(&mut self, vtable_type_name: &str) -> UniqueTypeId {\n-        let interner_key = self.unique_id_interner.intern(vtable_type_name);\n-        interner_key\n+    fn find_metadata_for_unique_id(\n+        &self,\n+        unique_type_id: UniqueTypeId<'tcx>,\n+    ) -> Option<&'ll DIType> {\n+        self.unique_id_to_metadata.borrow().get(&unique_type_id).cloned()\n     }\n }\n \n@@ -293,7 +226,7 @@ impl<'ll, 'tcx> TypeMap<'ll, 'tcx> {\n enum RecursiveTypeDescription<'ll, 'tcx> {\n     UnfinishedMetadata {\n         unfinished_type: Ty<'tcx>,\n-        unique_type_id: UniqueTypeId,\n+        unique_type_id: UniqueTypeId<'tcx>,\n         metadata_stub: &'ll DICompositeType,\n         member_holding_stub: &'ll DICompositeType,\n         member_description_factory: MemberDescriptionFactory<'ll, 'tcx>,\n@@ -304,15 +237,13 @@ enum RecursiveTypeDescription<'ll, 'tcx> {\n fn create_and_register_recursive_type_forward_declaration<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     unfinished_type: Ty<'tcx>,\n-    unique_type_id: UniqueTypeId,\n+    unique_type_id: UniqueTypeId<'tcx>,\n     metadata_stub: &'ll DICompositeType,\n     member_holding_stub: &'ll DICompositeType,\n     member_description_factory: MemberDescriptionFactory<'ll, 'tcx>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     // Insert the stub into the `TypeMap` in order to allow for recursive references.\n-    let mut type_map = debug_context(cx).type_map.borrow_mut();\n-    type_map.register_unique_id_with_metadata(unique_type_id, metadata_stub);\n-    type_map.register_type_with_metadata(unfinished_type, metadata_stub);\n+    debug_context(cx).type_map.register_unique_id_with_metadata(unique_type_id, metadata_stub);\n \n     UnfinishedMetadata {\n         unfinished_type,\n@@ -344,9 +275,10 @@ impl<'ll, 'tcx> RecursiveTypeDescription<'ll, 'tcx> {\n                 // `create_and_register_recursive_type_forward_declaration()`\n                 // function.\n                 {\n-                    let type_map = debug_context(cx).type_map.borrow();\n-                    if type_map.find_metadata_for_unique_id(unique_type_id).is_none()\n-                        || type_map.find_metadata_for_type(unfinished_type).is_none()\n+                    if debug_context(cx)\n+                        .type_map\n+                        .find_metadata_for_unique_id(unique_type_id)\n+                        .is_none()\n                     {\n                         bug!(\n                             \"Forward declaration of potentially recursive type \\\n@@ -379,7 +311,7 @@ impl<'ll, 'tcx> RecursiveTypeDescription<'ll, 'tcx> {\n macro_rules! return_if_metadata_created_in_meantime {\n     ($cx: expr, $unique_type_id: expr) => {\n         if let Some(metadata) =\n-            debug_context($cx).type_map.borrow().find_metadata_for_unique_id($unique_type_id)\n+            debug_context($cx).type_map.find_metadata_for_unique_id($unique_type_id)\n         {\n             return MetadataCreationResult::new(metadata, true);\n         }\n@@ -390,7 +322,7 @@ macro_rules! return_if_metadata_created_in_meantime {\n /// For slices (that is, \"arrays\" of unknown size) use [slice_type_metadata].\n fn fixed_size_array_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n-    unique_type_id: UniqueTypeId,\n+    unique_type_id: UniqueTypeId<'tcx>,\n     array_type: Ty<'tcx>,\n ) -> MetadataCreationResult<'ll> {\n     let ty::Array(element_type, len) = array_type.kind() else {\n@@ -434,7 +366,7 @@ fn pointer_or_reference_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     ptr_type: Ty<'tcx>,\n     pointee_type: Ty<'tcx>,\n-    unique_type_id: UniqueTypeId,\n+    unique_type_id: UniqueTypeId<'tcx>,\n ) -> MetadataCreationResult<'ll> {\n     let pointee_type_metadata = type_metadata(cx, pointee_type);\n \n@@ -534,16 +466,42 @@ fn pointer_or_reference_metadata<'ll, 'tcx>(\n \n fn subroutine_type_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n-    unique_type_id: UniqueTypeId,\n-    signature: ty::PolyFnSig<'tcx>,\n+    unique_type_id: UniqueTypeId<'tcx>,\n ) -> MetadataCreationResult<'ll> {\n-    let signature =\n-        cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), signature);\n+    // It's possible to create a self-referential\n+    // type in Rust by using 'impl trait':\n+    //\n+    // fn foo() -> impl Copy { foo }\n+    //\n+    // Unfortunately LLVM's API does not allow us to create recursive subroutine types.\n+    // In order to work around that restriction we place a marker type in the type map,\n+    // before creating the actual type. If the actual type is recursive, it will hit the\n+    // marker type. So we end up with a type that looks like\n+    //\n+    // fn foo() -> <recursive_type>\n+    //\n+    // Once that is created, we replace the marker in the typemap with the actual type.\n+    debug_context(cx)\n+        .type_map\n+        .unique_id_to_metadata\n+        .borrow_mut()\n+        .insert(unique_type_id, recursion_marker_type(cx));\n+\n+    let UniqueTypeId::Ty(fn_ty, _) = unique_type_id else {\n+        bug!(\"subroutine_type_metadata() called with unexpected input type: {:?}\", unique_type_id)\n+    };\n \n-    let signature_metadata: Vec<_> = iter::once(\n+    let signature = cx\n+        .tcx\n+        .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), fn_ty.fn_sig(cx.tcx));\n+\n+    let signature_metadata: SmallVec<[_; 32]> = iter::once(\n         // return type\n         match signature.output().kind() {\n-            ty::Tuple(tys) if tys.is_empty() => None,\n+            ty::Tuple(tys) if tys.is_empty() => {\n+                // this is a \"void\" function\n+                None\n+            }\n             _ => Some(type_metadata(cx, signature.output())),\n         },\n     )\n@@ -553,25 +511,38 @@ fn subroutine_type_metadata<'ll, 'tcx>(\n     )\n     .collect();\n \n-    return_if_metadata_created_in_meantime!(cx, unique_type_id);\n+    debug_context(cx).type_map.unique_id_to_metadata.borrow_mut().remove(&unique_type_id);\n \n-    MetadataCreationResult::new(\n-        unsafe {\n-            llvm::LLVMRustDIBuilderCreateSubroutineType(\n-                DIB(cx),\n-                create_DIArray(DIB(cx), &signature_metadata[..]),\n-            )\n-        },\n-        false,\n-    )\n+    let fn_metadata = unsafe {\n+        llvm::LLVMRustDIBuilderCreateSubroutineType(\n+            DIB(cx),\n+            create_DIArray(DIB(cx), &signature_metadata[..]),\n+        )\n+    };\n+\n+    // This is actually a function pointer, so wrap it in pointer DI.\n+    let name = compute_debuginfo_type_name(cx.tcx, fn_ty, false);\n+    let metadata = unsafe {\n+        llvm::LLVMRustDIBuilderCreatePointerType(\n+            DIB(cx),\n+            fn_metadata,\n+            cx.tcx.data_layout.pointer_size.bits(),\n+            cx.tcx.data_layout.pointer_align.abi.bits() as u32,\n+            0, // Ignore DWARF address space.\n+            name.as_ptr().cast(),\n+            name.len(),\n+        )\n+    };\n+\n+    MetadataCreationResult::new(metadata, false)\n }\n \n /// Create debuginfo for `dyn SomeTrait` types. Currently these are empty structs\n /// we with the correct type name (e.g. \"dyn SomeTrait<Foo, Item=u32> + Sync\").\n fn dyn_type_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     dyn_type: Ty<'tcx>,\n-    unique_type_id: UniqueTypeId,\n+    unique_type_id: UniqueTypeId<'tcx>,\n ) -> &'ll DIType {\n     if let ty::Dynamic(..) = dyn_type.kind() {\n         let type_name = compute_debuginfo_type_name(cx.tcx, dyn_type, true);\n@@ -601,7 +572,7 @@ fn dyn_type_metadata<'ll, 'tcx>(\n fn slice_type_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     slice_type: Ty<'tcx>,\n-    unique_type_id: UniqueTypeId,\n+    unique_type_id: UniqueTypeId<'tcx>,\n ) -> MetadataCreationResult<'ll> {\n     let element_type = match slice_type.kind() {\n         ty::Slice(element_type) => *element_type,\n@@ -620,38 +591,11 @@ fn slice_type_metadata<'ll, 'tcx>(\n }\n \n pub fn type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n-    // Get the unique type ID of this type.\n-    let unique_type_id = {\n-        let mut type_map = debug_context(cx).type_map.borrow_mut();\n-        // First, try to find the type in `TypeMap`. If we have seen it before, we\n-        // can exit early here.\n-        match type_map.find_metadata_for_type(t) {\n-            Some(metadata) => {\n-                return metadata;\n-            }\n-            None => {\n-                // The Ty is not in the `TypeMap` but maybe we have already seen\n-                // an equivalent type (e.g., only differing in region arguments).\n-                // In order to find out, generate the unique type ID and look\n-                // that up.\n-                let unique_type_id = type_map.get_unique_type_id_of_type(cx, t);\n-                match type_map.find_metadata_for_unique_id(unique_type_id) {\n-                    Some(metadata) => {\n-                        // There is already an equivalent type in the TypeMap.\n-                        // Register this Ty as an alias in the cache and\n-                        // return the cached metadata.\n-                        type_map.register_type_with_metadata(t, metadata);\n-                        return metadata;\n-                    }\n-                    None => {\n-                        // There really is no type metadata for this type, so\n-                        // proceed by creating it.\n-                        unique_type_id\n-                    }\n-                }\n-            }\n-        }\n-    };\n+    let unique_type_id = UniqueTypeId::for_ty(cx.tcx, t);\n+\n+    if let Some(metadata) = debug_context(cx).type_map.find_metadata_for_unique_id(unique_type_id) {\n+        return metadata;\n+    }\n \n     debug!(\"type_metadata: {:?}\", t);\n \n@@ -676,64 +620,7 @@ pub fn type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll\n         ty::Adt(def, _) if def.is_box() => {\n             pointer_or_reference_metadata(cx, t, t.boxed_ty(), unique_type_id)\n         }\n-        ty::FnDef(..) | ty::FnPtr(_) => {\n-            if let Some(metadata) =\n-                debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id)\n-            {\n-                return metadata;\n-            }\n-\n-            // It's possible to create a self-referential\n-            // type in Rust by using 'impl trait':\n-            //\n-            // fn foo() -> impl Copy { foo }\n-            //\n-            // See `TypeMap::remove_type` for more detals\n-            // about the workaround.\n-\n-            let temp_type = {\n-                unsafe {\n-                    // The choice of type here is pretty arbitrary -\n-                    // anything reading the debuginfo for a recursive\n-                    // type is going to see *something* weird - the only\n-                    // question is what exactly it will see.\n-                    let name = \"<recur_type>\";\n-                    llvm::LLVMRustDIBuilderCreateBasicType(\n-                        DIB(cx),\n-                        name.as_ptr().cast(),\n-                        name.len(),\n-                        cx.size_of(t).bits(),\n-                        DW_ATE_unsigned,\n-                    )\n-                }\n-            };\n-\n-            let type_map = &debug_context(cx).type_map;\n-            type_map.borrow_mut().register_type_with_metadata(t, temp_type);\n-\n-            let fn_metadata =\n-                subroutine_type_metadata(cx, unique_type_id, t.fn_sig(cx.tcx)).metadata;\n-\n-            type_map.borrow_mut().remove_type(t);\n-\n-            // This is actually a function pointer, so wrap it in pointer DI.\n-            let (pointer_size, pointer_align) =\n-                cx.size_and_align_of(cx.tcx.mk_imm_ptr(cx.tcx.mk_unit()));\n-            let name = compute_debuginfo_type_name(cx.tcx, t, false);\n-            let md = unsafe {\n-                llvm::LLVMRustDIBuilderCreatePointerType(\n-                    DIB(cx),\n-                    fn_metadata,\n-                    pointer_size.bits(),\n-                    pointer_align.bits() as u32,\n-                    0, // Ignore DWARF address space.\n-                    name.as_ptr().cast(),\n-                    name.len(),\n-                )\n-            };\n-\n-            MetadataCreationResult::new(md, false)\n-        }\n+        ty::FnDef(..) | ty::FnPtr(_) => subroutine_type_metadata(cx, unique_type_id),\n         ty::Closure(def_id, substs) => {\n             let upvar_tys: Vec<_> = substs.as_closure().upvar_tys().collect();\n             let containing_scope = get_namespace_for_item(cx, def_id);\n@@ -764,47 +651,56 @@ pub fn type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll\n     };\n \n     {\n-        let mut type_map = debug_context(cx).type_map.borrow_mut();\n-\n         if already_stored_in_typemap {\n-            // Also make sure that we already have a `TypeMap` entry for the unique type ID.\n-            let Some(metadata_for_uid) = type_map.find_metadata_for_unique_id(unique_type_id) else {\n-                bug!(\n-                    \"expected type metadata for unique \\\n-                            type ID '{}' to already be in \\\n-                            the `debuginfo::TypeMap` but it \\\n-                            was not. (Ty = {})\",\n-                    type_map.get_unique_type_id_as_string(unique_type_id),\n-                    t\n-                );\n-            };\n-\n-            match type_map.find_metadata_for_type(t) {\n-                Some(metadata) => {\n-                    if metadata != metadata_for_uid {\n+            // Make sure that we really do have a `TypeMap` entry for the unique type ID.\n+            let metadata_for_uid =\n+                match debug_context(cx).type_map.find_metadata_for_unique_id(unique_type_id) {\n+                    Some(metadata) => metadata,\n+                    None => {\n                         bug!(\n-                            \"mismatch between `Ty` and \\\n-                                   `UniqueTypeId` maps in \\\n-                                   `debuginfo::TypeMap`. \\\n-                                   UniqueTypeId={}, Ty={}\",\n-                            type_map.get_unique_type_id_as_string(unique_type_id),\n-                            t\n+                            \"expected type metadata for unique \\\n+                               type ID '{:?}' to already be in \\\n+                               the `debuginfo::TypeMap` but it \\\n+                               was not.\",\n+                            unique_type_id,\n                         );\n                     }\n-                }\n-                None => {\n-                    type_map.register_type_with_metadata(t, metadata);\n-                }\n-            }\n+                };\n+\n+            debug_assert_eq!(metadata_for_uid as *const _, metadata as *const _);\n         } else {\n-            type_map.register_type_with_metadata(t, metadata);\n-            type_map.register_unique_id_with_metadata(unique_type_id, metadata);\n+            debug_context(cx).type_map.register_unique_id_with_metadata(unique_type_id, metadata);\n         }\n     }\n \n     metadata\n }\n \n+fn recursion_marker_type<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) -> &'ll DIType {\n+    *debug_context(cx).recursion_marker_type.get_or_init(move || {\n+        unsafe {\n+            // The choice of type here is pretty arbitrary -\n+            // anything reading the debuginfo for a recursive\n+            // type is going to see *something* weird - the only\n+            // question is what exactly it will see.\n+            //\n+            // FIXME: the name `<recur_type>` does not fit the naming scheme\n+            //        of other types.\n+            //\n+            // FIXME: it might make sense to use an actual pointer type here\n+            //        so that debuggers can show the address.\n+            let name = \"<recur_type>\";\n+            llvm::LLVMRustDIBuilderCreateBasicType(\n+                DIB(cx),\n+                name.as_ptr().cast(),\n+                name.len(),\n+                cx.tcx.data_layout.pointer_size.bits(),\n+                DW_ATE_unsigned,\n+            )\n+        }\n+    })\n+}\n+\n fn hex_encode(data: &[u8]) -> String {\n     let mut hex_string = String::with_capacity(data.len() * 2);\n     for byte in data.iter() {\n@@ -985,7 +881,7 @@ fn basic_type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'l\n fn foreign_type_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     t: Ty<'tcx>,\n-    unique_type_id: UniqueTypeId,\n+    unique_type_id: UniqueTypeId<'tcx>,\n ) -> &'ll DIType {\n     debug!(\"foreign_type_metadata: {:?}\", t);\n \n@@ -1306,7 +1202,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n fn prepare_struct_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     struct_type: Ty<'tcx>,\n-    unique_type_id: UniqueTypeId,\n+    unique_type_id: UniqueTypeId<'tcx>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let struct_name = compute_debuginfo_type_name(cx.tcx, struct_type, false);\n \n@@ -1415,7 +1311,7 @@ fn prepare_tuple_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     tuple_type: Ty<'tcx>,\n     component_types: &[Ty<'tcx>],\n-    unique_type_id: UniqueTypeId,\n+    unique_type_id: UniqueTypeId<'tcx>,\n     containing_scope: Option<&'ll DIScope>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let (size, align) = cx.size_and_align_of(tuple_type);\n@@ -1483,7 +1379,7 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n fn prepare_union_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     union_type: Ty<'tcx>,\n-    unique_type_id: UniqueTypeId,\n+    unique_type_id: UniqueTypeId<'tcx>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let union_name = compute_debuginfo_type_name(cx.tcx, union_type, false);\n \n@@ -1570,7 +1466,7 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n         };\n \n         let variant_info_for = |index: VariantIdx| match *self.enum_type.kind() {\n-            ty::Adt(adt, _) => VariantInfo::Adt(&adt.variants[index]),\n+            ty::Adt(adt, _) => VariantInfo::Adt(&adt.variants[index], index),\n             ty::Generator(def_id, _, _) => {\n                 let (generator_layout, generator_saved_local_names) =\n                     generator_variant_info_data.as_ref().unwrap();\n@@ -1913,7 +1809,7 @@ impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n \n #[derive(Copy, Clone)]\n enum VariantInfo<'a, 'tcx> {\n-    Adt(&'tcx ty::VariantDef),\n+    Adt(&'tcx ty::VariantDef, VariantIdx),\n     Generator {\n         def_id: DefId,\n         generator_layout: &'tcx GeneratorLayout<'tcx>,\n@@ -1923,9 +1819,17 @@ enum VariantInfo<'a, 'tcx> {\n }\n \n impl<'tcx> VariantInfo<'_, 'tcx> {\n+    fn variant_idx(&self) -> VariantIdx {\n+        match self {\n+            VariantInfo::Adt(_, variant_index) | VariantInfo::Generator { variant_index, .. } => {\n+                *variant_index\n+            }\n+        }\n+    }\n+\n     fn map_struct_name<R>(&self, f: impl FnOnce(&str) -> R) -> R {\n         match self {\n-            VariantInfo::Adt(variant) => f(variant.name.as_str()),\n+            VariantInfo::Adt(variant, _) => f(variant.name.as_str()),\n             VariantInfo::Generator { variant_index, .. } => {\n                 f(&GeneratorSubsts::variant_name(*variant_index))\n             }\n@@ -1934,7 +1838,7 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n \n     fn variant_name(&self) -> String {\n         match self {\n-            VariantInfo::Adt(variant) => variant.name.to_string(),\n+            VariantInfo::Adt(variant, _) => variant.name.to_string(),\n             VariantInfo::Generator { variant_index, .. } => {\n                 // Since GDB currently prints out the raw discriminant along\n                 // with every variant, make each variant name be just the value\n@@ -1947,7 +1851,7 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n \n     fn field_name(&self, i: usize) -> String {\n         let field_name = match *self {\n-            VariantInfo::Adt(variant) if variant.ctor_kind != CtorKind::Fn => {\n+            VariantInfo::Adt(variant, _) if variant.ctor_kind != CtorKind::Fn => {\n                 Some(variant.fields[i].name)\n             }\n             VariantInfo::Generator {\n@@ -1988,10 +1892,8 @@ fn describe_enum_variant<'ll, 'tcx>(\n     containing_scope: &'ll DIScope,\n ) -> (&'ll DICompositeType, MemberDescriptionFactory<'ll, 'tcx>) {\n     let metadata_stub = variant.map_struct_name(|variant_name| {\n-        let unique_type_id = debug_context(cx)\n-            .type_map\n-            .borrow_mut()\n-            .get_unique_type_id_of_enum_variant(cx, layout.ty, variant_name);\n+        let unique_type_id =\n+            UniqueTypeId::for_enum_variant(cx.tcx, layout.ty, variant.variant_idx());\n \n         let (size, align) = cx.size_and_align_of(layout.ty);\n \n@@ -2021,7 +1923,7 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     enum_type: Ty<'tcx>,\n     enum_def_id: DefId,\n-    unique_type_id: UniqueTypeId,\n+    unique_type_id: UniqueTypeId<'tcx>,\n     outer_field_tys: Vec<Ty<'tcx>>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let tcx = cx.tcx;\n@@ -2145,8 +2047,7 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n         };\n \n         let enum_metadata = {\n-            let type_map = debug_context(cx).type_map.borrow();\n-            let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n+            let unique_type_id_str = unique_type_id.generate_unique_id_string(tcx);\n \n             unsafe {\n                 llvm::LLVMRustDIBuilderCreateUnionType(\n@@ -2257,10 +2158,9 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n         }\n     };\n \n-    let variant_part_unique_type_id_str = debug_context(cx)\n-        .type_map\n-        .borrow_mut()\n-        .get_unique_type_id_str_of_enum_variant_part(unique_type_id);\n+    let variant_part_unique_type_id_str =\n+        UniqueTypeId::for_enum_variant_part(tcx, enum_type).generate_unique_id_string(tcx);\n+\n     let empty_array = create_DIArray(DIB(cx), &[]);\n     let name = \"\";\n     let variant_part = unsafe {\n@@ -2288,9 +2188,7 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n         // an equivalent layout but offers us much better integration with\n         // debuggers.\n         let type_array = create_DIArray(DIB(cx), &[Some(variant_part)]);\n-\n-        let type_map = debug_context(cx).type_map.borrow();\n-        let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n+        let unique_type_id_str = unique_type_id.generate_unique_id_string(tcx);\n \n         unsafe {\n             llvm::LLVMRustDIBuilderCreateStructType(\n@@ -2336,7 +2234,7 @@ fn composite_type_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     composite_type: Ty<'tcx>,\n     composite_type_name: &str,\n-    composite_type_unique_id: UniqueTypeId,\n+    composite_type_unique_id: UniqueTypeId<'tcx>,\n     member_descriptions: Vec<MemberDescription<'ll>>,\n     containing_scope: Option<&'ll DIScope>,\n ) -> &'ll DICompositeType {\n@@ -2459,13 +2357,12 @@ fn create_struct_stub<'ll, 'tcx>(\n     size: Size,\n     align: Align,\n     type_name: &str,\n-    unique_type_id: UniqueTypeId,\n+    unique_type_id: UniqueTypeId<'tcx>,\n     containing_scope: Option<&'ll DIScope>,\n     flags: DIFlags,\n     vtable_holder: Option<&'ll DIType>,\n ) -> &'ll DICompositeType {\n-    let type_map = debug_context(cx).type_map.borrow();\n-    let unique_type_id = type_map.get_unique_type_id_as_string(unique_type_id);\n+    let unique_type_id = unique_type_id.generate_unique_id_string(cx.tcx);\n \n     let metadata_stub = unsafe {\n         // `LLVMRustDIBuilderCreateStructType()` wants an empty array. A null\n@@ -2499,13 +2396,11 @@ fn create_union_stub<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     union_type: Ty<'tcx>,\n     union_type_name: &str,\n-    unique_type_id: UniqueTypeId,\n+    unique_type_id: UniqueTypeId<'tcx>,\n     containing_scope: &'ll DIScope,\n ) -> &'ll DICompositeType {\n     let (union_size, union_align) = cx.size_and_align_of(union_type);\n-\n-    let type_map = debug_context(cx).type_map.borrow();\n-    let unique_type_id = type_map.get_unique_type_id_as_string(unique_type_id);\n+    let unique_type_id = unique_type_id.generate_unique_id_string(cx.tcx);\n \n     let metadata_stub = unsafe {\n         // `LLVMRustDIBuilderCreateUnionType()` wants an empty array. A null\n@@ -2629,10 +2524,7 @@ fn vtable_type_metadata<'ll, 'tcx>(\n \n     let vtable_type_name =\n         compute_debuginfo_vtable_name(cx.tcx, ty, poly_trait_ref, VTableNameKind::Type);\n-    let unique_type_id = debug_context(cx)\n-        .type_map\n-        .borrow_mut()\n-        .get_unique_type_id_of_vtable_type(&vtable_type_name);\n+    let unique_type_id = UniqueTypeId::for_vtable_ty(tcx, ty, poly_trait_ref);\n     let size = pointer_size * vtable_entries.len() as u64;\n \n     // This gets mapped to a DW_AT_containing_type attribute which allows GDB to correlate"}, {"sha": "1b4a193dbf1852d8cb193dc3c75272808215889e", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228", "patch": "@@ -38,6 +38,7 @@ use libc::c_uint;\n use smallvec::SmallVec;\n use std::cell::RefCell;\n use std::iter;\n+use std::lazy::OnceCell;\n use tracing::debug;\n \n mod create_scope_map;\n@@ -63,9 +64,11 @@ pub struct CrateDebugContext<'a, 'tcx> {\n     created_files: RefCell<FxHashMap<(Option<String>, Option<String>), &'a DIFile>>,\n     created_enum_disr_types: RefCell<FxHashMap<(DefId, Primitive), &'a DIType>>,\n \n-    type_map: RefCell<TypeMap<'a, 'tcx>>,\n+    type_map: TypeMap<'a, 'tcx>,\n     namespace_map: RefCell<DefIdMap<&'a DIScope>>,\n \n+    recursion_marker_type: OnceCell<&'a DIType>,\n+\n     // This collection is used to assert that composite types (structs, enums,\n     // ...) have their members only set once:\n     composite_types_completed: RefCell<FxHashSet<&'a DIType>>,\n@@ -93,6 +96,7 @@ impl<'a, 'tcx> CrateDebugContext<'a, 'tcx> {\n             created_enum_disr_types: Default::default(),\n             type_map: Default::default(),\n             namespace_map: RefCell::new(Default::default()),\n+            recursion_marker_type: OnceCell::new(),\n             composite_types_completed: Default::default(),\n         }\n     }"}, {"sha": "d39e753b8f3a39e212c9f032e6efdc55a1c4d4f4", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228", "patch": "@@ -9,10 +9,14 @@\n #![feature(crate_visibility_modifier)]\n #![feature(let_else)]\n #![feature(extern_types)]\n+#![feature(once_cell)]\n #![feature(nll)]\n #![recursion_limit = \"256\"]\n #![cfg_attr(not(bootstrap), allow(rustc::potential_query_instability))]\n \n+#[macro_use]\n+extern crate rustc_macros;\n+\n use back::write::{create_informational_target_machine, create_target_machine};\n \n pub use llvm_util::target_features;"}, {"sha": "0abc8a409ed7a5346c995ce235171a6103ebe408", "filename": "src/test/codegen/fn-impl-trait-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228/src%2Ftest%2Fcodegen%2Ffn-impl-trait-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228/src%2Ftest%2Fcodegen%2Ffn-impl-trait-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffn-impl-trait-self.rs?ref=9b2a46591ad0cc9dbe7699c17e2ecdb4dc921228", "patch": "@@ -5,7 +5,7 @@\n // NONMSVC: {{.*}}DIDerivedType(tag: DW_TAG_pointer_type, name: \"fn() -> <recursive_type>\",{{.*}}\n //\n // CHECK: {{.*}}DISubroutineType{{.*}}\n-// CHECK: {{.*}}DIBasicType(name: \"<recur_type>\", encoding: DW_ATE_unsigned)\n+// CHECK: {{.*}}DIBasicType(name: \"<recur_type>\", size: {{32|64}}, encoding: DW_ATE_unsigned)\n \n pub fn foo() -> impl Copy {\n     foo"}]}