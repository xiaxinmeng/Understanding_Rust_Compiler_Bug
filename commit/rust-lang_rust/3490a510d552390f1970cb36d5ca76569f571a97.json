{"sha": "3490a510d552390f1970cb36d5ca76569f571a97", "node_id": "C_kwDOAAsO6NoAKDM0OTBhNTEwZDU1MjM5MGYxOTcwY2IzNmQ1Y2E3NjU2OWY1NzFhOTc", "commit": {"author": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "me@fmease.dev", "date": "2022-11-04T16:05:56Z"}, "committer": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "me@fmease.dev", "date": "2023-06-07T11:29:36Z"}, "message": "rustdoc: re-elide cross-crate default trait object lifetime bounds", "tree": {"sha": "968a17472a90040ac9f8341062c591281a33d2bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/968a17472a90040ac9f8341062c591281a33d2bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3490a510d552390f1970cb36d5ca76569f571a97", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXSQFaHGAjVoD5I3F0XoHIV9o5xMFAmSAaiAACgkQ0XoHIV9o\n5xO4RQ//XCOsv109GHPwRXaumsupdSJz6YvpyM+L4HNFjh6ackHluQjXuTfckwzH\n94k+rhOtv3H2d/WMz1mBdxisDoZLtOzpNs8d1tvGxTPEaMgNovqr1xMXhquar8KS\n+BsE8jFnM37DmOjmbao5LhWWsRbjxZJwCoCoC24tbO8YWMceI0VqwP1iAhOSZ1Xm\n8H63HWqCHaQ8GZzurfuvS6/YGXGxC72cy/ar96HZwTkrMhmW0eDl9MlT1ENEvoT3\n1Ud+xsjcfsKiLD0VLaZvhWTSlII53c7Ns+E9LPbocflVrO6MJXOIP/hW6FKN5G3L\nWL/depY2DIHNydAG/mTpTFU/qkMBFxEhwqE4OP0OViO8DgSiYWvZ5fbvOKKK49i8\nwEUTQrkgSXbPxXmW5wfw7FZ/OviG2wIS3Q5WVrwiETEOB+KmKgD0CTPBzqIfX+zx\nhHNBPCdPzoNv/l8sVJgbhvQ4NumhUaJzASuvAUh6Kms/UTg2eaBfDZfGAaM2ME19\nWoS5aBdeFyo6MkwAm+qsf6KnTeFlNPn+zNvS9+s2OqPnbNS+FMeK3K54xM/+vo3u\na6PtiI+5IU0+2YVgoRlHg8FK63jc2oFSGrZY2zttV+iSLpshwThfgRcMVW4xqk+X\njrl1efneTPIm7zsHePz91Z/jESMOnKB7TpmlCGiexAthNd+V2qA=\n=M1ZN\n-----END PGP SIGNATURE-----", "payload": "tree 968a17472a90040ac9f8341062c591281a33d2bd\nparent 10b7e468f3cc263b8df8ff0212d0911ed5a3c090\nauthor Le\u00f3n Orell Valerian Liehr <me@fmease.dev> 1667577956 +0100\ncommitter Le\u00f3n Orell Valerian Liehr <me@fmease.dev> 1686137376 +0200\n\nrustdoc: re-elide cross-crate default trait object lifetime bounds\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3490a510d552390f1970cb36d5ca76569f571a97", "html_url": "https://github.com/rust-lang/rust/commit/3490a510d552390f1970cb36d5ca76569f571a97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3490a510d552390f1970cb36d5ca76569f571a97/comments", "author": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10b7e468f3cc263b8df8ff0212d0911ed5a3c090", "url": "https://api.github.com/repos/rust-lang/rust/commits/10b7e468f3cc263b8df8ff0212d0911ed5a3c090", "html_url": "https://github.com/rust-lang/rust/commit/10b7e468f3cc263b8df8ff0212d0911ed5a3c090"}], "stats": {"total": 503, "additions": 435, "deletions": 68}, "files": [{"sha": "c8a40e0150112981be2a7c209390a1ad050aa867", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3490a510d552390f1970cb36d5ca76569f571a97/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3490a510d552390f1970cb36d5ca76569f571a97/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=3490a510d552390f1970cb36d5ca76569f571a97", "patch": "@@ -124,7 +124,7 @@ where\n                 unsafety: hir::Unsafety::Normal,\n                 generics: new_generics,\n                 trait_: Some(clean_trait_ref_with_bindings(self.cx, trait_ref, ThinVec::new())),\n-                for_: clean_middle_ty(ty::Binder::dummy(ty), self.cx, None),\n+                for_: clean_middle_ty(ty::Binder::dummy(ty), self.cx, None, None),\n                 items: Vec::new(),\n                 polarity,\n                 kind: ImplKind::Auto,"}, {"sha": "a36041588510f55b701b4571e703e7b7c6ef9319", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3490a510d552390f1970cb36d5ca76569f571a97/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3490a510d552390f1970cb36d5ca76569f571a97/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=3490a510d552390f1970cb36d5ca76569f571a97", "patch": "@@ -107,7 +107,12 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             ty::Binder::dummy(trait_ref.subst_identity()),\n                             ThinVec::new(),\n                         )),\n-                        for_: clean_middle_ty(ty::Binder::dummy(ty.subst_identity()), cx, None),\n+                        for_: clean_middle_ty(\n+                            ty::Binder::dummy(ty.subst_identity()),\n+                            cx,\n+                            None,\n+                            None,\n+                        ),\n                         items: cx\n                             .tcx\n                             .associated_items(impl_def_id)\n@@ -119,6 +124,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             ty::Binder::dummy(trait_ref.subst_identity().self_ty()),\n                             cx,\n                             None,\n+                            None,\n                         ))),\n                     }))),\n                     cfg: None,"}, {"sha": "3aa98da1c803ad8d3c59b4589a1de96db0cd51a5", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3490a510d552390f1970cb36d5ca76569f571a97/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3490a510d552390f1970cb36d5ca76569f571a97/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=3490a510d552390f1970cb36d5ca76569f571a97", "patch": "@@ -278,8 +278,12 @@ fn build_union(cx: &mut DocContext<'_>, did: DefId) -> clean::Union {\n \n fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> Box<clean::Typedef> {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n-    let type_ =\n-        clean_middle_ty(ty::Binder::dummy(cx.tcx.type_of(did).subst_identity()), cx, Some(did));\n+    let type_ = clean_middle_ty(\n+        ty::Binder::dummy(cx.tcx.type_of(did).subst_identity()),\n+        cx,\n+        Some(did),\n+        None,\n+    );\n \n     Box::new(clean::Typedef {\n         type_,\n@@ -386,9 +390,12 @@ pub(crate) fn build_impl(\n \n     let for_ = match &impl_item {\n         Some(impl_) => clean_ty(impl_.self_ty, cx),\n-        None => {\n-            clean_middle_ty(ty::Binder::dummy(tcx.type_of(did).subst_identity()), cx, Some(did))\n-        }\n+        None => clean_middle_ty(\n+            ty::Binder::dummy(tcx.type_of(did).subst_identity()),\n+            cx,\n+            Some(did),\n+            None,\n+        ),\n     };\n \n     // Only inline impl if the implementing type is\n@@ -630,6 +637,7 @@ fn build_const(cx: &mut DocContext<'_>, def_id: DefId) -> clean::Constant {\n             ty::Binder::dummy(cx.tcx.type_of(def_id).subst_identity()),\n             cx,\n             Some(def_id),\n+            None,\n         ),\n         kind: clean::ConstantKind::Extern { def_id },\n     }\n@@ -641,6 +649,7 @@ fn build_static(cx: &mut DocContext<'_>, did: DefId, mutable: bool) -> clean::St\n             ty::Binder::dummy(cx.tcx.type_of(did).subst_identity()),\n             cx,\n             Some(did),\n+            None,\n         ),\n         mutability: if mutable { Mutability::Mut } else { Mutability::Not },\n         expr: None,"}, {"sha": "526c9a4a35faeb82d25fde53b44921c3bb01d097", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 219, "deletions": 26, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/3490a510d552390f1970cb36d5ca76569f571a97/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3490a510d552390f1970cb36d5ca76569f571a97/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3490a510d552390f1970cb36d5ca76569f571a97", "patch": "@@ -253,6 +253,7 @@ pub(crate) fn clean_const<'tcx>(constant: &hir::ConstArg, cx: &mut DocContext<'t\n             ty::Binder::dummy(cx.tcx.type_of(def_id).subst_identity()),\n             cx,\n             Some(def_id),\n+            None,\n         ),\n         kind: ConstantKind::Anonymous { body: constant.value.body },\n     }\n@@ -264,7 +265,7 @@ pub(crate) fn clean_middle_const<'tcx>(\n ) -> Constant {\n     // FIXME: instead of storing the stringified expression, store `self` directly instead.\n     Constant {\n-        type_: clean_middle_ty(constant.map_bound(|c| c.ty()), cx, None),\n+        type_: clean_middle_ty(constant.map_bound(|c| c.ty()), cx, None, None),\n         kind: ConstantKind::TyConst { expr: constant.skip_binder().to_string().into() },\n     }\n }\n@@ -370,7 +371,7 @@ fn clean_poly_trait_predicate<'tcx>(\n \n     let poly_trait_ref = pred.map_bound(|pred| pred.trait_ref);\n     Some(WherePredicate::BoundPredicate {\n-        ty: clean_middle_ty(poly_trait_ref.self_ty(), cx, None),\n+        ty: clean_middle_ty(poly_trait_ref.self_ty(), cx, None, None),\n         bounds: vec![clean_poly_trait_ref_with_bindings(cx, poly_trait_ref, ThinVec::new())],\n         bound_params: Vec::new(),\n     })\n@@ -396,7 +397,7 @@ fn clean_type_outlives_predicate<'tcx>(\n     let ty::OutlivesPredicate(ty, lt) = pred.skip_binder();\n \n     Some(WherePredicate::BoundPredicate {\n-        ty: clean_middle_ty(pred.rebind(ty), cx, None),\n+        ty: clean_middle_ty(pred.rebind(ty), cx, None, None),\n         bounds: vec![GenericBound::Outlives(\n             clean_middle_region(lt).expect(\"failed to clean lifetimes\"),\n         )],\n@@ -409,7 +410,7 @@ fn clean_middle_term<'tcx>(\n     cx: &mut DocContext<'tcx>,\n ) -> Term {\n     match term.skip_binder().unpack() {\n-        ty::TermKind::Ty(ty) => Term::Type(clean_middle_ty(term.rebind(ty), cx, None)),\n+        ty::TermKind::Ty(ty) => Term::Type(clean_middle_ty(term.rebind(ty), cx, None, None)),\n         ty::TermKind::Const(c) => Term::Constant(clean_middle_const(term.rebind(c), cx)),\n     }\n }\n@@ -462,7 +463,7 @@ fn clean_projection<'tcx>(\n \n     let trait_ =\n         clean_trait_ref_with_bindings(cx, ty.map_bound(|ty| ty.trait_ref(cx.tcx)), ThinVec::new());\n-    let self_type = clean_middle_ty(ty.map_bound(|ty| ty.self_ty()), cx, None);\n+    let self_type = clean_middle_ty(ty.map_bound(|ty| ty.self_ty()), cx, None, None);\n     let self_def_id = if let Some(def_id) = def_id {\n         cx.tcx.opt_parent(def_id).or(Some(def_id))\n     } else {\n@@ -493,8 +494,13 @@ fn projection_to_path_segment<'tcx>(\n     PathSegment {\n         name: item.name,\n         args: GenericArgs::AngleBracketed {\n-            args: substs_to_args(cx, ty.map_bound(|ty| &ty.substs[generics.parent_count..]), false)\n-                .into(),\n+            args: substs_to_args(\n+                cx,\n+                ty.map_bound(|ty| &ty.substs[generics.parent_count..]),\n+                false,\n+                None,\n+            )\n+            .into(),\n             bindings: Default::default(),\n         },\n     }\n@@ -514,6 +520,7 @@ fn clean_generic_param_def<'tcx>(\n                     ty::Binder::dummy(cx.tcx.type_of(def.def_id).subst_identity()),\n                     cx,\n                     Some(def.def_id),\n+                    None,\n                 ))\n             } else {\n                 None\n@@ -540,6 +547,7 @@ fn clean_generic_param_def<'tcx>(\n                     ),\n                     cx,\n                     Some(def.def_id),\n+                    None,\n                 )),\n                 default: match has_default {\n                     true => Some(Box::new(\n@@ -871,7 +879,7 @@ fn clean_ty_generics<'tcx>(\n         let crate::core::ImplTraitParam::ParamIndex(idx) = param else { unreachable!() };\n         if let Some(proj) = impl_trait_proj.remove(&idx) {\n             for (trait_did, name, rhs, bound_params) in proj {\n-                let rhs = clean_middle_ty(rhs, cx, None);\n+                let rhs = clean_middle_ty(rhs, cx, None, None);\n                 simplify::merge_bounds(\n                     cx,\n                     &mut bounds,\n@@ -1126,7 +1134,7 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n \n     // We assume all empty tuples are default return type. This theoretically can discard `-> ()`,\n     // but shouldn't change any code meaning.\n-    let output = clean_middle_ty(sig.output(), cx, None);\n+    let output = clean_middle_ty(sig.output(), cx, None, None);\n \n     FnDecl {\n         output,\n@@ -1136,7 +1144,7 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n                 .inputs()\n                 .iter()\n                 .map(|t| Argument {\n-                    type_: clean_middle_ty(t.map_bound(|t| *t), cx, None),\n+                    type_: clean_middle_ty(t.map_bound(|t| *t), cx, None, None),\n                     name: names\n                         .next()\n                         .map(|i| i.name)\n@@ -1190,8 +1198,12 @@ fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext\n             hir::TraitItemKind::Type(bounds, Some(default)) => {\n                 let generics = enter_impl_trait(cx, |cx| clean_generics(trait_item.generics, cx));\n                 let bounds = bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect();\n-                let item_type =\n-                    clean_middle_ty(ty::Binder::dummy(hir_ty_to_ty(cx.tcx, default)), cx, None);\n+                let item_type = clean_middle_ty(\n+                    ty::Binder::dummy(hir_ty_to_ty(cx.tcx, default)),\n+                    cx,\n+                    None,\n+                    None,\n+                );\n                 AssocTypeItem(\n                     Box::new(Typedef {\n                         type_: clean_ty(default, cx),\n@@ -1230,8 +1242,12 @@ pub(crate) fn clean_impl_item<'tcx>(\n             hir::ImplItemKind::Type(hir_ty) => {\n                 let type_ = clean_ty(hir_ty, cx);\n                 let generics = clean_generics(impl_.generics, cx);\n-                let item_type =\n-                    clean_middle_ty(ty::Binder::dummy(hir_ty_to_ty(cx.tcx, hir_ty)), cx, None);\n+                let item_type = clean_middle_ty(\n+                    ty::Binder::dummy(hir_ty_to_ty(cx.tcx, hir_ty)),\n+                    cx,\n+                    None,\n+                    None,\n+                );\n                 AssocTypeItem(\n                     Box::new(Typedef { type_, generics, item_type: Some(item_type) }),\n                     Vec::new(),\n@@ -1254,6 +1270,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                 ty::Binder::dummy(tcx.type_of(assoc_item.def_id).subst_identity()),\n                 cx,\n                 Some(assoc_item.def_id),\n+                None,\n             );\n \n             let provided = match assoc_item.container {\n@@ -1447,6 +1464,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                                 ty::Binder::dummy(tcx.type_of(assoc_item.def_id).subst_identity()),\n                                 cx,\n                                 Some(assoc_item.def_id),\n+                                None,\n                             ),\n                             generics,\n                             // FIXME: should we obtain the Type from HIR and pass it on here?\n@@ -1465,6 +1483,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                             ty::Binder::dummy(tcx.type_of(assoc_item.def_id).subst_identity()),\n                             cx,\n                             Some(assoc_item.def_id),\n+                            None,\n                         ),\n                         generics: Generics {\n                             params: ThinVec::new(),\n@@ -1510,7 +1529,7 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n             if !ty.has_escaping_bound_vars()\n                 && let Some(normalized_value) = normalize(cx, ty::Binder::dummy(ty))\n             {\n-                return clean_middle_ty(normalized_value, cx, None);\n+                return clean_middle_ty(normalized_value, cx, None, None);\n             }\n \n             let trait_segments = &p.segments[..p.segments.len() - 1];\n@@ -1738,11 +1757,174 @@ fn normalize<'tcx>(\n     }\n }\n \n+fn clean_trait_object_lifetime_bound<'tcx>(\n+    region: ty::Region<'tcx>,\n+    container: Option<ContainerTy<'tcx>>,\n+    trait_: DefId,\n+    substs: ty::Binder<'tcx, &ty::List<ty::GenericArg<'tcx>>>,\n+    tcx: TyCtxt<'tcx>,\n+) -> Option<Lifetime> {\n+    if can_elide_trait_object_lifetime_bound(region, container, trait_, substs, tcx) {\n+        return None;\n+    }\n+\n+    // Since there is a semantic difference between an implicitly elided (i.e. \"defaulted\") object\n+    // lifetime and an explicitly elided object lifetime (`'_`), we intentionally don't hide the\n+    // latter contrary to `clean_middle_region`.\n+    match *region {\n+        ty::ReStatic => Some(Lifetime::statik()),\n+        ty::ReEarlyBound(region) if region.name != kw::Empty => Some(Lifetime(region.name)),\n+        ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. })\n+            if name != kw::Empty =>\n+        {\n+            Some(Lifetime(name))\n+        }\n+        ty::ReEarlyBound(_)\n+        | ty::ReLateBound(..)\n+        | ty::ReFree(_)\n+        | ty::ReVar(_)\n+        | ty::RePlaceholder(_)\n+        | ty::ReErased\n+        | ty::ReError(_) => None,\n+    }\n+}\n+\n+fn can_elide_trait_object_lifetime_bound<'tcx>(\n+    region: ty::Region<'tcx>,\n+    container: Option<ContainerTy<'tcx>>,\n+    trait_: DefId,\n+    substs: ty::Binder<'tcx, &ty::List<ty::GenericArg<'tcx>>>,\n+    tcx: TyCtxt<'tcx>,\n+) -> bool {\n+    // Below we quote extracts from https://doc.rust-lang.org/reference/lifetime-elision.html#default-trait-object-lifetimes\n+\n+    // > If the trait object is used as a type argument of a generic type then the containing type is\n+    // > first used to try to infer a bound.\n+    let default = container\n+        .map_or(ObjectLifetimeDefault::Empty, |container| container.object_lifetime_default(tcx));\n+\n+    // > If there is a unique bound from the containing type then that is the default\n+    // If there is a default object lifetime and the given region is lexically equal to it, elide it.\n+    match default {\n+        ObjectLifetimeDefault::Static => return *region == ty::ReStatic,\n+        // FIXME(fmease): Don't compare lexically but respect de Bruijn indices etc. to handle shadowing correctly.\n+        ObjectLifetimeDefault::Arg(default) => return region.get_name() == default.get_name(),\n+        // > If there is more than one bound from the containing type then an explicit bound must be specified\n+        // Due to ambiguity there is no default trait-object lifetime and thus elision is impossible.\n+        // Don't elide the lifetime.\n+        ObjectLifetimeDefault::Ambiguous => return false,\n+        // There is no meaningful bound. Further processing is needed...\n+        ObjectLifetimeDefault::Empty => {}\n+    }\n+\n+    // We filter out any escaping regions below, thus it's fine to skip the binder.\n+    let substs = substs.skip_binder();\n+\n+    // > If neither of those rules apply, then the bounds on the trait are used:\n+    let mut trait_regions: Vec<_> = tcx\n+        .predicates_of(trait_)\n+        .predicates\n+        .iter()\n+        .filter_map(|(pred, _)| {\n+            // Look for bounds of the form `Self: 'a` for any region `'a`.\n+            if let ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(ty, region))) = pred.kind().skip_binder()\n+                && let ty::Param(param) = ty.kind()\n+                && param.name == kw::SelfUpper\n+            {\n+                Some(ty::EarlyBinder::bind(region).subst(tcx, tcx.mk_substs_trait(ty, substs)))\n+                    .filter(|region| !region.has_escaping_bound_vars())\n+            } else {\n+                None\n+            }\n+        })\n+        .collect();\n+\n+    // As a result of the substitutions above, we might be left with duplicate regions.\n+    // Consider `<'a, 'b> Self: 'a + 'b` with substitution `<'r, 'r>`. Deduplicate.\n+    trait_regions.dedup();\n+\n+    // > If 'static is used for any lifetime bound then 'static is used.\n+    // If the list contains `'static`, throw out everyhing else as it outlives any of them.\n+    if let Some(index) = trait_regions.iter().position(|region| region.is_static()) {\n+        let static_ = trait_regions.swap_remove(index);\n+        trait_regions.clear();\n+        trait_regions.push(static_);\n+    }\n+\n+    match *trait_regions {\n+        // > If the trait has no lifetime bounds, then the lifetime is inferred in expressions\n+        // > and is 'static outside of expressions.\n+        // FIXME: If we are in an expression context (i.e. fn bodies and const exprs) then the default is\n+        // `'_` and not `'static`. Only if we are in a non-expression one, the default is `'static`.\n+        // Note however that at the time of this writing it should be fine to disregard this subtlety\n+        // as we neither render const exprs faithfully anyway (hiding them in some places or using `_` instead)\n+        // nor show the contents of fn bodies.\n+        [] => *region == ty::ReStatic,\n+        // > If the trait is defined with a single lifetime bound then that bound is used.\n+        // FIXME(fmease): Don't compare lexically but respect de Bruijn indices etc. to handle shadowing correctly.\n+        [trait_region] => trait_region.get_name() == region.get_name(),\n+        // There are several distinct trait regions and none are `'static` (thanks to the preprocessing above).\n+        // Due to ambiguity there is no default trait-object lifetime and thus elision is impossible.\n+        // Don't elide the lifetime.\n+        _ => false,\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(crate) enum ContainerTy<'tcx> {\n+    Ref(ty::Region<'tcx>),\n+    Regular { ty: DefId, substs: ty::Binder<'tcx, &'tcx [ty::GenericArg<'tcx>]>, arg: usize },\n+}\n+\n+impl<'tcx> ContainerTy<'tcx> {\n+    fn object_lifetime_default(self, tcx: TyCtxt<'tcx>) -> ObjectLifetimeDefault<'tcx> {\n+        match self {\n+            Self::Ref(region) => ObjectLifetimeDefault::Arg(region),\n+            Self::Regular { ty: container, substs, arg: index } => {\n+                let (DefKind::Struct\n+                | DefKind::Union\n+                | DefKind::Enum\n+                | DefKind::TyAlias\n+                | DefKind::Trait\n+                | DefKind::AssocTy\n+                | DefKind::Variant) = tcx.def_kind(container)\n+                else {\n+                    return ObjectLifetimeDefault::Empty;\n+                };\n+\n+                let generics = tcx.generics_of(container);\n+                let param = generics.params[index].def_id;\n+                let default = tcx.object_lifetime_default(param);\n+\n+                match default {\n+                    rbv::ObjectLifetimeDefault::Param(lifetime) => {\n+                        let index = generics.param_def_id_to_index[&lifetime];\n+                        let arg = substs.skip_binder()[index as usize].expect_region();\n+                        ObjectLifetimeDefault::Arg(arg)\n+                    }\n+                    rbv::ObjectLifetimeDefault::Empty => ObjectLifetimeDefault::Empty,\n+                    rbv::ObjectLifetimeDefault::Static => ObjectLifetimeDefault::Static,\n+                    rbv::ObjectLifetimeDefault::Ambiguous => ObjectLifetimeDefault::Ambiguous,\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+pub(crate) enum ObjectLifetimeDefault<'tcx> {\n+    Empty,\n+    Static,\n+    Ambiguous,\n+    Arg(ty::Region<'tcx>),\n+}\n+\n #[instrument(level = \"trace\", skip(cx), ret)]\n pub(crate) fn clean_middle_ty<'tcx>(\n     bound_ty: ty::Binder<'tcx, Ty<'tcx>>,\n     cx: &mut DocContext<'tcx>,\n     parent_def_id: Option<DefId>,\n+    container: Option<ContainerTy<'tcx>>,\n ) -> Type {\n     let bound_ty = normalize(cx, bound_ty).unwrap_or(bound_ty);\n     match *bound_ty.skip_binder().kind() {\n@@ -1753,19 +1935,24 @@ pub(crate) fn clean_middle_ty<'tcx>(\n         ty::Uint(uint_ty) => Primitive(uint_ty.into()),\n         ty::Float(float_ty) => Primitive(float_ty.into()),\n         ty::Str => Primitive(PrimitiveType::Str),\n-        ty::Slice(ty) => Slice(Box::new(clean_middle_ty(bound_ty.rebind(ty), cx, None))),\n+        ty::Slice(ty) => Slice(Box::new(clean_middle_ty(bound_ty.rebind(ty), cx, None, None))),\n         ty::Array(ty, mut n) => {\n             n = n.eval(cx.tcx, ty::ParamEnv::reveal_all());\n             let n = print_const(cx, n);\n-            Array(Box::new(clean_middle_ty(bound_ty.rebind(ty), cx, None)), n.into())\n+            Array(Box::new(clean_middle_ty(bound_ty.rebind(ty), cx, None, None)), n.into())\n         }\n         ty::RawPtr(mt) => {\n-            RawPointer(mt.mutbl, Box::new(clean_middle_ty(bound_ty.rebind(mt.ty), cx, None)))\n+            RawPointer(mt.mutbl, Box::new(clean_middle_ty(bound_ty.rebind(mt.ty), cx, None, None)))\n         }\n         ty::Ref(r, ty, mutbl) => BorrowedRef {\n             lifetime: clean_middle_region(r),\n             mutability: mutbl,\n-            type_: Box::new(clean_middle_ty(bound_ty.rebind(ty), cx, None)),\n+            type_: Box::new(clean_middle_ty(\n+                bound_ty.rebind(ty),\n+                cx,\n+                None,\n+                Some(ContainerTy::Ref(r)),\n+            )),\n         },\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             // FIXME: should we merge the outer and inner binders somehow?\n@@ -1817,10 +2004,8 @@ pub(crate) fn clean_middle_ty<'tcx>(\n \n             inline::record_extern_fqn(cx, did, ItemType::Trait);\n \n-            // FIXME(fmease): Hide the trait-object lifetime bound if it coincides with its default\n-            // to partially address #44306. Follow the rules outlined at\n-            // https://doc.rust-lang.org/reference/lifetime-elision.html#default-trait-object-lifetimes\n-            let lifetime = clean_middle_region(*reg);\n+            let lifetime = clean_trait_object_lifetime_bound(*reg, container, did, substs, cx.tcx);\n+\n             let mut bounds = dids\n                 .map(|did| {\n                     let empty = ty::Binder::dummy(InternalSubsts::empty());\n@@ -1869,7 +2054,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n             DynTrait(bounds, lifetime)\n         }\n         ty::Tuple(t) => {\n-            Tuple(t.iter().map(|t| clean_middle_ty(bound_ty.rebind(t), cx, None)).collect())\n+            Tuple(t.iter().map(|t| clean_middle_ty(bound_ty.rebind(t), cx, None, None)).collect())\n         }\n \n         ty::Alias(ty::Projection, ref data) => {\n@@ -1878,7 +2063,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n \n         ty::Alias(ty::Inherent, alias_ty) => {\n             let alias_ty = bound_ty.rebind(alias_ty);\n-            let self_type = clean_middle_ty(alias_ty.map_bound(|ty| ty.self_ty()), cx, None);\n+            let self_type = clean_middle_ty(alias_ty.map_bound(|ty| ty.self_ty()), cx, None, None);\n \n             Type::QPath(Box::new(QPathData {\n                 assoc: PathSegment {\n@@ -1888,6 +2073,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n                             cx,\n                             alias_ty.map_bound(|ty| ty.substs.as_slice()),\n                             true,\n+                            None,\n                         )\n                         .into(),\n                         bindings: Default::default(),\n@@ -2023,6 +2209,7 @@ pub(crate) fn clean_middle_field<'tcx>(field: &ty::FieldDef, cx: &mut DocContext\n             ty::Binder::dummy(cx.tcx.type_of(field.did).subst_identity()),\n             cx,\n             Some(field.did),\n+            None,\n         ),\n         cx,\n     )\n@@ -2314,7 +2501,12 @@ fn clean_maybe_renamed_item<'tcx>(\n             ItemKind::TyAlias(hir_ty, generics) => {\n                 *cx.current_type_aliases.entry(def_id).or_insert(0) += 1;\n                 let rustdoc_ty = clean_ty(hir_ty, cx);\n-                let ty = clean_middle_ty(ty::Binder::dummy(hir_ty_to_ty(cx.tcx, hir_ty)), cx, None);\n+                let ty = clean_middle_ty(\n+                    ty::Binder::dummy(hir_ty_to_ty(cx.tcx, hir_ty)),\n+                    cx,\n+                    None,\n+                    None,\n+                );\n                 let generics = clean_generics(generics, cx);\n                 if let Some(count) = cx.current_type_aliases.get_mut(&def_id) {\n                     *count -= 1;\n@@ -2418,6 +2610,7 @@ fn clean_impl<'tcx>(\n                 ty::Binder::dummy(tcx.type_of(def_id).subst_identity()),\n                 cx,\n                 Some(def_id.to_def_id()),\n+                None,\n             )),\n             _ => None,\n         });"}, {"sha": "294de12cea8e2f7b0bffdf438f54108221452ae7", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3490a510d552390f1970cb36d5ca76569f571a97/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3490a510d552390f1970cb36d5ca76569f571a97/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=3490a510d552390f1970cb36d5ca76569f571a97", "patch": "@@ -73,28 +73,39 @@ pub(crate) fn krate(cx: &mut DocContext<'_>) -> Crate {\n \n pub(crate) fn substs_to_args<'tcx>(\n     cx: &mut DocContext<'tcx>,\n-    substs: ty::Binder<'tcx, &[ty::subst::GenericArg<'tcx>]>,\n+    substs: ty::Binder<'tcx, &'tcx [ty::subst::GenericArg<'tcx>]>,\n     mut skip_first: bool,\n+    container: Option<DefId>,\n ) -> Vec<GenericArg> {\n     let mut ret_val =\n         Vec::with_capacity(substs.skip_binder().len().saturating_sub(if skip_first {\n             1\n         } else {\n             0\n         }));\n-    ret_val.extend(substs.iter().filter_map(|kind| match kind.skip_binder().unpack() {\n-        GenericArgKind::Lifetime(lt) => {\n-            Some(GenericArg::Lifetime(clean_middle_region(lt).unwrap_or(Lifetime::elided())))\n-        }\n-        GenericArgKind::Type(_) if skip_first => {\n-            skip_first = false;\n-            None\n-        }\n-        GenericArgKind::Type(ty) => {\n-            Some(GenericArg::Type(clean_middle_ty(kind.rebind(ty), cx, None)))\n-        }\n-        GenericArgKind::Const(ct) => {\n-            Some(GenericArg::Const(Box::new(clean_middle_const(kind.rebind(ct), cx))))\n+\n+    ret_val.extend(substs.iter().enumerate().filter_map(|(index, kind)| {\n+        match kind.skip_binder().unpack() {\n+            GenericArgKind::Lifetime(lt) => {\n+                Some(GenericArg::Lifetime(clean_middle_region(lt).unwrap_or(Lifetime::elided())))\n+            }\n+            GenericArgKind::Type(_) if skip_first => {\n+                skip_first = false;\n+                None\n+            }\n+            GenericArgKind::Type(ty) => Some(GenericArg::Type(clean_middle_ty(\n+                kind.rebind(ty),\n+                cx,\n+                None,\n+                container.map(|container| crate::clean::ContainerTy::Regular {\n+                    ty: container,\n+                    substs,\n+                    arg: index,\n+                }),\n+            ))),\n+            GenericArgKind::Const(ct) => {\n+                Some(GenericArg::Const(Box::new(clean_middle_const(kind.rebind(ct), cx))))\n+            }\n         }\n     }));\n     ret_val\n@@ -107,7 +118,7 @@ fn external_generic_args<'tcx>(\n     bindings: ThinVec<TypeBinding>,\n     substs: ty::Binder<'tcx, SubstsRef<'tcx>>,\n ) -> GenericArgs {\n-    let args = substs_to_args(cx, substs.map_bound(|substs| &substs[..]), has_self);\n+    let args = substs_to_args(cx, substs.map_bound(|substs| &substs[..]), has_self, Some(did));\n \n     if cx.tcx.fn_trait_kind_from_def_id(did).is_some() {\n         let ty = substs\n@@ -118,7 +129,7 @@ fn external_generic_args<'tcx>(\n         let inputs =\n             // The trait's first substitution is the one after self, if there is one.\n             match ty.skip_binder().kind() {\n-                ty::Tuple(tys) => tys.iter().map(|t| clean_middle_ty(ty.rebind(t), cx, None)).collect::<Vec<_>>().into(),\n+                ty::Tuple(tys) => tys.iter().map(|t| clean_middle_ty(ty.rebind(t), cx, None, None)).collect::<Vec<_>>().into(),\n                 _ => return GenericArgs::AngleBracketed { args: args.into(), bindings },\n             };\n         let output = bindings.into_iter().next().and_then(|binding| match binding.kind {"}, {"sha": "08dfa879d436304c3eae7550e351e28de02a8d9c", "filename": "tests/rustdoc/assoc-consts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3490a510d552390f1970cb36d5ca76569f571a97/tests%2Frustdoc%2Fassoc-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3490a510d552390f1970cb36d5ca76569f571a97/tests%2Frustdoc%2Fassoc-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fassoc-consts.rs?ref=3490a510d552390f1970cb36d5ca76569f571a97", "patch": "@@ -46,7 +46,6 @@ pub fn f(_: &(ToString + 'static)) {}\n impl Bar {\n     // @has assoc_consts/struct.Bar.html '//*[@id=\"associatedconstant.F\"]' \\\n     //      \"const F: fn(_: &(dyn ToString + 'static))\"\n-    // FIXME(fmease): Hide default lifetime, render \"const F: fn(_: &dyn ToString)\"\n     pub const F: fn(_: &(ToString + 'static)) = f;\n }\n "}, {"sha": "644d0699e9d070641376f88d2a1347c98183e912", "filename": "tests/rustdoc/inline_cross/auxiliary/dyn_trait.rs", "status": "modified", "additions": 55, "deletions": 5, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3490a510d552390f1970cb36d5ca76569f571a97/tests%2Frustdoc%2Finline_cross%2Fauxiliary%2Fdyn_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3490a510d552390f1970cb36d5ca76569f571a97/tests%2Frustdoc%2Finline_cross%2Fauxiliary%2Fdyn_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Finline_cross%2Fauxiliary%2Fdyn_trait.rs?ref=3490a510d552390f1970cb36d5ca76569f571a97", "patch": "@@ -1,3 +1,5 @@\n+// ignore-tidy-linelength\n+\n pub type Ty0 = dyn for<'any> FnOnce(&'any str) -> bool;\n \n pub type Ty1<'obj> = dyn std::fmt::Display + 'obj;\n@@ -6,12 +8,60 @@ pub type Ty2 = dyn for<'a, 'r> Container<'r, Item<'a, 'static> = ()>;\n \n pub type Ty3<'s> = &'s dyn ToString;\n \n-pub fn func0(_: &(dyn Fn() + '_)) {}\n-\n-pub fn func1<'func>(_: &(dyn Fn() + 'func)) {}\n-\n pub trait Container<'r> {\n     type Item<'a, 'ctx>;\n }\n \n-pub trait Shape<'a> {}\n+// Trait-object types inside of a container type that has lifetime bounds (\"wrapped\").\n+\n+pub fn late_bound_wrapped_elided(_: &(dyn Fn() + '_)) {}\n+pub fn late_bound_wrapped_late0<'f>(_: &mut (dyn Fn() + 'f)) {}\n+pub fn late_bound_wrapped_defaulted0<'f>(_: &'f mut dyn Fn()) {}\n+pub type EarlyBoundWrappedDefaulted0<'x> = std::cell::Ref<'x, dyn Trait>;\n+pub type EarlyBoundWrappedDefaulted1<'x> = &'x dyn Trait;\n+pub type EarlyBoundWrappedEarly<'x, 'y> = std::cell::Ref<'x, dyn Trait + 'y>;\n+pub type EarlyBoundWrappedStatic<'x> = std::cell::Ref<'x, dyn Trait + 'static>;\n+pub fn late_bound_wrapped_defaulted1<'l>(_: std::cell::Ref<'l, dyn Trait>) {}\n+pub fn late_bound_wrapped_late1<'l, 'm>(_: std::cell::Ref<'l, dyn Trait + 'm>) {}\n+pub fn late_bound_wrapped_early<'e, 'l>(_: std::cell::Ref<'l, dyn Trait + 'e>) where 'e: {} // `'e` is early-bound\n+pub fn elided_bound_wrapped_defaulted(_: std::cell::Ref<'_, dyn Trait>) {}\n+pub type StaticBoundWrappedDefaulted0 = std::cell::Ref<'static, dyn Trait>;\n+pub type StaticBoundWrappedDefaulted1 = &'static dyn Trait;\n+pub type AmbiguousBoundWrappedEarly0<'r, 's> = AmbiguousBoundWrapper<'s, 'r, dyn Trait + 's>;\n+pub type AmbiguousBoundWrappedEarly1<'r, 's> = AmbiguousBoundWrapper<'s, 'r, dyn Trait + 'r>;\n+pub type AmbiguousBoundWrappedStatic<'q> = AmbiguousBoundWrapper<'q, 'q, dyn Trait + 'static>;\n+\n+// Trait-object types inside of a container type that doesn't have lifetime bounds (\"wrapped\").\n+\n+pub type NoBoundsWrappedDefaulted = Box<dyn Trait>;\n+pub type NoBoundsWrappedEarly<'e> = Box<dyn Trait + 'e>;\n+pub fn no_bounds_wrapped_late<'l>(_: Box<dyn Trait + 'l>) {}\n+pub fn no_bounds_wrapped_elided(_: Box<dyn Trait + '_>) {}\n+\n+// Trait-object types outside of a container (\u201cbare\u201d).\n+\n+pub type BareNoBoundsDefaulted = dyn Trait;\n+pub type BareNoBoundsEarly<'p> = dyn Trait + 'p;\n+pub type BareEarlyBoundDefaulted0<'u> = dyn EarlyBoundTrait0<'u>;\n+pub type BareEarlyBoundDefaulted1 = dyn for<'any> EarlyBoundTrait0<'any>;\n+pub type BareEarlyBoundDefaulted2<'w> = dyn EarlyBoundTrait1<'static, 'w>;\n+pub type BareEarlyBoundEarly<'i, 'j> = dyn EarlyBoundTrait0<'i> + 'j;\n+pub type BareEarlyBoundStatic<'i> = dyn EarlyBoundTrait0<'i> + 'static;\n+pub type BareStaticBoundDefaulted = dyn StaticBoundTrait;\n+pub type BareHigherRankedBoundDefaulted0 = dyn HigherRankedBoundTrait0;\n+pub type BareHigherRankedBoundDefaulted1<'r> = dyn HigherRankedBoundTrait1<'r>;\n+pub type BareAmbiguousBoundEarly0<'m, 'n> = dyn AmbiguousBoundTrait<'m, 'n> + 'm;\n+pub type BareAmbiguousBoundEarly1<'m, 'n> = dyn AmbiguousBoundTrait<'m, 'n> + 'n;\n+pub type BareAmbiguousBoundStatic<'o> = dyn AmbiguousBoundTrait<'o, 'o> + 'static;\n+\n+// Trait and container definitions.\n+\n+pub trait Trait {} // no bounds\n+pub trait EarlyBoundTrait0<'b>: 'b {}\n+pub trait EarlyBoundTrait1<'unused, 'c>: 'c {}\n+pub trait StaticBoundTrait: 'static {}\n+pub trait HigherRankedBoundTrait0 where for<'a> Self: 'a {}\n+pub trait HigherRankedBoundTrait1<'e> where for<'l> Self: 'e + 'l {}\n+pub trait AmbiguousBoundTrait<'a, 'b>: 'a + 'b {}\n+\n+pub struct AmbiguousBoundWrapper<'a, 'b, T: ?Sized + 'a + 'b>(&'a T, &'b T);"}, {"sha": "1de01af83d13e4fcc516935e8edb9bf88e374a61", "filename": "tests/rustdoc/inline_cross/dyn_trait.rs", "status": "modified", "additions": 112, "deletions": 13, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/3490a510d552390f1970cb36d5ca76569f571a97/tests%2Frustdoc%2Finline_cross%2Fdyn_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3490a510d552390f1970cb36d5ca76569f571a97/tests%2Frustdoc%2Finline_cross%2Fdyn_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Finline_cross%2Fdyn_trait.rs?ref=3490a510d552390f1970cb36d5ca76569f571a97", "patch": "@@ -1,31 +1,130 @@\n #![crate_name = \"user\"]\n \n+// In each test case, we include the trailing semicolon to ensure that nothing extra comes\n+// after the type like an unwanted outlives-bound.\n+\n // aux-crate:dyn_trait=dyn_trait.rs\n // edition:2021\n \n // @has user/type.Ty0.html\n-// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn for<'any> FnOnce(&'any str) -> bool + 'static\"\n-// FIXME(fmease): Hide default lifetime bound `'static`\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn for<'any> FnOnce(&'any str) -> bool;\"\n pub use dyn_trait::Ty0;\n \n // @has user/type.Ty1.html\n-// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn Display + 'obj\"\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn Display + 'obj;\"\n pub use dyn_trait::Ty1;\n \n // @has user/type.Ty2.html\n-// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn for<'a, 'r> Container<'r, Item<'a, 'static> = ()>\"\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn for<'a, 'r> Container<'r, Item<'a, 'static> = ()>;\"\n pub use dyn_trait::Ty2;\n \n // @has user/type.Ty3.html\n-// @has - '//*[@class=\"rust item-decl\"]//code' \"&'s (dyn ToString + 's)\"\n-// FIXME(fmease): Hide default lifetime bound, render \"&'s dyn ToString\"\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"&'s dyn ToString;\"\n pub use dyn_trait::Ty3;\n \n-// @has user/fn.func0.html\n-// @has - '//pre[@class=\"rust item-decl\"]' \"func0(_: &dyn Fn())\"\n-// FIXME(fmease): Show placeholder-lifetime bound, render \"func0(_: &(dyn Fn() + '_))\"\n-pub use dyn_trait::func0;\n+// Below we check if we correctly elide trait-object lifetime bounds if they coincide with their\n+// default (known as \"object lifetime default\" or \"default trait object lifetime\").\n+\n+// @has user/fn.lbwel.html\n+// @has - '//pre[@class=\"rust item-decl\"]' \"lbwel(_: &dyn Fn())\"\n+pub use dyn_trait::late_bound_wrapped_elided as lbwel;\n+// @has user/fn.lbwl0.html\n+// has - '//pre[@class=\"rust item-decl\"]' \"lbwl0<'f>(_: &mut (dyn Fn() + 'f))\"\n+pub use dyn_trait::late_bound_wrapped_late0 as lbwl0;\n+// @has user/fn.lbwd0.html\n+// has - '//pre[@class=\"rust item-decl\"]' \"lbwd0<'f>(_: &'f mut dyn Fn())\"\n+pub use dyn_trait::late_bound_wrapped_defaulted0 as lbwd0;\n+// @has user/type.EarlyBoundWrappedDefaulted0.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"Ref<'x, dyn Trait>;\"\n+pub use dyn_trait::EarlyBoundWrappedDefaulted0;\n+// @has user/type.EarlyBoundWrappedDefaulted1.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"&'x dyn Trait;\"\n+pub use dyn_trait::EarlyBoundWrappedDefaulted1;\n+// @has user/type.EarlyBoundWrappedEarly.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"Ref<'x, dyn Trait + 'y>\"\n+pub use dyn_trait::EarlyBoundWrappedEarly;\n+// @has user/type.EarlyBoundWrappedStatic.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"Ref<'x, dyn Trait + 'static>\"\n+pub use dyn_trait::EarlyBoundWrappedStatic;\n+// @has user/fn.lbwd1.html\n+// @has - '//pre[@class=\"rust item-decl\"]' \"lbwd1<'l>(_: Ref<'l, dyn Trait>)\"\n+pub use dyn_trait::late_bound_wrapped_defaulted1 as lbwd1;\n+// @has user/fn.lbwl1.html\n+// @has - '//pre[@class=\"rust item-decl\"]' \"lbwl1<'l, 'm>(_: Ref<'l, dyn Trait + 'm>)\"\n+pub use dyn_trait::late_bound_wrapped_late1 as lbwl1;\n+// @has user/fn.lbwe.html\n+// @has - '//pre[@class=\"rust item-decl\"]' \"lbwe<'e, 'l>(_: Ref<'l, dyn Trait + 'e>)\"\n+pub use dyn_trait::late_bound_wrapped_early as lbwe;\n+// @has user/fn.ebwd.html\n+// @has - '//pre[@class=\"rust item-decl\"]' \"ebwd(_: Ref<'_, dyn Trait>)\"\n+pub use dyn_trait::elided_bound_wrapped_defaulted as ebwd;\n+// @has user/type.StaticBoundWrappedDefaulted0.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"Ref<'static, dyn Trait>;\"\n+pub use dyn_trait::StaticBoundWrappedDefaulted0;\n+// @has user/type.StaticBoundWrappedDefaulted1.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"&'static dyn Trait;\"\n+pub use dyn_trait::StaticBoundWrappedDefaulted1;\n+// @has user/type.AmbiguousBoundWrappedEarly0.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"AmbiguousBoundWrapper<'s, 'r, dyn Trait + 's>;\"\n+pub use dyn_trait::AmbiguousBoundWrappedEarly0;\n+// @has user/type.AmbiguousBoundWrappedEarly1.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"AmbiguousBoundWrapper<'s, 'r, dyn Trait + 'r>;\"\n+pub use dyn_trait::AmbiguousBoundWrappedEarly1;\n+// @has user/type.AmbiguousBoundWrappedStatic.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"AmbiguousBoundWrapper<'q, 'q, dyn Trait + 'static>;\"\n+pub use dyn_trait::AmbiguousBoundWrappedStatic;\n+\n+// @has user/type.NoBoundsWrappedDefaulted.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"Box<dyn Trait, Global>;\"\n+pub use dyn_trait::NoBoundsWrappedDefaulted;\n+// @has user/type.NoBoundsWrappedEarly.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"Box<dyn Trait + 'e, Global>;\"\n+pub use dyn_trait::NoBoundsWrappedEarly;\n+// @has user/fn.nbwl.html\n+// @has - '//pre[@class=\"rust item-decl\"]' \"nbwl<'l>(_: Box<dyn Trait + 'l, Global>)\"\n+pub use dyn_trait::no_bounds_wrapped_late as nbwl;\n+// @has user/fn.nbwel.html\n+// @has - '//pre[@class=\"rust item-decl\"]' \"nbwel(_: Box<dyn Trait + '_, Global>)\"\n+// NB: It might seem counterintuitive to display the explicitly elided lifetime `'_` here instead of\n+// eliding it but this behavior is correct: The default is `'static` here which != `'_`.\n+pub use dyn_trait::no_bounds_wrapped_elided as nbwel;\n \n-// @has user/fn.func1.html\n-// @has - '//pre[@class=\"rust item-decl\"]' \"func1<'func>(_: &(dyn Fn() + 'func))\"\n-pub use dyn_trait::func1;\n+// @has user/type.BareNoBoundsDefaulted.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn Trait;\"\n+pub use dyn_trait::BareNoBoundsDefaulted;\n+// @has user/type.BareNoBoundsEarly.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn Trait + 'p;\"\n+pub use dyn_trait::BareNoBoundsEarly;\n+// @has user/type.BareEarlyBoundDefaulted0.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn EarlyBoundTrait0<'u>;\"\n+pub use dyn_trait::BareEarlyBoundDefaulted0;\n+// @has user/type.BareEarlyBoundDefaulted1.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn for<'any> EarlyBoundTrait0<'any>;\"\n+pub use dyn_trait::BareEarlyBoundDefaulted1;\n+// @has user/type.BareEarlyBoundDefaulted2.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn EarlyBoundTrait1<'static, 'w>;\"\n+pub use dyn_trait::BareEarlyBoundDefaulted2;\n+// @has user/type.BareEarlyBoundEarly.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn EarlyBoundTrait0<'i> + 'j;\"\n+pub use dyn_trait::BareEarlyBoundEarly;\n+// @has user/type.BareEarlyBoundStatic.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn EarlyBoundTrait0<'i> + 'static;\"\n+pub use dyn_trait::BareEarlyBoundStatic;\n+// @has user/type.BareStaticBoundDefaulted.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn StaticBoundTrait;\"\n+pub use dyn_trait::BareStaticBoundDefaulted;\n+// @has user/type.BareHigherRankedBoundDefaulted0.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn HigherRankedBoundTrait0;\"\n+pub use dyn_trait::BareHigherRankedBoundDefaulted0;\n+// @has user/type.BareHigherRankedBoundDefaulted1.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn HigherRankedBoundTrait1<'r>;\"\n+pub use dyn_trait::BareHigherRankedBoundDefaulted1;\n+// @has user/type.BareAmbiguousBoundEarly0.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn AmbiguousBoundTrait<'m, 'n> + 'm;\"\n+pub use dyn_trait::BareAmbiguousBoundEarly0;\n+// @has user/type.BareAmbiguousBoundEarly1.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn AmbiguousBoundTrait<'m, 'n> + 'n;\"\n+pub use dyn_trait::BareAmbiguousBoundEarly1;\n+// @has user/type.BareAmbiguousBoundStatic.html\n+// @has - '//*[@class=\"rust item-decl\"]//code' \"dyn AmbiguousBoundTrait<'o, 'o> + 'static;\"\n+pub use dyn_trait::BareAmbiguousBoundStatic;"}]}