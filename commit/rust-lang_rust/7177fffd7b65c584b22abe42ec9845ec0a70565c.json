{"sha": "7177fffd7b65c584b22abe42ec9845ec0a70565c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNzdmZmZkN2I2NWM1ODRiMjJhYmU0MmVjOTg0NWVjMGE3MDU2NWM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-26T23:03:52Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-26T23:30:54Z"}, "message": "fix verification on CI\n\nremove `--verify` flag from the binaries: we have tests for this!", "tree": {"sha": "5234e75cdbc7be20be681d5f5565bd5287c66dc7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5234e75cdbc7be20be681d5f5565bd5287c66dc7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7177fffd7b65c584b22abe42ec9845ec0a70565c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7177fffd7b65c584b22abe42ec9845ec0a70565c", "html_url": "https://github.com/rust-lang/rust/commit/7177fffd7b65c584b22abe42ec9845ec0a70565c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7177fffd7b65c584b22abe42ec9845ec0a70565c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e40d8d40321b191ee82b8b07910f8a0898c8914c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e40d8d40321b191ee82b8b07910f8a0898c8914c", "html_url": "https://github.com/rust-lang/rust/commit/e40d8d40321b191ee82b8b07910f8a0898c8914c"}], "stats": {"total": 302, "additions": 123, "deletions": 179}, "files": [{"sha": "8d10a43f0076506bd1fa4a42f32cd3c2a589bf4e", "filename": ".travis.yml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7177fffd7b65c584b22abe42ec9845ec0a70565c/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7177fffd7b65c584b22abe42ec9845ec0a70565c/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=7177fffd7b65c584b22abe42ec9845ec0a70565c", "patch": "@@ -10,8 +10,6 @@ build: &rust_build\n     script:\n         - rustup component add rustfmt\n         - rustup component add rust-src\n-        - cargo gen-tests --verify\n-        - cargo gen-syntax --verify\n         - cargo test --no-run  # let's measure compile time separately\n         - cargo test\n     env:"}, {"sha": "3ace6533c4566285aba735b0e7db7d6b527f25c4", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7177fffd7b65c584b22abe42ec9845ec0a70565c/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7177fffd7b65c584b22abe42ec9845ec0a70565c/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=7177fffd7b65c584b22abe42ec9845ec0a70565c", "patch": "@@ -660,50 +660,6 @@ impl ToOwned for DynTraitType {\n \n impl DynTraitType {}\n \n-// ElseBranch\n-#[derive(Debug, PartialEq, Eq, Hash)]\n-#[repr(transparent)]\n-pub struct ElseBranch {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-unsafe impl TransparentNewType for ElseBranch {\n-    type Repr = rowan::SyntaxNode<RaTypes>;\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum ElseBranchKind<'a> {\n-    Block(&'a Block),\n-    IfExpr(&'a IfExpr),\n-}\n-\n-impl AstNode for ElseBranch {\n-    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n-        match syntax.kind() {\n-            | BLOCK\n-            | IF_EXPR => Some(ElseBranch::from_repr(syntax.into_repr())),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n-\n-impl ToOwned for ElseBranch {\n-    type Owned = TreeArc<ElseBranch>;\n-    fn to_owned(&self) -> TreeArc<ElseBranch> { TreeArc::cast(self.syntax.to_owned()) }\n-}\n-\n-impl ElseBranch {\n-    pub fn kind(&self) -> ElseBranchKind {\n-        match self.syntax.kind() {\n-            BLOCK => ElseBranchKind::Block(Block::cast(&self.syntax).unwrap()),\n-            IF_EXPR => ElseBranchKind::IfExpr(IfExpr::cast(&self.syntax).unwrap()),\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n-impl ElseBranch {}\n-\n // EnumDef\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]"}, {"sha": "e00bd0d3daa8f66e56afadcde670343a40070de4", "filename": "crates/tools/src/bin/pre-commit.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7177fffd7b65c584b22abe42ec9845ec0a70565c/crates%2Ftools%2Fsrc%2Fbin%2Fpre-commit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7177fffd7b65c584b22abe42ec9845ec0a70565c/crates%2Ftools%2Fsrc%2Fbin%2Fpre-commit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Fsrc%2Fbin%2Fpre-commit.rs?ref=7177fffd7b65c584b22abe42ec9845ec0a70565c", "patch": "@@ -1,10 +1,9 @@\n-use std::{\n-    process::{Command},\n-};\n+use std::process::Command;\n \n-use tools::{Result, run_rustfmt, run, project_root};\n use failure::bail;\n \n+use tools::{Result, run_rustfmt, run, project_root};\n+\n fn main() -> tools::Result<()> {\n     run_rustfmt(tools::Overwrite)?;\n     update_staged()"}, {"sha": "311bcb4d8f002096c92423a43f991a8aca7b0b30", "filename": "crates/tools/src/lib.rs", "status": "modified", "additions": 103, "deletions": 3, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/7177fffd7b65c584b22abe42ec9845ec0a70565c/crates%2Ftools%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7177fffd7b65c584b22abe42ec9845ec0a70565c/crates%2Ftools%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Fsrc%2Flib.rs?ref=7177fffd7b65c584b22abe42ec9845ec0a70565c", "patch": "@@ -1,7 +1,8 @@\n use std::{\n+    fs,\n+    collections::HashMap,\n     path::{Path, PathBuf},\n     process::{Command, Stdio},\n-    fs::copy,\n     io::{Error, ErrorKind}\n };\n \n@@ -13,6 +14,10 @@ pub use teraron::{Mode, Overwrite, Verify};\n pub type Result<T> = std::result::Result<T, failure::Error>;\n \n pub const GRAMMAR: &str = \"crates/ra_syntax/src/grammar.ron\";\n+const GRAMMAR_DIR: &str = \"crates/ra_syntax/src/grammar\";\n+const OK_INLINE_TESTS_DIR: &str = \"crates/ra_syntax/tests/data/parser/inline/ok\";\n+const ERR_INLINE_TESTS_DIR: &str = \"crates/ra_syntax/tests/data/parser/inline/err\";\n+\n pub const SYNTAX_KINDS: &str = \"crates/ra_syntax/src/syntax_kinds/generated.rs.tera\";\n pub const AST: &str = \"crates/ra_syntax/src/ast/generated.rs.tera\";\n const TOOLCHAIN: &str = \"stable\";\n@@ -130,9 +135,9 @@ pub fn install_format_hook() -> Result<()> {\n     if !result_path.exists() {\n         run(\"cargo build --package tools --bin pre-commit\", \".\")?;\n         if cfg!(windows) {\n-            copy(\"./target/debug/pre-commit.exe\", result_path)?;\n+            fs::copy(\"./target/debug/pre-commit.exe\", result_path)?;\n         } else {\n-            copy(\"./target/debug/pre-commit\", result_path)?;\n+            fs::copy(\"./target/debug/pre-commit\", result_path)?;\n         }\n     } else {\n         return Err(Error::new(ErrorKind::AlreadyExists, \"Git hook already created\").into());\n@@ -156,3 +161,98 @@ pub fn run_fuzzer() -> Result<()> {\n         \"./crates/ra_syntax\",\n     )\n }\n+\n+pub fn gen_tests(mode: Mode) -> Result<()> {\n+    let tests = tests_from_dir(&project_root().join(Path::new(GRAMMAR_DIR)))?;\n+    fn install_tests(tests: &HashMap<String, Test>, into: &str, mode: Mode) -> Result<()> {\n+        let tests_dir = project_root().join(into);\n+        if !tests_dir.is_dir() {\n+            fs::create_dir_all(&tests_dir)?;\n+        }\n+        // ok is never actually read, but it needs to be specified to create a Test in existing_tests\n+        let existing = existing_tests(&tests_dir, true)?;\n+        for t in existing.keys().filter(|&t| !tests.contains_key(t)) {\n+            panic!(\"Test is deleted: {}\", t);\n+        }\n+\n+        let mut new_idx = existing.len() + 1;\n+        for (name, test) in tests {\n+            let path = match existing.get(name) {\n+                Some((path, _test)) => path.clone(),\n+                None => {\n+                    let file_name = format!(\"{:04}_{}.rs\", new_idx, name);\n+                    new_idx += 1;\n+                    tests_dir.join(file_name)\n+                }\n+            };\n+            teraron::update(&path, &test.text, mode)?;\n+        }\n+        Ok(())\n+    }\n+    install_tests(&tests.ok, OK_INLINE_TESTS_DIR, mode)?;\n+    install_tests(&tests.err, ERR_INLINE_TESTS_DIR, mode)\n+}\n+\n+#[derive(Default, Debug)]\n+struct Tests {\n+    pub ok: HashMap<String, Test>,\n+    pub err: HashMap<String, Test>,\n+}\n+\n+fn tests_from_dir(dir: &Path) -> Result<Tests> {\n+    let mut res = Tests::default();\n+    for entry in ::walkdir::WalkDir::new(dir) {\n+        let entry = entry.unwrap();\n+        if !entry.file_type().is_file() {\n+            continue;\n+        }\n+        if entry.path().extension().unwrap_or_default() != \"rs\" {\n+            continue;\n+        }\n+        process_file(&mut res, entry.path())?;\n+    }\n+    let grammar_rs = dir.parent().unwrap().join(\"grammar.rs\");\n+    process_file(&mut res, &grammar_rs)?;\n+    return Ok(res);\n+    fn process_file(res: &mut Tests, path: &Path) -> Result<()> {\n+        let text = fs::read_to_string(path)?;\n+\n+        for (_, test) in collect_tests(&text) {\n+            if test.ok {\n+                if let Some(old_test) = res.ok.insert(test.name.clone(), test) {\n+                    bail!(\"Duplicate test: {}\", old_test.name)\n+                }\n+            } else {\n+                if let Some(old_test) = res.err.insert(test.name.clone(), test) {\n+                    bail!(\"Duplicate test: {}\", old_test.name)\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+fn existing_tests(dir: &Path, ok: bool) -> Result<HashMap<String, (PathBuf, Test)>> {\n+    let mut res = HashMap::new();\n+    for file in fs::read_dir(dir)? {\n+        let file = file?;\n+        let path = file.path();\n+        if path.extension().unwrap_or_default() != \"rs\" {\n+            continue;\n+        }\n+        let name = {\n+            let file_name = path.file_name().unwrap().to_str().unwrap();\n+            file_name[5..file_name.len() - 3].to_string()\n+        };\n+        let text = fs::read_to_string(&path)?;\n+        let test = Test {\n+            name: name.clone(),\n+            text,\n+            ok,\n+        };\n+        if let Some(old) = res.insert(name, (path, test)) {\n+            println!(\"Duplicate test: {:?}\", old);\n+        }\n+    }\n+    Ok(res)\n+}"}, {"sha": "c3e293911bec4f1ec1606bbdb7e0ee05128bf3c8", "filename": "crates/tools/src/main.rs", "status": "modified", "additions": 5, "deletions": 122, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/7177fffd7b65c584b22abe42ec9845ec0a70565c/crates%2Ftools%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7177fffd7b65c584b22abe42ec9845ec0a70565c/crates%2Ftools%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Fsrc%2Fmain.rs?ref=7177fffd7b65c584b22abe42ec9845ec0a70565c", "patch": "@@ -1,152 +1,35 @@\n-use std::{\n-    collections::HashMap,\n-    fs,\n-    path::{Path, PathBuf},\n-};\n-\n-use clap::{App, Arg, SubCommand};\n-use failure::bail;\n+use clap::{App, SubCommand};\n \n use tools::{\n-    collect_tests, generate,install_format_hook, run, run_rustfmt,\n-    Mode, Overwrite, Result, Test, Verify, project_root, run_fuzzer\n+    generate, gen_tests, install_format_hook, run, run_rustfmt,\n+    Overwrite, Result, run_fuzzer,\n };\n \n-const GRAMMAR_DIR: &str = \"crates/ra_syntax/src/grammar\";\n-const OK_INLINE_TESTS_DIR: &str = \"crates/ra_syntax/tests/data/parser/inline/ok\";\n-const ERR_INLINE_TESTS_DIR: &str = \"crates/ra_syntax/tests/data/parser/inline/err\";\n-\n fn main() -> Result<()> {\n     let matches = App::new(\"tasks\")\n         .setting(clap::AppSettings::SubcommandRequiredElseHelp)\n-        .arg(\n-            Arg::with_name(\"verify\")\n-                .long(\"--verify\")\n-                .help(\"Verify that generated code is up-to-date\")\n-                .global(true),\n-        )\n         .subcommand(SubCommand::with_name(\"gen-syntax\"))\n         .subcommand(SubCommand::with_name(\"gen-tests\"))\n         .subcommand(SubCommand::with_name(\"install-code\"))\n         .subcommand(SubCommand::with_name(\"format\"))\n         .subcommand(SubCommand::with_name(\"format-hook\"))\n         .subcommand(SubCommand::with_name(\"fuzz-tests\"))\n         .get_matches();\n-    let mode = if matches.is_present(\"verify\") {\n-        Verify\n-    } else {\n-        Overwrite\n-    };\n     match matches\n         .subcommand_name()\n         .expect(\"Subcommand must be specified\")\n     {\n         \"install-code\" => install_code_extension()?,\n-        \"gen-tests\" => gen_tests(mode)?,\n+        \"gen-tests\" => gen_tests(Overwrite)?,\n         \"gen-syntax\" => generate(Overwrite)?,\n-        \"format\" => run_rustfmt(mode)?,\n+        \"format\" => run_rustfmt(Overwrite)?,\n         \"format-hook\" => install_format_hook()?,\n         \"fuzz-tests\" => run_fuzzer()?,\n         _ => unreachable!(),\n     }\n     Ok(())\n }\n \n-fn gen_tests(mode: Mode) -> Result<()> {\n-    let tests = tests_from_dir(Path::new(GRAMMAR_DIR))?;\n-    fn install_tests(tests: &HashMap<String, Test>, into: &str, mode: Mode) -> Result<()> {\n-        let tests_dir = project_root().join(into);\n-        if !tests_dir.is_dir() {\n-            fs::create_dir_all(&tests_dir)?;\n-        }\n-        // ok is never actually read, but it needs to be specified to create a Test in existing_tests\n-        let existing = existing_tests(&tests_dir, true)?;\n-        for t in existing.keys().filter(|&t| !tests.contains_key(t)) {\n-            panic!(\"Test is deleted: {}\", t);\n-        }\n-\n-        let mut new_idx = existing.len() + 1;\n-        for (name, test) in tests {\n-            let path = match existing.get(name) {\n-                Some((path, _test)) => path.clone(),\n-                None => {\n-                    let file_name = format!(\"{:04}_{}.rs\", new_idx, name);\n-                    new_idx += 1;\n-                    tests_dir.join(file_name)\n-                }\n-            };\n-            teraron::update(&path, &test.text, mode)?;\n-        }\n-        Ok(())\n-    }\n-    install_tests(&tests.ok, OK_INLINE_TESTS_DIR, mode)?;\n-    install_tests(&tests.err, ERR_INLINE_TESTS_DIR, mode)\n-}\n-\n-#[derive(Default, Debug)]\n-struct Tests {\n-    pub ok: HashMap<String, Test>,\n-    pub err: HashMap<String, Test>,\n-}\n-\n-fn tests_from_dir(dir: &Path) -> Result<Tests> {\n-    let mut res = Tests::default();\n-    for entry in ::walkdir::WalkDir::new(dir) {\n-        let entry = entry.unwrap();\n-        if !entry.file_type().is_file() {\n-            continue;\n-        }\n-        if entry.path().extension().unwrap_or_default() != \"rs\" {\n-            continue;\n-        }\n-        process_file(&mut res, entry.path())?;\n-    }\n-    let grammar_rs = dir.parent().unwrap().join(\"grammar.rs\");\n-    process_file(&mut res, &grammar_rs)?;\n-    return Ok(res);\n-    fn process_file(res: &mut Tests, path: &Path) -> Result<()> {\n-        let text = fs::read_to_string(path)?;\n-\n-        for (_, test) in collect_tests(&text) {\n-            if test.ok {\n-                if let Some(old_test) = res.ok.insert(test.name.clone(), test) {\n-                    bail!(\"Duplicate test: {}\", old_test.name)\n-                }\n-            } else {\n-                if let Some(old_test) = res.err.insert(test.name.clone(), test) {\n-                    bail!(\"Duplicate test: {}\", old_test.name)\n-                }\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n-fn existing_tests(dir: &Path, ok: bool) -> Result<HashMap<String, (PathBuf, Test)>> {\n-    let mut res = HashMap::new();\n-    for file in fs::read_dir(dir)? {\n-        let file = file?;\n-        let path = file.path();\n-        if path.extension().unwrap_or_default() != \"rs\" {\n-            continue;\n-        }\n-        let name = {\n-            let file_name = path.file_name().unwrap().to_str().unwrap();\n-            file_name[5..file_name.len() - 3].to_string()\n-        };\n-        let text = fs::read_to_string(&path)?;\n-        let test = Test {\n-            name: name.clone(),\n-            text,\n-            ok,\n-        };\n-        if let Some(old) = res.insert(name, (path, test)) {\n-            println!(\"Duplicate test: {:?}\", old);\n-        }\n-    }\n-    Ok(res)\n-}\n-\n fn install_code_extension() -> Result<()> {\n     run(\"cargo install --path crates/ra_lsp_server --force\", \".\")?;\n     if cfg!(windows) {"}, {"sha": "2ee4b5223a54501669bfd166e7acb8cf742d5f44", "filename": "crates/tools/tests/cli.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7177fffd7b65c584b22abe42ec9845ec0a70565c/crates%2Ftools%2Ftests%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7177fffd7b65c584b22abe42ec9845ec0a70565c/crates%2Ftools%2Ftests%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Ftests%2Fcli.rs?ref=7177fffd7b65c584b22abe42ec9845ec0a70565c", "patch": "@@ -1,14 +1,22 @@\n-extern crate tools;\n-\n-use tools::{generate, run_rustfmt, Verify};\n+use tools::{generate, gen_tests, run_rustfmt, Verify};\n \n #[test]\n-fn verify_template_generation() {\n+fn generated_grammar_is_fresh() {\n     if let Err(error) = generate(Verify) {\n         panic!(\"{}. Please update it by running `cargo gen-syntax`\", error);\n     }\n }\n \n+#[test]\n+fn generated_tests_are_fresh() {\n+    if let Err(error) = gen_tests(Verify) {\n+        panic!(\n+            \"{}. Please update tests by running `cargo gen-tests`\",\n+            error\n+        );\n+    }\n+}\n+\n #[test]\n fn check_code_formatting() {\n     if let Err(error) = run_rustfmt(Verify) {"}]}