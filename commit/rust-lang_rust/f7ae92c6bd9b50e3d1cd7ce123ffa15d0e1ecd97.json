{"sha": "f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97", "node_id": "C_kwDOAAsO6NoAKGY3YWU5MmM2YmQ5YjUwZTNkMWNkN2NlMTIzZmZhMTVkMGUxZWNkOTc", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-06-30T09:48:54Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-06-30T09:48:54Z"}, "message": "std: use futex-based locks on Fuchsia", "tree": {"sha": "76e231cd7f81b42fb1cf7ad5448f8f22633fef63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76e231cd7f81b42fb1cf7ad5448f8f22633fef63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEVuz3PwcqDyifNyYbcE4BSbAZSzwFAmK9cYYACgkQcE4BSbAZ\nSzz1hw/+PghNA92ilI4SpOjnHV/EvhOGZumzkMeo2dNDUccnUoPGIxgAHfBHTIrk\nQmuAojw3v7lKy5KwQXGwBMHvT+Lrdz8y5qf7zWT31Us2zVB1n9hmi483DEZcGu1W\n70va7CEhlR3rG25r/hSf7MiCRMYrWgu6f+YLyV2HjJTvY8GT8P1E2QSs1FkOKXSt\ncKjeeI547GNiUp9/nNrGu/afzAO4ZCMH1h4eNBpJY+wPd2RpLw1CSHFRHdwJDigC\n+rDiPmhkTPD9Kcxs0th12Plmrpv20wyGlFEgQLVLGcKGyD91w4xOiqNiCfCQ4QxU\n9581TAeTS1RoQcTcct0I/BPt+WuGPXq5fJ7mNFQdVL2eifMVXXH+imbh5YcBbLoM\nYzcRQ2xDDtIBR7l2ru6eg3lGyvN+mINT44qcdgao4Ee+jAfuV7sF3SYZSBQhivOU\n2Z7NxbqudL//sLrHrucKfMF2rlQHX/GJSp+BVKbvl+037xTox/sINlSH3btWmIgw\nDlR/PLE7tnCZwx+JIsuDxHQtq1hQHKJhjcmktrSfcv4uRICVCMilF2/IQbIGh7gC\nQWC9mBW6kYqlvsqzxwH1c6jq+/tf8XxFmhzlxqZIL9fmugvkX6F8AUdXTHB6pEKC\nWVIn0eWQ41Mnszx8sfvTYSziQCrsUHTGHjSgssyLw9J45J3XiSM=\n=KdDa\n-----END PGP SIGNATURE-----", "payload": "tree 76e231cd7f81b42fb1cf7ad5448f8f22633fef63\nparent 00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e\nauthor joboet <jonasboettiger@icloud.com> 1656582534 +0200\ncommitter joboet <jonasboettiger@icloud.com> 1656582534 +0200\n\nstd: use futex-based locks on Fuchsia\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97", "html_url": "https://github.com/rust-lang/rust/commit/f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e", "html_url": "https://github.com/rust-lang/rust/commit/00ebeb87ac87a492bd59ace6bd43d6ad1629ca4e"}], "stats": {"total": 310, "additions": 246, "deletions": 64}, "files": [{"sha": "9480451fc5c86078894a176f30fb979edea0170d", "filename": "library/std/src/sys/unix/futex.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs?ref=f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97", "patch": "@@ -240,25 +240,31 @@ pub fn futex_wake_all(futex: &AtomicU32) {\n }\n \n #[cfg(target_os = \"fuchsia\")]\n-mod zircon {\n-    type zx_time_t = i64;\n-    type zx_futex_t = crate::sync::atomic::AtomicU32;\n-    type zx_handle_t = u32;\n-    type zx_status_t = i32;\n+pub mod zircon {\n+    pub type zx_futex_t = crate::sync::atomic::AtomicU32;\n+    pub type zx_handle_t = u32;\n+    pub type zx_status_t = i32;\n+    pub type zx_time_t = i64;\n \n     pub const ZX_HANDLE_INVALID: zx_handle_t = 0;\n-    pub const ZX_ERR_TIMED_OUT: zx_status_t = -21;\n+\n     pub const ZX_TIME_INFINITE: zx_time_t = zx_time_t::MAX;\n \n+    pub const ZX_OK: zx_status_t = 0;\n+    pub const ZX_ERR_BAD_STATE: zx_status_t = -20;\n+    pub const ZX_ERR_TIMED_OUT: zx_status_t = -21;\n+\n     extern \"C\" {\n+        pub fn zx_clock_get_monotonic() -> zx_time_t;\n         pub fn zx_futex_wait(\n             value_ptr: *const zx_futex_t,\n             current_value: zx_futex_t,\n             new_futex_owner: zx_handle_t,\n             deadline: zx_time_t,\n         ) -> zx_status_t;\n         pub fn zx_futex_wake(value_ptr: *const zx_futex_t, wake_count: u32) -> zx_status_t;\n-        pub fn zx_clock_get_monotonic() -> zx_time_t;\n+        pub fn zx_futex_wake_single_owner(value_ptr: *const zx_futex_t) -> zx_status_t;\n+        pub fn zx_thread_self() -> zx_handle_t;\n     }\n }\n \n@@ -287,3 +293,8 @@ pub fn futex_wake(futex: &AtomicU32) -> bool {\n     unsafe { zircon::zx_futex_wake(futex, 1) };\n     false\n }\n+\n+#[cfg(target_os = \"fuchsia\")]\n+pub fn futex_wake_all(futex: &AtomicU32) {\n+    unsafe { zircon::zx_futex_wake(futex, u32::MAX) };\n+}"}, {"sha": "412e7e0018b4897a0ed9cfff8c2461a4249d0a77", "filename": "library/std/src/sys/unix/locks/fuchsia_mutex.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffuchsia_mutex.rs?ref=f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97", "patch": "@@ -0,0 +1,158 @@\n+//! A priority inheriting mutex for Fuchsia.\n+//!\n+//! This is a port of the [mutex in Fuchsia's libsync]. Contrary to the original,\n+//! it does not abort the process when reentrant locking is detected, but deadlocks.\n+//!\n+//! Priority inheritance is achieved by storing the owning thread's handle in an\n+//! atomic variable. Fuchsia's futex operations support setting an owner thread\n+//! for a futex, which can boost that thread's priority while the futex is waited\n+//! upon.\n+//!\n+//! libsync is licenced under the following BSD-style licence:\n+//!\n+//! Copyright 2016 The Fuchsia Authors.\n+//!\n+//! Redistribution and use in source and binary forms, with or without\n+//! modification, are permitted provided that the following conditions are\n+//! met:\n+//!\n+//!    * Redistributions of source code must retain the above copyright\n+//!      notice, this list of conditions and the following disclaimer.\n+//!    * Redistributions in binary form must reproduce the above\n+//!      copyright notice, this list of conditions and the following\n+//!      disclaimer in the documentation and/or other materials provided\n+//!      with the distribution.\n+//!\n+//! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+//! \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+//! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+//! A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+//! OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+//! SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+//! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+//! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+//! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+//! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+//! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+//!\n+//! [mutex in Fuchsia's libsync]: https://cs.opensource.google/fuchsia/fuchsia/+/main:zircon/system/ulib/sync/mutex.c\n+\n+use crate::sync::atomic::{\n+    AtomicU32,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n+use crate::sys::futex::zircon::{\n+    zx_futex_wait, zx_futex_wake_single_owner, zx_handle_t, zx_thread_self, ZX_ERR_BAD_STATE,\n+    ZX_OK, ZX_TIME_INFINITE,\n+};\n+\n+// The lowest two bits of a `zx_handle_t` are always set, so the lowest bit is used to mark the\n+// mutex as contested by clearing it.\n+const CONTESTED_BIT: u32 = 1;\n+// This can never be a valid `zx_handle_t`.\n+const UNLOCKED: u32 = 0;\n+\n+pub type MovableMutex = Mutex;\n+\n+pub struct Mutex {\n+    futex: AtomicU32,\n+}\n+\n+#[inline]\n+fn to_state(owner: zx_handle_t) -> u32 {\n+    owner\n+}\n+\n+#[inline]\n+fn to_owner(state: u32) -> zx_handle_t {\n+    state | CONTESTED_BIT\n+}\n+\n+#[inline]\n+fn is_contested(state: u32) -> bool {\n+    state & CONTESTED_BIT == 0\n+}\n+\n+#[inline]\n+fn mark_contested(state: u32) -> u32 {\n+    state & !CONTESTED_BIT\n+}\n+\n+impl Mutex {\n+    #[inline]\n+    pub const fn new() -> Mutex {\n+        Mutex { futex: AtomicU32::new(UNLOCKED) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {}\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        let thread_self = zx_thread_self();\n+        self.futex.compare_exchange(UNLOCKED, to_state(thread_self), Acquire, Relaxed).is_ok()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        let thread_self = zx_thread_self();\n+        if let Err(state) =\n+            self.futex.compare_exchange(UNLOCKED, to_state(thread_self), Acquire, Relaxed)\n+        {\n+            self.lock_contested(state, thread_self);\n+        }\n+    }\n+\n+    #[cold]\n+    fn lock_contested(&self, mut state: u32, thread_self: zx_handle_t) {\n+        let owned_state = mark_contested(to_state(thread_self));\n+        loop {\n+            // Mark the mutex as contested if it is not already.\n+            let contested = mark_contested(state);\n+            if is_contested(state)\n+                || self.futex.compare_exchange(state, contested, Relaxed, Relaxed).is_ok()\n+            {\n+                // The mutex has been marked as contested, wait for the state to change.\n+                unsafe {\n+                    match zx_futex_wait(\n+                        &self.futex,\n+                        AtomicU32::new(contested),\n+                        to_owner(state),\n+                        ZX_TIME_INFINITE,\n+                    ) {\n+                        ZX_OK | ZX_ERR_BAD_STATE => (),\n+                        // Deadlock even in the case of reentrant locking, as leaking a guard\n+                        // could lead to the same condition if the thread id is reused, but\n+                        // panicking is not expected in that situation. This makes things\n+                        // quite a bit harder to debug, but encourages portable programming.\n+                        _ if to_owner(state) == thread_self => loop {},\n+                        error => panic!(\"futex operation failed with error code {error}\"),\n+                    }\n+                }\n+            }\n+\n+            // The state has changed or a wakeup occured, try to lock the mutex.\n+            match self.futex.compare_exchange(UNLOCKED, owned_state, Acquire, Relaxed) {\n+                Ok(_) => return,\n+                Err(updated) => state = updated,\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        if is_contested(self.futex.swap(UNLOCKED, Release)) {\n+            // The woken thread will mark the mutex as contested again,\n+            // and return here, waking until there are no waiters left,\n+            // in which case this is a noop.\n+            self.wake();\n+        }\n+    }\n+\n+    #[cold]\n+    fn wake(&self) {\n+        unsafe {\n+            zx_futex_wake_single_owner(&self.futex);\n+        }\n+    }\n+}"}, {"sha": "c0576c17880e1127f94add57997e2c9862c33b68", "filename": "library/std/src/sys/unix/locks/futex_condvar.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_condvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_condvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_condvar.rs?ref=f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97", "patch": "@@ -0,0 +1,58 @@\n+use super::Mutex;\n+use crate::sync::atomic::{AtomicU32, Ordering::Relaxed};\n+use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n+use crate::time::Duration;\n+\n+pub type MovableCondvar = Condvar;\n+\n+pub struct Condvar {\n+    // The value of this atomic is simply incremented on every notification.\n+    // This is used by `.wait()` to not miss any notifications after\n+    // unlocking the mutex and before waiting for notifications.\n+    futex: AtomicU32,\n+}\n+\n+impl Condvar {\n+    #[inline]\n+    pub const fn new() -> Self {\n+        Self { futex: AtomicU32::new(0) }\n+    }\n+\n+    // All the memory orderings here are `Relaxed`,\n+    // because synchronization is done by unlocking and locking the mutex.\n+\n+    pub unsafe fn notify_one(&self) {\n+        self.futex.fetch_add(1, Relaxed);\n+        futex_wake(&self.futex);\n+    }\n+\n+    pub unsafe fn notify_all(&self) {\n+        self.futex.fetch_add(1, Relaxed);\n+        futex_wake_all(&self.futex);\n+    }\n+\n+    pub unsafe fn wait(&self, mutex: &Mutex) {\n+        self.wait_optional_timeout(mutex, None);\n+    }\n+\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, timeout: Duration) -> bool {\n+        self.wait_optional_timeout(mutex, Some(timeout))\n+    }\n+\n+    unsafe fn wait_optional_timeout(&self, mutex: &Mutex, timeout: Option<Duration>) -> bool {\n+        // Examine the notification counter _before_ we unlock the mutex.\n+        let futex_value = self.futex.load(Relaxed);\n+\n+        // Unlock the mutex before going to sleep.\n+        mutex.unlock();\n+\n+        // Wait, but only if there hasn't been any\n+        // notification since we unlocked the mutex.\n+        let r = futex_wait(&self.futex, futex_value, timeout);\n+\n+        // Lock the mutex again.\n+        mutex.lock();\n+\n+        r\n+    }\n+}"}, {"sha": "99ba86e5f996dce0bb445c5e12c99d494b441fcf", "filename": "library/std/src/sys/unix/locks/futex_mutex.rs", "status": "renamed", "additions": 1, "deletions": 55, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_mutex.rs?ref=f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97", "patch": "@@ -2,11 +2,9 @@ use crate::sync::atomic::{\n     AtomicU32,\n     Ordering::{Acquire, Relaxed, Release},\n };\n-use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n-use crate::time::Duration;\n+use crate::sys::futex::{futex_wait, futex_wake};\n \n pub type MovableMutex = Mutex;\n-pub type MovableCondvar = Condvar;\n \n pub struct Mutex {\n     /// 0: unlocked\n@@ -101,55 +99,3 @@ impl Mutex {\n         futex_wake(&self.futex);\n     }\n }\n-\n-pub struct Condvar {\n-    // The value of this atomic is simply incremented on every notification.\n-    // This is used by `.wait()` to not miss any notifications after\n-    // unlocking the mutex and before waiting for notifications.\n-    futex: AtomicU32,\n-}\n-\n-impl Condvar {\n-    #[inline]\n-    pub const fn new() -> Self {\n-        Self { futex: AtomicU32::new(0) }\n-    }\n-\n-    // All the memory orderings here are `Relaxed`,\n-    // because synchronization is done by unlocking and locking the mutex.\n-\n-    pub unsafe fn notify_one(&self) {\n-        self.futex.fetch_add(1, Relaxed);\n-        futex_wake(&self.futex);\n-    }\n-\n-    pub unsafe fn notify_all(&self) {\n-        self.futex.fetch_add(1, Relaxed);\n-        futex_wake_all(&self.futex);\n-    }\n-\n-    pub unsafe fn wait(&self, mutex: &Mutex) {\n-        self.wait_optional_timeout(mutex, None);\n-    }\n-\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, timeout: Duration) -> bool {\n-        self.wait_optional_timeout(mutex, Some(timeout))\n-    }\n-\n-    unsafe fn wait_optional_timeout(&self, mutex: &Mutex, timeout: Option<Duration>) -> bool {\n-        // Examine the notification counter _before_ we unlock the mutex.\n-        let futex_value = self.futex.load(Relaxed);\n-\n-        // Unlock the mutex before going to sleep.\n-        mutex.unlock();\n-\n-        // Wait, but only if there hasn't been any\n-        // notification since we unlocked the mutex.\n-        let r = futex_wait(&self.futex, futex_value, timeout);\n-\n-        // Lock the mutex again.\n-        mutex.lock();\n-\n-        r\n-    }\n-}", "previous_filename": "library/std/src/sys/unix/locks/futex.rs"}, {"sha": "f5f92f693583003d2cc590fb802a73905b1b3b5f", "filename": "library/std/src/sys/unix/locks/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs?ref=f7ae92c6bd9b50e3d1cd7ce123ffa15d0e1ecd97", "patch": "@@ -7,10 +7,19 @@ cfg_if::cfg_if! {\n         target_os = \"openbsd\",\n         target_os = \"dragonfly\",\n     ))] {\n-        mod futex;\n+        mod futex_mutex;\n         mod futex_rwlock;\n-        pub(crate) use futex::{Mutex, MovableMutex, MovableCondvar};\n+        mod futex_condvar;\n+        pub(crate) use futex_mutex::{Mutex, MovableMutex};\n         pub(crate) use futex_rwlock::{RwLock, MovableRwLock};\n+        pub(crate) use futex_condvar::MovableCondvar;\n+    } else if #[cfg(target_os = \"fuchsia\")] {\n+        mod fuchsia_mutex;\n+        mod futex_rwlock;\n+        mod futex_condvar;\n+        pub(crate) use fuchsia_mutex::{Mutex, MovableMutex};\n+        pub(crate) use futex_rwlock::{RwLock, MovableRwLock};\n+        pub(crate) use futex_condvar::MovableCondvar;\n     } else {\n         mod pthread_mutex;\n         mod pthread_rwlock;"}]}