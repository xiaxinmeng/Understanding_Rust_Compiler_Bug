{"sha": "c2f3174a278d587666b51adafd47d6147e4fd707", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyZjMxNzRhMjc4ZDU4NzY2NmI1MWFkYWZkNDdkNjE0N2U0ZmQ3MDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-24T01:50:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-24T01:50:03Z"}, "message": "Auto merge of #63824 - Centril:split-feature_gate, r=oli-obk\n\nRefactor `feature_gate.rs` into modules & cleanup\n\nSplit `src/libsyntax/feature_gate.rs` into `src/libsyntax/feature_gate/` with files:\n- `accepted.rs` (accepted feature gates)\n- `removed.rs` (...)\n- `active.rs` (...)\n- `builtin_attrs.rs` (definition of builtin attributes and their gates as well as gating `cfg` flags)\n- `check.rs` (post expansion checking of feature gates)\n- `mod.rs` (just reexports)\n\nAdditionally, `tidy.rs` is adjusted to respect the new scheme.\n\nAlso, `builtin_attrs.rs` sees some cleanup, organization, and DSL-ification to reduce repetition.\n\nThis is probably best read commit-by-commit I think.\n\nr? @oli-obk", "tree": {"sha": "99ec100b3f529270ed29dfcec20e65203079c6c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99ec100b3f529270ed29dfcec20e65203079c6c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2f3174a278d587666b51adafd47d6147e4fd707", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2f3174a278d587666b51adafd47d6147e4fd707", "html_url": "https://github.com/rust-lang/rust/commit/c2f3174a278d587666b51adafd47d6147e4fd707", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2f3174a278d587666b51adafd47d6147e4fd707/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49935246829165b2c4c5c69f981a300bcaa83d7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/49935246829165b2c4c5c69f981a300bcaa83d7f", "html_url": "https://github.com/rust-lang/rust/commit/49935246829165b2c4c5c69f981a300bcaa83d7f"}, {"sha": "3e061f7c495138767a0f21ac6a56d81a9faf573d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e061f7c495138767a0f21ac6a56d81a9faf573d", "html_url": "https://github.com/rust-lang/rust/commit/3e061f7c495138767a0f21ac6a56d81a9faf573d"}], "stats": {"total": 4959, "additions": 2426, "deletions": 2533}, "files": [{"sha": "fad4f3da3de70b2d668a132b750149243a7dbca1", "filename": "src/libsyntax/feature_gate.rs", "status": "removed", "additions": 0, "deletions": 2498, "changes": 2498, "blob_url": "https://github.com/rust-lang/rust/blob/49935246829165b2c4c5c69f981a300bcaa83d7f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49935246829165b2c4c5c69f981a300bcaa83d7f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=49935246829165b2c4c5c69f981a300bcaa83d7f"}, {"sha": "32a0b76d5f0d836d257843f07443bf3ef67e54ae", "filename": "src/libsyntax/feature_gate/accepted.rs", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Flibsyntax%2Ffeature_gate%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Flibsyntax%2Ffeature_gate%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Faccepted.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -0,0 +1,236 @@\n+//! List of the accepted feature gates.\n+\n+use crate::symbol::{Symbol, sym};\n+\n+macro_rules! declare_features {\n+    ($((accepted, $feature: ident, $ver: expr, $issue: expr, None),)+) => {\n+        /// Those language feature has since been Accepted (it was once Active)\n+        pub const ACCEPTED_FEATURES: &[(Symbol, &str, Option<u32>, Option<&str>)] = &[\n+            $((sym::$feature, $ver, $issue, None)),+\n+        ];\n+    }\n+}\n+\n+declare_features! (\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: for testing purposes\n+    // -------------------------------------------------------------------------\n+\n+    // A temporary feature gate used to enable parser extensions needed\n+    // to bootstrap fix for #5723.\n+    (accepted, issue_5723_bootstrap, \"1.0.0\", None, None),\n+    // These are used to test this portion of the compiler,\n+    // they don't actually mean anything.\n+    (accepted, test_accepted_feature, \"1.0.0\", None, None),\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-end: for testing purposes\n+    // -------------------------------------------------------------------------\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: accepted features\n+    // -------------------------------------------------------------------------\n+\n+    // Allows using associated `type`s in `trait`s.\n+    (accepted, associated_types, \"1.0.0\", None, None),\n+    // Allows using assigning a default type to type parameters in algebraic data type definitions.\n+    (accepted, default_type_params, \"1.0.0\", None, None),\n+    // FIXME: explain `globs`.\n+    (accepted, globs, \"1.0.0\", None, None),\n+    // Allows `macro_rules!` items.\n+    (accepted, macro_rules, \"1.0.0\", None, None),\n+    // Allows use of `&foo[a..b]` as a slicing syntax.\n+    (accepted, slicing_syntax, \"1.0.0\", None, None),\n+    // Allows struct variants `Foo { baz: u8, .. }` in enums (RFC 418).\n+    (accepted, struct_variant, \"1.0.0\", None, None),\n+    // Allows indexing tuples.\n+    (accepted, tuple_indexing, \"1.0.0\", None, None),\n+    // Allows the use of `if let` expressions.\n+    (accepted, if_let, \"1.0.0\", None, None),\n+    // Allows the use of `while let` expressions.\n+    (accepted, while_let, \"1.0.0\", None, None),\n+    // Allows using `#![no_std]`.\n+    (accepted, no_std, \"1.6.0\", None, None),\n+    // Allows overloading augmented assignment operations like `a += b`.\n+    (accepted, augmented_assignments, \"1.8.0\", Some(28235), None),\n+    // Allows empty structs and enum variants with braces.\n+    (accepted, braced_empty_structs, \"1.8.0\", Some(29720), None),\n+    // Allows `#[deprecated]` attribute.\n+    (accepted, deprecated, \"1.9.0\", Some(29935), None),\n+    // Allows macros to appear in the type position.\n+    (accepted, type_macros, \"1.13.0\", Some(27245), None),\n+    // Allows use of the postfix `?` operator in expressions.\n+    (accepted, question_mark, \"1.13.0\", Some(31436), None),\n+    // Allows `..` in tuple (struct) patterns.\n+    (accepted, dotdot_in_tuple_patterns, \"1.14.0\", Some(33627), None),\n+    // Allows some increased flexibility in the name resolution rules,\n+    // especially around globs and shadowing (RFC 1560).\n+    (accepted, item_like_imports, \"1.15.0\", Some(35120), None),\n+    // Allows using `Self` and associated types in struct expressions and patterns.\n+    (accepted, more_struct_aliases, \"1.16.0\", Some(37544), None),\n+    // Allows elision of `'static` lifetimes in `static`s and `const`s.\n+    (accepted, static_in_const, \"1.17.0\", Some(35897), None),\n+    // Allows field shorthands (`x` meaning `x: x`) in struct literal expressions.\n+    (accepted, field_init_shorthand, \"1.17.0\", Some(37340), None),\n+    // Allows the definition recursive static items.\n+    (accepted, static_recursion, \"1.17.0\", Some(29719), None),\n+    // Allows `pub(restricted)` visibilities (RFC 1422).\n+    (accepted, pub_restricted, \"1.18.0\", Some(32409), None),\n+    // Allows `#![windows_subsystem]`.\n+    (accepted, windows_subsystem, \"1.18.0\", Some(37499), None),\n+    // Allows `break {expr}` with a value inside `loop`s.\n+    (accepted, loop_break_value, \"1.19.0\", Some(37339), None),\n+    // Allows numeric fields in struct expressions and patterns.\n+    (accepted, relaxed_adts, \"1.19.0\", Some(35626), None),\n+    // Allows coercing non capturing closures to function pointers.\n+    (accepted, closure_to_fn_coercion, \"1.19.0\", Some(39817), None),\n+    // Allows attributes on struct literal fields.\n+    (accepted, struct_field_attributes, \"1.20.0\", Some(38814), None),\n+    // Allows the definition of associated constants in `trait` or `impl` blocks.\n+    (accepted, associated_consts, \"1.20.0\", Some(29646), None),\n+    // Allows usage of the `compile_error!` macro.\n+    (accepted, compile_error, \"1.20.0\", Some(40872), None),\n+    // Allows code like `let x: &'static u32 = &42` to work (RFC 1414).\n+    (accepted, rvalue_static_promotion, \"1.21.0\", Some(38865), None),\n+    // Allows `Drop` types in constants (RFC 1440).\n+    (accepted, drop_types_in_const, \"1.22.0\", Some(33156), None),\n+    // Allows the sysV64 ABI to be specified on all platforms\n+    // instead of just the platforms on which it is the C ABI.\n+    (accepted, abi_sysv64, \"1.24.0\", Some(36167), None),\n+    // Allows `repr(align(16))` struct attribute (RFC 1358).\n+    (accepted, repr_align, \"1.25.0\", Some(33626), None),\n+    // Allows '|' at beginning of match arms (RFC 1925).\n+    (accepted, match_beginning_vert, \"1.25.0\", Some(44101), None),\n+    // Allows nested groups in `use` items (RFC 2128).\n+    (accepted, use_nested_groups, \"1.25.0\", Some(44494), None),\n+    // Allows indexing into constant arrays.\n+    (accepted, const_indexing, \"1.26.0\", Some(29947), None),\n+    // Allows using `a..=b` and `..=b` as inclusive range syntaxes.\n+    (accepted, inclusive_range_syntax, \"1.26.0\", Some(28237), None),\n+    // Allows `..=` in patterns (RFC 1192).\n+    (accepted, dotdoteq_in_patterns, \"1.26.0\", Some(28237), None),\n+    // Allows `fn main()` with return types which implements `Termination` (RFC 1937).\n+    (accepted, termination_trait, \"1.26.0\", Some(43301), None),\n+    // Allows implementing `Clone` for closures where possible (RFC 2132).\n+    (accepted, clone_closures, \"1.26.0\", Some(44490), None),\n+    // Allows implementing `Copy` for closures where possible (RFC 2132).\n+    (accepted, copy_closures, \"1.26.0\", Some(44490), None),\n+    // Allows `impl Trait` in function arguments.\n+    (accepted, universal_impl_trait, \"1.26.0\", Some(34511), None),\n+    // Allows `impl Trait` in function return types.\n+    (accepted, conservative_impl_trait, \"1.26.0\", Some(34511), None),\n+    // Allows using the `u128` and `i128` types.\n+    (accepted, i128_type, \"1.26.0\", Some(35118), None),\n+    // Allows default match binding modes (RFC 2005).\n+    (accepted, match_default_bindings, \"1.26.0\", Some(42640), None),\n+    // Allows `'_` placeholder lifetimes.\n+    (accepted, underscore_lifetimes, \"1.26.0\", Some(44524), None),\n+    // Allows attributes on lifetime/type formal parameters in generics (RFC 1327).\n+    (accepted, generic_param_attrs, \"1.27.0\", Some(48848), None),\n+    // Allows `cfg(target_feature = \"...\")`.\n+    (accepted, cfg_target_feature, \"1.27.0\", Some(29717), None),\n+    // Allows `#[target_feature(...)]`.\n+    (accepted, target_feature, \"1.27.0\", None, None),\n+    // Allows using `dyn Trait` as a syntax for trait objects.\n+    (accepted, dyn_trait, \"1.27.0\", Some(44662), None),\n+    // Allows `#[must_use]` on functions, and introduces must-use operators (RFC 1940).\n+    (accepted, fn_must_use, \"1.27.0\", Some(43302), None),\n+    // Allows use of the `:lifetime` macro fragment specifier.\n+    (accepted, macro_lifetime_matcher, \"1.27.0\", Some(34303), None),\n+    // Allows `#[test]` functions where the return type implements `Termination` (RFC 1937).\n+    (accepted, termination_trait_test, \"1.27.0\", Some(48854), None),\n+    // Allows the `#[global_allocator]` attribute.\n+    (accepted, global_allocator, \"1.28.0\", Some(27389), None),\n+    // Allows `#[repr(transparent)]` attribute on newtype structs.\n+    (accepted, repr_transparent, \"1.28.0\", Some(43036), None),\n+    // Allows procedural macros in `proc-macro` crates.\n+    (accepted, proc_macro, \"1.29.0\", Some(38356), None),\n+    // Allows `foo.rs` as an alternative to `foo/mod.rs`.\n+    (accepted, non_modrs_mods, \"1.30.0\", Some(44660), None),\n+    // Allows use of the `:vis` macro fragment specifier\n+    (accepted, macro_vis_matcher, \"1.30.0\", Some(41022), None),\n+    // Allows importing and reexporting macros with `use`,\n+    // enables macro modularization in general.\n+    (accepted, use_extern_macros, \"1.30.0\", Some(35896), None),\n+    // Allows keywords to be escaped for use as identifiers.\n+    (accepted, raw_identifiers, \"1.30.0\", Some(48589), None),\n+    // Allows attributes scoped to tools.\n+    (accepted, tool_attributes, \"1.30.0\", Some(44690), None),\n+    // Allows multi-segment paths in attributes and derives.\n+    (accepted, proc_macro_path_invoc, \"1.30.0\", Some(38356), None),\n+    // Allows all literals in attribute lists and values of key-value pairs.\n+    (accepted, attr_literals, \"1.30.0\", Some(34981), None),\n+    // Allows inferring outlives requirements (RFC 2093).\n+    (accepted, infer_outlives_requirements, \"1.30.0\", Some(44493), None),\n+    // Allows annotating functions conforming to `fn(&PanicInfo) -> !` with `#[panic_handler]`.\n+    // This defines the behavior of panics.\n+    (accepted, panic_handler, \"1.30.0\", Some(44489), None),\n+    // Allows `#[used]` to preserve symbols (see llvm.used).\n+    (accepted, used, \"1.30.0\", Some(40289), None),\n+    // Allows `crate` in paths.\n+    (accepted, crate_in_paths, \"1.30.0\", Some(45477), None),\n+    // Allows resolving absolute paths as paths from other crates.\n+    (accepted, extern_absolute_paths, \"1.30.0\", Some(44660), None),\n+    // Allows access to crate names passed via `--extern` through prelude.\n+    (accepted, extern_prelude, \"1.30.0\", Some(44660), None),\n+    // Allows parentheses in patterns.\n+    (accepted, pattern_parentheses, \"1.31.0\", Some(51087), None),\n+    // Allows the definition of `const fn` functions.\n+    (accepted, min_const_fn, \"1.31.0\", Some(53555), None),\n+    // Allows scoped lints.\n+    (accepted, tool_lints, \"1.31.0\", Some(44690), None),\n+    // Allows lifetime elision in `impl` headers. For example:\n+    // + `impl<I:Iterator> Iterator for &mut Iterator`\n+    // + `impl Debug for Foo<'_>`\n+    (accepted, impl_header_lifetime_elision, \"1.31.0\", Some(15872), None),\n+    // Allows `extern crate foo as bar;`. This puts `bar` into extern prelude.\n+    (accepted, extern_crate_item_prelude, \"1.31.0\", Some(55599), None),\n+    // Allows use of the `:literal` macro fragment specifier (RFC 1576).\n+    (accepted, macro_literal_matcher, \"1.32.0\", Some(35625), None),\n+    // Allows use of `?` as the Kleene \"at most one\" operator in macros.\n+    (accepted, macro_at_most_once_rep, \"1.32.0\", Some(48075), None),\n+    // Allows `Self` struct constructor (RFC 2302).\n+    (accepted, self_struct_ctor, \"1.32.0\", Some(51994), None),\n+    // Allows `Self` in type definitions (RFC 2300).\n+    (accepted, self_in_typedefs, \"1.32.0\", Some(49303), None),\n+    // Allows `use x::y;` to search `x` in the current scope.\n+    (accepted, uniform_paths, \"1.32.0\", Some(53130), None),\n+    // Allows integer match exhaustiveness checking (RFC 2591).\n+    (accepted, exhaustive_integer_patterns, \"1.33.0\", Some(50907), None),\n+    // Allows `use path as _;` and `extern crate c as _;`.\n+    (accepted, underscore_imports, \"1.33.0\", Some(48216), None),\n+    // Allows `#[repr(packed(N))]` attribute on structs.\n+    (accepted, repr_packed, \"1.33.0\", Some(33158), None),\n+    // Allows irrefutable patterns in `if let` and `while let` statements (RFC 2086).\n+    (accepted, irrefutable_let_patterns, \"1.33.0\", Some(44495), None),\n+    // Allows calling `const unsafe fn` inside `unsafe` blocks in `const fn` functions.\n+    (accepted, min_const_unsafe_fn, \"1.33.0\", Some(55607), None),\n+    // Allows let bindings, assignments and destructuring in `const` functions and constants.\n+    // As long as control flow is not implemented in const eval, `&&` and `||` may not be used\n+    // at the same time as let bindings.\n+    (accepted, const_let, \"1.33.0\", Some(48821), None),\n+    // Allows `#[cfg_attr(predicate, multiple, attributes, here)]`.\n+    (accepted, cfg_attr_multi, \"1.33.0\", Some(54881), None),\n+    // Allows top level or-patterns (`p | q`) in `if let` and `while let`.\n+    (accepted, if_while_or_patterns, \"1.33.0\", Some(48215), None),\n+    // Allows `cfg(target_vendor = \"...\")`.\n+    (accepted, cfg_target_vendor, \"1.33.0\", Some(29718), None),\n+    // Allows `extern crate self as foo;`.\n+    // This puts local crate root into extern prelude under name `foo`.\n+    (accepted, extern_crate_self, \"1.34.0\", Some(56409), None),\n+    // Allows arbitrary delimited token streams in non-macro attributes.\n+    (accepted, unrestricted_attribute_tokens, \"1.34.0\", Some(55208), None),\n+    // Allows paths to enum variants on type aliases including `Self`.\n+    (accepted, type_alias_enum_variants, \"1.37.0\", Some(49683), None),\n+    // Allows using `#[repr(align(X))]` on enums with equivalent semantics\n+    // to wrapping an enum in a wrapper struct with `#[repr(align(X))]`.\n+    (accepted, repr_align_enum, \"1.37.0\", Some(57996), None),\n+    // Allows `const _: TYPE = VALUE`.\n+    (accepted, underscore_const_names, \"1.37.0\", Some(54912), None),\n+    // Allows free and inherent `async fn`s, `async` blocks, and `<expr>.await` expressions.\n+    (accepted, async_await, \"1.39.0\", Some(50547), None),\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-end: accepted features\n+    // -------------------------------------------------------------------------\n+);"}, {"sha": "0bff4ed24a4ce44988191865fb988d42f5d4af7e", "filename": "src/libsyntax/feature_gate/active.rs", "status": "added", "additions": 522, "deletions": 0, "changes": 522, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Flibsyntax%2Ffeature_gate%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Factive.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -0,0 +1,522 @@\n+//! List of the active feature gates.\n+\n+use crate::edition::Edition;\n+use crate::symbol::{Symbol, sym};\n+use syntax_pos::Span;\n+\n+macro_rules! set {\n+    ($field: ident) => {{\n+        fn f(features: &mut Features, _: Span) {\n+            features.$field = true;\n+        }\n+        f as fn(&mut Features, Span)\n+    }}\n+}\n+\n+macro_rules! declare_features {\n+    ($((active, $feature: ident, $ver: expr, $issue: expr, $edition: expr),)+) => {\n+        /// Represents active features that are currently being implemented or\n+        /// currently being considered for addition/removal.\n+        pub const ACTIVE_FEATURES:\n+            &[(Symbol, &str, Option<u32>, Option<Edition>, fn(&mut Features, Span))] =\n+            &[$((sym::$feature, $ver, $issue, $edition, set!($feature))),+];\n+\n+        /// A set of features to be used by later passes.\n+        #[derive(Clone)]\n+        pub struct Features {\n+            /// `#![feature]` attrs for language features, for error reporting\n+            pub declared_lang_features: Vec<(Symbol, Span, Option<Symbol>)>,\n+            /// `#![feature]` attrs for non-language (library) features\n+            pub declared_lib_features: Vec<(Symbol, Span)>,\n+            $(pub $feature: bool),+\n+        }\n+\n+        impl Features {\n+            pub fn new() -> Features {\n+                Features {\n+                    declared_lang_features: Vec::new(),\n+                    declared_lib_features: Vec::new(),\n+                    $($feature: false),+\n+                }\n+            }\n+\n+            pub fn walk_feature_fields<F>(&self, mut f: F)\n+                where F: FnMut(&str, bool)\n+            {\n+                $(f(stringify!($feature), self.$feature);)+\n+            }\n+        }\n+    };\n+}\n+\n+// If you change this, please modify `src/doc/unstable-book` as well.\n+//\n+// Don't ever remove anything from this list; move them to `removed.rs`.\n+//\n+// The version numbers here correspond to the version in which the current status\n+// was set. This is most important for knowing when a particular feature became\n+// stable (active).\n+//\n+// Note that the features are grouped into internal/user-facing and then\n+// sorted by version inside those groups. This is inforced with tidy.\n+//\n+// N.B., `tools/tidy/src/features.rs` parses this information directly out of the\n+// source, so take care when modifying it.\n+\n+declare_features! (\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: internal feature gates\n+    // -------------------------------------------------------------------------\n+\n+    // no-tracking-issue-start\n+\n+    // Allows using compiler's own crates.\n+    (active, rustc_private, \"1.0.0\", Some(27812), None),\n+\n+    // Allows using the `rust-intrinsic`'s \"ABI\".\n+    (active, intrinsics, \"1.0.0\", None, None),\n+\n+    // Allows using `#[lang = \"..\"]` attribute for linking items to special compiler logic.\n+    (active, lang_items, \"1.0.0\", None, None),\n+\n+    // Allows using the `#[stable]` and `#[unstable]` attributes.\n+    (active, staged_api, \"1.0.0\", None, None),\n+\n+    // Allows using `#[allow_internal_unstable]`. This is an\n+    // attribute on `macro_rules!` and can't use the attribute handling\n+    // below (it has to be checked before expansion possibly makes\n+    // macros disappear).\n+    (active, allow_internal_unstable, \"1.0.0\", None, None),\n+\n+    // Allows using `#[allow_internal_unsafe]`. This is an\n+    // attribute on `macro_rules!` and can't use the attribute handling\n+    // below (it has to be checked before expansion possibly makes\n+    // macros disappear).\n+    (active, allow_internal_unsafe, \"1.0.0\", None, None),\n+\n+    // Allows using the macros:\n+    // + `__diagnostic_used`\n+    // + `__register_diagnostic`\n+    // +`__build_diagnostic_array`\n+    (active, rustc_diagnostic_macros, \"1.0.0\", None, None),\n+\n+    // Allows using `#[rustc_const_unstable(feature = \"foo\", ..)]` which\n+    // lets a function to be `const` when opted into with `#![feature(foo)]`.\n+    (active, rustc_const_unstable, \"1.0.0\", None, None),\n+\n+    // no-tracking-issue-end\n+\n+    // Allows using `#[link_name=\"llvm.*\"]`.\n+    (active, link_llvm_intrinsics, \"1.0.0\", Some(29602), None),\n+\n+    // Allows using `rustc_*` attributes (RFC 572).\n+    (active, rustc_attrs, \"1.0.0\", Some(29642), None),\n+\n+    // Allows using `#[on_unimplemented(..)]` on traits.\n+    (active, on_unimplemented, \"1.0.0\", Some(29628), None),\n+\n+    // Allows using the `box $expr` syntax.\n+    (active, box_syntax, \"1.0.0\", Some(49733), None),\n+\n+    // Allows using `#[main]` to replace the entrypoint `#[lang = \"start\"]` calls.\n+    (active, main, \"1.0.0\", Some(29634), None),\n+\n+    // Allows using `#[start]` on a function indicating that it is the program entrypoint.\n+    (active, start, \"1.0.0\", Some(29633), None),\n+\n+    // Allows using the `#[fundamental]` attribute.\n+    (active, fundamental, \"1.0.0\", Some(29635), None),\n+\n+    // Allows using the `rust-call` ABI.\n+    (active, unboxed_closures, \"1.0.0\", Some(29625), None),\n+\n+    // Allows using the `#[linkage = \"..\"]` attribute.\n+    (active, linkage, \"1.0.0\", Some(29603), None),\n+\n+    // Allows features specific to OIBIT (auto traits).\n+    (active, optin_builtin_traits, \"1.0.0\", Some(13231), None),\n+\n+    // Allows using `box` in patterns (RFC 469).\n+    (active, box_patterns, \"1.0.0\", Some(29641), None),\n+\n+    // no-tracking-issue-start\n+\n+    // Allows using `#[prelude_import]` on glob `use` items.\n+    (active, prelude_import, \"1.2.0\", None, None),\n+\n+    // no-tracking-issue-end\n+\n+    // no-tracking-issue-start\n+\n+    // Allows using `#[omit_gdb_pretty_printer_section]`.\n+    (active, omit_gdb_pretty_printer_section, \"1.5.0\", None, None),\n+\n+    // Allows using the `vectorcall` ABI.\n+    (active, abi_vectorcall, \"1.7.0\", None, None),\n+\n+    // no-tracking-issue-end\n+\n+    // Allows using `#[structural_match]` which indicates that a type is structurally matchable.\n+    (active, structural_match, \"1.8.0\", Some(31434), None),\n+\n+    // Allows using the `may_dangle` attribute (RFC 1327).\n+    (active, dropck_eyepatch, \"1.10.0\", Some(34761), None),\n+\n+    // Allows using the `#![panic_runtime]` attribute.\n+    (active, panic_runtime, \"1.10.0\", Some(32837), None),\n+\n+    // Allows declaring with `#![needs_panic_runtime]` that a panic runtime is needed.\n+    (active, needs_panic_runtime, \"1.10.0\", Some(32837), None),\n+\n+    // no-tracking-issue-start\n+\n+    // Allows identifying the `compiler_builtins` crate.\n+    (active, compiler_builtins, \"1.13.0\", None, None),\n+\n+    // Allows using the `unadjusted` ABI; perma-unstable.\n+    (active, abi_unadjusted, \"1.16.0\", None, None),\n+\n+    // Allows identifying crates that contain sanitizer runtimes.\n+    (active, sanitizer_runtime, \"1.17.0\", None, None),\n+\n+    // Used to identify crates that contain the profiler runtime.\n+    (active, profiler_runtime, \"1.18.0\", None, None),\n+\n+    // Allows using the `thiscall` ABI.\n+    (active, abi_thiscall, \"1.19.0\", None, None),\n+\n+    // Allows using `#![needs_allocator]`, an implementation detail of `#[global_allocator]`.\n+    (active, allocator_internals, \"1.20.0\", None, None),\n+\n+    // no-tracking-issue-end\n+\n+    // Added for testing E0705; perma-unstable.\n+    (active, test_2018_feature, \"1.31.0\", Some(0), Some(Edition::Edition2018)),\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-end: internal feature gates\n+    // -------------------------------------------------------------------------\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: actual feature gates (target features)\n+    // -------------------------------------------------------------------------\n+\n+    // FIXME: Document these and merge with the list below.\n+\n+    // Unstable `#[target_feature]` directives.\n+    (active, arm_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, aarch64_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, hexagon_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, powerpc_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, mips_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, avx512_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, mmx_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, sse4a_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, tbm_target_feature, \"1.27.0\", Some(44839), None),\n+    (active, wasm_target_feature, \"1.30.0\", Some(44839), None),\n+    (active, adx_target_feature, \"1.32.0\", Some(44839), None),\n+    (active, cmpxchg16b_target_feature, \"1.32.0\", Some(44839), None),\n+    (active, movbe_target_feature, \"1.34.0\", Some(44839), None),\n+    (active, rtm_target_feature, \"1.35.0\", Some(44839), None),\n+    (active, f16c_target_feature, \"1.36.0\", Some(44839), None),\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-end: actual feature gates (target features)\n+    // -------------------------------------------------------------------------\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: actual feature gates\n+    // -------------------------------------------------------------------------\n+\n+    // Allows using the `#[link_args]` attribute.\n+    (active, link_args, \"1.0.0\", Some(29596), None),\n+\n+    // Allows defining identifiers beyond ASCII.\n+    (active, non_ascii_idents, \"1.0.0\", Some(55467), None),\n+\n+    // Allows using `#[plugin_registrar]` on functions.\n+    (active, plugin_registrar, \"1.0.0\", Some(29597), None),\n+\n+    // Allows using `#![plugin(myplugin)]`.\n+    (active, plugin, \"1.0.0\", Some(29597), None),\n+\n+    // Allows using `#[thread_local]` on `static` items.\n+    (active, thread_local, \"1.0.0\", Some(29594), None),\n+\n+    // Allows the use of SIMD types in functions declared in `extern` blocks.\n+    (active, simd_ffi, \"1.0.0\", Some(27731), None),\n+\n+    // Allows using custom attributes (RFC 572).\n+    (active, custom_attribute, \"1.0.0\", Some(29642), None),\n+\n+    // Allows using non lexical lifetimes (RFC 2094).\n+    (active, nll, \"1.0.0\", Some(43234), None),\n+\n+    // Allows using slice patterns.\n+    (active, slice_patterns, \"1.0.0\", Some(62254), None),\n+\n+    // Allows the definition of `const` functions with some advanced features.\n+    (active, const_fn, \"1.2.0\", Some(57563), None),\n+\n+    // Allows associated type defaults.\n+    (active, associated_type_defaults, \"1.2.0\", Some(29661), None),\n+\n+    // Allows `#![no_core]`.\n+    (active, no_core, \"1.3.0\", Some(29639), None),\n+\n+    // Allows default type parameters to influence type inference.\n+    (active, default_type_parameter_fallback, \"1.3.0\", Some(27336), None),\n+\n+    // Allows `repr(simd)` and importing the various simd intrinsics.\n+    (active, repr_simd, \"1.4.0\", Some(27731), None),\n+\n+    // Allows `extern \"platform-intrinsic\" { ... }`.\n+    (active, platform_intrinsics, \"1.4.0\", Some(27731), None),\n+\n+    // Allows `#[unwind(..)]`.\n+    //\n+    // Permits specifying whether a function should permit unwinding or abort on unwind.\n+    (active, unwind_attributes, \"1.4.0\", Some(58760), None),\n+\n+    // Allows `#[no_debug]`.\n+    (active, no_debug, \"1.5.0\", Some(29721), None),\n+\n+    // Allows attributes on expressions and non-item statements.\n+    (active, stmt_expr_attributes, \"1.6.0\", Some(15701), None),\n+\n+    // Allows the use of type ascription in expressions.\n+    (active, type_ascription, \"1.6.0\", Some(23416), None),\n+\n+    // Allows `cfg(target_thread_local)`.\n+    (active, cfg_target_thread_local, \"1.7.0\", Some(29594), None),\n+\n+    // Allows specialization of implementations (RFC 1210).\n+    (active, specialization, \"1.7.0\", Some(31844), None),\n+\n+    // Allows using `#[naked]` on functions.\n+    (active, naked_functions, \"1.9.0\", Some(32408), None),\n+\n+    // Allows `cfg(target_has_atomic = \"...\")`.\n+    (active, cfg_target_has_atomic, \"1.9.0\", Some(32976), None),\n+\n+    // Allows `X..Y` patterns.\n+    (active, exclusive_range_pattern, \"1.11.0\", Some(37854), None),\n+\n+    // Allows the `!` type. Does not imply 'exhaustive_patterns' (below) any more.\n+    (active, never_type, \"1.13.0\", Some(35121), None),\n+\n+    // Allows exhaustive pattern matching on types that contain uninhabited types.\n+    (active, exhaustive_patterns, \"1.13.0\", Some(51085), None),\n+\n+    // Allows untagged unions `union U { ... }`.\n+    (active, untagged_unions, \"1.13.0\", Some(32836), None),\n+\n+    // Allows `#[link(..., cfg(..))]`.\n+    (active, link_cfg, \"1.14.0\", Some(37406), None),\n+\n+    // Allows `extern \"ptx-*\" fn()`.\n+    (active, abi_ptx, \"1.15.0\", Some(38788), None),\n+\n+    // Allows the `#[repr(i128)]` attribute for enums.\n+    (active, repr128, \"1.16.0\", Some(35118), None),\n+\n+    // Allows `#[link(kind=\"static-nobundle\"...)]`.\n+    (active, static_nobundle, \"1.16.0\", Some(37403), None),\n+\n+    // Allows `extern \"msp430-interrupt\" fn()`.\n+    (active, abi_msp430_interrupt, \"1.16.0\", Some(38487), None),\n+\n+    // Allows declarative macros 2.0 (`macro`).\n+    (active, decl_macro, \"1.17.0\", Some(39412), None),\n+\n+    // Allows `extern \"x86-interrupt\" fn()`.\n+    (active, abi_x86_interrupt, \"1.17.0\", Some(40180), None),\n+\n+    // Allows overlapping impls of marker traits.\n+    (active, overlapping_marker_traits, \"1.18.0\", Some(29864), None),\n+\n+    // Allows a test to fail without failing the whole suite.\n+    (active, allow_fail, \"1.19.0\", Some(46488), None),\n+\n+    // Allows unsized tuple coercion.\n+    (active, unsized_tuple_coercion, \"1.20.0\", Some(42877), None),\n+\n+    // Allows defining generators.\n+    (active, generators, \"1.21.0\", Some(43122), None),\n+\n+    // Allows `#[doc(cfg(...))]`.\n+    (active, doc_cfg, \"1.21.0\", Some(43781), None),\n+\n+    // Allows `#[doc(masked)]`.\n+    (active, doc_masked, \"1.21.0\", Some(44027), None),\n+\n+    // Allows `#[doc(spotlight)]`.\n+    (active, doc_spotlight, \"1.22.0\", Some(45040), None),\n+\n+    // Allows `#[doc(include = \"some-file\")]`.\n+    (active, external_doc, \"1.22.0\", Some(44732), None),\n+\n+    // Allows future-proofing enums/structs with the `#[non_exhaustive]` attribute (RFC 2008).\n+    (active, non_exhaustive, \"1.22.0\", Some(44109), None),\n+\n+    // Allows using `crate` as visibility modifier, synonymous with `pub(crate)`.\n+    (active, crate_visibility_modifier, \"1.23.0\", Some(53120), None),\n+\n+    // Allows defining `extern type`s.\n+    (active, extern_types, \"1.23.0\", Some(43467), None),\n+\n+    // Allows trait methods with arbitrary self types.\n+    (active, arbitrary_self_types, \"1.23.0\", Some(44874), None),\n+\n+    // Allows in-band quantification of lifetime bindings (e.g., `fn foo(x: &'a u8) -> &'a u8`).\n+    (active, in_band_lifetimes, \"1.23.0\", Some(44524), None),\n+\n+    // Allows associated types to be generic, e.g., `type Foo<T>;` (RFC 1598).\n+    (active, generic_associated_types, \"1.23.0\", Some(44265), None),\n+\n+    // Allows defining `trait X = A + B;` alias items.\n+    (active, trait_alias, \"1.24.0\", Some(41517), None),\n+\n+    // Allows infering `'static` outlives requirements (RFC 2093).\n+    (active, infer_static_outlives_requirements, \"1.26.0\", Some(54185), None),\n+\n+    // Allows macro invocations in `extern {}` blocks.\n+    (active, macros_in_extern, \"1.27.0\", Some(49476), None),\n+\n+    // Allows accessing fields of unions inside `const` functions.\n+    (active, const_fn_union, \"1.27.0\", Some(51909), None),\n+\n+    // Allows casting raw pointers to `usize` during const eval.\n+    (active, const_raw_ptr_to_usize_cast, \"1.27.0\", Some(51910), None),\n+\n+    // Allows dereferencing raw pointers during const eval.\n+    (active, const_raw_ptr_deref, \"1.27.0\", Some(51911), None),\n+\n+    // Allows comparing raw pointers during const eval.\n+    (active, const_compare_raw_pointers, \"1.27.0\", Some(53020), None),\n+\n+    // Allows `#[doc(alias = \"...\")]`.\n+    (active, doc_alias, \"1.27.0\", Some(50146), None),\n+\n+    // Allows inconsistent bounds in where clauses.\n+    (active, trivial_bounds, \"1.28.0\", Some(48214), None),\n+\n+    // Allows `'a: { break 'a; }`.\n+    (active, label_break_value, \"1.28.0\", Some(48594), None),\n+\n+    // Allows using `#[doc(keyword = \"...\")]`.\n+    (active, doc_keyword, \"1.28.0\", Some(51315), None),\n+\n+    // Allows reinterpretation of the bits of a value of one type as another type during const eval.\n+    (active, const_transmute, \"1.29.0\", Some(53605), None),\n+\n+    // Allows using `try {...}` expressions.\n+    (active, try_blocks, \"1.29.0\", Some(31436), None),\n+\n+    // Allows defining an `#[alloc_error_handler]`.\n+    (active, alloc_error_handler, \"1.29.0\", Some(51540), None),\n+\n+    // Allows using the `amdgpu-kernel` ABI.\n+    (active, abi_amdgpu_kernel, \"1.29.0\", Some(51575), None),\n+\n+    // Allows panicking during const eval (producing compile-time errors).\n+    (active, const_panic, \"1.30.0\", Some(51999), None),\n+\n+    // Allows `#[marker]` on certain traits allowing overlapping implementations.\n+    (active, marker_trait_attr, \"1.30.0\", Some(29864), None),\n+\n+    // Allows macro invocations on modules expressions and statements and\n+    // procedural macros to expand to non-items.\n+    (active, proc_macro_hygiene, \"1.30.0\", Some(54727), None),\n+\n+    // Allows unsized rvalues at arguments and parameters.\n+    (active, unsized_locals, \"1.30.0\", Some(48055), None),\n+\n+    // Allows custom test frameworks with `#![test_runner]` and `#[test_case]`.\n+    (active, custom_test_frameworks, \"1.30.0\", Some(50297), None),\n+\n+    // Allows non-builtin attributes in inner attribute position.\n+    (active, custom_inner_attributes, \"1.30.0\", Some(54726), None),\n+\n+    // Allows mixing bind-by-move in patterns and references to those identifiers in guards.\n+    (active, bind_by_move_pattern_guards, \"1.30.0\", Some(15287), None),\n+\n+    // Allows `impl Trait` in bindings (`let`, `const`, `static`).\n+    (active, impl_trait_in_bindings, \"1.30.0\", Some(63065), None),\n+\n+    // Allows using `reason` in lint attributes and the `#[expect(lint)]` lint check.\n+    (active, lint_reasons, \"1.31.0\", Some(54503), None),\n+\n+    // Allows exhaustive integer pattern matching on `usize` and `isize`.\n+    (active, precise_pointer_size_matching, \"1.32.0\", Some(56354), None),\n+\n+    // Allows relaxing the coherence rules such that\n+    // `impl<T> ForeignTrait<LocalType> for ForeignType<T> is permitted.\n+    (active, re_rebalance_coherence, \"1.32.0\", Some(55437), None),\n+\n+    // Allows using `#[ffi_returns_twice]` on foreign functions.\n+    (active, ffi_returns_twice, \"1.34.0\", Some(58314), None),\n+\n+    // Allows const generic types (e.g. `struct Foo<const N: usize>(...);`).\n+    (active, const_generics, \"1.34.0\", Some(44580), None),\n+\n+    // Allows using `#[optimize(X)]`.\n+    (active, optimize_attribute, \"1.34.0\", Some(54882), None),\n+\n+    // Allows using C-variadics.\n+    (active, c_variadic, \"1.34.0\", Some(44930), None),\n+\n+    // Allows the user of associated type bounds.\n+    (active, associated_type_bounds, \"1.34.0\", Some(52662), None),\n+\n+    // Attributes on formal function params.\n+    (active, param_attrs, \"1.36.0\", Some(60406), None),\n+\n+    // Allows calling constructor functions in `const fn`.\n+    (active, const_constructor, \"1.37.0\", Some(61456), None),\n+\n+    // Allows `if/while p && let q = r && ...` chains.\n+    (active, let_chains, \"1.37.0\", Some(53667), None),\n+\n+    // Allows #[repr(transparent)] on enums (RFC 2645).\n+    (active, transparent_enums, \"1.37.0\", Some(60405), None),\n+\n+    // Allows #[repr(transparent)] on unions (RFC 2645).\n+    (active, transparent_unions, \"1.37.0\", Some(60405), None),\n+\n+    // Allows explicit discriminants on non-unit enum variants.\n+    (active, arbitrary_enum_discriminant, \"1.37.0\", Some(60553), None),\n+\n+    // Allows `impl Trait` with multiple unrelated lifetimes.\n+    (active, member_constraints, \"1.37.0\", Some(61977), None),\n+\n+    // Allows `async || body` closures.\n+    (active, async_closure, \"1.37.0\", Some(62290), None),\n+\n+    // Allows the use of `#[cfg(doctest)]`, set when rustdoc is collecting doctests\n+    (active, cfg_doctest, \"1.37.0\", Some(62210), None),\n+\n+    // Allows `[x; N]` where `x` is a constant (RFC 2203).\n+    (active, const_in_array_repeat_expressions, \"1.37.0\", Some(49147), None),\n+\n+    // Allows `impl Trait` to be used inside type aliases (RFC 2515).\n+    (active, type_alias_impl_trait, \"1.38.0\", Some(63063), None),\n+\n+    // Allows the use of or-patterns, e.g. `0 | 1`.\n+    (active, or_patterns, \"1.38.0\", Some(54883), None),\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-end: actual feature gates\n+    // -------------------------------------------------------------------------\n+);\n+\n+/// Some features are known to be incomplete and using them is likely to have\n+/// unanticipated results, such as compiler crashes. We warn the user about these\n+/// to alert them.\n+pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n+    sym::impl_trait_in_bindings,\n+    sym::generic_associated_types,\n+    sym::const_generics,\n+    sym::or_patterns,\n+    sym::let_chains,\n+];"}, {"sha": "b934f2e7f64efef80dc9b46d4faedaa4a69f30b1", "filename": "src/libsyntax/feature_gate/builtin_attrs.rs", "status": "added", "additions": 562, "deletions": 0, "changes": 562, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -0,0 +1,562 @@\n+//! Built-in attributes and `cfg` flag gating.\n+\n+use AttributeType::*;\n+use AttributeGate::*;\n+\n+use super::check::{emit_feature_err, GateIssue};\n+use super::check::{Stability, EXPLAIN_ALLOW_INTERNAL_UNSAFE, EXPLAIN_ALLOW_INTERNAL_UNSTABLE};\n+use super::active::Features;\n+\n+use crate::ast;\n+use crate::attr::AttributeTemplate;\n+use crate::symbol::{Symbol, sym};\n+use crate::parse::ParseSess;\n+\n+use syntax_pos::Span;\n+use rustc_data_structures::fx::FxHashMap;\n+use lazy_static::lazy_static;\n+\n+type GateFn = fn(&Features) -> bool;\n+\n+macro_rules! cfg_fn {\n+    ($field: ident) => {\n+        (|features| { features.$field }) as GateFn\n+    }\n+}\n+\n+/// `cfg(...)`'s that are feature gated.\n+const GATED_CFGS: &[(Symbol, Symbol, GateFn)] = &[\n+    // (name in cfg, feature, function to check if the feature is enabled)\n+    (sym::target_thread_local, sym::cfg_target_thread_local, cfg_fn!(cfg_target_thread_local)),\n+    (sym::target_has_atomic, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n+    (sym::rustdoc, sym::doc_cfg, cfg_fn!(doc_cfg)),\n+    (sym::doctest, sym::cfg_doctest, cfg_fn!(cfg_doctest)),\n+];\n+\n+#[derive(Debug)]\n+pub struct GatedCfg {\n+    span: Span,\n+    index: usize,\n+}\n+\n+impl GatedCfg {\n+    pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n+        GATED_CFGS.iter()\n+                  .position(|info| cfg.check_name(info.0))\n+                  .map(|idx| {\n+                      GatedCfg {\n+                          span: cfg.span,\n+                          index: idx\n+                      }\n+                  })\n+    }\n+\n+    pub fn check_and_emit(&self, sess: &ParseSess, features: &Features) {\n+        let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n+        if !has_feature(features) && !self.span.allows_unstable(feature) {\n+            let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n+            emit_feature_err(sess, feature, self.span, GateIssue::Language, &explain);\n+        }\n+    }\n+}\n+\n+// If you change this, please modify `src/doc/unstable-book` as well. You must\n+// move that documentation into the relevant place in the other docs, and\n+// remove the chapter on the flag.\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum AttributeType {\n+    /// Normal, builtin attribute that is consumed\n+    /// by the compiler before the unused_attribute check\n+    Normal,\n+\n+    /// Builtin attribute that may not be consumed by the compiler\n+    /// before the unused_attribute check. These attributes\n+    /// will be ignored by the unused_attribute lint\n+    Whitelisted,\n+\n+    /// Builtin attribute that is only allowed at the crate level\n+    CrateLevel,\n+}\n+\n+pub enum AttributeGate {\n+    /// Is gated by a given feature gate, reason\n+    /// and function to check if enabled\n+    Gated(Stability, Symbol, &'static str, fn(&Features) -> bool),\n+\n+    /// Ungated attribute, can be used on all release channels\n+    Ungated,\n+}\n+\n+// fn() is not Debug\n+impl std::fmt::Debug for AttributeGate {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match *self {\n+            Self::Gated(ref stab, name, expl, _) =>\n+                write!(fmt, \"Gated({:?}, {}, {})\", stab, name, expl),\n+            Self::Ungated => write!(fmt, \"Ungated\")\n+        }\n+    }\n+}\n+\n+impl AttributeGate {\n+    fn is_deprecated(&self) -> bool {\n+        match *self {\n+            Self::Gated(Stability::Deprecated(_, _), ..) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+/// A convenience macro for constructing attribute templates.\n+/// E.g., `template!(Word, List: \"description\")` means that the attribute\n+/// supports forms `#[attr]` and `#[attr(description)]`.\n+macro_rules! template {\n+    (Word) => { template!(@ true, None, None) };\n+    (List: $descr: expr) => { template!(@ false, Some($descr), None) };\n+    (NameValueStr: $descr: expr) => { template!(@ false, None, Some($descr)) };\n+    (Word, List: $descr: expr) => { template!(@ true, Some($descr), None) };\n+    (Word, NameValueStr: $descr: expr) => { template!(@ true, None, Some($descr)) };\n+    (List: $descr1: expr, NameValueStr: $descr2: expr) => {\n+        template!(@ false, Some($descr1), Some($descr2))\n+    };\n+    (Word, List: $descr1: expr, NameValueStr: $descr2: expr) => {\n+        template!(@ true, Some($descr1), Some($descr2))\n+    };\n+    (@ $word: expr, $list: expr, $name_value_str: expr) => { AttributeTemplate {\n+        word: $word, list: $list, name_value_str: $name_value_str\n+    } };\n+}\n+\n+macro_rules! ungated {\n+    ($attr:ident, $typ:expr, $tpl:expr $(,)?) => {\n+        (sym::$attr, $typ, $tpl, Ungated)\n+    };\n+}\n+\n+macro_rules! gated {\n+    ($attr:ident, $typ:expr, $tpl:expr, $gate:ident, $msg:expr $(,)?) => {\n+        (sym::$attr, $typ, $tpl, Gated(Stability::Unstable, sym::$gate, $msg, cfg_fn!($gate)))\n+    };\n+    ($attr:ident, $typ:expr, $tpl:expr, $msg:expr $(,)?) => {\n+        (sym::$attr, $typ, $tpl, Gated(Stability::Unstable, sym::$attr, $msg, cfg_fn!($attr)))\n+    };\n+}\n+\n+macro_rules! rustc_attr {\n+    (TEST, $attr:ident, $typ:expr, $tpl:expr $(,)?) => {\n+        rustc_attr!(\n+            $attr, $typ, $tpl,\n+            concat!(\"the `#[\", stringify!($attr), \"]` attribute is just used for rustc unit tests \\\n+                and will never be stable\",\n+            ),\n+        )\n+    };\n+    ($attr:ident, $typ:expr, $tpl:expr, $msg:expr $(,)?) => {\n+        (sym::$attr, $typ, $tpl,\n+         Gated(Stability::Unstable, sym::rustc_attrs, $msg, cfg_fn!(rustc_attrs)))\n+    };\n+}\n+\n+macro_rules! experimental {\n+    ($attr:ident) => {\n+        concat!(\"the `#[\", stringify!($attr), \"]` attribute is an experimental feature\")\n+    }\n+}\n+\n+const IMPL_DETAIL: &str = \"internal implementation detail\";\n+const INTERAL_UNSTABLE: &str = \"this is an internal attribute that will never be stable\";\n+\n+pub type BuiltinAttribute = (Symbol, AttributeType, AttributeTemplate, AttributeGate);\n+\n+/// Attributes that have a special meaning to rustc or rustdoc\n+pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n+    // ==========================================================================\n+    // Stable attributes:\n+    // ==========================================================================\n+\n+    // Condtional compilation:\n+    ungated!(cfg, Normal, template!(List: \"predicate\")),\n+    ungated!(cfg_attr, Normal, template!(List: \"predicate, attr1, attr2, ...\")),\n+\n+    // Testing:\n+    ungated!(ignore, Normal, template!(Word, NameValueStr: \"reason\")),\n+    ungated!(\n+        should_panic, Normal,\n+        template!(Word, List: r#\"expected = \"reason\"#, NameValueStr: \"reason\"),\n+    ),\n+    // FIXME(Centril): This can be used on stable but shouldn't.\n+    ungated!(reexport_test_harness_main, Normal, template!(NameValueStr: \"name\")),\n+\n+    // Macros:\n+    ungated!(derive, Normal, template!(List: \"Trait1, Trait2, ...\")),\n+    ungated!(automatically_derived, Normal, template!(Word)),\n+    // FIXME(#14407)\n+    ungated!(macro_use, Normal, template!(Word, List: \"name1, name2, ...\")),\n+    ungated!(macro_escape, Normal, template!(Word)), // Deprecated synonym for `macro_use`.\n+    ungated!(macro_export, Normal, template!(Word, List: \"local_inner_macros\")),\n+    ungated!(proc_macro, Normal, template!(Word)),\n+    ungated!(\n+        proc_macro_derive, Normal,\n+        template!(List: \"TraitName, /*opt*/ attributes(name1, name2, ...)\"),\n+    ),\n+    ungated!(proc_macro_attribute, Normal, template!(Word)),\n+\n+    // Lints:\n+    ungated!(warn, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#)),\n+    ungated!(allow, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#)),\n+    ungated!(forbid, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#)),\n+    ungated!(deny, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#)),\n+    ungated!(must_use, Whitelisted, template!(Word, NameValueStr: \"reason\")),\n+    // FIXME(#14407)\n+    ungated!(\n+        deprecated, Normal,\n+        template!(\n+            Word,\n+            List: r#\"/*opt*/ since = \"version\", /*opt*/ note = \"reason\"\"#,\n+            NameValueStr: \"reason\"\n+        ),\n+    ),\n+\n+    // Crate properties:\n+    ungated!(crate_name, CrateLevel, template!(NameValueStr: \"name\")),\n+    ungated!(crate_type, CrateLevel, template!(NameValueStr: \"bin|lib|...\")),\n+    ungated!(crate_id, CrateLevel, template!(NameValueStr: \"ignored\")),\n+\n+    // ABI, linking, symbols, and FFI\n+    ungated!(\n+        link, Whitelisted,\n+        template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\", /*opt*/ cfg = \"...\"\"#),\n+    ),\n+    ungated!(link_name, Whitelisted, template!(NameValueStr: \"name\")),\n+    ungated!(no_link, Normal, template!(Word)),\n+    ungated!(repr, Normal, template!(List: \"C, packed, ...\")),\n+    ungated!(export_name, Whitelisted, template!(NameValueStr: \"name\")),\n+    ungated!(link_section, Whitelisted, template!(NameValueStr: \"name\")),\n+    ungated!(no_mangle, Whitelisted, template!(Word)),\n+    ungated!(used, Whitelisted, template!(Word)),\n+\n+    // Limits:\n+    ungated!(recursion_limit, CrateLevel, template!(NameValueStr: \"N\")),\n+    ungated!(type_length_limit, CrateLevel, template!(NameValueStr: \"N\")),\n+\n+    // Entry point:\n+    ungated!(main, Normal, template!(Word)),\n+    ungated!(start, Normal, template!(Word)),\n+    ungated!(no_start, CrateLevel, template!(Word)),\n+    ungated!(no_main, CrateLevel, template!(Word)),\n+\n+    // Modules, prelude, and resolution:\n+    ungated!(path, Normal, template!(NameValueStr: \"file\")),\n+    ungated!(no_std, CrateLevel, template!(Word)),\n+    ungated!(no_implicit_prelude, Normal, template!(Word)),\n+\n+    // Runtime\n+    ungated!(windows_subsystem, Whitelisted, template!(NameValueStr: \"windows|console\")),\n+    ungated!(panic_handler, Normal, template!(Word)), // RFC 2070\n+\n+    // Code generation:\n+    ungated!(inline, Whitelisted, template!(Word, List: \"always|never\")),\n+    ungated!(cold, Whitelisted, template!(Word)),\n+    ungated!(no_builtins, Whitelisted, template!(Word)),\n+    ungated!(target_feature, Whitelisted, template!(List: r#\"enable = \"name\"\"#)),\n+\n+    // FIXME: #14408 whitelist docs since rustdoc looks at them\n+    ungated!(doc, Whitelisted, template!(List: \"hidden|inline|...\", NameValueStr: \"string\")),\n+\n+    // ==========================================================================\n+    // Unstable attributes:\n+    // ==========================================================================\n+\n+    // Linking:\n+    gated!(naked, Whitelisted, template!(Word), naked_functions, experimental!(naked)),\n+    gated!(\n+        link_args, Normal, template!(NameValueStr: \"args\"),\n+        \"the `link_args` attribute is experimental and not portable across platforms, \\\n+        it is recommended to use `#[link(name = \\\"foo\\\")] instead\",\n+    ),\n+\n+    // Plugins:\n+    ungated!(plugin_registrar, Normal, template!(Word)),\n+    gated!(\n+        plugin, CrateLevel, template!(List: \"name|name(args)\"),\n+        \"compiler plugins are experimental and possibly buggy\",\n+    ),\n+\n+    // Testing:\n+    gated!(allow_fail, Normal, template!(Word), experimental!(allow_fail)),\n+    gated!(\n+        test_runner, CrateLevel, template!(List: \"path\"), custom_test_frameworks,\n+        \"custom test frameworks are an unstable feature\",\n+    ),\n+\n+    // RFC #2008\n+    gated!(non_exhaustive, Whitelisted, template!(Word), experimental!(non_exhaustive)),\n+    // RFC #1268\n+    gated!(marker, Normal, template!(Word), marker_trait_attr, experimental!(marker)),\n+    gated!(\n+        thread_local, Whitelisted, template!(Word),\n+        \"`#[thread_local]` is an experimental feature, and does not currently handle destructors\",\n+    ),\n+    gated!(no_core, CrateLevel, template!(Word), experimental!(no_core)),\n+    // RFC 2412\n+    gated!(\n+        optimize, Whitelisted, template!(List: \"size|speed\"), optimize_attribute,\n+        experimental!(optimize),\n+    ),\n+\n+    gated!(ffi_returns_twice, Whitelisted, template!(Word), experimental!(ffi_returns_twice)),\n+\n+    // ==========================================================================\n+    // Internal attributes: Stability, deprecation, and unsafe:\n+    // ==========================================================================\n+\n+    ungated!(feature, CrateLevel, template!(List: \"name1, name1, ...\")),\n+    // FIXME(#14407) -- only looked at on-demand so we can't\n+    // guarantee they'll have already been checked.\n+    ungated!(\n+        rustc_deprecated, Whitelisted,\n+        template!(List: r#\"since = \"version\", reason = \"...\"\"#)\n+    ),\n+    // FIXME(#14407)\n+    ungated!(stable, Whitelisted, template!(List: r#\"feature = \"name\", since = \"version\"\"#)),\n+    // FIXME(#14407)\n+    ungated!(\n+        unstable, Whitelisted,\n+        template!(List: r#\"feature = \"name\", reason = \"...\", issue = \"N\"\"#),\n+    ),\n+    gated!(\n+        rustc_const_unstable, Normal, template!(List: r#\"feature = \"name\"\"#),\n+        \"the `#[rustc_const_unstable]` attribute is an internal feature\",\n+    ),\n+    gated!(\n+        allow_internal_unstable, Normal, template!(Word, List: \"feat1, feat2, ...\"),\n+        EXPLAIN_ALLOW_INTERNAL_UNSTABLE,\n+    ),\n+    gated!(allow_internal_unsafe, Normal, template!(Word), EXPLAIN_ALLOW_INTERNAL_UNSAFE),\n+\n+    // ==========================================================================\n+    // Internal attributes: Type system related:\n+    // ==========================================================================\n+\n+    gated!(fundamental, Whitelisted, template!(Word), experimental!(fundamental)),\n+    gated!(\n+        // RFC #1445.\n+        structural_match, Whitelisted, template!(Word),\n+        \"the semantics of constant patterns is not yet settled\",\n+    ),\n+    gated!(\n+        may_dangle, Normal, template!(Word), dropck_eyepatch,\n+        \"`may_dangle` has unstable semantics and may be removed in the future\",\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes: Runtime related:\n+    // ==========================================================================\n+\n+    rustc_attr!(rustc_allocator, Whitelisted, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_allocator_nounwind, Whitelisted, template!(Word), IMPL_DETAIL),\n+    gated!(alloc_error_handler, Normal, template!(Word), experimental!(alloc_error_handler)),\n+    gated!(\n+        default_lib_allocator, Whitelisted, template!(Word), allocator_internals,\n+        experimental!(default_lib_allocator),\n+    ),\n+    gated!(\n+        needs_allocator, Normal, template!(Word), allocator_internals,\n+        experimental!(needs_allocator),\n+    ),\n+    gated!(panic_runtime, Whitelisted, template!(Word), experimental!(panic_runtime)),\n+    gated!(needs_panic_runtime, Whitelisted, template!(Word), experimental!(needs_panic_runtime)),\n+    gated!(\n+        unwind, Whitelisted, template!(List: \"allowed|aborts\"), unwind_attributes,\n+        experimental!(unwind),\n+    ),\n+    gated!(\n+        compiler_builtins, Whitelisted, template!(Word),\n+        \"the `#[compiler_builtins]` attribute is used to identify the `compiler_builtins` crate \\\n+        which contains compiler-rt intrinsics and will never be stable\",\n+    ),\n+    gated!(\n+        sanitizer_runtime, Whitelisted, template!(Word),\n+        \"the `#[sanitizer_runtime]` attribute is used to identify crates that contain the runtime \\\n+        of a sanitizer and will never be stable\",\n+    ),\n+    gated!(\n+        profiler_runtime, Whitelisted, template!(Word),\n+        \"the `#[profiler_runtime]` attribute is used to identify the `profiler_builtins` crate \\\n+        which contains the profiler runtime and will never be stable\",\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes, Linkage:\n+    // ==========================================================================\n+\n+    gated!(\n+        linkage, Whitelisted, template!(NameValueStr: \"external|internal|...\"),\n+        \"the `linkage` attribute is experimental and not portable across platforms\",\n+    ),\n+    rustc_attr!(rustc_std_internal_symbol, Whitelisted, template!(Word), INTERAL_UNSTABLE),\n+\n+    // ==========================================================================\n+    // Internal attributes, Macro related:\n+    // ==========================================================================\n+\n+    rustc_attr!(rustc_builtin_macro, Whitelisted, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_proc_macro_decls, Normal, template!(Word), INTERAL_UNSTABLE),\n+    rustc_attr!(\n+        rustc_macro_transparency, Whitelisted,\n+        template!(NameValueStr: \"transparent|semitransparent|opaque\"),\n+        \"used internally for testing macro hygiene\",\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes, Diagnostics related:\n+    // ==========================================================================\n+\n+    gated!(\n+        rustc_on_unimplemented, Whitelisted,\n+        template!(\n+            List: r#\"/*opt*/ message = \"...\", /*opt*/ label = \"...\", /*opt*/ note = \"...\"\"#,\n+            NameValueStr: \"message\"\n+        ),\n+        on_unimplemented,\n+        experimental!(rustc_on_unimplemented),\n+    ),\n+    // Whitelists \"identity-like\" conversion methods to suggest on type mismatch.\n+    rustc_attr!(rustc_conversion_suggestion, Whitelisted, template!(Word), INTERAL_UNSTABLE),\n+\n+    // ==========================================================================\n+    // Internal attributes, Const related:\n+    // ==========================================================================\n+\n+    rustc_attr!(rustc_promotable, Whitelisted, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_allow_const_fn_ptr, Whitelisted, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_args_required_const, Whitelisted, template!(List: \"N\"), INTERAL_UNSTABLE),\n+\n+    // ==========================================================================\n+    // Internal attributes, Layout related:\n+    // ==========================================================================\n+\n+    rustc_attr!(\n+        rustc_layout_scalar_valid_range_start, Whitelisted, template!(List: \"value\"),\n+        \"the `#[rustc_layout_scalar_valid_range_start]` attribute is just used to enable \\\n+        niche optimizations in libcore and will never be stable\",\n+    ),\n+    rustc_attr!(\n+        rustc_layout_scalar_valid_range_end, Whitelisted, template!(List: \"value\"),\n+        \"the `#[rustc_layout_scalar_valid_range_end]` attribute is just used to enable \\\n+        niche optimizations in libcore and will never be stable\",\n+    ),\n+    rustc_attr!(\n+        rustc_nonnull_optimization_guaranteed, Whitelisted, template!(Word),\n+        \"the `#[rustc_nonnull_optimization_guaranteed]` attribute is just used to enable \\\n+        niche optimizations in libcore and will never be stable\",\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes, Misc:\n+    // ==========================================================================\n+\n+    gated!(\n+        lang, Normal, template!(NameValueStr: \"name\"), lang_items,\n+        \"language items are subject to change\",\n+    ),\n+    (\n+        sym::no_debug, Whitelisted, template!(Word),\n+        Gated(\n+            Stability::Deprecated(\"https://github.com/rust-lang/rust/issues/29721\", None),\n+            sym::no_debug,\n+            \"the `#[no_debug]` attribute was an experimental feature that has been \\\n+            deprecated due to lack of demand\",\n+            cfg_fn!(no_debug)\n+        )\n+    ),\n+    gated!(\n+        // Used in resolve:\n+        prelude_import, Whitelisted, template!(Word),\n+        \"`#[prelude_import]` is for use by rustc only\",\n+    ),\n+    gated!(\n+        rustc_paren_sugar, Normal, template!(Word), unboxed_closures,\n+        \"unboxed_closures are still evolving\",\n+    ),\n+    rustc_attr!(\n+        rustc_inherit_overflow_checks, Whitelisted, template!(Word),\n+        \"the `#[rustc_inherit_overflow_checks]` attribute is just used to control \\\n+        overflow checking behavior of several libcore functions that are inlined \\\n+        across crates and will never be stable\",\n+    ),\n+    rustc_attr!(\n+        rustc_test_marker, Normal, template!(Word),\n+        \"the `#[rustc_test_marker]` attribute is used internally to track tests\",\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes, Testing:\n+    // ==========================================================================\n+\n+    rustc_attr!(TEST, rustc_outlives, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_variance, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_layout, Normal, template!(List: \"field1, field2, ...\")),\n+    rustc_attr!(TEST, rustc_regions, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_error, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_dump_user_substs, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_if_this_changed, Whitelisted, template!(Word, List: \"DepNode\")),\n+    rustc_attr!(TEST, rustc_then_this_would_need, Whitelisted, template!(List: \"DepNode\")),\n+    rustc_attr!(\n+        TEST, rustc_dirty, Whitelisted,\n+        template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\", /*opt*/ except = \"...\"\"#),\n+    ),\n+    rustc_attr!(\n+        TEST, rustc_clean, Whitelisted,\n+        template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\", /*opt*/ except = \"...\"\"#),\n+    ),\n+    rustc_attr!(\n+        TEST, rustc_partition_reused, Whitelisted,\n+        template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n+    ),\n+    rustc_attr!(\n+        TEST, rustc_partition_codegened, Whitelisted,\n+        template!(List: r#\"cfg = \"...\", module = \"...\"\"#),\n+    ),\n+    rustc_attr!(\n+        TEST, rustc_expected_cgu_reuse, Whitelisted,\n+        template!(List: r#\"cfg = \"...\", module = \"...\", kind = \"...\"\"#),\n+    ),\n+    rustc_attr!(TEST, rustc_synthetic, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_symbol_name, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_def_path, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_mir, Whitelisted, template!(List: \"arg1, arg2, ...\")),\n+    rustc_attr!(TEST, rustc_dump_program_clauses, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_dump_env_program_clauses, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_object_lifetime_default, Whitelisted, template!(Word)),\n+    rustc_attr!(TEST, rustc_dummy, Normal, template!(Word /* doesn't matter*/)),\n+    gated!(\n+        omit_gdb_pretty_printer_section, Whitelisted, template!(Word),\n+        \"the `#[omit_gdb_pretty_printer_section]` attribute is just used for the Rust test suite\",\n+    ),\n+];\n+\n+pub fn deprecated_attributes() -> Vec<&'static BuiltinAttribute> {\n+    BUILTIN_ATTRIBUTES.iter().filter(|(.., gate)| gate.is_deprecated()).collect()\n+}\n+\n+pub fn is_builtin_attr_name(name: ast::Name) -> bool {\n+    BUILTIN_ATTRIBUTE_MAP.get(&name).is_some()\n+}\n+\n+pub fn is_builtin_attr(attr: &ast::Attribute) -> bool {\n+    attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name)).is_some()\n+}\n+\n+lazy_static! {\n+    pub static ref BUILTIN_ATTRIBUTE_MAP: FxHashMap<Symbol, &'static BuiltinAttribute> = {\n+        let mut map = FxHashMap::default();\n+        for attr in BUILTIN_ATTRIBUTES.iter() {\n+            if map.insert(attr.0, attr).is_some() {\n+                panic!(\"duplicate builtin attribute `{}`\", attr.0);\n+            }\n+        }\n+        map\n+    };\n+}"}, {"sha": "d82b287b6fb05f693a66e3f58147fd4143b0bd3d", "filename": "src/libsyntax/feature_gate/check.rs", "status": "added", "additions": 951, "deletions": 0, "changes": 951, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -0,0 +1,951 @@\n+use super::active::{ACTIVE_FEATURES, Features};\n+use super::accepted::ACCEPTED_FEATURES;\n+use super::removed::{REMOVED_FEATURES, STABLE_REMOVED_FEATURES};\n+use super::builtin_attrs::{AttributeGate, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n+\n+use crate::ast::{\n+    self, AssocTyConstraint, AssocTyConstraintKind, NodeId, GenericParam, GenericParamKind,\n+    PatKind, RangeEnd,\n+};\n+use crate::attr::{self, check_builtin_attribute};\n+use crate::source_map::Spanned;\n+use crate::edition::{ALL_EDITIONS, Edition};\n+use crate::visit::{self, FnKind, Visitor};\n+use crate::parse::{token, ParseSess};\n+use crate::parse::parser::Parser;\n+use crate::symbol::{Symbol, sym};\n+use crate::tokenstream::TokenTree;\n+\n+use errors::{Applicability, DiagnosticBuilder, Handler};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_target::spec::abi::Abi;\n+use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n+use log::debug;\n+\n+use std::env;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum Stability {\n+    Unstable,\n+    // First argument is tracking issue link; second argument is an optional\n+    // help message, which defaults to \"remove this attribute\"\n+    Deprecated(&'static str, Option<&'static str>),\n+}\n+\n+struct Context<'a> {\n+    features: &'a Features,\n+    parse_sess: &'a ParseSess,\n+    plugin_attributes: &'a [(Symbol, AttributeType)],\n+}\n+\n+macro_rules! gate_feature_fn {\n+    ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $level: expr) => {{\n+        let (cx, has_feature, span,\n+             name, explain, level) = ($cx, $has_feature, $span, $name, $explain, $level);\n+        let has_feature: bool = has_feature(&$cx.features);\n+        debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n+        if !has_feature && !span.allows_unstable($name) {\n+            leveled_feature_err(cx.parse_sess, name, span, GateIssue::Language, explain, level)\n+                .emit();\n+        }\n+    }}\n+}\n+\n+macro_rules! gate_feature {\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {\n+        gate_feature_fn!($cx, |x:&Features| x.$feature, $span,\n+                         sym::$feature, $explain, GateStrength::Hard)\n+    };\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {\n+        gate_feature_fn!($cx, |x:&Features| x.$feature, $span,\n+                         sym::$feature, $explain, $level)\n+    };\n+}\n+\n+impl<'a> Context<'a> {\n+    fn check_attribute(\n+        &self,\n+        attr: &ast::Attribute,\n+        attr_info: Option<&BuiltinAttribute>,\n+        is_macro: bool\n+    ) {\n+        debug!(\"check_attribute(attr = {:?})\", attr);\n+        if let Some(&(name, ty, _template, ref gateage)) = attr_info {\n+            if let AttributeGate::Gated(_, name, desc, ref has_feature) = *gateage {\n+                if !attr.span.allows_unstable(name) {\n+                    gate_feature_fn!(\n+                        self, has_feature, attr.span, name, desc, GateStrength::Hard\n+                    );\n+                }\n+            } else if name == sym::doc {\n+                if let Some(content) = attr.meta_item_list() {\n+                    if content.iter().any(|c| c.check_name(sym::include)) {\n+                        gate_feature!(self, external_doc, attr.span,\n+                            \"`#[doc(include = \\\"...\\\")]` is experimental\"\n+                        );\n+                    }\n+                }\n+            }\n+            debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", attr.path, ty, gateage);\n+            return;\n+        } else {\n+            for segment in &attr.path.segments {\n+                if segment.ident.as_str().starts_with(\"rustc\") {\n+                    let msg = \"attributes starting with `rustc` are \\\n+                               reserved for use by the `rustc` compiler\";\n+                    gate_feature!(self, rustc_attrs, segment.ident.span, msg);\n+                }\n+            }\n+        }\n+        for &(n, ty) in self.plugin_attributes {\n+            if attr.path == n {\n+                // Plugins can't gate attributes, so we don't check for it\n+                // unlike the code above; we only use this loop to\n+                // short-circuit to avoid the checks below.\n+                debug!(\"check_attribute: {:?} is registered by a plugin, {:?}\", attr.path, ty);\n+                return;\n+            }\n+        }\n+        if !is_macro && !attr::is_known(attr) {\n+            // Only run the custom attribute lint during regular feature gate\n+            // checking. Macro gating runs before the plugin attributes are\n+            // registered, so we skip this in that case.\n+            let msg = format!(\"the attribute `{}` is currently unknown to the compiler and \\\n+                               may have meaning added to it in the future\", attr.path);\n+            gate_feature!(self, custom_attribute, attr.span, &msg);\n+        }\n+    }\n+}\n+\n+pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features: &Features) {\n+    let cx = Context { features, parse_sess, plugin_attributes: &[] };\n+    cx.check_attribute(\n+        attr,\n+        attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name).map(|a| *a)),\n+        true\n+    );\n+}\n+\n+fn find_lang_feature_issue(feature: Symbol) -> Option<u32> {\n+    if let Some(info) = ACTIVE_FEATURES.iter().find(|t| t.0 == feature) {\n+        let issue = info.2;\n+        // FIXME (#28244): enforce that active features have issue numbers\n+        // assert!(issue.is_some())\n+        issue\n+    } else {\n+        // search in Accepted, Removed, or Stable Removed features\n+        let found = ACCEPTED_FEATURES.iter().chain(REMOVED_FEATURES).chain(STABLE_REMOVED_FEATURES)\n+            .find(|t| t.0 == feature);\n+        match found {\n+            Some(&(_, _, issue, _)) => issue,\n+            None => panic!(\"Feature `{}` is not declared anywhere\", feature),\n+        }\n+    }\n+}\n+\n+pub enum GateIssue {\n+    Language,\n+    Library(Option<u32>)\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq)]\n+pub enum GateStrength {\n+    /// A hard error. (Most feature gates should use this.)\n+    Hard,\n+    /// Only a warning. (Use this only as backwards-compatibility demands.)\n+    Soft,\n+}\n+\n+pub fn emit_feature_err(\n+    sess: &ParseSess,\n+    feature: Symbol,\n+    span: Span,\n+    issue: GateIssue,\n+    explain: &str,\n+) {\n+    feature_err(sess, feature, span, issue, explain).emit();\n+}\n+\n+pub fn feature_err<'a, S: Into<MultiSpan>>(\n+    sess: &'a ParseSess,\n+    feature: Symbol,\n+    span: S,\n+    issue: GateIssue,\n+    explain: &str,\n+) -> DiagnosticBuilder<'a> {\n+    leveled_feature_err(sess, feature, span, issue, explain, GateStrength::Hard)\n+}\n+\n+fn leveled_feature_err<'a, S: Into<MultiSpan>>(\n+    sess: &'a ParseSess,\n+    feature: Symbol,\n+    span: S,\n+    issue: GateIssue,\n+    explain: &str,\n+    level: GateStrength,\n+) -> DiagnosticBuilder<'a> {\n+    let diag = &sess.span_diagnostic;\n+\n+    let issue = match issue {\n+        GateIssue::Language => find_lang_feature_issue(feature),\n+        GateIssue::Library(lib) => lib,\n+    };\n+\n+    let mut err = match level {\n+        GateStrength::Hard => {\n+            diag.struct_span_err_with_code(span, explain, stringify_error_code!(E0658))\n+        }\n+        GateStrength::Soft => diag.struct_span_warn(span, explain),\n+    };\n+\n+    match issue {\n+        None | Some(0) => {}  // We still accept `0` as a stand-in for backwards compatibility\n+        Some(n) => {\n+            err.note(&format!(\n+                \"for more information, see https://github.com/rust-lang/rust/issues/{}\",\n+                n,\n+            ));\n+        }\n+    }\n+\n+    // #23973: do not suggest `#![feature(...)]` if we are in beta/stable\n+    if sess.unstable_features.is_nightly_build() {\n+        err.help(&format!(\"add `#![feature({})]` to the crate attributes to enable\", feature));\n+    }\n+\n+    // If we're on stable and only emitting a \"soft\" warning, add a note to\n+    // clarify that the feature isn't \"on\" (rather than being on but\n+    // warning-worthy).\n+    if !sess.unstable_features.is_nightly_build() && level == GateStrength::Soft {\n+        err.help(\"a nightly build of the compiler is required to enable this feature\");\n+    }\n+\n+    err\n+\n+}\n+\n+const EXPLAIN_BOX_SYNTAX: &str =\n+    \"box expression syntax is experimental; you can call `Box::new` instead\";\n+\n+pub const EXPLAIN_STMT_ATTR_SYNTAX: &str =\n+    \"attributes on expressions are experimental\";\n+\n+pub const EXPLAIN_ALLOW_INTERNAL_UNSTABLE: &str =\n+    \"allow_internal_unstable side-steps feature gating and stability checks\";\n+pub const EXPLAIN_ALLOW_INTERNAL_UNSAFE: &str =\n+    \"allow_internal_unsafe side-steps the unsafe_code lint\";\n+\n+pub const EXPLAIN_UNSIZED_TUPLE_COERCION: &str =\n+    \"unsized tuple coercion is not stable enough for use and is subject to change\";\n+\n+struct PostExpansionVisitor<'a> {\n+    context: &'a Context<'a>,\n+    builtin_attributes: &'static FxHashMap<Symbol, &'static BuiltinAttribute>,\n+}\n+\n+macro_rules! gate_feature_post {\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {{\n+        let (cx, span) = ($cx, $span);\n+        if !span.allows_unstable(sym::$feature) {\n+            gate_feature!(cx.context, $feature, span, $explain)\n+        }\n+    }};\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {{\n+        let (cx, span) = ($cx, $span);\n+        if !span.allows_unstable(sym::$feature) {\n+            gate_feature!(cx.context, $feature, span, $explain, $level)\n+        }\n+    }}\n+}\n+\n+impl<'a> PostExpansionVisitor<'a> {\n+    fn check_abi(&self, abi: Abi, span: Span) {\n+        match abi {\n+            Abi::RustIntrinsic => {\n+                gate_feature_post!(&self, intrinsics, span,\n+                                   \"intrinsics are subject to change\");\n+            },\n+            Abi::PlatformIntrinsic => {\n+                gate_feature_post!(&self, platform_intrinsics, span,\n+                                   \"platform intrinsics are experimental and possibly buggy\");\n+            },\n+            Abi::Vectorcall => {\n+                gate_feature_post!(&self, abi_vectorcall, span,\n+                                   \"vectorcall is experimental and subject to change\");\n+            },\n+            Abi::Thiscall => {\n+                gate_feature_post!(&self, abi_thiscall, span,\n+                                   \"thiscall is experimental and subject to change\");\n+            },\n+            Abi::RustCall => {\n+                gate_feature_post!(&self, unboxed_closures, span,\n+                                   \"rust-call ABI is subject to change\");\n+            },\n+            Abi::PtxKernel => {\n+                gate_feature_post!(&self, abi_ptx, span,\n+                                   \"PTX ABIs are experimental and subject to change\");\n+            },\n+            Abi::Unadjusted => {\n+                gate_feature_post!(&self, abi_unadjusted, span,\n+                                   \"unadjusted ABI is an implementation detail and perma-unstable\");\n+            },\n+            Abi::Msp430Interrupt => {\n+                gate_feature_post!(&self, abi_msp430_interrupt, span,\n+                                   \"msp430-interrupt ABI is experimental and subject to change\");\n+            },\n+            Abi::X86Interrupt => {\n+                gate_feature_post!(&self, abi_x86_interrupt, span,\n+                                   \"x86-interrupt ABI is experimental and subject to change\");\n+            },\n+            Abi::AmdGpuKernel => {\n+                gate_feature_post!(&self, abi_amdgpu_kernel, span,\n+                                   \"amdgpu-kernel ABI is experimental and subject to change\");\n+            },\n+            // Stable\n+            Abi::Cdecl |\n+            Abi::Stdcall |\n+            Abi::Fastcall |\n+            Abi::Aapcs |\n+            Abi::Win64 |\n+            Abi::SysV64 |\n+            Abi::Rust |\n+            Abi::C |\n+            Abi::System => {}\n+        }\n+    }\n+}\n+\n+impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n+    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n+        let attr_info = attr.ident().and_then(|ident| {\n+            self.builtin_attributes.get(&ident.name).map(|a| *a)\n+        });\n+\n+        // Check for gated attributes.\n+        self.context.check_attribute(attr, attr_info, false);\n+\n+        if attr.check_name(sym::doc) {\n+            if let Some(content) = attr.meta_item_list() {\n+                if content.len() == 1 && content[0].check_name(sym::cfg) {\n+                    gate_feature_post!(&self, doc_cfg, attr.span,\n+                        \"`#[doc(cfg(...))]` is experimental\"\n+                    );\n+                } else if content.iter().any(|c| c.check_name(sym::masked)) {\n+                    gate_feature_post!(&self, doc_masked, attr.span,\n+                        \"`#[doc(masked)]` is experimental\"\n+                    );\n+                } else if content.iter().any(|c| c.check_name(sym::spotlight)) {\n+                    gate_feature_post!(&self, doc_spotlight, attr.span,\n+                        \"`#[doc(spotlight)]` is experimental\"\n+                    );\n+                } else if content.iter().any(|c| c.check_name(sym::alias)) {\n+                    gate_feature_post!(&self, doc_alias, attr.span,\n+                        \"`#[doc(alias = \\\"...\\\")]` is experimental\"\n+                    );\n+                } else if content.iter().any(|c| c.check_name(sym::keyword)) {\n+                    gate_feature_post!(&self, doc_keyword, attr.span,\n+                        \"`#[doc(keyword = \\\"...\\\")]` is experimental\"\n+                    );\n+                }\n+            }\n+        }\n+\n+        match attr_info {\n+            // `rustc_dummy` doesn't have any restrictions specific to built-in attributes.\n+            Some(&(name, _, template, _)) if name != sym::rustc_dummy =>\n+                check_builtin_attribute(self.context.parse_sess, attr, name, template),\n+            _ => if let Some(TokenTree::Token(token)) = attr.tokens.trees().next() {\n+                if token == token::Eq {\n+                    // All key-value attributes are restricted to meta-item syntax.\n+                    attr.parse_meta(self.context.parse_sess).map_err(|mut err| err.emit()).ok();\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_name(&mut self, sp: Span, name: ast::Name) {\n+        if !name.as_str().is_ascii() {\n+            gate_feature_post!(\n+                &self,\n+                non_ascii_idents,\n+                self.context.parse_sess.source_map().def_span(sp),\n+                \"non-ascii idents are not fully supported\"\n+            );\n+        }\n+    }\n+\n+    fn visit_item(&mut self, i: &'a ast::Item) {\n+        match i.node {\n+            ast::ItemKind::ForeignMod(ref foreign_module) => {\n+                self.check_abi(foreign_module.abi, i.span);\n+            }\n+\n+            ast::ItemKind::Fn(..) => {\n+                if attr::contains_name(&i.attrs[..], sym::plugin_registrar) {\n+                    gate_feature_post!(&self, plugin_registrar, i.span,\n+                                       \"compiler plugins are experimental and possibly buggy\");\n+                }\n+                if attr::contains_name(&i.attrs[..], sym::start) {\n+                    gate_feature_post!(&self, start, i.span,\n+                                      \"a `#[start]` function is an experimental \\\n+                                       feature whose signature may change \\\n+                                       over time\");\n+                }\n+                if attr::contains_name(&i.attrs[..], sym::main) {\n+                    gate_feature_post!(&self, main, i.span,\n+                                       \"declaration of a non-standard `#[main]` \\\n+                                        function may change over time, for now \\\n+                                        a top-level `fn main()` is required\");\n+                }\n+            }\n+\n+            ast::ItemKind::Struct(..) => {\n+                for attr in attr::filter_by_name(&i.attrs[..], sym::repr) {\n+                    for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n+                        if item.check_name(sym::simd) {\n+                            gate_feature_post!(&self, repr_simd, attr.span,\n+                                               \"SIMD types are experimental and possibly buggy\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            ast::ItemKind::Enum(ast::EnumDef{ref variants, ..}, ..) => {\n+                for variant in variants {\n+                    match (&variant.data, &variant.disr_expr) {\n+                        (ast::VariantData::Unit(..), _) => {},\n+                        (_, Some(disr_expr)) =>\n+                            gate_feature_post!(\n+                                &self,\n+                                arbitrary_enum_discriminant,\n+                                disr_expr.value.span,\n+                                \"discriminants on non-unit variants are experimental\"),\n+                        _ => {},\n+                    }\n+                }\n+\n+                let has_feature = self.context.features.arbitrary_enum_discriminant;\n+                if !has_feature && !i.span.allows_unstable(sym::arbitrary_enum_discriminant) {\n+                    Parser::maybe_report_invalid_custom_discriminants(\n+                        self.context.parse_sess,\n+                        &variants,\n+                    );\n+                }\n+            }\n+\n+            ast::ItemKind::Impl(_, polarity, defaultness, ..) => {\n+                if polarity == ast::ImplPolarity::Negative {\n+                    gate_feature_post!(&self, optin_builtin_traits,\n+                                       i.span,\n+                                       \"negative trait bounds are not yet fully implemented; \\\n+                                        use marker types for now\");\n+                }\n+\n+                if let ast::Defaultness::Default = defaultness {\n+                    gate_feature_post!(&self, specialization,\n+                                       i.span,\n+                                       \"specialization is unstable\");\n+                }\n+            }\n+\n+            ast::ItemKind::Trait(ast::IsAuto::Yes, ..) => {\n+                gate_feature_post!(&self, optin_builtin_traits,\n+                                   i.span,\n+                                   \"auto traits are experimental and possibly buggy\");\n+            }\n+\n+            ast::ItemKind::TraitAlias(..) => {\n+                gate_feature_post!(\n+                    &self,\n+                    trait_alias,\n+                    i.span,\n+                    \"trait aliases are experimental\"\n+                );\n+            }\n+\n+            ast::ItemKind::MacroDef(ast::MacroDef { legacy: false, .. }) => {\n+                let msg = \"`macro` is experimental\";\n+                gate_feature_post!(&self, decl_macro, i.span, msg);\n+            }\n+\n+            ast::ItemKind::OpaqueTy(..) => {\n+                gate_feature_post!(\n+                    &self,\n+                    type_alias_impl_trait,\n+                    i.span,\n+                    \"`impl Trait` in type aliases is unstable\"\n+                );\n+            }\n+\n+            _ => {}\n+        }\n+\n+        visit::walk_item(self, i);\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &'a ast::ForeignItem) {\n+        match i.node {\n+            ast::ForeignItemKind::Fn(..) |\n+            ast::ForeignItemKind::Static(..) => {\n+                let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n+                let links_to_llvm = match link_name {\n+                    Some(val) => val.as_str().starts_with(\"llvm.\"),\n+                    _ => false\n+                };\n+                if links_to_llvm {\n+                    gate_feature_post!(&self, link_llvm_intrinsics, i.span,\n+                                       \"linking to LLVM intrinsics is experimental\");\n+                }\n+            }\n+            ast::ForeignItemKind::Ty => {\n+                    gate_feature_post!(&self, extern_types, i.span,\n+                                       \"extern types are experimental\");\n+            }\n+            ast::ForeignItemKind::Macro(..) => {}\n+        }\n+\n+        visit::walk_foreign_item(self, i)\n+    }\n+\n+    fn visit_ty(&mut self, ty: &'a ast::Ty) {\n+        match ty.node {\n+            ast::TyKind::BareFn(ref bare_fn_ty) => {\n+                self.check_abi(bare_fn_ty.abi, ty.span);\n+            }\n+            ast::TyKind::Never => {\n+                gate_feature_post!(&self, never_type, ty.span,\n+                                   \"The `!` type is experimental\");\n+            }\n+            _ => {}\n+        }\n+        visit::walk_ty(self, ty)\n+    }\n+\n+    fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FunctionRetTy) {\n+        if let ast::FunctionRetTy::Ty(ref output_ty) = *ret_ty {\n+            if let ast::TyKind::Never = output_ty.node {\n+                // Do nothing.\n+            } else {\n+                self.visit_ty(output_ty)\n+            }\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, e: &'a ast::Expr) {\n+        match e.node {\n+            ast::ExprKind::Box(_) => {\n+                gate_feature_post!(&self, box_syntax, e.span, EXPLAIN_BOX_SYNTAX);\n+            }\n+            ast::ExprKind::Type(..) => {\n+                // To avoid noise about type ascription in common syntax errors, only emit if it\n+                // is the *only* error.\n+                if self.context.parse_sess.span_diagnostic.err_count() == 0 {\n+                    gate_feature_post!(&self, type_ascription, e.span,\n+                                       \"type ascription is experimental\");\n+                }\n+            }\n+            ast::ExprKind::TryBlock(_) => {\n+                gate_feature_post!(&self, try_blocks, e.span, \"`try` expression is experimental\");\n+            }\n+            ast::ExprKind::Block(_, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    gate_feature_post!(&self, label_break_value, label.ident.span,\n+                                    \"labels on blocks are unstable\");\n+                }\n+            }\n+            _ => {}\n+        }\n+        visit::walk_expr(self, e)\n+    }\n+\n+    fn visit_arm(&mut self, arm: &'a ast::Arm) {\n+        visit::walk_arm(self, arm)\n+    }\n+\n+    fn visit_pat(&mut self, pattern: &'a ast::Pat) {\n+        match &pattern.node {\n+            PatKind::Slice(pats) => {\n+                for pat in &*pats {\n+                    let span = pat.span;\n+                    let inner_pat = match &pat.node {\n+                        PatKind::Ident(.., Some(pat)) => pat,\n+                        _ => pat,\n+                    };\n+                    if inner_pat.is_rest() {\n+                        gate_feature_post!(\n+                            &self,\n+                            slice_patterns,\n+                            span,\n+                            \"subslice patterns are unstable\"\n+                        );\n+                    }\n+                }\n+            }\n+            PatKind::Box(..) => {\n+                gate_feature_post!(&self, box_patterns,\n+                                  pattern.span,\n+                                  \"box pattern syntax is experimental\");\n+            }\n+            PatKind::Range(_, _, Spanned { node: RangeEnd::Excluded, .. }) => {\n+                gate_feature_post!(&self, exclusive_range_pattern, pattern.span,\n+                                   \"exclusive range pattern syntax is experimental\");\n+            }\n+            _ => {}\n+        }\n+        visit::walk_pat(self, pattern)\n+    }\n+\n+    fn visit_fn(&mut self,\n+                fn_kind: FnKind<'a>,\n+                fn_decl: &'a ast::FnDecl,\n+                span: Span,\n+                _node_id: NodeId) {\n+        if let Some(header) = fn_kind.header() {\n+            // Stability of const fn methods are covered in\n+            // `visit_trait_item` and `visit_impl_item` below; this is\n+            // because default methods don't pass through this point.\n+            self.check_abi(header.abi, span);\n+        }\n+\n+        if fn_decl.c_variadic {\n+            gate_feature_post!(&self, c_variadic, span, \"C-variadic functions are unstable\");\n+        }\n+\n+        visit::walk_fn(self, fn_kind, fn_decl, span)\n+    }\n+\n+    fn visit_generic_param(&mut self, param: &'a GenericParam) {\n+        match param.kind {\n+            GenericParamKind::Const { .. } =>\n+                gate_feature_post!(&self, const_generics, param.ident.span,\n+                    \"const generics are unstable\"),\n+            _ => {}\n+        }\n+        visit::walk_generic_param(self, param)\n+    }\n+\n+    fn visit_assoc_ty_constraint(&mut self, constraint: &'a AssocTyConstraint) {\n+        match constraint.kind {\n+            AssocTyConstraintKind::Bound { .. } =>\n+                gate_feature_post!(&self, associated_type_bounds, constraint.span,\n+                    \"associated type bounds are unstable\"),\n+            _ => {}\n+        }\n+        visit::walk_assoc_ty_constraint(self, constraint)\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'a ast::TraitItem) {\n+        match ti.node {\n+            ast::TraitItemKind::Method(ref sig, ref block) => {\n+                if block.is_none() {\n+                    self.check_abi(sig.header.abi, ti.span);\n+                }\n+                if sig.decl.c_variadic {\n+                    gate_feature_post!(&self, c_variadic, ti.span,\n+                                       \"C-variadic functions are unstable\");\n+                }\n+                if sig.header.constness.node == ast::Constness::Const {\n+                    gate_feature_post!(&self, const_fn, ti.span, \"const fn is unstable\");\n+                }\n+            }\n+            ast::TraitItemKind::Type(_, ref default) => {\n+                // We use three if statements instead of something like match guards so that all\n+                // of these errors can be emitted if all cases apply.\n+                if default.is_some() {\n+                    gate_feature_post!(&self, associated_type_defaults, ti.span,\n+                                       \"associated type defaults are unstable\");\n+                }\n+                if !ti.generics.params.is_empty() {\n+                    gate_feature_post!(&self, generic_associated_types, ti.span,\n+                                       \"generic associated types are unstable\");\n+                }\n+                if !ti.generics.where_clause.predicates.is_empty() {\n+                    gate_feature_post!(&self, generic_associated_types, ti.span,\n+                                       \"where clauses on associated types are unstable\");\n+                }\n+            }\n+            _ => {}\n+        }\n+        visit::walk_trait_item(self, ti)\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'a ast::ImplItem) {\n+        if ii.defaultness == ast::Defaultness::Default {\n+            gate_feature_post!(&self, specialization,\n+                              ii.span,\n+                              \"specialization is unstable\");\n+        }\n+\n+        match ii.node {\n+            ast::ImplItemKind::Method(..) => {}\n+            ast::ImplItemKind::OpaqueTy(..) => {\n+                gate_feature_post!(\n+                    &self,\n+                    type_alias_impl_trait,\n+                    ii.span,\n+                    \"`impl Trait` in type aliases is unstable\"\n+                );\n+            }\n+            ast::ImplItemKind::TyAlias(_) => {\n+                if !ii.generics.params.is_empty() {\n+                    gate_feature_post!(&self, generic_associated_types, ii.span,\n+                                       \"generic associated types are unstable\");\n+                }\n+                if !ii.generics.where_clause.predicates.is_empty() {\n+                    gate_feature_post!(&self, generic_associated_types, ii.span,\n+                                       \"where clauses on associated types are unstable\");\n+                }\n+            }\n+            _ => {}\n+        }\n+        visit::walk_impl_item(self, ii)\n+    }\n+\n+    fn visit_vis(&mut self, vis: &'a ast::Visibility) {\n+        if let ast::VisibilityKind::Crate(ast::CrateSugar::JustCrate) = vis.node {\n+            gate_feature_post!(&self, crate_visibility_modifier, vis.span,\n+                               \"`crate` visibility modifier is experimental\");\n+        }\n+        visit::walk_vis(self, vis)\n+    }\n+}\n+\n+pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n+                    crate_edition: Edition, allow_features: &Option<Vec<String>>) -> Features {\n+    fn feature_removed(span_handler: &Handler, span: Span, reason: Option<&str>) {\n+        let mut err = struct_span_err!(span_handler, span, E0557, \"feature has been removed\");\n+        if let Some(reason) = reason {\n+            err.span_note(span, reason);\n+        } else {\n+            err.span_label(span, \"feature has been removed\");\n+        }\n+        err.emit();\n+    }\n+\n+    let mut features = Features::new();\n+    let mut edition_enabled_features = FxHashMap::default();\n+\n+    for &edition in ALL_EDITIONS {\n+        if edition <= crate_edition {\n+            // The `crate_edition` implies its respective umbrella feature-gate\n+            // (i.e., `#![feature(rust_20XX_preview)]` isn't needed on edition 20XX).\n+            edition_enabled_features.insert(edition.feature_name(), edition);\n+        }\n+    }\n+\n+    for &(name, .., f_edition, set) in ACTIVE_FEATURES {\n+        if let Some(f_edition) = f_edition {\n+            if f_edition <= crate_edition {\n+                set(&mut features, DUMMY_SP);\n+                edition_enabled_features.insert(name, crate_edition);\n+            }\n+        }\n+    }\n+\n+    // Process the edition umbrella feature-gates first, to ensure\n+    // `edition_enabled_features` is completed before it's queried.\n+    for attr in krate_attrs {\n+        if !attr.check_name(sym::feature) {\n+            continue\n+        }\n+\n+        let list = match attr.meta_item_list() {\n+            Some(list) => list,\n+            None => continue,\n+        };\n+\n+        for mi in list {\n+            if !mi.is_word() {\n+                continue;\n+            }\n+\n+            let name = mi.name_or_empty();\n+\n+            if let Some(edition) = ALL_EDITIONS.iter().find(|e| name == e.feature_name()) {\n+                if *edition <= crate_edition {\n+                    continue;\n+                }\n+\n+                for &(name, .., f_edition, set) in ACTIVE_FEATURES {\n+                    if let Some(f_edition) = f_edition {\n+                        if f_edition <= *edition {\n+                            // FIXME(Manishearth) there is currently no way to set\n+                            // lib features by edition\n+                            set(&mut features, DUMMY_SP);\n+                            edition_enabled_features.insert(name, *edition);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    for attr in krate_attrs {\n+        if !attr.check_name(sym::feature) {\n+            continue\n+        }\n+\n+        let list = match attr.meta_item_list() {\n+            Some(list) => list,\n+            None => continue,\n+        };\n+\n+        let bad_input = |span| {\n+            struct_span_err!(span_handler, span, E0556, \"malformed `feature` attribute input\")\n+        };\n+\n+        for mi in list {\n+            let name = match mi.ident() {\n+                Some(ident) if mi.is_word() => ident.name,\n+                Some(ident) => {\n+                    bad_input(mi.span()).span_suggestion(\n+                        mi.span(),\n+                        \"expected just one word\",\n+                        format!(\"{}\", ident.name),\n+                        Applicability::MaybeIncorrect,\n+                    ).emit();\n+                    continue\n+                }\n+                None => {\n+                    bad_input(mi.span()).span_label(mi.span(), \"expected just one word\").emit();\n+                    continue\n+                }\n+            };\n+\n+            if let Some(edition) = edition_enabled_features.get(&name) {\n+                struct_span_warn!(\n+                    span_handler,\n+                    mi.span(),\n+                    E0705,\n+                    \"the feature `{}` is included in the Rust {} edition\",\n+                    name,\n+                    edition,\n+                ).emit();\n+                continue;\n+            }\n+\n+            if ALL_EDITIONS.iter().any(|e| name == e.feature_name()) {\n+                // Handled in the separate loop above.\n+                continue;\n+            }\n+\n+            let removed = REMOVED_FEATURES.iter().find(|f| name == f.0);\n+            let stable_removed = STABLE_REMOVED_FEATURES.iter().find(|f| name == f.0);\n+            if let Some((.., reason)) = removed.or(stable_removed) {\n+                feature_removed(span_handler, mi.span(), *reason);\n+                continue;\n+            }\n+\n+            if let Some((_, since, ..)) = ACCEPTED_FEATURES.iter().find(|f| name == f.0) {\n+                let since = Some(Symbol::intern(since));\n+                features.declared_lang_features.push((name, mi.span(), since));\n+                continue;\n+            }\n+\n+            if let Some(allowed) = allow_features.as_ref() {\n+                if allowed.iter().find(|f| *f == name.as_str()).is_none() {\n+                    span_err!(span_handler, mi.span(), E0725,\n+                              \"the feature `{}` is not in the list of allowed features\",\n+                              name);\n+                    continue;\n+                }\n+            }\n+\n+            if let Some((.., set)) = ACTIVE_FEATURES.iter().find(|f| name == f.0) {\n+                set(&mut features, mi.span());\n+                features.declared_lang_features.push((name, mi.span(), None));\n+                continue;\n+            }\n+\n+            features.declared_lib_features.push((name, mi.span()));\n+        }\n+    }\n+\n+    features\n+}\n+\n+pub fn check_crate(krate: &ast::Crate,\n+                   sess: &ParseSess,\n+                   features: &Features,\n+                   plugin_attributes: &[(Symbol, AttributeType)],\n+                   unstable: UnstableFeatures) {\n+    maybe_stage_features(&sess.span_diagnostic, krate, unstable);\n+    let ctx = Context {\n+        features,\n+        parse_sess: sess,\n+        plugin_attributes,\n+    };\n+\n+    macro_rules! gate_all {\n+        ($gate:ident, $msg:literal) => { gate_all!($gate, $gate, $msg); };\n+        ($spans:ident, $gate:ident, $msg:literal) => {\n+            for span in &*sess.gated_spans.$spans.borrow() {\n+                gate_feature!(&ctx, $gate, *span, $msg);\n+            }\n+        }\n+    }\n+\n+    gate_all!(param_attrs, \"attributes on function parameters are unstable\");\n+    gate_all!(let_chains, \"`let` expressions in this position are experimental\");\n+    gate_all!(async_closure, \"async closures are unstable\");\n+    gate_all!(yields, generators, \"yield syntax is experimental\");\n+    gate_all!(or_patterns, \"or-patterns syntax is experimental\");\n+\n+    let visitor = &mut PostExpansionVisitor {\n+        context: &ctx,\n+        builtin_attributes: &*BUILTIN_ATTRIBUTE_MAP,\n+    };\n+    visit::walk_crate(visitor, krate);\n+}\n+\n+#[derive(Clone, Copy, Hash)]\n+pub enum UnstableFeatures {\n+    /// Hard errors for unstable features are active, as on beta/stable channels.\n+    Disallow,\n+    /// Allow features to be activated, as on nightly.\n+    Allow,\n+    /// Errors are bypassed for bootstrapping. This is required any time\n+    /// during the build that feature-related lints are set to warn or above\n+    /// because the build turns on warnings-as-errors and uses lots of unstable\n+    /// features. As a result, this is always required for building Rust itself.\n+    Cheat\n+}\n+\n+impl UnstableFeatures {\n+    pub fn from_environment() -> UnstableFeatures {\n+        // Whether this is a feature-staged build, i.e., on the beta or stable channel\n+        let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n+        // Whether we should enable unstable features for bootstrapping\n+        let bootstrap = env::var(\"RUSTC_BOOTSTRAP\").is_ok();\n+        match (disable_unstable_features, bootstrap) {\n+            (_, true) => UnstableFeatures::Cheat,\n+            (true, _) => UnstableFeatures::Disallow,\n+            (false, _) => UnstableFeatures::Allow\n+        }\n+    }\n+\n+    pub fn is_nightly_build(&self) -> bool {\n+        match *self {\n+            UnstableFeatures::Allow | UnstableFeatures::Cheat => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate, unstable: UnstableFeatures) {\n+    let allow_features = match unstable {\n+        UnstableFeatures::Allow => true,\n+        UnstableFeatures::Disallow => false,\n+        UnstableFeatures::Cheat => true\n+    };\n+    if !allow_features {\n+        for attr in &krate.attrs {\n+            if attr.check_name(sym::feature) {\n+                let release_channel = option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\");\n+                span_err!(span_handler, attr.span, E0554,\n+                          \"`#![feature]` may not be used on the {} release channel\",\n+                          release_channel);\n+            }\n+        }\n+    }\n+}"}, {"sha": "97793bca1f5891ad5520b5d8e00f76c99c4337cd", "filename": "src/libsyntax/feature_gate/mod.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Flibsyntax%2Ffeature_gate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Flibsyntax%2Ffeature_gate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fmod.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -0,0 +1,31 @@\n+//! # Feature gating\n+//!\n+//! This module implements the gating necessary for preventing certain compiler\n+//! features from being used by default. This module will crawl a pre-expanded\n+//! AST to ensure that there are no features which are used that are not\n+//! enabled.\n+//!\n+//! Features are enabled in programs via the crate-level attributes of\n+//! `#![feature(...)]` with a comma-separated list of features.\n+//!\n+//! For the purpose of future feature-tracking, once code for detection of feature\n+//! gate usage is added, *do not remove it again* even once the feature\n+//! becomes stable.\n+\n+mod accepted;\n+mod removed;\n+mod active;\n+mod builtin_attrs;\n+mod check;\n+\n+pub use active::{Features, INCOMPLETE_FEATURES};\n+pub use builtin_attrs::{\n+    AttributeGate, AttributeType, GatedCfg,\n+    BuiltinAttribute, BUILTIN_ATTRIBUTES, BUILTIN_ATTRIBUTE_MAP,\n+    deprecated_attributes, is_builtin_attr,  is_builtin_attr_name,\n+};\n+pub use check::{\n+    check_attribute, check_crate, get_features, feature_err, emit_feature_err,\n+    Stability, GateIssue, UnstableFeatures,\n+    EXPLAIN_STMT_ATTR_SYNTAX, EXPLAIN_UNSIZED_TUPLE_COERCION,\n+};"}, {"sha": "6ebfeb29f677ba8ceea1819a6371dc2b5f44ad59", "filename": "src/libsyntax/feature_gate/removed.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Flibsyntax%2Ffeature_gate%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Flibsyntax%2Ffeature_gate%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fremoved.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -0,0 +1,82 @@\n+//! List of the removed feature gates.\n+\n+use crate::symbol::{Symbol, sym};\n+\n+macro_rules! declare_features {\n+    ($((removed, $feature: ident, $ver: expr, $issue: expr, None, $reason: expr),)+) => {\n+        /// Represents unstable features which have since been removed (it was once Active)\n+        pub const REMOVED_FEATURES: &[(Symbol, &str, Option<u32>, Option<&str>)] = &[\n+            $((sym::$feature, $ver, $issue, $reason)),+\n+        ];\n+    };\n+\n+    ($((stable_removed, $feature: ident, $ver: expr, $issue: expr, None),)+) => {\n+        /// Represents stable features which have since been removed (it was once Accepted)\n+        pub const STABLE_REMOVED_FEATURES: &[(Symbol, &str, Option<u32>, Option<&str>)] = &[\n+            $((sym::$feature, $ver, $issue, None)),+\n+        ];\n+    };\n+}\n+\n+declare_features! (\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: removed features\n+    // -------------------------------------------------------------------------\n+\n+    (removed, import_shadowing, \"1.0.0\", None, None, None),\n+    (removed, managed_boxes, \"1.0.0\", None, None, None),\n+    // Allows use of unary negate on unsigned integers, e.g., -e for e: u8\n+    (removed, negate_unsigned, \"1.0.0\", Some(29645), None, None),\n+    (removed, reflect, \"1.0.0\", Some(27749), None, None),\n+    // A way to temporarily opt out of opt in copy. This will *never* be accepted.\n+    (removed, opt_out_copy, \"1.0.0\", None, None, None),\n+    (removed, quad_precision_float, \"1.0.0\", None, None, None),\n+    (removed, struct_inherit, \"1.0.0\", None, None, None),\n+    (removed, test_removed_feature, \"1.0.0\", None, None, None),\n+    (removed, visible_private_types, \"1.0.0\", None, None, None),\n+    (removed, unsafe_no_drop_flag, \"1.0.0\", None, None, None),\n+    // Allows using items which are missing stability attributes\n+    (removed, unmarked_api, \"1.0.0\", None, None, None),\n+    (removed, allocator, \"1.0.0\", None, None, None),\n+    (removed, simd, \"1.0.0\", Some(27731), None,\n+     Some(\"removed in favor of `#[repr(simd)]`\")),\n+    (removed, advanced_slice_patterns, \"1.0.0\", Some(62254), None,\n+     Some(\"merged into `#![feature(slice_patterns)]`\")),\n+    (removed, macro_reexport, \"1.0.0\", Some(29638), None,\n+     Some(\"subsumed by `pub use`\")),\n+    (removed, pushpop_unsafe, \"1.2.0\", None, None, None),\n+    (removed, needs_allocator, \"1.4.0\", Some(27389), None,\n+     Some(\"subsumed by `#![feature(allocator_internals)]`\")),\n+    (removed, proc_macro_mod, \"1.27.0\", Some(54727), None,\n+     Some(\"subsumed by `#![feature(proc_macro_hygiene)]`\")),\n+    (removed, proc_macro_expr, \"1.27.0\", Some(54727), None,\n+     Some(\"subsumed by `#![feature(proc_macro_hygiene)]`\")),\n+    (removed, proc_macro_non_items, \"1.27.0\", Some(54727), None,\n+     Some(\"subsumed by `#![feature(proc_macro_hygiene)]`\")),\n+    (removed, proc_macro_gen, \"1.27.0\", Some(54727), None,\n+     Some(\"subsumed by `#![feature(proc_macro_hygiene)]`\")),\n+    (removed, panic_implementation, \"1.28.0\", Some(44489), None,\n+     Some(\"subsumed by `#[panic_handler]`\")),\n+    // Allows the use of `#[derive(Anything)]` as sugar for `#[derive_Anything]`.\n+    (removed, custom_derive, \"1.32.0\", Some(29644), None,\n+     Some(\"subsumed by `#[proc_macro_derive]`\")),\n+    // Paths of the form: `extern::foo::bar`\n+    (removed, extern_in_paths, \"1.33.0\", Some(55600), None,\n+     Some(\"subsumed by `::foo::bar` paths\")),\n+    (removed, quote, \"1.33.0\", Some(29601), None, None),\n+    // Allows using `#[unsafe_destructor_blind_to_params]` (RFC 1238).\n+    (removed, dropck_parametricity, \"1.38.0\", Some(28498), None, None),\n+    (removed, await_macro, \"1.38.0\", Some(50547), None,\n+     Some(\"subsumed by `.await` syntax\")),\n+    // Allows defining `existential type`s.\n+    (removed, existential_type, \"1.38.0\", Some(63063), None,\n+     Some(\"removed in favor of `#![feature(type_alias_impl_trait)]`\")),\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-end: removed features\n+    // -------------------------------------------------------------------------\n+);\n+\n+declare_features! (\n+    (stable_removed, no_stack_check, \"1.0.0\", None, None),\n+);"}, {"sha": "7dbeba53afcfe61739ffbb50f05d6821c8ed9a5a", "filename": "src/test/ui/conditional-compilation/cfg-attr-crate-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-crate-2.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -3,6 +3,6 @@\n // compile-flags: --cfg broken\n \n #![crate_type = \"lib\"]\n-#![cfg_attr(broken, no_core)] //~ ERROR no_core is experimental\n+#![cfg_attr(broken, no_core)] //~ ERROR the `#[no_core]` attribute is an experimental feature\n \n pub struct S {}"}, {"sha": "7b77701ee190f86885c13a581df3ec430be6c338", "filename": "src/test/ui/conditional-compilation/cfg-attr-crate-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-crate-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-crate-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-crate-2.stderr?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: no_core is experimental\n+error[E0658]: the `#[no_core]` attribute is an experimental feature\n   --> $DIR/cfg-attr-crate-2.rs:6:21\n    |\n LL | #![cfg_attr(broken, no_core)]"}, {"sha": "42ffb71e3d7b92dc10fe7a28089747ab65b773a8", "filename": "src/test/ui/conditional-compilation/cfg-attr-multi-invalid-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-1.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,6 +1,7 @@\n // compile-flags: --cfg broken\n \n #![crate_type = \"lib\"]\n-#![cfg_attr(broken, no_core, no_std)] //~ ERROR no_core is experimental\n+#![cfg_attr(broken, no_core, no_std)]\n+//~^ ERROR the `#[no_core]` attribute is an experimental feature\n \n pub struct S {}"}, {"sha": "ab7e1eb96032d401685cc43cc7b13ce72662d04d", "filename": "src/test/ui/conditional-compilation/cfg-attr-multi-invalid-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-1.stderr?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: no_core is experimental\n+error[E0658]: the `#[no_core]` attribute is an experimental feature\n   --> $DIR/cfg-attr-multi-invalid-1.rs:4:21\n    |\n LL | #![cfg_attr(broken, no_core, no_std)]"}, {"sha": "29690e2848f2d7ba0901f67302bee6f535846c49", "filename": "src/test/ui/conditional-compilation/cfg-attr-multi-invalid-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-2.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,6 +1,7 @@\n // compile-flags: --cfg broken\n \n #![crate_type = \"lib\"]\n-#![cfg_attr(broken, no_std, no_core)] //~ ERROR no_core is experimental\n+#![cfg_attr(broken, no_std, no_core)]\n+//~^ ERROR the `#[no_core]` attribute is an experimental feature\n \n pub struct S {}"}, {"sha": "8126affbd36cd02c395b388dcd4df407ddfa8a62", "filename": "src/test/ui/conditional-compilation/cfg-attr-multi-invalid-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-invalid-2.stderr?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: no_core is experimental\n+error[E0658]: the `#[no_core]` attribute is an experimental feature\n   --> $DIR/cfg-attr-multi-invalid-2.rs:4:29\n    |\n LL | #![cfg_attr(broken, no_std, no_core)]"}, {"sha": "15aa3a6af4ca9c2bf3fe48e0c9c437a4982d6486", "filename": "src/test/ui/feature-gate-optimize_attribute.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gate-optimize_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gate-optimize_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-optimize_attribute.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,17 +1,17 @@\n #![crate_type=\"rlib\"]\n-#![optimize(speed)] //~ ERROR `#[optimize]` attribute is an unstable feature\n+#![optimize(speed)] //~ ERROR the `#[optimize]` attribute is an experimental feature\n \n-#[optimize(size)] //~ ERROR `#[optimize]` attribute is an unstable feature\n+#[optimize(size)] //~ ERROR the `#[optimize]` attribute is an experimental feature\n mod module {\n \n-#[optimize(size)] //~ ERROR `#[optimize]` attribute is an unstable feature\n+#[optimize(size)] //~ ERROR the `#[optimize]` attribute is an experimental feature\n fn size() {}\n \n-#[optimize(speed)] //~ ERROR `#[optimize]` attribute is an unstable feature\n+#[optimize(speed)] //~ ERROR the `#[optimize]` attribute is an experimental feature\n fn speed() {}\n \n #[optimize(banana)]\n-//~^ ERROR `#[optimize]` attribute is an unstable feature\n+//~^ ERROR the `#[optimize]` attribute is an experimental feature\n //~| ERROR E0722\n fn not_known() {}\n "}, {"sha": "3e3ad71c344eec4ed52bc131cd0c532f71527f51", "filename": "src/test/ui/feature-gate-optimize_attribute.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gate-optimize_attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gate-optimize_attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-optimize_attribute.stderr?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: `#[optimize]` attribute is an unstable feature\n+error[E0658]: the `#[optimize]` attribute is an experimental feature\n   --> $DIR/feature-gate-optimize_attribute.rs:7:1\n    |\n LL | #[optimize(size)]\n@@ -7,7 +7,7 @@ LL | #[optimize(size)]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54882\n    = help: add `#![feature(optimize_attribute)]` to the crate attributes to enable\n \n-error[E0658]: `#[optimize]` attribute is an unstable feature\n+error[E0658]: the `#[optimize]` attribute is an experimental feature\n   --> $DIR/feature-gate-optimize_attribute.rs:10:1\n    |\n LL | #[optimize(speed)]\n@@ -16,7 +16,7 @@ LL | #[optimize(speed)]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54882\n    = help: add `#![feature(optimize_attribute)]` to the crate attributes to enable\n \n-error[E0658]: `#[optimize]` attribute is an unstable feature\n+error[E0658]: the `#[optimize]` attribute is an experimental feature\n   --> $DIR/feature-gate-optimize_attribute.rs:13:1\n    |\n LL | #[optimize(banana)]\n@@ -25,7 +25,7 @@ LL | #[optimize(banana)]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54882\n    = help: add `#![feature(optimize_attribute)]` to the crate attributes to enable\n \n-error[E0658]: `#[optimize]` attribute is an unstable feature\n+error[E0658]: the `#[optimize]` attribute is an experimental feature\n   --> $DIR/feature-gate-optimize_attribute.rs:4:1\n    |\n LL | #[optimize(size)]\n@@ -34,7 +34,7 @@ LL | #[optimize(size)]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54882\n    = help: add `#![feature(optimize_attribute)]` to the crate attributes to enable\n \n-error[E0658]: `#[optimize]` attribute is an unstable feature\n+error[E0658]: the `#[optimize]` attribute is an experimental feature\n   --> $DIR/feature-gate-optimize_attribute.rs:2:1\n    |\n LL | #![optimize(speed)]"}, {"sha": "ad890961830806ebc916763f5bccbd788d7617d4", "filename": "src/test/ui/feature-gates/feature-gate-alloc-error-handler.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -5,7 +5,7 @@\n \n use core::alloc::Layout;\n \n-#[alloc_error_handler] //~ ERROR `#[alloc_error_handler]` is an unstable feature\n+#[alloc_error_handler] //~ ERROR the `#[alloc_error_handler]` attribute is an experimental feature\n fn oom(info: Layout) -> ! {\n     loop {}\n }"}, {"sha": "79e44bf0d8ec134af2617abebc84724a348f0f0a", "filename": "src/test/ui/feature-gates/feature-gate-alloc-error-handler.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-alloc-error-handler.stderr?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: `#[alloc_error_handler]` is an unstable feature\n+error[E0658]: the `#[alloc_error_handler]` attribute is an experimental feature\n   --> $DIR/feature-gate-alloc-error-handler.rs:8:1\n    |\n LL | #[alloc_error_handler]"}, {"sha": "287d4ccf18010a6e803c18fc14bc6935524e90b4", "filename": "src/test/ui/feature-gates/feature-gate-allow_fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow_fail.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,6 +1,6 @@\n // check that #[allow_fail] is feature-gated\n \n-#[allow_fail] //~ ERROR allow_fail attribute is currently unstable\n+#[allow_fail] //~ ERROR the `#[allow_fail]` attribute is an experimental feature\n fn ok_to_fail() {\n     assert!(false);\n }"}, {"sha": "0f60a2de3a4e5bca82bed75e7f71b4417e0e7cdb", "filename": "src/test/ui/feature-gates/feature-gate-allow_fail.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow_fail.stderr?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: allow_fail attribute is currently unstable\n+error[E0658]: the `#[allow_fail]` attribute is an experimental feature\n   --> $DIR/feature-gate-allow_fail.rs:3:1\n    |\n LL | #[allow_fail]"}, {"sha": "5050c4792b06499ac63321f64ed035922e99ad74", "filename": "src/test/ui/feature-gates/feature-gate-marker_trait_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-marker_trait_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-marker_trait_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-marker_trait_attr.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,7 +1,7 @@\n use std::fmt::{Debug, Display};\n \n #[marker] trait ExplicitMarker {}\n-//~^ ERROR marker traits is an experimental feature\n+//~^ ERROR the `#[marker]` attribute is an experimental feature\n \n impl<T: Display> ExplicitMarker for T {}\n impl<T: Debug> ExplicitMarker for T {}"}, {"sha": "304c081c5aace38380df52741ae8d9ae77815de6", "filename": "src/test/ui/feature-gates/feature-gate-marker_trait_attr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-marker_trait_attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-marker_trait_attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-marker_trait_attr.stderr?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: marker traits is an experimental feature\n+error[E0658]: the `#[marker]` attribute is an experimental feature\n   --> $DIR/feature-gate-marker_trait_attr.rs:3:1\n    |\n LL | #[marker] trait ExplicitMarker {}"}, {"sha": "706efd786721119b1c06149fa49d0be5c23af180", "filename": "src/test/ui/feature-gates/feature-gate-no_core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_core.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,5 +1,5 @@\n #![crate_type = \"rlib\"]\n \n-#![no_core] //~ ERROR no_core is experimental\n+#![no_core] //~ ERROR the `#[no_core]` attribute is an experimental feature\n \n pub struct S {}"}, {"sha": "a80b3cbba25b1dd27ea0742a36cf47fecd7d1515", "filename": "src/test/ui/feature-gates/feature-gate-no_core.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_core.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_core.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_core.stderr?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: no_core is experimental\n+error[E0658]: the `#[no_core]` attribute is an experimental feature\n   --> $DIR/feature-gate-no_core.rs:3:1\n    |\n LL | #![no_core]"}, {"sha": "950f170f4fd4168bb0cfdd6ba52e25623c21b153", "filename": "src/test/ui/feature-gates/feature-gate-non_exhaustive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,6 +1,6 @@\n //#![feature(non_exhaustive)]\n \n-#[non_exhaustive] //~ERROR non exhaustive is an experimental feature\n+#[non_exhaustive] //~ERROR the `#[non_exhaustive]` attribute is an experimental feature\n pub enum NonExhaustiveEnum {\n     Unit,\n     Tuple(u32),"}, {"sha": "482332b8d706c457e731ae7a7c831dc8ad0977d9", "filename": "src/test/ui/feature-gates/feature-gate-non_exhaustive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive.stderr?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: non exhaustive is an experimental feature\n+error[E0658]: the `#[non_exhaustive]` attribute is an experimental feature\n   --> $DIR/feature-gate-non_exhaustive.rs:3:1\n    |\n LL | #[non_exhaustive]"}, {"sha": "4044fd2b895e49af2199828e9e4d46a7d25ce2ef", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -16,7 +16,7 @@ fn f() {}\n fn g() {}\n \n #[rustc_dummy]\n-//~^ ERROR used by the test suite\n+//~^ ERROR the `#[rustc_dummy]` attribute is just used for rustc unit tests\n #[rustc_unknown]\n //~^ ERROR attributes starting with `rustc` are reserved for use by the `rustc` compiler\n //~| ERROR cannot find attribute macro `rustc_unknown` in this scope"}, {"sha": "c1063027fa4445dcf8f3957c6da87f589c90bb93", "filename": "src/test/ui/feature-gates/feature-gate-rustc-attrs.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-rustc-attrs.stderr?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -43,7 +43,7 @@ error: cannot find attribute macro `rustc_unknown` in this scope\n LL | #[rustc_unknown]\n    |   ^^^^^^^^^^^^^\n \n-error[E0658]: used by the test suite\n+error[E0658]: the `#[rustc_dummy]` attribute is just used for rustc unit tests and will never be stable\n   --> $DIR/feature-gate-rustc-attrs.rs:18:1\n    |\n LL | #[rustc_dummy]"}, {"sha": "6d8ac7e8f2911f3e88ce41d64292cc82ac7a4869", "filename": "src/test/ui/feature-gates/feature-gate-unwind-attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -8,7 +8,7 @@ extern {\n     fn extern_fn();\n // CHECK-NOT: Function Attrs: nounwind\n // CHECK: declare void @unwinding_extern_fn\n-    #[unwind(allowed)] //~ ERROR `#[unwind]` is experimental\n+    #[unwind(allowed)] //~ ERROR the `#[unwind]` attribute is an experimental feature\n     fn unwinding_extern_fn();\n }\n "}, {"sha": "10cc494213507fc27e9b487994264663fe361e6f", "filename": "src/test/ui/feature-gates/feature-gate-unwind-attributes.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unwind-attributes.stderr?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: `#[unwind]` is experimental\n+error[E0658]: the `#[unwind]` attribute is an experimental feature\n   --> $DIR/feature-gate-unwind-attributes.rs:11:5\n    |\n LL |     #[unwind(allowed)]"}, {"sha": "164668f562ce000db9b3a68d0d7b6afd18c1feb7", "filename": "src/test/ui/malformed/malformed-regressions.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-regressions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-regressions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-regressions.stderr?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -26,8 +26,7 @@ LL | #[inline = \"\"]\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #57571 <https://github.com/rust-lang/rust/issues/57571>\n \n-warning: attribute must be of the form `#[link(name = \"...\", /*opt*/ kind = \"dylib|static|...\",\n-                                               /*opt*/ cfg = \"...\")]`\n+warning: attribute must be of the form `#[link(name = \"...\", /*opt*/ kind = \"dylib|static|...\", /*opt*/ cfg = \"...\")]`\n   --> $DIR/malformed-regressions.rs:6:1\n    |\n LL | #[link]\n@@ -36,8 +35,7 @@ LL | #[link]\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #57571 <https://github.com/rust-lang/rust/issues/57571>\n \n-warning: attribute must be of the form `#[link(name = \"...\", /*opt*/ kind = \"dylib|static|...\",\n-                                               /*opt*/ cfg = \"...\")]`\n+warning: attribute must be of the form `#[link(name = \"...\", /*opt*/ kind = \"dylib|static|...\", /*opt*/ cfg = \"...\")]`\n   --> $DIR/malformed-regressions.rs:7:1\n    |\n LL | #[link = \"\"]"}, {"sha": "468e56001012f94fab061f0c9a358cbfcecdfd5f", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2f3174a278d587666b51adafd47d6147e4fd707/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=c2f3174a278d587666b51adafd47d6147e4fd707", "patch": "@@ -221,7 +221,14 @@ fn test_filen_gate(filen_underscore: &str, features: &mut Features) -> bool {\n }\n \n pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n-    let contents = t!(fs::read_to_string(base_src_path.join(\"libsyntax/feature_gate.rs\")));\n+    let mut all = collect_lang_features_in(base_src_path, \"active.rs\", bad);\n+    all.extend(collect_lang_features_in(base_src_path, \"accepted.rs\", bad));\n+    all.extend(collect_lang_features_in(base_src_path, \"removed.rs\", bad));\n+    all\n+}\n+\n+fn collect_lang_features_in(base: &Path, file: &str, bad: &mut bool) -> Features {\n+    let contents = t!(fs::read_to_string(base.join(\"libsyntax/feature_gate\").join(file)));\n \n     // We allow rustc-internal features to omit a tracking issue.\n     // To make tidy accept omitting a tracking issue, group the list of features"}]}