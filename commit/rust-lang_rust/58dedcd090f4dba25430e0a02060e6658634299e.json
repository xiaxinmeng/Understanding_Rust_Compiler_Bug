{"sha": "58dedcd090f4dba25430e0a02060e6658634299e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZGVkY2QwOTBmNGRiYTI1NDMwZTBhMDIwNjBlNjY1ODYzNDI5OWU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T07:07:03Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:54:45Z"}, "message": "Convert lexer to istrs. Issue #855", "tree": {"sha": "b2b42412a9a93ca9009daf049e628a5c2628a8c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2b42412a9a93ca9009daf049e628a5c2628a8c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58dedcd090f4dba25430e0a02060e6658634299e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58dedcd090f4dba25430e0a02060e6658634299e", "html_url": "https://github.com/rust-lang/rust/commit/58dedcd090f4dba25430e0a02060e6658634299e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58dedcd090f4dba25430e0a02060e6658634299e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2ae28fc99328ab1b7176560ed643a84a8883403", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ae28fc99328ab1b7176560ed643a84a8883403", "html_url": "https://github.com/rust-lang/rust/commit/d2ae28fc99328ab1b7176560ed643a84a8883403"}], "stats": {"total": 236, "additions": 134, "deletions": 102}, "files": [{"sha": "a1a7d205b54f1be6b04c670428007bb9bd60a886", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 104, "deletions": 83, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/58dedcd090f4dba25430e0a02060e6658634299e/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dedcd090f4dba25430e0a02060e6658634299e/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=58dedcd090f4dba25430e0a02060e6658634299e", "patch": "@@ -3,6 +3,7 @@ import std::io;\n import std::int;\n import std::vec;\n import std::str;\n+import std::istr;\n import std::map;\n import std::map::hashmap;\n import std::option;\n@@ -19,44 +20,44 @@ type reader =\n         fn next() -> char;\n         fn init();\n         fn bump();\n-        fn get_str_from(uint) -> str;\n-        fn get_interner() -> @interner::interner<str>;\n+        fn get_str_from(uint) -> istr;\n+        fn get_interner() -> @interner::interner<istr>;\n         fn get_chpos() -> uint;\n         fn get_byte_pos() -> uint;\n         fn get_col() -> uint;\n         fn get_filemap() -> codemap::filemap;\n-        fn err(str);\n+        fn err(&istr);\n     };\n \n-fn new_reader(cm: &codemap::codemap, src: str, filemap: codemap::filemap,\n-              itr: @interner::interner<str>) -> reader {\n+fn new_reader(cm: &codemap::codemap, src: &istr, filemap: codemap::filemap,\n+              itr: @interner::interner<istr>) -> reader {\n     obj reader(cm: codemap::codemap,\n-               src: str,\n+               src: istr,\n                len: uint,\n                mutable col: uint,\n                mutable pos: uint,\n                mutable ch: char,\n                mutable chpos: uint,\n-               mutable strs: [str],\n+               mutable strs: [istr],\n                fm: codemap::filemap,\n-               itr: @interner::interner<str>) {\n+               itr: @interner::interner<istr>) {\n         fn is_eof() -> bool { ret ch == -1 as char; }\n-        fn get_str_from(start: uint) -> str {\n+        fn get_str_from(start: uint) -> istr {\n             // I'm pretty skeptical about this subtraction. What if there's a\n             // multi-byte character before the mark?\n-            ret str::slice(src, start - 1u, pos - 1u);\n+            ret istr::slice(src, start - 1u, pos - 1u);\n         }\n         fn get_chpos() -> uint { ret chpos; }\n         fn get_byte_pos() -> uint { ret pos; }\n         fn curr() -> char { ret ch; }\n         fn next() -> char {\n             if pos < len {\n-                ret str::char_at(src, pos);\n+                ret istr::char_at(src, pos);\n             } else { ret -1 as char; }\n         }\n         fn init() {\n             if pos < len {\n-                let next = str::char_range_at(src, pos);\n+                let next = istr::char_range_at(src, pos);\n                 pos = next.next;\n                 ch = next.ch;\n             }\n@@ -69,21 +70,23 @@ fn new_reader(cm: &codemap::codemap, src: str, filemap: codemap::filemap,\n                     codemap::next_line(fm, chpos, pos + fm.start_pos.byte);\n                     col = 0u;\n                 }\n-                let next = str::char_range_at(src, pos);\n+                let next = istr::char_range_at(src, pos);\n                 pos = next.next;\n                 ch = next.ch;\n             } else { ch = -1 as char; }\n         }\n-        fn get_interner() -> @interner::interner<str> { ret itr; }\n+        fn get_interner() -> @interner::interner<istr> { ret itr; }\n         fn get_col() -> uint { ret col; }\n         fn get_filemap() -> codemap::filemap { ret fm; }\n-        fn err(m: str) {\n-            codemap::emit_error(some(ast_util::mk_sp(chpos, chpos)), m, cm);\n+        fn err(m: &istr) {\n+            codemap::emit_error(\n+                some(ast_util::mk_sp(chpos, chpos)),\n+                istr::to_estr(m), cm);\n         }\n     }\n-    let strs: [str] = [];\n+    let strs: [istr] = [];\n     let rd =\n-        reader(cm, src, str::byte_len(src), 0u, 0u, -1 as char,\n+        reader(cm, src, istr::byte_len(src), 0u, 0u, -1 as char,\n                filemap.start_pos.ch, strs, filemap, itr);\n     rd.init();\n     ret rd;\n@@ -146,7 +149,9 @@ fn consume_any_line_comment(rdr: &reader) {\n fn consume_block_comment(rdr: &reader) {\n     let level: int = 1;\n     while level > 0 {\n-        if rdr.is_eof() { rdr.err(\"unterminated block comment\"); fail; }\n+        if rdr.is_eof() {\n+            rdr.err(~\"unterminated block comment\"); fail;\n+        }\n         if rdr.curr() == '/' && rdr.next() == '*' {\n             rdr.bump();\n             rdr.bump();\n@@ -164,35 +169,35 @@ fn consume_block_comment(rdr: &reader) {\n     be consume_whitespace_and_comments(rdr);\n }\n \n-fn digits_to_string(s: str) -> int {\n+fn digits_to_string(s: &istr) -> int {\n     let accum_int: int = 0;\n     for c: u8 in s { accum_int *= 10; accum_int += dec_digit_val(c as char); }\n     ret accum_int;\n }\n \n-fn scan_exponent(rdr: &reader) -> option::t<str> {\n+fn scan_exponent(rdr: &reader) -> option::t<istr> {\n     let c = rdr.curr();\n-    let rslt = \"\";\n+    let rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n-        rslt += str::unsafe_from_bytes([c as u8]);\n+        rslt += istr::unsafe_from_bytes([c as u8]);\n         rdr.bump();\n         c = rdr.curr();\n         if c == '-' || c == '+' {\n-            rslt += str::unsafe_from_bytes([c as u8]);\n+            rslt += istr::unsafe_from_bytes([c as u8]);\n             rdr.bump();\n         }\n         let exponent = scan_dec_digits(rdr);\n-        if str::byte_len(exponent) > 0u {\n+        if istr::byte_len(exponent) > 0u {\n             ret some(rslt + exponent);\n-        } else { rdr.err(\"scan_exponent: bad fp literal\"); fail; }\n-    } else { ret none::<str>; }\n+        } else { rdr.err(~\"scan_exponent: bad fp literal\"); fail; }\n+    } else { ret none::<istr>; }\n }\n \n-fn scan_dec_digits(rdr: &reader) -> str {\n+fn scan_dec_digits(rdr: &reader) -> istr {\n     let c = rdr.curr();\n-    let rslt: str = \"\";\n+    let rslt: istr = ~\"\";\n     while is_dec_digit(c) || c == '_' {\n-        if c != '_' { rslt += str::unsafe_from_bytes([c as u8]); }\n+        if c != '_' { rslt += istr::unsafe_from_bytes([c as u8]); }\n         rdr.bump();\n         c = rdr.curr();\n     }\n@@ -201,7 +206,7 @@ fn scan_dec_digits(rdr: &reader) -> str {\n \n fn scan_number(c: char, rdr: &reader) -> token::token {\n     let accum_int = 0;\n-    let dec_str: str = \"\";\n+    let dec_str: istr = ~\"\";\n     let is_dec_integer: bool = false;\n     let n = rdr.next();\n     if c == '0' && n == 'x' {\n@@ -272,7 +277,7 @@ fn scan_number(c: char, rdr: &reader) -> token::token {\n \n         rdr.bump();\n         let dec_part = scan_dec_digits(rdr);\n-        let float_str = dec_str + \".\" + dec_part;\n+        let float_str = dec_str + ~\".\" + dec_part;\n         c = rdr.curr();\n         let exponent_str = scan_exponent(rdr);\n         alt exponent_str { some(s) { float_str += s; } none. { } }\n@@ -298,15 +303,17 @@ fn scan_number(c: char, rdr: &reader) -> token::token {\n \n             }\n         } else {\n-            ret token::LIT_FLOAT(interner::intern::<str>(*rdr.get_interner(),\n-                                                         float_str));\n+            ret token::LIT_FLOAT(interner::intern::<istr>(\n+                *rdr.get_interner(),\n+                float_str));\n         }\n     }\n     let maybe_exponent = scan_exponent(rdr);\n     alt maybe_exponent {\n       some(s) {\n-        ret token::LIT_FLOAT(interner::intern::<str>(*rdr.get_interner(),\n-                                                     dec_str + s));\n+        ret token::LIT_FLOAT(interner::intern::<istr>(\n+            *rdr.get_interner(),\n+            dec_str + s));\n       }\n       none. { ret token::LIT_INT(accum_int); }\n     }\n@@ -318,7 +325,9 @@ fn scan_numeric_escape(rdr: &reader, n_hex_digits: uint) -> char {\n         let n = rdr.curr();\n         rdr.bump();\n         if !is_hex_digit(n) {\n-            rdr.err(#fmt[\"illegal numeric character escape: %d\", n as int]);\n+            rdr.err(\n+                istr::from_estr(\n+                    #fmt[\"illegal numeric character escape: %d\", n as int]));\n             fail;\n         }\n         accum_int *= 16;\n@@ -337,18 +346,19 @@ fn next_token(rdr: &reader) -> {tok: token::token, chpos: uint, bpos: uint} {\n }\n \n fn next_token_inner(rdr: &reader) -> token::token {\n-    let accum_str = \"\";\n+    let accum_str = ~\"\";\n     let c = rdr.curr();\n     if is_alpha(c) || c == '_' {\n         while is_alnum(c) || c == '_' {\n-            str::push_char(accum_str, c);\n+            istr::push_char(accum_str, c);\n             rdr.bump();\n             c = rdr.curr();\n         }\n-        if str::eq(accum_str, \"_\") { ret token::UNDERSCORE; }\n+        if istr::eq(accum_str, ~\"_\") { ret token::UNDERSCORE; }\n         let is_mod_name = c == ':' && rdr.next() == ':';\n-        ret token::IDENT(interner::intern::<str>(*rdr.get_interner(),\n-                                                 accum_str), is_mod_name);\n+        ret token::IDENT(interner::intern::<istr>(\n+            *rdr.get_interner(),\n+            accum_str), is_mod_name);\n     }\n     if is_dec_digit(c) { ret scan_number(c, rdr); }\n     fn binop(rdr: &reader, op: token::binop) -> token::token {\n@@ -460,13 +470,15 @@ fn next_token_inner(rdr: &reader) -> token::token {\n               'u' { c2 = scan_numeric_escape(rdr, 4u); }\n               'U' { c2 = scan_numeric_escape(rdr, 8u); }\n               c2 {\n-                rdr.err(#fmt[\"unknown character escape: %d\", c2 as int]);\n+                rdr.err(\n+                    istr::from_estr(#fmt[\"unknown character escape: %d\",\n+                                         c2 as int]));\n                 fail;\n               }\n             }\n         }\n         if rdr.curr() != '\\'' {\n-            rdr.err(\"unterminated character constant\");\n+            rdr.err(~\"unterminated character constant\");\n             fail;\n         }\n         rdr.bump(); // advance curr past token\n@@ -483,33 +495,36 @@ fn next_token_inner(rdr: &reader) -> token::token {\n                 let escaped = rdr.curr();\n                 rdr.bump();\n                 alt escaped {\n-                  'n' { str::push_byte(accum_str, '\\n' as u8); }\n-                  'r' { str::push_byte(accum_str, '\\r' as u8); }\n-                  't' { str::push_byte(accum_str, '\\t' as u8); }\n-                  '\\\\' { str::push_byte(accum_str, '\\\\' as u8); }\n-                  '\"' { str::push_byte(accum_str, '\"' as u8); }\n+                  'n' { istr::push_byte(accum_str, '\\n' as u8); }\n+                  'r' { istr::push_byte(accum_str, '\\r' as u8); }\n+                  't' { istr::push_byte(accum_str, '\\t' as u8); }\n+                  '\\\\' { istr::push_byte(accum_str, '\\\\' as u8); }\n+                  '\"' { istr::push_byte(accum_str, '\"' as u8); }\n                   '\\n' { consume_whitespace(rdr); }\n                   'x' {\n-                    str::push_char(accum_str, scan_numeric_escape(rdr, 2u));\n+                    istr::push_char(accum_str, scan_numeric_escape(rdr, 2u));\n                   }\n                   'u' {\n-                    str::push_char(accum_str, scan_numeric_escape(rdr, 4u));\n+                    istr::push_char(accum_str, scan_numeric_escape(rdr, 4u));\n                   }\n                   'U' {\n-                    str::push_char(accum_str, scan_numeric_escape(rdr, 8u));\n+                    istr::push_char(accum_str, scan_numeric_escape(rdr, 8u));\n                   }\n                   c2 {\n-                    rdr.err(#fmt[\"unknown string escape: %d\", c2 as int]);\n+                    rdr.err(\n+                        istr::from_estr(#fmt[\"unknown string escape: %d\",\n+                                             c2 as int]));\n                     fail;\n                   }\n                 }\n               }\n-              _ { str::push_char(accum_str, ch); }\n+              _ { istr::push_char(accum_str, ch); }\n             }\n         }\n         rdr.bump();\n-        ret token::LIT_STR(interner::intern::<str>(*rdr.get_interner(),\n-                                                   accum_str));\n+        ret token::LIT_STR(interner::intern::<istr>(\n+            *rdr.get_interner(),\n+            accum_str));\n       }\n       '-' {\n         if rdr.next() == '>' {\n@@ -536,7 +551,11 @@ fn next_token_inner(rdr: &reader) -> token::token {\n       '/' { ret binop(rdr, token::SLASH); }\n       '^' { ret binop(rdr, token::CARET); }\n       '%' { ret binop(rdr, token::PERCENT); }\n-      c { rdr.err(#fmt[\"unkown start of token: %d\", c as int]); fail; }\n+      c {\n+        rdr.err(\n+            istr::from_estr(#fmt[\"unkown start of token: %d\", c as int]));\n+        fail;\n+      }\n     }\n }\n \n@@ -547,19 +566,19 @@ tag cmnt_style {\n     blank_line; // Just a manual blank line \"\\n\\n\", for layout\n }\n \n-type cmnt = {style: cmnt_style, lines: [str], pos: uint};\n+type cmnt = {style: cmnt_style, lines: [istr], pos: uint};\n \n-fn read_to_eol(rdr: &reader) -> str {\n-    let val = \"\";\n+fn read_to_eol(rdr: &reader) -> istr {\n+    let val = ~\"\";\n     while rdr.curr() != '\\n' && !rdr.is_eof() {\n-        str::push_char(val, rdr.curr());\n+        istr::push_char(val, rdr.curr());\n         rdr.bump();\n     }\n     if rdr.curr() == '\\n' { rdr.bump(); }\n     ret val;\n }\n \n-fn read_one_line_comment(rdr: &reader) -> str {\n+fn read_one_line_comment(rdr: &reader) -> istr {\n     let val = read_to_eol(rdr);\n     assert (val[0] == '/' as u8 && val[1] == '/' as u8);\n     ret val;\n@@ -577,7 +596,7 @@ fn consume_non_eol_whitespace(rdr: &reader) {\n \n fn push_blank_line_comment(rdr: &reader, comments: &mutable [cmnt]) {\n     log \">>> blank-line comment\";\n-    let v: [str] = [];\n+    let v: [istr] = [];\n     comments += [{style: blank_line, lines: v, pos: rdr.get_chpos()}];\n }\n \n@@ -594,7 +613,7 @@ fn consume_whitespace_counting_blank_lines(rdr: &reader,\n fn read_line_comments(rdr: &reader, code_to_the_left: bool) -> cmnt {\n     log \">>> line comments\";\n     let p = rdr.get_chpos();\n-    let lines: [str] = [];\n+    let lines: [istr] = [];\n     while rdr.curr() == '/' && rdr.next() == '/' {\n         let line = read_one_line_comment(rdr);\n         log line;\n@@ -607,58 +626,58 @@ fn read_line_comments(rdr: &reader, code_to_the_left: bool) -> cmnt {\n          pos: p};\n }\n \n-fn all_whitespace(s: &str, begin: uint, end: uint) -> bool {\n+fn all_whitespace(s: &istr, begin: uint, end: uint) -> bool {\n     let i: uint = begin;\n     while i != end { if !is_whitespace(s[i] as char) { ret false; } i += 1u; }\n     ret true;\n }\n \n-fn trim_whitespace_prefix_and_push_line(lines: &mutable [str], s: &str,\n+fn trim_whitespace_prefix_and_push_line(lines: &mutable [istr], s: &istr,\n                                         col: uint) {\n     let s1;\n     if all_whitespace(s, 0u, col) {\n-        if col < str::byte_len(s) {\n-            s1 = str::slice(s, col, str::byte_len(s));\n-        } else { s1 = \"\"; }\n+        if col < istr::byte_len(s) {\n+            s1 = istr::slice(s, col, istr::byte_len(s));\n+        } else { s1 = ~\"\"; }\n     } else { s1 = s; }\n-    log \"pushing line: \" + s1;\n+    log ~\"pushing line: \" + s1;\n     lines += [s1];\n }\n \n fn read_block_comment(rdr: &reader, code_to_the_left: bool) -> cmnt {\n     log \">>> block comment\";\n     let p = rdr.get_chpos();\n-    let lines: [str] = [];\n+    let lines: [istr] = [];\n     let col: uint = rdr.get_col();\n     rdr.bump();\n     rdr.bump();\n-    let curr_line = \"/*\";\n+    let curr_line = ~\"/*\";\n     let level: int = 1;\n     while level > 0 {\n         log #fmt[\"=== block comment level %d\", level];\n-        if rdr.is_eof() { rdr.err(\"unterminated block comment\"); fail; }\n+        if rdr.is_eof() { rdr.err(~\"unterminated block comment\"); fail; }\n         if rdr.curr() == '\\n' {\n             trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n-            curr_line = \"\";\n+            curr_line = ~\"\";\n             rdr.bump();\n         } else {\n-            str::push_char(curr_line, rdr.curr());\n+            istr::push_char(curr_line, rdr.curr());\n             if rdr.curr() == '/' && rdr.next() == '*' {\n                 rdr.bump();\n                 rdr.bump();\n-                curr_line += \"*\";\n+                curr_line += ~\"*\";\n                 level += 1;\n             } else {\n                 if rdr.curr() == '*' && rdr.next() == '/' {\n                     rdr.bump();\n                     rdr.bump();\n-                    curr_line += \"/\";\n+                    curr_line += ~\"/\";\n                     level -= 1;\n                 } else { rdr.bump(); }\n             }\n         }\n     }\n-    if str::byte_len(curr_line) != 0u {\n+    if istr::byte_len(curr_line) != 0u {\n         trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n     }\n     let style = if code_to_the_left { trailing } else { isolated };\n@@ -700,14 +719,16 @@ fn is_lit(t: &token::token) -> bool {\n         }\n }\n \n-type lit = {lit: str, pos: uint};\n+type lit = {lit: istr, pos: uint};\n \n-fn gather_comments_and_literals(cm: &codemap::codemap, path: str,\n+fn gather_comments_and_literals(cm: &codemap::codemap, path: &istr,\n                                 srdr: io::reader) ->\n    {cmnts: [cmnt], lits: [lit]} {\n-    let src = str::unsafe_from_bytes(srdr.read_whole_stream());\n-    let itr = @interner::mk::<str>(str::hash, str::eq);\n-    let rdr = new_reader(cm, src, codemap::new_filemap(path, 0u, 0u), itr);\n+    let src = istr::unsafe_from_bytes(srdr.read_whole_stream());\n+    let itr = @interner::mk::<istr>(istr::hash, istr::eq);\n+    let rdr = new_reader(cm, src,\n+                         codemap::new_filemap(\n+                             istr::to_estr(path), 0u, 0u), itr);\n     let comments: [cmnt] = [];\n     let literals: [lit] = [];\n     let first_read: bool = true;"}, {"sha": "7e163751cd19bb7b126aa963efa7ed1fca7a548e", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/58dedcd090f4dba25430e0a02060e6658634299e/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dedcd090f4dba25430e0a02060e6658634299e/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=58dedcd090f4dba25430e0a02060e6658634299e", "patch": "@@ -63,10 +63,10 @@ type parser =\n fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, path: str,\n                         chpos: uint, byte_pos: uint, ftype: file_type) ->\n    parser {\n-    let src = istr::to_estr(io::read_whole_file_str(istr::from_estr(path)));\n+    let src = io::read_whole_file_str(istr::from_estr(path));\n     let filemap = codemap::new_filemap(path, chpos, byte_pos);\n     sess.cm.files += [filemap];\n-    let itr = @interner::mk(str::hash, str::eq);\n+    let itr = @interner::mk(istr::hash, istr::eq);\n     let rdr = lexer::new_reader(sess.cm, src, filemap, itr);\n \n     ret new_parser(sess, cfg, rdr, ftype);\n@@ -128,7 +128,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n         fn get_cfg() -> ast::crate_cfg { ret cfg; }\n         fn get_prec_table() -> @[op_spec] { ret precs; }\n         fn get_str(i: token::str_num) -> str {\n-            ret interner::get(*rdr.get_interner(), i);\n+            ret istr::to_estr(interner::get(*rdr.get_interner(), i));\n         }\n         fn get_reader() -> lexer::reader { ret rdr; }\n         fn get_filemap() -> codemap::filemap { ret rdr.get_filemap(); }\n@@ -2434,8 +2434,9 @@ fn parse_crate_from_source_str(name: &str, source: &str, cfg: &ast::crate_cfg,\n     let ftype = SOURCE_FILE;\n     let filemap = codemap::new_filemap(name, 0u, 0u);\n     sess.cm.files += [filemap];\n-    let itr = @interner::mk(str::hash, str::eq);\n-    let rdr = lexer::new_reader(sess.cm, source, filemap, itr);\n+    let itr = @interner::mk(istr::hash, istr::eq);\n+    let rdr = lexer::new_reader(sess.cm, istr::from_estr(source),\n+                                filemap, itr);\n     let p = new_parser(sess, cfg, rdr, ftype);\n     ret parse_crate_mod(p, cfg);\n }"}, {"sha": "90303542123c92cab526cb2013ab7cedb21c5323", "filename": "src/comp/syntax/parse/token.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/58dedcd090f4dba25430e0a02060e6658634299e/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dedcd090f4dba25430e0a02060e6658634299e/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=58dedcd090f4dba25430e0a02060e6658634299e", "patch": "@@ -152,12 +152,17 @@ fn to_str(r: lexer::reader, t: token) -> str {\n         ret istr::to_estr(int::to_str(i, 10u)) + \"_\" + ty_mach_to_str(tm);\n       }\n       LIT_MACH_FLOAT(tm, s) {\n-        ret interner::get::<str>(*r.get_interner(), s) + \"_\" +\n-                ty_mach_to_str(tm);\n+        ret istr::to_estr(interner::get::<istr>(\n+            *r.get_interner(), s) + ~\"_\") +\n+            ty_mach_to_str(tm);\n+      }\n+      LIT_FLOAT(s) {\n+        ret istr::to_estr(interner::get::<istr>(*r.get_interner(), s));\n       }\n-      LIT_FLOAT(s) { ret interner::get::<str>(*r.get_interner(), s); }\n       LIT_STR(s) { // FIXME: escape.\n-        ret \"\\\"\" + interner::get::<str>(*r.get_interner(), s) + \"\\\"\";\n+        ret \"\\\"\" +\n+            istr::to_estr(interner::get::<istr>(*r.get_interner(), s))\n+            + \"\\\"\";\n       }\n       LIT_CHAR(c) {\n         // FIXME: escape.\n@@ -171,7 +176,7 @@ fn to_str(r: lexer::reader, t: token) -> str {\n \n       /* Name components */\n       IDENT(s, _) {\n-        ret interner::get::<str>(*r.get_interner(), s);\n+        ret istr::to_estr(interner::get::<istr>(*r.get_interner(), s));\n       }\n       IDX(i) { ret istr::to_estr(~\"_\" + int::to_str(i, 10u)); }\n       UNDERSCORE. { ret \"_\"; }"}, {"sha": "7def22f8bd3d03dbde25db1484b80a72810f1c66", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/58dedcd090f4dba25430e0a02060e6658634299e/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dedcd090f4dba25430e0a02060e6658634299e/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=58dedcd090f4dba25430e0a02060e6658634299e", "patch": "@@ -78,7 +78,8 @@ const default_columns: uint = 78u;\n fn print_crate(cm: &codemap, crate: @ast::crate, filename: str,\n                in: io::reader, out: io::writer, ann: &pp_ann) {\n     let boxes: [pp::breaks] = [];\n-    let r = lexer::gather_comments_and_literals(cm, filename, in);\n+    let r = lexer::gather_comments_and_literals(\n+        cm, istr::from_estr(filename), in);\n     let s =\n         @{s: pp::mk_printer(out, default_columns),\n           cm: some(cm),\n@@ -1499,7 +1500,7 @@ fn print_literal(s: &ps, lit: &@ast::lit) {\n               ast::lit_str(_, ast::sk_unique.) { word(s.s, \"~\"); }\n               _ { }\n             }\n-            word(s.s, lt.lit);\n+            word(s.s, istr::to_estr(lt.lit));\n             s.cur_lit += 1u;\n             ret;\n         }\n@@ -1567,27 +1568,31 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n       lexer::mixed. {\n         assert (vec::len(cmnt.lines) == 1u);\n         zerobreak(s.s);\n-        word(s.s, cmnt.lines[0]);\n+        word(s.s, istr::to_estr(cmnt.lines[0]));\n         zerobreak(s.s);\n       }\n       lexer::isolated. {\n         pprust::hardbreak_if_not_bol(s);\n-        for line: str in cmnt.lines {\n+        for line: istr in cmnt.lines {\n             // Don't print empty lines because they will end up as trailing\n             // whitespace\n-            if str::is_not_empty(line) { word(s.s, line); }\n+            if istr::is_not_empty(line) {\n+                word(s.s, istr::to_estr(line));\n+            }\n             hardbreak(s.s);\n         }\n       }\n       lexer::trailing. {\n         word(s.s, \" \");\n         if vec::len(cmnt.lines) == 1u {\n-            word(s.s, cmnt.lines[0]);\n+            word(s.s, istr::to_estr(cmnt.lines[0]));\n             hardbreak(s.s);\n         } else {\n             ibox(s, 0u);\n-            for line: str in cmnt.lines {\n-                if str::is_not_empty(line) { word(s.s, line); }\n+            for line: istr in cmnt.lines {\n+                if istr::is_not_empty(line) {\n+                    word(s.s, istr::to_estr(line));\n+                }\n                 hardbreak(s.s);\n             }\n             end(s);"}, {"sha": "808ce458eb22b8c86c56c9a29a55e0e4a0fc9d9f", "filename": "src/lib/istr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dedcd090f4dba25430e0a02060e6658634299e/src%2Flib%2Fistr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dedcd090f4dba25430e0a02060e6658634299e/src%2Flib%2Fistr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fistr.rs?ref=58dedcd090f4dba25430e0a02060e6658634299e", "patch": "@@ -4,7 +4,7 @@ concat, connect, to_upper, replace, char_slice, trim_left, trim_right, trim,\n unshift_char, shift_char, pop_char, push_char, is_utf8, from_chars, to_chars,\n char_len, char_at, bytes, is_ascii, shift_byte, pop_byte, unsafe_from_byte,\n unsafe_from_bytes, from_char, char_range_at, str_from_cstr, sbuf,\n-as_buf;\n+as_buf, push_byte;\n \n export from_estr, to_estr, from_estrs, to_estrs;\n "}]}