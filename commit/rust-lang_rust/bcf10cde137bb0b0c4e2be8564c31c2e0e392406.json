{"sha": "bcf10cde137bb0b0c4e2be8564c31c2e0e392406", "node_id": "C_kwDOAAsO6NoAKGJjZjEwY2RlMTM3YmIwYjBjNGUyYmU4NTY0YzMxYzJlMGUzOTI0MDY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-20T13:07:48Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-20T13:07:48Z"}, "message": "internal: Remove `previous_token` field from `CompletionContext`", "tree": {"sha": "2bd2c6efa006e3bdb12eeddb011fb6c6521985c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bd2c6efa006e3bdb12eeddb011fb6c6521985c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcf10cde137bb0b0c4e2be8564c31c2e0e392406", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcf10cde137bb0b0c4e2be8564c31c2e0e392406", "html_url": "https://github.com/rust-lang/rust/commit/bcf10cde137bb0b0c4e2be8564c31c2e0e392406", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcf10cde137bb0b0c4e2be8564c31c2e0e392406/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90483321ee0b47d48a5019bd9bbb11b45a24ac84", "url": "https://api.github.com/repos/rust-lang/rust/commits/90483321ee0b47d48a5019bd9bbb11b45a24ac84", "html_url": "https://github.com/rust-lang/rust/commit/90483321ee0b47d48a5019bd9bbb11b45a24ac84"}], "stats": {"total": 87, "additions": 50, "deletions": 37}, "files": [{"sha": "3f9314bbb3147e8c026c131fcdaa1abc694303e4", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcf10cde137bb0b0c4e2be8564c31c2e0e392406/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf10cde137bb0b0c4e2be8564c31c2e0e392406/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=bcf10cde137bb0b0c4e2be8564c31c2e0e392406", "patch": "@@ -541,8 +541,8 @@ pub(super) fn complete_name_ref(\n         NameRefKind::Keyword(item) => {\n             keyword::complete_for_and_where(acc, ctx, item);\n         }\n-        NameRefKind::RecordExpr(record_expr) => {\n-            record::complete_record_expr_fields(acc, ctx, record_expr);\n+        NameRefKind::RecordExpr { dot_prefix, expr } => {\n+            record::complete_record_expr_fields(acc, ctx, expr, dot_prefix);\n         }\n         NameRefKind::Pattern(pattern_ctx) => complete_patterns(acc, ctx, pattern_ctx),\n     }"}, {"sha": "3115971c857d29a21d5cf6bad0aa426b7407ddf5", "filename": "crates/ide-completion/src/completions/attribute.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bcf10cde137bb0b0c4e2be8564c31c2e0e392406/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf10cde137bb0b0c4e2be8564c31c2e0e392406/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=bcf10cde137bb0b0c4e2be8564c31c2e0e392406", "patch": "@@ -33,6 +33,7 @@ pub(crate) use self::derive::complete_derive_path;\n pub(crate) fn complete_known_attribute_input(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n+    &colon_prefix: &bool,\n     fake_attribute_under_caret: &ast::Attr,\n ) -> Option<()> {\n     let attribute = fake_attribute_under_caret;\n@@ -47,7 +48,9 @@ pub(crate) fn complete_known_attribute_input(\n \n     match path.text().as_str() {\n         \"repr\" => repr::complete_repr(acc, ctx, tt),\n-        \"feature\" => lint::complete_lint(acc, ctx, &parse_tt_as_comma_sep_paths(tt)?, FEATURES),\n+        \"feature\" => {\n+            lint::complete_lint(acc, ctx, colon_prefix, &parse_tt_as_comma_sep_paths(tt)?, FEATURES)\n+        }\n         \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n             let existing_lints = parse_tt_as_comma_sep_paths(tt)?;\n \n@@ -60,7 +63,7 @@ pub(crate) fn complete_known_attribute_input(\n                 .cloned()\n                 .collect();\n \n-            lint::complete_lint(acc, ctx, &existing_lints, &lints);\n+            lint::complete_lint(acc, ctx, colon_prefix, &existing_lints, &lints);\n         }\n         \"cfg\" => cfg::complete_cfg(acc, ctx),\n         _ => (),"}, {"sha": "5c0481031871fb99e01d573e20bb45ed896a1c4b", "filename": "crates/ide-completion/src/completions/attribute/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcf10cde137bb0b0c4e2be8564c31c2e0e392406/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf10cde137bb0b0c4e2be8564c31c2e0e392406/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs?ref=bcf10cde137bb0b0c4e2be8564c31c2e0e392406", "patch": "@@ -1,16 +1,16 @@\n //! Completion for lints\n use ide_db::{generated::lints::Lint, SymbolKind};\n-use syntax::{ast, T};\n+use syntax::ast;\n \n use crate::{context::CompletionContext, item::CompletionItem, Completions};\n \n pub(super) fn complete_lint(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n+    is_qualified: bool,\n     existing_lints: &[ast::Path],\n     lints_completions: &[Lint],\n ) {\n-    let is_qualified = ctx.previous_token_is(T![:]);\n     for &Lint { label, description } in lints_completions {\n         let (qual, name) = {\n             // FIXME: change `Lint`'s label to not store a path in it but split the prefix off instead?"}, {"sha": "9f834e1ca1588e79b3b6dec722cf894b75c360f1", "filename": "crates/ide-completion/src/completions/record.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bcf10cde137bb0b0c4e2be8564c31c2e0e392406/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf10cde137bb0b0c4e2be8564c31c2e0e392406/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=bcf10cde137bb0b0c4e2be8564c31c2e0e392406", "patch": "@@ -1,9 +1,6 @@\n //! Complete fields in record literals and patterns.\n use ide_db::SymbolKind;\n-use syntax::{\n-    ast::{self, Expr},\n-    T,\n-};\n+use syntax::ast::{self, Expr};\n \n use crate::{\n     context::{ExprCtx, PathCompletionCtx, PatternContext, Qualified},\n@@ -24,6 +21,7 @@ pub(crate) fn complete_record_expr_fields(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n     record_expr: &ast::RecordExpr,\n+    &dot_prefix: &bool,\n ) {\n     let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_expr.clone()));\n \n@@ -45,7 +43,7 @@ pub(crate) fn complete_record_expr_fields(\n             let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n \n             add_default_update(acc, ctx, ty, &missing_fields);\n-            if ctx.previous_token_is(T![.]) {\n+            if dot_prefix {\n                 let mut item =\n                     CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), \"..\");\n                 item.insert_text(\".\");"}, {"sha": "9aee1e8b49ebc5b0e0e49d2d0f909250ebfa8246", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bcf10cde137bb0b0c4e2be8564c31c2e0e392406/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf10cde137bb0b0c4e2be8564c31c2e0e392406/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=bcf10cde137bb0b0c4e2be8564c31c2e0e392406", "patch": "@@ -259,8 +259,11 @@ pub(super) enum NameRefKind {\n     DotAccess(DotAccess),\n     /// Position where we are only interested in keyword completions\n     Keyword(ast::Item),\n-    /// The record expression this nameref is a field of\n-    RecordExpr(ast::RecordExpr),\n+    /// The record expression this nameref is a field of and whether a dot precedes the completion identifier.\n+    RecordExpr {\n+        dot_prefix: bool,\n+        expr: ast::RecordExpr,\n+    },\n     Pattern(PatternContext),\n }\n \n@@ -279,6 +282,7 @@ pub(super) enum IdentContext {\n     },\n     /// Set if we are currently completing in an unexpanded attribute, this usually implies a builtin attribute like `allow($0)`\n     UnexpandedAttrTT {\n+        colon_prefix: bool,\n         fake_attribute_under_caret: Option<ast::Attr>,\n     },\n }\n@@ -334,9 +338,6 @@ pub(crate) struct CompletionContext<'a> {\n     /// The expected type of what we are completing.\n     pub(super) expected_type: Option<Type>,\n \n-    // FIXME: This shouldn't exist\n-    pub(super) previous_token: Option<SyntaxToken>,\n-\n     // We might wanna split these out of CompletionContext\n     pub(super) ident_ctx: IdentContext,\n     pub(super) qualifier_ctx: QualifierCtx,\n@@ -361,11 +362,6 @@ impl<'a> CompletionContext<'a> {\n         }\n     }\n \n-    // FIXME: This shouldn't exist\n-    pub(crate) fn previous_token_is(&self, kind: SyntaxKind) -> bool {\n-        self.previous_token.as_ref().map_or(false, |tok| tok.kind() == kind)\n-    }\n-\n     pub(crate) fn famous_defs(&self) -> FamousDefs {\n         FamousDefs(&self.sema, self.krate)\n     }\n@@ -507,9 +503,11 @@ impl<'a> CompletionContext<'a> {\n             module,\n             expected_name: None,\n             expected_type: None,\n-            previous_token: None,\n             // dummy value, will be overwritten\n-            ident_ctx: IdentContext::UnexpandedAttrTT { fake_attribute_under_caret: None },\n+            ident_ctx: IdentContext::UnexpandedAttrTT {\n+                fake_attribute_under_caret: None,\n+                colon_prefix: false,\n+            },\n             qualifier_ctx: Default::default(),\n             locals,\n         };"}, {"sha": "1f691f3baf6c58d0de8dd29ccc2b07338fd5f376", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bcf10cde137bb0b0c4e2be8564c31c2e0e392406/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf10cde137bb0b0c4e2be8564c31c2e0e392406/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=bcf10cde137bb0b0c4e2be8564c31c2e0e392406", "patch": "@@ -254,7 +254,9 @@ impl<'a> CompletionContext<'a> {\n                     // match foo { $0 }\n                     // match foo { ..., pat => $0 }\n                     ast::MatchExpr(it) => {\n-                        let ty = if self.previous_token_is(T![=>]) {\n+                        let on_arrow = previous_non_trivia_token(self.token.clone()).map_or(false, |it| T![=>] == it.kind());\n+\n+                        let ty = if on_arrow {\n                             // match foo { ..., pat => $0 }\n                             cov_mark::hit!(expected_type_match_arm_body_without_leading_char);\n                             cov_mark::hit!(expected_type_match_arm_body_with_leading_char);\n@@ -327,9 +329,6 @@ impl<'a> CompletionContext<'a> {\n             return None;\n         }\n \n-        self.previous_token =\n-            syntax_element.clone().into_token().and_then(previous_non_trivia_token);\n-\n         (self.expected_type, self.expected_name) = self.expected_type_and_name();\n \n         // Overwrite the path kind for derives\n@@ -368,19 +367,19 @@ impl<'a> CompletionContext<'a> {\n                 } else {\n                     // Fix up trailing whitespace problem\n                     // #[attr(foo = $0\n-                    let token = if self.token.kind() == SyntaxKind::WHITESPACE {\n-                        self.previous_token.as_ref()?\n-                    } else {\n-                        &self.token\n-                    };\n+                    let token =\n+                        syntax::algo::skip_trivia_token(self.token.clone(), Direction::Prev)?;\n                     let p = token.parent()?;\n                     if p.kind() == SyntaxKind::TOKEN_TREE\n                         && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n                     {\n+                        let colon_prefix = previous_non_trivia_token(self.token.clone())\n+                            .map_or(false, |it| T![:] == it.kind());\n                         self.ident_ctx = IdentContext::UnexpandedAttrTT {\n                             fake_attribute_under_caret: syntax_element\n                                 .ancestors()\n                                 .find_map(ast::Attr::cast),\n+                            colon_prefix,\n                         };\n                     } else {\n                         return None;\n@@ -493,12 +492,15 @@ impl<'a> CompletionContext<'a> {\n             |kind| (NameRefContext { nameref: nameref.clone(), kind }, Default::default());\n \n         if let Some(record_field) = ast::RecordExprField::for_field_name(&name_ref) {\n+            let dot_prefix = previous_non_trivia_token(name_ref.syntax().clone())\n+                .map_or(false, |it| T![.] == it.kind());\n+\n             return find_node_in_file_compensated(\n                 sema,\n                 original_file,\n                 &record_field.parent_record_lit(),\n             )\n-            .map(NameRefKind::RecordExpr)\n+            .map(|expr| NameRefKind::RecordExpr { expr, dot_prefix })\n             .map(make_res);\n         }\n         if let Some(record_field) = ast::RecordPatField::for_field_name_ref(&name_ref) {\n@@ -1180,8 +1182,12 @@ pub(crate) fn is_in_loop_body(node: &SyntaxNode) -> bool {\n         .is_some()\n }\n \n-fn previous_non_trivia_token(token: SyntaxToken) -> Option<SyntaxToken> {\n-    let mut token = token.prev_token();\n+fn previous_non_trivia_token(e: impl Into<SyntaxElement>) -> Option<SyntaxToken> {\n+    let mut token = match e.into() {\n+        SyntaxElement::Node(n) => n.first_token()?,\n+        SyntaxElement::Token(t) => t,\n+    }\n+    .prev_token();\n     while let Some(inner) = token {\n         if !inner.kind().is_trivia() {\n             return Some(inner);"}, {"sha": "bf75dcf26bc1f5595ce7de85ffb0fe855d41ab31", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bcf10cde137bb0b0c4e2be8564c31c2e0e392406/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf10cde137bb0b0c4e2be8564c31c2e0e392406/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=bcf10cde137bb0b0c4e2be8564c31c2e0e392406", "patch": "@@ -181,8 +181,16 @@ pub fn completions(\n                 completions::extern_abi::complete_extern_abi(acc, ctx, expanded);\n                 completions::format_string::format_string(acc, ctx, original, expanded);\n             }\n-            IdentContext::UnexpandedAttrTT { fake_attribute_under_caret: Some(attr) } => {\n-                completions::attribute::complete_known_attribute_input(acc, ctx, attr);\n+            IdentContext::UnexpandedAttrTT {\n+                colon_prefix,\n+                fake_attribute_under_caret: Some(attr),\n+            } => {\n+                completions::attribute::complete_known_attribute_input(\n+                    acc,\n+                    ctx,\n+                    colon_prefix,\n+                    attr,\n+                );\n             }\n             IdentContext::UnexpandedAttrTT { .. } | IdentContext::String { .. } => (),\n         }"}]}