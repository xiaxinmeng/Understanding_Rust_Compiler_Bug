{"sha": "0c927b458421c488323efbf742ce7017b6da29ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjOTI3YjQ1ODQyMWM0ODgzMjNlZmJmNzQyY2U3MDE3YjZkYTI5YWI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-07T16:48:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-07T16:48:15Z"}, "message": "Merge #3882\n\n3882: Move computation of missing fields into hir r=matklad a=matklad\n\ncc @SomeoneToIgnore, this is that refactoring that moves computation of missing fields to hir. \r\n\r\nit actually removes meaningful duplication between diagnostics code and the completion code. Nontheless, it's a net addition of code :(\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "caf82fa6db2c2f7f9293dc556445cc8b0eb47f58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caf82fa6db2c2f7f9293dc556445cc8b0eb47f58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c927b458421c488323efbf742ce7017b6da29ab", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJejK7PCRBK7hj4Ov3rIwAAdHIIAIeCo7ToO8v5nTJkjOg580i/\nbcpNbAGC+/WRpwvniS2WJpIezR+0fjNGrgmVH7rljiKGsIzU5C0N7F+a7bbtXR4n\nPSpLR82OnRg7utN7yviiMHIP1XGQo4aDVLef4VbnIqtak0ytAID6gouOeA6IScKU\niyVb5hO6hbFH9wLjytbrL7jZx5oyxwBYVwTNGFEU9x7sODTLH81uUFdF4+rYf5me\nMZ0VLcImV9/zs6xE3SwDFV8/7SAfp9KNIrhHpiDm5sbY26l3jNRFxx2gTviR+UYq\nCJTMDkXdvBNp12722f9iDUsW+mcHWtZ0QzcixpIq2CArnMmH7gEDklqVJku1dT8=\n=0M8r\n-----END PGP SIGNATURE-----\n", "payload": "tree caf82fa6db2c2f7f9293dc556445cc8b0eb47f58\nparent 173dccc804e75da1c83532bc0dbb21f074777731\nparent 4c29214bba65d23e18875bd060325c489be5a8e4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586278095 +0000\ncommitter GitHub <noreply@github.com> 1586278095 +0000\n\nMerge #3882\n\n3882: Move computation of missing fields into hir r=matklad a=matklad\n\ncc @SomeoneToIgnore, this is that refactoring that moves computation of missing fields to hir. \r\n\r\nit actually removes meaningful duplication between diagnostics code and the completion code. Nontheless, it's a net addition of code :(\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c927b458421c488323efbf742ce7017b6da29ab", "html_url": "https://github.com/rust-lang/rust/commit/0c927b458421c488323efbf742ce7017b6da29ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c927b458421c488323efbf742ce7017b6da29ab/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "173dccc804e75da1c83532bc0dbb21f074777731", "url": "https://api.github.com/repos/rust-lang/rust/commits/173dccc804e75da1c83532bc0dbb21f074777731", "html_url": "https://github.com/rust-lang/rust/commit/173dccc804e75da1c83532bc0dbb21f074777731"}, {"sha": "4c29214bba65d23e18875bd060325c489be5a8e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c29214bba65d23e18875bd060325c489be5a8e4", "html_url": "https://github.com/rust-lang/rust/commit/4c29214bba65d23e18875bd060325c489be5a8e4"}], "stats": {"total": 366, "additions": 198, "deletions": 168}, "files": [{"sha": "9baebf64350c5eaa8ceaee3ee14c45a8d8b0c2a5", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0c927b458421c488323efbf742ce7017b6da29ab/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c927b458421c488323efbf742ce7017b6da29ab/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=0c927b458421c488323efbf742ce7017b6da29ab", "patch": "@@ -1027,8 +1027,16 @@ impl Type {\n         ty: Ty,\n     ) -> Option<Type> {\n         let krate = resolver.krate()?;\n+        Some(Type::new_with_resolver_inner(db, krate, resolver, ty))\n+    }\n+    pub(crate) fn new_with_resolver_inner(\n+        db: &dyn HirDatabase,\n+        krate: CrateId,\n+        resolver: &Resolver,\n+        ty: Ty,\n+    ) -> Type {\n         let environment = TraitEnvironment::lower(db, &resolver);\n-        Some(Type { krate, ty: InEnvironment { value: ty, environment } })\n+        Type { krate, ty: InEnvironment { value: ty, environment } }\n     }\n \n     fn new(db: &dyn HirDatabase, krate: CrateId, lexical_env: impl HasResolver, ty: Ty) -> Type {\n@@ -1152,27 +1160,6 @@ impl Type {\n         res\n     }\n \n-    pub fn variant_fields(\n-        &self,\n-        db: &dyn HirDatabase,\n-        def: VariantDef,\n-    ) -> Vec<(StructField, Type)> {\n-        // FIXME: check that ty and def match\n-        match &self.ty.value {\n-            Ty::Apply(a_ty) => {\n-                let field_types = db.field_types(def.into());\n-                def.fields(db)\n-                    .into_iter()\n-                    .map(|it| {\n-                        let ty = field_types[it.id].clone().subst(&a_ty.parameters);\n-                        (it, self.derived(ty))\n-                    })\n-                    .collect()\n-            }\n-            _ => Vec::new(),\n-        }\n-    }\n-\n     pub fn autoderef<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Type> + 'a {\n         // There should be no inference vars in types passed here\n         // FIXME check that?"}, {"sha": "2707e422d109477017e70cdf6b994666c4cd5a93", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0c927b458421c488323efbf742ce7017b6da29ab/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c927b458421c488323efbf742ce7017b6da29ab/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=0c927b458421c488323efbf742ce7017b6da29ab", "patch": "@@ -23,7 +23,7 @@ use crate::{\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, SourceAnalyzer},\n     AssocItem, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module, ModuleDef, Name,\n-    Origin, Path, ScopeDef, StructField, Trait, Type, TypeParam, VariantDef,\n+    Origin, Path, ScopeDef, StructField, Trait, Type, TypeParam,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -187,14 +187,6 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.analyze(field.syntax()).resolve_record_field(self.db, field)\n     }\n \n-    pub fn resolve_record_literal(&self, record_lit: &ast::RecordLit) -> Option<VariantDef> {\n-        self.analyze(record_lit.syntax()).resolve_record_literal(self.db, record_lit)\n-    }\n-\n-    pub fn resolve_record_pattern(&self, record_pat: &ast::RecordPat) -> Option<VariantDef> {\n-        self.analyze(record_pat.syntax()).resolve_record_pattern(record_pat)\n-    }\n-\n     pub fn resolve_macro_call(&self, macro_call: &ast::MacroCall) -> Option<MacroDef> {\n         let sa = self.analyze(macro_call.syntax());\n         let macro_call = self.find_file(macro_call.syntax().clone()).with_value(macro_call);\n@@ -212,6 +204,24 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     // FIXME: use this instead?\n     // pub fn resolve_name_ref(&self, name_ref: &ast::NameRef) -> Option<???>;\n \n+    pub fn record_literal_missing_fields(\n+        &self,\n+        literal: &ast::RecordLit,\n+    ) -> Vec<(StructField, Type)> {\n+        self.analyze(literal.syntax())\n+            .record_literal_missing_fields(self.db, literal)\n+            .unwrap_or_default()\n+    }\n+\n+    pub fn record_pattern_missing_fields(\n+        &self,\n+        pattern: &ast::RecordPat,\n+    ) -> Vec<(StructField, Type)> {\n+        self.analyze(pattern.syntax())\n+            .record_pattern_missing_fields(self.db, pattern)\n+            .unwrap_or_default()\n+    }\n+\n     pub fn to_def<T: ToDef>(&self, src: &T) -> Option<T::Def> {\n         let src = self.find_file(src.syntax().clone()).with_value(src).cloned();\n         T::to_def(self, src)"}, {"sha": "45631f8fdf821e4d73aaa06db7fb2de9bd42bf3e", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 70, "deletions": 20, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/0c927b458421c488323efbf742ce7017b6da29ab/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c927b458421c488323efbf742ce7017b6da29ab/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=0c927b458421c488323efbf742ce7017b6da29ab", "patch": "@@ -14,19 +14,24 @@ use hir_def::{\n     },\n     expr::{ExprId, Pat, PatId},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n-    AsMacroCall, DefWithBodyId,\n+    AsMacroCall, DefWithBodyId, LocalStructFieldId, StructFieldId, VariantId,\n };\n use hir_expand::{hygiene::Hygiene, name::AsName, HirFileId, InFile};\n-use hir_ty::InferenceResult;\n+use hir_ty::{\n+    expr::{record_literal_missing_fields, record_pattern_missing_fields},\n+    InferenceResult, Substs, Ty,\n+};\n use ra_syntax::{\n     ast::{self, AstNode},\n     SyntaxNode, SyntaxNodePtr, TextUnit,\n };\n \n use crate::{\n     db::HirDatabase, semantics::PathResolution, Adt, Const, EnumVariant, Function, Local, MacroDef,\n-    ModPath, ModuleDef, Path, PathKind, Static, Struct, Trait, Type, TypeAlias, TypeParam,\n+    ModPath, ModuleDef, Path, PathKind, Static, Struct, StructField, Trait, Type, TypeAlias,\n+    TypeParam,\n };\n+use ra_db::CrateId;\n \n /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of\n /// original source files. It should not be used inside the HIR itself.\n@@ -164,23 +169,6 @@ impl SourceAnalyzer {\n         Some((struct_field.into(), local))\n     }\n \n-    pub(crate) fn resolve_record_literal(\n-        &self,\n-        db: &dyn HirDatabase,\n-        record_lit: &ast::RecordLit,\n-    ) -> Option<crate::VariantDef> {\n-        let expr_id = self.expr_id(db, &record_lit.clone().into())?;\n-        self.infer.as_ref()?.variant_resolution_for_expr(expr_id).map(|it| it.into())\n-    }\n-\n-    pub(crate) fn resolve_record_pattern(\n-        &self,\n-        record_pat: &ast::RecordPat,\n-    ) -> Option<crate::VariantDef> {\n-        let pat_id = self.pat_id(&record_pat.clone().into())?;\n-        self.infer.as_ref()?.variant_resolution_for_pat(pat_id).map(|it| it.into())\n-    }\n-\n     pub(crate) fn resolve_macro_call(\n         &self,\n         db: &dyn HirDatabase,\n@@ -231,6 +219,68 @@ impl SourceAnalyzer {\n         resolve_hir_path(db, &self.resolver, &hir_path)\n     }\n \n+    pub(crate) fn record_literal_missing_fields(\n+        &self,\n+        db: &dyn HirDatabase,\n+        literal: &ast::RecordLit,\n+    ) -> Option<Vec<(StructField, Type)>> {\n+        let krate = self.resolver.krate()?;\n+        let body = self.body.as_ref()?;\n+        let infer = self.infer.as_ref()?;\n+\n+        let expr_id = self.expr_id(db, &literal.clone().into())?;\n+        let substs = match &infer.type_of_expr[expr_id] {\n+            Ty::Apply(a_ty) => &a_ty.parameters,\n+            _ => return None,\n+        };\n+\n+        let (variant, missing_fields, _exhaustive) =\n+            record_literal_missing_fields(db, infer, expr_id, &body[expr_id])?;\n+        let res = self.missing_fields(db, krate, substs, variant, missing_fields);\n+        Some(res)\n+    }\n+\n+    pub(crate) fn record_pattern_missing_fields(\n+        &self,\n+        db: &dyn HirDatabase,\n+        pattern: &ast::RecordPat,\n+    ) -> Option<Vec<(StructField, Type)>> {\n+        let krate = self.resolver.krate()?;\n+        let body = self.body.as_ref()?;\n+        let infer = self.infer.as_ref()?;\n+\n+        let pat_id = self.pat_id(&pattern.clone().into())?;\n+        let substs = match &infer.type_of_pat[pat_id] {\n+            Ty::Apply(a_ty) => &a_ty.parameters,\n+            _ => return None,\n+        };\n+\n+        let (variant, missing_fields) =\n+            record_pattern_missing_fields(db, infer, pat_id, &body[pat_id])?;\n+        let res = self.missing_fields(db, krate, substs, variant, missing_fields);\n+        Some(res)\n+    }\n+\n+    fn missing_fields(\n+        &self,\n+        db: &dyn HirDatabase,\n+        krate: CrateId,\n+        substs: &Substs,\n+        variant: VariantId,\n+        missing_fields: Vec<LocalStructFieldId>,\n+    ) -> Vec<(StructField, Type)> {\n+        let field_types = db.field_types(variant);\n+\n+        missing_fields\n+            .into_iter()\n+            .map(|local_id| {\n+                let field = StructFieldId { parent: variant, local_id };\n+                let ty = field_types[local_id].clone().subst(substs);\n+                (field.into(), Type::new_with_resolver_inner(db, krate, &self.resolver, ty))\n+            })\n+            .collect()\n+    }\n+\n     pub(crate) fn expand(\n         &self,\n         db: &dyn HirDatabase,"}, {"sha": "b4592fbf56d0905ace0322133e05e9c35981cbdc", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 91, "deletions": 67, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/0c927b458421c488323efbf742ce7017b6da29ab/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c927b458421c488323efbf742ce7017b6da29ab/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=0c927b458421c488323efbf742ce7017b6da29ab", "patch": "@@ -2,12 +2,8 @@\n \n use std::sync::Arc;\n \n-use hir_def::{\n-    path::{path, Path},\n-    resolver::HasResolver,\n-    AdtId, FunctionId,\n-};\n-use hir_expand::{diagnostics::DiagnosticSink, name::Name};\n+use hir_def::{path::path, resolver::HasResolver, AdtId, FunctionId};\n+use hir_expand::diagnostics::DiagnosticSink;\n use ra_syntax::ast;\n use ra_syntax::AstPtr;\n use rustc_hash::FxHashSet;\n@@ -29,7 +25,7 @@ pub use hir_def::{\n         ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal, LogicOp,\n         MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement, UnaryOp,\n     },\n-    VariantId,\n+    LocalStructFieldId, VariantId,\n };\n \n pub struct ExprValidator<'a, 'b: 'a> {\n@@ -50,14 +46,37 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n     pub fn validate_body(&mut self, db: &dyn HirDatabase) {\n         let body = db.body(self.func.into());\n \n-        for e in body.exprs.iter() {\n-            if let (id, Expr::RecordLit { path, fields, spread }) = e {\n-                self.validate_record_literal(id, path, fields, *spread, db);\n-            } else if let (id, Expr::Match { expr, arms }) = e {\n+        for (id, expr) in body.exprs.iter() {\n+            if let Some((variant_def, missed_fields, true)) =\n+                record_literal_missing_fields(db, &self.infer, id, expr)\n+            {\n+                // XXX: only look at source_map if we do have missing fields\n+                let (_, source_map) = db.body_with_source_map(self.func.into());\n+\n+                if let Ok(source_ptr) = source_map.expr_syntax(id) {\n+                    if let Some(expr) = source_ptr.value.left() {\n+                        let root = source_ptr.file_syntax(db.upcast());\n+                        if let ast::Expr::RecordLit(record_lit) = expr.to_node(&root) {\n+                            if let Some(field_list) = record_lit.record_field_list() {\n+                                let variant_data = variant_data(db.upcast(), variant_def);\n+                                let missed_fields = missed_fields\n+                                    .into_iter()\n+                                    .map(|idx| variant_data.fields()[idx].name.clone())\n+                                    .collect();\n+                                self.sink.push(MissingFields {\n+                                    file: source_ptr.file_id,\n+                                    field_list: AstPtr::new(&field_list),\n+                                    missed_fields,\n+                                })\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            if let Expr::Match { expr, arms } = expr {\n                 self.validate_match(id, *expr, arms, db, self.infer.clone());\n             }\n         }\n-\n         let body_expr = &body[body.body_expr];\n         if let Expr::Block { tail: Some(t), .. } = body_expr {\n             self.validate_results_in_tail_expr(body.body_expr, *t, db);\n@@ -146,61 +165,6 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n     }\n \n-    fn validate_record_literal(\n-        &mut self,\n-        id: ExprId,\n-        _path: &Option<Path>,\n-        fields: &[RecordLitField],\n-        spread: Option<ExprId>,\n-        db: &dyn HirDatabase,\n-    ) {\n-        if spread.is_some() {\n-            return;\n-        };\n-        let variant_def: VariantId = match self.infer.variant_resolution_for_expr(id) {\n-            Some(VariantId::UnionId(_)) | None => return,\n-            Some(it) => it,\n-        };\n-        if let VariantId::UnionId(_) = variant_def {\n-            return;\n-        }\n-\n-        let variant_data = variant_data(db.upcast(), variant_def);\n-\n-        let lit_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();\n-        let missed_fields: Vec<Name> = variant_data\n-            .fields()\n-            .iter()\n-            .filter_map(|(_f, d)| {\n-                let name = d.name.clone();\n-                if lit_fields.contains(&name) {\n-                    None\n-                } else {\n-                    Some(name)\n-                }\n-            })\n-            .collect();\n-        if missed_fields.is_empty() {\n-            return;\n-        }\n-        let (_, source_map) = db.body_with_source_map(self.func.into());\n-\n-        if let Ok(source_ptr) = source_map.expr_syntax(id) {\n-            if let Some(expr) = source_ptr.value.left() {\n-                let root = source_ptr.file_syntax(db.upcast());\n-                if let ast::Expr::RecordLit(record_lit) = expr.to_node(&root) {\n-                    if let Some(field_list) = record_lit.record_field_list() {\n-                        self.sink.push(MissingFields {\n-                            file: source_ptr.file_id,\n-                            field_list: AstPtr::new(&field_list),\n-                            missed_fields,\n-                        })\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn validate_results_in_tail_expr(&mut self, body_id: ExprId, id: ExprId, db: &dyn HirDatabase) {\n         // the mismatch will be on the whole block currently\n         let mismatch = match self.infer.type_mismatch_for_expr(body_id) {\n@@ -233,3 +197,63 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n     }\n }\n+\n+pub fn record_literal_missing_fields(\n+    db: &dyn HirDatabase,\n+    infer: &InferenceResult,\n+    id: ExprId,\n+    expr: &Expr,\n+) -> Option<(VariantId, Vec<LocalStructFieldId>, /*exhaustive*/ bool)> {\n+    let (fields, exhausitve) = match expr {\n+        Expr::RecordLit { path: _, fields, spread } => (fields, spread.is_none()),\n+        _ => return None,\n+    };\n+\n+    let variant_def = infer.variant_resolution_for_expr(id)?;\n+    if let VariantId::UnionId(_) = variant_def {\n+        return None;\n+    }\n+\n+    let variant_data = variant_data(db.upcast(), variant_def);\n+\n+    let specified_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();\n+    let missed_fields: Vec<LocalStructFieldId> = variant_data\n+        .fields()\n+        .iter()\n+        .filter_map(|(f, d)| if specified_fields.contains(&d.name) { None } else { Some(f) })\n+        .collect();\n+    if missed_fields.is_empty() {\n+        return None;\n+    }\n+    Some((variant_def, missed_fields, exhausitve))\n+}\n+\n+pub fn record_pattern_missing_fields(\n+    db: &dyn HirDatabase,\n+    infer: &InferenceResult,\n+    id: PatId,\n+    pat: &Pat,\n+) -> Option<(VariantId, Vec<LocalStructFieldId>)> {\n+    let fields = match pat {\n+        Pat::Record { path: _, args } => args,\n+        _ => return None,\n+    };\n+\n+    let variant_def = infer.variant_resolution_for_pat(id)?;\n+    if let VariantId::UnionId(_) = variant_def {\n+        return None;\n+    }\n+\n+    let variant_data = variant_data(db.upcast(), variant_def);\n+\n+    let specified_fields: FxHashSet<_> = fields.iter().map(|f| &f.name).collect();\n+    let missed_fields: Vec<LocalStructFieldId> = variant_data\n+        .fields()\n+        .iter()\n+        .filter_map(|(f, d)| if specified_fields.contains(&d.name) { None } else { Some(f) })\n+        .collect();\n+    if missed_fields.is_empty() {\n+        return None;\n+    }\n+    Some((variant_def, missed_fields))\n+}"}, {"sha": "f46bcee5c43864f50163f1fe8867a2420a3fae0a", "filename": "crates/ra_ide/src/completion/complete_record.rs", "status": "modified", "additions": 9, "deletions": 50, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0c927b458421c488323efbf742ce7017b6da29ab/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c927b458421c488323efbf742ce7017b6da29ab/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_record.rs?ref=0c927b458421c488323efbf742ce7017b6da29ab", "patch": "@@ -1,60 +1,19 @@\n //! Complete fields in record literals and patterns.\n-use ra_syntax::{ast, ast::NameOwner, SmolStr};\n-\n use crate::completion::{CompletionContext, Completions};\n \n pub(super) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    let (ty, variant, already_present_fields) =\n-        match (ctx.record_lit_pat.as_ref(), ctx.record_lit_syntax.as_ref()) {\n-            (None, None) => return None,\n-            (Some(_), Some(_)) => unreachable!(\"A record cannot be both a literal and a pattern\"),\n-            (Some(record_pat), _) => (\n-                ctx.sema.type_of_pat(&record_pat.clone().into())?,\n-                ctx.sema.resolve_record_pattern(record_pat)?,\n-                pattern_ascribed_fields(record_pat),\n-            ),\n-            (_, Some(record_lit)) => (\n-                ctx.sema.type_of_expr(&record_lit.clone().into())?,\n-                ctx.sema.resolve_record_literal(record_lit)?,\n-                literal_ascribed_fields(record_lit),\n-            ),\n-        };\n+    let missing_fields = match (ctx.record_lit_pat.as_ref(), ctx.record_lit_syntax.as_ref()) {\n+        (None, None) => return None,\n+        (Some(_), Some(_)) => unreachable!(\"A record cannot be both a literal and a pattern\"),\n+        (Some(record_pat), _) => ctx.sema.record_pattern_missing_fields(record_pat),\n+        (_, Some(record_lit)) => ctx.sema.record_literal_missing_fields(record_lit),\n+    };\n \n-    for (field, field_ty) in ty.variant_fields(ctx.db, variant).into_iter().filter(|(field, _)| {\n-        // FIXME: already_present_names better be `Vec<hir::Name>`\n-        !already_present_fields.contains(&SmolStr::from(field.name(ctx.db).to_string()))\n-    }) {\n-        acc.add_field(ctx, field, &field_ty);\n+    for (field, ty) in missing_fields {\n+        acc.add_field(ctx, field, &ty)\n     }\n-    Some(())\n-}\n \n-fn literal_ascribed_fields(record_lit: &ast::RecordLit) -> Vec<SmolStr> {\n-    record_lit\n-        .record_field_list()\n-        .map(|field_list| field_list.fields())\n-        .map(|fields| {\n-            fields\n-                .into_iter()\n-                .filter_map(|field| field.name_ref())\n-                .map(|name_ref| name_ref.text().clone())\n-                .collect()\n-        })\n-        .unwrap_or_default()\n-}\n-\n-fn pattern_ascribed_fields(record_pat: &ast::RecordPat) -> Vec<SmolStr> {\n-    record_pat\n-        .record_field_pat_list()\n-        .map(|pat_list| {\n-            pat_list\n-                .record_field_pats()\n-                .filter_map(|fild_pat| fild_pat.name())\n-                .chain(pat_list.bind_pats().filter_map(|bind_pat| bind_pat.name()))\n-                .map(|name| name.text().clone())\n-                .collect()\n-        })\n-        .unwrap_or_default()\n+    Some(())\n }\n \n #[cfg(test)]"}]}