{"sha": "a8018e224efa8aef9e6a8c9b8a74dc67c225d51d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MDE4ZTIyNGVmYThhZWY5ZTZhOGM5YjhhNzRkYzY3YzIyNWQ1MWQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-22T09:32:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-22T09:32:21Z"}, "message": "Rollup merge of #72161 - nbdd0121:master, r=cuviper\n\nReplace fcntl-based file lock with flock\n\nWSL1 does not support `fcntl`-based lock and will always report success,\ntherefore creating a race condition when multiple rustc processes are\nmodifying shared data such as `search-index.js`. WSL1 does however\nsupport `flock`.\n\n`flock` is supported by all unix-like platforms. The only caveat is that\nLinux 2.6.11 or earlier does not support `flock` on NFS mounts, but as\nthe minimum supported Linux version is 2.6.18, it is not an issue.\n\nFixes #72157", "tree": {"sha": "b5517d21045ed2af3c42e6f0cdc2c5f825cad492", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5517d21045ed2af3c42e6f0cdc2c5f825cad492"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8018e224efa8aef9e6a8c9b8a74dc67c225d51d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJex5wlCRBK7hj4Ov3rIwAAdHIIABWJfpCtVwK8N0NCL6ZmeDPO\nWKBcBXIyWhDBWAMT3EiXHz+xZFEA2Z6mHD7PY6BKQ+/tON8CByJTf6elxaAeY/SJ\nBU/6QO7y03l9dTZCZ5zeIkx3csov/MvwIEQousgD874di/ZUun5XLWMmPOLwvJri\nZJ3P0jvzugpGN9LxdS2zvT1QLTHsfJ74mT9i2IqqA56kaV5asimb92v249FLPxKl\n5yRP6TT8oVkmhjwgvIOTKE4B1Wn48KuQ7V6KulAvYl89aZXyXOZLyrNpPbxFiUvy\nE4iSvi7xDzYeqo8+wzSekbGVUmy6HpX98xZfDD5CFP0Kt778t2Uf6TpG5FOqwfs=\n=2OhO\n-----END PGP SIGNATURE-----\n", "payload": "tree b5517d21045ed2af3c42e6f0cdc2c5f825cad492\nparent 2059112eb40619d39f89102f832c4450d6b8ffc5\nparent a05acbf36f5a1f49919253281fc9bf9465606070\nauthor Ralf Jung <post@ralfj.de> 1590139941 +0200\ncommitter GitHub <noreply@github.com> 1590139941 +0200\n\nRollup merge of #72161 - nbdd0121:master, r=cuviper\n\nReplace fcntl-based file lock with flock\n\nWSL1 does not support `fcntl`-based lock and will always report success,\ntherefore creating a race condition when multiple rustc processes are\nmodifying shared data such as `search-index.js`. WSL1 does however\nsupport `flock`.\n\n`flock` is supported by all unix-like platforms. The only caveat is that\nLinux 2.6.11 or earlier does not support `flock` on NFS mounts, but as\nthe minimum supported Linux version is 2.6.18, it is not an issue.\n\nFixes #72157\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8018e224efa8aef9e6a8c9b8a74dc67c225d51d", "html_url": "https://github.com/rust-lang/rust/commit/a8018e224efa8aef9e6a8c9b8a74dc67c225d51d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8018e224efa8aef9e6a8c9b8a74dc67c225d51d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2059112eb40619d39f89102f832c4450d6b8ffc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2059112eb40619d39f89102f832c4450d6b8ffc5", "html_url": "https://github.com/rust-lang/rust/commit/2059112eb40619d39f89102f832c4450d6b8ffc5"}, {"sha": "a05acbf36f5a1f49919253281fc9bf9465606070", "url": "https://api.github.com/repos/rust-lang/rust/commits/a05acbf36f5a1f49919253281fc9bf9465606070", "html_url": "https://github.com/rust-lang/rust/commit/a05acbf36f5a1f49919253281fc9bf9465606070"}], "stats": {"total": 81, "additions": 57, "deletions": 24}, "files": [{"sha": "9383be474fd5a6224094a66f676875ec367681d5", "filename": "src/librustc_data_structures/flock.rs", "status": "modified", "additions": 57, "deletions": 24, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a8018e224efa8aef9e6a8c9b8a74dc67c225d51d/src%2Flibrustc_data_structures%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8018e224efa8aef9e6a8c9b8a74dc67c225d51d/src%2Flibrustc_data_structures%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fflock.rs?ref=a8018e224efa8aef9e6a8c9b8a74dc67c225d51d", "patch": "@@ -7,18 +7,22 @@\n #![allow(non_camel_case_types)]\n #![allow(nonstandard_style)]\n \n+use std::fs::{File, OpenOptions};\n use std::io;\n use std::path::Path;\n \n cfg_if! {\n-    if #[cfg(unix)] {\n-        use std::ffi::{CString, OsStr};\n-        use std::mem;\n+    // We use `flock` rather than `fcntl` on Linux, because WSL1 does not support\n+    // `fcntl`-style advisory locks properly (rust-lang/rust#72157).\n+    //\n+    // For other Unix targets we still use `fcntl` because it's more portable than\n+    // `flock`.\n+    if #[cfg(target_os = \"linux\")] {\n         use std::os::unix::prelude::*;\n \n         #[derive(Debug)]\n         pub struct Lock {\n-            fd: libc::c_int,\n+            _file: File,\n         }\n \n         impl Lock {\n@@ -27,22 +31,55 @@ cfg_if! {\n                        create: bool,\n                        exclusive: bool)\n                        -> io::Result<Lock> {\n-                let os: &OsStr = p.as_ref();\n-                let buf = CString::new(os.as_bytes()).unwrap();\n-                let open_flags = if create {\n-                    libc::O_RDWR | libc::O_CREAT\n+                let file = OpenOptions::new()\n+                    .read(true)\n+                    .write(true)\n+                    .create(create)\n+                    .mode(libc::S_IRWXU as u32)\n+                    .open(p)?;\n+\n+                let mut operation = if exclusive {\n+                    libc::LOCK_EX\n                 } else {\n-                    libc::O_RDWR\n-                };\n-\n-                let fd = unsafe {\n-                    libc::open(buf.as_ptr(), open_flags,\n-                               libc::S_IRWXU as libc::c_int)\n+                    libc::LOCK_SH\n                 };\n+                if !wait {\n+                    operation |= libc::LOCK_NB\n+                }\n \n-                if fd < 0 {\n-                    return Err(io::Error::last_os_error());\n+                let ret = unsafe { libc::flock(file.as_raw_fd(), operation) };\n+                if ret == -1 {\n+                    Err(io::Error::last_os_error())\n+                } else {\n+                    Ok(Lock { _file: file })\n                 }\n+            }\n+        }\n+\n+        // Note that we don't need a Drop impl to execute `flock(fd, LOCK_UN)`. Lock acquired by\n+        // `flock` is associated with the file descriptor and closing the file release it\n+        // automatically.\n+    } else if #[cfg(unix)] {\n+        use std::mem;\n+        use std::os::unix::prelude::*;\n+\n+        #[derive(Debug)]\n+        pub struct Lock {\n+            file: File,\n+        }\n+\n+        impl Lock {\n+            pub fn new(p: &Path,\n+                       wait: bool,\n+                       create: bool,\n+                       exclusive: bool)\n+                       -> io::Result<Lock> {\n+                let file = OpenOptions::new()\n+                    .read(true)\n+                    .write(true)\n+                    .create(create)\n+                    .mode(libc::S_IRWXU as u32)\n+                    .open(p)?;\n \n                 let lock_type = if exclusive {\n                     libc::F_WRLCK\n@@ -58,14 +95,12 @@ cfg_if! {\n \n                 let cmd = if wait { libc::F_SETLKW } else { libc::F_SETLK };\n                 let ret = unsafe {\n-                    libc::fcntl(fd, cmd, &flock)\n+                    libc::fcntl(file.as_raw_fd(), cmd, &flock)\n                 };\n                 if ret == -1 {\n-                    let err = io::Error::last_os_error();\n-                    unsafe { libc::close(fd); }\n-                    Err(err)\n+                    Err(io::Error::last_os_error())\n                 } else {\n-                    Ok(Lock { fd })\n+                    Ok(Lock { file })\n                 }\n             }\n         }\n@@ -79,15 +114,13 @@ cfg_if! {\n                 flock.l_len = 0;\n \n                 unsafe {\n-                    libc::fcntl(self.fd, libc::F_SETLK, &flock);\n-                    libc::close(self.fd);\n+                    libc::fcntl(self.file.as_raw_fd(), libc::F_SETLK, &flock);\n                 }\n             }\n         }\n     } else if #[cfg(windows)] {\n         use std::mem;\n         use std::os::windows::prelude::*;\n-        use std::fs::{File, OpenOptions};\n \n         use winapi::um::minwinbase::{OVERLAPPED, LOCKFILE_FAIL_IMMEDIATELY, LOCKFILE_EXCLUSIVE_LOCK};\n         use winapi::um::fileapi::LockFileEx;"}]}