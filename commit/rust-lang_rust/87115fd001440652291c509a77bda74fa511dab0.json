{"sha": "87115fd001440652291c509a77bda74fa511dab0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MTE1ZmQwMDE0NDA2NTIyOTFjNTA5YTc3YmRhNzRmYTUxMWRhYjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-07T18:06:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-07T18:06:45Z"}, "message": "auto merge of #13901 : alexcrichton/rust/facade, r=brson\n\nThis is the second step in implementing #13851. This PR cannot currently land until a snapshot exists with #13892, but I imagine that this review will take longer.\r\n\r\nThis PR refactors a large amount of functionality outside of the standard library into a new library, libcore. This new library has 0 dependencies (in theory). In practice, this library currently depends on these symbols being available:\r\n\r\n* `rust_begin_unwind` and `rust_fail_bounds_check` - These are the two entry points of failure in libcore. The symbols are provided by libstd currently. In the future (see the bullets on #13851) this will be officially supported with nice error mesages. Additionally, there will only be one failure entry point once `std::fmt` migrates to libcore.\r\n* `memcpy` - This is often generated by LLVM. This is also quite trivial to implement for any platform, so I'm not too worried about this.\r\n* `memcmp` - This is required for comparing strings. This function is quite common *everywhere*, so I don't feel to bad about relying on a consumer of libcore to define it.\r\n* `malloc` and `free` - This is quite unfortunate, and is a temporary stopgap until we deal with the `~` situation. More details can be found in the module `core::should_not_exist`\r\n* `fmod` and `fmodf` - These exist because the `Rem` trait is defined in libcore, so the `Rem` implementation for floats must also be defined in libcore. I imagine that any platform using floating-point modulus will have these symbols anyway, and otherwise they will be optimized out.\r\n* `fdim` and `fdimf` - Like `fmod`, these are from the `Signed` trait being defined in libcore. I don't expect this to be much of a problem\r\n\r\nThese dependencies all \"Just Work\" for now because libcore only exists as an rlib, not as a dylib.\r\n\r\nThe commits themselves are organized to show that the overall diff of this extraction is not all that large. Most modules were able to be moved with very few modifications. The primary module left out of this iteration is `std::fmt`. I plan on migrating the `fmt` module to libcore, but I chose to not do so at this time because it had implications on the `Writer` trait that I wanted to deal with in isolation. There are a few breaking changes in these commits, but they are fairly minor, and are all labeled with `[breaking-change]`.\r\n\r\nThe nastiest parts of this movement come up with `~[T]` and `~str` being language-defined types today. I believe that much of this nastiness will get better over time as we migrate towards `Vec<T>` and `Str` (or whatever the types will be named). There will likely always be some extension traits, but the situation won't be as bad as it is today.\r\n\r\nKnown deficiencies:\r\n\r\n* rustdoc will get worse in terms of readability. This is the next issue I will tackle as part of #13851. If others think that the rustdoc change should happen first, I can also table this to fix rustdoc first.\r\n* The compiler reveals that all these types are reexports via error messages like `core::option::Option`. This is filed as #13065, and I believe that issue would have a higher priority now. I do not currently plan on fixing that as part of #13851. If others believe that this issue should be fixed, I can also place it on the roadmap for #13851.\r\n\r\nI recommend viewing these changes on a commit-by-commit basis. The overall change is likely too overwhelming to take in.", "tree": {"sha": "06de178943c0e48728df22b090dcdc1b9ba9a9d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06de178943c0e48728df22b090dcdc1b9ba9a9d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87115fd001440652291c509a77bda74fa511dab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87115fd001440652291c509a77bda74fa511dab0", "html_url": "https://github.com/rust-lang/rust/commit/87115fd001440652291c509a77bda74fa511dab0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87115fd001440652291c509a77bda74fa511dab0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "445988b47811679144d0fa9b3a2ccf2348752850", "url": "https://api.github.com/repos/rust-lang/rust/commits/445988b47811679144d0fa9b3a2ccf2348752850", "html_url": "https://github.com/rust-lang/rust/commit/445988b47811679144d0fa9b3a2ccf2348752850"}, {"sha": "07caa224501817c93be3f5c57a013ed5db6c04e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/07caa224501817c93be3f5c57a013ed5db6c04e1", "html_url": "https://github.com/rust-lang/rust/commit/07caa224501817c93be3f5c57a013ed5db6c04e1"}], "stats": {"total": 26997, "additions": 14123, "deletions": 12874}, "files": [{"sha": "9da80c2bc11c5453e7204bae893cdeee88fc14af", "filename": "mk/crates.mk", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -51,12 +51,13 @@\n \n TARGET_CRATES := libc std green rustuv native flate arena glob term semver \\\n                  uuid serialize sync getopts collections num test time rand \\\n-\t\t workcache url log regex graphviz\n+\t\t workcache url log regex graphviz core\n HOST_CRATES := syntax rustc rustdoc fourcc hexfloat regex_macros\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n \n-DEPS_std := libc native:rustrt native:compiler-rt native:backtrace\n+DEPS_core :=\n+DEPS_std := core libc native:rustrt native:compiler-rt native:backtrace\n DEPS_green := std rand native:context_switch\n DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std\n@@ -95,6 +96,8 @@ TOOL_SOURCE_compiletest := $(S)src/compiletest/compiletest.rs\n TOOL_SOURCE_rustdoc := $(S)src/driver/driver.rs\n TOOL_SOURCE_rustc := $(S)src/driver/driver.rs\n \n+ONLY_RLIB_core := 1\n+\n ################################################################################\n # You should not need to edit below this line\n ################################################################################"}, {"sha": "ea2ac7a11409353e3ff7470e8a226699e9325b7d", "filename": "mk/host.mk", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/mk%2Fhost.mk", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/mk%2Fhost.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fhost.mk?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -18,6 +18,7 @@\n # $(5) - the name of the crate being processed\n define CP_HOST_STAGE_N_CRATE\n \n+ifeq ($$(ONLY_RLIB_$(5)),)\n $$(HLIB$(2)_H_$(4))/stamp.$(5):\t\t\t\t\t\\\n \t$$(TLIB$(1)_T_$(3)_H_$(4))/stamp.$(5)\t\t\t\\\n \t$$(RUST_DEPS_$(5):%=$$(HLIB$(2)_H_$(4))/stamp.%)\t\\\n@@ -30,6 +31,10 @@ $$(HLIB$(2)_H_$(4))/stamp.$(5):\t\t\t\t\t\\\n \t        $$(HLIB$(2)_H_$(4))\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES,\\\n \t    $$(dir $$@)$$(call CFG_LIB_GLOB_$(3),$(5)))\n+else\n+$$(HLIB$(2)_H_$(4))/stamp.$(5):\n+\t$$(Q)touch $$@\n+endif\n \n endef\n \n@@ -54,9 +59,6 @@ endef\n # $(4) - the host triple (same as $(3))\n define CP_HOST_STAGE_N\n \n-$$(HBIN$(2)_H_$(4))/:\n-\t@mkdir -p $$@\n-\n ifneq ($(CFG_LIBDIR_RELATIVE),bin)\n $$(HLIB$(2)_H_$(4))/:\n \t@mkdir -p $$@"}, {"sha": "44e7a304e671dfa1a98c55f194e97795ffaabd35", "filename": "src/doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -3274,7 +3274,7 @@ The machine types are the following:\n \n * The signed two's complement word types `i8`, `i16`, `i32` and `i64`, with\n   values drawn from the integer intervals [-(2^(7)), 2^7 - 1],\n-  [-(2^(15)), 2^15 - 1], $[-(2^(31)), 2^31 - 1], [-(2^(63)), 2^63 - 1]\n+  [-(2^(15)), 2^15 - 1], [-(2^(31)), 2^31 - 1], [-(2^(63)), 2^63 - 1]\n   respectively.\n \n * The IEEE 754-2008 `binary32` and `binary64` floating-point types: `f32` and"}, {"sha": "459015445eb6ac0881b0a170a46e9199adcdbadf", "filename": "src/libcore/any.rs", "status": "renamed", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -21,7 +21,6 @@\n //! the extension traits (`*Ext`) for the full details.\n \n use cast::{transmute, transmute_copy};\n-use fmt;\n use option::{Option, Some, None};\n use owned::Box;\n use raw::TraitObject;\n@@ -145,28 +144,12 @@ impl AnyOwnExt for Box<Any> {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////////\n-// Trait implementations\n-///////////////////////////////////////////////////////////////////////////////\n-\n-impl fmt::Show for Box<Any> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"Box<Any>\")\n-    }\n-}\n-\n-impl<'a> fmt::Show for &'a Any {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"&Any\")\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n     use super::*;\n     use owned::Box;\n-    use str::StrSlice;\n+    use realstd::str::StrAllocating;\n \n     #[deriving(Eq, Show)]\n     struct Test;\n@@ -291,13 +274,13 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let a = box 8u as Box<Any>;\n-        let b = box Test as Box<Any>;\n+        let a = box 8u as Box<::realcore::any::Any>;\n+        let b = box Test as Box<::realcore::any::Any>;\n         assert_eq!(format!(\"{}\", a), \"Box<Any>\".to_owned());\n         assert_eq!(format!(\"{}\", b), \"Box<Any>\".to_owned());\n \n-        let a = &8u as &Any;\n-        let b = &Test as &Any;\n+        let a = &8u as &::realcore::any::Any;\n+        let b = &Test as &::realcore::any::Any;\n         assert_eq!(format!(\"{}\", a), \"&Any\".to_owned());\n         assert_eq!(format!(\"{}\", b), \"&Any\".to_owned());\n     }", "previous_filename": "src/libstd/any.rs"}, {"sha": "0f632f4d4d095c366820356c694d7789227c8da2", "filename": "src/libcore/bool.rs", "status": "renamed", "additions": 5, "deletions": 35, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -14,7 +14,6 @@\n //!\n //! Implementations of the following traits:\n //!\n-//! * `FromStr`\n //! * `Not`\n //! * `Ord`\n //! * `TotalOrd`\n@@ -24,11 +23,9 @@\n //!\n //! A `to_bit` conversion function.\n \n-use from_str::FromStr;\n use num::{Int, one, zero};\n-use option::{None, Option, Some};\n \n-#[cfg(not(test))] use cmp::{Eq, Ord, TotalOrd, Ordering};\n+#[cfg(not(test))] use cmp::{Eq, Ord, TotalOrd, Ordering, TotalEq};\n #[cfg(not(test))] use ops::{Not, BitAnd, BitOr, BitXor};\n #[cfg(not(test))] use default::Default;\n \n@@ -55,28 +52,6 @@ pub fn to_bit<N: Int>(p: bool) -> N {\n // Trait impls on `bool`\n /////////////////////////////////////////////////////////////////////////////\n \n-impl FromStr for bool {\n-    /// Parse a `bool` from a string.\n-    ///\n-    /// Yields an `Option<bool>`, because `s` may or may not actually be parseable.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(from_str::<bool>(\"true\"), Some(true));\n-    /// assert_eq!(from_str::<bool>(\"false\"), Some(false));\n-    /// assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n-    /// ```\n-    #[inline]\n-    fn from_str(s: &str) -> Option<bool> {\n-        match s {\n-            \"true\"  => Some(true),\n-            \"false\" => Some(false),\n-            _       => None,\n-        }\n-    }\n-}\n-\n #[cfg(not(test))]\n impl Not<bool> for bool {\n     /// The logical complement of a boolean value.\n@@ -190,16 +165,18 @@ impl Eq for bool {\n     fn eq(&self, other: &bool) -> bool { (*self) == (*other) }\n }\n \n+#[cfg(not(test))]\n+impl TotalEq for bool {}\n+\n #[cfg(not(test))]\n impl Default for bool {\n     fn default() -> bool { false }\n }\n \n #[cfg(test)]\n mod tests {\n-    use prelude::*;\n+    use realstd::prelude::*;\n     use super::to_bit;\n-    use str::StrSlice;\n \n     #[test]\n     fn test_to_bit() {\n@@ -260,13 +237,6 @@ mod tests {\n         assert_eq!(!false, true);\n     }\n \n-    #[test]\n-    fn test_from_str() {\n-        assert_eq!(from_str::<bool>(\"true\"), Some(true));\n-        assert_eq!(from_str::<bool>(\"false\"), Some(false));\n-        assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n-    }\n-\n     #[test]\n     fn test_to_str() {\n         assert_eq!(false.to_str(), \"false\".to_owned());", "previous_filename": "src/libstd/bool.rs"}, {"sha": "8cea197fbfa4a2f187b1fd9f061df68354ceddd6", "filename": "src/libcore/cast.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -108,7 +108,7 @@ pub unsafe fn copy_lifetime_vec<'a,S,T>(_ptr: &'a [S], ptr: &T) -> &'a T {\n mod tests {\n     use cast::{bump_box_refcount, transmute};\n     use raw;\n-    use str::StrSlice;\n+    use realstd::str::StrAllocating;\n \n     #[test]\n     fn test_transmute_copy() {", "previous_filename": "src/libstd/cast.rs"}, {"sha": "8951c7d806ab2ca1ec064c3de1a009f454145b76", "filename": "src/libcore/cell.rs", "status": "renamed", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -12,7 +12,6 @@\n \n use clone::Clone;\n use cmp::Eq;\n-use fmt;\n use kinds::{marker, Copy};\n use ops::{Deref, DerefMut, Drop};\n use option::{None, Option, Some};\n@@ -60,12 +59,6 @@ impl<T:Eq + Copy> Eq for Cell<T> {\n     }\n }\n \n-impl<T: Copy + fmt::Show> fmt::Show for Cell<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, r\"Cell \\{ value: {} \\}\", self.get())\n-    }\n-}\n-\n /// A mutable memory location with dynamically checked borrow rules\n pub struct RefCell<T> {\n     value: Unsafe<T>,\n@@ -228,22 +221,22 @@ mod test {\n     #[test]\n     fn smoketest_cell() {\n         let x = Cell::new(10);\n-        assert_eq!(x, Cell::new(10));\n-        assert_eq!(x.get(), 10);\n+        assert!(x == Cell::new(10));\n+        assert!(x.get() == 10);\n         x.set(20);\n-        assert_eq!(x, Cell::new(20));\n-        assert_eq!(x.get(), 20);\n+        assert!(x == Cell::new(20));\n+        assert!(x.get() == 20);\n \n         let y = Cell::new((30, 40));\n-        assert_eq!(y, Cell::new((30, 40)));\n-        assert_eq!(y.get(), (30, 40));\n+        assert!(y == Cell::new((30, 40)));\n+        assert!(y.get() == (30, 40));\n     }\n \n     #[test]\n     fn cell_has_sensible_show() {\n         use str::StrSlice;\n \n-        let x = Cell::new(\"foo bar\");\n+        let x = ::realcore::cell::Cell::new(\"foo bar\");\n         assert!(format!(\"{}\", x).contains(x.get()));\n \n         x.set(\"baz qux\");", "previous_filename": "src/libstd/cell.rs"}, {"sha": "1e31486c63f1c0670c0f8df291fe2487d9fb6cd1", "filename": "src/libcore/char.rs", "status": "renamed", "additions": 177, "deletions": 161, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -27,14 +27,9 @@\n use cast::transmute;\n use option::{None, Option, Some};\n use iter::{Iterator, range_step};\n-use str::StrSlice;\n use unicode::{derived_property, property, general_category, decompose, conversions};\n \n-#[cfg(test)] use str::Str;\n-#[cfg(test)] use strbuf::StrBuf;\n-#[cfg(test)] use slice::ImmutableVector;\n-\n-#[cfg(not(test))] use cmp::{Eq, Ord};\n+#[cfg(not(test))] use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering};\n #[cfg(not(test))] use default::Default;\n \n // UTF-8 ranges and tags for encoding characters\n@@ -215,7 +210,7 @@ pub fn is_digit_radix(c: char, radix: uint) -> bool {\n #[inline]\n pub fn to_digit(c: char, radix: uint) -> Option<uint> {\n     if radix > 36 {\n-        fail!(\"to_digit: radix {} is too high (maximum 36)\", radix);\n+        fail!(\"to_digit: radix is too high (maximum 36)\");\n     }\n     let val = match c {\n       '0' .. '9' => c as uint - ('0' as uint),\n@@ -274,7 +269,7 @@ pub fn to_lowercase(c: char) -> char {\n #[inline]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n-        fail!(\"from_digit: radix {} is to high (maximum 36)\", num);\n+        fail!(\"from_digit: radix is to high (maximum 36)\");\n     }\n     if num < radix {\n         unsafe {\n@@ -659,187 +654,208 @@ impl Eq for char {\n     fn eq(&self, other: &char) -> bool { (*self) == (*other) }\n }\n \n+#[cfg(not(test))]\n+impl TotalEq for char {}\n+\n #[cfg(not(test))]\n impl Ord for char {\n     #[inline]\n     fn lt(&self, other: &char) -> bool { *self < *other }\n }\n \n+#[cfg(not(test))]\n+impl TotalOrd for char {\n+    fn cmp(&self, other: &char) -> Ordering {\n+        (*self as u32).cmp(&(*other as u32))\n+    }\n+}\n+\n #[cfg(not(test))]\n impl Default for char {\n     #[inline]\n     fn default() -> char { '\\x00' }\n }\n \n-#[test]\n-fn test_is_lowercase() {\n-    assert!('a'.is_lowercase());\n-    assert!('\u00f6'.is_lowercase());\n-    assert!('\u00df'.is_lowercase());\n-    assert!(!'\u00dc'.is_lowercase());\n-    assert!(!'P'.is_lowercase());\n-}\n+#[cfg(test)]\n+mod test {\n+    use super::{escape_unicode, escape_default};\n \n-#[test]\n-fn test_is_uppercase() {\n-    assert!(!'h'.is_uppercase());\n-    assert!(!'\u00e4'.is_uppercase());\n-    assert!(!'\u00df'.is_uppercase());\n-    assert!('\u00d6'.is_uppercase());\n-    assert!('T'.is_uppercase());\n-}\n+    use realcore::char::Char;\n+    use slice::ImmutableVector;\n+    use realstd::option::{Some, None};\n+    use realstd::strbuf::StrBuf;\n+    use realstd::str::StrAllocating;\n \n-#[test]\n-fn test_is_whitespace() {\n-    assert!(' '.is_whitespace());\n-    assert!('\\u2007'.is_whitespace());\n-    assert!('\\t'.is_whitespace());\n-    assert!('\\n'.is_whitespace());\n-    assert!(!'a'.is_whitespace());\n-    assert!(!'_'.is_whitespace());\n-    assert!(!'\\u0000'.is_whitespace());\n-}\n+    #[test]\n+    fn test_is_lowercase() {\n+        assert!('a'.is_lowercase());\n+        assert!('\u00f6'.is_lowercase());\n+        assert!('\u00df'.is_lowercase());\n+        assert!(!'\u00dc'.is_lowercase());\n+        assert!(!'P'.is_lowercase());\n+    }\n \n-#[test]\n-fn test_to_digit() {\n-    assert_eq!('0'.to_digit(10u), Some(0u));\n-    assert_eq!('1'.to_digit(2u), Some(1u));\n-    assert_eq!('2'.to_digit(3u), Some(2u));\n-    assert_eq!('9'.to_digit(10u), Some(9u));\n-    assert_eq!('a'.to_digit(16u), Some(10u));\n-    assert_eq!('A'.to_digit(16u), Some(10u));\n-    assert_eq!('b'.to_digit(16u), Some(11u));\n-    assert_eq!('B'.to_digit(16u), Some(11u));\n-    assert_eq!('z'.to_digit(36u), Some(35u));\n-    assert_eq!('Z'.to_digit(36u), Some(35u));\n-    assert_eq!(' '.to_digit(10u), None);\n-    assert_eq!('$'.to_digit(36u), None);\n-}\n+    #[test]\n+    fn test_is_uppercase() {\n+        assert!(!'h'.is_uppercase());\n+        assert!(!'\u00e4'.is_uppercase());\n+        assert!(!'\u00df'.is_uppercase());\n+        assert!('\u00d6'.is_uppercase());\n+        assert!('T'.is_uppercase());\n+    }\n \n-#[test]\n-fn test_to_lowercase() {\n-    assert_eq!('A'.to_lowercase(), 'a');\n-    assert_eq!('\u00d6'.to_lowercase(), '\u00f6');\n-    assert_eq!('\u00df'.to_lowercase(), '\u00df');\n-    assert_eq!('\u00dc'.to_lowercase(), '\u00fc');\n-    assert_eq!('\ud83d\udca9'.to_lowercase(), '\ud83d\udca9');\n-    assert_eq!('\u03a3'.to_lowercase(), '\u03c3');\n-    assert_eq!('\u03a4'.to_lowercase(), '\u03c4');\n-    assert_eq!('\u0399'.to_lowercase(), '\u03b9');\n-    assert_eq!('\u0393'.to_lowercase(), '\u03b3');\n-    assert_eq!('\u039c'.to_lowercase(), '\u03bc');\n-    assert_eq!('\u0391'.to_lowercase(), '\u03b1');\n-    assert_eq!('\u03a3'.to_lowercase(), '\u03c3');\n-}\n+    #[test]\n+    fn test_is_whitespace() {\n+        assert!(' '.is_whitespace());\n+        assert!('\\u2007'.is_whitespace());\n+        assert!('\\t'.is_whitespace());\n+        assert!('\\n'.is_whitespace());\n+        assert!(!'a'.is_whitespace());\n+        assert!(!'_'.is_whitespace());\n+        assert!(!'\\u0000'.is_whitespace());\n+    }\n \n-#[test]\n-fn test_to_uppercase() {\n-    assert_eq!('a'.to_uppercase(), 'A');\n-    assert_eq!('\u00f6'.to_uppercase(), '\u00d6');\n-    assert_eq!('\u00df'.to_uppercase(), '\u00df'); // not \u1e9e: Latin capital letter sharp s\n-    assert_eq!('\u00fc'.to_uppercase(), '\u00dc');\n-    assert_eq!('\ud83d\udca9'.to_uppercase(), '\ud83d\udca9');\n-\n-    assert_eq!('\u03c3'.to_uppercase(), '\u03a3');\n-    assert_eq!('\u03c4'.to_uppercase(), '\u03a4');\n-    assert_eq!('\u03b9'.to_uppercase(), '\u0399');\n-    assert_eq!('\u03b3'.to_uppercase(), '\u0393');\n-    assert_eq!('\u03bc'.to_uppercase(), '\u039c');\n-    assert_eq!('\u03b1'.to_uppercase(), '\u0391');\n-    assert_eq!('\u03c2'.to_uppercase(), '\u03a3');\n-}\n+    #[test]\n+    fn test_to_digit() {\n+        assert_eq!('0'.to_digit(10u), Some(0u));\n+        assert_eq!('1'.to_digit(2u), Some(1u));\n+        assert_eq!('2'.to_digit(3u), Some(2u));\n+        assert_eq!('9'.to_digit(10u), Some(9u));\n+        assert_eq!('a'.to_digit(16u), Some(10u));\n+        assert_eq!('A'.to_digit(16u), Some(10u));\n+        assert_eq!('b'.to_digit(16u), Some(11u));\n+        assert_eq!('B'.to_digit(16u), Some(11u));\n+        assert_eq!('z'.to_digit(36u), Some(35u));\n+        assert_eq!('Z'.to_digit(36u), Some(35u));\n+        assert_eq!(' '.to_digit(10u), None);\n+        assert_eq!('$'.to_digit(36u), None);\n+    }\n \n-#[test]\n-fn test_is_control() {\n-    assert!('\\u0000'.is_control());\n-    assert!('\\u0003'.is_control());\n-    assert!('\\u0006'.is_control());\n-    assert!('\\u0009'.is_control());\n-    assert!('\\u007f'.is_control());\n-    assert!('\\u0092'.is_control());\n-    assert!(!'\\u0020'.is_control());\n-    assert!(!'\\u0055'.is_control());\n-    assert!(!'\\u0068'.is_control());\n-}\n+    #[test]\n+    fn test_to_lowercase() {\n+        assert_eq!('A'.to_lowercase(), 'a');\n+        assert_eq!('\u00d6'.to_lowercase(), '\u00f6');\n+        assert_eq!('\u00df'.to_lowercase(), '\u00df');\n+        assert_eq!('\u00dc'.to_lowercase(), '\u00fc');\n+        assert_eq!('\ud83d\udca9'.to_lowercase(), '\ud83d\udca9');\n+        assert_eq!('\u03a3'.to_lowercase(), '\u03c3');\n+        assert_eq!('\u03a4'.to_lowercase(), '\u03c4');\n+        assert_eq!('\u0399'.to_lowercase(), '\u03b9');\n+        assert_eq!('\u0393'.to_lowercase(), '\u03b3');\n+        assert_eq!('\u039c'.to_lowercase(), '\u03bc');\n+        assert_eq!('\u0391'.to_lowercase(), '\u03b1');\n+        assert_eq!('\u03a3'.to_lowercase(), '\u03c3');\n+    }\n \n-#[test]\n-fn test_is_digit() {\n-   assert!('2'.is_digit());\n-   assert!('7'.is_digit());\n-   assert!(!'c'.is_digit());\n-   assert!(!'i'.is_digit());\n-   assert!(!'z'.is_digit());\n-   assert!(!'Q'.is_digit());\n-}\n+    #[test]\n+    fn test_to_uppercase() {\n+        assert_eq!('a'.to_uppercase(), 'A');\n+        assert_eq!('\u00f6'.to_uppercase(), '\u00d6');\n+        assert_eq!('\u00df'.to_uppercase(), '\u00df'); // not \u1e9e: Latin capital letter sharp s\n+        assert_eq!('\u00fc'.to_uppercase(), '\u00dc');\n+        assert_eq!('\ud83d\udca9'.to_uppercase(), '\ud83d\udca9');\n+\n+        assert_eq!('\u03c3'.to_uppercase(), '\u03a3');\n+        assert_eq!('\u03c4'.to_uppercase(), '\u03a4');\n+        assert_eq!('\u03b9'.to_uppercase(), '\u0399');\n+        assert_eq!('\u03b3'.to_uppercase(), '\u0393');\n+        assert_eq!('\u03bc'.to_uppercase(), '\u039c');\n+        assert_eq!('\u03b1'.to_uppercase(), '\u0391');\n+        assert_eq!('\u03c2'.to_uppercase(), '\u03a3');\n+    }\n \n-#[test]\n-fn test_escape_default() {\n-    fn string(c: char) -> ~str {\n-        let mut result = StrBuf::new();\n-        escape_default(c, |c| { result.push_char(c); });\n-        return result.into_owned();\n+    #[test]\n+    fn test_is_control() {\n+        assert!('\\u0000'.is_control());\n+        assert!('\\u0003'.is_control());\n+        assert!('\\u0006'.is_control());\n+        assert!('\\u0009'.is_control());\n+        assert!('\\u007f'.is_control());\n+        assert!('\\u0092'.is_control());\n+        assert!(!'\\u0020'.is_control());\n+        assert!(!'\\u0055'.is_control());\n+        assert!(!'\\u0068'.is_control());\n     }\n-    assert_eq!(string('\\n'), \"\\\\n\".to_owned());\n-    assert_eq!(string('\\r'), \"\\\\r\".to_owned());\n-    assert_eq!(string('\\''), \"\\\\'\".to_owned());\n-    assert_eq!(string('\"'), \"\\\\\\\"\".to_owned());\n-    assert_eq!(string(' '), \" \".to_owned());\n-    assert_eq!(string('a'), \"a\".to_owned());\n-    assert_eq!(string('~'), \"~\".to_owned());\n-    assert_eq!(string('\\x00'), \"\\\\x00\".to_owned());\n-    assert_eq!(string('\\x1f'), \"\\\\x1f\".to_owned());\n-    assert_eq!(string('\\x7f'), \"\\\\x7f\".to_owned());\n-    assert_eq!(string('\\xff'), \"\\\\xff\".to_owned());\n-    assert_eq!(string('\\u011b'), \"\\\\u011b\".to_owned());\n-    assert_eq!(string('\\U0001d4b6'), \"\\\\U0001d4b6\".to_owned());\n-}\n \n-#[test]\n-fn test_escape_unicode() {\n-    fn string(c: char) -> ~str {\n-        let mut result = StrBuf::new();\n-        escape_unicode(c, |c| { result.push_char(c); });\n-        return result.into_owned();\n+    #[test]\n+    fn test_is_digit() {\n+       assert!('2'.is_digit());\n+       assert!('7'.is_digit());\n+       assert!(!'c'.is_digit());\n+       assert!(!'i'.is_digit());\n+       assert!(!'z'.is_digit());\n+       assert!(!'Q'.is_digit());\n     }\n-    assert_eq!(string('\\x00'), \"\\\\x00\".to_owned());\n-    assert_eq!(string('\\n'), \"\\\\x0a\".to_owned());\n-    assert_eq!(string(' '), \"\\\\x20\".to_owned());\n-    assert_eq!(string('a'), \"\\\\x61\".to_owned());\n-    assert_eq!(string('\\u011b'), \"\\\\u011b\".to_owned());\n-    assert_eq!(string('\\U0001d4b6'), \"\\\\U0001d4b6\".to_owned());\n-}\n \n-#[test]\n-fn test_to_str() {\n-    use to_str::ToStr;\n-    let s = 't'.to_str();\n-    assert_eq!(s, \"t\".to_owned());\n-}\n+    #[test]\n+    fn test_escape_default() {\n+        fn string(c: char) -> ~str {\n+            let mut result = StrBuf::new();\n+            escape_default(c, |c| { result.push_char(c); });\n+            return result.into_owned();\n+        }\n+        assert_eq!(string('\\n'), \"\\\\n\".to_owned());\n+        assert_eq!(string('\\r'), \"\\\\r\".to_owned());\n+        assert_eq!(string('\\''), \"\\\\'\".to_owned());\n+        assert_eq!(string('\"'), \"\\\\\\\"\".to_owned());\n+        assert_eq!(string(' '), \" \".to_owned());\n+        assert_eq!(string('a'), \"a\".to_owned());\n+        assert_eq!(string('~'), \"~\".to_owned());\n+        assert_eq!(string('\\x00'), \"\\\\x00\".to_owned());\n+        assert_eq!(string('\\x1f'), \"\\\\x1f\".to_owned());\n+        assert_eq!(string('\\x7f'), \"\\\\x7f\".to_owned());\n+        assert_eq!(string('\\xff'), \"\\\\xff\".to_owned());\n+        assert_eq!(string('\\u011b'), \"\\\\u011b\".to_owned());\n+        assert_eq!(string('\\U0001d4b6'), \"\\\\U0001d4b6\".to_owned());\n+    }\n \n-#[test]\n-fn test_encode_utf8() {\n-    fn check(input: char, expect: &[u8]) {\n-        let mut buf = [0u8, ..4];\n-        let n = input.encode_utf8(buf /* as mut slice! */);\n-        assert_eq!(buf.slice_to(n), expect);\n+    #[test]\n+    fn test_escape_unicode() {\n+        fn string(c: char) -> ~str {\n+            let mut result = StrBuf::new();\n+            escape_unicode(c, |c| { result.push_char(c); });\n+            return result.into_owned();\n+        }\n+        assert_eq!(string('\\x00'), \"\\\\x00\".to_owned());\n+        assert_eq!(string('\\n'), \"\\\\x0a\".to_owned());\n+        assert_eq!(string(' '), \"\\\\x20\".to_owned());\n+        assert_eq!(string('a'), \"\\\\x61\".to_owned());\n+        assert_eq!(string('\\u011b'), \"\\\\u011b\".to_owned());\n+        assert_eq!(string('\\U0001d4b6'), \"\\\\U0001d4b6\".to_owned());\n     }\n \n-    check('x', [0x78]);\n-    check('\\u00e9', [0xc3, 0xa9]);\n-    check('\\ua66e', [0xea, 0x99, 0xae]);\n-    check('\\U0001f4a9', [0xf0, 0x9f, 0x92, 0xa9]);\n-}\n+    #[test]\n+    fn test_to_str() {\n+        use realstd::to_str::ToStr;\n+        let s = 't'.to_str();\n+        assert_eq!(s, \"t\".to_owned());\n+    }\n+\n+    #[test]\n+    fn test_encode_utf8() {\n+        fn check(input: char, expect: &[u8]) {\n+            let mut buf = [0u8, ..4];\n+            let n = input.encode_utf8(buf /* as mut slice! */);\n+            assert_eq!(buf.slice_to(n), expect);\n+        }\n \n-#[test]\n-fn test_encode_utf16() {\n-    fn check(input: char, expect: &[u16]) {\n-        let mut buf = [0u16, ..2];\n-        let n = input.encode_utf16(buf /* as mut slice! */);\n-        assert_eq!(buf.slice_to(n), expect);\n+        check('x', [0x78]);\n+        check('\\u00e9', [0xc3, 0xa9]);\n+        check('\\ua66e', [0xea, 0x99, 0xae]);\n+        check('\\U0001f4a9', [0xf0, 0x9f, 0x92, 0xa9]);\n     }\n \n-    check('x', [0x0078]);\n-    check('\\u00e9', [0x00e9]);\n-    check('\\ua66e', [0xa66e]);\n-    check('\\U0001f4a9', [0xd83d, 0xdca9]);\n+    #[test]\n+    fn test_encode_utf16() {\n+        fn check(input: char, expect: &[u16]) {\n+            let mut buf = [0u16, ..2];\n+            let n = input.encode_utf16(buf /* as mut slice! */);\n+            assert_eq!(buf.slice_to(n), expect);\n+        }\n+\n+        check('x', [0x0078]);\n+        check('\\u00e9', [0x00e9]);\n+        check('\\ua66e', [0xa66e]);\n+        check('\\U0001f4a9', [0xd83d, 0xdca9]);\n+    }\n }", "previous_filename": "src/libstd/char.rs"}, {"sha": "06cbaf19812804fe65a09bc500bb93a6406bbefd", "filename": "src/libcore/clone.rs", "status": "renamed", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -126,46 +126,52 @@ extern_fn_clone!(A, B, C, D, E, F)\n extern_fn_clone!(A, B, C, D, E, F, G)\n extern_fn_clone!(A, B, C, D, E, F, G, H)\n \n-#[test]\n-fn test_owned_clone() {\n-    let a = box 5i;\n-    let b: Box<int> = a.clone();\n-    assert_eq!(a, b);\n-}\n+#[cfg(test)]\n+mod test {\n+    use prelude::*;\n+    use owned::Box;\n+\n+    #[test]\n+    fn test_owned_clone() {\n+        let a = box 5i;\n+        let b: Box<int> = a.clone();\n+        assert_eq!(a, b);\n+    }\n \n-#[test]\n-fn test_managed_clone() {\n-    let a = @5i;\n-    let b: @int = a.clone();\n-    assert_eq!(a, b);\n-}\n+    #[test]\n+    fn test_managed_clone() {\n+        let a = @5i;\n+        let b: @int = a.clone();\n+        assert_eq!(a, b);\n+    }\n \n-#[test]\n-fn test_borrowed_clone() {\n-    let x = 5i;\n-    let y: &int = &x;\n-    let z: &int = (&y).clone();\n-    assert_eq!(*z, 5);\n-}\n+    #[test]\n+    fn test_borrowed_clone() {\n+        let x = 5i;\n+        let y: &int = &x;\n+        let z: &int = (&y).clone();\n+        assert_eq!(*z, 5);\n+    }\n \n-#[test]\n-fn test_clone_from() {\n-    let a = box 5;\n-    let mut b = box 10;\n-    b.clone_from(&a);\n-    assert_eq!(*b, 5);\n-}\n+    #[test]\n+    fn test_clone_from() {\n+        let a = box 5;\n+        let mut b = box 10;\n+        b.clone_from(&a);\n+        assert_eq!(*b, 5);\n+    }\n \n-#[test]\n-fn test_extern_fn_clone() {\n-    trait Empty {}\n-    impl Empty for int {}\n+    #[test]\n+    fn test_extern_fn_clone() {\n+        trait Empty {}\n+        impl Empty for int {}\n \n-    fn test_fn_a() -> f64 { 1.0 }\n-    fn test_fn_b<T: Empty>(x: T) -> T { x }\n-    fn test_fn_c(_: int, _: f64, _: ~[int], _: int, _: int, _: int) {}\n+        fn test_fn_a() -> f64 { 1.0 }\n+        fn test_fn_b<T: Empty>(x: T) -> T { x }\n+        fn test_fn_c(_: int, _: f64, _: ~[int], _: int, _: int, _: int) {}\n \n-    let _ = test_fn_a.clone();\n-    let _ = test_fn_b::<int>.clone();\n-    let _ = test_fn_c.clone();\n+        let _ = test_fn_a.clone();\n+        let _ = test_fn_b::<int>.clone();\n+        let _ = test_fn_c.clone();\n+    }\n }", "previous_filename": "src/libstd/clone.rs"}, {"sha": "af611cd94e506e656fac8b532082e3e2fa0d8a8b", "filename": "src/libcore/cmp.rs", "status": "renamed", "additions": 78, "deletions": 54, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -81,32 +81,8 @@ pub trait TotalEq: Eq {\n     fn assert_receiver_is_total_eq(&self) {}\n }\n \n-/// A macro which defines an implementation of TotalEq for a given type.\n-macro_rules! totaleq_impl(\n-    ($t:ty) => {\n-        impl TotalEq for $t {}\n-    }\n-)\n-\n-totaleq_impl!(bool)\n-\n-totaleq_impl!(u8)\n-totaleq_impl!(u16)\n-totaleq_impl!(u32)\n-totaleq_impl!(u64)\n-\n-totaleq_impl!(i8)\n-totaleq_impl!(i16)\n-totaleq_impl!(i32)\n-totaleq_impl!(i64)\n-\n-totaleq_impl!(int)\n-totaleq_impl!(uint)\n-\n-totaleq_impl!(char)\n-\n /// An ordering is, e.g, a result of a comparison between two values.\n-#[deriving(Clone, Eq, Show)]\n+#[deriving(Clone, Eq)]\n pub enum Ordering {\n    /// An ordering where a compared value is less [than another].\n    Less = -1,\n@@ -140,6 +116,7 @@ pub trait TotalOrd: TotalEq + Ord {\n }\n \n impl TotalEq for Ordering {}\n+\n impl TotalOrd for Ordering {\n     #[inline]\n     fn cmp(&self, other: &Ordering) -> Ordering {\n@@ -152,35 +129,6 @@ impl Ord for Ordering {\n     fn lt(&self, other: &Ordering) -> bool { (*self as int) < (*other as int) }\n }\n \n-/// A macro which defines an implementation of TotalOrd for a given type.\n-macro_rules! totalord_impl(\n-    ($t:ty) => {\n-        impl TotalOrd for $t {\n-            #[inline]\n-            fn cmp(&self, other: &$t) -> Ordering {\n-                if *self < *other { Less }\n-                else if *self > *other { Greater }\n-                else { Equal }\n-            }\n-        }\n-    }\n-)\n-\n-totalord_impl!(u8)\n-totalord_impl!(u16)\n-totalord_impl!(u32)\n-totalord_impl!(u64)\n-\n-totalord_impl!(i8)\n-totalord_impl!(i16)\n-totalord_impl!(i32)\n-totalord_impl!(i64)\n-\n-totalord_impl!(int)\n-totalord_impl!(uint)\n-\n-totalord_impl!(char)\n-\n /// Combine orderings, lexically.\n ///\n /// For example for a type `(int, int)`, two comparisons could be done.\n@@ -241,6 +189,82 @@ pub fn max<T: TotalOrd>(v1: T, v2: T) -> T {\n     if v1 > v2 { v1 } else { v2 }\n }\n \n+// Implementation of Eq/TotalEq for some primitive types\n+#[cfg(not(test))]\n+mod impls {\n+    use cmp::{Ord, TotalOrd, Eq, TotalEq, Ordering};\n+    use owned::Box;\n+\n+    // & pointers\n+    impl<'a, T: Eq> Eq for &'a T {\n+        #[inline]\n+        fn eq(&self, other: & &'a T) -> bool { *(*self) == *(*other) }\n+        #[inline]\n+        fn ne(&self, other: & &'a T) -> bool { *(*self) != *(*other) }\n+    }\n+    impl<'a, T: Ord> Ord for &'a T {\n+        #[inline]\n+        fn lt(&self, other: & &'a T) -> bool { *(*self) < *(*other) }\n+        #[inline]\n+        fn le(&self, other: & &'a T) -> bool { *(*self) <= *(*other) }\n+        #[inline]\n+        fn ge(&self, other: & &'a T) -> bool { *(*self) >= *(*other) }\n+        #[inline]\n+        fn gt(&self, other: & &'a T) -> bool { *(*self) > *(*other) }\n+    }\n+    impl<'a, T: TotalOrd> TotalOrd for &'a T {\n+        #[inline]\n+        fn cmp(&self, other: & &'a T) -> Ordering { (**self).cmp(*other) }\n+    }\n+    impl<'a, T: TotalEq> TotalEq for &'a T {}\n+\n+    // @ pointers\n+    impl<T:Eq> Eq for @T {\n+        #[inline]\n+        fn eq(&self, other: &@T) -> bool { *(*self) == *(*other) }\n+        #[inline]\n+        fn ne(&self, other: &@T) -> bool { *(*self) != *(*other) }\n+    }\n+    impl<T:Ord> Ord for @T {\n+        #[inline]\n+        fn lt(&self, other: &@T) -> bool { *(*self) < *(*other) }\n+        #[inline]\n+        fn le(&self, other: &@T) -> bool { *(*self) <= *(*other) }\n+        #[inline]\n+        fn ge(&self, other: &@T) -> bool { *(*self) >= *(*other) }\n+        #[inline]\n+        fn gt(&self, other: &@T) -> bool { *(*self) > *(*other) }\n+    }\n+    impl<T: TotalOrd> TotalOrd for @T {\n+        #[inline]\n+        fn cmp(&self, other: &@T) -> Ordering { (**self).cmp(*other) }\n+    }\n+    impl<T: TotalEq> TotalEq for @T {}\n+\n+    // box pointers\n+    impl<T:Eq> Eq for Box<T> {\n+        #[inline]\n+        fn eq(&self, other: &Box<T>) -> bool { *(*self) == *(*other) }\n+        #[inline]\n+        fn ne(&self, other: &Box<T>) -> bool { *(*self) != *(*other) }\n+    }\n+    impl<T:Ord> Ord for Box<T> {\n+        #[inline]\n+        fn lt(&self, other: &Box<T>) -> bool { *(*self) < *(*other) }\n+        #[inline]\n+        fn le(&self, other: &Box<T>) -> bool { *(*self) <= *(*other) }\n+        #[inline]\n+        fn ge(&self, other: &Box<T>) -> bool { *(*self) >= *(*other) }\n+        #[inline]\n+        fn gt(&self, other: &Box<T>) -> bool { *(*self) > *(*other) }\n+    }\n+    impl<T: TotalOrd> TotalOrd for Box<T> {\n+        #[inline]\n+        fn cmp(&self, other: &Box<T>) -> Ordering { (**self).cmp(*other) }\n+    }\n+    impl<T: TotalEq> TotalEq for Box<T> {}\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::lexical_ordering;", "previous_filename": "src/libstd/cmp.rs"}, {"sha": "e8ee3792dcf2cdf423398ec3606003b594d9b192", "filename": "src/libcore/container.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "previous_filename": "src/libstd/container.rs"}, {"sha": "9cf3a7636488749413980ce90e0c4c68f3454037", "filename": "src/libcore/default.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "previous_filename": "src/libstd/default.rs"}, {"sha": "2296e663033cb0d754dc9a3d9b31e7083aa71319", "filename": "src/libcore/failure.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffailure.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Failure support for libcore\n+\n+#![allow(dead_code)]\n+\n+#[cfg(not(test))]\n+use str::raw::c_str_to_static_slice;\n+\n+// FIXME: Once std::fmt is in libcore, all of these functions should delegate\n+//        to a common failure function with this signature:\n+//\n+//          extern {\n+//              fn rust_unwind(f: &fmt::Arguments, file: &str, line: uint) -> !;\n+//          }\n+//\n+//        Each of these functions can create a temporary fmt::Arguments\n+//        structure to pass to this function.\n+\n+#[cold] #[inline(never)] // this is the slow path, always\n+#[lang=\"fail_\"]\n+#[cfg(not(test))]\n+fn fail_(expr: *u8, file: *u8, line: uint) -> ! {\n+    unsafe {\n+        let expr = c_str_to_static_slice(expr as *i8);\n+        let file = c_str_to_static_slice(file as *i8);\n+        begin_unwind(expr, file, line)\n+    }\n+}\n+\n+#[cold]\n+#[lang=\"fail_bounds_check\"]\n+#[cfg(not(test))]\n+fn fail_bounds_check(file: *u8, line: uint, index: uint, len: uint) -> ! {\n+    #[allow(ctypes)]\n+    extern { fn rust_fail_bounds_check(file: *u8, line: uint,\n+                                       index: uint, len: uint,) -> !; }\n+    unsafe { rust_fail_bounds_check(file, line, index, len) }\n+}\n+\n+#[cold]\n+pub fn begin_unwind(msg: &str, file: &'static str, line: uint) -> ! {\n+    #[allow(ctypes)]\n+    extern { fn rust_begin_unwind(msg: &str, file: &'static str,\n+                                  line: uint) -> !; }\n+    unsafe { rust_begin_unwind(msg, file, line) }\n+}"}, {"sha": "a4d261f539a5005a8761a049a22b628a059ed5b0", "filename": "src/libcore/finally.rs", "status": "renamed", "additions": 54, "deletions": 44, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -30,11 +30,15 @@ use std::unstable::finally::Finally;\n ```\n */\n \n-use ops::Drop;\n+#![experimental]\n \n-#[cfg(test)] use task::failing;\n+use ops::Drop;\n \n+/// A trait for executing a destructor unconditionally after a block of code,\n+/// regardless of whether the blocked fails.\n pub trait Finally<T> {\n+    /// Executes this object, unconditionally running `dtor` after this block of\n+    /// code has run.\n     fn finally(&mut self, dtor: ||) -> T;\n }\n \n@@ -111,49 +115,55 @@ impl<'a,A> Drop for Finallyalizer<'a,A> {\n     }\n }\n \n-#[test]\n-fn test_success() {\n-    let mut i = 0;\n-    try_finally(\n-        &mut i, (),\n-        |i, ()| {\n-            *i = 10;\n-        },\n-        |i| {\n-            assert!(!failing());\n-            assert_eq!(*i, 10);\n-            *i = 20;\n-        });\n-    assert_eq!(i, 20);\n-}\n+#[cfg(test)]\n+mod test {\n+    use super::{try_finally, Finally};\n+    use realstd::task::failing;\n+\n+    #[test]\n+    fn test_success() {\n+        let mut i = 0;\n+        try_finally(\n+            &mut i, (),\n+            |i, ()| {\n+                *i = 10;\n+            },\n+            |i| {\n+                assert!(!failing());\n+                assert_eq!(*i, 10);\n+                *i = 20;\n+            });\n+        assert_eq!(i, 20);\n+    }\n \n-#[test]\n-#[should_fail]\n-fn test_fail() {\n-    let mut i = 0;\n-    try_finally(\n-        &mut i, (),\n-        |i, ()| {\n-            *i = 10;\n-            fail!();\n-        },\n-        |i| {\n-            assert!(failing());\n-            assert_eq!(*i, 10);\n-        })\n-}\n+    #[test]\n+    #[should_fail]\n+    fn test_fail() {\n+        let mut i = 0;\n+        try_finally(\n+            &mut i, (),\n+            |i, ()| {\n+                *i = 10;\n+                fail!();\n+            },\n+            |i| {\n+                assert!(failing());\n+                assert_eq!(*i, 10);\n+            })\n+    }\n \n-#[test]\n-fn test_retval() {\n-    let mut closure: || -> int = || 10;\n-    let i = closure.finally(|| { });\n-    assert_eq!(i, 10);\n-}\n+    #[test]\n+    fn test_retval() {\n+        let mut closure: || -> int = || 10;\n+        let i = closure.finally(|| { });\n+        assert_eq!(i, 10);\n+    }\n \n-#[test]\n-fn test_compact() {\n-    fn do_some_fallible_work() {}\n-    fn but_always_run_this_function() { }\n-    let mut f = do_some_fallible_work;\n-    f.finally(but_always_run_this_function);\n+    #[test]\n+    fn test_compact() {\n+        fn do_some_fallible_work() {}\n+        fn but_always_run_this_function() { }\n+        let mut f = do_some_fallible_work;\n+        f.finally(but_always_run_this_function);\n+    }\n }", "previous_filename": "src/libstd/unstable/finally.rs"}, {"sha": "d7a277d3b6b9f3cf17961deb45a3b40839df999c", "filename": "src/libcore/intrinsics.rs", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -41,11 +41,12 @@ A quick refresher on memory ordering:\n \n */\n \n+#![experimental]\n #![allow(missing_doc)]\n \n // This is needed to prevent duplicate lang item definitions.\n #[cfg(test)]\n-pub use realstd::intrinsics::{TyDesc, Opaque, TyVisitor, TypeId};\n+pub use realcore::intrinsics::{TyDesc, Opaque, TyVisitor, TypeId};\n \n pub type GlueFn = extern \"Rust\" fn(*i8);\n \n@@ -470,7 +471,7 @@ extern \"rust-intrinsic\" {\n /// `TypeId` represents a globally unique identifier for a type\n #[lang=\"type_id\"] // This needs to be kept in lockstep with the code in trans/intrinsic.rs and\n                   // middle/lang_items.rs\n-#[deriving(Eq, Hash, Show, TotalEq)]\n+#[deriving(Eq, TotalEq)]\n #[cfg(not(test))]\n pub struct TypeId {\n     t: u64,\n@@ -482,4 +483,5 @@ impl TypeId {\n     pub fn of<T: 'static>() -> TypeId {\n         unsafe { type_id::<T>() }\n     }\n+    pub fn hash(&self) -> u64 { self.t }\n }", "previous_filename": "src/libstd/intrinsics.rs"}, {"sha": "5ee642cd8100d1a3f080ab7f0744e4e48c50545b", "filename": "src/libcore/iter.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -969,7 +969,7 @@ impl<A: TotalOrd, T: Iterator<A>> OrdIterator<A> for T {\n }\n \n /// `MinMaxResult` is an enum returned by `min_max`. See `OrdIterator::min_max` for more detail.\n-#[deriving(Clone, Eq, Show)]\n+#[deriving(Clone, Eq)]\n pub enum MinMaxResult<T> {\n     /// Empty iterator\n     NoElements,\n@@ -1090,7 +1090,7 @@ impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T>\n pub struct Chain<T, U> {\n     a: T,\n     b: U,\n-    flag: bool\n+    flag: bool,\n }\n \n impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for Chain<T, U> {\n@@ -2329,13 +2329,13 @@ pub mod order {\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use prelude::*;\n+    use realstd::prelude::*;\n+    use realstd::iter::*;\n+    use realstd::num;\n \n     use cmp;\n     use owned::Box;\n     use uint;\n-    use num;\n \n     #[test]\n     fn test_counter_from_iter() {", "previous_filename": "src/libstd/iter.rs"}, {"sha": "6ef71d3360a752b0cba79d22f38ab2e0d5402989", "filename": "src/libcore/kinds.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "previous_filename": "src/libstd/kinds.rs"}, {"sha": "53de765b89c1d43569ef5d6f880f205325912f88", "filename": "src/libcore/lib.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,114 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The Rust core library\n+\n+#![crate_id = \"core#0.11-pre\"]\n+#![license = \"MIT/ASL2\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+       html_root_url = \"http://static.rust-lang.org/doc/master\")]\n+\n+#![no_std]\n+#![feature(globs, macro_rules, managed_boxes, phase)]\n+#![deny(missing_doc)]\n+\n+#[cfg(test)] extern crate realcore = \"core\";\n+#[cfg(test)] extern crate libc;\n+#[cfg(test)] extern crate native;\n+#[phase(syntax, link)] #[cfg(test)] extern crate realstd = \"std\";\n+#[phase(syntax, link)] #[cfg(test)] extern crate log;\n+\n+#[cfg(test)] pub use cmp = realcore::cmp;\n+#[cfg(test)] pub use kinds = realcore::kinds;\n+#[cfg(test)] pub use ops = realcore::ops;\n+#[cfg(test)] pub use owned = realcore::owned;\n+#[cfg(test)] pub use ty = realcore::ty;\n+\n+#[cfg(not(test))]\n+mod macros;\n+\n+#[path = \"num/float_macros.rs\"] mod float_macros;\n+#[path = \"num/int_macros.rs\"]   mod int_macros;\n+#[path = \"num/uint_macros.rs\"]  mod uint_macros;\n+\n+#[path = \"num/int.rs\"]  pub mod int;\n+#[path = \"num/i8.rs\"]   pub mod i8;\n+#[path = \"num/i16.rs\"]  pub mod i16;\n+#[path = \"num/i32.rs\"]  pub mod i32;\n+#[path = \"num/i64.rs\"]  pub mod i64;\n+\n+#[path = \"num/uint.rs\"] pub mod uint;\n+#[path = \"num/u8.rs\"]   pub mod u8;\n+#[path = \"num/u16.rs\"]  pub mod u16;\n+#[path = \"num/u32.rs\"]  pub mod u32;\n+#[path = \"num/u64.rs\"]  pub mod u64;\n+\n+#[path = \"num/f32.rs\"]   pub mod f32;\n+#[path = \"num/f64.rs\"]   pub mod f64;\n+\n+pub mod num;\n+\n+/* The libcore prelude, not as all-encompassing as the libstd prelude */\n+\n+pub mod prelude;\n+\n+/* Core modules for ownership management */\n+\n+pub mod cast;\n+pub mod intrinsics;\n+pub mod mem;\n+pub mod ptr;\n+\n+/* Core language traits */\n+\n+#[cfg(not(test))] pub mod kinds;\n+#[cfg(not(test))] pub mod ops;\n+#[cfg(not(test))] pub mod ty;\n+#[cfg(not(test))] pub mod cmp;\n+#[cfg(not(test))] pub mod owned;\n+pub mod clone;\n+pub mod default;\n+pub mod container;\n+\n+/* Core types and methods on primitives */\n+\n+mod unicode;\n+mod unit;\n+pub mod any;\n+pub mod bool;\n+pub mod cell;\n+pub mod char;\n+pub mod finally;\n+pub mod iter;\n+pub mod option;\n+pub mod raw;\n+pub mod result;\n+pub mod slice;\n+pub mod str;\n+pub mod tuple;\n+\n+mod failure;\n+\n+// FIXME: this module should not exist. Once owned allocations are no longer a\n+//        language type, this module can move outside to the owned allocation\n+//        crate.\n+mod should_not_exist;\n+\n+mod std {\n+    pub use clone;\n+    pub use cmp;\n+\n+    #[cfg(test)] pub use realstd::fmt;    // needed for fail!()\n+    #[cfg(test)] pub use realstd::rt;     // needed for fail!()\n+    #[cfg(test)] pub use realstd::option; // needed for assert!()\n+    #[cfg(test)] pub use realstd::os;     // needed for tests\n+}"}, {"sha": "50d5cd81ba00e701d2980931ef174cdd958fa79d", "filename": "src/libcore/macros.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![macro_escape]\n+\n+/// Entry point of failure, for details, see std::macros\n+#[macro_export]\n+macro_rules! fail(\n+    () => (\n+        fail!(\"explicit failure\")\n+    );\n+    ($msg:expr) => (\n+        ::failure::begin_unwind($msg, file!(), line!())\n+    );\n+)\n+\n+/// Runtime assertion, for details see std::macros\n+#[macro_export]\n+macro_rules! assert(\n+    ($cond:expr) => (\n+        if !$cond {\n+            fail!(concat!(\"assertion failed: \", stringify!($cond)))\n+        }\n+    );\n+)\n+\n+/// Runtime assertion, disableable at compile time\n+#[macro_export]\n+macro_rules! debug_assert(\n+    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n+)"}, {"sha": "0bac90064d6f43bf3fe8760952e8f7dbbffeb05a", "filename": "src/libcore/mem.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -13,8 +13,6 @@\n //! This module contains functions for querying the size and alignment of\n //! types, initializing and manipulating memory.\n \n-#![allow(missing_doc)] // FIXME\n-\n use cast;\n use ptr;\n use intrinsics;\n@@ -295,7 +293,7 @@ pub fn drop<T>(_x: T) { }\n mod tests {\n     use mem::*;\n     use option::{Some,None};\n-    use str::StrSlice;\n+    use realstd::str::StrAllocating;\n \n     #[test]\n     fn size_of_basic() {", "previous_filename": "src/libstd/mem.rs"}, {"sha": "c4cdc5a0a4017e90d3ce7af9d2c18b99b11cdbbe", "filename": "src/libcore/num/f32.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,227 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for 32-bits floats (`f32` type)\n+\n+use default::Default;\n+use intrinsics;\n+use num::{Zero, One, Bounded, Signed, Num, Primitive};\n+\n+#[cfg(not(test))] use cmp::{Eq, Ord};\n+#[cfg(not(test))] use ops::{Add, Sub, Mul, Div, Rem, Neg};\n+\n+pub static RADIX: uint = 2u;\n+\n+pub static MANTISSA_DIGITS: uint = 24u;\n+pub static DIGITS: uint = 6u;\n+\n+pub static EPSILON: f32 = 1.19209290e-07_f32;\n+\n+/// Smallest finite f32 value\n+pub static MIN_VALUE: f32 = -3.40282347e+38_f32;\n+/// Smallest positive, normalized f32 value\n+pub static MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n+/// Largest finite f32 value\n+pub static MAX_VALUE: f32 = 3.40282347e+38_f32;\n+\n+pub static MIN_EXP: int = -125;\n+pub static MAX_EXP: int = 128;\n+\n+pub static MIN_10_EXP: int = -37;\n+pub static MAX_10_EXP: int = 38;\n+\n+pub static NAN: f32 = 0.0_f32/0.0_f32;\n+pub static INFINITY: f32 = 1.0_f32/0.0_f32;\n+pub static NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n+\n+/// Various useful constants.\n+pub mod consts {\n+    // FIXME: replace with mathematical constants from cmath.\n+\n+    // FIXME(#5527): These constants should be deprecated once associated\n+    // constants are implemented in favour of referencing the respective members\n+    // of `Float`.\n+\n+    /// Archimedes' constant\n+    pub static PI: f32 = 3.14159265358979323846264338327950288_f32;\n+\n+    /// pi * 2.0\n+    pub static PI_2: f32 = 6.28318530717958647692528676655900576_f32;\n+\n+    /// pi/2.0\n+    pub static FRAC_PI_2: f32 = 1.57079632679489661923132169163975144_f32;\n+\n+    /// pi/3.0\n+    pub static FRAC_PI_3: f32 = 1.04719755119659774615421446109316763_f32;\n+\n+    /// pi/4.0\n+    pub static FRAC_PI_4: f32 = 0.785398163397448309615660845819875721_f32;\n+\n+    /// pi/6.0\n+    pub static FRAC_PI_6: f32 = 0.52359877559829887307710723054658381_f32;\n+\n+    /// pi/8.0\n+    pub static FRAC_PI_8: f32 = 0.39269908169872415480783042290993786_f32;\n+\n+    /// 1.0/pi\n+    pub static FRAC_1_PI: f32 = 0.318309886183790671537767526745028724_f32;\n+\n+    /// 2.0/pi\n+    pub static FRAC_2_PI: f32 = 0.636619772367581343075535053490057448_f32;\n+\n+    /// 2.0/sqrt(pi)\n+    pub static FRAC_2_SQRTPI: f32 = 1.12837916709551257389615890312154517_f32;\n+\n+    /// sqrt(2.0)\n+    pub static SQRT2: f32 = 1.41421356237309504880168872420969808_f32;\n+\n+    /// 1.0/sqrt(2.0)\n+    pub static FRAC_1_SQRT2: f32 = 0.707106781186547524400844362104849039_f32;\n+\n+    /// Euler's number\n+    pub static E: f32 = 2.71828182845904523536028747135266250_f32;\n+\n+    /// log2(e)\n+    pub static LOG2_E: f32 = 1.44269504088896340735992468100189214_f32;\n+\n+    /// log10(e)\n+    pub static LOG10_E: f32 = 0.434294481903251827651128918916605082_f32;\n+\n+    /// ln(2.0)\n+    pub static LN_2: f32 = 0.693147180559945309417232121458176568_f32;\n+\n+    /// ln(10.0)\n+    pub static LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n+}\n+\n+#[cfg(not(test))]\n+impl Ord for f32 {\n+    #[inline]\n+    fn lt(&self, other: &f32) -> bool { (*self) < (*other) }\n+    #[inline]\n+    fn le(&self, other: &f32) -> bool { (*self) <= (*other) }\n+    #[inline]\n+    fn ge(&self, other: &f32) -> bool { (*self) >= (*other) }\n+    #[inline]\n+    fn gt(&self, other: &f32) -> bool { (*self) > (*other) }\n+}\n+#[cfg(not(test))]\n+impl Eq for f32 {\n+    #[inline]\n+    fn eq(&self, other: &f32) -> bool { (*self) == (*other) }\n+}\n+\n+impl Num for f32 {}\n+\n+impl Default for f32 {\n+    #[inline]\n+    fn default() -> f32 { 0.0 }\n+}\n+\n+impl Primitive for f32 {}\n+\n+impl Zero for f32 {\n+    #[inline]\n+    fn zero() -> f32 { 0.0 }\n+\n+    /// Returns true if the number is equal to either `0.0` or `-0.0`\n+    #[inline]\n+    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n+}\n+\n+impl One for f32 {\n+    #[inline]\n+    fn one() -> f32 { 1.0 }\n+}\n+\n+#[cfg(not(test))]\n+impl Add<f32,f32> for f32 {\n+    #[inline]\n+    fn add(&self, other: &f32) -> f32 { *self + *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Sub<f32,f32> for f32 {\n+    #[inline]\n+    fn sub(&self, other: &f32) -> f32 { *self - *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Mul<f32,f32> for f32 {\n+    #[inline]\n+    fn mul(&self, other: &f32) -> f32 { *self * *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Div<f32,f32> for f32 {\n+    #[inline]\n+    fn div(&self, other: &f32) -> f32 { *self / *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Rem<f32,f32> for f32 {\n+    #[inline]\n+    fn rem(&self, other: &f32) -> f32 {\n+        extern { fn fmodf(a: f32, b: f32) -> f32; }\n+        unsafe { fmodf(*self, *other) }\n+    }\n+}\n+\n+#[cfg(not(test))]\n+impl Neg<f32> for f32 {\n+    #[inline]\n+    fn neg(&self) -> f32 { -*self }\n+}\n+\n+impl Signed for f32 {\n+    /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n+    #[inline]\n+    fn abs(&self) -> f32 {\n+        unsafe { intrinsics::fabsf32(*self) }\n+    }\n+\n+    /// The positive difference of two numbers. Returns `0.0` if the number is\n+    /// less than or equal to `other`, otherwise the difference between`self`\n+    /// and `other` is returned.\n+    #[inline]\n+    fn abs_sub(&self, other: &f32) -> f32 {\n+        extern { fn fdimf(a: f32, b: f32) -> f32; }\n+        unsafe { fdimf(*self, *other) }\n+    }\n+\n+    /// # Returns\n+    ///\n+    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n+    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n+    /// - `NAN` if the number is NaN\n+    #[inline]\n+    fn signum(&self) -> f32 {\n+        if self != self { NAN } else {\n+            unsafe { intrinsics::copysignf32(1.0, *self) }\n+        }\n+    }\n+\n+    /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n+    #[inline]\n+    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == INFINITY }\n+\n+    /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n+    #[inline]\n+    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == NEG_INFINITY }\n+}\n+\n+impl Bounded for f32 {\n+    // NOTE: this is the smallest non-infinite f32 value, *not* MIN_VALUE\n+    #[inline]\n+    fn min_value() -> f32 { -MAX_VALUE }\n+\n+    #[inline]\n+    fn max_value() -> f32 { MAX_VALUE }\n+}"}, {"sha": "b15b4566cdd689e9f1648fa0d96d7550d22d0137", "filename": "src/libcore/num/f64.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,227 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for 64-bits floats (`f64` type)\n+\n+use default::Default;\n+use intrinsics;\n+use num::{Zero, One, Bounded, Signed, Num, Primitive};\n+\n+#[cfg(not(test))] use cmp::{Eq, Ord};\n+#[cfg(not(test))] use ops::{Add, Sub, Mul, Div, Rem, Neg};\n+\n+// FIXME(#5527): These constants should be deprecated once associated\n+// constants are implemented in favour of referencing the respective\n+// members of `Bounded` and `Float`.\n+\n+pub static RADIX: uint = 2u;\n+\n+pub static MANTISSA_DIGITS: uint = 53u;\n+pub static DIGITS: uint = 15u;\n+\n+pub static EPSILON: f64 = 2.2204460492503131e-16_f64;\n+\n+/// Smallest finite f64 value\n+pub static MIN_VALUE: f64 = -1.7976931348623157e+308_f64;\n+/// Smallest positive, normalized f64 value\n+pub static MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n+/// Largest finite f64 value\n+pub static MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n+\n+pub static MIN_EXP: int = -1021;\n+pub static MAX_EXP: int = 1024;\n+\n+pub static MIN_10_EXP: int = -307;\n+pub static MAX_10_EXP: int = 308;\n+\n+pub static NAN: f64 = 0.0_f64/0.0_f64;\n+\n+pub static INFINITY: f64 = 1.0_f64/0.0_f64;\n+\n+pub static NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n+\n+/// Various useful constants.\n+pub mod consts {\n+    // FIXME: replace with mathematical constants from cmath.\n+\n+    // FIXME(#5527): These constants should be deprecated once associated\n+    // constants are implemented in favour of referencing the respective members\n+    // of `Float`.\n+\n+    /// Archimedes' constant\n+    pub static PI: f64 = 3.14159265358979323846264338327950288_f64;\n+\n+    /// pi * 2.0\n+    pub static PI_2: f64 = 6.28318530717958647692528676655900576_f64;\n+\n+    /// pi/2.0\n+    pub static FRAC_PI_2: f64 = 1.57079632679489661923132169163975144_f64;\n+\n+    /// pi/3.0\n+    pub static FRAC_PI_3: f64 = 1.04719755119659774615421446109316763_f64;\n+\n+    /// pi/4.0\n+    pub static FRAC_PI_4: f64 = 0.785398163397448309615660845819875721_f64;\n+\n+    /// pi/6.0\n+    pub static FRAC_PI_6: f64 = 0.52359877559829887307710723054658381_f64;\n+\n+    /// pi/8.0\n+    pub static FRAC_PI_8: f64 = 0.39269908169872415480783042290993786_f64;\n+\n+    /// 1.0/pi\n+    pub static FRAC_1_PI: f64 = 0.318309886183790671537767526745028724_f64;\n+\n+    /// 2.0/pi\n+    pub static FRAC_2_PI: f64 = 0.636619772367581343075535053490057448_f64;\n+\n+    /// 2.0/sqrt(pi)\n+    pub static FRAC_2_SQRTPI: f64 = 1.12837916709551257389615890312154517_f64;\n+\n+    /// sqrt(2.0)\n+    pub static SQRT2: f64 = 1.41421356237309504880168872420969808_f64;\n+\n+    /// 1.0/sqrt(2.0)\n+    pub static FRAC_1_SQRT2: f64 = 0.707106781186547524400844362104849039_f64;\n+\n+    /// Euler's number\n+    pub static E: f64 = 2.71828182845904523536028747135266250_f64;\n+\n+    /// log2(e)\n+    pub static LOG2_E: f64 = 1.44269504088896340735992468100189214_f64;\n+\n+    /// log10(e)\n+    pub static LOG10_E: f64 = 0.434294481903251827651128918916605082_f64;\n+\n+    /// ln(2.0)\n+    pub static LN_2: f64 = 0.693147180559945309417232121458176568_f64;\n+\n+    /// ln(10.0)\n+    pub static LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n+}\n+\n+#[cfg(not(test))]\n+impl Ord for f64 {\n+    #[inline]\n+    fn lt(&self, other: &f64) -> bool { (*self) < (*other) }\n+    #[inline]\n+    fn le(&self, other: &f64) -> bool { (*self) <= (*other) }\n+    #[inline]\n+    fn ge(&self, other: &f64) -> bool { (*self) >= (*other) }\n+    #[inline]\n+    fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n+}\n+#[cfg(not(test))]\n+impl Eq for f64 {\n+    #[inline]\n+    fn eq(&self, other: &f64) -> bool { (*self) == (*other) }\n+}\n+\n+impl Default for f64 {\n+    #[inline]\n+    fn default() -> f64 { 0.0 }\n+}\n+\n+impl Primitive for f64 {}\n+\n+impl Num for f64 {}\n+\n+impl Zero for f64 {\n+    #[inline]\n+    fn zero() -> f64 { 0.0 }\n+\n+    /// Returns true if the number is equal to either `0.0` or `-0.0`\n+    #[inline]\n+    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n+}\n+\n+impl One for f64 {\n+    #[inline]\n+    fn one() -> f64 { 1.0 }\n+}\n+\n+#[cfg(not(test))]\n+impl Add<f64,f64> for f64 {\n+    #[inline]\n+    fn add(&self, other: &f64) -> f64 { *self + *other }\n+}\n+#[cfg(not(test))]\n+impl Sub<f64,f64> for f64 {\n+    #[inline]\n+    fn sub(&self, other: &f64) -> f64 { *self - *other }\n+}\n+#[cfg(not(test))]\n+impl Mul<f64,f64> for f64 {\n+    #[inline]\n+    fn mul(&self, other: &f64) -> f64 { *self * *other }\n+}\n+#[cfg(not(test))]\n+impl Div<f64,f64> for f64 {\n+    #[inline]\n+    fn div(&self, other: &f64) -> f64 { *self / *other }\n+}\n+#[cfg(not(test))]\n+impl Rem<f64,f64> for f64 {\n+    #[inline]\n+    fn rem(&self, other: &f64) -> f64 {\n+        extern { fn fmod(a: f64, b: f64) -> f64; }\n+        unsafe { fmod(*self, *other) }\n+    }\n+}\n+#[cfg(not(test))]\n+impl Neg<f64> for f64 {\n+    #[inline]\n+    fn neg(&self) -> f64 { -*self }\n+}\n+\n+impl Signed for f64 {\n+    /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n+    #[inline]\n+    fn abs(&self) -> f64 {\n+        unsafe { intrinsics::fabsf64(*self) }\n+    }\n+\n+    /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n+    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n+    #[inline]\n+    fn abs_sub(&self, other: &f64) -> f64 {\n+        extern { fn fdim(a: f64, b: f64) -> f64; }\n+        unsafe { fdim(*self, *other) }\n+    }\n+\n+    /// # Returns\n+    ///\n+    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n+    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n+    /// - `NAN` if the number is NaN\n+    #[inline]\n+    fn signum(&self) -> f64 {\n+        if self != self { NAN } else {\n+            unsafe { intrinsics::copysignf64(1.0, *self) }\n+        }\n+    }\n+\n+    /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n+    #[inline]\n+    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == INFINITY }\n+\n+    /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n+    #[inline]\n+    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == NEG_INFINITY }\n+}\n+\n+impl Bounded for f64 {\n+    // NOTE: this is the smallest non-infinite f32 value, *not* MIN_VALUE\n+    #[inline]\n+    fn min_value() -> f64 { -MAX_VALUE }\n+\n+    #[inline]\n+    fn max_value() -> f64 { MAX_VALUE }\n+}"}, {"sha": "3e403219a4fbaffdc207d8c2015ba88431a4e67f", "filename": "src/libcore/num/float_macros.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat_macros.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![macro_escape]\n+#![doc(hidden)]\n+\n+macro_rules! assert_approx_eq(\n+    ($a:expr, $b:expr) => ({\n+        let (a, b) = (&$a, &$b);\n+        assert!((*a - *b).abs() < 1.0e-6,\n+                \"{} is not approximately equal to {}\", *a, *b);\n+    })\n+)"}, {"sha": "361f75b9e8831d79890c4672d482d76e26f12d51", "filename": "src/libcore/num/i16.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for signed 16-bits integers (`i16` type)\n+\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Signed, Num, Primitive, Int};\n+use num::{CheckedDiv, CheckedAdd, CheckedSub, CheckedMul};\n+use option::{Option, Some, None};\n+\n+#[cfg(not(test))]\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+#[cfg(not(test))]\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitOr, BitAnd, BitXor};\n+#[cfg(not(test))]\n+use ops::{Shl, Shr, Not};\n+\n+int_module!(i16, 16)\n+\n+impl Bitwise for i16 {\n+    /// Returns the number of ones in the binary representation of the number.\n+    #[inline]\n+    fn count_ones(&self) -> i16 { unsafe { intrinsics::ctpop16(*self as u16) as i16 } }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn leading_zeros(&self) -> i16 { unsafe { intrinsics::ctlz16(*self as u16) as i16 } }\n+\n+    /// Returns the number of trailing zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn trailing_zeros(&self) -> i16 { unsafe { intrinsics::cttz16(*self as u16) as i16 } }\n+}\n+\n+impl CheckedAdd for i16 {\n+    #[inline]\n+    fn checked_add(&self, v: &i16) -> Option<i16> {\n+        unsafe {\n+            let (x, y) = intrinsics::i16_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for i16 {\n+    #[inline]\n+    fn checked_sub(&self, v: &i16) -> Option<i16> {\n+        unsafe {\n+            let (x, y) = intrinsics::i16_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for i16 {\n+    #[inline]\n+    fn checked_mul(&self, v: &i16) -> Option<i16> {\n+        unsafe {\n+            let (x, y) = intrinsics::i16_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "9071f150292d29468d06e374bc18d91aa25825ca", "filename": "src/libcore/num/i32.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for signed 32-bits integers (`i32` type)\n+\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Signed, Num, Primitive, Int};\n+use num::{CheckedDiv, CheckedAdd, CheckedSub, CheckedMul};\n+use option::{Option, Some, None};\n+\n+#[cfg(not(test))]\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+#[cfg(not(test))]\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitOr, BitAnd, BitXor};\n+#[cfg(not(test))]\n+use ops::{Shl, Shr, Not};\n+\n+int_module!(i32, 32)\n+\n+impl Bitwise for i32 {\n+    /// Returns the number of ones in the binary representation of the number.\n+    #[inline]\n+    fn count_ones(&self) -> i32 { unsafe { intrinsics::ctpop32(*self as u32) as i32 } }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn leading_zeros(&self) -> i32 { unsafe { intrinsics::ctlz32(*self as u32) as i32 } }\n+\n+    /// Returns the number of trailing zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn trailing_zeros(&self) -> i32 { unsafe { intrinsics::cttz32(*self as u32) as i32 } }\n+}\n+\n+impl CheckedAdd for i32 {\n+    #[inline]\n+    fn checked_add(&self, v: &i32) -> Option<i32> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for i32 {\n+    #[inline]\n+    fn checked_sub(&self, v: &i32) -> Option<i32> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for i32 {\n+    #[inline]\n+    fn checked_mul(&self, v: &i32) -> Option<i32> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "ba7b715f13d6a49e01cef3d06b7af480f0dd6faf", "filename": "src/libcore/num/i64.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for signed 64-bits integers (`i64` type)\n+\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Signed, Num, Primitive, Int};\n+use num::{CheckedDiv, CheckedAdd, CheckedSub, CheckedMul};\n+use option::{Option, Some, None};\n+\n+#[cfg(not(test))]\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+#[cfg(not(test))]\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitOr, BitAnd, BitXor};\n+#[cfg(not(test))]\n+use ops::{Shl, Shr, Not};\n+\n+int_module!(i64, 64)\n+\n+impl Bitwise for i64 {\n+    /// Returns the number of ones in the binary representation of the number.\n+    #[inline]\n+    fn count_ones(&self) -> i64 { unsafe { intrinsics::ctpop64(*self as u64) as i64 } }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn leading_zeros(&self) -> i64 { unsafe { intrinsics::ctlz64(*self as u64) as i64 } }\n+\n+    /// Counts the number of trailing zeros.\n+    #[inline]\n+    fn trailing_zeros(&self) -> i64 { unsafe { intrinsics::cttz64(*self as u64) as i64 } }\n+}\n+\n+impl CheckedAdd for i64 {\n+    #[inline]\n+    fn checked_add(&self, v: &i64) -> Option<i64> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for i64 {\n+    #[inline]\n+    fn checked_sub(&self, v: &i64) -> Option<i64> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for i64 {\n+    #[inline]\n+    fn checked_mul(&self, v: &i64) -> Option<i64> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "6ec05eb50ee614e8c8959010144fcf533d1554ea", "filename": "src/libcore/num/i8.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for signed 8-bits integers (`i8` type)\n+\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Signed, Num, Primitive, Int};\n+use num::{CheckedDiv, CheckedAdd, CheckedSub, CheckedMul};\n+use option::{Option, Some, None};\n+\n+#[cfg(not(test))]\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+#[cfg(not(test))]\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitOr, BitAnd, BitXor};\n+#[cfg(not(test))]\n+use ops::{Shl, Shr, Not};\n+\n+int_module!(i8, 8)\n+\n+impl Bitwise for i8 {\n+    /// Returns the number of ones in the binary representation of the number.\n+    #[inline]\n+    fn count_ones(&self) -> i8 { unsafe { intrinsics::ctpop8(*self as u8) as i8 } }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn leading_zeros(&self) -> i8 { unsafe { intrinsics::ctlz8(*self as u8) as i8 } }\n+\n+    /// Returns the number of trailing zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn trailing_zeros(&self) -> i8 { unsafe { intrinsics::cttz8(*self as u8) as i8 } }\n+}\n+\n+impl CheckedAdd for i8 {\n+    #[inline]\n+    fn checked_add(&self, v: &i8) -> Option<i8> {\n+        unsafe {\n+            let (x, y) = intrinsics::i8_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for i8 {\n+    #[inline]\n+    fn checked_sub(&self, v: &i8) -> Option<i8> {\n+        unsafe {\n+            let (x, y) = intrinsics::i8_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for i8 {\n+    #[inline]\n+    fn checked_mul(&self, v: &i8) -> Option<i8> {\n+        unsafe {\n+            let (x, y) = intrinsics::i8_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "8273fa2b39f2757a63582055da35d2c7a3f30667", "filename": "src/libcore/num/int.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for architecture-sized signed integers (`int` type)\n+\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Signed, Num, Primitive, Int};\n+use num::{CheckedDiv, CheckedAdd, CheckedSub, CheckedMul};\n+use option::{Option, Some, None};\n+\n+#[cfg(not(test))]\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+#[cfg(not(test))]\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitOr, BitAnd, BitXor};\n+#[cfg(not(test))]\n+use ops::{Shl, Shr, Not};\n+\n+#[cfg(target_word_size = \"32\")] int_module!(int, 32)\n+#[cfg(target_word_size = \"64\")] int_module!(int, 64)\n+\n+#[cfg(target_word_size = \"32\")]\n+impl Bitwise for int {\n+    /// Returns the number of ones in the binary representation of the number.\n+    #[inline]\n+    fn count_ones(&self) -> int { (*self as i32).count_ones() as int }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn leading_zeros(&self) -> int { (*self as i32).leading_zeros() as int }\n+\n+    /// Returns the number of trailing zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn trailing_zeros(&self) -> int { (*self as i32).trailing_zeros() as int }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl Bitwise for int {\n+    /// Returns the number of ones in the binary representation of the number.\n+    #[inline]\n+    fn count_ones(&self) -> int { (*self as i64).count_ones() as int }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn leading_zeros(&self) -> int { (*self as i64).leading_zeros() as int }\n+\n+    /// Returns the number of trailing zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn trailing_zeros(&self) -> int { (*self as i64).trailing_zeros() as int }\n+}\n+\n+#[cfg(target_word_size = \"32\")]\n+impl CheckedAdd for int {\n+    #[inline]\n+    fn checked_add(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_add_with_overflow(*self as i32, *v as i32);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl CheckedAdd for int {\n+    #[inline]\n+    fn checked_add(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_add_with_overflow(*self as i64, *v as i64);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"32\")]\n+impl CheckedSub for int {\n+    #[inline]\n+    fn checked_sub(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_sub_with_overflow(*self as i32, *v as i32);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl CheckedSub for int {\n+    #[inline]\n+    fn checked_sub(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_sub_with_overflow(*self as i64, *v as i64);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"32\")]\n+impl CheckedMul for int {\n+    #[inline]\n+    fn checked_mul(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i32_mul_with_overflow(*self as i32, *v as i32);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl CheckedMul for int {\n+    #[inline]\n+    fn checked_mul(&self, v: &int) -> Option<int> {\n+        unsafe {\n+            let (x, y) = intrinsics::i64_mul_with_overflow(*self as i64, *v as i64);\n+            if y { None } else { Some(x as int) }\n+        }\n+    }\n+}"}, {"sha": "7d21764eb70d39908a7b28d3e4b83fa5dabc8c67", "filename": "src/libcore/num/int_macros.rs", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,338 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![macro_escape]\n+#![doc(hidden)]\n+\n+macro_rules! int_module (($T:ty, $bits:expr) => (\n+\n+// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n+// calling the `mem::size_of` function.\n+pub static BITS : uint = $bits;\n+// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n+// calling the `mem::size_of` function.\n+pub static BYTES : uint = ($bits / 8);\n+\n+// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n+// calling the `Bounded::min_value` function.\n+pub static MIN: $T = (-1 as $T) << (BITS - 1);\n+// FIXME(#9837): Compute MIN like this so the high bits that shouldn't exist are 0.\n+// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n+// calling the `Bounded::max_value` function.\n+pub static MAX: $T = !MIN;\n+\n+#[cfg(not(test))]\n+impl Ord for $T {\n+    #[inline]\n+    fn lt(&self, other: &$T) -> bool { *self < *other }\n+}\n+#[cfg(not(test))]\n+impl TotalEq for $T {}\n+#[cfg(not(test))]\n+impl Eq for $T {\n+    #[inline]\n+    fn eq(&self, other: &$T) -> bool { *self == *other }\n+}\n+#[cfg(not(test))]\n+impl TotalOrd for $T {\n+    #[inline]\n+    fn cmp(&self, other: &$T) -> Ordering {\n+        if *self < *other { Less }\n+        else if *self > *other { Greater }\n+        else { Equal }\n+    }\n+}\n+\n+impl Num for $T {}\n+\n+impl Zero for $T {\n+    #[inline]\n+    fn zero() -> $T { 0 }\n+\n+    #[inline]\n+    fn is_zero(&self) -> bool { *self == 0 }\n+}\n+\n+impl One for $T {\n+    #[inline]\n+    fn one() -> $T { 1 }\n+}\n+\n+#[cfg(not(test))]\n+impl Add<$T,$T> for $T {\n+    #[inline]\n+    fn add(&self, other: &$T) -> $T { *self + *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Sub<$T,$T> for $T {\n+    #[inline]\n+    fn sub(&self, other: &$T) -> $T { *self - *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Mul<$T,$T> for $T {\n+    #[inline]\n+    fn mul(&self, other: &$T) -> $T { *self * *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Div<$T,$T> for $T {\n+    /// Integer division, truncated towards 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// assert!( 8 /  3 ==  2);\n+    /// assert!( 8 / -3 == -2);\n+    /// assert!(-8 /  3 == -2);\n+    /// assert!(-8 / -3 ==  2);\n+    ///\n+    /// assert!( 1 /  2 ==  0);\n+    /// assert!( 1 / -2 ==  0);\n+    /// assert!(-1 /  2 ==  0);\n+    /// assert!(-1 / -2 ==  0);\n+    /// ~~~\n+    #[inline]\n+    fn div(&self, other: &$T) -> $T { *self / *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Rem<$T,$T> for $T {\n+    /// Returns the integer remainder after division, satisfying:\n+    ///\n+    /// ~~~\n+    /// # let n = 1;\n+    /// # let d = 2;\n+    /// assert!((n / d) * d + (n % d) == n)\n+    /// ~~~\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~\n+    /// assert!( 8 %  3 ==  2);\n+    /// assert!( 8 % -3 ==  2);\n+    /// assert!(-8 %  3 == -2);\n+    /// assert!(-8 % -3 == -2);\n+    ///\n+    /// assert!( 1 %  2 ==  1);\n+    /// assert!( 1 % -2 ==  1);\n+    /// assert!(-1 %  2 == -1);\n+    /// assert!(-1 % -2 == -1);\n+    /// ~~~\n+    #[inline]\n+    fn rem(&self, other: &$T) -> $T { *self % *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Neg<$T> for $T {\n+    #[inline]\n+    fn neg(&self) -> $T { -*self }\n+}\n+\n+impl Signed for $T {\n+    /// Computes the absolute value\n+    #[inline]\n+    fn abs(&self) -> $T {\n+        if self.is_negative() { -*self } else { *self }\n+    }\n+\n+    ///\n+    /// The positive difference of two numbers. Returns `0` if the number is less than or\n+    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n+    ///\n+    #[inline]\n+    fn abs_sub(&self, other: &$T) -> $T {\n+        if *self <= *other { 0 } else { *self - *other }\n+    }\n+\n+    ///\n+    /// # Returns\n+    ///\n+    /// - `0` if the number is zero\n+    /// - `1` if the number is positive\n+    /// - `-1` if the number is negative\n+    ///\n+    #[inline]\n+    fn signum(&self) -> $T {\n+        match *self {\n+            n if n > 0 =>  1,\n+            0          =>  0,\n+            _          => -1,\n+        }\n+    }\n+\n+    /// Returns true if the number is positive\n+    #[inline]\n+    fn is_positive(&self) -> bool { *self > 0 }\n+\n+    /// Returns true if the number is negative\n+    #[inline]\n+    fn is_negative(&self) -> bool { *self < 0 }\n+}\n+\n+#[cfg(not(test))]\n+impl BitOr<$T,$T> for $T {\n+    #[inline]\n+    fn bitor(&self, other: &$T) -> $T { *self | *other }\n+}\n+\n+#[cfg(not(test))]\n+impl BitAnd<$T,$T> for $T {\n+    #[inline]\n+    fn bitand(&self, other: &$T) -> $T { *self & *other }\n+}\n+\n+#[cfg(not(test))]\n+impl BitXor<$T,$T> for $T {\n+    #[inline]\n+    fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Shl<$T,$T> for $T {\n+    #[inline]\n+    fn shl(&self, other: &$T) -> $T { *self << *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Shr<$T,$T> for $T {\n+    #[inline]\n+    fn shr(&self, other: &$T) -> $T { *self >> *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Not<$T> for $T {\n+    #[inline]\n+    fn not(&self) -> $T { !*self }\n+}\n+\n+impl Bounded for $T {\n+    #[inline]\n+    fn min_value() -> $T { MIN }\n+\n+    #[inline]\n+    fn max_value() -> $T { MAX }\n+}\n+\n+impl CheckedDiv for $T {\n+    #[inline]\n+    fn checked_div(&self, v: &$T) -> Option<$T> {\n+        if *v == 0 || (*self == MIN && *v == -1) {\n+            None\n+        } else {\n+            Some(self / *v)\n+        }\n+    }\n+}\n+\n+impl Default for $T {\n+    #[inline]\n+    fn default() -> $T { 0 }\n+}\n+\n+impl Int for $T {}\n+\n+impl Primitive for $T {}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+    use super::*;\n+\n+    use int;\n+    use num;\n+    use num::Bitwise;\n+    use num::CheckedDiv;\n+\n+    #[test]\n+    fn test_overflows() {\n+        assert!(MAX > 0);\n+        assert!(MIN <= 0);\n+        assert!(MIN + MAX + 1 == 0);\n+    }\n+\n+    #[test]\n+    fn test_num() {\n+        num::test_num(10 as $T, 2 as $T);\n+    }\n+\n+    #[test]\n+    pub fn test_abs() {\n+        assert!((1 as $T).abs() == 1 as $T);\n+        assert!((0 as $T).abs() == 0 as $T);\n+        assert!((-1 as $T).abs() == 1 as $T);\n+    }\n+\n+    #[test]\n+    fn test_abs_sub() {\n+        assert!((-1 as $T).abs_sub(&(1 as $T)) == 0 as $T);\n+        assert!((1 as $T).abs_sub(&(1 as $T)) == 0 as $T);\n+        assert!((1 as $T).abs_sub(&(0 as $T)) == 1 as $T);\n+        assert!((1 as $T).abs_sub(&(-1 as $T)) == 2 as $T);\n+    }\n+\n+    #[test]\n+    fn test_signum() {\n+        assert!((1 as $T).signum() == 1 as $T);\n+        assert!((0 as $T).signum() == 0 as $T);\n+        assert!((-0 as $T).signum() == 0 as $T);\n+        assert!((-1 as $T).signum() == -1 as $T);\n+    }\n+\n+    #[test]\n+    fn test_is_positive() {\n+        assert!((1 as $T).is_positive());\n+        assert!(!(0 as $T).is_positive());\n+        assert!(!(-0 as $T).is_positive());\n+        assert!(!(-1 as $T).is_positive());\n+    }\n+\n+    #[test]\n+    fn test_is_negative() {\n+        assert!(!(1 as $T).is_negative());\n+        assert!(!(0 as $T).is_negative());\n+        assert!(!(-0 as $T).is_negative());\n+        assert!((-1 as $T).is_negative());\n+    }\n+\n+    #[test]\n+    fn test_bitwise() {\n+        assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n+        assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n+        assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n+        assert!(0b1110 as $T == (0b0111 as $T).shl(&(1 as $T)));\n+        assert!(0b0111 as $T == (0b1110 as $T).shr(&(1 as $T)));\n+        assert!(-(0b11 as $T) - (1 as $T) == (0b11 as $T).not());\n+    }\n+\n+    #[test]\n+    fn test_count_ones() {\n+        assert!((0b0101100 as $T).count_ones() == 3);\n+        assert!((0b0100001 as $T).count_ones() == 2);\n+        assert!((0b1111001 as $T).count_ones() == 5);\n+    }\n+\n+    #[test]\n+    fn test_count_zeros() {\n+        assert!((0b0101100 as $T).count_zeros() == BITS as $T - 3);\n+        assert!((0b0100001 as $T).count_zeros() == BITS as $T - 2);\n+        assert!((0b1111001 as $T).count_zeros() == BITS as $T - 5);\n+    }\n+\n+    #[test]\n+    fn test_signed_checked_div() {\n+        assert!(10i.checked_div(&2) == Some(5));\n+        assert!(5i.checked_div(&0) == None);\n+        assert!(int::MIN.checked_div(&-1) == None);\n+    }\n+}\n+\n+))"}, {"sha": "22411fef3b26801884c5a5d94ae81274c08c9dac", "filename": "src/libcore/num/mod.rs", "status": "added", "additions": 876, "deletions": 0, "changes": 876, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,876 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Numeric traits and functions for generic mathematics\n+//!\n+//! These are implemented for the primitive numeric types in `std::{u8, u16,\n+//! u32, u64, uint, i8, i16, i32, i64, int, f32, f64, float}`.\n+\n+#![allow(missing_doc)]\n+\n+use clone::Clone;\n+use cmp::{Eq, Ord};\n+use kinds::Copy;\n+use mem::size_of;\n+use ops::{Add, Sub, Mul, Div, Rem, Neg};\n+use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n+use option::{Option, Some, None};\n+\n+/// The base trait for numeric types\n+pub trait Num: Eq + Zero + One\n+             + Neg<Self>\n+             + Add<Self,Self>\n+             + Sub<Self,Self>\n+             + Mul<Self,Self>\n+             + Div<Self,Self>\n+             + Rem<Self,Self> {}\n+\n+/// Simultaneous division and remainder\n+#[inline]\n+pub fn div_rem<T: Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) {\n+    (x / y, x % y)\n+}\n+\n+/// Defines an additive identity element for `Self`.\n+///\n+/// # Deriving\n+///\n+/// This trait can be automatically be derived using `#[deriving(Zero)]`\n+/// attribute. If you choose to use this, make sure that the laws outlined in\n+/// the documentation for `Zero::zero` still hold.\n+pub trait Zero: Add<Self, Self> {\n+    /// Returns the additive identity element of `Self`, `0`.\n+    ///\n+    /// # Laws\n+    ///\n+    /// ~~~notrust\n+    /// a + 0 = a       \u2200 a \u2208 Self\n+    /// 0 + a = a       \u2200 a \u2208 Self\n+    /// ~~~\n+    ///\n+    /// # Purity\n+    ///\n+    /// This function should return the same result at all times regardless of\n+    /// external mutable state, for example values stored in TLS or in\n+    /// `static mut`s.\n+    // FIXME (#5527): This should be an associated constant\n+    fn zero() -> Self;\n+\n+    /// Returns `true` if `self` is equal to the additive identity.\n+    fn is_zero(&self) -> bool;\n+}\n+\n+/// Returns the additive identity, `0`.\n+#[inline(always)] pub fn zero<T: Zero>() -> T { Zero::zero() }\n+\n+/// Defines a multiplicative identity element for `Self`.\n+pub trait One: Mul<Self, Self> {\n+    /// Returns the multiplicative identity element of `Self`, `1`.\n+    ///\n+    /// # Laws\n+    ///\n+    /// ~~~notrust\n+    /// a * 1 = a       \u2200 a \u2208 Self\n+    /// 1 * a = a       \u2200 a \u2208 Self\n+    /// ~~~\n+    ///\n+    /// # Purity\n+    ///\n+    /// This function should return the same result at all times regardless of\n+    /// external mutable state, for example values stored in TLS or in\n+    /// `static mut`s.\n+    // FIXME (#5527): This should be an associated constant\n+    fn one() -> Self;\n+}\n+\n+/// Returns the multiplicative identity, `1`.\n+#[inline(always)] pub fn one<T: One>() -> T { One::one() }\n+\n+/// Useful functions for signed numbers (i.e. numbers that can be negative).\n+pub trait Signed: Num + Neg<Self> {\n+    /// Computes the absolute value.\n+    ///\n+    /// For float, f32, and f64, `NaN` will be returned if the number is `NaN`.\n+    fn abs(&self) -> Self;\n+\n+    /// The positive difference of two numbers.\n+    ///\n+    /// Returns `zero` if the number is less than or equal to `other`, otherwise the difference\n+    /// between `self` and `other` is returned.\n+    fn abs_sub(&self, other: &Self) -> Self;\n+\n+    /// Returns the sign of the number.\n+    ///\n+    /// For `float`, `f32`, `f64`:\n+    ///   * `1.0` if the number is positive, `+0.0` or `INFINITY`\n+    ///   * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n+    ///   * `NaN` if the number is `NaN`\n+    ///\n+    /// For `int`:\n+    ///   * `0` if the number is zero\n+    ///   * `1` if the number is positive\n+    ///   * `-1` if the number is negative\n+    fn signum(&self) -> Self;\n+\n+    /// Returns true if the number is positive and false if the number is zero or negative.\n+    fn is_positive(&self) -> bool;\n+\n+    /// Returns true if the number is negative and false if the number is zero or positive.\n+    fn is_negative(&self) -> bool;\n+}\n+\n+/// Computes the absolute value.\n+///\n+/// For float, f32, and f64, `NaN` will be returned if the number is `NaN`\n+#[inline(always)]\n+pub fn abs<T: Signed>(value: T) -> T {\n+    value.abs()\n+}\n+\n+/// The positive difference of two numbers.\n+///\n+/// Returns `zero` if the number is less than or equal to `other`,\n+/// otherwise the difference between `self` and `other` is returned.\n+#[inline(always)]\n+pub fn abs_sub<T: Signed>(x: T, y: T) -> T {\n+    x.abs_sub(&y)\n+}\n+\n+/// Returns the sign of the number.\n+///\n+/// For float, f32, f64:\n+/// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n+/// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n+/// - `NAN` if the number is `NAN`\n+///\n+/// For int:\n+/// - `0` if the number is zero\n+/// - `1` if the number is positive\n+/// - `-1` if the number is negative\n+#[inline(always)] pub fn signum<T: Signed>(value: T) -> T { value.signum() }\n+\n+/// A trait for values which cannot be negative\n+pub trait Unsigned: Num {}\n+\n+/// Raises a value to the power of exp, using exponentiation by squaring.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::num;\n+///\n+/// assert_eq!(num::pow(2, 4), 16);\n+/// ```\n+#[inline]\n+pub fn pow<T: One + Mul<T, T>>(mut base: T, mut exp: uint) -> T {\n+    if exp == 1 { base }\n+    else {\n+        let mut acc = one::<T>();\n+        while exp > 0 {\n+            if (exp & 1) == 1 {\n+                acc = acc * base;\n+            }\n+            base = base * base;\n+            exp = exp >> 1;\n+        }\n+        acc\n+    }\n+}\n+\n+/// Numbers which have upper and lower bounds\n+pub trait Bounded {\n+    // FIXME (#5527): These should be associated constants\n+    /// returns the smallest finite number this type can represent\n+    fn min_value() -> Self;\n+    /// returns the largest finite number this type can represent\n+    fn max_value() -> Self;\n+}\n+\n+/// Numbers with a fixed binary representation.\n+pub trait Bitwise: Bounded\n+                 + Not<Self>\n+                 + BitAnd<Self,Self>\n+                 + BitOr<Self,Self>\n+                 + BitXor<Self,Self>\n+                 + Shl<Self,Self>\n+                 + Shr<Self,Self> {\n+    /// Returns the number of ones in the binary representation of the number.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Bitwise;\n+    ///\n+    /// let n = 0b01001100u8;\n+    /// assert_eq!(n.count_ones(), 3);\n+    /// ```\n+    fn count_ones(&self) -> Self;\n+\n+    /// Returns the number of zeros in the binary representation of the number.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Bitwise;\n+    ///\n+    /// let n = 0b01001100u8;\n+    /// assert_eq!(n.count_zeros(), 5);\n+    /// ```\n+    #[inline]\n+    fn count_zeros(&self) -> Self {\n+        (!*self).count_ones()\n+    }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Bitwise;\n+    ///\n+    /// let n = 0b0101000u16;\n+    /// assert_eq!(n.leading_zeros(), 10);\n+    /// ```\n+    fn leading_zeros(&self) -> Self;\n+\n+    /// Returns the number of trailing zeros in the in the binary representation\n+    /// of the number.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Bitwise;\n+    ///\n+    /// let n = 0b0101000u16;\n+    /// assert_eq!(n.trailing_zeros(), 3);\n+    /// ```\n+    fn trailing_zeros(&self) -> Self;\n+}\n+\n+/// Specifies the available operations common to all of Rust's core numeric primitives.\n+/// These may not always make sense from a purely mathematical point of view, but\n+/// may be useful for systems programming.\n+pub trait Primitive: Copy\n+                   + Clone\n+                   + Num\n+                   + NumCast\n+                   + Ord\n+                   + Bounded {}\n+\n+/// A collection of traits relevant to primitive signed and unsigned integers\n+pub trait Int: Primitive\n+             + Bitwise\n+             + CheckedAdd\n+             + CheckedSub\n+             + CheckedMul\n+             + CheckedDiv {}\n+\n+/// Returns the smallest power of 2 greater than or equal to `n`.\n+#[inline]\n+pub fn next_power_of_two<T: Unsigned + Int>(n: T) -> T {\n+    let halfbits: T = cast(size_of::<T>() * 4).unwrap();\n+    let mut tmp: T = n - one();\n+    let mut shift: T = one();\n+    while shift <= halfbits {\n+        tmp = tmp | (tmp >> shift);\n+        shift = shift << one();\n+    }\n+    tmp + one()\n+}\n+\n+// Returns `true` iff `n == 2^k` for some k.\n+#[inline]\n+pub fn is_power_of_two<T: Unsigned + Int>(n: T) -> bool {\n+    (n - one()) & n == zero()\n+}\n+\n+/// Returns the smallest power of 2 greater than or equal to `n`. If the next\n+/// power of two is greater than the type's maximum value, `None` is returned,\n+/// otherwise the power of 2 is wrapped in `Some`.\n+#[inline]\n+pub fn checked_next_power_of_two<T: Unsigned + Int>(n: T) -> Option<T> {\n+    let halfbits: T = cast(size_of::<T>() * 4).unwrap();\n+    let mut tmp: T = n - one();\n+    let mut shift: T = one();\n+    while shift <= halfbits {\n+        tmp = tmp | (tmp >> shift);\n+        shift = shift << one();\n+    }\n+    tmp.checked_add(&one())\n+}\n+\n+/// A generic trait for converting a value to a number.\n+pub trait ToPrimitive {\n+    /// Converts the value of `self` to an `int`.\n+    #[inline]\n+    fn to_int(&self) -> Option<int> {\n+        self.to_i64().and_then(|x| x.to_int())\n+    }\n+\n+    /// Converts the value of `self` to an `i8`.\n+    #[inline]\n+    fn to_i8(&self) -> Option<i8> {\n+        self.to_i64().and_then(|x| x.to_i8())\n+    }\n+\n+    /// Converts the value of `self` to an `i16`.\n+    #[inline]\n+    fn to_i16(&self) -> Option<i16> {\n+        self.to_i64().and_then(|x| x.to_i16())\n+    }\n+\n+    /// Converts the value of `self` to an `i32`.\n+    #[inline]\n+    fn to_i32(&self) -> Option<i32> {\n+        self.to_i64().and_then(|x| x.to_i32())\n+    }\n+\n+    /// Converts the value of `self` to an `i64`.\n+    fn to_i64(&self) -> Option<i64>;\n+\n+    /// Converts the value of `self` to an `uint`.\n+    #[inline]\n+    fn to_uint(&self) -> Option<uint> {\n+        self.to_u64().and_then(|x| x.to_uint())\n+    }\n+\n+    /// Converts the value of `self` to an `u8`.\n+    #[inline]\n+    fn to_u8(&self) -> Option<u8> {\n+        self.to_u64().and_then(|x| x.to_u8())\n+    }\n+\n+    /// Converts the value of `self` to an `u16`.\n+    #[inline]\n+    fn to_u16(&self) -> Option<u16> {\n+        self.to_u64().and_then(|x| x.to_u16())\n+    }\n+\n+    /// Converts the value of `self` to an `u32`.\n+    #[inline]\n+    fn to_u32(&self) -> Option<u32> {\n+        self.to_u64().and_then(|x| x.to_u32())\n+    }\n+\n+    /// Converts the value of `self` to an `u64`.\n+    #[inline]\n+    fn to_u64(&self) -> Option<u64>;\n+\n+    /// Converts the value of `self` to an `f32`.\n+    #[inline]\n+    fn to_f32(&self) -> Option<f32> {\n+        self.to_f64().and_then(|x| x.to_f32())\n+    }\n+\n+    /// Converts the value of `self` to an `f64`.\n+    #[inline]\n+    fn to_f64(&self) -> Option<f64> {\n+        self.to_i64().and_then(|x| x.to_f64())\n+    }\n+}\n+\n+macro_rules! impl_to_primitive_int_to_int(\n+    ($SrcT:ty, $DstT:ty) => (\n+        {\n+            if size_of::<$SrcT>() <= size_of::<$DstT>() {\n+                Some(*self as $DstT)\n+            } else {\n+                let n = *self as i64;\n+                let min_value: $DstT = Bounded::min_value();\n+                let max_value: $DstT = Bounded::max_value();\n+                if min_value as i64 <= n && n <= max_value as i64 {\n+                    Some(*self as $DstT)\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    )\n+)\n+\n+macro_rules! impl_to_primitive_int_to_uint(\n+    ($SrcT:ty, $DstT:ty) => (\n+        {\n+            let zero: $SrcT = Zero::zero();\n+            let max_value: $DstT = Bounded::max_value();\n+            if zero <= *self && *self as u64 <= max_value as u64 {\n+                Some(*self as $DstT)\n+            } else {\n+                None\n+            }\n+        }\n+    )\n+)\n+\n+macro_rules! impl_to_primitive_int(\n+    ($T:ty) => (\n+        impl ToPrimitive for $T {\n+            #[inline]\n+            fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!($T, int) }\n+            #[inline]\n+            fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!($T, i8) }\n+            #[inline]\n+            fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!($T, i16) }\n+            #[inline]\n+            fn to_i32(&self) -> Option<i32> { impl_to_primitive_int_to_int!($T, i32) }\n+            #[inline]\n+            fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!($T, i64) }\n+\n+            #[inline]\n+            fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!($T, uint) }\n+            #[inline]\n+            fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!($T, u8) }\n+            #[inline]\n+            fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!($T, u16) }\n+            #[inline]\n+            fn to_u32(&self) -> Option<u32> { impl_to_primitive_int_to_uint!($T, u32) }\n+            #[inline]\n+            fn to_u64(&self) -> Option<u64> { impl_to_primitive_int_to_uint!($T, u64) }\n+\n+            #[inline]\n+            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n+            #[inline]\n+            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n+        }\n+    )\n+)\n+\n+impl_to_primitive_int!(int)\n+impl_to_primitive_int!(i8)\n+impl_to_primitive_int!(i16)\n+impl_to_primitive_int!(i32)\n+impl_to_primitive_int!(i64)\n+\n+macro_rules! impl_to_primitive_uint_to_int(\n+    ($DstT:ty) => (\n+        {\n+            let max_value: $DstT = Bounded::max_value();\n+            if *self as u64 <= max_value as u64 {\n+                Some(*self as $DstT)\n+            } else {\n+                None\n+            }\n+        }\n+    )\n+)\n+\n+macro_rules! impl_to_primitive_uint_to_uint(\n+    ($SrcT:ty, $DstT:ty) => (\n+        {\n+            if size_of::<$SrcT>() <= size_of::<$DstT>() {\n+                Some(*self as $DstT)\n+            } else {\n+                let zero: $SrcT = Zero::zero();\n+                let max_value: $DstT = Bounded::max_value();\n+                if zero <= *self && *self as u64 <= max_value as u64 {\n+                    Some(*self as $DstT)\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    )\n+)\n+\n+macro_rules! impl_to_primitive_uint(\n+    ($T:ty) => (\n+        impl ToPrimitive for $T {\n+            #[inline]\n+            fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int) }\n+            #[inline]\n+            fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8) }\n+            #[inline]\n+            fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16) }\n+            #[inline]\n+            fn to_i32(&self) -> Option<i32> { impl_to_primitive_uint_to_int!(i32) }\n+            #[inline]\n+            fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64) }\n+\n+            #[inline]\n+            fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, uint) }\n+            #[inline]\n+            fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8) }\n+            #[inline]\n+            fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!($T, u16) }\n+            #[inline]\n+            fn to_u32(&self) -> Option<u32> { impl_to_primitive_uint_to_uint!($T, u32) }\n+            #[inline]\n+            fn to_u64(&self) -> Option<u64> { impl_to_primitive_uint_to_uint!($T, u64) }\n+\n+            #[inline]\n+            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n+            #[inline]\n+            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n+        }\n+    )\n+)\n+\n+impl_to_primitive_uint!(uint)\n+impl_to_primitive_uint!(u8)\n+impl_to_primitive_uint!(u16)\n+impl_to_primitive_uint!(u32)\n+impl_to_primitive_uint!(u64)\n+\n+macro_rules! impl_to_primitive_float_to_float(\n+    ($SrcT:ty, $DstT:ty) => (\n+        if size_of::<$SrcT>() <= size_of::<$DstT>() {\n+            Some(*self as $DstT)\n+        } else {\n+            let n = *self as f64;\n+            let max_value: $SrcT = Bounded::max_value();\n+            if -max_value as f64 <= n && n <= max_value as f64 {\n+                Some(*self as $DstT)\n+            } else {\n+                None\n+            }\n+        }\n+    )\n+)\n+\n+macro_rules! impl_to_primitive_float(\n+    ($T:ty) => (\n+        impl ToPrimitive for $T {\n+            #[inline]\n+            fn to_int(&self) -> Option<int> { Some(*self as int) }\n+            #[inline]\n+            fn to_i8(&self) -> Option<i8> { Some(*self as i8) }\n+            #[inline]\n+            fn to_i16(&self) -> Option<i16> { Some(*self as i16) }\n+            #[inline]\n+            fn to_i32(&self) -> Option<i32> { Some(*self as i32) }\n+            #[inline]\n+            fn to_i64(&self) -> Option<i64> { Some(*self as i64) }\n+\n+            #[inline]\n+            fn to_uint(&self) -> Option<uint> { Some(*self as uint) }\n+            #[inline]\n+            fn to_u8(&self) -> Option<u8> { Some(*self as u8) }\n+            #[inline]\n+            fn to_u16(&self) -> Option<u16> { Some(*self as u16) }\n+            #[inline]\n+            fn to_u32(&self) -> Option<u32> { Some(*self as u32) }\n+            #[inline]\n+            fn to_u64(&self) -> Option<u64> { Some(*self as u64) }\n+\n+            #[inline]\n+            fn to_f32(&self) -> Option<f32> { impl_to_primitive_float_to_float!($T, f32) }\n+            #[inline]\n+            fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!($T, f64) }\n+        }\n+    )\n+)\n+\n+impl_to_primitive_float!(f32)\n+impl_to_primitive_float!(f64)\n+\n+/// A generic trait for converting a number to a value.\n+pub trait FromPrimitive {\n+    /// Convert an `int` to return an optional value of this type. If the\n+    /// value cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_int(n: int) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+\n+    /// Convert an `i8` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_i8(n: i8) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+\n+    /// Convert an `i16` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_i16(n: i16) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+\n+    /// Convert an `i32` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_i32(n: i32) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+\n+    /// Convert an `i64` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    fn from_i64(n: i64) -> Option<Self>;\n+\n+    /// Convert an `uint` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_uint(n: uint) -> Option<Self> {\n+        FromPrimitive::from_u64(n as u64)\n+    }\n+\n+    /// Convert an `u8` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_u8(n: u8) -> Option<Self> {\n+        FromPrimitive::from_u64(n as u64)\n+    }\n+\n+    /// Convert an `u16` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_u16(n: u16) -> Option<Self> {\n+        FromPrimitive::from_u64(n as u64)\n+    }\n+\n+    /// Convert an `u32` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_u32(n: u32) -> Option<Self> {\n+        FromPrimitive::from_u64(n as u64)\n+    }\n+\n+    /// Convert an `u64` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    fn from_u64(n: u64) -> Option<Self>;\n+\n+    /// Convert a `f32` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_f32(n: f32) -> Option<Self> {\n+        FromPrimitive::from_f64(n as f64)\n+    }\n+\n+    /// Convert a `f64` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_f64(n: f64) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_int`.\n+pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> {\n+    FromPrimitive::from_int(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i8`.\n+pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> {\n+    FromPrimitive::from_i8(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i16`.\n+pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> {\n+    FromPrimitive::from_i16(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i32`.\n+pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> {\n+    FromPrimitive::from_i32(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i64`.\n+pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n+    FromPrimitive::from_i64(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_uint`.\n+pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> {\n+    FromPrimitive::from_uint(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u8`.\n+pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> {\n+    FromPrimitive::from_u8(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u16`.\n+pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> {\n+    FromPrimitive::from_u16(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u32`.\n+pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> {\n+    FromPrimitive::from_u32(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u64`.\n+pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> {\n+    FromPrimitive::from_u64(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_f32`.\n+pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> {\n+    FromPrimitive::from_f32(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_f64`.\n+pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n+    FromPrimitive::from_f64(n)\n+}\n+\n+macro_rules! impl_from_primitive(\n+    ($T:ty, $to_ty:expr) => (\n+        impl FromPrimitive for $T {\n+            #[inline] fn from_int(n: int) -> Option<$T> { $to_ty }\n+            #[inline] fn from_i8(n: i8) -> Option<$T> { $to_ty }\n+            #[inline] fn from_i16(n: i16) -> Option<$T> { $to_ty }\n+            #[inline] fn from_i32(n: i32) -> Option<$T> { $to_ty }\n+            #[inline] fn from_i64(n: i64) -> Option<$T> { $to_ty }\n+\n+            #[inline] fn from_uint(n: uint) -> Option<$T> { $to_ty }\n+            #[inline] fn from_u8(n: u8) -> Option<$T> { $to_ty }\n+            #[inline] fn from_u16(n: u16) -> Option<$T> { $to_ty }\n+            #[inline] fn from_u32(n: u32) -> Option<$T> { $to_ty }\n+            #[inline] fn from_u64(n: u64) -> Option<$T> { $to_ty }\n+\n+            #[inline] fn from_f32(n: f32) -> Option<$T> { $to_ty }\n+            #[inline] fn from_f64(n: f64) -> Option<$T> { $to_ty }\n+        }\n+    )\n+)\n+\n+impl_from_primitive!(int, n.to_int())\n+impl_from_primitive!(i8, n.to_i8())\n+impl_from_primitive!(i16, n.to_i16())\n+impl_from_primitive!(i32, n.to_i32())\n+impl_from_primitive!(i64, n.to_i64())\n+impl_from_primitive!(uint, n.to_uint())\n+impl_from_primitive!(u8, n.to_u8())\n+impl_from_primitive!(u16, n.to_u16())\n+impl_from_primitive!(u32, n.to_u32())\n+impl_from_primitive!(u64, n.to_u64())\n+impl_from_primitive!(f32, n.to_f32())\n+impl_from_primitive!(f64, n.to_f64())\n+\n+/// Cast from one machine scalar to another.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::num;\n+///\n+/// let twenty: f32 = num::cast(0x14).unwrap();\n+/// assert_eq!(twenty, 20f32);\n+/// ```\n+///\n+#[inline]\n+pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> {\n+    NumCast::from(n)\n+}\n+\n+/// An interface for casting between machine scalars.\n+pub trait NumCast: ToPrimitive {\n+    /// Creates a number from another value that can be converted into a primitive via the\n+    /// `ToPrimitive` trait.\n+    fn from<T: ToPrimitive>(n: T) -> Option<Self>;\n+}\n+\n+macro_rules! impl_num_cast(\n+    ($T:ty, $conv:ident) => (\n+        impl NumCast for $T {\n+            #[inline]\n+            fn from<N: ToPrimitive>(n: N) -> Option<$T> {\n+                // `$conv` could be generated using `concat_idents!`, but that\n+                // macro seems to be broken at the moment\n+                n.$conv()\n+            }\n+        }\n+    )\n+)\n+\n+impl_num_cast!(u8,    to_u8)\n+impl_num_cast!(u16,   to_u16)\n+impl_num_cast!(u32,   to_u32)\n+impl_num_cast!(u64,   to_u64)\n+impl_num_cast!(uint,  to_uint)\n+impl_num_cast!(i8,    to_i8)\n+impl_num_cast!(i16,   to_i16)\n+impl_num_cast!(i32,   to_i32)\n+impl_num_cast!(i64,   to_i64)\n+impl_num_cast!(int,   to_int)\n+impl_num_cast!(f32,   to_f32)\n+impl_num_cast!(f64,   to_f64)\n+\n+/// Saturating math operations\n+pub trait Saturating {\n+    /// Saturating addition operator.\n+    /// Returns a+b, saturating at the numeric bounds instead of overflowing.\n+    fn saturating_add(self, v: Self) -> Self;\n+\n+    /// Saturating subtraction operator.\n+    /// Returns a-b, saturating at the numeric bounds instead of overflowing.\n+    fn saturating_sub(self, v: Self) -> Self;\n+}\n+\n+impl<T: CheckedAdd + CheckedSub + Zero + Ord + Bounded> Saturating for T {\n+    #[inline]\n+    fn saturating_add(self, v: T) -> T {\n+        match self.checked_add(&v) {\n+            Some(x) => x,\n+            None => if v >= Zero::zero() {\n+                Bounded::max_value()\n+            } else {\n+                Bounded::min_value()\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn saturating_sub(self, v: T) -> T {\n+        match self.checked_sub(&v) {\n+            Some(x) => x,\n+            None => if v >= Zero::zero() {\n+                Bounded::min_value()\n+            } else {\n+                Bounded::max_value()\n+            }\n+        }\n+    }\n+}\n+\n+/// Performs addition that returns `None` instead of wrapping around on overflow.\n+pub trait CheckedAdd: Add<Self, Self> {\n+    /// Adds two numbers, checking for overflow. If overflow happens, `None` is returned.\n+    fn checked_add(&self, v: &Self) -> Option<Self>;\n+}\n+\n+/// Performs subtraction that returns `None` instead of wrapping around on underflow.\n+pub trait CheckedSub: Sub<Self, Self> {\n+    /// Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.\n+    fn checked_sub(&self, v: &Self) -> Option<Self>;\n+}\n+\n+/// Performs multiplication that returns `None` instead of wrapping around on underflow or\n+/// overflow.\n+pub trait CheckedMul: Mul<Self, Self> {\n+    /// Multiplies two numbers, checking for underflow or overflow. If underflow or overflow\n+    /// happens, `None` is returned.\n+    fn checked_mul(&self, v: &Self) -> Option<Self>;\n+}\n+\n+/// Performs division that returns `None` instead of wrapping around on underflow or overflow.\n+pub trait CheckedDiv: Div<Self, Self> {\n+    /// Divides two numbers, checking for underflow or overflow. If underflow or overflow happens,\n+    /// `None` is returned.\n+    fn checked_div(&self, v: &Self) -> Option<Self>;\n+}\n+\n+/// Helper function for testing numeric operations\n+#[cfg(test)]\n+pub fn test_num<T:Num + NumCast + ::std::fmt::Show>(ten: T, two: T) {\n+    assert_eq!(ten.add(&two),  cast(12).unwrap());\n+    assert_eq!(ten.sub(&two),  cast(8).unwrap());\n+    assert_eq!(ten.mul(&two),  cast(20).unwrap());\n+    assert_eq!(ten.div(&two),  cast(5).unwrap());\n+    assert_eq!(ten.rem(&two),  cast(0).unwrap());\n+\n+    assert_eq!(ten.add(&two),  ten + two);\n+    assert_eq!(ten.sub(&two),  ten - two);\n+    assert_eq!(ten.mul(&two),  ten * two);\n+    assert_eq!(ten.div(&two),  ten / two);\n+    assert_eq!(ten.rem(&two),  ten % two);\n+}"}, {"sha": "96db898e3b0692836e82d1bdb76988c8621978c8", "filename": "src/libcore/num/u16.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for unsigned 16-bits integers (`u16` type)\n+\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Unsigned, Num, Int, Primitive};\n+use num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n+use option::{Some, None, Option};\n+\n+#[cfg(not(test))]\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+#[cfg(not(test))]\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitAnd, BitOr, BitXor};\n+#[cfg(not(test))]\n+use ops::{Shl, Shr, Not};\n+\n+uint_module!(u16, i16, 16)\n+\n+impl CheckedAdd for u16 {\n+    #[inline]\n+    fn checked_add(&self, v: &u16) -> Option<u16> {\n+        unsafe {\n+            let (x, y) = intrinsics::u16_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for u16 {\n+    #[inline]\n+    fn checked_sub(&self, v: &u16) -> Option<u16> {\n+        unsafe {\n+            let (x, y) = intrinsics::u16_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for u16 {\n+    #[inline]\n+    fn checked_mul(&self, v: &u16) -> Option<u16> {\n+        unsafe {\n+            let (x, y) = intrinsics::u16_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "2748b001bb8ed28b6e54ce4d5b2ad7f8c8621d29", "filename": "src/libcore/num/u32.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for unsigned 32-bits integers (`u32` type)\n+\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Unsigned, Num, Int, Primitive};\n+use num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n+use option::{Some, None, Option};\n+\n+#[cfg(not(test))]\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+#[cfg(not(test))]\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitAnd, BitOr, BitXor};\n+#[cfg(not(test))]\n+use ops::{Shl, Shr, Not};\n+\n+uint_module!(u32, i32, 32)\n+\n+impl CheckedAdd for u32 {\n+    #[inline]\n+    fn checked_add(&self, v: &u32) -> Option<u32> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for u32 {\n+    #[inline]\n+    fn checked_sub(&self, v: &u32) -> Option<u32> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for u32 {\n+    #[inline]\n+    fn checked_mul(&self, v: &u32) -> Option<u32> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "c047df095327f88c434297ff54d85f2f84eb5b58", "filename": "src/libcore/num/u64.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for unsigned 64-bits integer (`u64` type)\n+\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Unsigned, Num, Int, Primitive};\n+use num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n+use option::{Some, None, Option};\n+\n+#[cfg(not(test))]\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+#[cfg(not(test))]\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitAnd, BitOr, BitXor};\n+#[cfg(not(test))]\n+use ops::{Shl, Shr, Not};\n+\n+uint_module!(u64, i64, 64)\n+\n+impl CheckedAdd for u64 {\n+    #[inline]\n+    fn checked_add(&self, v: &u64) -> Option<u64> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for u64 {\n+    #[inline]\n+    fn checked_sub(&self, v: &u64) -> Option<u64> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for u64 {\n+    #[inline]\n+    fn checked_mul(&self, v: &u64) -> Option<u64> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "a6df17956a143416b7532fd405052c304c4ab45e", "filename": "src/libcore/num/u8.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for unsigned 8-bits integers (`u8` type)\n+\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Unsigned, Num, Int, Primitive};\n+use num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n+use option::{Some, None, Option};\n+\n+#[cfg(not(test))]\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+#[cfg(not(test))]\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitAnd, BitOr, BitXor};\n+#[cfg(not(test))]\n+use ops::{Shl, Shr, Not};\n+\n+uint_module!(u8, i8, 8)\n+\n+impl CheckedAdd for u8 {\n+    #[inline]\n+    fn checked_add(&self, v: &u8) -> Option<u8> {\n+        unsafe {\n+            let (x, y) = intrinsics::u8_add_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedSub for u8 {\n+    #[inline]\n+    fn checked_sub(&self, v: &u8) -> Option<u8> {\n+        unsafe {\n+            let (x, y) = intrinsics::u8_sub_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}\n+\n+impl CheckedMul for u8 {\n+    #[inline]\n+    fn checked_mul(&self, v: &u8) -> Option<u8> {\n+        unsafe {\n+            let (x, y) = intrinsics::u8_mul_with_overflow(*self, *v);\n+            if y { None } else { Some(x) }\n+        }\n+    }\n+}"}, {"sha": "f988650cc01d496ecdee651dc6aeadf34ab4a906", "filename": "src/libcore/num/uint.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for architecture-sized unsigned integers (`uint` type)\n+\n+use default::Default;\n+use intrinsics;\n+use num::{Bitwise, Bounded, Zero, One, Unsigned, Num, Int, Primitive};\n+use num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n+use option::{Some, None, Option};\n+\n+#[cfg(not(test))]\n+use cmp::{Eq, Ord, TotalEq, TotalOrd, Less, Greater, Equal, Ordering};\n+#[cfg(not(test))]\n+use ops::{Add, Sub, Mul, Div, Rem, Neg, BitAnd, BitOr, BitXor};\n+#[cfg(not(test))]\n+use ops::{Shl, Shr, Not};\n+\n+uint_module!(uint, int, ::int::BITS)\n+\n+#[cfg(target_word_size = \"32\")]\n+impl CheckedAdd for uint {\n+    #[inline]\n+    fn checked_add(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_add_with_overflow(*self as u32, *v as u32);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl CheckedAdd for uint {\n+    #[inline]\n+    fn checked_add(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_add_with_overflow(*self as u64, *v as u64);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"32\")]\n+impl CheckedSub for uint {\n+    #[inline]\n+    fn checked_sub(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_sub_with_overflow(*self as u32, *v as u32);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl CheckedSub for uint {\n+    #[inline]\n+    fn checked_sub(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_sub_with_overflow(*self as u64, *v as u64);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"32\")]\n+impl CheckedMul for uint {\n+    #[inline]\n+    fn checked_mul(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u32_mul_with_overflow(*self as u32, *v as u32);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl CheckedMul for uint {\n+    #[inline]\n+    fn checked_mul(&self, v: &uint) -> Option<uint> {\n+        unsafe {\n+            let (x, y) = intrinsics::u64_mul_with_overflow(*self as u64, *v as u64);\n+            if y { None } else { Some(x as uint) }\n+        }\n+    }\n+}"}, {"sha": "092f7d81d220c2b1a5083043a2d466ff0954dcad", "filename": "src/libcore/num/uint_macros.rs", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,235 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![macro_escape]\n+#![doc(hidden)]\n+\n+macro_rules! uint_module (($T:ty, $T_SIGNED:ty, $bits:expr) => (\n+\n+pub static BITS : uint = $bits;\n+pub static BYTES : uint = ($bits / 8);\n+\n+pub static MIN: $T = 0 as $T;\n+pub static MAX: $T = 0 as $T - 1 as $T;\n+\n+#[cfg(not(test))]\n+impl Ord for $T {\n+    #[inline]\n+    fn lt(&self, other: &$T) -> bool { *self < *other }\n+}\n+#[cfg(not(test))]\n+impl TotalEq for $T {}\n+#[cfg(not(test))]\n+impl Eq for $T {\n+    #[inline]\n+    fn eq(&self, other: &$T) -> bool { *self == *other }\n+}\n+#[cfg(not(test))]\n+impl TotalOrd for $T {\n+    #[inline]\n+    fn cmp(&self, other: &$T) -> Ordering {\n+        if *self < *other { Less }\n+        else if *self > *other { Greater }\n+        else { Equal }\n+    }\n+}\n+\n+impl Num for $T {}\n+\n+impl Zero for $T {\n+    #[inline]\n+    fn zero() -> $T { 0 }\n+\n+    #[inline]\n+    fn is_zero(&self) -> bool { *self == 0 }\n+}\n+\n+impl One for $T {\n+    #[inline]\n+    fn one() -> $T { 1 }\n+}\n+\n+#[cfg(not(test))]\n+impl Add<$T,$T> for $T {\n+    #[inline]\n+    fn add(&self, other: &$T) -> $T { *self + *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Sub<$T,$T> for $T {\n+    #[inline]\n+    fn sub(&self, other: &$T) -> $T { *self - *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Mul<$T,$T> for $T {\n+    #[inline]\n+    fn mul(&self, other: &$T) -> $T { *self * *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Div<$T,$T> for $T {\n+    #[inline]\n+    fn div(&self, other: &$T) -> $T { *self / *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Rem<$T,$T> for $T {\n+    #[inline]\n+    fn rem(&self, other: &$T) -> $T { *self % *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Neg<$T> for $T {\n+    #[inline]\n+    fn neg(&self) -> $T { -(*self as $T_SIGNED) as $T }\n+}\n+\n+impl Unsigned for $T {}\n+\n+#[cfg(not(test))]\n+impl BitOr<$T,$T> for $T {\n+    #[inline]\n+    fn bitor(&self, other: &$T) -> $T { *self | *other }\n+}\n+\n+#[cfg(not(test))]\n+impl BitAnd<$T,$T> for $T {\n+    #[inline]\n+    fn bitand(&self, other: &$T) -> $T { *self & *other }\n+}\n+\n+#[cfg(not(test))]\n+impl BitXor<$T,$T> for $T {\n+    #[inline]\n+    fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Shl<$T,$T> for $T {\n+    #[inline]\n+    fn shl(&self, other: &$T) -> $T { *self << *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Shr<$T,$T> for $T {\n+    #[inline]\n+    fn shr(&self, other: &$T) -> $T { *self >> *other }\n+}\n+\n+#[cfg(not(test))]\n+impl Not<$T> for $T {\n+    #[inline]\n+    fn not(&self) -> $T { !*self }\n+}\n+\n+impl Bounded for $T {\n+    #[inline]\n+    fn min_value() -> $T { MIN }\n+\n+    #[inline]\n+    fn max_value() -> $T { MAX }\n+}\n+\n+impl Bitwise for $T {\n+    /// Returns the number of ones in the binary representation of the number.\n+    #[inline]\n+    fn count_ones(&self) -> $T {\n+        (*self as $T_SIGNED).count_ones() as $T\n+    }\n+\n+    /// Returns the number of leading zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn leading_zeros(&self) -> $T {\n+        (*self as $T_SIGNED).leading_zeros() as $T\n+    }\n+\n+    /// Returns the number of trailing zeros in the in the binary representation\n+    /// of the number.\n+    #[inline]\n+    fn trailing_zeros(&self) -> $T {\n+        (*self as $T_SIGNED).trailing_zeros() as $T\n+    }\n+}\n+\n+impl CheckedDiv for $T {\n+    #[inline]\n+    fn checked_div(&self, v: &$T) -> Option<$T> {\n+        if *v == 0 {\n+            None\n+        } else {\n+            Some(self / *v)\n+        }\n+    }\n+}\n+\n+impl Int for $T {}\n+\n+impl Primitive for $T {}\n+\n+impl Default for $T {\n+    #[inline]\n+    fn default() -> $T { 0 }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+    use super::*;\n+\n+    use num;\n+    use num::CheckedDiv;\n+    use num::Bitwise;\n+\n+    #[test]\n+    fn test_overflows() {\n+        assert!(MAX > 0);\n+        assert!(MIN <= 0);\n+        assert!(MIN + MAX + 1 == 0);\n+    }\n+\n+    #[test]\n+    fn test_num() {\n+        num::test_num(10 as $T, 2 as $T);\n+    }\n+\n+    #[test]\n+    fn test_bitwise() {\n+        assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n+        assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n+        assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n+        assert!(0b1110 as $T == (0b0111 as $T).shl(&(1 as $T)));\n+        assert!(0b0111 as $T == (0b1110 as $T).shr(&(1 as $T)));\n+        assert!(MAX - (0b1011 as $T) == (0b1011 as $T).not());\n+    }\n+\n+    #[test]\n+    fn test_count_ones() {\n+        assert!((0b0101100 as $T).count_ones() == 3);\n+        assert!((0b0100001 as $T).count_ones() == 2);\n+        assert!((0b1111001 as $T).count_ones() == 5);\n+    }\n+\n+    #[test]\n+    fn test_count_zeros() {\n+        assert!((0b0101100 as $T).count_zeros() == BITS as $T - 3);\n+        assert!((0b0100001 as $T).count_zeros() == BITS as $T - 2);\n+        assert!((0b1111001 as $T).count_zeros() == BITS as $T - 5);\n+    }\n+\n+    #[test]\n+    fn test_unsigned_checked_div() {\n+        assert!(10u.checked_div(&2) == Some(5));\n+        assert!(5u.checked_div(&0) == None);\n+    }\n+}\n+\n+))"}, {"sha": "4c31face2e3e28041b4e0bba624e145eaa0e94b8", "filename": "src/libcore/ops.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "previous_filename": "src/libstd/ops.rs"}, {"sha": "c6884a8002f799a06f17efe7d9dbe52e8ce2280a", "filename": "src/libcore/option.rs", "status": "added", "additions": 866, "deletions": 0, "changes": 866, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,866 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Optional values\n+//!\n+//! Type `Option` represents an optional value: every `Option`\n+//! is either `Some` and contains a value, or `None`, and\n+//! does not. `Option` types are very common in Rust code, as\n+//! they have a number of uses:\n+//!\n+//! * Initial values\n+//! * Return values for functions that are not defined\n+//!   over their entire input range (partial functions)\n+//! * Return value for otherwise reporting simple errors, where `None` is\n+//!   returned on error\n+//! * Optional struct fields\n+//! * Struct fields that can be loaned or \"taken\"\n+//! * Optional function arguments\n+//! * Nullable pointers\n+//! * Swapping things out of difficult situations\n+//!\n+//! Options are commonly paired with pattern matching to query the presence\n+//! of a value and take action, always accounting for the `None` case.\n+//!\n+//! ```\n+//! # // FIXME This is not the greatest first example\n+//! // cow_says contains the word \"moo\"\n+//! let cow_says = Some(\"moo\");\n+//! // dog_says does not contain a value\n+//! let dog_says: Option<&str> = None;\n+//!\n+//! // Pattern match to retrieve the value\n+//! match (cow_says, dog_says) {\n+//!     (Some(cow_words), Some(dog_words)) => {\n+//!         println!(\"Cow says {} and dog says {}!\", cow_words, dog_words);\n+//!     }\n+//!     (Some(cow_words), None) => println!(\"Cow says {}\", cow_words),\n+//!     (None, Some(dog_words)) => println!(\"Dog says {}\", dog_words),\n+//!     (None, None) => println!(\"Cow and dog are suspiciously silent\")\n+//! }\n+//! ```\n+//!\n+//\n+// FIXME: Show how `Option` is used in practice, with lots of methods\n+//\n+//! # Options and pointers (\"nullable\" pointers)\n+//!\n+//! Rust's pointer types must always point to a valid location; there are\n+//! no \"null\" pointers. Instead, Rust has *optional* pointers, like\n+//! the optional owned box, `Option<Box<T>>`.\n+//!\n+//! The following example uses `Option` to create an optional box of\n+//! `int`. Notice that in order to use the inner `int` value first the\n+//! `check_optional` function needs to use pattern matching to\n+//! determine whether the box has a value (i.e. it is `Some(...)`) or\n+//! not (`None`).\n+//!\n+//! ```\n+//! let optional: Option<Box<int>> = None;\n+//! check_optional(&optional);\n+//!\n+//! let optional: Option<Box<int>> = Some(box 9000);\n+//! check_optional(&optional);\n+//!\n+//! fn check_optional(optional: &Option<Box<int>>) {\n+//!     match *optional {\n+//!         Some(ref p) => println!(\"have value {}\", p),\n+//!         None => println!(\"have no value\")\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! This usage of `Option` to create safe nullable pointers is so\n+//! common that Rust does special optimizations to make the\n+//! representation of `Option<Box<T>>` a single pointer. Optional pointers\n+//! in Rust are stored as efficiently as any other pointer type.\n+//!\n+//! # Examples\n+//!\n+//! Basic pattern matching on `Option`:\n+//!\n+//! ```\n+//! let msg = Some(\"howdy\");\n+//!\n+//! // Take a reference to the contained string\n+//! match msg {\n+//!     Some(ref m) => println!(\"{}\", *m),\n+//!     None => ()\n+//! }\n+//!\n+//! // Remove the contained string, destroying the Option\n+//! let unwrapped_msg = match msg {\n+//!     Some(m) => m,\n+//!     None => \"default message\"\n+//! };\n+//! ```\n+//!\n+//! Initialize a result to `None` before a loop:\n+//!\n+//! ```\n+//! enum Kingdom { Plant(uint, &'static str), Animal(uint, &'static str) }\n+//!\n+//! // A list of data to search through.\n+//! let all_the_big_things = [\n+//!     Plant(250, \"redwood\"),\n+//!     Plant(230, \"noble fir\"),\n+//!     Plant(229, \"sugar pine\"),\n+//!     Animal(25, \"blue whale\"),\n+//!     Animal(19, \"fin whale\"),\n+//!     Animal(15, \"north pacific right whale\"),\n+//! ];\n+//!\n+//! // We're going to search for the name of the biggest animal,\n+//! // but to start with we've just got `None`.\n+//! let mut name_of_biggest_animal = None;\n+//! let mut size_of_biggest_animal = 0;\n+//! for big_thing in all_the_big_things.iter() {\n+//!     match *big_thing {\n+//!         Animal(size, name) if size > size_of_biggest_animal => {\n+//!             // Now we've found the name of some big animal\n+//!             size_of_biggest_animal = size;\n+//!             name_of_biggest_animal = Some(name);\n+//!         }\n+//!         Animal(..) | Plant(..) => ()\n+//!     }\n+//! }\n+//!\n+//! match name_of_biggest_animal {\n+//!     Some(name) => println!(\"the biggest animal is {}\", name),\n+//!     None => println!(\"there are no animals :(\")\n+//! }\n+//! ```\n+\n+use cmp::{Eq, TotalEq, TotalOrd};\n+use default::Default;\n+use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};\n+use mem;\n+use slice;\n+\n+/// The `Option`\n+#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n+pub enum Option<T> {\n+    /// No value\n+    None,\n+    /// Some value `T`\n+    Some(T)\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// Type implementation\n+/////////////////////////////////////////////////////////////////////////////\n+\n+impl<T> Option<T> {\n+    /////////////////////////////////////////////////////////////////////////\n+    // Querying the contained values\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Returns `true` if the option is a `Some` value\n+    #[inline]\n+    pub fn is_some(&self) -> bool {\n+        match *self {\n+            Some(_) => true,\n+            None => false\n+        }\n+    }\n+\n+    /// Returns `true` if the option is a `None` value\n+    #[inline]\n+    pub fn is_none(&self) -> bool {\n+        !self.is_some()\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////\n+    // Adapter for working with references\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Convert from `Option<T>` to `Option<&T>`\n+    ///\n+    /// # Example\n+    ///\n+    /// Convert an `Option<~str>` into an `Option<int>`, preserving the original.\n+    /// The `map` method takes the `self` argument by value, consuming the original,\n+    /// so this technique uses `as_ref` to first take an `Option` to a reference\n+    /// to the value inside the original.\n+    ///\n+    /// ```\n+    /// let num_as_str: Option<~str> = Some(\"10\".to_owned());\n+    /// // First, cast `Option<~str>` to `Option<&~str>` with `as_ref`,\n+    /// // then consume *that* with `map`, leaving `num_as_str` on the stack.\n+    /// let num_as_int: Option<uint> = num_as_str.as_ref().map(|n| n.len());\n+    /// println!(\"still can print num_as_str: {}\", num_as_str);\n+    /// ```\n+    #[inline]\n+    pub fn as_ref<'r>(&'r self) -> Option<&'r T> {\n+        match *self { Some(ref x) => Some(x), None => None }\n+    }\n+\n+    /// Convert from `Option<T>` to `Option<&mut T>`\n+    #[inline]\n+    pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {\n+        match *self { Some(ref mut x) => Some(x), None => None }\n+    }\n+\n+    /// Convert from `Option<T>` to `&[T]` (without copying)\n+    #[inline]\n+    pub fn as_slice<'r>(&'r self) -> &'r [T] {\n+        match *self {\n+            Some(ref x) => slice::ref_slice(x),\n+            None => &[]\n+        }\n+    }\n+\n+    /// Convert from `Option<T>` to `&mut [T]` (without copying)\n+    #[inline]\n+    pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n+        match *self {\n+            Some(ref mut x) => slice::mut_ref_slice(x),\n+            None => &mut []\n+        }\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////\n+    // Getting to contained values\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Moves a value out of an option type and returns it, consuming the `Option`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the self value equals `None`.\n+    ///\n+    /// # Safety note\n+    ///\n+    /// In general, because this function may fail, its use is discouraged.\n+    /// Instead, prefer to use pattern matching and handle the `None`\n+    /// case explicitly.\n+    #[inline]\n+    pub fn unwrap(self) -> T {\n+        match self {\n+            Some(val) => val,\n+            None => fail!(\"called `Option::unwrap()` on a `None` value\"),\n+        }\n+    }\n+\n+    /// Returns the contained value or a default.\n+    #[inline]\n+    pub fn unwrap_or(self, def: T) -> T {\n+        match self {\n+            Some(x) => x,\n+            None => def\n+        }\n+    }\n+\n+    /// Returns the contained value or computes it from a closure.\n+    #[inline]\n+    pub fn unwrap_or_else(self, f: || -> T) -> T {\n+        match self {\n+            Some(x) => x,\n+            None => f()\n+        }\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////\n+    // Transforming contained values\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value\n+    ///\n+    /// # Example\n+    ///\n+    /// Convert an `Option<~str>` into an `Option<uint>`, consuming the original:\n+    ///\n+    /// ```\n+    /// let num_as_str: Option<~str> = Some(\"10\".to_owned());\n+    /// // `Option::map` takes self *by value*, consuming `num_as_str`\n+    /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n+    /// ```\n+    #[inline]\n+    pub fn map<U>(self, f: |T| -> U) -> Option<U> {\n+        match self { Some(x) => Some(f(x)), None => None }\n+    }\n+\n+    /// Applies a function to the contained value or returns a default.\n+    #[inline]\n+    pub fn map_or<U>(self, def: U, f: |T| -> U) -> U {\n+        match self { None => def, Some(t) => f(t) }\n+    }\n+\n+    /// Applies a function to the contained value or does nothing.\n+    /// Returns true if the contained value was mutated.\n+    pub fn mutate(&mut self, f: |T| -> T) -> bool {\n+        if self.is_some() {\n+            *self = Some(f(self.take_unwrap()));\n+            true\n+        } else { false }\n+    }\n+\n+    /// Applies a function to the contained value or sets it to a default.\n+    /// Returns true if the contained value was mutated, or false if set to the default.\n+    pub fn mutate_or_set(&mut self, def: T, f: |T| -> T) -> bool {\n+        if self.is_some() {\n+            *self = Some(f(self.take_unwrap()));\n+            true\n+        } else {\n+            *self = Some(def);\n+            false\n+        }\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////\n+    // Iterator constructors\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Returns an iterator over the possibly contained value.\n+    #[inline]\n+    pub fn iter<'r>(&'r self) -> Item<&'r T> {\n+        Item{opt: self.as_ref()}\n+    }\n+\n+    /// Returns a mutable iterator over the possibly contained value.\n+    #[inline]\n+    pub fn mut_iter<'r>(&'r mut self) -> Item<&'r mut T> {\n+        Item{opt: self.as_mut()}\n+    }\n+\n+    /// Returns a consuming iterator over the possibly contained value.\n+    #[inline]\n+    pub fn move_iter(self) -> Item<T> {\n+        Item{opt: self}\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////\n+    // Boolean operations on the values, eager and lazy\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Returns `None` if the option is `None`, otherwise returns `optb`.\n+    #[inline]\n+    pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n+        match self {\n+            Some(_) => optb,\n+            None => None,\n+        }\n+    }\n+\n+    /// Returns `None` if the option is `None`, otherwise calls `f` with the\n+    /// wrapped value and returns the result.\n+    #[inline]\n+    pub fn and_then<U>(self, f: |T| -> Option<U>) -> Option<U> {\n+        match self {\n+            Some(x) => f(x),\n+            None => None,\n+        }\n+    }\n+\n+    /// Returns the option if it contains a value, otherwise returns `optb`.\n+    #[inline]\n+    pub fn or(self, optb: Option<T>) -> Option<T> {\n+        match self {\n+            Some(_) => self,\n+            None => optb\n+        }\n+    }\n+\n+    /// Returns the option if it contains a value, otherwise calls `f` and\n+    /// returns the result.\n+    #[inline]\n+    pub fn or_else(self, f: || -> Option<T>) -> Option<T> {\n+        match self {\n+            Some(_) => self,\n+            None => f()\n+        }\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////\n+    // Misc\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Takes the value out of the option, leaving a `None` in its place.\n+    #[inline]\n+    pub fn take(&mut self) -> Option<T> {\n+        mem::replace(self, None)\n+    }\n+\n+    /// Filters an optional value using a given function.\n+    #[inline(always)]\n+    pub fn filtered(self, f: |t: &T| -> bool) -> Option<T> {\n+        match self {\n+            Some(x) => if f(&x) { Some(x) } else { None },\n+            None => None\n+        }\n+    }\n+\n+    /// Applies a function zero or more times until the result is `None`.\n+    #[inline]\n+    pub fn while_some(self, f: |v: T| -> Option<T>) {\n+        let mut opt = self;\n+        loop {\n+            match opt {\n+                Some(x) => opt = f(x),\n+                None => break\n+            }\n+        }\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////\n+    // Common special cases\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// The option dance. Moves a value out of an option type and returns it,\n+    /// replacing the original with `None`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value equals `None`.\n+    #[inline]\n+    pub fn take_unwrap(&mut self) -> T {\n+        match self.take() {\n+            Some(x) => x,\n+            None => fail!(\"called `Option::take_unwrap()` on a `None` value\")\n+        }\n+    }\n+\n+    /// Gets an immutable reference to the value inside an option.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value equals `None`\n+    ///\n+    /// # Safety note\n+    ///\n+    /// In general, because this function may fail, its use is discouraged\n+    /// (calling `get` on `None` is akin to dereferencing a null pointer).\n+    /// Instead, prefer to use pattern matching and handle the `None`\n+    /// case explicitly.\n+    #[inline]\n+    pub fn get_ref<'a>(&'a self) -> &'a T {\n+        match *self {\n+            Some(ref x) => x,\n+            None => fail!(\"called `Option::get_ref()` on a `None` value\"),\n+        }\n+    }\n+\n+    /// Gets a mutable reference to the value inside an option.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value equals `None`\n+    ///\n+    /// # Safety note\n+    ///\n+    /// In general, because this function may fail, its use is discouraged\n+    /// (calling `get` on `None` is akin to dereferencing a null pointer).\n+    /// Instead, prefer to use pattern matching and handle the `None`\n+    /// case explicitly.\n+    #[inline]\n+    pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n+        match *self {\n+            Some(ref mut x) => x,\n+            None => fail!(\"called `Option::get_mut_ref()` on a `None` value\"),\n+        }\n+    }\n+}\n+\n+impl<T: Default> Option<T> {\n+    /// Returns the contained value or a default\n+    ///\n+    /// Consumes the `self` argument then, if `Some`, returns the contained\n+    /// value, otherwise if `None`, returns the default value for that\n+    /// type.\n+    ///\n+    /// # Example\n+    ///\n+    /// Convert a string to an integer, turning poorly-formed strings\n+    /// into 0 (the default value for integers). `from_str` converts\n+    /// a string to any other type that implements `FromStr`, returning\n+    /// `None` on error.\n+    ///\n+    /// ```\n+    /// let good_year_from_input = \"1909\";\n+    /// let bad_year_from_input = \"190blarg\";\n+    /// let good_year = from_str(good_year_from_input).unwrap_or_default();\n+    /// let bad_year = from_str(bad_year_from_input).unwrap_or_default();\n+    ///\n+    /// assert_eq!(1909, good_year);\n+    /// assert_eq!(0, bad_year);\n+    /// ```\n+    #[inline]\n+    pub fn unwrap_or_default(self) -> T {\n+        match self {\n+            Some(x) => x,\n+            None => Default::default()\n+        }\n+    }\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// Trait implementations\n+/////////////////////////////////////////////////////////////////////////////\n+\n+impl<T> Default for Option<T> {\n+    #[inline]\n+    fn default() -> Option<T> { None }\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// The Option Iterator\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// An `Option` iterator that yields either one or zero elements\n+///\n+/// The `Item` iterator is returned by the `iter`, `mut_iter` and `move_iter`\n+/// methods on `Option`.\n+#[deriving(Clone)]\n+pub struct Item<A> {\n+    opt: Option<A>\n+}\n+\n+impl<A> Iterator<A> for Item<A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        self.opt.take()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        match self.opt {\n+            Some(_) => (1, Some(1)),\n+            None => (0, Some(0)),\n+        }\n+    }\n+}\n+\n+impl<A> DoubleEndedIterator<A> for Item<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        self.opt.take()\n+    }\n+}\n+\n+impl<A> ExactSize<A> for Item<A> {}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// Free functions\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// Takes each element in the `Iterator`: if it is `None`, no further\n+/// elements are taken, and the `None` is returned. Should no `None` occur, a\n+/// vector containing the values of each `Option` is returned.\n+///\n+/// Here is an example which increments every integer in a vector,\n+/// checking for overflow:\n+///\n+///     fn inc_conditionally(x: uint) -> Option<uint> {\n+///         if x == uint::MAX { return None; }\n+///         else { return Some(x+1u); }\n+///     }\n+///     let v = [1u, 2, 3];\n+///     let res = collect(v.iter().map(|&x| inc_conditionally(x)));\n+///     assert!(res == Some(~[2u, 3, 4]));\n+#[inline]\n+pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(iter: Iter) -> Option<V> {\n+    // FIXME(#11084): This should be twice as fast once this bug is closed.\n+    let mut iter = iter.scan(false, |state, x| {\n+        match x {\n+            Some(x) => Some(x),\n+            None => {\n+                *state = true;\n+                None\n+            }\n+        }\n+    });\n+\n+    let v: V = FromIterator::from_iter(iter.by_ref());\n+\n+    if iter.state {\n+        None\n+    } else {\n+        Some(v)\n+    }\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// Tests\n+/////////////////////////////////////////////////////////////////////////////\n+\n+#[cfg(test)]\n+mod tests {\n+    use realstd::option::collect;\n+    use realstd::prelude::*;\n+    use realstd::iter::range;\n+\n+    use str::StrSlice;\n+    use kinds::marker;\n+    use slice::ImmutableVector;\n+\n+    #[test]\n+    fn test_get_ptr() {\n+        unsafe {\n+            let x = box 0;\n+            let addr_x: *int = ::cast::transmute(&*x);\n+            let opt = Some(x);\n+            let y = opt.unwrap();\n+            let addr_y: *int = ::cast::transmute(&*y);\n+            assert_eq!(addr_x, addr_y);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_get_str() {\n+        let x = \"test\".to_owned();\n+        let addr_x = x.as_ptr();\n+        let opt = Some(x);\n+        let y = opt.unwrap();\n+        let addr_y = y.as_ptr();\n+        assert_eq!(addr_x, addr_y);\n+    }\n+\n+    #[test]\n+    fn test_get_resource() {\n+        use realstd::rc::Rc;\n+        use cell::RefCell;\n+\n+        struct R {\n+           i: Rc<RefCell<int>>,\n+        }\n+\n+        #[unsafe_destructor]\n+        impl ::ops::Drop for R {\n+           fn drop(&mut self) {\n+                let ii = &*self.i;\n+                let i = ii.borrow().clone();\n+                *ii.borrow_mut() = i + 1;\n+            }\n+        }\n+\n+        fn R(i: Rc<RefCell<int>>) -> R {\n+            R {\n+                i: i\n+            }\n+        }\n+\n+        let i = Rc::new(RefCell::new(0));\n+        {\n+            let x = R(i.clone());\n+            let opt = Some(x);\n+            let _y = opt.unwrap();\n+        }\n+        assert_eq!(*i.borrow(), 1);\n+    }\n+\n+    #[test]\n+    fn test_option_dance() {\n+        let x = Some(());\n+        let mut y = Some(5);\n+        let mut y2 = 0;\n+        for _x in x.iter() {\n+            y2 = y.take_unwrap();\n+        }\n+        assert_eq!(y2, 5);\n+        assert!(y.is_none());\n+    }\n+\n+    #[test] #[should_fail]\n+    fn test_option_too_much_dance() {\n+        let mut y = Some(marker::NoCopy);\n+        let _y2 = y.take_unwrap();\n+        let _y3 = y.take_unwrap();\n+    }\n+\n+    #[test]\n+    fn test_and() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.and(Some(2)), Some(2));\n+        assert_eq!(x.and(None::<int>), None);\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.and(Some(2)), None);\n+        assert_eq!(x.and(None::<int>), None);\n+    }\n+\n+    #[test]\n+    fn test_and_then() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.and_then(|x| Some(x + 1)), Some(2));\n+        assert_eq!(x.and_then(|_| None::<int>), None);\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.and_then(|x| Some(x + 1)), None);\n+        assert_eq!(x.and_then(|_| None::<int>), None);\n+    }\n+\n+    #[test]\n+    fn test_or() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.or(Some(2)), Some(1));\n+        assert_eq!(x.or(None), Some(1));\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.or(Some(2)), Some(2));\n+        assert_eq!(x.or(None), None);\n+    }\n+\n+    #[test]\n+    fn test_or_else() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.or_else(|| Some(2)), Some(1));\n+        assert_eq!(x.or_else(|| None), Some(1));\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.or_else(|| Some(2)), Some(2));\n+        assert_eq!(x.or_else(|| None), None);\n+    }\n+\n+    #[test]\n+    fn test_option_while_some() {\n+        let mut i = 0;\n+        Some(10).while_some(|j| {\n+            i += 1;\n+            if j > 0 {\n+                Some(j-1)\n+            } else {\n+                None\n+            }\n+        });\n+        assert_eq!(i, 11);\n+    }\n+\n+    #[test]\n+    fn test_unwrap() {\n+        assert_eq!(Some(1).unwrap(), 1);\n+        assert_eq!(Some(\"hello\".to_owned()).unwrap(), \"hello\".to_owned());\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_unwrap_fail1() {\n+        let x: Option<int> = None;\n+        x.unwrap();\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_unwrap_fail2() {\n+        let x: Option<~str> = None;\n+        x.unwrap();\n+    }\n+\n+    #[test]\n+    fn test_unwrap_or() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.unwrap_or(2), 1);\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.unwrap_or(2), 2);\n+    }\n+\n+    #[test]\n+    fn test_unwrap_or_else() {\n+        let x: Option<int> = Some(1);\n+        assert_eq!(x.unwrap_or_else(|| 2), 1);\n+\n+        let x: Option<int> = None;\n+        assert_eq!(x.unwrap_or_else(|| 2), 2);\n+    }\n+\n+    #[test]\n+    fn test_filtered() {\n+        let some_stuff = Some(42);\n+        let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n+        assert_eq!(some_stuff.unwrap(), 42);\n+        assert!(modified_stuff.is_none());\n+    }\n+\n+    #[test]\n+    fn test_iter() {\n+        let val = 5;\n+\n+        let x = Some(val);\n+        let mut it = x.iter();\n+\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(it.next(), Some(&val));\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert!(it.next().is_none());\n+    }\n+\n+    #[test]\n+    fn test_mut_iter() {\n+        let val = 5;\n+        let new_val = 11;\n+\n+        let mut x = Some(val);\n+        {\n+            let mut it = x.mut_iter();\n+\n+            assert_eq!(it.size_hint(), (1, Some(1)));\n+\n+            match it.next() {\n+                Some(interior) => {\n+                    assert_eq!(*interior, val);\n+                    *interior = new_val;\n+                }\n+                None => assert!(false),\n+            }\n+\n+            assert_eq!(it.size_hint(), (0, Some(0)));\n+            assert!(it.next().is_none());\n+        }\n+        assert_eq!(x, Some(new_val));\n+    }\n+\n+    #[test]\n+    fn test_ord() {\n+        let small = Some(1.0);\n+        let big = Some(5.0);\n+        let nan = Some(0.0/0.0);\n+        assert!(!(nan < big));\n+        assert!(!(nan > big));\n+        assert!(small < big);\n+        assert!(None < big);\n+        assert!(big > None);\n+    }\n+\n+    #[test]\n+    fn test_mutate() {\n+        let mut x = Some(3i);\n+        assert!(x.mutate(|i| i+1));\n+        assert_eq!(x, Some(4i));\n+        assert!(x.mutate_or_set(0, |i| i+1));\n+        assert_eq!(x, Some(5i));\n+        x = None;\n+        assert!(!x.mutate(|i| i+1));\n+        assert_eq!(x, None);\n+        assert!(!x.mutate_or_set(0i, |i| i+1));\n+        assert_eq!(x, Some(0i));\n+    }\n+\n+    #[test]\n+    fn test_collect() {\n+        let v: Option<~[int]> = collect(range(0, 0)\n+                                        .map(|_| Some(0)));\n+        assert_eq!(v, Some(box []));\n+\n+        let v: Option<~[int]> = collect(range(0, 3)\n+                                        .map(|x| Some(x)));\n+        assert_eq!(v, Some(box [0, 1, 2]));\n+\n+        let v: Option<~[int]> = collect(range(0, 3)\n+                                        .map(|x| if x > 1 { None } else { Some(x) }));\n+        assert_eq!(v, None);\n+\n+        // test that it does not take more elements than it needs\n+        let mut functions = [|| Some(()), || None, || fail!()];\n+\n+        let v: Option<~[()]> = collect(functions.mut_iter().map(|f| (*f)()));\n+\n+        assert_eq!(v, None);\n+    }\n+}"}, {"sha": "d5cdd9c39b67c22550a0952f5cecb6b2a60c3af1", "filename": "src/libcore/owned.rs", "status": "renamed", "additions": 4, "deletions": 30, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fowned.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -10,7 +10,10 @@\n \n //! Operations on unique pointer types\n \n-#[cfg(not(test))] use cmp::*;\n+// FIXME: this module should not exist in libcore. It must currently because the\n+//        Box implementation is quite ad-hoc in the compiler. Once there is\n+//        proper support in the compiler this type will be able to be defined in\n+//        its own module.\n \n /// A value that represents the global exchange heap. This is the default\n /// place that the `box` keyword allocates into when no place is supplied.\n@@ -33,32 +36,3 @@ pub struct Box<T>(*T);\n \n #[cfg(test)]\n pub struct Box<T>(*T);\n-\n-#[cfg(not(test))]\n-impl<T:Eq> Eq for Box<T> {\n-    #[inline]\n-    fn eq(&self, other: &Box<T>) -> bool { *(*self) == *(*other) }\n-    #[inline]\n-    fn ne(&self, other: &Box<T>) -> bool { *(*self) != *(*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl<T:Ord> Ord for Box<T> {\n-    #[inline]\n-    fn lt(&self, other: &Box<T>) -> bool { *(*self) < *(*other) }\n-    #[inline]\n-    fn le(&self, other: &Box<T>) -> bool { *(*self) <= *(*other) }\n-    #[inline]\n-    fn ge(&self, other: &Box<T>) -> bool { *(*self) >= *(*other) }\n-    #[inline]\n-    fn gt(&self, other: &Box<T>) -> bool { *(*self) > *(*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl<T: TotalOrd> TotalOrd for Box<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Box<T>) -> Ordering { (**self).cmp(*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl<T: TotalEq> TotalEq for Box<T> {}", "previous_filename": "src/libstd/owned.rs"}, {"sha": "efd6732f6530a80360419c2a434bad6aa0eb29e4", "filename": "src/libcore/prelude.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The core prelude\n+//!\n+//! For more information, see std::prelude.\n+\n+// Reexported core operators\n+pub use kinds::{Copy, Send, Sized, Share};\n+pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n+pub use ops::{BitAnd, BitOr, BitXor};\n+pub use ops::{Drop, Deref, DerefMut};\n+pub use ops::{Shl, Shr, Index};\n+pub use option::{Option, Some, None};\n+pub use result::{Result, Ok, Err};\n+\n+// Reexported functions\n+pub use iter::range;\n+pub use mem::drop;\n+\n+// Reexported types and traits\n+\n+pub use char::Char;\n+pub use clone::Clone;\n+pub use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater, Equiv};\n+pub use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n+pub use iter::{FromIterator, Extendable};\n+pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, CloneableIterator};\n+pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n+pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n+pub use num::{Signed, Unsigned};\n+pub use num::{Primitive, Int, ToPrimitive, FromPrimitive};\n+pub use ptr::RawPtr;\n+pub use str::{Str, StrSlice};\n+pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n+pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n+pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n+pub use slice::{ImmutableEqVector, ImmutableTotalOrdVector};\n+pub use slice::{MutableVector};\n+pub use slice::{Vector, ImmutableVector};"}, {"sha": "e3a3f78dcb9257518bce768d43e465adebc5f122", "filename": "src/libcore/ptr.rs", "status": "renamed", "additions": 11, "deletions": 47, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -92,14 +92,12 @@\n \n use cast;\n use clone::Clone;\n-#[cfg(not(test))]\n-use cmp::Equiv;\n+use intrinsics;\n use iter::{range, Iterator};\n use mem;\n-use option::{Option, Some, None};\n-use intrinsics;\n+use option::{Some, None, Option};\n \n-#[cfg(not(test))] use cmp::{Eq, TotalEq, Ord};\n+#[cfg(not(test))] use cmp::{Eq, TotalEq, Ord, Equiv};\n \n /// Return the offset of the first null pointer in `buf`.\n #[inline]\n@@ -377,7 +375,9 @@ impl<T> RawPtr<T> for *mut T {\n     fn to_uint(&self) -> uint { *self as uint }\n \n     #[inline]\n-    unsafe fn offset(self, count: int) -> *mut T { intrinsics::offset(self as *T, count) as *mut T }\n+    unsafe fn offset(self, count: int) -> *mut T {\n+        intrinsics::offset(self as *T, count) as *mut T\n+    }\n \n     #[inline]\n     unsafe fn to_option(&self) -> Option<&T> {\n@@ -444,10 +444,6 @@ mod externfnpointers {\n             let other_: *() = unsafe { cast::transmute(*other) };\n             self_ == other_\n         }\n-        #[inline]\n-        fn ne(&self, other: &extern \"C\" fn() -> _R) -> bool {\n-            !self.eq(other)\n-        }\n     }\n     macro_rules! fnptreq(\n         ($($p:ident),*) => {\n@@ -458,10 +454,6 @@ mod externfnpointers {\n                     let other_: *() = unsafe { cast::transmute(*other) };\n                     self_ == other_\n                 }\n-                #[inline]\n-                fn ne(&self, other: &extern \"C\" fn($($p),*) -> _R) -> bool {\n-                    !self.eq(other)\n-                }\n             }\n         }\n     )\n@@ -476,52 +468,24 @@ mod externfnpointers {\n #[cfg(not(test))]\n impl<T> Ord for *T {\n     #[inline]\n-    fn lt(&self, other: &*T) -> bool {\n-        *self < *other\n-    }\n-    #[inline]\n-    fn le(&self, other: &*T) -> bool {\n-        *self <= *other\n-    }\n-    #[inline]\n-    fn ge(&self, other: &*T) -> bool {\n-        *self >= *other\n-    }\n-    #[inline]\n-    fn gt(&self, other: &*T) -> bool {\n-        *self > *other\n-    }\n+    fn lt(&self, other: &*T) -> bool { *self < *other }\n }\n \n #[cfg(not(test))]\n impl<T> Ord for *mut T {\n     #[inline]\n-    fn lt(&self, other: &*mut T) -> bool {\n-        *self < *other\n-    }\n-    #[inline]\n-    fn le(&self, other: &*mut T) -> bool {\n-        *self <= *other\n-    }\n-    #[inline]\n-    fn ge(&self, other: &*mut T) -> bool {\n-        *self >= *other\n-    }\n-    #[inline]\n-    fn gt(&self, other: &*mut T) -> bool {\n-        *self > *other\n-    }\n+    fn lt(&self, other: &*mut T) -> bool { *self < *other }\n }\n \n #[cfg(test)]\n pub mod ptr_tests {\n     use super::*;\n-    use prelude::*;\n+    use realstd::prelude::*;\n \n-    use c_str::ToCStr;\n+    use realstd::c_str::ToCStr;\n     use cast;\n     use libc;\n-    use str;\n+    use realstd::str;\n     use slice::{ImmutableVector, MutableVector};\n \n     #[test]", "previous_filename": "src/libstd/ptr.rs"}, {"sha": "d6caa145ae9c8abccd549dcb774cf5fe8da0df9a", "filename": "src/libcore/raw.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![allow(missing_doc)]\n+#![experimental]\n \n //! Contains struct definitions for the layout of compiler built-in types.\n //!", "previous_filename": "src/libstd/raw.rs"}, {"sha": "337b2ac89dd7aacc61ac982df1358d959d8e6932", "filename": "src/libcore/result.rs", "status": "added", "additions": 752, "deletions": 0, "changes": 752, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,752 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Error handling with the `Result` type\n+//!\n+//! `Result<T>` is the type used for returning and propagating\n+//! errors. It is an enum with the variants, `Ok(T)`, representing\n+//! success and containing a value, and `Err(E)`, representing error\n+//! and containing an error value.\n+//!\n+//! ~~~\n+//! enum Result<T, E> {\n+//!    Ok(T),\n+//!    Err(E)\n+//! }\n+//! ~~~\n+//!\n+//! Functions return `Result` whenever errors are expected and\n+//! recoverable. In the `std` crate `Result` is most prominently used\n+//! for [I/O](../io/index.html).\n+//!\n+//! A simple function returning `Result` might be\n+//! defined and used like so:\n+//!\n+//! ~~~\n+//! #[deriving(Show)]\n+//! enum Version { Version1, Version2 }\n+//!\n+//! fn parse_version(header: &[u8]) -> Result<Version, &'static str> {\n+//!     if header.len() < 1 {\n+//!         return Err(\"invalid header length\");\n+//!     }\n+//!     match header[0] {\n+//!         1 => Ok(Version1),\n+//!         2 => Ok(Version2),\n+//!         _ => Err(\"invalid version\")\n+//!     }\n+//! }\n+//!\n+//! let version = parse_version(&[1, 2, 3, 4]);\n+//! match version {\n+//!     Ok(v) => {\n+//!         println!(\"working with version: {}\", v);\n+//!     }\n+//!     Err(e) => {\n+//!         println!(\"error parsing header: {}\", e);\n+//!     }\n+//! }\n+//! ~~~\n+//!\n+//! Pattern matching on `Result`s is clear and straightforward for\n+//! simple cases, but `Result` comes with some convenience methods\n+//! that make working it more succinct.\n+//!\n+//! ~~~\n+//! let good_result: Result<int, int> = Ok(10);\n+//! let bad_result: Result<int, int> = Err(10);\n+//!\n+//! // The `is_ok` and `is_err` methods do what they say.\n+//! assert!(good_result.is_ok() && !good_result.is_err());\n+//! assert!(bad_result.is_err() && !bad_result.is_ok());\n+//!\n+//! // `map` consumes the `Result` and produces another.\n+//! let good_result: Result<int, int> = good_result.map(|i| i + 1);\n+//! let bad_result: Result<int, int> = bad_result.map(|i| i - 1);\n+//!\n+//! // Use `and_then` to continue the computation.\n+//! let good_result: Result<bool, int> = good_result.and_then(|i| Ok(i == 11));\n+//!\n+//! // Use `or_else` to handle the error.\n+//! let bad_result: Result<int, int> = bad_result.or_else(|i| Ok(11));\n+//!\n+//! // Consume the result and return the contents with `unwrap`.\n+//! let final_awesome_result = good_result.ok().unwrap();\n+//! ~~~\n+//!\n+//! # Results must be used\n+//!\n+//! A common problem with using return values to indicate errors is\n+//! that it is easy to ignore the return value, thus failing to handle\n+//! the error. Result is annotated with the #[must_use] attribute,\n+//! which will cause the compiler to issue a warning when a Result\n+//! value is ignored. This makes `Result` especially useful with\n+//! functions that may encounter errors but don't otherwise return a\n+//! useful value.\n+//!\n+//! Consider the `write_line` method defined for I/O types\n+//! by the [`Writer`](../io/trait.Writer.html) trait:\n+//!\n+//! ~~~\n+//! use std::io::IoError;\n+//!\n+//! trait Writer {\n+//!     fn write_line(&mut self, s: &str) -> Result<(), IoError>;\n+//! }\n+//! ~~~\n+//!\n+//! *Note: The actual definition of `Writer` uses `IoResult`, which\n+//! is just a synonym for `Result<T, IoError>`.*\n+//!\n+//! This method doesn`t produce a value, but the write may\n+//! fail. It's crucial to handle the error case, and *not* write\n+//! something like this:\n+//!\n+//! ~~~ignore\n+//! use std::io::{File, Open, Write};\n+//!\n+//! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n+//! // If `write_line` errors, then we'll never know, because the return\n+//! // value is ignored.\n+//! file.write_line(\"important message\");\n+//! drop(file);\n+//! ~~~\n+//!\n+//! If you *do* write that in Rust, the compiler will by give you a\n+//! warning (by default, controlled by the `unused_must_use` lint).\n+//!\n+//! You might instead, if you don't want to handle the error, simply\n+//! fail, by converting to an `Option` with `ok`, then asserting\n+//! success with `expect`. This will fail if the write fails, proving\n+//! a marginally useful message indicating why:\n+//!\n+//! ~~~no_run\n+//! use std::io::{File, Open, Write};\n+//!\n+//! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n+//! file.write_line(\"important message\").ok().expect(\"failed to write message\");\n+//! drop(file);\n+//! ~~~\n+//!\n+//! You might also simply assert success:\n+//!\n+//! ~~~no_run\n+//! # use std::io::{File, Open, Write};\n+//!\n+//! # let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n+//! assert!(file.write_line(\"important message\").is_ok());\n+//! # drop(file);\n+//! ~~~\n+//!\n+//! Or propagate the error up the call stack with `try!`:\n+//!\n+//! ~~~\n+//! # use std::io::{File, Open, Write, IoError};\n+//! fn write_message() -> Result<(), IoError> {\n+//!     let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n+//!     try!(file.write_line(\"important message\"));\n+//!     drop(file);\n+//!     return Ok(());\n+//! }\n+//! ~~~\n+//!\n+//! # The `try!` macro\n+//!\n+//! When writing code that calls many functions that return the\n+//! `Result` type, the error handling can be tedious.  The `try!`\n+//! macro hides some of the boilerplate of propagating errors up the\n+//! call stack.\n+//!\n+//! It replaces this:\n+//!\n+//! ~~~\n+//! use std::io::{File, Open, Write, IoError};\n+//!\n+//! struct Info { name: ~str, age: int, rating: int }\n+//!\n+//! fn write_info(info: &Info) -> Result<(), IoError> {\n+//!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n+//!     // Early return on error\n+//!     match file.write_line(format!(\"name: {}\", info.name)) {\n+//!         Ok(_) => (),\n+//!         Err(e) => return Err(e)\n+//!     }\n+//!     match file.write_line(format!(\"age: {}\", info.age)) {\n+//!         Ok(_) => (),\n+//!         Err(e) => return Err(e)\n+//!     }\n+//!     return file.write_line(format!(\"rating: {}\", info.rating));\n+//! }\n+//! ~~~\n+//!\n+//! With this:\n+//!\n+//! ~~~\n+//! use std::io::{File, Open, Write, IoError};\n+//!\n+//! struct Info { name: ~str, age: int, rating: int }\n+//!\n+//! fn write_info(info: &Info) -> Result<(), IoError> {\n+//!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n+//!     // Early return on error\n+//!     try!(file.write_line(format!(\"name: {}\", info.name)));\n+//!     try!(file.write_line(format!(\"age: {}\", info.age)));\n+//!     try!(file.write_line(format!(\"rating: {}\", info.rating)));\n+//!     return Ok(());\n+//! }\n+//! ~~~\n+//!\n+//! *It's much nicer!*\n+//!\n+//! Wrapping an expression in `try!` will result in the unwrapped\n+//! success (`Ok`) value, unless the result is `Err`, in which case\n+//! `Err` is returned early from the enclosing function. Its simple definition\n+//! makes it clear:\n+//!\n+//! ~~~\n+//! # #![feature(macro_rules)]\n+//! macro_rules! try(\n+//!     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+//! )\n+//! # fn main() { }\n+//! ~~~\n+//!\n+//! `try!` is imported by the prelude, and is available everywhere.\n+//!\n+//! # `Result` and `Option`\n+//!\n+//! The `Result` and [`Option`](../option/index.html) types are\n+//! similar and complementary: they are often employed to indicate a\n+//! lack of a return value; and they are trivially converted between\n+//! each other, so `Result`s are often handled by first converting to\n+//! `Option` with the [`ok`](enum.Result.html#method.ok) and\n+//! [`err`](enum.Result.html#method.ok) methods.\n+//!\n+//! Whereas `Option` only indicates the lack of a value, `Result` is\n+//! specifically for error reporting, and carries with it an error\n+//! value.  Sometimes `Option` is used for indicating errors, but this\n+//! is only for simple cases and is generally discouraged. Even when\n+//! there is no useful error value to return, prefer `Result<T, ()>`.\n+//!\n+//! Converting to an `Option` with `ok()` to handle an error:\n+//!\n+//! ~~~\n+//! use std::io::Timer;\n+//! let mut t = Timer::new().ok().expect(\"failed to create timer!\");\n+//! ~~~\n+//!\n+//! # `Result` vs. `fail!`\n+//!\n+//! `Result` is for recoverable errors; `fail!` is for unrecoverable\n+//! errors. Callers should always be able to avoid failure if they\n+//! take the proper precautions, for example, calling `is_some()`\n+//! on an `Option` type before calling `unwrap`.\n+//!\n+//! The suitability of `fail!` as an error handling mechanism is\n+//! limited by Rust's lack of any way to \"catch\" and resume execution\n+//! from a thrown exception. Therefore using failure for error\n+//! handling requires encapsulating fallable code in a task. Calling\n+//! the `fail!` macro, or invoking `fail!` indirectly should be\n+//! avoided as an error reporting strategy. Failure is only for\n+//! unrecoverable errors and a failing task is typically the sign of\n+//! a bug.\n+//!\n+//! A module that instead returns `Results` is alerting the caller\n+//! that failure is possible, and providing precise control over how\n+//! it is handled.\n+//!\n+//! Furthermore, failure may not be recoverable at all, depending on\n+//! the context. The caller of `fail!` should assume that execution\n+//! will not resume after failure, that failure is catastrophic.\n+\n+use clone::Clone;\n+use cmp::Eq;\n+use iter::{Iterator, FromIterator};\n+use option::{None, Option, Some};\n+\n+/// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n+///\n+/// See the [`std::result`](index.html) module documentation for details.\n+#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n+#[must_use]\n+pub enum Result<T, E> {\n+    /// Contains the success value\n+    Ok(T),\n+\n+    /// Contains the error value\n+    Err(E)\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// Type implementation\n+/////////////////////////////////////////////////////////////////////////////\n+\n+impl<T, E> Result<T, E> {\n+    /////////////////////////////////////////////////////////////////////////\n+    // Querying the contained values\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Returns true if the result is `Ok`\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~\n+    /// use std::io::{File, Open, Write};\n+    ///\n+    /// # fn do_not_run_example() { // creates a file\n+    /// let mut file = File::open_mode(&Path::new(\"secret.txt\"), Open, Write);\n+    /// assert!(file.write_line(\"it's cold in here\").is_ok());\n+    /// # }\n+    /// ~~~\n+    #[inline]\n+    pub fn is_ok(&self) -> bool {\n+        match *self {\n+            Ok(_) => true,\n+            Err(_) => false\n+        }\n+    }\n+\n+    /// Returns true if the result is `Err`\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~\n+    /// use std::io::{File, Open, Read};\n+    ///\n+    /// // When opening with `Read` access, if the file does not exist\n+    /// // then `open_mode` returns an error.\n+    /// let bogus = File::open_mode(&Path::new(\"not_a_file.txt\"), Open, Read);\n+    /// assert!(bogus.is_err());\n+    /// ~~~\n+    #[inline]\n+    pub fn is_err(&self) -> bool {\n+        !self.is_ok()\n+    }\n+\n+\n+    /////////////////////////////////////////////////////////////////////////\n+    // Adapter for each variant\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Convert from `Result<T, E>` to `Option<T>`\n+    ///\n+    /// Converts `self` into an `Option<T>`, consuming `self`,\n+    /// and discarding the error, if any.\n+    ///\n+    /// To convert to an `Option` without discarding the error value,\n+    /// use `as_ref` to first convert the `Result<T, E>` into a\n+    /// `Result<&T, &E>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ~~~{.should_fail}\n+    /// use std::io::{File, IoResult};\n+    ///\n+    /// let bdays: IoResult<File> = File::open(&Path::new(\"important_birthdays.txt\"));\n+    /// let bdays: File = bdays.ok().expect(\"unable to open birthday file\");\n+    /// ~~~\n+    #[inline]\n+    pub fn ok(self) -> Option<T> {\n+        match self {\n+            Ok(x)  => Some(x),\n+            Err(_) => None,\n+        }\n+    }\n+\n+    /// Convert from `Result<T, E>` to `Option<E>`\n+    ///\n+    /// Converts `self` into an `Option<T>`, consuming `self`,\n+    /// and discarding the value, if any.\n+    #[inline]\n+    pub fn err(self) -> Option<E> {\n+        match self {\n+            Ok(_)  => None,\n+            Err(x) => Some(x),\n+        }\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////\n+    // Adapter for working with references\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Convert from `Result<T, E>` to `Result<&T, &E>`\n+    ///\n+    /// Produces a new `Result`, containing a reference\n+    /// into the original, leaving the original in place.\n+    #[inline]\n+    pub fn as_ref<'r>(&'r self) -> Result<&'r T, &'r E> {\n+        match *self {\n+            Ok(ref x) => Ok(x),\n+            Err(ref x) => Err(x),\n+        }\n+    }\n+\n+    /// Convert from `Result<T, E>` to `Result<&mut T, &mut E>`\n+    #[inline]\n+    pub fn as_mut<'r>(&'r mut self) -> Result<&'r mut T, &'r mut E> {\n+        match *self {\n+            Ok(ref mut x) => Ok(x),\n+            Err(ref mut x) => Err(x),\n+        }\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////\n+    // Transforming contained values\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Maps a `Result<T, E>` to `Result<U, E>` by applying a function to an\n+    /// contained `Ok` value, leaving an `Err` value untouched.\n+    ///\n+    /// This function can be used to compose the results of two functions.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Sum the lines of a buffer by mapping strings to numbers,\n+    /// ignoring I/O and parse errors:\n+    ///\n+    /// ~~~\n+    /// use std::io::{BufReader, IoResult};\n+    ///\n+    /// let buffer = \"1\\n2\\n3\\n4\\n\";\n+    /// let mut reader = BufReader::new(buffer.as_bytes());\n+    ///\n+    /// let mut sum = 0;\n+    ///\n+    /// while !reader.eof() {\n+    ///     let line: IoResult<~str> = reader.read_line();\n+    ///     // Convert the string line to a number using `map` and `from_str`\n+    ///     let val: IoResult<int> = line.map(|line| {\n+    ///         from_str::<int>(line).unwrap_or(0)\n+    ///     });\n+    ///     // Add the value if there were no errors, otherwise add 0\n+    ///     sum += val.ok().unwrap_or(0);\n+    /// }\n+    /// ~~~\n+    #[inline]\n+    pub fn map<U>(self, op: |T| -> U) -> Result<U,E> {\n+        match self {\n+          Ok(t) => Ok(op(t)),\n+          Err(e) => Err(e)\n+        }\n+    }\n+\n+    /// Maps a `Result<T, E>` to `Result<T, F>` by applying a function to an\n+    /// contained `Err` value, leaving an `Ok` value untouched.\n+    ///\n+    /// This function can be used to pass through a successful result while handling\n+    /// an error.\n+    #[inline]\n+    pub fn map_err<F>(self, op: |E| -> F) -> Result<T,F> {\n+        match self {\n+          Ok(t) => Ok(t),\n+          Err(e) => Err(op(e))\n+        }\n+    }\n+\n+    ////////////////////////////////////////////////////////////////////////\n+    // Boolean operations on the values, eager and lazy\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n+    #[inline]\n+    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n+        match self {\n+            Ok(_) => res,\n+            Err(e) => Err(e),\n+        }\n+    }\n+\n+    /// Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n+    ///\n+    /// This function can be used for control flow based on result values\n+    #[inline]\n+    pub fn and_then<U>(self, op: |T| -> Result<U, E>) -> Result<U, E> {\n+        match self {\n+            Ok(t) => op(t),\n+            Err(e) => Err(e),\n+        }\n+    }\n+\n+    /// Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n+    #[inline]\n+    pub fn or(self, res: Result<T, E>) -> Result<T, E> {\n+        match self {\n+            Ok(_) => self,\n+            Err(_) => res,\n+        }\n+    }\n+\n+    /// Calls `op` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n+    ///\n+    /// This function can be used for control flow based on result values\n+    #[inline]\n+    pub fn or_else<F>(self, op: |E| -> Result<T, F>) -> Result<T, F> {\n+        match self {\n+            Ok(t) => Ok(t),\n+            Err(e) => op(e),\n+        }\n+    }\n+\n+    /// Unwraps a result, yielding the content of an `Ok`.\n+    /// Else it returns `optb`.\n+    #[inline]\n+    pub fn unwrap_or(self, optb: T) -> T {\n+        match self {\n+            Ok(t) => t,\n+            Err(_) => optb\n+        }\n+    }\n+\n+    /// Unwraps a result, yielding the content of an `Ok`.\n+    /// If the value is an `Err` then it calls `op` with its value.\n+    #[inline]\n+    pub fn unwrap_or_handle(self, op: |E| -> T) -> T {\n+        match self {\n+            Ok(t) => t,\n+            Err(e) => op(e)\n+        }\n+    }\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// Free functions\n+/////////////////////////////////////////////////////////////////////////////\n+\n+/// Takes each element in the `Iterator`: if it is an `Err`, no further\n+/// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n+/// vector containing the values of each `Result` is returned.\n+///\n+/// Here is an example which increments every integer in a vector,\n+/// checking for overflow:\n+///\n+///     fn inc_conditionally(x: uint) -> Result<uint, &'static str> {\n+///         if x == uint::MAX { return Err(\"overflow\"); }\n+///         else { return Ok(x+1u); }\n+///     }\n+///     let v = [1u, 2, 3];\n+///     let res = collect(v.iter().map(|&x| inc_conditionally(x)));\n+///     assert!(res == Ok(~[2u, 3, 4]));\n+#[inline]\n+pub fn collect<T, E, Iter: Iterator<Result<T, E>>, V: FromIterator<T>>(iter: Iter) -> Result<V, E> {\n+    // FIXME(#11084): This should be twice as fast once this bug is closed.\n+    let mut iter = iter.scan(None, |state, x| {\n+        match x {\n+            Ok(x) => Some(x),\n+            Err(err) => {\n+                *state = Some(err);\n+                None\n+            }\n+        }\n+    });\n+\n+    let v: V = FromIterator::from_iter(iter.by_ref());\n+\n+    match iter.state {\n+        Some(err) => Err(err),\n+        None => Ok(v),\n+    }\n+}\n+\n+/// Perform a fold operation over the result values from an iterator.\n+///\n+/// If an `Err` is encountered, it is immediately returned.\n+/// Otherwise, the folded value is returned.\n+#[inline]\n+pub fn fold<T,\n+            V,\n+            E,\n+            Iter: Iterator<Result<T, E>>>(\n+            mut iterator: Iter,\n+            mut init: V,\n+            f: |V, T| -> V)\n+            -> Result<V, E> {\n+    for t in iterator {\n+        match t {\n+            Ok(v) => init = f(init, v),\n+            Err(u) => return Err(u)\n+        }\n+    }\n+    Ok(init)\n+}\n+\n+/// Perform a trivial fold operation over the result values\n+/// from an iterator.\n+///\n+/// If an `Err` is encountered, it is immediately returned.\n+/// Otherwise, a simple `Ok(())` is returned.\n+#[inline]\n+pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n+    fold(iterator, (), |_, _| ())\n+}\n+\n+/////////////////////////////////////////////////////////////////////////////\n+// Tests\n+/////////////////////////////////////////////////////////////////////////////\n+\n+#[cfg(test)]\n+mod tests {\n+    use realstd::result::{collect, fold, fold_};\n+    use realstd::prelude::*;\n+    use realstd::iter::range;\n+\n+    pub fn op1() -> Result<int, ~str> { Ok(666) }\n+    pub fn op2() -> Result<int, ~str> { Err(\"sadface\".to_owned()) }\n+\n+    #[test]\n+    pub fn test_and() {\n+        assert_eq!(op1().and(Ok(667)).unwrap(), 667);\n+        assert_eq!(op1().and(Err::<(), ~str>(\"bad\".to_owned())).unwrap_err(), \"bad\".to_owned());\n+\n+        assert_eq!(op2().and(Ok(667)).unwrap_err(), \"sadface\".to_owned());\n+        assert_eq!(op2().and(Err::<(), ~str>(\"bad\".to_owned())).unwrap_err(), \"sadface\".to_owned());\n+    }\n+\n+    #[test]\n+    pub fn test_and_then() {\n+        assert_eq!(op1().and_then(|i| Ok::<int, ~str>(i + 1)).unwrap(), 667);\n+        assert_eq!(op1().and_then(|_| Err::<int, ~str>(\"bad\".to_owned())).unwrap_err(),\n+                   \"bad\".to_owned());\n+\n+        assert_eq!(op2().and_then(|i| Ok::<int, ~str>(i + 1)).unwrap_err(),\n+                   \"sadface\".to_owned());\n+        assert_eq!(op2().and_then(|_| Err::<int, ~str>(\"bad\".to_owned())).unwrap_err(),\n+                   \"sadface\".to_owned());\n+    }\n+\n+    #[test]\n+    pub fn test_or() {\n+        assert_eq!(op1().or(Ok(667)).unwrap(), 666);\n+        assert_eq!(op1().or(Err(\"bad\".to_owned())).unwrap(), 666);\n+\n+        assert_eq!(op2().or(Ok(667)).unwrap(), 667);\n+        assert_eq!(op2().or(Err(\"bad\".to_owned())).unwrap_err(), \"bad\".to_owned());\n+    }\n+\n+    #[test]\n+    pub fn test_or_else() {\n+        assert_eq!(op1().or_else(|_| Ok::<int, ~str>(667)).unwrap(), 666);\n+        assert_eq!(op1().or_else(|e| Err::<int, ~str>(e + \"!\")).unwrap(), 666);\n+\n+        assert_eq!(op2().or_else(|_| Ok::<int, ~str>(667)).unwrap(), 667);\n+        assert_eq!(op2().or_else(|e| Err::<int, ~str>(e + \"!\")).unwrap_err(),\n+                   \"sadface!\".to_owned());\n+    }\n+\n+    #[test]\n+    pub fn test_impl_map() {\n+        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"), Ok(\"ab\".to_owned()));\n+        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"), Err(\"a\".to_owned()));\n+    }\n+\n+    #[test]\n+    pub fn test_impl_map_err() {\n+        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"), Ok(\"a\".to_owned()));\n+        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"), Err(\"ab\".to_owned()));\n+    }\n+\n+    #[test]\n+    fn test_collect() {\n+        let v: Result<~[int], ()> = collect(range(0, 0).map(|_| Ok::<int, ()>(0)));\n+        assert_eq!(v, Ok(box []));\n+\n+        let v: Result<~[int], ()> = collect(range(0, 3).map(|x| Ok::<int, ()>(x)));\n+        assert_eq!(v, Ok(box [0, 1, 2]));\n+\n+        let v: Result<~[int], int> = collect(range(0, 3)\n+                                             .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n+        assert_eq!(v, Err(2));\n+\n+        // test that it does not take more elements than it needs\n+        let mut functions = [|| Ok(()), || Err(1), || fail!()];\n+\n+        let v: Result<~[()], int> = collect(functions.mut_iter().map(|f| (*f)()));\n+        assert_eq!(v, Err(1));\n+    }\n+\n+    #[test]\n+    fn test_fold() {\n+        assert_eq!(fold_(range(0, 0)\n+                        .map(|_| Ok::<(), ()>(()))),\n+                   Ok(()));\n+        assert_eq!(fold(range(0, 3)\n+                        .map(|x| Ok::<int, ()>(x)),\n+                        0, |a, b| a + b),\n+                   Ok(3));\n+        assert_eq!(fold_(range(0, 3)\n+                        .map(|x| if x > 1 { Err(x) } else { Ok(()) })),\n+                   Err(2));\n+\n+        // test that it does not take more elements than it needs\n+        let mut functions = [|| Ok(()), || Err(1), || fail!()];\n+\n+        assert_eq!(fold_(functions.mut_iter()\n+                        .map(|f| (*f)())),\n+                   Err(1));\n+    }\n+\n+    #[test]\n+    pub fn test_to_str() {\n+        let ok: Result<int, ~str> = Ok(100);\n+        let err: Result<int, ~str> = Err(\"Err\".to_owned());\n+\n+        assert_eq!(ok.to_str(), \"Ok(100)\".to_owned());\n+        assert_eq!(err.to_str(), \"Err(Err)\".to_owned());\n+    }\n+\n+    #[test]\n+    pub fn test_fmt_default() {\n+        let ok: Result<int, ~str> = Ok(100);\n+        let err: Result<int, ~str> = Err(\"Err\".to_owned());\n+\n+        assert_eq!(format!(\"{}\", ok), \"Ok(100)\".to_owned());\n+        assert_eq!(format!(\"{}\", err), \"Err(Err)\".to_owned());\n+    }\n+\n+    #[test]\n+    pub fn test_unwrap_or() {\n+        let ok: Result<int, ~str> = Ok(100);\n+        let ok_err: Result<int, ~str> = Err(\"Err\".to_owned());\n+\n+        assert_eq!(ok.unwrap_or(50), 100);\n+        assert_eq!(ok_err.unwrap_or(50), 50);\n+    }\n+\n+    #[test]\n+    pub fn test_unwrap_or_else() {\n+        fn handler(msg: ~str) -> int {\n+            if msg == \"I got this.\".to_owned() {\n+                50\n+            } else {\n+                fail!(\"BadBad\")\n+            }\n+        }\n+\n+        let ok: Result<int, ~str> = Ok(100);\n+        let ok_err: Result<int, ~str> = Err(\"I got this.\".to_owned());\n+\n+        assert_eq!(ok.unwrap_or_handle(handler), 100);\n+        assert_eq!(ok_err.unwrap_or_handle(handler), 50);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    pub fn test_unwrap_or_else_failure() {\n+        fn handler(msg: ~str) -> int {\n+            if msg == \"I got this.\".to_owned() {\n+                50\n+            } else {\n+                fail!(\"BadBad\")\n+            }\n+        }\n+\n+        let bad_err: Result<int, ~str> = Err(\"Unrecoverable mess.\".to_owned());\n+        let _ : int = bad_err.unwrap_or_handle(handler);\n+    }\n+}"}, {"sha": "50447f0c5b375cb1e7a5591780106186cbce1e82", "filename": "src/libcore/should_not_exist.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fshould_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fshould_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fshould_not_exist.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,202 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cast;\n+use char::Char;\n+use clone::Clone;\n+use container::Container;\n+use default::Default;\n+use intrinsics;\n+use iter::{Iterator, FromIterator};\n+use mem;\n+use num::{CheckedMul, CheckedAdd};\n+use option::{Some, None};\n+use ptr::RawPtr;\n+use ptr;\n+use raw::Vec;\n+use slice::ImmutableVector;\n+use str::StrSlice;\n+\n+#[cfg(not(test))] use ops::Add;\n+#[cfg(not(test))] use slice::Vector;\n+\n+#[allow(ctypes)]\n+extern {\n+    fn malloc(size: uint) -> *u8;\n+    fn free(ptr: *u8);\n+}\n+\n+unsafe fn alloc(cap: uint) -> *mut Vec<()> {\n+    let cap = cap.checked_add(&mem::size_of::<Vec<()>>()).unwrap();\n+    let ret = malloc(cap) as *mut Vec<()>;\n+    if ret.is_null() {\n+        intrinsics::abort();\n+    }\n+    (*ret).fill = 0;\n+    (*ret).alloc = cap;\n+    ret\n+}\n+\n+// Strings\n+\n+impl Default for ~str {\n+    fn default() -> ~str {\n+        unsafe {\n+            // Get some memory\n+            let ptr = alloc(0);\n+\n+            // Initialize the memory\n+            (*ptr).fill = 0;\n+            (*ptr).alloc = 0;\n+\n+            cast::transmute(ptr)\n+        }\n+    }\n+}\n+\n+impl Clone for ~str {\n+    fn clone(&self) -> ~str {\n+        // Don't use the clone() implementation above because it'll start\n+        // requiring the eh_personality lang item (no fun)\n+        unsafe {\n+            let bytes = self.as_bytes().as_ptr();\n+            let len = self.len();\n+\n+            let ptr = alloc(len) as *mut Vec<u8>;\n+            ptr::copy_nonoverlapping_memory(&mut (*ptr).data, bytes, len);\n+            (*ptr).fill = len;\n+            (*ptr).alloc = len;\n+\n+            cast::transmute(ptr)\n+        }\n+    }\n+}\n+\n+impl FromIterator<char> for ~str {\n+    #[inline]\n+    fn from_iter<T: Iterator<char>>(mut iterator: T) -> ~str {\n+        let (lower, _) = iterator.size_hint();\n+        let mut cap = if lower == 0 {16} else {lower};\n+        let mut len = 0;\n+        let mut tmp = [0u8, ..4];\n+\n+        unsafe {\n+            let mut ptr = alloc(cap) as *mut Vec<u8>;\n+            let mut ret = cast::transmute(ptr);\n+            for ch in iterator {\n+                let amt = ch.encode_utf8(tmp);\n+\n+                if len + amt > cap {\n+                    cap = cap.checked_mul(&2).unwrap();\n+                    if cap < len + amt {\n+                        cap = len + amt;\n+                    }\n+                    let ptr2 = alloc(cap) as *mut Vec<u8>;\n+                    ptr::copy_nonoverlapping_memory(&mut (*ptr2).data,\n+                                                    &(*ptr).data,\n+                                                    len);\n+                    free(ptr as *u8);\n+                    cast::forget(ret);\n+                    ret = cast::transmute(ptr2);\n+                    ptr = ptr2;\n+                }\n+\n+                let base = &mut (*ptr).data as *mut u8;\n+                for byte in tmp.slice_to(amt).iter() {\n+                    *base.offset(len as int) = *byte;\n+                    len += 1;\n+                }\n+                (*ptr).fill = len;\n+            }\n+            ret\n+        }\n+    }\n+}\n+\n+#[cfg(not(test))]\n+impl<'a> Add<&'a str,~str> for &'a str {\n+    #[inline]\n+    fn add(&self, rhs: & &'a str) -> ~str {\n+        let amt = self.len().checked_add(&rhs.len()).unwrap();\n+        unsafe {\n+            let ptr = alloc(amt) as *mut Vec<u8>;\n+            let base = &mut (*ptr).data as *mut _;\n+            ptr::copy_nonoverlapping_memory(base,\n+                                            self.as_bytes().as_ptr(),\n+                                            self.len());\n+            let base = base.offset(self.len() as int);\n+            ptr::copy_nonoverlapping_memory(base,\n+                                            rhs.as_bytes().as_ptr(),\n+                                            rhs.len());\n+            (*ptr).fill = amt;\n+            (*ptr).alloc = amt;\n+            cast::transmute(ptr)\n+        }\n+    }\n+}\n+\n+// Arrays\n+\n+impl<A: Clone> Clone for ~[A] {\n+    #[inline]\n+    fn clone(&self) -> ~[A] {\n+        self.iter().map(|a| a.clone()).collect()\n+    }\n+}\n+\n+impl<A> FromIterator<A> for ~[A] {\n+    fn from_iter<T: Iterator<A>>(mut iterator: T) -> ~[A] {\n+        let (lower, _) = iterator.size_hint();\n+        let cap = if lower == 0 {16} else {lower};\n+        let mut cap = cap.checked_mul(&mem::size_of::<A>()).unwrap();\n+        let mut len = 0;\n+\n+        unsafe {\n+            let mut ptr = alloc(cap) as *mut Vec<A>;\n+            let mut ret = cast::transmute(ptr);\n+            for elt in iterator {\n+                if len * mem::size_of::<A>() >= cap {\n+                    cap = cap.checked_mul(&2).unwrap();\n+                    let ptr2 = alloc(cap) as *mut Vec<A>;\n+                    ptr::copy_nonoverlapping_memory(&mut (*ptr2).data,\n+                                                    &(*ptr).data,\n+                                                    len);\n+                    free(ptr as *u8);\n+                    cast::forget(ret);\n+                    ret = cast::transmute(ptr2);\n+                    ptr = ptr2;\n+                }\n+\n+                let base = &mut (*ptr).data as *mut A;\n+                intrinsics::move_val_init(&mut *base.offset(len as int), elt);\n+                len += 1;\n+                (*ptr).fill = len * mem::nonzero_size_of::<A>();\n+            }\n+            ret\n+        }\n+    }\n+}\n+\n+#[cfg(not(test))]\n+impl<'a,T:Clone, V: Vector<T>> Add<V, ~[T]> for &'a [T] {\n+    #[inline]\n+    fn add(&self, rhs: &V) -> ~[T] {\n+        let first = self.iter().map(|t| t.clone());\n+        first.chain(rhs.as_slice().iter().map(|t| t.clone())).collect()\n+    }\n+}\n+\n+#[cfg(not(test))]\n+impl<T:Clone, V: Vector<T>> Add<V, ~[T]> for ~[T] {\n+    #[inline]\n+    fn add(&self, rhs: &V) -> ~[T] {\n+        self.as_slice() + rhs.as_slice()\n+    }\n+}"}, {"sha": "b828ad3361effbab67a7201cee2476daea64f7d1", "filename": "src/libcore/slice.rs", "status": "added", "additions": 1483, "deletions": 0, "changes": 1483, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,1483 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Slice management and manipulation\n+//!\n+//! For more details `std::slice`.\n+\n+use cast;\n+use cast::transmute;\n+use clone::Clone;\n+use container::Container;\n+use cmp::{Eq, TotalOrd, Ordering, Less, Equal, Greater};\n+use cmp;\n+use default::Default;\n+use iter::*;\n+use num::{CheckedAdd, Saturating, div_rem};\n+use option::{None, Option, Some};\n+use ptr;\n+use ptr::RawPtr;\n+use mem;\n+use mem::size_of;\n+use kinds::marker;\n+use raw::{Repr, Slice};\n+\n+/**\n+ * Converts a pointer to A into a slice of length 1 (without copying).\n+ */\n+pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n+    unsafe {\n+        transmute(Slice { data: s, len: 1 })\n+    }\n+}\n+\n+/**\n+ * Converts a pointer to A into a slice of length 1 (without copying).\n+ */\n+pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n+    unsafe {\n+        let ptr: *A = transmute(s);\n+        transmute(Slice { data: ptr, len: 1 })\n+    }\n+}\n+\n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function.\n+pub struct Splits<'a, T> {\n+    v: &'a [T],\n+    pred: |t: &T|: 'a -> bool,\n+    finished: bool\n+}\n+\n+impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.finished { return None; }\n+\n+        match self.v.iter().position(|x| (self.pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                Some(self.v)\n+            }\n+            Some(idx) => {\n+                let ret = Some(self.v.slice(0, idx));\n+                self.v = self.v.slice(idx + 1, self.v.len());\n+                ret\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            (1, Some(self.v.len() + 1))\n+        }\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.finished { return None; }\n+\n+        match self.v.iter().rposition(|x| (self.pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                Some(self.v)\n+            }\n+            Some(idx) => {\n+                let ret = Some(self.v.slice(idx + 1, self.v.len()));\n+                self.v = self.v.slice(0, idx);\n+                ret\n+            }\n+        }\n+    }\n+}\n+\n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function, splitting at most a fixed number of times.\n+pub struct SplitsN<'a, T> {\n+    iter: Splits<'a, T>,\n+    count: uint,\n+    invert: bool\n+}\n+\n+impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.count == 0 {\n+            if self.iter.finished {\n+                None\n+            } else {\n+                self.iter.finished = true;\n+                Some(self.iter.v)\n+            }\n+        } else {\n+            self.count -= 1;\n+            if self.invert { self.iter.next_back() } else { self.iter.next() }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.iter.finished {\n+            (0, Some(0))\n+        } else {\n+            (1, Some(cmp::min(self.count, self.iter.v.len()) + 1))\n+        }\n+    }\n+}\n+\n+// Functional utilities\n+\n+/// An iterator over the (overlapping) slices of length `size` within\n+/// a vector.\n+#[deriving(Clone)]\n+pub struct Windows<'a, T> {\n+    v: &'a [T],\n+    size: uint\n+}\n+\n+impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.size > self.v.len() {\n+            None\n+        } else {\n+            let ret = Some(self.v.slice(0, self.size));\n+            self.v = self.v.slice(1, self.v.len());\n+            ret\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.size > self.v.len() {\n+            (0, Some(0))\n+        } else {\n+            let x = self.v.len() - self.size;\n+            (x.saturating_add(1), x.checked_add(&1u))\n+        }\n+    }\n+}\n+\n+/// An iterator over a vector in (non-overlapping) chunks (`size`\n+/// elements at a time).\n+///\n+/// When the vector len is not evenly divided by the chunk size,\n+/// the last slice of the iteration will be the remainder.\n+#[deriving(Clone)]\n+pub struct Chunks<'a, T> {\n+    v: &'a [T],\n+    size: uint\n+}\n+\n+impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let chunksz = cmp::min(self.v.len(), self.size);\n+            let (fst, snd) = (self.v.slice_to(chunksz),\n+                              self.v.slice_from(chunksz));\n+            self.v = snd;\n+            Some(fst)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.v.len() == 0 {\n+            (0, Some(0))\n+        } else {\n+            let (n, rem) = div_rem(self.v.len(), self.size);\n+            let n = if rem > 0 { n+1 } else { n };\n+            (n, Some(n))\n+        }\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.size;\n+            let chunksz = if remainder != 0 { remainder } else { self.size };\n+            let (fst, snd) = (self.v.slice_to(self.v.len() - chunksz),\n+                              self.v.slice_from(self.v.len() - chunksz));\n+            self.v = fst;\n+            Some(snd)\n+        }\n+    }\n+}\n+\n+impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n+    }\n+\n+    #[inline]\n+    fn idx(&mut self, index: uint) -> Option<&'a [T]> {\n+        if index < self.indexable() {\n+            let lo = index * self.size;\n+            let mut hi = lo + self.size;\n+            if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n+\n+            Some(self.v.slice(lo, hi))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+// Equality\n+\n+#[cfg(not(test))]\n+#[allow(missing_doc)]\n+pub mod traits {\n+    use super::*;\n+\n+    use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Equiv};\n+    use iter::{order, Iterator};\n+    use container::Container;\n+\n+    impl<'a,T:Eq> Eq for &'a [T] {\n+        fn eq(&self, other: & &'a [T]) -> bool {\n+            self.len() == other.len() &&\n+                order::eq(self.iter(), other.iter())\n+        }\n+        fn ne(&self, other: & &'a [T]) -> bool {\n+            self.len() != other.len() ||\n+                order::ne(self.iter(), other.iter())\n+        }\n+    }\n+\n+    impl<T:Eq> Eq for ~[T] {\n+        #[inline]\n+        fn eq(&self, other: &~[T]) -> bool { self.as_slice() == *other }\n+        #[inline]\n+        fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n+    }\n+\n+    impl<'a,T:TotalEq> TotalEq for &'a [T] {}\n+\n+    impl<T:TotalEq> TotalEq for ~[T] {}\n+\n+    impl<'a,T:Eq, V: Vector<T>> Equiv<V> for &'a [T] {\n+        #[inline]\n+        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+    }\n+\n+    impl<'a,T:Eq, V: Vector<T>> Equiv<V> for ~[T] {\n+        #[inline]\n+        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+    }\n+\n+    impl<'a,T:TotalOrd> TotalOrd for &'a [T] {\n+        fn cmp(&self, other: & &'a [T]) -> Ordering {\n+            order::cmp(self.iter(), other.iter())\n+        }\n+    }\n+\n+    impl<T: TotalOrd> TotalOrd for ~[T] {\n+        #[inline]\n+        fn cmp(&self, other: &~[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n+\n+    impl<'a, T: Ord> Ord for &'a [T] {\n+        fn lt(&self, other: & &'a [T]) -> bool {\n+            order::lt(self.iter(), other.iter())\n+        }\n+        #[inline]\n+        fn le(&self, other: & &'a [T]) -> bool {\n+            order::le(self.iter(), other.iter())\n+        }\n+        #[inline]\n+        fn ge(&self, other: & &'a [T]) -> bool {\n+            order::ge(self.iter(), other.iter())\n+        }\n+        #[inline]\n+        fn gt(&self, other: & &'a [T]) -> bool {\n+            order::gt(self.iter(), other.iter())\n+        }\n+    }\n+\n+    impl<T: Ord> Ord for ~[T] {\n+        #[inline]\n+        fn lt(&self, other: &~[T]) -> bool { self.as_slice() < other.as_slice() }\n+        #[inline]\n+        fn le(&self, other: &~[T]) -> bool { self.as_slice() <= other.as_slice() }\n+        #[inline]\n+        fn ge(&self, other: &~[T]) -> bool { self.as_slice() >= other.as_slice() }\n+        #[inline]\n+        fn gt(&self, other: &~[T]) -> bool { self.as_slice() > other.as_slice() }\n+    }\n+}\n+\n+#[cfg(test)]\n+pub mod traits {}\n+\n+/// Any vector that can be represented as a slice.\n+pub trait Vector<T> {\n+    /// Work with `self` as a slice.\n+    fn as_slice<'a>(&'a self) -> &'a [T];\n+}\n+\n+impl<'a,T> Vector<T> for &'a [T] {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n+}\n+\n+impl<T> Vector<T> for ~[T] {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n+}\n+\n+impl<'a, T> Container for &'a [T] {\n+    /// Returns the length of a vector\n+    #[inline]\n+    fn len(&self) -> uint {\n+        self.repr().len\n+    }\n+}\n+\n+impl<T> Container for ~[T] {\n+    /// Returns the length of a vector\n+    #[inline]\n+    fn len(&self) -> uint {\n+        self.as_slice().len()\n+    }\n+}\n+\n+/// Extension methods for vectors\n+pub trait ImmutableVector<'a, T> {\n+    /**\n+     * Returns a slice of self between `start` and `end`.\n+     *\n+     * Fails when `start` or `end` point outside the bounds of self,\n+     * or when `start` > `end`.\n+     */\n+    fn slice(&self, start: uint, end: uint) -> &'a [T];\n+\n+    /**\n+     * Returns a slice of self from `start` to the end of the vec.\n+     *\n+     * Fails when `start` points outside the bounds of self.\n+     */\n+    fn slice_from(&self, start: uint) -> &'a [T];\n+\n+    /**\n+     * Returns a slice of self from the start of the vec to `end`.\n+     *\n+     * Fails when `end` points outside the bounds of self.\n+     */\n+    fn slice_to(&self, end: uint) -> &'a [T];\n+    /// Returns an iterator over the vector\n+    fn iter(self) -> Items<'a, T>;\n+    /// Returns a reversed iterator over a vector\n+    #[deprecated = \"replaced by .iter().rev()\"]\n+    fn rev_iter(self) -> Rev<Items<'a, T>>;\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`.  The matched element\n+    /// is not contained in the subslices.\n+    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`, limited to splitting\n+    /// at most `n` times.  The matched element is not contained in\n+    /// the subslices.\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`. This starts at the\n+    /// end of the vector and works backwards.  The matched element is\n+    /// not contained in the subslices.\n+    #[deprecated = \"replaced by .split(pred).rev()\"]\n+    fn rsplit(self, pred: |&T|: 'a -> bool) -> Rev<Splits<'a, T>>;\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred` limited to splitting\n+    /// at most `n` times. This starts at the end of the vector and\n+    /// works backwards.  The matched element is not contained in the\n+    /// subslices.\n+    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n+\n+    /**\n+     * Returns an iterator over all contiguous windows of length\n+     * `size`. The windows overlap. If the vector is shorter than\n+     * `size`, the iterator returns no values.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     *\n+     * # Example\n+     *\n+     * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`,\n+     * `[3,4]`):\n+     *\n+     * ```rust\n+     * let v = &[1,2,3,4];\n+     * for win in v.windows(2) {\n+     *     println!(\"{:?}\", win);\n+     * }\n+     * ```\n+     *\n+     */\n+    fn windows(self, size: uint) -> Windows<'a, T>;\n+    /**\n+     *\n+     * Returns an iterator over `size` elements of the vector at a\n+     * time. The chunks do not overlap. If `size` does not divide the\n+     * length of the vector, then the last chunk will not have length\n+     * `size`.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     *\n+     * # Example\n+     *\n+     * Print the vector two elements at a time (i.e. `[1,2]`,\n+     * `[3,4]`, `[5]`):\n+     *\n+     * ```rust\n+     * let v = &[1,2,3,4,5];\n+     * for win in v.chunks(2) {\n+     *     println!(\"{:?}\", win);\n+     * }\n+     * ```\n+     *\n+     */\n+    fn chunks(self, size: uint) -> Chunks<'a, T>;\n+\n+    /// Returns the element of a vector at the given index, or `None` if the\n+    /// index is out of bounds\n+    fn get(&self, index: uint) -> Option<&'a T>;\n+    /// Returns the first element of a vector, or `None` if it is empty\n+    fn head(&self) -> Option<&'a T>;\n+    /// Returns all but the first element of a vector\n+    fn tail(&self) -> &'a [T];\n+    /// Returns all but the first `n' elements of a vector\n+    fn tailn(&self, n: uint) -> &'a [T];\n+    /// Returns all but the last element of a vector\n+    fn init(&self) -> &'a [T];\n+    /// Returns all but the last `n' elements of a vector\n+    fn initn(&self, n: uint) -> &'a [T];\n+    /// Returns the last element of a vector, or `None` if it is empty.\n+    fn last(&self) -> Option<&'a T>;\n+\n+    /// Returns a pointer to the element at the given index, without doing\n+    /// bounds checking.\n+    unsafe fn unsafe_ref(self, index: uint) -> &'a T;\n+\n+    /**\n+     * Returns an unsafe pointer to the vector's buffer\n+     *\n+     * The caller must ensure that the vector outlives the pointer this\n+     * function returns, or else it will end up pointing to garbage.\n+     *\n+     * Modifying the vector may cause its buffer to be reallocated, which\n+     * would also make any pointers to it invalid.\n+     */\n+    fn as_ptr(&self) -> *T;\n+\n+    /**\n+     * Binary search a sorted vector with a comparator function.\n+     *\n+     * The comparator function should implement an order consistent\n+     * with the sort order of the underlying vector, returning an\n+     * order code that indicates whether its argument is `Less`,\n+     * `Equal` or `Greater` the desired target.\n+     *\n+     * Returns the index where the comparator returned `Equal`, or `None` if\n+     * not found.\n+     */\n+    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n+\n+    /**\n+     * Returns a mutable reference to the first element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```ignore\n+     *     if self.len() == 0 { return None }\n+     *     let head = &self[0];\n+     *     *self = self.slice_from(1);\n+     *     Some(head)\n+     * ```\n+     *\n+     * Returns `None` if vector is empty\n+     */\n+    fn shift_ref(&mut self) -> Option<&'a T>;\n+\n+    /**\n+     * Returns a mutable reference to the last element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```ignore\n+     *     if self.len() == 0 { return None; }\n+     *     let tail = &self[self.len() - 1];\n+     *     *self = self.slice_to(self.len() - 1);\n+     *     Some(tail)\n+     * ```\n+     *\n+     * Returns `None` if slice is empty.\n+     */\n+    fn pop_ref(&mut self) -> Option<&'a T>;\n+}\n+\n+impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n+    #[inline]\n+    fn slice(&self, start: uint, end: uint) -> &'a [T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        unsafe {\n+            transmute(Slice {\n+                    data: self.as_ptr().offset(start as int),\n+                    len: (end - start)\n+                })\n+        }\n+    }\n+\n+    #[inline]\n+    fn slice_from(&self, start: uint) -> &'a [T] {\n+        self.slice(start, self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to(&self, end: uint) -> &'a [T] {\n+        self.slice(0, end)\n+    }\n+\n+    #[inline]\n+    fn iter(self) -> Items<'a, T> {\n+        unsafe {\n+            let p = self.as_ptr();\n+            if mem::size_of::<T>() == 0 {\n+                Items{ptr: p,\n+                      end: (p as uint + self.len()) as *T,\n+                      marker: marker::ContravariantLifetime::<'a>}\n+            } else {\n+                Items{ptr: p,\n+                      end: p.offset(self.len() as int),\n+                      marker: marker::ContravariantLifetime::<'a>}\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"replaced by .iter().rev()\"]\n+    fn rev_iter(self) -> Rev<Items<'a, T>> {\n+        self.iter().rev()\n+    }\n+\n+    #[inline]\n+    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n+        Splits {\n+            v: self,\n+            pred: pred,\n+            finished: false\n+        }\n+    }\n+\n+    #[inline]\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n+        SplitsN {\n+            iter: self.split(pred),\n+            count: n,\n+            invert: false\n+        }\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"replaced by .split(pred).rev()\"]\n+    fn rsplit(self, pred: |&T|: 'a -> bool) -> Rev<Splits<'a, T>> {\n+        self.split(pred).rev()\n+    }\n+\n+    #[inline]\n+    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n+        SplitsN {\n+            iter: self.split(pred),\n+            count: n,\n+            invert: true\n+        }\n+    }\n+\n+    #[inline]\n+    fn windows(self, size: uint) -> Windows<'a, T> {\n+        assert!(size != 0);\n+        Windows { v: self, size: size }\n+    }\n+\n+    #[inline]\n+    fn chunks(self, size: uint) -> Chunks<'a, T> {\n+        assert!(size != 0);\n+        Chunks { v: self, size: size }\n+    }\n+\n+    #[inline]\n+    fn get(&self, index: uint) -> Option<&'a T> {\n+        if index < self.len() { Some(&self[index]) } else { None }\n+    }\n+\n+    #[inline]\n+    fn head(&self) -> Option<&'a T> {\n+        if self.len() == 0 { None } else { Some(&self[0]) }\n+    }\n+\n+    #[inline]\n+    fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }\n+\n+    #[inline]\n+    fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }\n+\n+    #[inline]\n+    fn init(&self) -> &'a [T] {\n+        self.slice(0, self.len() - 1)\n+    }\n+\n+    #[inline]\n+    fn initn(&self, n: uint) -> &'a [T] {\n+        self.slice(0, self.len() - n)\n+    }\n+\n+    #[inline]\n+    fn last(&self) -> Option<&'a T> {\n+            if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n+    }\n+\n+    #[inline]\n+    unsafe fn unsafe_ref(self, index: uint) -> &'a T {\n+        transmute(self.repr().data.offset(index as int))\n+    }\n+\n+    #[inline]\n+    fn as_ptr(&self) -> *T {\n+        self.repr().data\n+    }\n+\n+\n+    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n+        let mut base : uint = 0;\n+        let mut lim : uint = self.len();\n+\n+        while lim != 0 {\n+            let ix = base + (lim >> 1);\n+            match f(&self[ix]) {\n+                Equal => return Some(ix),\n+                Less => {\n+                    base = ix + 1;\n+                    lim -= 1;\n+                }\n+                Greater => ()\n+            }\n+            lim >>= 1;\n+        }\n+        return None;\n+    }\n+\n+    fn shift_ref(&mut self) -> Option<&'a T> {\n+        if self.len() == 0 { return None; }\n+        unsafe {\n+            let s: &mut Slice<T> = transmute(self);\n+            Some(&*raw::shift_ptr(s))\n+        }\n+    }\n+\n+    fn pop_ref(&mut self) -> Option<&'a T> {\n+        if self.len() == 0 { return None; }\n+        unsafe {\n+            let s: &mut Slice<T> = transmute(self);\n+            Some(&*raw::pop_ptr(s))\n+        }\n+    }\n+}\n+\n+/// Extension methods for vectors contain `Eq` elements.\n+pub trait ImmutableEqVector<T:Eq> {\n+    /// Find the first index containing a matching value\n+    fn position_elem(&self, t: &T) -> Option<uint>;\n+\n+    /// Find the last index containing a matching value\n+    fn rposition_elem(&self, t: &T) -> Option<uint>;\n+\n+    /// Return true if a vector contains an element with the given value\n+    fn contains(&self, x: &T) -> bool;\n+\n+    /// Returns true if `needle` is a prefix of the vector.\n+    fn starts_with(&self, needle: &[T]) -> bool;\n+\n+    /// Returns true if `needle` is a suffix of the vector.\n+    fn ends_with(&self, needle: &[T]) -> bool;\n+}\n+\n+impl<'a,T:Eq> ImmutableEqVector<T> for &'a [T] {\n+    #[inline]\n+    fn position_elem(&self, x: &T) -> Option<uint> {\n+        self.iter().position(|y| *x == *y)\n+    }\n+\n+    #[inline]\n+    fn rposition_elem(&self, t: &T) -> Option<uint> {\n+        self.iter().rposition(|x| *x == *t)\n+    }\n+\n+    #[inline]\n+    fn contains(&self, x: &T) -> bool {\n+        self.iter().any(|elt| *x == *elt)\n+    }\n+\n+    #[inline]\n+    fn starts_with(&self, needle: &[T]) -> bool {\n+        let n = needle.len();\n+        self.len() >= n && needle == self.slice_to(n)\n+    }\n+\n+    #[inline]\n+    fn ends_with(&self, needle: &[T]) -> bool {\n+        let (m, n) = (self.len(), needle.len());\n+        m >= n && needle == self.slice_from(m - n)\n+    }\n+}\n+\n+/// Extension methods for vectors containing `TotalOrd` elements.\n+pub trait ImmutableTotalOrdVector<T: TotalOrd> {\n+    /**\n+     * Binary search a sorted vector for a given element.\n+     *\n+     * Returns the index of the element or None if not found.\n+     */\n+    fn bsearch_elem(&self, x: &T) -> Option<uint>;\n+}\n+\n+impl<'a, T: TotalOrd> ImmutableTotalOrdVector<T> for &'a [T] {\n+    fn bsearch_elem(&self, x: &T) -> Option<uint> {\n+        self.bsearch(|p| p.cmp(x))\n+    }\n+}\n+\n+/// Extension methods for vectors such that their elements are\n+/// mutable.\n+pub trait MutableVector<'a, T> {\n+    /// Work with `self` as a mut slice.\n+    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n+    fn as_mut_slice(self) -> &'a mut [T];\n+\n+    /// Return a slice that points into another slice.\n+    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T];\n+\n+    /**\n+     * Returns a slice of self from `start` to the end of the vec.\n+     *\n+     * Fails when `start` points outside the bounds of self.\n+     */\n+    fn mut_slice_from(self, start: uint) -> &'a mut [T];\n+\n+    /**\n+     * Returns a slice of self from the start of the vec to `end`.\n+     *\n+     * Fails when `end` points outside the bounds of self.\n+     */\n+    fn mut_slice_to(self, end: uint) -> &'a mut [T];\n+\n+    /// Returns an iterator that allows modifying each value\n+    fn mut_iter(self) -> MutItems<'a, T>;\n+\n+    /// Returns a mutable pointer to the last item in the vector.\n+    fn mut_last(self) -> Option<&'a mut T>;\n+\n+    /// Returns a reversed iterator that allows modifying each value\n+    #[deprecated = \"replaced by .mut_iter().rev()\"]\n+    fn mut_rev_iter(self) -> Rev<MutItems<'a, T>>;\n+\n+    /// Returns an iterator over the mutable subslices of the vector\n+    /// which are separated by elements that match `pred`.  The\n+    /// matched element is not contained in the subslices.\n+    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;\n+\n+    /**\n+     * Returns an iterator over `size` elements of the vector at a time.\n+     * The chunks are mutable and do not overlap. If `size` does not divide the\n+     * length of the vector, then the last chunk will not have length\n+     * `size`.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     */\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T>;\n+\n+    /**\n+     * Returns a mutable reference to the first element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```ignore\n+     *     if self.len() == 0 { return None; }\n+     *     let head = &mut self[0];\n+     *     *self = self.mut_slice_from(1);\n+     *     Some(head)\n+     * ```\n+     *\n+     * Returns `None` if slice is empty\n+     */\n+    fn mut_shift_ref(&mut self) -> Option<&'a mut T>;\n+\n+    /**\n+     * Returns a mutable reference to the last element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```ignore\n+     *     if self.len() == 0 { return None; }\n+     *     let tail = &mut self[self.len() - 1];\n+     *     *self = self.mut_slice_to(self.len() - 1);\n+     *     Some(tail)\n+     * ```\n+     *\n+     * Returns `None` if slice is empty.\n+     */\n+    fn mut_pop_ref(&mut self) -> Option<&'a mut T>;\n+\n+    /// Swaps two elements in a vector.\n+    ///\n+    /// Fails if `a` or `b` are out of bounds.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * a - The index of the first element\n+    /// * b - The index of the second element\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n+    /// v.swap(1, 3);\n+    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// ```\n+    fn swap(self, a: uint, b: uint);\n+\n+\n+    /// Divides one `&mut` into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// Fails if `mid > len`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1, 2, 3, 4, 5, 6];\n+    ///\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// {\n+    ///    let (left, right) = v.mut_split_at(0);\n+    ///    assert!(left == &mut []);\n+    ///    assert!(right == &mut [1, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.mut_split_at(2);\n+    ///     assert!(left == &mut [1, 2]);\n+    ///     assert!(right == &mut [3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.mut_split_at(6);\n+    ///     assert!(left == &mut [1, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == &mut []);\n+    /// }\n+    /// ```\n+    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n+\n+    /// Reverse the order of elements in a vector, in place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1, 2, 3];\n+    /// v.reverse();\n+    /// assert!(v == [3, 2, 1]);\n+    /// ```\n+    fn reverse(self);\n+\n+    /// Returns an unsafe mutable pointer to the element in index\n+    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T;\n+\n+    /// Return an unsafe mutable pointer to the vector's buffer.\n+    ///\n+    /// The caller must ensure that the vector outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the vector may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[inline]\n+    fn as_mut_ptr(self) -> *mut T;\n+\n+    /// Unsafely sets the element in index to the value.\n+    ///\n+    /// This performs no bounds checks, and it is undefined behaviour\n+    /// if `index` is larger than the length of `self`. However, it\n+    /// does run the destructor at `index`. It is equivalent to\n+    /// `self[index] = val`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = ~[\"foo\".to_owned(), \"bar\".to_owned(), \"baz\".to_owned()];\n+    ///\n+    /// unsafe {\n+    ///     // `\"baz\".to_owned()` is deallocated.\n+    ///     v.unsafe_set(2, \"qux\".to_owned());\n+    ///\n+    ///     // Out of bounds: could cause a crash, or overwriting\n+    ///     // other data, or something else.\n+    ///     // v.unsafe_set(10, \"oops\".to_owned());\n+    /// }\n+    /// ```\n+    unsafe fn unsafe_set(self, index: uint, val: T);\n+\n+    /// Unchecked vector index assignment.  Does not drop the\n+    /// old value and hence is only suitable when the vector\n+    /// is newly allocated.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"foo\".to_owned(), \"bar\".to_owned()];\n+    ///\n+    /// // memory leak! `\"bar\".to_owned()` is not deallocated.\n+    /// unsafe { v.init_elem(1, \"baz\".to_owned()); }\n+    /// ```\n+    unsafe fn init_elem(self, i: uint, val: T);\n+\n+    /// Copies raw bytes from `src` to `self`.\n+    ///\n+    /// This does not run destructors on the overwritten elements, and\n+    /// ignores move semantics. `self` and `src` must not\n+    /// overlap. Fails if `self` is shorter than `src`.\n+    unsafe fn copy_memory(self, src: &[T]);\n+}\n+\n+impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n+    #[inline]\n+    fn as_mut_slice(self) -> &'a mut [T] { self }\n+\n+    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        unsafe {\n+            transmute(Slice {\n+                    data: self.as_mut_ptr().offset(start as int) as *T,\n+                    len: (end - start)\n+                })\n+        }\n+    }\n+\n+    #[inline]\n+    fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n+        let len = self.len();\n+        self.mut_slice(start, len)\n+    }\n+\n+    #[inline]\n+    fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n+        self.mut_slice(0, end)\n+    }\n+\n+    #[inline]\n+    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n+        unsafe {\n+            let len = self.len();\n+            let self2: &'a mut [T] = cast::transmute_copy(&self);\n+            (self.mut_slice(0, mid), self2.mut_slice(mid, len))\n+        }\n+    }\n+\n+    #[inline]\n+    fn mut_iter(self) -> MutItems<'a, T> {\n+        unsafe {\n+            let p = self.as_mut_ptr();\n+            if mem::size_of::<T>() == 0 {\n+                MutItems{ptr: p,\n+                         end: (p as uint + self.len()) as *mut T,\n+                         marker: marker::ContravariantLifetime::<'a>,\n+                         marker2: marker::NoCopy}\n+            } else {\n+                MutItems{ptr: p,\n+                         end: p.offset(self.len() as int),\n+                         marker: marker::ContravariantLifetime::<'a>,\n+                         marker2: marker::NoCopy}\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn mut_last(self) -> Option<&'a mut T> {\n+        let len = self.len();\n+        if len == 0 { return None; }\n+        Some(&mut self[len - 1])\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"replaced by .mut_iter().rev()\"]\n+    fn mut_rev_iter(self) -> Rev<MutItems<'a, T>> {\n+        self.mut_iter().rev()\n+    }\n+\n+    #[inline]\n+    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n+        MutSplits { v: self, pred: pred, finished: false }\n+    }\n+\n+    #[inline]\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T> {\n+        assert!(chunk_size > 0);\n+        MutChunks { v: self, chunk_size: chunk_size }\n+    }\n+\n+    fn mut_shift_ref(&mut self) -> Option<&'a mut T> {\n+        if self.len() == 0 { return None; }\n+        unsafe {\n+            let s: &mut Slice<T> = transmute(self);\n+            // FIXME #13933: this `&` -> `&mut` cast is a little\n+            // dubious\n+            Some(&mut *(raw::shift_ptr(s) as *mut _))\n+        }\n+    }\n+\n+    fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n+        if self.len() == 0 { return None; }\n+        unsafe {\n+            let s: &mut Slice<T> = transmute(self);\n+            // FIXME #13933: this `&` -> `&mut` cast is a little\n+            // dubious\n+            Some(&mut *(raw::pop_ptr(s) as *mut _))\n+        }\n+    }\n+\n+    fn swap(self, a: uint, b: uint) {\n+        unsafe {\n+            // Can't take two mutable loans from one vector, so instead just cast\n+            // them to their raw pointers to do the swap\n+            let pa: *mut T = &mut self[a];\n+            let pb: *mut T = &mut self[b];\n+            ptr::swap(pa, pb);\n+        }\n+    }\n+\n+    fn reverse(self) {\n+        let mut i: uint = 0;\n+        let ln = self.len();\n+        while i < ln / 2 {\n+            self.swap(i, ln - i - 1);\n+            i += 1;\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T {\n+        transmute((self.repr().data as *mut T).offset(index as int))\n+    }\n+\n+    #[inline]\n+    fn as_mut_ptr(self) -> *mut T {\n+        self.repr().data as *mut T\n+    }\n+\n+    #[inline]\n+    unsafe fn unsafe_set(self, index: uint, val: T) {\n+        *self.unsafe_mut_ref(index) = val;\n+    }\n+\n+    #[inline]\n+    unsafe fn init_elem(self, i: uint, val: T) {\n+        mem::move_val_init(&mut (*self.as_mut_ptr().offset(i as int)), val);\n+    }\n+\n+    #[inline]\n+    unsafe fn copy_memory(self, src: &[T]) {\n+        let len_src = src.len();\n+        assert!(self.len() >= len_src);\n+        ptr::copy_nonoverlapping_memory(self.as_mut_ptr(), src.as_ptr(), len_src)\n+    }\n+}\n+\n+/// Trait for &[T] where T is Cloneable\n+pub trait MutableCloneableVector<T> {\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::slice::MutableCloneableVector;\n+    ///\n+    /// let mut dst = [0, 0, 0];\n+    /// let src = [1, 2];\n+    ///\n+    /// assert!(dst.copy_from(src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n+    ///\n+    /// let src2 = [3, 4, 5, 6];\n+    /// assert!(dst.copy_from(src2) == 3);\n+    /// assert!(dst == [3, 4, 5]);\n+    /// ```\n+    fn copy_from(self, &[T]) -> uint;\n+}\n+\n+impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n+    #[inline]\n+    fn copy_from(self, src: &[T]) -> uint {\n+        for (a, b) in self.mut_iter().zip(src.iter()) {\n+            a.clone_from(b);\n+        }\n+        cmp::min(self.len(), src.len())\n+    }\n+}\n+\n+/// Unsafe operations\n+pub mod raw {\n+    use cast::transmute;\n+    use iter::Iterator;\n+    use ptr::RawPtr;\n+    use raw::Slice;\n+\n+    /**\n+     * Form a slice from a pointer and length (as a number of units,\n+     * not bytes).\n+     */\n+    #[inline]\n+    pub unsafe fn buf_as_slice<T,U>(p: *T, len: uint, f: |v: &[T]| -> U)\n+                               -> U {\n+        f(transmute(Slice {\n+            data: p,\n+            len: len\n+        }))\n+    }\n+\n+    /**\n+     * Form a slice from a pointer and length (as a number of units,\n+     * not bytes).\n+     */\n+    #[inline]\n+    pub unsafe fn mut_buf_as_slice<T,\n+                                   U>(\n+                                   p: *mut T,\n+                                   len: uint,\n+                                   f: |v: &mut [T]| -> U)\n+                                   -> U {\n+        f(transmute(Slice {\n+            data: p as *T,\n+            len: len\n+        }))\n+    }\n+\n+    /**\n+     * Returns a pointer to first element in slice and adjusts\n+     * slice so it no longer contains that element. Fails if\n+     * slice is empty. O(1).\n+     */\n+    pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> *T {\n+        if slice.len == 0 { fail!(\"shift on empty slice\"); }\n+        let head: *T = slice.data;\n+        slice.data = slice.data.offset(1);\n+        slice.len -= 1;\n+        head\n+    }\n+\n+    /**\n+     * Returns a pointer to last element in slice and adjusts\n+     * slice so it no longer contains that element. Fails if\n+     * slice is empty. O(1).\n+     */\n+    pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> *T {\n+        if slice.len == 0 { fail!(\"pop on empty slice\"); }\n+        let tail: *T = slice.data.offset((slice.len - 1) as int);\n+        slice.len -= 1;\n+        tail\n+    }\n+}\n+\n+/// Operations on `[u8]`.\n+pub mod bytes {\n+    use container::Container;\n+    use ptr;\n+    use slice::MutableVector;\n+\n+    /// A trait for operations on mutable `[u8]`s.\n+    pub trait MutableByteVector {\n+        /// Sets all bytes of the receiver to the given value.\n+        fn set_memory(self, value: u8);\n+    }\n+\n+    impl<'a> MutableByteVector for &'a mut [u8] {\n+        #[inline]\n+        fn set_memory(self, value: u8) {\n+            unsafe { ptr::set_memory(self.as_mut_ptr(), value, self.len()) };\n+        }\n+    }\n+\n+    /// Copies data from `src` to `dst`\n+    ///\n+    /// `src` and `dst` must not overlap. Fails if the length of `dst`\n+    /// is less than the length of `src`.\n+    #[inline]\n+    pub fn copy_memory(dst: &mut [u8], src: &[u8]) {\n+        // Bound checks are done at .copy_memory.\n+        unsafe { dst.copy_memory(src) }\n+    }\n+}\n+\n+/// Immutable slice iterator\n+pub struct Items<'a, T> {\n+    ptr: *T,\n+    end: *T,\n+    marker: marker::ContravariantLifetime<'a>\n+}\n+\n+/// Mutable slice iterator\n+pub struct MutItems<'a, T> {\n+    ptr: *mut T,\n+    end: *mut T,\n+    marker: marker::ContravariantLifetime<'a>,\n+    marker2: marker::NoCopy\n+}\n+\n+macro_rules! iterator {\n+    (struct $name:ident -> $ptr:ty, $elem:ty) => {\n+        impl<'a, T> Iterator<$elem> for $name<'a, T> {\n+            #[inline]\n+            fn next(&mut self) -> Option<$elem> {\n+                // could be implemented with slices, but this avoids bounds checks\n+                unsafe {\n+                    if self.ptr == self.end {\n+                        None\n+                    } else {\n+                        let old = self.ptr;\n+                        self.ptr = if mem::size_of::<T>() == 0 {\n+                            // purposefully don't use 'ptr.offset' because for\n+                            // vectors with 0-size elements this would return the\n+                            // same pointer.\n+                            transmute(self.ptr as uint + 1)\n+                        } else {\n+                            self.ptr.offset(1)\n+                        };\n+\n+                        Some(transmute(old))\n+                    }\n+                }\n+            }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                let diff = (self.end as uint) - (self.ptr as uint);\n+                let exact = diff / mem::nonzero_size_of::<T>();\n+                (exact, Some(exact))\n+            }\n+        }\n+\n+        impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$elem> {\n+                // could be implemented with slices, but this avoids bounds checks\n+                unsafe {\n+                    if self.end == self.ptr {\n+                        None\n+                    } else {\n+                        self.end = if mem::size_of::<T>() == 0 {\n+                            // See above for why 'ptr.offset' isn't used\n+                            transmute(self.end as uint - 1)\n+                        } else {\n+                            self.end.offset(-1)\n+                        };\n+                        Some(transmute(self.end))\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        let (exact, _) = self.size_hint();\n+        exact\n+    }\n+\n+    #[inline]\n+    fn idx(&mut self, index: uint) -> Option<&'a T> {\n+        unsafe {\n+            if index < self.indexable() {\n+                transmute(self.ptr.offset(index as int))\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+iterator!{struct Items -> *T, &'a T}\n+#[deprecated = \"replaced by Rev<Items<'a, T>>\"]\n+pub type RevItems<'a, T> = Rev<Items<'a, T>>;\n+\n+impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n+\n+impl<'a, T> Clone for Items<'a, T> {\n+    fn clone(&self) -> Items<'a, T> { *self }\n+}\n+\n+iterator!{struct MutItems -> *mut T, &'a mut T}\n+#[deprecated = \"replaced by Rev<MutItems<'a, T>>\"]\n+pub type RevMutItems<'a, T> = Rev<MutItems<'a, T>>;\n+\n+/// An iterator over the subslices of the vector which are separated\n+/// by elements that match `pred`.\n+pub struct MutSplits<'a, T> {\n+    v: &'a mut [T],\n+    pred: |t: &T|: 'a -> bool,\n+    finished: bool\n+}\n+\n+impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished { return None; }\n+\n+        let pred = &mut self.pred;\n+        match self.v.iter().position(|x| (*pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let len = tmp.len();\n+                let (head, tail) = tmp.mut_split_at(len);\n+                self.v = tail;\n+                Some(head)\n+            }\n+            Some(idx) => {\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let (head, tail) = tmp.mut_split_at(idx);\n+                self.v = tail.mut_slice_from(1);\n+                Some(head)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            // if the predicate doesn't match anything, we yield one slice\n+            // if it matches every element, we yield len+1 empty slices.\n+            (1, Some(self.v.len() + 1))\n+        }\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished { return None; }\n+\n+        let pred = &mut self.pred;\n+        match self.v.iter().rposition(|x| (*pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                Some(tmp)\n+            }\n+            Some(idx) => {\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let (head, tail) = tmp.mut_split_at(idx);\n+                self.v = head;\n+                Some(tail.mut_slice_from(1))\n+            }\n+        }\n+    }\n+}\n+\n+/// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n+/// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n+/// the remainder.\n+pub struct MutChunks<'a, T> {\n+    v: &'a mut [T],\n+    chunk_size: uint\n+}\n+\n+impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let sz = cmp::min(self.v.len(), self.chunk_size);\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.mut_split_at(sz);\n+            self.v = tail;\n+            Some(head)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.v.len() == 0 {\n+            (0, Some(0))\n+        } else {\n+            let (n, rem) = div_rem(self.v.len(), self.chunk_size);\n+            let n = if rem > 0 { n + 1 } else { n };\n+            (n, Some(n))\n+        }\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.chunk_size;\n+            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let tmp_len = tmp.len();\n+            let (head, tail) = tmp.mut_split_at(tmp_len - sz);\n+            self.v = head;\n+            Some(tail)\n+        }\n+    }\n+}\n+\n+impl<'a, T> Default for &'a [T] {\n+    fn default() -> &'a [T] { &[] }\n+}\n+\n+impl<T> Default for ~[T] {\n+    fn default() -> ~[T] { ~[] }\n+}"}, {"sha": "9d9e12d0ad594c52629bc5e34bf3c9680ab201e9", "filename": "src/libcore/str.rs", "status": "added", "additions": 1861, "deletions": 0, "changes": 1861, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -0,0 +1,1861 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! String manipulation\n+//!\n+//! For more details, see std::str\n+\n+use cast::transmute;\n+use cast;\n+use char;\n+use clone::Clone;\n+use cmp::{Eq, TotalEq};\n+use container::Container;\n+use default::Default;\n+use iter::{Filter, Map, Iterator};\n+use iter::{Rev, DoubleEndedIterator, ExactSize};\n+use num::Saturating;\n+use option::{None, Option, Some};\n+use raw::Repr;\n+use slice::{ImmutableVector, Vector};\n+use slice;\n+\n+/*\n+Section: Creating a string\n+*/\n+\n+/// Converts a vector to a string slice without performing any allocations.\n+///\n+/// Once the slice has been validated as utf-8, it is transmuted in-place and\n+/// returned as a '&str' instead of a '&[u8]'\n+///\n+/// Returns None if the slice is not utf-8.\n+pub fn from_utf8<'a>(v: &'a [u8]) -> Option<&'a str> {\n+    if is_utf8(v) {\n+        Some(unsafe { raw::from_utf8(v) })\n+    } else { None }\n+}\n+\n+/// Something that can be used to compare against a character\n+pub trait CharEq {\n+    /// Determine if the splitter should split at the given character\n+    fn matches(&mut self, char) -> bool;\n+    /// Indicate if this is only concerned about ASCII characters,\n+    /// which can allow for a faster implementation.\n+    fn only_ascii(&self) -> bool;\n+}\n+\n+impl CharEq for char {\n+    #[inline]\n+    fn matches(&mut self, c: char) -> bool { *self == c }\n+\n+    #[inline]\n+    fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n+}\n+\n+impl<'a> CharEq for |char|: 'a -> bool {\n+    #[inline]\n+    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n+\n+    #[inline]\n+    fn only_ascii(&self) -> bool { false }\n+}\n+\n+impl CharEq for extern \"Rust\" fn(char) -> bool {\n+    #[inline]\n+    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n+\n+    #[inline]\n+    fn only_ascii(&self) -> bool { false }\n+}\n+\n+impl<'a> CharEq for &'a [char] {\n+    #[inline]\n+    fn matches(&mut self, c: char) -> bool {\n+        self.iter().any(|&mut m| m.matches(c))\n+    }\n+\n+    #[inline]\n+    fn only_ascii(&self) -> bool {\n+        self.iter().all(|m| m.only_ascii())\n+    }\n+}\n+\n+/*\n+Section: Iterators\n+*/\n+\n+/// External iterator for a string's characters.\n+/// Use with the `std::iter` module.\n+#[deriving(Clone)]\n+pub struct Chars<'a> {\n+    /// The slice remaining to be iterated\n+    string: &'a str,\n+}\n+\n+impl<'a> Iterator<char> for Chars<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<char> {\n+        // Decode the next codepoint, then update\n+        // the slice to be just the remaining part\n+        if self.string.len() != 0 {\n+            let CharRange {ch, next} = self.string.char_range_at(0);\n+            unsafe {\n+                self.string = raw::slice_unchecked(self.string, next, self.string.len());\n+            }\n+            Some(ch)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.string.len().saturating_add(3)/4, Some(self.string.len()))\n+    }\n+}\n+\n+impl<'a> DoubleEndedIterator<char> for Chars<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<char> {\n+        if self.string.len() != 0 {\n+            let CharRange {ch, next} = self.string.char_range_at_reverse(self.string.len());\n+            unsafe {\n+                self.string = raw::slice_unchecked(self.string, 0, next);\n+            }\n+            Some(ch)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// External iterator for a string's characters and their byte offsets.\n+/// Use with the `std::iter` module.\n+#[deriving(Clone)]\n+pub struct CharOffsets<'a> {\n+    /// The original string to be iterated\n+    string: &'a str,\n+    iter: Chars<'a>,\n+}\n+\n+impl<'a> Iterator<(uint, char)> for CharOffsets<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(uint, char)> {\n+        // Compute the byte offset by using the pointer offset between\n+        // the original string slice and the iterator's remaining part\n+        let offset = self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n+        self.iter.next().map(|ch| (offset, ch))\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(uint, char)> {\n+        self.iter.next_back().map(|ch| {\n+            let offset = self.iter.string.len() +\n+                    self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n+            (offset, ch)\n+        })\n+    }\n+}\n+\n+#[deprecated = \"replaced by Rev<Chars<'a>>\"]\n+pub type RevChars<'a> = Rev<Chars<'a>>;\n+\n+#[deprecated = \"replaced by Rev<CharOffsets<'a>>\"]\n+pub type RevCharOffsets<'a> = Rev<CharOffsets<'a>>;\n+\n+/// External iterator for a string's bytes.\n+/// Use with the `std::iter` module.\n+pub type Bytes<'a> =\n+    Map<'a, &'a u8, u8, slice::Items<'a, u8>>;\n+\n+#[deprecated = \"replaced by Rev<Bytes<'a>>\"]\n+pub type RevBytes<'a> = Rev<Bytes<'a>>;\n+\n+/// An iterator over the substrings of a string, separated by `sep`.\n+#[deriving(Clone)]\n+pub struct CharSplits<'a, Sep> {\n+    /// The slice remaining to be iterated\n+    string: &'a str,\n+    sep: Sep,\n+    /// Whether an empty string at the end is allowed\n+    allow_trailing_empty: bool,\n+    only_ascii: bool,\n+    finished: bool,\n+}\n+\n+#[deprecated = \"replaced by Rev<CharSplits<'a, Sep>>\"]\n+pub type RevCharSplits<'a, Sep> = Rev<CharSplits<'a, Sep>>;\n+\n+/// An iterator over the substrings of a string, separated by `sep`,\n+/// splitting at most `count` times.\n+#[deriving(Clone)]\n+pub struct CharSplitsN<'a, Sep> {\n+    iter: CharSplits<'a, Sep>,\n+    /// The number of splits remaining\n+    count: uint,\n+    invert: bool,\n+}\n+\n+/// An iterator over the words of a string, separated by a sequence of whitespace\n+pub type Words<'a> =\n+    Filter<'a, &'a str, CharSplits<'a, extern \"Rust\" fn(char) -> bool>>;\n+\n+/// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n+pub type AnyLines<'a> =\n+    Map<'a, &'a str, &'a str, CharSplits<'a, char>>;\n+\n+impl<'a, Sep> CharSplits<'a, Sep> {\n+    #[inline]\n+    fn get_end(&mut self) -> Option<&'a str> {\n+        if !self.finished && (self.allow_trailing_empty || self.string.len() > 0) {\n+            self.finished = true;\n+            Some(self.string)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplits<'a, Sep> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        if self.finished { return None }\n+\n+        let mut next_split = None;\n+        if self.only_ascii {\n+            for (idx, byte) in self.string.bytes().enumerate() {\n+                if self.sep.matches(byte as char) && byte < 128u8 {\n+                    next_split = Some((idx, idx + 1));\n+                    break;\n+                }\n+            }\n+        } else {\n+            for (idx, ch) in self.string.char_indices() {\n+                if self.sep.matches(ch) {\n+                    next_split = Some((idx, self.string.char_range_at(idx).next));\n+                    break;\n+                }\n+            }\n+        }\n+        match next_split {\n+            Some((a, b)) => unsafe {\n+                let elt = raw::slice_unchecked(self.string, 0, a);\n+                self.string = raw::slice_unchecked(self.string, b, self.string.len());\n+                Some(elt)\n+            },\n+            None => self.get_end(),\n+        }\n+    }\n+}\n+\n+impl<'a, Sep: CharEq> DoubleEndedIterator<&'a str>\n+for CharSplits<'a, Sep> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        if self.finished { return None }\n+\n+        if !self.allow_trailing_empty {\n+            self.allow_trailing_empty = true;\n+            match self.next_back() {\n+                Some(elt) if !elt.is_empty() => return Some(elt),\n+                _ => if self.finished { return None }\n+            }\n+        }\n+        let len = self.string.len();\n+        let mut next_split = None;\n+\n+        if self.only_ascii {\n+            for (idx, byte) in self.string.bytes().enumerate().rev() {\n+                if self.sep.matches(byte as char) && byte < 128u8 {\n+                    next_split = Some((idx, idx + 1));\n+                    break;\n+                }\n+            }\n+        } else {\n+            for (idx, ch) in self.string.char_indices().rev() {\n+                if self.sep.matches(ch) {\n+                    next_split = Some((idx, self.string.char_range_at(idx).next));\n+                    break;\n+                }\n+            }\n+        }\n+        match next_split {\n+            Some((a, b)) => unsafe {\n+                let elt = raw::slice_unchecked(self.string, b, len);\n+                self.string = raw::slice_unchecked(self.string, 0, a);\n+                Some(elt)\n+            },\n+            None => { self.finished = true; Some(self.string) }\n+        }\n+    }\n+}\n+\n+impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplitsN<'a, Sep> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        if self.count != 0 {\n+            self.count -= 1;\n+            if self.invert { self.iter.next_back() } else { self.iter.next() }\n+        } else {\n+            self.iter.get_end()\n+        }\n+    }\n+}\n+\n+/// An iterator over the start and end indices of the matches of a\n+/// substring within a larger string\n+#[deriving(Clone)]\n+pub struct MatchIndices<'a> {\n+    haystack: &'a str,\n+    needle: &'a str,\n+    position: uint,\n+}\n+\n+/// An iterator over the substrings of a string separated by a given\n+/// search string\n+#[deriving(Clone)]\n+pub struct StrSplits<'a> {\n+    it: MatchIndices<'a>,\n+    last_end: uint,\n+    finished: bool\n+}\n+\n+impl<'a> Iterator<(uint, uint)> for MatchIndices<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(uint, uint)> {\n+        // See Issue #1932 for why this is a naive search\n+        let (h_len, n_len) = (self.haystack.len(), self.needle.len());\n+        let mut match_start = 0;\n+        let mut match_i = 0;\n+\n+        while self.position < h_len {\n+            if self.haystack[self.position] == self.needle[match_i] {\n+                if match_i == 0 { match_start = self.position; }\n+                match_i += 1;\n+                self.position += 1;\n+\n+                if match_i == n_len {\n+                    // found a match!\n+                    return Some((match_start, self.position));\n+                }\n+            } else {\n+                // failed match, backtrack\n+                if match_i > 0 {\n+                    match_i = 0;\n+                    self.position = match_start;\n+                }\n+                self.position += 1;\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'a> Iterator<&'a str> for StrSplits<'a> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        if self.finished { return None; }\n+\n+        match self.it.next() {\n+            Some((from, to)) => {\n+                let ret = Some(self.it.haystack.slice(self.last_end, from));\n+                self.last_end = to;\n+                ret\n+            }\n+            None => {\n+                self.finished = true;\n+                Some(self.it.haystack.slice(self.last_end, self.it.haystack.len()))\n+            }\n+        }\n+    }\n+}\n+\n+/*\n+Section: Comparing strings\n+*/\n+\n+// share the implementation of the lang-item vs. non-lang-item\n+// eq_slice.\n+#[inline]\n+fn eq_slice_(a: &str, b: &str) -> bool {\n+    #[allow(ctypes)]\n+    extern { fn memcmp(s1: *i8, s2: *i8, n: uint) -> i32; }\n+    a.len() == b.len() && unsafe {\n+        memcmp(a.as_ptr() as *i8,\n+               b.as_ptr() as *i8,\n+               a.len()) == 0\n+    }\n+}\n+\n+/// Bytewise slice equality\n+#[cfg(not(test))]\n+#[lang=\"str_eq\"]\n+#[inline]\n+pub fn eq_slice(a: &str, b: &str) -> bool {\n+    eq_slice_(a, b)\n+}\n+\n+/// Bytewise slice equality\n+#[cfg(test)]\n+#[inline]\n+pub fn eq_slice(a: &str, b: &str) -> bool {\n+    eq_slice_(a, b)\n+}\n+\n+/// Bytewise string equality\n+#[cfg(not(test))]\n+#[lang=\"uniq_str_eq\"]\n+#[inline]\n+pub fn eq(a: &~str, b: &~str) -> bool {\n+    eq_slice(*a, *b)\n+}\n+\n+#[cfg(test)]\n+#[inline]\n+pub fn eq(a: &~str, b: &~str) -> bool {\n+    eq_slice(*a, *b)\n+}\n+\n+/*\n+Section: Misc\n+*/\n+\n+/// Walk through `iter` checking that it's a valid UTF-8 sequence,\n+/// returning `true` in that case, or, if it is invalid, `false` with\n+/// `iter` reset such that it is pointing at the first byte in the\n+/// invalid sequence.\n+#[inline(always)]\n+fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool {\n+    loop {\n+        // save the current thing we're pointing at.\n+        let old = *iter;\n+\n+        // restore the iterator we had at the start of this codepoint.\n+        macro_rules! err ( () => { {*iter = old; return false} });\n+        macro_rules! next ( () => {\n+                match iter.next() {\n+                    Some(a) => *a,\n+                    // we needed data, but there was none: error!\n+                    None => err!()\n+                }\n+            });\n+\n+        let first = match iter.next() {\n+            Some(&b) => b,\n+            // we're at the end of the iterator and a codepoint\n+            // boundary at the same time, so this string is valid.\n+            None => return true\n+        };\n+\n+        // ASCII characters are always valid, so only large\n+        // bytes need more examination.\n+        if first >= 128 {\n+            let w = utf8_char_width(first);\n+            let second = next!();\n+            // 2-byte encoding is for codepoints  \\u0080 to  \\u07ff\n+            //        first  C2 80        last DF BF\n+            // 3-byte encoding is for codepoints  \\u0800 to  \\uffff\n+            //        first  E0 A0 80     last EF BF BF\n+            //   excluding surrogates codepoints  \\ud800 to  \\udfff\n+            //               ED A0 80 to       ED BF BF\n+            // 4-byte encoding is for codepoints \\u10000 to \\u10ffff\n+            //        first  F0 90 80 80  last F4 8F BF BF\n+            //\n+            // Use the UTF-8 syntax from the RFC\n+            //\n+            // https://tools.ietf.org/html/rfc3629\n+            // UTF8-1      = %x00-7F\n+            // UTF8-2      = %xC2-DF UTF8-tail\n+            // UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /\n+            //               %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )\n+            // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n+            //               %xF4 %x80-8F 2( UTF8-tail )\n+            match w {\n+                2 => if second & 192 != TAG_CONT_U8 {err!()},\n+                3 => {\n+                    match (first, second, next!() & 192) {\n+                        (0xE0        , 0xA0 .. 0xBF, TAG_CONT_U8) |\n+                        (0xE1 .. 0xEC, 0x80 .. 0xBF, TAG_CONT_U8) |\n+                        (0xED        , 0x80 .. 0x9F, TAG_CONT_U8) |\n+                        (0xEE .. 0xEF, 0x80 .. 0xBF, TAG_CONT_U8) => {}\n+                        _ => err!()\n+                    }\n+                }\n+                4 => {\n+                    match (first, second, next!() & 192, next!() & 192) {\n+                        (0xF0        , 0x90 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n+                        (0xF1 .. 0xF3, 0x80 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n+                        (0xF4        , 0x80 .. 0x8F, TAG_CONT_U8, TAG_CONT_U8) => {}\n+                        _ => err!()\n+                    }\n+                }\n+                _ => err!()\n+            }\n+        }\n+    }\n+}\n+\n+/// Determines if a vector of bytes contains valid UTF-8.\n+pub fn is_utf8(v: &[u8]) -> bool {\n+    run_utf8_validation_iterator(&mut v.iter())\n+}\n+\n+/// Determines if a vector of `u16` contains valid UTF-16\n+pub fn is_utf16(v: &[u16]) -> bool {\n+    let mut it = v.iter();\n+    macro_rules! next ( ($ret:expr) => {\n+            match it.next() { Some(u) => *u, None => return $ret }\n+        }\n+    )\n+    loop {\n+        let u = next!(true);\n+\n+        match char::from_u32(u as u32) {\n+            Some(_) => {}\n+            None => {\n+                let u2 = next!(false);\n+                if u < 0xD7FF || u > 0xDBFF ||\n+                    u2 < 0xDC00 || u2 > 0xDFFF { return false; }\n+            }\n+        }\n+    }\n+}\n+\n+/// An iterator that decodes UTF-16 encoded codepoints from a vector\n+/// of `u16`s.\n+#[deriving(Clone)]\n+pub struct UTF16Items<'a> {\n+    iter: slice::Items<'a, u16>\n+}\n+/// The possibilities for values decoded from a `u16` stream.\n+#[deriving(Eq, TotalEq, Clone)]\n+pub enum UTF16Item {\n+    /// A valid codepoint.\n+    ScalarValue(char),\n+    /// An invalid surrogate without its pair.\n+    LoneSurrogate(u16)\n+}\n+\n+impl UTF16Item {\n+    /// Convert `self` to a `char`, taking `LoneSurrogate`s to the\n+    /// replacement character (U+FFFD).\n+    #[inline]\n+    pub fn to_char_lossy(&self) -> char {\n+        match *self {\n+            ScalarValue(c) => c,\n+            LoneSurrogate(_) => '\\uFFFD'\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator<UTF16Item> for UTF16Items<'a> {\n+    fn next(&mut self) -> Option<UTF16Item> {\n+        let u = match self.iter.next() {\n+            Some(u) => *u,\n+            None => return None\n+        };\n+\n+        if u < 0xD800 || 0xDFFF < u {\n+            // not a surrogate\n+            Some(ScalarValue(unsafe {cast::transmute(u as u32)}))\n+        } else if u >= 0xDC00 {\n+            // a trailing surrogate\n+            Some(LoneSurrogate(u))\n+        } else {\n+            // preserve state for rewinding.\n+            let old = self.iter;\n+\n+            let u2 = match self.iter.next() {\n+                Some(u2) => *u2,\n+                // eof\n+                None => return Some(LoneSurrogate(u))\n+            };\n+            if u2 < 0xDC00 || u2 > 0xDFFF {\n+                // not a trailing surrogate so we're not a valid\n+                // surrogate pair, so rewind to redecode u2 next time.\n+                self.iter = old;\n+                return Some(LoneSurrogate(u))\n+            }\n+\n+            // all ok, so lets decode it.\n+            let c = ((u - 0xD800) as u32 << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n+            Some(ScalarValue(unsafe {cast::transmute(c)}))\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let (low, high) = self.iter.size_hint();\n+        // we could be entirely valid surrogates (2 elements per\n+        // char), or entirely non-surrogates (1 element per char)\n+        (low / 2, high)\n+    }\n+}\n+\n+/// Create an iterator over the UTF-16 encoded codepoints in `v`,\n+/// returning invalid surrogates as `LoneSurrogate`s.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::str;\n+/// use std::str::{ScalarValue, LoneSurrogate};\n+///\n+/// // \ud834\udd1emus<invalid>ic<invalid>\n+/// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///          0x0073, 0xDD1E, 0x0069, 0x0063,\n+///          0xD834];\n+///\n+/// assert_eq!(str::utf16_items(v).collect::<~[_]>(),\n+///            ~[ScalarValue('\ud834\udd1e'),\n+///              ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n+///              LoneSurrogate(0xDD1E),\n+///              ScalarValue('i'), ScalarValue('c'),\n+///              LoneSurrogate(0xD834)]);\n+/// ```\n+pub fn utf16_items<'a>(v: &'a [u16]) -> UTF16Items<'a> {\n+    UTF16Items { iter : v.iter() }\n+}\n+\n+/// Return a slice of `v` ending at (and not including) the first NUL\n+/// (0).\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::str;\n+///\n+/// // \"abcd\"\n+/// let mut v = ['a' as u16, 'b' as u16, 'c' as u16, 'd' as u16];\n+/// // no NULs so no change\n+/// assert_eq!(str::truncate_utf16_at_nul(v), v.as_slice());\n+///\n+/// // \"ab\\0d\"\n+/// v[2] = 0;\n+/// assert_eq!(str::truncate_utf16_at_nul(v),\n+///            &['a' as u16, 'b' as u16]);\n+/// ```\n+pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n+    match v.iter().position(|c| *c == 0) {\n+        // don't include the 0\n+        Some(i) => v.slice_to(i),\n+        None => v\n+    }\n+}\n+\n+// https://tools.ietf.org/html/rfc3629\n+static UTF8_CHAR_WIDTH: [u8, ..256] = [\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x1F\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x3F\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x5F\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x7F\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0x9F\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0xBF\n+0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0xDF\n+3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3, // 0xEF\n+4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0, // 0xFF\n+];\n+\n+/// Given a first byte, determine how many bytes are in this UTF-8 character\n+#[inline]\n+pub fn utf8_char_width(b: u8) -> uint {\n+    return UTF8_CHAR_WIDTH[b as uint] as uint;\n+}\n+\n+/// Struct that contains a `char` and the index of the first byte of\n+/// the next `char` in a string.  This can be used as a data structure\n+/// for iterating over the UTF-8 bytes of a string.\n+pub struct CharRange {\n+    /// Current `char`\n+    pub ch: char,\n+    /// Index of the first byte of the next `char`\n+    pub next: uint,\n+}\n+\n+// Return the initial codepoint accumulator for the first byte.\n+// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n+// for width 3, and 3 bits for width 4\n+macro_rules! utf8_first_byte(\n+    ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as u32)\n+)\n+\n+// return the value of $ch updated with continuation byte $byte\n+macro_rules! utf8_acc_cont_byte(\n+    ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n+)\n+\n+static TAG_CONT_U8: u8 = 128u8;\n+\n+/// Unsafe operations\n+pub mod raw {\n+    use cast;\n+    use container::Container;\n+    use iter::Iterator;\n+    use ptr::RawPtr;\n+    use raw::Slice;\n+    use slice::{ImmutableVector};\n+    use str::{is_utf8, StrSlice};\n+\n+    /// Converts a slice of bytes to a string slice without checking\n+    /// that the string contains valid UTF-8.\n+    pub unsafe fn from_utf8<'a>(v: &'a [u8]) -> &'a str {\n+        cast::transmute(v)\n+    }\n+\n+    /// Form a slice from a C string. Unsafe because the caller must ensure the\n+    /// C string has the static lifetime, or else the return value may be\n+    /// invalidated later.\n+    pub unsafe fn c_str_to_static_slice(s: *i8) -> &'static str {\n+        let s = s as *u8;\n+        let mut curr = s;\n+        let mut len = 0u;\n+        while *curr != 0u8 {\n+            len += 1u;\n+            curr = s.offset(len as int);\n+        }\n+        let v = Slice { data: s, len: len };\n+        assert!(is_utf8(::cast::transmute(v)));\n+        ::cast::transmute(v)\n+    }\n+\n+    /// Takes a bytewise (not UTF-8) slice from a string.\n+    ///\n+    /// Returns the substring from [`begin`..`end`).\n+    ///\n+    /// # Failure\n+    ///\n+    /// If begin is greater than end.\n+    /// If end is greater than the length of the string.\n+    #[inline]\n+    pub unsafe fn slice_bytes<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n+        assert!(begin <= end);\n+        assert!(end <= s.len());\n+        slice_unchecked(s, begin, end)\n+    }\n+\n+    /// Takes a bytewise (not UTF-8) slice from a string.\n+    ///\n+    /// Returns the substring from [`begin`..`end`).\n+    ///\n+    /// Caller must check slice boundaries!\n+    #[inline]\n+    pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n+        cast::transmute(Slice {\n+                data: s.as_ptr().offset(begin as int),\n+                len: end - begin,\n+            })\n+    }\n+}\n+\n+/*\n+Section: Trait implementations\n+*/\n+\n+#[cfg(not(test))]\n+#[allow(missing_doc)]\n+pub mod traits {\n+    use container::Container;\n+    use cmp::{TotalOrd, Ordering, Less, Equal, Greater, Eq, Ord, Equiv, TotalEq};\n+    use iter::Iterator;\n+    use option::{Some, None};\n+    use str::{Str, StrSlice, eq_slice};\n+\n+    impl<'a> TotalOrd for &'a str {\n+        #[inline]\n+        fn cmp(&self, other: & &'a str) -> Ordering {\n+            for (s_b, o_b) in self.bytes().zip(other.bytes()) {\n+                match s_b.cmp(&o_b) {\n+                    Greater => return Greater,\n+                    Less => return Less,\n+                    Equal => ()\n+                }\n+            }\n+\n+            self.len().cmp(&other.len())\n+        }\n+    }\n+\n+    impl TotalOrd for ~str {\n+        #[inline]\n+        fn cmp(&self, other: &~str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n+\n+    impl<'a> Eq for &'a str {\n+        #[inline]\n+        fn eq(&self, other: & &'a str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+        #[inline]\n+        fn ne(&self, other: & &'a str) -> bool { !(*self).eq(other) }\n+    }\n+\n+    impl Eq for ~str {\n+        #[inline]\n+        fn eq(&self, other: &~str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+    }\n+\n+    impl<'a> TotalEq for &'a str {}\n+\n+    impl TotalEq for ~str {}\n+\n+    impl<'a> Ord for &'a str {\n+        #[inline]\n+        fn lt(&self, other: & &'a str) -> bool { self.cmp(other) == Less }\n+    }\n+\n+    impl Ord for ~str {\n+        #[inline]\n+        fn lt(&self, other: &~str) -> bool { self.cmp(other) == Less }\n+    }\n+\n+    impl<'a, S: Str> Equiv<S> for &'a str {\n+        #[inline]\n+        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+    }\n+\n+    impl<'a, S: Str> Equiv<S> for ~str {\n+        #[inline]\n+        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+    }\n+}\n+\n+#[cfg(test)]\n+pub mod traits {}\n+\n+/// Any string that can be represented as a slice\n+pub trait Str {\n+    /// Work with `self` as a slice.\n+    fn as_slice<'a>(&'a self) -> &'a str;\n+}\n+\n+impl<'a> Str for &'a str {\n+    #[inline]\n+    fn as_slice<'a>(&'a self) -> &'a str { *self }\n+}\n+\n+impl<'a> Str for ~str {\n+    #[inline]\n+    fn as_slice<'a>(&'a self) -> &'a str { let s: &'a str = *self; s }\n+}\n+\n+impl<'a> Container for &'a str {\n+    #[inline]\n+    fn len(&self) -> uint {\n+        self.repr().len\n+    }\n+}\n+\n+impl Container for ~str {\n+    #[inline]\n+    fn len(&self) -> uint { self.as_slice().len() }\n+}\n+\n+/// Methods for string slices\n+pub trait StrSlice<'a> {\n+    /// Returns true if one string contains another\n+    ///\n+    /// # Arguments\n+    ///\n+    /// - needle - The string to look for\n+    fn contains<'a>(&self, needle: &'a str) -> bool;\n+\n+    /// Returns true if a string contains a char.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// - needle - The char to look for\n+    fn contains_char(&self, needle: char) -> bool;\n+\n+    /// An iterator over the characters of `self`. Note, this iterates\n+    /// over unicode code-points, not unicode graphemes.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[char] = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n+    /// assert_eq!(v, ~['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n+    /// ```\n+    fn chars(&self) -> Chars<'a>;\n+\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .chars().rev()\"]\n+    fn chars_rev(&self) -> Rev<Chars<'a>>;\n+\n+    /// An iterator over the bytes of `self`\n+    fn bytes(&self) -> Bytes<'a>;\n+\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .bytes().rev()\"]\n+    fn bytes_rev(&self) -> Rev<Bytes<'a>>;\n+\n+    /// An iterator over the characters of `self` and their byte offsets.\n+    fn char_indices(&self) -> CharOffsets<'a>;\n+\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .char_indices().rev()\"]\n+    fn char_indices_rev(&self) -> Rev<CharOffsets<'a>>;\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[&str] = \"Mary had a little lamb\".split(' ').collect();\n+    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    ///\n+    /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).collect();\n+    /// assert_eq!(v, ~[\"abc\", \"def\", \"ghi\"]);\n+    ///\n+    /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').collect();\n+    /// assert_eq!(v, ~[\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    /// ```\n+    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`, restricted to splitting at most `count`\n+    /// times.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[&str] = \"Mary had a little lambda\".splitn(' ', 2).collect();\n+    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a little lambda\"]);\n+    ///\n+    /// let v: ~[&str] = \"abc1def2ghi\".splitn(|c: char| c.is_digit(), 1).collect();\n+    /// assert_eq!(v, ~[\"abc\", \"def2ghi\"]);\n+    ///\n+    /// let v: ~[&str] = \"lionXXtigerXleopard\".splitn('X', 2).collect();\n+    /// assert_eq!(v, ~[\"lion\", \"\", \"tigerXleopard\"]);\n+    /// ```\n+    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`.\n+    ///\n+    /// Equivalent to `split`, except that the trailing substring\n+    /// is skipped if empty (terminator semantics).\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[&str] = \"A.B.\".split_terminator('.').collect();\n+    /// assert_eq!(v, ~[\"A\", \"B\"]);\n+    ///\n+    /// let v: ~[&str] = \"A..B..\".split_terminator('.').collect();\n+    /// assert_eq!(v, ~[\"A\", \"\", \"B\", \"\"]);\n+    ///\n+    /// let v: ~[&str] = \"Mary had a little lamb\".split(' ').rev().collect();\n+    /// assert_eq!(v, ~[\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    ///\n+    /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).rev().collect();\n+    /// assert_eq!(v, ~[\"ghi\", \"def\", \"abc\"]);\n+    ///\n+    /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').rev().collect();\n+    /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    /// ```\n+    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n+\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .split(sep).rev()\"]\n+    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> Rev<CharSplits<'a, Sep>>;\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by `sep`, starting from the end of the string.\n+    /// Restricted to splitting at most `count` times.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[&str] = \"Mary had a little lamb\".rsplitn(' ', 2).collect();\n+    /// assert_eq!(v, ~[\"lamb\", \"little\", \"Mary had a\"]);\n+    ///\n+    /// let v: ~[&str] = \"abc1def2ghi\".rsplitn(|c: char| c.is_digit(), 1).collect();\n+    /// assert_eq!(v, ~[\"ghi\", \"abc1def\"]);\n+    ///\n+    /// let v: ~[&str] = \"lionXXtigerXleopard\".rsplitn('X', 2).collect();\n+    /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"lionX\"]);\n+    /// ```\n+    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n+\n+    /// An iterator over the start and end indices of the disjoint\n+    /// matches of `sep` within `self`.\n+    ///\n+    /// That is, each returned value `(start, end)` satisfies\n+    /// `self.slice(start, end) == sep`. For matches of `sep` within\n+    /// `self` that overlap, only the indicies corresponding to the\n+    /// first match are returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[(uint, uint)] = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, ~[(0,3), (6,9), (12,15)]);\n+    ///\n+    /// let v: ~[(uint, uint)] = \"1abcabc2\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, ~[(1,4), (4,7)]);\n+    ///\n+    /// let v: ~[(uint, uint)] = \"ababa\".match_indices(\"aba\").collect();\n+    /// assert_eq!(v, ~[(0, 3)]); // only the first `aba`\n+    /// ```\n+    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a>;\n+\n+    /// An iterator over the substrings of `self` separated by `sep`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: ~[&str] = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, ~[\"\", \"XXX\", \"YYY\", \"\"]);\n+    ///\n+    /// let v: ~[&str] = \"1abcabc2\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, ~[\"1\", \"\", \"2\"]);\n+    /// ```\n+    fn split_str(&self, &'a str) -> StrSplits<'a>;\n+\n+    /// An iterator over the lines of a string (subsequences separated\n+    /// by `\\n`). This does not include the empty string after a\n+    /// trailing `\\n`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n+    /// let v: ~[&str] = four_lines.lines().collect();\n+    /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    fn lines(&self) -> CharSplits<'a, char>;\n+\n+    /// An iterator over the lines of a string, separated by either\n+    /// `\\n` or `\\r\\n`. As with `.lines()`, this does not include an\n+    /// empty trailing line.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n+    /// let v: ~[&str] = four_lines.lines_any().collect();\n+    /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    fn lines_any(&self) -> AnyLines<'a>;\n+\n+    /// An iterator over the words of a string (subsequences separated\n+    /// by any sequence of whitespace). Sequences of whitespace are\n+    /// collapsed, so empty \"words\" are not included.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n+    /// let v: ~[&str] = some_words.words().collect();\n+    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// ```\n+    fn words(&self) -> Words<'a>;\n+\n+    /// Returns true if the string contains only whitespace.\n+    ///\n+    /// Whitespace characters are determined by `char::is_whitespace`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\" \\t\\n\".is_whitespace());\n+    /// assert!(\"\".is_whitespace());\n+    ///\n+    /// assert!( !\"abc\".is_whitespace());\n+    /// ```\n+    fn is_whitespace(&self) -> bool;\n+\n+    /// Returns true if the string contains only alphanumeric code\n+    /// points.\n+    ///\n+    /// Alphanumeric characters are determined by `char::is_alphanumeric`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert!(\"L\u00f6we\u8001\u864eL\u00e9opard123\".is_alphanumeric());\n+    /// assert!(\"\".is_alphanumeric());\n+    ///\n+    /// assert!( !\" &*~\".is_alphanumeric());\n+    /// ```\n+    fn is_alphanumeric(&self) -> bool;\n+\n+    /// Returns the number of Unicode code points (`char`) that a\n+    /// string holds.\n+    ///\n+    /// This does not perform any normalization, and is `O(n)`, since\n+    /// UTF-8 is a variable width encoding of code points.\n+    ///\n+    /// *Warning*: The number of code points in a string does not directly\n+    /// correspond to the number of visible characters or width of the\n+    /// visible text due to composing characters, and double- and\n+    /// zero-width ones.\n+    ///\n+    /// See also `.len()` for the byte length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// // composed forms of `\u00f6` and `\u00e9`\n+    /// let c = \"L\u00f6we \u8001\u864e L\u00e9opard\"; // German, Simplified Chinese, French\n+    /// // decomposed forms of `\u00f6` and `\u00e9`\n+    /// let d = \"Lo\\u0308we \u8001\u864e Le\\u0301opard\";\n+    ///\n+    /// assert_eq!(c.char_len(), 15);\n+    /// assert_eq!(d.char_len(), 17);\n+    ///\n+    /// assert_eq!(c.len(), 21);\n+    /// assert_eq!(d.len(), 23);\n+    ///\n+    /// // the two strings *look* the same\n+    /// println!(\"{}\", c);\n+    /// println!(\"{}\", d);\n+    /// ```\n+    fn char_len(&self) -> uint;\n+\n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`..`end`).\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Fails when `begin` and `end` do not point to valid characters\n+    /// or point beyond the last character of the string.\n+    ///\n+    /// See also `slice_to` and `slice_from` for slicing prefixes and\n+    /// suffixes of strings, and `slice_chars` for slicing based on\n+    /// code point counts.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(s.slice(0, 1), \"L\");\n+    ///\n+    /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\");\n+    ///\n+    /// // these will fail:\n+    /// // byte 2 lies within `\u00f6`:\n+    /// // s.slice(2, 3);\n+    ///\n+    /// // byte 8 lies within `\u8001`\n+    /// // s.slice(1, 8);\n+    ///\n+    /// // byte 100 is outside the string\n+    /// // s.slice(3, 100);\n+    /// ```\n+    fn slice(&self, begin: uint, end: uint) -> &'a str;\n+\n+    /// Returns a slice of the string from `begin` to its end.\n+    ///\n+    /// Equivalent to `self.slice(begin, self.len())`.\n+    ///\n+    /// Fails when `begin` does not point to a valid character, or is\n+    /// out of bounds.\n+    ///\n+    /// See also `slice`, `slice_to` and `slice_chars`.\n+    fn slice_from(&self, begin: uint) -> &'a str;\n+\n+    /// Returns a slice of the string from the beginning to byte\n+    /// `end`.\n+    ///\n+    /// Equivalent to `self.slice(0, end)`.\n+    ///\n+    /// Fails when `end` does not point to a valid character, or is\n+    /// out of bounds.\n+    ///\n+    /// See also `slice`, `slice_from` and `slice_chars`.\n+    fn slice_to(&self, end: uint) -> &'a str;\n+\n+    /// Returns a slice of the string from the character range\n+    /// [`begin`..`end`).\n+    ///\n+    /// That is, start at the `begin`-th code point of the string and\n+    /// continue to the `end`-th code point. This does not detect or\n+    /// handle edge cases such as leaving a combining character as the\n+    /// first code point of the string.\n+    ///\n+    /// Due to the design of UTF-8, this operation is `O(end)`.\n+    /// See `slice`, `slice_to` and `slice_from` for `O(1)`\n+    /// variants that use byte indices rather than code point\n+    /// indices.\n+    ///\n+    /// Fails if `begin` > `end` or the either `begin` or `end` are\n+    /// beyond the last character of the string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n+    /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n+    /// ```\n+    fn slice_chars(&self, begin: uint, end: uint) -> &'a str;\n+\n+    /// Returns true if `needle` is a prefix of the string.\n+    fn starts_with(&self, needle: &str) -> bool;\n+\n+    /// Returns true if `needle` is a suffix of the string.\n+    fn ends_with(&self, needle: &str) -> bool;\n+\n+    /// Returns a string with leading and trailing whitespace removed.\n+    fn trim(&self) -> &'a str;\n+\n+    /// Returns a string with leading whitespace removed.\n+    fn trim_left(&self) -> &'a str;\n+\n+    /// Returns a string with trailing whitespace removed.\n+    fn trim_right(&self) -> &'a str;\n+\n+    /// Returns a string with characters that match `to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_chars(&['1', '2']), \"foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\")\n+    /// ```\n+    fn trim_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n+\n+    /// Returns a string with leading `chars_to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\")\n+    /// assert_eq!(\"12foo1bar12\".trim_left_chars(&['1', '2']), \"foo1bar12\")\n+    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\")\n+    /// ```\n+    fn trim_left_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n+\n+    /// Returns a string with trailing `chars_to_trim` removed.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * to_trim - a character matcher\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_right_chars(&['1', '2']), \"12foo1bar\")\n+    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\")\n+    /// ```\n+    fn trim_right_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n+\n+    /// Check that `index`-th byte lies at the start and/or end of a\n+    /// UTF-8 code point sequence.\n+    ///\n+    /// The start and end of the string (when `index == self.len()`)\n+    /// are considered to be boundaries.\n+    ///\n+    /// Fails if `index` is greater than `self.len()`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert!(s.is_char_boundary(0));\n+    /// // start of `\u8001`\n+    /// assert!(s.is_char_boundary(6));\n+    /// assert!(s.is_char_boundary(s.len()));\n+    ///\n+    /// // second byte of `\u00f6`\n+    /// assert!(!s.is_char_boundary(2));\n+    ///\n+    /// // third byte of `\u8001`\n+    /// assert!(!s.is_char_boundary(8));\n+    /// ```\n+    fn is_char_boundary(&self, index: uint) -> bool;\n+\n+    /// Pluck a character out of a string and return the index of the next\n+    /// character.\n+    ///\n+    /// This function can be used to iterate over the unicode characters of a\n+    /// string.\n+    ///\n+    /// # Example\n+    ///\n+    /// This example manually iterate through the characters of a\n+    /// string; this should normally by done by `.chars()` or\n+    /// `.char_indices`.\n+    ///\n+    /// ```rust\n+    /// use std::str::CharRange;\n+    ///\n+    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let mut i = 0u;\n+    /// while i < s.len() {\n+    ///     let CharRange {ch, next} = s.char_range_at(i);\n+    ///     println!(\"{}: {}\", i, ch);\n+    ///     i = next;\n+    /// }\n+    /// ```\n+    ///\n+    /// ## Output\n+    ///\n+    /// ```ignore\n+    /// 0: \u4e2d\n+    /// 3: \u534e\n+    /// 6: V\n+    /// 7: i\n+    /// 8: \u1ec7\n+    /// 11: t\n+    /// 12:\n+    /// 13: N\n+    /// 14: a\n+    /// 15: m\n+    /// ```\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * s - The string\n+    /// * i - The byte offset of the char to extract\n+    ///\n+    /// # Return value\n+    ///\n+    /// A record {ch: char, next: uint} containing the char value and the byte\n+    /// index of the next unicode character.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    fn char_range_at(&self, start: uint) -> CharRange;\n+\n+    /// Given a byte position and a str, return the previous char and its position.\n+    ///\n+    /// This function can be used to iterate over a unicode string in reverse.\n+    ///\n+    /// Returns 0 for next index if called on start index 0.\n+    fn char_range_at_reverse(&self, start: uint) -> CharRange;\n+\n+    /// Plucks the character starting at the `i`th byte of a string\n+    fn char_at(&self, i: uint) -> char;\n+\n+    /// Plucks the character ending at the `i`th byte of a string\n+    fn char_at_reverse(&self, i: uint) -> char;\n+\n+    /// Work with the byte buffer of a string as a byte slice.\n+    fn as_bytes(&self) -> &'a [u8];\n+\n+    /// Returns the byte index of the first character of `self` that\n+    /// matches `search`.\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the last matching character\n+    /// or `None` if there is no match\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find('L'), Some(0));\n+    /// assert_eq!(s.find('\u00e9'), Some(14));\n+    ///\n+    /// // the first space\n+    /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n+    ///\n+    /// // neither are found\n+    /// assert_eq!(s.find(&['1', '2']), None);\n+    /// ```\n+    fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n+\n+    /// Returns the byte index of the last character of `self` that\n+    /// matches `search`.\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the last matching character\n+    /// or `None` if there is no match.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind('L'), Some(13));\n+    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n+    ///\n+    /// // the second space\n+    /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n+    ///\n+    /// // searches for an occurrence of either `1` or `2`, but neither are found\n+    /// assert_eq!(s.rfind(&['1', '2']), None);\n+    /// ```\n+    fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n+\n+    /// Returns the byte index of the first matching substring\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `needle` - The string to search for\n+    ///\n+    /// # Return value\n+    ///\n+    /// `Some` containing the byte index of the first matching substring\n+    /// or `None` if there is no match.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n+    /// assert_eq!(s.find_str(\"muffin man\"), None);\n+    /// ```\n+    fn find_str(&self, &str) -> Option<uint>;\n+\n+    /// Retrieves the first character from a string slice and returns\n+    /// it. This does not allocate a new string; instead, it returns a\n+    /// slice that point one character beyond the character that was\n+    /// shifted. If the string does not contain any characters,\n+    /// a tuple of None and an empty string is returned instead.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let (c, s1) = s.slice_shift_char();\n+    /// assert_eq!(c, Some('L'));\n+    /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n+    ///\n+    /// let (c, s2) = s1.slice_shift_char();\n+    /// assert_eq!(c, Some('\u00f6'));\n+    /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n+    /// ```\n+    fn slice_shift_char(&self) -> (Option<char>, &'a str);\n+\n+    /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n+    ///\n+    /// Fails if `inner` is not a direct slice contained within self.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let string = \"a\\nb\\nc\";\n+    /// let lines: ~[&str] = string.lines().collect();\n+    ///\n+    /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n+    /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n+    /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n+    /// ```\n+    fn subslice_offset(&self, inner: &str) -> uint;\n+\n+    /// Return an unsafe pointer to the strings buffer.\n+    ///\n+    /// The caller must ensure that the string outlives this pointer,\n+    /// and that it is not reallocated (e.g. by pushing to the\n+    /// string).\n+    fn as_ptr(&self) -> *u8;\n+}\n+\n+impl<'a> StrSlice<'a> for &'a str {\n+    #[inline]\n+    fn contains<'a>(&self, needle: &'a str) -> bool {\n+        self.find_str(needle).is_some()\n+    }\n+\n+    #[inline]\n+    fn contains_char(&self, needle: char) -> bool {\n+        self.find(needle).is_some()\n+    }\n+\n+    #[inline]\n+    fn chars(&self) -> Chars<'a> {\n+        Chars{string: *self}\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"replaced by .chars().rev()\"]\n+    fn chars_rev(&self) -> RevChars<'a> {\n+        self.chars().rev()\n+    }\n+\n+    #[inline]\n+    fn bytes(&self) -> Bytes<'a> {\n+        self.as_bytes().iter().map(|&b| b)\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"replaced by .bytes().rev()\"]\n+    fn bytes_rev(&self) -> RevBytes<'a> {\n+        self.bytes().rev()\n+    }\n+\n+    #[inline]\n+    fn char_indices(&self) -> CharOffsets<'a> {\n+        CharOffsets{string: *self, iter: self.chars()}\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"replaced by .char_indices().rev()\"]\n+    fn char_indices_rev(&self) -> RevCharOffsets<'a> {\n+        self.char_indices().rev()\n+    }\n+\n+    #[inline]\n+    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep> {\n+        CharSplits {\n+            string: *self,\n+            only_ascii: sep.only_ascii(),\n+            sep: sep,\n+            allow_trailing_empty: true,\n+            finished: false,\n+        }\n+    }\n+\n+    #[inline]\n+    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n+        -> CharSplitsN<'a, Sep> {\n+        CharSplitsN {\n+            iter: self.split(sep),\n+            count: count,\n+            invert: false,\n+        }\n+    }\n+\n+    #[inline]\n+    fn split_terminator<Sep: CharEq>(&self, sep: Sep)\n+        -> CharSplits<'a, Sep> {\n+        CharSplits {\n+            allow_trailing_empty: false,\n+            ..self.split(sep)\n+        }\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"replaced by .split(sep).rev()\"]\n+    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> RevCharSplits<'a, Sep> {\n+        self.split(sep).rev()\n+    }\n+\n+    #[inline]\n+    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n+        -> CharSplitsN<'a, Sep> {\n+        CharSplitsN {\n+            iter: self.split(sep),\n+            count: count,\n+            invert: true,\n+        }\n+    }\n+\n+    #[inline]\n+    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a> {\n+        assert!(!sep.is_empty())\n+        MatchIndices {\n+            haystack: *self,\n+            needle: sep,\n+            position: 0\n+        }\n+    }\n+\n+    #[inline]\n+    fn split_str(&self, sep: &'a str) -> StrSplits<'a> {\n+        StrSplits {\n+            it: self.match_indices(sep),\n+            last_end: 0,\n+            finished: false\n+        }\n+    }\n+\n+    #[inline]\n+    fn lines(&self) -> CharSplits<'a, char> {\n+        self.split_terminator('\\n')\n+    }\n+\n+    fn lines_any(&self) -> AnyLines<'a> {\n+        self.lines().map(|line| {\n+            let l = line.len();\n+            if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n+            else { line }\n+        })\n+    }\n+\n+    #[inline]\n+    fn words(&self) -> Words<'a> {\n+        self.split(char::is_whitespace).filter(|s| !s.is_empty())\n+    }\n+\n+    #[inline]\n+    fn is_whitespace(&self) -> bool { self.chars().all(char::is_whitespace) }\n+\n+    #[inline]\n+    fn is_alphanumeric(&self) -> bool { self.chars().all(char::is_alphanumeric) }\n+\n+    #[inline]\n+    fn char_len(&self) -> uint { self.chars().len() }\n+\n+    #[inline]\n+    fn slice(&self, begin: uint, end: uint) -> &'a str {\n+        assert!(self.is_char_boundary(begin) && self.is_char_boundary(end));\n+        unsafe { raw::slice_bytes(*self, begin, end) }\n+    }\n+\n+    #[inline]\n+    fn slice_from(&self, begin: uint) -> &'a str {\n+        self.slice(begin, self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to(&self, end: uint) -> &'a str {\n+        assert!(self.is_char_boundary(end));\n+        unsafe { raw::slice_bytes(*self, 0, end) }\n+    }\n+\n+    fn slice_chars(&self, begin: uint, end: uint) -> &'a str {\n+        assert!(begin <= end);\n+        let mut count = 0;\n+        let mut begin_byte = None;\n+        let mut end_byte = None;\n+\n+        // This could be even more efficient by not decoding,\n+        // only finding the char boundaries\n+        for (idx, _) in self.char_indices() {\n+            if count == begin { begin_byte = Some(idx); }\n+            if count == end { end_byte = Some(idx); break; }\n+            count += 1;\n+        }\n+        if begin_byte.is_none() && count == begin { begin_byte = Some(self.len()) }\n+        if end_byte.is_none() && count == end { end_byte = Some(self.len()) }\n+\n+        match (begin_byte, end_byte) {\n+            (None, _) => fail!(\"slice_chars: `begin` is beyond end of string\"),\n+            (_, None) => fail!(\"slice_chars: `end` is beyond end of string\"),\n+            (Some(a), Some(b)) => unsafe { raw::slice_bytes(*self, a, b) }\n+        }\n+    }\n+\n+    #[inline]\n+    fn starts_with<'a>(&self, needle: &'a str) -> bool {\n+        let n = needle.len();\n+        self.len() >= n && needle.as_bytes() == self.as_bytes().slice_to(n)\n+    }\n+\n+    #[inline]\n+    fn ends_with(&self, needle: &str) -> bool {\n+        let (m, n) = (self.len(), needle.len());\n+        m >= n && needle.as_bytes() == self.as_bytes().slice_from(m - n)\n+    }\n+\n+    #[inline]\n+    fn trim(&self) -> &'a str {\n+        self.trim_left().trim_right()\n+    }\n+\n+    #[inline]\n+    fn trim_left(&self) -> &'a str {\n+        self.trim_left_chars(char::is_whitespace)\n+    }\n+\n+    #[inline]\n+    fn trim_right(&self) -> &'a str {\n+        self.trim_right_chars(char::is_whitespace)\n+    }\n+\n+    #[inline]\n+    fn trim_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n+        let cur = match self.find(|c: char| !to_trim.matches(c)) {\n+            None => \"\",\n+            Some(i) => unsafe { raw::slice_bytes(*self, i, self.len()) }\n+        };\n+        match cur.rfind(|c: char| !to_trim.matches(c)) {\n+            None => \"\",\n+            Some(i) => {\n+                let right = cur.char_range_at(i).next;\n+                unsafe { raw::slice_bytes(cur, 0, right) }\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn trim_left_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n+        match self.find(|c: char| !to_trim.matches(c)) {\n+            None => \"\",\n+            Some(first) => unsafe { raw::slice_bytes(*self, first, self.len()) }\n+        }\n+    }\n+\n+    #[inline]\n+    fn trim_right_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n+        match self.rfind(|c: char| !to_trim.matches(c)) {\n+            None => \"\",\n+            Some(last) => {\n+                let next = self.char_range_at(last).next;\n+                unsafe { raw::slice_bytes(*self, 0u, next) }\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_char_boundary(&self, index: uint) -> bool {\n+        if index == self.len() { return true; }\n+        let b = self[index];\n+        return b < 128u8 || b >= 192u8;\n+    }\n+\n+    #[inline]\n+    fn char_range_at(&self, i: uint) -> CharRange {\n+        if self[i] < 128u8 {\n+            return CharRange {ch: self[i] as char, next: i + 1 };\n+        }\n+\n+        // Multibyte case is a fn to allow char_range_at to inline cleanly\n+        fn multibyte_char_range_at(s: &str, i: uint) -> CharRange {\n+            let mut val = s[i] as u32;\n+            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n+            assert!((w != 0));\n+\n+            val = utf8_first_byte!(val, w);\n+            val = utf8_acc_cont_byte!(val, s[i + 1]);\n+            if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n+            if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n+\n+            return CharRange {ch: unsafe { transmute(val) }, next: i + w};\n+        }\n+\n+        return multibyte_char_range_at(*self, i);\n+    }\n+\n+    #[inline]\n+    fn char_range_at_reverse(&self, start: uint) -> CharRange {\n+        let mut prev = start;\n+\n+        prev = prev.saturating_sub(1);\n+        if self[prev] < 128 { return CharRange{ch: self[prev] as char, next: prev} }\n+\n+        // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n+        fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {\n+            // while there is a previous byte == 10......\n+            while i > 0 && s[i] & 192u8 == TAG_CONT_U8 {\n+                i -= 1u;\n+            }\n+\n+            let mut val = s[i] as u32;\n+            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n+            assert!((w != 0));\n+\n+            val = utf8_first_byte!(val, w);\n+            val = utf8_acc_cont_byte!(val, s[i + 1]);\n+            if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n+            if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n+\n+            return CharRange {ch: unsafe { transmute(val) }, next: i};\n+        }\n+\n+        return multibyte_char_range_at_reverse(*self, prev);\n+    }\n+\n+    #[inline]\n+    fn char_at(&self, i: uint) -> char {\n+        self.char_range_at(i).ch\n+    }\n+\n+    #[inline]\n+    fn char_at_reverse(&self, i: uint) -> char {\n+        self.char_range_at_reverse(i).ch\n+    }\n+\n+    #[inline]\n+    fn as_bytes(&self) -> &'a [u8] {\n+        unsafe { cast::transmute(*self) }\n+    }\n+\n+    fn find<C: CharEq>(&self, mut search: C) -> Option<uint> {\n+        if search.only_ascii() {\n+            self.bytes().position(|b| search.matches(b as char))\n+        } else {\n+            for (index, c) in self.char_indices() {\n+                if search.matches(c) { return Some(index); }\n+            }\n+            None\n+        }\n+    }\n+\n+    fn rfind<C: CharEq>(&self, mut search: C) -> Option<uint> {\n+        if search.only_ascii() {\n+            self.bytes().rposition(|b| search.matches(b as char))\n+        } else {\n+            for (index, c) in self.char_indices().rev() {\n+                if search.matches(c) { return Some(index); }\n+            }\n+            None\n+        }\n+    }\n+\n+    fn find_str(&self, needle: &str) -> Option<uint> {\n+        if needle.is_empty() {\n+            Some(0)\n+        } else {\n+            self.match_indices(needle)\n+                .next()\n+                .map(|(start, _end)| start)\n+        }\n+    }\n+\n+    #[inline]\n+    fn slice_shift_char(&self) -> (Option<char>, &'a str) {\n+        if self.is_empty() {\n+            return (None, *self);\n+        } else {\n+            let CharRange {ch, next} = self.char_range_at(0u);\n+            let next_s = unsafe { raw::slice_bytes(*self, next, self.len()) };\n+            return (Some(ch), next_s);\n+        }\n+    }\n+\n+    fn subslice_offset(&self, inner: &str) -> uint {\n+        let a_start = self.as_ptr() as uint;\n+        let a_end = a_start + self.len();\n+        let b_start = inner.as_ptr() as uint;\n+        let b_end = b_start + inner.len();\n+\n+        assert!(a_start <= b_start);\n+        assert!(b_end <= a_end);\n+        b_start - a_start\n+    }\n+\n+    #[inline]\n+    fn as_ptr(&self) -> *u8 {\n+        self.repr().data\n+    }\n+}\n+\n+impl<'a> Default for &'a str {\n+    fn default() -> &'a str { \"\" }\n+}"}, {"sha": "b73d85489a390bc030e64880455fdd9e25ad56ea", "filename": "src/libcore/tuple.rs", "status": "renamed", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -15,8 +15,6 @@\n use clone::Clone;\n #[cfg(not(test))] use cmp::*;\n #[cfg(not(test))] use default::Default;\n-use fmt;\n-use result::{Ok, Err};\n \n // macro for implementing n-ary tuple functions and operations\n macro_rules! tuple_impls {\n@@ -112,12 +110,6 @@ macro_rules! tuple_impls {\n                     ($({ let x: $T = Default::default(); x},)+)\n                 }\n             }\n-\n-            impl<$($T: fmt::Show),+> fmt::Show for ($($T,)+) {\n-                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                    write_tuple!(f.buf, $(self.$refN()),+)\n-                }\n-            }\n         )+\n     }\n }\n@@ -144,18 +136,6 @@ macro_rules! lexical_cmp {\n     ($a:expr, $b:expr) => { ($a).cmp($b) };\n }\n \n-macro_rules! write_tuple {\n-    ($buf:expr, $x:expr) => (\n-        write!($buf, \"({},)\", *$x)\n-    );\n-    ($buf:expr, $hd:expr, $($tl:expr),+) => ({\n-        try!(write!($buf, \"(\"));\n-        try!(write!($buf, \"{}\", *$hd));\n-        $(try!(write!($buf, \", {}\", *$tl));)+\n-        write!($buf, \")\")\n-    });\n-}\n-\n tuple_impls! {\n     Tuple1 {\n         (val0, ref0, mut0) -> A { (a) => a }\n@@ -266,7 +246,7 @@ mod tests {\n     use super::*;\n     use clone::Clone;\n     use cmp::*;\n-    use str::StrSlice;\n+    use realstd::str::StrAllocating;\n \n     #[test]\n     fn test_clone() {", "previous_filename": "src/libstd/tuple.rs"}, {"sha": "0c9f0b02fdf0a2a38152273816550965143bb84e", "filename": "src/libcore/ty.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fty.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "previous_filename": "src/libstd/ty.rs"}, {"sha": "db016ad880741381c3af19796e85c7d50775f60d", "filename": "src/libcore/unicode.rs", "status": "added", "additions": 5009, "deletions": 0, "changes": 5009, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=87115fd001440652291c509a77bda74fa511dab0"}, {"sha": "f55cb2d22360df3b4589af4a43efa7dc72143e53", "filename": "src/libcore/unit.rs", "status": "renamed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibcore%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funit.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -14,7 +14,6 @@\n use default::Default;\n #[cfg(not(test))]\n use cmp::{Eq, Equal, Ord, Ordering, TotalEq, TotalOrd};\n-use fmt;\n \n #[cfg(not(test))]\n impl Eq for () {\n@@ -44,9 +43,3 @@ impl Default for () {\n     #[inline]\n     fn default() -> () { () }\n }\n-\n-impl fmt::Show for () {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"()\")\n-    }\n-}", "previous_filename": "src/libstd/unit.rs"}, {"sha": "29315c458108fa20ff8d3c2b71788843d14f986e", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -1398,7 +1398,6 @@ impl<T: Iterator<char>> Parser<T> {\n                     'n' => res.push_char('\\n'),\n                     'r' => res.push_char('\\r'),\n                     't' => res.push_char('\\t'),\n-//<<<<<<< HEAD\n                     'u' => match try!(self.decode_hex_escape()) {\n                         0xDC00 .. 0xDFFF => return self.error(LoneLeadingSurrogateInHexEscape),\n "}, {"sha": "df0c6f3b8d3974f1a83f984d00f86c56d48d97fd", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -981,7 +981,6 @@ mod test {\n \n     use native;\n     use os;\n-    use owned::Box;\n     use super::*;\n \n     pub fn stress_factor() -> uint {\n@@ -1516,7 +1515,6 @@ mod test {\n mod sync_tests {\n     use prelude::*;\n     use os;\n-    use owned::Box;\n \n     pub fn stress_factor() -> uint {\n         match os::getenv(\"RUST_TEST_STRESS\") {"}, {"sha": "74ab874d3194c0bfa24c073a82dfdff2ebdfe0d2", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 147, "deletions": 3, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -485,20 +485,25 @@ will look like `\"\\\\{\"`.\n \n use any;\n use cast;\n+use cell::Cell;\n use char::Char;\n+use cmp;\n use container::Container;\n use io::MemWriter;\n use io;\n+use iter;\n use iter::{Iterator, range};\n+use kinds::Copy;\n use num::Signed;\n-use option::{Option,Some,None};\n+use option::{Option, Some, None};\n use owned::Box;\n use repr;\n-use result::{Ok, Err};\n-use str::StrSlice;\n+use result::{Ok, Err, ResultUnwrap};\n+use str::{StrSlice, StrAllocating, UTF16Item, ScalarValue, LoneSurrogate};\n use str;\n use slice::{Vector, ImmutableVector};\n use slice;\n+use intrinsics::TypeId;\n \n pub use self::num::radix;\n pub use self::num::Radix;\n@@ -1241,5 +1246,144 @@ impl<T> Show for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n }\n \n+macro_rules! peel(($name:ident, $($other:ident,)*) => (tuple!($($other,)*)))\n+\n+macro_rules! tuple (\n+    () => ();\n+    ( $($name:ident,)+ ) => (\n+        impl<$($name:Show),*> Show for ($($name,)*) {\n+            #[allow(uppercase_variables, dead_assignment)]\n+            fn fmt(&self, f: &mut Formatter) -> Result {\n+                try!(write!(f.buf, \"(\"));\n+                let ($(ref $name,)*) = *self;\n+                let mut n = 0;\n+                $(\n+                    if n > 0 {\n+                        try!(write!(f.buf, \", \"));\n+                    }\n+                    try!(write!(f.buf, \"{}\", *$name));\n+                    n += 1;\n+                )*\n+                if n == 1 {\n+                    try!(write!(f.buf, \",\"));\n+                }\n+                write!(f.buf, \")\")\n+            }\n+        }\n+        peel!($($name,)*)\n+    )\n+)\n+\n+tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n+\n+impl Show for Box<any::Any> {\n+    fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"Box<Any>\") }\n+}\n+\n+impl<'a> Show for &'a any::Any {\n+    fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"&Any\") }\n+}\n+\n+impl<T: Show> Show for Option<T> {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        match *self {\n+            Some(ref t) => write!(f.buf, \"Some({})\", *t),\n+            None => write!(f.buf, \"None\"),\n+        }\n+    }\n+}\n+\n+impl<T: Show, U: Show> Show for ::result::Result<T, U> {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        match *self {\n+            Ok(ref t) => write!(f.buf, \"Ok({})\", *t),\n+            Err(ref t) => write!(f.buf, \"Err({})\", *t),\n+        }\n+    }\n+}\n+\n+impl<'a, T: Show> Show for &'a [T] {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        if f.flags & (1 << (parse::FlagAlternate as uint)) == 0 {\n+            try!(write!(f.buf, \"[\"));\n+        }\n+        let mut is_first = true;\n+        for x in self.iter() {\n+            if is_first {\n+                is_first = false;\n+            } else {\n+                try!(write!(f.buf, \", \"));\n+            }\n+            try!(write!(f.buf, \"{}\", *x))\n+        }\n+        if f.flags & (1 << (parse::FlagAlternate as uint)) == 0 {\n+            try!(write!(f.buf, \"]\"));\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, T: Show> Show for &'a mut [T] {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_show(&self.as_slice(), f)\n+    }\n+}\n+\n+impl<T: Show> Show for ~[T] {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_show(&self.as_slice(), f)\n+    }\n+}\n+\n+impl Show for () {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        f.pad(\"()\")\n+    }\n+}\n+\n+impl Show for TypeId {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        write!(f.buf, \"TypeId \\\\{ {} \\\\}\", self.hash())\n+    }\n+}\n+\n+impl<T: Show> Show for iter::MinMaxResult<T> {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        match *self {\n+            iter::NoElements =>\n+                write!(f.buf, \"NoElements\"),\n+            iter::OneElement(ref t) =>\n+                write!(f.buf, \"OneElement({})\", *t),\n+            iter::MinMax(ref t1, ref t2) =>\n+                write!(f.buf, \"MinMax({}, {})\", *t1, *t2),\n+        }\n+    }\n+}\n+\n+impl Show for cmp::Ordering {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        match *self {\n+            cmp::Less => write!(f.buf, \"Less\"),\n+            cmp::Greater => write!(f.buf, \"Greater\"),\n+            cmp::Equal => write!(f.buf, \"Equal\"),\n+        }\n+    }\n+}\n+\n+impl<T: Copy + Show> Show for Cell<T> {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        write!(f.buf, r\"Cell \\{ value: {} \\}\", self.get())\n+    }\n+}\n+\n+impl Show for UTF16Item {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        match *self {\n+            ScalarValue(c) => write!(f.buf, \"ScalarValue({})\", c),\n+            LoneSurrogate(u) => write!(f.buf, \"LoneSurrogate({})\", u),\n+        }\n+    }\n+}\n+\n // If you expected tests to be here, look instead at the run-pass/ifmt.rs test,\n // it's a lot easier than creating all of the rt::Piece structures here."}, {"sha": "839b7407e5558b00312a64bcf1aaec63c33727d0", "filename": "src/libstd/fmt/num.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fnum.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -194,7 +194,7 @@ mod tests {\n     use fmt::radix;\n     use super::{Binary, Octal, Decimal, LowerHex, UpperHex};\n     use super::{GenericRadix, Radix};\n-    use str::StrSlice;\n+    use str::StrAllocating;\n \n     #[test]\n     fn test_radix_base() {\n@@ -400,6 +400,7 @@ mod bench {\n         use super::test::Bencher;\n         use fmt::radix;\n         use rand::{XorShiftRng, Rng};\n+        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn format_bin(b: &mut Bencher) {\n@@ -436,6 +437,7 @@ mod bench {\n         use super::test::Bencher;\n         use fmt::radix;\n         use rand::{XorShiftRng, Rng};\n+        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn format_bin(b: &mut Bencher) {"}, {"sha": "62bb8e4d969f0221b580552b94dcef7da313e04e", "filename": "src/libstd/from_str.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Ffrom_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Ffrom_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffrom_str.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -10,7 +10,7 @@\n \n //! The `FromStr` trait for types that can be created from strings\n \n-use option::Option;\n+use option::{Option, Some, None};\n \n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n@@ -24,3 +24,37 @@ pub trait FromStr {\n pub fn from_str<A: FromStr>(s: &str) -> Option<A> {\n     FromStr::from_str(s)\n }\n+\n+impl FromStr for bool {\n+    /// Parse a `bool` from a string.\n+    ///\n+    /// Yields an `Option<bool>`, because `s` may or may not actually be parseable.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert_eq!(from_str::<bool>(\"true\"), Some(true));\n+    /// assert_eq!(from_str::<bool>(\"false\"), Some(false));\n+    /// assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n+    /// ```\n+    #[inline]\n+    fn from_str(s: &str) -> Option<bool> {\n+        match s {\n+            \"true\"  => Some(true),\n+            \"false\" => Some(false),\n+            _       => None,\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::*;\n+\n+    #[test]\n+    fn test_bool_from_str() {\n+        assert_eq!(from_str::<bool>(\"true\"), Some(true));\n+        assert_eq!(from_str::<bool>(\"false\"), Some(false));\n+        assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n+    }\n+}"}, {"sha": "9260d8d7ab2be2ad07827ef5cb8a6e0e8b34bc79", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -20,7 +20,6 @@ collector is task-local so `Gc<T>` is not sendable.\n \n use kinds::marker;\n use clone::Clone;\n-use managed;\n \n /// Immutable garbage-collected pointer type\n #[lang=\"gc\"]\n@@ -55,7 +54,7 @@ impl<T: 'static> Gc<T> {\n     /// Determine if two garbage-collected boxes point to the same object\n     #[inline]\n     pub fn ptr_eq(&self, other: &Gc<T>) -> bool {\n-        managed::ptr_eq(self.ptr, other.ptr)\n+        self.borrow() as *T == other.borrow() as *T\n     }\n }\n "}, {"sha": "c8207a4c37ccefe5deb55cfa26340d2a7f538b9d", "filename": "src/libstd/hash/mod.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fmod.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -64,13 +64,15 @@\n #![allow(unused_must_use)]\n \n use container::Container;\n+use intrinsics::TypeId;\n use io::Writer;\n use iter::Iterator;\n use option::{Option, Some, None};\n use owned::Box;\n use rc::Rc;\n-use str::{Str, StrSlice};\n+use result::{Result, Ok, Err};\n use slice::{Vector, ImmutableVector};\n+use str::{Str, StrSlice};\n use vec::Vec;\n \n /// Reexport the `sip::hash` function as our default hasher.\n@@ -284,6 +286,23 @@ impl<S: Writer, T> Hash<S> for *mut T {\n     }\n }\n \n+impl<S: Writer> Hash<S> for TypeId {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.hash().hash(state)\n+    }\n+}\n+\n+impl<S: Writer, T: Hash<S>, U: Hash<S>> Hash<S> for Result<T, U> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        match *self {\n+            Ok(ref t) => { 1u.hash(state); t.hash(state); }\n+            Err(ref t) => { 2u.hash(state); t.hash(state); }\n+        }\n+    }\n+}\n+\n //////////////////////////////////////////////////////////////////////////////\n \n #[cfg(test)]"}, {"sha": "58e0f4c717dedee7b0215058988737e33d0ccf2d", "filename": "src/libstd/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fsip.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -362,7 +362,7 @@ mod tests {\n     use prelude::*;\n     use num::ToStrRadix;\n     use option::{Some, None};\n-    use str::{Str,StrSlice};\n+    use str::Str;\n     use strbuf::StrBuf;\n     use slice::{Vector, ImmutableVector};\n     use self::test::Bencher;"}, {"sha": "a8e7b324bd755e3285abdc705b561fdecf9c1b70", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -16,7 +16,7 @@ use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n use iter::ExactSize;\n use ops::Drop;\n use option::{Some, None, Option};\n-use result::{Ok, Err};\n+use result::{Ok, Err, ResultUnwrap};\n use slice::{ImmutableVector, MutableVector};\n use slice;\n use vec::Vec;"}, {"sha": "125b4ddad88f4bdcaad5f382392a088cbb129cf4", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -1335,7 +1335,7 @@ mod test {\n         use rand::{StdRng, Rng};\n \n         let mut bytes = [0, ..1024];\n-        StdRng::new().unwrap().fill_bytes(bytes);\n+        StdRng::new().ok().unwrap().fill_bytes(bytes);\n \n         let tmpdir = tmpdir();\n "}, {"sha": "cd069ddc1ea40df9ccecadd5d7f9008912528558", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -230,7 +230,7 @@ use option::{Option, Some, None};\n use owned::Box;\n use path::Path;\n use result::{Ok, Err, Result};\n-use str::StrSlice;\n+use str::{StrSlice, StrAllocating};\n use str;\n use uint;\n use unstable::finally::try_finally;"}, {"sha": "b7636493decc72a2732e52eea32ef0700c3c66bb", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -358,6 +358,8 @@ mod test {\n     })\n \n     pub fn socket_name(addr: SocketAddr) {\n+        use result::ResultUnwrap;\n+\n         let server = UdpSocket::bind(addr);\n \n         assert!(server.is_ok());"}, {"sha": "74f6944f102eab95ae3bee120607eaedf00ef07c", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -428,7 +428,6 @@ impl Drop for Process {\n mod tests {\n     use io::process::{ProcessConfig, Process};\n     use prelude::*;\n-    use str::StrSlice;\n \n     // FIXME(#10380) these tests should not all be ignored on android.\n "}, {"sha": "69ba0fb20ee1c28c2b8b5bb05e1b93939e348e4c", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -36,7 +36,7 @@ use mem::replace;\n use option::{Option, Some, None};\n use owned::Box;\n use prelude::drop;\n-use result::{Ok, Err};\n+use result::{Ok, Err, ResultUnwrap};\n use rt;\n use rt::local::Local;\n use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};"}, {"sha": "8c28caa988a5c05d0671b446e3b3e3a1fcba8bcc", "filename": "src/libstd/io/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftempfile.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -18,7 +18,7 @@ use ops::Drop;\n use option::{Option, None, Some};\n use os;\n use path::{Path, GenericPath};\n-use result::{Ok, Err};\n+use result::{Ok, Err, ResultUnwrap};\n use sync::atomics;\n \n /// A wrapper for a path to temporary directory implementing automatic"}, {"sha": "5565918ef854f5dfff0624e61e23d49e4af8d007", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -21,6 +21,7 @@ use comm::Receiver;\n use io::IoResult;\n use kinds::Send;\n use owned::Box;\n+use option::Expect;\n use rt::rtio::{IoFactory, LocalIo, RtioTimer};\n \n /// A synchronous timer object"}, {"sha": "72d41ae1dd2911f7ce4b0b8baef1140874b1bf67", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -122,8 +122,8 @@\n // Make and rand accessible for benchmarking/testcases\n #[cfg(test)] extern crate rand;\n \n-// we wrap some libc stuff\n extern crate libc;\n+extern crate core;\n \n // Make std testable by not duplicating lang items. See #2912\n #[cfg(test)] extern crate realstd = \"std\";\n@@ -133,6 +133,27 @@ extern crate libc;\n #[cfg(test)] pub use ty = realstd::ty;\n #[cfg(test)] pub use owned = realstd::owned;\n \n+#[cfg(not(test))] pub use cmp = core::cmp;\n+#[cfg(not(test))] pub use kinds = core::kinds;\n+#[cfg(not(test))] pub use ops = core::ops;\n+#[cfg(not(test))] pub use owned = core::owned;\n+#[cfg(not(test))] pub use ty = core::ty;\n+\n+pub use core::any;\n+pub use core::bool;\n+pub use core::cast;\n+pub use core::cell;\n+pub use core::char;\n+pub use core::clone;\n+pub use core::container;\n+pub use core::default;\n+pub use core::intrinsics;\n+pub use core::iter;\n+pub use core::mem;\n+pub use core::ptr;\n+pub use core::raw;\n+pub use core::tuple;\n+\n // Run tests with libgreen instead of libnative.\n //\n // FIXME: This egregiously hacks around starting the test runner in a different\n@@ -176,52 +197,27 @@ pub mod prelude;\n #[path = \"num/f32.rs\"]   pub mod f32;\n #[path = \"num/f64.rs\"]   pub mod f64;\n \n-pub mod unit;\n-pub mod bool;\n-pub mod char;\n-pub mod tuple;\n-\n pub mod slice;\n pub mod vec;\n pub mod str;\n pub mod strbuf;\n \n pub mod ascii;\n \n-pub mod ptr;\n-mod managed;\n-mod reference;\n pub mod rc;\n pub mod gc;\n \n-\n-/* Core language traits */\n-\n-#[cfg(not(test))] pub mod kinds;\n-#[cfg(not(test))] pub mod ops;\n-#[cfg(not(test))] pub mod cmp;\n-#[cfg(not(test))] pub mod ty;\n-#[cfg(not(test))] pub mod owned;\n-\n-\n /* Common traits */\n \n pub mod from_str;\n pub mod num;\n-pub mod iter;\n pub mod to_str;\n-pub mod clone;\n pub mod hash;\n-pub mod container;\n-pub mod default;\n-pub mod any;\n \n /* Common data structures */\n \n-pub mod option;\n pub mod result;\n-pub mod cell;\n-\n+pub mod option;\n \n /* Tasks and communication */\n \n@@ -238,11 +234,8 @@ pub mod c_vec;\n pub mod os;\n pub mod io;\n pub mod path;\n-pub mod cast;\n pub mod fmt;\n pub mod cleanup;\n-pub mod mem;\n-\n \n /* Unsupported interfaces */\n \n@@ -254,10 +247,6 @@ pub mod reflect;\n // Private APIs\n #[unstable]\n pub mod unstable;\n-#[experimental]\n-pub mod intrinsics;\n-#[experimental]\n-pub mod raw;\n \n /* For internal use, not exported */\n "}, {"sha": "da738a387b2cdbec8c416c96dad7c57468d1ce93", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -357,7 +357,6 @@ mod tests {\n     use super::*;\n     use owned::Box;\n     use task;\n-    use str::StrSlice;\n \n     #[test]\n     fn test_tls_multitask() {"}, {"sha": "bf73c05440c14bf3a388df72444f01ac6ae4324f", "filename": "src/libstd/managed.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/445988b47811679144d0fa9b3a2ccf2348752850/src%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445988b47811679144d0fa9b3a2ccf2348752850/src%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmanaged.rs?ref=445988b47811679144d0fa9b3a2ccf2348752850", "patch": "@@ -1,58 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Operations on managed box types\n-\n-#[cfg(not(test))] use cmp::*;\n-\n-/// Determine if two shared boxes point to the same object\n-#[inline]\n-pub fn ptr_eq<T>(a: @T, b: @T) -> bool {\n-    &*a as *T == &*b as *T\n-}\n-\n-#[cfg(not(test))]\n-impl<T:Eq> Eq for @T {\n-    #[inline]\n-    fn eq(&self, other: &@T) -> bool { *(*self) == *(*other) }\n-    #[inline]\n-    fn ne(&self, other: &@T) -> bool { *(*self) != *(*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl<T:Ord> Ord for @T {\n-    #[inline]\n-    fn lt(&self, other: &@T) -> bool { *(*self) < *(*other) }\n-    #[inline]\n-    fn le(&self, other: &@T) -> bool { *(*self) <= *(*other) }\n-    #[inline]\n-    fn ge(&self, other: &@T) -> bool { *(*self) >= *(*other) }\n-    #[inline]\n-    fn gt(&self, other: &@T) -> bool { *(*self) > *(*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl<T: TotalOrd> TotalOrd for @T {\n-    #[inline]\n-    fn cmp(&self, other: &@T) -> Ordering { (**self).cmp(*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl<T: TotalEq> TotalEq for @T {}\n-\n-#[test]\n-fn test() {\n-    let x = @3;\n-    let y = @3;\n-    assert!((ptr_eq::<int>(x, x)));\n-    assert!((ptr_eq::<int>(y, y)));\n-    assert!((!ptr_eq::<int>(x, y)));\n-    assert!((!ptr_eq::<int>(y, x)));\n-}"}, {"sha": "ea248b6d40defeec278c2b1438211bfa4adb3bdc", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 7, "deletions": 211, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -16,14 +16,18 @@\n use prelude::*;\n \n use cast;\n-use default::Default;\n use from_str::FromStr;\n-use libc::{c_int};\n+use libc::c_int;\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n-use num::{Zero, One, Bounded, strconv};\n+use num::strconv;\n use num;\n use intrinsics;\n \n+pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n+pub use core::f32::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n+pub use core::f32::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n+pub use core::f32::consts;\n+\n #[allow(dead_code)]\n mod cmath {\n     use libc::{c_float, c_int};\n@@ -65,214 +69,6 @@ mod cmath {\n     }\n }\n \n-pub static RADIX: uint = 2u;\n-\n-pub static MANTISSA_DIGITS: uint = 24u;\n-pub static DIGITS: uint = 6u;\n-\n-pub static EPSILON: f32 = 1.19209290e-07_f32;\n-\n-/// Smallest finite f32 value\n-pub static MIN_VALUE: f32 = -3.40282347e+38_f32;\n-/// Smallest positive, normalized f32 value\n-pub static MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n-/// Largest finite f32 value\n-pub static MAX_VALUE: f32 = 3.40282347e+38_f32;\n-\n-pub static MIN_EXP: int = -125;\n-pub static MAX_EXP: int = 128;\n-\n-pub static MIN_10_EXP: int = -37;\n-pub static MAX_10_EXP: int = 38;\n-\n-pub static NAN: f32 = 0.0_f32/0.0_f32;\n-pub static INFINITY: f32 = 1.0_f32/0.0_f32;\n-pub static NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n-\n-/// Various useful constants.\n-pub mod consts {\n-    // FIXME: replace with mathematical constants from cmath.\n-\n-    // FIXME(#5527): These constants should be deprecated once associated\n-    // constants are implemented in favour of referencing the respective members\n-    // of `Float`.\n-\n-    /// Archimedes' constant\n-    pub static PI: f32 = 3.14159265358979323846264338327950288_f32;\n-\n-    /// pi * 2.0\n-    pub static PI_2: f32 = 6.28318530717958647692528676655900576_f32;\n-\n-    /// pi/2.0\n-    pub static FRAC_PI_2: f32 = 1.57079632679489661923132169163975144_f32;\n-\n-    /// pi/3.0\n-    pub static FRAC_PI_3: f32 = 1.04719755119659774615421446109316763_f32;\n-\n-    /// pi/4.0\n-    pub static FRAC_PI_4: f32 = 0.785398163397448309615660845819875721_f32;\n-\n-    /// pi/6.0\n-    pub static FRAC_PI_6: f32 = 0.52359877559829887307710723054658381_f32;\n-\n-    /// pi/8.0\n-    pub static FRAC_PI_8: f32 = 0.39269908169872415480783042290993786_f32;\n-\n-    /// 1.0/pi\n-    pub static FRAC_1_PI: f32 = 0.318309886183790671537767526745028724_f32;\n-\n-    /// 2.0/pi\n-    pub static FRAC_2_PI: f32 = 0.636619772367581343075535053490057448_f32;\n-\n-    /// 2.0/sqrt(pi)\n-    pub static FRAC_2_SQRTPI: f32 = 1.12837916709551257389615890312154517_f32;\n-\n-    /// sqrt(2.0)\n-    pub static SQRT2: f32 = 1.41421356237309504880168872420969808_f32;\n-\n-    /// 1.0/sqrt(2.0)\n-    pub static FRAC_1_SQRT2: f32 = 0.707106781186547524400844362104849039_f32;\n-\n-    /// Euler's number\n-    pub static E: f32 = 2.71828182845904523536028747135266250_f32;\n-\n-    /// log2(e)\n-    pub static LOG2_E: f32 = 1.44269504088896340735992468100189214_f32;\n-\n-    /// log10(e)\n-    pub static LOG10_E: f32 = 0.434294481903251827651128918916605082_f32;\n-\n-    /// ln(2.0)\n-    pub static LN_2: f32 = 0.693147180559945309417232121458176568_f32;\n-\n-    /// ln(10.0)\n-    pub static LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n-}\n-\n-impl Num for f32 {}\n-\n-#[cfg(not(test))]\n-impl Eq for f32 {\n-    #[inline]\n-    fn eq(&self, other: &f32) -> bool { (*self) == (*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl Ord for f32 {\n-    #[inline]\n-    fn lt(&self, other: &f32) -> bool { (*self) < (*other) }\n-    #[inline]\n-    fn le(&self, other: &f32) -> bool { (*self) <= (*other) }\n-    #[inline]\n-    fn ge(&self, other: &f32) -> bool { (*self) >= (*other) }\n-    #[inline]\n-    fn gt(&self, other: &f32) -> bool { (*self) > (*other) }\n-}\n-\n-impl Default for f32 {\n-    #[inline]\n-    fn default() -> f32 { 0.0 }\n-}\n-\n-impl Zero for f32 {\n-    #[inline]\n-    fn zero() -> f32 { 0.0 }\n-\n-    /// Returns true if the number is equal to either `0.0` or `-0.0`\n-    #[inline]\n-    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n-}\n-\n-impl One for f32 {\n-    #[inline]\n-    fn one() -> f32 { 1.0 }\n-}\n-\n-#[cfg(not(test))]\n-impl Add<f32,f32> for f32 {\n-    #[inline]\n-    fn add(&self, other: &f32) -> f32 { *self + *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Sub<f32,f32> for f32 {\n-    #[inline]\n-    fn sub(&self, other: &f32) -> f32 { *self - *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Mul<f32,f32> for f32 {\n-    #[inline]\n-    fn mul(&self, other: &f32) -> f32 { *self * *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Div<f32,f32> for f32 {\n-    #[inline]\n-    fn div(&self, other: &f32) -> f32 { *self / *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Rem<f32,f32> for f32 {\n-    #[inline]\n-    fn rem(&self, other: &f32) -> f32 {\n-        unsafe { cmath::fmodf(*self, *other) }\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl Neg<f32> for f32 {\n-    #[inline]\n-    fn neg(&self) -> f32 { -*self }\n-}\n-\n-impl Signed for f32 {\n-    /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n-    #[inline]\n-    fn abs(&self) -> f32 {\n-        unsafe { intrinsics::fabsf32(*self) }\n-    }\n-\n-    /// The positive difference of two numbers. Returns `0.0` if the number is\n-    /// less than or equal to `other`, otherwise the difference between`self`\n-    /// and `other` is returned.\n-    #[inline]\n-    fn abs_sub(&self, other: &f32) -> f32 {\n-        unsafe { cmath::fdimf(*self, *other) }\n-    }\n-\n-    /// # Returns\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n-    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-    /// - `NAN` if the number is NaN\n-    #[inline]\n-    fn signum(&self) -> f32 {\n-        if self.is_nan() { NAN } else {\n-            unsafe { intrinsics::copysignf32(1.0, *self) }\n-        }\n-    }\n-\n-    /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n-    #[inline]\n-    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == INFINITY }\n-\n-    /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n-    #[inline]\n-    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == NEG_INFINITY }\n-}\n-\n-impl Bounded for f32 {\n-    // NOTE: this is the smallest non-infinite f32 value, *not* MIN_VALUE\n-    #[inline]\n-    fn min_value() -> f32 { -MAX_VALUE }\n-\n-    #[inline]\n-    fn max_value() -> f32 { MAX_VALUE }\n-}\n-\n-impl Primitive for f32 {}\n-\n impl Float for f32 {\n     #[inline]\n     fn nan() -> f32 { NAN }"}, {"sha": "77171a00befef8438038dac1889d8fdf63622999", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 6, "deletions": 210, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -15,14 +15,18 @@\n use prelude::*;\n \n use cast;\n-use default::Default;\n use from_str::FromStr;\n use libc::{c_int};\n use num::{FPCategory, FPNaN, FPInfinite , FPZero, FPSubnormal, FPNormal};\n-use num::{Zero, One, Bounded, strconv};\n+use num::{strconv};\n use num;\n use intrinsics;\n \n+pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n+pub use core::f64::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n+pub use core::f64::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n+pub use core::f64::consts;\n+\n #[allow(dead_code)]\n mod cmath {\n     use libc::{c_double, c_int};\n@@ -73,214 +77,6 @@ mod cmath {\n     }\n }\n \n-// FIXME(#5527): These constants should be deprecated once associated\n-// constants are implemented in favour of referencing the respective\n-// members of `Bounded` and `Float`.\n-\n-pub static RADIX: uint = 2u;\n-\n-pub static MANTISSA_DIGITS: uint = 53u;\n-pub static DIGITS: uint = 15u;\n-\n-pub static EPSILON: f64 = 2.2204460492503131e-16_f64;\n-\n-/// Smallest finite f64 value\n-pub static MIN_VALUE: f64 = -1.7976931348623157e+308_f64;\n-/// Smallest positive, normalized f64 value\n-pub static MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n-/// Largest finite f64 value\n-pub static MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n-\n-pub static MIN_EXP: int = -1021;\n-pub static MAX_EXP: int = 1024;\n-\n-pub static MIN_10_EXP: int = -307;\n-pub static MAX_10_EXP: int = 308;\n-\n-pub static NAN: f64 = 0.0_f64/0.0_f64;\n-\n-pub static INFINITY: f64 = 1.0_f64/0.0_f64;\n-\n-pub static NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n-\n-/// Various useful constants.\n-pub mod consts {\n-    // FIXME: replace with mathematical constants from cmath.\n-\n-    // FIXME(#5527): These constants should be deprecated once associated\n-    // constants are implemented in favour of referencing the respective members\n-    // of `Float`.\n-\n-    /// Archimedes' constant\n-    pub static PI: f64 = 3.14159265358979323846264338327950288_f64;\n-\n-    /// pi * 2.0\n-    pub static PI_2: f64 = 6.28318530717958647692528676655900576_f64;\n-\n-    /// pi/2.0\n-    pub static FRAC_PI_2: f64 = 1.57079632679489661923132169163975144_f64;\n-\n-    /// pi/3.0\n-    pub static FRAC_PI_3: f64 = 1.04719755119659774615421446109316763_f64;\n-\n-    /// pi/4.0\n-    pub static FRAC_PI_4: f64 = 0.785398163397448309615660845819875721_f64;\n-\n-    /// pi/6.0\n-    pub static FRAC_PI_6: f64 = 0.52359877559829887307710723054658381_f64;\n-\n-    /// pi/8.0\n-    pub static FRAC_PI_8: f64 = 0.39269908169872415480783042290993786_f64;\n-\n-    /// 1.0/pi\n-    pub static FRAC_1_PI: f64 = 0.318309886183790671537767526745028724_f64;\n-\n-    /// 2.0/pi\n-    pub static FRAC_2_PI: f64 = 0.636619772367581343075535053490057448_f64;\n-\n-    /// 2.0/sqrt(pi)\n-    pub static FRAC_2_SQRTPI: f64 = 1.12837916709551257389615890312154517_f64;\n-\n-    /// sqrt(2.0)\n-    pub static SQRT2: f64 = 1.41421356237309504880168872420969808_f64;\n-\n-    /// 1.0/sqrt(2.0)\n-    pub static FRAC_1_SQRT2: f64 = 0.707106781186547524400844362104849039_f64;\n-\n-    /// Euler's number\n-    pub static E: f64 = 2.71828182845904523536028747135266250_f64;\n-\n-    /// log2(e)\n-    pub static LOG2_E: f64 = 1.44269504088896340735992468100189214_f64;\n-\n-    /// log10(e)\n-    pub static LOG10_E: f64 = 0.434294481903251827651128918916605082_f64;\n-\n-    /// ln(2.0)\n-    pub static LN_2: f64 = 0.693147180559945309417232121458176568_f64;\n-\n-    /// ln(10.0)\n-    pub static LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n-}\n-\n-impl Num for f64 {}\n-\n-#[cfg(not(test))]\n-impl Eq for f64 {\n-    #[inline]\n-    fn eq(&self, other: &f64) -> bool { (*self) == (*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl Ord for f64 {\n-    #[inline]\n-    fn lt(&self, other: &f64) -> bool { (*self) < (*other) }\n-    #[inline]\n-    fn le(&self, other: &f64) -> bool { (*self) <= (*other) }\n-    #[inline]\n-    fn ge(&self, other: &f64) -> bool { (*self) >= (*other) }\n-    #[inline]\n-    fn gt(&self, other: &f64) -> bool { (*self) > (*other) }\n-}\n-\n-impl Default for f64 {\n-    #[inline]\n-    fn default() -> f64 { 0.0 }\n-}\n-\n-impl Zero for f64 {\n-    #[inline]\n-    fn zero() -> f64 { 0.0 }\n-\n-    /// Returns true if the number is equal to either `0.0` or `-0.0`\n-    #[inline]\n-    fn is_zero(&self) -> bool { *self == 0.0 || *self == -0.0 }\n-}\n-\n-impl One for f64 {\n-    #[inline]\n-    fn one() -> f64 { 1.0 }\n-}\n-\n-#[cfg(not(test))]\n-impl Add<f64,f64> for f64 {\n-    #[inline]\n-    fn add(&self, other: &f64) -> f64 { *self + *other }\n-}\n-#[cfg(not(test))]\n-impl Sub<f64,f64> for f64 {\n-    #[inline]\n-    fn sub(&self, other: &f64) -> f64 { *self - *other }\n-}\n-#[cfg(not(test))]\n-impl Mul<f64,f64> for f64 {\n-    #[inline]\n-    fn mul(&self, other: &f64) -> f64 { *self * *other }\n-}\n-#[cfg(not(test))]\n-impl Div<f64,f64> for f64 {\n-    #[inline]\n-    fn div(&self, other: &f64) -> f64 { *self / *other }\n-}\n-#[cfg(not(test))]\n-impl Rem<f64,f64> for f64 {\n-    #[inline]\n-    fn rem(&self, other: &f64) -> f64 {\n-        unsafe { cmath::fmod(*self, *other) }\n-    }\n-}\n-#[cfg(not(test))]\n-impl Neg<f64> for f64 {\n-    #[inline]\n-    fn neg(&self) -> f64 { -*self }\n-}\n-\n-impl Signed for f64 {\n-    /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n-    #[inline]\n-    fn abs(&self) -> f64 {\n-        unsafe { intrinsics::fabsf64(*self) }\n-    }\n-\n-    /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n-    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n-    #[inline]\n-    fn abs_sub(&self, other: &f64) -> f64 {\n-        unsafe { cmath::fdim(*self, *other) }\n-    }\n-\n-    /// # Returns\n-    ///\n-    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n-    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-    /// - `NAN` if the number is NaN\n-    #[inline]\n-    fn signum(&self) -> f64 {\n-        if self.is_nan() { NAN } else {\n-            unsafe { intrinsics::copysignf64(1.0, *self) }\n-        }\n-    }\n-\n-    /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n-    #[inline]\n-    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == INFINITY }\n-\n-    /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n-    #[inline]\n-    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == NEG_INFINITY }\n-}\n-\n-impl Bounded for f64 {\n-    // NOTE: this is the smallest non-infinite f32 value, *not* MIN_VALUE\n-    #[inline]\n-    fn min_value() -> f64 { -MAX_VALUE }\n-\n-    #[inline]\n-    fn max_value() -> f64 { MAX_VALUE }\n-}\n-\n-impl Primitive for f64 {}\n-\n impl Float for f64 {\n     #[inline]\n     fn nan() -> f64 { NAN }"}, {"sha": "4bd2ba07634cacd291b895ddf069b8fe25b6ff45", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 6, "deletions": 55, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -10,63 +10,14 @@\n \n //! Operations and constants for signed 16-bits integers (`i16` type)\n \n-#![allow(non_uppercase_statics)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded, CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-int_module!(i16, 16)\n-\n-impl Bitwise for i16 {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> i16 { unsafe { intrinsics::ctpop16(*self as u16) as i16 } }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> i16 { unsafe { intrinsics::ctlz16(*self as u16) as i16 } }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> i16 { unsafe { intrinsics::cttz16(*self as u16) as i16 } }\n-}\n-\n-impl CheckedAdd for i16 {\n-    #[inline]\n-    fn checked_add(&self, v: &i16) -> Option<i16> {\n-        unsafe {\n-            let (x, y) = intrinsics::i16_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for i16 {\n-    #[inline]\n-    fn checked_sub(&self, v: &i16) -> Option<i16> {\n-        unsafe {\n-            let (x, y) = intrinsics::i16_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::i16::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for i16 {\n-    #[inline]\n-    fn checked_mul(&self, v: &i16) -> Option<i16> {\n-        unsafe {\n-            let (x, y) = intrinsics::i16_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+int_module!(i16)"}, {"sha": "3c3acfae3c0f8757ddd80cfe68a237b06c2a976a", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 6, "deletions": 55, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -10,63 +10,14 @@\n \n //! Operations and constants for signed 32-bits integers (`i32` type)\n \n-#![allow(non_uppercase_statics)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded, CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-int_module!(i32, 32)\n-\n-impl Bitwise for i32 {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> i32 { unsafe { intrinsics::ctpop32(*self as u32) as i32 } }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> i32 { unsafe { intrinsics::ctlz32(*self as u32) as i32 } }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> i32 { unsafe { intrinsics::cttz32(*self as u32) as i32 } }\n-}\n-\n-impl CheckedAdd for i32 {\n-    #[inline]\n-    fn checked_add(&self, v: &i32) -> Option<i32> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for i32 {\n-    #[inline]\n-    fn checked_sub(&self, v: &i32) -> Option<i32> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::i32::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for i32 {\n-    #[inline]\n-    fn checked_mul(&self, v: &i32) -> Option<i32> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+int_module!(i32)"}, {"sha": "ad0fe1c08ef04cd621f3873b4b83726bc6cf5a6d", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 6, "deletions": 56, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -10,64 +10,14 @@\n \n //! Operations and constants for signed 64-bits integers (`i64` type)\n \n-#![allow(non_uppercase_statics)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-#[cfg(target_word_size = \"64\")]\n-use num::CheckedMul;\n-use num::{Bitwise, Bounded, CheckedAdd, CheckedSub};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-int_module!(i64, 64)\n-\n-impl Bitwise for i64 {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> i64 { unsafe { intrinsics::ctpop64(*self as u64) as i64 } }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> i64 { unsafe { intrinsics::ctlz64(*self as u64) as i64 } }\n-\n-    /// Counts the number of trailing zeros.\n-    #[inline]\n-    fn trailing_zeros(&self) -> i64 { unsafe { intrinsics::cttz64(*self as u64) as i64 } }\n-}\n-\n-impl CheckedAdd for i64 {\n-    #[inline]\n-    fn checked_add(&self, v: &i64) -> Option<i64> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for i64 {\n-    #[inline]\n-    fn checked_sub(&self, v: &i64) -> Option<i64> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::i64::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for i64 {\n-    #[inline]\n-    fn checked_mul(&self, v: &i64) -> Option<i64> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+int_module!(i64)"}, {"sha": "bd40a2c53b656b0f99fdc8af858c649f904eb7f6", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 6, "deletions": 55, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -10,63 +10,14 @@\n \n //! Operations and constants for signed 8-bits integers (`i8` type)\n \n-#![allow(non_uppercase_statics)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded, CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-int_module!(i8, 8)\n-\n-impl Bitwise for i8 {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> i8 { unsafe { intrinsics::ctpop8(*self as u8) as i8 } }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> i8 { unsafe { intrinsics::ctlz8(*self as u8) as i8 } }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> i8 { unsafe { intrinsics::cttz8(*self as u8) as i8 } }\n-}\n-\n-impl CheckedAdd for i8 {\n-    #[inline]\n-    fn checked_add(&self, v: &i8) -> Option<i8> {\n-        unsafe {\n-            let (x, y) = intrinsics::i8_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for i8 {\n-    #[inline]\n-    fn checked_sub(&self, v: &i8) -> Option<i8> {\n-        unsafe {\n-            let (x, y) = intrinsics::i8_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::i8::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for i8 {\n-    #[inline]\n-    fn checked_mul(&self, v: &i8) -> Option<i8> {\n-        unsafe {\n-            let (x, y) = intrinsics::i8_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+int_module!(i8)"}, {"sha": "d9552ee33400ed5c898a126593009d1bb430beca", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 6, "deletions": 110, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -10,118 +10,14 @@\n \n //! Operations and constants for architecture-sized signed integers (`int` type)\n \n-#![allow(non_uppercase_statics)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded, CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-#[cfg(target_word_size = \"32\")] int_module!(int, 32)\n-#[cfg(target_word_size = \"64\")] int_module!(int, 64)\n-\n-#[cfg(target_word_size = \"32\")]\n-impl Bitwise for int {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> int { (*self as i32).count_ones() as int }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> int { (*self as i32).leading_zeros() as int }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> int { (*self as i32).trailing_zeros() as int }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl Bitwise for int {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> int { (*self as i64).count_ones() as int }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> int { (*self as i64).leading_zeros() as int }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> int { (*self as i64).trailing_zeros() as int }\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-impl CheckedAdd for int {\n-    #[inline]\n-    fn checked_add(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_add_with_overflow(*self as i32, *v as i32);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl CheckedAdd for int {\n-    #[inline]\n-    fn checked_add(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_add_with_overflow(*self as i64, *v as i64);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-impl CheckedSub for int {\n-    #[inline]\n-    fn checked_sub(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_sub_with_overflow(*self as i32, *v as i32);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl CheckedSub for int {\n-    #[inline]\n-    fn checked_sub(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_sub_with_overflow(*self as i64, *v as i64);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n \n-#[cfg(target_word_size = \"32\")]\n-impl CheckedMul for int {\n-    #[inline]\n-    fn checked_mul(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i32_mul_with_overflow(*self as i32, *v as i32);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n+pub use core::int::{BITS, BYTES, MIN, MAX};\n \n-#[cfg(target_word_size = \"64\")]\n-impl CheckedMul for int {\n-    #[inline]\n-    fn checked_mul(&self, v: &int) -> Option<int> {\n-        unsafe {\n-            let (x, y) = intrinsics::i64_mul_with_overflow(*self as i64, *v as i64);\n-            if y { None } else { Some(x as int) }\n-        }\n-    }\n-}\n+int_module!(int)"}, {"sha": "8a7bea465851ac21ba122a8866a2855c7af7c7fc", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 307, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -11,226 +11,7 @@\n #![macro_escape]\n #![doc(hidden)]\n \n-macro_rules! int_module (($T:ty, $bits:expr) => (\n-\n-// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n-// calling the `mem::size_of` function.\n-pub static BITS : uint = $bits;\n-// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n-// calling the `mem::size_of` function.\n-pub static BYTES : uint = ($bits / 8);\n-\n-// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n-// calling the `Bounded::min_value` function.\n-pub static MIN: $T = (-1 as $T) << (BITS - 1);\n-// FIXME(#9837): Compute MIN like this so the high bits that shouldn't exist are 0.\n-// FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n-// calling the `Bounded::max_value` function.\n-pub static MAX: $T = !MIN;\n-\n-impl CheckedDiv for $T {\n-    #[inline]\n-    fn checked_div(&self, v: &$T) -> Option<$T> {\n-        if *v == 0 || (*self == MIN && *v == -1) {\n-            None\n-        } else {\n-            Some(self / *v)\n-        }\n-    }\n-}\n-\n-impl Num for $T {}\n-\n-#[cfg(not(test))]\n-impl Ord for $T {\n-    #[inline]\n-    fn lt(&self, other: &$T) -> bool { return (*self) < (*other); }\n-}\n-\n-#[cfg(not(test))]\n-impl Eq for $T {\n-    #[inline]\n-    fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }\n-}\n-\n-impl Default for $T {\n-    #[inline]\n-    fn default() -> $T { 0 }\n-}\n-\n-impl Zero for $T {\n-    #[inline]\n-    fn zero() -> $T { 0 }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool { *self == 0 }\n-}\n-\n-impl One for $T {\n-    #[inline]\n-    fn one() -> $T { 1 }\n-}\n-\n-#[cfg(not(test))]\n-impl Add<$T,$T> for $T {\n-    #[inline]\n-    fn add(&self, other: &$T) -> $T { *self + *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Sub<$T,$T> for $T {\n-    #[inline]\n-    fn sub(&self, other: &$T) -> $T { *self - *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Mul<$T,$T> for $T {\n-    #[inline]\n-    fn mul(&self, other: &$T) -> $T { *self * *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Div<$T,$T> for $T {\n-    /// Integer division, truncated towards 0.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ~~~\n-    /// assert!( 8 /  3 ==  2);\n-    /// assert!( 8 / -3 == -2);\n-    /// assert!(-8 /  3 == -2);\n-    /// assert!(-8 / -3 ==  2);\n-    ///\n-    /// assert!( 1 /  2 ==  0);\n-    /// assert!( 1 / -2 ==  0);\n-    /// assert!(-1 /  2 ==  0);\n-    /// assert!(-1 / -2 ==  0);\n-    /// ~~~\n-    #[inline]\n-    fn div(&self, other: &$T) -> $T { *self / *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Rem<$T,$T> for $T {\n-    /// Returns the integer remainder after division, satisfying:\n-    ///\n-    /// ~~~\n-    /// # let n = 1;\n-    /// # let d = 2;\n-    /// assert!((n / d) * d + (n % d) == n)\n-    /// ~~~\n-    ///\n-    /// # Examples\n-    ///\n-    /// ~~~\n-    /// assert!( 8 %  3 ==  2);\n-    /// assert!( 8 % -3 ==  2);\n-    /// assert!(-8 %  3 == -2);\n-    /// assert!(-8 % -3 == -2);\n-    ///\n-    /// assert!( 1 %  2 ==  1);\n-    /// assert!( 1 % -2 ==  1);\n-    /// assert!(-1 %  2 == -1);\n-    /// assert!(-1 % -2 == -1);\n-    /// ~~~\n-    #[inline]\n-    fn rem(&self, other: &$T) -> $T { *self % *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Neg<$T> for $T {\n-    #[inline]\n-    fn neg(&self) -> $T { -*self }\n-}\n-\n-impl Signed for $T {\n-    /// Computes the absolute value\n-    #[inline]\n-    fn abs(&self) -> $T {\n-        if self.is_negative() { -*self } else { *self }\n-    }\n-\n-    ///\n-    /// The positive difference of two numbers. Returns `0` if the number is less than or\n-    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n-    ///\n-    #[inline]\n-    fn abs_sub(&self, other: &$T) -> $T {\n-        if *self <= *other { 0 } else { *self - *other }\n-    }\n-\n-    ///\n-    /// # Returns\n-    ///\n-    /// - `0` if the number is zero\n-    /// - `1` if the number is positive\n-    /// - `-1` if the number is negative\n-    ///\n-    #[inline]\n-    fn signum(&self) -> $T {\n-        match *self {\n-            n if n > 0 =>  1,\n-            0          =>  0,\n-            _          => -1,\n-        }\n-    }\n-\n-    /// Returns true if the number is positive\n-    #[inline]\n-    fn is_positive(&self) -> bool { *self > 0 }\n-\n-    /// Returns true if the number is negative\n-    #[inline]\n-    fn is_negative(&self) -> bool { *self < 0 }\n-}\n-\n-#[cfg(not(test))]\n-impl BitOr<$T,$T> for $T {\n-    #[inline]\n-    fn bitor(&self, other: &$T) -> $T { *self | *other }\n-}\n-\n-#[cfg(not(test))]\n-impl BitAnd<$T,$T> for $T {\n-    #[inline]\n-    fn bitand(&self, other: &$T) -> $T { *self & *other }\n-}\n-\n-#[cfg(not(test))]\n-impl BitXor<$T,$T> for $T {\n-    #[inline]\n-    fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Shl<$T,$T> for $T {\n-    #[inline]\n-    fn shl(&self, other: &$T) -> $T { *self << *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Shr<$T,$T> for $T {\n-    #[inline]\n-    fn shr(&self, other: &$T) -> $T { *self >> *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Not<$T> for $T {\n-    #[inline]\n-    fn not(&self) -> $T { !*self }\n-}\n-\n-impl Bounded for $T {\n-    #[inline]\n-    fn min_value() -> $T { MIN }\n-\n-    #[inline]\n-    fn max_value() -> $T { MAX }\n-}\n-\n-impl Int for $T {}\n-\n-impl Primitive for $T {}\n+macro_rules! int_module (($T:ty) => (\n \n // String conversion functions and impl str -> num\n \n@@ -296,7 +77,7 @@ impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        let mut buf = Vec::new();\n+        let mut buf = ::vec::Vec::new();\n         strconv::int_to_str_bytes_common(*self, radix, strconv::SignNeg, |i| {\n             buf.push(i);\n         });\n@@ -311,89 +92,10 @@ mod tests {\n     use prelude::*;\n     use super::*;\n \n-    use int;\n     use i32;\n-    use num;\n-    use num::Bitwise;\n-    use num::CheckedDiv;\n     use num::ToStrRadix;\n     use str::StrSlice;\n \n-    #[test]\n-    fn test_overflows() {\n-        assert!(MAX > 0);\n-        assert!(MIN <= 0);\n-        assert_eq!(MIN + MAX + 1, 0);\n-    }\n-\n-    #[test]\n-    fn test_num() {\n-        num::test_num(10 as $T, 2 as $T);\n-    }\n-\n-    #[test]\n-    pub fn test_abs() {\n-        assert_eq!((1 as $T).abs(), 1 as $T);\n-        assert_eq!((0 as $T).abs(), 0 as $T);\n-        assert_eq!((-1 as $T).abs(), 1 as $T);\n-    }\n-\n-    #[test]\n-    fn test_abs_sub() {\n-        assert_eq!((-1 as $T).abs_sub(&(1 as $T)), 0 as $T);\n-        assert_eq!((1 as $T).abs_sub(&(1 as $T)), 0 as $T);\n-        assert_eq!((1 as $T).abs_sub(&(0 as $T)), 1 as $T);\n-        assert_eq!((1 as $T).abs_sub(&(-1 as $T)), 2 as $T);\n-    }\n-\n-    #[test]\n-    fn test_signum() {\n-        assert_eq!((1 as $T).signum(), 1 as $T);\n-        assert_eq!((0 as $T).signum(), 0 as $T);\n-        assert_eq!((-0 as $T).signum(), 0 as $T);\n-        assert_eq!((-1 as $T).signum(), -1 as $T);\n-    }\n-\n-    #[test]\n-    fn test_is_positive() {\n-        assert!((1 as $T).is_positive());\n-        assert!(!(0 as $T).is_positive());\n-        assert!(!(-0 as $T).is_positive());\n-        assert!(!(-1 as $T).is_positive());\n-    }\n-\n-    #[test]\n-    fn test_is_negative() {\n-        assert!(!(1 as $T).is_negative());\n-        assert!(!(0 as $T).is_negative());\n-        assert!(!(-0 as $T).is_negative());\n-        assert!((-1 as $T).is_negative());\n-    }\n-\n-    #[test]\n-    fn test_bitwise() {\n-        assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(&(0b1010 as $T)));\n-        assert_eq!(0b1000 as $T, (0b1100 as $T).bitand(&(0b1010 as $T)));\n-        assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(&(0b1010 as $T)));\n-        assert_eq!(0b1110 as $T, (0b0111 as $T).shl(&(1 as $T)));\n-        assert_eq!(0b0111 as $T, (0b1110 as $T).shr(&(1 as $T)));\n-        assert_eq!(-(0b11 as $T) - (1 as $T), (0b11 as $T).not());\n-    }\n-\n-    #[test]\n-    fn test_count_ones() {\n-        assert_eq!((0b0101100 as $T).count_ones(), 3);\n-        assert_eq!((0b0100001 as $T).count_ones(), 2);\n-        assert_eq!((0b1111001 as $T).count_ones(), 5);\n-    }\n-\n-    #[test]\n-    fn test_count_zeros() {\n-        assert_eq!((0b0101100 as $T).count_zeros(), BITS as $T - 3);\n-        assert_eq!((0b0100001 as $T).count_zeros(), BITS as $T - 2);\n-        assert_eq!((0b1111001 as $T).count_zeros(), BITS as $T - 5);\n-    }\n-\n     #[test]\n     fn test_from_str() {\n         assert_eq!(from_str::<$T>(\"0\"), Some(0 as $T));\n@@ -508,13 +210,6 @@ mod tests {\n         assert_eq!(from_str::<i64>(\"-9223372036854775808\"), Some(i64_val));\n         assert!(from_str::<i64>(\"-9223372036854775809\").is_none());\n     }\n-\n-    #[test]\n-    fn test_signed_checked_div() {\n-        assert_eq!(10i.checked_div(&2), Some(5));\n-        assert_eq!(5i.checked_div(&0), None);\n-        assert_eq!(int::MIN.checked_div(&-1), None);\n-    }\n }\n \n ))"}, {"sha": "1efd7cad300bfca9b0144c0ba89ee4bfa11a58fe", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 15, "deletions": 849, "changes": 864, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -15,306 +15,24 @@\n \n #![allow(missing_doc)]\n \n-use clone::Clone;\n-use cmp::{Eq, Ord};\n-use kinds::Copy;\n-use mem::size_of;\n-use ops::{Add, Sub, Mul, Div, Rem, Neg};\n-use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n-use option::{Option, Some, None};\n-use fmt::{Show, Binary, Octal, LowerHex, UpperHex};\n+use option::{Option};\n+\n+#[cfg(test)] use fmt::Show;\n+\n+pub use core::num::{Num, div_rem, Zero, zero, One, one};\n+pub use core::num::{Signed, abs, abs_sub, signum};\n+pub use core::num::{Unsigned, pow, Bounded, Bitwise};\n+pub use core::num::{Primitive, Int, Saturating};\n+pub use core::num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n+pub use core::num::{cast, FromPrimitive, NumCast, ToPrimitive};\n+pub use core::num::{next_power_of_two, is_power_of_two};\n+pub use core::num::{checked_next_power_of_two};\n+pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n+pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n+pub use core::num::{from_f32, from_f64};\n \n pub mod strconv;\n \n-/// The base trait for numeric types\n-pub trait Num: Eq + Zero + One\n-             + Neg<Self>\n-             + Add<Self,Self>\n-             + Sub<Self,Self>\n-             + Mul<Self,Self>\n-             + Div<Self,Self>\n-             + Rem<Self,Self> {}\n-\n-/// Simultaneous division and remainder\n-#[inline]\n-pub fn div_rem<T: Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) {\n-    (x / y, x % y)\n-}\n-\n-/// Defines an additive identity element for `Self`.\n-///\n-/// # Deriving\n-///\n-/// This trait can be automatically be derived using `#[deriving(Zero)]`\n-/// attribute. If you choose to use this, make sure that the laws outlined in\n-/// the documentation for `Zero::zero` still hold.\n-pub trait Zero: Add<Self, Self> {\n-    /// Returns the additive identity element of `Self`, `0`.\n-    ///\n-    /// # Laws\n-    ///\n-    /// ~~~notrust\n-    /// a + 0 = a       \u2200 a \u2208 Self\n-    /// 0 + a = a       \u2200 a \u2208 Self\n-    /// ~~~\n-    ///\n-    /// # Purity\n-    ///\n-    /// This function should return the same result at all times regardless of\n-    /// external mutable state, for example values stored in TLS or in\n-    /// `static mut`s.\n-    // FIXME (#5527): This should be an associated constant\n-    fn zero() -> Self;\n-\n-    /// Returns `true` if `self` is equal to the additive identity.\n-    fn is_zero(&self) -> bool;\n-}\n-\n-/// Returns the additive identity, `0`.\n-#[inline(always)] pub fn zero<T: Zero>() -> T { Zero::zero() }\n-\n-/// Defines a multiplicative identity element for `Self`.\n-pub trait One: Mul<Self, Self> {\n-    /// Returns the multiplicative identity element of `Self`, `1`.\n-    ///\n-    /// # Laws\n-    ///\n-    /// ~~~notrust\n-    /// a * 1 = a       \u2200 a \u2208 Self\n-    /// 1 * a = a       \u2200 a \u2208 Self\n-    /// ~~~\n-    ///\n-    /// # Purity\n-    ///\n-    /// This function should return the same result at all times regardless of\n-    /// external mutable state, for example values stored in TLS or in\n-    /// `static mut`s.\n-    // FIXME (#5527): This should be an associated constant\n-    fn one() -> Self;\n-}\n-\n-/// Returns the multiplicative identity, `1`.\n-#[inline(always)] pub fn one<T: One>() -> T { One::one() }\n-\n-/// Useful functions for signed numbers (i.e. numbers that can be negative).\n-pub trait Signed: Num + Neg<Self> {\n-    /// Computes the absolute value.\n-    ///\n-    /// For float, f32, and f64, `NaN` will be returned if the number is `NaN`.\n-    fn abs(&self) -> Self;\n-\n-    /// The positive difference of two numbers.\n-    ///\n-    /// Returns `zero` if the number is less than or equal to `other`, otherwise the difference\n-    /// between `self` and `other` is returned.\n-    fn abs_sub(&self, other: &Self) -> Self;\n-\n-    /// Returns the sign of the number.\n-    ///\n-    /// For `float`, `f32`, `f64`:\n-    ///   * `1.0` if the number is positive, `+0.0` or `INFINITY`\n-    ///   * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-    ///   * `NaN` if the number is `NaN`\n-    ///\n-    /// For `int`:\n-    ///   * `0` if the number is zero\n-    ///   * `1` if the number is positive\n-    ///   * `-1` if the number is negative\n-    fn signum(&self) -> Self;\n-\n-    /// Returns true if the number is positive and false if the number is zero or negative.\n-    fn is_positive(&self) -> bool;\n-\n-    /// Returns true if the number is negative and false if the number is zero or positive.\n-    fn is_negative(&self) -> bool;\n-}\n-\n-/// Computes the absolute value.\n-///\n-/// For float, f32, and f64, `NaN` will be returned if the number is `NaN`\n-#[inline(always)]\n-pub fn abs<T: Signed>(value: T) -> T {\n-    value.abs()\n-}\n-\n-/// The positive difference of two numbers.\n-///\n-/// Returns `zero` if the number is less than or equal to `other`,\n-/// otherwise the difference between `self` and `other` is returned.\n-#[inline(always)]\n-pub fn abs_sub<T: Signed>(x: T, y: T) -> T {\n-    x.abs_sub(&y)\n-}\n-\n-/// Returns the sign of the number.\n-///\n-/// For float, f32, f64:\n-/// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n-/// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-/// - `NAN` if the number is `NAN`\n-///\n-/// For int:\n-/// - `0` if the number is zero\n-/// - `1` if the number is positive\n-/// - `-1` if the number is negative\n-#[inline(always)] pub fn signum<T: Signed>(value: T) -> T { value.signum() }\n-\n-/// A trait for values which cannot be negative\n-pub trait Unsigned: Num {}\n-\n-/// Raises a value to the power of exp, using exponentiation by squaring.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::num;\n-///\n-/// assert_eq!(num::pow(2, 4), 16);\n-/// ```\n-#[inline]\n-pub fn pow<T: One + Mul<T, T>>(mut base: T, mut exp: uint) -> T {\n-    if exp == 1 { base }\n-    else {\n-        let mut acc = one::<T>();\n-        while exp > 0 {\n-            if (exp & 1) == 1 {\n-                acc = acc * base;\n-            }\n-            base = base * base;\n-            exp = exp >> 1;\n-        }\n-        acc\n-    }\n-}\n-\n-/// Numbers which have upper and lower bounds\n-pub trait Bounded {\n-    // FIXME (#5527): These should be associated constants\n-    /// returns the smallest finite number this type can represent\n-    fn min_value() -> Self;\n-    /// returns the largest finite number this type can represent\n-    fn max_value() -> Self;\n-}\n-\n-/// Numbers with a fixed binary representation.\n-pub trait Bitwise: Bounded\n-                 + Not<Self>\n-                 + BitAnd<Self,Self>\n-                 + BitOr<Self,Self>\n-                 + BitXor<Self,Self>\n-                 + Shl<Self,Self>\n-                 + Shr<Self,Self> {\n-    /// Returns the number of ones in the binary representation of the number.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n-    /// let n = 0b01001100u8;\n-    /// assert_eq!(n.count_ones(), 3);\n-    /// ```\n-    fn count_ones(&self) -> Self;\n-\n-    /// Returns the number of zeros in the binary representation of the number.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n-    /// let n = 0b01001100u8;\n-    /// assert_eq!(n.count_zeros(), 5);\n-    /// ```\n-    #[inline]\n-    fn count_zeros(&self) -> Self {\n-        (!*self).count_ones()\n-    }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n-    /// let n = 0b0101000u16;\n-    /// assert_eq!(n.leading_zeros(), 10);\n-    /// ```\n-    fn leading_zeros(&self) -> Self;\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n-    /// let n = 0b0101000u16;\n-    /// assert_eq!(n.trailing_zeros(), 3);\n-    /// ```\n-    fn trailing_zeros(&self) -> Self;\n-}\n-\n-/// Specifies the available operations common to all of Rust's core numeric primitives.\n-/// These may not always make sense from a purely mathematical point of view, but\n-/// may be useful for systems programming.\n-pub trait Primitive: Copy\n-                   + Clone\n-                   + Num\n-                   + NumCast\n-                   + Ord\n-                   + Bounded {}\n-\n-/// A collection of traits relevant to primitive signed and unsigned integers\n-pub trait Int: Primitive\n-             + Bitwise\n-             + CheckedAdd\n-             + CheckedSub\n-             + CheckedMul\n-             + CheckedDiv\n-             + Show\n-             + Binary\n-             + Octal\n-             + LowerHex\n-             + UpperHex {}\n-\n-/// Returns the smallest power of 2 greater than or equal to `n`.\n-#[inline]\n-pub fn next_power_of_two<T: Unsigned + Int>(n: T) -> T {\n-    let halfbits: T = cast(size_of::<T>() * 4).unwrap();\n-    let mut tmp: T = n - one();\n-    let mut shift: T = one();\n-    while shift <= halfbits {\n-        tmp = tmp | (tmp >> shift);\n-        shift = shift << one();\n-    }\n-    tmp + one()\n-}\n-\n-// Returns `true` iff `n == 2^k` for some k.\n-#[inline]\n-pub fn is_power_of_two<T: Unsigned + Int>(n: T) -> bool {\n-    (n - one()) & n == zero()\n-}\n-\n-/// Returns the smallest power of 2 greater than or equal to `n`. If the next\n-/// power of two is greater than the type's maximum value, `None` is returned,\n-/// otherwise the power of 2 is wrapped in `Some`.\n-#[inline]\n-pub fn checked_next_power_of_two<T: Unsigned + Int>(n: T) -> Option<T> {\n-    let halfbits: T = cast(size_of::<T>() * 4).unwrap();\n-    let mut tmp: T = n - one();\n-    let mut shift: T = one();\n-    while shift <= halfbits {\n-        tmp = tmp | (tmp >> shift);\n-        shift = shift << one();\n-    }\n-    tmp.checked_add(&one())\n-}\n-\n /// Used for representing the classification of floating point numbers\n #[deriving(Eq, Show)]\n pub enum FPCategory {\n@@ -537,494 +255,6 @@ pub trait Float: Signed + Primitive {\n     fn to_radians(self) -> Self;\n }\n \n-/// A generic trait for converting a value to a number.\n-pub trait ToPrimitive {\n-    /// Converts the value of `self` to an `int`.\n-    #[inline]\n-    fn to_int(&self) -> Option<int> {\n-        self.to_i64().and_then(|x| x.to_int())\n-    }\n-\n-    /// Converts the value of `self` to an `i8`.\n-    #[inline]\n-    fn to_i8(&self) -> Option<i8> {\n-        self.to_i64().and_then(|x| x.to_i8())\n-    }\n-\n-    /// Converts the value of `self` to an `i16`.\n-    #[inline]\n-    fn to_i16(&self) -> Option<i16> {\n-        self.to_i64().and_then(|x| x.to_i16())\n-    }\n-\n-    /// Converts the value of `self` to an `i32`.\n-    #[inline]\n-    fn to_i32(&self) -> Option<i32> {\n-        self.to_i64().and_then(|x| x.to_i32())\n-    }\n-\n-    /// Converts the value of `self` to an `i64`.\n-    fn to_i64(&self) -> Option<i64>;\n-\n-    /// Converts the value of `self` to an `uint`.\n-    #[inline]\n-    fn to_uint(&self) -> Option<uint> {\n-        self.to_u64().and_then(|x| x.to_uint())\n-    }\n-\n-    /// Converts the value of `self` to an `u8`.\n-    #[inline]\n-    fn to_u8(&self) -> Option<u8> {\n-        self.to_u64().and_then(|x| x.to_u8())\n-    }\n-\n-    /// Converts the value of `self` to an `u16`.\n-    #[inline]\n-    fn to_u16(&self) -> Option<u16> {\n-        self.to_u64().and_then(|x| x.to_u16())\n-    }\n-\n-    /// Converts the value of `self` to an `u32`.\n-    #[inline]\n-    fn to_u32(&self) -> Option<u32> {\n-        self.to_u64().and_then(|x| x.to_u32())\n-    }\n-\n-    /// Converts the value of `self` to an `u64`.\n-    #[inline]\n-    fn to_u64(&self) -> Option<u64>;\n-\n-    /// Converts the value of `self` to an `f32`.\n-    #[inline]\n-    fn to_f32(&self) -> Option<f32> {\n-        self.to_f64().and_then(|x| x.to_f32())\n-    }\n-\n-    /// Converts the value of `self` to an `f64`.\n-    #[inline]\n-    fn to_f64(&self) -> Option<f64> {\n-        self.to_i64().and_then(|x| x.to_f64())\n-    }\n-}\n-\n-macro_rules! impl_to_primitive_int_to_int(\n-    ($SrcT:ty, $DstT:ty) => (\n-        {\n-            if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-                Some(*self as $DstT)\n-            } else {\n-                let n = *self as i64;\n-                let min_value: $DstT = Bounded::min_value();\n-                let max_value: $DstT = Bounded::max_value();\n-                if min_value as i64 <= n && n <= max_value as i64 {\n-                    Some(*self as $DstT)\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n-    )\n-)\n-\n-macro_rules! impl_to_primitive_int_to_uint(\n-    ($SrcT:ty, $DstT:ty) => (\n-        {\n-            let zero: $SrcT = Zero::zero();\n-            let max_value: $DstT = Bounded::max_value();\n-            if zero <= *self && *self as u64 <= max_value as u64 {\n-                Some(*self as $DstT)\n-            } else {\n-                None\n-            }\n-        }\n-    )\n-)\n-\n-macro_rules! impl_to_primitive_int(\n-    ($T:ty) => (\n-        impl ToPrimitive for $T {\n-            #[inline]\n-            fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!($T, int) }\n-            #[inline]\n-            fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!($T, i8) }\n-            #[inline]\n-            fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!($T, i16) }\n-            #[inline]\n-            fn to_i32(&self) -> Option<i32> { impl_to_primitive_int_to_int!($T, i32) }\n-            #[inline]\n-            fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!($T, i64) }\n-\n-            #[inline]\n-            fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!($T, uint) }\n-            #[inline]\n-            fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!($T, u8) }\n-            #[inline]\n-            fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!($T, u16) }\n-            #[inline]\n-            fn to_u32(&self) -> Option<u32> { impl_to_primitive_int_to_uint!($T, u32) }\n-            #[inline]\n-            fn to_u64(&self) -> Option<u64> { impl_to_primitive_int_to_uint!($T, u64) }\n-\n-            #[inline]\n-            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n-            #[inline]\n-            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n-        }\n-    )\n-)\n-\n-impl_to_primitive_int!(int)\n-impl_to_primitive_int!(i8)\n-impl_to_primitive_int!(i16)\n-impl_to_primitive_int!(i32)\n-impl_to_primitive_int!(i64)\n-\n-macro_rules! impl_to_primitive_uint_to_int(\n-    ($DstT:ty) => (\n-        {\n-            let max_value: $DstT = Bounded::max_value();\n-            if *self as u64 <= max_value as u64 {\n-                Some(*self as $DstT)\n-            } else {\n-                None\n-            }\n-        }\n-    )\n-)\n-\n-macro_rules! impl_to_primitive_uint_to_uint(\n-    ($SrcT:ty, $DstT:ty) => (\n-        {\n-            if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-                Some(*self as $DstT)\n-            } else {\n-                let zero: $SrcT = Zero::zero();\n-                let max_value: $DstT = Bounded::max_value();\n-                if zero <= *self && *self as u64 <= max_value as u64 {\n-                    Some(*self as $DstT)\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n-    )\n-)\n-\n-macro_rules! impl_to_primitive_uint(\n-    ($T:ty) => (\n-        impl ToPrimitive for $T {\n-            #[inline]\n-            fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int) }\n-            #[inline]\n-            fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8) }\n-            #[inline]\n-            fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16) }\n-            #[inline]\n-            fn to_i32(&self) -> Option<i32> { impl_to_primitive_uint_to_int!(i32) }\n-            #[inline]\n-            fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64) }\n-\n-            #[inline]\n-            fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, uint) }\n-            #[inline]\n-            fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8) }\n-            #[inline]\n-            fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!($T, u16) }\n-            #[inline]\n-            fn to_u32(&self) -> Option<u32> { impl_to_primitive_uint_to_uint!($T, u32) }\n-            #[inline]\n-            fn to_u64(&self) -> Option<u64> { impl_to_primitive_uint_to_uint!($T, u64) }\n-\n-            #[inline]\n-            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n-            #[inline]\n-            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n-        }\n-    )\n-)\n-\n-impl_to_primitive_uint!(uint)\n-impl_to_primitive_uint!(u8)\n-impl_to_primitive_uint!(u16)\n-impl_to_primitive_uint!(u32)\n-impl_to_primitive_uint!(u64)\n-\n-macro_rules! impl_to_primitive_float_to_float(\n-    ($SrcT:ty, $DstT:ty) => (\n-        if size_of::<$SrcT>() <= size_of::<$DstT>() {\n-            Some(*self as $DstT)\n-        } else {\n-            let n = *self as f64;\n-            let max_value: $SrcT = Bounded::max_value();\n-            if -max_value as f64 <= n && n <= max_value as f64 {\n-                Some(*self as $DstT)\n-            } else {\n-                None\n-            }\n-        }\n-    )\n-)\n-\n-macro_rules! impl_to_primitive_float(\n-    ($T:ty) => (\n-        impl ToPrimitive for $T {\n-            #[inline]\n-            fn to_int(&self) -> Option<int> { Some(*self as int) }\n-            #[inline]\n-            fn to_i8(&self) -> Option<i8> { Some(*self as i8) }\n-            #[inline]\n-            fn to_i16(&self) -> Option<i16> { Some(*self as i16) }\n-            #[inline]\n-            fn to_i32(&self) -> Option<i32> { Some(*self as i32) }\n-            #[inline]\n-            fn to_i64(&self) -> Option<i64> { Some(*self as i64) }\n-\n-            #[inline]\n-            fn to_uint(&self) -> Option<uint> { Some(*self as uint) }\n-            #[inline]\n-            fn to_u8(&self) -> Option<u8> { Some(*self as u8) }\n-            #[inline]\n-            fn to_u16(&self) -> Option<u16> { Some(*self as u16) }\n-            #[inline]\n-            fn to_u32(&self) -> Option<u32> { Some(*self as u32) }\n-            #[inline]\n-            fn to_u64(&self) -> Option<u64> { Some(*self as u64) }\n-\n-            #[inline]\n-            fn to_f32(&self) -> Option<f32> { impl_to_primitive_float_to_float!($T, f32) }\n-            #[inline]\n-            fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!($T, f64) }\n-        }\n-    )\n-)\n-\n-impl_to_primitive_float!(f32)\n-impl_to_primitive_float!(f64)\n-\n-/// A generic trait for converting a number to a value.\n-pub trait FromPrimitive {\n-    /// Convert an `int` to return an optional value of this type. If the\n-    /// value cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_int(n: int) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Convert an `i8` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i8(n: i8) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Convert an `i16` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i16(n: i16) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Convert an `i32` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_i32(n: i32) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-\n-    /// Convert an `i64` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    fn from_i64(n: i64) -> Option<Self>;\n-\n-    /// Convert an `uint` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_uint(n: uint) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Convert an `u8` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u8(n: u8) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Convert an `u16` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u16(n: u16) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Convert an `u32` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_u32(n: u32) -> Option<Self> {\n-        FromPrimitive::from_u64(n as u64)\n-    }\n-\n-    /// Convert an `u64` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    fn from_u64(n: u64) -> Option<Self>;\n-\n-    /// Convert a `f32` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_f32(n: f32) -> Option<Self> {\n-        FromPrimitive::from_f64(n as f64)\n-    }\n-\n-    /// Convert a `f64` to return an optional value of this type. If the\n-    /// type cannot be represented by this value, the `None` is returned.\n-    #[inline]\n-    fn from_f64(n: f64) -> Option<Self> {\n-        FromPrimitive::from_i64(n as i64)\n-    }\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_int`.\n-pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> {\n-    FromPrimitive::from_int(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i8`.\n-pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> {\n-    FromPrimitive::from_i8(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i16`.\n-pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> {\n-    FromPrimitive::from_i16(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i32`.\n-pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> {\n-    FromPrimitive::from_i32(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_i64`.\n-pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n-    FromPrimitive::from_i64(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_uint`.\n-pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> {\n-    FromPrimitive::from_uint(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u8`.\n-pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> {\n-    FromPrimitive::from_u8(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u16`.\n-pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> {\n-    FromPrimitive::from_u16(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u32`.\n-pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> {\n-    FromPrimitive::from_u32(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_u64`.\n-pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> {\n-    FromPrimitive::from_u64(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_f32`.\n-pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> {\n-    FromPrimitive::from_f32(n)\n-}\n-\n-/// A utility function that just calls `FromPrimitive::from_f64`.\n-pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n-    FromPrimitive::from_f64(n)\n-}\n-\n-macro_rules! impl_from_primitive(\n-    ($T:ty, $to_ty:expr) => (\n-        impl FromPrimitive for $T {\n-            #[inline] fn from_int(n: int) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i8(n: i8) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i16(n: i16) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i32(n: i32) -> Option<$T> { $to_ty }\n-            #[inline] fn from_i64(n: i64) -> Option<$T> { $to_ty }\n-\n-            #[inline] fn from_uint(n: uint) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u8(n: u8) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u16(n: u16) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u32(n: u32) -> Option<$T> { $to_ty }\n-            #[inline] fn from_u64(n: u64) -> Option<$T> { $to_ty }\n-\n-            #[inline] fn from_f32(n: f32) -> Option<$T> { $to_ty }\n-            #[inline] fn from_f64(n: f64) -> Option<$T> { $to_ty }\n-        }\n-    )\n-)\n-\n-impl_from_primitive!(int, n.to_int())\n-impl_from_primitive!(i8, n.to_i8())\n-impl_from_primitive!(i16, n.to_i16())\n-impl_from_primitive!(i32, n.to_i32())\n-impl_from_primitive!(i64, n.to_i64())\n-impl_from_primitive!(uint, n.to_uint())\n-impl_from_primitive!(u8, n.to_u8())\n-impl_from_primitive!(u16, n.to_u16())\n-impl_from_primitive!(u32, n.to_u32())\n-impl_from_primitive!(u64, n.to_u64())\n-impl_from_primitive!(f32, n.to_f32())\n-impl_from_primitive!(f64, n.to_f64())\n-\n-/// Cast from one machine scalar to another.\n-///\n-/// # Example\n-///\n-/// ```\n-/// use std::num;\n-///\n-/// let twenty: f32 = num::cast(0x14).unwrap();\n-/// assert_eq!(twenty, 20f32);\n-/// ```\n-///\n-#[inline]\n-pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> {\n-    NumCast::from(n)\n-}\n-\n-/// An interface for casting between machine scalars.\n-pub trait NumCast: ToPrimitive {\n-    /// Creates a number from another value that can be converted into a primitive via the\n-    /// `ToPrimitive` trait.\n-    fn from<T: ToPrimitive>(n: T) -> Option<Self>;\n-}\n-\n-macro_rules! impl_num_cast(\n-    ($T:ty, $conv:ident) => (\n-        impl NumCast for $T {\n-            #[inline]\n-            fn from<N: ToPrimitive>(n: N) -> Option<$T> {\n-                // `$conv` could be generated using `concat_idents!`, but that\n-                // macro seems to be broken at the moment\n-                n.$conv()\n-            }\n-        }\n-    )\n-)\n-\n-impl_num_cast!(u8,    to_u8)\n-impl_num_cast!(u16,   to_u16)\n-impl_num_cast!(u32,   to_u32)\n-impl_num_cast!(u64,   to_u64)\n-impl_num_cast!(uint,  to_uint)\n-impl_num_cast!(i8,    to_i8)\n-impl_num_cast!(i16,   to_i16)\n-impl_num_cast!(i32,   to_i32)\n-impl_num_cast!(i64,   to_i64)\n-impl_num_cast!(int,   to_int)\n-impl_num_cast!(f32,   to_f32)\n-impl_num_cast!(f64,   to_f64)\n-\n /// A generic trait for converting a value to a string with a radix (base)\n pub trait ToStrRadix {\n     fn to_str_radix(&self, radix: uint) -> ~str;\n@@ -1040,70 +270,6 @@ pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n     FromStrRadix::from_str_radix(str, radix)\n }\n \n-/// Saturating math operations\n-pub trait Saturating {\n-    /// Saturating addition operator.\n-    /// Returns a+b, saturating at the numeric bounds instead of overflowing.\n-    fn saturating_add(self, v: Self) -> Self;\n-\n-    /// Saturating subtraction operator.\n-    /// Returns a-b, saturating at the numeric bounds instead of overflowing.\n-    fn saturating_sub(self, v: Self) -> Self;\n-}\n-\n-impl<T: CheckedAdd + CheckedSub + Zero + Ord + Bounded> Saturating for T {\n-    #[inline]\n-    fn saturating_add(self, v: T) -> T {\n-        match self.checked_add(&v) {\n-            Some(x) => x,\n-            None => if v >= Zero::zero() {\n-                Bounded::max_value()\n-            } else {\n-                Bounded::min_value()\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn saturating_sub(self, v: T) -> T {\n-        match self.checked_sub(&v) {\n-            Some(x) => x,\n-            None => if v >= Zero::zero() {\n-                Bounded::min_value()\n-            } else {\n-                Bounded::max_value()\n-            }\n-        }\n-    }\n-}\n-\n-/// Performs addition that returns `None` instead of wrapping around on overflow.\n-pub trait CheckedAdd: Add<Self, Self> {\n-    /// Adds two numbers, checking for overflow. If overflow happens, `None` is returned.\n-    fn checked_add(&self, v: &Self) -> Option<Self>;\n-}\n-\n-/// Performs subtraction that returns `None` instead of wrapping around on underflow.\n-pub trait CheckedSub: Sub<Self, Self> {\n-    /// Subtracts two numbers, checking for underflow. If underflow happens, `None` is returned.\n-    fn checked_sub(&self, v: &Self) -> Option<Self>;\n-}\n-\n-/// Performs multiplication that returns `None` instead of wrapping around on underflow or\n-/// overflow.\n-pub trait CheckedMul: Mul<Self, Self> {\n-    /// Multiplies two numbers, checking for underflow or overflow. If underflow or overflow\n-    /// happens, `None` is returned.\n-    fn checked_mul(&self, v: &Self) -> Option<Self>;\n-}\n-\n-/// Performs division that returns `None` instead of wrapping around on underflow or overflow.\n-pub trait CheckedDiv: Div<Self, Self> {\n-    /// Divides two numbers, checking for underflow or overflow. If underflow or overflow happens,\n-    /// `None` is returned.\n-    fn checked_div(&self, v: &Self) -> Option<Self>;\n-}\n-\n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T:Num + NumCast + Show>(ten: T, two: T) {"}, {"sha": "8861597bb4c16d50348648dd6ffd882cdf6ab41e", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -820,6 +820,7 @@ mod bench {\n         use super::test::Bencher;\n         use rand::{XorShiftRng, Rng};\n         use num::ToStrRadix;\n+        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n@@ -856,6 +857,7 @@ mod bench {\n         use super::test::Bencher;\n         use rand::{XorShiftRng, Rng};\n         use num::ToStrRadix;\n+        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n@@ -892,6 +894,7 @@ mod bench {\n         use super::test::Bencher;\n         use rand::{XorShiftRng, Rng};\n         use f64;\n+        use realstd::result::ResultUnwrap;\n \n         #[bench]\n         fn float_to_str(b: &mut Bencher) {"}, {"sha": "dd6a838df9ba649521654bda13a0c51722dd8794", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 6, "deletions": 41, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -10,49 +10,14 @@\n \n //! Operations and constants for unsigned 16-bits integers (`u16` type)\n \n-#![allow(non_uppercase_statics)]\n-#![allow(unsigned_negate)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded};\n-use num::{CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-uint_module!(u16, i16, 16)\n-\n-impl CheckedAdd for u16 {\n-    #[inline]\n-    fn checked_add(&self, v: &u16) -> Option<u16> {\n-        unsafe {\n-            let (x, y) = intrinsics::u16_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for u16 {\n-    #[inline]\n-    fn checked_sub(&self, v: &u16) -> Option<u16> {\n-        unsafe {\n-            let (x, y) = intrinsics::u16_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::u16::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for u16 {\n-    #[inline]\n-    fn checked_mul(&self, v: &u16) -> Option<u16> {\n-        unsafe {\n-            let (x, y) = intrinsics::u16_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+uint_module!(u16)"}, {"sha": "bb05938969dee5bf60fd42fe0bd5f00f94b75e0c", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 6, "deletions": 41, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -10,49 +10,14 @@\n \n //! Operations and constants for unsigned 32-bits integers (`u32` type)\n \n-#![allow(non_uppercase_statics)]\n-#![allow(unsigned_negate)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded};\n-use num::{CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-uint_module!(u32, i32, 32)\n-\n-impl CheckedAdd for u32 {\n-    #[inline]\n-    fn checked_add(&self, v: &u32) -> Option<u32> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for u32 {\n-    #[inline]\n-    fn checked_sub(&self, v: &u32) -> Option<u32> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::u32::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for u32 {\n-    #[inline]\n-    fn checked_mul(&self, v: &u32) -> Option<u32> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+uint_module!(u32)"}, {"sha": "f38806e1527fd3b98ebcdcd13559033b8279d713", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 6, "deletions": 43, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -10,51 +10,14 @@\n \n //! Operations and constants for unsigned 64-bits integer (`u64` type)\n \n-#![allow(non_uppercase_statics)]\n-#![allow(unsigned_negate)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded};\n-#[cfg(target_word_size = \"64\")]\n-use num::CheckedMul;\n-use num::{CheckedAdd, CheckedSub};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-uint_module!(u64, i64, 64)\n-\n-impl CheckedAdd for u64 {\n-    #[inline]\n-    fn checked_add(&self, v: &u64) -> Option<u64> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for u64 {\n-    #[inline]\n-    fn checked_sub(&self, v: &u64) -> Option<u64> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::u64::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for u64 {\n-    #[inline]\n-    fn checked_mul(&self, v: &u64) -> Option<u64> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+uint_module!(u64)"}, {"sha": "87fed563a1535658ddb17ce97274b84ad5dac09d", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 6, "deletions": 41, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -10,49 +10,14 @@\n \n //! Operations and constants for unsigned 8-bits integers (`u8` type)\n \n-#![allow(non_uppercase_statics)]\n-#![allow(unsigned_negate)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded};\n-use num::{CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-uint_module!(u8, i8, 8)\n-\n-impl CheckedAdd for u8 {\n-    #[inline]\n-    fn checked_add(&self, v: &u8) -> Option<u8> {\n-        unsafe {\n-            let (x, y) = intrinsics::u8_add_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n \n-impl CheckedSub for u8 {\n-    #[inline]\n-    fn checked_sub(&self, v: &u8) -> Option<u8> {\n-        unsafe {\n-            let (x, y) = intrinsics::u8_sub_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+pub use core::u8::{BITS, BYTES, MIN, MAX};\n \n-impl CheckedMul for u8 {\n-    #[inline]\n-    fn checked_mul(&self, v: &u8) -> Option<u8> {\n-        unsafe {\n-            let (x, y) = intrinsics::u8_mul_with_overflow(*self, *v);\n-            if y { None } else { Some(x) }\n-        }\n-    }\n-}\n+uint_module!(u8)"}, {"sha": "61ab97e86b87c25350772be94301a73560499ebb", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 6, "deletions": 77, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -10,85 +10,14 @@\n \n //! Operations and constants for architecture-sized unsigned integers (`uint` type)\n \n-#![allow(non_uppercase_statics)]\n-#![allow(unsigned_negate)]\n-\n-use prelude::*;\n-\n-use default::Default;\n use from_str::FromStr;\n-use num::{Bitwise, Bounded};\n-use num::{CheckedAdd, CheckedSub, CheckedMul};\n-use num::{CheckedDiv, Zero, One, strconv};\n+use iter::Iterator;\n use num::{ToStrRadix, FromStrRadix};\n-use option::{Option, Some, None};\n+use num::strconv;\n+use option::Option;\n+use slice::{ImmutableVector, OwnedVector};\n use str;\n-use intrinsics;\n-\n-uint_module!(uint, int, ::int::BITS)\n-\n-#[cfg(target_word_size = \"32\")]\n-impl CheckedAdd for uint {\n-    #[inline]\n-    fn checked_add(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_add_with_overflow(*self as u32, *v as u32);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl CheckedAdd for uint {\n-    #[inline]\n-    fn checked_add(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_add_with_overflow(*self as u64, *v as u64);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-impl CheckedSub for uint {\n-    #[inline]\n-    fn checked_sub(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_sub_with_overflow(*self as u32, *v as u32);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl CheckedSub for uint {\n-    #[inline]\n-    fn checked_sub(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_sub_with_overflow(*self as u64, *v as u64);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n \n-#[cfg(target_word_size = \"32\")]\n-impl CheckedMul for uint {\n-    #[inline]\n-    fn checked_mul(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u32_mul_with_overflow(*self as u32, *v as u32);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n+pub use core::uint::{BITS, BYTES, MIN, MAX};\n \n-#[cfg(target_word_size = \"64\")]\n-impl CheckedMul for uint {\n-    #[inline]\n-    fn checked_mul(&self, v: &uint) -> Option<uint> {\n-        unsafe {\n-            let (x, y) = intrinsics::u64_mul_with_overflow(*self as u64, *v as u64);\n-            if y { None } else { Some(x as uint) }\n-        }\n-    }\n-}\n+uint_module!(uint)"}, {"sha": "3e64c17161368bcc1f387918f82d6327f71085a3", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 204, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -12,140 +12,7 @@\n #![doc(hidden)]\n #![allow(unsigned_negate)]\n \n-macro_rules! uint_module (($T:ty, $T_SIGNED:ty, $bits:expr) => (\n-\n-pub static BITS : uint = $bits;\n-pub static BYTES : uint = ($bits / 8);\n-\n-pub static MIN: $T = 0 as $T;\n-pub static MAX: $T = 0 as $T - 1 as $T;\n-\n-impl CheckedDiv for $T {\n-    #[inline]\n-    fn checked_div(&self, v: &$T) -> Option<$T> {\n-        if *v == 0 {\n-            None\n-        } else {\n-            Some(self / *v)\n-        }\n-    }\n-}\n-\n-impl Num for $T {}\n-\n-#[cfg(not(test))]\n-impl Ord for $T {\n-    #[inline]\n-    fn lt(&self, other: &$T) -> bool { (*self) < (*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl Eq for $T {\n-    #[inline]\n-    fn eq(&self, other: &$T) -> bool { return (*self) == (*other); }\n-}\n-\n-impl Default for $T {\n-    #[inline]\n-    fn default() -> $T { 0 }\n-}\n-\n-impl Zero for $T {\n-    #[inline]\n-    fn zero() -> $T { 0 }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool { *self == 0 }\n-}\n-\n-impl One for $T {\n-    #[inline]\n-    fn one() -> $T { 1 }\n-}\n-\n-#[cfg(not(test))]\n-impl Add<$T,$T> for $T {\n-    #[inline]\n-    fn add(&self, other: &$T) -> $T { *self + *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Sub<$T,$T> for $T {\n-    #[inline]\n-    fn sub(&self, other: &$T) -> $T { *self - *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Mul<$T,$T> for $T {\n-    #[inline]\n-    fn mul(&self, other: &$T) -> $T { *self * *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Div<$T,$T> for $T {\n-    #[inline]\n-    fn div(&self, other: &$T) -> $T { *self / *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Rem<$T,$T> for $T {\n-    #[inline]\n-    fn rem(&self, other: &$T) -> $T { *self % *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Neg<$T> for $T {\n-    #[inline]\n-    fn neg(&self) -> $T { -*self }\n-}\n-\n-impl Unsigned for $T {}\n-\n-#[cfg(not(test))]\n-impl BitOr<$T,$T> for $T {\n-    #[inline]\n-    fn bitor(&self, other: &$T) -> $T { *self | *other }\n-}\n-\n-#[cfg(not(test))]\n-impl BitAnd<$T,$T> for $T {\n-    #[inline]\n-    fn bitand(&self, other: &$T) -> $T { *self & *other }\n-}\n-\n-#[cfg(not(test))]\n-impl BitXor<$T,$T> for $T {\n-    #[inline]\n-    fn bitxor(&self, other: &$T) -> $T { *self ^ *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Shl<$T,$T> for $T {\n-    #[inline]\n-    fn shl(&self, other: &$T) -> $T { *self << *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Shr<$T,$T> for $T {\n-    #[inline]\n-    fn shr(&self, other: &$T) -> $T { *self >> *other }\n-}\n-\n-#[cfg(not(test))]\n-impl Not<$T> for $T {\n-    #[inline]\n-    fn not(&self) -> $T { !*self }\n-}\n-\n-impl Bounded for $T {\n-    #[inline]\n-    fn min_value() -> $T { MIN }\n-\n-    #[inline]\n-    fn max_value() -> $T { MAX }\n-}\n-\n-impl Int for $T {}\n+macro_rules! uint_module (($T:ty) => (\n \n // String conversion functions and impl str -> num\n \n@@ -211,7 +78,7 @@ impl ToStrRadix for $T {\n     /// Convert to a string in a given base.\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n-        let mut buf = Vec::new();\n+        let mut buf = ::vec::Vec::new();\n         strconv::int_to_str_bytes_common(*self, radix, strconv::SignNone, |i| {\n             buf.push(i);\n         });\n@@ -221,78 +88,15 @@ impl ToStrRadix for $T {\n     }\n }\n \n-impl Primitive for $T {}\n-\n-impl Bitwise for $T {\n-    /// Returns the number of ones in the binary representation of the number.\n-    #[inline]\n-    fn count_ones(&self) -> $T {\n-        (*self as $T_SIGNED).count_ones() as $T\n-    }\n-\n-    /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn leading_zeros(&self) -> $T {\n-        (*self as $T_SIGNED).leading_zeros() as $T\n-    }\n-\n-    /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n-    #[inline]\n-    fn trailing_zeros(&self) -> $T {\n-        (*self as $T_SIGNED).trailing_zeros() as $T\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n     use super::*;\n \n-    use num;\n-    use num::CheckedDiv;\n-    use num::Bitwise;\n     use num::ToStrRadix;\n     use str::StrSlice;\n     use u16;\n \n-    #[test]\n-    fn test_overflows() {\n-        assert!(MAX > 0);\n-        assert!(MIN <= 0);\n-        assert_eq!(MIN + MAX + 1, 0);\n-    }\n-\n-    #[test]\n-    fn test_num() {\n-        num::test_num(10 as $T, 2 as $T);\n-    }\n-\n-    #[test]\n-    fn test_bitwise() {\n-        assert_eq!(0b1110 as $T, (0b1100 as $T).bitor(&(0b1010 as $T)));\n-        assert_eq!(0b1000 as $T, (0b1100 as $T).bitand(&(0b1010 as $T)));\n-        assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(&(0b1010 as $T)));\n-        assert_eq!(0b1110 as $T, (0b0111 as $T).shl(&(1 as $T)));\n-        assert_eq!(0b0111 as $T, (0b1110 as $T).shr(&(1 as $T)));\n-        assert_eq!(MAX - (0b1011 as $T), (0b1011 as $T).not());\n-    }\n-\n-    #[test]\n-    fn test_count_ones() {\n-        assert_eq!((0b0101100 as $T).count_ones(), 3);\n-        assert_eq!((0b0100001 as $T).count_ones(), 2);\n-        assert_eq!((0b1111001 as $T).count_ones(), 5);\n-    }\n-\n-    #[test]\n-    fn test_count_zeros() {\n-        assert_eq!((0b0101100 as $T).count_zeros(), BITS as $T - 3);\n-        assert_eq!((0b0100001 as $T).count_zeros(), BITS as $T - 2);\n-        assert_eq!((0b1111001 as $T).count_zeros(), BITS as $T - 5);\n-    }\n-\n     #[test]\n     pub fn test_to_str() {\n         assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_owned());\n@@ -404,12 +208,6 @@ mod tests {\n     pub fn to_str_radix37() {\n         100u.to_str_radix(37u);\n     }\n-\n-    #[test]\n-    fn test_unsigned_checked_div() {\n-        assert_eq!(10u.checked_div(&2), Some(5));\n-        assert_eq!(5u.checked_div(&0), None);\n-    }\n }\n \n ))"}, {"sha": "8fbcd529b63b7a6abfa1449c8d6b4e17a1e3d5ab", "filename": "src/libstd/option.rs", "status": "modified", "additions": 12, "deletions": 727, "changes": 739, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -139,744 +139,29 @@\n //! ```\n \n use any::Any;\n-use clone::Clone;\n-use cmp::{Eq, TotalEq, TotalOrd};\n-use default::Default;\n-use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};\n use kinds::Send;\n-use mem;\n-use slice;\n \n-/// The `Option`\n-#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd, Show)]\n-pub enum Option<T> {\n-    /// No value\n-    None,\n-    /// Some value `T`\n-    Some(T)\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// Type implementation\n-/////////////////////////////////////////////////////////////////////////////\n-\n-impl<T> Option<T> {\n-    /////////////////////////////////////////////////////////////////////////\n-    // Querying the contained values\n-    /////////////////////////////////////////////////////////////////////////\n-\n-    /// Returns `true` if the option is a `Some` value\n-    #[inline]\n-    pub fn is_some(&self) -> bool {\n-        match *self {\n-            Some(_) => true,\n-            None => false\n-        }\n-    }\n-\n-    /// Returns `true` if the option is a `None` value\n-    #[inline]\n-    pub fn is_none(&self) -> bool {\n-        !self.is_some()\n-    }\n+pub use core::option::{Option, Some, None, Item, collect};\n \n-    /////////////////////////////////////////////////////////////////////////\n-    // Adapter for working with references\n-    /////////////////////////////////////////////////////////////////////////\n-\n-    /// Convert from `Option<T>` to `Option<&T>`\n-    ///\n-    /// # Example\n-    ///\n-    /// Convert an `Option<~str>` into an `Option<int>`, preserving the original.\n-    /// The `map` method takes the `self` argument by value, consuming the original,\n-    /// so this technique uses `as_ref` to first take an `Option` to a reference\n-    /// to the value inside the original.\n-    ///\n-    /// ```\n-    /// let num_as_str: Option<~str> = Some(\"10\".to_owned());\n-    /// // First, cast `Option<~str>` to `Option<&~str>` with `as_ref`,\n-    /// // then consume *that* with `map`, leaving `num_as_str` on the stack.\n-    /// let num_as_int: Option<uint> = num_as_str.as_ref().map(|n| n.len());\n-    /// println!(\"still can print num_as_str: {}\", num_as_str);\n-    /// ```\n-    #[inline]\n-    pub fn as_ref<'r>(&'r self) -> Option<&'r T> {\n-        match *self { Some(ref x) => Some(x), None => None }\n-    }\n-\n-    /// Convert from `Option<T>` to `Option<&mut T>`\n-    #[inline]\n-    pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {\n-        match *self { Some(ref mut x) => Some(x), None => None }\n-    }\n-\n-    /// Convert from `Option<T>` to `&[T]` (without copying)\n-    #[inline]\n-    pub fn as_slice<'r>(&'r self) -> &'r [T] {\n-        match *self {\n-            Some(ref x) => slice::ref_slice(x),\n-            None => &[]\n-        }\n-    }\n-\n-    /// Convert from `Option<T>` to `&mut [T]` (without copying)\n-    #[inline]\n-    pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n-        match *self {\n-            Some(ref mut x) => slice::mut_ref_slice(x),\n-            None => &mut []\n-        }\n-    }\n-\n-    /////////////////////////////////////////////////////////////////////////\n-    // Getting to contained values\n-    /////////////////////////////////////////////////////////////////////////\n+/// Extension trait for the `Option` type to add an `expect` method\n \n+// FIXME(#14008) should this trait even exist?\n+pub trait Expect<T> {\n     /// Unwraps an option, yielding the content of a `Some`\n     ///\n     /// # Failure\n     ///\n-    /// Fails if the value is a `None` with a custom failure message provided by `msg`.\n-    #[inline]\n-    pub fn expect<M: Any + Send>(self, msg: M) -> T {\n-        match self {\n-            Some(val) => val,\n-            None => fail!(msg),\n-        }\n-    }\n-\n-    /// Moves a value out of an option type and returns it, consuming the `Option`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the self value equals `None`.\n-    ///\n-    /// # Safety note\n-    ///\n-    /// In general, because this function may fail, its use is discouraged.\n-    /// Instead, prefer to use pattern matching and handle the `None`\n-    /// case explicitly.\n-    #[inline]\n-    pub fn unwrap(self) -> T {\n-        match self {\n-            Some(val) => val,\n-            None => fail!(\"called `Option::unwrap()` on a `None` value\"),\n-        }\n-    }\n-\n-    /// Returns the contained value or a default.\n-    #[inline]\n-    pub fn unwrap_or(self, def: T) -> T {\n-        match self {\n-            Some(x) => x,\n-            None => def\n-        }\n-    }\n-\n-    /// Returns the contained value or computes it from a closure.\n-    #[inline]\n-    pub fn unwrap_or_else(self, f: || -> T) -> T {\n-        match self {\n-            Some(x) => x,\n-            None => f()\n-        }\n-    }\n-\n-    /////////////////////////////////////////////////////////////////////////\n-    // Transforming contained values\n-    /////////////////////////////////////////////////////////////////////////\n-\n-    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value\n-    ///\n-    /// # Example\n-    ///\n-    /// Convert an `Option<~str>` into an `Option<uint>`, consuming the original:\n-    ///\n-    /// ```\n-    /// let num_as_str: Option<~str> = Some(\"10\".to_owned());\n-    /// // `Option::map` takes self *by value*, consuming `num_as_str`\n-    /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n-    /// ```\n-    #[inline]\n-    pub fn map<U>(self, f: |T| -> U) -> Option<U> {\n-        match self { Some(x) => Some(f(x)), None => None }\n-    }\n-\n-    /// Applies a function to the contained value or returns a default.\n-    #[inline]\n-    pub fn map_or<U>(self, def: U, f: |T| -> U) -> U {\n-        match self { None => def, Some(t) => f(t) }\n-    }\n-\n-    /// Applies a function to the contained value or does nothing.\n-    /// Returns true if the contained value was mutated.\n-    pub fn mutate(&mut self, f: |T| -> T) -> bool {\n-        if self.is_some() {\n-            *self = Some(f(self.take_unwrap()));\n-            true\n-        } else { false }\n-    }\n-\n-    /// Applies a function to the contained value or sets it to a default.\n-    /// Returns true if the contained value was mutated, or false if set to the default.\n-    pub fn mutate_or_set(&mut self, def: T, f: |T| -> T) -> bool {\n-        if self.is_some() {\n-            *self = Some(f(self.take_unwrap()));\n-            true\n-        } else {\n-            *self = Some(def);\n-            false\n-        }\n-    }\n-\n-    /////////////////////////////////////////////////////////////////////////\n-    // Iterator constructors\n-    /////////////////////////////////////////////////////////////////////////\n-\n-    /// Returns an iterator over the possibly contained value.\n-    #[inline]\n-    pub fn iter<'r>(&'r self) -> Item<&'r T> {\n-        Item{opt: self.as_ref()}\n-    }\n-\n-    /// Returns a mutable iterator over the possibly contained value.\n-    #[inline]\n-    pub fn mut_iter<'r>(&'r mut self) -> Item<&'r mut T> {\n-        Item{opt: self.as_mut()}\n-    }\n-\n-    /// Returns a consuming iterator over the possibly contained value.\n-    #[inline]\n-    pub fn move_iter(self) -> Item<T> {\n-        Item{opt: self}\n-    }\n-\n-    /////////////////////////////////////////////////////////////////////////\n-    // Boolean operations on the values, eager and lazy\n-    /////////////////////////////////////////////////////////////////////////\n-\n-    /// Returns `None` if the option is `None`, otherwise returns `optb`.\n-    #[inline]\n-    pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n-        match self {\n-            Some(_) => optb,\n-            None => None,\n-        }\n-    }\n-\n-    /// Returns `None` if the option is `None`, otherwise calls `f` with the\n-    /// wrapped value and returns the result.\n-    #[inline]\n-    pub fn and_then<U>(self, f: |T| -> Option<U>) -> Option<U> {\n-        match self {\n-            Some(x) => f(x),\n-            None => None,\n-        }\n-    }\n-\n-    /// Returns the option if it contains a value, otherwise returns `optb`.\n-    #[inline]\n-    pub fn or(self, optb: Option<T>) -> Option<T> {\n-        match self {\n-            Some(_) => self,\n-            None => optb\n-        }\n-    }\n-\n-    /// Returns the option if it contains a value, otherwise calls `f` and\n-    /// returns the result.\n-    #[inline]\n-    pub fn or_else(self, f: || -> Option<T>) -> Option<T> {\n-        match self {\n-            Some(_) => self,\n-            None => f()\n-        }\n-    }\n-\n-    /////////////////////////////////////////////////////////////////////////\n-    // Misc\n-    /////////////////////////////////////////////////////////////////////////\n-\n-    /// Takes the value out of the option, leaving a `None` in its place.\n-    #[inline]\n-    pub fn take(&mut self) -> Option<T> {\n-        mem::replace(self, None)\n-    }\n-\n-    /// Filters an optional value using a given function.\n-    #[inline(always)]\n-    pub fn filtered(self, f: |t: &T| -> bool) -> Option<T> {\n-        match self {\n-            Some(x) => if f(&x) { Some(x) } else { None },\n-            None => None\n-        }\n-    }\n-\n-    /// Applies a function zero or more times until the result is `None`.\n-    #[inline]\n-    pub fn while_some(self, f: |v: T| -> Option<T>) {\n-        let mut opt = self;\n-        loop {\n-            match opt {\n-                Some(x) => opt = f(x),\n-                None => break\n-            }\n-        }\n-    }\n-\n-    /////////////////////////////////////////////////////////////////////////\n-    // Common special cases\n-    /////////////////////////////////////////////////////////////////////////\n-\n-    /// The option dance. Moves a value out of an option type and returns it,\n-    /// replacing the original with `None`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value equals `None`.\n-    #[inline]\n-    pub fn take_unwrap(&mut self) -> T {\n-        match self.take() {\n-            Some(x) => x,\n-            None => fail!(\"called `Option::take_unwrap()` on a `None` value\")\n-        }\n-    }\n-\n-    /// Gets an immutable reference to the value inside an option.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value equals `None`\n-    ///\n-    /// # Safety note\n-    ///\n-    /// In general, because this function may fail, its use is discouraged\n-    /// (calling `get` on `None` is akin to dereferencing a null pointer).\n-    /// Instead, prefer to use pattern matching and handle the `None`\n-    /// case explicitly.\n-    #[inline]\n-    pub fn get_ref<'a>(&'a self) -> &'a T {\n-        match *self {\n-            Some(ref x) => x,\n-            None => fail!(\"called `Option::get_ref()` on a `None` value\"),\n-        }\n-    }\n-\n-    /// Gets a mutable reference to the value inside an option.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value equals `None`\n-    ///\n-    /// # Safety note\n-    ///\n-    /// In general, because this function may fail, its use is discouraged\n-    /// (calling `get` on `None` is akin to dereferencing a null pointer).\n-    /// Instead, prefer to use pattern matching and handle the `None`\n-    /// case explicitly.\n-    #[inline]\n-    pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n-        match *self {\n-            Some(ref mut x) => x,\n-            None => fail!(\"called `Option::get_mut_ref()` on a `None` value\"),\n-        }\n-    }\n+    /// Fails if the value is a `None` with a custom failure message provided by\n+    /// `msg`.\n+    fn expect<M: Any + Send>(self, m: M) -> T;\n }\n \n-impl<T: Default> Option<T> {\n-    /// Returns the contained value or a default\n-    ///\n-    /// Consumes the `self` argument then, if `Some`, returns the contained\n-    /// value, otherwise if `None`, returns the default value for that\n-    /// type.\n-    ///\n-    /// # Example\n-    ///\n-    /// Convert a string to an integer, turning poorly-formed strings\n-    /// into 0 (the default value for integers). `from_str` converts\n-    /// a string to any other type that implements `FromStr`, returning\n-    /// `None` on error.\n-    ///\n-    /// ```\n-    /// let good_year_from_input = \"1909\";\n-    /// let bad_year_from_input = \"190blarg\";\n-    /// let good_year = from_str(good_year_from_input).unwrap_or_default();\n-    /// let bad_year = from_str(bad_year_from_input).unwrap_or_default();\n-    ///\n-    /// assert_eq!(1909, good_year);\n-    /// assert_eq!(0, bad_year);\n-    /// ```\n+impl<T> Expect<T> for Option<T> {\n     #[inline]\n-    pub fn unwrap_or_default(self) -> T {\n+    fn expect<M: Any + Send>(self, msg: M) -> T {\n         match self {\n-            Some(x) => x,\n-            None => Default::default()\n-        }\n-    }\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// Trait implementations\n-/////////////////////////////////////////////////////////////////////////////\n-\n-impl<T> Default for Option<T> {\n-    #[inline]\n-    fn default() -> Option<T> { None }\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// The Option Iterator\n-/////////////////////////////////////////////////////////////////////////////\n-\n-/// An `Option` iterator that yields either one or zero elements\n-///\n-/// The `Item` iterator is returned by the `iter`, `mut_iter` and `move_iter`\n-/// methods on `Option`.\n-#[deriving(Clone)]\n-pub struct Item<A> {\n-    opt: Option<A>\n-}\n-\n-impl<A> Iterator<A> for Item<A> {\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        self.opt.take()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        match self.opt {\n-            Some(_) => (1, Some(1)),\n-            None => (0, Some(0)),\n-        }\n-    }\n-}\n-\n-impl<A> DoubleEndedIterator<A> for Item<A> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n-        self.opt.take()\n-    }\n-}\n-\n-impl<A> ExactSize<A> for Item<A> {}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// Free functions\n-/////////////////////////////////////////////////////////////////////////////\n-\n-/// Takes each element in the `Iterator`: if it is `None`, no further\n-/// elements are taken, and the `None` is returned. Should no `None` occur, a\n-/// vector containing the values of each `Option` is returned.\n-///\n-/// Here is an example which increments every integer in a vector,\n-/// checking for overflow:\n-///\n-///     fn inc_conditionally(x: uint) -> Option<uint> {\n-///         if x == uint::MAX { return None; }\n-///         else { return Some(x+1u); }\n-///     }\n-///     let v = [1u, 2, 3];\n-///     let res = collect(v.iter().map(|&x| inc_conditionally(x)));\n-///     assert!(res == Some(~[2u, 3, 4]));\n-#[inline]\n-pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(iter: Iter) -> Option<V> {\n-    // FIXME(#11084): This should be twice as fast once this bug is closed.\n-    let mut iter = iter.scan(false, |state, x| {\n-        match x {\n-            Some(x) => Some(x),\n-            None => {\n-                *state = true;\n-                None\n-            }\n-        }\n-    });\n-\n-    let v: V = FromIterator::from_iter(iter.by_ref());\n-\n-    if iter.state {\n-        None\n-    } else {\n-        Some(v)\n-    }\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// Tests\n-/////////////////////////////////////////////////////////////////////////////\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use prelude::*;\n-\n-    use iter::range;\n-    use str::StrSlice;\n-    use kinds::marker;\n-    use slice::ImmutableVector;\n-\n-    #[test]\n-    fn test_get_ptr() {\n-        unsafe {\n-            let x = box 0;\n-            let addr_x: *int = ::cast::transmute(&*x);\n-            let opt = Some(x);\n-            let y = opt.unwrap();\n-            let addr_y: *int = ::cast::transmute(&*y);\n-            assert_eq!(addr_x, addr_y);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_get_str() {\n-        let x = \"test\".to_owned();\n-        let addr_x = x.as_ptr();\n-        let opt = Some(x);\n-        let y = opt.unwrap();\n-        let addr_y = y.as_ptr();\n-        assert_eq!(addr_x, addr_y);\n-    }\n-\n-    #[test]\n-    fn test_get_resource() {\n-        use rc::Rc;\n-        use cell::RefCell;\n-\n-        struct R {\n-           i: Rc<RefCell<int>>,\n-        }\n-\n-        #[unsafe_destructor]\n-        impl ::ops::Drop for R {\n-           fn drop(&mut self) {\n-                let ii = &*self.i;\n-                let i = ii.borrow().clone();\n-                *ii.borrow_mut() = i + 1;\n-            }\n-        }\n-\n-        fn R(i: Rc<RefCell<int>>) -> R {\n-            R {\n-                i: i\n-            }\n-        }\n-\n-        let i = Rc::new(RefCell::new(0));\n-        {\n-            let x = R(i.clone());\n-            let opt = Some(x);\n-            let _y = opt.unwrap();\n-        }\n-        assert_eq!(*i.borrow(), 1);\n-    }\n-\n-    #[test]\n-    fn test_option_dance() {\n-        let x = Some(());\n-        let mut y = Some(5);\n-        let mut y2 = 0;\n-        for _x in x.iter() {\n-            y2 = y.take_unwrap();\n-        }\n-        assert_eq!(y2, 5);\n-        assert!(y.is_none());\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_option_too_much_dance() {\n-        let mut y = Some(marker::NoCopy);\n-        let _y2 = y.take_unwrap();\n-        let _y3 = y.take_unwrap();\n-    }\n-\n-    #[test]\n-    fn test_and() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.and(Some(2)), Some(2));\n-        assert_eq!(x.and(None::<int>), None);\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.and(Some(2)), None);\n-        assert_eq!(x.and(None::<int>), None);\n-    }\n-\n-    #[test]\n-    fn test_and_then() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.and_then(|x| Some(x + 1)), Some(2));\n-        assert_eq!(x.and_then(|_| None::<int>), None);\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.and_then(|x| Some(x + 1)), None);\n-        assert_eq!(x.and_then(|_| None::<int>), None);\n-    }\n-\n-    #[test]\n-    fn test_or() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.or(Some(2)), Some(1));\n-        assert_eq!(x.or(None), Some(1));\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.or(Some(2)), Some(2));\n-        assert_eq!(x.or(None), None);\n-    }\n-\n-    #[test]\n-    fn test_or_else() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.or_else(|| Some(2)), Some(1));\n-        assert_eq!(x.or_else(|| None), Some(1));\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.or_else(|| Some(2)), Some(2));\n-        assert_eq!(x.or_else(|| None), None);\n-    }\n-\n-    #[test]\n-    fn test_option_while_some() {\n-        let mut i = 0;\n-        Some(10).while_some(|j| {\n-            i += 1;\n-            if j > 0 {\n-                Some(j-1)\n-            } else {\n-                None\n-            }\n-        });\n-        assert_eq!(i, 11);\n-    }\n-\n-    #[test]\n-    fn test_unwrap() {\n-        assert_eq!(Some(1).unwrap(), 1);\n-        assert_eq!(Some(\"hello\".to_owned()).unwrap(), \"hello\".to_owned());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_unwrap_fail1() {\n-        let x: Option<int> = None;\n-        x.unwrap();\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_unwrap_fail2() {\n-        let x: Option<~str> = None;\n-        x.unwrap();\n-    }\n-\n-    #[test]\n-    fn test_unwrap_or() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.unwrap_or(2), 1);\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.unwrap_or(2), 2);\n-    }\n-\n-    #[test]\n-    fn test_unwrap_or_else() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.unwrap_or_else(|| 2), 1);\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.unwrap_or_else(|| 2), 2);\n-    }\n-\n-    #[test]\n-    fn test_filtered() {\n-        let some_stuff = Some(42);\n-        let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n-        assert_eq!(some_stuff.unwrap(), 42);\n-        assert!(modified_stuff.is_none());\n-    }\n-\n-    #[test]\n-    fn test_iter() {\n-        let val = 5;\n-\n-        let x = Some(val);\n-        let mut it = x.iter();\n-\n-        assert_eq!(it.size_hint(), (1, Some(1)));\n-        assert_eq!(it.next(), Some(&val));\n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_mut_iter() {\n-        let val = 5;\n-        let new_val = 11;\n-\n-        let mut x = Some(val);\n-        {\n-            let mut it = x.mut_iter();\n-\n-            assert_eq!(it.size_hint(), (1, Some(1)));\n-\n-            match it.next() {\n-                Some(interior) => {\n-                    assert_eq!(*interior, val);\n-                    *interior = new_val;\n-                }\n-                None => assert!(false),\n-            }\n-\n-            assert_eq!(it.size_hint(), (0, Some(0)));\n-            assert!(it.next().is_none());\n+            Some(val) => val,\n+            None => fail!(msg),\n         }\n-        assert_eq!(x, Some(new_val));\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let small = Some(1.0);\n-        let big = Some(5.0);\n-        let nan = Some(0.0/0.0);\n-        assert!(!(nan < big));\n-        assert!(!(nan > big));\n-        assert!(small < big);\n-        assert!(None < big);\n-        assert!(big > None);\n-    }\n-\n-    #[test]\n-    fn test_mutate() {\n-        let mut x = Some(3i);\n-        assert!(x.mutate(|i| i+1));\n-        assert_eq!(x, Some(4i));\n-        assert!(x.mutate_or_set(0, |i| i+1));\n-        assert_eq!(x, Some(5i));\n-        x = None;\n-        assert!(!x.mutate(|i| i+1));\n-        assert_eq!(x, None);\n-        assert!(!x.mutate_or_set(0i, |i| i+1));\n-        assert_eq!(x, Some(0i));\n-    }\n-\n-    #[test]\n-    fn test_collect() {\n-        let v: Option<~[int]> = collect(range(0, 0)\n-                                        .map(|_| Some(0)));\n-        assert_eq!(v, Some(box []));\n-\n-        let v: Option<~[int]> = collect(range(0, 3)\n-                                        .map(|x| Some(x)));\n-        assert_eq!(v, Some(box [0, 1, 2]));\n-\n-        let v: Option<~[int]> = collect(range(0, 3)\n-                                        .map(|x| if x > 1 { None } else { Some(x) }));\n-        assert_eq!(v, None);\n-\n-        // test that it does not take more elements than it needs\n-        let mut functions = [|| Some(()), || None, || fail!()];\n-\n-        let v: Option<~[()]> = collect(functions.mut_iter().map(|f| (*f)()));\n-\n-        assert_eq!(v, None);\n     }\n }"}, {"sha": "809757aaf4d0281a6445038a9f84d6d6cc64b245", "filename": "src/libstd/os.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -38,7 +38,7 @@ use ops::Drop;\n use result::{Err, Ok, Result};\n use ptr;\n use str;\n-use str::{Str, StrSlice};\n+use str::{Str, StrSlice, StrAllocating};\n use fmt;\n use sync::atomics::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use path::{Path, GenericPath};\n@@ -81,6 +81,8 @@ pub fn getcwd() -> Path {\n pub fn getcwd() -> Path {\n     use libc::DWORD;\n     use libc::GetCurrentDirectoryW;\n+    use option::Expect;\n+\n     let mut buf = [0 as u16, ..BUF_BYTES];\n     unsafe {\n         if libc::GetCurrentDirectoryW(buf.len() as DWORD, buf.as_mut_ptr()) == 0 as DWORD {\n@@ -96,11 +98,11 @@ pub mod win32 {\n     use iter::Iterator;\n     use libc::types::os::arch::extra::DWORD;\n     use libc;\n-    use option::{None, Option};\n+    use option::{None, Option, Expect};\n     use option;\n     use os::TMPBUF_SZ;\n     use slice::{MutableVector, ImmutableVector, OwnedVector};\n-    use str::StrSlice;\n+    use str::{StrSlice, StrAllocating};\n     use str;\n     use vec::Vec;\n \n@@ -182,7 +184,6 @@ pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n         #[cfg(windows)]\n         unsafe fn get_env_pairs() -> Vec<~[u8]> {\n             use c_str;\n-            use str::StrSlice;\n \n             use libc::funcs::extra::kernel32::{\n                 GetEnvironmentStringsA,\n@@ -830,6 +831,7 @@ fn real_args() -> ~[~str] {\n #[cfg(windows)]\n fn real_args() -> ~[~str] {\n     use slice;\n+    use option::Expect;\n \n     let mut nArgs: c_int = 0;\n     let lpArgCount: *mut c_int = &mut nArgs;"}, {"sha": "f21fbe1b6e669d2ad8423e15b3e02bda21040eb1", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -21,7 +21,7 @@ use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Rev, Iterator, Map};\n use option::{Option, Some, None};\n use slice::{Vector, OwnedVector, ImmutableVector};\n-use str::{CharSplits, Str, StrVector, StrSlice};\n+use str::{CharSplits, Str, StrAllocating, StrVector, StrSlice};\n use strbuf::StrBuf;\n use vec::Vec;\n \n@@ -684,7 +684,7 @@ impl Path {\n         }\n     }\n \n-    fn normalize_<S: Str>(s: S) -> (Option<PathPrefix>, StrBuf) {\n+    fn normalize_<S: StrAllocating>(s: S) -> (Option<PathPrefix>, StrBuf) {\n         // make borrowck happy\n         let (prefix, val) = {\n             let prefix = parse_prefix(s.as_slice());\n@@ -842,7 +842,7 @@ impl Path {\n     }\n \n     fn update_normalized<S: Str>(&mut self, s: S) {\n-        let (prefix, path) = Path::normalize_(s);\n+        let (prefix, path) = Path::normalize_(s.as_slice());\n         self.repr = path;\n         self.prefix = prefix;\n         self.update_sepidx();"}, {"sha": "6cd9e96496fe0ae85fb3557435cd3df7cffe3e91", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -65,18 +65,21 @@ pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n pub use num::{Signed, Unsigned};\n pub use num::{Primitive, Int, Float, ToPrimitive, FromPrimitive};\n+pub use option::Expect;\n pub use owned::Box;\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;\n pub use io::{Buffer, Writer, Reader, Seek};\n+pub use result::{ResultUnwrap, ResultUnwrapErr};\n pub use str::{Str, StrVector, StrSlice, OwnedStr, IntoMaybeOwned};\n+pub use str::{StrAllocating};\n pub use to_str::{ToStr, IntoStr};\n pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n pub use slice::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCloneableVector};\n pub use slice::{OwnedVector};\n-pub use slice::{MutableVector, MutableTotalOrdVector};\n+pub use slice::{MutableVector, MutableTotalOrdVector, MutableVectorAllocating};\n pub use slice::{Vector, VectorVector, CloneableVector, ImmutableVector};\n pub use strbuf::StrBuf;\n pub use vec::Vec;"}, {"sha": "eb615afd85f9a2192599a0081324fc48ba80d579", "filename": "src/libstd/reference.rs", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/445988b47811679144d0fa9b3a2ccf2348752850/src%2Flibstd%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445988b47811679144d0fa9b3a2ccf2348752850/src%2Flibstd%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freference.rs?ref=445988b47811679144d0fa9b3a2ccf2348752850", "patch": "@@ -1,57 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Utilities for references\n-\n-#[cfg(not(test))]\n-use cmp::{Eq, Ord, Ordering, TotalEq, TotalOrd};\n-\n-// Equality for region pointers\n-#[cfg(not(test))]\n-impl<'a, T: Eq> Eq for &'a T {\n-    #[inline]\n-    fn eq(&self, other: & &'a T) -> bool {\n-        *(*self) == *(*other)\n-    }\n-    #[inline]\n-    fn ne(&self, other: & &'a T) -> bool {\n-        *(*self) != *(*other)\n-    }\n-}\n-\n-// Comparison for region pointers\n-#[cfg(not(test))]\n-impl<'a, T: Ord> Ord for &'a T {\n-    #[inline]\n-    fn lt(&self, other: & &'a T) -> bool {\n-        *(*self) < *(*other)\n-    }\n-    #[inline]\n-    fn le(&self, other: & &'a T) -> bool {\n-        *(*self) <= *(*other)\n-    }\n-    #[inline]\n-    fn ge(&self, other: & &'a T) -> bool {\n-        *(*self) >= *(*other)\n-    }\n-    #[inline]\n-    fn gt(&self, other: & &'a T) -> bool {\n-        *(*self) > *(*other)\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl<'a, T: TotalOrd> TotalOrd for &'a T {\n-    #[inline]\n-    fn cmp(&self, other: & &'a T) -> Ordering { (**self).cmp(*other) }\n-}\n-\n-#[cfg(not(test))]\n-impl<'a, T: TotalEq> TotalEq for &'a T {}"}, {"sha": "35c5cbc85c3a2a2c604d52bfffa8cc02ff5d4c32", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -25,7 +25,7 @@ use option::{Some, None, Option};\n use ptr::RawPtr;\n use reflect;\n use reflect::{MovePtr, align};\n-use result::{Ok, Err};\n+use result::{Ok, Err, ResultUnwrap};\n use str::StrSlice;\n use to_str::ToStr;\n use slice::Vector;\n@@ -606,6 +606,7 @@ pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {\n \n pub fn repr_to_str<T>(t: &T) -> ~str {\n     use str;\n+    use str::StrAllocating;\n     use io;\n \n     let mut result = io::MemWriter::new();\n@@ -624,7 +625,6 @@ fn test_repr() {\n     use io::stdio::println;\n     use char::is_alphabetic;\n     use mem::swap;\n-    use owned::Box;\n \n     fn exact_test<T>(t: &T, e:&str) {\n         let mut m = io::MemWriter::new();"}, {"sha": "cc9e6684d283617e5cb5cac5575976e91aaf6598", "filename": "src/libstd/result.rs", "status": "modified", "additions": 19, "deletions": 490, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -266,262 +266,32 @@\n //! the context. The caller of `fail!` should assume that execution\n //! will not resume after failure, that failure is catastrophic.\n \n-use clone::Clone;\n-use cmp::Eq;\n-use std::fmt::Show;\n-use iter::{Iterator, FromIterator};\n-use option::{None, Option, Some};\n+use fmt::Show;\n \n-/// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n-///\n-/// See the [`std::result`](index.html) module documentation for details.\n-#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd, Show, Hash)]\n-#[must_use]\n-pub enum Result<T, E> {\n-    /// Contains the success value\n-    Ok(T),\n-\n-    /// Contains the error value\n-    Err(E)\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// Type implementation\n-/////////////////////////////////////////////////////////////////////////////\n-\n-impl<T, E> Result<T, E> {\n-    /////////////////////////////////////////////////////////////////////////\n-    // Querying the contained values\n-    /////////////////////////////////////////////////////////////////////////\n-\n-    /// Returns true if the result is `Ok`\n-    ///\n-    /// # Example\n-    ///\n-    /// ~~~\n-    /// use std::io::{File, Open, Write};\n-    ///\n-    /// # fn do_not_run_example() { // creates a file\n-    /// let mut file = File::open_mode(&Path::new(\"secret.txt\"), Open, Write);\n-    /// assert!(file.write_line(\"it's cold in here\").is_ok());\n-    /// # }\n-    /// ~~~\n-    #[inline]\n-    pub fn is_ok(&self) -> bool {\n-        match *self {\n-            Ok(_) => true,\n-            Err(_) => false\n-        }\n-    }\n-\n-    /// Returns true if the result is `Err`\n-    ///\n-    /// # Example\n-    ///\n-    /// ~~~\n-    /// use std::io::{File, Open, Read};\n-    ///\n-    /// // When opening with `Read` access, if the file does not exist\n-    /// // then `open_mode` returns an error.\n-    /// let bogus = File::open_mode(&Path::new(\"not_a_file.txt\"), Open, Read);\n-    /// assert!(bogus.is_err());\n-    /// ~~~\n-    #[inline]\n-    pub fn is_err(&self) -> bool {\n-        !self.is_ok()\n-    }\n+pub use core::result::{Result, Ok, Err, collect, fold, fold_};\n \n+// FIXME: These traits should not exist. Once std::fmt is moved to libcore,\n+//        these can once again become inherent methods on Result.\n \n-    /////////////////////////////////////////////////////////////////////////\n-    // Adapter for each variant\n-    /////////////////////////////////////////////////////////////////////////\n-\n-    /// Convert from `Result<T, E>` to `Option<T>`\n-    ///\n-    /// Converts `self` into an `Option<T>`, consuming `self`,\n-    /// and discarding the error, if any.\n-    ///\n-    /// To convert to an `Option` without discarding the error value,\n-    /// use `as_ref` to first convert the `Result<T, E>` into a\n-    /// `Result<&T, &E>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ~~~{.should_fail}\n-    /// use std::io::{File, IoResult};\n-    ///\n-    /// let bdays: IoResult<File> = File::open(&Path::new(\"important_birthdays.txt\"));\n-    /// let bdays: File = bdays.ok().expect(\"unable to open birthday file\");\n-    /// ~~~\n-    #[inline]\n-    pub fn ok(self) -> Option<T> {\n-        match self {\n-            Ok(x)  => Some(x),\n-            Err(_) => None,\n-        }\n-    }\n-\n-    /// Convert from `Result<T, E>` to `Option<E>`\n-    ///\n-    /// Converts `self` into an `Option<T>`, consuming `self`,\n-    /// and discarding the value, if any.\n-    #[inline]\n-    pub fn err(self) -> Option<E> {\n-        match self {\n-            Ok(_)  => None,\n-            Err(x) => Some(x),\n-        }\n-    }\n-\n-    /////////////////////////////////////////////////////////////////////////\n-    // Adapter for working with references\n-    /////////////////////////////////////////////////////////////////////////\n-\n-    /// Convert from `Result<T, E>` to `Result<&T, &E>`\n-    ///\n-    /// Produces a new `Result`, containing a reference\n-    /// into the original, leaving the original in place.\n-    #[inline]\n-    pub fn as_ref<'r>(&'r self) -> Result<&'r T, &'r E> {\n-        match *self {\n-            Ok(ref x) => Ok(x),\n-            Err(ref x) => Err(x),\n-        }\n-    }\n-\n-    /// Convert from `Result<T, E>` to `Result<&mut T, &mut E>`\n-    #[inline]\n-    pub fn as_mut<'r>(&'r mut self) -> Result<&'r mut T, &'r mut E> {\n-        match *self {\n-            Ok(ref mut x) => Ok(x),\n-            Err(ref mut x) => Err(x),\n-        }\n-    }\n-\n-    /////////////////////////////////////////////////////////////////////////\n-    // Transforming contained values\n-    /////////////////////////////////////////////////////////////////////////\n-\n-    /// Maps a `Result<T, E>` to `Result<U, E>` by applying a function to an\n-    /// contained `Ok` value, leaving an `Err` value untouched.\n-    ///\n-    /// This function can be used to compose the results of two functions.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Sum the lines of a buffer by mapping strings to numbers,\n-    /// ignoring I/O and parse errors:\n-    ///\n-    /// ~~~\n-    /// use std::io::{BufReader, IoResult};\n-    ///\n-    /// let buffer = \"1\\n2\\n3\\n4\\n\";\n-    /// let mut reader = BufReader::new(buffer.as_bytes());\n-    ///\n-    /// let mut sum = 0;\n-    ///\n-    /// while !reader.eof() {\n-    ///     let line: IoResult<~str> = reader.read_line();\n-    ///     // Convert the string line to a number using `map` and `from_str`\n-    ///     let val: IoResult<int> = line.map(|line| {\n-    ///         from_str::<int>(line).unwrap_or(0)\n-    ///     });\n-    ///     // Add the value if there were no errors, otherwise add 0\n-    ///     sum += val.ok().unwrap_or(0);\n-    /// }\n-    /// ~~~\n-    #[inline]\n-    pub fn map<U>(self, op: |T| -> U) -> Result<U,E> {\n-        match self {\n-          Ok(t) => Ok(op(t)),\n-          Err(e) => Err(e)\n-        }\n-    }\n-\n-    /// Maps a `Result<T, E>` to `Result<T, F>` by applying a function to an\n-    /// contained `Err` value, leaving an `Ok` value untouched.\n-    ///\n-    /// This function can be used to pass through a successful result while handling\n-    /// an error.\n-    #[inline]\n-    pub fn map_err<F>(self, op: |E| -> F) -> Result<T,F> {\n-        match self {\n-          Ok(t) => Ok(t),\n-          Err(e) => Err(op(e))\n-        }\n-    }\n-\n-    ////////////////////////////////////////////////////////////////////////\n-    // Boolean operations on the values, eager and lazy\n-    /////////////////////////////////////////////////////////////////////////\n-\n-    /// Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n-    #[inline]\n-    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n-        match self {\n-            Ok(_) => res,\n-            Err(e) => Err(e),\n-        }\n-    }\n-\n-    /// Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n+/// Temporary trait for unwrapping a result\n+pub trait ResultUnwrap<T, E> {\n+    /// Unwraps a result, yielding the content of an `Ok`.\n     ///\n-    /// This function can be used for control flow based on result values\n-    #[inline]\n-    pub fn and_then<U>(self, op: |T| -> Result<U, E>) -> Result<U, E> {\n-        match self {\n-            Ok(t) => op(t),\n-            Err(e) => Err(e),\n-        }\n-    }\n-\n-    /// Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n-    #[inline]\n-    pub fn or(self, res: Result<T, E>) -> Result<T, E> {\n-        match self {\n-            Ok(_) => self,\n-            Err(_) => res,\n-        }\n-    }\n+    /// Fails if the value is an `Err`.\n+    fn unwrap(self) -> T;\n+}\n \n-    /// Calls `op` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n+/// Temporary trait for unwrapping the error of a result\n+pub trait ResultUnwrapErr<T, E> {\n+    /// Unwraps a result, yielding the content of an `Err`.\n     ///\n-    /// This function can be used for control flow based on result values\n-    #[inline]\n-    pub fn or_else<F>(self, op: |E| -> Result<T, F>) -> Result<T, F> {\n-        match self {\n-            Ok(t) => Ok(t),\n-            Err(e) => op(e),\n-        }\n-    }\n-\n-    /// Unwraps a result, yielding the content of an `Ok`.\n-    /// Else it returns `optb`.\n-    #[inline]\n-    pub fn unwrap_or(self, optb: T) -> T {\n-        match self {\n-            Ok(t) => t,\n-            Err(_) => optb\n-        }\n-    }\n-\n-    /// Unwraps a result, yielding the content of an `Ok`.\n-    /// If the value is an `Err` then it calls `op` with its value.\n-    #[inline]\n-    pub fn unwrap_or_handle(self, op: |E| -> T) -> T {\n-        match self {\n-            Ok(t) => t,\n-            Err(e) => op(e)\n-        }\n-    }\n+    /// Fails if the value is an `Ok`.\n+    fn unwrap_err(self) -> E;\n }\n \n-impl<T, E: Show> Result<T, E> {\n-    /// Unwraps a result, yielding the content of an `Ok`.\n-    ///\n-    /// Fails if the value is an `Err`.\n+impl<T, E: Show> ResultUnwrap<T, E> for Result<T, E> {\n     #[inline]\n-    pub fn unwrap(self) -> T {\n+    fn unwrap(self) -> T {\n         match self {\n             Ok(t) => t,\n             Err(e) =>\n@@ -530,254 +300,13 @@ impl<T, E: Show> Result<T, E> {\n     }\n }\n \n-impl<T: Show, E> Result<T, E> {\n-    /// Unwraps a result, yielding the content of an `Err`.\n-    ///\n-    /// Fails if the value is an `Ok`.\n+impl<T: Show, E> ResultUnwrapErr<T, E> for Result<T, E> {\n     #[inline]\n-    pub fn unwrap_err(self) -> E {\n+    fn unwrap_err(self) -> E {\n         match self {\n             Ok(t) =>\n                 fail!(\"called `Result::unwrap_err()` on an `Ok` value: {}\", t),\n             Err(e) => e\n         }\n     }\n }\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// Free functions\n-/////////////////////////////////////////////////////////////////////////////\n-\n-/// Takes each element in the `Iterator`: if it is an `Err`, no further\n-/// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n-/// vector containing the values of each `Result` is returned.\n-///\n-/// Here is an example which increments every integer in a vector,\n-/// checking for overflow:\n-///\n-///     fn inc_conditionally(x: uint) -> Result<uint, &'static str> {\n-///         if x == uint::MAX { return Err(\"overflow\"); }\n-///         else { return Ok(x+1u); }\n-///     }\n-///     let v = [1u, 2, 3];\n-///     let res = collect(v.iter().map(|&x| inc_conditionally(x)));\n-///     assert!(res == Ok(~[2u, 3, 4]));\n-#[inline]\n-pub fn collect<T, E, Iter: Iterator<Result<T, E>>, V: FromIterator<T>>(iter: Iter) -> Result<V, E> {\n-    // FIXME(#11084): This should be twice as fast once this bug is closed.\n-    let mut iter = iter.scan(None, |state, x| {\n-        match x {\n-            Ok(x) => Some(x),\n-            Err(err) => {\n-                *state = Some(err);\n-                None\n-            }\n-        }\n-    });\n-\n-    let v: V = FromIterator::from_iter(iter.by_ref());\n-\n-    match iter.state {\n-        Some(err) => Err(err),\n-        None => Ok(v),\n-    }\n-}\n-\n-/// Perform a fold operation over the result values from an iterator.\n-///\n-/// If an `Err` is encountered, it is immediately returned.\n-/// Otherwise, the folded value is returned.\n-#[inline]\n-pub fn fold<T,\n-            V,\n-            E,\n-            Iter: Iterator<Result<T, E>>>(\n-            mut iterator: Iter,\n-            mut init: V,\n-            f: |V, T| -> V)\n-            -> Result<V, E> {\n-    for t in iterator {\n-        match t {\n-            Ok(v) => init = f(init, v),\n-            Err(u) => return Err(u)\n-        }\n-    }\n-    Ok(init)\n-}\n-\n-/// Perform a trivial fold operation over the result values\n-/// from an iterator.\n-///\n-/// If an `Err` is encountered, it is immediately returned.\n-/// Otherwise, a simple `Ok(())` is returned.\n-#[inline]\n-pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n-    fold(iterator, (), |_, _| ())\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// Tests\n-/////////////////////////////////////////////////////////////////////////////\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use prelude::*;\n-    use str::StrSlice;\n-\n-    use iter::range;\n-\n-    pub fn op1() -> Result<int, ~str> { Ok(666) }\n-    pub fn op2() -> Result<int, ~str> { Err(\"sadface\".to_owned()) }\n-\n-    #[test]\n-    pub fn test_and() {\n-        assert_eq!(op1().and(Ok(667)).unwrap(), 667);\n-        assert_eq!(op1().and(Err::<(), ~str>(\"bad\".to_owned())).unwrap_err(), \"bad\".to_owned());\n-\n-        assert_eq!(op2().and(Ok(667)).unwrap_err(), \"sadface\".to_owned());\n-        assert_eq!(op2().and(Err::<(), ~str>(\"bad\".to_owned())).unwrap_err(), \"sadface\".to_owned());\n-    }\n-\n-    #[test]\n-    pub fn test_and_then() {\n-        assert_eq!(op1().and_then(|i| Ok::<int, ~str>(i + 1)).unwrap(), 667);\n-        assert_eq!(op1().and_then(|_| Err::<int, ~str>(\"bad\".to_owned())).unwrap_err(),\n-                   \"bad\".to_owned());\n-\n-        assert_eq!(op2().and_then(|i| Ok::<int, ~str>(i + 1)).unwrap_err(),\n-                   \"sadface\".to_owned());\n-        assert_eq!(op2().and_then(|_| Err::<int, ~str>(\"bad\".to_owned())).unwrap_err(),\n-                   \"sadface\".to_owned());\n-    }\n-\n-    #[test]\n-    pub fn test_or() {\n-        assert_eq!(op1().or(Ok(667)).unwrap(), 666);\n-        assert_eq!(op1().or(Err(\"bad\".to_owned())).unwrap(), 666);\n-\n-        assert_eq!(op2().or(Ok(667)).unwrap(), 667);\n-        assert_eq!(op2().or(Err(\"bad\".to_owned())).unwrap_err(), \"bad\".to_owned());\n-    }\n-\n-    #[test]\n-    pub fn test_or_else() {\n-        assert_eq!(op1().or_else(|_| Ok::<int, ~str>(667)).unwrap(), 666);\n-        assert_eq!(op1().or_else(|e| Err::<int, ~str>(e + \"!\")).unwrap(), 666);\n-\n-        assert_eq!(op2().or_else(|_| Ok::<int, ~str>(667)).unwrap(), 667);\n-        assert_eq!(op2().or_else(|e| Err::<int, ~str>(e + \"!\")).unwrap_err(),\n-                   \"sadface!\".to_owned());\n-    }\n-\n-    #[test]\n-    pub fn test_impl_map() {\n-        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"), Ok(\"ab\".to_owned()));\n-        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"), Err(\"a\".to_owned()));\n-    }\n-\n-    #[test]\n-    pub fn test_impl_map_err() {\n-        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"), Ok(\"a\".to_owned()));\n-        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"), Err(\"ab\".to_owned()));\n-    }\n-\n-    #[test]\n-    fn test_collect() {\n-        let v: Result<~[int], ()> = collect(range(0, 0).map(|_| Ok::<int, ()>(0)));\n-        assert_eq!(v, Ok(box []));\n-\n-        let v: Result<~[int], ()> = collect(range(0, 3).map(|x| Ok::<int, ()>(x)));\n-        assert_eq!(v, Ok(box [0, 1, 2]));\n-\n-        let v: Result<~[int], int> = collect(range(0, 3)\n-                                             .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n-        assert_eq!(v, Err(2));\n-\n-        // test that it does not take more elements than it needs\n-        let mut functions = [|| Ok(()), || Err(1), || fail!()];\n-\n-        let v: Result<~[()], int> = collect(functions.mut_iter().map(|f| (*f)()));\n-        assert_eq!(v, Err(1));\n-    }\n-\n-    #[test]\n-    fn test_fold() {\n-        assert_eq!(fold_(range(0, 0)\n-                        .map(|_| Ok::<(), ()>(()))),\n-                   Ok(()));\n-        assert_eq!(fold(range(0, 3)\n-                        .map(|x| Ok::<int, ()>(x)),\n-                        0, |a, b| a + b),\n-                   Ok(3));\n-        assert_eq!(fold_(range(0, 3)\n-                        .map(|x| if x > 1 { Err(x) } else { Ok(()) })),\n-                   Err(2));\n-\n-        // test that it does not take more elements than it needs\n-        let mut functions = [|| Ok(()), || Err(1), || fail!()];\n-\n-        assert_eq!(fold_(functions.mut_iter()\n-                        .map(|f| (*f)())),\n-                   Err(1));\n-    }\n-\n-    #[test]\n-    pub fn test_to_str() {\n-        let ok: Result<int, ~str> = Ok(100);\n-        let err: Result<int, ~str> = Err(\"Err\".to_owned());\n-\n-        assert_eq!(ok.to_str(), \"Ok(100)\".to_owned());\n-        assert_eq!(err.to_str(), \"Err(Err)\".to_owned());\n-    }\n-\n-    #[test]\n-    pub fn test_fmt_default() {\n-        let ok: Result<int, ~str> = Ok(100);\n-        let err: Result<int, ~str> = Err(\"Err\".to_owned());\n-\n-        assert_eq!(format!(\"{}\", ok), \"Ok(100)\".to_owned());\n-        assert_eq!(format!(\"{}\", err), \"Err(Err)\".to_owned());\n-    }\n-\n-    #[test]\n-    pub fn test_unwrap_or() {\n-        let ok: Result<int, ~str> = Ok(100);\n-        let ok_err: Result<int, ~str> = Err(\"Err\".to_owned());\n-\n-        assert_eq!(ok.unwrap_or(50), 100);\n-        assert_eq!(ok_err.unwrap_or(50), 50);\n-    }\n-\n-    #[test]\n-    pub fn test_unwrap_or_else() {\n-        fn handler(msg: ~str) -> int {\n-            if msg == \"I got this.\".to_owned() {\n-                50\n-            } else {\n-                fail!(\"BadBad\")\n-            }\n-        }\n-\n-        let ok: Result<int, ~str> = Ok(100);\n-        let ok_err: Result<int, ~str> = Err(\"I got this.\".to_owned());\n-\n-        assert_eq!(ok.unwrap_or_handle(handler), 100);\n-        assert_eq!(ok_err.unwrap_or_handle(handler), 50);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    pub fn test_unwrap_or_else_failure() {\n-        fn handler(msg: ~str) -> int {\n-            if msg == \"I got this.\".to_owned() {\n-                50\n-            } else {\n-                fail!(\"BadBad\")\n-            }\n-        }\n-\n-        let bad_err: Result<int, ~str> = Err(\"Unrecoverable mess.\".to_owned());\n-        let _ : int = bad_err.unwrap_or_handle(handler);\n-    }\n-}"}, {"sha": "ac1692e6bb33ab327bebdbb2285ef976e01cfa56", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -70,7 +70,6 @@ mod imp {\n     use owned::Box;\n     use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     use mem;\n-    #[cfg(not(test))] use str::StrSlice;\n     #[cfg(not(test))] use ptr::RawPtr;\n \n     static mut global_args_ptr: uint = 0;"}, {"sha": "708c42030ab7e1d6bcca6dd38f252cd7b8e22c7f", "filename": "src/libstd/rt/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fenv.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -11,7 +11,7 @@\n //! Runtime environment settings\n \n use from_str::from_str;\n-use option::{Some, None};\n+use option::{Some, None, Expect};\n use os;\n \n // Note that these are all accessed without any synchronization."}, {"sha": "5b9c314d42b0c688a9254b016a04d0d768afeec1", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -70,7 +70,7 @@ use self::task::{Task, BlockedTask};\n pub use self::util::default_sched_threads;\n \n // Export unwinding facilities used by the failure macros\n-pub use self::unwind::{begin_unwind, begin_unwind_raw, begin_unwind_fmt};\n+pub use self::unwind::{begin_unwind, begin_unwind_fmt};\n \n pub use self::util::{Stdio, Stdout, Stderr};\n "}, {"sha": "909df5618aaa39042ab9d7403520a1992dee74ab", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -436,7 +436,7 @@ mod test {\n     #[test]\n     fn rng() {\n         use rand::{StdRng, Rng};\n-        let mut r = StdRng::new().unwrap();\n+        let mut r = StdRng::new().ok().unwrap();\n         let _ = r.next_u32();\n     }\n "}, {"sha": "5f3731eb819d3b68e9848c1b78a4d7f8dcb58cb3", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 11, "deletions": 31, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -58,7 +58,6 @@\n // Currently Rust uses unwind runtime provided by libgcc.\n \n use any::{Any, AnyRefExt};\n-use c_str::CString;\n use cast;\n use fmt;\n use kinds::Send;\n@@ -298,42 +297,23 @@ pub mod eabi {\n }\n \n #[cold]\n-#[lang=\"fail_\"]\n+#[no_mangle]\n #[cfg(not(test))]\n-pub fn fail_(expr: *u8, file: *u8, line: uint) -> ! {\n-    begin_unwind_raw(expr, file, line);\n-}\n-\n-#[cold]\n-#[lang=\"fail_bounds_check\"]\n-#[cfg(not(test))]\n-pub fn fail_bounds_check(file: *u8, line: uint, index: uint, len: uint) -> ! {\n-    use c_str::ToCStr;\n+pub extern fn rust_fail_bounds_check(file: *u8, line: uint,\n+                                     index: uint, len: uint) -> ! {\n+    use str::raw::c_str_to_static_slice;\n \n     let msg = format!(\"index out of bounds: the len is {} but the index is {}\",\n                       len as uint, index as uint);\n-    msg.with_c_str(|buf| fail_(buf as *u8, file, line))\n+    begin_unwind(msg, unsafe { c_str_to_static_slice(file as *i8) }, line)\n }\n \n-/// This is the entry point of unwinding for things like lang items and such.\n-/// The arguments are normally generated by the compiler, and need to\n-/// have static lifetimes.\n-#[inline(never)] #[cold] // this is the slow path, please never inline this\n-pub fn begin_unwind_raw(msg: *u8, file: *u8, line: uint) -> ! {\n-    use libc::c_char;\n-    #[inline]\n-    fn static_char_ptr(p: *u8) -> &'static str {\n-        let s = unsafe { CString::new(p as *c_char, false) };\n-        match s.as_str() {\n-            Some(s) => unsafe { cast::transmute::<&str, &'static str>(s) },\n-            None => rtabort!(\"message wasn't utf8?\")\n-        }\n-    }\n-\n-    let msg = static_char_ptr(msg);\n-    let file = static_char_ptr(file);\n-\n-    begin_unwind(msg, file, line as uint)\n+// Entry point of failure from the libcore crate\n+#[no_mangle]\n+#[cfg(not(test))]\n+pub extern fn rust_begin_unwind(msg: &str, file: &'static str, line: uint) -> ! {\n+    use str::StrAllocating;\n+    begin_unwind(msg.to_owned(), file, line)\n }\n \n /// The entry point for unwinding with a formatted message."}, {"sha": "c7cefbb28eef9d0e1a143f919db3f720f2723c3b", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 80, "deletions": 1616, "changes": 1696, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -97,138 +97,28 @@ There are a number of free functions that create or take vectors, for example:\n \n */\n \n-use cast;\n use cast::transmute;\n-use ops::Drop;\n+use cast;\n use clone::Clone;\n-use container::Container;\n-use cmp::{Eq, TotalOrd, Ordering, Less, Equal, Greater};\n+use cmp::{TotalOrd, Ordering, Less, Greater};\n use cmp;\n-use default::Default;\n-use fmt;\n+use container::Container;\n use iter::*;\n-use num::{CheckedAdd, Saturating, div_rem};\n-use num::CheckedMul;\n+use mem::size_of;\n+use mem;\n+use ops::Drop;\n use option::{None, Option, Some};\n-use ptr;\n use ptr::RawPtr;\n-use rt::global_heap::{malloc_raw, exchange_free};\n-use result::{Ok, Err};\n-use mem;\n-use mem::size_of;\n-use kinds::marker;\n+use ptr;\n+use rt::global_heap::{exchange_free};\n use unstable::finally::try_finally;\n-use raw::{Repr, Slice};\n-use RawVec = raw::Vec;\n use vec::Vec;\n \n-/**\n- * Converts a pointer to A into a slice of length 1 (without copying).\n- */\n-pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n-    unsafe {\n-        transmute(Slice { data: s, len: 1 })\n-    }\n-}\n-\n-/**\n- * Converts a pointer to A into a slice of length 1 (without copying).\n- */\n-pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n-    unsafe {\n-        let ptr: *A = transmute(s);\n-        transmute(Slice { data: ptr, len: 1 })\n-    }\n-}\n-\n-/// An iterator over the slices of a vector separated by elements that\n-/// match a predicate function.\n-pub struct Splits<'a, T> {\n-    v: &'a [T],\n-    pred: |t: &T|: 'a -> bool,\n-    finished: bool\n-}\n-\n-impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.finished { return None; }\n-\n-        match self.v.iter().position(|x| (self.pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                Some(self.v)\n-            }\n-            Some(idx) => {\n-                let ret = Some(self.v.slice(0, idx));\n-                self.v = self.v.slice(idx + 1, self.v.len());\n-                ret\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.finished {\n-            (0, Some(0))\n-        } else {\n-            (1, Some(self.v.len() + 1))\n-        }\n-    }\n-}\n-\n-impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a [T]> {\n-        if self.finished { return None; }\n-\n-        match self.v.iter().rposition(|x| (self.pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                Some(self.v)\n-            }\n-            Some(idx) => {\n-                let ret = Some(self.v.slice(idx + 1, self.v.len()));\n-                self.v = self.v.slice(0, idx);\n-                ret\n-            }\n-        }\n-    }\n-}\n-\n-/// An iterator over the slices of a vector separated by elements that\n-/// match a predicate function, splitting at most a fixed number of times.\n-pub struct SplitsN<'a, T> {\n-    iter: Splits<'a, T>,\n-    count: uint,\n-    invert: bool\n-}\n-\n-impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.count == 0 {\n-            if self.iter.finished {\n-                None\n-            } else {\n-                self.iter.finished = true;\n-                Some(self.iter.v)\n-            }\n-        } else {\n-            self.count -= 1;\n-            if self.invert { self.iter.next_back() } else { self.iter.next() }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.iter.finished {\n-            (0, Some(0))\n-        } else {\n-            (1, Some(cmp::min(self.count, self.iter.v.len()) + 1))\n-        }\n-    }\n-}\n+pub use core::slice::{ref_slice, mut_ref_slice, Splits, Windows};\n+pub use core::slice::{Chunks, Vector, ImmutableVector, ImmutableEqVector};\n+pub use core::slice::{ImmutableTotalOrdVector, MutableVector, Items, MutItems};\n+pub use core::slice::{RevItems, RevMutItems, MutSplits, MutChunks};\n+pub use core::slice::{bytes, MutableCloneableVector};\n \n // Functional utilities\n \n@@ -410,249 +300,6 @@ impl<T: Clone> Iterator<~[T]> for Permutations<T> {\n     }\n }\n \n-/// An iterator over the (overlapping) slices of length `size` within\n-/// a vector.\n-#[deriving(Clone)]\n-pub struct Windows<'a, T> {\n-    v: &'a [T],\n-    size: uint\n-}\n-\n-impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.size > self.v.len() {\n-            None\n-        } else {\n-            let ret = Some(self.v.slice(0, self.size));\n-            self.v = self.v.slice(1, self.v.len());\n-            ret\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.size > self.v.len() {\n-            (0, Some(0))\n-        } else {\n-            let x = self.v.len() - self.size;\n-            (x.saturating_add(1), x.checked_add(&1u))\n-        }\n-    }\n-}\n-\n-/// An iterator over a vector in (non-overlapping) chunks (`size`\n-/// elements at a time).\n-///\n-/// When the vector len is not evenly divided by the chunk size,\n-/// the last slice of the iteration will be the remainder.\n-#[deriving(Clone)]\n-pub struct Chunks<'a, T> {\n-    v: &'a [T],\n-    size: uint\n-}\n-\n-impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let chunksz = cmp::min(self.v.len(), self.size);\n-            let (fst, snd) = (self.v.slice_to(chunksz),\n-                              self.v.slice_from(chunksz));\n-            self.v = snd;\n-            Some(fst)\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.v.len() == 0 {\n-            (0, Some(0))\n-        } else {\n-            let (n, rem) = div_rem(self.v.len(), self.size);\n-            let n = if rem > 0 { n+1 } else { n };\n-            (n, Some(n))\n-        }\n-    }\n-}\n-\n-impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let remainder = self.v.len() % self.size;\n-            let chunksz = if remainder != 0 { remainder } else { self.size };\n-            let (fst, snd) = (self.v.slice_to(self.v.len() - chunksz),\n-                              self.v.slice_from(self.v.len() - chunksz));\n-            self.v = fst;\n-            Some(snd)\n-        }\n-    }\n-}\n-\n-impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n-    #[inline]\n-    fn indexable(&self) -> uint {\n-        self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: uint) -> Option<&'a [T]> {\n-        if index < self.indexable() {\n-            let lo = index * self.size;\n-            let mut hi = lo + self.size;\n-            if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n-\n-            Some(self.v.slice(lo, hi))\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-// Equality\n-\n-#[cfg(not(test))]\n-#[allow(missing_doc)]\n-pub mod traits {\n-    use super::*;\n-\n-    use container::Container;\n-    use clone::Clone;\n-    use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Equiv};\n-    use iter::{order, Iterator};\n-    use ops::Add;\n-    use vec::Vec;\n-\n-    impl<'a,T:Eq> Eq for &'a [T] {\n-        fn eq(&self, other: & &'a [T]) -> bool {\n-            self.len() == other.len() &&\n-                order::eq(self.iter(), other.iter())\n-        }\n-        fn ne(&self, other: & &'a [T]) -> bool {\n-            self.len() != other.len() ||\n-                order::ne(self.iter(), other.iter())\n-        }\n-    }\n-\n-    impl<T:Eq> Eq for ~[T] {\n-        #[inline]\n-        fn eq(&self, other: &~[T]) -> bool { self.as_slice() == *other }\n-        #[inline]\n-        fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n-    }\n-\n-    impl<'a,T:TotalEq> TotalEq for &'a [T] {}\n-\n-    impl<T:TotalEq> TotalEq for ~[T] {}\n-\n-    impl<'a,T:Eq, V: Vector<T>> Equiv<V> for &'a [T] {\n-        #[inline]\n-        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-    }\n-\n-    impl<'a,T:Eq, V: Vector<T>> Equiv<V> for ~[T] {\n-        #[inline]\n-        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-    }\n-\n-    impl<'a,T:TotalOrd> TotalOrd for &'a [T] {\n-        fn cmp(&self, other: & &'a [T]) -> Ordering {\n-            order::cmp(self.iter(), other.iter())\n-        }\n-    }\n-\n-    impl<T: TotalOrd> TotalOrd for ~[T] {\n-        #[inline]\n-        fn cmp(&self, other: &~[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n-    }\n-\n-    impl<'a, T: Ord> Ord for &'a [T] {\n-        fn lt(&self, other: & &'a [T]) -> bool {\n-            order::lt(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn le(&self, other: & &'a [T]) -> bool {\n-            order::le(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn ge(&self, other: & &'a [T]) -> bool {\n-            order::ge(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn gt(&self, other: & &'a [T]) -> bool {\n-            order::gt(self.iter(), other.iter())\n-        }\n-    }\n-\n-    impl<T: Ord> Ord for ~[T] {\n-        #[inline]\n-        fn lt(&self, other: &~[T]) -> bool { self.as_slice() < other.as_slice() }\n-        #[inline]\n-        fn le(&self, other: &~[T]) -> bool { self.as_slice() <= other.as_slice() }\n-        #[inline]\n-        fn ge(&self, other: &~[T]) -> bool { self.as_slice() >= other.as_slice() }\n-        #[inline]\n-        fn gt(&self, other: &~[T]) -> bool { self.as_slice() > other.as_slice() }\n-    }\n-\n-    impl<'a,T:Clone, V: Vector<T>> Add<V, ~[T]> for &'a [T] {\n-        #[inline]\n-        fn add(&self, rhs: &V) -> ~[T] {\n-            let mut res = Vec::with_capacity(self.len() + rhs.as_slice().len());\n-            res.push_all(*self);\n-            res.push_all(rhs.as_slice());\n-            res.move_iter().collect()\n-        }\n-    }\n-\n-    impl<T:Clone, V: Vector<T>> Add<V, ~[T]> for ~[T] {\n-        #[inline]\n-        fn add(&self, rhs: &V) -> ~[T] {\n-            self.as_slice() + rhs.as_slice()\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-pub mod traits {}\n-\n-/// Any vector that can be represented as a slice.\n-pub trait Vector<T> {\n-    /// Work with `self` as a slice.\n-    fn as_slice<'a>(&'a self) -> &'a [T];\n-}\n-\n-impl<'a,T> Vector<T> for &'a [T] {\n-    #[inline(always)]\n-    fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n-}\n-\n-impl<T> Vector<T> for ~[T] {\n-    #[inline(always)]\n-    fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n-}\n-\n-impl<'a, T> Container for &'a [T] {\n-    /// Returns the length of a vector\n-    #[inline]\n-    fn len(&self) -> uint {\n-        self.repr().len\n-    }\n-}\n-\n-impl<T> Container for ~[T] {\n-    /// Returns the length of a vector\n-    #[inline]\n-    fn len(&self) -> uint {\n-        self.as_slice().len()\n-    }\n-}\n-\n /// Extension methods for vector slices with cloneable elements\n pub trait CloneableVector<T> {\n     /// Copy `self` into a new owned vector\n@@ -703,496 +350,85 @@ impl<T: Clone> CloneableVector<T> for ~[T] {\n     fn into_owned(self) -> ~[T] { self }\n }\n \n-/// Extension methods for vectors\n-pub trait ImmutableVector<'a, T> {\n-    /**\n-     * Returns a slice of self between `start` and `end`.\n-     *\n-     * Fails when `start` or `end` point outside the bounds of self,\n-     * or when `start` > `end`.\n-     */\n-    fn slice(&self, start: uint, end: uint) -> &'a [T];\n+/// Extension methods for vectors containing `Clone` elements.\n+pub trait ImmutableCloneableVector<T> {\n+    /// Partitions the vector into two vectors `(A,B)`, where all\n+    /// elements of `A` satisfy `f` and all elements of `B` do not.\n+    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]);\n \n-    /**\n-     * Returns a slice of self from `start` to the end of the vec.\n-     *\n-     * Fails when `start` points outside the bounds of self.\n-     */\n-    fn slice_from(&self, start: uint) -> &'a [T];\n+    /// Create an iterator that yields every possible permutation of the\n+    /// vector in succession.\n+    fn permutations(self) -> Permutations<T>;\n+}\n \n-    /**\n-     * Returns a slice of self from the start of the vec to `end`.\n-     *\n-     * Fails when `end` points outside the bounds of self.\n-     */\n-    fn slice_to(&self, end: uint) -> &'a [T];\n-    /// Returns an iterator over the vector\n-    fn iter(self) -> Items<'a, T>;\n-    /// Returns a reversed iterator over a vector\n-    #[deprecated = \"replaced by .iter().rev()\"]\n-    fn rev_iter(self) -> Rev<Items<'a, T>>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred`.  The matched element\n-    /// is not contained in the subslices.\n-    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred`, limited to splitting\n-    /// at most `n` times.  The matched element is not contained in\n-    /// the subslices.\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred`. This starts at the\n-    /// end of the vector and works backwards.  The matched element is\n-    /// not contained in the subslices.\n-    #[deprecated = \"replaced by .split(pred).rev()\"]\n-    fn rsplit(self, pred: |&T|: 'a -> bool) -> Rev<Splits<'a, T>>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred` limited to splitting\n-    /// at most `n` times. This starts at the end of the vector and\n-    /// works backwards.  The matched element is not contained in the\n-    /// subslices.\n-    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n+impl<'a,T:Clone> ImmutableCloneableVector<T> for &'a [T] {\n+    #[inline]\n+    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]) {\n+        let mut lefts  = Vec::new();\n+        let mut rights = Vec::new();\n \n-    /**\n-     * Returns an iterator over all contiguous windows of length\n-     * `size`. The windows overlap. If the vector is shorter than\n-     * `size`, the iterator returns no values.\n-     *\n-     * # Failure\n-     *\n-     * Fails if `size` is 0.\n-     *\n-     * # Example\n-     *\n-     * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`,\n-     * `[3,4]`):\n-     *\n-     * ```rust\n-     * let v = &[1,2,3,4];\n-     * for win in v.windows(2) {\n-     *     println!(\"{:?}\", win);\n-     * }\n-     * ```\n-     *\n-     */\n-    fn windows(self, size: uint) -> Windows<'a, T>;\n-    /**\n-     *\n-     * Returns an iterator over `size` elements of the vector at a\n-     * time. The chunks do not overlap. If `size` does not divide the\n-     * length of the vector, then the last chunk will not have length\n-     * `size`.\n-     *\n-     * # Failure\n-     *\n-     * Fails if `size` is 0.\n-     *\n-     * # Example\n-     *\n-     * Print the vector two elements at a time (i.e. `[1,2]`,\n-     * `[3,4]`, `[5]`):\n-     *\n-     * ```rust\n-     * let v = &[1,2,3,4,5];\n-     * for win in v.chunks(2) {\n-     *     println!(\"{:?}\", win);\n-     * }\n-     * ```\n-     *\n-     */\n-    fn chunks(self, size: uint) -> Chunks<'a, T>;\n-\n-    /// Returns the element of a vector at the given index, or `None` if the\n-    /// index is out of bounds\n-    fn get(&self, index: uint) -> Option<&'a T>;\n-    /// Returns the first element of a vector, or `None` if it is empty\n-    fn head(&self) -> Option<&'a T>;\n-    /// Returns all but the first element of a vector\n-    fn tail(&self) -> &'a [T];\n-    /// Returns all but the first `n' elements of a vector\n-    fn tailn(&self, n: uint) -> &'a [T];\n-    /// Returns all but the last element of a vector\n-    fn init(&self) -> &'a [T];\n-    /// Returns all but the last `n' elements of a vector\n-    fn initn(&self, n: uint) -> &'a [T];\n-    /// Returns the last element of a vector, or `None` if it is empty.\n-    fn last(&self) -> Option<&'a T>;\n-\n-    /// Returns a pointer to the element at the given index, without doing\n-    /// bounds checking.\n-    unsafe fn unsafe_ref(self, index: uint) -> &'a T;\n+        for elt in self.iter() {\n+            if f(elt) {\n+                lefts.push((*elt).clone());\n+            } else {\n+                rights.push((*elt).clone());\n+            }\n+        }\n \n-    /**\n-     * Returns an unsafe pointer to the vector's buffer\n-     *\n-     * The caller must ensure that the vector outlives the pointer this\n-     * function returns, or else it will end up pointing to garbage.\n-     *\n-     * Modifying the vector may cause its buffer to be reallocated, which\n-     * would also make any pointers to it invalid.\n-     */\n-    fn as_ptr(&self) -> *T;\n+        (lefts.move_iter().collect(), rights.move_iter().collect())\n+    }\n \n-    /**\n-     * Binary search a sorted vector with a comparator function.\n-     *\n-     * The comparator function should implement an order consistent\n-     * with the sort order of the underlying vector, returning an\n-     * order code that indicates whether its argument is `Less`,\n-     * `Equal` or `Greater` the desired target.\n-     *\n-     * Returns the index where the comparator returned `Equal`, or `None` if\n-     * not found.\n-     */\n-    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n+    fn permutations(self) -> Permutations<T> {\n+        Permutations{\n+            swaps: ElementSwaps::new(self.len()),\n+            v: self.to_owned(),\n+        }\n+    }\n \n-    /**\n-     * Returns a mutable reference to the first element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None }\n-     *     let head = &self[0];\n-     *     *self = self.slice_from(1);\n-     *     Some(head)\n-     * ```\n-     *\n-     * Returns `None` if vector is empty\n-     */\n-    fn shift_ref(&mut self) -> Option<&'a T>;\n+}\n+\n+/// Extension methods for owned vectors.\n+pub trait OwnedVector<T> {\n+    /// Creates a consuming iterator, that is, one that moves each\n+    /// value out of the vector (from start to end). The vector cannot\n+    /// be used after calling this.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let v = ~[\"a\".to_owned(), \"b\".to_owned()];\n+    /// for s in v.move_iter() {\n+    ///   // s has type ~str, not &~str\n+    ///   println!(\"{}\", s);\n+    /// }\n+    /// ```\n+    fn move_iter(self) -> MoveItems<T>;\n+    /// Creates a consuming iterator that moves out of the vector in\n+    /// reverse order.\n+    #[deprecated = \"replaced by .move_iter().rev()\"]\n+    fn move_rev_iter(self) -> Rev<MoveItems<T>>;\n \n     /**\n-     * Returns a mutable reference to the last element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let tail = &self[self.len() - 1];\n-     *     *self = self.slice_to(self.len() - 1);\n-     *     Some(tail)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty.\n+     * Partitions the vector into two vectors `(A,B)`, where all\n+     * elements of `A` satisfy `f` and all elements of `B` do not.\n      */\n-    fn pop_ref(&mut self) -> Option<&'a T>;\n+    fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]);\n }\n \n-impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n+impl<T> OwnedVector<T> for ~[T] {\n     #[inline]\n-    fn slice(&self, start: uint, end: uint) -> &'a [T] {\n-        assert!(start <= end);\n-        assert!(end <= self.len());\n+    fn move_iter(self) -> MoveItems<T> {\n         unsafe {\n-            transmute(Slice {\n-                    data: self.as_ptr().offset(start as int),\n-                    len: (end - start)\n-                })\n+            let iter = transmute(self.iter());\n+            let ptr = transmute(self);\n+            MoveItems { allocation: ptr, iter: iter }\n         }\n     }\n \n     #[inline]\n-    fn slice_from(&self, start: uint) -> &'a [T] {\n-        self.slice(start, self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &'a [T] {\n-        self.slice(0, end)\n-    }\n-\n-    #[inline]\n-    fn iter(self) -> Items<'a, T> {\n-        unsafe {\n-            let p = self.as_ptr();\n-            if mem::size_of::<T>() == 0 {\n-                Items{ptr: p,\n-                      end: (p as uint + self.len()) as *T,\n-                      marker: marker::ContravariantLifetime::<'a>}\n-            } else {\n-                Items{ptr: p,\n-                      end: p.offset(self.len() as int),\n-                      marker: marker::ContravariantLifetime::<'a>}\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .iter().rev()\"]\n-    fn rev_iter(self) -> Rev<Items<'a, T>> {\n-        self.iter().rev()\n-    }\n-\n-    #[inline]\n-    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n-        Splits {\n-            v: self,\n-            pred: pred,\n-            finished: false\n-        }\n-    }\n-\n-    #[inline]\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: false\n-        }\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .split(pred).rev()\"]\n-    fn rsplit(self, pred: |&T|: 'a -> bool) -> Rev<Splits<'a, T>> {\n-        self.split(pred).rev()\n-    }\n-\n-    #[inline]\n-    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: true\n-        }\n-    }\n-\n-    #[inline]\n-    fn windows(self, size: uint) -> Windows<'a, T> {\n-        assert!(size != 0);\n-        Windows { v: self, size: size }\n-    }\n-\n-    #[inline]\n-    fn chunks(self, size: uint) -> Chunks<'a, T> {\n-        assert!(size != 0);\n-        Chunks { v: self, size: size }\n-    }\n-\n-    #[inline]\n-    fn get(&self, index: uint) -> Option<&'a T> {\n-        if index < self.len() { Some(&self[index]) } else { None }\n-    }\n-\n-    #[inline]\n-    fn head(&self) -> Option<&'a T> {\n-        if self.len() == 0 { None } else { Some(&self[0]) }\n-    }\n-\n-    #[inline]\n-    fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }\n-\n-    #[inline]\n-    fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }\n-\n-    #[inline]\n-    fn init(&self) -> &'a [T] {\n-        self.slice(0, self.len() - 1)\n-    }\n-\n-    #[inline]\n-    fn initn(&self, n: uint) -> &'a [T] {\n-        self.slice(0, self.len() - n)\n-    }\n-\n-    #[inline]\n-    fn last(&self) -> Option<&'a T> {\n-            if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n-    }\n-\n-    #[inline]\n-    unsafe fn unsafe_ref(self, index: uint) -> &'a T {\n-        transmute(self.repr().data.offset(index as int))\n-    }\n-\n-    #[inline]\n-    fn as_ptr(&self) -> *T {\n-        self.repr().data\n-    }\n-\n-\n-    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n-        let mut base : uint = 0;\n-        let mut lim : uint = self.len();\n-\n-        while lim != 0 {\n-            let ix = base + (lim >> 1);\n-            match f(&self[ix]) {\n-                Equal => return Some(ix),\n-                Less => {\n-                    base = ix + 1;\n-                    lim -= 1;\n-                }\n-                Greater => ()\n-            }\n-            lim >>= 1;\n-        }\n-        return None;\n-    }\n-\n-    fn shift_ref(&mut self) -> Option<&'a T> {\n-        if self.len() == 0 { return None; }\n-        unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n-            Some(&*raw::shift_ptr(s))\n-        }\n-    }\n-\n-    fn pop_ref(&mut self) -> Option<&'a T> {\n-        if self.len() == 0 { return None; }\n-        unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n-            Some(&*raw::pop_ptr(s))\n-        }\n-    }\n-}\n-\n-/// Extension methods for vectors contain `Eq` elements.\n-pub trait ImmutableEqVector<T:Eq> {\n-    /// Find the first index containing a matching value\n-    fn position_elem(&self, t: &T) -> Option<uint>;\n-\n-    /// Find the last index containing a matching value\n-    fn rposition_elem(&self, t: &T) -> Option<uint>;\n-\n-    /// Return true if a vector contains an element with the given value\n-    fn contains(&self, x: &T) -> bool;\n-\n-    /// Returns true if `needle` is a prefix of the vector.\n-    fn starts_with(&self, needle: &[T]) -> bool;\n-\n-    /// Returns true if `needle` is a suffix of the vector.\n-    fn ends_with(&self, needle: &[T]) -> bool;\n-}\n-\n-impl<'a,T:Eq> ImmutableEqVector<T> for &'a [T] {\n-    #[inline]\n-    fn position_elem(&self, x: &T) -> Option<uint> {\n-        self.iter().position(|y| *x == *y)\n-    }\n-\n-    #[inline]\n-    fn rposition_elem(&self, t: &T) -> Option<uint> {\n-        self.iter().rposition(|x| *x == *t)\n-    }\n-\n-    #[inline]\n-    fn contains(&self, x: &T) -> bool {\n-        self.iter().any(|elt| *x == *elt)\n-    }\n-\n-    #[inline]\n-    fn starts_with(&self, needle: &[T]) -> bool {\n-        let n = needle.len();\n-        self.len() >= n && needle == self.slice_to(n)\n-    }\n-\n-    #[inline]\n-    fn ends_with(&self, needle: &[T]) -> bool {\n-        let (m, n) = (self.len(), needle.len());\n-        m >= n && needle == self.slice_from(m - n)\n-    }\n-}\n-\n-/// Extension methods for vectors containing `TotalOrd` elements.\n-pub trait ImmutableTotalOrdVector<T: TotalOrd> {\n-    /**\n-     * Binary search a sorted vector for a given element.\n-     *\n-     * Returns the index of the element or None if not found.\n-     */\n-    fn bsearch_elem(&self, x: &T) -> Option<uint>;\n-}\n-\n-impl<'a, T: TotalOrd> ImmutableTotalOrdVector<T> for &'a [T] {\n-    fn bsearch_elem(&self, x: &T) -> Option<uint> {\n-        self.bsearch(|p| p.cmp(x))\n-    }\n-}\n-\n-/// Extension methods for vectors containing `Clone` elements.\n-pub trait ImmutableCloneableVector<T> {\n-    /// Partitions the vector into two vectors `(A,B)`, where all\n-    /// elements of `A` satisfy `f` and all elements of `B` do not.\n-    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]);\n-\n-    /// Create an iterator that yields every possible permutation of the\n-    /// vector in succession.\n-    fn permutations(self) -> Permutations<T>;\n-}\n-\n-impl<'a,T:Clone> ImmutableCloneableVector<T> for &'a [T] {\n-    #[inline]\n-    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]) {\n-        let mut lefts  = Vec::new();\n-        let mut rights = Vec::new();\n-\n-        for elt in self.iter() {\n-            if f(elt) {\n-                lefts.push((*elt).clone());\n-            } else {\n-                rights.push((*elt).clone());\n-            }\n-        }\n-\n-        (lefts.move_iter().collect(), rights.move_iter().collect())\n-    }\n-\n-    fn permutations(self) -> Permutations<T> {\n-        Permutations{\n-            swaps: ElementSwaps::new(self.len()),\n-            v: self.to_owned(),\n-        }\n-    }\n-\n-}\n-\n-/// Extension methods for owned vectors.\n-pub trait OwnedVector<T> {\n-    /// Creates a consuming iterator, that is, one that moves each\n-    /// value out of the vector (from start to end). The vector cannot\n-    /// be used after calling this.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let v = ~[\"a\".to_owned(), \"b\".to_owned()];\n-    /// for s in v.move_iter() {\n-    ///   // s has type ~str, not &~str\n-    ///   println!(\"{}\", s);\n-    /// }\n-    /// ```\n-    fn move_iter(self) -> MoveItems<T>;\n-    /// Creates a consuming iterator that moves out of the vector in\n-    /// reverse order.\n-    #[deprecated = \"replaced by .move_iter().rev()\"]\n-    fn move_rev_iter(self) -> Rev<MoveItems<T>>;\n-\n-    /**\n-     * Partitions the vector into two vectors `(A,B)`, where all\n-     * elements of `A` satisfy `f` and all elements of `B` do not.\n-     */\n-    fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]);\n-}\n-\n-impl<T> OwnedVector<T> for ~[T] {\n-    #[inline]\n-    fn move_iter(self) -> MoveItems<T> {\n-        unsafe {\n-            let iter = transmute(self.iter());\n-            let ptr = transmute(self);\n-            MoveItems { allocation: ptr, iter: iter }\n-        }\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .move_iter().rev()\"]\n-    fn move_rev_iter(self) -> Rev<MoveItems<T>> {\n-        self.move_iter().rev()\n+    #[deprecated = \"replaced by .move_iter().rev()\"]\n+    fn move_rev_iter(self) -> Rev<MoveItems<T>> {\n+        self.move_iter().rev()\n     }\n \n     #[inline]\n@@ -1417,155 +653,7 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n \n /// Extension methods for vectors such that their elements are\n /// mutable.\n-pub trait MutableVector<'a, T> {\n-    /// Work with `self` as a mut slice.\n-    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n-    fn as_mut_slice(self) -> &'a mut [T];\n-\n-    /// Return a slice that points into another slice.\n-    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T];\n-\n-    /**\n-     * Returns a slice of self from `start` to the end of the vec.\n-     *\n-     * Fails when `start` points outside the bounds of self.\n-     */\n-    fn mut_slice_from(self, start: uint) -> &'a mut [T];\n-\n-    /**\n-     * Returns a slice of self from the start of the vec to `end`.\n-     *\n-     * Fails when `end` points outside the bounds of self.\n-     */\n-    fn mut_slice_to(self, end: uint) -> &'a mut [T];\n-\n-    /// Returns an iterator that allows modifying each value\n-    fn mut_iter(self) -> MutItems<'a, T>;\n-\n-    /// Returns a mutable pointer to the last item in the vector.\n-    fn mut_last(self) -> Option<&'a mut T>;\n-\n-    /// Returns a reversed iterator that allows modifying each value\n-    #[deprecated = \"replaced by .mut_iter().rev()\"]\n-    fn mut_rev_iter(self) -> Rev<MutItems<'a, T>>;\n-\n-    /// Returns an iterator over the mutable subslices of the vector\n-    /// which are separated by elements that match `pred`.  The\n-    /// matched element is not contained in the subslices.\n-    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;\n-\n-    /**\n-     * Returns an iterator over `size` elements of the vector at a time.\n-     * The chunks are mutable and do not overlap. If `size` does not divide the\n-     * length of the vector, then the last chunk will not have length\n-     * `size`.\n-     *\n-     * # Failure\n-     *\n-     * Fails if `size` is 0.\n-     */\n-    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T>;\n-\n-    /**\n-     * Returns a mutable reference to the first element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let head = &mut self[0];\n-     *     *self = self.mut_slice_from(1);\n-     *     Some(head)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty\n-     */\n-    fn mut_shift_ref(&mut self) -> Option<&'a mut T>;\n-\n-    /**\n-     * Returns a mutable reference to the last element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let tail = &mut self[self.len() - 1];\n-     *     *self = self.mut_slice_to(self.len() - 1);\n-     *     Some(tail)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty.\n-     */\n-    fn mut_pop_ref(&mut self) -> Option<&'a mut T>;\n-\n-    /// Swaps two elements in a vector.\n-    ///\n-    /// Fails if `a` or `b` are out of bounds.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * a - The index of the first element\n-    /// * b - The index of the second element\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n-    /// v.swap(1, 3);\n-    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n-    /// ```\n-    fn swap(self, a: uint, b: uint);\n-\n-\n-    /// Divides one `&mut` into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// Fails if `mid > len`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [1, 2, 3, 4, 5, 6];\n-    ///\n-    /// // scoped to restrict the lifetime of the borrows\n-    /// {\n-    ///    let (left, right) = v.mut_split_at(0);\n-    ///    assert!(left == &mut []);\n-    ///    assert!(right == &mut [1, 2, 3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.mut_split_at(2);\n-    ///     assert!(left == &mut [1, 2]);\n-    ///     assert!(right == &mut [3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.mut_split_at(6);\n-    ///     assert!(left == &mut [1, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == &mut []);\n-    /// }\n-    /// ```\n-    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n-\n-    /// Reverse the order of elements in a vector, in place.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [1, 2, 3];\n-    /// v.reverse();\n-    /// assert!(v == [3, 2, 1]);\n-    /// ```\n-    fn reverse(self);\n-\n+pub trait MutableVectorAllocating<'a, T> {\n     /// Sort the vector, in place, using `compare` to compare\n     /// elements.\n     ///\n@@ -1599,181 +687,9 @@ pub trait MutableVector<'a, T> {\n      * * end - The index into `str` to stop copying from\n      */\n     fn move_from(self, src: ~[T], start: uint, end: uint) -> uint;\n-\n-    /// Returns an unsafe mutable pointer to the element in index\n-    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T;\n-\n-    /// Return an unsafe mutable pointer to the vector's buffer.\n-    ///\n-    /// The caller must ensure that the vector outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the vector may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    #[inline]\n-    fn as_mut_ptr(self) -> *mut T;\n-\n-    /// Unsafely sets the element in index to the value.\n-    ///\n-    /// This performs no bounds checks, and it is undefined behaviour\n-    /// if `index` is larger than the length of `self`. However, it\n-    /// does run the destructor at `index`. It is equivalent to\n-    /// `self[index] = val`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = ~[\"foo\".to_owned(), \"bar\".to_owned(), \"baz\".to_owned()];\n-    ///\n-    /// unsafe {\n-    ///     // `\"baz\".to_owned()` is deallocated.\n-    ///     v.unsafe_set(2, \"qux\".to_owned());\n-    ///\n-    ///     // Out of bounds: could cause a crash, or overwriting\n-    ///     // other data, or something else.\n-    ///     // v.unsafe_set(10, \"oops\".to_owned());\n-    /// }\n-    /// ```\n-    unsafe fn unsafe_set(self, index: uint, val: T);\n-\n-    /// Unchecked vector index assignment.  Does not drop the\n-    /// old value and hence is only suitable when the vector\n-    /// is newly allocated.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [\"foo\".to_owned(), \"bar\".to_owned()];\n-    ///\n-    /// // memory leak! `\"bar\".to_owned()` is not deallocated.\n-    /// unsafe { v.init_elem(1, \"baz\".to_owned()); }\n-    /// ```\n-    unsafe fn init_elem(self, i: uint, val: T);\n-\n-    /// Copies raw bytes from `src` to `self`.\n-    ///\n-    /// This does not run destructors on the overwritten elements, and\n-    /// ignores move semantics. `self` and `src` must not\n-    /// overlap. Fails if `self` is shorter than `src`.\n-    unsafe fn copy_memory(self, src: &[T]);\n }\n \n-impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n-    #[inline]\n-    fn as_mut_slice(self) -> &'a mut [T] { self }\n-\n-    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n-        assert!(start <= end);\n-        assert!(end <= self.len());\n-        unsafe {\n-            transmute(Slice {\n-                    data: self.as_mut_ptr().offset(start as int) as *T,\n-                    len: (end - start)\n-                })\n-        }\n-    }\n-\n-    #[inline]\n-    fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n-        let len = self.len();\n-        self.mut_slice(start, len)\n-    }\n-\n-    #[inline]\n-    fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n-        self.mut_slice(0, end)\n-    }\n-\n-    #[inline]\n-    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        unsafe {\n-            let len = self.len();\n-            let self2: &'a mut [T] = cast::transmute_copy(&self);\n-            (self.mut_slice(0, mid), self2.mut_slice(mid, len))\n-        }\n-    }\n-\n-    #[inline]\n-    fn mut_iter(self) -> MutItems<'a, T> {\n-        unsafe {\n-            let p = self.as_mut_ptr();\n-            if mem::size_of::<T>() == 0 {\n-                MutItems{ptr: p,\n-                         end: (p as uint + self.len()) as *mut T,\n-                         marker: marker::ContravariantLifetime::<'a>,\n-                         marker2: marker::NoCopy}\n-            } else {\n-                MutItems{ptr: p,\n-                         end: p.offset(self.len() as int),\n-                         marker: marker::ContravariantLifetime::<'a>,\n-                         marker2: marker::NoCopy}\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn mut_last(self) -> Option<&'a mut T> {\n-        let len = self.len();\n-        if len == 0 { return None; }\n-        Some(&mut self[len - 1])\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .mut_iter().rev()\"]\n-    fn mut_rev_iter(self) -> Rev<MutItems<'a, T>> {\n-        self.mut_iter().rev()\n-    }\n-\n-    #[inline]\n-    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n-        MutSplits { v: self, pred: pred, finished: false }\n-    }\n-\n-    #[inline]\n-    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T> {\n-        assert!(chunk_size > 0);\n-        MutChunks { v: self, chunk_size: chunk_size }\n-    }\n-\n-    fn mut_shift_ref(&mut self) -> Option<&'a mut T> {\n-        if self.len() == 0 { return None; }\n-        unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n-            // FIXME #13933: this `&` -> `&mut` cast is a little\n-            // dubious\n-            Some(&mut *(raw::shift_ptr(s) as *mut _))\n-        }\n-    }\n-\n-    fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n-        if self.len() == 0 { return None; }\n-        unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n-            // FIXME #13933: this `&` -> `&mut` cast is a little\n-            // dubious\n-            Some(&mut *(raw::pop_ptr(s) as *mut _))\n-        }\n-    }\n-\n-    fn swap(self, a: uint, b: uint) {\n-        unsafe {\n-            // Can't take two mutable loans from one vector, so instead just cast\n-            // them to their raw pointers to do the swap\n-            let pa: *mut T = &mut self[a];\n-            let pb: *mut T = &mut self[b];\n-            ptr::swap(pa, pb);\n-        }\n-    }\n-\n-    fn reverse(self) {\n-        let mut i: uint = 0;\n-        let ln = self.len();\n-        while i < ln / 2 {\n-            self.swap(i, ln - i - 1);\n-            i += 1;\n-        }\n-    }\n-\n+impl<'a,T> MutableVectorAllocating<'a, T> for &'a mut [T] {\n     #[inline]\n     fn sort_by(self, compare: |&T, &T| -> Ordering) {\n         merge_sort(self, compare)\n@@ -1786,67 +702,6 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n         }\n         cmp::min(self.len(), end-start)\n     }\n-\n-    #[inline]\n-    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T {\n-        transmute((self.repr().data as *mut T).offset(index as int))\n-    }\n-\n-    #[inline]\n-    fn as_mut_ptr(self) -> *mut T {\n-        self.repr().data as *mut T\n-    }\n-\n-    #[inline]\n-    unsafe fn unsafe_set(self, index: uint, val: T) {\n-        *self.unsafe_mut_ref(index) = val;\n-    }\n-\n-    #[inline]\n-    unsafe fn init_elem(self, i: uint, val: T) {\n-        mem::move_val_init(&mut (*self.as_mut_ptr().offset(i as int)), val);\n-    }\n-\n-    #[inline]\n-    unsafe fn copy_memory(self, src: &[T]) {\n-        let len_src = src.len();\n-        assert!(self.len() >= len_src);\n-        ptr::copy_nonoverlapping_memory(self.as_mut_ptr(), src.as_ptr(), len_src)\n-    }\n-}\n-\n-/// Trait for &[T] where T is Cloneable\n-pub trait MutableCloneableVector<T> {\n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::slice::MutableCloneableVector;\n-    ///\n-    /// let mut dst = [0, 0, 0];\n-    /// let src = [1, 2];\n-    ///\n-    /// assert!(dst.copy_from(src) == 2);\n-    /// assert!(dst == [1, 2, 0]);\n-    ///\n-    /// let src2 = [3, 4, 5, 6];\n-    /// assert!(dst.copy_from(src2) == 3);\n-    /// assert!(dst == [3, 4, 5]);\n-    /// ```\n-    fn copy_from(self, &[T]) -> uint;\n-}\n-\n-impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n-    #[inline]\n-    fn copy_from(self, src: &[T]) -> uint {\n-        for (a, b) in self.mut_iter().zip(src.iter()) {\n-            a.clone_from(b);\n-        }\n-        cmp::min(self.len(), src.len())\n-    }\n }\n \n /// Methods for mutable vectors with orderable elements, such as\n@@ -1866,6 +721,7 @@ pub trait MutableTotalOrdVector<T> {\n     /// ```\n     fn sort(self);\n }\n+\n impl<'a, T: TotalOrd> MutableTotalOrdVector<T> for &'a mut [T] {\n     #[inline]\n     fn sort(self) {\n@@ -1888,43 +744,13 @@ pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n \n /// Unsafe operations\n pub mod raw {\n-    use cast::transmute;\n     use iter::Iterator;\n-    use ptr::RawPtr;\n     use ptr;\n-    use raw::Slice;\n     use slice::{MutableVector, OwnedVector};\n     use vec::Vec;\n \n-    /**\n-     * Form a slice from a pointer and length (as a number of units,\n-     * not bytes).\n-     */\n-    #[inline]\n-    pub unsafe fn buf_as_slice<T,U>(p: *T, len: uint, f: |v: &[T]| -> U)\n-                               -> U {\n-        f(transmute(Slice {\n-            data: p,\n-            len: len\n-        }))\n-    }\n-\n-    /**\n-     * Form a slice from a pointer and length (as a number of units,\n-     * not bytes).\n-     */\n-    #[inline]\n-    pub unsafe fn mut_buf_as_slice<T,\n-                                   U>(\n-                                   p: *mut T,\n-                                   len: uint,\n-                                   f: |v: &mut [T]| -> U)\n-                                   -> U {\n-        f(transmute(Slice {\n-            data: p as *T,\n-            len: len\n-        }))\n-    }\n+    pub use core::slice::raw::{buf_as_slice, mut_buf_as_slice};\n+    pub use core::slice::raw::{shift_ptr, pop_ptr};\n \n     /**\n     * Constructs a vector from an unsafe pointer to a buffer\n@@ -1942,332 +768,6 @@ pub mod raw {\n         ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n         dst.move_iter().collect()\n     }\n-\n-    /**\n-     * Returns a pointer to first element in slice and adjusts\n-     * slice so it no longer contains that element. Fails if\n-     * slice is empty. O(1).\n-     */\n-    pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> *T {\n-        if slice.len == 0 { fail!(\"shift on empty slice\"); }\n-        let head: *T = slice.data;\n-        slice.data = slice.data.offset(1);\n-        slice.len -= 1;\n-        head\n-    }\n-\n-    /**\n-     * Returns a pointer to last element in slice and adjusts\n-     * slice so it no longer contains that element. Fails if\n-     * slice is empty. O(1).\n-     */\n-    pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> *T {\n-        if slice.len == 0 { fail!(\"pop on empty slice\"); }\n-        let tail: *T = slice.data.offset((slice.len - 1) as int);\n-        slice.len -= 1;\n-        tail\n-    }\n-}\n-\n-/// Operations on `[u8]`.\n-pub mod bytes {\n-    use container::Container;\n-    use slice::MutableVector;\n-    use ptr;\n-\n-    /// A trait for operations on mutable `[u8]`s.\n-    pub trait MutableByteVector {\n-        /// Sets all bytes of the receiver to the given value.\n-        fn set_memory(self, value: u8);\n-    }\n-\n-    impl<'a> MutableByteVector for &'a mut [u8] {\n-        #[inline]\n-        fn set_memory(self, value: u8) {\n-            unsafe { ptr::set_memory(self.as_mut_ptr(), value, self.len()) };\n-        }\n-    }\n-\n-    /// Copies data from `src` to `dst`\n-    ///\n-    /// `src` and `dst` must not overlap. Fails if the length of `dst`\n-    /// is less than the length of `src`.\n-    #[inline]\n-    pub fn copy_memory(dst: &mut [u8], src: &[u8]) {\n-        // Bound checks are done at .copy_memory.\n-        unsafe { dst.copy_memory(src) }\n-    }\n-}\n-\n-impl<A: Clone> Clone for ~[A] {\n-    #[inline]\n-    fn clone(&self) -> ~[A] {\n-        // Use the fast to_owned on &[A] for cloning\n-        self.as_slice().to_owned()\n-    }\n-}\n-\n-impl<'a, T: fmt::Show> fmt::Show for &'a [T] {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if f.flags & (1 << (fmt::parse::FlagAlternate as uint)) == 0 {\n-            try!(write!(f.buf, \"[\"));\n-        }\n-        let mut is_first = true;\n-        for x in self.iter() {\n-            if is_first {\n-                is_first = false;\n-            } else {\n-                try!(write!(f.buf, \", \"));\n-            }\n-            try!(write!(f.buf, \"{}\", *x))\n-        }\n-        if f.flags & (1 << (fmt::parse::FlagAlternate as uint)) == 0 {\n-            try!(write!(f.buf, \"]\"));\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl<'a, T: fmt::Show> fmt::Show for &'a mut [T] {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.as_slice().fmt(f)\n-    }\n-}\n-\n-impl<T: fmt::Show> fmt::Show for ~[T] {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.as_slice().fmt(f)\n-    }\n-}\n-\n-// This works because every lifetime is a sub-lifetime of 'static\n-impl<'a, A> Default for &'a [A] {\n-    fn default() -> &'a [A] { &'a [] }\n-}\n-\n-impl<A> Default for ~[A] {\n-    fn default() -> ~[A] { box [] }\n-}\n-\n-/// Immutable slice iterator\n-pub struct Items<'a, T> {\n-    ptr: *T,\n-    end: *T,\n-    marker: marker::ContravariantLifetime<'a>\n-}\n-\n-/// Mutable slice iterator\n-pub struct MutItems<'a, T> {\n-    ptr: *mut T,\n-    end: *mut T,\n-    marker: marker::ContravariantLifetime<'a>,\n-    marker2: marker::NoCopy\n-}\n-\n-macro_rules! iterator {\n-    (struct $name:ident -> $ptr:ty, $elem:ty) => {\n-        impl<'a, T> Iterator<$elem> for $name<'a, T> {\n-            #[inline]\n-            fn next(&mut self) -> Option<$elem> {\n-                // could be implemented with slices, but this avoids bounds checks\n-                unsafe {\n-                    if self.ptr == self.end {\n-                        None\n-                    } else {\n-                        let old = self.ptr;\n-                        self.ptr = if mem::size_of::<T>() == 0 {\n-                            // purposefully don't use 'ptr.offset' because for\n-                            // vectors with 0-size elements this would return the\n-                            // same pointer.\n-                            transmute(self.ptr as uint + 1)\n-                        } else {\n-                            self.ptr.offset(1)\n-                        };\n-\n-                        Some(transmute(old))\n-                    }\n-                }\n-            }\n-\n-            #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n-                let diff = (self.end as uint) - (self.ptr as uint);\n-                let exact = diff / mem::nonzero_size_of::<T>();\n-                (exact, Some(exact))\n-            }\n-        }\n-\n-        impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$elem> {\n-                // could be implemented with slices, but this avoids bounds checks\n-                unsafe {\n-                    if self.end == self.ptr {\n-                        None\n-                    } else {\n-                        self.end = if mem::size_of::<T>() == 0 {\n-                            // See above for why 'ptr.offset' isn't used\n-                            transmute(self.end as uint - 1)\n-                        } else {\n-                            self.end.offset(-1)\n-                        };\n-                        Some(transmute(self.end))\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n-    #[inline]\n-    fn indexable(&self) -> uint {\n-        let (exact, _) = self.size_hint();\n-        exact\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: uint) -> Option<&'a T> {\n-        unsafe {\n-            if index < self.indexable() {\n-                transmute(self.ptr.offset(index as int))\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-iterator!{struct Items -> *T, &'a T}\n-#[deprecated = \"replaced by Rev<Items<'a, T>>\"]\n-pub type RevItems<'a, T> = Rev<Items<'a, T>>;\n-\n-impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n-impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n-\n-impl<'a, T> Clone for Items<'a, T> {\n-    fn clone(&self) -> Items<'a, T> { *self }\n-}\n-\n-iterator!{struct MutItems -> *mut T, &'a mut T}\n-#[deprecated = \"replaced by Rev<MutItems<'a, T>>\"]\n-pub type RevMutItems<'a, T> = Rev<MutItems<'a, T>>;\n-\n-/// An iterator over the subslices of the vector which are separated\n-/// by elements that match `pred`.\n-pub struct MutSplits<'a, T> {\n-    v: &'a mut [T],\n-    pred: |t: &T|: 'a -> bool,\n-    finished: bool\n-}\n-\n-impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a mut [T]> {\n-        if self.finished { return None; }\n-\n-        let pred = &mut self.pred;\n-        match self.v.iter().position(|x| (*pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let len = tmp.len();\n-                let (head, tail) = tmp.mut_split_at(len);\n-                self.v = tail;\n-                Some(head)\n-            }\n-            Some(idx) => {\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let (head, tail) = tmp.mut_split_at(idx);\n-                self.v = tail.mut_slice_from(1);\n-                Some(head)\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.finished {\n-            (0, Some(0))\n-        } else {\n-            // if the predicate doesn't match anything, we yield one slice\n-            // if it matches every element, we yield len+1 empty slices.\n-            (1, Some(self.v.len() + 1))\n-        }\n-    }\n-}\n-\n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut [T]> {\n-        if self.finished { return None; }\n-\n-        let pred = &mut self.pred;\n-        match self.v.iter().rposition(|x| (*pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                Some(tmp)\n-            }\n-            Some(idx) => {\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let (head, tail) = tmp.mut_split_at(idx);\n-                self.v = head;\n-                Some(tail.mut_slice_from(1))\n-            }\n-        }\n-    }\n-}\n-\n-/// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n-/// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n-/// the remainder.\n-pub struct MutChunks<'a, T> {\n-    v: &'a mut [T],\n-    chunk_size: uint\n-}\n-\n-impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a mut [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let sz = cmp::min(self.v.len(), self.chunk_size);\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.mut_split_at(sz);\n-            self.v = tail;\n-            Some(head)\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.v.len() == 0 {\n-            (0, Some(0))\n-        } else {\n-            let (n, rem) = div_rem(self.v.len(), self.chunk_size);\n-            let n = if rem > 0 { n + 1 } else { n };\n-            (n, Some(n))\n-        }\n-    }\n-}\n-\n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let remainder = self.v.len() % self.chunk_size;\n-            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n-            let (head, tail) = tmp.mut_split_at(tmp_len - sz);\n-            self.v = head;\n-            Some(tail)\n-        }\n-    }\n }\n \n /// An iterator that moves out of a vector.\n@@ -2314,41 +814,6 @@ impl<T> Drop for MoveItems<T> {\n #[deprecated = \"replaced by Rev<MoveItems<'a, T>>\"]\n pub type RevMoveItems<T> = Rev<MoveItems<T>>;\n \n-impl<A> FromIterator<A> for ~[A] {\n-    fn from_iter<T: Iterator<A>>(mut iterator: T) -> ~[A] {\n-        let mut xs: Vec<A> = iterator.collect();\n-\n-        // Must shrink so the capacity is the same as the length. The length of\n-        // the ~[T] vector must exactly match the length of the allocation.\n-        xs.shrink_to_fit();\n-\n-        let len = xs.len();\n-        assert!(len == xs.capacity());\n-        let data = xs.as_mut_ptr();\n-\n-        let data_size = len.checked_mul(&mem::size_of::<A>());\n-        let data_size = data_size.expect(\"overflow in from_iter()\");\n-        let size = mem::size_of::<RawVec<()>>().checked_add(&data_size);\n-        let size = size.expect(\"overflow in from_iter()\");\n-\n-\n-        // This is some terribly awful code. Note that all of this will go away\n-        // with DST because creating ~[T] from Vec<T> will just be some pointer\n-        // swizzling.\n-        unsafe {\n-            let ret = malloc_raw(size) as *mut RawVec<()>;\n-\n-            (*ret).fill = len * mem::nonzero_size_of::<A>();\n-            (*ret).alloc = len * mem::nonzero_size_of::<A>();\n-            ptr::copy_nonoverlapping_memory(&mut (*ret).data as *mut _ as *mut u8,\n-                                            data as *u8,\n-                                            data_size);\n-            xs.set_len(0); // ownership has been transferred\n-            cast::transmute(ret)\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n@@ -3112,7 +1577,6 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_from_elem_fail() {\n-        use cast;\n         use cell::Cell;\n         use rc::Rc;\n "}, {"sha": "666c0a58b3351b1d2b37473a4491de3312661f80", "filename": "src/libstd/str.rs", "status": "modified", "additions": 133, "deletions": 1972, "changes": 2105, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -83,22 +83,24 @@ use cmp::{Eq, TotalEq, Ord, TotalOrd, Equiv, Ordering};\n use container::Container;\n use fmt;\n use io::Writer;\n-use iter::{Iterator, FromIterator, Extendable, range};\n-use iter::{Filter, AdditiveIterator, Map};\n-use iter::{Rev, DoubleEndedIterator, ExactSize};\n-use libc;\n-use num::Saturating;\n+use iter::{Iterator, range, AdditiveIterator};\n use option::{None, Option, Some};\n use ptr;\n use from_str::FromStr;\n-use slice;\n use slice::{OwnedVector, ImmutableVector, MutableVector};\n use slice::{Vector};\n use vec::Vec;\n use default::Default;\n-use raw::Repr;\n use strbuf::StrBuf;\n \n+pub use core::str::{from_utf8, CharEq, Chars, CharOffsets, RevChars};\n+pub use core::str::{RevCharOffsets, Bytes, RevBytes, CharSplits, RevCharSplits};\n+pub use core::str::{CharSplitsN, Words, AnyLines, MatchIndices, StrSplits};\n+pub use core::str::{eq_slice, eq, is_utf8, is_utf16, UTF16Items};\n+pub use core::str::{UTF16Item, ScalarValue, LoneSurrogate, utf16_items};\n+pub use core::str::{truncate_utf16_at_nul, utf8_char_width, CharRange};\n+pub use core::str::{Str, StrSlice};\n+\n /*\n Section: Creating a string\n */\n@@ -113,18 +115,6 @@ pub fn from_utf8_owned(vv: ~[u8]) -> Option<~str> {\n     }\n }\n \n-/// Converts a vector to a string slice without performing any allocations.\n-///\n-/// Once the slice has been validated as utf-8, it is transmuted in-place and\n-/// returned as a '&str' instead of a '&[u8]'\n-///\n-/// Returns None if the slice is not utf-8.\n-pub fn from_utf8<'a>(v: &'a [u8]) -> Option<&'a str> {\n-    if is_utf8(v) {\n-        Some(unsafe { raw::from_utf8(v) })\n-    } else { None }\n-}\n-\n impl FromStr for ~str {\n     #[inline]\n     fn from_str(s: &str) -> Option<~str> { Some(s.to_owned()) }\n@@ -214,348 +204,10 @@ impl<'a, S: Str> StrVector for Vec<S> {\n     }\n }\n \n-/// Something that can be used to compare against a character\n-pub trait CharEq {\n-    /// Determine if the splitter should split at the given character\n-    fn matches(&mut self, char) -> bool;\n-    /// Indicate if this is only concerned about ASCII characters,\n-    /// which can allow for a faster implementation.\n-    fn only_ascii(&self) -> bool;\n-}\n-\n-impl CharEq for char {\n-    #[inline]\n-    fn matches(&mut self, c: char) -> bool { *self == c }\n-\n-    #[inline]\n-    fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n-}\n-\n-impl<'a> CharEq for |char|: 'a -> bool {\n-    #[inline]\n-    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n-\n-    #[inline]\n-    fn only_ascii(&self) -> bool { false }\n-}\n-\n-impl CharEq for extern \"Rust\" fn(char) -> bool {\n-    #[inline]\n-    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n-\n-    #[inline]\n-    fn only_ascii(&self) -> bool { false }\n-}\n-\n-impl<'a> CharEq for &'a [char] {\n-    #[inline]\n-    fn matches(&mut self, c: char) -> bool {\n-        self.iter().any(|&mut m| m.matches(c))\n-    }\n-\n-    #[inline]\n-    fn only_ascii(&self) -> bool {\n-        self.iter().all(|m| m.only_ascii())\n-    }\n-}\n-\n /*\n Section: Iterators\n */\n \n-/// External iterator for a string's characters.\n-/// Use with the `std::iter` module.\n-#[deriving(Clone)]\n-pub struct Chars<'a> {\n-    /// The slice remaining to be iterated\n-    string: &'a str,\n-}\n-\n-impl<'a> Iterator<char> for Chars<'a> {\n-    #[inline]\n-    fn next(&mut self) -> Option<char> {\n-        // Decode the next codepoint, then update\n-        // the slice to be just the remaining part\n-        if self.string.len() != 0 {\n-            let CharRange {ch, next} = self.string.char_range_at(0);\n-            unsafe {\n-                self.string = raw::slice_unchecked(self.string, next, self.string.len());\n-            }\n-            Some(ch)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        (self.string.len().saturating_add(3)/4, Some(self.string.len()))\n-    }\n-}\n-\n-impl<'a> DoubleEndedIterator<char> for Chars<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<char> {\n-        if self.string.len() != 0 {\n-            let CharRange {ch, next} = self.string.char_range_at_reverse(self.string.len());\n-            unsafe {\n-                self.string = raw::slice_unchecked(self.string, 0, next);\n-            }\n-            Some(ch)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// External iterator for a string's characters and their byte offsets.\n-/// Use with the `std::iter` module.\n-#[deriving(Clone)]\n-pub struct CharOffsets<'a> {\n-    /// The original string to be iterated\n-    string: &'a str,\n-    iter: Chars<'a>,\n-}\n-\n-impl<'a> Iterator<(uint, char)> for CharOffsets<'a> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(uint, char)> {\n-        // Compute the byte offset by using the pointer offset between\n-        // the original string slice and the iterator's remaining part\n-        let offset = self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n-        self.iter.next().map(|ch| (offset, ch))\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(uint, char)> {\n-        self.iter.next_back().map(|ch| {\n-            let offset = self.iter.string.len() +\n-                    self.iter.string.as_ptr() as uint - self.string.as_ptr() as uint;\n-            (offset, ch)\n-        })\n-    }\n-}\n-\n-#[deprecated = \"replaced by Rev<Chars<'a>>\"]\n-pub type RevChars<'a> = Rev<Chars<'a>>;\n-\n-#[deprecated = \"replaced by Rev<CharOffsets<'a>>\"]\n-pub type RevCharOffsets<'a> = Rev<CharOffsets<'a>>;\n-\n-/// External iterator for a string's bytes.\n-/// Use with the `std::iter` module.\n-pub type Bytes<'a> =\n-    Map<'a, &'a u8, u8, slice::Items<'a, u8>>;\n-\n-#[deprecated = \"replaced by Rev<Bytes<'a>>\"]\n-pub type RevBytes<'a> = Rev<Bytes<'a>>;\n-\n-/// An iterator over the substrings of a string, separated by `sep`.\n-#[deriving(Clone)]\n-pub struct CharSplits<'a, Sep> {\n-    /// The slice remaining to be iterated\n-    string: &'a str,\n-    sep: Sep,\n-    /// Whether an empty string at the end is allowed\n-    allow_trailing_empty: bool,\n-    only_ascii: bool,\n-    finished: bool,\n-}\n-\n-#[deprecated = \"replaced by Rev<CharSplits<'a, Sep>>\"]\n-pub type RevCharSplits<'a, Sep> = Rev<CharSplits<'a, Sep>>;\n-\n-/// An iterator over the substrings of a string, separated by `sep`,\n-/// splitting at most `count` times.\n-#[deriving(Clone)]\n-pub struct CharSplitsN<'a, Sep> {\n-    iter: CharSplits<'a, Sep>,\n-    /// The number of splits remaining\n-    count: uint,\n-    invert: bool,\n-}\n-\n-/// An iterator over the words of a string, separated by a sequence of whitespace\n-pub type Words<'a> =\n-    Filter<'a, &'a str, CharSplits<'a, extern \"Rust\" fn(char) -> bool>>;\n-\n-/// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n-pub type AnyLines<'a> =\n-    Map<'a, &'a str, &'a str, CharSplits<'a, char>>;\n-\n-impl<'a, Sep> CharSplits<'a, Sep> {\n-    #[inline]\n-    fn get_end(&mut self) -> Option<&'a str> {\n-        if !self.finished && (self.allow_trailing_empty || self.string.len() > 0) {\n-            self.finished = true;\n-            Some(self.string)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplits<'a, Sep> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        if self.finished { return None }\n-\n-        let mut next_split = None;\n-        if self.only_ascii {\n-            for (idx, byte) in self.string.bytes().enumerate() {\n-                if self.sep.matches(byte as char) && byte < 128u8 {\n-                    next_split = Some((idx, idx + 1));\n-                    break;\n-                }\n-            }\n-        } else {\n-            for (idx, ch) in self.string.char_indices() {\n-                if self.sep.matches(ch) {\n-                    next_split = Some((idx, self.string.char_range_at(idx).next));\n-                    break;\n-                }\n-            }\n-        }\n-        match next_split {\n-            Some((a, b)) => unsafe {\n-                let elt = raw::slice_unchecked(self.string, 0, a);\n-                self.string = raw::slice_unchecked(self.string, b, self.string.len());\n-                Some(elt)\n-            },\n-            None => self.get_end(),\n-        }\n-    }\n-}\n-\n-impl<'a, Sep: CharEq> DoubleEndedIterator<&'a str>\n-for CharSplits<'a, Sep> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        if self.finished { return None }\n-\n-        if !self.allow_trailing_empty {\n-            self.allow_trailing_empty = true;\n-            match self.next_back() {\n-                Some(elt) if !elt.is_empty() => return Some(elt),\n-                _ => if self.finished { return None }\n-            }\n-        }\n-        let len = self.string.len();\n-        let mut next_split = None;\n-\n-        if self.only_ascii {\n-            for (idx, byte) in self.string.bytes().enumerate().rev() {\n-                if self.sep.matches(byte as char) && byte < 128u8 {\n-                    next_split = Some((idx, idx + 1));\n-                    break;\n-                }\n-            }\n-        } else {\n-            for (idx, ch) in self.string.char_indices().rev() {\n-                if self.sep.matches(ch) {\n-                    next_split = Some((idx, self.string.char_range_at(idx).next));\n-                    break;\n-                }\n-            }\n-        }\n-        match next_split {\n-            Some((a, b)) => unsafe {\n-                let elt = raw::slice_unchecked(self.string, b, len);\n-                self.string = raw::slice_unchecked(self.string, 0, a);\n-                Some(elt)\n-            },\n-            None => { self.finished = true; Some(self.string) }\n-        }\n-    }\n-}\n-\n-impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplitsN<'a, Sep> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        if self.count != 0 {\n-            self.count -= 1;\n-            if self.invert { self.iter.next_back() } else { self.iter.next() }\n-        } else {\n-            self.iter.get_end()\n-        }\n-    }\n-}\n-\n-/// An iterator over the start and end indices of the matches of a\n-/// substring within a larger string\n-#[deriving(Clone)]\n-pub struct MatchIndices<'a> {\n-    haystack: &'a str,\n-    needle: &'a str,\n-    position: uint,\n-}\n-\n-/// An iterator over the substrings of a string separated by a given\n-/// search string\n-#[deriving(Clone)]\n-pub struct StrSplits<'a> {\n-    it: MatchIndices<'a>,\n-    last_end: uint,\n-    finished: bool\n-}\n-\n-impl<'a> Iterator<(uint, uint)> for MatchIndices<'a> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(uint, uint)> {\n-        // See Issue #1932 for why this is a naive search\n-        let (h_len, n_len) = (self.haystack.len(), self.needle.len());\n-        let mut match_start = 0;\n-        let mut match_i = 0;\n-\n-        while self.position < h_len {\n-            if self.haystack[self.position] == self.needle[match_i] {\n-                if match_i == 0 { match_start = self.position; }\n-                match_i += 1;\n-                self.position += 1;\n-\n-                if match_i == n_len {\n-                    // found a match!\n-                    return Some((match_start, self.position));\n-                }\n-            } else {\n-                // failed match, backtrack\n-                if match_i > 0 {\n-                    match_i = 0;\n-                    self.position = match_start;\n-                }\n-                self.position += 1;\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-impl<'a> Iterator<&'a str> for StrSplits<'a> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        if self.finished { return None; }\n-\n-        match self.it.next() {\n-            Some((from, to)) => {\n-                let ret = Some(self.it.haystack.slice(self.last_end, from));\n-                self.last_end = to;\n-                ret\n-            }\n-            None => {\n-                self.finished = true;\n-                Some(self.it.haystack.slice(self.last_end, self.it.haystack.len()))\n-            }\n-        }\n-    }\n-}\n-\n // Helper functions used for Unicode normalization\n fn canonical_sort(comb: &mut [(char, u8)]) {\n     use iter::range;\n@@ -675,294 +327,10 @@ pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n     result.into_owned()\n }\n \n-/*\n-Section: Comparing strings\n-*/\n-\n-// share the implementation of the lang-item vs. non-lang-item\n-// eq_slice.\n-#[inline]\n-fn eq_slice_(a: &str, b: &str) -> bool {\n-    a.len() == b.len() && unsafe {\n-        libc::memcmp(a.as_ptr() as *libc::c_void,\n-                     b.as_ptr() as *libc::c_void,\n-                     a.len() as libc::size_t) == 0\n-    }\n-}\n-\n-/// Bytewise slice equality\n-#[cfg(not(test))]\n-#[lang=\"str_eq\"]\n-#[inline]\n-pub fn eq_slice(a: &str, b: &str) -> bool {\n-    eq_slice_(a, b)\n-}\n-\n-/// Bytewise slice equality\n-#[cfg(test)]\n-#[inline]\n-pub fn eq_slice(a: &str, b: &str) -> bool {\n-    eq_slice_(a, b)\n-}\n-\n-/// Bytewise string equality\n-#[cfg(not(test))]\n-#[lang=\"uniq_str_eq\"]\n-#[inline]\n-pub fn eq(a: &~str, b: &~str) -> bool {\n-    eq_slice(*a, *b)\n-}\n-\n-#[cfg(test)]\n-#[inline]\n-pub fn eq(a: &~str, b: &~str) -> bool {\n-    eq_slice(*a, *b)\n-}\n-\n /*\n Section: Misc\n */\n \n-/// Walk through `iter` checking that it's a valid UTF-8 sequence,\n-/// returning `true` in that case, or, if it is invalid, `false` with\n-/// `iter` reset such that it is pointing at the first byte in the\n-/// invalid sequence.\n-#[inline(always)]\n-fn run_utf8_validation_iterator(iter: &mut slice::Items<u8>) -> bool {\n-    loop {\n-        // save the current thing we're pointing at.\n-        let old = *iter;\n-\n-        // restore the iterator we had at the start of this codepoint.\n-        macro_rules! err ( () => { {*iter = old; return false} });\n-        macro_rules! next ( () => {\n-                match iter.next() {\n-                    Some(a) => *a,\n-                    // we needed data, but there was none: error!\n-                    None => err!()\n-                }\n-            });\n-\n-        let first = match iter.next() {\n-            Some(&b) => b,\n-            // we're at the end of the iterator and a codepoint\n-            // boundary at the same time, so this string is valid.\n-            None => return true\n-        };\n-\n-        // ASCII characters are always valid, so only large\n-        // bytes need more examination.\n-        if first >= 128 {\n-            let w = utf8_char_width(first);\n-            let second = next!();\n-            // 2-byte encoding is for codepoints  \\u0080 to  \\u07ff\n-            //        first  C2 80        last DF BF\n-            // 3-byte encoding is for codepoints  \\u0800 to  \\uffff\n-            //        first  E0 A0 80     last EF BF BF\n-            //   excluding surrogates codepoints  \\ud800 to  \\udfff\n-            //               ED A0 80 to       ED BF BF\n-            // 4-byte encoding is for codepoints \\u10000 to \\u10ffff\n-            //        first  F0 90 80 80  last F4 8F BF BF\n-            //\n-            // Use the UTF-8 syntax from the RFC\n-            //\n-            // https://tools.ietf.org/html/rfc3629\n-            // UTF8-1      = %x00-7F\n-            // UTF8-2      = %xC2-DF UTF8-tail\n-            // UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /\n-            //               %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )\n-            // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n-            //               %xF4 %x80-8F 2( UTF8-tail )\n-            match w {\n-                2 => if second & 192 != TAG_CONT_U8 {err!()},\n-                3 => {\n-                    match (first, second, next!() & 192) {\n-                        (0xE0        , 0xA0 .. 0xBF, TAG_CONT_U8) |\n-                        (0xE1 .. 0xEC, 0x80 .. 0xBF, TAG_CONT_U8) |\n-                        (0xED        , 0x80 .. 0x9F, TAG_CONT_U8) |\n-                        (0xEE .. 0xEF, 0x80 .. 0xBF, TAG_CONT_U8) => {}\n-                        _ => err!()\n-                    }\n-                }\n-                4 => {\n-                    match (first, second, next!() & 192, next!() & 192) {\n-                        (0xF0        , 0x90 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n-                        (0xF1 .. 0xF3, 0x80 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n-                        (0xF4        , 0x80 .. 0x8F, TAG_CONT_U8, TAG_CONT_U8) => {}\n-                        _ => err!()\n-                    }\n-                }\n-                _ => err!()\n-            }\n-        }\n-    }\n-}\n-\n-/// Determines if a vector of bytes contains valid UTF-8.\n-pub fn is_utf8(v: &[u8]) -> bool {\n-    run_utf8_validation_iterator(&mut v.iter())\n-}\n-\n-#[inline(always)]\n-fn first_non_utf8_index(v: &[u8]) -> Option<uint> {\n-    let mut it = v.iter();\n-\n-    let ok = run_utf8_validation_iterator(&mut it);\n-    if ok {\n-        None\n-    } else {\n-        // work out how many valid bytes we've consumed\n-        // (run_utf8_validation_iterator resets the iterator to just\n-        // after the last good byte), which we can do because the\n-        // vector iterator size_hint is exact.\n-        let (remaining, _) = it.size_hint();\n-        Some(v.len() - remaining)\n-    }\n-}\n-\n-/// Determines if a vector of `u16` contains valid UTF-16\n-pub fn is_utf16(v: &[u16]) -> bool {\n-    let mut it = v.iter();\n-    macro_rules! next ( ($ret:expr) => {\n-            match it.next() { Some(u) => *u, None => return $ret }\n-        }\n-    )\n-    loop {\n-        let u = next!(true);\n-\n-        match char::from_u32(u as u32) {\n-            Some(_) => {}\n-            None => {\n-                let u2 = next!(false);\n-                if u < 0xD7FF || u > 0xDBFF ||\n-                    u2 < 0xDC00 || u2 > 0xDFFF { return false; }\n-            }\n-        }\n-    }\n-}\n-\n-/// An iterator that decodes UTF-16 encoded codepoints from a vector\n-/// of `u16`s.\n-#[deriving(Clone)]\n-pub struct UTF16Items<'a> {\n-    iter: slice::Items<'a, u16>\n-}\n-/// The possibilities for values decoded from a `u16` stream.\n-#[deriving(Eq, TotalEq, Clone, Show)]\n-pub enum UTF16Item {\n-    /// A valid codepoint.\n-    ScalarValue(char),\n-    /// An invalid surrogate without its pair.\n-    LoneSurrogate(u16)\n-}\n-\n-impl UTF16Item {\n-    /// Convert `self` to a `char`, taking `LoneSurrogate`s to the\n-    /// replacement character (U+FFFD).\n-    #[inline]\n-    pub fn to_char_lossy(&self) -> char {\n-        match *self {\n-            ScalarValue(c) => c,\n-            LoneSurrogate(_) => '\\uFFFD'\n-        }\n-    }\n-}\n-\n-impl<'a> Iterator<UTF16Item> for UTF16Items<'a> {\n-    fn next(&mut self) -> Option<UTF16Item> {\n-        let u = match self.iter.next() {\n-            Some(u) => *u,\n-            None => return None\n-        };\n-\n-        if u < 0xD800 || 0xDFFF < u {\n-            // not a surrogate\n-            Some(ScalarValue(unsafe {cast::transmute(u as u32)}))\n-        } else if u >= 0xDC00 {\n-            // a trailing surrogate\n-            Some(LoneSurrogate(u))\n-        } else {\n-            // preserve state for rewinding.\n-            let old = self.iter;\n-\n-            let u2 = match self.iter.next() {\n-                Some(u2) => *u2,\n-                // eof\n-                None => return Some(LoneSurrogate(u))\n-            };\n-            if u2 < 0xDC00 || u2 > 0xDFFF {\n-                // not a trailing surrogate so we're not a valid\n-                // surrogate pair, so rewind to redecode u2 next time.\n-                self.iter = old;\n-                return Some(LoneSurrogate(u))\n-            }\n-\n-            // all ok, so lets decode it.\n-            let c = ((u - 0xD800) as u32 << 10 | (u2 - 0xDC00) as u32) + 0x1_0000;\n-            Some(ScalarValue(unsafe {cast::transmute(c)}))\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        let (low, high) = self.iter.size_hint();\n-        // we could be entirely valid surrogates (2 elements per\n-        // char), or entirely non-surrogates (1 element per char)\n-        (low / 2, high)\n-    }\n-}\n-\n-/// Create an iterator over the UTF-16 encoded codepoints in `v`,\n-/// returning invalid surrogates as `LoneSurrogate`s.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::str;\n-/// use std::str::{ScalarValue, LoneSurrogate};\n-///\n-/// // \ud834\udd1emus<invalid>ic<invalid>\n-/// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///          0x0073, 0xDD1E, 0x0069, 0x0063,\n-///          0xD834];\n-///\n-/// assert_eq!(str::utf16_items(v).collect::<~[_]>(),\n-///            ~[ScalarValue('\ud834\udd1e'),\n-///              ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n-///              LoneSurrogate(0xDD1E),\n-///              ScalarValue('i'), ScalarValue('c'),\n-///              LoneSurrogate(0xD834)]);\n-/// ```\n-pub fn utf16_items<'a>(v: &'a [u16]) -> UTF16Items<'a> {\n-    UTF16Items { iter : v.iter() }\n-}\n-\n-/// Return a slice of `v` ending at (and not including) the first NUL\n-/// (0).\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::str;\n-///\n-/// // \"abcd\"\n-/// let mut v = ['a' as u16, 'b' as u16, 'c' as u16, 'd' as u16];\n-/// // no NULs so no change\n-/// assert_eq!(str::truncate_utf16_at_nul(v), v.as_slice());\n-///\n-/// // \"ab\\0d\"\n-/// v[2] = 0;\n-/// assert_eq!(str::truncate_utf16_at_nul(v),\n-///            &['a' as u16, 'b' as u16]);\n-/// ```\n-pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n-    match v.iter().position(|c| *c == 0) {\n-        // don't include the 0\n-        Some(i) => v.slice_to(i),\n-        None => v\n-    }\n-}\n-\n /// Decode a UTF-16 encoded vector `v` into a string, returning `None`\n /// if `v` contains any invalid data.\n ///\n@@ -1010,42 +378,6 @@ pub fn from_utf16_lossy(v: &[u16]) -> ~str {\n     utf16_items(v).map(|c| c.to_char_lossy()).collect()\n }\n \n-// https://tools.ietf.org/html/rfc3629\n-static UTF8_CHAR_WIDTH: [u8, ..256] = [\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x1F\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x3F\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x5F\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x7F\n-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0x9F\n-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0xBF\n-0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n-2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0xDF\n-3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3, // 0xEF\n-4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0, // 0xFF\n-];\n-\n-/// Given a first byte, determine how many bytes are in this UTF-8 character\n-#[inline]\n-pub fn utf8_char_width(b: u8) -> uint {\n-    return UTF8_CHAR_WIDTH[b as uint] as uint;\n-}\n-\n-/// Struct that contains a `char` and the index of the first byte of\n-/// the next `char` in a string.  This can be used as a data structure\n-/// for iterating over the UTF-8 bytes of a string.\n-pub struct CharRange {\n-    /// Current `char`\n-    pub ch: char,\n-    /// Index of the first byte of the next `char`\n-    pub next: uint,\n-}\n-\n // Return the initial codepoint accumulator for the first byte.\n // The first byte is special, only want bottom 5 bits for width 2, 4 bits\n // for width 3, and 3 bits for width 4\n@@ -1071,13 +403,12 @@ static TAG_CONT_U8: u8 = 128u8;\n /// assert_eq!(output.as_slice(), \"Hello \\uFFFDWorld\");\n /// ```\n pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n-    let firstbad = match first_non_utf8_index(v) {\n-        None => return Slice(unsafe { cast::transmute(v) }),\n-        Some(i) => i\n-    };\n+    if is_utf8(v) {\n+        return Slice(unsafe { cast::transmute(v) })\n+    }\n \n     static REPLACEMENT: &'static [u8] = bytes!(0xEF, 0xBF, 0xBD); // U+FFFD in UTF-8\n-    let mut i = firstbad;\n+    let mut i = 0;\n     let total = v.len();\n     fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n         unsafe { *xs.unsafe_ref(i) }\n@@ -1101,7 +432,7 @@ pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n     // subseqidx is the index of the first byte of the subsequence we're looking at.\n     // It's used to copy a bunch of contiguous good codepoints at once instead of copying\n     // them one by one.\n-    let mut subseqidx = firstbad;\n+    let mut subseqidx = 0;\n \n     while i < total {\n         let i_ = i;\n@@ -1282,7 +613,9 @@ impl<'a> Str for MaybeOwned<'a> {\n             Owned(ref s) => s.as_slice()\n         }\n     }\n+}\n \n+impl<'a> StrAllocating for MaybeOwned<'a> {\n     #[inline]\n     fn into_owned(self) -> ~str {\n         match self {\n@@ -1335,16 +668,17 @@ impl<'a> fmt::Show for MaybeOwned<'a> {\n /// Unsafe operations\n pub mod raw {\n     use cast;\n-    use container::Container;\n     use iter::Iterator;\n     use libc;\n     use ptr::RawPtr;\n     use ptr;\n-    use raw::Slice;\n-    use slice::{MutableVector, ImmutableVector, OwnedVector, Vector};\n-    use str::{is_utf8, StrSlice};\n+    use slice::{MutableVector, OwnedVector, Vector};\n+    use str::{is_utf8};\n     use vec::Vec;\n \n+    pub use core::str::raw::{from_utf8, c_str_to_static_slice, slice_bytes};\n+    pub use core::str::raw::{slice_unchecked};\n+\n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v = Vec::with_capacity(len);\n@@ -1373,12 +707,6 @@ pub mod raw {\n         from_buf_len(buf as *u8, i as uint)\n     }\n \n-    /// Converts a slice of bytes to a string slice without checking\n-    /// that the string contains valid UTF-8.\n-    pub unsafe fn from_utf8<'a>(v: &'a [u8]) -> &'a str {\n-        cast::transmute(v)\n-    }\n-\n     /// Converts an owned vector of bytes to a new owned string. This assumes\n     /// that the utf-8-ness of the vector has already been validated\n     #[inline]\n@@ -1389,1317 +717,158 @@ pub mod raw {\n     /// Converts a byte to a string.\n     pub unsafe fn from_byte(u: u8) -> ~str { from_utf8_owned(box [u]) }\n \n-    /// Form a slice from a C string. Unsafe because the caller must ensure the\n-    /// C string has the static lifetime, or else the return value may be\n-    /// invalidated later.\n-    pub unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n-        let s = s as *u8;\n-        let mut curr = s;\n-        let mut len = 0u;\n-        while *curr != 0u8 {\n-            len += 1u;\n-            curr = s.offset(len as int);\n-        }\n-        let v = Slice { data: s, len: len };\n-        assert!(is_utf8(::cast::transmute(v)));\n-        ::cast::transmute(v)\n-    }\n-\n-    /// Takes a bytewise (not UTF-8) slice from a string.\n-    ///\n-    /// Returns the substring from [`begin`..`end`).\n-    ///\n-    /// # Failure\n-    ///\n-    /// If begin is greater than end.\n-    /// If end is greater than the length of the string.\n-    #[inline]\n-    pub unsafe fn slice_bytes<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-        assert!(begin <= end);\n-        assert!(end <= s.len());\n-        slice_unchecked(s, begin, end)\n-    }\n-\n-    /// Takes a bytewise (not UTF-8) slice from a string.\n-    ///\n-    /// Returns the substring from [`begin`..`end`).\n-    ///\n-    /// Caller must check slice boundaries!\n-    #[inline]\n-    pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-        cast::transmute(Slice {\n-                data: s.as_ptr().offset(begin as int),\n-                len: end - begin,\n-            })\n-    }\n-\n-    /// Access the str in its vector representation.\n-    /// The caller must preserve the valid UTF-8 property when modifying.\n-    #[inline]\n-    pub unsafe fn as_owned_vec<'a>(s: &'a mut ~str) -> &'a mut ~[u8] {\n-        cast::transmute(s)\n-    }\n-\n-    /// Sets the length of a string\n-    ///\n-    /// This will explicitly set the size of the string, without actually\n-    /// modifying its buffers, so it is up to the caller to ensure that\n-    /// the string is actually the specified size.\n-    #[test]\n-    fn test_from_buf_len() {\n-        unsafe {\n-            let a = box [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n-            let b = a.as_ptr();\n-            let c = from_buf_len(b, 3u);\n-            assert_eq!(c, \"AAA\".to_owned());\n-        }\n-    }\n-}\n-\n-/*\n-Section: Trait implementations\n-*/\n-\n-#[cfg(not(test))]\n-#[allow(missing_doc)]\n-pub mod traits {\n-    use container::Container;\n-    use cmp::{TotalOrd, Ordering, Less, Equal, Greater, Eq, Ord, Equiv, TotalEq};\n-    use iter::Iterator;\n-    use ops::Add;\n-    use option::{Some, None};\n-    use str::{Str, StrSlice, eq_slice};\n-    use strbuf::StrBuf;\n-\n-    impl<'a> Add<&'a str,~str> for &'a str {\n-        #[inline]\n-        fn add(&self, rhs: & &'a str) -> ~str {\n-            let mut ret = StrBuf::from_owned_str(self.to_owned());\n-            ret.push_str(*rhs);\n-            ret.into_owned()\n-        }\n-    }\n-\n-    impl<'a> TotalOrd for &'a str {\n-        #[inline]\n-        fn cmp(&self, other: & &'a str) -> Ordering {\n-            for (s_b, o_b) in self.bytes().zip(other.bytes()) {\n-                match s_b.cmp(&o_b) {\n-                    Greater => return Greater,\n-                    Less => return Less,\n-                    Equal => ()\n-                }\n-            }\n-\n-            self.len().cmp(&other.len())\n-        }\n-    }\n-\n-    impl TotalOrd for ~str {\n-        #[inline]\n-        fn cmp(&self, other: &~str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n-    }\n-\n-    impl<'a> Eq for &'a str {\n-        #[inline]\n-        fn eq(&self, other: & &'a str) -> bool {\n-            eq_slice((*self), (*other))\n-        }\n-        #[inline]\n-        fn ne(&self, other: & &'a str) -> bool { !(*self).eq(other) }\n-    }\n-\n-    impl Eq for ~str {\n-        #[inline]\n-        fn eq(&self, other: &~str) -> bool {\n-            eq_slice((*self), (*other))\n-        }\n-    }\n-\n-    impl<'a> TotalEq for &'a str {}\n-\n-    impl TotalEq for ~str {}\n-\n-    impl<'a> Ord for &'a str {\n-        #[inline]\n-        fn lt(&self, other: & &'a str) -> bool { self.cmp(other) == Less }\n-    }\n-\n-    impl Ord for ~str {\n-        #[inline]\n-        fn lt(&self, other: &~str) -> bool { self.cmp(other) == Less }\n-    }\n-\n-    impl<'a, S: Str> Equiv<S> for &'a str {\n-        #[inline]\n-        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n-    }\n-\n-    impl<'a, S: Str> Equiv<S> for ~str {\n-        #[inline]\n-        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n-    }\n-}\n-\n-#[cfg(test)]\n-pub mod traits {}\n-\n-/// Any string that can be represented as a slice\n-pub trait Str {\n-    /// Work with `self` as a slice.\n-    fn as_slice<'a>(&'a self) -> &'a str;\n-\n-    /// Convert `self` into a ~str, not making a copy if possible.\n-    fn into_owned(self) -> ~str;\n-\n-    /// Convert `self` into a `StrBuf`.\n-    #[inline]\n-    fn to_strbuf(&self) -> StrBuf {\n-        StrBuf::from_str(self.as_slice())\n-    }\n-\n-    /// Convert `self` into a `StrBuf`, not making a copy if possible.\n-    #[inline]\n-    fn into_strbuf(self) -> StrBuf {\n-        StrBuf::from_owned_str(self.into_owned())\n-    }\n-}\n-\n-impl<'a> Str for &'a str {\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a str { *self }\n-\n-    #[inline]\n-    fn into_owned(self) -> ~str { self.to_owned() }\n-}\n-\n-impl<'a> Str for ~str {\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a str {\n-        let s: &'a str = *self; s\n-    }\n-\n-    #[inline]\n-    fn into_owned(self) -> ~str { self }\n-}\n-\n-impl<'a> Container for &'a str {\n-    #[inline]\n-    fn len(&self) -> uint {\n-        self.repr().len\n-    }\n-}\n-\n-impl Container for ~str {\n-    #[inline]\n-    fn len(&self) -> uint { self.as_slice().len() }\n-}\n-\n-/// Methods for string slices\n-pub trait StrSlice<'a> {\n-    /// Returns true if one string contains another\n-    ///\n-    /// # Arguments\n-    ///\n-    /// - needle - The string to look for\n-    fn contains<'a>(&self, needle: &'a str) -> bool;\n-\n-    /// Returns true if a string contains a char.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// - needle - The char to look for\n-    fn contains_char(&self, needle: char) -> bool;\n-\n-    /// An iterator over the characters of `self`. Note, this iterates\n-    /// over unicode code-points, not unicode graphemes.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: ~[char] = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n-    /// assert_eq!(v, ~['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n-    /// ```\n-    fn chars(&self) -> Chars<'a>;\n-\n-    /// Do not use this - it is deprecated.\n-    #[deprecated = \"replaced by .chars().rev()\"]\n-    fn chars_rev(&self) -> Rev<Chars<'a>>;\n-\n-    /// An iterator over the bytes of `self`\n-    fn bytes(&self) -> Bytes<'a>;\n-\n-    /// Do not use this - it is deprecated.\n-    #[deprecated = \"replaced by .bytes().rev()\"]\n-    fn bytes_rev(&self) -> Rev<Bytes<'a>>;\n-\n-    /// An iterator over the characters of `self` and their byte offsets.\n-    fn char_indices(&self) -> CharOffsets<'a>;\n-\n-    /// Do not use this - it is deprecated.\n-    #[deprecated = \"replaced by .char_indices().rev()\"]\n-    fn char_indices_rev(&self) -> Rev<CharOffsets<'a>>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lamb\".split(' ').collect();\n-    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).collect();\n-    /// assert_eq!(v, ~[\"abc\", \"def\", \"ghi\"]);\n-    ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, ~[\"lion\", \"\", \"tiger\", \"leopard\"]);\n-    /// ```\n-    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`, restricted to splitting at most `count`\n-    /// times.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lambda\".splitn(' ', 2).collect();\n-    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a little lambda\"]);\n-    ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".splitn(|c: char| c.is_digit(), 1).collect();\n-    /// assert_eq!(v, ~[\"abc\", \"def2ghi\"]);\n-    ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".splitn('X', 2).collect();\n-    /// assert_eq!(v, ~[\"lion\", \"\", \"tigerXleopard\"]);\n-    /// ```\n-    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`.\n-    ///\n-    /// Equivalent to `split`, except that the trailing substring\n-    /// is skipped if empty (terminator semantics).\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: ~[&str] = \"A.B.\".split_terminator('.').collect();\n-    /// assert_eq!(v, ~[\"A\", \"B\"]);\n-    ///\n-    /// let v: ~[&str] = \"A..B..\".split_terminator('.').collect();\n-    /// assert_eq!(v, ~[\"A\", \"\", \"B\", \"\"]);\n-    ///\n-    /// let v: ~[&str] = \"Mary had a little lamb\".split(' ').rev().collect();\n-    /// assert_eq!(v, ~[\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n-    ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).rev().collect();\n-    /// assert_eq!(v, ~[\"ghi\", \"def\", \"abc\"]);\n-    ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').rev().collect();\n-    /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"\", \"lion\"]);\n-    /// ```\n-    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n-\n-    /// Do not use this - it is deprecated.\n-    #[deprecated = \"replaced by .split(sep).rev()\"]\n-    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> Rev<CharSplits<'a, Sep>>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`, starting from the end of the string.\n-    /// Restricted to splitting at most `count` times.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lamb\".rsplitn(' ', 2).collect();\n-    /// assert_eq!(v, ~[\"lamb\", \"little\", \"Mary had a\"]);\n-    ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".rsplitn(|c: char| c.is_digit(), 1).collect();\n-    /// assert_eq!(v, ~[\"ghi\", \"abc1def\"]);\n-    ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".rsplitn('X', 2).collect();\n-    /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"lionX\"]);\n-    /// ```\n-    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitsN<'a, Sep>;\n-\n-    /// An iterator over the start and end indices of the disjoint\n-    /// matches of `sep` within `self`.\n-    ///\n-    /// That is, each returned value `(start, end)` satisfies\n-    /// `self.slice(start, end) == sep`. For matches of `sep` within\n-    /// `self` that overlap, only the indicies corresponding to the\n-    /// first match are returned.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: ~[(uint, uint)] = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, ~[(0,3), (6,9), (12,15)]);\n-    ///\n-    /// let v: ~[(uint, uint)] = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, ~[(1,4), (4,7)]);\n-    ///\n-    /// let v: ~[(uint, uint)] = \"ababa\".match_indices(\"aba\").collect();\n-    /// assert_eq!(v, ~[(0, 3)]); // only the first `aba`\n-    /// ```\n-    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a>;\n-\n-    /// An iterator over the substrings of `self` separated by `sep`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: ~[&str] = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, ~[\"\", \"XXX\", \"YYY\", \"\"]);\n-    ///\n-    /// let v: ~[&str] = \"1abcabc2\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, ~[\"1\", \"\", \"2\"]);\n-    /// ```\n-    fn split_str(&self, &'a str) -> StrSplits<'a>;\n-\n-    /// An iterator over the lines of a string (subsequences separated\n-    /// by `\\n`). This does not include the empty string after a\n-    /// trailing `\\n`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n-    /// let v: ~[&str] = four_lines.lines().collect();\n-    /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n-    fn lines(&self) -> CharSplits<'a, char>;\n-\n-    /// An iterator over the lines of a string, separated by either\n-    /// `\\n` or `\\r\\n`. As with `.lines()`, this does not include an\n-    /// empty trailing line.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n-    /// let v: ~[&str] = four_lines.lines_any().collect();\n-    /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n-    fn lines_any(&self) -> AnyLines<'a>;\n-\n-    /// An iterator over the words of a string (subsequences separated\n-    /// by any sequence of whitespace). Sequences of whitespace are\n-    /// collapsed, so empty \"words\" are not included.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n-    /// let v: ~[&str] = some_words.words().collect();\n-    /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n-    /// ```\n-    fn words(&self) -> Words<'a>;\n-\n-    /// An Iterator over the string in Unicode Normalization Form D\n-    /// (canonical decomposition).\n-    fn nfd_chars(&self) -> Normalizations<'a>;\n-\n-    /// An Iterator over the string in Unicode Normalization Form KD\n-    /// (compatibility decomposition).\n-    fn nfkd_chars(&self) -> Normalizations<'a>;\n-\n-    /// Returns true if the string contains only whitespace.\n-    ///\n-    /// Whitespace characters are determined by `char::is_whitespace`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\" \\t\\n\".is_whitespace());\n-    /// assert!(\"\".is_whitespace());\n-    ///\n-    /// assert!( !\"abc\".is_whitespace());\n-    /// ```\n-    fn is_whitespace(&self) -> bool;\n-\n-    /// Returns true if the string contains only alphanumeric code\n-    /// points.\n-    ///\n-    /// Alphanumeric characters are determined by `char::is_alphanumeric`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert!(\"L\u00f6we\u8001\u864eL\u00e9opard123\".is_alphanumeric());\n-    /// assert!(\"\".is_alphanumeric());\n-    ///\n-    /// assert!( !\" &*~\".is_alphanumeric());\n-    /// ```\n-    fn is_alphanumeric(&self) -> bool;\n-\n-    /// Returns the number of Unicode code points (`char`) that a\n-    /// string holds.\n-    ///\n-    /// This does not perform any normalization, and is `O(n)`, since\n-    /// UTF-8 is a variable width encoding of code points.\n-    ///\n-    /// *Warning*: The number of code points in a string does not directly\n-    /// correspond to the number of visible characters or width of the\n-    /// visible text due to composing characters, and double- and\n-    /// zero-width ones.\n-    ///\n-    /// See also `.len()` for the byte length.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// // composed forms of `\u00f6` and `\u00e9`\n-    /// let c = \"L\u00f6we \u8001\u864e L\u00e9opard\"; // German, Simplified Chinese, French\n-    /// // decomposed forms of `\u00f6` and `\u00e9`\n-    /// let d = \"Lo\\u0308we \u8001\u864e Le\\u0301opard\";\n-    ///\n-    /// assert_eq!(c.char_len(), 15);\n-    /// assert_eq!(d.char_len(), 17);\n-    ///\n-    /// assert_eq!(c.len(), 21);\n-    /// assert_eq!(d.len(), 23);\n-    ///\n-    /// // the two strings *look* the same\n-    /// println!(\"{}\", c);\n-    /// println!(\"{}\", d);\n-    /// ```\n-    fn char_len(&self) -> uint;\n-\n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`..`end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Fails when `begin` and `end` do not point to valid characters\n-    /// or point beyond the last character of the string.\n-    ///\n-    /// See also `slice_to` and `slice_from` for slicing prefixes and\n-    /// suffixes of strings, and `slice_chars` for slicing based on\n-    /// code point counts.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(s.slice(0, 1), \"L\");\n-    ///\n-    /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\");\n-    ///\n-    /// // these will fail:\n-    /// // byte 2 lies within `\u00f6`:\n-    /// // s.slice(2, 3);\n-    ///\n-    /// // byte 8 lies within `\u8001`\n-    /// // s.slice(1, 8);\n-    ///\n-    /// // byte 100 is outside the string\n-    /// // s.slice(3, 100);\n-    /// ```\n-    fn slice(&self, begin: uint, end: uint) -> &'a str;\n-\n-    /// Returns a slice of the string from `begin` to its end.\n-    ///\n-    /// Equivalent to `self.slice(begin, self.len())`.\n-    ///\n-    /// Fails when `begin` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_to` and `slice_chars`.\n-    fn slice_from(&self, begin: uint) -> &'a str;\n-\n-    /// Returns a slice of the string from the beginning to byte\n-    /// `end`.\n-    ///\n-    /// Equivalent to `self.slice(0, end)`.\n-    ///\n-    /// Fails when `end` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_from` and `slice_chars`.\n-    fn slice_to(&self, end: uint) -> &'a str;\n-\n-    /// Returns a slice of the string from the character range\n-    /// [`begin`..`end`).\n-    ///\n-    /// That is, start at the `begin`-th code point of the string and\n-    /// continue to the `end`-th code point. This does not detect or\n-    /// handle edge cases such as leaving a combining character as the\n-    /// first code point of the string.\n-    ///\n-    /// Due to the design of UTF-8, this operation is `O(end)`.\n-    /// See `slice`, `slice_to` and `slice_from` for `O(1)`\n-    /// variants that use byte indices rather than code point\n-    /// indices.\n-    ///\n-    /// Fails if `begin` > `end` or the either `begin` or `end` are\n-    /// beyond the last character of the string.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n-    /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n-    /// ```\n-    fn slice_chars(&self, begin: uint, end: uint) -> &'a str;\n-\n-    /// Returns true if `needle` is a prefix of the string.\n-    fn starts_with(&self, needle: &str) -> bool;\n-\n-    /// Returns true if `needle` is a suffix of the string.\n-    fn ends_with(&self, needle: &str) -> bool;\n-\n-    /// Escape each char in `s` with `char::escape_default`.\n-    fn escape_default(&self) -> ~str;\n-\n-    /// Escape each char in `s` with `char::escape_unicode`.\n-    fn escape_unicode(&self) -> ~str;\n-\n-    /// Returns a string with leading and trailing whitespace removed.\n-    fn trim(&self) -> &'a str;\n-\n-    /// Returns a string with leading whitespace removed.\n-    fn trim_left(&self) -> &'a str;\n-\n-    /// Returns a string with trailing whitespace removed.\n-    fn trim_right(&self) -> &'a str;\n-\n-    /// Returns a string with characters that match `to_trim` removed.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * to_trim - a character matcher\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\")\n-    /// assert_eq!(\"12foo1bar12\".trim_chars(&['1', '2']), \"foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_chars(|c: char| c.is_digit()), \"foo1bar\")\n-    /// ```\n-    fn trim_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n-\n-    /// Returns a string with leading `chars_to_trim` removed.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * to_trim - a character matcher\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\")\n-    /// assert_eq!(\"12foo1bar12\".trim_left_chars(&['1', '2']), \"foo1bar12\")\n-    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|c: char| c.is_digit()), \"foo1bar123\")\n-    /// ```\n-    fn trim_left_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n-\n-    /// Returns a string with trailing `chars_to_trim` removed.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * to_trim - a character matcher\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\")\n-    /// assert_eq!(\"12foo1bar12\".trim_right_chars(&['1', '2']), \"12foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|c: char| c.is_digit()), \"123foo1bar\")\n-    /// ```\n-    fn trim_right_chars<C: CharEq>(&self, to_trim: C) -> &'a str;\n-\n-    /// Replace all occurrences of one string with another.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * `from` - The string to replace\n-    /// * `to` - The replacement string\n-    ///\n-    /// # Return value\n-    ///\n-    /// The original string with all occurrences of `from` replaced with `to`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"Do you know the muffin man,\n-    /// The muffin man, the muffin man, ...\".to_owned();\n-    ///\n-    /// assert_eq!(s.replace(\"muffin man\", \"little lamb\"),\n-    ///            \"Do you know the little lamb,\n-    /// The little lamb, the little lamb, ...\".to_owned());\n-    ///\n-    /// // not found, so no change.\n-    /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n-    /// ```\n-    fn replace(&self, from: &str, to: &str) -> ~str;\n-\n-    /// Copy a slice into a new owned str.\n-    fn to_owned(&self) -> ~str;\n-\n-    /// Converts to a vector of `u16` encoded as UTF-16.\n-    fn to_utf16(&self) -> ~[u16];\n-\n-    /// Check that `index`-th byte lies at the start and/or end of a\n-    /// UTF-8 code point sequence.\n-    ///\n-    /// The start and end of the string (when `index == self.len()`)\n-    /// are considered to be boundaries.\n-    ///\n-    /// Fails if `index` is greater than `self.len()`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert!(s.is_char_boundary(0));\n-    /// // start of `\u8001`\n-    /// assert!(s.is_char_boundary(6));\n-    /// assert!(s.is_char_boundary(s.len()));\n-    ///\n-    /// // second byte of `\u00f6`\n-    /// assert!(!s.is_char_boundary(2));\n-    ///\n-    /// // third byte of `\u8001`\n-    /// assert!(!s.is_char_boundary(8));\n-    /// ```\n-    fn is_char_boundary(&self, index: uint) -> bool;\n-\n-    /// Pluck a character out of a string and return the index of the next\n-    /// character.\n-    ///\n-    /// This function can be used to iterate over the unicode characters of a\n-    /// string.\n-    ///\n-    /// # Example\n-    ///\n-    /// This example manually iterate through the characters of a\n-    /// string; this should normally by done by `.chars()` or\n-    /// `.char_indices`.\n-    ///\n-    /// ```rust\n-    /// use std::str::CharRange;\n-    ///\n-    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n-    /// let mut i = 0u;\n-    /// while i < s.len() {\n-    ///     let CharRange {ch, next} = s.char_range_at(i);\n-    ///     println!(\"{}: {}\", i, ch);\n-    ///     i = next;\n-    /// }\n-    /// ```\n-    ///\n-    /// ## Output\n-    ///\n-    /// ```ignore\n-    /// 0: \u4e2d\n-    /// 3: \u534e\n-    /// 6: V\n-    /// 7: i\n-    /// 8: \u1ec7\n-    /// 11: t\n-    /// 12:\n-    /// 13: N\n-    /// 14: a\n-    /// 15: m\n-    /// ```\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * s - The string\n-    /// * i - The byte offset of the char to extract\n-    ///\n-    /// # Return value\n-    ///\n-    /// A record {ch: char, next: uint} containing the char value and the byte\n-    /// index of the next unicode character.\n-    ///\n-    /// # Failure\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n-    fn char_range_at(&self, start: uint) -> CharRange;\n-\n-    /// Given a byte position and a str, return the previous char and its position.\n-    ///\n-    /// This function can be used to iterate over a unicode string in reverse.\n-    ///\n-    /// Returns 0 for next index if called on start index 0.\n-    fn char_range_at_reverse(&self, start: uint) -> CharRange;\n-\n-    /// Plucks the character starting at the `i`th byte of a string\n-    fn char_at(&self, i: uint) -> char;\n-\n-    /// Plucks the character ending at the `i`th byte of a string\n-    fn char_at_reverse(&self, i: uint) -> char;\n-\n-    /// Work with the byte buffer of a string as a byte slice.\n-    fn as_bytes(&self) -> &'a [u8];\n-\n-    /// Returns the byte index of the first character of `self` that\n-    /// matches `search`.\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the last matching character\n-    /// or `None` if there is no match\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find('L'), Some(0));\n-    /// assert_eq!(s.find('\u00e9'), Some(14));\n-    ///\n-    /// // the first space\n-    /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n-    ///\n-    /// // neither are found\n-    /// assert_eq!(s.find(&['1', '2']), None);\n-    /// ```\n-    fn find<C: CharEq>(&self, search: C) -> Option<uint>;\n-\n-    /// Returns the byte index of the last character of `self` that\n-    /// matches `search`.\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the last matching character\n-    /// or `None` if there is no match.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.rfind('L'), Some(13));\n-    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n-    ///\n-    /// // the second space\n-    /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n-    ///\n-    /// // searches for an occurrence of either `1` or `2`, but neither are found\n-    /// assert_eq!(s.rfind(&['1', '2']), None);\n-    /// ```\n-    fn rfind<C: CharEq>(&self, search: C) -> Option<uint>;\n-\n-    /// Returns the byte index of the first matching substring\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * `needle` - The string to search for\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the first matching substring\n-    /// or `None` if there is no match.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n-    /// assert_eq!(s.find_str(\"muffin man\"), None);\n-    /// ```\n-    fn find_str(&self, &str) -> Option<uint>;\n-\n-    /// Given a string, make a new string with repeated copies of it.\n-    fn repeat(&self, nn: uint) -> ~str;\n-\n-    /// Retrieves the first character from a string slice and returns\n-    /// it. This does not allocate a new string; instead, it returns a\n-    /// slice that point one character beyond the character that was\n-    /// shifted. If the string does not contain any characters,\n-    /// a tuple of None and an empty string is returned instead.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let (c, s1) = s.slice_shift_char();\n-    /// assert_eq!(c, Some('L'));\n-    /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n-    ///\n-    /// let (c, s2) = s1.slice_shift_char();\n-    /// assert_eq!(c, Some('\u00f6'));\n-    /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n-    /// ```\n-    fn slice_shift_char(&self) -> (Option<char>, &'a str);\n-\n-    /// Levenshtein Distance between two strings.\n-    fn lev_distance(&self, t: &str) -> uint;\n-\n-    /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n-    ///\n-    /// Fails if `inner` is not a direct slice contained within self.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let string = \"a\\nb\\nc\";\n-    /// let lines: ~[&str] = string.lines().collect();\n-    ///\n-    /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n-    /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n-    /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n-    /// ```\n-    fn subslice_offset(&self, inner: &str) -> uint;\n-\n-    /// Return an unsafe pointer to the strings buffer.\n-    ///\n-    /// The caller must ensure that the string outlives this pointer,\n-    /// and that it is not reallocated (e.g. by pushing to the\n-    /// string).\n-    fn as_ptr(&self) -> *u8;\n-}\n-\n-impl<'a> StrSlice<'a> for &'a str {\n-    #[inline]\n-    fn contains<'a>(&self, needle: &'a str) -> bool {\n-        self.find_str(needle).is_some()\n-    }\n-\n-    #[inline]\n-    fn contains_char(&self, needle: char) -> bool {\n-        self.find(needle).is_some()\n-    }\n-\n-    #[inline]\n-    fn chars(&self) -> Chars<'a> {\n-        Chars{string: *self}\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .chars().rev()\"]\n-    fn chars_rev(&self) -> Rev<Chars<'a>> {\n-        self.chars().rev()\n-    }\n-\n-    #[inline]\n-    fn bytes(&self) -> Bytes<'a> {\n-        self.as_bytes().iter().map(|&b| b)\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .bytes().rev()\"]\n-    fn bytes_rev(&self) -> Rev<Bytes<'a>> {\n-        self.bytes().rev()\n-    }\n-\n-    #[inline]\n-    fn char_indices(&self) -> CharOffsets<'a> {\n-        CharOffsets{string: *self, iter: self.chars()}\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .char_indices().rev()\"]\n-    fn char_indices_rev(&self) -> Rev<CharOffsets<'a>> {\n-        self.char_indices().rev()\n-    }\n-\n-    #[inline]\n-    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep> {\n-        CharSplits {\n-            string: *self,\n-            only_ascii: sep.only_ascii(),\n-            sep: sep,\n-            allow_trailing_empty: true,\n-            finished: false,\n-        }\n-    }\n-\n-    #[inline]\n-    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n-        -> CharSplitsN<'a, Sep> {\n-        CharSplitsN {\n-            iter: self.split(sep),\n-            count: count,\n-            invert: false,\n-        }\n-    }\n-\n-    #[inline]\n-    fn split_terminator<Sep: CharEq>(&self, sep: Sep)\n-        -> CharSplits<'a, Sep> {\n-        CharSplits {\n-            allow_trailing_empty: false,\n-            ..self.split(sep)\n-        }\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .split(sep).rev()\"]\n-    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> Rev<CharSplits<'a, Sep>> {\n-        self.split(sep).rev()\n-    }\n-\n-    #[inline]\n-    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n-        -> CharSplitsN<'a, Sep> {\n-        CharSplitsN {\n-            iter: self.split(sep),\n-            count: count,\n-            invert: true,\n-        }\n-    }\n-\n-    #[inline]\n-    fn match_indices(&self, sep: &'a str) -> MatchIndices<'a> {\n-        assert!(!sep.is_empty())\n-        MatchIndices {\n-            haystack: *self,\n-            needle: sep,\n-            position: 0\n-        }\n-    }\n-\n-    #[inline]\n-    fn split_str(&self, sep: &'a str) -> StrSplits<'a> {\n-        StrSplits {\n-            it: self.match_indices(sep),\n-            last_end: 0,\n-            finished: false\n-        }\n-    }\n-\n-    #[inline]\n-    fn lines(&self) -> CharSplits<'a, char> {\n-        self.split_terminator('\\n')\n-    }\n-\n-    fn lines_any(&self) -> AnyLines<'a> {\n-        self.lines().map(|line| {\n-            let l = line.len();\n-            if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n-            else { line }\n-        })\n-    }\n-\n+    /// Access the str in its vector representation.\n+    /// The caller must preserve the valid UTF-8 property when modifying.\n     #[inline]\n-    fn words(&self) -> Words<'a> {\n-        self.split(char::is_whitespace).filter(|s| !s.is_empty())\n+    pub unsafe fn as_owned_vec<'a>(s: &'a mut ~str) -> &'a mut ~[u8] {\n+        cast::transmute(s)\n     }\n \n-    #[inline]\n-    fn nfd_chars(&self) -> Normalizations<'a> {\n-        Normalizations {\n-            iter: self.chars(),\n-            buffer: Vec::new(),\n-            sorted: false,\n-            kind: NFD\n-        }\n-    }\n+    /// Sets the length of a string\n+    ///\n+    /// This will explicitly set the size of the string, without actually\n+    /// modifying its buffers, so it is up to the caller to ensure that\n+    /// the string is actually the specified size.\n+    #[test]\n+    fn test_from_buf_len() {\n+        use slice::ImmutableVector;\n+        use str::StrAllocating;\n \n-    #[inline]\n-    fn nfkd_chars(&self) -> Normalizations<'a> {\n-        Normalizations {\n-            iter: self.chars(),\n-            buffer: Vec::new(),\n-            sorted: false,\n-            kind: NFKD\n+        unsafe {\n+            let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n+            let b = a.as_ptr();\n+            let c = from_buf_len(b, 3u);\n+            assert_eq!(c, \"AAA\".to_owned());\n         }\n     }\n+}\n \n-    #[inline]\n-    fn is_whitespace(&self) -> bool { self.chars().all(char::is_whitespace) }\n-\n-    #[inline]\n-    fn is_alphanumeric(&self) -> bool { self.chars().all(char::is_alphanumeric) }\n-\n-    #[inline]\n-    fn char_len(&self) -> uint { self.chars().len() }\n-\n-    #[inline]\n-    fn slice(&self, begin: uint, end: uint) -> &'a str {\n-        assert!(self.is_char_boundary(begin) && self.is_char_boundary(end));\n-        unsafe { raw::slice_bytes(*self, begin, end) }\n-    }\n-\n-    #[inline]\n-    fn slice_from(&self, begin: uint) -> &'a str {\n-        self.slice(begin, self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &'a str {\n-        assert!(self.is_char_boundary(end));\n-        unsafe { raw::slice_bytes(*self, 0, end) }\n-    }\n-\n-    fn slice_chars(&self, begin: uint, end: uint) -> &'a str {\n-        assert!(begin <= end);\n-        let mut count = 0;\n-        let mut begin_byte = None;\n-        let mut end_byte = None;\n-\n-        // This could be even more efficient by not decoding,\n-        // only finding the char boundaries\n-        for (idx, _) in self.char_indices() {\n-            if count == begin { begin_byte = Some(idx); }\n-            if count == end { end_byte = Some(idx); break; }\n-            count += 1;\n-        }\n-        if begin_byte.is_none() && count == begin { begin_byte = Some(self.len()) }\n-        if end_byte.is_none() && count == end { end_byte = Some(self.len()) }\n+/*\n+Section: Trait implementations\n+*/\n \n-        match (begin_byte, end_byte) {\n-            (None, _) => fail!(\"slice_chars: `begin` is beyond end of string\"),\n-            (_, None) => fail!(\"slice_chars: `end` is beyond end of string\"),\n-            (Some(a), Some(b)) => unsafe { raw::slice_bytes(*self, a, b) }\n-        }\n-    }\n+/// Any string that can be represented as a slice\n+pub trait StrAllocating: Str {\n+    /// Convert `self` into a ~str, not making a copy if possible.\n+    fn into_owned(self) -> ~str;\n \n+    /// Convert `self` into a `StrBuf`.\n     #[inline]\n-    fn starts_with<'a>(&self, needle: &'a str) -> bool {\n-        let n = needle.len();\n-        self.len() >= n && needle.as_bytes() == self.as_bytes().slice_to(n)\n+    fn to_strbuf(&self) -> StrBuf {\n+        StrBuf::from_str(self.as_slice())\n     }\n \n+    /// Convert `self` into a `StrBuf`, not making a copy if possible.\n     #[inline]\n-    fn ends_with(&self, needle: &str) -> bool {\n-        let (m, n) = (self.len(), needle.len());\n-        m >= n && needle.as_bytes() == self.as_bytes().slice_from(m - n)\n+    fn into_strbuf(self) -> StrBuf {\n+        StrBuf::from_owned_str(self.into_owned())\n     }\n \n+    /// Escape each char in `s` with `char::escape_default`.\n     fn escape_default(&self) -> ~str {\n-        let mut out = StrBuf::with_capacity(self.len());\n-        for c in self.chars() {\n+        let me = self.as_slice();\n+        let mut out = StrBuf::with_capacity(me.len());\n+        for c in me.chars() {\n             c.escape_default(|c| out.push_char(c));\n         }\n         out.into_owned()\n     }\n \n+    /// Escape each char in `s` with `char::escape_unicode`.\n     fn escape_unicode(&self) -> ~str {\n-        let mut out = StrBuf::with_capacity(self.len());\n-        for c in self.chars() {\n+        let me = self.as_slice();\n+        let mut out = StrBuf::with_capacity(me.len());\n+        for c in me.chars() {\n             c.escape_unicode(|c| out.push_char(c));\n         }\n         out.into_owned()\n     }\n \n-    #[inline]\n-    fn trim(&self) -> &'a str {\n-        self.trim_left().trim_right()\n-    }\n-\n-    #[inline]\n-    fn trim_left(&self) -> &'a str {\n-        self.trim_left_chars(char::is_whitespace)\n-    }\n-\n-    #[inline]\n-    fn trim_right(&self) -> &'a str {\n-        self.trim_right_chars(char::is_whitespace)\n-    }\n-\n-    #[inline]\n-    fn trim_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n-        let cur = match self.find(|c: char| !to_trim.matches(c)) {\n-            None => \"\",\n-            Some(i) => unsafe { raw::slice_bytes(*self, i, self.len()) }\n-        };\n-        match cur.rfind(|c: char| !to_trim.matches(c)) {\n-            None => \"\",\n-            Some(i) => {\n-                let right = cur.char_range_at(i).next;\n-                unsafe { raw::slice_bytes(cur, 0, right) }\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn trim_left_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n-        match self.find(|c: char| !to_trim.matches(c)) {\n-            None => \"\",\n-            Some(first) => unsafe { raw::slice_bytes(*self, first, self.len()) }\n-        }\n-    }\n-\n-    #[inline]\n-    fn trim_right_chars<C: CharEq>(&self, mut to_trim: C) -> &'a str {\n-        match self.rfind(|c: char| !to_trim.matches(c)) {\n-            None => \"\",\n-            Some(last) => {\n-                let next = self.char_range_at(last).next;\n-                unsafe { raw::slice_bytes(*self, 0u, next) }\n-            }\n-        }\n-    }\n-\n+    /// Replace all occurrences of one string with another.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * `from` - The string to replace\n+    /// * `to` - The replacement string\n+    ///\n+    /// # Return value\n+    ///\n+    /// The original string with all occurrences of `from` replaced with `to`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"Do you know the muffin man,\n+    /// The muffin man, the muffin man, ...\".to_owned();\n+    ///\n+    /// assert_eq!(s.replace(\"muffin man\", \"little lamb\"),\n+    ///            \"Do you know the little lamb,\n+    /// The little lamb, the little lamb, ...\".to_owned());\n+    ///\n+    /// // not found, so no change.\n+    /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n+    /// ```\n     fn replace(&self, from: &str, to: &str) -> ~str {\n+        let me = self.as_slice();\n         let mut result = StrBuf::new();\n         let mut last_end = 0;\n-        for (start, end) in self.match_indices(from) {\n-            result.push_str(unsafe{raw::slice_bytes(*self, last_end, start)});\n+        for (start, end) in me.match_indices(from) {\n+            result.push_str(unsafe{raw::slice_bytes(me, last_end, start)});\n             result.push_str(to);\n             last_end = end;\n         }\n-        result.push_str(unsafe{raw::slice_bytes(*self, last_end, self.len())});\n+        result.push_str(unsafe{raw::slice_bytes(me, last_end, me.len())});\n         result.into_owned()\n     }\n \n+    /// Copy a slice into a new owned str.\n     #[inline]\n     fn to_owned(&self) -> ~str {\n-        let len = self.len();\n+        let me = self.as_slice();\n+        let len = me.len();\n         unsafe {\n             let mut v = Vec::with_capacity(len);\n \n-            ptr::copy_memory(v.as_mut_ptr(), self.as_ptr(), len);\n+            ptr::copy_memory(v.as_mut_ptr(), me.as_ptr(), len);\n             v.set_len(len);\n             ::cast::transmute(v.move_iter().collect::<~[u8]>())\n         }\n     }\n \n+    /// Converts to a vector of `u16` encoded as UTF-16.\n     fn to_utf16(&self) -> ~[u16] {\n+        let me = self.as_slice();\n         let mut u = Vec::new();;\n-        for ch in self.chars() {\n+        for ch in me.chars() {\n             let mut buf = [0u16, ..2];\n             let n = ch.encode_utf16(buf /* as mut slice! */);\n             u.push_all(buf.slice_to(n));\n         }\n         u.move_iter().collect()\n     }\n \n-    #[inline]\n-    fn is_char_boundary(&self, index: uint) -> bool {\n-        if index == self.len() { return true; }\n-        let b = self[index];\n-        return b < 128u8 || b >= 192u8;\n-    }\n-\n-    #[inline]\n-    fn char_range_at(&self, i: uint) -> CharRange {\n-        if self[i] < 128u8 {\n-            return CharRange {ch: self[i] as char, next: i + 1 };\n-        }\n-\n-        // Multibyte case is a fn to allow char_range_at to inline cleanly\n-        fn multibyte_char_range_at(s: &str, i: uint) -> CharRange {\n-            let mut val = s[i] as u32;\n-            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n-            assert!((w != 0));\n-\n-            val = utf8_first_byte!(val, w);\n-            val = utf8_acc_cont_byte!(val, s[i + 1]);\n-            if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n-            if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n-\n-            return CharRange {ch: unsafe { transmute(val) }, next: i + w};\n-        }\n-\n-        return multibyte_char_range_at(*self, i);\n-    }\n-\n-    #[inline]\n-    fn char_range_at_reverse(&self, start: uint) -> CharRange {\n-        let mut prev = start;\n-\n-        prev = prev.saturating_sub(1);\n-        if self[prev] < 128 { return CharRange{ch: self[prev] as char, next: prev} }\n-\n-        // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n-        fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {\n-            // while there is a previous byte == 10......\n-            while i > 0 && s[i] & 192u8 == TAG_CONT_U8 {\n-                i -= 1u;\n-            }\n-\n-            let mut val = s[i] as u32;\n-            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n-            assert!((w != 0));\n-\n-            val = utf8_first_byte!(val, w);\n-            val = utf8_acc_cont_byte!(val, s[i + 1]);\n-            if w > 2 { val = utf8_acc_cont_byte!(val, s[i + 2]); }\n-            if w > 3 { val = utf8_acc_cont_byte!(val, s[i + 3]); }\n-\n-            return CharRange {ch: unsafe { transmute(val) }, next: i};\n-        }\n-\n-        return multibyte_char_range_at_reverse(*self, prev);\n-    }\n-\n-    #[inline]\n-    fn char_at(&self, i: uint) -> char {\n-        self.char_range_at(i).ch\n-    }\n-\n-    #[inline]\n-    fn char_at_reverse(&self, i: uint) -> char {\n-        self.char_range_at_reverse(i).ch\n-    }\n-\n-    #[inline]\n-    fn as_bytes(&self) -> &'a [u8] {\n-        unsafe { cast::transmute(*self) }\n-    }\n-\n-    fn find<C: CharEq>(&self, mut search: C) -> Option<uint> {\n-        if search.only_ascii() {\n-            self.bytes().position(|b| search.matches(b as char))\n-        } else {\n-            for (index, c) in self.char_indices() {\n-                if search.matches(c) { return Some(index); }\n-            }\n-            None\n-        }\n-    }\n-\n-    fn rfind<C: CharEq>(&self, mut search: C) -> Option<uint> {\n-        if search.only_ascii() {\n-            self.bytes().rposition(|b| search.matches(b as char))\n-        } else {\n-            for (index, c) in self.char_indices().rev() {\n-                if search.matches(c) { return Some(index); }\n-            }\n-            None\n-        }\n-    }\n-\n-    fn find_str(&self, needle: &str) -> Option<uint> {\n-        if needle.is_empty() {\n-            Some(0)\n-        } else {\n-            self.match_indices(needle)\n-                .next()\n-                .map(|(start, _end)| start)\n-        }\n-    }\n-\n+    /// Given a string, make a new string with repeated copies of it.\n     fn repeat(&self, nn: uint) -> ~str {\n-        let mut ret = StrBuf::with_capacity(nn * self.len());\n+        let me = self.as_slice();\n+        let mut ret = StrBuf::with_capacity(nn * me.len());\n         for _ in range(0, nn) {\n-            ret.push_str(*self);\n+            ret.push_str(me);\n         }\n         ret.into_owned()\n     }\n \n-    #[inline]\n-    fn slice_shift_char(&self) -> (Option<char>, &'a str) {\n-        if self.is_empty() {\n-            return (None, *self);\n-        } else {\n-            let CharRange {ch, next} = self.char_range_at(0u);\n-            let next_s = unsafe { raw::slice_bytes(*self, next, self.len()) };\n-            return (Some(ch), next_s);\n-        }\n-    }\n-\n+    /// Levenshtein Distance between two strings.\n     fn lev_distance(&self, t: &str) -> uint {\n-        let slen = self.len();\n+        let me = self.as_slice();\n+        let slen = me.len();\n         let tlen = t.len();\n \n         if slen == 0 { return tlen; }\n         if tlen == 0 { return slen; }\n \n         let mut dcol = Vec::from_fn(tlen + 1, |x| x);\n \n-        for (i, sc) in self.chars().enumerate() {\n+        for (i, sc) in me.chars().enumerate() {\n \n             let mut current = i;\n             *dcol.get_mut(0) = current + 1;\n@@ -2723,23 +892,41 @@ impl<'a> StrSlice<'a> for &'a str {\n         return *dcol.get(tlen);\n     }\n \n-    fn subslice_offset(&self, inner: &str) -> uint {\n-        let a_start = self.as_ptr() as uint;\n-        let a_end = a_start + self.len();\n-        let b_start = inner.as_ptr() as uint;\n-        let b_end = b_start + inner.len();\n-\n-        assert!(a_start <= b_start);\n-        assert!(b_end <= a_end);\n-        b_start - a_start\n+    /// An Iterator over the string in Unicode Normalization Form D\n+    /// (canonical decomposition).\n+    #[inline]\n+    fn nfd_chars<'a>(&'a self) -> Normalizations<'a> {\n+        Normalizations {\n+            iter: self.as_slice().chars(),\n+            buffer: Vec::new(),\n+            sorted: false,\n+            kind: NFD\n+        }\n     }\n \n+    /// An Iterator over the string in Unicode Normalization Form KD\n+    /// (compatibility decomposition).\n     #[inline]\n-    fn as_ptr(&self) -> *u8 {\n-        self.repr().data\n+    fn nfkd_chars<'a>(&'a self) -> Normalizations<'a> {\n+        Normalizations {\n+            iter: self.as_slice().chars(),\n+            buffer: Vec::new(),\n+            sorted: false,\n+            kind: NFKD\n+        }\n     }\n }\n \n+impl<'a> StrAllocating for &'a str {\n+    #[inline]\n+    fn into_owned(self) -> ~str { self.to_owned() }\n+}\n+\n+impl<'a> StrAllocating for ~str {\n+    #[inline]\n+    fn into_owned(self) -> ~str { self }\n+}\n+\n /// Methods for owned strings\n pub trait OwnedStr {\n     /// Consumes the string, returning the underlying byte buffer.\n@@ -2765,32 +952,6 @@ impl OwnedStr for ~str {\n     }\n }\n \n-impl Clone for ~str {\n-    #[inline]\n-    fn clone(&self) -> ~str {\n-        self.to_owned()\n-    }\n-}\n-\n-impl FromIterator<char> for ~str {\n-    #[inline]\n-    fn from_iter<T: Iterator<char>>(iterator: T) -> ~str {\n-        let (lower, _) = iterator.size_hint();\n-        let mut buf = StrBuf::with_capacity(lower);\n-        buf.extend(iterator);\n-        buf.into_owned()\n-    }\n-}\n-\n-// This works because every lifetime is a sub-lifetime of 'static\n-impl<'a> Default for &'a str {\n-    fn default() -> &'a str { \"\" }\n-}\n-\n-impl Default for ~str {\n-    fn default() -> ~str { \"\".to_owned() }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use iter::AdditiveIterator;"}, {"sha": "ad703b8054b0bcf6e1c25201527e41ed2d41ab6b", "filename": "src/libstd/strbuf.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fstrbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fstrbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstrbuf.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -20,8 +20,8 @@ use iter::{Extendable, FromIterator, Iterator, range};\n use option::{None, Option, Some};\n use ptr::RawPtr;\n use slice::{OwnedVector, Vector};\n+use str::{OwnedStr, Str, StrSlice, StrAllocating};\n use str;\n-use str::{OwnedStr, Str, StrSlice};\n use vec::Vec;\n \n /// A growable string stored as a UTF-8 encoded buffer.\n@@ -268,7 +268,9 @@ impl Str for StrBuf {\n             cast::transmute(self.vec.as_slice())\n         }\n     }\n+}\n \n+impl StrAllocating for StrBuf {\n     #[inline]\n     fn into_owned(self) -> ~str {\n         let StrBuf {"}, {"sha": "2df5031b4826cbabb066c8f6169330a149f66f2d", "filename": "src/libstd/sync/mpmc_bounded_queue.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -162,7 +162,6 @@ impl<T: Send> Clone for Queue<T> {\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n-    use option::*;\n     use super::Queue;\n     use native;\n "}, {"sha": "2f7b31ae31d9858796741193462783b6897b8bb4", "filename": "src/libstd/task.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -49,7 +49,8 @@ use str::{Str, SendStr, IntoMaybeOwned};\n \n #[cfg(test)] use any::{AnyOwnExt, AnyRefExt};\n #[cfg(test)] use result;\n-#[cfg(test)] use str::StrSlice;\n+#[cfg(test)] use str::StrAllocating;\n+#[cfg(test)] use realstd::result::ResultUnwrap;\n \n /// Indicates the manner in which a task exited.\n ///"}, {"sha": "4132c8a5b5a3332c80d3ace6a07d834b7f8e0b96", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -35,7 +35,7 @@ impl<T: fmt::Show> ToStr for T {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use str::StrSlice;\n+    use str::StrAllocating;\n \n     #[test]\n     fn test_simple_types() {"}, {"sha": "be6e5d040a7c9e80b56da8128e08de6ca82a1cf0", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 1, "deletions": 4991, "changes": 4992, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=87115fd001440652291c509a77bda74fa511dab0"}, {"sha": "8b07850263fe85111e0dc224a9ddfce48d80d84e", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -10,12 +10,13 @@\n \n #![doc(hidden)]\n \n-use prelude::*;\n use libc::uintptr_t;\n+use kinds::Send;\n+\n+pub use core::finally;\n \n pub mod dynamic_lib;\n \n-pub mod finally;\n pub mod simd;\n pub mod sync;\n pub mod mutex;"}, {"sha": "af146b96e505a1c3128baed38c241ec21b7c6435", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -23,13 +23,14 @@ use mem;\n use num;\n use num::{CheckedMul, CheckedAdd};\n use ops::Drop;\n-use option::{None, Option, Some};\n+use option::{None, Option, Some, Expect};\n use ptr::RawPtr;\n use ptr;\n use rt::global_heap::{malloc_raw, realloc_raw};\n use raw::Slice;\n use slice::{ImmutableEqVector, ImmutableVector, Items, MutItems, MutableVector};\n use slice::{MutableTotalOrdVector, OwnedVector, Vector};\n+use slice::{MutableVectorAllocating};\n \n /// An owned, growable vector.\n ///"}, {"sha": "d705da7b72b6301ce9db1a0fe44e2e8ead484652", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -109,11 +109,6 @@ impl Str for RcStr {\n         let s: &'a str = *self.string;\n         s\n     }\n-\n-    #[inline]\n-    fn into_owned(self) -> ~str {\n-        self.string.to_owned()\n-    }\n }\n \n impl fmt::Show for RcStr {"}, {"sha": "3dbbf47d56bd4661adf173302936a83a2f7c89ee", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -1,3 +1,11 @@\n+S 2014-05-06 24f6f26\n+  freebsd-x86_64 cebcfcece5676c9aea30241bf13c517ffdb37b7c\n+  linux-i386 e9960c7c793ff7ae87c9d30c88cfedf7e40345f7\n+  linux-x86_64 120f63393bf9071b1424dc5e6e55eb3db4fa7c8d\n+  macos-i386 1973f342f19d346a7ae1e2e6079e8335edbcebe3\n+  macos-x86_64 7b3dc30a2c28b546751593d5e34301fb314258c0\n+  winnt-i386 1c7898079cece7d5fbc98566f6826d270a3111f5\n+\n S 2014-05-04 922c420\n   freebsd-x86_64 635f28dd48340db0c1cdc01adad18866acfc7020\n   linux-i386 360a40acf713e6f2d7fcde0112ae87d8336f320c"}, {"sha": "ac6e35d0b26ea1d7e0eadba2a1f9c1829a7be4cc", "filename": "src/test/compile-fail/drop-on-non-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdrop-on-non-struct.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -13,7 +13,7 @@\n \n type Foo = Vec<u8>;\n \n-impl Drop for Foo {   //~ ERROR conflicting implementations\n+impl Drop for Foo {\n //~^ ERROR cannot provide an extension implementation\n //~^^ ERROR multiple applicable methods\n     fn drop(&mut self) {"}, {"sha": "c5e7fc82cc9949aebd61a2ae0786a46c540f37b4", "filename": "src/test/compile-fail/fully-qualified-type-name1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name1.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -13,5 +13,5 @@\n fn main() {\n     let x: Option<uint>;\n     x = 5;\n-    //~^ ERROR mismatched types: expected `std::option::Option<uint>`\n+    //~^ ERROR mismatched types: expected `core::option::Option<uint>`\n }"}, {"sha": "768ae6353d225c1e520c27ba7f2581d9d0c3926a", "filename": "src/test/compile-fail/fully-qualified-type-name4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffully-qualified-type-name4.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -14,7 +14,7 @@ use std::option::Option;\n \n fn bar(x: uint) -> Option<uint> {\n     return x;\n-    //~^ ERROR mismatched types: expected `std::option::Option<uint>`\n+    //~^ ERROR mismatched types: expected `core::option::Option<uint>`\n }\n \n fn main() {"}, {"sha": "44a52148e5b9ee1f0bc22d23218f351ac1172718", "filename": "src/test/compile-fail/issue-13466.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Ftest%2Fcompile-fail%2Fissue-13466.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Ftest%2Fcompile-fail%2Fissue-13466.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13466.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -16,7 +16,7 @@ pub fn main() {\n     // tricked into looking up a non-existing second type parameter.\n     let _x: uint = match Some(1u) {\n     //~^ ERROR mismatched types: expected `uint` but found `<generic #0>`\n-        Ok(u) => u, //~ ERROR  mismatched types: expected `std::option::Option<uint>`\n-        Err(e) => fail!(e)  //~ ERROR mismatched types: expected `std::option::Option<uint>`\n+        Ok(u) => u, //~ ERROR  mismatched types: expected `core::option::Option<uint>`\n+        Err(e) => fail!(e)  //~ ERROR mismatched types: expected `core::option::Option<uint>`\n     };\n }"}, {"sha": "02c619f5f36cc2df6251ec241de24c2b0541ab1a", "filename": "src/test/compile-fail/issue-3680.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Ftest%2Fcompile-fail%2Fissue-3680.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Ftest%2Fcompile-fail%2Fissue-3680.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3680.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     match None {\n         Err(_) => ()\n-        //~^ ERROR mismatched types: expected `std::option::Option<<generic #1>>`\n-        //         but found `std::result::Result<<generic #2>,<generic #3>>`\n+        //~^ ERROR mismatched types: expected `core::option::Option<<generic #1>>`\n+        //         but found `core::result::Result<<generic #2>,<generic #3>>`\n     }\n }"}, {"sha": "b59011b5880211530cca9654edf9bd3ae7406b3a", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -18,6 +18,6 @@ fn main() {\n     let x: Box<HashMap<~str, ~str>> = box HashMap::new();\n     let x: Box<Map<~str, ~str>> = x;\n     let y: Box<Map<uint, ~str>> = box x;\n-    //~^ ERROR failed to find an implementation of trait std::container::Map<uint,~str>\n-    //         for ~std::container::Map<~str,~str>:Send\n+    //~^ ERROR failed to find an implementation of trait core::container::Map<uint,~str>\n+    //         for ~core::container::Map<~str,~str>:Send\n }"}, {"sha": "508fec069c13e3d5590d8bb24d1da097e846d015", "filename": "src/test/compile-fail/noexporttypeexe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87115fd001440652291c509a77bda74fa511dab0/src%2Ftest%2Fcompile-fail%2Fnoexporttypeexe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87115fd001440652291c509a77bda74fa511dab0/src%2Ftest%2Fcompile-fail%2Fnoexporttypeexe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoexporttypeexe.rs?ref=87115fd001440652291c509a77bda74fa511dab0", "patch": "@@ -18,5 +18,5 @@ fn main() {\n     // because the def_id associated with the type was\n     // not convertible to a path.\n   let x: int = noexporttypelib::foo();\n-    //~^ ERROR expected `int` but found `std::option::Option<int>`\n+    //~^ ERROR expected `int` but found `core::option::Option<int>`\n }"}]}