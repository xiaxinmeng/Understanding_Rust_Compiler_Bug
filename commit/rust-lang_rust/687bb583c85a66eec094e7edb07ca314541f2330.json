{"sha": "687bb583c85a66eec094e7edb07ca314541f2330", "node_id": "C_kwDOAAsO6NoAKDY4N2JiNTgzYzg1YTY2ZWVjMDk0ZTdlZGIwN2NhMzE0NTQxZjIzMzA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-25T04:51:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-25T04:51:09Z"}, "message": "Rollup merge of #88794 - sunfishcode:sunfishcode/try-clone, r=joshtriplett\n\nAdd a `try_clone()` function to `OwnedFd`.\n\nAs suggested in #88564. This adds a `try_clone()` to `OwnedFd` by\nrefactoring the code out of the existing `File`/`Socket` code.\n\nr? ``@joshtriplett``", "tree": {"sha": "a4db86466ef74e2157b8dbf77e4b6bf91448a2be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4db86466ef74e2157b8dbf77e4b6bf91448a2be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/687bb583c85a66eec094e7edb07ca314541f2330", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh74G9CRBK7hj4Ov3rIwAALToIACiLT/ztTTC3TbqY0JkQ1cFU\n969HWhDv9BhpHrifbLR6Mbe5Kw0UDb+Ebs36ksNqVKzf74pPAmZfCFNGGgPwMsUq\nDsCHHJMCxyYlNsuu6RrGzPYODR+AtPMwdBTbgEjrjJgfEmebXmUTttmHez/eBFFA\n5hpgSKuJE+GGVpi4FIjOSw0+h4KShEEwu7IXGo5i+a/1I8kNR5SqgBgbsan/uoyl\ncKmwT57JCWNkW5zpuk3MDEl4cYf10F6DGkBLnE7QMf7xntbp9Qzq3ghRzpiONODk\nA6E6l0qFNXtc57KQHPqGz/zWYGZVaUu/y3XHxpcamNAdLms5EHBkujm4COP6leA=\n=VIvw\n-----END PGP SIGNATURE-----\n", "payload": "tree a4db86466ef74e2157b8dbf77e4b6bf91448a2be\nparent e7825f2b690c9a0d21b6f6d84c404bb53b151b38\nparent 83aebf8f7bb6d766f6b68accdc44acb9cea3d57e\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1643086269 +0100\ncommitter GitHub <noreply@github.com> 1643086269 +0100\n\nRollup merge of #88794 - sunfishcode:sunfishcode/try-clone, r=joshtriplett\n\nAdd a `try_clone()` function to `OwnedFd`.\n\nAs suggested in #88564. This adds a `try_clone()` to `OwnedFd` by\nrefactoring the code out of the existing `File`/`Socket` code.\n\nr? ``@joshtriplett``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/687bb583c85a66eec094e7edb07ca314541f2330", "html_url": "https://github.com/rust-lang/rust/commit/687bb583c85a66eec094e7edb07ca314541f2330", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/687bb583c85a66eec094e7edb07ca314541f2330/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7825f2b690c9a0d21b6f6d84c404bb53b151b38", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7825f2b690c9a0d21b6f6d84c404bb53b151b38", "html_url": "https://github.com/rust-lang/rust/commit/e7825f2b690c9a0d21b6f6d84c404bb53b151b38"}, {"sha": "83aebf8f7bb6d766f6b68accdc44acb9cea3d57e", "url": "https://api.github.com/repos/rust-lang/rust/commits/83aebf8f7bb6d766f6b68accdc44acb9cea3d57e", "html_url": "https://github.com/rust-lang/rust/commit/83aebf8f7bb6d766f6b68accdc44acb9cea3d57e"}], "stats": {"total": 242, "additions": 151, "deletions": 91}, "files": [{"sha": "0b6588db92c83102b30fb5fe7a17de01c82a4acf", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/687bb583c85a66eec094e7edb07ca314541f2330/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687bb583c85a66eec094e7edb07ca314541f2330/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=687bb583c85a66eec094e7edb07ca314541f2330", "patch": "@@ -8,6 +8,8 @@ use crate::fmt;\n use crate::fs;\n use crate::marker::PhantomData;\n use crate::mem::forget;\n+#[cfg(not(target_os = \"wasi\"))]\n+use crate::sys::cvt;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n /// A borrowed file descriptor.\n@@ -67,6 +69,37 @@ impl BorrowedFd<'_> {\n     }\n }\n \n+impl OwnedFd {\n+    /// Creates a new `OwnedFd` instance that shares the same underlying file handle\n+    /// as the existing `OwnedFd` instance.\n+    #[cfg(not(target_os = \"wasi\"))]\n+    pub fn try_clone(&self) -> crate::io::Result<Self> {\n+        // We want to atomically duplicate this file descriptor and set the\n+        // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n+        // is a POSIX flag that was added to Linux in 2.6.24.\n+        #[cfg(not(target_os = \"espidf\"))]\n+        let cmd = libc::F_DUPFD_CLOEXEC;\n+\n+        // For ESP-IDF, F_DUPFD is used instead, because the CLOEXEC semantics\n+        // will never be supported, as this is a bare metal framework with\n+        // no capabilities for multi-process execution.  While F_DUPFD is also\n+        // not supported yet, it might be (currently it returns ENOSYS).\n+        #[cfg(target_os = \"espidf\")]\n+        let cmd = libc::F_DUPFD;\n+\n+        let fd = cvt(unsafe { libc::fcntl(self.as_raw_fd(), cmd, 0) })?;\n+        Ok(unsafe { Self::from_raw_fd(fd) })\n+    }\n+\n+    #[cfg(target_os = \"wasi\")]\n+    pub fn try_clone(&self) -> crate::io::Result<Self> {\n+        Err(crate::io::Error::new_const(\n+            crate::io::ErrorKind::Unsupported,\n+            &\"operation not supported on WASI yet\",\n+        ))\n+    }\n+}\n+\n #[unstable(feature = \"io_safety\", issue = \"87074\")]\n impl AsRawFd for BorrowedFd<'_> {\n     #[inline]"}, {"sha": "e37ce633a129a77f231af65ffff172824d358adc", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/687bb583c85a66eec094e7edb07ca314541f2330/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687bb583c85a66eec094e7edb07ca314541f2330/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=687bb583c85a66eec094e7edb07ca314541f2330", "patch": "@@ -6,9 +6,11 @@ use super::raw::{AsRawHandle, FromRawHandle, IntoRawHandle, RawHandle};\n use crate::convert::TryFrom;\n use crate::fmt;\n use crate::fs;\n+use crate::io;\n use crate::marker::PhantomData;\n use crate::mem::forget;\n use crate::sys::c;\n+use crate::sys::cvt;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n /// A borrowed handle.\n@@ -144,6 +146,36 @@ impl TryFrom<HandleOrNull> for OwnedHandle {\n     }\n }\n \n+impl OwnedHandle {\n+    /// Creates a new `OwnedHandle` instance that shares the same underlying file handle\n+    /// as the existing `OwnedHandle` instance.\n+    pub fn try_clone(&self) -> crate::io::Result<Self> {\n+        self.duplicate(0, false, c::DUPLICATE_SAME_ACCESS)\n+    }\n+\n+    pub(crate) fn duplicate(\n+        &self,\n+        access: c::DWORD,\n+        inherit: bool,\n+        options: c::DWORD,\n+    ) -> io::Result<Self> {\n+        let mut ret = 0 as c::HANDLE;\n+        cvt(unsafe {\n+            let cur_proc = c::GetCurrentProcess();\n+            c::DuplicateHandle(\n+                cur_proc,\n+                self.as_raw_handle(),\n+                cur_proc,\n+                &mut ret,\n+                access,\n+                inherit as c::BOOL,\n+                options,\n+            )\n+        })?;\n+        unsafe { Ok(Self::from_raw_handle(ret)) }\n+    }\n+}\n+\n impl TryFrom<HandleOrInvalid> for OwnedHandle {\n     type Error = ();\n "}, {"sha": "26b569bcdd3625f3f1c0ecaa75eb6c183113e6d3", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/687bb583c85a66eec094e7edb07ca314541f2330/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687bb583c85a66eec094e7edb07ca314541f2330/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=687bb583c85a66eec094e7edb07ca314541f2330", "patch": "@@ -4,9 +4,13 @@\n \n use super::raw::{AsRawSocket, FromRawSocket, IntoRawSocket, RawSocket};\n use crate::fmt;\n+use crate::io;\n use crate::marker::PhantomData;\n+use crate::mem;\n use crate::mem::forget;\n+use crate::sys;\n use crate::sys::c;\n+use crate::sys::cvt;\n \n /// A borrowed socket.\n ///\n@@ -69,6 +73,77 @@ impl BorrowedSocket<'_> {\n     }\n }\n \n+impl OwnedSocket {\n+    /// Creates a new `OwnedSocket` instance that shares the same underlying socket\n+    /// as the existing `OwnedSocket` instance.\n+    pub fn try_clone(&self) -> io::Result<Self> {\n+        let mut info = unsafe { mem::zeroed::<c::WSAPROTOCOL_INFO>() };\n+        let result = unsafe {\n+            c::WSADuplicateSocketW(self.as_raw_socket(), c::GetCurrentProcessId(), &mut info)\n+        };\n+        sys::net::cvt(result)?;\n+        let socket = unsafe {\n+            c::WSASocketW(\n+                info.iAddressFamily,\n+                info.iSocketType,\n+                info.iProtocol,\n+                &mut info,\n+                0,\n+                c::WSA_FLAG_OVERLAPPED | c::WSA_FLAG_NO_HANDLE_INHERIT,\n+            )\n+        };\n+\n+        if socket != c::INVALID_SOCKET {\n+            unsafe { Ok(OwnedSocket::from_raw_socket(socket)) }\n+        } else {\n+            let error = unsafe { c::WSAGetLastError() };\n+\n+            if error != c::WSAEPROTOTYPE && error != c::WSAEINVAL {\n+                return Err(io::Error::from_raw_os_error(error));\n+            }\n+\n+            let socket = unsafe {\n+                c::WSASocketW(\n+                    info.iAddressFamily,\n+                    info.iSocketType,\n+                    info.iProtocol,\n+                    &mut info,\n+                    0,\n+                    c::WSA_FLAG_OVERLAPPED,\n+                )\n+            };\n+\n+            if socket == c::INVALID_SOCKET {\n+                return Err(last_error());\n+            }\n+\n+            unsafe {\n+                let socket = OwnedSocket::from_raw_socket(socket);\n+                socket.set_no_inherit()?;\n+                Ok(socket)\n+            }\n+        }\n+    }\n+\n+    #[cfg(not(target_vendor = \"uwp\"))]\n+    pub(crate) fn set_no_inherit(&self) -> io::Result<()> {\n+        cvt(unsafe {\n+            c::SetHandleInformation(self.as_raw_socket() as c::HANDLE, c::HANDLE_FLAG_INHERIT, 0)\n+        })\n+        .map(drop)\n+    }\n+\n+    #[cfg(target_vendor = \"uwp\")]\n+    pub(crate) fn set_no_inherit(&self) -> io::Result<()> {\n+        Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"Unavailable on UWP\"))\n+    }\n+}\n+\n+/// Returns the last error from the Windows socket interface.\n+fn last_error() -> io::Error {\n+    io::Error::from_raw_os_error(unsafe { c::WSAGetLastError() })\n+}\n+\n impl AsRawSocket for BorrowedSocket<'_> {\n     #[inline]\n     fn as_raw_socket(&self) -> RawSocket {"}, {"sha": "3de7c68a6866dbde7bb55aa2f749e621a164f30b", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/687bb583c85a66eec094e7edb07ca314541f2330/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687bb583c85a66eec094e7edb07ca314541f2330/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=687bb583c85a66eec094e7edb07ca314541f2330", "patch": "@@ -259,22 +259,9 @@ impl FileDesc {\n         }\n     }\n \n+    #[inline]\n     pub fn duplicate(&self) -> io::Result<FileDesc> {\n-        // We want to atomically duplicate this file descriptor and set the\n-        // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n-        // is a POSIX flag that was added to Linux in 2.6.24.\n-        #[cfg(not(target_os = \"espidf\"))]\n-        let cmd = libc::F_DUPFD_CLOEXEC;\n-\n-        // For ESP-IDF, F_DUPFD is used instead, because the CLOEXEC semantics\n-        // will never be supported, as this is a bare metal framework with\n-        // no capabilities for multi-process execution.  While F_DUPFD is also\n-        // not supported yet, it might be (currently it returns ENOSYS).\n-        #[cfg(target_os = \"espidf\")]\n-        let cmd = libc::F_DUPFD;\n-\n-        let fd = cvt(unsafe { libc::fcntl(self.as_raw_fd(), cmd, 0) })?;\n-        Ok(unsafe { FileDesc::from_raw_fd(fd) })\n+        Ok(Self(self.0.try_clone()?))\n     }\n }\n "}, {"sha": "028b6b30099dd7a7146b694b5c2ca1cbd32afd6e", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/687bb583c85a66eec094e7edb07ca314541f2330/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687bb583c85a66eec094e7edb07ca314541f2330/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=687bb583c85a66eec094e7edb07ca314541f2330", "patch": "@@ -460,7 +460,7 @@ impl File {\n     }\n \n     pub fn duplicate(&self) -> io::Result<File> {\n-        Ok(File { handle: self.handle.duplicate(0, false, c::DUPLICATE_SAME_ACCESS)? })\n+        Ok(Self { handle: self.handle.try_clone()? })\n     }\n \n     fn reparse_point<'a>("}, {"sha": "daab39bb00cbcd9a0c556d935bbfc66b7b697953", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/687bb583c85a66eec094e7edb07ca314541f2330/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687bb583c85a66eec094e7edb07ca314541f2330/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=687bb583c85a66eec094e7edb07ca314541f2330", "patch": "@@ -262,26 +262,17 @@ impl Handle {\n         Ok(written as usize)\n     }\n \n+    pub fn try_clone(&self) -> io::Result<Self> {\n+        Ok(Self(self.0.try_clone()?))\n+    }\n+\n     pub fn duplicate(\n         &self,\n         access: c::DWORD,\n         inherit: bool,\n         options: c::DWORD,\n-    ) -> io::Result<Handle> {\n-        let mut ret = 0 as c::HANDLE;\n-        cvt(unsafe {\n-            let cur_proc = c::GetCurrentProcess();\n-            c::DuplicateHandle(\n-                cur_proc,\n-                self.as_raw_handle(),\n-                cur_proc,\n-                &mut ret,\n-                access,\n-                inherit as c::BOOL,\n-                options,\n-            )\n-        })?;\n-        unsafe { Ok(Handle::from_raw_handle(ret)) }\n+    ) -> io::Result<Self> {\n+        Ok(Self(self.0.duplicate(access, inherit, options)?))\n     }\n }\n "}, {"sha": "14d5f15d2024822585ad8b3c6cf3e6c4f9d0076a", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 2, "deletions": 60, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/687bb583c85a66eec094e7edb07ca314541f2330/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/687bb583c85a66eec094e7edb07ca314541f2330/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=687bb583c85a66eec094e7edb07ca314541f2330", "patch": "@@ -134,7 +134,7 @@ impl Socket {\n \n             unsafe {\n                 let socket = Self::from_raw_socket(socket);\n-                socket.set_no_inherit()?;\n+                socket.0.set_no_inherit()?;\n                 Ok(socket)\n             }\n         }\n@@ -213,52 +213,7 @@ impl Socket {\n     }\n \n     pub fn duplicate(&self) -> io::Result<Socket> {\n-        let mut info = unsafe { mem::zeroed::<c::WSAPROTOCOL_INFO>() };\n-        let result = unsafe {\n-            c::WSADuplicateSocketW(self.as_raw_socket(), c::GetCurrentProcessId(), &mut info)\n-        };\n-        cvt(result)?;\n-        let socket = unsafe {\n-            c::WSASocketW(\n-                info.iAddressFamily,\n-                info.iSocketType,\n-                info.iProtocol,\n-                &mut info,\n-                0,\n-                c::WSA_FLAG_OVERLAPPED | c::WSA_FLAG_NO_HANDLE_INHERIT,\n-            )\n-        };\n-\n-        if socket != c::INVALID_SOCKET {\n-            unsafe { Ok(Self::from_inner(OwnedSocket::from_raw_socket(socket))) }\n-        } else {\n-            let error = unsafe { c::WSAGetLastError() };\n-\n-            if error != c::WSAEPROTOTYPE && error != c::WSAEINVAL {\n-                return Err(io::Error::from_raw_os_error(error));\n-            }\n-\n-            let socket = unsafe {\n-                c::WSASocketW(\n-                    info.iAddressFamily,\n-                    info.iSocketType,\n-                    info.iProtocol,\n-                    &mut info,\n-                    0,\n-                    c::WSA_FLAG_OVERLAPPED,\n-                )\n-            };\n-\n-            if socket == c::INVALID_SOCKET {\n-                return Err(last_error());\n-            }\n-\n-            unsafe {\n-                let socket = Self::from_inner(OwnedSocket::from_raw_socket(socket));\n-                socket.set_no_inherit()?;\n-                Ok(socket)\n-            }\n-        }\n+        Ok(Self(self.0.try_clone()?))\n     }\n \n     fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n@@ -421,19 +376,6 @@ impl Socket {\n         }\n     }\n \n-    #[cfg(not(target_vendor = \"uwp\"))]\n-    fn set_no_inherit(&self) -> io::Result<()> {\n-        sys::cvt(unsafe {\n-            c::SetHandleInformation(self.as_raw_socket() as c::HANDLE, c::HANDLE_FLAG_INHERIT, 0)\n-        })\n-        .map(drop)\n-    }\n-\n-    #[cfg(target_vendor = \"uwp\")]\n-    fn set_no_inherit(&self) -> io::Result<()> {\n-        Err(io::Error::new_const(io::ErrorKind::Unsupported, &\"Unavailable on UWP\"))\n-    }\n-\n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n         let how = match how {\n             Shutdown::Write => c::SD_SEND,"}]}