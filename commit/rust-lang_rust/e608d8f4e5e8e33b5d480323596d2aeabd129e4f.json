{"sha": "e608d8f4e5e8e33b5d480323596d2aeabd129e4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MDhkOGY0ZTVlOGUzM2I1ZDQ4MDMyMzU5NmQyYWVhYmQxMjllNGY=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-03T01:52:24Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-01-12T20:31:58Z"}, "message": "Make `DefIdForest` cheaper to clone\n\nSince `DefIdForest` contains 0 or 1 elements the large majority of the\ntime, by allocating only in the >1 case we avoid almost all allocations,\ncompared to `Arc<SmallVec<[DefId;1]>>`. This shaves off 0.2% on the\nbenchmark that stresses uninhabitedness checking.", "tree": {"sha": "0c4c0c8a4cf430b5360bdccecbdb103cf2511900", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c4c0c8a4cf430b5360bdccecbdb103cf2511900"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e608d8f4e5e8e33b5d480323596d2aeabd129e4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e608d8f4e5e8e33b5d480323596d2aeabd129e4f", "html_url": "https://github.com/rust-lang/rust/commit/e608d8f4e5e8e33b5d480323596d2aeabd129e4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e608d8f4e5e8e33b5d480323596d2aeabd129e4f/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8598c9f6e53571d449ebf521fca1be4af9af1be6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8598c9f6e53571d449ebf521fca1be4af9af1be6", "html_url": "https://github.com/rust-lang/rust/commit/8598c9f6e53571d449ebf521fca1be4af9af1be6"}], "stats": {"total": 140, "additions": 81, "deletions": 59}, "files": [{"sha": "2f1e0b391561b635ad0916c44049b2fd4045784a", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e608d8f4e5e8e33b5d480323596d2aeabd129e4f/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e608d8f4e5e8e33b5d480323596d2aeabd129e4f/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=e608d8f4e5e8e33b5d480323596d2aeabd129e4f", "patch": "@@ -1314,7 +1314,7 @@ rustc_queries! {\n         /// check whether the forest is empty.\n         query type_uninhabited_from(\n             key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n-        ) -> Arc<ty::inhabitedness::DefIdForest> {\n+        ) -> ty::inhabitedness::DefIdForest {\n             desc { \"computing the inhabitedness of `{:?}`\", key }\n         }\n     }"}, {"sha": "03c8963b0907e7f8585c8e6111426b265431c51a", "filename": "compiler/rustc_middle/src/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 76, "deletions": 51, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/e608d8f4e5e8e33b5d480323596d2aeabd129e4f/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e608d8f4e5e8e33b5d480323596d2aeabd129e4f/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=e608d8f4e5e8e33b5d480323596d2aeabd129e4f", "patch": "@@ -3,6 +3,9 @@ use crate::ty::{DefId, DefIdTree};\n use rustc_hir::CRATE_HIR_ID;\n use smallvec::SmallVec;\n use std::mem;\n+use std::sync::Arc;\n+\n+use DefIdForest::*;\n \n /// Represents a forest of `DefId`s closed under the ancestor relation. That is,\n /// if a `DefId` representing a module is contained in the forest then all\n@@ -11,45 +14,77 @@ use std::mem;\n ///\n /// This is used to represent a set of modules in which a type is visibly\n /// uninhabited.\n+///\n+/// We store the minimal set of `DefId`s required to represent the whole set. If A and B are\n+/// `DefId`s in the `DefIdForest`, and A is a parent of B, then only A will be stored. When this is\n+/// used with `type_uninhabited_from`, there will very rarely be more than one `DefId` stored.\n #[derive(Clone, HashStable)]\n-pub struct DefIdForest {\n-    /// The minimal set of `DefId`s required to represent the whole set.\n-    /// If A and B are DefIds in the `DefIdForest`, and A is a descendant\n-    /// of B, then only B will be in `root_ids`.\n-    /// We use a `SmallVec` here because (for its use for caching inhabitedness)\n-    /// it's rare that this will contain even two IDs.\n-    root_ids: SmallVec<[DefId; 1]>,\n+pub enum DefIdForest {\n+    Empty,\n+    Single(DefId),\n+    /// This variant is very rare.\n+    /// Invariant: >1 elements\n+    /// We use `Arc` because this is used in the output of a query.\n+    Multiple(Arc<[DefId]>),\n+}\n+\n+/// Tests whether a slice of roots contains a given DefId.\n+#[inline]\n+fn slice_contains(tcx: TyCtxt<'tcx>, slice: &[DefId], id: DefId) -> bool {\n+    slice.iter().any(|root_id| tcx.is_descendant_of(id, *root_id))\n }\n \n impl<'tcx> DefIdForest {\n     /// Creates an empty forest.\n     pub fn empty() -> DefIdForest {\n-        DefIdForest { root_ids: SmallVec::new() }\n+        DefIdForest::Empty\n     }\n \n     /// Creates a forest consisting of a single tree representing the entire\n     /// crate.\n     #[inline]\n     pub fn full(tcx: TyCtxt<'tcx>) -> DefIdForest {\n-        let crate_id = tcx.hir().local_def_id(CRATE_HIR_ID);\n-        DefIdForest::from_id(crate_id.to_def_id())\n+        DefIdForest::from_id(tcx.hir().local_def_id(CRATE_HIR_ID).to_def_id())\n     }\n \n     /// Creates a forest containing a `DefId` and all its descendants.\n     pub fn from_id(id: DefId) -> DefIdForest {\n-        let mut root_ids = SmallVec::new();\n-        root_ids.push(id);\n-        DefIdForest { root_ids }\n+        DefIdForest::Single(id)\n+    }\n+\n+    fn as_slice(&self) -> &[DefId] {\n+        match self {\n+            Empty => &[],\n+            Single(id) => std::slice::from_ref(id),\n+            Multiple(root_ids) => root_ids,\n+        }\n+    }\n+\n+    // Only allocates in the rare `Multiple` case.\n+    fn from_slice(root_ids: &[DefId]) -> DefIdForest {\n+        match root_ids {\n+            [] => Empty,\n+            [id] => Single(*id),\n+            _ => DefIdForest::Multiple(root_ids.into()),\n+        }\n     }\n \n     /// Tests whether the forest is empty.\n     pub fn is_empty(&self) -> bool {\n-        self.root_ids.is_empty()\n+        match self {\n+            Empty => true,\n+            Single(..) | Multiple(..) => false,\n+        }\n+    }\n+\n+    /// Iterate over the set of roots.\n+    fn iter(&self) -> impl Iterator<Item = DefId> + '_ {\n+        self.as_slice().iter().copied()\n     }\n \n     /// Tests whether the forest contains a given DefId.\n     pub fn contains(&self, tcx: TyCtxt<'tcx>, id: DefId) -> bool {\n-        self.root_ids.iter().any(|root_id| tcx.is_descendant_of(id, *root_id))\n+        slice_contains(tcx, self.as_slice(), id)\n     }\n \n     /// Calculate the intersection of a collection of forests.\n@@ -58,65 +93,55 @@ impl<'tcx> DefIdForest {\n         I: IntoIterator<Item = DefIdForest>,\n     {\n         let mut iter = iter.into_iter();\n-        let mut ret = if let Some(first) = iter.next() {\n-            first\n+        let mut ret: SmallVec<[_; 1]> = if let Some(first) = iter.next() {\n+            SmallVec::from_slice(first.as_slice())\n         } else {\n             return DefIdForest::full(tcx);\n         };\n \n-        let mut next_ret = SmallVec::new();\n-        let mut old_ret: SmallVec<[DefId; 1]> = SmallVec::new();\n+        let mut next_ret: SmallVec<[_; 1]> = SmallVec::new();\n         for next_forest in iter {\n             // No need to continue if the intersection is already empty.\n-            if ret.is_empty() {\n-                break;\n+            if ret.is_empty() || next_forest.is_empty() {\n+                return DefIdForest::empty();\n             }\n \n-            // `next_ret` and `old_ret` are empty here.\n-            // We keep the elements in `ret` that are also in `next_forest`. Those that aren't are\n-            // put back in `ret` via `old_ret`.\n-            for id in ret.root_ids.drain(..) {\n-                if next_forest.contains(tcx, id) {\n-                    next_ret.push(id);\n-                } else {\n-                    old_ret.push(id);\n-                }\n-            }\n-            ret.root_ids.extend(old_ret.drain(..));\n-\n+            // We keep the elements in `ret` that are also in `next_forest`.\n+            next_ret.extend(ret.iter().copied().filter(|&id| next_forest.contains(tcx, id)));\n             // We keep the elements in `next_forest` that are also in `ret`.\n-            // You'd think this is not needed because `next_ret` already contains `ret \\inter\n-            // next_forest`. But those aren't just sets of things. If `ret = [a]`, `next_forest =\n-            // [b]` and `b` is a submodule of `a`, then `b` belongs in the intersection but we\n-            // didn't catch it in the loop above.\n-            next_ret.extend(next_forest.root_ids.into_iter().filter(|&id| ret.contains(tcx, id)));\n-            // `next_ret` now contains the intersection of the original `ret` and `next_forest`.\n-\n-            mem::swap(&mut next_ret, &mut ret.root_ids);\n-            next_ret.drain(..);\n+            next_ret.extend(next_forest.iter().filter(|&id| slice_contains(tcx, &ret, id)));\n+\n+            mem::swap(&mut next_ret, &mut ret);\n+            next_ret.clear();\n         }\n-        ret\n+        DefIdForest::from_slice(&ret)\n     }\n \n     /// Calculate the union of a collection of forests.\n     pub fn union<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest\n     where\n         I: IntoIterator<Item = DefIdForest>,\n     {\n-        let mut ret = DefIdForest::empty();\n-        let mut next_ret = SmallVec::new();\n+        let mut ret: SmallVec<[_; 1]> = SmallVec::new();\n+        let mut next_ret: SmallVec<[_; 1]> = SmallVec::new();\n         for next_forest in iter {\n-            next_ret.extend(ret.root_ids.drain(..).filter(|&id| !next_forest.contains(tcx, id)));\n+            // Union with the empty set is a no-op.\n+            if next_forest.is_empty() {\n+                continue;\n+            }\n \n-            for id in next_forest.root_ids {\n-                if !next_ret.contains(&id) {\n+            // We add everything in `ret` that is not in `next_forest`.\n+            next_ret.extend(ret.iter().copied().filter(|&id| !next_forest.contains(tcx, id)));\n+            // We add everything in `next_forest` that we haven't added yet.\n+            for id in next_forest.iter() {\n+                if !slice_contains(tcx, &next_ret, id) {\n                     next_ret.push(id);\n                 }\n             }\n \n-            mem::swap(&mut next_ret, &mut ret.root_ids);\n-            next_ret.drain(..);\n+            mem::swap(&mut next_ret, &mut ret);\n+            next_ret.clear();\n         }\n-        ret\n+        DefIdForest::from_slice(&ret)\n     }\n }"}, {"sha": "119cb135046dbf84e6a0cb8bb4da1880f995c571", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e608d8f4e5e8e33b5d480323596d2aeabd129e4f/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e608d8f4e5e8e33b5d480323596d2aeabd129e4f/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=e608d8f4e5e8e33b5d480323596d2aeabd129e4f", "patch": "@@ -7,8 +7,6 @@ use crate::ty::{AdtDef, FieldDef, Ty, TyS, VariantDef};\n use crate::ty::{AdtKind, Visibility};\n use crate::ty::{DefId, SubstsRef};\n \n-use std::sync::Arc;\n-\n mod def_id_forest;\n \n // The methods in this module calculate `DefIdForest`s of modules in which a\n@@ -193,18 +191,18 @@ impl<'tcx> TyS<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> DefIdForest {\n-        tcx.type_uninhabited_from(param_env.and(self)).as_ref().clone()\n+        tcx.type_uninhabited_from(param_env.and(self))\n     }\n }\n \n // Query provider for `type_uninhabited_from`.\n pub(crate) fn type_uninhabited_from<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-) -> Arc<DefIdForest> {\n+) -> DefIdForest {\n     let ty = key.value;\n     let param_env = key.param_env;\n-    let forest = match *ty.kind() {\n+    match *ty.kind() {\n         Adt(def, substs) => def.uninhabited_from(tcx, substs, param_env),\n \n         Never => DefIdForest::full(tcx),\n@@ -229,6 +227,5 @@ pub(crate) fn type_uninhabited_from<'tcx>(\n         Ref(..) => DefIdForest::empty(),\n \n         _ => DefIdForest::empty(),\n-    };\n-    Arc::new(forest)\n+    }\n }"}]}