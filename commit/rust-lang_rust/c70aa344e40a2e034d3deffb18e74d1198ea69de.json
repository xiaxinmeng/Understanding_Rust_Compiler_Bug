{"sha": "c70aa344e40a2e034d3deffb18e74d1198ea69de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MGFhMzQ0ZTQwYTJlMDM0ZDNkZWZmYjE4ZTc0ZDExOThlYTY5ZGU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-25T10:17:06Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-25T10:42:25Z"}, "message": "borrowck: prefer \"value\" over \"`_`\".", "tree": {"sha": "d531b86f7aa5f8bc504c7235a1801efc826fdfba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d531b86f7aa5f8bc504c7235a1801efc826fdfba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c70aa344e40a2e034d3deffb18e74d1198ea69de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c70aa344e40a2e034d3deffb18e74d1198ea69de", "html_url": "https://github.com/rust-lang/rust/commit/c70aa344e40a2e034d3deffb18e74d1198ea69de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c70aa344e40a2e034d3deffb18e74d1198ea69de/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02046a5d402c789c006d0da7662f800fe3c45faf", "url": "https://api.github.com/repos/rust-lang/rust/commits/02046a5d402c789c006d0da7662f800fe3c45faf", "html_url": "https://github.com/rust-lang/rust/commit/02046a5d402c789c006d0da7662f800fe3c45faf"}], "stats": {"total": 247, "additions": 113, "deletions": 134}, "files": [{"sha": "3848dd2ee3b4b1a4f17f81bbb8a5e97171352a7d", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 31, "deletions": 58, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=c70aa344e40a2e034d3deffb18e74d1198ea69de", "patch": "@@ -256,25 +256,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             \"report_move_out_while_borrowed: location={:?} place={:?} span={:?} borrow={:?}\",\n             location, place, span, borrow\n         );\n-        let value_msg = match self.describe_place(place.as_ref()) {\n-            Some(name) => format!(\"`{}`\", name),\n-            None => \"value\".to_owned(),\n-        };\n-        let borrow_msg = match self.describe_place(borrow.borrowed_place.as_ref()) {\n-            Some(name) => format!(\"`{}`\", name),\n-            None => \"value\".to_owned(),\n-        };\n+        let value_msg = self.describe_place_str(place.as_ref());\n+        let borrow_msg = self.describe_place_str(borrow.borrowed_place.as_ref());\n \n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.args_or_use();\n \n         let move_spans = self.move_spans(place.as_ref(), location);\n         let span = move_spans.args_or_use();\n \n-        let mut err = self.cannot_move_when_borrowed(\n-            span,\n-            &self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n-        );\n+        let mut err =\n+            self.cannot_move_when_borrowed(span, &self.describe_place_str(place.as_ref()));\n         err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_msg));\n         err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n \n@@ -314,16 +306,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         let mut err = self.cannot_use_when_mutably_borrowed(\n             span,\n-            &self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n+            &self.describe_place_str(place.as_ref()),\n             borrow_span,\n-            &self.describe_place(borrow.borrowed_place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n+            &self.describe_place_str(borrow.borrowed_place.as_ref()),\n         );\n \n         borrow_spans.var_span_label(&mut err, {\n             let place = &borrow.borrowed_place;\n-            let desc_place = self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned());\n-\n-            format!(\"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe())\n+            let desc_place = self.describe_place_str(place.as_ref());\n+            format!(\"borrow occurs due to use of {}{}\", desc_place, borrow_spans.describe())\n         });\n \n         self.explain_why_borrow_contains_point(location, borrow, None)\n@@ -433,7 +424,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     borrow_spans.var_span_label(\n                         &mut err,\n                         format!(\n-                            \"borrow occurs due to use of `{}`{}\",\n+                            \"borrow occurs due to use of {}{}\",\n                             desc_place,\n                             borrow_spans.describe(),\n                         ),\n@@ -511,16 +502,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if issued_spans == borrow_spans {\n             borrow_spans.var_span_label(\n                 &mut err,\n-                format!(\"borrows occur due to use of `{}`{}\", desc_place, borrow_spans.describe()),\n+                format!(\"borrows occur due to use of {}{}\", desc_place, borrow_spans.describe()),\n             );\n         } else {\n             let borrow_place = &issued_borrow.borrowed_place;\n-            let borrow_place_desc =\n-                self.describe_place(borrow_place.as_ref()).unwrap_or_else(|| \"_\".to_owned());\n+            let borrow_place_desc = self.describe_place_str(borrow_place.as_ref());\n             issued_spans.var_span_label(\n                 &mut err,\n                 format!(\n-                    \"first borrow occurs due to use of `{}`{}\",\n+                    \"first borrow occurs due to use of {}{}\",\n                     borrow_place_desc,\n                     issued_spans.describe(),\n                 ),\n@@ -529,7 +519,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             borrow_spans.var_span_label(\n                 &mut err,\n                 format!(\n-                    \"second borrow occurs due to use of `{}`{}\",\n+                    \"second borrow occurs due to use of {}{}\",\n                     desc_place,\n                     borrow_spans.describe(),\n                 ),\n@@ -538,7 +528,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         if union_type_name != \"\" {\n             err.note(&format!(\n-                \"`{}` is a field of the union `{}`, so it overlaps the field `{}`\",\n+                \"{} is a field of the union `{}`, so it overlaps the field {}\",\n                 msg_place, union_type_name, msg_borrow,\n             ));\n         }\n@@ -606,7 +596,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let ty = Place::ty_from(place_base, place_projection, *self.body, self.infcx.tcx).ty;\n             ty.ty_adt_def().filter(|adt| adt.is_union()).map(|_| ty)\n         };\n-        let describe_place = |place| self.describe_place(place).unwrap_or_else(|| \"_\".to_owned());\n \n         // Start with an empty tuple, so we can use the functions on `Option` to reduce some\n         // code duplication (particularly around returning an empty description in the failure\n@@ -645,30 +634,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .and_then(|(target_base, target_field)| {\n                 // With the place of a union and a field access into it, we traverse the second\n                 // borrowed place and look for a access to a different field of the same union.\n-                let Place { local, projection } = second_borrowed_place;\n+                let Place { local, ref projection } = *second_borrowed_place;\n \n                 let mut cursor = &projection[..];\n                 while let [proj_base @ .., elem] = cursor {\n                     cursor = proj_base;\n \n                     if let ProjectionElem::Field(field, _) = elem {\n-                        if let Some(union_ty) = union_ty(*local, proj_base) {\n+                        if let Some(union_ty) = union_ty(local, proj_base) {\n                             if field != target_field\n-                                && *local == target_base.local\n+                                && local == target_base.local\n                                 && proj_base == target_base.projection\n                             {\n-                                // FIXME when we avoid clone reuse describe_place closure\n-                                let describe_base_place = self\n-                                    .describe_place(PlaceRef {\n-                                        local: *local,\n-                                        projection: proj_base,\n-                                    })\n-                                    .unwrap_or_else(|| \"_\".to_owned());\n-\n                                 return Some((\n-                                    describe_base_place,\n-                                    describe_place(first_borrowed_place.as_ref()),\n-                                    describe_place(second_borrowed_place.as_ref()),\n+                                    self.describe_place_str(PlaceRef {\n+                                        local,\n+                                        projection: proj_base,\n+                                    }),\n+                                    self.describe_place_str(first_borrowed_place.as_ref()),\n+                                    self.describe_place_str(second_borrowed_place.as_ref()),\n                                     union_ty.to_string(),\n                                 ));\n                             }\n@@ -681,7 +665,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // If we didn't find a field access into a union, or both places match, then\n                 // only return the description of the first place.\n                 (\n-                    describe_place(first_borrowed_place.as_ref()),\n+                    self.describe_place_str(first_borrowed_place.as_ref()),\n                     \"\".to_string(),\n                     \"\".to_string(),\n                     \"\".to_string(),\n@@ -1404,12 +1388,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let loan_spans = self.retrieve_borrow_spans(loan);\n         let loan_span = loan_spans.args_or_use();\n \n+        let descr_place = self.describe_place_str(place.as_ref());\n         if loan.kind == BorrowKind::Shallow {\n             if let Some(section) = self.classify_immutable_section(&loan.assigned_place) {\n                 let mut err = self.cannot_mutate_in_immutable_section(\n                     span,\n                     loan_span,\n-                    &self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n+                    &descr_place,\n                     section,\n                     \"assign\",\n                 );\n@@ -1424,11 +1409,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n         }\n \n-        let mut err = self.cannot_assign_to_borrowed(\n-            span,\n-            loan_span,\n-            &self.describe_place(place.as_ref()).unwrap_or_else(|| \"_\".to_owned()),\n-        );\n+        let mut err = self.cannot_assign_to_borrowed(span, loan_span, &descr_place);\n \n         loan_spans\n             .var_span_label(&mut err, format!(\"borrow occurs due to use{}\", loan_spans.describe()));\n@@ -1482,27 +1463,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             })\n             | Some(LocalDecl { local_info: LocalInfo::StaticRef { .. }, .. })\n             | Some(LocalDecl { local_info: LocalInfo::Other, .. })\n-            | None => (self.describe_place(place.as_ref()), assigned_span),\n-            Some(decl) => (self.describe_place(err_place.as_ref()), decl.source_info.span),\n+            | None => (self.describe_place_str(place.as_ref()), assigned_span),\n+            Some(decl) => (self.describe_place_str(err_place.as_ref()), decl.source_info.span),\n         };\n \n-        let mut err = self.cannot_reassign_immutable(\n-            span,\n-            place_description.as_ref().map(AsRef::as_ref).unwrap_or(\"_\"),\n-            from_arg,\n-        );\n+        let mut err = self.cannot_reassign_immutable(span, &place_description, from_arg);\n         let msg = if from_arg {\n             \"cannot assign to immutable argument\"\n         } else {\n             \"cannot assign twice to immutable variable\"\n         };\n         if span != assigned_span {\n             if !from_arg {\n-                let value_msg = match place_description {\n-                    Some(name) => format!(\"`{}`\", name),\n-                    None => \"value\".to_owned(),\n-                };\n-                err.span_label(assigned_span, format!(\"first assignment to {}\", value_msg));\n+                err.span_label(assigned_span, format!(\"first assignment to {}\", place_description));\n             }\n         }\n         if let Some(decl) = local_decl {"}, {"sha": "e5850d642b538fbeaae48e136e75ec071aee16e6", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=c70aa344e40a2e034d3deffb18e74d1198ea69de", "patch": "@@ -137,8 +137,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    /// End-user visible description of `place` if one can be found. If the\n-    /// place is a temporary for instance, None will be returned.\n+    /// End-user visible description of `place` if one can be found.\n+    /// If the place is a temporary for instance, `value` will be returned.\n+    pub(super) fn describe_place_str(&self, place_ref: PlaceRef<'tcx>) -> String {\n+        match self.describe_place(place_ref) {\n+            Some(descr) => format!(\"`{}`\", descr),\n+            None => \"value\".to_string(),\n+        }\n+    }\n+\n+    /// End-user visible description of `place` if one can be found.\n+    /// If the place is a temporary for instance, None will be returned.\n     pub(super) fn describe_place(&self, place_ref: PlaceRef<'tcx>) -> Option<String> {\n         self.describe_place_with_options(place_ref, IncludingDowncast(false))\n     }"}, {"sha": "6146b3abc9cc54f7d5a810189bc356648d253a71", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=c70aa344e40a2e034d3deffb18e74d1198ea69de", "patch": "@@ -272,14 +272,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         span: Span,\n     ) -> DiagnosticBuilder<'a> {\n         let description = if place.projection.len() == 1 {\n-            format!(\"static item `{}`\", self.describe_place(place.as_ref()).unwrap())\n+            format!(\"static item {}\", self.describe_place_str(place.as_ref()))\n         } else {\n             let base_static = PlaceRef { local: place.local, projection: &[ProjectionElem::Deref] };\n \n             format!(\n-                \"`{:?}` as `{:?}` is a static item\",\n-                self.describe_place(place.as_ref()).unwrap(),\n-                self.describe_place(base_static).unwrap(),\n+                \"{} as {} is a static item\",\n+                self.describe_place_str(place.as_ref()),\n+                self.describe_place_str(base_static),\n             )\n         };\n \n@@ -349,16 +349,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let upvar_name = upvar.name;\n                 let upvar_span = self.infcx.tcx.hir().span(upvar_hir_id);\n \n-                let place_name = self.describe_place(move_place.as_ref()).unwrap();\n+                let place_name = self.describe_place_str(move_place.as_ref());\n \n-                let place_description = if self\n-                    .is_upvar_field_projection(move_place.as_ref())\n-                    .is_some()\n-                {\n-                    format!(\"`{}`, a {}\", place_name, capture_description)\n-                } else {\n-                    format!(\"`{}`, as `{}` is a {}\", place_name, upvar_name, capture_description,)\n-                };\n+                let place_description =\n+                    if self.is_upvar_field_projection(move_place.as_ref()).is_some() {\n+                        format!(\"{}, a {}\", place_name, capture_description)\n+                    } else {\n+                        format!(\"{}, as `{}` is a {}\", place_name, upvar_name, capture_description)\n+                    };\n \n                 debug!(\n                     \"report: closure_kind_ty={:?} closure_kind={:?} place_description={:?}\","}, {"sha": "e6c25c053a265fd97c9dfa47cc866f789b6b098d", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=c70aa344e40a2e034d3deffb18e74d1198ea69de", "patch": "@@ -169,9 +169,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 borrow_spans.var_span_label(\n                     &mut err,\n                     format!(\n-                        \"mutable borrow occurs due to use of `{}` in closure\",\n-                        // always Some() if the message is printed.\n-                        self.describe_place(access_place.as_ref()).unwrap_or_default(),\n+                        \"mutable borrow occurs due to use of {} in closure\",\n+                        self.describe_place_str(access_place.as_ref()),\n                     ),\n                 );\n                 borrow_span"}, {"sha": "b39f998ec29a5e8bb9f711350c827eaddc500083", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=c70aa344e40a2e034d3deffb18e74d1198ea69de", "patch": "@@ -4,7 +4,7 @@ use rustc_span::{MultiSpan, Span};\n \n impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n     crate fn cannot_move_when_borrowed(&self, span: Span, desc: &str) -> DiagnosticBuilder<'cx> {\n-        struct_span_err!(self, span, E0505, \"cannot move out of `{}` because it is borrowed\", desc,)\n+        struct_span_err!(self, span, E0505, \"cannot move out of {} because it is borrowed\", desc,)\n     }\n \n     crate fn cannot_use_when_mutably_borrowed(\n@@ -18,12 +18,12 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n             self,\n             span,\n             E0503,\n-            \"cannot use `{}` because it was mutably borrowed\",\n+            \"cannot use {} because it was mutably borrowed\",\n             desc,\n         );\n \n-        err.span_label(borrow_span, format!(\"borrow of `{}` occurs here\", borrow_desc));\n-        err.span_label(span, format!(\"use of borrowed `{}`\", borrow_desc));\n+        err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_desc));\n+        err.span_label(span, format!(\"use of borrowed {}\", borrow_desc));\n         err\n     }\n \n@@ -53,12 +53,12 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n         old_load_end_span: Option<Span>,\n     ) -> DiagnosticBuilder<'cx> {\n         let via =\n-            |msg: &str| if msg.is_empty() { msg.to_string() } else { format!(\" (via `{}`)\", msg) };\n+            |msg: &str| if msg.is_empty() { msg.to_string() } else { format!(\" (via {})\", msg) };\n         let mut err = struct_span_err!(\n             self,\n             new_loan_span,\n             E0499,\n-            \"cannot borrow `{}`{} as mutable more than once at a time\",\n+            \"cannot borrow {}{} as mutable more than once at a time\",\n             desc,\n             via(opt_via),\n         );\n@@ -103,7 +103,7 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n             self,\n             new_loan_span,\n             E0524,\n-            \"two closures require unique access to `{}` at the same time\",\n+            \"two closures require unique access to {} at the same time\",\n             desc,\n         );\n         if old_loan_span == new_loan_span {\n@@ -136,7 +136,7 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n             self,\n             new_loan_span,\n             E0500,\n-            \"closure requires unique access to `{}` but {} is already borrowed{}\",\n+            \"closure requires unique access to {} but {} is already borrowed{}\",\n             desc_new,\n             noun_old,\n             old_opt_via,\n@@ -168,7 +168,7 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n             self,\n             new_loan_span,\n             E0501,\n-            \"cannot borrow `{}`{} as {} because previous closure \\\n+            \"cannot borrow {}{} as {} because previous closure \\\n              requires unique access\",\n             desc_new,\n             opt_via,\n@@ -201,12 +201,12 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n         old_load_end_span: Option<Span>,\n     ) -> DiagnosticBuilder<'cx> {\n         let via =\n-            |msg: &str| if msg.is_empty() { msg.to_string() } else { format!(\" (via `{}`)\", msg) };\n+            |msg: &str| if msg.is_empty() { msg.to_string() } else { format!(\" (via {})\", msg) };\n         let mut err = struct_span_err!(\n             self,\n             span,\n             E0502,\n-            \"cannot borrow `{}`{} as {} because {} is also borrowed \\\n+            \"cannot borrow {}{} as {} because {} is also borrowed \\\n              as {}{}\",\n             desc_new,\n             via(msg_new),\n@@ -225,7 +225,7 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n             err.span_label(\n                 span,\n                 format!(\n-                    \"{} borrow of `{}` -- which overlaps with `{}` -- occurs here\",\n+                    \"{} borrow of {} -- which overlaps with {} -- occurs here\",\n                     kind_new, msg_new, msg_old,\n                 ),\n             );\n@@ -248,12 +248,12 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n             self,\n             span,\n             E0506,\n-            \"cannot assign to `{}` because it is borrowed\",\n+            \"cannot assign to {} because it is borrowed\",\n             desc,\n         );\n \n-        err.span_label(borrow_span, format!(\"borrow of `{}` occurs here\", desc));\n-        err.span_label(span, format!(\"assignment to borrowed `{}` occurs here\", desc));\n+        err.span_label(borrow_span, format!(\"borrow of {} occurs here\", desc));\n+        err.span_label(span, format!(\"assignment to borrowed {} occurs here\", desc));\n         err\n     }\n \n@@ -264,7 +264,7 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n         is_arg: bool,\n     ) -> DiagnosticBuilder<'cx> {\n         let msg = if is_arg { \"to immutable argument\" } else { \"twice to immutable variable\" };\n-        struct_span_err!(self, span, E0384, \"cannot assign {} `{}`\", msg, desc,)\n+        struct_span_err!(self, span, E0384, \"cannot assign {} {}\", msg, desc)\n     }\n \n     crate fn cannot_assign(&self, span: Span, desc: &str) -> DiagnosticBuilder<'cx> {\n@@ -362,7 +362,7 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n             self,\n             mutate_span,\n             E0510,\n-            \"cannot {} `{}` in {}\",\n+            \"cannot {} {} in {}\",\n             action,\n             immutable_place,\n             immutable_section,"}, {"sha": "f1680e9e8884e93806f361bfd3a9b593111f7c90", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.rs?ref=c70aa344e40a2e034d3deffb18e74d1198ea69de", "patch": "@@ -45,27 +45,27 @@ fn main() {\n     *b = NC;\n     let ref a @ box ref mut b = Box::new(NC);\n     //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n-    //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+    //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     *b = NC;\n     drop(a);\n \n     let ref mut a @ box ref b = Box::new(NC);\n     //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n-    //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n+    //~| ERROR cannot borrow value as immutable because it is also borrowed as mutable\n     *a = Box::new(NC);\n     drop(b);\n \n     fn f5(ref mut a @ box ref b: Box<NC>) {\n         //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n-        //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n+        //~| ERROR cannot borrow value as immutable because it is also borrowed as mutable\n         *a = Box::new(NC);\n         drop(b);\n     }\n \n     match Box::new(nc()) {\n         ref mut a @ box ref b => {\n             //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n-            //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n+            //~| ERROR cannot borrow value as immutable because it is also borrowed as mutable\n             *a = Box::new(NC);\n             drop(b);\n         }"}, {"sha": "5ce546f08bf6f41e21ea5cb70a74c88205280f88", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr?ref=c70aa344e40a2e034d3deffb18e74d1198ea69de", "patch": "@@ -99,7 +99,7 @@ LL |         a @ box b => {}\n    |         |       value used here after move\n    |         value moved here\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-at-and-box.rs:46:21\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n@@ -111,7 +111,7 @@ LL |     let ref a @ box ref mut b = Box::new(NC);\n LL |     drop(a);\n    |          - immutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-at-and-box.rs:52:25\n    |\n LL |     let ref mut a @ box ref b = Box::new(NC);\n@@ -123,7 +123,7 @@ LL |     let ref mut a @ box ref b = Box::new(NC);\n LL |     *a = Box::new(NC);\n    |     -- mutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-at-and-box.rs:66:25\n    |\n LL |         ref mut a @ box ref b => {\n@@ -155,7 +155,7 @@ LL |     fn f2(a @ box b: Box<C>) {}\n    |           value moved here\n    |           move occurs because value has type `std::boxed::Box<C>`, which does not implement the `Copy` trait\n \n-error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-at-and-box.rs:58:27\n    |\n LL |     fn f5(ref mut a @ box ref b: Box<NC>) {"}, {"sha": "2b5e339c6396e36074e3d4f361baa17b63ada02f", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-and-ref.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.rs?ref=c70aa344e40a2e034d3deffb18e74d1198ea69de", "patch": "@@ -10,7 +10,7 @@ fn main() {\n     match &mut Some(1) {\n         ref mut z @ &mut Some(ref a) => {\n         //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n-        //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n+        //~| ERROR cannot borrow value as immutable because it is also borrowed as mutable\n             **z = None;\n             println!(\"{}\", *a);\n         }\n@@ -47,12 +47,12 @@ fn main() {\n \n     let ref mut a @ ref b = u();\n     //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable\n-    //~| ERROR cannot borrow `_` as immutable because it is also borrowed as mutable\n+    //~| ERROR cannot borrow value as immutable because it is also borrowed as mutable\n     *a = u();\n     drop(b);\n     let ref a @ ref mut b = u();\n     //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n-    //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+    //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     *b = u();\n     drop(a);\n \n@@ -78,8 +78,8 @@ fn main() {\n         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n             //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n             //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n-            //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n-            //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+            //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n+            //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n             *b = U;\n             drop(a);\n         }\n@@ -123,15 +123,15 @@ fn main() {\n \n     let ref a @ (ref mut b, ref mut c) = (U, U);\n     //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n-    //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n-    //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+    //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n+    //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     *b = U;\n     drop(a);\n \n     let ref a @ (ref mut b, ref mut c) = (U, U);\n     //~^ ERROR cannot borrow value as mutable because it is also borrowed as immutable\n-    *b = U; //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n-    *c = U; //~| ERROR cannot borrow `_` as mutable because it is also borrowed as immutable\n+    *b = U; //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n+    *c = U; //~| ERROR cannot borrow value as mutable because it is also borrowed as immutable\n     drop(a);\n     let ref mut a @ (ref b, ref c) = (U, U);\n     //~^ ERROR cannot borrow value as immutable because it is also borrowed as mutable"}, {"sha": "b161054414a303ca660036dc32dc12b1a50f92eb", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-and-ref.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr?ref=c70aa344e40a2e034d3deffb18e74d1198ea69de", "patch": "@@ -294,7 +294,7 @@ LL |     fn f4_also_moved(ref a @ ref mut b @ c: U) {}\n    |                              |           value moved into `c` here\n    |                              value borrowed, by `b`, here\n \n-error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:11:31\n    |\n LL |         ref mut z @ &mut Some(ref a) => {\n@@ -306,7 +306,7 @@ LL |         ref mut z @ &mut Some(ref a) => {\n LL |             **z = None;\n    |             ---------- mutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as immutable because it is also borrowed as mutable\n+error[E0502]: cannot borrow value as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:48:21\n    |\n LL |     let ref mut a @ ref b = u();\n@@ -318,7 +318,7 @@ LL |     let ref mut a @ ref b = u();\n LL |     *a = u();\n    |     -------- mutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:53:17\n    |\n LL |     let ref a @ ref mut b = u();\n@@ -330,7 +330,7 @@ LL |     let ref a @ ref mut b = u();\n LL |     drop(a);\n    |          - immutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:78:20\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n@@ -342,7 +342,7 @@ LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n LL |             drop(a);\n    |                  - immutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:78:45\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n@@ -402,7 +402,7 @@ LL |         ref mut a @ Ok(ref b) | ref mut a @ Err(ref b) if { drop(a); false\n    |\n    = note: variables bound in patterns cannot be moved from until after the end of the pattern guard\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:124:18\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n@@ -414,7 +414,7 @@ LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n LL |     drop(a);\n    |          - immutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:124:29\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n@@ -426,7 +426,7 @@ LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n LL |     drop(a);\n    |          - immutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:131:18\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n@@ -438,7 +438,7 @@ LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n LL |     drop(a);\n    |          - immutable borrow later used here\n \n-error[E0502]: cannot borrow `_` as mutable because it is also borrowed as immutable\n+error[E0502]: cannot borrow value as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:131:29\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);"}, {"sha": "a208d0087ff53d7ff9e458f7223083990dca4307", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-twice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.rs?ref=c70aa344e40a2e034d3deffb18e74d1198ea69de", "patch": "@@ -27,7 +27,7 @@ fn main() {\n \n     let ref mut a @ ref mut b = U;\n     //~^ ERROR cannot borrow value as mutable more than once at a time\n-    //~| ERROR cannot borrow `_` as mutable more than once at a time\n+    //~| ERROR cannot borrow value as mutable more than once at a time\n     drop(a);\n     let ref mut a @ ref mut b = U;\n     //~^ ERROR cannot borrow value as mutable more than once at a time\n@@ -37,7 +37,7 @@ fn main() {\n \n     let ref mut a @ ref mut b = U;\n     //~^ ERROR cannot borrow value as mutable more than once at a time\n-    //~| ERROR cannot borrow `_` as mutable more than once at a time\n+    //~| ERROR cannot borrow value as mutable more than once at a time\n     *a = U;\n     let ref mut a @ ref mut b = U;\n     //~^ ERROR cannot borrow value as mutable more than once at a time\n@@ -95,20 +95,20 @@ fn main() {\n         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n             //~^ ERROR cannot borrow value as mutable more than once at a time\n             //~| ERROR cannot borrow value as mutable more than once at a time\n-            //~| ERROR cannot borrow `_` as mutable more than once at a time\n-            //~| ERROR cannot borrow `_` as mutable more than once at a time\n+            //~| ERROR cannot borrow value as mutable more than once at a time\n+            //~| ERROR cannot borrow value as mutable more than once at a time\n             *a = Err(U);\n \n-            // FIXME: The binding name `_` used above makes for problematic diagnostics.\n+            // FIXME: The binding name value used above makes for problematic diagnostics.\n             // Resolve that somehow...\n         }\n     }\n     match Ok(U) {\n         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n             //~^ ERROR cannot borrow value as mutable more than once at a time\n             //~| ERROR cannot borrow value as mutable more than once at a time\n-            //~| ERROR cannot borrow `_` as mutable more than once at a time\n-            //~| ERROR cannot borrow `_` as mutable more than once at a time\n+            //~| ERROR cannot borrow value as mutable more than once at a time\n+            //~| ERROR cannot borrow value as mutable more than once at a time\n             drop(a);\n         }\n     }"}, {"sha": "ae7c8f38e1eb4b78fc35ad3fac3aa345e223fe07", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-twice.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr?ref=c70aa344e40a2e034d3deffb18e74d1198ea69de", "patch": "@@ -258,7 +258,7 @@ LL |     fn f4_also_moved(ref mut a @ ref mut b @ c: U) {}\n    |                                  |           value moved into `c` here\n    |                                  value borrowed, by `b`, here\n \n-error[E0499]: cannot borrow `_` as mutable more than once at a time\n+error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:28:21\n    |\n LL |     let ref mut a @ ref mut b = U;\n@@ -270,7 +270,7 @@ LL |     let ref mut a @ ref mut b = U;\n LL |     drop(a);\n    |          - first borrow later used here\n \n-error[E0499]: cannot borrow `_` as mutable more than once at a time\n+error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:38:21\n    |\n LL |     let ref mut a @ ref mut b = U;\n@@ -318,7 +318,7 @@ LL |     let a @ &mut (ref mut b, ref mut c) = &mut (U, U);\n    |         |                    value borrowed here after move\n    |         value moved here\n \n-error[E0499]: cannot borrow `_` as mutable more than once at a time\n+error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:95:24\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n@@ -330,7 +330,7 @@ LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n LL |             *a = Err(U);\n    |             ----------- first borrow later used here\n \n-error[E0499]: cannot borrow `_` as mutable more than once at a time\n+error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:95:53\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n@@ -342,7 +342,7 @@ LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n LL |             *a = Err(U);\n    |             ----------- first borrow later used here\n \n-error[E0499]: cannot borrow `_` as mutable more than once at a time\n+error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:107:24\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n@@ -354,7 +354,7 @@ LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n LL |             drop(a);\n    |                  - first borrow later used here\n \n-error[E0499]: cannot borrow `_` as mutable more than once at a time\n+error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:107:53\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {"}, {"sha": "a45497229ac9e49a7b2213e2d87babc60e38b381", "filename": "src/test/ui/pattern/bindings-after-at/default-binding-modes-both-sides-independent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.rs?ref=c70aa344e40a2e034d3deffb18e74d1198ea69de", "patch": "@@ -29,7 +29,7 @@ fn main() {\n     let _a: &NotCopy = a;\n     let _b: NotCopy = b;\n     let ref mut a @ b = NotCopy; //~ ERROR cannot move out of value because it is borrowed\n-    //~^ ERROR cannot move out of `_` because it is borrowed\n+    //~^ ERROR cannot move out of value because it is borrowed\n     let _a: &NotCopy = a;\n     let _b: NotCopy = b;\n     match Ok(NotCopy) {"}, {"sha": "141d667c7460cb7bf31ec26038c36d97217ec779", "filename": "src/test/ui/pattern/bindings-after-at/default-binding-modes-both-sides-independent.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c70aa344e40a2e034d3deffb18e74d1198ea69de/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr?ref=c70aa344e40a2e034d3deffb18e74d1198ea69de", "patch": "@@ -44,7 +44,7 @@ LL |         ref a @ b => {\n    |         |       value moved into `b` here\n    |         value borrowed, by `a`, here\n \n-error[E0505]: cannot move out of `_` because it is borrowed\n+error[E0505]: cannot move out of value because it is borrowed\n   --> $DIR/default-binding-modes-both-sides-independent.rs:31:21\n    |\n LL |     let ref mut a @ b = NotCopy;"}]}