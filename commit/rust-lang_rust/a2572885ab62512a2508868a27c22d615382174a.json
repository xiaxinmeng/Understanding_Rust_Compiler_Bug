{"sha": "a2572885ab62512a2508868a27c22d615382174a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNTcyODg1YWI2MjUxMmEyNTA4ODY4YTI3YzIyZDYxNTM4MjE3NGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-17T00:50:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-17T00:50:26Z"}, "message": "Auto merge of #23352 - alexcrichton:stabilize-net, r=aturon\n\nThis commit performs a stabilization pass over the std::net module,\r\nincorporating the changes from RFC 923. Specifically, the following actions were\r\ntaken:\r\n\r\nStable functionality:\r\n\r\n* `net` (the name)\r\n* `Shutdown`\r\n* `Shutdown::{Read, Write, Both}`\r\n* `lookup_host`\r\n* `LookupHost`\r\n* `SocketAddr`\r\n* `SocketAddr::{V4, V6}`\r\n* `SocketAddr::port`\r\n* `SocketAddrV4`\r\n* `SocketAddrV4::{new, ip, port}`\r\n* `SocketAddrV6`\r\n* `SocketAddrV4::{new, ip, port, flowinfo, scope_id}`\r\n* Common trait impls for socket addr structures\r\n* `ToSocketAddrs`\r\n* `ToSocketAddrs::Iter`\r\n* `ToSocketAddrs::to_socket_addrs`\r\n* `ToSocketAddrs for {SocketAddr*, (Ipv*Addr, u16), str, (str, u16)}`\r\n* `Ipv4Addr`\r\n* `Ipv4Addr::{new, octets, to_ipv6_compatible, to_ipv6_mapped}`\r\n* `Ipv6Addr`\r\n* `Ipv6Addr::{new, segments, to_ipv4}`\r\n* `TcpStream`\r\n* `TcpStream::connect`\r\n* `TcpStream::{peer_addr, local_addr, shutdown, try_clone}`\r\n* `{Read,Write} for {TcpStream, &TcpStream}`\r\n* `TcpListener`\r\n* `TcpListener::bind`\r\n* `TcpListener::{local_addr, try_clone, accept, incoming}`\r\n* `Incoming`\r\n* `UdpSocket`\r\n* `UdpSocket::bind`\r\n* `UdpSocket::{recv_from, send_to, local_addr, try_clone}`\r\n\r\nUnstable functionality:\r\n\r\n* Extra methods on `Ipv{4,6}Addr` for various methods of inspecting the address\r\n  and determining qualities of it.\r\n* Extra methods on `TcpStream` to configure various protocol options.\r\n* Extra methods on `UdpSocket` to configure various protocol options.\r\n\r\nDeprecated functionality:\r\n\r\n* The `socket_addr` method has been renamed to `local_addr`\r\n\r\nThis commit is a breaking change due to the restructuring of the `SocketAddr`\r\ntype as well as the renaming of the `socket_addr` method. Migration should be\r\nfairly straightforward, however, after accounting for the new level of\r\nabstraction in `SocketAddr` (protocol distinction at the socket address level,\r\nnot the IP address).\r\n\r\n[breaking-change]", "tree": {"sha": "9ae0cc7b8755cc870de3189d466af68e74150320", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ae0cc7b8755cc870de3189d466af68e74150320"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2572885ab62512a2508868a27c22d615382174a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2572885ab62512a2508868a27c22d615382174a", "html_url": "https://github.com/rust-lang/rust/commit/a2572885ab62512a2508868a27c22d615382174a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2572885ab62512a2508868a27c22d615382174a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92dd995e1705a8c398a5266c8483e2519e494f47", "url": "https://api.github.com/repos/rust-lang/rust/commits/92dd995e1705a8c398a5266c8483e2519e494f47", "html_url": "https://github.com/rust-lang/rust/commit/92dd995e1705a8c398a5266c8483e2519e494f47"}, {"sha": "f798674b86382929ca17c88de422a6e2fdb27f2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f798674b86382929ca17c88de422a6e2fdb27f2a", "html_url": "https://github.com/rust-lang/rust/commit/f798674b86382929ca17c88de422a6e2fdb27f2a"}], "stats": {"total": 637, "additions": 408, "deletions": 229}, "files": [{"sha": "5ef93cb569ec5919aa3103c29f4e9e425f2e027f", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2572885ab62512a2508868a27c22d615382174a/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572885ab62512a2508868a27c22d615382174a/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=a2572885ab62512a2508868a27c22d615382174a", "patch": "@@ -20,7 +20,6 @@\n #![feature(std_misc)]\n #![feature(test)]\n #![feature(core)]\n-#![feature(net)]\n #![feature(path_ext)]\n \n #![deny(warnings)]"}, {"sha": "702f81db8e22faa07971f65d089ce5125b6da1f8", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 260, "deletions": 135, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=a2572885ab62512a2508868a27c22d615382174a", "patch": "@@ -15,150 +15,220 @@ use hash;\n use io;\n use libc::{self, socklen_t, sa_family_t};\n use mem;\n-use net::{IpAddr, lookup_host, ntoh, hton};\n+use net::{lookup_host, ntoh, hton, Ipv4Addr, Ipv6Addr};\n use option;\n use sys_common::{FromInner, AsInner, IntoInner};\n use vec;\n \n-/// Representation of a socket address for networking applications\n+/// Representation of a socket address for networking applications.\n ///\n-/// A socket address consists of at least an (ip, port) pair and may also\n-/// contain other information depending on the protocol.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct SocketAddr {\n-    repr: Repr,\n+/// A socket address can either represent the IPv4 or IPv6 protocol and is\n+/// paired with at least a port number as well. Each protocol may have more\n+/// specific information about the address available to it as well.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum SocketAddr {\n+    /// An IPv4 socket address which is a (ip, port) combination.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    V4(SocketAddrV4),\n+    /// An IPv6 socket address\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    V6(SocketAddrV6),\n }\n \n+/// An IPv4 socket address which is a (ip, port) combination.\n #[derive(Copy)]\n-enum Repr {\n-    V4(libc::sockaddr_in),\n-    V6(libc::sockaddr_in6),\n-}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct SocketAddrV4 { inner: libc::sockaddr_in }\n+\n+/// An IPv6 socket address\n+#[derive(Copy)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct SocketAddrV6 { inner: libc::sockaddr_in6 }\n \n impl SocketAddr {\n+    /// Gets the port number associated with this socket address\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn port(&self) -> u16 {\n+        match *self {\n+            SocketAddr::V4(ref a) => a.port(),\n+            SocketAddr::V6(ref a) => a.port(),\n+        }\n+    }\n+}\n+\n+impl SocketAddrV4 {\n     /// Creates a new socket address from the (ip, port) pair.\n-    pub fn new(ip: IpAddr, port: u16) -> SocketAddr {\n-        let repr = match ip {\n-            IpAddr::V4(ref ip) => {\n-                Repr::V4(libc::sockaddr_in {\n-                    sin_family: libc::AF_INET as sa_family_t,\n-                    sin_port: hton(port),\n-                    sin_addr: *ip.as_inner(),\n-                    .. unsafe { mem::zeroed() }\n-                })\n-            }\n-            IpAddr::V6(ref ip) => {\n-                Repr::V6(libc::sockaddr_in6 {\n-                    sin6_family: libc::AF_INET6 as sa_family_t,\n-                    sin6_port: hton(port),\n-                    sin6_addr: *ip.as_inner(),\n-                    .. unsafe { mem::zeroed() }\n-                })\n-            }\n-        };\n-        SocketAddr { repr: repr }\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4 {\n+        SocketAddrV4 {\n+            inner: libc::sockaddr_in {\n+                sin_family: libc::AF_INET as sa_family_t,\n+                sin_port: hton(port),\n+                sin_addr: *ip.as_inner(),\n+                .. unsafe { mem::zeroed() }\n+            },\n+        }\n     }\n \n     /// Gets the IP address associated with this socket address.\n-    pub fn ip(&self) -> IpAddr {\n-        match self.repr {\n-            Repr::V4(ref sa) => IpAddr::V4(FromInner::from_inner(sa.sin_addr)),\n-            Repr::V6(ref sa) => IpAddr::V6(FromInner::from_inner(sa.sin6_addr)),\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn ip(&self) -> &Ipv4Addr {\n+        unsafe {\n+            &*(&self.inner.sin_addr as *const libc::in_addr as *const Ipv4Addr)\n         }\n     }\n \n     /// Gets the port number associated with this socket address\n-    pub fn port(&self) -> u16 {\n-        match self.repr {\n-            Repr::V4(ref sa) => ntoh(sa.sin_port),\n-            Repr::V6(ref sa) => ntoh(sa.sin6_port),\n-        }\n-    }\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn port(&self) -> u16 { ntoh(self.inner.sin_port) }\n+}\n \n-    fn set_port(&mut self, port: u16) {\n-        match self.repr {\n-            Repr::V4(ref mut sa) => sa.sin_port = hton(port),\n-            Repr::V6(ref mut sa) => sa.sin6_port = hton(port),\n+impl SocketAddrV6 {\n+    /// Creates a new socket address from the ip/port/flowinfo/scope_id\n+    /// components.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32)\n+               -> SocketAddrV6 {\n+        SocketAddrV6 {\n+            inner: libc::sockaddr_in6 {\n+                sin6_family: libc::AF_INET6 as sa_family_t,\n+                sin6_port: hton(port),\n+                sin6_addr: *ip.as_inner(),\n+                sin6_flowinfo: hton(flowinfo),\n+                sin6_scope_id: hton(scope_id),\n+                .. unsafe { mem::zeroed() }\n+            },\n         }\n     }\n-}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for SocketAddr {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.repr {\n-            Repr::V4(_) => write!(f, \"{}:{}\", self.ip(), self.port()),\n-            Repr::V6(_) => write!(f, \"[{}]:{}\", self.ip(), self.port()),\n+    /// Gets the IP address associated with this socket address.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn ip(&self) -> &Ipv6Addr {\n+        unsafe {\n+            &*(&self.inner.sin6_addr as *const libc::in6_addr as *const Ipv6Addr)\n         }\n     }\n+\n+    /// Gets the port number associated with this socket address\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn port(&self) -> u16 { ntoh(self.inner.sin6_port) }\n+\n+    /// Gets scope ID associated with this address, corresponding to the\n+    /// `sin6_flowinfo` field in C.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn flowinfo(&self) -> u32 { ntoh(self.inner.sin6_flowinfo) }\n+\n+    /// Gets scope ID associated with this address, corresponding to the\n+    /// `sin6_scope_id` field in C.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn scope_id(&self) -> u32 { ntoh(self.inner.sin6_scope_id) }\n }\n \n-impl FromInner<libc::sockaddr_in> for SocketAddr {\n-    fn from_inner(addr: libc::sockaddr_in) -> SocketAddr {\n-        SocketAddr { repr: Repr::V4(addr) }\n+impl FromInner<libc::sockaddr_in> for SocketAddrV4 {\n+    fn from_inner(addr: libc::sockaddr_in) -> SocketAddrV4 {\n+        SocketAddrV4 { inner: addr }\n     }\n }\n \n-impl FromInner<libc::sockaddr_in6> for SocketAddr {\n-    fn from_inner(addr: libc::sockaddr_in6) -> SocketAddr {\n-        SocketAddr { repr: Repr::V6(addr) }\n+impl FromInner<libc::sockaddr_in6> for SocketAddrV6 {\n+    fn from_inner(addr: libc::sockaddr_in6) -> SocketAddrV6 {\n+        SocketAddrV6 { inner: addr }\n     }\n }\n \n impl<'a> IntoInner<(*const libc::sockaddr, socklen_t)> for &'a SocketAddr {\n     fn into_inner(self) -> (*const libc::sockaddr, socklen_t) {\n-        match self.repr {\n-            Repr::V4(ref a) => {\n+        match *self {\n+            SocketAddr::V4(ref a) => {\n                 (a as *const _ as *const _, mem::size_of_val(a) as socklen_t)\n             }\n-            Repr::V6(ref a) => {\n+            SocketAddr::V6(ref a) => {\n                 (a as *const _ as *const _, mem::size_of_val(a) as socklen_t)\n             }\n         }\n     }\n }\n \n-impl fmt::Debug for SocketAddr {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for SocketAddr {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            SocketAddr::V4(ref a) => a.fmt(f),\n+            SocketAddr::V6(ref a) => a.fmt(f),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for SocketAddrV4 {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}:{}\", self.ip(), self.port())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for SocketAddrV4 {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(self, fmt)\n     }\n }\n \n-impl Clone for Repr {\n-    fn clone(&self) -> Repr { *self }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for SocketAddrV6 {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"[{}]:{}\", self.ip(), self.port())\n+    }\n }\n \n-impl PartialEq for Repr {\n-    fn eq(&self, other: &Repr) -> bool {\n-        match (*self, *other) {\n-            (Repr::V4(ref a), Repr::V4(ref b)) => {\n-                a.sin_port == b.sin_port &&\n-                    a.sin_addr.s_addr == b.sin_addr.s_addr\n-            }\n-            (Repr::V6(ref a), Repr::V6(ref b)) => {\n-                a.sin6_port == b.sin6_port &&\n-                    a.sin6_addr.s6_addr == b.sin6_addr.s6_addr &&\n-                    a.sin6_flowinfo == b.sin6_flowinfo &&\n-                    a.sin6_scope_id == b.sin6_scope_id\n-            }\n-            _ => false,\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for SocketAddrV6 {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Clone for SocketAddrV4 {\n+    fn clone(&self) -> SocketAddrV4 { *self }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Clone for SocketAddrV6 {\n+    fn clone(&self) -> SocketAddrV6 { *self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl PartialEq for SocketAddrV4 {\n+    fn eq(&self, other: &SocketAddrV4) -> bool {\n+        self.inner.sin_port == other.inner.sin_port &&\n+            self.inner.sin_addr.s_addr == other.inner.sin_addr.s_addr\n     }\n }\n-impl Eq for Repr {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl PartialEq for SocketAddrV6 {\n+    fn eq(&self, other: &SocketAddrV6) -> bool {\n+        self.inner.sin6_port == other.inner.sin6_port &&\n+            self.inner.sin6_addr.s6_addr == other.inner.sin6_addr.s6_addr &&\n+            self.inner.sin6_flowinfo == other.inner.sin6_flowinfo &&\n+            self.inner.sin6_scope_id == other.inner.sin6_scope_id\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Eq for SocketAddrV4 {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Eq for SocketAddrV6 {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl hash::Hash for Repr {\n+impl hash::Hash for SocketAddrV4 {\n     fn hash<H: hash::Hasher>(&self, s: &mut H) {\n-        match *self {\n-            Repr::V4(ref a) => {\n-                (a.sin_family, a.sin_port, a.sin_addr.s_addr).hash(s)\n-            }\n-            Repr::V6(ref a) => {\n-                (a.sin6_family, a.sin6_port, &a.sin6_addr.s6_addr,\n-                 a.sin6_flowinfo, a.sin6_scope_id).hash(s)\n-            }\n-        }\n+        (self.inner.sin_port, self.inner.sin_addr.s_addr).hash(s)\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl hash::Hash for SocketAddrV6 {\n+    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n+        (self.inner.sin6_port, &self.inner.sin6_addr.s6_addr,\n+         self.inner.sin6_flowinfo, self.inner.sin6_scope_id).hash(s)\n     }\n }\n \n@@ -168,12 +238,13 @@ impl hash::Hash for Repr {\n /// This trait is used for generic address resolution when constructing network\n /// objects.  By default it is implemented for the following types:\n ///\n-///  * `SocketAddr` - `to_socket_addrs` is identity function.\n+///  * `SocketAddr`, `SocketAddrV4`, `SocketAddrV6` - `to_socket_addrs` is\n+///    identity function.\n ///\n-///  * `(IpAddr, u16)` - `to_socket_addrs` constructs `SocketAddr` trivially.\n+///  * `(IpvNAddr, u16)` - `to_socket_addrs` constructs `SocketAddr` trivially.\n ///\n ///  * `(&str, u16)` - the string should be either a string representation of an\n-///    IP address expected by `FromStr` implementation for `IpAddr` or a host\n+///    IP address expected by `FromStr` implementation for `IpvNAddr` or a host\n ///    name.\n ///\n ///  * `&str` - the string should be either a string representation of a\n@@ -192,32 +263,34 @@ impl hash::Hash for Repr {\n /// Some examples:\n ///\n /// ```no_run\n-/// use std::net::{IpAddr, SocketAddr, TcpStream, UdpSocket, TcpListener};\n+/// use std::net::{SocketAddrV4, TcpStream, UdpSocket, TcpListener, Ipv4Addr};\n ///\n /// fn main() {\n-///     let ip = IpAddr::new_v4(127, 0, 0, 1);\n+///     let ip = Ipv4Addr::new(127, 0, 0, 1);\n ///     let port = 12345;\n ///\n ///     // The following lines are equivalent modulo possible \"localhost\" name\n ///     // resolution differences\n-///     let tcp_s = TcpStream::connect(&SocketAddr::new(ip, port));\n-///     let tcp_s = TcpStream::connect(&(ip, port));\n-///     let tcp_s = TcpStream::connect(&(\"127.0.0.1\", port));\n-///     let tcp_s = TcpStream::connect(&(\"localhost\", port));\n+///     let tcp_s = TcpStream::connect(SocketAddrV4::new(ip, port));\n+///     let tcp_s = TcpStream::connect((ip, port));\n+///     let tcp_s = TcpStream::connect((\"127.0.0.1\", port));\n+///     let tcp_s = TcpStream::connect((\"localhost\", port));\n ///     let tcp_s = TcpStream::connect(\"127.0.0.1:12345\");\n ///     let tcp_s = TcpStream::connect(\"localhost:12345\");\n ///\n ///     // TcpListener::bind(), UdpSocket::bind() and UdpSocket::send_to()\n ///     // behave similarly\n ///     let tcp_l = TcpListener::bind(\"localhost:12345\");\n ///\n-///     let mut udp_s = UdpSocket::bind(&(\"127.0.0.1\", port)).unwrap();\n-///     udp_s.send_to(&[7], &(ip, 23451));\n+///     let mut udp_s = UdpSocket::bind((\"127.0.0.1\", port)).unwrap();\n+///     udp_s.send_to(&[7], (ip, 23451));\n /// }\n /// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ToSocketAddrs {\n     /// Returned iterator over socket addresses which this type may correspond\n     /// to.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Iter: Iterator<Item=SocketAddr>;\n \n     /// Converts this object to an iterator of resolved `SocketAddr`s.\n@@ -231,48 +304,92 @@ pub trait ToSocketAddrs {\n     /// # Errors\n     ///\n     /// Any errors encountered during resolution will be returned as an `Err`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn to_socket_addrs(&self) -> io::Result<Self::Iter>;\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ToSocketAddrs for SocketAddr {\n     type Iter = option::IntoIter<SocketAddr>;\n     fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n         Ok(Some(*self).into_iter())\n     }\n }\n \n-impl ToSocketAddrs for (IpAddr, u16) {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ToSocketAddrs for SocketAddrV4 {\n+    type Iter = option::IntoIter<SocketAddr>;\n+    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n+        SocketAddr::V4(*self).to_socket_addrs()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ToSocketAddrs for SocketAddrV6 {\n+    type Iter = option::IntoIter<SocketAddr>;\n+    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n+        SocketAddr::V6(*self).to_socket_addrs()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ToSocketAddrs for (Ipv4Addr, u16) {\n+    type Iter = option::IntoIter<SocketAddr>;\n+    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n+        let (ip, port) = *self;\n+        SocketAddrV4::new(ip, port).to_socket_addrs()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ToSocketAddrs for (Ipv6Addr, u16) {\n     type Iter = option::IntoIter<SocketAddr>;\n     fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n         let (ip, port) = *self;\n-        Ok(Some(SocketAddr::new(ip, port)).into_iter())\n+        SocketAddrV6::new(ip, port, 0, 0).to_socket_addrs()\n     }\n }\n \n fn resolve_socket_addr(s: &str, p: u16) -> io::Result<vec::IntoIter<SocketAddr>> {\n     let ips = try!(lookup_host(s));\n     let v: Vec<_> = try!(ips.map(|a| {\n-        a.map(|mut a| { a.set_port(p); a })\n+        a.map(|a| {\n+            match a {\n+                SocketAddr::V4(ref a) => {\n+                    SocketAddr::V4(SocketAddrV4::new(*a.ip(), p))\n+                }\n+                SocketAddr::V6(ref a) => {\n+                    SocketAddr::V6(SocketAddrV6::new(*a.ip(), p, a.flowinfo(),\n+                                                     a.scope_id()))\n+                }\n+            }\n+        })\n     }).collect());\n     Ok(v.into_iter())\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> ToSocketAddrs for (&'a str, u16) {\n     type Iter = vec::IntoIter<SocketAddr>;\n     fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> {\n         let (host, port) = *self;\n \n-        // try to parse the host as a regular IpAddr first\n-        match host.parse().ok() {\n-            Some(addr) => return Ok(vec![SocketAddr::new(addr, port)].into_iter()),\n-            None => {}\n+        // try to parse the host as a regular IP address first\n+        if let Ok(addr) = host.parse::<Ipv4Addr>() {\n+            let addr = SocketAddrV4::new(addr, port);\n+            return Ok(vec![SocketAddr::V4(addr)].into_iter())\n+        }\n+        if let Ok(addr) = host.parse::<Ipv6Addr>() {\n+            let addr = SocketAddrV6::new(addr, port, 0, 0);\n+            return Ok(vec![SocketAddr::V6(addr)].into_iter())\n         }\n \n         resolve_socket_addr(host, port)\n     }\n }\n \n // accepts strings like 'localhost:12345'\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ToSocketAddrs for str {\n     type Iter = vec::IntoIter<SocketAddr>;\n     fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> {\n@@ -322,16 +439,16 @@ mod tests {\n         assert_eq!(Ok(Ipv4Addr::new(0, 0, 0, 0)), \"0.0.0.0\".parse());\n \n         // out of range\n-        let none: Option<IpAddr> = \"256.0.0.1\".parse().ok();\n+        let none: Option<Ipv4Addr> = \"256.0.0.1\".parse().ok();\n         assert_eq!(None, none);\n         // too short\n-        let none: Option<IpAddr> = \"255.0.0\".parse().ok();\n+        let none: Option<Ipv4Addr> = \"255.0.0\".parse().ok();\n         assert_eq!(None, none);\n         // too long\n-        let none: Option<IpAddr> = \"255.0.0.1.2\".parse().ok();\n+        let none: Option<Ipv4Addr> = \"255.0.0.1.2\".parse().ok();\n         assert_eq!(None, none);\n         // no number between dots\n-        let none: Option<IpAddr> = \"255.0..1\".parse().ok();\n+        let none: Option<Ipv4Addr> = \"255.0..1\".parse().ok();\n         assert_eq!(None, none);\n     }\n \n@@ -347,19 +464,19 @@ mod tests {\n                 \"2a02:6b8::11:11\".parse());\n \n         // too long group\n-        let none: Option<IpAddr> = \"::00000\".parse().ok();\n+        let none: Option<Ipv6Addr> = \"::00000\".parse().ok();\n         assert_eq!(None, none);\n         // too short\n-        let none: Option<IpAddr> = \"1:2:3:4:5:6:7\".parse().ok();\n+        let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7\".parse().ok();\n         assert_eq!(None, none);\n         // too long\n-        let none: Option<IpAddr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n+        let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n         assert_eq!(None, none);\n         // triple colon\n-        let none: Option<IpAddr> = \"1:2:::6:7:8\".parse().ok();\n+        let none: Option<Ipv6Addr> = \"1:2:::6:7:8\".parse().ok();\n         assert_eq!(None, none);\n         // two double colons\n-        let none: Option<IpAddr> = \"1:2::6::8\".parse().ok();\n+        let none: Option<Ipv6Addr> = \"1:2::6::8\".parse().ok();\n         assert_eq!(None, none);\n     }\n \n@@ -375,24 +492,24 @@ mod tests {\n                 \"2001:db8:122:c000:2:2100:192.0.2.33\".parse());\n \n         // colon after v4\n-        let none: Option<IpAddr> = \"::127.0.0.1:\".parse().ok();\n+        let none: Option<Ipv4Addr> = \"::127.0.0.1:\".parse().ok();\n         assert_eq!(None, none);\n         // not enough groups\n-        let none: Option<IpAddr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n+        let none: Option<Ipv6Addr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n         assert_eq!(None, none);\n         // too many groups\n-        let none: Option<IpAddr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n+        let none: Option<Ipv6Addr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n         assert_eq!(None, none);\n     }\n \n     #[test]\n     fn test_from_str_socket_addr() {\n-        assert_eq!(Ok(SocketAddr::new(IpAddr::new_v4(77, 88, 21, 11), 80)),\n-                \"77.88.21.11:80\".parse());\n-        assert_eq!(Ok(SocketAddr::new(IpAddr::new_v6(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53)),\n-                \"[2a02:6b8:0:1::1]:53\".parse());\n-        assert_eq!(Ok(SocketAddr::new(IpAddr::new_v6(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22)),\n-                \"[::127.0.0.1]:22\".parse());\n+        assert_eq!(Ok(sa4(Ipv4Addr::new(77, 88, 21, 11), 80)),\n+                   \"77.88.21.11:80\".parse());\n+        assert_eq!(Ok(sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53)),\n+                   \"[2a02:6b8:0:1::1]:53\".parse());\n+        assert_eq!(Ok(sa6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22)),\n+                   \"[::127.0.0.1]:22\".parse());\n \n         // without port\n         let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n@@ -555,39 +672,47 @@ mod tests {\n \n     #[test]\n     fn to_socket_addr_socketaddr() {\n-        let a = SocketAddr::new(IpAddr::new_v4(77, 88, 21, 11), 12345);\n+        let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 12345);\n         assert_eq!(Ok(vec![a]), tsa(a));\n     }\n \n+    fn sa4(a: Ipv4Addr, p: u16) -> SocketAddr {\n+        SocketAddr::V4(SocketAddrV4::new(a, p))\n+    }\n+\n+    fn sa6(a: Ipv6Addr, p: u16) -> SocketAddr {\n+        SocketAddr::V6(SocketAddrV6::new(a, p, 0, 0))\n+    }\n+\n     #[test]\n     fn to_socket_addr_ipaddr_u16() {\n-        let a = IpAddr::new_v4(77, 88, 21, 11);\n+        let a = Ipv4Addr::new(77, 88, 21, 11);\n         let p = 12345;\n-        let e = SocketAddr::new(a, p);\n+        let e = SocketAddr::V4(SocketAddrV4::new(a, p));\n         assert_eq!(Ok(vec![e]), tsa((a, p)));\n     }\n \n     #[test]\n     fn to_socket_addr_str_u16() {\n-        let a = SocketAddr::new(IpAddr::new_v4(77, 88, 21, 11), 24352);\n+        let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 24352);\n         assert_eq!(Ok(vec![a]), tsa((\"77.88.21.11\", 24352)));\n \n-        let a = SocketAddr::new(IpAddr::new_v6(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53);\n+        let a = sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53);\n         assert_eq!(Ok(vec![a]), tsa((\"2a02:6b8:0:1::1\", 53)));\n \n-        let a = SocketAddr::new(IpAddr::new_v4(127, 0, 0, 1), 23924);\n+        let a = sa4(Ipv4Addr::new(127, 0, 0, 1), 23924);\n         assert!(tsa((\"localhost\", 23924)).unwrap().contains(&a));\n     }\n \n     #[test]\n     fn to_socket_addr_str() {\n-        let a = SocketAddr::new(IpAddr::new_v4(77, 88, 21, 11), 24352);\n+        let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 24352);\n         assert_eq!(Ok(vec![a]), tsa(\"77.88.21.11:24352\"));\n \n-        let a = SocketAddr::new(IpAddr::new_v6(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53);\n+        let a = sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53);\n         assert_eq!(Ok(vec![a]), tsa(\"[2a02:6b8:0:1::1]:53\"));\n \n-        let a = SocketAddr::new(IpAddr::new_v4(127, 0, 0, 1), 23924);\n+        let a = sa4(Ipv4Addr::new(127, 0, 0, 1), 23924);\n         assert!(tsa(\"localhost:23924\").unwrap().contains(&a));\n     }\n "}, {"sha": "c5f2ae53d22ed87c94748b1997fabd0c93731958", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=a2572885ab62512a2508868a27c22d615382174a", "patch": "@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable(feature = \"ip\", reason = \"extra functionality has not been \\\n+                                      scrutinized to the level that it should \\\n+                                      be stable\")]\n+\n use prelude::v1::*;\n \n use cmp::Ordering;\n@@ -19,12 +23,14 @@ use net::{hton, ntoh};\n \n /// Representation of an IPv4 address.\n #[derive(Copy)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ipv4Addr {\n     inner: libc::in_addr,\n }\n \n /// Representation of an IPv6 address.\n #[derive(Copy)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ipv6Addr {\n     inner: libc::in6_addr,\n }\n@@ -41,46 +47,11 @@ pub enum Ipv6MulticastScope {\n     Global\n }\n \n-/// Enumeration of possible IP addresses\n-#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n-pub enum IpAddr {\n-    /// An IPv4 address.\n-    V4(Ipv4Addr),\n-    /// An IPv6 address.\n-    V6(Ipv6Addr)\n-}\n-\n-impl IpAddr {\n-    /// Create a new IpAddr that contains an IPv4 address.\n-    ///\n-    /// The result will represent the IP address a.b.c.d\n-    pub fn new_v4(a: u8, b: u8, c: u8, d: u8) -> IpAddr {\n-        IpAddr::V4(Ipv4Addr::new(a, b, c, d))\n-    }\n-\n-    /// Create a new IpAddr that contains an IPv6 address.\n-    ///\n-    /// The result will represent the IP address a:b:c:d:e:f\n-    pub fn new_v6(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,\n-                  h: u16) -> IpAddr {\n-        IpAddr::V6(Ipv6Addr::new(a, b, c, d, e, f, g, h))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for IpAddr {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            IpAddr::V4(v4) => v4.fmt(f),\n-            IpAddr::V6(v6) => v6.fmt(f)\n-        }\n-    }\n-}\n-\n impl Ipv4Addr {\n     /// Create a new IPv4 address from four eight-bit octets.\n     ///\n     /// The result will represent the IP address a.b.c.d\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n         Ipv4Addr {\n             inner: libc::in_addr {\n@@ -93,6 +64,7 @@ impl Ipv4Addr {\n     }\n \n     /// Returns the four eight-bit integers that make up this address\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn octets(&self) -> [u8; 4] {\n         let bits = ntoh(self.inner.s_addr);\n         [(bits >> 24) as u8, (bits >> 16) as u8, (bits >> 8) as u8, bits as u8]\n@@ -148,6 +120,7 @@ impl Ipv4Addr {\n     /// Convert this address to an IPv4-compatible IPv6 address\n     ///\n     /// a.b.c.d becomes ::a.b.c.d\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_ipv6_compatible(&self) -> Ipv6Addr {\n         Ipv6Addr::new(0, 0, 0, 0, 0, 0,\n                       ((self.octets()[0] as u16) << 8) | self.octets()[1] as u16,\n@@ -157,6 +130,7 @@ impl Ipv4Addr {\n     /// Convert this address to an IPv4-mapped IPv6 address\n     ///\n     /// a.b.c.d becomes ::ffff:a.b.c.d\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_ipv6_mapped(&self) -> Ipv6Addr {\n         Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff,\n                       ((self.octets()[0] as u16) << 8) | self.octets()[1] as u16,\n@@ -165,28 +139,34 @@ impl Ipv4Addr {\n \n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Ipv4Addr {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let octets = self.octets();\n         write!(fmt, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3])\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Ipv4Addr {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(self, fmt)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Clone for Ipv4Addr {\n     fn clone(&self) -> Ipv4Addr { *self }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for Ipv4Addr {\n     fn eq(&self, other: &Ipv4Addr) -> bool {\n         self.inner.s_addr == other.inner.s_addr\n     }\n }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Eq for Ipv4Addr {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -196,12 +176,14 @@ impl hash::Hash for Ipv4Addr {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialOrd for Ipv4Addr {\n     fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n         Some(self.cmp(other))\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Ord for Ipv4Addr {\n     fn cmp(&self, other: &Ipv4Addr) -> Ordering {\n         self.inner.s_addr.cmp(&other.inner.s_addr)\n@@ -221,6 +203,7 @@ impl Ipv6Addr {\n     /// Create a new IPv6 address from eight 16-bit segments.\n     ///\n     /// The result will represent the IP address a:b:c:d:e:f\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,\n                h: u16) -> Ipv6Addr {\n         Ipv6Addr {\n@@ -232,6 +215,7 @@ impl Ipv6Addr {\n     }\n \n     /// Return the eight 16-bit segments that make up this address\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn segments(&self) -> [u16; 8] {\n         [ntoh(self.inner.s6_addr[0]),\n          ntoh(self.inner.s6_addr[1]),\n@@ -324,6 +308,7 @@ impl Ipv6Addr {\n     /// neither IPv4-compatible or IPv4-mapped.\n     ///\n     /// ::a.b.c.d and ::ffff:a.b.c.d become a.b.c.d\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_ipv4(&self) -> Option<Ipv4Addr> {\n         match self.segments() {\n             [0, 0, 0, 0, 0, f, g, h] if f == 0 || f == 0xffff => {\n@@ -335,6 +320,7 @@ impl Ipv6Addr {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Ipv6Addr {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match self.segments() {\n@@ -405,21 +391,26 @@ impl fmt::Display for Ipv6Addr {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for Ipv6Addr {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(self, fmt)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Clone for Ipv6Addr {\n     fn clone(&self) -> Ipv6Addr { *self }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for Ipv6Addr {\n     fn eq(&self, other: &Ipv6Addr) -> bool {\n         self.inner.s6_addr == other.inner.s6_addr\n     }\n }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Eq for Ipv6Addr {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -429,12 +420,14 @@ impl hash::Hash for Ipv6Addr {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialOrd for Ipv6Addr {\n     fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n         Some(self.cmp(other))\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Ord for Ipv6Addr {\n     fn cmp(&self, other: &Ipv6Addr) -> Ordering {\n         self.inner.s6_addr.cmp(&other.inner.s6_addr)"}, {"sha": "36f36af73e1480c10bc435e1455e8f8d48c41122", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=a2572885ab62512a2508868a27c22d615382174a", "patch": "@@ -13,16 +13,16 @@\n //! > **NOTE**: This module is very much a work in progress and is under active\n //! > development.\n \n-#![unstable(feature = \"net\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use prelude::v1::*;\n \n use io::{self, Error, ErrorKind};\n use num::Int;\n use sys_common::net2 as net_imp;\n \n-pub use self::ip::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n-pub use self::addr::{SocketAddr, ToSocketAddrs};\n+pub use self::ip::{Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n+pub use self::addr::{SocketAddr, SocketAddrV4, SocketAddrV6, ToSocketAddrs};\n pub use self::tcp::{TcpStream, TcpListener};\n pub use self::udp::UdpSocket;\n \n@@ -36,23 +36,27 @@ mod parser;\n /// Possible values which can be passed to the `shutdown` method of `TcpStream`\n /// and `UdpSocket`.\n #[derive(Copy, Clone, PartialEq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Shutdown {\n     /// Indicates that the reading portion of this stream/socket should be shut\n     /// down. All currently blocked and future reads will return `Ok(0)`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Read,\n     /// Indicates that the writing portion of this stream/socket should be shut\n     /// down. All currently blocked and future writes will return an error.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Write,\n     /// Shut down both the reading and writing portions of this stream.\n     ///\n     /// See `Shutdown::Read` and `Shutdown::Write` for more information.\n-    Both\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Both,\n }\n \n fn hton<I: Int>(i: I) -> I { i.to_be() }\n fn ntoh<I: Int>(i: I) -> I { Int::from_be(i) }\n \n-fn each_addr<A: ToSocketAddrs + ?Sized, F, T>(addr: &A, mut f: F) -> io::Result<T>\n+fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>\n     where F: FnMut(&SocketAddr) -> io::Result<T>\n {\n     let mut last_err = None;\n@@ -69,8 +73,10 @@ fn each_addr<A: ToSocketAddrs + ?Sized, F, T>(addr: &A, mut f: F) -> io::Result<\n }\n \n /// An iterator over `SocketAddr` values returned from a host lookup operation.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LookupHost(net_imp::LookupHost);\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for LookupHost {\n     type Item = io::Result<SocketAddr>;\n     fn next(&mut self) -> Option<io::Result<SocketAddr>> { self.0.next() }\n@@ -93,6 +99,7 @@ impl Iterator for LookupHost {\n /// # Ok(())\n /// # }\n /// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     net_imp::lookup_host(host).map(LookupHost)\n }"}, {"sha": "9843a1527180e356b7f996e69e4aba307e8fd99b", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=a2572885ab62512a2508868a27c22d615382174a", "patch": "@@ -16,14 +16,19 @@\n use prelude::v1::*;\n \n use str::FromStr;\n-use net::{Ipv4Addr, Ipv6Addr, IpAddr, SocketAddr};\n+use net::{Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n \n struct Parser<'a> {\n     // parsing as ASCII, so can use byte array\n     s: &'a [u8],\n     pos: usize,\n }\n \n+enum IpAddr {\n+    V4(Ipv4Addr),\n+    V6(Ipv6Addr),\n+}\n+\n impl<'a> Parser<'a> {\n     fn new(s: &'a str) -> Parser<'a> {\n         Parser {\n@@ -281,18 +286,13 @@ impl<'a> Parser<'a> {\n         let port  = |p: &mut Parser| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n \n         // host, colon, port\n-        self.read_seq_3::<IpAddr, char, u16, _, _, _>(ip_addr, colon, port)\n-                .map(|t| match t { (ip, _, port) => SocketAddr::new(ip, port) })\n-    }\n-}\n-\n-impl FromStr for IpAddr {\n-    type Err = ParseError;\n-    fn from_str(s: &str) -> Result<IpAddr, ParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_ip_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(ParseError),\n-        }\n+        self.read_seq_3(ip_addr, colon, port).map(|t| {\n+            let (ip, _, port): (IpAddr, char, u16) = t;\n+            match ip {\n+                IpAddr::V4(ip) => SocketAddr::V4(SocketAddrV4::new(ip, port)),\n+                IpAddr::V6(ip) => SocketAddr::V6(SocketAddrV6::new(ip, port, 0, 0)),\n+            }\n+        })\n     }\n }\n "}, {"sha": "501ba2dc2c178b63ffe7b98597c769043ee112f5", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=a2572885ab62512a2508868a27c22d615382174a", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable(feature = \"tcp\", reason = \"remaining functions have not been \\\n+                                       scrutinized enough to be stabilized\")]\n+\n use prelude::v1::*;\n use io::prelude::*;\n \n@@ -35,6 +38,7 @@ use sys_common::AsInner;\n ///     let _ = stream.read(&mut [0; 128]); // ignore here too\n /// } // the stream is closed here\n /// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TcpStream(net_imp::TcpStream);\n \n /// A structure representing a socket server.\n@@ -67,12 +71,14 @@ pub struct TcpStream(net_imp::TcpStream);\n /// // close the socket server\n /// drop(listener);\n /// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TcpListener(net_imp::TcpListener);\n \n /// An infinite iterator over the connections from a `TcpListener`.\n ///\n /// This iterator will infinitely yield `Some` of the accepted connections. It\n /// is equivalent to calling `accept` in a loop.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Incoming<'a> { listener: &'a TcpListener }\n \n impl TcpStream {\n@@ -81,25 +87,36 @@ impl TcpStream {\n     /// `addr` is an address of the remote host. Anything which implements\n     /// `ToSocketAddrs` trait can be supplied for the address; see this trait\n     /// documentation for concrete examples.\n-    pub fn connect<A: ToSocketAddrs + ?Sized>(addr: &A) -> io::Result<TcpStream> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn connect<A: ToSocketAddrs>(addr: A) -> io::Result<TcpStream> {\n         super::each_addr(addr, net_imp::TcpStream::connect).map(TcpStream)\n     }\n \n     /// Returns the socket address of the remote peer of this TCP connection.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         self.0.peer_addr()\n     }\n \n     /// Returns the socket address of the local half of this TCP connection.\n+    #[unstable(feature = \"net\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to local_addr\")]\n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n         self.0.socket_addr()\n     }\n \n+    /// Returns the socket address of the local half of this TCP connection.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        self.0.socket_addr()\n+    }\n+\n     /// Shut down the read, write, or both halves of this connection.\n     ///\n     /// This function will cause all pending and future I/O on the specified\n     /// portions to return immediately with an appropriate value (see the\n     /// documentation of `Shutdown`).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n         self.0.shutdown(how)\n     }\n@@ -110,6 +127,7 @@ impl TcpStream {\n     /// object references. Both handles will read and write the same stream of\n     /// data, and options set on one stream will be propagated to the other\n     /// stream.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_clone(&self) -> io::Result<TcpStream> {\n         self.0.duplicate().map(TcpStream)\n     }\n@@ -129,16 +147,20 @@ impl TcpStream {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for TcpStream {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Read for &'a TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for &'a TcpStream {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> { self.0.write(buf) }\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n@@ -160,11 +182,20 @@ impl TcpListener {\n     ///\n     /// The address type can be any implementer of `ToSocketAddrs` trait. See\n     /// its documentation for concrete examples.\n-    pub fn bind<A: ToSocketAddrs + ?Sized>(addr: &A) -> io::Result<TcpListener> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> {\n         super::each_addr(addr, net_imp::TcpListener::bind).map(TcpListener)\n     }\n \n     /// Returns the local socket address of this listener.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        self.0.socket_addr()\n+    }\n+\n+    /// Deprecated, renamed to local_addr\n+    #[unstable(feature = \"net\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to local_addr\")]\n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n         self.0.socket_addr()\n     }\n@@ -174,6 +205,7 @@ impl TcpListener {\n     /// The returned `TcpListener` is a reference to the same socket that this\n     /// object references. Both handles can be used to accept incoming\n     /// connections and options set on one listener will affect the other.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_clone(&self) -> io::Result<TcpListener> {\n         self.0.duplicate().map(TcpListener)\n     }\n@@ -183,6 +215,7 @@ impl TcpListener {\n     /// This function will block the calling thread until a new TCP connection\n     /// is established. When established, the corresponding `TcpStream` and the\n     /// remote peer's address will be returned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n         self.0.accept().map(|(a, b)| (TcpStream(a), b))\n     }\n@@ -192,11 +225,13 @@ impl TcpListener {\n     ///\n     /// The returned iterator will never returned `None` and will also not yield\n     /// the peer's `SocketAddr` structure.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn incoming(&self) -> Incoming {\n         Incoming { listener: self }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Incoming<'a> {\n     type Item = io::Result<TcpStream>;\n     fn next(&mut self) -> Option<io::Result<TcpStream>> {"}, {"sha": "3d42472f0fc424caa1e93d4a2b2c5a7b73de9790", "filename": "src/libstd/net/test.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftest.rs?ref=a2572885ab62512a2508868a27c22d615382174a", "patch": "@@ -11,19 +11,20 @@\n use prelude::v1::*;\n \n use env;\n-use net::{SocketAddr, IpAddr};\n+use net::{SocketAddr, SocketAddrV4, SocketAddrV6, Ipv4Addr, Ipv6Addr};\n use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n static PORT: AtomicUsize = ATOMIC_USIZE_INIT;\n \n pub fn next_test_ip4() -> SocketAddr {\n-    SocketAddr::new(IpAddr::new_v4(127, 0, 0, 1),\n-                    PORT.fetch_add(1, Ordering::SeqCst) as u16 + base_port())\n+    let port = PORT.fetch_add(1, Ordering::SeqCst) as u16 + base_port();\n+    SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), port))\n }\n \n pub fn next_test_ip6() -> SocketAddr {\n-    SocketAddr::new(IpAddr::new_v6(0, 0, 0, 0, 0, 0, 0, 1),\n-                    PORT.fetch_add(1, Ordering::SeqCst) as u16 + base_port())\n+    let port = PORT.fetch_add(1, Ordering::SeqCst) as u16 + base_port();\n+    SocketAddr::V6(SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1),\n+                                     port, 0, 0))\n }\n \n // The bots run multiple builds at the same time, and these builds"}, {"sha": "1ace195752658ab297b853009a52b8b5ee21ba8c", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=a2572885ab62512a2508868a27c22d615382174a", "patch": "@@ -8,10 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable(feature = \"udp\", reason = \"remaining functions have not been \\\n+                                       scrutinized enough to be stabilized\")]\n+\n use prelude::v1::*;\n \n use io::{self, Error, ErrorKind};\n-use net::{ToSocketAddrs, SocketAddr, IpAddr};\n+use net::{ToSocketAddrs, SocketAddr};\n use sys_common::net2 as net_imp;\n use sys_common::AsInner;\n \n@@ -41,19 +44,22 @@ use sys_common::AsInner;\n /// # Ok(())\n /// # }\n /// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct UdpSocket(net_imp::UdpSocket);\n \n impl UdpSocket {\n     /// Creates a UDP socket from the given address.\n     ///\n     /// Address type can be any implementor of `ToSocketAddr` trait. See its\n     /// documentation for concrete examples.\n-    pub fn bind<A: ToSocketAddrs + ?Sized>(addr: &A) -> io::Result<UdpSocket> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> {\n         super::each_addr(addr, net_imp::UdpSocket::bind).map(UdpSocket)\n     }\n \n     /// Receives data from the socket. On success, returns the number of bytes\n     /// read and the address from whence the data came.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n         self.0.recv_from(buf)\n     }\n@@ -63,8 +69,9 @@ impl UdpSocket {\n     ///\n     /// Address type can be any implementor of `ToSocketAddrs` trait. See its\n     /// documentation for concrete examples.\n-    pub fn send_to<A: ToSocketAddrs + ?Sized>(&self, buf: &[u8], addr: &A)\n-                                              -> io::Result<usize> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A)\n+                                     -> io::Result<usize> {\n         match try!(addr.to_socket_addrs()).next() {\n             Some(addr) => self.0.send_to(buf, &addr),\n             None => Err(Error::new(ErrorKind::InvalidInput,\n@@ -73,15 +80,24 @@ impl UdpSocket {\n     }\n \n     /// Returns the socket address that this socket was created from.\n+    #[unstable(feature = \"net\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to local_addr\")]\n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n         self.0.socket_addr()\n     }\n \n+    /// Returns the socket address that this socket was created from.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        self.0.socket_addr()\n+    }\n+\n     /// Create a new independently owned handle to the underlying socket.\n     ///\n     /// The returned `UdpSocket` is a reference to the same socket that this\n     /// object references. Both handles will read and write the same port, and\n     /// options set on one socket will be propagated to the other.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_clone(&self) -> io::Result<UdpSocket> {\n         self.0.duplicate().map(UdpSocket)\n     }\n@@ -99,12 +115,12 @@ impl UdpSocket {\n     }\n \n     /// Joins a multicast IP address (becomes a member of it)\n-    pub fn join_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n+    pub fn join_multicast(&self, multi: &SocketAddr) -> io::Result<()> {\n         self.0.join_multicast(multi)\n     }\n \n     /// Leaves a multicast IP address (drops membership from it)\n-    pub fn leave_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n+    pub fn leave_multicast(&self, multi: &SocketAddr) -> io::Result<()> {\n         self.0.leave_multicast(multi)\n     }\n \n@@ -151,7 +167,7 @@ mod tests {\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n     #[test]\n     fn bind_error() {\n-        let addr = SocketAddr::new(IpAddr::new_v4(0, 0, 0, 0), 1);\n+        let addr = SocketAddrV4::new(Ipv4Addr::new(0, 0, 0, 0), 1);\n         match UdpSocket::bind(&addr) {\n             Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind(), ErrorKind::PermissionDenied),"}, {"sha": "25aeab1b4ff74074a716f811f1b02bf37151923a", "filename": "src/libstd/sys/common/net2.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs?ref=a2572885ab62512a2508868a27c22d615382174a", "patch": "@@ -14,7 +14,7 @@ use ffi::CString;\n use io::{self, Error, ErrorKind};\n use libc::{self, c_int, c_char, c_void, socklen_t};\n use mem;\n-use net::{IpAddr, SocketAddr, Shutdown};\n+use net::{SocketAddr, Shutdown};\n use sys::c;\n use sys::net::{cvt, cvt_r, cvt_gai, Socket, init, wrlen_t};\n use sys_common::{AsInner, FromInner, IntoInner};\n@@ -63,15 +63,15 @@ fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n     match storage.ss_family as libc::c_int {\n         libc::AF_INET => {\n             assert!(len as usize >= mem::size_of::<libc::sockaddr_in>());\n-            Ok(FromInner::from_inner(unsafe {\n+            Ok(SocketAddr::V4(FromInner::from_inner(unsafe {\n                 *(storage as *const _ as *const libc::sockaddr_in)\n-            }))\n+            })))\n         }\n         libc::AF_INET6 => {\n             assert!(len as usize >= mem::size_of::<libc::sockaddr_in6>());\n-            Ok(FromInner::from_inner(unsafe {\n+            Ok(SocketAddr::V6(FromInner::from_inner(unsafe {\n                 *(storage as *const _ as *const libc::sockaddr_in6)\n-            }))\n+            })))\n         }\n         _ => {\n             Err(Error::new(ErrorKind::InvalidInput, \"invalid argument\", None))\n@@ -334,39 +334,39 @@ impl UdpSocket {\n                    libc::IP_MULTICAST_LOOP, on as c_int)\n     }\n \n-    pub fn join_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n+    pub fn join_multicast(&self, multi: &SocketAddr) -> io::Result<()> {\n         match *multi {\n-            IpAddr::V4(..) => {\n+            SocketAddr::V4(..) => {\n                 self.set_membership(multi, libc::IP_ADD_MEMBERSHIP)\n             }\n-            IpAddr::V6(..) => {\n+            SocketAddr::V6(..) => {\n                 self.set_membership(multi, libc::IPV6_ADD_MEMBERSHIP)\n             }\n         }\n     }\n-    pub fn leave_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n+    pub fn leave_multicast(&self, multi: &SocketAddr) -> io::Result<()> {\n         match *multi {\n-            IpAddr::V4(..) => {\n+            SocketAddr::V4(..) => {\n                 self.set_membership(multi, libc::IP_DROP_MEMBERSHIP)\n             }\n-            IpAddr::V6(..) => {\n+            SocketAddr::V6(..) => {\n                 self.set_membership(multi, libc::IPV6_DROP_MEMBERSHIP)\n             }\n         }\n     }\n-    fn set_membership(&self, addr: &IpAddr, opt: c_int) -> io::Result<()> {\n+    fn set_membership(&self, addr: &SocketAddr, opt: c_int) -> io::Result<()> {\n         match *addr {\n-            IpAddr::V4(ref addr) => {\n+            SocketAddr::V4(ref addr) => {\n                 let mreq = libc::ip_mreq {\n-                    imr_multiaddr: *addr.as_inner(),\n+                    imr_multiaddr: *addr.ip().as_inner(),\n                     // interface == INADDR_ANY\n                     imr_interface: libc::in_addr { s_addr: 0x0 },\n                 };\n                 setsockopt(&self.inner, libc::IPPROTO_IP, opt, mreq)\n             }\n-            IpAddr::V6(ref addr) => {\n+            SocketAddr::V6(ref addr) => {\n                 let mreq = libc::ip6_mreq {\n-                    ipv6mr_multiaddr: *addr.as_inner(),\n+                    ipv6mr_multiaddr: *addr.ip().as_inner(),\n                     ipv6mr_interface: 0,\n                 };\n                 setsockopt(&self.inner, libc::IPPROTO_IPV6, opt, mreq)"}, {"sha": "b22fa33e5624a3ca7a2e1754f57b65b2b027ac7c", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=a2572885ab62512a2508868a27c22d615382174a", "patch": "@@ -15,7 +15,7 @@ use io;\n use libc::{self, c_int, size_t};\n use str;\n use sys::c;\n-use net::{SocketAddr, IpAddr};\n+use net::SocketAddr;\n use sys::fd::FileDesc;\n use sys_common::AsInner;\n \n@@ -40,9 +40,9 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n \n impl Socket {\n     pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {\n-        let fam = match addr.ip() {\n-            IpAddr::V4(..) => libc::AF_INET,\n-            IpAddr::V6(..) => libc::AF_INET6,\n+        let fam = match *addr {\n+            SocketAddr::V4(..) => libc::AF_INET,\n+            SocketAddr::V6(..) => libc::AF_INET6,\n         };\n         unsafe {\n             let fd = try!(cvt(libc::socket(fam, ty, 0)));"}, {"sha": "e092faf4935dbc3d3e542168cd34389db5a7041b", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572885ab62512a2508868a27c22d615382174a/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=a2572885ab62512a2508868a27c22d615382174a", "patch": "@@ -14,7 +14,7 @@ use io;\n use libc::consts::os::extra::INVALID_SOCKET;\n use libc::{self, c_int, c_void};\n use mem;\n-use net::{SocketAddr, IpAddr};\n+use net::SocketAddr;\n use num::{SignedInt, Int};\n use rt;\n use sync::{Once, ONCE_INIT};\n@@ -73,9 +73,9 @@ pub fn cvt_r<T: SignedInt, F>(mut f: F) -> io::Result<T> where F: FnMut() -> T {\n \n impl Socket {\n     pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {\n-        let fam = match addr.ip() {\n-            IpAddr::V4(..) => libc::AF_INET,\n-            IpAddr::V6(..) => libc::AF_INET6,\n+        let fam = match *addr {\n+            SocketAddr::V4(..) => libc::AF_INET,\n+            SocketAddr::V6(..) => libc::AF_INET6,\n         };\n         match unsafe { libc::socket(fam, ty, 0) } {\n             INVALID_SOCKET => Err(last_error()),"}, {"sha": "f668cae66c6036e9f3e4b5bd66aef82a62cc016b", "filename": "src/test/run-pass/issue-22577.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2572885ab62512a2508868a27c22d615382174a/src%2Ftest%2Frun-pass%2Fissue-22577.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2572885ab62512a2508868a27c22d615382174a/src%2Ftest%2Frun-pass%2Fissue-22577.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22577.rs?ref=a2572885ab62512a2508868a27c22d615382174a", "patch": "@@ -25,5 +25,8 @@ fn main() {\n     assert_both::<net::TcpListener>();\n     assert_both::<net::UdpSocket>();\n     assert_both::<net::SocketAddr>();\n-    assert_both::<net::IpAddr>();\n+    assert_both::<net::SocketAddrV4>();\n+    assert_both::<net::SocketAddrV6>();\n+    assert_both::<net::Ipv4Addr>();\n+    assert_both::<net::Ipv6Addr>();\n }"}]}