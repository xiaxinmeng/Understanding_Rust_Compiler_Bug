{"sha": "6bb1b0dd3793db24fb1214640af72a5e8c66dded", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYjFiMGRkMzc5M2RiMjRmYjEyMTQ2NDBhZjcyYTVlOGM2NmRkZWQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-01-21T22:11:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-01-21T22:11:37Z"}, "message": "Rollup merge of #47247 - estebank:suggest-cast, r=petrochenkov\n\nSuggest casting on numeric type error\n\nRe #47168.", "tree": {"sha": "0a8c0fa34ad03dbb5dd8027500d4fe85ae5c4a49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a8c0fa34ad03dbb5dd8027500d4fe85ae5c4a49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bb1b0dd3793db24fb1214640af72a5e8c66dded", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bb1b0dd3793db24fb1214640af72a5e8c66dded", "html_url": "https://github.com/rust-lang/rust/commit/6bb1b0dd3793db24fb1214640af72a5e8c66dded", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bb1b0dd3793db24fb1214640af72a5e8c66dded/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97520ccb101609af63f29919bb0a39115269c89e", "url": "https://api.github.com/repos/rust-lang/rust/commits/97520ccb101609af63f29919bb0a39115269c89e", "html_url": "https://github.com/rust-lang/rust/commit/97520ccb101609af63f29919bb0a39115269c89e"}, {"sha": "71c08734a3ef12135ba695964e6fe882bc5e6d6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/71c08734a3ef12135ba695964e6fe882bc5e6d6e", "html_url": "https://github.com/rust-lang/rust/commit/71c08734a3ef12135ba695964e6fe882bc5e6d6e"}], "stats": {"total": 1831, "additions": 1717, "deletions": 114}, "files": [{"sha": "3da2855929d3ab56b95b7427785ddff976387b48", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=6bb1b0dd3793db24fb1214640af72a5e8c66dded", "patch": "@@ -34,13 +34,14 @@ use util::nodemap::{NodeMap, FxHashSet};\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n-use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n+use syntax::ast::{self, Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenStream;\n use syntax::util::ThinVec;\n+use syntax::util::parser::ExprPrecedence;\n use ty::AdtKind;\n \n use rustc_data_structures::indexed_vec;\n@@ -958,6 +959,31 @@ impl BinOp_ {\n     }\n }\n \n+impl Into<ast::BinOpKind> for BinOp_ {\n+    fn into(self) -> ast::BinOpKind {\n+        match self {\n+            BiAdd => ast::BinOpKind::Add,\n+            BiSub => ast::BinOpKind::Sub,\n+            BiMul => ast::BinOpKind::Mul,\n+            BiDiv => ast::BinOpKind::Div,\n+            BiRem => ast::BinOpKind::Rem,\n+            BiAnd => ast::BinOpKind::And,\n+            BiOr => ast::BinOpKind::Or,\n+            BiBitXor => ast::BinOpKind::BitXor,\n+            BiBitAnd => ast::BinOpKind::BitAnd,\n+            BiBitOr => ast::BinOpKind::BitOr,\n+            BiShl => ast::BinOpKind::Shl,\n+            BiShr => ast::BinOpKind::Shr,\n+            BiEq => ast::BinOpKind::Eq,\n+            BiLt => ast::BinOpKind::Lt,\n+            BiLe => ast::BinOpKind::Le,\n+            BiNe => ast::BinOpKind::Ne,\n+            BiGe => ast::BinOpKind::Ge,\n+            BiGt => ast::BinOpKind::Gt,\n+        }\n+    }\n+}\n+\n pub type BinOp = Spanned<BinOp_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -1166,6 +1192,42 @@ pub struct Expr {\n     pub hir_id: HirId,\n }\n \n+impl Expr {\n+    pub fn precedence(&self) -> ExprPrecedence {\n+        match self.node {\n+            ExprBox(_) => ExprPrecedence::Box,\n+            ExprArray(_) => ExprPrecedence::Array,\n+            ExprCall(..) => ExprPrecedence::Call,\n+            ExprMethodCall(..) => ExprPrecedence::MethodCall,\n+            ExprTup(_) => ExprPrecedence::Tup,\n+            ExprBinary(op, ..) => ExprPrecedence::Binary(op.node.into()),\n+            ExprUnary(..) => ExprPrecedence::Unary,\n+            ExprLit(_) => ExprPrecedence::Lit,\n+            ExprType(..) | ExprCast(..) => ExprPrecedence::Cast,\n+            ExprIf(..) => ExprPrecedence::If,\n+            ExprWhile(..) => ExprPrecedence::While,\n+            ExprLoop(..) => ExprPrecedence::Loop,\n+            ExprMatch(..) => ExprPrecedence::Match,\n+            ExprClosure(..) => ExprPrecedence::Closure,\n+            ExprBlock(..) => ExprPrecedence::Block,\n+            ExprAssign(..) => ExprPrecedence::Assign,\n+            ExprAssignOp(..) => ExprPrecedence::AssignOp,\n+            ExprField(..) => ExprPrecedence::Field,\n+            ExprTupField(..) => ExprPrecedence::TupField,\n+            ExprIndex(..) => ExprPrecedence::Index,\n+            ExprPath(..) => ExprPrecedence::Path,\n+            ExprAddrOf(..) => ExprPrecedence::AddrOf,\n+            ExprBreak(..) => ExprPrecedence::Break,\n+            ExprAgain(..) => ExprPrecedence::Continue,\n+            ExprRet(..) => ExprPrecedence::Ret,\n+            ExprInlineAsm(..) => ExprPrecedence::InlineAsm,\n+            ExprStruct(..) => ExprPrecedence::Struct,\n+            ExprRepeat(..) => ExprPrecedence::Repeat,\n+            ExprYield(..) => ExprPrecedence::Yield,\n+        }\n+    }\n+}\n+\n impl fmt::Debug for Expr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"expr({}: {})\", self.id,"}, {"sha": "4cfa7a470a4faaca1c78b742bc2502c7f905d45d", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 50, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=6bb1b0dd3793db24fb1214640af72a5e8c66dded", "patch": "@@ -1104,7 +1104,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_expr_maybe_paren(&mut self, expr: &hir::Expr, prec: i8) -> io::Result<()> {\n-        let needs_par = expr_precedence(expr) < prec;\n+        let needs_par = expr.precedence().order() < prec;\n         if needs_par {\n             self.popen()?;\n         }\n@@ -2318,55 +2318,6 @@ fn stmt_ends_with_semi(stmt: &hir::Stmt_) -> bool {\n     }\n }\n \n-\n-fn expr_precedence(expr: &hir::Expr) -> i8 {\n-    use syntax::util::parser::*;\n-\n-    match expr.node {\n-        hir::ExprClosure(..) => PREC_CLOSURE,\n-\n-        hir::ExprBreak(..) |\n-        hir::ExprAgain(..) |\n-        hir::ExprRet(..) |\n-        hir::ExprYield(..) => PREC_JUMP,\n-\n-        // Binop-like expr kinds, handled by `AssocOp`.\n-        hir::ExprBinary(op, _, _) => bin_op_to_assoc_op(op.node).precedence() as i8,\n-\n-        hir::ExprCast(..) => AssocOp::As.precedence() as i8,\n-        hir::ExprType(..) => AssocOp::Colon.precedence() as i8,\n-\n-        hir::ExprAssign(..) |\n-        hir::ExprAssignOp(..) => AssocOp::Assign.precedence() as i8,\n-\n-        // Unary, prefix\n-        hir::ExprBox(..) |\n-        hir::ExprAddrOf(..) |\n-        hir::ExprUnary(..) => PREC_PREFIX,\n-\n-        // Unary, postfix\n-        hir::ExprCall(..) |\n-        hir::ExprMethodCall(..) |\n-        hir::ExprField(..) |\n-        hir::ExprTupField(..) |\n-        hir::ExprIndex(..) |\n-        hir::ExprInlineAsm(..) => PREC_POSTFIX,\n-\n-        // Never need parens\n-        hir::ExprArray(..) |\n-        hir::ExprRepeat(..) |\n-        hir::ExprTup(..) |\n-        hir::ExprLit(..) |\n-        hir::ExprPath(..) |\n-        hir::ExprIf(..) |\n-        hir::ExprWhile(..) |\n-        hir::ExprLoop(..) |\n-        hir::ExprMatch(..) |\n-        hir::ExprBlock(..) |\n-        hir::ExprStruct(..) => PREC_PAREN,\n-    }\n-}\n-\n fn bin_op_to_assoc_op(op: hir::BinOp_) -> AssocOp {\n     use hir::BinOp_::*;\n     match op {"}, {"sha": "b6b863cfea6e66394a3f9749a447883eacb275ac", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 240, "deletions": 4, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=6bb1b0dd3793db24fb1214640af72a5e8c66dded", "patch": "@@ -15,6 +15,7 @@ use rustc::infer::InferOk;\n use rustc::traits::ObligationCause;\n \n use syntax::ast;\n+use syntax::util::parser::AssocOp;\n use syntax_pos::{self, Span};\n use rustc::hir;\n use rustc::hir::print;\n@@ -137,7 +138,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((msg, suggestion)) = self.check_ref(expr, checked_ty, expected) {\n             err.span_suggestion(expr.span, msg, suggestion);\n-        } else {\n+        } else if !self.check_for_cast(&mut err, expr, expr_ty, expected) {\n             let methods = self.get_conversion_methods(expected, checked_ty);\n             if let Ok(expr_text) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n                 let suggestions = iter::repeat(expr_text).zip(methods.iter())\n@@ -287,8 +288,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // Maybe remove `&`?\n                         hir::ExprAddrOf(_, ref expr) => {\n                             if let Ok(code) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n-                                return Some((\"consider removing the borrow\",\n-                                             code));\n+                                return Some((\"consider removing the borrow\", code));\n                             }\n                         }\n \n@@ -303,12 +303,248 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                  format!(\"*{}\", code)));\n                                 }\n                             }\n-                        },\n+                        }\n                     }\n                 }\n                 None\n             }\n             _ => None,\n         }\n     }\n+\n+    fn check_for_cast(&self,\n+                      err: &mut DiagnosticBuilder<'tcx>,\n+                      expr: &hir::Expr,\n+                      checked_ty: Ty<'tcx>,\n+                      expected_ty: Ty<'tcx>)\n+                      -> bool {\n+        let will_truncate = \"will truncate the source value\";\n+        let depending_on_isize = \"will truncate or zero-extend depending on the bit width of \\\n+                                  `isize`\";\n+        let depending_on_usize = \"will truncate or zero-extend depending on the bit width of \\\n+                                  `usize`\";\n+        let will_sign_extend = \"will sign-extend the source value\";\n+        let will_zero_extend = \"will zero-extend the source value\";\n+\n+        // If casting this expression to a given numeric type would be appropriate in case of a type\n+        // mismatch.\n+        //\n+        // We want to minimize the amount of casting operations that are suggested, as it can be a\n+        // lossy operation with potentially bad side effects, so we only suggest when encountering\n+        // an expression that indicates that the original type couldn't be directly changed.\n+        //\n+        // For now, don't suggest casting with `as`.\n+        let can_cast = false;\n+\n+        let needs_paren = expr.precedence().order() < (AssocOp::As.precedence() as i8);\n+\n+        if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n+            let msg = format!(\"you can cast an `{}` to `{}`\", checked_ty, expected_ty);\n+            let cast_suggestion = format!(\"{}{}{} as {}\",\n+                                          if needs_paren { \"(\" } else { \"\" },\n+                                          src,\n+                                          if needs_paren { \")\" } else { \"\" },\n+                                          expected_ty);\n+            let into_suggestion = format!(\"{}{}{}.into()\",\n+                                          if needs_paren { \"(\" } else { \"\" },\n+                                          src,\n+                                          if needs_paren { \")\" } else { \"\" });\n+\n+            match (&expected_ty.sty, &checked_ty.sty) {\n+                (&ty::TyInt(ref exp), &ty::TyInt(ref found)) => {\n+                    match (found.bit_width(), exp.bit_width()) {\n+                        (Some(found), Some(exp)) if found > exp => {\n+                            if can_cast {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                                    cast_suggestion);\n+                            }\n+                        }\n+                        (None, _) | (_, None) => {\n+                            if can_cast {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\",\n+                                                             msg,\n+                                                             depending_on_isize),\n+                                                    cast_suggestion);\n+                            }\n+                        }\n+                        _ => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                                into_suggestion);\n+                        }\n+                    }\n+                    true\n+                }\n+                (&ty::TyUint(ref exp), &ty::TyUint(ref found)) => {\n+                    match (found.bit_width(), exp.bit_width()) {\n+                        (Some(found), Some(exp)) if found > exp => {\n+                            if can_cast {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                                    cast_suggestion);\n+                            }\n+                        }\n+                        (None, _) | (_, None) => {\n+                            if can_cast {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\",\n+                                                             msg,\n+                                                             depending_on_usize),\n+                                                    cast_suggestion);\n+                            }\n+                        }\n+                        _ => {\n+                            err.span_suggestion(expr.span,\n+                                                &format!(\"{}, which {}\", msg, will_zero_extend),\n+                                                into_suggestion);\n+                        }\n+                    }\n+                    true\n+                }\n+                (&ty::TyInt(ref exp), &ty::TyUint(ref found)) => {\n+                    if can_cast {\n+                        match (found.bit_width(), exp.bit_width()) {\n+                            (Some(found), Some(exp)) if found > exp - 1 => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                                    cast_suggestion);\n+                            }\n+                            (None, None) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                                    cast_suggestion);\n+                            }\n+                            (None, _) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\",\n+                                                             msg,\n+                                                             depending_on_isize),\n+                                                    cast_suggestion);\n+                            }\n+                            (_, None) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\",\n+                                                             msg,\n+                                                             depending_on_usize),\n+                                                    cast_suggestion);\n+                            }\n+                            _ => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_zero_extend),\n+                                                    cast_suggestion);\n+                            }\n+                        }\n+                    }\n+                    true\n+                }\n+                (&ty::TyUint(ref exp), &ty::TyInt(ref found)) => {\n+                    if can_cast {\n+                        match (found.bit_width(), exp.bit_width()) {\n+                            (Some(found), Some(exp)) if found - 1 > exp => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                                    cast_suggestion);\n+                            }\n+                            (None, None) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                                    cast_suggestion);\n+                            }\n+                            (None, _) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\",\n+                                                             msg,\n+                                                             depending_on_usize),\n+                                                    cast_suggestion);\n+                            }\n+                            (_, None) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\",\n+                                                             msg,\n+                                                             depending_on_isize),\n+                                                    cast_suggestion);\n+                            }\n+                            _ => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                                    cast_suggestion);\n+                            }\n+                        }\n+                    }\n+                    true\n+                }\n+                (&ty::TyFloat(ref exp), &ty::TyFloat(ref found)) => {\n+                    if found.bit_width() < exp.bit_width() {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{} in a lossless way\",\n+                                                     msg),\n+                                            into_suggestion);\n+                    } else if can_cast {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, producing the closest possible value\",\n+                                                     msg),\n+                                            cast_suggestion);\n+                        err.warn(\"casting here will cause undefined behavior if the value is \\\n+                                  finite but larger or smaller than the largest or smallest \\\n+                                  finite value representable by `f32` (this is a bug and will be \\\n+                                  fixed)\");\n+                    }\n+                    true\n+                }\n+                (&ty::TyUint(_), &ty::TyFloat(_)) | (&ty::TyInt(_), &ty::TyFloat(_)) => {\n+                    if can_cast {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, rounding the float towards zero\",\n+                                                     msg),\n+                                            cast_suggestion);\n+                        err.warn(\"casting here will cause undefined behavior if the rounded value \\\n+                                  cannot be represented by the target integer type, including \\\n+                                  `Inf` and `NaN` (this is a bug and will be fixed)\");\n+                    }\n+                    true\n+                }\n+                (&ty::TyFloat(ref exp), &ty::TyUint(ref found)) => {\n+                    // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n+                    if exp.bit_width() > found.bit_width().unwrap_or(256) {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, producing the floating point \\\n+                                                      representation of the integer\",\n+                                                      msg),\n+                                            into_suggestion);\n+                    } else if can_cast {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, producing the floating point \\\n+                                                      representation of the integer, rounded if \\\n+                                                      necessary\",\n+                                                      msg),\n+                                            cast_suggestion);\n+                    }\n+                    true\n+                }\n+                (&ty::TyFloat(ref exp), &ty::TyInt(ref found)) => {\n+                    // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n+                    if exp.bit_width() > found.bit_width().unwrap_or(256) {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, producing the floating point \\\n+                                                      representation of the integer\",\n+                                                      msg),\n+                                            into_suggestion);\n+                    } else if can_cast {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, producing the floating point \\\n+                                                      representation of the integer, rounded if \\\n+                                                      necessary\",\n+                                                      msg),\n+                                            cast_suggestion);\n+                    }\n+                    true\n+                }\n+                _ => false,\n+            }\n+        } else {\n+            false\n+        }\n+    }\n }"}, {"sha": "a64f1e9e4002cc098a9718e46c2000ec1ef5081c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6bb1b0dd3793db24fb1214640af72a5e8c66dded", "patch": "@@ -15,6 +15,7 @@ pub use self::UnsafeSource::*;\n pub use self::PathParameters::*;\n pub use symbol::{Ident, Symbol as Name};\n pub use util::ThinVec;\n+pub use util::parser::ExprPrecedence;\n \n use syntax_pos::{Span, DUMMY_SP};\n use codemap::{respan, Spanned};\n@@ -730,6 +731,7 @@ impl BinOpKind {\n             _ => false\n         }\n     }\n+\n     pub fn is_comparison(&self) -> bool {\n         use self::BinOpKind::*;\n         match *self {\n@@ -740,6 +742,7 @@ impl BinOpKind {\n             false,\n         }\n     }\n+\n     /// Returns `true` if the binary operator takes its arguments by value\n     pub fn is_by_value(&self) -> bool {\n         !self.is_comparison()\n@@ -966,6 +969,49 @@ impl Expr {\n \n         Some(P(Ty { node, id: self.id, span: self.span }))\n     }\n+\n+    pub fn precedence(&self) -> ExprPrecedence {\n+        match self.node {\n+            ExprKind::Box(_) => ExprPrecedence::Box,\n+            ExprKind::InPlace(..) => ExprPrecedence::InPlace,\n+            ExprKind::Array(_) => ExprPrecedence::Array,\n+            ExprKind::Call(..) => ExprPrecedence::Call,\n+            ExprKind::MethodCall(..) => ExprPrecedence::MethodCall,\n+            ExprKind::Tup(_) => ExprPrecedence::Tup,\n+            ExprKind::Binary(op, ..) => ExprPrecedence::Binary(op.node),\n+            ExprKind::Unary(..) => ExprPrecedence::Unary,\n+            ExprKind::Lit(_) => ExprPrecedence::Lit,\n+            ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n+            ExprKind::If(..) => ExprPrecedence::If,\n+            ExprKind::IfLet(..) => ExprPrecedence::IfLet,\n+            ExprKind::While(..) => ExprPrecedence::While,\n+            ExprKind::WhileLet(..) => ExprPrecedence::WhileLet,\n+            ExprKind::ForLoop(..) => ExprPrecedence::ForLoop,\n+            ExprKind::Loop(..) => ExprPrecedence::Loop,\n+            ExprKind::Match(..) => ExprPrecedence::Match,\n+            ExprKind::Closure(..) => ExprPrecedence::Closure,\n+            ExprKind::Block(..) => ExprPrecedence::Block,\n+            ExprKind::Catch(..) => ExprPrecedence::Catch,\n+            ExprKind::Assign(..) => ExprPrecedence::Assign,\n+            ExprKind::AssignOp(..) => ExprPrecedence::AssignOp,\n+            ExprKind::Field(..) => ExprPrecedence::Field,\n+            ExprKind::TupField(..) => ExprPrecedence::TupField,\n+            ExprKind::Index(..) => ExprPrecedence::Index,\n+            ExprKind::Range(..) => ExprPrecedence::Range,\n+            ExprKind::Path(..) => ExprPrecedence::Path,\n+            ExprKind::AddrOf(..) => ExprPrecedence::AddrOf,\n+            ExprKind::Break(..) => ExprPrecedence::Break,\n+            ExprKind::Continue(..) => ExprPrecedence::Continue,\n+            ExprKind::Ret(..) => ExprPrecedence::Ret,\n+            ExprKind::InlineAsm(..) => ExprPrecedence::InlineAsm,\n+            ExprKind::Mac(..) => ExprPrecedence::Mac,\n+            ExprKind::Struct(..) => ExprPrecedence::Struct,\n+            ExprKind::Repeat(..) => ExprPrecedence::Repeat,\n+            ExprKind::Paren(..) => ExprPrecedence::Paren,\n+            ExprKind::Try(..) => ExprPrecedence::Try,\n+            ExprKind::Yield(..) => ExprPrecedence::Yield,\n+        }\n+    }\n }\n \n impl fmt::Debug for Expr {"}, {"sha": "ff065b57b8d0b45b557d30b00045f044795a989f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=6bb1b0dd3793db24fb1214640af72a5e8c66dded", "patch": "@@ -1839,7 +1839,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_expr_maybe_paren(&mut self, expr: &ast::Expr, prec: i8) -> io::Result<()> {\n-        let needs_par = parser::expr_precedence(expr) < prec;\n+        let needs_par = expr.precedence().order() < prec;\n         if needs_par {\n             self.popen()?;\n         }"}, {"sha": "86963c4000bd16c84e40a6c77a24e4f13b54b196", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 124, "deletions": 58, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=6bb1b0dd3793db24fb1214640af72a5e8c66dded", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n use parse::token::{Token, BinOpToken};\n use symbol::keywords;\n-use ast::{self, BinOpKind, ExprKind};\n+use ast::{self, BinOpKind};\n+\n+use std::cmp::Ordering;\n \n /// Associative operator with precedence.\n ///\n@@ -228,66 +230,130 @@ pub const PREC_POSTFIX: i8 = 60;\n pub const PREC_PAREN: i8 = 99;\n pub const PREC_FORCE_PAREN: i8 = 100;\n \n-pub fn expr_precedence(expr: &ast::Expr) -> i8 {\n-    match expr.node {\n-        ExprKind::Closure(..) => PREC_CLOSURE,\n-\n-        ExprKind::Break(..) |\n-        ExprKind::Continue(..) |\n-        ExprKind::Ret(..) |\n-        ExprKind::Yield(..) => PREC_JUMP,\n-\n-        // `Range` claims to have higher precedence than `Assign`, but `x .. x = x` fails to parse,\n-        // instead of parsing as `(x .. x) = x`.  Giving `Range` a lower precedence ensures that\n-        // `pprust` will add parentheses in the right places to get the desired parse.\n-        ExprKind::Range(..) => PREC_RANGE,\n-\n-        // Binop-like expr kinds, handled by `AssocOp`.\n-        ExprKind::Binary(op, _, _) =>\n-            AssocOp::from_ast_binop(op.node).precedence() as i8,\n-\n-        ExprKind::InPlace(..) => AssocOp::Inplace.precedence() as i8,\n-        ExprKind::Cast(..) => AssocOp::As.precedence() as i8,\n-        ExprKind::Type(..) => AssocOp::Colon.precedence() as i8,\n-\n-        ExprKind::Assign(..) |\n-        ExprKind::AssignOp(..) => AssocOp::Assign.precedence() as i8,\n-\n-        // Unary, prefix\n-        ExprKind::Box(..) |\n-        ExprKind::AddrOf(..) |\n-        ExprKind::Unary(..) => PREC_PREFIX,\n-\n-        // Unary, postfix\n-        ExprKind::Call(..) |\n-        ExprKind::MethodCall(..) |\n-        ExprKind::Field(..) |\n-        ExprKind::TupField(..) |\n-        ExprKind::Index(..) |\n-        ExprKind::Try(..) |\n-        ExprKind::InlineAsm(..) |\n-        ExprKind::Mac(..) => PREC_POSTFIX,\n-\n-        // Never need parens\n-        ExprKind::Array(..) |\n-        ExprKind::Repeat(..) |\n-        ExprKind::Tup(..) |\n-        ExprKind::Lit(..) |\n-        ExprKind::Path(..) |\n-        ExprKind::Paren(..) |\n-        ExprKind::If(..) |\n-        ExprKind::IfLet(..) |\n-        ExprKind::While(..) |\n-        ExprKind::WhileLet(..) |\n-        ExprKind::ForLoop(..) |\n-        ExprKind::Loop(..) |\n-        ExprKind::Match(..) |\n-        ExprKind::Block(..) |\n-        ExprKind::Catch(..) |\n-        ExprKind::Struct(..) => PREC_PAREN,\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum ExprPrecedence {\n+    Closure,\n+    Break,\n+    Continue,\n+    Ret,\n+    Yield,\n+\n+    Range,\n+\n+    Binary(BinOpKind),\n+\n+    InPlace,\n+    Cast,\n+    Type,\n+\n+    Assign,\n+    AssignOp,\n+\n+    Box,\n+    AddrOf,\n+    Unary,\n+\n+    Call,\n+    MethodCall,\n+    Field,\n+    TupField,\n+    Index,\n+    Try,\n+    InlineAsm,\n+    Mac,\n+\n+    Array,\n+    Repeat,\n+    Tup,\n+    Lit,\n+    Path,\n+    Paren,\n+    If,\n+    IfLet,\n+    While,\n+    WhileLet,\n+    ForLoop,\n+    Loop,\n+    Match,\n+    Block,\n+    Catch,\n+    Struct,\n+}\n+\n+impl PartialOrd for ExprPrecedence {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.order().cmp(&other.order()))\n+    }\n+}\n+\n+impl Ord for ExprPrecedence {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.order().cmp(&other.order())\n     }\n }\n \n+impl ExprPrecedence {\n+    pub fn order(self) -> i8 {\n+        match self {\n+            ExprPrecedence::Closure => PREC_CLOSURE,\n+\n+            ExprPrecedence::Break |\n+            ExprPrecedence::Continue |\n+            ExprPrecedence::Ret |\n+            ExprPrecedence::Yield => PREC_JUMP,\n+\n+            // `Range` claims to have higher precedence than `Assign`, but `x .. x = x` fails to\n+            // parse, instead of parsing as `(x .. x) = x`.  Giving `Range` a lower precedence\n+            // ensures that `pprust` will add parentheses in the right places to get the desired\n+            // parse.\n+            ExprPrecedence::Range => PREC_RANGE,\n+\n+            // Binop-like expr kinds, handled by `AssocOp`.\n+            ExprPrecedence::Binary(op) => AssocOp::from_ast_binop(op).precedence() as i8,\n+            ExprPrecedence::InPlace => AssocOp::Inplace.precedence() as i8,\n+            ExprPrecedence::Cast => AssocOp::As.precedence() as i8,\n+            ExprPrecedence::Type => AssocOp::Colon.precedence() as i8,\n+\n+            ExprPrecedence::Assign |\n+            ExprPrecedence::AssignOp => AssocOp::Assign.precedence() as i8,\n+\n+            // Unary, prefix\n+            ExprPrecedence::Box |\n+            ExprPrecedence::AddrOf |\n+            ExprPrecedence::Unary => PREC_PREFIX,\n+\n+            // Unary, postfix\n+            ExprPrecedence::Call |\n+            ExprPrecedence::MethodCall |\n+            ExprPrecedence::Field |\n+            ExprPrecedence::TupField |\n+            ExprPrecedence::Index |\n+            ExprPrecedence::Try |\n+            ExprPrecedence::InlineAsm |\n+            ExprPrecedence::Mac => PREC_POSTFIX,\n+\n+            // Never need parens\n+            ExprPrecedence::Array |\n+            ExprPrecedence::Repeat |\n+            ExprPrecedence::Tup |\n+            ExprPrecedence::Lit |\n+            ExprPrecedence::Path |\n+            ExprPrecedence::Paren |\n+            ExprPrecedence::If |\n+            ExprPrecedence::IfLet |\n+            ExprPrecedence::While |\n+            ExprPrecedence::WhileLet |\n+            ExprPrecedence::ForLoop |\n+            ExprPrecedence::Loop |\n+            ExprPrecedence::Match |\n+            ExprPrecedence::Block |\n+            ExprPrecedence::Catch |\n+            ExprPrecedence::Struct => PREC_PAREN,\n+        }\n+    }\n+}\n+\n+\n /// Expressions that syntactically contain an \"exterior\" struct literal i.e. not surrounded by any\n /// parens or other delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not."}, {"sha": "2092b6bce37c1733bcd4da00647779542b548eef", "filename": "src/test/ui/suggestions/numeric-cast-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.rs?ref=6bb1b0dd3793db24fb1214640af72a5e8c66dded", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo() -> i32 {\n+    4\n+}\n+fn main() {\n+    let x: u16 = foo();\n+    //~^ ERROR mismatched types\n+    let y: i64 = x + x;\n+    //~^ ERROR mismatched types\n+    let z: i32 = x + x;\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "90086d247d6e92764f3e2f925c54307d15ffaa61", "filename": "src/test/ui/suggestions/numeric-cast-2.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.stderr?ref=6bb1b0dd3793db24fb1214640af72a5e8c66dded", "patch": "@@ -0,0 +1,20 @@\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-2.rs:15:18\n+   |\n+15 |     let x: u16 = foo();\n+   |                  ^^^^^ expected u16, found i32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-2.rs:17:18\n+   |\n+17 |     let y: i64 = x + x;\n+   |                  ^^^^^ expected i64, found u16\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-2.rs:19:18\n+   |\n+19 |     let z: i32 = x + x;\n+   |                  ^^^^^ expected i32, found u16\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "6e144037ec2208a8eddf94dd5e7976696c862a4e", "filename": "src/test/ui/suggestions/numeric-cast.rs", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.rs?ref=6bb1b0dd3793db24fb1214640af72a5e8c66dded", "patch": "@@ -0,0 +1,315 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+fn foo<N>(_x: N) {}\n+\n+fn main() {\n+    let x_usize: usize = 1;\n+    let x_u64: u64 = 2;\n+    let x_u32: u32 = 3;\n+    let x_u16: u16 = 4;\n+    let x_u8: u8 = 5;\n+    let x_isize: isize = 6;\n+    let x_i64: i64 = 7;\n+    let x_i32: i32 = 8;\n+    let x_i16: i16 = 9;\n+    let x_i8: i8 = 10;\n+    let x_f64: f64 = 11.0;\n+    let x_f32: f32 = 12.0;\n+\n+    foo::<usize>(x_usize);\n+    foo::<usize>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<usize>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<isize>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_isize);\n+    foo::<isize>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<isize>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<u64>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_u64);\n+    foo::<u64>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<u64>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<i64>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_i64);\n+    foo::<i64>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<i64>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<u32>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_u32);\n+    foo::<u32>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<u32>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<i32>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_i32);\n+    foo::<i32>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<i32>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<u16>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_u16);\n+    foo::<u16>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<u16>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<i16>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_i16);\n+    foo::<i16>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<i16>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<u8>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_u8);\n+    foo::<u8>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<u8>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<i8>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_i8);\n+    foo::<i8>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<i8>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<f64>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<f64>(x_f64);\n+    foo::<f64>(x_f32);\n+    //~^ ERROR mismatched types\n+\n+    foo::<f32>(x_usize);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_u64);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_u32);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_u16);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_u8);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_isize);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_i64);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_i32);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_i16);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_i8);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_f64);\n+    //~^ ERROR mismatched types\n+    foo::<f32>(x_f32);\n+}"}, {"sha": "0ce3d087f350927d1048489aeb202938b5d86488", "filename": "src/test/ui/suggestions/numeric-cast.stderr", "status": "added", "additions": 886, "deletions": 0, "changes": 886, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1b0dd3793db24fb1214640af72a5e8c66dded/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.stderr?ref=6bb1b0dd3793db24fb1214640af72a5e8c66dded", "patch": "@@ -0,0 +1,886 @@\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:29:18\n+   |\n+29 |     foo::<usize>(x_u64);\n+   |                  ^^^^^ expected usize, found u64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:31:18\n+   |\n+31 |     foo::<usize>(x_u32);\n+   |                  ^^^^^ expected usize, found u32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:33:18\n+   |\n+33 |     foo::<usize>(x_u16);\n+   |                  ^^^^^ expected usize, found u16\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:35:18\n+   |\n+35 |     foo::<usize>(x_u8);\n+   |                  ^^^^ expected usize, found u8\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:37:18\n+   |\n+37 |     foo::<usize>(x_isize);\n+   |                  ^^^^^^^ expected usize, found isize\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:39:18\n+   |\n+39 |     foo::<usize>(x_i64);\n+   |                  ^^^^^ expected usize, found i64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:41:18\n+   |\n+41 |     foo::<usize>(x_i32);\n+   |                  ^^^^^ expected usize, found i32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:43:18\n+   |\n+43 |     foo::<usize>(x_i16);\n+   |                  ^^^^^ expected usize, found i16\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:45:18\n+   |\n+45 |     foo::<usize>(x_i8);\n+   |                  ^^^^ expected usize, found i8\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:47:18\n+   |\n+47 |     foo::<usize>(x_f64);\n+   |                  ^^^^^ expected usize, found f64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:49:18\n+   |\n+49 |     foo::<usize>(x_f32);\n+   |                  ^^^^^ expected usize, found f32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:52:18\n+   |\n+52 |     foo::<isize>(x_usize);\n+   |                  ^^^^^^^ expected isize, found usize\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:54:18\n+   |\n+54 |     foo::<isize>(x_u64);\n+   |                  ^^^^^ expected isize, found u64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:56:18\n+   |\n+56 |     foo::<isize>(x_u32);\n+   |                  ^^^^^ expected isize, found u32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:58:18\n+   |\n+58 |     foo::<isize>(x_u16);\n+   |                  ^^^^^ expected isize, found u16\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:60:18\n+   |\n+60 |     foo::<isize>(x_u8);\n+   |                  ^^^^ expected isize, found u8\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:63:18\n+   |\n+63 |     foo::<isize>(x_i64);\n+   |                  ^^^^^ expected isize, found i64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:65:18\n+   |\n+65 |     foo::<isize>(x_i32);\n+   |                  ^^^^^ expected isize, found i32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:67:18\n+   |\n+67 |     foo::<isize>(x_i16);\n+   |                  ^^^^^ expected isize, found i16\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:69:18\n+   |\n+69 |     foo::<isize>(x_i8);\n+   |                  ^^^^ expected isize, found i8\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:71:18\n+   |\n+71 |     foo::<isize>(x_f64);\n+   |                  ^^^^^ expected isize, found f64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:73:18\n+   |\n+73 |     foo::<isize>(x_f32);\n+   |                  ^^^^^ expected isize, found f32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:76:16\n+   |\n+76 |     foo::<u64>(x_usize);\n+   |                ^^^^^^^ expected u64, found usize\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:79:16\n+   |\n+79 |     foo::<u64>(x_u32);\n+   |                ^^^^^ expected u64, found u32\n+help: you can cast an `u32` to `u64`, which will zero-extend the source value\n+   |\n+79 |     foo::<u64>(x_u32.into());\n+   |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:81:16\n+   |\n+81 |     foo::<u64>(x_u16);\n+   |                ^^^^^ expected u64, found u16\n+help: you can cast an `u16` to `u64`, which will zero-extend the source value\n+   |\n+81 |     foo::<u64>(x_u16.into());\n+   |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:83:16\n+   |\n+83 |     foo::<u64>(x_u8);\n+   |                ^^^^ expected u64, found u8\n+help: you can cast an `u8` to `u64`, which will zero-extend the source value\n+   |\n+83 |     foo::<u64>(x_u8.into());\n+   |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:85:16\n+   |\n+85 |     foo::<u64>(x_isize);\n+   |                ^^^^^^^ expected u64, found isize\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:87:16\n+   |\n+87 |     foo::<u64>(x_i64);\n+   |                ^^^^^ expected u64, found i64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:89:16\n+   |\n+89 |     foo::<u64>(x_i32);\n+   |                ^^^^^ expected u64, found i32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:91:16\n+   |\n+91 |     foo::<u64>(x_i16);\n+   |                ^^^^^ expected u64, found i16\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:93:16\n+   |\n+93 |     foo::<u64>(x_i8);\n+   |                ^^^^ expected u64, found i8\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:95:16\n+   |\n+95 |     foo::<u64>(x_f64);\n+   |                ^^^^^ expected u64, found f64\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast.rs:97:16\n+   |\n+97 |     foo::<u64>(x_f32);\n+   |                ^^^^^ expected u64, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:100:16\n+    |\n+100 |     foo::<i64>(x_usize);\n+    |                ^^^^^^^ expected i64, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:102:16\n+    |\n+102 |     foo::<i64>(x_u64);\n+    |                ^^^^^ expected i64, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:104:16\n+    |\n+104 |     foo::<i64>(x_u32);\n+    |                ^^^^^ expected i64, found u32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:106:16\n+    |\n+106 |     foo::<i64>(x_u16);\n+    |                ^^^^^ expected i64, found u16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:108:16\n+    |\n+108 |     foo::<i64>(x_u8);\n+    |                ^^^^ expected i64, found u8\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:110:16\n+    |\n+110 |     foo::<i64>(x_isize);\n+    |                ^^^^^^^ expected i64, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:113:16\n+    |\n+113 |     foo::<i64>(x_i32);\n+    |                ^^^^^ expected i64, found i32\n+help: you can cast an `i32` to `i64`, which will sign-extend the source value\n+    |\n+113 |     foo::<i64>(x_i32.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:115:16\n+    |\n+115 |     foo::<i64>(x_i16);\n+    |                ^^^^^ expected i64, found i16\n+help: you can cast an `i16` to `i64`, which will sign-extend the source value\n+    |\n+115 |     foo::<i64>(x_i16.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:117:16\n+    |\n+117 |     foo::<i64>(x_i8);\n+    |                ^^^^ expected i64, found i8\n+help: you can cast an `i8` to `i64`, which will sign-extend the source value\n+    |\n+117 |     foo::<i64>(x_i8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:119:16\n+    |\n+119 |     foo::<i64>(x_f64);\n+    |                ^^^^^ expected i64, found f64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:121:16\n+    |\n+121 |     foo::<i64>(x_f32);\n+    |                ^^^^^ expected i64, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:124:16\n+    |\n+124 |     foo::<u32>(x_usize);\n+    |                ^^^^^^^ expected u32, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:126:16\n+    |\n+126 |     foo::<u32>(x_u64);\n+    |                ^^^^^ expected u32, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:129:16\n+    |\n+129 |     foo::<u32>(x_u16);\n+    |                ^^^^^ expected u32, found u16\n+help: you can cast an `u16` to `u32`, which will zero-extend the source value\n+    |\n+129 |     foo::<u32>(x_u16.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:131:16\n+    |\n+131 |     foo::<u32>(x_u8);\n+    |                ^^^^ expected u32, found u8\n+help: you can cast an `u8` to `u32`, which will zero-extend the source value\n+    |\n+131 |     foo::<u32>(x_u8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:133:16\n+    |\n+133 |     foo::<u32>(x_isize);\n+    |                ^^^^^^^ expected u32, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:135:16\n+    |\n+135 |     foo::<u32>(x_i64);\n+    |                ^^^^^ expected u32, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:137:16\n+    |\n+137 |     foo::<u32>(x_i32);\n+    |                ^^^^^ expected u32, found i32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:139:16\n+    |\n+139 |     foo::<u32>(x_i16);\n+    |                ^^^^^ expected u32, found i16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:141:16\n+    |\n+141 |     foo::<u32>(x_i8);\n+    |                ^^^^ expected u32, found i8\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:143:16\n+    |\n+143 |     foo::<u32>(x_f64);\n+    |                ^^^^^ expected u32, found f64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:145:16\n+    |\n+145 |     foo::<u32>(x_f32);\n+    |                ^^^^^ expected u32, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:148:16\n+    |\n+148 |     foo::<i32>(x_usize);\n+    |                ^^^^^^^ expected i32, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:150:16\n+    |\n+150 |     foo::<i32>(x_u64);\n+    |                ^^^^^ expected i32, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:152:16\n+    |\n+152 |     foo::<i32>(x_u32);\n+    |                ^^^^^ expected i32, found u32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:154:16\n+    |\n+154 |     foo::<i32>(x_u16);\n+    |                ^^^^^ expected i32, found u16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:156:16\n+    |\n+156 |     foo::<i32>(x_u8);\n+    |                ^^^^ expected i32, found u8\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:158:16\n+    |\n+158 |     foo::<i32>(x_isize);\n+    |                ^^^^^^^ expected i32, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:160:16\n+    |\n+160 |     foo::<i32>(x_i64);\n+    |                ^^^^^ expected i32, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:163:16\n+    |\n+163 |     foo::<i32>(x_i16);\n+    |                ^^^^^ expected i32, found i16\n+help: you can cast an `i16` to `i32`, which will sign-extend the source value\n+    |\n+163 |     foo::<i32>(x_i16.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:165:16\n+    |\n+165 |     foo::<i32>(x_i8);\n+    |                ^^^^ expected i32, found i8\n+help: you can cast an `i8` to `i32`, which will sign-extend the source value\n+    |\n+165 |     foo::<i32>(x_i8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:167:16\n+    |\n+167 |     foo::<i32>(x_f64);\n+    |                ^^^^^ expected i32, found f64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:169:16\n+    |\n+169 |     foo::<i32>(x_f32);\n+    |                ^^^^^ expected i32, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:172:16\n+    |\n+172 |     foo::<u16>(x_usize);\n+    |                ^^^^^^^ expected u16, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:174:16\n+    |\n+174 |     foo::<u16>(x_u64);\n+    |                ^^^^^ expected u16, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:176:16\n+    |\n+176 |     foo::<u16>(x_u32);\n+    |                ^^^^^ expected u16, found u32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:179:16\n+    |\n+179 |     foo::<u16>(x_u8);\n+    |                ^^^^ expected u16, found u8\n+help: you can cast an `u8` to `u16`, which will zero-extend the source value\n+    |\n+179 |     foo::<u16>(x_u8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:181:16\n+    |\n+181 |     foo::<u16>(x_isize);\n+    |                ^^^^^^^ expected u16, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:183:16\n+    |\n+183 |     foo::<u16>(x_i64);\n+    |                ^^^^^ expected u16, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:185:16\n+    |\n+185 |     foo::<u16>(x_i32);\n+    |                ^^^^^ expected u16, found i32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:187:16\n+    |\n+187 |     foo::<u16>(x_i16);\n+    |                ^^^^^ expected u16, found i16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:189:16\n+    |\n+189 |     foo::<u16>(x_i8);\n+    |                ^^^^ expected u16, found i8\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:191:16\n+    |\n+191 |     foo::<u16>(x_f64);\n+    |                ^^^^^ expected u16, found f64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:193:16\n+    |\n+193 |     foo::<u16>(x_f32);\n+    |                ^^^^^ expected u16, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:196:16\n+    |\n+196 |     foo::<i16>(x_usize);\n+    |                ^^^^^^^ expected i16, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:198:16\n+    |\n+198 |     foo::<i16>(x_u64);\n+    |                ^^^^^ expected i16, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:200:16\n+    |\n+200 |     foo::<i16>(x_u32);\n+    |                ^^^^^ expected i16, found u32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:202:16\n+    |\n+202 |     foo::<i16>(x_u16);\n+    |                ^^^^^ expected i16, found u16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:204:16\n+    |\n+204 |     foo::<i16>(x_u8);\n+    |                ^^^^ expected i16, found u8\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:206:16\n+    |\n+206 |     foo::<i16>(x_isize);\n+    |                ^^^^^^^ expected i16, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:208:16\n+    |\n+208 |     foo::<i16>(x_i64);\n+    |                ^^^^^ expected i16, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:210:16\n+    |\n+210 |     foo::<i16>(x_i32);\n+    |                ^^^^^ expected i16, found i32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:213:16\n+    |\n+213 |     foo::<i16>(x_i8);\n+    |                ^^^^ expected i16, found i8\n+help: you can cast an `i8` to `i16`, which will sign-extend the source value\n+    |\n+213 |     foo::<i16>(x_i8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:215:16\n+    |\n+215 |     foo::<i16>(x_f64);\n+    |                ^^^^^ expected i16, found f64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:217:16\n+    |\n+217 |     foo::<i16>(x_f32);\n+    |                ^^^^^ expected i16, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:220:15\n+    |\n+220 |     foo::<u8>(x_usize);\n+    |               ^^^^^^^ expected u8, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:222:15\n+    |\n+222 |     foo::<u8>(x_u64);\n+    |               ^^^^^ expected u8, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:224:15\n+    |\n+224 |     foo::<u8>(x_u32);\n+    |               ^^^^^ expected u8, found u32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:226:15\n+    |\n+226 |     foo::<u8>(x_u16);\n+    |               ^^^^^ expected u8, found u16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:229:15\n+    |\n+229 |     foo::<u8>(x_isize);\n+    |               ^^^^^^^ expected u8, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:231:15\n+    |\n+231 |     foo::<u8>(x_i64);\n+    |               ^^^^^ expected u8, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:233:15\n+    |\n+233 |     foo::<u8>(x_i32);\n+    |               ^^^^^ expected u8, found i32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:235:15\n+    |\n+235 |     foo::<u8>(x_i16);\n+    |               ^^^^^ expected u8, found i16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:237:15\n+    |\n+237 |     foo::<u8>(x_i8);\n+    |               ^^^^ expected u8, found i8\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:239:15\n+    |\n+239 |     foo::<u8>(x_f64);\n+    |               ^^^^^ expected u8, found f64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:241:15\n+    |\n+241 |     foo::<u8>(x_f32);\n+    |               ^^^^^ expected u8, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:244:15\n+    |\n+244 |     foo::<i8>(x_usize);\n+    |               ^^^^^^^ expected i8, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:246:15\n+    |\n+246 |     foo::<i8>(x_u64);\n+    |               ^^^^^ expected i8, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:248:15\n+    |\n+248 |     foo::<i8>(x_u32);\n+    |               ^^^^^ expected i8, found u32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:250:15\n+    |\n+250 |     foo::<i8>(x_u16);\n+    |               ^^^^^ expected i8, found u16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:252:15\n+    |\n+252 |     foo::<i8>(x_u8);\n+    |               ^^^^ expected i8, found u8\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:254:15\n+    |\n+254 |     foo::<i8>(x_isize);\n+    |               ^^^^^^^ expected i8, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:256:15\n+    |\n+256 |     foo::<i8>(x_i64);\n+    |               ^^^^^ expected i8, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:258:15\n+    |\n+258 |     foo::<i8>(x_i32);\n+    |               ^^^^^ expected i8, found i32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:260:15\n+    |\n+260 |     foo::<i8>(x_i16);\n+    |               ^^^^^ expected i8, found i16\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:263:15\n+    |\n+263 |     foo::<i8>(x_f64);\n+    |               ^^^^^ expected i8, found f64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:265:15\n+    |\n+265 |     foo::<i8>(x_f32);\n+    |               ^^^^^ expected i8, found f32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:268:16\n+    |\n+268 |     foo::<f64>(x_usize);\n+    |                ^^^^^^^ expected f64, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:270:16\n+    |\n+270 |     foo::<f64>(x_u64);\n+    |                ^^^^^ expected f64, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:272:16\n+    |\n+272 |     foo::<f64>(x_u32);\n+    |                ^^^^^ expected f64, found u32\n+help: you can cast an `u32` to `f64`, producing the floating point representation of the integer\n+    |\n+272 |     foo::<f64>(x_u32.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:274:16\n+    |\n+274 |     foo::<f64>(x_u16);\n+    |                ^^^^^ expected f64, found u16\n+help: you can cast an `u16` to `f64`, producing the floating point representation of the integer\n+    |\n+274 |     foo::<f64>(x_u16.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:276:16\n+    |\n+276 |     foo::<f64>(x_u8);\n+    |                ^^^^ expected f64, found u8\n+help: you can cast an `u8` to `f64`, producing the floating point representation of the integer\n+    |\n+276 |     foo::<f64>(x_u8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:278:16\n+    |\n+278 |     foo::<f64>(x_isize);\n+    |                ^^^^^^^ expected f64, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:280:16\n+    |\n+280 |     foo::<f64>(x_i64);\n+    |                ^^^^^ expected f64, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:282:16\n+    |\n+282 |     foo::<f64>(x_i32);\n+    |                ^^^^^ expected f64, found i32\n+help: you can cast an `i32` to `f64`, producing the floating point representation of the integer\n+    |\n+282 |     foo::<f64>(x_i32.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:284:16\n+    |\n+284 |     foo::<f64>(x_i16);\n+    |                ^^^^^ expected f64, found i16\n+help: you can cast an `i16` to `f64`, producing the floating point representation of the integer\n+    |\n+284 |     foo::<f64>(x_i16.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:286:16\n+    |\n+286 |     foo::<f64>(x_i8);\n+    |                ^^^^ expected f64, found i8\n+help: you can cast an `i8` to `f64`, producing the floating point representation of the integer\n+    |\n+286 |     foo::<f64>(x_i8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:289:16\n+    |\n+289 |     foo::<f64>(x_f32);\n+    |                ^^^^^ expected f64, found f32\n+help: you can cast an `f32` to `f64` in a lossless way\n+    |\n+289 |     foo::<f64>(x_f32.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:292:16\n+    |\n+292 |     foo::<f32>(x_usize);\n+    |                ^^^^^^^ expected f32, found usize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:294:16\n+    |\n+294 |     foo::<f32>(x_u64);\n+    |                ^^^^^ expected f32, found u64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:296:16\n+    |\n+296 |     foo::<f32>(x_u32);\n+    |                ^^^^^ expected f32, found u32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:298:16\n+    |\n+298 |     foo::<f32>(x_u16);\n+    |                ^^^^^ expected f32, found u16\n+help: you can cast an `u16` to `f32`, producing the floating point representation of the integer\n+    |\n+298 |     foo::<f32>(x_u16.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:300:16\n+    |\n+300 |     foo::<f32>(x_u8);\n+    |                ^^^^ expected f32, found u8\n+help: you can cast an `u8` to `f32`, producing the floating point representation of the integer\n+    |\n+300 |     foo::<f32>(x_u8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:302:16\n+    |\n+302 |     foo::<f32>(x_isize);\n+    |                ^^^^^^^ expected f32, found isize\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:304:16\n+    |\n+304 |     foo::<f32>(x_i64);\n+    |                ^^^^^ expected f32, found i64\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:306:16\n+    |\n+306 |     foo::<f32>(x_i32);\n+    |                ^^^^^ expected f32, found i32\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:308:16\n+    |\n+308 |     foo::<f32>(x_i16);\n+    |                ^^^^^ expected f32, found i16\n+help: you can cast an `i16` to `f32`, producing the floating point representation of the integer\n+    |\n+308 |     foo::<f32>(x_i16.into());\n+    |                ^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:310:16\n+    |\n+310 |     foo::<f32>(x_i8);\n+    |                ^^^^ expected f32, found i8\n+help: you can cast an `i8` to `f32`, producing the floating point representation of the integer\n+    |\n+310 |     foo::<f32>(x_i8.into());\n+    |                ^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+   --> $DIR/numeric-cast.rs:312:16\n+    |\n+312 |     foo::<f32>(x_f64);\n+    |                ^^^^^ expected f32, found f64\n+\n+error: aborting due to 132 previous errors\n+"}]}