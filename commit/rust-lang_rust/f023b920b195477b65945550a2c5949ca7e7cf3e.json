{"sha": "f023b920b195477b65945550a2c5949ca7e7cf3e", "node_id": "C_kwDOAAsO6NoAKGYwMjNiOTIwYjE5NTQ3N2I2NTk0NTU1MGEyYzU5NDljYTdlN2NmM2U", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-05-27T22:20:21Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-06-01T17:41:50Z"}, "message": "Rework `prohibit_generics`", "tree": {"sha": "bcc5ed07d0a8b681f555321f84445ec688a867bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcc5ed07d0a8b681f555321f84445ec688a867bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f023b920b195477b65945550a2c5949ca7e7cf3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f023b920b195477b65945550a2c5949ca7e7cf3e", "html_url": "https://github.com/rust-lang/rust/commit/f023b920b195477b65945550a2c5949ca7e7cf3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f023b920b195477b65945550a2c5949ca7e7cf3e/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "395a09c3dafe0c7838c9ca41d2b47bb5e79a5b6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/395a09c3dafe0c7838c9ca41d2b47bb5e79a5b6d", "html_url": "https://github.com/rust-lang/rust/commit/395a09c3dafe0c7838c9ca41d2b47bb5e79a5b6d"}], "stats": {"total": 140, "additions": 75, "deletions": 65}, "files": [{"sha": "492e9609f96ff45ab4067277b530e46325b1328e", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 75, "deletions": 65, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/f023b920b195477b65945550a2c5949ca7e7cf3e/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f023b920b195477b65945550a2c5949ca7e7cf3e/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=f023b920b195477b65945550a2c5949ca7e7cf3e", "patch": "@@ -16,7 +16,7 @@ use crate::require_c_abi_if_c_variadic;\n use rustc_ast::TraitObjectSyntax;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{\n-    struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError,\n+    struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError, MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n@@ -653,7 +653,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             span, item_def_id, item_segment\n         );\n         if tcx.generics_of(item_def_id).params.is_empty() {\n-            self.prohibit_generics(slice::from_ref(item_segment));\n+            self.prohibit_generics(slice::from_ref(item_segment).iter());\n \n             parent_substs\n         } else {\n@@ -681,7 +681,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         trait_ref: &hir::TraitRef<'_>,\n         self_ty: Ty<'tcx>,\n     ) -> ty::TraitRef<'tcx> {\n-        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n+        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1.iter());\n \n         self.ast_path_to_mono_trait_ref(\n             trait_ref.path.span,\n@@ -784,7 +784,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let args = trait_segment.args();\n         let infer_args = trait_segment.infer_args;\n \n-        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n+        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1.iter());\n         self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment, false);\n \n         self.instantiate_poly_trait_ref_inner(\n@@ -1796,7 +1796,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 if let Some(variant_def) = variant_def {\n                     if permit_variants {\n                         tcx.check_stability(variant_def.def_id, Some(hir_ref_id), span, None);\n-                        self.prohibit_generics(slice::from_ref(assoc_segment));\n+                        self.prohibit_generics(slice::from_ref(assoc_segment).iter());\n                         return Ok((qself_ty, DefKind::Variant, variant_def.def_id));\n                     } else {\n                         variant_resolution = Some(variant_def.def_id);\n@@ -2017,69 +2017,79 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self.normalize_ty(span, tcx.mk_projection(item_def_id, item_substs))\n     }\n \n-    pub fn prohibit_generics<'a, T: IntoIterator<Item = &'a hir::PathSegment<'a>>>(\n+    pub fn prohibit_generics<'a, T: Iterator<Item = &'a hir::PathSegment<'a>> + Clone>(\n         &self,\n         segments: T,\n     ) -> bool {\n-        let mut has_err = false;\n-        for segment in segments {\n-            let (mut err_for_lt, mut err_for_ty, mut err_for_ct) = (false, false, false);\n-            for arg in segment.args().args {\n-                let (span, kind) = match arg {\n-                    hir::GenericArg::Lifetime(lt) => {\n-                        if err_for_lt {\n-                            continue;\n-                        }\n-                        err_for_lt = true;\n-                        has_err = true;\n-                        (lt.span, \"lifetime\")\n-                    }\n-                    hir::GenericArg::Type(ty) => {\n-                        if err_for_ty {\n-                            continue;\n-                        }\n-                        err_for_ty = true;\n-                        has_err = true;\n-                        (ty.span, \"type\")\n-                    }\n-                    hir::GenericArg::Const(ct) => {\n-                        if err_for_ct {\n-                            continue;\n-                        }\n-                        err_for_ct = true;\n-                        has_err = true;\n-                        (ct.span, \"const\")\n-                    }\n-                    hir::GenericArg::Infer(inf) => {\n-                        if err_for_ty {\n-                            continue;\n-                        }\n-                        has_err = true;\n-                        err_for_ty = true;\n-                        (inf.span, \"generic\")\n-                    }\n-                };\n-                let mut err = struct_span_err!(\n-                    self.tcx().sess,\n-                    span,\n-                    E0109,\n-                    \"{} arguments are not allowed for this type\",\n-                    kind,\n-                );\n-                err.span_label(span, format!(\"{} argument not allowed\", kind));\n-                err.emit();\n-                if err_for_lt && err_for_ty && err_for_ct {\n-                    break;\n-                }\n+        let args = segments.clone().flat_map(|segment| segment.args().args);\n+\n+        let (lt, ty, ct, inf) =\n+            args.clone().fold((false, false, false, false), |(lt, ty, ct, inf), arg| match arg {\n+                hir::GenericArg::Lifetime(_) => (true, ty, ct, inf),\n+                hir::GenericArg::Type(_) => (lt, true, ct, inf),\n+                hir::GenericArg::Const(_) => (lt, ty, true, inf),\n+                hir::GenericArg::Infer(_) => (lt, ty, ct, true),\n+            });\n+        let mut emitted = false;\n+        if lt || ty || ct || inf {\n+            let arg_spans: Vec<Span> = args\n+                .map(|arg| match arg {\n+                    hir::GenericArg::Lifetime(lt) => lt.span,\n+                    hir::GenericArg::Type(ty) => ty.span,\n+                    hir::GenericArg::Const(ct) => ct.span,\n+                    hir::GenericArg::Infer(inf) => inf.span,\n+                })\n+                .collect();\n+\n+            let mut types = Vec::with_capacity(4);\n+            if lt {\n+                types.push(\"lifetime\");\n+            }\n+            if ty {\n+                types.push(\"type\");\n+            }\n+            if ct {\n+                types.push(\"const\");\n             }\n+            if inf {\n+                types.push(\"generic\");\n+            }\n+            let (kind, s) = match types[..] {\n+                [.., _, last] => (\n+                    format!(\n+                        \"{} and `{last}`\",\n+                        types[..types.len() - 1]\n+                            .iter()\n+                            .map(|&x| x)\n+                            .intersperse(\", \")\n+                            .collect::<String>()\n+                    ),\n+                    \"s\",\n+                ),\n+                [only] => (format!(\"{only}\"), \"\"),\n+                [] => unreachable!(),\n+            };\n+            let last_span = *arg_spans.last().unwrap();\n+            let span: MultiSpan = arg_spans.into();\n+            let mut err = struct_span_err!(\n+                self.tcx().sess,\n+                span,\n+                E0109,\n+                \"{kind} arguments are not allowed for this type\",\n+            );\n+            err.span_label(last_span, format!(\"{kind} argument{s} not allowed\"));\n+            err.emit();\n+            emitted = true;\n+        }\n \n+        for segment in segments {\n             // Only emit the first error to avoid overloading the user with error messages.\n             if let [binding, ..] = segment.args().bindings {\n-                has_err = true;\n                 Self::prohibit_assoc_ty_binding(self.tcx(), binding.span);\n+                return true;\n             }\n         }\n-        has_err\n+        emitted\n     }\n \n     // FIXME(eddyb, varkor) handle type paths here too, not just value ones.\n@@ -2229,7 +2239,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // Check for desugared `impl Trait`.\n                 assert!(ty::is_impl_trait_defn(tcx, did).is_none());\n                 let item_segment = path.segments.split_last().unwrap();\n-                self.prohibit_generics(item_segment.1);\n+                self.prohibit_generics(item_segment.1.iter());\n                 let substs = self.ast_path_substs_for_ty(span, did, item_segment.0);\n                 self.normalize_ty(span, tcx.mk_opaque(did, substs))\n             }\n@@ -2242,7 +2252,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 did,\n             ) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments.split_last().unwrap().1);\n+                self.prohibit_generics(path.segments.split_last().unwrap().1.iter());\n                 self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n             Res::Def(kind @ DefKind::Variant, def_id) if permit_variants => {\n@@ -2265,7 +2275,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::Def(DefKind::TyParam, def_id) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments);\n+                self.prohibit_generics(path.segments.iter());\n \n                 let def_id = def_id.expect_local();\n                 let item_def_id = tcx.hir().ty_param_owner(def_id);\n@@ -2276,13 +2286,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             Res::SelfTy { trait_: Some(_), alias_to: None } => {\n                 // `Self` in trait or type alias.\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments);\n+                self.prohibit_generics(path.segments.iter());\n                 tcx.types.self_param\n             }\n             Res::SelfTy { trait_: _, alias_to: Some((def_id, forbid_generic)) } => {\n                 // `Self` in impl (we know the concrete type).\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments);\n+                self.prohibit_generics(path.segments.iter());\n                 // Try to evaluate any array length constants.\n                 let ty = tcx.at(span).type_of(def_id);\n                 // HACK(min_const_generics): Forbid generic `Self` types\n@@ -2324,7 +2334,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::Def(DefKind::AssocTy, def_id) => {\n                 debug_assert!(path.segments.len() >= 2);\n-                self.prohibit_generics(&path.segments[..path.segments.len() - 2]);\n+                self.prohibit_generics(path.segments[..path.segments.len() - 2].iter());\n                 self.qpath_to_ty(\n                     span,\n                     opt_self_ty,\n@@ -2335,7 +2345,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::PrimTy(prim_ty) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments);\n+                self.prohibit_generics(path.segments.iter());\n                 match prim_ty {\n                     hir::PrimTy::Bool => tcx.types.bool,\n                     hir::PrimTy::Char => tcx.types.char,"}]}